code,godclass,dataclass,longmethod,longparamlist
"public class FileSystemFactoryBean implements InitializingBean, DisposableBean, FactoryBean<FileSystem> {
	private FileSystem fs;
	private Configuration configuration;
	private URI uri;
	private String user;
	private boolean closeAll = false;
	private boolean close = true;
	public void afterPropertiesSet() throws Exception {
		Configuration cfg = (configuration != null ? configuration : new Configuration(true));
		if (uri == null) {
			uri = FileSystem.getDefaultUri(cfg);
		}
		if (StringUtils.hasText(user)) {
			fs = FileSystem.get(uri, cfg, user);
		}
		else {
			fs = FileSystem.get(uri, cfg);
		}
	}
	public void destroy() throws Exception {
		if (fs != null && close) {
			fs.close();
		}
		fs = null;
		if (closeAll) {
			FileSystem.closeAll();
		}
	}
	public FileSystem getObject() throws Exception {
		return fs;
	}
	public Class<?> getObjectType() {
		return (fs != null ? fs.getClass() : FileSystem.class);
	}
	public boolean isSingleton() {
		return true;
	}
	public void setConfiguration(Configuration configuration) {
		this.configuration = configuration;
	}
	public void setUri(URI uri) {
		this.uri = uri;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public void setCloseAll(boolean closeAll) {
		this.closeAll = closeAll;
	}
	public void setClose(boolean close) {
		this.close = close;
	}
}",0,1,0,0
"public static String hexToBase64(String value) throws DecoderException, UnsupportedEncodingException {
	 String base64Value = null;
	 if (value != null) {
		 base64Value = new String(Base64.encodeBase64(Hex.decodeHex(value.toCharArray())), ""UTF-8"");
	 }
	 return base64Value;
 }",0,0,0,0
"public boolean execute (MessageState msgState, String param) {
	if (isPunished (msgState)) return false;
	String grpname = null;
	boolean mayKick = msgState.sender.hasRight(IUserStates.MAY_KICK);
	if (!mayKick) {
		 msgState.msgTemplate = ""error.noRight.noVipAdmin"";
		 msgState.sender.sendMessage(msgState.mp);
		 return false;
	 }
	 int pos1 = param.indexOf("" "");
	 int pos2 = param.indexOf("":"");
	 boolean multiUser = (pos1!=-1 && (pos2 > pos1+1 || pos2==-1));
	 if (multiUser && !msgState.sender.hasRight(IUserStates.ROLE_VIP)) {
		 msgState.msgTemplate=""error.mass.noRight.noVipAdmin"";
		 msgState.sender.sendMessage (msgState.mp);
		 return false;
	 }
	if (pos2>-1) {
		 String parts[] = param.split ("":"");
		param = parts[0];
		msgState.targetGroup = GroupManager.mgr.getGroup(parts[1]);
		grpname = parts[1];
	}
	 else {
		 msgState.msgTemplate = ""error.kc.noroom"";
		 msgState.sender.sendMessage(msgState.mp);
		 return false;
	 }
	 Vector<User> found = getMultibleUsers(msgState, param);
	 boolean created = false;
	 GroupUserList gul = new GroupUserList();
	 msgState.useRenderCache=false;
	 for (Iterator<User> i = found.iterator();
	 i.hasNext();
	 ) {
		 User cu = (User) i.next();
		 msgState.sourceGroup = cu.getGroup();
		 if (cu.hasRight(IUserStates.ROLE_GOD)) {
			 msgState.usercontext = cu;
			 msgState.msgTemplate = ""error.noRight.isAdmin"";
			 msgState.sender.sendMessage(msgState.mp);
			 i.remove();
			 msgState.param = grpname;
			 msgState.msgTemplate = ""message.kc.godinfo"";
			 cu.sendMessage(msgState.mp);
			 continue;
		 }
		 else if (cu.hasRight(IUserStates.ROLE_VIP) && !msgState.sender.hasRight(IUserStates.ROLE_GOD)) {
			 msgState.usercontext = cu;
			 msgState.msgTemplate = ""error.noRight.isVip"";
			 msgState.sender.sendMessage(msgState.mp);
			 i.remove();
			 continue;
		 }
		 else if (cu.hasRight(IUserStates.PROTECTED_FROM_KICK) && !msgState.sender.hasRight(IUserStates.ROLE_GOD)) {
			 msgState.msgTemplate = ""error.k.protected"";
			 msgState.usercontext = cu;
			 msgState.sender.sendMessage(msgState.mp);
			 i.remove();
			 continue;
		 }
		 else if (!msgState.sender.hasRight(IUserStates.ROLE_GOD) && !isVip (msgState.sender, cu.getGroup(), msgState)) {
			 msgState.targetGroup = cu.getGroup();
			 if (msgState.usrList.length > 1) msgState.msgTemplate = ""error.membership.notMember.many"";
			 else msgState.msgTemplate = ""error.membership.notMember"";
			 msgState.usercontext=cu;
			 msgState.sender.sendMessage(msgState.mp);
			 i.remove();
			 continue;
		 }
		 if (msgState.targetGroup == null) {
			 msgState.targetGroup = GroupManager.mgr.openGroup (grpname, ""punished users here"", cu, msgState.sender);
			 if (msgState.targetGroup == null) {
				 msgState.param = """";
				 msgState.usercontext = cu;
				 msgState.msgTemplate = ""error.k.noGroupRight"";
				 msgState.sender.sendMessage(msgState.mp);
				 return false;
			 }
			 created=true;
		 }
		 else if (!msgState.targetGroup.usrMayJoin(msgState.sender)) {
			 msgState.param = """";
			 msgState.usercontext = cu;
			 msgState.msgTemplate = ""error.k.noGroupRight"";
			 msgState.sender.sendMessage (msgState.mp);
			 return false;
		 }
		 msgState.usercontext = cu;
		 gul.addUser(cu);
		 msgState.targetGroup.addUser(cu, msgState.sender);
		 msgState.targetGroup.removeFromSusers(cu);
		 msgState.msgTemplate = ""message.kc.personal"";
		 cu.sendMessage(msgState.mp);
	 }
	if (found.size()==0) return false;
	if (found.size()==1) {
		 msgState.msgTemplate=""message.kc.destination.singular"";
		 msgState.targetGroup.exclusiveSendMessage(msgState.mp, found);
		 if (!msgState.sender.getGroup().equals(msgState.sourceGroup)) {
			 msgState.msgTemplate=""message.kc.confirm.singular"";
			 msgState.sender.sendMessage(msgState.mp);
		 }
		 if (msgState.sourceGroup != null) {
			 msgState.msgTemplate=""message.kc.singular"";
			 msgState.sourceGroup.sendMessage(msgState.mp);
		 }
		 return true;
	 }
	 msgState.usrList = found.toArray();
	 gul.sendMessage(msgState, ""message.kc"", false);
	msgState.msgTemplate=""message.kc.destination.plural"";
	 msgState.targetGroup.exclusiveSendMessage(msgState.mp, found);
	 msgState.msgTemplate=""message.kc.confirm.plural"";
	 msgState.sender.sendMessage(msgState.mp);
	return true;
}",0,0,1,0
"public class FileSinkOptionsMetadata implements ProfileNamesProvider {
	private static final String USE_SPEL_PROFILE = ""use-expression"";
	private static final String USE_LITERAL_STRING_PROFILE = ""use-string"";
	private boolean binary = false;
	private String charset = ""UTF-8"";
	private String dir = ""/tmp/xd/output/"";
	private String name = XD_STREAM_NAME;
	private String suffix = ""out"";
	private Mode mode = APPEND;
	private String nameExpression;
	private String dirExpression;
	public Mode getMode() {
		return mode;
	}
	public void setMode(Mode mode) {
		this.mode = mode;
	}
	public String getExtensionWithDot() {
		return StringUtils.hasText(suffix) ? ""."" + suffix.trim() : """";
	}
	public void setSuffix(String suffix) {
		this.suffix = suffix;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDir() {
		return dir;
	}
	public void setDir(String dir) {
		this.dir = dir;
	}
	public boolean isBinary() {
		return binary;
	}
	public void setBinary(boolean binary) {
		this.binary = binary;
	}
	public void setCharset(String charset) {
		this.charset = charset;
	}
	public String getCharset() {
		return charset;
	}
	public String getNameExpression() {
		return nameExpression;
	}
	public void setNameExpression(String nameExpression) {
		this.nameExpression = nameExpression;
	}
	public String getDirExpression() {
		return dirExpression;
	}
	public void setDirExpression(String dirExpression) {
		this.dirExpression = dirExpression;
	}
	public static enum Mode {
		APPEND, REPLACE, FAIL, IGNORE;
	}
	public String[] profilesToActivate() {
		return (nameExpression != null || dirExpression != null) ? new String[] {
		 USE_SPEL_PROFILE }
		: new String[] {
		 USE_LITERAL_STRING_PROFILE }
		;
	}
}",1,1,0,0
"public void execute() throws BuildException {
	 if (usedMatchingTask) {
		 log(""DEPRECATED - Use of the implicit FileSet is deprecated. "" + ""Use a nested fileset element instead."", quiet ? Project.MSG_VERBOSE : verbosity);
	 }
	 if (file == null && dir == null && filesets.size() == 0 && rcs == null) {
		 throw new BuildException(""At least one of the file or dir "" + ""attributes, or a nested resource collection, "" + ""must be set."");
	 }
	 if (quiet && failonerror) {
		 throw new BuildException(""quiet and failonerror cannot both be "" + ""set to true"", getLocation());
	 }
	 if (file != null) {
		 if (file.exists()) {
			 if (file.isDirectory()) {
				 log(""Directory "" + file.getAbsolutePath() + "" cannot be removed using the file attribute. "" + ""Use dir instead."", quiet ? Project.MSG_VERBOSE : verbosity);
			 }
			 else {
				 log(""Deleting: "" + file.getAbsolutePath());
				 if (!delete(file)) {
					 handle(""Unable to delete file "" + file.getAbsolutePath());
				 }
			 }
		 }
		 else if (isDanglingSymlink(file)) {
			 log(""Trying to delete file "" + file.getAbsolutePath() + "" which looks like a broken symlink."", quiet ? Project.MSG_VERBOSE : verbosity);
			 if (!delete(file)) {
				 handle(""Unable to delete file "" + file.getAbsolutePath());
			 }
		 }
		 else {
			 log(""Could not find file "" + file.getAbsolutePath() + "" to delete."", quiet ? Project.MSG_VERBOSE : verbosity);
		 }
	 }
	 if (dir != null && !usedMatchingTask) {
		 if (dir.exists() && dir.isDirectory()) {
			 if (verbosity == Project.MSG_VERBOSE) {
				 log(""Deleting directory "" + dir.getAbsolutePath());
			 }
			 removeDir(dir);
		 }
		 else if (isDanglingSymlink(dir)) {
			 log(""Trying to delete directory "" + dir.getAbsolutePath() + "" which looks like a broken symlink."", quiet ? Project.MSG_VERBOSE : verbosity);
			 if (!delete(dir)) {
				 handle(""Unable to delete directory "" + dir.getAbsolutePath());
			 }
		 }
	 }
	 Resources resourcesToDelete = new Resources();
	 resourcesToDelete.setProject(getProject());
	 resourcesToDelete.setCache(true);
	 Resources filesetDirs = new Resources();
	 filesetDirs.setProject(getProject());
	 filesetDirs.setCache(true);
	 FileSet implicit = null;
	 if (usedMatchingTask && dir != null && dir.isDirectory()) {
		 implicit = getImplicitFileSet();
		 implicit.setProject(getProject());
		 filesets.add(implicit);
	 }
	 final int size = filesets.size();
	 for (int i = 0;
	 i < size;
	 i++) {
		 FileSet fs = (FileSet) filesets.get(i);
		 if (fs.getProject() == null) {
			 log(""Deleting fileset with no project specified;
			"" + "" assuming executing project"", Project.MSG_VERBOSE);
			 fs = (FileSet) fs.clone();
			 fs.setProject(getProject());
		 }
		 final File fsDir = fs.getDir();
		 if (!fs.getErrorOnMissingDir() && (fsDir == null || !fsDir.exists())) {
			 continue;
		 }
		 if (fsDir == null) {
			 throw new BuildException( ""File or Resource without directory or file specified"");
		 }
		 else if (!fsDir.isDirectory()) {
			 handle(""Directory does not exist: "" + fsDir);
		 }
		 else {
			 DirectoryScanner ds = fs.getDirectoryScanner();
			 final String[] files = ds.getIncludedFiles();
			 resourcesToDelete.add(new ResourceCollection() {
				 public boolean isFilesystemOnly() {
					 return true;
				 }
				 public int size() {
					 return files.length;
				 }
				 public Iterator iterator() {
					 return new FileResourceIterator(getProject(), fsDir, files);
				 }
			 }
			);
			 if (includeEmpty) {
				 filesetDirs.add(new ReverseDirs(getProject(), fsDir, ds .getIncludedDirectories()));
			 }
			 if (removeNotFollowedSymlinks) {
				 String[] n = ds.getNotFollowedSymlinks();
				 if (n.length > 0) {
					 String[] links = new String[n.length];
					 System.arraycopy(n, 0, links, 0, n.length);
					 Arrays.sort(links, ReverseDirs.REVERSE);
					 for (int l = 0;
					 l < links.length;
					 l++) {
						 try {
							 SYMLINK_UTILS .deleteSymbolicLink(new File(links[l]), this);
						 }
						 catch (java.io.IOException ex) {
							 handle(ex);
						 }
					 }
				 }
			 }
		 }
	 }
	 resourcesToDelete.add(filesetDirs);
	 if (rcs != null) {
		 Restrict exists = new Restrict();
		 exists.add(EXISTS);
		 exists.add(rcs);
		 Sort s = new Sort();
		 s.add(REVERSE_FILESYSTEM);
		 s.add(exists);
		 resourcesToDelete.add(s);
	 }
	 try {
		 if (resourcesToDelete.isFilesystemOnly()) {
			 for (Iterator iter = resourcesToDelete.iterator();
			 iter.hasNext();
			) {
				 Resource r = (Resource) iter.next();
				 File f = ((FileProvider) r.as(FileProvider.class)) .getFile();
				 if (!f.exists()) {
					 continue;
				 }
				 if (!(f.isDirectory()) || f.list().length == 0) {
					 log(""Deleting "" + f, verbosity);
					 if (!delete(f) && failonerror) {
						 handle(""Unable to delete "" + (f.isDirectory() ? ""directory "" : ""file "") + f);
					 }
				 }
			 }
		 }
		 else {
			 handle(getTaskName() + "" handles only filesystem resources"");
		 }
	 }
	 catch (Exception e) {
		 handle(e);
	 }
	 finally {
		 if (implicit != null) {
			 filesets.remove(implicit);
		 }
	 }
 }",0,0,1,0
"public class Customer1953 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer1953() {
	}
	public Customer1953(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer1953[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"public void updateExperiment(String airavataExperimentId, ExperimentModel experiment) throws RegistryServiceException, TException {
	 try {
		 experimentCatalog = RegistryFactory.getDefaultExpCatalog();
		 if (!experimentCatalog.isExist(ExperimentCatalogModelType.EXPERIMENT, airavataExperimentId)) {
			 logger.error(airavataExperimentId, ""Update request failed, Experiment {
			}
			 doesn't exist."", airavataExperimentId);
			 throw new RegistryServiceException(""Requested experiment id "" + airavataExperimentId + "" does not exist in the system.."");
		 }
		 ExperimentStatus experimentStatus = getExperimentStatusInternal(airavataExperimentId);
		 if (experimentStatus != null){
			 ExperimentState experimentState = experimentStatus.getState();
			 switch (experimentState){
				 case CREATED: case VALIDATED: if(experiment.getUserConfigurationData() != null && experiment.getUserConfigurationData() .getComputationalResourceScheduling() != null){
					 String compResourceId = experiment.getUserConfigurationData() .getComputationalResourceScheduling().getResourceHostId();
					 ComputeResourceDescription computeResourceDescription = appCatalog.getComputeResource() .getComputeResource(compResourceId);
					 if(!computeResourceDescription.isEnabled()){
						 logger.error(""Compute Resource is not enabled by the Admin!"");
						 AiravataSystemException exception = new AiravataSystemException();
						 exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);
						 exception.setMessage(""Compute Resource is not enabled by the Admin!"");
						 throw exception;
					 }
				 }
				 experimentCatalog.update(ExperimentCatalogModelType.EXPERIMENT, experiment, airavataExperimentId);
				 logger.debug(airavataExperimentId, ""Successfully updated experiment {
				}
				 "", experiment.getExperimentName());
				 break;
				 default: logger.error(airavataExperimentId, ""Error while updating experiment. Update experiment is only valid for experiments "" + ""with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given "" + ""experiment is in one of above statuses... "");
				 AiravataSystemException exception = new AiravataSystemException();
				 exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);
				 exception.setMessage(""Error while updating experiment. Update experiment is only valid for experiments "" + ""with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given "" + ""experiment is in one of above statuses... "");
				 throw exception;
			 }
		 }
	 }
	 catch (RegistryException e) {
		 logger.error(airavataExperimentId, ""Error while updating experiment"", e);
		 RegistryServiceException exception = new RegistryServiceException();
		 exception.setMessage(""Error while updating experiment. More info : "" + e.getMessage());
		 throw exception;
	 }
	 catch (AppCatalogException e) {
		 logger.error(airavataExperimentId, ""Error while updating experiment"", e);
		 RegistryServiceException exception = new RegistryServiceException();
		 exception.setMessage(""Error while updating experiment. More info : "" + e.getMessage());
		 throw exception;
	 }
 }",0,0,1,0
"public class ViewerModelEvent {
	 public static final int CODE_RECOMPILED = 1;
	 public static final int NODE_SELECTED = 2;
	 public static final int PATH_EXPRESSION_APPENDED = 3;
	 public static final int PATH_EXPRESSION_EVALUATED = 4;
	 private Object source;
	 private int reason;
	 private Object parameter;
	 public ViewerModelEvent(Object source, int reason) {
		 this(source, reason, null);
	 }
	 public ViewerModelEvent(Object source, int reason, Object parameter) {
		 this.source = source;
		 this.reason = reason;
		 this.parameter = parameter;
	 }
	 public int getReason() {
		 return reason;
	 }
	 public Object getSource() {
		 return source;
	 }
	 public Object getParameter() {
		 return parameter;
	 }
}",0,1,0,0
"private T createPeriod(Calendar startDate, Calendar endDate, Calendar referenceStartDate, Calendar referenceEndDate, boolean forwards) throws ScheduleException;",0,0,0,1
"public void setPath(String path) {
	 parts = Path.translatePath(getProject(), path);
 }
 public void setPath(String path) throws BuildException {
	 checkAttributesAllowed();
	 createPathElement().setPath(path);
 }",0,0,0,0
"public class ColumnFamilyStore implements ColumnFamilyStoreMBean{
	 private static Logger logger = LoggerFactory.getLogger(ColumnFamilyStore.class);
	 private static final ExecutorService flushWriter = new JMXEnabledThreadPoolExecutor(DatabaseDescriptor.getFlushWriters(), StageManager.KEEPALIVE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(DatabaseDescriptor.getFlushQueueSize()), new NamedThreadFactory(""FlushWriter""), ""internal"");
	 public static final ExecutorService postFlushExecutor = new JMXEnabledThreadPoolExecutor(""MemtablePostFlusher"");
	 static {
		 StorageService.optionalTasks.scheduleWithFixedDelay(new MeteredFlusher(), 1000, 1000, TimeUnit.MILLISECONDS);
	 }
	 public final Table table;
	 public final String columnFamily;
	 public final CFMetaData metadata;
	 public final IPartitioner partitioner;
	 private final String mbeanName;
	 private volatile boolean valid = true;
	 private final DataTracker data;
	 private volatile int memtableSwitchCount = 0;
	 private AtomicInteger fileIndexGenerator = new AtomicInteger(0);
	 public final SecondaryIndexManager indexManager;
	 private LatencyTracker readStats = new LatencyTracker();
	 private LatencyTracker writeStats = new LatencyTracker();
	 private final EstimatedHistogram recentSSTablesPerRead = new EstimatedHistogram(35);
	 private final EstimatedHistogram sstablesPerRead = new EstimatedHistogram(35);
	 private static final int INTERN_CUTOFF = 256;
	 public final ConcurrentMap<ByteBuffer, ByteBuffer> internedNames = new NonBlockingHashMap<ByteBuffer, ByteBuffer>();
	 private volatile DefaultInteger minCompactionThreshold;
	 private volatile DefaultInteger maxCompactionThreshold;
	 private volatile AbstractCompactionStrategy compactionStrategy;
	 public final Directories directories;
	 volatile double liveRatio = 1.0;
	 private final AtomicLong liveRatioComputedAt = new AtomicLong(32);
	 public void reload() throws IOException {
		 if (!minCompactionThreshold.isModified()) for (ColumnFamilyStore cfs : concatWithIndexes()) cfs.minCompactionThreshold = new DefaultInteger(metadata.getMinCompactionThreshold());
		 if (!maxCompactionThreshold.isModified()) for (ColumnFamilyStore cfs : concatWithIndexes()) cfs.maxCompactionThreshold = new DefaultInteger(metadata.getMaxCompactionThreshold());
		 maybeReloadCompactionStrategy();
		 indexManager.reload();
	 }
	 private void maybeReloadCompactionStrategy() {
		 if (metadata.compactionStrategyClass.equals(compactionStrategy.getClass()) && metadata.compactionStrategyOptions.equals(compactionStrategy.getOptions())) return;
		 CompactionManager.instance.getCompactionLock().lock();
		 try {
			 compactionStrategy.shutdown();
			 compactionStrategy = metadata.createCompactionStrategyInstance(this);
		 }
		 finally {
			 CompactionManager.instance.getCompactionLock().unlock();
		 }
	 }
	 public void setCompactionStrategyClass(String compactionStrategyClass) throws ConfigurationException {
		 metadata.compactionStrategyClass = CFMetaData.createCompactionStrategy(compactionStrategyClass);
		 maybeReloadCompactionStrategy();
	 }
	 public String getCompactionStrategyClass() {
		 return metadata.compactionStrategyClass.getName();
	 }
	 public Map<String,String> getCompressionParameters() {
		 return metadata.compressionParameters().asThriftOptions();
	 }
	 public void setCompressionParameters(Map<String,String> opts) throws ConfigurationException {
		 metadata.compressionParameters = CompressionParameters.create(opts);
	 }
	 private ColumnFamilyStore(Table table, String columnFamilyName, IPartitioner partitioner, int generation, CFMetaData metadata, Directories directories) {
		 assert metadata != null : ""null metadata for "" + table + "":"" + columnFamilyName;
		 this.table = table;
		 columnFamily = columnFamilyName;
		 this.metadata = metadata;
		 this.minCompactionThreshold = new DefaultInteger(metadata.getMinCompactionThreshold());
		 this.maxCompactionThreshold = new DefaultInteger(metadata.getMaxCompactionThreshold());
		 this.partitioner = partitioner;
		 this.directories = directories;
		 this.indexManager = new SecondaryIndexManager(this);
		 fileIndexGenerator.set(generation);
		 Caching caching = metadata.getCaching();
		 if (logger.isDebugEnabled()) logger.debug(""Starting CFS {
		}
		"", columnFamily);
		 data = new DataTracker(this);
		 Set<DecoratedKey> savedKeys = caching == Caching.NONE || caching == Caching.ROWS_ONLY ? Collections.<DecoratedKey>emptySet() : CacheService.instance.keyCache.readSaved(table.name, columnFamily);
		 Directories.SSTableLister sstables = directories.sstableLister().skipCompacted(true).skipTemporary(true);
		 data.addInitialSSTables(SSTableReader.batchOpen(sstables.list().entrySet(), savedKeys, data, metadata, this.partitioner));
		 this.compactionStrategy = metadata.createCompactionStrategyInstance(this);
		 for (ColumnDefinition info : metadata.getColumn_metadata().values()) {
			 if (info.getIndexType() != null) indexManager.addIndexedColumn(info);
		 }
		 String type = this.partitioner instanceof LocalPartitioner ? ""IndexColumnFamilies"" : ""ColumnFamilies"";
		 mbeanName = ""org.apache.cassandra.db:type="" + type + "",keyspace="" + this.table.name + "",columnfamily="" + columnFamily;
		 try {
			 MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
			 ObjectName nameObj = new ObjectName(mbeanName);
			 mbs.registerMBean(this, nameObj);
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public void invalidate() {
		 try {
			 valid = false;
			 unregisterMBean();
			 data.unreferenceSSTables();
			 indexManager.invalidate();
		 }
		 catch (Exception e) {
			 logger.warn(""Failed unregistering mbean: "" + mbeanName, e);
		 }
	 }
	 void unregisterMBean() throws MalformedObjectNameException, InstanceNotFoundException, MBeanRegistrationException {
		 MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
		 ObjectName nameObj = new ObjectName(mbeanName);
		 if (mbs.isRegistered(nameObj)) mbs.unregisterMBean(nameObj);
	 }
	 public long getMinRowSize() {
		 return data.getMinRowSize();
	 }
	 public long getMaxRowSize() {
		 return data.getMaxRowSize();
	 }
	 public long getMeanRowSize() {
		 return data.getMeanRowSize();
	 }
	 public int getMeanColumns() {
		 return data.getMeanColumns();
	 }
	 public static ColumnFamilyStore createColumnFamilyStore(Table table, String columnFamily) {
		 return createColumnFamilyStore(table, columnFamily, StorageService.getPartitioner(), Schema.instance.getCFMetaData(table.name, columnFamily));
	 }
	 public static synchronized ColumnFamilyStore createColumnFamilyStore(Table table, String columnFamily, IPartitioner partitioner, CFMetaData metadata) {
		 Directories directories = Directories.create(table.name, columnFamily);
		 Directories.SSTableLister lister = directories.sstableLister().includeBackups(true);
		 List<Integer> generations = new ArrayList<Integer>();
		 for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet()) {
			 Descriptor desc = entry.getKey();
			 generations.add(desc.generation);
			 if (!desc.isCompatible()) throw new RuntimeException(String.format(""Can't open incompatible SSTable! Current version %s, found file: %s"", Descriptor.CURRENT_VERSION, desc));
		 }
		 Collections.sort(generations);
		 int value = (generations.size() > 0) ? (generations.get(generations.size() - 1)) : 0;
		 return new ColumnFamilyStore(table, columnFamily, partitioner, value, metadata, directories);
	 }
	 public static void scrubDataDirectories(String table, String columnFamily) {
		 logger.debug(""Removing compacted SSTable files from {
		}
		 (see http: Directories directories = Directories.create(table, columnFamily);
		 for (Map.Entry<Descriptor,Set<Component>> sstableFiles : directories.sstableLister().list().entrySet()) {
			 Descriptor desc = sstableFiles.getKey();
			 Set<Component> components = sstableFiles.getValue();
			 if (components.contains(Component.COMPACTED_MARKER) || desc.temporary) {
				 try {
					 SSTable.delete(desc, components);
				 }
				 catch (IOException e) {
					 throw new IOError(e);
				 }
				 continue;
			 }
			 File dataFile = new File(desc.filenameFor(Component.DATA));
			 if (components.contains(Component.DATA) && dataFile.length() > 0) continue;
			 logger.warn(""Removing orphans for {
			}
			: {
			}
			"", desc, components);
			 for (Component component : components) {
				 try {
					 FileUtils.deleteWithConfirm(desc.filenameFor(component));
				 }
				 catch (IOException e) {
					 throw new IOError(e);
				 }
			 }
		 }
		 Pattern tmpCacheFilePattern = Pattern.compile(table + ""-"" + columnFamily + ""-(Key|Row)Cache.*\\.tmp$"");
		 File dir = new File(DatabaseDescriptor.getSavedCachesLocation());
		 if (dir.exists()) {
			 assert dir.isDirectory();
			 for (File file : dir.listFiles()) if (tmpCacheFilePattern.matcher(file.getName()).matches()) if (!file.delete()) logger.warn(""could not delete "" + file.getAbsolutePath());
		 }
		 CFMetaData cfm = Schema.instance.getCFMetaData(table, columnFamily);
		 if (cfm != null) {
			 for (ColumnDefinition def : cfm.getColumn_metadata().values()) scrubDataDirectories(table, cfm.indexColumnFamilyName(def));
		 }
	 }
	 public void initRowCache() {
		 if (!isRowCacheEnabled()) return;
		 long start = System.currentTimeMillis();
		 AutoSavingCache<RowCacheKey, IRowCacheEntry> rowCache = CacheService.instance.rowCache;
		 int cachedRowsRead = 0;
		 for (DecoratedKey key : rowCache.readSaved(table.name, columnFamily)) {
			 ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(columnFamily)), Integer.MIN_VALUE, true);
			 CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
		 }
		 if (cachedRowsRead > 0) logger.info(String.format(""completed loading (%d ms;
		 %d keys) row cache for %s.%s"", System.currentTimeMillis() - start, cachedRowsRead, table.name, columnFamily));
	 }
	 public static synchronized void loadNewSSTables(String ksName, String cfName) {
		 Table table = Table.open(ksName);
		 table.getColumnFamilyStore(cfName).loadNewSSTables();
	 }
	 public synchronized void loadNewSSTables() {
		 logger.info(""Loading new SSTables for "" + table.name + ""/"" + columnFamily + ""..."");
		 Set<Descriptor> currentDescriptors = new HashSet<Descriptor>();
		 for (SSTableReader sstable : data.getView().sstables) currentDescriptors.add(sstable.descriptor);
		 Set<SSTableReader> newSSTables = new HashSet<SSTableReader>();
		 Directories.SSTableLister lister = directories.sstableLister().skipCompacted(true).skipTemporary(true);
		 for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet()) {
			 Descriptor descriptor = entry.getKey();
			 if (currentDescriptors.contains(descriptor)) continue;
			 if (descriptor.temporary) continue;
			 if (!descriptor.isCompatible()) throw new RuntimeException(String.format(""Can't open incompatible SSTable! Current version %s, found file: %s"", Descriptor.CURRENT_VERSION, descriptor));
			 Descriptor newDescriptor = new Descriptor(descriptor.version, descriptor.directory, descriptor.ksname, descriptor.cfname, fileIndexGenerator.incrementAndGet(), false);
			 logger.info(""Renaming new SSTable {
			}
			 to {
			}
			"", descriptor, newDescriptor);
			 SSTableWriter.rename(descriptor, newDescriptor, entry.getValue());
			 SSTableReader reader;
			 try {
				 reader = SSTableReader.open(newDescriptor, entry.getValue(), Collections.<DecoratedKey>emptySet(), data, metadata, partitioner);
			 }
			 catch (IOException e) {
				 SSTableReader.logOpenException(entry.getKey(), e);
				 continue;
			 }
			 newSSTables.add(reader);
		 }
		 if (newSSTables.isEmpty()) {
			 logger.info(""No new SSTables where found for "" + table.name + ""/"" + columnFamily);
			 return;
		 }
		 logger.info(""Loading new SSTables and building secondary indexes for "" + table.name + ""/"" + columnFamily + "": "" + newSSTables);
		 SSTableReader.acquireReferences(newSSTables);
		 data.addSSTables(newSSTables);
		 try {
			 indexManager.maybeBuildSecondaryIndexes(newSSTables, indexManager.getIndexedColumns());
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 finally {
			 SSTableReader.releaseReferences(newSSTables);
		 }
		 logger.info(""Done loading load new SSTables for "" + table.name + ""/"" + columnFamily);
	 }
	 public static void rebuildSecondaryIndex(String ksName, String cfName, String... idxNames) {
		 ColumnFamilyStore cfs = Table.open(ksName).getColumnFamilyStore(cfName);
		 SortedSet<ByteBuffer> indexes = new TreeSet<ByteBuffer>(cfs.metadata.comparator);
		 if (idxNames.length == 0) indexes.addAll(cfs.indexManager.getIndexedColumns());
		 for (String idxName : idxNames) indexes.add(cfs.indexManager.getColumnByIdxName(idxName));
		 Collection<SSTableReader> sstables = cfs.getSSTables();
		 try {
			 cfs.indexManager.setIndexRemoved(indexes);
			 SSTableReader.acquireReferences(sstables);
			 logger.info(String.format(""User Requested secondary index re-build for %s/%s indexes"", ksName, cfName));
			 cfs.indexManager.maybeBuildSecondaryIndexes(sstables, indexes);
			 cfs.indexManager.setIndexBuilt(indexes);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 finally {
			 SSTableReader.releaseReferences(sstables);
		 }
	 }
	 public String getColumnFamilyName() {
		 return columnFamily;
	 }
	 public String getFlushPath(long estimatedSize, String version) {
		 File location = directories.getDirectoryForNewSSTables(estimatedSize);
		 if (location == null) throw new RuntimeException(""Insufficient disk space to flush "" + estimatedSize + "" bytes"");
		 return getTempSSTablePath(location, version);
	 }
	 public String getTempSSTablePath(File directory, String version) {
		 Descriptor desc = new Descriptor(version, directory, table.name, columnFamily, fileIndexGenerator.incrementAndGet(), true);
		 return desc.filenameFor(Component.DATA);
	 }
	 public String getTempSSTablePath(File directory) {
		 return getTempSSTablePath(directory, Descriptor.CURRENT_VERSION);
	 }
	 public Future<?> maybeSwitchMemtable(Memtable oldMemtable, final boolean writeCommitLog) {
		 if (oldMemtable.isFrozen()) {
			 logger.debug(""memtable is already frozen;
			 another thread must be flushing it"");
			 return null;
		 }
		 Table.switchLock.writeLock().lock();
		 try {
			 if (oldMemtable.isFrozen()) {
				 logger.debug(""memtable is already frozen;
				 another thread must be flushing it"");
				 return null;
			 }
			 assert getMemtableThreadSafe() == oldMemtable;
			 final ReplayPosition ctx = writeCommitLog ? CommitLog.instance.getContext() : ReplayPosition.NONE;
			 logger.debug(""flush position is {
			}
			"", ctx);
			 final List<ColumnFamilyStore> icc = new ArrayList<ColumnFamilyStore>();
			 for (ColumnFamilyStore cfs : concatWithIndexes()) {
				 Memtable mt = cfs.getMemtableThreadSafe();
				 if (!mt.isClean() && !mt.isFrozen()) {
					 mt.freeze();
					 icc.add(cfs);
				 }
			 }
			 final CountDownLatch latch = new CountDownLatch(icc.size());
			 for (ColumnFamilyStore cfs : icc) {
				 Memtable memtable = cfs.data.switchMemtable();
				 logger.info(""Enqueuing flush of {
				}
				"", memtable);
				 memtable.flushAndSignal(latch, flushWriter, ctx);
			 }
			 if (memtableSwitchCount == Integer.MAX_VALUE) memtableSwitchCount = 0;
			 memtableSwitchCount++;
			 return postFlushExecutor.submit(new WrappedRunnable() {
				 public void runMayThrow() throws InterruptedException, IOException {
					 latch.await();
					 if (!icc.isEmpty()) {
						 for (SecondaryIndex index : indexManager.getIndexesNotBackedByCfs()) {
							 logger.info(""Flushing SecondaryIndex {
							}
							"", index);
							 index.forceBlockingFlush();
						 }
					 }
					 if (writeCommitLog) {
						 CommitLog.instance.discardCompletedSegments(metadata.cfId, ctx);
					 }
				 }
			 }
			);
		 }
		 finally {
			 Table.switchLock.writeLock().unlock();
		 }
	 }
	 public Future<?> forceFlush() {
		 boolean clean = true;
		 for (ColumnFamilyStore cfs : concatWithIndexes()) clean &= cfs.getMemtableThreadSafe().isClean();
		 if (clean) {
			 logger.debug(""forceFlush requested but everything is clean in {
			}
			"", columnFamily);
			 return null;
		 }
		 return maybeSwitchMemtable(getMemtableThreadSafe(), true);
	 }
	 public void forceBlockingFlush() throws ExecutionException, InterruptedException {
		 Future<?> future = forceFlush();
		 if (future != null) future.get();
	 }
	 public void updateRowCache(DecoratedKey key, ColumnFamily columnFamily) {
		 if (metadata.cfId == null) return;
		 RowCacheKey cacheKey = new RowCacheKey(metadata.cfId, key);
		 if (CacheService.instance.rowCache.isPutCopying()) {
			 invalidateCachedRow(cacheKey);
			 return;
		 }
		 IRowCacheEntry cachedRow = getCachedRowInternal(cacheKey);
		 if (cachedRow != null) {
			 if (cachedRow instanceof RowCacheSentinel) invalidateCachedRow(cacheKey);
			 else ((ColumnFamily) cachedRow).addAllWithSCCopy(columnFamily, HeapAllocator.instance);
		 }
	 }
	 public void apply(DecoratedKey key, ColumnFamily columnFamily) {
		 long start = System.nanoTime();
		 Memtable mt = getMemtableThreadSafe();
		 mt.put(key, columnFamily);
		 updateRowCache(key, columnFamily);
		 writeStats.addNano(System.nanoTime() - start);
		 while (true) {
			 long last = liveRatioComputedAt.get();
			 long operations = writeStats.getOpCount();
			 if (operations < 2 * last) break;
			 if (liveRatioComputedAt.compareAndSet(last, operations)) {
				 logger.debug(""computing liveRatio of {
				}
				 at {
				}
				 ops"", this, operations);
				 mt.updateLiveRatio();
			 }
		 }
	 }
	 public static ColumnFamily removeDeletedCF(ColumnFamily cf, int gcBefore) {
		 if (cf.getColumnCount() == 0 && (!cf.isMarkedForDelete() || cf.getLocalDeletionTime() < gcBefore)) return null;
		 cf.maybeResetDeletionTimes(gcBefore);
		 return cf;
	 }
	 public static ColumnFamily removeDeleted(ColumnFamily cf, int gcBefore) {
		 if (cf == null) {
			 return null;
		 }
		 removeDeletedColumnsOnly(cf, gcBefore);
		 return removeDeletedCF(cf, gcBefore);
	 }
	 public static void removeDeletedColumnsOnly(ColumnFamily cf, int gcBefore) {
		 if (cf.isSuper()) removeDeletedSuper(cf, gcBefore);
		 else removeDeletedStandard(cf, gcBefore);
	 }
	 private static void removeDeletedStandard(ColumnFamily cf, int gcBefore) {
		 Iterator<IColumn> iter = cf.iterator();
		 while (iter.hasNext()) {
			 IColumn c = iter.next();
			 ByteBuffer cname = c.name();
			 if (c.getLocalDeletionTime() < gcBefore || c.timestamp() <= cf.getMarkedForDeleteAt()) {
				 iter.remove();
			 }
		 }
	 }
	 private static void removeDeletedSuper(ColumnFamily cf, int gcBefore) {
		 Iterator<IColumn> iter = cf.iterator();
		 while (iter.hasNext()) {
			 SuperColumn c = (SuperColumn)iter.next();
			 long minTimestamp = Math.max(c.getMarkedForDeleteAt(), cf.getMarkedForDeleteAt());
			 Iterator<IColumn> subIter = c.getSubColumns().iterator();
			 while (subIter.hasNext()) {
				 IColumn subColumn = subIter.next();
				 if (subColumn.timestamp() <= minTimestamp || subColumn.getLocalDeletionTime() < gcBefore) {
					 subIter.remove();
				 }
			 }
			 if (c.getSubColumns().isEmpty() && (!c.isMarkedForDelete() || c.getLocalDeletionTime() < gcBefore)) {
				 iter.remove();
			 }
			 else {
				 c.maybeResetDeletionTimes(gcBefore);
			 }
		 }
	 }
	 public boolean isKeyInRemainingSSTables(DecoratedKey key, Set<? extends SSTable> sstablesToIgnore) {
		 List<SSTableReader> filteredSSTables = data.getView().intervalTree.search(new Interval(key, key));
		 for (SSTableReader sstable : filteredSSTables) {
			 if (!sstablesToIgnore.contains(sstable) && sstable.getBloomFilter().isPresent(key.key)) return true;
		 }
		 return false;
	 }
	 public void addSSTable(SSTableReader sstable) {
		 assert sstable.getColumnFamilyName().equals(columnFamily);
		 data.addSSTables(Arrays.asList(sstable));
		 CompactionManager.instance.submitBackground(this);
	 }
	 public long getExpectedCompactedFileSize(Iterable<SSTableReader> sstables) {
		 long expectedFileSize = 0;
		 for (SSTableReader sstable : sstables) {
			 long size = sstable.onDiskLength();
			 expectedFileSize = expectedFileSize + size;
		 }
		 return expectedFileSize;
	 }
	 public SSTableReader getMaxSizeFile(Iterable<SSTableReader> sstables) {
		 long maxSize = 0L;
		 SSTableReader maxFile = null;
		 for (SSTableReader sstable : sstables) {
			 if (sstable.onDiskLength() > maxSize) {
				 maxSize = sstable.onDiskLength();
				 maxFile = sstable;
			 }
		 }
		 return maxFile;
	 }
	 public void forceCleanup(NodeId.OneShotRenewer renewer) throws ExecutionException, InterruptedException {
		 CompactionManager.instance.performCleanup(ColumnFamilyStore.this, renewer);
	 }
	 public void scrub() throws ExecutionException, InterruptedException {
		 snapshotWithoutFlush(""pre-scrub-"" + System.currentTimeMillis());
		 CompactionManager.instance.performScrub(ColumnFamilyStore.this);
	 }
	 public void sstablesRewrite() throws ExecutionException, InterruptedException {
		 CompactionManager.instance.performSSTableRewrite(ColumnFamilyStore.this);
	 }
	 public void markCompacted(Collection<SSTableReader> sstables, OperationType compactionType) {
		 assert !sstables.isEmpty();
		 data.markCompacted(sstables, compactionType);
	 }
	 public void replaceCompactedSSTables(Collection<SSTableReader> sstables, Iterable<SSTableReader> replacements, OperationType compactionType) {
		 data.replaceCompactedSSTables(sstables, replacements, compactionType);
	 }
	 void replaceFlushed(Memtable memtable, SSTableReader sstable) {
		 data.replaceFlushed(memtable, sstable);
		 CompactionManager.instance.submitBackground(this);
	 }
	 public boolean isValid() {
		 return valid;
	 }
	 public long getMemtableColumnsCount() {
		 return getMemtableThreadSafe().getOperations();
	 }
	 public long getMemtableDataSize() {
		 return getMemtableThreadSafe().getLiveSize();
	 }
	 public long getTotalMemtableLiveSize() {
		 return getMemtableDataSize() + indexManager.getTotalLiveSize();
	 }
	 public int getMemtableSwitchCount() {
		 return memtableSwitchCount;
	 }
	 private Memtable getMemtableThreadSafe() {
		 return data.getMemtable();
	 }
	 public DataTracker getDataTracker() {
		 return data;
	 }
	 public Collection<SSTableReader> getSSTables() {
		 return data.getSSTables();
	 }
	 public Set<SSTableReader> getUncompactingSSTables() {
		 return data.getUncompactingSSTables();
	 }
	 public long[] getRecentSSTablesPerReadHistogram() {
		 return recentSSTablesPerRead.getBuckets(true);
	 }
	 public long[] getSSTablesPerReadHistogram() {
		 return sstablesPerRead.getBuckets(false);
	 }
	 public long getReadCount() {
		 return readStats.getOpCount();
	 }
	 public double getRecentReadLatencyMicros() {
		 return readStats.getRecentLatencyMicros();
	 }
	 public long[] getLifetimeReadLatencyHistogramMicros() {
		 return readStats.getTotalLatencyHistogramMicros();
	 }
	 public long[] getRecentReadLatencyHistogramMicros() {
		 return readStats.getRecentLatencyHistogramMicros();
	 }
	 public long getTotalReadLatencyMicros() {
		 return readStats.getTotalLatencyMicros();
	 }
	 public int getPendingTasks() {
		 return Table.switchLock.getQueueLength();
	 }
	 public long getWriteCount() {
		 return writeStats.getOpCount();
	 }
	 public long getTotalWriteLatencyMicros() {
		 return writeStats.getTotalLatencyMicros();
	 }
	 public double getRecentWriteLatencyMicros() {
		 return writeStats.getRecentLatencyMicros();
	 }
	 public long[] getLifetimeWriteLatencyHistogramMicros() {
		 return writeStats.getTotalLatencyHistogramMicros();
	 }
	 public long[] getRecentWriteLatencyHistogramMicros() {
		 return writeStats.getRecentLatencyHistogramMicros();
	 }
	 public ColumnFamily getColumnFamily(DecoratedKey key, QueryPath path, ByteBuffer start, ByteBuffer finish, boolean reversed, int limit) {
		 return getColumnFamily(QueryFilter.getSliceFilter(key, path, start, finish, reversed, limit));
	 }
	 public ColumnFamily getColumnFamily(QueryFilter filter) {
		 return getColumnFamily(filter, gcBefore());
	 }
	 public ColumnFamily getColumnFamily(QueryFilter filter, ISortedColumns.Factory factory) {
		 return getColumnFamily(filter, gcBefore());
	 }
	 public int gcBefore() {
		 return (int) (System.currentTimeMillis() / 1000) - metadata.getGcGraceSeconds();
	 }
	 private ColumnFamily getThroughCache(Integer cfId, QueryFilter filter) {
		 assert isRowCacheEnabled() : String.format(""Row cache is not enabled on column family ["" + getColumnFamilyName() + ""]"");
		 RowCacheKey key = new RowCacheKey(cfId, filter.key);
		 IRowCacheEntry cached = CacheService.instance.rowCache.get(key);
		 if (cached != null) {
			 if (cached instanceof RowCacheSentinel) {
				 return getTopLevelColumns(filter, Integer.MIN_VALUE, false);
			 }
			 return (ColumnFamily) cached;
		 }
		 RowCacheSentinel sentinel = new RowCacheSentinel();
		 boolean sentinelSuccess = CacheService.instance.rowCache.putIfAbsent(key, sentinel);
		 try {
			 ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(filter.key, new QueryPath(columnFamily)), Integer.MIN_VALUE, true);
			 if (sentinelSuccess && data != null) CacheService.instance.rowCache.replace(key, sentinel, data);
			 return data;
		 }
		 finally {
			 if (sentinelSuccess && data == null) CacheService.instance.rowCache.remove(key);
		 }
	 }
	 ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore) {
		 assert columnFamily.equals(filter.getColumnFamilyName()) : filter.getColumnFamilyName();
		 long start = System.nanoTime();
		 try {
			 if (!isRowCacheEnabled()) {
				 ColumnFamily cf = getTopLevelColumns(filter, gcBefore, false);
				 if (cf == null) return null;
				 return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);
			 }
			 Integer cfId = Schema.instance.getId(table.name, this.columnFamily);
			 if (cfId == null) return null;
			 ColumnFamily cached = getThroughCache(cfId, filter);
			 if (cached == null) return null;
			 return filterColumnFamily(cached, filter, gcBefore);
		 }
		 finally {
			 readStats.addNano(System.nanoTime() - start);
		 }
	 }
	 ColumnFamily filterColumnFamily(ColumnFamily cached, QueryFilter filter, int gcBefore) {
		 ColumnFamily cf = cached.cloneMeShallow(ArrayBackedSortedColumns.factory(), filter.filter.isReversed());
		 IColumnIterator ci = filter.getMemtableColumnIterator(cached, null);
		 filter.collateColumns(cf, Collections.singletonList(ci), gcBefore);
		 return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);
	 }
	 private DataTracker.View markCurrentViewReferenced() {
		 while (true) {
			 DataTracker.View currentView = data.getView();
			 if (SSTableReader.acquireReferences(currentView.sstables)) return currentView;
		 }
	 }
	 public Collection<SSTableReader> markCurrentSSTablesReferenced() {
		 return markCurrentViewReferenced().sstables;
	 }
	 public ViewFragment markReferenced(DecoratedKey key) {
		 assert !key.isMinimum();
		 DataTracker.View view;
		 List<SSTableReader> sstables;
		 while (true) {
			 view = data.getView();
			 sstables = view.intervalTree.search(new Interval(key, key));
			 if (SSTableReader.acquireReferences(sstables)) break;
		 }
		 return new ViewFragment(sstables, Iterables.concat(Collections.singleton(view.memtable), view.memtablesPendingFlush));
	 }
	 public ViewFragment markReferenced(RowPosition startWith, RowPosition stopAt) {
		 DataTracker.View view;
		 List<SSTableReader> sstables;
		 while (true) {
			 view = data.getView();
			 Comparable stopInTree = stopAt.isMinimum() ? view.intervalTree.max() : stopAt;
			 sstables = view.intervalTree.search(new Interval(startWith, stopInTree));
			 if (SSTableReader.acquireReferences(sstables)) break;
		 }
		 return new ViewFragment(sstables, Iterables.concat(Collections.singleton(view.memtable), view.memtablesPendingFlush));
	 }
	 private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore, boolean forCache) {
		 CollationController controller = new CollationController(this, forCache, filter, gcBefore);
		 ColumnFamily columns = controller.getTopLevelColumns();
		 recentSSTablesPerRead.add(controller.getSstablesIterated());
		 sstablesPerRead.add(controller.getSstablesIterated());
		 return columns;
	 }
	 public static abstract class AbstractScanIterator extends AbstractIterator<Row> implements CloseableIterator<Row> {
	}
	 public AbstractScanIterator getSequentialIterator(ByteBuffer superColumn, final AbstractBounds<RowPosition> range, IFilter columnFilter) {
		 assert !(range instanceof Range) || !((Range)range).isWrapAround() || range.right.isMinimum() : range;
		 final RowPosition startWith = range.left;
		 final RowPosition stopAt = range.right;
		 QueryFilter filter = new QueryFilter(null, new QueryPath(columnFamily, superColumn, null), columnFilter);
		 List<Row> rows;
		 final ViewFragment view = markReferenced(startWith, stopAt);
		 try {
			 final CloseableIterator<Row> iterator = RowIteratorFactory.getIterator(view.memtables, view.sstables, startWith, stopAt, filter, this);
			 final int gcBefore = (int)(System.currentTimeMillis() / 1000) - metadata.getGcGraceSeconds();
			 return new AbstractScanIterator() {
				 protected Row computeNext() {
					 if (!iterator.hasNext()) return endOfData();
					 Row current = iterator.next();
					 DecoratedKey key = current.key;
					 if (!stopAt.isMinimum() && stopAt.compareTo(key) < 0) return endOfData();
					 if (!range.contains(key)) return computeNext();
					 if (logger.isDebugEnabled()) logger.debug(""scanned "" + key);
					 return current.cf != null && current.cf.isSuper() ? new Row(current.key, removeDeleted(current.cf, gcBefore)) : current;
				 }
				 public void close() throws IOException {
					 SSTableReader.releaseReferences(view.sstables);
					 try {
						 iterator.close();
					 }
					 catch (IOException e) {
						 throw new IOError(e);
					 }
				 }
			 }
			;
		 }
		 catch (RuntimeException e) {
			 SSTableReader.releaseReferences(view.sstables);
			 throw e;
		 }
	 }
	 public List<Row> getRangeSlice(ByteBuffer superColumn, final AbstractBounds<RowPosition> range, int maxResults, IFilter columnFilter, List<IndexExpression> rowFilter) {
		 return getRangeSlice(superColumn, range, maxResults, columnFilter, rowFilter, false, false);
	 }
	 public List<Row> getRangeSlice(ByteBuffer superColumn, final AbstractBounds<RowPosition> range, int maxResults, IFilter columnFilter, List<IndexExpression> rowFilter, boolean maxIsColumns, boolean isPaging) {
		 return filter(getSequentialIterator(superColumn, range, columnFilter), ExtendedFilter.create(this, columnFilter, rowFilter, maxResults, maxIsColumns, isPaging));
	 }
	 public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IFilter dataFilter) {
		 return search(clause, range, maxResults, dataFilter, false);
	 }
	 public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IFilter dataFilter, boolean maxIsColumns) {
		 return indexManager.search(clause, range, maxResults, dataFilter, maxIsColumns);
	 }
	 public List<Row> filter(AbstractScanIterator rowIterator, ExtendedFilter filter) {
		 if (logger.isDebugEnabled()) logger.debug(""Filtering {
		}
		 for rows matching {
		}
		"", rowIterator, filter);
		 List<Row> rows = new ArrayList<Row>();
		 int columnsCount = 0;
		 try {
			 while (rowIterator.hasNext() && rows.size() < filter.maxRows() && columnsCount < filter.maxColumns()) {
				 Row rawRow = rowIterator.next();
				 ColumnFamily data = rawRow.cf;
				 IFilter extraFilter = filter.getExtraFilter(data);
				 if (extraFilter != null) {
					 QueryPath path = new QueryPath(columnFamily);
					 ColumnFamily cf = filter.cfs.getColumnFamily(new QueryFilter(rawRow.key, path, extraFilter));
					 if (cf != null) data.addAll(cf, HeapAllocator.instance);
				 }
				 if (!filter.isSatisfiedBy(data)) continue;
				 logger.debug(""{
				}
				 satisfies all filter expressions"", data);
				 data = filter.prune(data);
				 rows.add(new Row(rawRow.key, data));
				 if (data != null) columnsCount += data.getLiveColumnCount();
				 filter.updateFilter(columnsCount);
			 }
			 return rows;
		 }
		 finally {
			 try {
				 rowIterator.close();
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
	 }
	 public AbstractType<?> getComparator() {
		 return metadata.comparator;
	 }
	 public void snapshotWithoutFlush(String snapshotName) {
		 for (ColumnFamilyStore cfs : concatWithIndexes()) {
			 DataTracker.View currentView = cfs.markCurrentViewReferenced();
			 try {
				 for (SSTableReader ssTable : currentView.sstables) {
					 File snapshotDirectory = Directories.getSnapshotDirectory(ssTable.descriptor, snapshotName);
					 ssTable.createLinks(snapshotDirectory.getPath());
					 if (logger.isDebugEnabled()) logger.debug(""Snapshot for "" + table + "" keyspace data file "" + ssTable.getFilename() + "" created in "" + snapshotDirectory);
				 }
				 if (compactionStrategy instanceof LeveledCompactionStrategy) directories.snapshotLeveledManifest(snapshotName);
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
			 finally {
				 SSTableReader.releaseReferences(currentView.sstables);
			 }
		 }
	 }
	 public void snapshot(String snapshotName) {
		 try {
			 forceBlockingFlush();
		 }
		 catch (ExecutionException e) {
			 throw new RuntimeException(e);
		 }
		 catch (InterruptedException e) {
			 throw new AssertionError(e);
		 }
		 snapshotWithoutFlush(snapshotName);
	 }
	 public boolean snapshotExists(String snapshotName) {
		 return directories.snapshotExists(snapshotName);
	 }
	 public void clearSnapshot(String snapshotName) throws IOException {
		 directories.clearSnapshot(snapshotName);
	 }
	 public boolean hasUnreclaimedSpace() {
		 return data.getLiveSize() < data.getTotalSize();
	 }
	 public long getTotalDiskSpaceUsed() {
		 return data.getTotalSize();
	 }
	 public long getLiveDiskSpaceUsed() {
		 return data.getLiveSize();
	 }
	 public int getLiveSSTableCount() {
		 return data.getSSTables().size();
	 }
	 public ColumnFamily getRawCachedRow(DecoratedKey key) {
		 if (metadata.cfId == null) return null;
		 IRowCacheEntry cached = getCachedRowInternal(new RowCacheKey(metadata.cfId, key));
		 return cached == null || cached instanceof RowCacheSentinel ? null : (ColumnFamily) cached;
	 }
	 private IRowCacheEntry getCachedRowInternal(RowCacheKey key) {
		 return CacheService.instance.rowCache.getCapacity() == 0 ? null : CacheService.instance.rowCache.getInternal(key);
	 }
	 public boolean containsCachedRow(DecoratedKey key) {
		 return CacheService.instance.rowCache.getCapacity() != 0 && CacheService.instance.rowCache.containsKey(new RowCacheKey(metadata.cfId, key));
	 }
	 public void invalidateCachedRow(RowCacheKey key) {
		 CacheService.instance.rowCache.remove(key);
	 }
	 public void invalidateCachedRow(DecoratedKey key) {
		 Integer cfId = Schema.instance.getId(table.name, this.columnFamily);
		 if (cfId == null) return;
		 invalidateCachedRow(new RowCacheKey(cfId, key));
	 }
	 public void forceMajorCompaction() throws InterruptedException, ExecutionException {
		 CompactionManager.instance.performMaximal(this);
	 }
	 public static Iterable<ColumnFamilyStore> all() {
		 List<Iterable<ColumnFamilyStore>> stores = new ArrayList<Iterable<ColumnFamilyStore>>(Schema.instance.getTables().size());
		 for (Table table : Table.all()) {
			 stores.add(table.getColumnFamilyStores());
		 }
		 return Iterables.concat(stores);
	 }
	 public static List<ColumnFamilyStore> allUserDefined() {
		 List<ColumnFamilyStore> cfses = new ArrayList<ColumnFamilyStore>();
		 for (Table table : Sets.difference(ImmutableSet.copyOf(Table.all()), ImmutableSet.of(Table.open(Table.SYSTEM_TABLE)))) cfses.addAll(table.getColumnFamilyStores());
		 return cfses;
	 }
	 public Iterable<DecoratedKey<?>> keySamples(Range<Token> range) {
		 Collection<SSTableReader> sstables = getSSTables();
		 Iterable<DecoratedKey<?>>[] samples = new Iterable[sstables.size()];
		 int i = 0;
		 for (SSTableReader sstable: sstables) {
			 samples[i++] = sstable.getKeySamples(range);
		 }
		 return Iterables.concat(samples);
	 }
	 public void clearUnsafe() {
		 for (ColumnFamilyStore cfs : concatWithIndexes()) cfs.data.init();
	 }
	 private void waitForActiveFlushes() {
		 Future<?> future;
		 Table.switchLock.writeLock().lock();
		 try {
			 future = postFlushExecutor.submit(new Runnable() {
				 public void run() {
				 }
			 }
			);
		 }
		 finally {
			 Table.switchLock.writeLock().unlock();
		 }
		 try {
			 future.get();
		 }
		 catch (InterruptedException e) {
			 throw new AssertionError(e);
		 }
		 catch (ExecutionException e) {
			 throw new AssertionError(e);
		 }
	 }
	 public Future<?> truncate() throws IOException, ExecutionException, InterruptedException {
		 logger.debug(""truncating {
		}
		"", columnFamily);
		 forceBlockingFlush();
		 CommitLog.instance.forceNewSegment();
		 ReplayPosition position = CommitLog.instance.getContext();
		 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) cfs.forceFlush();
		 waitForActiveFlushes();
		 CommitLog.instance.discardCompletedSegments(metadata.cfId, position);
		 try {
			 Thread.sleep(100);
		 }
		 catch (InterruptedException e) {
			 throw new AssertionError(e);
		 }
		 long truncatedAt = System.currentTimeMillis();
		 if (DatabaseDescriptor.isAutoSnapshot()) snapshot(Table.getTimestampedSnapshotName(columnFamily));
		 return CompactionManager.instance.submitTruncate(this, truncatedAt);
	 }
	 public long getBloomFilterFalsePositives() {
		 return data.getBloomFilterFalsePositives();
	 }
	 public long getRecentBloomFilterFalsePositives() {
		 return data.getRecentBloomFilterFalsePositives();
	 }
	 public double getBloomFilterFalseRatio() {
		 return data.getBloomFilterFalseRatio();
	 }
	 public double getRecentBloomFilterFalseRatio() {
		 return data.getRecentBloomFilterFalseRatio();
	 }
	 public long getBloomFilterDiskSpaceUsed() {
		 long total = 0;
		 for (SSTableReader sst : getSSTables()) total += sst.getBloomFilterSerializedSize();
		 return total;
	 }
	 public String toString() {
		 return ""CFS("" + ""Keyspace='"" + table.name + '\'' + "", ColumnFamily='"" + columnFamily + '\'' + ')';
	 }
	 public void disableAutoCompaction() {
		 minCompactionThreshold.set(0);
		 maxCompactionThreshold.set(0);
	 }
	 public AbstractCompactionStrategy getCompactionStrategy() {
		 return compactionStrategy;
	 }
	 public int getMinimumCompactionThreshold() {
		 return minCompactionThreshold.value();
	 }
	 public void setMinimumCompactionThreshold(int minCompactionThreshold) {
		 if ((minCompactionThreshold > this.maxCompactionThreshold.value()) && this.maxCompactionThreshold.value() != 0) {
			 throw new RuntimeException(""The min_compaction_threshold cannot be larger than the max."");
		 }
		 this.minCompactionThreshold.set(minCompactionThreshold);
	 }
	 public int getMaximumCompactionThreshold() {
		 return maxCompactionThreshold.value();
	 }
	 public void setMaximumCompactionThreshold(int maxCompactionThreshold) {
		 if (maxCompactionThreshold > 0 && maxCompactionThreshold < this.minCompactionThreshold.value()) {
			 throw new RuntimeException(""The max_compaction_threshold cannot be smaller than the min."");
		 }
		 this.maxCompactionThreshold.set(maxCompactionThreshold);
	 }
	 public boolean isCompactionDisabled() {
		 return getMinimumCompactionThreshold() <= 0 || getMaximumCompactionThreshold() <= 0;
	 }
	 public long estimateKeys() {
		 return data.estimatedKeys();
	 }
	 public long[] getEstimatedRowSizeHistogram() {
		 return data.getEstimatedRowSizeHistogram();
	 }
	 public long[] getEstimatedColumnCountHistogram() {
		 return data.getEstimatedColumnCountHistogram();
	 }
	 public double getCompressionRatio() {
		 return data.getCompressionRatio();
	 }
	 public boolean isIndex() {
		 return partitioner instanceof LocalPartitioner;
	 }
	 private String getParentColumnfamily() {
		 assert isIndex();
		 return columnFamily.split(""\\."")[0];
	 }
	 private ByteBuffer intern(ByteBuffer name) {
		 ByteBuffer internedName = internedNames.get(name);
		 if (internedName == null) {
			 internedName = ByteBufferUtil.clone(name);
			 ByteBuffer concurrentName = internedNames.putIfAbsent(internedName, internedName);
			 if (concurrentName != null) internedName = concurrentName;
		 }
		 return internedName;
	 }
	 public ByteBuffer internOrCopy(ByteBuffer name, Allocator allocator) {
		 if (internedNames.size() >= INTERN_CUTOFF) return allocator.clone(name);
		 return intern(name);
	 }
	 public ByteBuffer maybeIntern(ByteBuffer name) {
		 if (internedNames.size() >= INTERN_CUTOFF) return null;
		 return intern(name);
	 }
	 public SSTableWriter createFlushWriter(long estimatedRows, long estimatedSize, ReplayPosition context) throws IOException {
		 SSTableMetadata.Collector sstableMetadataCollector = SSTableMetadata.createCollector().replayPosition(context);
		 return new SSTableWriter(getFlushPath(estimatedSize, Descriptor.CURRENT_VERSION), estimatedRows, metadata, partitioner, sstableMetadataCollector);
	 }
	 public SSTableWriter createCompactionWriter(long estimatedRows, File location, Collection<SSTableReader> sstables) throws IOException {
		 ReplayPosition rp = ReplayPosition.getReplayPosition(sstables);
		 SSTableMetadata.Collector sstableMetadataCollector = SSTableMetadata.createCollector().replayPosition(rp);
		 for (SSTableReader sstable : sstables) sstableMetadataCollector.updateMaxTimestamp(sstable.getMaxTimestamp());
		 return new SSTableWriter(getTempSSTablePath(location), estimatedRows, metadata, partitioner, sstableMetadataCollector);
	 }
	 public Iterable<ColumnFamilyStore> concatWithIndexes() {
		 return Iterables.concat(indexManager.getIndexesBackedByCfs(), Collections.singleton(this));
	 }
	 public Set<Memtable> getMemtablesPendingFlush() {
		 return data.getMemtablesPendingFlush();
	 }
	 public List<String> getBuiltIndexes() {
		 return indexManager.getBuiltIndexes();
	 }
	 public int getUnleveledSSTables() {
		 return this.compactionStrategy instanceof LeveledCompactionStrategy ? ((LeveledCompactionStrategy) this.compactionStrategy).getLevelSize(0) : 0;
	 }
	 public static class ViewFragment {
		 public final List<SSTableReader> sstables;
		 public final Iterable<Memtable> memtables;
		 public ViewFragment(List<SSTableReader> sstables, Iterable<Memtable> memtables) {
			 this.sstables = sstables;
			 this.memtables = memtables;
		 }
	 }
	 public long oldestUnflushedMemtable() {
		 DataTracker.View view = data.getView();
		 long oldest = view.memtable.creationTime();
		 for (Memtable memtable : view.memtablesPendingFlush) oldest = Math.min(oldest, memtable.creationTime());
		 return oldest;
	 }
	 public boolean isEmpty() {
		 DataTracker.View view = data.getView();
		 return view.sstables.isEmpty() && view.memtable.getOperations() == 0 && view.memtablesPendingFlush.isEmpty();
	 }
	 private boolean isRowCacheEnabled() {
		 return !(metadata.getCaching() == Caching.NONE || metadata.getCaching() == Caching.KEYS_ONLY || CacheService.instance.rowCache.getCapacity() == 0);
	 }
	 public void discardSSTables(long truncatedAt) {
		 List<SSTableReader> truncatedSSTables = new ArrayList<SSTableReader>();
		 for (SSTableReader sstable : getSSTables()) {
			 if (!sstable.newSince(truncatedAt)) truncatedSSTables.add(sstable);
		 }
		 if (!truncatedSSTables.isEmpty()) markCompacted(truncatedSSTables, OperationType.UNKNOWN);
	 }
}",1,0,0,0
"protected void sendMessage(Connection cnx) throws Exception {
	 if (cnx.getServer().getRequiresCredentials()) {
		 getMessage().setMessageHasSecurePartFlag();
		 long userId = -1;
		 if (UserAttributes.userAttributes.get() == null) {
			 userId = cnx.getServer().getUserId();
		 }
		 else {
			 Object id = UserAttributes.userAttributes.get().getServerToId().get(cnx.getServer());
			 if (id == null) {
				 throw new ServerConnectivityException(""Connection error while authenticating user"");
			 }
			 userId = (Long) id;
		 }
		 HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
		 try {
			 hdos.writeLong(cnx.getConnectionID());
			 hdos.writeLong(userId);
			 getMessage().setSecurePart(((ConnectionImpl) cnx).encryptBytes(hdos.toByteArray()));
		 }
		 finally {
			 hdos.close();
		 }
	 }
	 getMessage().send(false);
 }",0,0,1,0
"public class AnnealingLayoutAlgorithm extends JGraphLayoutAlgorithm implements GraphModelListener {
	 public final static int COUT_COSTFUNCTION = 6;
	 public final static int COSTFUNCTION_EDGE_DISTANCE = 1;
	 public final static int COSTFUNCTION_EDGE_CROSSING = 2;
	 public final static int COSTFUNCTION_EDGE_LENGTH = 4;
	 public final static int COSTFUNCTION_BORDERLINE = 8;
	 public final static int COSTFUNCTION_NODE_DISTRIBUTION = 16;
	 public final static int COSTFUNCTION_NODE_DISTANCE = 32;
	 public final static String KEY_CAPTION = ""Annealing Layoutalgorithm Attributes"";
	 public final static String KEY_POSITION = ""Position"";
	 public final static String KEY_RELATIVES = ""Relatives"";
	 public final static String CF_KEY_EDGE_DISTANCE_RELEVANT_EDGES = ""costfunction edge distance key for relevant edges"";
	 public final static String KEY_CLUSTERED_VERTICES = ""Clustered Vertices"";
	 public final static String KEY_CLUSTER = ""Cluster"";
	 public final static String KEY_IS_CLUSTER = ""is Cluster"";
	 public final static String KEY_CLUSTER_INIT_POSITION = ""initial Position of the Cluster"";
	 protected final static int CONFIG_KEY_RUN = 0;
	 protected final static int CONFIG_KEY_LAYOUT_UPDATE = 1;
	 private double temperature;
	 private double initTemperature = 40;
	 private double minTemperature = 2;
	 private double minDistance = 50;
	 private double tempScaleFactor = 0.95;
	 private int maxRounds = 10000;
	 protected double[] lambdaList = new double[]{
	 1000, 100000, 0.02, 2000, 150, 1000000}
	;
	 private Rectangle bounds = new Rectangle(0, 0, 1000, 700);
	 private boolean computePermutation = true;
	 private boolean uphillMovesAllowed = true;
	 private boolean isLayoutUpdateEnabled = true;
	 private int costFunctionConfig = Integer.parseInt(""111110"", 2);
	 private int round;
	 private int triesPerCell = 8;
	 protected ArrayList cellList;
	 protected ArrayList edgeList;
	 protected ArrayList applyCellList;
	 private JGraph jgraph;
	 protected Properties presetConfig;
	 private boolean isRunning = false;
	 private int luRecursionDepth = 1;
	 private double luPerimeterRadius = 100;
	 private double luPerimeterRadiusInc = 20;
	 private String luMethod = AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETER;
	 private double equalsNull = 0.05;
	 private boolean isClusteringEnabled = true;
	 private double clusterMoveScaleFactor = 0.1;
	 private double clusteringFactor = 8.0;
	 protected boolean isOptimizer = false;
	 public AnnealingLayoutAlgorithm() {
		 this(false);
		 setMaximumProgress(100);
	 }
	 public AnnealingLayoutAlgorithm(boolean isOptimizer) {
		 this.isOptimizer = isOptimizer;
	 }
	public String toString() {
		return ""Annealing"";
	}
	public String getHint() {
		return ""Ignores selection"";
	}
	public JGraphLayoutSettings createSettings() {
		return new AnnealingLayoutSettings(this, false);
	}
	 public void run(JGraph graph, Object[] dynamic_cells, Object[] static_cells) {
		 isRunning = true;
		 setAllowedToRun(true);
		 setProgress(1);
		 jgraph = graph;
		 cellList = new ArrayList();
		 edgeList = new ArrayList();
		 applyCellList = new ArrayList();
		 getNodes(jgraph, dynamic_cells);
		 if( applyCellList.size() == 0 ) return;
		 if( isLayoutUpdateEnabled ) jgraph.getModel().addGraphModelListener(this);
		 init(true);
		 run();
		 if (isAllowedToRun()) {
			 moveGraphToNW();
			applyChanges();
			 removeTemporaryData();
		 }
		 isRunning = false;
	 }
	 public void performOptimization(ArrayList applyList, ArrayList allCellList, ArrayList allEdgeList, Properties config) {
		 cellList = allCellList;
		 applyCellList = applyList;
		 edgeList = allEdgeList;
		 presetConfig = config;
		 loadConfiguration(CONFIG_KEY_RUN);
		 init(false);
		 run();
	 }
	 private void loadConfiguration(int configSwitch) {
		 if( configSwitch == CONFIG_KEY_RUN ){
			 initTemperature = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_INIT_TEMPERATURE));
			 minTemperature = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_MIN_TEMPERATURE));
			 minDistance = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_MIN_DISTANCE));
			 tempScaleFactor = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_TEMP_SCALE_FACTOR));
			 maxRounds = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_MAX_ROUNDS));
			 triesPerCell = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_TRIES_PER_CELL));
			 ArrayList lambda = (ArrayList) presetConfig.get(AnnealingLayoutSettings.KEY_LAMBDA);
			 lambdaList = new double[COUT_COSTFUNCTION];
			 for( int i = 0;
			 i < lambdaList.length;
			 i++ ) lambdaList[i] = ((Double)lambda.get(i)).doubleValue();
			 bounds = (Rectangle) presetConfig.get(AnnealingLayoutSettings.KEY_BOUNDS);
			 costFunctionConfig = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_COST_FUNCTION_CONFIG),2);
			 computePermutation = isTrue((String)presetConfig.get(AnnealingLayoutSettings.KEY_COMPUTE_PERMUTATION));
			 uphillMovesAllowed = isTrue((String)presetConfig.get(AnnealingLayoutSettings.KEY_IS_UPHILL_MOVE_ALLOWED));
		 }
		 else if( configSwitch == CONFIG_KEY_LAYOUT_UPDATE ){
			 initTemperature = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_INIT_TEMPERATURE));
			 minTemperature = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_MIN_TEMPERATURE));
			 minDistance = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_MIN_DISTANCE));
			 tempScaleFactor = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR));
			 maxRounds = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_MAX_ROUNDS));
			 triesPerCell = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_TRIES_PER_CELL));
			 ArrayList lambda = (ArrayList) presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_LAMBDA);
			 lambdaList = new double[COUT_COSTFUNCTION];
			 for( int i = 0;
			 i < lambdaList.length;
			 i++ ) lambdaList[i] = ((Double)lambda.get(i)).doubleValue();
			 bounds = (Rectangle) presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_BOUNDS);
			 costFunctionConfig = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG),2);
			 computePermutation = isTrue((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION));
			 uphillMovesAllowed = isTrue((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED));
			 luRecursionDepth = Integer.parseInt((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH));
			 luPerimeterRadius = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS));
			 luPerimeterRadiusInc = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE));
			 luMethod = (String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_METHOD);
			 isClusteringEnabled = isTrue((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED));
			 clusteringFactor = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR));
			 clusterMoveScaleFactor = Double.parseDouble((String)presetConfig.get(AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE));
		 }
	 }
	 private boolean isTrue(String boolValue) {
		 if( boolValue != null ){
			 if( ""TRUE"".equals(boolValue.toUpperCase()) ) {
				 return true;
			 }
			 else if( ""FALSE"".equals(boolValue.toUpperCase()) ) {
				 return false;
			 }
		 }
		 return false;
	 }
	 private void getNodes(JGraph jgraph, Object[] cells){
		 Object[] all = jgraph.getRoots();
		 CellView[] view = jgraph.getGraphLayoutCache().getMapping(all,false);
		 CellView[] selectedView = jgraph.getGraphLayoutCache().getMapping( cells,false);
		 for (int i = 0;
		 i < view.length;
		 i++) if (view[i] instanceof VertexView){
			 cellList.add(view[i]);
			 applyCellList.add(view[i]);
		 }
		 else if( view[i] instanceof EdgeView ){
			 edgeList.add(view[i]);
		 }
		 for( int i = 0;
		 i < selectedView.length;
		 i++ ) if( selectedView[i] instanceof VertexView ) applyCellList.add(selectedView[i]);
	 }
	 private void applyChanges(){
		 Map viewMap = new Hashtable();
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 CellView view = (CellView)applyCellList.get(i);
			 Point2D.Double pos = getPosition(view);
			 Rectangle2D r = view.getBounds();
			 r.setFrame(pos.getX() - (r.getWidth() /2.0), pos.getY() - (r.getHeight()/2.0), r.getWidth(), r.getHeight());
			 Object cell = ((CellView) applyCellList.get(i)).getCell();
			 Map attributes = new Hashtable();
			 GraphConstants.setBounds(attributes, r);
			 viewMap.put(cell, attributes);
		 }
		 jgraph.getGraphLayoutCache().edit(viewMap,null,null,null);
	 }
	 private void removeTemporaryData(){
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ) ((CellView)applyCellList.get(i)).getAttributes().clear();
	 }
	 private void init(boolean setInitPositions){
		 if( setInitPositions ){
			 for( int i = 0;
			 i < applyCellList.size();
			 i++ ) if( !((CellView)applyCellList.get(i)).getAttributes().containsKey(KEY_POSITION) ) setPosition(i, (Math.random()*bounds.getWidth()) +bounds.getX(), (Math.random()*bounds.getHeight())+bounds.getY());
			 for( int i = 0;
			 i < cellList.size();
			 i++ ) if( !((CellView)cellList.get(i)).getAttributes().containsKey(KEY_POSITION) ) setPosition((CellView)cellList.get(i), (Math.random()*bounds.getWidth()) +bounds.getX(), (Math.random()*bounds.getHeight())+bounds.getY());
		 }
		 temperature = initTemperature;
		 maxRounds = Math.min(100 * applyCellList.size(), getMaxRoundsByTemperature(temperature));
		 round = 0;
	 }
	 private void run(){
		 while( round <= maxRounds && isAllowedToRun()) performRound();
	 }
	 private void performRound(){
		 Point2D.Double[] config = getConfig();
		 double startEnergy = getGlobalCosts(lambdaList);
		 double globalEnergy = startEnergy;
		 double newGlobalEnergy = globalEnergy * 1.1;
		 int[] sequence = new int[applyCellList.size()];
		 if( !computePermutation ) for( int i = 0;
		 i < applyCellList.size();
		 i++ ) sequence[i] = i;
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 if( computePermutation ) sequence = createPermutation(applyCellList.size());
			 double offset = Math.random() * 2.0 * Math.PI;
			 for( int j = 0;
			 j < triesPerCell;
			 j++ ){
				 double angle = j * ((2.0 * Math.PI)/triesPerCell);
				 angle += offset;
				 Point2D.Double move = null;
				 if( isCluster((CellView)applyCellList.get(i)) ){
					 move = new Point2D.Double( clusterMoveScaleFactor * temperature * Math.cos(angle), clusterMoveScaleFactor * temperature * Math.sin(angle));
				 }
				 else {
					 move = new Point2D.Double( temperature * Math.cos(angle), temperature * Math.sin(angle));
				 }
				 setPosition(sequence[i],config[sequence[i]].x + move.x, config[sequence[i]].y + move.y);
				 newGlobalEnergy = getGlobalCosts(lambdaList);
				 if( newGlobalEnergy < globalEnergy || (getBolzmanBreak(globalEnergy,newGlobalEnergy) && uphillMovesAllowed) ){
					 globalEnergy = newGlobalEnergy;
					 config[sequence[i]] = new Point2D.Double( config[sequence[i]].x + move.x, config[sequence[i]].y + move.y);
					 break;
				 }
				 else {
					 setPosition(sequence[i], config[sequence[i]].x, config[sequence[i]].y);
				 }
				 setProgress((int)(((double)((round*applyCellList.size()*triesPerCell)+(i*triesPerCell)+j)/(double)(maxRounds*applyCellList.size()*triesPerCell))*(100.0)));
				 if (!isAllowedToRun()) break;
			 }
			 if( globalEnergy == startEnergy * 0.05 ) break;
			 if (!isAllowedToRun()) break;
		 }
		 temperature *= tempScaleFactor;
		 round++;
	 }
	 private Point2D.Double[] getConfig(){
		 Point2D.Double[] config = new Point2D.Double[applyCellList.size()];
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 Point2D.Double pos = getPosition((CellView)applyCellList.get(i));
			 config[i] = new Point2D.Double(pos.x,pos.y);
		 }
		 return config;
	 }
	 private double getGlobalCosts(double[] lambda){
		 double energy = 0.0;
		 if( (costFunctionConfig & COSTFUNCTION_NODE_DISTANCE) != 0 ){
			 energy += getNodeDistance(lambda[5]);
		 }
		 if( (costFunctionConfig & COSTFUNCTION_NODE_DISTRIBUTION) != 0 ){
			 energy += getNodeDistribution(lambda[0]);
		 }
		 if( (costFunctionConfig & COSTFUNCTION_BORDERLINE) != 0 ){
			 energy += getBorderline(lambda[1]);
		 }
		 if( (costFunctionConfig & COSTFUNCTION_EDGE_LENGTH) != 0 ){
			 energy += getEdgeLength(lambda[2]);
		 }
		 if( (costFunctionConfig & COSTFUNCTION_EDGE_CROSSING) != 0 ){
			 energy += getEdgeCrossing(1.0,lambda[3]);
		 }
		 if( (costFunctionConfig & COSTFUNCTION_EDGE_DISTANCE) != 0 ){
			 energy += getEdgeDistance(lambda[4]);
		 }
		 return energy;
	 }
	 public int[] createPermutation(int length){
		 int[] permutation = new int[length];
		 for( int i = 0;
		 i < permutation.length;
		 i++ ){
			 int newValue = (int)(Math.random()*length);
			 for( int j = 0;
			 j < i;
			 j++ ) if( newValue == permutation[j] ){
				 newValue = (int)(Math.random()*length);
				 j = -1;
			 }
			 permutation[i] = newValue;
		 }
		 return permutation;
	 }
	 private boolean getBolzmanBreak(double oldEnergy, double newEnergy){
		 return Math.random() < Math.pow(Math.E,(oldEnergy-newEnergy)/temperature);
	 }
	 private int getMaxRoundsByTemperature(double actualTemperature){
		 return (int)Math.ceil( Math.log(minTemperature/actualTemperature) / Math.log(tempScaleFactor));
	 }
	 private double getNodeDistribution(double lambda){
		 double energy = 0.0;
		 for( int i = 0 ;
		 i < applyCellList.size();
		 i++ ) for( int j = 0;
		 j < cellList.size();
		 j++ ){
			 if( applyCellList.get(i) != cellList.get(j) ){
				 double distance = MathExtensions.getEuclideanDistance( getPosition((CellView)applyCellList.get(i)), getPosition((CellView)cellList.get(j)));
				 if( Math.abs(distance) < equalsNull ) distance = equalsNull;
				 energy += lambda/(distance*distance);
			 }
		 }
		 return energy;
	 }
	 private double getBorderline(double lambda){
		 double energy = 0.0;
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 Point2D.Double pos = getPosition((CellView)applyCellList.get(i));
			 double t = pos.y-bounds.y;
			 double l = pos.x-bounds.x;
			 double b = bounds.y+bounds.height-pos.y;
			 double r = bounds.x+bounds.width -pos.x;
			 energy += lambda * ( (1.0/(t*t)) + (1.0/(l*l)) + (1.0/(b*b)) + (1.0/(r*r)) );
		 }
		 return energy;
	 }
	 private double getEdgeLength(double lambda ){
		 double energy = 0.0;
		 Line2D.Double[] lineList = getEdgeLines(edgeList);
		 for( int i = 0;
		 i < lineList.length;
		 i++ ){
			 Point2D p1 = lineList[i].getP1();
			 Point2D p2 = lineList[i].getP2();
			 double edgeLength = p1.distance(p2);
			 energy += lambda * edgeLength * edgeLength;
		 }
		 return energy;
	 }
	 private double getEdgeCrossing(double f, double lambda){
		 int n = 0;
		 Line2D.Double[] lineList = getEdgeLines(edgeList);
		 for( int i = 0;
		 i < lineList.length;
		 i++ ) for( int j = i;
		 j < lineList.length;
		 j++ ) if( j != i ) if( lineList[i].intersectsLine(lineList[j]) ){
			 if( ((lineList[i].getP1().getX() != lineList[j].getP1().getX()) && (lineList[i].getP1().getY() != lineList[j].getP1().getY())) && ((lineList[i].getP1().getX() != lineList[j].getP2().getX()) && (lineList[i].getP1().getY() != lineList[j].getP2().getY())) && ((lineList[i].getP2().getX() != lineList[j].getP1().getX()) && (lineList[i].getP2().getY() != lineList[j].getP1().getY())) && ((lineList[i].getP2().getX() != lineList[j].getP2().getX()) && (lineList[i].getP2().getY() != lineList[j].getP2().getY())) ){
				 n++;
			 }
		 }
		 return lambda * f * n;
	 }
	 private double getEdgeDistance(double lambda){
		 double energy = 0.0;
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 double h = 0.0;
			 CellView view = (CellView) applyCellList.get(i);
			 ArrayList relevantEdges = null;
			 if( view.getAttributes().containsKey(CF_KEY_EDGE_DISTANCE_RELEVANT_EDGES) ){
				 relevantEdges = (ArrayList) view.getAttributes().get(CF_KEY_EDGE_DISTANCE_RELEVANT_EDGES);
			 }
			 else {
				 relevantEdges = getRelevantEdges(view);
				 view.getAttributes().put(CF_KEY_EDGE_DISTANCE_RELEVANT_EDGES,relevantEdges);
			 }
			 Line2D.Double[] lineList = getEdgeLines(getRelevantEdges(view));
			 for( int j = 0;
			 j < lineList.length;
			 j++ ){
				 double distance = lineList[j].ptSegDist(getPosition(view));
				 if( Math.abs(distance) < equalsNull ) distance = equalsNull;
				 if( distance != 0.0 ) h += lambda / ( distance * distance );
				 if( distance < minDistance ) h += lambda / ( minDistance * minDistance );
			 }
			 energy += h;
		 }
		 return energy;
	 }
	 private double getNodeDistance(double lambda){
		 double energy = 0.0;
		 double radiusInc = 30.0;
		 int overlapCount = 0;
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 Point2D.Double pos = (Point2D.Double)((CellView)applyCellList.get(i)).getAttributes().get(KEY_POSITION);
			 Rectangle2D vertex = ((CellView)applyCellList.get(i)).getBounds();
			 for( int j = 0;
			 j < cellList.size();
			 j++ ){
				 if( applyCellList.get(i) != cellList.get(j) ){
					 Point2D.Double uPos = (Point2D.Double)((CellView)cellList.get(j)).getAttributes().get(KEY_POSITION);
					 Rectangle2D uVertex = ((CellView)cellList.get(j)).getBounds();
					 double minDist = Math.max((2.0 * radiusInc) + (Math.max(vertex.getWidth(),vertex.getHeight())/2.0) + (Math.max(uVertex.getWidth(),uVertex.getHeight())/2.0), minDistance);
					 double distance = Math.abs(pos.distance(uPos));
					 if( Math.abs(distance) < equalsNull ) distance = equalsNull;
					 if( distance < minDist ){
						 energy += lambda / (distance * distance);
						 overlapCount++;
					 }
				 }
			 }
		 }
		 return energy;
	 }
	 private Line2D.Double[] getEdgeLines(ArrayList edges){
		 Line2D.Double[] lines = new Line2D.Double[edges.size()];
		 for( int i = 0;
		 i < edges.size();
		 i++ ){
			 EdgeView edge = (EdgeView) edges.get(i);
			 CellView source = edge.getSource().getParentView();
			 CellView target = edge.getTarget().getParentView();
			 lines[i] = new Line2D.Double(getPosition(source), getPosition(target));
		 }
		 return lines;
	 }
	 private ArrayList getRelevantEdges(CellView except){
		 ArrayList relevantEdgeList = new ArrayList();
		 for( int i = 0;
		 i < edgeList.size();
		 i++ ){
			 CellView view = ((EdgeView)edgeList.get(i)).getSource().getParentView();
			 if( view != except && applyCellList.contains(view) ){
				 relevantEdgeList.add(edgeList.get(i));
			 }
			 else {
				 view = ((EdgeView)edgeList.get(i)).getTarget().getParentView();
				 if( view != except && applyCellList.contains(view) ){
					 relevantEdgeList.add(edgeList.get(i));
				 }
			 }
		 }
		 return relevantEdgeList;
	 }
	 public Point2D.Double getRandomVector(double maxLength){
		 double alpha = Math.random()*Math.PI*2;
		 double length = Math.random()*maxLength;
		 return new Point2D.Double(length*Math.cos(alpha), length*Math.sin(alpha));
	 }
	 private void setPosition(CellView view, Point2D.Double pos){
		 setAttribute(view,KEY_POSITION,pos);
	 }
	 private void setPosition(int index, double x, double y){
		 setPosition((CellView)applyCellList.get(index),x,y);
	 }
	 private void setPosition(CellView view, double x, double y){
		 setPosition(view,new Point2D.Double(x,y));
	 }
	 private Point2D.Double getPosition(CellView view){
		 return (Point2D.Double) getAttribute(view,KEY_POSITION);
	 }
	 private void setAttribute(CellView view,String key, Object obj){
		 if( view.getAttributes() == null ) view.changeAttributes(new AttributeMap());
		 Map attributes = view.getAttributes();
		 attributes.put(key,obj);
	 }
	 private Object getAttribute(CellView view, String key){
		 return view.getAttributes().get(key);
	 }
	 private void moveGraphToNW(){
		 Point2D.Double firstPos = getPosition((CellView)cellList.get(0));
		 double minX = firstPos.x;
		 double minY = firstPos.y;
		 double maxX = minX;
		 double maxY = minY;
		 for( int i = 0;
		 i < cellList.size();
		 i++ ){
			 CellView view = (CellView) cellList.get(i);
			 Point2D.Double viewPos = getPosition((CellView)cellList.get(i));
			 Rectangle2D viewBounds = view.getAttributes().createRect(view.getBounds());
			 if( viewPos.getX() < minX ){
				 minX = viewPos.getX();
			 }
			 else if( viewPos.getX()+viewBounds.getWidth() > maxX ){
				 maxX = viewPos.getX()+viewBounds.getWidth();
			 }
			 if( viewPos.getY() < minY ){
				 minY = viewPos.getY();
			 }
			 else if( viewPos.getY()+viewBounds.getHeight() > maxY ){
				 maxY = viewPos.getY()+viewBounds.getHeight();
			 }
		 }
		 minX -= 50;
		 minY -= 50;
		 for( int i = 0;
		 i < cellList.size();
		 i++ ){
			 CellView view = (CellView) cellList.get(i);
			 Point2D.Double pos = getPosition(view);
			 setPosition(view,new Point2D.Double(pos.x-minX, pos.y-minY));
		 }
	 }
	 protected ArrayList getRelativesFrom(ArrayList list, CellView view){
		 ArrayList relatives = getRelatives(view);
		 ArrayList result = new ArrayList();
		 for( int i = 0;
		 i < relatives.size();
		 i++ ) if( list.contains(relatives.get(i)) ) result.add(relatives.get(i));
		 return result;
	 }
	 protected ArrayList getRelatives(CellView view){
		 if( view.getAttributes().containsKey(KEY_RELATIVES) ) return (ArrayList) view.getAttributes().get(KEY_RELATIVES);
		 ArrayList relatives = new ArrayList();
		 ArrayList portsCells = new ArrayList();
		 VertexView vertexView = (VertexView)view;
		 if( isCluster(view) ){
			 ArrayList clusteredVertices = (ArrayList) vertexView.getAttributes().get(KEY_CLUSTERED_VERTICES);
			 for( int i = 0;
			 i < clusteredVertices.size();
			 i++ ){
				 ArrayList clusterRelatives = getRelatives((CellView)clusteredVertices.get(i));
				 for( int j = 0;
				 j < clusterRelatives.size();
				 j++ ) if( !relatives.contains(clusterRelatives.get(j)) && !clusteredVertices.contains(clusterRelatives.get(j)) ){
					 relatives.add(clusterRelatives.get(j));
				 }
			 }
		 }
		 else {
			 GraphModel model = jgraph.getModel();
			 CellMapper mapper = jgraph.getGraphLayoutCache() ;
			 Object vertexCell = vertexView.getCell() ;
			 for (int i = 0;
			 i < model.getChildCount(vertexCell);
			 i++){
				 Object portCell = model.getChild(vertexCell, i);
				 portsCells.add(portCell);
			 }
			 for( int i = 0;
			 i < portsCells.size() ;
			 i++ ){
				 Object portCell = portsCells.get(i);
				 Iterator edges = model.edges(portCell);
				 while (edges.hasNext() ){
					 Object edge = edges.next() ;
					 Object nextPort = null;
					 if( model.getSource(edge) != portCell ){
						 nextPort = model.getSource(edge);
					 }
					 else {
						 nextPort = model.getTarget(edge);
					 }
					 CellView nextVertex = mapper.getMapping( model.getParent(nextPort), false);
					 relatives.add(nextVertex);
				 }
			 }
		 }
		 view.getAttributes().put(KEY_RELATIVES,relatives);
		 return relatives;
	 }
	 private void arrangeLayoutUpdateInsertPlacement(CellView[] viewList){
		 for( int i = 0;
		 i < cellList.size();
		 i++ ){
			 CellView view = (CellView) cellList.get(i);
			 if( !view.getAttributes().containsKey(KEY_POSITION) ){
				 Point2D.Double pos = new Point2D.Double( view.getBounds().getCenterX(), view.getBounds().getCenterY());
				 view.getAttributes().put(KEY_POSITION,pos);
			 }
		 }
		 ArrayList placableCells = new ArrayList();
		 for( int i = 0;
		 i < viewList.length;
		 i++ ) placableCells.add(viewList[i]);
		 arrangeLayoutUpdateInsertedCellsPlacement(placableCells);
	 }
	 private void arrangeLayoutUpdateInsertedCellsPlacement(ArrayList placableCells){
		 ArrayList notPlacedCells = new ArrayList();
		 for( int i = 0;
		 i < placableCells.size();
		 i++ ){
			 CellView view = (CellView) placableCells.get(i);
			 if( view instanceof VertexView ){
				 ArrayList relatives = getRelativesFrom(cellList,view);
				 if( relatives.size() != 0 ){
					 double sumX = 0.0;
					 double sumY = 0.0;
					 for( int j = 0;
					 j < relatives.size();
					 j++ ){
						 Point2D.Double pos = (Point2D.Double) ((CellView)relatives.get(j)). getAttributes(). get(KEY_POSITION);
						 sumX += pos.x;
						 sumY += pos.y;
					 }
					 Point2D.Double randomVector = new Point2D.Double(Math.cos(Math.random()*2.0*Math.PI)*10.0, Math.sin(Math.random()*2.0*Math.PI)*10.0);
					 view.getAttributes().put(KEY_POSITION, new Point2D.Double( (sumX/relatives.size())+randomVector.x, (sumY/relatives.size())+randomVector.y));
				 }
				 else {
					 notPlacedCells.add(view);
				 }
			 }
		 }
		 for( int i = 0;
		 i < placableCells.size();
		 i++ ){
			 if( placableCells.get(i) != null ) if( ((CellView) placableCells.get(i)).getAttributes() != null ) if( ((CellView) placableCells.get(i)).getAttributes().containsKey(KEY_POSITION) ) cellList.add(placableCells.get(i));
		 }
		 if( notPlacedCells.size() != placableCells.size() ){
			 arrangeLayoutUpdateInsertedCellsPlacement(notPlacedCells);
		 }
		 else {
			 for( int i = 0;
			 i < notPlacedCells.size();
			 i++ ){
				 CellView view = (CellView) notPlacedCells.get(i);
				 if( !view.getAttributes().containsKey(KEY_POSITION) ) view.getAttributes().put(KEY_POSITION, new Point2D.Double(0.0,0.0));
			 }
		 }
		 for( int i = 0;
		 i < cellList.size();
		 i++ ) if( ((CellView)cellList.get(i)).getAttributes().get(KEY_POSITION) == null ) System.err.println(""WHATCH OUT!!! NODE ""+i+"" == NULL"");
	 }
	 private void getLayoutUpdateCells(CellView[] viewList){
		 for( int i = 0;
		 i < viewList.length;
		 i++ ){
			 if( viewList[i] instanceof VertexView ){
				 if( !applyCellList.contains(viewList[i]) ) applyCellList.add(viewList[i]);
				 if( !cellList.contains(viewList[i]) ) cellList.add(viewList[i]);
			 }
			 else if( viewList[i] instanceof EdgeView && viewList[i] != null ){
				 if( !edgeList.contains(viewList[i]) ){
					 edgeList.add(viewList[i]);
					 System.out.println(""edge added"");
				 }
			 }
		 }
		 if( AnnealingLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETER. equals(luMethod)){
			 ArrayList perimeterList = new ArrayList();
			 for( int i = 0;
			 i < applyCellList.size();
			 i++ ){
				 VertexView vertex = (VertexView) applyCellList.get(i);
				 Point2D.Double pos = (Point2D.Double) vertex. getAttributes().get(KEY_POSITION);
				 int intersectionCount = 0;
				 for( int j = 0;
				 j < applyCellList.size();
				 j++ ){
					 if( i != j ){
						 VertexView uVertex = (VertexView) applyCellList.get(j);
						 Point2D.Double uPos = (Point2D.Double) uVertex. getAttributes().get(KEY_POSITION);
						 if( pos.distance(uPos) < luPerimeterRadius ) intersectionCount++;
					 }
				 }
				 perimeterList.add(new Ellipse2D.Double( pos.x - (luPerimeterRadius + (intersectionCount * luPerimeterRadiusInc)), pos.y - (luPerimeterRadius + (intersectionCount * luPerimeterRadiusInc)), 2.0 * (luPerimeterRadius + (intersectionCount * luPerimeterRadiusInc)), 2.0 * (luPerimeterRadius + (intersectionCount * luPerimeterRadiusInc))));
			 }
			 for( int i = 0;
			 i < cellList.size();
			 i++ ){
				 VertexView vertex = (VertexView) cellList.get(i);
				 Point2D.Double pos = (Point2D.Double) vertex.getAttributes().get(KEY_POSITION);
				 for( int j = 0;
				 j < perimeterList.size();
				 j++ ){
					 Ellipse2D.Double perimeter = (Ellipse2D.Double) perimeterList.get(j);
					 Point2D.Double center = new Point2D.Double( perimeter.getCenterX(), perimeter.getCenterY());
					 double radius = perimeter.getCenterX() - perimeter.getX();
					 if( center.distance(pos) < radius ) if( !applyCellList.contains(vertex) ) applyCellList.add(vertex);
				 }
			 }
		 }
		 if( luRecursionDepth > 0 ){
			 int vertexCount = 0;
			 for( int i = 0;
			 i < viewList.length;
			 i++ ) if( viewList[i] instanceof VertexView ) vertexCount++;
			 VertexView[] vertexList = new VertexView[vertexCount];
			 vertexCount = 0;
			 for( int i = 0;
			 i < viewList.length;
			 i++ ) if( viewList[i] instanceof VertexView ) vertexList[vertexCount++] = (VertexView) viewList[i];
			 addRelativesToList(vertexList,luRecursionDepth);
		 }
	 }
	 private void addRelativesToList(VertexView[] vertexList, int depth){
		 if( vertexList == null ) return;
		 if( vertexList.length == 0 ) return;
		 if( depth == 0 ) return;
		 for( int i = 0;
		 i < vertexList.length;
		 i++ ){
			 ArrayList relatives = getRelatives(vertexList[i]);
			 VertexView[] relativeList = new VertexView[relatives.size()];
			 for( int j = 0;
			 j < relatives.size();
			 j++ ){
				 if( !applyCellList.contains(relatives.get(j)) ){
					 applyCellList.add(relatives.get(j));
				 }
				 if( !cellList.contains(relatives.get(j)) ) cellList.add(relatives.get(j));
				 relativeList[j] = (VertexView) relatives.get(j);
			 }
			 addRelativesToList(relativeList,depth-1);
		 }
	 }
	 public void graphChanged(GraphModelEvent e){
		 if( !isRunning ){
			 isRunning = true;
			 Object[] vertexIns = e.getChange().getInserted();
			 Object[] vertexRem = e.getChange().getRemoved();
			 if( vertexIns != null && vertexRem == null ){
				 if( vertexIns.length == 0 ){
					 isRunning = false;
					 return;
				 }
				 CellView[] viewList = jgraph.getGraphLayoutCache().getMapping( vertexIns,false);
				 if( viewList.length == 0 ){
					 isRunning = false;
					 return;
				 }
				 applyCellList.clear();
				 loadConfiguration(CONFIG_KEY_LAYOUT_UPDATE);
				 boolean bugPresent = false;
				 for( int i = 0;
				 i < viewList.length;
				 i++ ) if( viewList[i] == null ){
					 bugPresent = true;
					 break;
				 }
				 if( bugPresent ) getAllEdges();
				 arrangeLayoutUpdateInsertPlacement(viewList);
				 getLayoutUpdateCells(viewList);
				 if( applyCellList.size() == 0 ){
					 isRunning = false;
					 return;
				 }
				 round = 0;
				 if( isClusteringEnabled ) clusterGraph();
				 init(false);
				 run();
				 if( isClusteringEnabled ) declusterGraph();
				applyChanges();
				 removeTemporaryData();
			 }
			 else if( vertexIns == null && vertexRem != null ){
				 isRunning = true;
				 CellView[] viewList = jgraph.getGraphLayoutCache().getMapping( vertexRem,false);
				 for( int i = 0;
				 i < viewList.length;
				 i++ ) if( viewList[i] instanceof VertexView ){
					 if( applyCellList.contains(viewList[i]) ) applyCellList.remove(viewList[i]);
					 if( cellList.contains(viewList[i]) ) cellList.remove(viewList[i]);
				 }
				 else if( viewList[i] instanceof EdgeView ){
				 }
			 }
			 isRunning = false;
		 }
	 }
	 private void getAllEdges(){
		 Object[] cells = jgraph.getRoots();
		 CellView[] views = jgraph.getGraphLayoutCache().getMapping(cells,false);
		 for( int i = 0;
		 i < views.length;
		 i++ ){
			 if( views[i] instanceof VertexView ){
				 VertexView vertexView = (VertexView) views[i];
				 GraphModel model = jgraph.getModel();
				 CellMapper mapper = jgraph.getGraphLayoutCache() ;
				 Object vertexCell = vertexView.getCell() ;
				 ArrayList portsCells = new ArrayList();
				 for (int j = 0;
				 j < model.getChildCount(vertexCell);
				 j++){
					 Object portCell = model.getChild(vertexCell, j);
					 portsCells.add(portCell);
				 }
				 for( int j = 0;
				 j < portsCells.size();
				 j++ ){
					 Object portCell = portsCells.get(j);
					 Iterator edges = model.edges(portCell);
					 while (edges.hasNext() ){
						 Object edge = edges.next() ;
						 Object e = mapper.getMapping(edge,false);
						 if( !edgeList.contains(e) && e != null){
							 edgeList.add(e);
						 }
					 }
				 }
			 }
			 else if( views[i] instanceof EdgeView ){
				 if( !edgeList.contains(views[i]) && views[i] != null ){
					 edgeList.add(views[i]);
				 }
			 }
		 }
	 }
	 protected void clusterGraph(){
		 int maxClusters = Math.max((int)((cellList.size() - applyCellList.size()) / clusteringFactor ),2);
		 if( cellList.size() <= 1 ){
			 System.out.println(""cellList.size() <= 1"");
			 return;
		 }
		 ArrayList clusterList = new ArrayList();
		 ArrayList cellsToCluster = new ArrayList();
		 for( int i = 0;
		 i < cellList.size();
		 i++ ) if( !applyCellList.contains(cellList.get(i)) ) cellsToCluster.add(cellList.get(i));
		 VertexView[] clusters = new VertexView[maxClusters];
		 Rectangle boundingBox = getBoundingBox();
		 for( int i = 0;
		 i < clusters.length;
		 i++ ){
			 clusters[i] = new VertexView(null);
			 Map attributes = clusters[i].getAttributes();
			 attributes.put(KEY_IS_CLUSTER,""true"");
			 attributes.put(KEY_POSITION,new Point2D.Double( Math.random()*boundingBox.width, Math.random()*boundingBox.height));
			 clusterList.add(clusters[i]);
		 }
		 for( int i = 0;
		 i < cellsToCluster.size();
		 i++ ){
			 VertexView cell = (VertexView) cellsToCluster.get(i);
			 Point2D.Double cellPos = getPosition(cell);
			 int clusterID = 0;
			 Point2D.Double clusterPos = getPosition((CellView)clusterList.get(0));
			 double minDistance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
			 for( int j = 1;
			 j < clusterList.size();
			 j++ ){
				 clusterPos = getPosition((VertexView)clusterList.get(j));
				 double distance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
				 if( minDistance > distance ){
					 minDistance = distance;
					 clusterID = j;
				 }
			 }
			 VertexView cluster = (VertexView) clusterList.get(clusterID);
			 moveVerticeToCluster(cell,cluster);
		 }
		 boolean couldMakeItBetter = false;
		 do {
			 couldMakeItBetter = false;
			 for( int i = 0;
			 i < cellsToCluster.size();
			 i++ ){
				 VertexView cell = (VertexView) cellsToCluster.get(i);
				 VertexView oldCluster = (VertexView) cell.getAttributes().get(KEY_CLUSTER);
				 Point2D.Double cellPos = getPosition(cell);
				 Point2D.Double clusterPos = getPosition(oldCluster);
				 double distance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
				 for( int j = 0;
				 j < clusterList.size();
				 j++ ){
					 VertexView cluster = (VertexView) clusterList.get(j);
					 if( cluster != oldCluster ){
						 clusterPos = getPosition(cluster);
						 double newDistance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
						 if( newDistance < distance ){
							 moveVerticeToCluster(cell,cluster);
							 couldMakeItBetter = true;
							 break;
						 }
					 }
				 }
			 }
		 }
		 while( couldMakeItBetter );
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 if( !((VertexView)clusterList.get(i)).getAttributes().containsKey(KEY_CLUSTERED_VERTICES)){
				 clusterList.remove(i--);
			 }
			 else if( ((ArrayList)((VertexView)clusterList.get(i)).getAttributes().get(KEY_CLUSTERED_VERTICES)).size() == 0 ){
				 clusterList.remove(i--);
			 }
		 }
		 for( int i = 0;
		 i < cellsToCluster.size();
		 i++ ) cellList.remove(cellsToCluster.get(i));
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 applyCellList.add(clusterList.get(i));
			 cellList.add(clusterList.get(i));
		 }
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 VertexView cluster = (VertexView) clusterList.get(i);
			 Map attribs = cluster.getAttributes();
			 Point2D.Double clusterPos = (Point2D.Double) attribs.get(KEY_POSITION);
			 attribs.put(KEY_CLUSTER_INIT_POSITION, new Point2D.Double( clusterPos.x, clusterPos.y));
		 }
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 VertexView cluster = (VertexView)clusterList.get(i);
			 cluster.setCachedBounds(getBoundingBox((ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES)));
		 }
	 }
	 protected void moveVerticeToCluster(VertexView vertice, VertexView cluster){
		 if( !cluster.getAttributes().containsKey(KEY_CLUSTERED_VERTICES) ) cluster.getAttributes().put(KEY_CLUSTERED_VERTICES,new ArrayList());
		 ArrayList clusteredVertices = (ArrayList) cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
		 clusteredVertices.add(vertice);
		 if( vertice.getAttributes().containsKey(KEY_CLUSTER) ){
			 VertexView oldCluster = (VertexView) vertice.getAttributes().get(KEY_CLUSTER);
			 ArrayList list = (ArrayList)oldCluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
			 list.remove(vertice);
			 computeClusterPosition(oldCluster);
		 }
		 vertice.getAttributes().put(KEY_CLUSTER,cluster);
		 computeClusterPosition(cluster);
	 }
	 protected void computeClusterPosition(VertexView cluster){
		 ArrayList clusteredVertices = (ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
		 Point2D.Double clusterPos = computeBarycenter(clusteredVertices);
		 cluster.getAttributes().put(KEY_POSITION,clusterPos);
	 }
	 protected void declusterGraph(){
		 if( cellList.size() <= 1 ) return;
		 ArrayList clusterList = new ArrayList();
		 for( int i = 0;
		 i < cellList.size();
		 i++ ){
			 VertexView cell = ((VertexView)cellList.get(i));
			 if( isCluster(cell) ) clusterList.add(cell);
		 }
		 if( clusterList.size() == 0 ) return;
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 cellList.remove(clusterList.get(i));
			 applyCellList.remove(clusterList.get(i));
		 }
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 VertexView cluster = (VertexView)clusterList.get(i);
			 Map attribs = cluster.getAttributes();
			 Point2D.Double newClusterPos = getPosition(cluster);
			 Point2D.Double oldClusterPos = (Point2D.Double) attribs.get(KEY_CLUSTER_INIT_POSITION);
			 Point2D.Double move = new Point2D.Double(newClusterPos.x - oldClusterPos.x, newClusterPos.y - oldClusterPos.y);
			 ArrayList vertexList = (ArrayList)attribs.get(KEY_CLUSTERED_VERTICES);
			 for( int j = 0;
			 j < vertexList.size();
			 j++ ){
				 VertexView cell = (VertexView) vertexList.get(j);
				 Point2D.Double cellPos = getPosition(cell);
				 Point2D.Double newCellPos = new Point2D.Double(cellPos.x + move.x, cellPos.y + move.y);
				 cell.getAttributes().put(KEY_POSITION,newCellPos);
				 cellList.add(cell);
			 }
		 }
	 }
	 protected boolean isCluster(CellView cell){
		 if( cell.getAttributes().containsKey(KEY_IS_CLUSTER)){
			 if( isTrue((String)cell.getAttributes().get(KEY_IS_CLUSTER))){
				 return true;
			 }
			 else {
				 System.err.println(""FATAL ERROR: CELL CANNOT CLEARLY BE IDENTIFIED AS A CLUSTER!!!"");
				 return false;
			 }
		 }
		 else return false;
	 }
	 private Point2D.Double computeBarycenter(ArrayList list){
		 double sumX = 0.0;
		 double sumY = 0.0;
		 for( int i = 0;
		 i < list.size();
		 i++ ){
			 CellView view = (CellView) list.get(i);
			 Point2D.Double pos = getPosition(view);
			 sumX += pos.x;
			 sumY += pos.y;
		 }
		 return new Point2D.Double(sumX/(list.size()), sumY/(list.size()));
	 }
	 private Rectangle getBoundingBox(ArrayList verticeList){
		 if( verticeList.size() > 0 ){
			 Point2D.Double vertexPos = getPosition((VertexView)verticeList.get(0));
			 Rectangle2D vertexSize = ((CellView)verticeList.get(0)).getBounds();
			 double minX = vertexPos.getX();
			 double minY = vertexPos.getX();
			 double maxX = vertexPos.getX()+vertexSize.getWidth();
			 double maxY = vertexPos.getX()+vertexSize.getHeight();
			 for( int i = 1;
			 i < verticeList.size();
			 i++ ){
				 vertexPos = getPosition((VertexView)verticeList.get(i));
				 vertexSize =((CellView)verticeList.get(i)).getBounds();
				 if( minX > vertexPos.getX() ) minX = vertexPos.getX();
				 if( minY > vertexPos.getY() ) minY = vertexPos.getY();
				 if( maxX < vertexPos.getX()+vertexSize.getWidth() ) maxX = vertexPos.getX()+vertexSize.getWidth();
				 if( maxY < vertexPos.getY()+vertexSize.getHeight() ) maxY = vertexPos.getY()+vertexSize.getHeight();
			 }
			 Rectangle boundingBox = new Rectangle((int)minX, (int)minY, (int)(maxX-minX), (int)(maxY-minY));
			 return boundingBox;
		 }
		 return null;
	 }
	 private Rectangle getBoundingBox(){
		 return getBoundingBox(cellList);
	 }
	 public static abstract class MathExtensions {
		public static double sgn(double x){
			 if( x < 0.0 ) {
				return -1.0;
			 }
			 else if( x > 0.0 ){
				return 1.0;
			 }
			 else {
				return 0.0;
			 }
		 }
		public static double abs(Point2D.Double v){
			 return Math.sqrt(getTransposed(v,v));
		}
		public static double abs(double x, double y){
			 return Math.sqrt( (x*x) + (y*y) );
		}
		public static double angleBetween(Point2D.Double v1, Point2D.Double v2){
			 double xty = getTransposed(v1,v2);
			 double lx = Math.sqrt(getTransposed(v1,v1));
			 double ly = Math.sqrt(getTransposed(v2,v2));
			 double result = xty/(lx*ly);
			 if( result > 1.0 ) result = 1.0;
			 if( result < -1.0 ) result = -1.0;
			 return Math.acos(result);
		}
		public static double getTransposed(Point2D.Double v1, Point2D.Double v2){
			 return v1.getX() * v2.getX() + v1.getY() * v2.getY();
		}
		public static double getEuclideanDistance(Point2D.Double p1, Point2D.Double p2){
			 return Math.sqrt(((p1.x-p2.x)*(p1.x-p2.x))+((p1.y-p2.y)*(p1.y-p2.y)));
		}
		public static Point2D.Double getNormalizedVector(Point2D.Double v){
			 double length = abs(v);
			 return new Point2D.Double(v.x / length, v.y / length );
		}
	 }
	public boolean isOptimizer() {
		return isOptimizer;
	}
	public Properties getPresetConfig() {
		return presetConfig;
	}
	public void setPresetConfig(Properties presetConfig) {
		this.presetConfig = presetConfig;
		 loadConfiguration(CONFIG_KEY_RUN);
	}
}",1,0,0,0
public SAXSourceLocator(Locator locator);,0,0,0,0
"public class NoopOutputTransformerContainer extends AbstractOutputTransformerContainer{
	private static final long serialVersionUID = 1L;
	public NoopOutputTransformerContainer(final String id){
		super(id);
	}
	public NoopOutputTransformerContainer(final String id, final IModel<?> model){
		super(id, model);
	}
	public CharSequence transform(final Component component, final CharSequence output){
		return output;
	}
}",0,0,0,0
"public void appendValue(StringBuilder buffer, String itemType, String value) {
	 if (itemType != null) {
		 appendTo(buffer);
		 buffer.append(""<t:"");
		 buffer.append(itemType);
		 buffer.append('>');
	 }
	 buffer.append(""<t:ExtendedProperty>"");
	 appendTo(buffer);
	 if (propertyType == PropertyType.StringArray) {
		 buffer.append(""<t:Values>"");
		 String[] values = value.split("","");
		 for (final String singleValue : values) {
			 buffer.append(""<t:Value>"");
			 buffer.append(StringUtil.xmlEncode(singleValue));
			 buffer.append(""</t:Value>"");
		 }
		 buffer.append(""</t:Values>"");
	 }
	 else {
		 buffer.append(""<t:Value>"");
		 if (""0x10f3"".equals(propertyTag)) {
			 buffer.append(StringUtil.xmlEncode(StringUtil.encodeUrlcompname(value)));
		 }
		 else {
			 buffer.append(StringUtil.xmlEncode(value));
		 }
		 buffer.append(""</t:Value>"");
	 }
	 buffer.append(""</t:ExtendedProperty>"");
	 if (itemType != null) {
		 buffer.append(""</t:"");
		 buffer.append(itemType);
		 buffer.append('>');
	 }
 }",0,0,0,0
"public void validateDepositDetailForUpdate(final JsonElement element, final FromJsonHelper fromApiJsonHelper, final DataValidatorBuilder baseDataValidator) {
	 if (fromApiJsonHelper.parameterExists(nameParamName, element)) {
		 final String name = fromApiJsonHelper.extractStringNamed(nameParamName, element);
		 baseDataValidator.reset().parameter(nameParamName).value(name).notBlank().notExceedingLengthOf(100);
	 }
	 if (fromApiJsonHelper.parameterExists(shortNameParamName, element)) {
		 final String shortName = fromApiJsonHelper.extractStringNamed(shortNameParamName, element);
		 baseDataValidator.reset().parameter(shortNameParamName).value(shortName).notBlank().notExceedingLengthOf(4);
	 }
	 if (fromApiJsonHelper.parameterExists(descriptionParamName, element)) {
		 final String description = fromApiJsonHelper.extractStringNamed(descriptionParamName, element);
		 baseDataValidator.reset().parameter(descriptionParamName).value(description).notBlank().notExceedingLengthOf(500);
	 }
	 if (fromApiJsonHelper.parameterExists(currencyCodeParamName, element)) {
		 final String currencyCode = fromApiJsonHelper.extractStringNamed(currencyCodeParamName, element);
		 baseDataValidator.reset().parameter(currencyCodeParamName).value(currencyCode).notBlank();
	 }
	 if (fromApiJsonHelper.parameterExists(digitsAfterDecimalParamName, element)) {
		 final Integer digitsAfterDecimal = fromApiJsonHelper.extractIntegerSansLocaleNamed(digitsAfterDecimalParamName, element);
		 baseDataValidator.reset().parameter(digitsAfterDecimalParamName).value(digitsAfterDecimal).notNull().inMinMaxRange(0, 6);
	 }
	 if (fromApiJsonHelper.parameterExists(inMultiplesOfParamName, element)) {
		 final Integer inMultiplesOf = fromApiJsonHelper.extractIntegerNamed(inMultiplesOfParamName, element, Locale.getDefault());
		 baseDataValidator.reset().parameter(inMultiplesOfParamName).value(inMultiplesOf).ignoreIfNull().integerZeroOrGreater();
	 }
	 if (fromApiJsonHelper.parameterExists(nominalAnnualInterestRateParamName, element)) {
		 final BigDecimal interestRate = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(nominalAnnualInterestRateParamName, element);
		 baseDataValidator.reset().parameter(nominalAnnualInterestRateParamName).value(interestRate).notNull().zeroOrPositiveAmount();
	 }
	 if (fromApiJsonHelper.parameterExists(interestCompoundingPeriodTypeParamName, element)) {
		 final Integer interestCompoundingPeriodType = fromApiJsonHelper.extractIntegerSansLocaleNamed( interestCompoundingPeriodTypeParamName, element);
		 baseDataValidator.reset().parameter(interestCompoundingPeriodTypeParamName).value(interestCompoundingPeriodType).notNull() .isOneOfTheseValues(SavingsCompoundingInterestPeriodType.integerValues());
	 }
	 if (fromApiJsonHelper.parameterExists(interestCalculationTypeParamName, element)) {
		 final Integer interestCalculationType = fromApiJsonHelper.extractIntegerSansLocaleNamed(interestCalculationTypeParamName, element);
		 baseDataValidator.reset().parameter(interestCalculationTypeParamName).value(interestCalculationType).notNull() .inMinMaxRange(1, 2);
	 }
	 if (fromApiJsonHelper.parameterExists(interestCalculationDaysInYearTypeParamName, element)) {
		 final Integer interestCalculationDaysInYearType = fromApiJsonHelper.extractIntegerSansLocaleNamed( interestCalculationDaysInYearTypeParamName, element);
		 baseDataValidator.reset().parameter(interestCalculationDaysInYearTypeParamName).value(interestCalculationDaysInYearType) .notNull().isOneOfTheseValues(360, 365);
	 }
	 if (fromApiJsonHelper.parameterExists(minRequiredOpeningBalanceParamName, element)) {
		 final BigDecimal minOpeningBalance = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(minRequiredOpeningBalanceParamName, element);
		 baseDataValidator.reset().parameter(minRequiredOpeningBalanceParamName).value(minOpeningBalance).ignoreIfNull() .zeroOrPositiveAmount();
	 }
	 if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyParamName, element)) {
		 final Integer lockinPeriodFrequency = fromApiJsonHelper.extractIntegerWithLocaleNamed(lockinPeriodFrequencyParamName, element);
		 baseDataValidator.reset().parameter(lockinPeriodFrequencyParamName).value(lockinPeriodFrequency).ignoreIfNull() .integerZeroOrGreater();
	 }
	 if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyTypeParamName, element)) {
		 final Integer lockinPeriodFrequencyType = fromApiJsonHelper.extractIntegerSansLocaleNamed(lockinPeriodFrequencyTypeParamName, element);
		 baseDataValidator.reset().parameter(lockinPeriodFrequencyTypeParamName).value(lockinPeriodFrequencyType).inMinMaxRange(0, 3);
	 }
	 if (fromApiJsonHelper.parameterExists(withdrawalFeeForTransfersParamName, element)) {
		 final Boolean isWithdrawalFeeApplicableForTransfers = fromApiJsonHelper.extractBooleanNamed(withdrawalFeeForTransfersParamName, element);
		 baseDataValidator.reset().parameter(withdrawalFeeForTransfersParamName).value(isWithdrawalFeeApplicableForTransfers) .ignoreIfNull().validateForBooleanValue();
	 }
	 if (fromApiJsonHelper.parameterExists(feeAmountParamName, element)) {
		 final BigDecimal annualFeeAmount = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(feeAmountParamName, element);
		 baseDataValidator.reset().parameter(feeAmountParamName).value(annualFeeAmount).ignoreIfNull().zeroOrPositiveAmount();
	 }
	 if (fromApiJsonHelper.parameterExists(feeOnMonthDayParamName, element)) {
		 final MonthDay monthDayOfAnnualFee = fromApiJsonHelper.extractMonthDayNamed(feeOnMonthDayParamName, element);
		 baseDataValidator.reset().parameter(feeOnMonthDayParamName).value(monthDayOfAnnualFee).ignoreIfNull();
	 }
	 if (this.fromApiJsonHelper.parameterExists(minBalanceForInterestCalculationParamName, element)) {
		 final BigDecimal minBalanceForInterestCalculation = this.fromApiJsonHelper.extractBigDecimalWithLocaleNamed( minBalanceForInterestCalculationParamName, element);
		 baseDataValidator.reset().parameter(minBalanceForInterestCalculationParamName).value(minBalanceForInterestCalculation) .ignoreIfNull().zeroOrPositiveAmount();
	 }
	 final Long savingsControlAccountId = fromApiJsonHelper.extractLongNamed( SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue(), element);
	 baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue()).value(savingsControlAccountId) .ignoreIfNull().integerGreaterThanZero();
	 final Long savingsReferenceAccountId = fromApiJsonHelper.extractLongNamed( SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue(), element);
	 baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue()) .value(savingsReferenceAccountId).ignoreIfNull().integerGreaterThanZero();
	 final Long transfersInSuspenseAccountId = fromApiJsonHelper.extractLongNamed( SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue(), element);
	 baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue()) .value(transfersInSuspenseAccountId).ignoreIfNull().integerGreaterThanZero();
	 final Long interestOnSavingsAccountId = fromApiJsonHelper.extractLongNamed( SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue(), element);
	 baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue()) .value(interestOnSavingsAccountId).ignoreIfNull().integerGreaterThanZero();
	 final Long incomeFromFeeId = fromApiJsonHelper.extractLongNamed(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue(), element);
	 baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue()).value(incomeFromFeeId) .ignoreIfNull().integerGreaterThanZero();
	 final Long incomeFromPenaltyId = fromApiJsonHelper.extractLongNamed( SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue(), element);
	 baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue()).value(incomeFromPenaltyId) .ignoreIfNull().integerGreaterThanZero();
	 validatePaymentChannelFundSourceMappings(fromApiJsonHelper, baseDataValidator, element);
	 validateChargeToIncomeAccountMappings(fromApiJsonHelper, baseDataValidator, element);
	 validateTaxWithHoldingParams(baseDataValidator, element, false);
 }",0,0,1,0
"public class RemoteWasbDelegationTokenManager implements WasbDelegationTokenManager {
	 public static final String KEY_DELEGATION_TOKEN_SERVICE_URLS = ""fs.azure.delegation.token.service.urls"";
	 public static final String DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_KEY = ""fs.azure.delegationtokenservice.http.retry.policy.enabled"";
	 public static final String DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_KEY = ""fs.azure.delegationtokenservice.http.retry.policy.spec"";
	 private static final String DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT = ""/tokenmanager/v1"";
	 private static final String DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_DEFAULT = ""10,3,100,2"";
	 private static final boolean DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_DEFAULT = true;
	 private static final Text WASB_DT_SERVICE_NAME = new Text(""WASB_DT_SERVICE"");
	 private static final String GET_DELEGATION_TOKEN_OP = ""GETDELEGATIONTOKEN"";
	 private static final String RENEW_DELEGATION_TOKEN_OP = ""RENEWDELEGATIONTOKEN"";
	 private static final String CANCEL_DELEGATION_TOKEN_OP = ""CANCELDELEGATIONTOKEN"";
	 private static final String OP_PARAM_KEY_NAME = ""op"";
	 private static final String RENEWER_PARAM_KEY_NAME = ""renewer"";
	 private static final String SERVICE_PARAM_KEY_NAME = ""service"";
	 private static final String TOKEN_PARAM_KEY_NAME = ""token"";
	 private WasbRemoteCallHelper remoteCallHelper;
	 private String[] dtServiceUrls;
	 private boolean isSpnegoTokenCacheEnabled;
	 public RemoteWasbDelegationTokenManager(Configuration conf) throws IOException {
		 RetryPolicy retryPolicy = RetryUtils.getMultipleLinearRandomRetry(conf, DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_KEY, DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_DEFAULT, DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_KEY, DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_DEFAULT);
		 this.isSpnegoTokenCacheEnabled = conf.getBoolean(Constants.AZURE_ENABLE_SPNEGO_TOKEN_CACHE, true);
		 remoteCallHelper = new SecureWasbRemoteCallHelper(retryPolicy, true, isSpnegoTokenCacheEnabled);
		 this.dtServiceUrls = conf.getTrimmedStrings(KEY_DELEGATION_TOKEN_SERVICE_URLS);
		 if (this.dtServiceUrls == null || this.dtServiceUrls.length <= 0) {
			 throw new IOException( KEY_DELEGATION_TOKEN_SERVICE_URLS + "" config not set"" + "" in configuration."");
		 }
	 }
	 public Token<DelegationTokenIdentifier> getDelegationToken( String renewer) throws IOException {
		 URIBuilder uriBuilder = new URIBuilder().setPath(DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT) .addParameter(OP_PARAM_KEY_NAME, GET_DELEGATION_TOKEN_OP) .addParameter(RENEWER_PARAM_KEY_NAME, renewer) .addParameter(SERVICE_PARAM_KEY_NAME, WASB_DT_SERVICE_NAME.toString());
		 String responseBody = remoteCallHelper .makeRemoteRequest(dtServiceUrls, uriBuilder.getPath(), uriBuilder.getQueryParams(), HttpGet.METHOD_NAME);
		 return TokenUtils.toDelegationToken(JsonUtils.parse(responseBody));
	 }
	 public long renewDelegationToken(Token<?> token) throws IOException {
		 URIBuilder uriBuilder = new URIBuilder().setPath(DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT) .addParameter(OP_PARAM_KEY_NAME, RENEW_DELEGATION_TOKEN_OP) .addParameter(TOKEN_PARAM_KEY_NAME, token.encodeToUrlString());
		 String responseBody = remoteCallHelper .makeRemoteRequest(dtServiceUrls, uriBuilder.getPath(), uriBuilder.getQueryParams(), HttpPut.METHOD_NAME);
		 Map<?, ?> parsedResp = JsonUtils.parse(responseBody);
		 return ((Number) parsedResp.get(""long"")).longValue();
	 }
	 public void cancelDelegationToken(Token<?> token) throws IOException {
		 URIBuilder uriBuilder = new URIBuilder().setPath(DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT) .addParameter(OP_PARAM_KEY_NAME, CANCEL_DELEGATION_TOKEN_OP) .addParameter(TOKEN_PARAM_KEY_NAME, token.encodeToUrlString());
		 remoteCallHelper.makeRemoteRequest(dtServiceUrls, uriBuilder.getPath(), uriBuilder.getQueryParams(), HttpPut.METHOD_NAME);
	 }
}",1,0,0,0
"public class Customer758Service {
	public Customer758Service(Customer758Repository repo) {
	}
}",0,0,0,0
"public class RequestSecurityManagerImpl implements RequestSecurityManager{
	 private final Request request;
	 private final Response response;
	 private final MetaDataLocator locator;
	 private final boolean securityEnabled;
	 private final ComponentEventLinkEncoder componentEventLinkEncoder;
	 public RequestSecurityManagerImpl(Request request, Response response, ComponentEventLinkEncoder componentEventLinkEncoder, MetaDataLocator locator, boolean securityEnabled) {
		 this.request = request;
		 this.response = response;
		 this.componentEventLinkEncoder = componentEventLinkEncoder;
		 this.locator = locator;
		 this.securityEnabled = securityEnabled;
	 }
	 public boolean checkForInsecureComponentEventRequest(ComponentEventRequestParameters parameters) throws IOException {
		 if (!needsRedirect(parameters.getActivePageName())) {
			 return false;
		 }
		 Link link = componentEventLinkEncoder.createComponentEventLink(parameters, false);
		 response.sendRedirect(link);
		 return true;
	 }
	 public boolean checkForInsecurePageRenderRequest(PageRenderRequestParameters parameters) throws IOException {
		 if (!needsRedirect(parameters.getLogicalPageName())) return false;
		 Link link = componentEventLinkEncoder.createPageRenderLink(parameters);
		 response.sendRedirect(link);
		 return true;
	 }
	 private boolean needsRedirect(String pageName) {
		 if (!securityEnabled) {
			 return false;
		 }
		 if (request.isSecure()) {
			 return false;
		 }
		 if (!isSecure(pageName)) {
			 return false;
		 }
		 return true;
	 }
	 private boolean isSecure(String pageName) {
		 return locator.findMeta(MetaDataConstants.SECURE_PAGE, pageName, Boolean.class);
	 }
	 public LinkSecurity checkPageSecurity(String pageName) {
		 if (!securityEnabled) {
			 return request.isSecure() ? LinkSecurity.SECURE : LinkSecurity.INSECURE;
		 }
		 boolean securePage = isSecure(pageName);
		 if (request.isSecure() == securePage) {
			 return securePage ? LinkSecurity.SECURE : LinkSecurity.INSECURE;
		 }
		 return securePage ? LinkSecurity.FORCE_SECURE : LinkSecurity.FORCE_INSECURE;
	 }
}",0,0,0,0
"public static JarMarker getInstance() {
	 return DEFAULT;
 }",0,0,0,0
"public class StatementSchema extends Statement {
	 int order;
	 Object[] arguments = ValuePool.emptyObjectArray;
	 boolean isSchemaDefinition;
	 Token[] statementTokens;
	 StatementSchema() {
		 super(StatementTypes.CREATE_SCHEMA, StatementTypes.X_SQL_SCHEMA_DEFINITION);
		 isTransactionStatement = true;
	 }
	 StatementSchema(String sql, int type, HsqlName readName, HsqlName writeName) {
		 this(sql, type, null, readName, writeName);
	 }
	 StatementSchema(String sql, int type, Object[] args) {
		 this(sql, type, args, null, null);
	 }
	 StatementSchema(String sql, int type, Object[] args, HsqlName readName, HsqlName writeName) {
		 super(type);
		 isTransactionStatement = true;
		 this.sql = sql;
		 if (args != null) {
			 arguments = args;
		 }
		 if (readName != null && readName != writeName) {
			 readTableNames = new HsqlName[]{
			 readName }
			;
		 }
		 if (writeName != null) {
			 writeTableNames = new HsqlName[]{
			 writeName }
			;
		 }
		 switch (type) {
			 case StatementTypes.RENAME_OBJECT : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 break;
			 case StatementTypes.ALTER_DOMAIN : case StatementTypes.ALTER_ROUTINE : case StatementTypes.ALTER_SEQUENCE : case StatementTypes.ALTER_TYPE : case StatementTypes.ALTER_TABLE : case StatementTypes.ALTER_TRANSFORM : case StatementTypes.ALTER_VIEW : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 break;
			 case StatementTypes.DROP_ASSERTION : case StatementTypes.DROP_CHARACTER_SET : case StatementTypes.DROP_COLLATION : case StatementTypes.DROP_TYPE : case StatementTypes.DROP_DOMAIN : case StatementTypes.DROP_ROLE : case StatementTypes.DROP_USER : case StatementTypes.DROP_ROUTINE : case StatementTypes.DROP_SCHEMA : case StatementTypes.DROP_SEQUENCE : case StatementTypes.DROP_TABLE : case StatementTypes.DROP_TRANSFORM : case StatementTypes.DROP_TRANSLATION : case StatementTypes.DROP_TRIGGER : case StatementTypes.DROP_CAST : case StatementTypes.DROP_ORDERING : case StatementTypes.DROP_VIEW : case StatementTypes.DROP_INDEX : case StatementTypes.DROP_CONSTRAINT : case StatementTypes.DROP_COLUMN : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 break;
			 case StatementTypes.GRANT : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 order = 10;
			 break;
			 case StatementTypes.GRANT_ROLE : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 order = 10;
			 break;
			 case StatementTypes.REVOKE : case StatementTypes.REVOKE_ROLE : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 break;
			 case StatementTypes.CREATE_SCHEMA : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 break;
			 case StatementTypes.CREATE_ROLE : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_ROUTINE : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 7;
			 break;
			 case StatementTypes.CREATE_SEQUENCE : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_TABLE : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 2;
			 break;
			 case StatementTypes.CREATE_TRANSFORM : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_TRANSLATION : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_TRIGGER : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 7;
			 break;
			 case StatementTypes.CREATE_CAST : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 2;
			 break;
			 case StatementTypes.CREATE_TYPE : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_ORDERING : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_VIEW : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 5;
			 break;
			 case StatementTypes.CREATE_USER : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_ASSERTION : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 9;
			 break;
			 case StatementTypes.CREATE_CHARACTER_SET : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_COLLATION : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_DOMAIN : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 1;
			 break;
			 case StatementTypes.CREATE_ALIAS : group = StatementTypes.X_SQL_SCHEMA_DEFINITION;
			 order = 8;
			 break;
			 case StatementTypes.CREATE_INDEX : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 order = 4;
			 break;
			 case StatementTypes.COMMENT : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 order = 11;
			 break;
			 case StatementTypes.CHECK : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 statementTokens = (Token[]) args[0];
			 break;
			 case StatementTypes.LOG_SCHEMA_STATEMENT : group = StatementTypes.X_SQL_SCHEMA_MANIPULATION;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""StatemntSchema"");
		 }
	 }
	 public Result execute(Session session) {
		 Result result;
		 try {
			 result = getResult(session);
		 }
		 catch (Throwable t) {
			 result = Result.newErrorResult(t, null);
		 }
		 if (result.isError()) {
			 result.getException().setStatementType(group, type);
			 return result;
		 }
		 session.database.schemaManager.setSchemaChangeTimestamp();
		 try {
			 if (isLogged) {
				 session.database.logger.writeToLog(session, sql);
			 }
		 }
		 catch (Throwable e) {
			 return Result.newErrorResult(e, sql);
		 }
		 return result;
	 }
	 Result getResult(Session session) {
		 SchemaManager schemaManager = session.database.schemaManager;
		 if (this.isExplain) {
			 return Result.newSingleColumnStringResult(""OPERATION"", describe(session));
		 }
		 switch (type) {
			 case StatementTypes.RENAME_OBJECT : {
				 HsqlName name = (HsqlName) arguments[0];
				 HsqlName newName = (HsqlName) arguments[1];
				 SchemaObject object;
				 if (name.type == SchemaObject.CATALOG) {
					 try {
						 session.checkAdmin();
						 session.checkDDLWrite();
						 name.rename(newName);
						 break;
					 }
					 catch (HsqlException e) {
						 return Result.newErrorResult(e, sql);
					 }
				 }
				 else if (name.type == SchemaObject.SCHEMA) {
					 checkSchemaUpdateAuthorisation(session, name);
					 schemaManager.checkSchemaNameCanChange(name);
					 schemaManager.renameSchema(name, newName);
					 break;
				 }
				 try {
					 name.setSchemaIfNull(session.getCurrentSchemaHsqlName());
					 if (name.type == SchemaObject.COLUMN) {
						 Table table = schemaManager.getUserTable(session, name.parent);
						 int index = table.getColumnIndex(name.name);
						 object = table.getColumn(index);
					 }
					 else {
						 object = schemaManager.getSchemaObject(name);
						 if (object == null) {
							 throw Error.error(ErrorCode.X_42501, name.name);
						 }
						 name = object.getName();
					 }
					 checkSchemaUpdateAuthorisation(session, name.schema);
					 newName.setSchemaIfNull(name.schema);
					 if (name.schema != newName.schema) {
						 HsqlException e = Error.error(ErrorCode.X_42505);
						 return Result.newErrorResult(e, sql);
					 }
					 newName.parent = name.parent;
					 switch (object.getType()) {
						 case SchemaObject.COLUMN : HsqlName parent = object.getName().parent;
						 schemaManager.checkColumnIsReferenced( parent, object.getName());
						 Table table = schemaManager.getUserTable(session, parent);
						 table.renameColumn((ColumnSchema) object, newName);
						 break;
						 default : schemaManager.renameSchemaObject(name, newName);
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.ALTER_SEQUENCE : {
				 try {
					 NumberSequence sequence = (NumberSequence) arguments[0];
					 NumberSequence settings = (NumberSequence) arguments[1];
					 checkSchemaUpdateAuthorisation(session, sequence.getSchemaName());
					 sequence.reset(settings);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.ALTER_DOMAIN : case StatementTypes.ALTER_ROUTINE : case StatementTypes.ALTER_TYPE : case StatementTypes.ALTER_TABLE : case StatementTypes.ALTER_TRANSFORM : {
				 try {
					 session.parser.reset(sql);
					 session.parser.read();
					 session.parser.processAlter();
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.ALTER_VIEW : {
				 View view = (View) arguments[0];
				 try {
					 checkSchemaUpdateAuthorisation(session, view.getSchemaName());
					 View oldView = (View) schemaManager.getSchemaObject(view.getName());
					 if (oldView == null) {
						 throw Error.error(ErrorCode.X_42501, view.getName().name);
					 }
					 view.setName(oldView.getName());
					 view.compile(session, null);
					 OrderedHashSet dependents = schemaManager.getReferencingObjectNames( oldView.getName());
					 if (dependents.getCommonElementCount(view.getReferences()) > 0) {
						 throw Error.error(ErrorCode.X_42502);
					 }
					 int i = schemaManager.getTableIndex(oldView);
					 schemaManager.setTable(i, view);
					 OrderedHashSet set = new OrderedHashSet();
					 set.add(view);
					 try {
						 schemaManager.recompileDependentObjects(set);
					 }
					 catch (HsqlException e) {
						 schemaManager.setTable(i, oldView);
						 schemaManager.recompileDependentObjects(set);
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.DROP_COLUMN : {
				 try {
					 HsqlName name = (HsqlName) arguments[0];
					 int objectType = ((Integer) arguments[1]).intValue();
					 boolean cascade = ((Boolean) arguments[2]).booleanValue();
					 boolean ifExists = ((Boolean) arguments[3]).booleanValue();
					 Table table = schemaManager.getUserTable(session, name.parent);
					 int colindex = table.getColumnIndex(name.name);
					 if (table.getColumnCount() == 1) {
						 throw Error.error(ErrorCode.X_42591);
					 }
					 checkSchemaUpdateAuthorisation(session, table.getSchemaName());
					 session.commit(false);
					 TableWorks tableWorks = new TableWorks(session, table);
					 tableWorks.dropColumn(colindex, cascade);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.DROP_ASSERTION : case StatementTypes.DROP_CHARACTER_SET : case StatementTypes.DROP_COLLATION : case StatementTypes.DROP_TYPE : case StatementTypes.DROP_DOMAIN : case StatementTypes.DROP_ROLE : case StatementTypes.DROP_USER : case StatementTypes.DROP_ROUTINE : case StatementTypes.DROP_SCHEMA : case StatementTypes.DROP_SEQUENCE : case StatementTypes.DROP_TABLE : case StatementTypes.DROP_TRANSFORM : case StatementTypes.DROP_TRANSLATION : case StatementTypes.DROP_TRIGGER : case StatementTypes.DROP_CAST : case StatementTypes.DROP_ORDERING : case StatementTypes.DROP_VIEW : case StatementTypes.DROP_INDEX : case StatementTypes.DROP_CONSTRAINT : {
				 try {
					 HsqlName name = (HsqlName) arguments[0];
					 int objectType = ((Integer) arguments[1]).intValue();
					 boolean cascade = ((Boolean) arguments[2]).booleanValue();
					 boolean ifExists = ((Boolean) arguments[3]).booleanValue();
					 switch (type) {
						 case StatementTypes.DROP_ROLE : case StatementTypes.DROP_USER : session.checkAdmin();
						 session.checkDDLWrite();
						 break;
						 case StatementTypes.DROP_SCHEMA : checkSchemaUpdateAuthorisation(session, name);
						 if (!schemaManager.schemaExists(name.name)) {
							 if (ifExists) {
								 return Result.updateZeroResult;
							 }
						 }
						 break;
						 default : if (name.schema == null) {
							 name.schema = session.getCurrentSchemaHsqlName();
						 }
						 else {
							 if (!schemaManager.schemaExists( name.schema.name)) {
								 if (ifExists) {
									 return Result.updateZeroResult;
								 }
							 }
						 }
						 name.schema = schemaManager.getUserSchemaHsqlName( name.schema.name);
						 checkSchemaUpdateAuthorisation(session, name.schema);
						 SchemaObject object = schemaManager.getSchemaObject(name);
						 if (object == null) {
							 if (ifExists) {
								 return Result.updateZeroResult;
							 }
							 throw Error.error(ErrorCode.X_42501, name.name);
						 }
						 if (name.type == SchemaObject.SPECIFIC_ROUTINE) {
							 name = ((Routine) object).getSpecificName();
						 }
						 else {
							 name = object.getName();
						 }
					 }
					 if (!cascade) {
						 schemaManager.checkObjectIsReferenced(name);
					 }
					 switch (type) {
						 case StatementTypes.DROP_ROLE : dropRole(session, name, cascade);
						 break;
						 case StatementTypes.DROP_USER : dropUser(session, name, cascade);
						 break;
						 case StatementTypes.DROP_SCHEMA : dropSchema(session, name, cascade);
						 break;
						 case StatementTypes.DROP_ASSERTION : break;
						 case StatementTypes.DROP_CHARACTER_SET : case StatementTypes.DROP_COLLATION : case StatementTypes.DROP_SEQUENCE : case StatementTypes.DROP_TRIGGER : dropObject(session, name, cascade);
						 break;
						 case StatementTypes.DROP_TYPE : dropType(session, name, cascade);
						 break;
						 case StatementTypes.DROP_DOMAIN : dropDomain(session, name, cascade);
						 break;
						 case StatementTypes.DROP_ROUTINE : dropRoutine(session, name, cascade);
						 break;
						 case StatementTypes.DROP_TABLE : case StatementTypes.DROP_VIEW : dropTable(session, name, cascade);
						 break;
						 case StatementTypes.DROP_TRANSFORM : case StatementTypes.DROP_TRANSLATION : case StatementTypes.DROP_CAST : case StatementTypes.DROP_ORDERING : break;
						 case StatementTypes.DROP_INDEX : checkSchemaUpdateAuthorisation(session, name.schema);
						 schemaManager.dropIndex(session, name);
						 break;
						 case StatementTypes.DROP_CONSTRAINT : checkSchemaUpdateAuthorisation(session, name.schema);
						 schemaManager.dropConstraint(session, name, cascade);
						 break;
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.GRANT : case StatementTypes.REVOKE : {
				 try {
					 boolean grant = type == StatementTypes.GRANT;
					 OrderedHashSet granteeList = (OrderedHashSet) arguments[0];
					 HsqlName name = (HsqlName) arguments[1];
					 this.setSchemaName(session, null, name);
					 name = schemaManager.getSchemaObjectName(name.schema, name.name, name.type, true);
					 SchemaObject schemaObject = schemaManager.getSchemaObject(name);
					 Right right = (Right) arguments[2];
					 Grantee grantor = (Grantee) arguments[3];
					 boolean cascade = ((Boolean) arguments[4]).booleanValue();
					 boolean isGrantOption = ((Boolean) arguments[5]).booleanValue();
					 if (grantor == null) {
						 grantor = isSchemaDefinition ? schemaName.owner : session.getGrantee();
					 }
					 GranteeManager gm = session.database.granteeManager;
					 switch (schemaObject.getType()) {
						 case SchemaObject.CHARSET : System.out.println(""grant charset!"");
						 break;
						 case SchemaObject.VIEW : case SchemaObject.TABLE : {
							 Table t = (Table) schemaObject;
							 right.setColumns(t);
							 if (t.getTableType() == TableBase.TEMP_TABLE && !right.isFull()) {
								 return Result.newErrorResult( Error.error(ErrorCode.X_42595), sql);
							 }
						 }
					 }
					 if (grant) {
						 gm.grant(granteeList, schemaObject, right, grantor, isGrantOption);
					 }
					 else {
						 gm.revoke(granteeList, schemaObject, right, grantor, isGrantOption, cascade);
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.GRANT_ROLE : case StatementTypes.REVOKE_ROLE : {
				 try {
					 boolean grant = type == StatementTypes.GRANT_ROLE;
					 OrderedHashSet granteeList = (OrderedHashSet) arguments[0];
					 OrderedHashSet roleList = (OrderedHashSet) arguments[1];
					 Grantee grantor = (Grantee) arguments[2];
					 boolean cascade = ((Boolean) arguments[3]).booleanValue();
					 GranteeManager gm = session.database.granteeManager;
					 gm.checkGranteeList(granteeList);
					 for (int i = 0;
					 i < granteeList.size();
					 i++) {
						 String grantee = (String) granteeList.get(i);
						 gm.checkRoleList(grantee, roleList, grantor, grant);
					 }
					 if (grant) {
						 for (int i = 0;
						 i < granteeList.size();
						 i++) {
							 String grantee = (String) granteeList.get(i);
							 for (int j = 0;
							 j < roleList.size();
							 j++) {
								 String roleName = (String) roleList.get(j);
								 gm.grant(grantee, roleName, grantor);
							 }
						 }
					 }
					 else {
						 for (int i = 0;
						 i < granteeList.size();
						 i++) {
							 String grantee = (String) granteeList.get(i);
							 for (int j = 0;
							 j < roleList.size();
							 j++) {
								 gm.revoke(grantee, (String) roleList.get(j), grantor);
							 }
						 }
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_ASSERTION : {
				 return Result.updateZeroResult;
			 }
			 case StatementTypes.CREATE_CHARACTER_SET : {
				 Charset charset = (Charset) arguments[0];
				 try {
					 setOrCheckObjectName(session, null, charset.getName(), true);
					 schemaManager.addSchemaObject(charset);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_COLLATION : {
				 return Result.updateZeroResult;
			 }
			 case StatementTypes.CREATE_ROLE : {
				 try {
					 session.checkAdmin();
					 session.checkDDLWrite();
					 HsqlName name = (HsqlName) arguments[0];
					 session.database.getGranteeManager().addRole(name);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_USER : {
				 HsqlName name = (HsqlName) arguments[0];
				 String password = (String) arguments[1];
				 Grantee grantor = (Grantee) arguments[2];
				 boolean admin = ((Boolean) arguments[3]).booleanValue();
				 try {
					 session.checkAdmin();
					 session.checkDDLWrite();
					 session.database.getUserManager().createUser(name, password);
					 if (admin) {
						 session.database.getGranteeManager().grant(name.name, SqlInvariants.DBA_ADMIN_ROLE_NAME, grantor);
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_SCHEMA : {
				 HsqlName name = (HsqlName) arguments[0];
				 Grantee owner = (Grantee) arguments[1];
				 try {
					 session.checkDDLWrite();
					 if (schemaManager.schemaExists(name.name)) {
						 if (session.isProcessingScript && SqlInvariants.PUBLIC_SCHEMA.equals( name.name)) {
						}
						 else {
							 throw Error.error(ErrorCode.X_42504, name.name);
						 }
					 }
					 else {
						 schemaManager.createSchema(name, owner);
						 Schema schema = schemaManager.findSchema(name.name);
						 this.sql = schema.getSQL();
						 if (session.isProcessingScript() && session.database.getProperties() .isVersion18()) {
							 session.setSchema(schema.getName().name);
						 }
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_ROUTINE : {
				 Routine routine = (Routine) arguments[0];
				 try {
					 routine.resolve(session);
					 setOrCheckObjectName(session, null, routine.getName(), false);
					 schemaManager.addSchemaObject(routine);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_ALIAS : {
				 HsqlName name = (HsqlName) arguments[0];
				 Routine[] routines = (Routine[]) arguments[1];
				 try {
					 session.checkAdmin();
					 session.checkDDLWrite();
					 if (name != null) {
						 for (int i = 0;
						 i < routines.length;
						 i++) {
							 routines[i].setName(name);
							 schemaManager.addSchemaObject(routines[i]);
						 }
					 }
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_SEQUENCE : {
				 NumberSequence sequence = (NumberSequence) arguments[0];
				 try {
					 setOrCheckObjectName(session, null, sequence.getName(), true);
					 schemaManager.addSchemaObject(sequence);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_DOMAIN : {
				 Type type = (Type) arguments[0];
				 Constraint[] constraints = type.userTypeModifier.getConstraints();
				 try {
					 setOrCheckObjectName(session, null, type.getName(), true);
					 for (int i = 0;
					 i < constraints.length;
					 i++) {
						 Constraint c = constraints[i];
						 setOrCheckObjectName(session, type.getName(), c.getName(), true);
						 schemaManager.addSchemaObject(c);
					 }
					 schemaManager.addSchemaObject(type);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_TABLE : {
				 Table table = (Table) arguments[0];
				 HsqlArrayList tempConstraints = (HsqlArrayList) arguments[1];
				 StatementDMQL statement = (StatementDMQL) arguments[2];
				 HsqlArrayList foreignConstraints = null;
				 try {
					 setOrCheckObjectName(session, null, table.getName(), true);
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
				 try {
					 if (isSchemaDefinition) {
						 foreignConstraints = new HsqlArrayList();
					 }
					 if (tempConstraints != null) {
						 table = ParserDDL.addTableConstraintDefinitions(session, table, tempConstraints, foreignConstraints, true);
						 arguments[1] = foreignConstraints;
					 }
					 table.compile(session, null);
					 schemaManager.addSchemaObject(table);
					 if (statement != null) {
						 Result result = statement.execute(session);
						 table.insertIntoTable(session, result);
					 }
					 if (table.hasLobColumn) {
						 RowIterator it = table.rowIterator(session);
						 while (it.hasNext()) {
							 Row row = it.getNextRow();
							 Object[] data = row.getData();
							 session.sessionData.adjustLobUsageCount(table, data, 1);
						 }
					 }
					 return Result.updateZeroResult;
				 }
				 catch (HsqlException e) {
					 schemaManager.removeExportedKeys(table);
					 schemaManager.removeDependentObjects(table.getName());
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_TRANSFORM : return Result.updateZeroResult;
			 case StatementTypes.CREATE_TRANSLATION : return Result.updateZeroResult;
			 case StatementTypes.CREATE_TRIGGER : {
				 TriggerDef trigger = (TriggerDef) arguments[0];
				 HsqlName otherName = (HsqlName) arguments[1];
				 try {
					 checkSchemaUpdateAuthorisation(session, trigger.getSchemaName());
					 schemaManager.checkSchemaObjectNotExists( trigger.getName());
					 if (otherName != null) {
						 if (schemaManager.getSchemaObject(otherName) == null) {
							 throw Error.error(ErrorCode.X_42501, otherName.name);
						 }
					 }
					 trigger.table.addTrigger(trigger, otherName);
					 schemaManager.addSchemaObject(trigger);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_CAST : return Result.updateZeroResult;
			 case StatementTypes.CREATE_TYPE : {
				 Type type = (Type) arguments[0];
				 try {
					 setOrCheckObjectName(session, null, type.getName(), true);
					 schemaManager.addSchemaObject(type);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_ORDERING : return Result.updateZeroResult;
			 case StatementTypes.CREATE_VIEW : {
				 View view = (View) arguments[0];
				 try {
					 checkSchemaUpdateAuthorisation(session, view.getSchemaName());
					 schemaManager.checkSchemaObjectNotExists(view.getName());
					 view.compile(session, null);
					 schemaManager.addSchemaObject(view);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.CREATE_INDEX : {
				 Table table;
				 HsqlName name;
				 int[] indexColumns;
				 boolean unique;
				 table = (Table) arguments[0];
				 indexColumns = (int[]) arguments[1];
				 name = (HsqlName) arguments[2];
				 unique = ((Boolean) arguments[3]).booleanValue();
				 try {
					 setOrCheckObjectName(session, table.getName(), name, true);
					 TableWorks tableWorks = new TableWorks(session, table);
					 tableWorks.addIndex(indexColumns, name, unique);
					 break;
				 }
				 catch (HsqlException e) {
					 return Result.newErrorResult(e, sql);
				 }
			 }
			 case StatementTypes.COMMENT : {
				 HsqlName name = (HsqlName) arguments[0];
				 String comment = (String) arguments[1];
				 switch (name.type) {
					 case SchemaObject.COLUMN : {
						 Table table = (Table) schemaManager.getSchemaObject( name.parent.name, name.parent.schema.name, SchemaObject.TABLE);
						 if (!session.getGrantee().isFullyAccessibleByRole( table.getName())) {
							 throw Error.error(ErrorCode.X_42501);
						 }
						 int index = table.getColumnIndex(name.name);
						 if (index < 0) {
							 throw Error.error(ErrorCode.X_42501);
						 }
						 ColumnSchema column = table.getColumn(index);
						 column.getName().comment = comment;
						 break;
					 }
					 case SchemaObject.ROUTINE : {
						 RoutineSchema routine = (RoutineSchema) schemaManager.getSchemaObject( name.name, name.schema.name, SchemaObject.ROUTINE);
						 if (!session.getGrantee().isFullyAccessibleByRole( routine.getName())) {
							 throw Error.error(ErrorCode.X_42501);
						 }
						 routine.getName().comment = comment;
						 break;
					 }
					 case SchemaObject.TABLE : {
						 Table table = (Table) schemaManager.getSchemaObject(name.name, name.schema.name, SchemaObject.TABLE);
						 if (!session.getGrantee().isFullyAccessibleByRole( table.getName())) {
							 throw Error.error(ErrorCode.X_42501);
						 }
						 table.getName().comment = comment;
						 break;
					 }
				 }
				 break;
			 }
			 case StatementTypes.LOG_SCHEMA_STATEMENT : break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""CompiledStateemntSchema"");
		 }
		 return Result.updateZeroResult;
	 }
	 private void dropType(Session session, HsqlName name, boolean cascade) {
		 checkSchemaUpdateAuthorisation(session, name.schema);
		 Type distinct = (Type) session.database.schemaManager.getSchemaObject(name);
		 session.database.schemaManager.removeSchemaObject(name, cascade);
		 distinct.userTypeModifier = null;
	 }
	 private static void dropDomain(Session session, HsqlName name, boolean cascade) {
		 Type domain = (Type) session.database.schemaManager.getSchemaObject(name);
		 OrderedHashSet set = session.database.schemaManager.getReferencingObjectNames( domain.getName());
		 if (!cascade && set.size() > 0) {
			 HsqlName objectName = (HsqlName) set.get(0);
			 throw Error.error(ErrorCode.X_42502, objectName.getSchemaQualifiedStatementName());
		 }
		 Constraint[] constraints = domain.userTypeModifier.getConstraints();
		 set = new OrderedHashSet();
		 for (int i = 0;
		 i < constraints.length;
		 i++) {
			 set.add(constraints[i].getName());
		 }
		 session.database.schemaManager.removeSchemaObjects(set);
		 session.database.schemaManager.removeSchemaObject(domain.getName(), cascade);
		 domain.userTypeModifier = null;
	 }
	 private static void dropRole(Session session, HsqlName name, boolean cascade) {
		 Grantee role = session.database.getGranteeManager().getRole(name.name);
		 if (!cascade && session.database.schemaManager.hasSchemas(role)) {
			 HsqlArrayList list = session.database.schemaManager.getSchemas(role);
			 Schema schema = (Schema) list.get(0);
			 throw Error.error(ErrorCode.X_42502, schema.getName().statementName);
		 }
		 session.database.schemaManager.dropSchemas(session, role, cascade);
		 session.database.getGranteeManager().dropRole(name.name);
	 }
	 private static void dropUser(Session session, HsqlName name, boolean cascade) {
		 Grantee grantee = session.database.getUserManager().get(name.name);
		 if (session.database.getSessionManager().isUserActive(name.name)) {
			 throw Error.error(ErrorCode.X_42539);
		 }
		 if (!cascade && session.database.schemaManager.hasSchemas(grantee)) {
			 HsqlArrayList list = session.database.schemaManager.getSchemas(grantee);
			 Schema schema = (Schema) list.get(0);
			 throw Error.error(ErrorCode.X_42502, schema.getName().statementName);
		 }
		 session.database.schemaManager.dropSchemas(session, grantee, cascade);
		 session.database.getUserManager().dropUser(name.name);
	 }
	 private void dropSchema(Session session, HsqlName name, boolean cascade) {
		 HsqlName schema = session.database.schemaManager.getUserSchemaHsqlName(name.name);
		 checkSchemaUpdateAuthorisation(session, schema);
		 session.database.schemaManager.dropSchema(session, name.name, cascade);
	 }
	 private void dropRoutine(Session session, HsqlName name, boolean cascade) {
		 checkSchemaUpdateAuthorisation(session, name.schema);
		 session.database.schemaManager.removeSchemaObject(name, cascade);
	 }
	 private void dropObject(Session session, HsqlName name, boolean cascade) {
		 name = session.database.schemaManager.getSchemaObjectName(name.schema, name.name, name.type, true);
		 session.database.schemaManager.removeSchemaObject(name, cascade);
	 }
	 private void dropTable(Session session, HsqlName name, boolean cascade) {
		 Table table = session.database.schemaManager.findUserTable(session, name.name, name.schema.name);
		 session.database.schemaManager.dropTableOrView(session, table, cascade);
	 }
	 void checkSchemaUpdateAuthorisation(Session session, HsqlName schema) {
		 if (session.isProcessingLog) {
			 return;
		 }
		 if (SqlInvariants.isSystemSchemaName(schema.name)) {
			 throw Error.error(ErrorCode.X_42503);
		 }
		 if (session.parser.isSchemaDefinition) {
			 if (schema == session.getCurrentSchemaHsqlName()) {
				 return;
			 }
			 Error.error(ErrorCode.X_42505, schema.name);
		 }
		 session.getGrantee().checkSchemaUpdateOrGrantRights(schema.name);
		 session.checkDDLWrite();
	 }
	 void setOrCheckObjectName(Session session, HsqlName parent, HsqlName name, boolean check) {
		 if (name.schema == null) {
			 name.schema = schemaName == null ? session.getCurrentSchemaHsqlName() : schemaName;
		 }
		 else {
			 name.schema = session.getSchemaHsqlName(name.schema.name);
			 if (name.schema == null) {
				 throw Error.error(ErrorCode.X_42505);
			 }
			 if (isSchemaDefinition && schemaName != name.schema) {
				 throw Error.error(ErrorCode.X_42505);
			 }
		 }
		 name.parent = parent;
		 if (!isSchemaDefinition) {
			 checkSchemaUpdateAuthorisation(session, name.schema);
		 }
		 if (check) {
			 session.database.schemaManager.checkSchemaObjectNotExists(name);
		 }
	 }
	 void setSchemaName(Session session, HsqlName parent, HsqlName name) {
		 if (name.schema == null) {
			 name.schema = schemaName == null ? session.getCurrentSchemaHsqlName() : schemaName;
		 }
		 else {
			 name.schema = session.getSchemaHsqlName(name.schema.name);
			 if (name.schema == null) {
				 throw Error.error(ErrorCode.X_42505);
			 }
			 if (isSchemaDefinition && schemaName != name.schema) {
				 throw Error.error(ErrorCode.X_42505);
			 }
		 }
	 }
	 public boolean isAutoCommitStatement() {
		 return true;
	 }
	 public String describe(Session session) {
		 return sql;
	 }
}",1,0,0,0
"private void mainSort() {
	 int i, j, ss, sb;
	 int[] runningOrder = new int[256];
	 int[] copy = new int[256];
	 boolean[] bigDone = new boolean[256];
	 int c1, c2;
	 int numQSorted;
	 for (i = 0;
	 i < NUM_OVERSHOOT_BYTES;
	 i++) {
		 block[last + i + 2] = block[(i % (last + 1)) + 1];
	 }
	 for (i = 0;
	 i <= last + NUM_OVERSHOOT_BYTES;
	 i++) {
		 quadrant[i] = 0;
	 }
	 block[0] = (char) (block[last + 1]);
	 if (last < 4000) {
		 for (i = 0;
		 i <= last;
		 i++) {
			 zptr[i] = i;
		 }
		 firstAttempt = false;
		 workDone = workLimit = 0;
		 simpleSort(0, last, 0);
	 }
	 else {
		 numQSorted = 0;
		 for (i = 0;
		 i <= 255;
		 i++) {
			 bigDone[i] = false;
		 }
		 for (i = 0;
		 i <= 65536;
		 i++) {
			 ftab[i] = 0;
		 }
		 c1 = block[0];
		 for (i = 0;
		 i <= last;
		 i++) {
			 c2 = block[i + 1];
			 ftab[(c1 << 8) + c2]++;
			 c1 = c2;
		 }
		 for (i = 1;
		 i <= 65536;
		 i++) {
			 ftab[i] += ftab[i - 1];
		 }
		 c1 = block[1];
		 for (i = 0;
		 i < last;
		 i++) {
			 c2 = block[i + 2];
			 j = (c1 << 8) + c2;
			 c1 = c2;
			 ftab[j]--;
			 zptr[ftab[j]] = i;
		 }
		 j = ((block[last + 1]) << 8) + (block[1]);
		 ftab[j]--;
		 zptr[ftab[j]] = last;
		 for (i = 0;
		 i <= 255;
		 i++) {
			 runningOrder[i] = i;
		 }
		 {
			 int vv;
			 int h = 1;
			 do {
				 h = 3 * h + 1;
			 }
			 while (h <= 256);
			 do {
				 h = h / 3;
				 for (i = h;
				 i <= 255;
				 i++) {
					 vv = runningOrder[i];
					 j = i;
					 while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {
						 runningOrder[j] = runningOrder[j - h];
						 j = j - h;
						 if (j <= (h - 1)) {
							 break;
						 }
					 }
					 runningOrder[j] = vv;
				 }
			 }
			 while (h != 1);
		 }
		 for (i = 0;
		 i <= 255;
		 i++) {
			 ss = runningOrder[i];
			 for (j = 0;
			 j <= 255;
			 j++) {
				 sb = (ss << 8) + j;
				 if (!((ftab[sb] & SETMASK) == SETMASK)) {
					 int lo = ftab[sb] & CLEARMASK;
					 int hi = (ftab[sb + 1] & CLEARMASK) - 1;
					 if (hi > lo) {
						 qSort3(lo, hi, 2);
						 numQSorted += (hi - lo + 1);
						 if (workDone > workLimit && firstAttempt) {
							 return;
						 }
					 }
					 ftab[sb] |= SETMASK;
				 }
			 }
			 bigDone[ss] = true;
			 if (i < 255) {
				 int bbStart = ftab[ss << 8] & CLEARMASK;
				 int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
				 int shifts = 0;
				 while ((bbSize >> shifts) > 65534) {
					 shifts++;
				 }
				 for (j = 0;
				 j < bbSize;
				 j++) {
					 int a2update = zptr[bbStart + j];
					 int qVal = (j >> shifts);
					 quadrant[a2update] = qVal;
					 if (a2update < NUM_OVERSHOOT_BYTES) {
						 quadrant[a2update + last + 1] = qVal;
					 }
				 }
				 if (!(((bbSize - 1) >> shifts) <= 65535)) {
					 panic();
				 }
			 }
			 for (j = 0;
			 j <= 255;
			 j++) {
				 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
			 }
			 for (j = ftab[ss << 8] & CLEARMASK;
			 j < (ftab[(ss + 1) << 8] & CLEARMASK);
			 j++) {
				 c1 = block[zptr[j]];
				 if (!bigDone[c1]) {
					 zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;
					 copy[c1]++;
				 }
			 }
			 for (j = 0;
			 j <= 255;
			 j++) {
				 ftab[(j << 8) + ss] |= SETMASK;
			 }
		 }
	 }
 }",0,0,1,0
"public class Cluster {
	 private final Configuration configuration;
	 public Cluster(PigContext context) {
		 configuration = ConfigurationUtil.toConfiguration(context.getProperties());
	 }
	 public boolean exists(Path destination) throws IOException {
		 FileSystem fs = destination.getFileSystem(configuration);
		 return fs.exists(destination);
	 }
	 public void update(Path local, Path destination) throws IOException {
		 if (! exists(destination) || ! sameSize(local, destination)) {
			 copyFromLocalFile(local, destination, true);
		 }
	 }
	 public void copyFromLocalFile(Path local, Path destination) throws IOException {
		 copyFromLocalFile(local, destination, true);
	 }
	 public void copyFromLocalFile(Path local, Path destination, boolean overwrite) throws IOException {
		 FileSystem fs = local.getFileSystem(configuration);
		 fs.copyFromLocalFile(false, overwrite, local, destination);
	 }
	 public void copyFromLocalFile(String[] content, String destination) throws IOException {
		 copyFromLocalFile(content, destination, true);
	 }
	 public void copyFromLocalFile(String[] content, String destination, boolean overwrite) throws IOException {
		 Path file = new Path(destination);
		 FileSystem fs = file.getFileSystem(configuration);
		 if (overwrite && fs.exists(file)) {
			 fs.delete(file, true);
		 }
		 Util.createInputFile(fs, destination, content);
	 }
	 public void copyFromLocalFile(String[][] data) throws IOException {
		 copyFromLocalFile(data, false);
	 }
	 public void copyFromLocalFile(String[][] data, boolean overwrite) throws IOException {
		 for (int i = 0;
		 i < data.length;
		 i++) {
			 copyFromLocalFile(new Path(data[i][0]), new Path(data[i][1]), overwrite);
		 }
	 }
	 public FileStatus[] listStatus(Path path) throws IOException {
		 FileSystem fs = path.getFileSystem(configuration);
		 return fs.listStatus(path);
	 }
	 public boolean delete(Path path) throws IOException {
		 FileSystem fs = path.getFileSystem(configuration);
		 return fs.delete(path, true);
	 }
	 private boolean sameSize(Path local, Path destination) throws IOException {
		 FileSystem fs1 = FileSystem.getLocal(configuration);
		 FileSystem fs2 = destination.getFileSystem(configuration);
		 return fs1.getFileStatus(local).getLen() == fs2.getFileStatus(destination).getLen();
	 }
}",1,0,0,0
"public class VirtualMachineEntityImpl implements VirtualMachineEntity {
	 private VMEntityManager manager;
	 private VMEntityVO vmEntityVO;
	 public VirtualMachineEntityImpl() {
	 }
	 public void init(String vmId) {
		 this.vmEntityVO = this.manager.loadVirtualMachine(vmId);
	 }
	 public void init(String vmId, String owner, String hostName, String displayName, int cpu, int speed, long memory, List<String> computeTags, List<String> rootDiskTags, List<String> networks) {
		 init(vmId);
		 this.vmEntityVO.setOwner(owner);
		 this.vmEntityVO.setHostname(hostName);
		 this.vmEntityVO.setDisplayname(displayName);
		 this.vmEntityVO.setComputeTags(computeTags);
		 this.vmEntityVO.setRootDiskTags(rootDiskTags);
		 this.vmEntityVO.setNetworkIds(networks);
		 manager.saveVirtualMachine(vmEntityVO);
	 }
	 public VirtualMachineEntityImpl(String vmId, VMEntityManager manager) {
		 this.manager = manager;
		 this.vmEntityVO = this.manager.loadVirtualMachine(vmId);
	 }
	 public VirtualMachineEntityImpl(String vmId, String owner, String hostName, String displayName, int cpu, int speed, long memory, List<String> computeTags, List<String> rootDiskTags, List<String> networks, VMEntityManager manager) {
		 this(vmId, manager);
		 this.vmEntityVO.setOwner(owner);
		 this.vmEntityVO.setHostname(hostName);
		 this.vmEntityVO.setDisplayname(displayName);
		 this.vmEntityVO.setComputeTags(computeTags);
		 this.vmEntityVO.setRootDiskTags(rootDiskTags);
		 this.vmEntityVO.setNetworkIds(networks);
		 manager.saveVirtualMachine(vmEntityVO);
	 }
	 public String getUuid() {
		 return vmEntityVO.getUuid();
	 }
	 public long getId() {
		 return vmEntityVO.getId();
	 }
	 public String getCurrentState() {
		 return null;
	 }
	 public String getDesiredState() {
		 return null;
	 }
	 public Date getCreatedTime() {
		 return vmEntityVO.getCreated();
	 }
	 public Date getLastUpdatedTime() {
		 return vmEntityVO.getUpdateTime();
	 }
	 public String getOwner() {
		 return null;
	 }
	 public Map<String, String> getDetails() {
		 return vmEntityVO.getDetails();
	 }
	 public void addDetail(String name, String value) {
		 vmEntityVO.setDetail(name, value);
	 }
	 public void delDetail(String name, String value) {
	 }
	 public void updateDetail(String name, String value) {
	 }
	 public List<Method> getApplicableActions() {
		 return null;
	 }
	 public List<String> listVolumeIds() {
		 return null;
	 }
	 public List<VolumeEntity> listVolumes() {
		 return null;
	 }
	 public List<String> listNicUuids() {
		 return null;
	 }
	 public List<NicEntity> listNics() {
		 return null;
	 }
	 public TemplateEntity getTemplate() {
		 return null;
	 }
	 public List<String> listTags() {
		 return null;
	 }
	 public void addTag() {
	 }
	 public void delTag() {
	 }
	 public String reserve(DeploymentPlanner plannerToUse, DeploymentPlan plan, ExcludeList exclude, String caller) throws InsufficientCapacityException, ResourceUnavailableException {
		 return manager.reserveVirtualMachine(this.vmEntityVO, plannerToUse, plan, exclude);
	 }
	 public void migrateTo(String reservationId, String caller) {
	 }
	 public void deploy(String reservationId, String caller, Map<VirtualMachineProfile.Param, Object> params, boolean deployOnGivenHost) throws InsufficientCapacityException, ResourceUnavailableException {
		 manager.deployVirtualMachine(reservationId, this.vmEntityVO, caller, params, deployOnGivenHost);
	 }
	 public boolean stop(String caller) throws ResourceUnavailableException {
		 return manager.stopvirtualmachine(this.vmEntityVO, caller);
	 }
	 public boolean stopForced(String caller) throws ResourceUnavailableException {
		 return manager.stopvirtualmachineforced(this.vmEntityVO, caller);
	 }
	 public void cleanup() {
	 }
	 public boolean destroy(String caller, boolean expunge) throws AgentUnavailableException, OperationTimedoutException, ConcurrentOperationException {
		 return manager.destroyVirtualMachine(this.vmEntityVO, caller, expunge);
	 }
	 public VirtualMachineEntity duplicate(String externalId) {
		 return null;
	 }
	 public SnapshotEntity takeSnapshotOf() {
		 return null;
	 }
	 public void attach(VolumeEntity volume, short deviceId) {
	 }
	 public void detach(VolumeEntity volume) {
	 }
	 public void connectTo(NetworkEntity network, short nicId) {
	 }
	 public void disconnectFrom(NetworkEntity netowrk, short nicId) {
	 }
}",1,1,0,0
"public class MediaParser extends AbstractParser<MediaSource> {
	 public MediaParser() {
		 super(AltFormat.MEDIA, MediaSource.class);
	 }
	 public <R extends MediaSource> R parse(ParseSource parseSource, InputProperties inProps, Class<R> resultClass) {
		 Preconditions.checkArgument(resultClass.isAssignableFrom(MediaSource.class), ""Result class must be "" + MediaSource.class.getName());
		 InputStream inputStream = parseSource.getInputStream();
		 Preconditions.checkNotNull(inputStream, ""Parse source must be stream-based"");
		 MediaStreamSource mediaSource = new MediaStreamSource(inputStream, inProps.getContentType().toString());
		 return resultClass.cast(mediaSource);
	 }
}",0,0,0,0
"public class MarshallingMethodEndpointAdapter extends AbstractMethodEndpointAdapter implements InitializingBean {
	private Marshaller marshaller;
	private Unmarshaller unmarshaller;
	public MarshallingMethodEndpointAdapter() {
	}
	public MarshallingMethodEndpointAdapter(Marshaller marshaller) {
		Assert.notNull(marshaller, ""marshaller must not be null"");
		if (!(marshaller instanceof Unmarshaller)) {
			throw new IllegalArgumentException(""Marshaller ["" + marshaller + ""] does not implement the Unmarshaller "" +""interface. Please set an Unmarshaller explicitly by using the "" +""MarshallingMethodEndpointAdapter(Marshaller, Unmarshaller) constructor."");
		}
		else {
			this.setMarshaller(marshaller);
			this.setUnmarshaller((Unmarshaller) marshaller);
		}
	}
	public MarshallingMethodEndpointAdapter(Marshaller marshaller, Unmarshaller unmarshaller) {
		Assert.notNull(marshaller, ""marshaller must not be null"");
		Assert.notNull(unmarshaller, ""unmarshaller must not be null"");
		this.setMarshaller(marshaller);
		this.setUnmarshaller(unmarshaller);
	}
	public Marshaller getMarshaller() {
		return marshaller;
	}
	public final void setMarshaller(Marshaller marshaller) {
		this.marshaller = marshaller;
	}
	public Unmarshaller getUnmarshaller() {
		return unmarshaller;
	}
	public final void setUnmarshaller(Unmarshaller unmarshaller) {
		this.unmarshaller = unmarshaller;
	}
	public void afterPropertiesSet() throws Exception {
		Assert.notNull(getMarshaller(), ""marshaller is required"");
		Assert.notNull(getUnmarshaller(), ""unmarshaller is required"");
	}
	protected void invokeInternal(MessageContext messageContext, MethodEndpoint methodEndpoint) throws Exception {
		WebServiceMessage request = messageContext.getRequest();
		Object requestObject = unmarshalRequest(request);
		Object responseObject = methodEndpoint.invoke(new Object[]{
		requestObject}
		);
		if (responseObject != null) {
			WebServiceMessage response = messageContext.getResponse();
			marshalResponse(responseObject, response);
		}
	}
	private Object unmarshalRequest(WebServiceMessage request) throws IOException {
		Object requestObject = MarshallingUtils.unmarshal(getUnmarshaller(), request);
		if (logger.isDebugEnabled()) {
			logger.debug(""Unmarshalled payload request to ["" + requestObject + ""]"");
		}
		return requestObject;
	}
	private void marshalResponse(Object responseObject, WebServiceMessage response) throws IOException {
		if (logger.isDebugEnabled()) {
			logger.debug(""Marshalling ["" + responseObject + ""] to response payload"");
		}
		MarshallingUtils.marshal(getMarshaller(), responseObject, response);
	}
	protected boolean supportsInternal(MethodEndpoint methodEndpoint) {
		Method method = methodEndpoint.getMethod();
		return supportsReturnType(method) && supportsParameters(method);
	}
	private boolean supportsReturnType(Method method) {
		return (Void.TYPE.equals(method.getReturnType()) || getMarshaller().supports(method.getReturnType()));
	}
	private boolean supportsParameters(Method method) {
		if (method.getParameterTypes().length != 1) {
			return false;
		}
		else {
			return getUnmarshaller().supports(method.getParameterTypes()[0]);
		}
	}
}",0,0,0,0
"public class GroupMultiplicitiesElements extends AbstractParserRuleElementFinder {
	private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.xtext.validation.ConcreteSyntaxValidationTestLanguage.GroupMultiplicities"");
	private final Group cGroup = (Group)rule.eContents().get(1);
	private final Keyword cNumberSignDigitFourKeyword_0 = (Keyword)cGroup.eContents().get(0);
	private final Assignment cVal1Assignment_1 = (Assignment)cGroup.eContents().get(1);
	private final RuleCall cVal1IDTerminalRuleCall_1_0 = (RuleCall)cVal1Assignment_1.eContents().get(0);
	private final Keyword cKw1Keyword_2 = (Keyword)cGroup.eContents().get(2);
	private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
	private final Assignment cVal2Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
	private final RuleCall cVal2IDTerminalRuleCall_3_0_0 = (RuleCall)cVal2Assignment_3_0.eContents().get(0);
	private final Assignment cVal3Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
	private final RuleCall cVal3IDTerminalRuleCall_3_1_0 = (RuleCall)cVal3Assignment_3_1.eContents().get(0);
	private final Keyword cKw2Keyword_4 = (Keyword)cGroup.eContents().get(4);
	private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
	private final Assignment cVal4Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
	private final RuleCall cVal4IDTerminalRuleCall_5_0_0 = (RuleCall)cVal4Assignment_5_0.eContents().get(0);
	private final Assignment cVal5Assignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
	private final RuleCall cVal5IDTerminalRuleCall_5_1_0 = (RuleCall)cVal5Assignment_5_1.eContents().get(0);
	private final Keyword cKw3Keyword_6 = (Keyword)cGroup.eContents().get(6);
	private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
	private final Assignment cVal6Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
	private final RuleCall cVal6IDTerminalRuleCall_7_0_0 = (RuleCall)cVal6Assignment_7_0.eContents().get(0);
	private final Assignment cVal7Assignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
	private final RuleCall cVal7IDTerminalRuleCall_7_1_0 = (RuleCall)cVal7Assignment_7_1.eContents().get(0);
	 public ParserRule getRule() {
		 return rule;
	 }
	public Group getGroup() {
		 return cGroup;
	 }
	public Keyword getNumberSignDigitFourKeyword_0() {
		 return cNumberSignDigitFourKeyword_0;
	 }
	public Assignment getVal1Assignment_1() {
		 return cVal1Assignment_1;
	 }
	public RuleCall getVal1IDTerminalRuleCall_1_0() {
		 return cVal1IDTerminalRuleCall_1_0;
	 }
	public Keyword getKw1Keyword_2() {
		 return cKw1Keyword_2;
	 }
	public Group getGroup_3() {
		 return cGroup_3;
	 }
	public Assignment getVal2Assignment_3_0() {
		 return cVal2Assignment_3_0;
	 }
	public RuleCall getVal2IDTerminalRuleCall_3_0_0() {
		 return cVal2IDTerminalRuleCall_3_0_0;
	 }
	public Assignment getVal3Assignment_3_1() {
		 return cVal3Assignment_3_1;
	 }
	public RuleCall getVal3IDTerminalRuleCall_3_1_0() {
		 return cVal3IDTerminalRuleCall_3_1_0;
	 }
	public Keyword getKw2Keyword_4() {
		 return cKw2Keyword_4;
	 }
	public Group getGroup_5() {
		 return cGroup_5;
	 }
	public Assignment getVal4Assignment_5_0() {
		 return cVal4Assignment_5_0;
	 }
	public RuleCall getVal4IDTerminalRuleCall_5_0_0() {
		 return cVal4IDTerminalRuleCall_5_0_0;
	 }
	public Assignment getVal5Assignment_5_1() {
		 return cVal5Assignment_5_1;
	 }
	public RuleCall getVal5IDTerminalRuleCall_5_1_0() {
		 return cVal5IDTerminalRuleCall_5_1_0;
	 }
	public Keyword getKw3Keyword_6() {
		 return cKw3Keyword_6;
	 }
	public Group getGroup_7() {
		 return cGroup_7;
	 }
	public Assignment getVal6Assignment_7_0() {
		 return cVal6Assignment_7_0;
	 }
	public RuleCall getVal6IDTerminalRuleCall_7_0_0() {
		 return cVal6IDTerminalRuleCall_7_0_0;
	 }
	public Assignment getVal7Assignment_7_1() {
		 return cVal7Assignment_7_1;
	 }
	public RuleCall getVal7IDTerminalRuleCall_7_1_0() {
		 return cVal7IDTerminalRuleCall_7_1_0;
	 }
}",1,1,0,0
"public class Ejbc extends MatchingTask {
	 private File descriptorDirectory;
	 private File generatedFilesDirectory;
	 private File generatedManifestFile;
	 private String classpath;
	 private File sourceDirectory;
	 public boolean keepgenerated;
	 public void execute() throws BuildException {
		 if (descriptorDirectory == null || !descriptorDirectory.isDirectory()) {
			 throw new BuildException(""descriptors directory "" + descriptorDirectory + "" is not valid"");
		 }
		 if (generatedFilesDirectory == null || !generatedFilesDirectory.isDirectory()) {
			 throw new BuildException(""dest directory "" + generatedFilesDirectory + "" is not valid"");
		 }
		 if (sourceDirectory == null || !sourceDirectory.isDirectory()) {
			 throw new BuildException(""src directory "" + sourceDirectory + "" is not valid"");
		 }
		 String systemClassPath = System.getProperty(""java.class.path"");
		 String execClassPath = FileUtils.translatePath(systemClassPath + "":"" + classpath + "":"" + generatedFilesDirectory);
		 DirectoryScanner ds = super.getDirectoryScanner(descriptorDirectory);
		 String[] files = ds.getIncludedFiles();
		 Java helperTask = new Java(this);
		 helperTask.setFork(true);
		 helperTask.setClassname(""org.apache.tools.ant.taskdefs.optional.ejb.EjbcHelper"");
		 String args = """";
		 args += "" "" + descriptorDirectory;
		 args += "" "" + generatedFilesDirectory;
		 args += "" "" + sourceDirectory;
		 args += "" "" + generatedManifestFile;
		 args += "" "" + keepgenerated;
		 for (int i = 0;
		 i < files.length;
		 ++i) {
			 args += "" "" + files[i];
		 }
		 Commandline.Argument arguments = helperTask.createArg();
		 arguments.setLine(args);
		 helperTask.setClasspath(new Path(getProject(), execClassPath));
		 if (helperTask.executeJava() != 0) {
			 throw new BuildException(""Execution of ejbc helper failed"");
		 }
	 }
	 public boolean getKeepgenerated() {
		 return keepgenerated;
	 }
	 public void setDescriptors(String dirName) {
		 descriptorDirectory = new File(dirName);
	 }
	 public void setDest(String dirName) {
		 generatedFilesDirectory = new File(dirName);
	 }
	 public void setKeepgenerated(String newKeepgenerated) {
		 keepgenerated = Boolean.valueOf(newKeepgenerated.trim()).booleanValue();
	 }
	 public void setManifest(String manifestFilename) {
		 generatedManifestFile = new File(manifestFilename);
	 }
	 public void setClasspath(String s) {
		 this.classpath = FileUtils.translatePath(s);
	 }
	 public void setSrc(String dirName) {
		 sourceDirectory = new File(dirName);
	 }
}",0,0,0,0
"public void afterValue( K key, V value ) throws LdapException, CursorException {
	 checkNotClosed();
	 if ( value == null ) {
		 containerCursor.after( new Tuple<K, DupsContainer<V>>( key, null ) );
	 }
	 else {
		 containerCursor.before( new Tuple<K, DupsContainer<V>>( key, null ) );
	 }
	 if ( containerCursor.next() ) {
		 containerTuple.setBoth( containerCursor.get() );
		 DupsContainer<V> values = containerTuple.getValue();
		 if ( values.isArrayTree() ) {
			 ArrayTree<V> set = values.getArrayTree();
			 dupsCursor = new ArrayTreeCursor<>( set );
		 }
		 else {
			 try {
				 BTree tree = table.getBTree( values.getBTreeRedirect() );
				 dupsCursor = new KeyBTreeCursor<>( tree, table.getValueComparator() );
			 }
			 catch ( IOException e ) {
				 throw new CursorException( e );
			 }
		 }
		 if ( value == null ) {
			 return;
		 }
		 if ( table.getKeyComparator().compare( containerTuple.getKey(), key ) == 0 ) {
			 dupsCursor.after( value );
		 }
		 return;
	 }
	 clearValue();
	 containerTuple.setKey( null );
	 containerTuple.setValue( null );
 }",0,0,1,0
"public final class ObjectLruCache extends AbstractLruCache {
	 Object[] values = new Object[INITIAL_SIZE];
	 public ObjectLruCache(int maxSize) {
		 super(maxSize);
	 }
	 Object getValuesArray() {
		 return values;
	 }
	 void allocNewValuesArray(int newSize) {
		 super.allocNewValuesArray(newSize);
		 values = new Object[newSize];
	 }
	 void put(long key, Object oldvalues, int offset) {
		 Object[] v = (Object[])oldvalues;
		 put(key, v[offset]);
	 }
	 public Object get(long key) {
		 int index = getIndexAndPromote(key) ;
		 if (index != -1) {
			 return values[index];
		 }
		 return null;
	 }
	 public void put(long key, Object value) {
		 int index = putIndexAndPromote(key) ;
		 values[index] = value;
		 checkRehash();
	 }
}",0,1,0,0
"public abstract class DispatchTask extends Task implements Dispatchable {
	 private String action;
	 public String getActionParameterName() {
		 return ""action"";
	 }
	 public void setAction(String action) {
		 this.action = action;
	 }
	 public String getAction() {
		 return action;
	 }
}",0,0,0,0
"public class SemanticVersion implements Comparable<SemanticVersion>{
	 private static final String VERSION_REGEXP = ""(\\d+)\\.(\\d+)\\.(\\d+)(\\-[.\\w]+)?(\\+[.\\w]+)?"";
	 private static final Pattern pattern = Pattern.compile(VERSION_REGEXP);
	 public final int major;
	 public final int minor;
	 public final int patch;
	 private final String[] preRelease;
	 private final String[] build;
	 private SemanticVersion(int major, int minor, int patch, String[] preRelease, String[] build) {
		 this.major = major;
		 this.minor = minor;
		 this.patch = patch;
		 this.preRelease = preRelease;
		 this.build = build;
	 }
	 public SemanticVersion(String version) {
		 Matcher matcher = pattern.matcher(version);
		 if (!matcher.matches()) throw new IllegalArgumentException(""Invalid version value: "" + version + "" (see http: try {
			 this.major = Integer.valueOf(matcher.group(1));
			 this.minor = Integer.valueOf(matcher.group(2));
			 this.patch = Integer.valueOf(matcher.group(3));
			 String pr = matcher.group(4);
			 String bld = matcher.group(5);
			 this.preRelease = pr == null || pr.isEmpty() ? null : parseIdentifiers(version, pr);
			 this.build = bld == null || bld.isEmpty() ? null : parseIdentifiers(version, bld);
		 }
		 catch (NumberFormatException e) {
		 throw new IllegalArgumentException(""Invalid version value: "" + version + "" (see http: }
	 }
	 private static String[] parseIdentifiers(String version, String str) {
		 str = str.substring(1);
		 String[] parts = str.split(""\\."");
		 for (String part : parts) {
		 if (!part.matches(""\\w+"")) throw new IllegalArgumentException(""Invalid version value: "" + version + "" (see http: }
		 return parts;
	 }
	 public int compareTo(SemanticVersion other) {
		 if (major < other.major) return -1;
		 if (major > other.major) return 1;
		 if (minor < other.minor) return -1;
		 if (minor > other.minor) return 1;
		 if (patch < other.patch) return -1;
		 if (patch > other.patch) return 1;
		 int c = compareIdentifiers(preRelease, other.preRelease, 1);
		 if (c != 0) return c;
		 return compareIdentifiers(build, other.build, -1);
	 }
	 public SemanticVersion findSupportingVersion(SemanticVersion... versions) {
		 for (SemanticVersion version : versions) {
			 if (isSupportedBy(version)) return version;
		 }
		 return null;
	 }
	 public boolean isSupportedBy(SemanticVersion version) {
		 return major == version.major && minor <= version.minor;
	 }
	 private static int compareIdentifiers(String[] ids1, String[] ids2, int defaultPred) {
		 if (ids1 == null) return ids2 == null ? 0 : defaultPred;
		 else if (ids2 == null) return -defaultPred;
		 int min = Math.min(ids1.length, ids2.length);
		 for (int i = 0;
		 i < min;
		 i++) {
			 Integer i1 = tryParseInt(ids1[i]);
			 Integer i2 = tryParseInt(ids2[i]);
			 if (i1 != null) {
				 if (i2 == null || i1 < i2) return -1;
				 else if (i1 > i2) return 1;
			 }
			 else {
				 if (i2 != null) return 1;
				 int c = ids1[i].compareTo(ids2[i]);
				 if (c != 0) return c;
			 }
		 }
		 if (ids1.length < ids2.length) return -1;
		 if (ids1.length > ids2.length) return 1;
		 return 0;
	 }
	 private static Integer tryParseInt(String str) {
		 try {
			 return Integer.valueOf(str);
		 }
		 catch (NumberFormatException e) {
			 return null;
		 }
	 }
	 public boolean equals(Object o) {
		 if(!(o instanceof SemanticVersion)) return false;
		 SemanticVersion that = (SemanticVersion)o;
		 return major == that.major && minor == that.minor && patch == that.patch && Arrays.equals(preRelease, that.preRelease) && Arrays.equals(build, that.build);
	 }
	 public int hashCode() {
		 return Objects.hashCode(major, minor, patch, preRelease, build);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 sb.append(major).append('.').append(minor).append('.').append(patch);
		 if (preRelease != null) sb.append('-').append(StringUtils.join(preRelease, "".""));
		 if (build != null) sb.append('+').append(StringUtils.join(build, "".""));
		 return sb.toString();
	 }
}",0,0,0,0
"public class POSTaggerNameFeatureGenerator implements AdaptiveFeatureGenerator {
	 private POSTagger posTagger;
	 private String[] cachedTokens;
	 private String[] cachedTags;
	 public POSTaggerNameFeatureGenerator(POSTagger aPosTagger) {
		 this.posTagger = aPosTagger;
	 }
	 public POSTaggerNameFeatureGenerator(POSModel aPosModel) {
		 this.posTagger = new POSTaggerME(aPosModel);
	 }
	 public void createFeatures(List<String> feats, String[] toks, int index, String[] preds) {
		 if (!Arrays.equals(this.cachedTokens, toks)) {
			 this.cachedTokens = toks;
			 this.cachedTags = this.posTagger.tag(toks);
		 }
		 feats.add(""pos="" + this.cachedTags[index]);
	 }
}",0,0,0,0
"public static boolean handle(File tempFile, ParsedHookData data) {
	try {
		StringBuffer buf = new StringBuffer();
		InputStream in = new FileInputStream(tempFile);
		BufferedReader r = new BufferedReader(new InputStreamReader(in));
		while (true) {
			String ln = r.readLine();
			if (ln == null) {
				break;
			}
			buf.append(ln + ""\n"");
		}
		in.close();
		Logger.log(""Parsing facebook page..."");
		ArrayList<String> sdUrls1 = findURL(""sd_src"", buf);
		ArrayList<String> sdUrls2 = findURL(""sd_src_no_ratelimit"", buf);
		ArrayList<String> hdUrls1 = findURL(""hd_src"", buf);
		ArrayList<String> hdUrls2 = findURL(""hd_src_no_ratelimit"", buf);
		for (int i = 0;
		 i < sdUrls1.size();
		 i++) {
			HttpMetadata metadata = new HttpMetadata();
			metadata.setUrl(sdUrls1.get(i));
			metadata.setHeaders(data.getRequestHeaders());
			String file = data.getFile();
			if (StringUtils.isNullOrEmptyOrBlank(file)) {
				file = XDMUtils.getFileName(data.getUrl());
			}
			XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 LOW"");
		}
		for (int i = 0;
		 i < sdUrls2.size();
		 i++) {
			HttpMetadata metadata = new HttpMetadata();
			metadata.setUrl(sdUrls2.get(i));
			metadata.setHeaders(data.getRequestHeaders());
			String file = data.getFile();
			if (StringUtils.isNullOrEmptyOrBlank(file)) {
				file = XDMUtils.getFileName(data.getUrl());
			}
			XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 MEDIUM"");
		}
		for (int i = 0;
		 i < hdUrls1.size();
		 i++) {
			HttpMetadata metadata = new HttpMetadata();
			metadata.setUrl(hdUrls1.get(i));
			metadata.setHeaders(data.getRequestHeaders());
			String file = data.getFile();
			if (StringUtils.isNullOrEmptyOrBlank(file)) {
				file = XDMUtils.getFileName(data.getUrl());
			}
			XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 HD"");
		}
		for (int i = 0;
		 i < hdUrls2.size();
		 i++) {
			HttpMetadata metadata = new HttpMetadata();
			metadata.setUrl(hdUrls2.get(i));
			metadata.setHeaders(data.getRequestHeaders());
			String file = data.getFile();
			if (StringUtils.isNullOrEmptyOrBlank(file)) {
				file = XDMUtils.getFileName(data.getUrl());
			}
			XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 HQ"");
		}
		return true;
	}
	 catch (Exception e) {
		Logger.log(e);
		return false;
	}
}",0,0,1,0
"private static void loadPreviousConfig(String config) throws ConfigurationException {
	 try {
		 XMLUtils xmlUtils = new XMLUtils(config);
		 conf.cluster_name = xmlUtils.getNodeValue(""/Storage/ClusterName"");
		 String syncRaw = xmlUtils.getNodeValue(""/Storage/CommitLogSync"");
		 conf.commitlog_sync = Config.CommitLogSync.valueOf(syncRaw);
		 if (conf.commitlog_sync != null) {
			 if (conf.commitlog_sync == Config.CommitLogSync.batch) conf.commitlog_sync_batch_window_in_ms = Double.valueOf(xmlUtils.getNodeValue(""/Storage/CommitLogSyncBatchWindowInMS""));
			 else conf.commitlog_sync_period_in_ms = Integer.valueOf(xmlUtils.getNodeValue(""/Storage/CommitLogSyncPeriodInMS""));
		 }
		 String modeRaw = xmlUtils.getNodeValue(""/Storage/DiskAccessMode"");
		 conf.disk_access_mode = Config.DiskAccessMode.valueOf(modeRaw);
		 conf.authenticator = xmlUtils.getNodeValue(""/Storage/Authenticator"");
		 if (conf.authenticator != null && conf.authenticator.equals(SimpleAuthenticator.class.getName())) conf.authority = SimpleAuthority.class.getName();
		 conf.partitioner = xmlUtils.getNodeValue(""/Storage/Partitioner"");
		 conf.job_tracker_host = xmlUtils.getNodeValue(""/Storage/JobTrackerHost"");
		 conf.job_jar_file_location = xmlUtils.getNodeValue(""/Storage/JobJarFileLocation"");
		 conf.initial_token = xmlUtils.getNodeValue(""/Storage/InitialToken"");
		 String rpcTimeout = xmlUtils.getNodeValue(""/Storage/RpcTimeoutInMillis"");
		 if ( rpcTimeout != null ) conf.rpc_timeout_in_ms = Long.parseLong(rpcTimeout);
		 String rawReaders = xmlUtils.getNodeValue(""/Storage/ConcurrentReads"");
		 if (rawReaders != null) {
			 conf.concurrent_reads = Integer.parseInt(rawReaders);
		 }
		 String rawWriters = xmlUtils.getNodeValue(""/Storage/ConcurrentWrites"");
		 if (rawWriters != null) {
			 conf.concurrent_writes = Integer.parseInt(rawWriters);
		 }
		 String rawSlicedBuffer = xmlUtils.getNodeValue(""/Storage/SlicedBufferSizeInKB"");
		 if (rawSlicedBuffer != null) {
			 conf.sliced_buffer_size_in_kb = Integer.parseInt(rawSlicedBuffer);
		 }
		 String bmtThresh = xmlUtils.getNodeValue(""/Storage/BinaryMemtableThroughputInMB"");
		 if (bmtThresh != null) {
			 conf.binary_memtable_throughput_in_mb = Integer.parseInt(bmtThresh);
		 }
		 String port = xmlUtils.getNodeValue(""/Storage/StoragePort"");
		 if ( port != null ) conf.storage_port = Integer.parseInt(port);
		 conf.listen_address = xmlUtils.getNodeValue(""/Storage/ListenAddress"");
		 conf.rpc_address = xmlUtils.getNodeValue(""/Storage/RPCAddress"");
		 port = xmlUtils.getNodeValue(""/Storage/RPCPort"");
		 if (port != null) conf.rpc_port = Integer.parseInt(port);
		 String framedRaw = xmlUtils.getNodeValue(""/Storage/ThriftFramedTransport"");
		 if (framedRaw != null && !Boolean.valueOf(framedRaw)) {
			 System.out.println(""WARN : Cassandra uses a Thrift framed Transport by default in 0.7! Clients will need to match."");
		 }
		 conf.thrift_framed_transport_size_in_mb = 15;
		 String sbc = xmlUtils.getNodeValue(""/Storage/SnapshotBeforeCompaction"");
		 if (sbc != null) {
			 conf.snapshot_before_compaction = Boolean.valueOf(sbc);
		 }
		 String autoBootstr = xmlUtils.getNodeValue(""/Storage/AutoBootstrap"");
		 if (autoBootstr != null) {
			 conf.auto_bootstrap = Boolean.valueOf(autoBootstr);
		 }
		 String columnIndexSize = xmlUtils.getNodeValue(""/Storage/ColumnIndexSizeInKB"");
		 if(columnIndexSize != null) {
			 conf.column_index_size_in_kb = Integer.parseInt(columnIndexSize);
		 }
		 conf.data_file_directories = xmlUtils.getNodeValues(""/Storage/DataFileDirectories/DataFileDirectory"");
		 conf.commitlog_directory = xmlUtils.getNodeValue(""/Storage/CommitLogDirectory"");
		 conf.saved_caches_directory = xmlUtils.getNodeValue(""/Storage/SavedCachesDirectory"");
		 String value = xmlUtils.getNodeValue(""/Storage/CommitLogRotationThresholdInMB"");
		 if ( value != null) conf.commitlog_rotation_threshold_in_mb = Integer.parseInt(value);
		 conf.seeds = xmlUtils.getNodeValues(""/Storage/Seeds/Seed"");
		 conf.keyspaces = readTablesFromXml(xmlUtils);
	 }
	 catch (ParserConfigurationException e) {
		 System.out.println(""Parser error during previous config load."");
		 throw new ConfigurationException(""Parser error during previous config load."");
	 }
	 catch (SAXException e) {
		 System.out.println(""SAX error during previous config load."");
		 throw new ConfigurationException(""SAX error during previous config load."");
	 }
	 catch (IOException e) {
		 System.out.println(""File I/O error during previous config load."");
		 throw new ConfigurationException(""File I/O error during previous config load."");
	 }
	 catch (XPathExpressionException e) {
		 System.out.println(""XPath error during previous config load."");
		 throw new ConfigurationException(""XPath error during previous config load."");
	 }
 }",0,0,1,0
"public void processItem(String folderPath, String itemName) throws IOException {
	 EWSMethod.Item item = getEwsItem(folderPath, itemName);
	 if (item != null) {
		 HashMap<String, String> localProperties = new HashMap<String, String>();
		 localProperties.put(""processed"", ""1"");
		 localProperties.put(""read"", ""1"");
		 UpdateItemMethod updateItemMethod = new UpdateItemMethod(MessageDisposition.SaveOnly, ConflictResolution.AlwaysOverwrite, SendMeetingInvitationsOrCancellations.SendToNone, new ItemId(item), buildProperties(localProperties));
		 executeMethod(updateItemMethod);
	 }
 }",0,0,0,0
"public class QueryFilter{
	 private static Logger logger = LoggerFactory.getLogger(QueryFilter.class);
	 public final DecoratedKey key;
	 public final QueryPath path;
	 public final IFilter filter;
	 private final IFilter superFilter;
	 public QueryFilter(DecoratedKey key, QueryPath path, IFilter filter) {
		 this.key = key;
		 this.path = path;
		 this.filter = filter;
		 superFilter = path.superColumnName == null ? null : new NamesQueryFilter(path.superColumnName);
	 }
	 public IColumnIterator getMemtableColumnIterator(Memtable memtable, AbstractType comparator) {
		 ColumnFamily cf = memtable.getColumnFamily(key);
		 if (cf == null) return null;
		 return getMemtableColumnIterator(cf, key, comparator);
	 }
	 public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey key, AbstractType comparator) {
		 assert cf != null;
		 if (path.superColumnName == null) return filter.getMemtableColumnIterator(cf, key, comparator);
		 return superFilter.getMemtableColumnIterator(cf, key, comparator);
	 }
	 public IColumnIterator getSSTableColumnIterator(SSTableReader sstable) {
		 if (path.superColumnName == null) return filter.getSSTableColumnIterator(sstable, key);
		 return superFilter.getSSTableColumnIterator(sstable, key);
	 }
	 public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key) {
		 if (path.superColumnName == null) return filter.getSSTableColumnIterator(sstable, file, key);
		 return superFilter.getSSTableColumnIterator(sstable, file, key);
	 }
	 public void collectCollatedColumns(final ColumnFamily returnCF, Iterator<IColumn> collatedColumns, final int gcBefore) {
		 ReducingIterator<IColumn, IColumn> reduced = new ReducingIterator<IColumn, IColumn>(collatedColumns) {
			 ColumnFamily curCF = returnCF.cloneMeShallow();
			 protected boolean isEqual(IColumn o1, IColumn o2) {
				 return o1.name().equals(o2.name());
			 }
			 public void reduce(IColumn current) {
				 if (curCF.isSuper() && curCF.isEmpty()) {
					 assert current instanceof SuperColumn;
					 curCF.addColumn(((SuperColumn)current).cloneMe());
				 }
				 else {
					 curCF.addColumn(current);
				 }
			 }
			 protected IColumn getReduced() {
				 IColumn c = curCF.getSortedColumns().iterator().next();
				 if (superFilter != null) {
					 long deletedAt = c.getMarkedForDeleteAt();
					 if (returnCF.getMarkedForDeleteAt() > deletedAt) ((SuperColumn)c).markForDeleteAt(c.getLocalDeletionTime(), returnCF.getMarkedForDeleteAt());
					 c = filter.filterSuperColumn((SuperColumn)c, gcBefore);
					 ((SuperColumn)c).markForDeleteAt(c.getLocalDeletionTime(), deletedAt);
				 }
				 curCF.clear();
				 return c;
			 }
		 }
		;
		 (superFilter == null ? filter : superFilter).collectReducedColumns(returnCF, reduced, gcBefore);
	 }
	 public String getColumnFamilyName() {
		 return path.columnFamilyName;
	 }
	 public static boolean isRelevant(IColumn column, IColumnContainer container, int gcBefore) {
		 long maxChange = column.mostRecentLiveChangeAt();
		 return (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore || maxChange > column.getMarkedForDeleteAt()) && (!container.isMarkedForDelete() || maxChange > container.getMarkedForDeleteAt());
	 }
	 public static QueryFilter getSliceFilter(DecoratedKey key, QueryPath path, ByteBuffer start, ByteBuffer finish, boolean reversed, int limit) {
		 return new QueryFilter(key, path, new SliceQueryFilter(start, finish, reversed, limit));
	 }
	 public static QueryFilter getIdentityFilter(DecoratedKey key, QueryPath path) {
		 return new QueryFilter(key, path, new IdentityQueryFilter());
	 }
	 public static QueryFilter getNamesFilter(DecoratedKey key, QueryPath path, SortedSet<ByteBuffer> columns) {
		 return new QueryFilter(key, path, new NamesQueryFilter(columns));
	 }
	 public static IFilter getFilter(SlicePredicate predicate, AbstractType comparator) {
		 if (predicate.column_names != null) {
			 final SortedSet<ByteBuffer> columnNameSet = new TreeSet<ByteBuffer>(comparator);
			 columnNameSet.addAll(predicate.column_names);
			 return new NamesQueryFilter(columnNameSet);
		 }
		 SliceRange range = predicate.slice_range;
		 return new SliceQueryFilter(range.start, range.finish, range.reversed, range.count);
	 }
	 public static QueryFilter getNamesFilter(DecoratedKey key, QueryPath path, ByteBuffer column) {
		 return new QueryFilter(key, path, new NamesQueryFilter(column));
	 }
	 public String toString() {
		 return getClass().getSimpleName() + ""(key="" + key + "", path="" + path + (filter == null ? """" : "", filter="" + filter) + (superFilter == null ? """" : "", superFilter="" + superFilter) + "")"";
	 }
}",0,0,0,0
"protected void baselineLayout(int targetSpan, int axis, int[] offsets, int[] spans) {
	 int totalAscent = (int)(targetSpan * getAlignment(axis));
	 int totalDescent = targetSpan - totalAscent;
	 int n = getViewCount();
	 for (int i = 0;
	 i < n;
	 i++) {
		 View v = getView(i);
		 float align = v.getAlignment(axis);
		 float viewSpan;
		 if (v.getResizeWeight(axis) > 0) {
			 float minSpan = v.getMinimumSpan(axis);
			 float maxSpan = v.getMaximumSpan(axis);
			 if (align == 0.0f) {
				 viewSpan = Math.max(Math.min(maxSpan, totalDescent), minSpan);
			 }
			 else if (align == 1.0f) {
				 viewSpan = Math.max(Math.min(maxSpan, totalAscent), minSpan);
			 }
			 else {
				 float fitSpan = Math.min(totalAscent / align, totalDescent / (1.0f - align));
				 viewSpan = Math.max(Math.min(maxSpan, fitSpan), minSpan);
			 }
		 }
		 else {
			 viewSpan = v.getPreferredSpan(axis);
		 }
		 offsets[i] = totalAscent - (int)(viewSpan * align);
		 spans[i] = (int)viewSpan;
	 }
 }",0,0,1,0
"public class SimpleCustomPartitioner3 extends Partitioner<PigNullableWritable, Writable> {
	 public int getPartition(PigNullableWritable key, Writable value, int numPartitions) {
		 return numPartitions >= 1 ? 1 : 0;
	 }
}",1,0,0,0
"public class IgnoreCommitOptimizeUpdateProcessorFactory extends UpdateRequestProcessorFactory {
	 private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
	 private static final String DEFAULT_RESPONSE_MSG = ""Explicit commit/optimize requests are forbidden!"";
	 protected ErrorCode errorCode;
	 protected String responseMsg;
	 protected boolean ignoreOptimizeOnly = false;
	 public void init(final NamedList args) {
		 SolrParams params = (args != null) ? args.toSolrParams() : null;
		 if (params == null) {
			 errorCode = ErrorCode.FORBIDDEN;
			 responseMsg = DEFAULT_RESPONSE_MSG;
			 ignoreOptimizeOnly = false;
			 return;
		 }
		 ignoreOptimizeOnly = params.getBool(""ignoreOptimizeOnly"", false);
		 int statusCode = params.getInt(""statusCode"", ErrorCode.FORBIDDEN.code);
		 if (statusCode == 200) {
			 errorCode = null;
			 responseMsg = params.get(""responseMessage"");
		 }
		 else {
			 errorCode = ErrorCode.getErrorCode(statusCode);
			 if (errorCode == ErrorCode.UNKNOWN) {
				 StringBuilder validCodes = new StringBuilder();
				 int appended = 0;
				 for (ErrorCode code : ErrorCode.values()) {
					 if (code != ErrorCode.UNKNOWN) {
						 if (appended++ > 0) validCodes.append("", "");
						 validCodes.append(code.code);
					 }
				 }
				 throw new IllegalArgumentException(""Configured status code "" + statusCode + "" not supported! Please choose one of: "" + validCodes.toString());
			 }
			 responseMsg = params.get(""responseMessage"", DEFAULT_RESPONSE_MSG);
		 }
	 }
	 public UpdateRequestProcessor getInstance(SolrQueryRequest req, SolrQueryResponse rsp, UpdateRequestProcessor next) {
		 return new IgnoreCommitOptimizeUpdateProcessor(rsp, this, next);
	 }
	 static class IgnoreCommitOptimizeUpdateProcessor extends UpdateRequestProcessor {
		 private final SolrQueryResponse rsp;
		 private final ErrorCode errorCode;
		 private final String responseMsg;
		 private final boolean ignoreOptimizeOnly;
		 IgnoreCommitOptimizeUpdateProcessor(SolrQueryResponse rsp, IgnoreCommitOptimizeUpdateProcessorFactory factory, UpdateRequestProcessor next) {
			 super(next);
			 this.rsp = rsp;
			 this.errorCode = factory.errorCode;
			 this.responseMsg = factory.responseMsg;
			 this.ignoreOptimizeOnly = factory.ignoreOptimizeOnly;
		 }
		 public void processCommit(CommitUpdateCommand cmd) throws IOException {
			 if (ignoreOptimizeOnly && !cmd.optimize) {
				 if (next != null) next.processCommit(cmd);
				 return;
			 }
			 if (cmd.getReq().getParams().getBool(DistributedUpdateProcessor.COMMIT_END_POINT, false)) {
				 if (next != null) next.processCommit(cmd);
				 return;
			 }
			 final String cmdType = cmd.optimize ? ""optimize"" : ""commit"";
			 if (errorCode != null) {
				 IgnoreCommitOptimizeUpdateProcessorFactory.log.info( ""{
				}
				 from client application ignored with error code: {
				}
				"", cmdType, errorCode.code);
				 rsp.setException(new SolrException(errorCode, responseMsg));
			 }
			 else {
				 IgnoreCommitOptimizeUpdateProcessorFactory.log.info( ""{
				}
				 from client application ignored with status code: 200"", cmdType);
				 if (responseMsg != null) {
					 NamedList<Object> responseHeader = rsp.getResponseHeader();
					 if (responseHeader != null) {
						 responseHeader.add(""msg"", responseMsg);
					 }
					 else {
						 responseHeader = new SimpleOrderedMap<Object>();
						 responseHeader.add(""msg"", responseMsg);
						 rsp.addResponseHeader(responseHeader);
					 }
				 }
			 }
		 }
	 }
}",1,0,0,0
"void getHashes(List<Integer> searchHashes, int bitShift) {
	 searchHashes.clear();
	 if (title != null) {
		 searchHashes.add((title.ignoreCaseHash >>> bitShift));
	 }
	 if (person != null) {
		 addHash(person.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (category != null) {
		 addHash(category.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (subCategory != null) {
		 addHash(subCategory.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (chanName.length() > 0) {
		 addHash(chanName.hashCode(), searchHashes, bitShift);
	 }
	 if (chanNames != null && chanNames.length > 0) {
		 for (String chanName : chanNames) {
			 addHash(chanName.hashCode(), searchHashes, bitShift);
		 }
	 }
	 if (network != null) {
		 addHash(network.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (rated != null) {
		 addHash(rated.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (year != null) {
		 addHash(year.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (pr != null) {
		 addHash(pr.ignoreCaseHash, searchHashes, bitShift);
	 }
	 if (searchHashes.contains(0)) searchHashes.clear();
 }",0,0,1,0
"public int executeUpdate(final String inSql) throws SQLException {
	 this.sql = inSql;
	 if (this.sql == null) {
		 throw new SQLException(""sql is null"");
	 }
	 trimSQL();
	 if (this.sql.length() == 0) {
		 throw new SQLException(""empty sql"");
	 }
	 String lowcaseSql = this.sql.toLowerCase();
	 Object req = null;
	 if (lowcaseSql.startsWith(""create domain"") || lowcaseSql.startsWith(""create table"")) {
		 int pos = this.sql.lastIndexOf("" "");
		 String domain = convertSQLIdentifierToCatalogFormat(this.sql.substring(pos + 1).trim(), DELIMITED_IDENTIFIER_QUOTE);
		 req = new CreateDomainRequest().withDomainName(domain);
	 }
	 else if (lowcaseSql.startsWith(""delete domain"") || lowcaseSql.startsWith(""delete table"") || lowcaseSql.startsWith(""drop table"")) {
		 int pos = this.sql.lastIndexOf("" "");
		 String domain = convertSQLIdentifierToCatalogFormat(this.sql.substring(pos + 1).trim(), DELIMITED_IDENTIFIER_QUOTE);
		 List<String> pending = this.conn.getPendingColumns(domain);
		 if (pending != null) {
			 pending = new ArrayList<>(pending);
			 for (String attr : pending) {
				 this.conn.removePendingColumn(domain, attr);
			 }
		 }
		 req = new DeleteDomainRequest().withDomainName(domain);
	 }
	 else if (lowcaseSql.startsWith(""delete from"")) {
		 req = prepareDeleteRowRequest();
	 }
	 else if (lowcaseSql.startsWith(""alter table "")) {
		 req = prepareDropAttributeRequest();
	 }
	 else if (lowcaseSql.startsWith(""insert "")) {
		 req = prepareInsertRequest();
	 }
	 else if (lowcaseSql.startsWith(""update "")) {
		 req = prepareUpdateRequest();
	 }
	 else if (lowcaseSql.startsWith(""create testdomain "")) {
		 req = new ArrayList<>();
		 String domain = convertSQLIdentifierToCatalogFormat(this.sql.substring(this.sql.lastIndexOf("" "") + 1).trim(), DELIMITED_IDENTIFIER_QUOTE);
		 ((List<Object>) req).add(new CreateDomainRequest().withDomainName(domain));
		 ReplaceableAttribute attr = new ReplaceableAttribute().withName(""attr1"").withValue(""val1"").withReplace(Boolean.TRUE);
		 for (int i = 0;
		 i < 570;
		 i++) {
			 ((List<Object>) req).add(new PutAttributesRequest().withDomainName(domain).withItemName(""item"" + i).withAttributes(attr));
		 }
	 }
	 if (req != null) {
		 int result = executeSDBRequest(req);
		 if (this.params != null) {
			 for (Object obj : this.params) {
				 if (obj instanceof SimpleDBItemName) {
					 ((SimpleDBItemName) obj).setPersisted(true);
				 }
			 }
		 }
		 return result;
	 }
	 throw new SQLException(""unsupported update: "" + this.sql);
 }",0,0,1,0
"private void addGenICGeneratedFiles( File genericJarFile, Hashtable ejbFiles) {
	 Java genicTask = null;
	 String genicClass = null;
	 if (nogenic) {
		 return;
	 }
	 genicTask = new Java(getTask());
	 genicTask.setTaskName(""genic"");
	 genicTask.setFork(true);
	 genicTask.createJvmarg().setValue(""-Dinstall.root="" + jonasroot);
	 String jonasConfigDir = jonasroot + File.separator + ""config"";
	 File javaPolicyFile = new File(jonasConfigDir, ""java.policy"");
	 if (javaPolicyFile.exists()) {
		 genicTask.createJvmarg().setValue(""-Djava.security.policy="" + javaPolicyFile.toString());
	 }
	 try {
		 outputdir = createTempDir();
	 }
	 catch (IOException aIOException) {
		 String msg = ""Cannot create temp dir: "" + aIOException.getMessage();
		 throw new BuildException(msg, aIOException);
	 }
	 log(""Using temporary output directory: "" + outputdir, Project.MSG_VERBOSE);
	 genicTask.createArg().setValue(""-d"");
	 genicTask.createArg().setFile(outputdir);
	 String key;
	 File f;
	 Enumeration keys = ejbFiles.keys();
	 while (keys.hasMoreElements()) {
		 key = (String) keys.nextElement();
		 f = new File(outputdir + File.separator + key);
		 f.getParentFile().mkdirs();
	 }
	 log(""Worked around a bug of GenIC 2.5."", Project.MSG_VERBOSE);
	 Path classpath = getCombinedClasspath();
	 if (classpath == null) {
		 classpath = new Path(getTask().getProject());
	 }
	 classpath.append(new Path(classpath.getProject(), jonasConfigDir));
	 classpath.append(new Path(classpath.getProject(), outputdir.toString()));
	 if (orb != null) {
		 String orbJar = jonasroot + File.separator + ""lib"" + File.separator + orb + ""_jonas.jar"";
		 classpath.append(new Path(classpath.getProject(), orbJar));
	 }
	 log(""Using classpath: "" + classpath.toString(), Project.MSG_VERBOSE);
	 genicTask.setClasspath(classpath);
	 genicClass = getGenicClassName(classpath);
	 if (genicClass == null) {
		 log(""Cannot find GenIC class in classpath."", Project.MSG_ERR);
		 throw new BuildException(""GenIC class not found, please check the classpath."");
	 }
	 else {
		 log(""Using '"" + genicClass + ""' GenIC class."" , Project.MSG_VERBOSE);
		 genicTask.setClassname(genicClass);
	 }
	 if (keepgenerated) {
		 genicTask.createArg().setValue(""-keepgenerated"");
	 }
	 if (nocompil) {
		 genicTask.createArg().setValue(""-nocompil"");
	 }
	 if (novalidation) {
		 genicTask.createArg().setValue(""-novalidation"");
	 }
	 if (javac != null) {
		 genicTask.createArg().setValue(""-javac"");
		 genicTask.createArg().setLine(javac);
	 }
	 if (javacopts != null && !javacopts.equals("""")) {
		 genicTask.createArg().setValue(""-javacopts"");
		 genicTask.createArg().setLine(javacopts);
	 }
	 if (rmicopts != null && !rmicopts.equals("""")) {
		 genicTask.createArg().setValue(""-rmicopts"");
		 genicTask.createArg().setLine(rmicopts);
	 }
	 if (secpropag) {
		 genicTask.createArg().setValue(""-secpropag"");
	 }
	 if (verbose) {
		 genicTask.createArg().setValue(""-verbose"");
	 }
	 if (additionalargs != null) {
		 genicTask.createArg().setValue(additionalargs);
	 }
	 genicTask.createArg().setValue(""-noaddinjar"");
	 genicTask.createArg().setValue(genericJarFile.getPath());
	 log(""Calling "" + genicClass + "" for "" + getConfig().descriptorDir + File.separator + descriptorName + ""."", Project.MSG_VERBOSE);
	 if (genicTask.executeJava() != 0) {
		 log(""Deleting temp output directory '"" + outputdir + ""'."", Project.MSG_VERBOSE);
		 deleteAllFiles(outputdir);
		 if (!keepgeneric) {
			 log(""Deleting generic JAR "" + genericJarFile.toString(), Project.MSG_VERBOSE);
			 genericJarFile.delete();
		 }
		 throw new BuildException(""GenIC reported an error."");
	 }
	 addAllFiles(outputdir, """", ejbFiles);
 }",0,0,1,0
"public class Validatable<T> implements IValidatable<T>{
	private T value;
	private ArrayList<IValidationError> errors;
	public Validatable(){
	}
	public Validatable(T value){
		this.value = value;
	}
	public void setValue(T value){
		this.value = value;
	}
	public T getValue(){
		return value;
	}
	public void error(IValidationError error){
		if (errors == null){
			errors = new ArrayList<IValidationError>();
		}
		errors.add(error);
	}
	public List<IValidationError> getErrors(){
		if (errors == null){
			return Collections.emptyList();
		}
		else{
			return Collections.unmodifiableList(errors);
		}
	}
	public boolean isValid(){
		return errors == null;
	}
}",0,0,0,0
"public void run() {
	 try {
		 IThreadContext threadContext = ThreadContextFactory.make();
		 while (true) {
			 try {
				 if (Thread.currentThread().isInterrupted()) throw new ManifoldCFException(""Interrupted"",ManifoldCFException.INTERRUPTED);
				 checkAgents(threadContext);
				 ManifoldCF.sleep(5000L);
			 }
			 catch (InterruptedException e) {
				 break;
			 }
			 catch (ManifoldCFException e) {
				 if (e.getErrorCode() == ManifoldCFException.INTERRUPTED) break;
				 if (e.getErrorCode() == ManifoldCFException.SETUP_ERROR) {
					 System.err.println(""Misconfigured ManifoldCF agents - shutting down"");
					 Logging.agents.fatal(""AgentThread configuration exception tossed: ""+e.getMessage(),e);
					 System.exit(-200);
				 }
				 Logging.agents.error(""Exception tossed: ""+e.getMessage(),e);
			 }
			 catch (OutOfMemoryError e) {
				 System.err.println(""Agents process ran out of memory - shutting down"");
				 e.printStackTrace(System.err);
				 System.exit(-200);
			 }
			 catch (Throwable e) {
				 Logging.agents.fatal(""Error tossed: ""+e.getMessage(),e);
			 }
		 }
	 }
	 catch (Throwable e) {
		 System.err.println(""Agents process could not start - shutting down"");
		 Logging.agents.fatal(""AgentThread initialization error tossed: ""+e.getMessage(),e);
		 System.exit(-300);
	 }
 }",0,0,1,0
"public class ColumnIdentifier implements Comparable<ColumnIdentifier>{
	 public final ByteBuffer key;
	 private final String text;
	 public ColumnIdentifier(String rawText, boolean keepCase) {
		 this.text = keepCase ? rawText : rawText.toLowerCase(Locale.US);
		 this.key = ByteBufferUtil.bytes(this.text);
	 }
	 public ColumnIdentifier(ByteBuffer key) {
		 try {
			 this.key = key;
			 this.text = ByteBufferUtil.string(key);
		 }
		 catch (CharacterCodingException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public final int hashCode() {
		 return key.hashCode();
	 }
	 public final boolean equals(Object o) {
		 if(!(o instanceof ColumnIdentifier)) return false;
		 ColumnIdentifier that = (ColumnIdentifier)o;
		 return key.equals(that.key);
	 }
	 public String toString() {
		 return text;
	 }
	 public int compareTo(ColumnIdentifier other) {
		 return key.compareTo(other.key);
	 }
}",0,0,0,0
"private boolean deriveTypeHierarchyFromOverridden(ParserRule rule, Grammar grammar) throws TransformationException {
	AbstractRule parentRule = GrammarUtil.findRuleForName(grammar, rule.getName());
	if (parentRule != null) {
		if (parentRule != rule && parentRule instanceof ParserRule) {
			ParserRule casted = (ParserRule) parentRule;
			if (casted.isFragment() != rule.isFragment()) {
				if (rule.isFragment()) {
					throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,""A fragment rule cannot override a production rule."", rule);
				}
				 else {
					throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,""Only fragment rule can override other fragment rules."", rule);
				}
			}
			if (casted.isWildcard() != rule.isWildcard()) {
				if (rule.isWildcard()) {
					throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,""A wildcard fragment rule cannot override a typed fragment rule."", rule);
				}
				 else {
					throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,""Only wildcard fragment rules can override other wildcard fragments."", rule);
				}
			}
			if (rule.isFragment() && !rule.isWildcard() && parentRule.getType() != null) {
				if (rule.getType().getClassifier() != parentRule.getType().getClassifier()) {
					throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,""Overriding fragment rules cannot redeclare their type."", rule.getType());
				}
			}
			checkParameterLists(rule, casted);
		}
		if (parentRule.getType() != null && parentRule != rule) {
			if (parentRule.getType().getClassifier() instanceof EDataType)throw new TransformationException(TransformationErrorCode.InvalidSupertype,""Cannot inherit from datatype rule and return another type."", rule.getType());
			EClassifierInfo parentTypeInfo = eClassifierInfos.getInfoOrNull(parentRule.getType());
			if (parentTypeInfo == null)throw new TransformationException(TransformationErrorCode.InvalidSupertype,""Cannot determine return type of overridden rule."", rule.getType());
			addSuperType(rule, rule.getType(), parentTypeInfo);
			return true;
		}
	}
	return false;
}",0,0,1,0
"public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {
	 static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);
	 private static final Set<Integer> expectedBkOperationErrors = Collections.unmodifiableSet(Sets .newHashSet(BKException.Code.BookieHandleNotAvailableException, BKException.Code.NoSuchEntryException, BKException.Code.NoSuchLedgerExistsException, BKException.Code.LedgerFencedException, BKException.Code.LedgerExistException, BKException.Code.DuplicateEntryIdException, BKException.Code.WriteOnReadOnlyBookieException));
	 private static final int DEFAULT_HIGH_PRIORITY_VALUE = 100;
	 private static final AtomicLong txnIdGenerator = new AtomicLong(0);
	 final BookieSocketAddress addr;
	 final EventLoopGroup eventLoopGroup;
	 final ByteBufAllocator allocator;
	 final OrderedExecutor executor;
	 final long addEntryTimeoutNanos;
	 final long readEntryTimeoutNanos;
	 final int maxFrameSize;
	 final int getBookieInfoTimeout;
	 final int startTLSTimeout;
	 private final ConcurrentOpenHashMap<CompletionKey, CompletionValue> completionObjects = new ConcurrentOpenHashMap<CompletionKey, CompletionValue>();
	 private final SynchronizedHashMultiMap<CompletionKey, CompletionValue> completionObjectsV2Conflicts = new SynchronizedHashMultiMap<>();
	 private final StatsLogger statsLogger;
	 private final OpStatsLogger readEntryOpLogger;
	 private final OpStatsLogger readTimeoutOpLogger;
	 private final OpStatsLogger addEntryOpLogger;
	 private final OpStatsLogger writeLacOpLogger;
	 private final OpStatsLogger forceLedgerOpLogger;
	 private final OpStatsLogger readLacOpLogger;
	 private final OpStatsLogger addTimeoutOpLogger;
	 private final OpStatsLogger writeLacTimeoutOpLogger;
	 private final OpStatsLogger forceLedgerTimeoutOpLogger;
	 private final OpStatsLogger readLacTimeoutOpLogger;
	 private final OpStatsLogger getBookieInfoOpLogger;
	 private final OpStatsLogger getBookieInfoTimeoutOpLogger;
	 private final OpStatsLogger startTLSOpLogger;
	 private final OpStatsLogger startTLSTimeoutOpLogger;
	 private final OpStatsLogger connectTimer;
	 private final Counter exceptionCounter;
	 private final Counter addEntryOutstanding;
	 private final Counter readEntryOutstanding;
	 private final OpStatsLogger nettyOpLogger;
	 private final Counter activeNonTlsChannelCounter;
	 private final Counter activeTlsChannelCounter;
	 private final Counter failedConnectionCounter;
	 private final Counter failedTlsHandshakeCounter;
	 private final boolean useV2WireProtocol;
	 private final boolean preserveMdcForTaskExecution;
	 private volatile Queue<GenericCallback<PerChannelBookieClient>> pendingOps = new ArrayDeque<GenericCallback<PerChannelBookieClient>>();
	 volatile Channel channel = null;
	 private final ClientConnectionPeer connectionPeer;
	 private volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;
	 enum ConnectionState {
	 DISCONNECTED, CONNECTING, CONNECTED, CLOSED, START_TLS }
	 volatile ConnectionState state;
	 final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();
	 private final ClientConfiguration conf;
	 private final PerChannelBookieClientPool pcbcPool;
	 private final ClientAuthProvider.Factory authProviderFactory;
	 private final ExtensionRegistry extRegistry;
	 private final SecurityHandlerFactory shFactory;
	 private volatile boolean isWritable = true;
	 public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup, BookieSocketAddress addr) throws SecurityException {
		 this(new ClientConfiguration(), executor, eventLoopGroup, addr, NullStatsLogger.INSTANCE, null, null, null);
	 }
	 public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup, BookieSocketAddress addr, ClientAuthProvider.Factory authProviderFactory, ExtensionRegistry extRegistry) throws SecurityException {
		 this(new ClientConfiguration(), executor, eventLoopGroup, addr, NullStatsLogger.INSTANCE, authProviderFactory, extRegistry, null);
	 }
	 public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor, EventLoopGroup eventLoopGroup, BookieSocketAddress addr, StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory, ExtensionRegistry extRegistry, PerChannelBookieClientPool pcbcPool) throws SecurityException {
		 this(conf, executor, eventLoopGroup, UnpooledByteBufAllocator.DEFAULT, addr, NullStatsLogger.INSTANCE, authProviderFactory, extRegistry, pcbcPool, null);
	 }
	 public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor, EventLoopGroup eventLoopGroup, ByteBufAllocator allocator, BookieSocketAddress addr, StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory, ExtensionRegistry extRegistry, PerChannelBookieClientPool pcbcPool, SecurityHandlerFactory shFactory) throws SecurityException {
		 this.maxFrameSize = conf.getNettyMaxFrameSizeBytes();
		 this.conf = conf;
		 this.addr = addr;
		 this.executor = executor;
		 if (LocalBookiesRegistry.isLocalBookie(addr)) {
			 this.eventLoopGroup = new DefaultEventLoopGroup();
		 }
		 else {
			 this.eventLoopGroup = eventLoopGroup;
		 }
		 this.allocator = allocator;
		 this.state = ConnectionState.DISCONNECTED;
		 this.addEntryTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getAddEntryTimeout());
		 this.readEntryTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getReadEntryTimeout());
		 this.getBookieInfoTimeout = conf.getBookieInfoTimeout();
		 this.startTLSTimeout = conf.getStartTLSTimeout();
		 this.useV2WireProtocol = conf.getUseV2WireProtocol();
		 this.preserveMdcForTaskExecution = conf.getPreserveMdcForTaskExecution();
		 this.authProviderFactory = authProviderFactory;
		 this.extRegistry = extRegistry;
		 this.shFactory = shFactory;
		 if (shFactory != null) {
			 shFactory.init(NodeType.Client, conf, allocator);
		 }
		 StringBuilder nameBuilder = new StringBuilder();
		 nameBuilder.append(addr.getHostName().replace('.', '_').replace('-', '_')) .append(""_"").append(addr.getPort());
		 this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE) .scope(nameBuilder.toString());
		 readEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_OP);
		 addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);
		 writeLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE_LAC_OP);
		 forceLedgerOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_FORCE_OP);
		 readLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_LAC_OP);
		 getBookieInfoOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.GET_BOOKIE_INFO_OP);
		 readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);
		 addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);
		 writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);
		 forceLedgerTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_FORCE);
		 readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);
		 getBookieInfoTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO);
		 startTLSOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_START_TLS_OP);
		 startTLSTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP);
		 exceptionCounter = statsLogger.getCounter(BookKeeperClientStats.NETTY_EXCEPTION_CNT);
		 connectTimer = statsLogger.getOpStatsLogger(BookKeeperClientStats.CLIENT_CONNECT_TIMER);
		 addEntryOutstanding = statsLogger.getCounter(BookKeeperClientStats.ADD_OP_OUTSTANDING);
		 readEntryOutstanding = statsLogger.getCounter(BookKeeperClientStats.READ_OP_OUTSTANDING);
		 nettyOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.NETTY_OPS);
		 activeNonTlsChannelCounter = statsLogger.getCounter(BookKeeperClientStats.ACTIVE_NON_TLS_CHANNEL_COUNTER);
		 activeTlsChannelCounter = statsLogger.getCounter(BookKeeperClientStats.ACTIVE_TLS_CHANNEL_COUNTER);
		 failedConnectionCounter = statsLogger.getCounter(BookKeeperClientStats.FAILED_CONNECTION_COUNTER);
		 failedTlsHandshakeCounter = statsLogger.getCounter(BookKeeperClientStats.FAILED_TLS_HANDSHAKE_COUNTER);
		 this.pcbcPool = pcbcPool;
		 this.connectionPeer = new ClientConnectionPeer() {
			 public SocketAddress getRemoteAddr() {
				 Channel c = channel;
				 if (c != null) {
					 return c.remoteAddress();
				 }
				 else {
					 return null;
				 }
			 }
			 public Collection<Object> getProtocolPrincipals() {
				 Channel c = channel;
				 if (c == null) {
					 return Collections.emptyList();
				 }
				 SslHandler ssl = c.pipeline().get(SslHandler.class);
				 if (ssl == null) {
					 return Collections.emptyList();
				 }
				 try {
					 Certificate[] certificates = ssl.engine().getSession().getPeerCertificates();
					 if (certificates == null) {
						 return Collections.emptyList();
					 }
					 List<Object> result = new ArrayList<>();
					 result.addAll(Arrays.asList(certificates));
					 return result;
				 }
				 catch (SSLPeerUnverifiedException err) {
					 return Collections.emptyList();
				 }
			 }
			 public void disconnect() {
				 Channel c = channel;
				 if (c != null) {
					 c.close().addListener(x -> makeWritable());
				 }
				 LOG.info(""authplugin disconnected channel {
				}
				"", channel);
			 }
			 public void setAuthorizedId(BookKeeperPrincipal principal) {
				 authorizedId = principal;
				 LOG.info(""connection {
				}
				 authenticated as {
				}
				"", channel, principal);
			 }
			 public BookKeeperPrincipal getAuthorizedId() {
				 return authorizedId;
			 }
			 public boolean isSecure() {
				 Channel c = channel;
				 if (c == null) {
					 return false;
				 }
				 else {
					 return c.pipeline().get(SslHandler.class) != null;
				 }
			 }
		 }
		;
	 }
	 private void completeOperation(GenericCallback<PerChannelBookieClient> op, int rc) {
		 closeLock.readLock().lock();
		 try {
			 if (ConnectionState.CLOSED == state) {
				 op.operationComplete(BKException.Code.ClientClosedException, this);
			 }
			 else {
				 op.operationComplete(rc, this);
			 }
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 protected long getNumPendingCompletionRequests() {
		 return completionObjects.size();
	 }
	 protected ChannelFuture connect() {
		 final long startTime = MathUtils.nowInNano();
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Connecting to bookie: {
			}
			"", addr);
		 }
		 Bootstrap bootstrap = new Bootstrap();
		 bootstrap.group(eventLoopGroup);
		 if (eventLoopGroup instanceof EpollEventLoopGroup) {
			 bootstrap.channel(EpollSocketChannel.class);
		 }
		 else if (eventLoopGroup instanceof DefaultEventLoopGroup) {
			 bootstrap.channel(LocalChannel.class);
		 }
		 else {
			 bootstrap.channel(NioSocketChannel.class);
		 }
		 bootstrap.option(ChannelOption.ALLOCATOR, this.allocator);
		 bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.getClientConnectTimeoutMillis());
		 bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark( conf.getClientWriteBufferLowWaterMark(), conf.getClientWriteBufferHighWaterMark()));
		 if (!(eventLoopGroup instanceof DefaultEventLoopGroup)) {
			 bootstrap.option(ChannelOption.TCP_NODELAY, conf.getClientTcpNoDelay());
			 bootstrap.option(ChannelOption.SO_KEEPALIVE, conf.getClientSockKeepalive());
			 if (conf.getClientSendBufferSize() > 0) {
				 bootstrap.option(ChannelOption.SO_SNDBUF, conf.getClientSendBufferSize());
			 }
			 if (conf.getClientReceiveBufferSize() > 0) {
				 bootstrap.option(ChannelOption.SO_RCVBUF, conf.getClientReceiveBufferSize());
			 }
		 }
		 bootstrap.handler(new ChannelInitializer<Channel>() {
			 protected void initChannel(Channel ch) throws Exception {
				 ChannelPipeline pipeline = ch.pipeline();
				 pipeline.addLast(""bytebufList"", ByteBufList.ENCODER_WITH_SIZE);
				 pipeline.addLast(""lengthbasedframedecoder"", new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));
				 pipeline.addLast(""lengthprepender"", new LengthFieldPrepender(4));
				 pipeline.addLast(""bookieProtoEncoder"", new BookieProtoEncoding.RequestEncoder(extRegistry));
				 pipeline.addLast( ""bookieProtoDecoder"", new BookieProtoEncoding.ResponseDecoder(extRegistry, useV2WireProtocol));
				 pipeline.addLast(""authHandler"", new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator, connectionPeer, useV2WireProtocol));
				 pipeline.addLast(""mainhandler"", PerChannelBookieClient.this);
			 }
		 }
		);
		 SocketAddress bookieAddr = addr.getSocketAddress();
		 if (eventLoopGroup instanceof DefaultEventLoopGroup) {
			 bookieAddr = addr.getLocalAddress();
		 }
		 ChannelFuture future = bootstrap.connect(bookieAddr);
		 future.addListener(contextPreservingListener(new ConnectionFutureListener(startTime)));
		 future.addListener(x -> makeWritable());
		 return future;
	 }
	 void cleanDisconnectAndClose() {
		 disconnect();
		 close();
	 }
	 public boolean isWritable() {
		 return isWritable;
	 }
	 public void setWritable(boolean val) {
		 isWritable = val;
	 }
	 private void makeWritable() {
		 setWritable(true);
	 }
	 void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {
		 boolean completeOpNow = false;
		 int opRc = BKException.Code.OK;
		 if (channel != null && state == ConnectionState.CONNECTED) {
			 completeOpNow = true;
		 }
		 else {
			 synchronized (this) {
				 if (channel != null && state == ConnectionState.CONNECTED) {
					 completeOpNow = true;
					 opRc = BKException.Code.OK;
				 }
				 else if (state == ConnectionState.CLOSED) {
					 completeOpNow = true;
					 opRc = BKException.Code.BookieHandleNotAvailableException;
				 }
				 else {
					 pendingOps.add(op);
					 if (state == ConnectionState.CONNECTING || state == ConnectionState.START_TLS) {
						 return;
					 }
					 state = ConnectionState.CONNECTING;
				 }
			 }
			 if (!completeOpNow) {
				 connect();
			 }
		 }
		 if (completeOpNow) {
			 completeOperation(op, opRc);
		 }
	 }
	 void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ByteBufList toSend, WriteLacCallback cb, Object ctx) {
		 final long txnId = getTxnId();
		 final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.WRITE_LAC);
		 completionObjects.put(completionKey, new WriteLacCompletion(completionKey, cb, ctx, lac));
		 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.WRITE_LAC) .setTxnId(txnId);
		 ByteString body;
		 if (toSend.hasArray()) {
			 body = UnsafeByteOperations.unsafeWrap(toSend.array(), toSend.arrayOffset(), toSend.readableBytes());
		 }
		 else if (toSend.size() == 1) {
			 body = UnsafeByteOperations.unsafeWrap(toSend.getBuffer(0).nioBuffer());
		 }
		 else {
			 body = UnsafeByteOperations.unsafeWrap(toSend.toArray());
		 }
		 WriteLacRequest.Builder writeLacBuilder = WriteLacRequest.newBuilder() .setLedgerId(ledgerId) .setLac(lac) .setMasterKey(UnsafeByteOperations.unsafeWrap(masterKey)) .setBody(body);
		 final Request writeLacRequest = withRequestContext(Request.newBuilder()) .setHeader(headerBuilder) .setWriteLacRequest(writeLacBuilder) .build();
		 writeAndFlush(channel, completionKey, writeLacRequest);
	 }
	 void forceLedger(final long ledgerId, ForceLedgerCallback cb, Object ctx) {
		 if (useV2WireProtocol) {
			 LOG.error(""force is not allowed with v2 protocol"");
			 executor.executeOrdered(ledgerId, () -> {
				 cb.forceLedgerComplete(BKException.Code.IllegalOpException, ledgerId, addr, ctx);
			 }
			);
			 return;
		 }
		 final long txnId = getTxnId();
		 final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.FORCE_LEDGER);
		 completionObjects.put(completionKey, new ForceLedgerCompletion(completionKey, cb, ctx, ledgerId));
		 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.FORCE_LEDGER) .setTxnId(txnId);
		 ForceLedgerRequest.Builder writeLacBuilder = ForceLedgerRequest.newBuilder() .setLedgerId(ledgerId);
		 final Request forceLedgerRequest = withRequestContext(Request.newBuilder()) .setHeader(headerBuilder) .setForceLedgerRequest(writeLacBuilder) .build();
		 writeAndFlush(channel, completionKey, forceLedgerRequest);
	 }
	 void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ByteBufList toSend, WriteCallback cb, Object ctx, final int options, boolean allowFastFail, final EnumSet<WriteFlag> writeFlags) {
		 Object request = null;
		 CompletionKey completionKey = null;
		 if (useV2WireProtocol) {
			 if (writeFlags.contains(WriteFlag.DEFERRED_SYNC)) {
				 LOG.error(""invalid writeflags {
				}
				 for v2 protocol"", writeFlags);
				 executor.executeOrdered(ledgerId, () -> {
					 cb.writeComplete(BKException.Code.IllegalOpException, ledgerId, entryId, addr, ctx);
				 }
				);
				 return;
			 }
			 completionKey = acquireV2Key(ledgerId, entryId, OperationType.ADD_ENTRY);
			 request = BookieProtocol.AddRequest.create( BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId, (short) options, masterKey, toSend);
		 }
		 else {
			 final long txnId = getTxnId();
			 completionKey = new V3CompletionKey(txnId, OperationType.ADD_ENTRY);
			 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.ADD_ENTRY) .setTxnId(txnId);
			 if (((short) options & BookieProtocol.FLAG_HIGH_PRIORITY) == BookieProtocol.FLAG_HIGH_PRIORITY) {
				 headerBuilder.setPriority(DEFAULT_HIGH_PRIORITY_VALUE);
			 }
			 ByteString body;
			 if (toSend.hasArray()) {
				 body = UnsafeByteOperations.unsafeWrap(toSend.array(), toSend.arrayOffset(), toSend.readableBytes());
			 }
			 else if (toSend.size() == 1) {
				 body = UnsafeByteOperations.unsafeWrap(toSend.getBuffer(0).nioBuffer());
			 }
			 else {
				 body = UnsafeByteOperations.unsafeWrap(toSend.toArray());
			 }
			 AddRequest.Builder addBuilder = AddRequest.newBuilder() .setLedgerId(ledgerId) .setEntryId(entryId) .setMasterKey(UnsafeByteOperations.unsafeWrap(masterKey)) .setBody(body);
			 if (((short) options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {
				 addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);
			 }
			 if (!writeFlags.isEmpty()) {
				 addBuilder.setWriteFlags(WriteFlag.getWriteFlagsValue(writeFlags));
			 }
			 request = withRequestContext(Request.newBuilder()) .setHeader(headerBuilder) .setAddRequest(addBuilder) .build();
		 }
		 putCompletionKeyValue(completionKey, acquireAddCompletion(completionKey, cb, ctx, ledgerId, entryId));
		 final Channel c = channel;
		 if (c == null) {
			 errorOut(completionKey);
			 toSend.release();
			 return;
		 }
		 else {
			 writeAndFlush(c, completionKey, request, allowFastFail);
		 }
	 }
	 public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {
		 Object request = null;
		 CompletionKey completionKey = null;
		 if (useV2WireProtocol) {
			 request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, 0, (short) 0, null);
			 completionKey = acquireV2Key(ledgerId, 0, OperationType.READ_LAC);
		 }
		 else {
			 final long txnId = getTxnId();
			 completionKey = new V3CompletionKey(txnId, OperationType.READ_LAC);
			 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.READ_LAC) .setTxnId(txnId);
			 ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder() .setLedgerId(ledgerId);
			 request = withRequestContext(Request.newBuilder()) .setHeader(headerBuilder) .setReadLacRequest(readLacBuilder) .build();
		 }
		 putCompletionKeyValue(completionKey, new ReadLacCompletion(completionKey, cb, ctx, ledgerId));
		 writeAndFlush(channel, completionKey, request);
	 }
	 public void readEntryWaitForLACUpdate(final long ledgerId, final long entryId, final long previousLAC, final long timeOutInMillis, final boolean piggyBackEntry, ReadEntryCallback cb, Object ctx) {
		 readEntryInternal(ledgerId, entryId, previousLAC, timeOutInMillis, piggyBackEntry, cb, ctx, (short) 0, null, false);
	 }
	 public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx, int flags, byte[] masterKey, boolean allowFastFail) {
		 readEntryInternal(ledgerId, entryId, null, null, false, cb, ctx, (short) flags, masterKey, allowFastFail);
	 }
	 private void readEntryInternal(final long ledgerId, final long entryId, final Long previousLAC, final Long timeOutInMillis, final boolean piggyBackEntry, final ReadEntryCallback cb, final Object ctx, int flags, byte[] masterKey, boolean allowFastFail) {
		 Object request = null;
		 CompletionKey completionKey = null;
		 if (useV2WireProtocol) {
			 request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId, (short) flags, masterKey);
			 completionKey = acquireV2Key(ledgerId, entryId, OperationType.READ_ENTRY);
		 }
		 else {
			 final long txnId = getTxnId();
			 completionKey = new V3CompletionKey(txnId, OperationType.READ_ENTRY);
			 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.READ_ENTRY) .setTxnId(txnId);
			 if (((short) flags & BookieProtocol.FLAG_HIGH_PRIORITY) == BookieProtocol.FLAG_HIGH_PRIORITY) {
				 headerBuilder.setPriority(DEFAULT_HIGH_PRIORITY_VALUE);
			 }
			 ReadRequest.Builder readBuilder = ReadRequest.newBuilder() .setLedgerId(ledgerId) .setEntryId(entryId);
			 if (null != previousLAC) {
				 readBuilder = readBuilder.setPreviousLAC(previousLAC);
			 }
			 if (null != timeOutInMillis) {
				 if (null == previousLAC) {
					 cb.readEntryComplete(BKException.Code.IncorrectParameterException, ledgerId, entryId, null, ctx);
					 return;
				 }
				 readBuilder = readBuilder.setTimeOut(timeOutInMillis);
			 }
			 if (piggyBackEntry) {
				 if (null == previousLAC) {
					 cb.readEntryComplete(BKException.Code.IncorrectParameterException, ledgerId, entryId, null, ctx);
					 return;
				 }
				 readBuilder = readBuilder.setFlag(ReadRequest.Flag.ENTRY_PIGGYBACK);
			 }
			 if (((short) flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {
				 readBuilder.setFlag(ReadRequest.Flag.FENCE_LEDGER);
				 if (masterKey == null) {
					 cb.readEntryComplete(BKException.Code.IncorrectParameterException, ledgerId, entryId, null, ctx);
					 return;
				 }
				 readBuilder.setMasterKey(ByteString.copyFrom(masterKey));
			 }
			 request = withRequestContext(Request.newBuilder()) .setHeader(headerBuilder) .setReadRequest(readBuilder) .build();
		 }
		 ReadCompletion readCompletion = new ReadCompletion(completionKey, cb, ctx, ledgerId, entryId);
		 putCompletionKeyValue(completionKey, readCompletion);
		 writeAndFlush(channel, completionKey, request, allowFastFail);
	 }
	 public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object ctx) {
		 final long txnId = getTxnId();
		 final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.GET_BOOKIE_INFO);
		 completionObjects.put(completionKey, new GetBookieInfoCompletion( completionKey, cb, ctx));
		 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.GET_BOOKIE_INFO) .setTxnId(txnId);
		 GetBookieInfoRequest.Builder getBookieInfoBuilder = GetBookieInfoRequest.newBuilder() .setRequested(requested);
		 final Request getBookieInfoRequest = withRequestContext(Request.newBuilder()) .setHeader(headerBuilder) .setGetBookieInfoRequest(getBookieInfoBuilder) .build();
		 writeAndFlush(channel, completionKey, getBookieInfoRequest);
	 }
	 private static final BiPredicate<CompletionKey, CompletionValue> timeoutCheck = (key, value) -> {
		 return value.maybeTimeout();
	 }
	;
	 public void checkTimeoutOnPendingOperations() {
		 int timedOutOperations = completionObjects.removeIf(timeoutCheck);
		 timedOutOperations += completionObjectsV2Conflicts.removeIf(timeoutCheck);
		 if (timedOutOperations > 0) {
			 LOG.info(""Timed-out {
			}
			 operations to channel {
			}
			 for {
			}
			"", timedOutOperations, channel, addr);
		 }
	 }
	 public void disconnect() {
		 disconnect(true);
	 }
	 public void disconnect(boolean wait) {
		 LOG.info(""Disconnecting the per channel bookie client for {
		}
		"", addr);
		 closeInternal(false, wait);
	 }
	 public void close() {
		 close(true);
	 }
	 public void close(boolean wait) {
		 LOG.info(""Closing the per channel bookie client for {
		}
		"", addr);
		 closeLock.writeLock().lock();
		 try {
			 if (ConnectionState.CLOSED == state) {
				 return;
			 }
			 state = ConnectionState.CLOSED;
			 errorOutOutstandingEntries(BKException.Code.ClientClosedException);
		 }
		 finally {
			 closeLock.writeLock().unlock();
		 }
		 if (channel != null && channel.pipeline().get(SslHandler.class) != null) {
			 activeTlsChannelCounter.dec();
		 }
		 else {
			 activeNonTlsChannelCounter.dec();
		 }
		 closeInternal(true, wait);
	 }
	 private void closeInternal(boolean permanent, boolean wait) {
		 Channel toClose = null;
		 synchronized (this) {
			 if (permanent) {
				 state = ConnectionState.CLOSED;
			 }
			 else if (state != ConnectionState.CLOSED) {
				 state = ConnectionState.DISCONNECTED;
			 }
			 toClose = channel;
			 channel = null;
			 makeWritable();
		 }
		 if (toClose != null) {
			 ChannelFuture cf = closeChannel(toClose);
			 if (wait) {
				 cf.awaitUninterruptibly();
			 }
		 }
	 }
	 private ChannelFuture closeChannel(Channel c) {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Closing channel {
			}
			"", c);
		 }
		 return c.close().addListener(x -> makeWritable());
	 }
	 public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
		 final Channel c = channel;
		 if (c == null || c.isWritable()) {
			 makeWritable();
		 }
		 super.channelWritabilityChanged(ctx);
	 }
	 private void writeAndFlush(final Channel channel, final CompletionKey key, final Object request) {
		 writeAndFlush(channel, key, request, false);
	 }
	 private void writeAndFlush(final Channel channel, final CompletionKey key, final Object request, final boolean allowFastFail) {
		 if (channel == null) {
			 LOG.warn(""Operation {
			}
			 failed: channel == null"", StringUtils.requestToString(request));
			 errorOut(key);
			 return;
		 }
		 final boolean isChannelWritable = channel.isWritable();
		 if (isWritable != isChannelWritable) {
			 isWritable = isChannelWritable;
		 }
		 if (allowFastFail && !isWritable) {
			 LOG.warn(""Operation {
			}
			 failed: TooManyRequestsException"", StringUtils.requestToString(request));
			 errorOut(key, BKException.Code.TooManyRequestsException);
			 return;
		 }
		 try {
			 final long startTime = MathUtils.nowInNano();
			 ChannelPromise promise = channel.newPromise().addListener(future -> {
				 if (future.isSuccess()) {
					 nettyOpLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);
					 CompletionValue completion = completionObjects.get(key);
					 if (completion != null) {
						 completion.setOutstanding();
					 }
				 }
				 else {
					 nettyOpLogger.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);
				 }
			 }
			);
			 channel.writeAndFlush(request, promise);
		 }
		 catch (Throwable e) {
			 LOG.warn(""Operation {
			}
			 failed"", StringUtils.requestToString(request), e);
			 errorOut(key);
		 }
	 }
	 void errorOut(final CompletionKey key) {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Removing completion key: {
			}
			"", key);
		 }
		 CompletionValue completion = completionObjects.remove(key);
		 if (completion != null) {
			 completion.errorOut();
		 }
		 else {
			 completionObjectsV2Conflicts.removeAny(key).ifPresent(c -> c.errorOut());
		 }
	 }
	 void errorOut(final CompletionKey key, final int rc) {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Removing completion key: {
			}
			"", key);
		 }
		 CompletionValue completion = completionObjects.remove(key);
		 if (completion != null) {
			 completion.errorOut(rc);
		 }
		 else {
			 completionObjectsV2Conflicts.removeAny(key).ifPresent(c -> c.errorOut(rc));
		 }
	 }
	 void errorOutPendingOps(int rc) {
		 Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;
		 synchronized (this) {
			 oldPendingOps = pendingOps;
			 pendingOps = new ArrayDeque<>();
		 }
		 for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {
			 pendingOp.operationComplete(rc, PerChannelBookieClient.this);
		 }
	 }
	 void errorOutOutstandingEntries(int rc) {
		 Optional<CompletionKey> multikey = completionObjectsV2Conflicts.getAnyKey();
		 while (multikey.isPresent()) {
			 multikey.ifPresent(k -> errorOut(k, rc));
			 multikey = completionObjectsV2Conflicts.getAnyKey();
		 }
		 for (CompletionKey key : completionObjects.keys()) {
			 errorOut(key, rc);
		 }
	 }
	 void recordError() {
		 if (pcbcPool != null) {
			 pcbcPool.recordError();
		 }
	 }
	 public void channelInactive(ChannelHandlerContext ctx) throws Exception {
		 LOG.info(""Disconnected from bookie channel {
		}
		"", ctx.channel());
		 if (ctx.channel() != null) {
			 closeChannel(ctx.channel());
			 if (ctx.channel().pipeline().get(SslHandler.class) != null) {
				 activeTlsChannelCounter.dec();
			 }
			 else {
				 activeNonTlsChannelCounter.dec();
			 }
		 }
		 errorOutOutstandingEntries(BKException.Code.BookieHandleNotAvailableException);
		 errorOutPendingOps(BKException.Code.BookieHandleNotAvailableException);
		 synchronized (this) {
			 if (this.channel == ctx.channel() && state != ConnectionState.CLOSED) {
				 state = ConnectionState.DISCONNECTED;
			 }
		 }
	 }
	 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
		 exceptionCounter.inc();
		 if (cause instanceof CorruptedFrameException || cause instanceof TooLongFrameException) {
			 LOG.error(""Corrupted frame received from bookie: {
			}
			"", ctx.channel().remoteAddress());
			 ctx.close();
			 return;
		 }
		 if (cause instanceof AuthHandler.AuthenticationException) {
			 LOG.error(""Error authenticating connection"", cause);
			 errorOutOutstandingEntries(BKException.Code.UnauthorizedAccessException);
			 Channel c = ctx.channel();
			 if (c != null) {
				 closeChannel(c);
			 }
			 return;
		 }
		 if (cause instanceof DecoderException && cause.getCause() instanceof SSLHandshakeException) {
			 LOG.error(""TLS handshake failed"", cause);
			 errorOutPendingOps(BKException.Code.SecurityException);
			 Channel c = ctx.channel();
			 if (c != null) {
				 closeChannel(c);
			 }
		 }
		 if (cause instanceof IOException) {
			 if (cause instanceof NativeIoException) {
				 LOG.warn(""Exception caught on:{
				}
				 cause: {
				}
				"", ctx.channel(), cause.getMessage());
			 }
			 else {
				 LOG.warn(""Exception caught on:{
				}
				 cause:"", ctx.channel(), cause);
			 }
			 ctx.close();
			 return;
		 }
		 synchronized (this) {
			 if (state == ConnectionState.CLOSED) {
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Unexpected exception caught by bookie client channel handler, "" + ""but the client is closed, so it isn't important"", cause);
				 }
			 }
			 else {
				 LOG.error(""Unexpected exception caught by bookie client channel handler"", cause);
			 }
		 }
		 ctx.close();
	 }
	 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
		 if (msg instanceof BookieProtocol.Response) {
			 BookieProtocol.Response response = (BookieProtocol.Response) msg;
			 readV2Response(response);
		 }
		 else if (msg instanceof Response) {
			 Response response = (Response) msg;
			 readV3Response(response);
		 }
		 else {
			 ctx.fireChannelRead(msg);
		 }
	 }
	 private void readV2Response(final BookieProtocol.Response response) {
		 OperationType operationType = getOperationType(response.getOpCode());
		 StatusCode status = getStatusCodeFromErrorCode(response.errorCode);
		 CompletionKey key = acquireV2Key(response.ledgerId, response.entryId, operationType);
		 CompletionValue completionValue = getCompletionValue(key);
		 key.release();
		 if (null == completionValue) {
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(""Unexpected response received from bookie : "" + addr + "" for type : "" + operationType + "" and ledger:entry : "" + response.ledgerId + "":"" + response.entryId);
			 }
			 response.release();
		 }
		 else {
			 long orderingKey = completionValue.ledgerId;
			 executor.executeOrdered(orderingKey, ReadV2ResponseCallback.create(completionValue, response.ledgerId, response.entryId, status, response));
		 }
	 }
	 private static class ReadV2ResponseCallback extends SafeRunnable {
		 CompletionValue completionValue;
		 long ledgerId;
		 long entryId;
		 StatusCode status;
		 BookieProtocol.Response response;
		 static ReadV2ResponseCallback create(CompletionValue completionValue, long ledgerId, long entryId, StatusCode status, BookieProtocol.Response response) {
			 ReadV2ResponseCallback callback = RECYCLER.get();
			 callback.completionValue = completionValue;
			 callback.ledgerId = ledgerId;
			 callback.entryId = entryId;
			 callback.status = status;
			 callback.response = response;
			 return callback;
		 }
		 public void safeRun() {
			 completionValue.handleV2Response(ledgerId, entryId, status, response);
			 response.release();
			 response.recycle();
			 recycle();
		 }
		 void recycle() {
			 completionValue = null;
			 ledgerId = -1;
			 entryId = -1;
			 status = null;
			 response = null;
			 recyclerHandle.recycle(this);
		 }
		 private final Handle<ReadV2ResponseCallback> recyclerHandle;
		 private ReadV2ResponseCallback(Handle<ReadV2ResponseCallback> recyclerHandle) {
			 this.recyclerHandle = recyclerHandle;
		 }
		 private static final Recycler<ReadV2ResponseCallback> RECYCLER = new Recycler<ReadV2ResponseCallback>() {
			 protected ReadV2ResponseCallback newObject(Handle<ReadV2ResponseCallback> handle) {
				 return new ReadV2ResponseCallback(handle);
			 }
		 }
		;
	 }
	 private static OperationType getOperationType(byte opCode) {
		 switch (opCode) {
			 case BookieProtocol.ADDENTRY: return OperationType.ADD_ENTRY;
			 case BookieProtocol.READENTRY: return OperationType.READ_ENTRY;
			 case BookieProtocol.AUTH: return OperationType.AUTH;
			 case BookieProtocol.READ_LAC: return OperationType.READ_LAC;
			 case BookieProtocol.WRITE_LAC: return OperationType.WRITE_LAC;
			 case BookieProtocol.GET_BOOKIE_INFO: return OperationType.GET_BOOKIE_INFO;
			 default: throw new IllegalArgumentException(""Invalid operation type "" + opCode);
		 }
	 }
	 private static StatusCode getStatusCodeFromErrorCode(int errorCode) {
		 switch (errorCode) {
			 case BookieProtocol.EOK: return StatusCode.EOK;
			 case BookieProtocol.ENOLEDGER: return StatusCode.ENOLEDGER;
			 case BookieProtocol.ENOENTRY: return StatusCode.ENOENTRY;
			 case BookieProtocol.EBADREQ: return StatusCode.EBADREQ;
			 case BookieProtocol.EIO: return StatusCode.EIO;
			 case BookieProtocol.EUA: return StatusCode.EUA;
			 case BookieProtocol.EBADVERSION: return StatusCode.EBADVERSION;
			 case BookieProtocol.EFENCED: return StatusCode.EFENCED;
			 case BookieProtocol.EREADONLY: return StatusCode.EREADONLY;
			 case BookieProtocol.ETOOMANYREQUESTS: return StatusCode.ETOOMANYREQUESTS;
			 default: throw new IllegalArgumentException(""Invalid error code: "" + errorCode);
		 }
	 }
	 private void readV3Response(final Response response) {
		 final BKPacketHeader header = response.getHeader();
		 final CompletionKey key = newCompletionKey(header.getTxnId(), header.getOperation());
		 final CompletionValue completionValue = completionObjects.get(key);
		 if (null == completionValue) {
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(""Unexpected response received from bookie : "" + addr + "" for type : "" + header.getOperation() + "" and txnId : "" + header.getTxnId());
			 }
		 }
		 else {
			 long orderingKey = completionValue.ledgerId;
			 executor.executeOrdered(orderingKey, new SafeRunnable() {
				 public void safeRun() {
					 completionValue.restoreMdcContext();
					 completionValue.handleV3Response(response);
				 }
				 public String toString() {
					 return String.format(""HandleResponse(Txn=%d, Type=%s, Entry=(%d, %d))"", header.getTxnId(), header.getOperation(), completionValue.ledgerId, completionValue.entryId);
				 }
			 }
			);
		 }
		 completionObjects.remove(key);
	 }
	 void initTLSHandshake() {
		 PerChannelBookieClient parentObj = PerChannelBookieClient.this;
		 SslHandler handler = parentObj.shFactory.newTLSHandler();
		 channel.pipeline().addFirst(parentObj.shFactory.getHandlerName(), handler);
		 handler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
			 public void operationComplete(Future<Channel> future) throws Exception {
				 int rc;
				 Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;
				 synchronized (PerChannelBookieClient.this) {
					 if (future.isSuccess() && state == ConnectionState.CONNECTING) {
						 LOG.error(""Connection state changed before TLS handshake completed {
						}
						/{
						}
						"", addr, state);
						 rc = BKException.Code.BookieHandleNotAvailableException;
						 closeChannel(channel);
						 channel = null;
						 if (state != ConnectionState.CLOSED) {
							 state = ConnectionState.DISCONNECTED;
						 }
					 }
					 else if (future.isSuccess() && state == ConnectionState.START_TLS) {
						 rc = BKException.Code.OK;
						 LOG.info(""Successfully connected to bookie using TLS: "" + addr);
						 state = ConnectionState.CONNECTED;
						 AuthHandler.ClientSideHandler authHandler = future.get().pipeline() .get(AuthHandler.ClientSideHandler.class);
						 authHandler.authProvider.onProtocolUpgrade();
						 activeTlsChannelCounter.inc();
					 }
					 else if (future.isSuccess() && (state == ConnectionState.CLOSED || state == ConnectionState.DISCONNECTED)) {
						 LOG.warn(""Closed before TLS handshake completed, clean up: {
						}
						, current state {
						}
						"", channel, state);
						 closeChannel(channel);
						 rc = BKException.Code.BookieHandleNotAvailableException;
						 channel = null;
					 }
					 else if (future.isSuccess() && state == ConnectionState.CONNECTED) {
						 LOG.debug(""Already connected with another channel({
						}
						), so close the new channel({
						}
						)"", channel, channel);
						 closeChannel(channel);
						 return;
					 }
					 else {
						 LOG.error(""TLS handshake failed with bookie: {
						}
						/{
						}
						, current state {
						}
						 : "", channel, addr, state, future.cause());
						 rc = BKException.Code.SecurityException;
						 closeChannel(channel);
						 channel = null;
						 if (state != ConnectionState.CLOSED) {
							 state = ConnectionState.DISCONNECTED;
						 }
						 failedTlsHandshakeCounter.inc();
					 }
					 oldPendingOps = pendingOps;
					 pendingOps = new ArrayDeque<>();
				 }
				 makeWritable();
				 for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {
					 pendingOp.operationComplete(rc, PerChannelBookieClient.this);
				 }
			 }
		 }
		);
	 }
	 abstract class CompletionValue {
		 private final OpStatsLogger opLogger;
		 private final OpStatsLogger timeoutOpLogger;
		 private final String operationName;
		 private final Map<String, String> mdcContextMap;
		 protected Object ctx;
		 protected long ledgerId;
		 protected long entryId;
		 protected long startTime;
		 public CompletionValue(String operationName, Object ctx, long ledgerId, long entryId, OpStatsLogger opLogger, OpStatsLogger timeoutOpLogger) {
			 this.operationName = operationName;
			 this.ctx = ctx;
			 this.ledgerId = ledgerId;
			 this.entryId = entryId;
			 this.startTime = MathUtils.nowInNano();
			 this.opLogger = opLogger;
			 this.timeoutOpLogger = timeoutOpLogger;
			 this.mdcContextMap = preserveMdcForTaskExecution ? MDC.getCopyOfContextMap() : null;
		 }
		 private long latency() {
			 return MathUtils.elapsedNanos(startTime);
		 }
		 void logOpResult(int rc) {
			 if (rc != BKException.Code.OK) {
				 opLogger.registerFailedEvent(latency(), TimeUnit.NANOSECONDS);
			 }
			 else {
				 opLogger.registerSuccessfulEvent(latency(), TimeUnit.NANOSECONDS);
			 }
			 if (rc != BKException.Code.OK && !expectedBkOperationErrors.contains(rc)) {
				 recordError();
			 }
		 }
		 boolean maybeTimeout() {
			 if (MathUtils.elapsedNanos(startTime) >= readEntryTimeoutNanos) {
				 timeout();
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 void timeout() {
			 errorOut(BKException.Code.TimeoutException);
			 timeoutOpLogger.registerSuccessfulEvent(latency(), TimeUnit.NANOSECONDS);
		 }
		 protected void logResponse(StatusCode status, Object... extraInfo) {
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(""Got {
				}
				 response from bookie:{
				}
				 rc:{
				}
				, {
				}
				"", operationName, addr, status, Joiner.on("":"").join(extraInfo));
			 }
		 }
		 protected int convertStatus(StatusCode status, int defaultStatus) {
			 int rcToRet = statusCodeToExceptionCode(status);
			 if (rcToRet == BKException.Code.UNINITIALIZED) {
				 LOG.error(""{
				}
				 for failed on bookie {
				}
				 code {
				}
				"", operationName, addr, status);
				 return defaultStatus;
			 }
			 else {
				 return rcToRet;
			 }
		 }
		 public void restoreMdcContext() {
			 MdcUtils.restoreContext(mdcContextMap);
		 }
		 public abstract void errorOut();
		 public abstract void errorOut(int rc);
		 public void setOutstanding() {
		 }
		 protected void errorOutAndRunCallback(final Runnable callback) {
			 executor.executeOrdered(ledgerId, new SafeRunnable() {
				 public void safeRun() {
					 String bAddress = ""null"";
					 Channel c = channel;
					 if (c != null && c.remoteAddress() != null) {
						 bAddress = c.remoteAddress().toString();
					 }
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""Could not write {
						}
						 request to bookie {
						}
						 for ledger {
						}
						, entry {
						}
						"", operationName, bAddress, ledgerId, entryId);
					 }
					 callback.run();
				 }
			 }
			);
		 }
		 public void handleV2Response( long ledgerId, long entryId, StatusCode status, BookieProtocol.Response response) {
			 LOG.warn(""Unhandled V2 response {
			}
			"", response);
		 }
		 public abstract void handleV3Response( BookkeeperProtocol.Response response);
	 }
	 class WriteLacCompletion extends CompletionValue {
		 final WriteLacCallback cb;
		 public WriteLacCompletion(final CompletionKey key, final WriteLacCallback originalCallback, final Object originalCtx, final long ledgerId) {
			 super(""WriteLAC"", originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, writeLacOpLogger, writeLacTimeoutOpLogger);
			 this.cb = new WriteLacCallback() {
				 public void writeLacComplete(int rc, long ledgerId, BookieSocketAddress addr, Object ctx) {
					 logOpResult(rc);
					 originalCallback.writeLacComplete(rc, ledgerId, addr, originalCtx);
					 key.release();
				 }
			 }
			;
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 errorOutAndRunCallback( () -> cb.writeLacComplete(rc, ledgerId, addr, ctx));
		 }
		 public void handleV3Response(BookkeeperProtocol.Response response) {
			 WriteLacResponse writeLacResponse = response.getWriteLacResponse();
			 StatusCode status = response.getStatus() == StatusCode.EOK ? writeLacResponse.getStatus() : response.getStatus();
			 long ledgerId = writeLacResponse.getLedgerId();
			 if (LOG.isDebugEnabled()) {
				 logResponse(status, ""ledger"", ledgerId);
			 }
			 int rc = convertStatus(status, BKException.Code.WriteException);
			 cb.writeLacComplete(rc, ledgerId, addr, ctx);
		 }
	 }
	 class ForceLedgerCompletion extends CompletionValue {
		 final ForceLedgerCallback cb;
		 public ForceLedgerCompletion(final CompletionKey key, final ForceLedgerCallback originalCallback, final Object originalCtx, final long ledgerId) {
			 super(""ForceLedger"", originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, forceLedgerOpLogger, forceLedgerTimeoutOpLogger);
			 this.cb = new ForceLedgerCallback() {
				 public void forceLedgerComplete(int rc, long ledgerId, BookieSocketAddress addr, Object ctx) {
					 logOpResult(rc);
					 originalCallback.forceLedgerComplete(rc, ledgerId, addr, originalCtx);
					 key.release();
				 }
			 }
			;
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 errorOutAndRunCallback( () -> cb.forceLedgerComplete(rc, ledgerId, addr, ctx));
		 }
		 public void handleV3Response(BookkeeperProtocol.Response response) {
			 ForceLedgerResponse forceLedgerResponse = response.getForceLedgerResponse();
			 StatusCode status = response.getStatus() == StatusCode.EOK ? forceLedgerResponse.getStatus() : response.getStatus();
			 long ledgerId = forceLedgerResponse.getLedgerId();
			 if (LOG.isDebugEnabled()) {
				 logResponse(status, ""ledger"", ledgerId);
			 }
			 int rc = convertStatus(status, BKException.Code.WriteException);
			 cb.forceLedgerComplete(rc, ledgerId, addr, ctx);
		 }
	 }
	 class ReadLacCompletion extends CompletionValue {
		 final ReadLacCallback cb;
		 public ReadLacCompletion(final CompletionKey key, ReadLacCallback originalCallback, final Object ctx, final long ledgerId) {
			 super(""ReadLAC"", ctx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, readLacOpLogger, readLacTimeoutOpLogger);
			 this.cb = new ReadLacCallback() {
				 public void readLacComplete(int rc, long ledgerId, ByteBuf lacBuffer, ByteBuf lastEntryBuffer, Object ctx) {
					 logOpResult(rc);
					 originalCallback.readLacComplete( rc, ledgerId, lacBuffer, lastEntryBuffer, ctx);
					 key.release();
				 }
			 }
			;
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 errorOutAndRunCallback( () -> cb.readLacComplete(rc, ledgerId, null, null, ctx));
		 }
		 public void handleV3Response(BookkeeperProtocol.Response response) {
			 ReadLacResponse readLacResponse = response.getReadLacResponse();
			 ByteBuf lacBuffer = Unpooled.EMPTY_BUFFER;
			 ByteBuf lastEntryBuffer = Unpooled.EMPTY_BUFFER;
			 StatusCode status = response.getStatus() == StatusCode.EOK ? readLacResponse.getStatus() : response.getStatus();
			 if (readLacResponse.hasLacBody()) {
				 lacBuffer = Unpooled.wrappedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());
			 }
			 if (readLacResponse.hasLastEntryBody()) {
				 lastEntryBuffer = Unpooled.wrappedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());
			 }
			 if (LOG.isDebugEnabled()) {
				 logResponse(status, ""ledgerId"", ledgerId);
			 }
			 int rc = convertStatus(status, BKException.Code.ReadException);
			 cb.readLacComplete(rc, ledgerId, lacBuffer.slice(), lastEntryBuffer.slice(), ctx);
		 }
	 }
	 class ReadCompletion extends CompletionValue {
		 final ReadEntryCallback cb;
		 public ReadCompletion(final CompletionKey key, final ReadEntryCallback originalCallback, final Object originalCtx, long ledgerId, final long entryId) {
			 super(""Read"", originalCtx, ledgerId, entryId, readEntryOpLogger, readTimeoutOpLogger);
			 this.cb = new ReadEntryCallback() {
				 public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx) {
					 logOpResult(rc);
					 originalCallback.readEntryComplete(rc, ledgerId, entryId, buffer, originalCtx);
					 key.release();
				 }
			 }
			;
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 errorOutAndRunCallback( () -> cb.readEntryComplete(rc, ledgerId, entryId, null, ctx));
		 }
		 public void setOutstanding() {
			 readEntryOutstanding.inc();
		 }
		 public void handleV2Response(long ledgerId, long entryId, StatusCode status, BookieProtocol.Response response) {
			 readEntryOutstanding.dec();
			 if (!(response instanceof BookieProtocol.ReadResponse)) {
				 return;
			 }
			 BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;
			 handleReadResponse(ledgerId, entryId, status, readResponse.getData(), INVALID_ENTRY_ID, -1L);
		 }
		 public void handleV3Response(BookkeeperProtocol.Response response) {
			 readEntryOutstanding.dec();
			 ReadResponse readResponse = response.getReadResponse();
			 StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();
			 ByteBuf buffer = Unpooled.EMPTY_BUFFER;
			 if (readResponse.hasBody()) {
				 buffer = Unpooled.wrappedBuffer(readResponse.getBody().asReadOnlyByteBuffer());
			 }
			 long maxLAC = INVALID_ENTRY_ID;
			 if (readResponse.hasMaxLAC()) {
				 maxLAC = readResponse.getMaxLAC();
			 }
			 long lacUpdateTimestamp = -1L;
			 if (readResponse.hasLacUpdateTimestamp()) {
				 lacUpdateTimestamp = readResponse.getLacUpdateTimestamp();
			 }
			 handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, maxLAC, lacUpdateTimestamp);
			 buffer.release();
		 }
		 private void handleReadResponse(long ledgerId, long entryId, StatusCode status, ByteBuf buffer, long maxLAC, long lacUpdateTimestamp) {
			 int readableBytes = buffer.readableBytes();
			 if (LOG.isDebugEnabled()) {
				 logResponse(status, ""ledger"", ledgerId, ""entry"", entryId, ""entryLength"", readableBytes);
			 }
			 int rc = convertStatus(status, BKException.Code.ReadException);
			 if (maxLAC > INVALID_ENTRY_ID && (ctx instanceof ReadEntryCallbackCtx)) {
				 ((ReadEntryCallbackCtx) ctx).setLastAddConfirmed(maxLAC);
			 }
			 if (lacUpdateTimestamp > -1L && (ctx instanceof ReadLastConfirmedAndEntryContext)) {
				 ((ReadLastConfirmedAndEntryContext) ctx).setLacUpdateTimestamp(lacUpdateTimestamp);
			 }
			 cb.readEntryComplete(rc, ledgerId, entryId, buffer.slice(), ctx);
		 }
	 }
	 class StartTLSCompletion extends CompletionValue {
		 final StartTLSCallback cb;
		 public StartTLSCompletion(final CompletionKey key) {
			 super(""StartTLS"", null, -1, -1, startTLSOpLogger, startTLSTimeoutOpLogger);
			 this.cb = new StartTLSCallback() {
				 public void startTLSComplete(int rc, Object ctx) {
					 logOpResult(rc);
					 key.release();
				 }
			 }
			;
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 failTLS(rc);
		 }
		 public void handleV3Response(BookkeeperProtocol.Response response) {
			 StatusCode status = response.getStatus();
			 if (LOG.isDebugEnabled()) {
				 logResponse(status);
			 }
			 int rc = convertStatus(status, BKException.Code.SecurityException);
			 cb.startTLSComplete(rc, null);
			 if (state != ConnectionState.START_TLS) {
				 LOG.error(""Connection state changed before TLS response received"");
				 failTLS(BKException.Code.BookieHandleNotAvailableException);
			 }
			 else if (status != StatusCode.EOK) {
				 LOG.error(""Client received error {
				}
				 during TLS negotiation"", status);
				 failTLS(BKException.Code.SecurityException);
			 }
			 else {
				 initTLSHandshake();
			 }
		 }
	 }
	 class GetBookieInfoCompletion extends CompletionValue {
		 final GetBookieInfoCallback cb;
		 public GetBookieInfoCompletion(final CompletionKey key, final GetBookieInfoCallback origCallback, final Object origCtx) {
			 super(""GetBookieInfo"", origCtx, 0L, 0L, getBookieInfoOpLogger, getBookieInfoTimeoutOpLogger);
			 this.cb = new GetBookieInfoCallback() {
				 public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {
					 logOpResult(rc);
					 origCallback.getBookieInfoComplete(rc, bInfo, origCtx);
					 key.release();
				 }
			 }
			;
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 errorOutAndRunCallback( () -> cb.getBookieInfoComplete(rc, new BookieInfo(), ctx));
		 }
		 public void handleV3Response(BookkeeperProtocol.Response response) {
			 GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();
			 StatusCode status = response.getStatus() == StatusCode.EOK ? getBookieInfoResponse.getStatus() : response.getStatus();
			 long freeDiskSpace = getBookieInfoResponse.getFreeDiskSpace();
			 long totalDiskSpace = getBookieInfoResponse.getTotalDiskCapacity();
			 if (LOG.isDebugEnabled()) {
				 logResponse(status, ""freeDisk"", freeDiskSpace, ""totalDisk"", totalDiskSpace);
			 }
			 int rc = convertStatus(status, BKException.Code.ReadException);
			 cb.getBookieInfoComplete(rc, new BookieInfo(totalDiskSpace, freeDiskSpace), ctx);
		 }
	 }
	 private final Recycler<AddCompletion> addCompletionRecycler = new Recycler<AddCompletion>() {
		 protected AddCompletion newObject(Recycler.Handle<AddCompletion> handle) {
			 return new AddCompletion(handle);
		 }
	 }
	;
	 AddCompletion acquireAddCompletion(final CompletionKey key, final WriteCallback originalCallback, final Object originalCtx, final long ledgerId, final long entryId) {
		 AddCompletion completion = addCompletionRecycler.get();
		 completion.reset(key, originalCallback, originalCtx, ledgerId, entryId);
		 return completion;
	 }
	 class AddCompletion extends CompletionValue implements WriteCallback {
		 final Recycler.Handle<AddCompletion> handle;
		 CompletionKey key = null;
		 WriteCallback originalCallback = null;
		 AddCompletion(Recycler.Handle<AddCompletion> handle) {
			 super(""Add"", null, -1, -1, addEntryOpLogger, addTimeoutOpLogger);
			 this.handle = handle;
		 }
		 void reset(final CompletionKey key, final WriteCallback originalCallback, final Object originalCtx, final long ledgerId, final long entryId) {
			 this.key = key;
			 this.originalCallback = originalCallback;
			 this.ctx = originalCtx;
			 this.ledgerId = ledgerId;
			 this.entryId = entryId;
			 this.startTime = MathUtils.nowInNano();
		 }
		 public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {
			 logOpResult(rc);
			 originalCallback.writeComplete(rc, ledgerId, entryId, addr, ctx);
			 key.release();
			 handle.recycle(this);
		 }
		 boolean maybeTimeout() {
			 if (MathUtils.elapsedNanos(startTime) >= addEntryTimeoutNanos) {
				 timeout();
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 public void errorOut() {
			 errorOut(BKException.Code.BookieHandleNotAvailableException);
		 }
		 public void errorOut(final int rc) {
			 errorOutAndRunCallback( () -> writeComplete(rc, ledgerId, entryId, addr, ctx));
		 }
		 public void setOutstanding() {
			 addEntryOutstanding.inc();
		 }
		 public void handleV2Response( long ledgerId, long entryId, StatusCode status, BookieProtocol.Response response) {
			 addEntryOutstanding.dec();
			 handleResponse(ledgerId, entryId, status);
		 }
		 public void handleV3Response( BookkeeperProtocol.Response response) {
			 addEntryOutstanding.dec();
			 AddResponse addResponse = response.getAddResponse();
			 StatusCode status = response.getStatus() == StatusCode.EOK ? addResponse.getStatus() : response.getStatus();
			 handleResponse(addResponse.getLedgerId(), addResponse.getEntryId(), status);
		 }
		 private void handleResponse(long ledgerId, long entryId, StatusCode status) {
			 if (LOG.isDebugEnabled()) {
				 logResponse(status, ""ledger"", ledgerId, ""entry"", entryId);
			 }
			 int rc = convertStatus(status, BKException.Code.WriteException);
			 writeComplete(rc, ledgerId, entryId, addr, ctx);
		 }
	 }
	 CompletionKey newCompletionKey(long txnId, OperationType operationType) {
		 return new V3CompletionKey(txnId, operationType);
	 }
	 class V3CompletionKey extends CompletionKey {
		 public V3CompletionKey(long txnId, OperationType operationType) {
			 super(txnId, operationType);
		 }
		 public boolean equals(Object obj) {
			 if (!(obj instanceof V3CompletionKey)) {
				 return false;
			 }
			 V3CompletionKey that = (V3CompletionKey) obj;
			 return this.txnId == that.txnId && this.operationType == that.operationType;
		 }
		 public int hashCode() {
			 return ((int) txnId);
		 }
		 public String toString() {
			 return String.format(""TxnId(%d), OperationType(%s)"", txnId, operationType);
		 }
	 }
	 abstract class CompletionKey {
		 final long txnId;
		 OperationType operationType;
		 CompletionKey(long txnId, OperationType operationType) {
			 this.txnId = txnId;
			 this.operationType = operationType;
		 }
		 public void release() {
		}
	 }
	 private int statusCodeToExceptionCode(StatusCode status) {
		 switch (status) {
			 case EOK: return BKException.Code.OK;
			 case ENOENTRY: return BKException.Code.NoSuchEntryException;
			 case ENOLEDGER: return BKException.Code.NoSuchLedgerExistsException;
			 case EBADVERSION: return BKException.Code.ProtocolVersionException;
			 case EUA: return BKException.Code.UnauthorizedAccessException;
			 case EFENCED: return BKException.Code.LedgerFencedException;
			 case EREADONLY: return BKException.Code.WriteOnReadOnlyBookieException;
			 case ETOOMANYREQUESTS: return BKException.Code.TooManyRequestsException;
			 default: return BKException.Code.UNINITIALIZED;
		 }
	 }
	 private void putCompletionKeyValue(CompletionKey key, CompletionValue value) {
		 CompletionValue existingValue = completionObjects.putIfAbsent(key, value);
		 if (existingValue != null) {
			 completionObjectsV2Conflicts.put(key, value);
		 }
	 }
	 private CompletionValue getCompletionValue(CompletionKey key) {
		 CompletionValue completionValue = completionObjects.remove(key);
		 if (completionValue == null) {
			 completionValue = completionObjectsV2Conflicts.removeAny(key).orElse(null);
		 }
		 return completionValue;
	 }
	 private long getTxnId() {
		 return txnIdGenerator.incrementAndGet();
	 }
	 private final Recycler<V2CompletionKey> v2KeyRecycler = new Recycler<V2CompletionKey>() {
		 protected V2CompletionKey newObject( Recycler.Handle<V2CompletionKey> handle) {
			 return new V2CompletionKey(handle);
		 }
	 }
	;
	 V2CompletionKey acquireV2Key(long ledgerId, long entryId, OperationType operationType) {
		 V2CompletionKey key = v2KeyRecycler.get();
		 key.reset(ledgerId, entryId, operationType);
		 return key;
	 }
	 private class V2CompletionKey extends CompletionKey {
		 private final Handle<V2CompletionKey> recyclerHandle;
		 long ledgerId;
		 long entryId;
		 private V2CompletionKey(Handle<V2CompletionKey> handle) {
			 super(-1, null);
			 this.recyclerHandle = handle;
		 }
		 void reset(long ledgerId, long entryId, OperationType operationType) {
			 this.ledgerId = ledgerId;
			 this.entryId = entryId;
			 this.operationType = operationType;
		 }
		 public boolean equals(Object object) {
			 if (!(object instanceof V2CompletionKey)) {
				 return false;
			 }
			 V2CompletionKey that = (V2CompletionKey) object;
			 return this.entryId == that.entryId && this.ledgerId == that.ledgerId && this.operationType == that.operationType;
		 }
		 public int hashCode() {
			 return Long.hashCode(ledgerId) * 31 + Long.hashCode(entryId);
		 }
		 public String toString() {
			 return String.format(""%d:%d %s"", ledgerId, entryId, operationType);
		 }
		 public void release() {
			 recyclerHandle.recycle(this);
		 }
	 }
	 Request.Builder withRequestContext(Request.Builder builder) {
		 if (preserveMdcForTaskExecution) {
			 return appendRequestContext(builder);
		 }
		 return builder;
	 }
	 static Request.Builder appendRequestContext(Request.Builder builder) {
		 final Map<String, String> mdcContextMap = MDC.getCopyOfContextMap();
		 if (mdcContextMap == null || mdcContextMap.isEmpty()) {
			 return builder;
		 }
		 for (Map.Entry<String, String> kv : mdcContextMap.entrySet()) {
			 final BookkeeperProtocol.ContextPair context = BookkeeperProtocol.ContextPair.newBuilder() .setKey(kv.getKey()) .setValue(kv.getValue()) .build();
			 builder.addRequestContext(context);
		 }
		 return builder;
	 }
	 ChannelFutureListener contextPreservingListener(ChannelFutureListener listener) {
		 return preserveMdcForTaskExecution ? new ContextPreservingFutureListener(listener) : listener;
	 }
	 static class ContextPreservingFutureListener implements ChannelFutureListener {
		 private final ChannelFutureListener listener;
		 private final Map<String, String> mdcContextMap;
		 ContextPreservingFutureListener(ChannelFutureListener listener) {
			 this.listener = listener;
			 this.mdcContextMap = MDC.getCopyOfContextMap();
		 }
		 public void operationComplete(ChannelFuture future) throws Exception {
			 MdcUtils.restoreContext(mdcContextMap);
			 try {
				 listener.operationComplete(future);
			 }
			 finally {
				 MDC.clear();
			 }
		 }
	 }
	 class ConnectionFutureListener implements ChannelFutureListener {
		 private final long startTime;
		 ConnectionFutureListener(long startTime) {
			 this.startTime = startTime;
		 }
		 public void operationComplete(ChannelFuture future) throws Exception {
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(""Channel connected ({
				}
				) {
				}
				"", future.isSuccess(), future.channel());
			 }
			 int rc;
			 Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;
			 if (future.isSuccess()) {
				 PerChannelBookieClient.this .connectTimer.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);
			 }
			 else {
				 PerChannelBookieClient.this .connectTimer.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);
			 }
			 synchronized (PerChannelBookieClient.this) {
				 if (future.isSuccess() && state == ConnectionState.CONNECTING && future.channel().isActive()) {
					 LOG.info(""Successfully connected to bookie: {
					}
					"", future.channel());
					 rc = BKException.Code.OK;
					 channel = future.channel();
					 if (shFactory != null) {
						 makeWritable();
						 initiateTLS();
						 return;
					 }
					 else {
						 LOG.info(""Successfully connected to bookie: "" + addr);
						 state = ConnectionState.CONNECTED;
						 activeNonTlsChannelCounter.inc();
					 }
				 }
				 else if (future.isSuccess() && state == ConnectionState.START_TLS) {
					 rc = BKException.Code.OK;
					 LOG.info(""Successfully connected to bookie using TLS: "" + addr);
					 state = ConnectionState.CONNECTED;
					 AuthHandler.ClientSideHandler authHandler = future.channel().pipeline() .get(AuthHandler.ClientSideHandler.class);
					 authHandler.authProvider.onProtocolUpgrade();
					 activeTlsChannelCounter.inc();
				 }
				 else if (future.isSuccess() && (state == ConnectionState.CLOSED || state == ConnectionState.DISCONNECTED)) {
					 LOG.warn(""Closed before connection completed, clean up: {
					}
					, current state {
					}
					"", future.channel(), state);
					 closeChannel(future.channel());
					 rc = BKException.Code.BookieHandleNotAvailableException;
					 channel = null;
				 }
				 else if (future.isSuccess() && state == ConnectionState.CONNECTED) {
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""Already connected with another channel({
						}
						), so close the new channel({
						}
						)"", channel, future.channel());
					 }
					 closeChannel(future.channel());
					 return;
				 }
				 else {
					 Throwable cause = future.cause();
					 if (cause instanceof UnknownHostException || cause instanceof NativeIoException) {
						 LOG.warn(""Could not connect to bookie: {
						}
						/{
						}
						, current state {
						}
						 : {
						}
						"", future.channel(), addr, state, future.cause().getMessage());
					 }
					 else {
						 LOG.error(""Could not connect to bookie: {
						}
						/{
						}
						, current state {
						}
						 : "", future.channel(), addr, state, future.cause());
					 }
					 rc = BKException.Code.BookieHandleNotAvailableException;
					 closeChannel(future.channel());
					 channel = null;
					 if (state != ConnectionState.CLOSED) {
						 state = ConnectionState.DISCONNECTED;
					 }
					 failedConnectionCounter.inc();
				 }
				 oldPendingOps = pendingOps;
				 pendingOps = new ArrayDeque<>();
			 }
			 for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {
				 pendingOp.operationComplete(rc, PerChannelBookieClient.this);
			 }
			 makeWritable();
		 }
	 }
	 private void initiateTLS() {
		 LOG.info(""Initializing TLS to {
		}
		"", channel);
		 assert state == ConnectionState.CONNECTING;
		 final long txnId = getTxnId();
		 final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.START_TLS);
		 completionObjects.put(completionKey, new StartTLSCompletion(completionKey));
		 BookkeeperProtocol.Request.Builder h = withRequestContext(BookkeeperProtocol.Request.newBuilder());
		 BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder() .setVersion(ProtocolVersion.VERSION_THREE) .setOperation(OperationType.START_TLS) .setTxnId(txnId);
		 h.setHeader(headerBuilder.build());
		 h.setStartTLSRequest(BookkeeperProtocol.StartTLSRequest.newBuilder().build());
		 state = ConnectionState.START_TLS;
		 writeAndFlush(channel, completionKey, h.build());
	 }
	 private void failTLS(int rc) {
		 LOG.error(""TLS failure on: {
		}
		, rc: {
		}
		"", channel, rc);
		 Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;
		 synchronized (this) {
			 disconnect();
			 oldPendingOps = pendingOps;
			 pendingOps = new ArrayDeque<>();
		 }
		 for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {
			 pendingOp.operationComplete(rc, null);
		 }
		 failedTlsHandshakeCounter.inc();
	 }
}",1,0,0,0
"public class VAJAntToolGUI extends Frame {
	private VAJBuildLogger logger = new VAJBuildLogger();
	private String lineSeparator = ""\r\n"";
	private PrivateEventHandler iEventHandler = new PrivateEventHandler();
	private VAJBuildInfo iBuildInfo = null;
	private MenuBar iAntMakeMenuBar = null;
	private Menu iFileMenu = null;
	private MenuItem iSaveMenuItem = null;
	private MenuItem iMenuSeparator = null;
	private MenuItem iShowLogMenuItem = null;
	private Menu iHelpMenu = null;
	private MenuItem iAboutMenuItem = null;
	private Panel iContentsPane = null;
	private Panel iOptionenPanel = null;
	private Panel iCommandButtonPanel = null;
	private FlowLayout iCommandButtonPanelFlowLayout = null;
	private Label iProjectLabel = null;
	private Label iProjectText = null;
	private Label iBuildFileLabel = null;
	private TextField iBuildFileTextField = null;
	private boolean iConnPtoP2Aligning = false;
	private Button iBrowseButton = null;
	private FileDialog iFileDialog = null;
	private Choice iMessageOutputLevelChoice = null;
	private Label iMessageOutputLevelLabel = null;
	private Label iTargetLabel = null;
	private List iTargetList = null;
	private Button iBuildButton = null;
	private Button iReloadButton = null;
	private Button iCloseButton = null;
	private Frame iMessageFrame = null;
	private Panel iMessageCommandPanel = null;
	private Panel iMessageContentPanel = null;
	private TextArea iMessageTextArea = null;
	private Button iMessageOkButton = null;
	private Button iMessageClearLogButton = null;
	private Dialog iAboutDialog = null;
	private Panel iAboutDialogContentPanel = null;
	private Panel iAboutInfoPanel = null;
	private Panel iAboutCommandPanel = null;
	private Label iAboutTitleLabel = null;
	private Label iAboutDevLabel = null;
	private Label iAboutContactLabel = null;
	private Button iAboutOkButton = null;
	private class VAJBuildLogger implements BuildListener {
		private long startTime = System.currentTimeMillis();
		public VAJBuildLogger() {
			super();
		}
		public void buildFinished(BuildEvent event) {
			Throwable error = event.getException();
			if (error == null) {
				getMessageTextArea().append(lineSeparator + ""BUILD SUCCESSFUL"");
			}
			else {
				getMessageTextArea().append(lineSeparator + ""BUILD FAILED"" + lineSeparator);
				if (error instanceof BuildException) {
					getMessageTextArea().append(error.toString());
					Throwable nested = ((BuildException)error).getException();
					if (nested != null) {
						nested.printStackTrace(System.err);
					}
				}
				else {
					error.printStackTrace(System.err);
				}
			}
			getMessageTextArea().append(lineSeparator + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
		}
		public void buildStarted(BuildEvent event) {
			startTime = System.currentTimeMillis();
			getMessageTextArea().append(lineSeparator);
		}
		public void messageLogged(BuildEvent event) {
			if (event.getPriority() <= getBuildInfo().getOutputMessageLevel()) {
				String msg = """";
				if (event.getTask() != null)msg = ""["" + event.getTask().getTaskName() + ""] "";
				getMessageTextArea().append(lineSeparator + msg + event.getMessage());
			}
		}
		public void targetFinished(BuildEvent event) {
		}
		public void targetStarted(BuildEvent event) {
			if (getBuildInfo().getOutputMessageLevel() <= Project.MSG_INFO) {
				getMessageTextArea().append(lineSeparator + event.getTarget().getName() + "":"");
			}
		}
		public void taskFinished(BuildEvent event) {
		}
		public void taskStarted(BuildEvent event) {
		}
		public void buildSuccessful() {
			getMessageTextArea().append(lineSeparator + ""BUILD SUCCESSFUL"");
			getMessageTextArea().append(lineSeparator + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
		}
		public void buildFailed(Throwable exc) {
			getMessageTextArea().append(lineSeparator + ""BUILD FAILED"" + lineSeparator);
			if (exc instanceof BuildException) {
				getMessageTextArea().append(exc.toString());
				Throwable nested = ((BuildException)exc).getException();
				if (nested != null) {
					nested.printStackTrace(System.err);
				}
			}
			else {
				exc.printStackTrace(System.err);
			}
			getMessageTextArea().append(lineSeparator + ""Total time: "" + formatTime(System.currentTimeMillis() - startTime));
		}
	}
	private class PrivateEventHandler implements ActionListener, ItemListener, TextListener, WindowListener, PropertyChangeListener {
		public void actionPerformed(ActionEvent e) {
			try {
				if (e.getSource() == VAJAntToolGUI.this.getBrowseButton()) {
					getFileDialog().setDirectory(getBuildFileTextField().getText().substring(0, getBuildFileTextField().getText().lastIndexOf('\\') + 1));
					getFileDialog().setFile(""*.xml"");
					getFileDialog().show();
					if (!getFileDialog().getFile().equals("""") ) {
						getBuildFileTextField().setText(getFileDialog().getDirectory() + getFileDialog().getFile());
					}
				}
				if (e.getSource() == VAJAntToolGUI.this.getCloseButton()) {
					dispose();
					System.exit(0);
				}
				if (e.getSource() == VAJAntToolGUI.this.getBuildButton()) executeTarget();
				if (e.getSource() == VAJAntToolGUI.this.getReloadButton()) {
					try {
						getBuildInfo().updateTargetList();
						fillList();
					}
					catch (Throwable fileNotFound) {
						handleException(fileNotFound);
						getTargetList().removeAll();
						getBuildButton().setEnabled(false);
					}
				}
				if (e.getSource() == VAJAntToolGUI.this.getSaveMenuItem()) saveBuildInfo();
				if (e.getSource() == VAJAntToolGUI.this.getAboutMenuItem()) getAboutDialog().show();
				if (e.getSource() == VAJAntToolGUI.this.getShowLogMenuItem()) getMessageFrame().show();
				if (e.getSource() == VAJAntToolGUI.this.getAboutOkButton()) getAboutDialog().dispose();
				if (e.getSource() == VAJAntToolGUI.this.getMessageOkButton())getMessageFrame().dispose();
				if (e.getSource() == VAJAntToolGUI.this.getMessageClearLogButton()) getMessageTextArea().setText("""");
				if (e.getSource() == VAJAntToolGUI.this.getMessageOkButton()) getMessageFrame().dispose();
			}
			catch (Throwable exc) {
				handleException(exc);
			}
		}
		public void itemStateChanged(ItemEvent e) {
			try {
				if (e.getSource() == VAJAntToolGUI.this.getTargetList()) getBuildButton().setEnabled(true);
				if (e.getSource() == VAJAntToolGUI.this.getMessageOutputLevelChoice()) getBuildInfo().setOutputMessageLevel(getMessageOutputLevelChoice().getSelectedIndex());
				if (e.getSource() == VAJAntToolGUI.this.getTargetList()) getBuildInfo().setTarget(getTargetList().getSelectedItem());
			}
			catch (Throwable exc) {
				handleException(exc);
			}
		}
		public void propertyChange(java.beans.PropertyChangeEvent evt) {
			if (evt.getSource() == VAJAntToolGUI.this.getBuildInfo() && (evt.getPropertyName().equals(""projectName""))) connectProjectNameToLabel();
			if (evt.getSource() == VAJAntToolGUI.this.getBuildInfo() && (evt.getPropertyName().equals(""buildFileName""))) connectBuildFileNameToTextField();
		}
		public void textValueChanged(TextEvent e) {
			if (e.getSource() == VAJAntToolGUI.this.getBuildFileTextField()) connectTextFieldToBuildFileName();
		}
		public void windowClosing(WindowEvent e) {
			try {
				if (e.getSource() == VAJAntToolGUI.this) {
					dispose();
					System.exit(0);
				}
				if (e.getSource() == VAJAntToolGUI.this.getAboutDialog()) getAboutDialog().dispose();
				if (e.getSource() == VAJAntToolGUI.this.getMessageFrame()) getMessageFrame().dispose();
			}
			catch (Throwable exc) {
				handleException(exc);
			}
		}
		public void windowActivated(WindowEvent e) {
		}
		;
		public void windowClosed(WindowEvent e) {
		}
		;
		public void windowDeactivated(WindowEvent e) {
		}
		;
		public void windowDeiconified(WindowEvent e) {
		}
		;
		public void windowIconified(WindowEvent e) {
		}
		;
		public void windowOpened(WindowEvent e) {
		}
		;
	}
	private VAJAntToolGUI() {
		super();
		initialize();
	}
	public VAJAntToolGUI(VAJBuildInfo newBuildInfo) {
		super();
		setBuildInfo(newBuildInfo);
		initialize();
	}
	public static void centerDialog(Dialog dialog) {
		dialog.setLocation((Toolkit.getDefaultToolkit().getScreenSize().width / 2) - (dialog.getSize().width / 2), (java.awt.Toolkit.getDefaultToolkit().getScreenSize().height / 2) - (dialog.getSize().height / 2));
	}
	private void connectBuildFileNameToTextField() {
		try {
			if (iConnPtoP2Aligning == false) {
				iConnPtoP2Aligning = true;
				if ((getBuildInfo() != null)) {
					getBuildFileTextField().setText(getBuildInfo().getBuildFileName());
				}
				iConnPtoP2Aligning = false;
			}
		}
		 catch (Throwable iExc) {
			iConnPtoP2Aligning = false;
			handleException(iExc);
		}
	}
	private void connectProjectNameToLabel() {
		try {
			if ((getBuildInfo() != null)) {
				getProjectText().setText(getBuildInfo().getVAJProjectName());
			}
		}
		 catch (Throwable iExc) {
			handleException(iExc);
		}
	}
	private void connectTextFieldToBuildFileName() {
		try {
			if (iConnPtoP2Aligning == false) {
				iConnPtoP2Aligning = true;
				if ((getBuildInfo() != null)) {
					getBuildInfo().setBuildFileName(getBuildFileTextField().getText());
				}
				iConnPtoP2Aligning = false;
			}
		}
		 catch (Throwable iExc) {
			iConnPtoP2Aligning = false;
			handleException(iExc);
		}
	}
	private void executeTarget() {
		try{
			getMessageFrame().show();
			logger.buildStarted(null);
			getBuildInfo().executeProject(logger);
			logger.buildSuccessful();
		}
		catch (Throwable exc) {
			logger.buildFailed( exc );
		}
		return;
	}
	private void fillList() {
		getTargetList().removeAll();
		Vector targets = getBuildInfo().getProjectTargets();
		for (int i = 0;
		i < targets.size();
		 i++) {
			getTargetList().add(targets.elementAt(i).toString());
		}
		getTargetList().select(iBuildInfo.getProjectTargets().indexOf(iBuildInfo.getTarget()));
		if (getTargetList().getSelectedIndex() >= 0) {
			getBuildButton().setEnabled(true);
		}
	}
	public static String formatTime(long millis) {
		long seconds = millis / 1000;
		long minutes = seconds / 60;
		if (minutes > 0) {
			return Long.toString(minutes) + "" minute""+ (minutes == 1 ? "" "" : ""s "")+ Long.toString(seconds%60) + "" second""+ (seconds%60 == 1 ? """" : ""s"");
		}
		else {
			return Long.toString(seconds) + "" second""+ (seconds%60 == 1 ? """" : ""s"");
		}
	}
	private Panel getAboutCommandPanel() {
		if (iAboutCommandPanel == null) {
			try {
				iAboutCommandPanel = new Panel();
				iAboutCommandPanel.setName(""AboutCommandPanel"");
				iAboutCommandPanel.setLayout(new java.awt.FlowLayout());
				getAboutCommandPanel().add(getAboutOkButton(), getAboutOkButton().getName());
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutCommandPanel;
	}
	private Label getAboutContactLabel() {
		if (iAboutContactLabel == null) {
			try {
				iAboutContactLabel = new Label();
				iAboutContactLabel.setName(""AboutContactLabel"");
				iAboutContactLabel.setAlignment(java.awt.Label.CENTER);
				iAboutContactLabel.setText(""contact: wolf.siberski or christoph.wilhelms"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutContactLabel;
	}
	private Label getAboutDevLabel() {
		if (iAboutDevLabel == null) {
			try {
				iAboutDevLabel = new Label();
				iAboutDevLabel.setName(""AboutDevLabel"");
				iAboutDevLabel.setAlignment(java.awt.Label.CENTER);
				iAboutDevLabel.setText(""developed by Wolf Siberski & Christoph Wilhelms"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutDevLabel;
	}
	private Dialog getAboutDialog() {
		if (iAboutDialog == null) {
			try {
				iAboutDialog = new Dialog(this);
				iAboutDialog.setName(""AboutDialog"");
				iAboutDialog.setResizable(false);
				iAboutDialog.setLayout(new java.awt.BorderLayout());
				iAboutDialog.setBounds(550, 14, 383, 142);
				iAboutDialog.setModal(true);
				iAboutDialog.setTitle(""About..."");
				getAboutDialog().add(getAboutDialogContentPanel(), ""Center"");
				iAboutDialog.pack();
				centerDialog(iAboutDialog);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutDialog;
	}
	private Panel getAboutDialogContentPanel() {
		if (iAboutDialogContentPanel == null) {
			try {
				iAboutDialogContentPanel = new Panel();
				iAboutDialogContentPanel.setName(""AboutDialogContentPanel"");
				iAboutDialogContentPanel.setLayout(new java.awt.BorderLayout());
				getAboutDialogContentPanel().add(getAboutCommandPanel(), ""South"");
				getAboutDialogContentPanel().add(getAboutInfoPanel(), ""Center"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutDialogContentPanel;
	}
	private Panel getAboutInfoPanel() {
		if (iAboutInfoPanel == null) {
			try {
				iAboutInfoPanel = new Panel();
				iAboutInfoPanel.setName(""AboutInfoPanel"");
				iAboutInfoPanel.setLayout(new GridBagLayout());
				GridBagConstraints constraintsAboutTitleLabel = new GridBagConstraints();
				constraintsAboutTitleLabel.gridx = 0;
				 constraintsAboutTitleLabel.gridy = 0;
				constraintsAboutTitleLabel.fill = GridBagConstraints.HORIZONTAL;
				constraintsAboutTitleLabel.weightx = 1.0;
				constraintsAboutTitleLabel.weighty = 1.0;
				constraintsAboutTitleLabel.insets = new Insets(4, 0, 4, 0);
				getAboutInfoPanel().add(getAboutTitleLabel(), constraintsAboutTitleLabel);
				GridBagConstraints constraintsAboutDevLabel = new GridBagConstraints();
				constraintsAboutDevLabel.gridx = 0;
				 constraintsAboutDevLabel.gridy = 1;
				constraintsAboutDevLabel.fill = GridBagConstraints.HORIZONTAL;
				constraintsAboutDevLabel.weightx = 1.0;
				constraintsAboutDevLabel.insets = new Insets(4, 0, 0, 0);
				getAboutInfoPanel().add(getAboutDevLabel(), constraintsAboutDevLabel);
				GridBagConstraints constraintsAboutContactLabel = new GridBagConstraints();
				constraintsAboutContactLabel.gridx = 0;
				 constraintsAboutContactLabel.gridy = 2;
				constraintsAboutContactLabel.fill = GridBagConstraints.HORIZONTAL;
				constraintsAboutContactLabel.weightx = 1.0;
				constraintsAboutContactLabel.insets = new Insets(2, 0, 4, 0);
				getAboutInfoPanel().add(getAboutContactLabel(), constraintsAboutContactLabel);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutInfoPanel;
	}
	private MenuItem getAboutMenuItem() {
		if (iAboutMenuItem == null) {
			try {
				iAboutMenuItem = new MenuItem();
				iAboutMenuItem.setLabel(""About..."");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutMenuItem;
	}
	private Button getAboutOkButton() {
		if (iAboutOkButton == null) {
			try {
				iAboutOkButton = new Button();
				iAboutOkButton.setName(""AboutOkButton"");
				iAboutOkButton.setLabel(""OK"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutOkButton;
	}
	private Label getAboutTitleLabel() {
		if (iAboutTitleLabel == null) {
			try {
				iAboutTitleLabel = new Label();
				iAboutTitleLabel.setName(""AboutTitleLabel"");
				iAboutTitleLabel.setFont(new Font(""Arial"", 1, 12));
				iAboutTitleLabel.setAlignment(Label.CENTER);
				iAboutTitleLabel.setText(""Ant VisualAge for Java Tool-Integration"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAboutTitleLabel;
	}
	private MenuBar getAntMakeMenuBar() {
		if (iAntMakeMenuBar == null) {
			try {
				iAntMakeMenuBar = new MenuBar();
				iAntMakeMenuBar.add(getFileMenu());
				iAntMakeMenuBar.add(getHelpMenu());
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iAntMakeMenuBar;
	}
	private Button getBrowseButton() {
		if (iBrowseButton == null) {
			try {
				iBrowseButton = new Button();
				iBrowseButton.setName(""BrowseButton"");
				iBrowseButton.setLabel(""..."");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBrowseButton;
	}
	private Button getBuildButton() {
		if (iBuildButton == null) {
			try {
				iBuildButton = new Button();
				iBuildButton.setName(""BuildButton"");
				iBuildButton.setLabel(""Build"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBuildButton;
	}
	private Label getBuildFileLabel() {
		if (iBuildFileLabel == null) {
			try {
				iBuildFileLabel = new Label();
				iBuildFileLabel.setName(""BuildFileLabel"");
				iBuildFileLabel.setText(""Ant-Buildfile:"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBuildFileLabel;
	}
	private TextField getBuildFileTextField() {
		if (iBuildFileTextField == null) {
			try {
				iBuildFileTextField = new TextField();
				iBuildFileTextField.setName(""BuildFileTextField"");
				iBuildFileTextField.setBackground(SystemColor.textHighlightText);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iBuildFileTextField;
	}
	private VAJBuildInfo getBuildInfo() {
		return iBuildInfo;
	}
	private Button getCloseButton() {
		if (iCloseButton == null) {
			try {
				iCloseButton = new Button();
				iCloseButton.setName(""CloseButton"");
				iCloseButton.setLabel(""Close"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iCloseButton;
	}
	private Panel getCommandButtonPanel() {
		if (iCommandButtonPanel == null) {
			try {
				iCommandButtonPanel = new Panel();
				iCommandButtonPanel.setName(""CommandButtonPanel"");
				iCommandButtonPanel.setLayout(getCommandButtonPanelFlowLayout());
				iCommandButtonPanel.setBackground(SystemColor.control);
				iCommandButtonPanel.add(getReloadButton());
				getCommandButtonPanel().add(getBuildButton(), getBuildButton().getName());
				getCommandButtonPanel().add(getCloseButton(), getCloseButton().getName());
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iCommandButtonPanel;
	}
	private FlowLayout getCommandButtonPanelFlowLayout() {
		FlowLayout iCommandButtonPanelFlowLayout = null;
		try {
			iCommandButtonPanelFlowLayout = new FlowLayout();
			iCommandButtonPanelFlowLayout.setAlignment(FlowLayout.RIGHT);
		}
		 catch (Throwable iExc) {
			handleException(iExc);
		}
		;
		return iCommandButtonPanelFlowLayout;
	}
	private Panel getContentsPane() {
		if (iContentsPane == null) {
			try {
				iContentsPane = new Panel();
				iContentsPane.setName(""ContentsPane"");
				iContentsPane.setLayout(new BorderLayout());
				getContentsPane().add(getCommandButtonPanel(), ""South"");
				getContentsPane().add(getOptionenPanel(), ""Center"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iContentsPane;
	}
	private FileDialog getFileDialog() {
		if (iFileDialog == null) {
			try {
				iFileDialog = new FileDialog(this);
				iFileDialog.setName(""FileDialog"");
				iFileDialog.setLayout(null);
				centerDialog(iFileDialog);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iFileDialog;
	}
	private Menu getFileMenu() {
		if (iFileMenu == null) {
			try {
				iFileMenu = new Menu();
				iFileMenu.setLabel(""File"");
				iFileMenu.add(getSaveMenuItem());
				iFileMenu.add(getMenuSeparator());
				iFileMenu.add(getShowLogMenuItem());
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iFileMenu;
	}
	private Menu getHelpMenu() {
		if (iHelpMenu == null) {
			try {
				iHelpMenu = new Menu();
				iHelpMenu.setLabel(""Help"");
				iHelpMenu.add(getAboutMenuItem());
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iHelpMenu;
	}
	private MenuItem getMenuSeparator() {
		if (iMenuSeparator == null) {
			try {
				iMenuSeparator = new MenuItem();
				iMenuSeparator.setLabel(""-"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMenuSeparator;
	}
	private Button getMessageClearLogButton() {
		if (iMessageClearLogButton == null) {
			try {
				iMessageClearLogButton = new Button();
				iMessageClearLogButton.setName(""MessageClearLogButton"");
				iMessageClearLogButton.setLabel(""Clear Log"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageClearLogButton;
	}
	private Panel getMessageCommandPanel() {
		if (iMessageCommandPanel == null) {
			try {
				iMessageCommandPanel = new Panel();
				iMessageCommandPanel.setName(""MessageCommandPanel"");
				iMessageCommandPanel.setLayout(new FlowLayout());
				getMessageCommandPanel().add(getMessageClearLogButton(), getMessageClearLogButton().getName());
				getMessageCommandPanel().add(getMessageOkButton(), getMessageOkButton().getName());
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageCommandPanel;
	}
	private Panel getMessageContentPanel() {
		if (iMessageContentPanel == null) {
			try {
				iMessageContentPanel = new Panel();
				iMessageContentPanel.setName(""MessageContentPanel"");
				iMessageContentPanel.setLayout(new BorderLayout());
				iMessageContentPanel.setBackground(SystemColor.control);
				getMessageContentPanel().add(getMessageTextArea(), ""Center"");
				getMessageContentPanel().add(getMessageCommandPanel(), ""South"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageContentPanel;
	}
	private Frame getMessageFrame() {
		if (iMessageFrame == null) {
			try {
				iMessageFrame = new Frame();
				iMessageFrame.setName(""MessageFrame"");
				iMessageFrame.setLayout(new BorderLayout());
				iMessageFrame.setBounds(0, 0, 750, 250);
				iMessageFrame.setTitle(""Message Log"");
				iMessageFrame.add(getMessageContentPanel(), ""Center"");
				iMessageFrame.setLocation((Toolkit.getDefaultToolkit().getScreenSize().width / 2) - (iMessageFrame.getSize().width / 2), (java.awt.Toolkit.getDefaultToolkit().getScreenSize().height / 2));
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageFrame;
	}
	private Button getMessageOkButton() {
		if (iMessageOkButton == null) {
			try {
				iMessageOkButton = new Button();
				iMessageOkButton.setName(""MessageOkButton"");
				iMessageOkButton.setLabel(""Close"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageOkButton;
	}
	private Choice getMessageOutputLevelChoice() {
		if (iMessageOutputLevelChoice == null) {
			try {
				iMessageOutputLevelChoice = new Choice();
				iMessageOutputLevelChoice.setName(""MessageOutputLevelChoice"");
				iMessageOutputLevelChoice.add(""Error"");
				iMessageOutputLevelChoice.add(""Warning"");
				iMessageOutputLevelChoice.add(""Info"");
				iMessageOutputLevelChoice.add(""Verbose"");
				iMessageOutputLevelChoice.add(""Debug"");
				iMessageOutputLevelChoice.select(2);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageOutputLevelChoice;
	}
	private Label getMessageOutputLevelLabel() {
		if (iMessageOutputLevelLabel == null) {
			try {
				iMessageOutputLevelLabel = new Label();
				iMessageOutputLevelLabel.setName(""MessageOutputLevelLabel"");
				iMessageOutputLevelLabel.setText(""Message Level:"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageOutputLevelLabel;
	}
	private TextArea getMessageTextArea() {
		if (iMessageTextArea == null) {
			try {
				iMessageTextArea = new TextArea();
				iMessageTextArea.setName(""MessageTextArea"");
				iMessageTextArea.setFont(new Font(""monospaced"", 0, 12));
				iMessageTextArea.setText("""");
				iMessageTextArea.setEditable(false);
				iMessageTextArea.setEnabled(true);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iMessageTextArea;
	}
	private Panel getOptionenPanel() {
		if (iOptionenPanel == null) {
			try {
				iOptionenPanel = new Panel();
				iOptionenPanel.setName(""OptionenPanel"");
				iOptionenPanel.setLayout(new GridBagLayout());
				iOptionenPanel.setBackground(SystemColor.control);
				GridBagConstraints constraintsProjectLabel = new GridBagConstraints();
				constraintsProjectLabel.gridx = 0;
				 constraintsProjectLabel.gridy = 0;
				constraintsProjectLabel.anchor = GridBagConstraints.WEST;
				constraintsProjectLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getProjectLabel(), constraintsProjectLabel);
				GridBagConstraints constraintsBuildFileLabel = new GridBagConstraints();
				constraintsBuildFileLabel.gridx = 0;
				 constraintsBuildFileLabel.gridy = 1;
				constraintsBuildFileLabel.anchor = GridBagConstraints.WEST;
				constraintsBuildFileLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getBuildFileLabel(), constraintsBuildFileLabel);
				GridBagConstraints constraintsTargetLabel = new GridBagConstraints();
				constraintsTargetLabel.gridx = 0;
				 constraintsTargetLabel.gridy = 2;
				constraintsTargetLabel.anchor = GridBagConstraints.NORTHWEST;
				constraintsTargetLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getTargetLabel(), constraintsTargetLabel);
				GridBagConstraints constraintsProjectText = new GridBagConstraints();
				constraintsProjectText.gridx = 1;
				 constraintsProjectText.gridy = 0;
				constraintsProjectText.gridwidth = 2;
				constraintsProjectText.fill = GridBagConstraints.HORIZONTAL;
				constraintsProjectText.anchor = GridBagConstraints.WEST;
				constraintsProjectText.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getProjectText(), constraintsProjectText);
				GridBagConstraints constraintsBuildFileTextField = new GridBagConstraints();
				constraintsBuildFileTextField.gridx = 1;
				 constraintsBuildFileTextField.gridy = 1;
				constraintsBuildFileTextField.fill = GridBagConstraints.HORIZONTAL;
				constraintsBuildFileTextField.anchor = GridBagConstraints.WEST;
				constraintsBuildFileTextField.weightx = 1.0;
				constraintsBuildFileTextField.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getBuildFileTextField(), constraintsBuildFileTextField);
				GridBagConstraints constraintsBrowseButton = new GridBagConstraints();
				constraintsBrowseButton.gridx = 2;
				 constraintsBrowseButton.gridy = 1;
				constraintsBrowseButton.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getBrowseButton(), constraintsBrowseButton);
				GridBagConstraints constraintsTargetList = new GridBagConstraints();
				constraintsTargetList.gridx = 1;
				 constraintsTargetList.gridy = 2;
				constraintsTargetList.gridheight = 2;
				constraintsTargetList.fill = GridBagConstraints.BOTH;
				constraintsTargetList.weightx = 1.0;
				constraintsTargetList.weighty = 1.0;
				constraintsTargetList.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getTargetList(), constraintsTargetList);
				GridBagConstraints constraintsMessageOutputLevelLabel = new GridBagConstraints();
				constraintsMessageOutputLevelLabel.gridx = 0;
				 constraintsMessageOutputLevelLabel.gridy = 4;
				constraintsMessageOutputLevelLabel.anchor = GridBagConstraints.WEST;
				constraintsMessageOutputLevelLabel.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getMessageOutputLevelLabel(), constraintsMessageOutputLevelLabel);
				GridBagConstraints constraintsMessageOutputLevelChoice = new GridBagConstraints();
				constraintsMessageOutputLevelChoice.gridx = 1;
				 constraintsMessageOutputLevelChoice.gridy = 4;
				constraintsMessageOutputLevelChoice.fill = GridBagConstraints.HORIZONTAL;
				constraintsMessageOutputLevelChoice.anchor = GridBagConstraints.WEST;
				constraintsMessageOutputLevelChoice.weightx = 1.0;
				constraintsMessageOutputLevelChoice.insets = new Insets(4, 4, 4, 4);
				getOptionenPanel().add(getMessageOutputLevelChoice(), constraintsMessageOutputLevelChoice);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iOptionenPanel;
	}
	private Label getProjectLabel() {
		if (iProjectLabel == null) {
			try {
				iProjectLabel = new Label();
				iProjectLabel.setName(""ProjectLabel"");
				iProjectLabel.setText(""Projectname:"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iProjectLabel;
	}
	private Label getProjectText() {
		if (iProjectText == null) {
			try {
				iProjectText = new Label();
				iProjectText.setName(""ProjectText"");
				iProjectText.setText("" "");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iProjectText;
	}
	private Button getReloadButton() {
		if (iReloadButton == null) {
			try {
				iReloadButton = new Button();
				iReloadButton.setName(""ReloadButton"");
				iReloadButton.setLabel(""(Re)Load"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iReloadButton;
	}
	private MenuItem getSaveMenuItem() {
		if (iSaveMenuItem == null) {
			try {
				iSaveMenuItem = new MenuItem();
				iSaveMenuItem.setLabel(""Save BuildInfo To Repository"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iSaveMenuItem;
	}
	private MenuItem getShowLogMenuItem() {
		if (iShowLogMenuItem == null) {
			try {
				iShowLogMenuItem = new MenuItem();
				iShowLogMenuItem.setLabel(""Log"");
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iShowLogMenuItem;
	}
	private Label getTargetLabel() {
		if (iTargetLabel == null) {
			try {
				iTargetLabel = new Label();
				iTargetLabel.setName(""TargetLabel"");
				iTargetLabel.setText(""Target:"");
				iTargetLabel.setEnabled(true);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iTargetLabel;
	}
	private List getTargetList() {
		if (iTargetList == null) {
			try {
				iTargetList = new List();
				iTargetList.setName(""TargetList"");
				iTargetList.setEnabled(true);
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
		return iTargetList;
	}
	private void handleException(Throwable exception) {
		getMessageTextArea().append(lineSeparator + lineSeparator + exception.getMessage());
		getMessageFrame().show();
	}
	private void initConnections() throws Exception {
		this.addWindowListener(iEventHandler);
		getBrowseButton().addActionListener(iEventHandler);
		getCloseButton().addActionListener(iEventHandler);
		getBuildButton().addActionListener(iEventHandler);
		getSaveMenuItem().addActionListener(iEventHandler);
		getAboutOkButton().addActionListener(iEventHandler);
		getAboutMenuItem().addActionListener(iEventHandler);
		getMessageOkButton().addActionListener(iEventHandler);
		getMessageClearLogButton().addActionListener(iEventHandler);
		getMessageOkButton().addActionListener(iEventHandler);
		getShowLogMenuItem().addActionListener(iEventHandler);
		getAboutDialog().addWindowListener(iEventHandler);
		getMessageFrame().addWindowListener(iEventHandler);
		getReloadButton().addActionListener(iEventHandler);
		getTargetList().addItemListener(iEventHandler);
		getMessageOutputLevelChoice().addItemListener(iEventHandler);
		getBuildFileTextField().addTextListener(iEventHandler);
		connectProjectNameToLabel();
		connectBuildFileNameToTextField();
	}
	private void initialize() {
		try {
			setName(""AntMake"");
			setMenuBar(getAntMakeMenuBar());
			setLayout(new java.awt.BorderLayout());
			setSize(389, 222);
			setTitle(""Ant VisualAge for Java Tool-Integration"");
			add(getContentsPane(), ""Center"");
			initConnections();
		}
		 catch (Throwable iExc) {
			handleException(iExc);
		}
		setLocation((Toolkit.getDefaultToolkit().getScreenSize().width / 2) - (getSize().width / 2), (java.awt.Toolkit.getDefaultToolkit().getScreenSize().height / 2) - (getSize().height));
		if ((getTargetList().getItemCount() == 0) || (getTargetList().getSelectedIndex() < 0)) {
			getBuildButton().setEnabled(false);
		}
	}
	private void saveBuildInfo() {
		try {
			VAJAntTool.saveBuildData(getBuildInfo());
		}
		catch (Throwable exc) {
			handleException( exc );
		}
		return;
	}
	private void setBuildInfo(VAJBuildInfo newValue) {
		if (iBuildInfo != newValue) {
			try {
				if (iBuildInfo != null) {
					iBuildInfo.removePropertyChangeListener(iEventHandler);
				}
				iBuildInfo = newValue;
				if (iBuildInfo != null) {
					iBuildInfo.addPropertyChangeListener(iEventHandler);
				}
				connectProjectNameToLabel();
				connectBuildFileNameToTextField();
				getMessageOutputLevelChoice().select(iBuildInfo.getOutputMessageLevel());
				fillList();
				if ((iBuildInfo.getVAJProjectName() == null) || (iBuildInfo.getVAJProjectName().equals(""""))) {
					getSaveMenuItem().setEnabled(false);
				}
			}
			 catch (Throwable iExc) {
				handleException(iExc);
			}
		}
	}
}",1,0,0,0
"public static int getRpcPort() {
	 return conf.rpc_port;
 }",0,0,0,0
"public class MemoryUsage {
	 public static long sizeOf(Creator c) {
		 long size= 0;
		 Object[] objects = new Object[100];
		 try {
			 Object primer = c.create();
			 long startingMemoryUse = getUsedMemory();
			 for (int i = 0;
			 i < objects.length;
			 i++) {
				 objects[i] = c.create();
			 }
			 long endingMemoryUse = getUsedMemory();
			 float approxSize = (endingMemoryUse - startingMemoryUse) / 100f;
			 size = Math.round(approxSize);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
		 return size;
	 }
	 private static long getUsedMemory() {
		 gc();
		 long totalMemory = Runtime.getRuntime().totalMemory();
		 gc();
		 long freeMemory = Runtime.getRuntime().freeMemory();
		 long usedMemory = totalMemory - freeMemory;
		 return usedMemory;
	 }
	 private static void gc() {
		 try {
			 System.gc();
			 Thread.currentThread().sleep(100);
			 System.runFinalization();
			 Thread.currentThread().sleep(100);
			 System.gc();
			 Thread.currentThread().sleep(100);
			 System.runFinalization();
			 Thread.currentThread().sleep(100);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 public static void main(String[] args) {
		 try {
			 MemoryComparator set = new MemoryComparator(new TroveSetCreator(), new JavasoftSetCreator(), ""Compare size of Set implementation: 1,000 Integer objects measured in bytes"");
			 set.compare();
			 set = null;
			 MemoryComparator list = new MemoryComparator(new TroveListCreator(), new JavasoftListCreator(), ""Compare size of LinkedList implementation: 1,000 TLinkableAdaptor objects measured in bytes"");
			 list.compare();
			 list = null;
			 MemoryComparator list2 = new MemoryComparator(new TroveIntArrayListCreator(), new JavasoftIntegerArrayListCreator(), ""Compare size of int/IntegerArrayList implementation: 1,000 ints measured in bytes"");
			 list2.compare();
			 list2 = null;
			 MemoryComparator map = new MemoryComparator(new TroveMapCreator(), new JavasoftMapCreator(), ""Compare size of Map implementation: 1,000 Integer->Integer mappings measured in bytes"");
			 map.compare();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
		 System.exit(0);
	 }
	 static class MemoryComparator {
		 Creator trove, javasoft;
		 String description;
		 MemoryComparator(Creator trove, Creator javasoft, String description) {
			 this.trove = trove;
			 this.javasoft = javasoft;
			 this.description = description;
		 }
		 public void compare() {
			 gc();
			 long j = sizeOf(javasoft);
			 gc();
			 long t = sizeOf(trove);
			 long p = Math.round(t * 100 / j * 100) / 100;
			 System.out.println(""--------------------------"");
			 System.out.println(description);
			 System.out.println(""javasoft: "" + j);
			 System.out.println(""trove: "" + t);
			 System.out.println(""trove's collection requires "" + p + ""% of the memory needed by javasoft's collection"");
		 }
	 }
	 interface Creator {
		 Object create();
	 }
	 static class TroveIntArrayListCreator implements Creator {
		 public Object create() {
			 TIntArrayList list = new TIntArrayList();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 list.add(i);
			 }
			 list.trimToSize();
			 return list;
		 }
	 }
	 static class JavasoftIntegerArrayListCreator implements Creator {
		 public Object create() {
			 ArrayList list = new ArrayList();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 Integer x = new Integer(i);
				 list.add(x);
			 }
			 list.trimToSize();
			 return list;
		 }
	 }
	 static class TroveMapCreator implements Creator {
		 public Object create() {
			 THashMap map = new THashMap();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 Integer x = new Integer(i);
				 map.put(x,x);
			 }
			 return map;
		 }
	 }
	 static class JavasoftMapCreator implements Creator {
		 public Object create() {
			 HashMap map = new HashMap();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 Integer x = new Integer(i);
				 map.put(x,x);
			 }
			 return map;
		 }
	 }
	 static class TroveSetCreator implements Creator {
		 public Object create() {
			 THashSet map = new THashSet();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 Integer x = new Integer(i);
				 map.add(x);
			 }
			 return map;
		 }
	 }
	 static class JavasoftSetCreator implements Creator {
		 public Object create() {
			 HashSet map = new HashSet();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 Integer x = new Integer(i);
				 map.add(x);
			 }
			 return map;
		 }
	 }
	 static class TroveListCreator implements Creator {
		 public Object create() {
			 TLinkedList list = new TLinkedList();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 TLinkableAdapter a = new TLinkableAdapter();
				 list.add(a);
			 }
			 return list;
		 }
	 }
	 static class JavasoftListCreator implements Creator {
		 public Object create() {
			 LinkedList list = new LinkedList();
			 for (int i = 0;
			 i < 1000;
			 i++) {
				 TLinkableAdapter a = new TLinkableAdapter();
				 list.add(a);
			 }
			 return list;
		 }
	 }
}",0,0,0,0
"public interface WrapperExecuteCallback {
	 void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException;
}",0,0,0,0
"public void run() {
	 try {
		 FileUtil.fullyDelete(workDir);
	 }
	 catch (IOException e) {
	 }
 }",0,0,0,0
"public class LongWritable implements WritableComparable {
	 private long value;
	 public LongWritable() {
	}
	 public LongWritable(long value) {
		 set(value);
	 }
	 public void set(long value) {
		 this.value = value;
	 }
	 public long get() {
		 return value;
	 }
	 public void readFields(DataInput in) throws IOException {
		 value = in.readLong();
	 }
	 public void write(DataOutput out) throws IOException {
		 out.writeLong(value);
	 }
	 public boolean equals(Object o) {
		 if (!(o instanceof LongWritable)) return false;
		 LongWritable other = (LongWritable)o;
		 return this.value == other.value;
	 }
	 public int hashCode() {
		 return (int)value;
	 }
	 public int compareTo(Object o) {
		 long thisValue = this.value;
		 long thatValue = ((LongWritable)o).value;
		 return (thisValue<thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
	 }
	 public String toString() {
		 return Long.toString(value);
	 }
	 public static class Comparator extends WritableComparator {
		 public Comparator() {
			 super(LongWritable.class);
		 }
		 public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
			 long thisValue = readLong(b1, s1);
			 long thatValue = readLong(b2, s2);
			 return (thisValue<thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
		 }
	 }
	 public static class DecreasingComparator extends Comparator {
		 public int compare(WritableComparable a, WritableComparable b) {
			 return -super.compare(a, b);
		 }
		 public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
			 return -super.compare(b1, s1, l1, b2, s2, l2);
		 }
	 }
	 static {
		 WritableComparator.define(LongWritable.class, new Comparator());
	 }
}",0,0,0,0
"public static class UserToken implements HttpAuthToken {
	 private String token;
	 public UserToken(String token) {
		 this.token = token;
	 }
	 public String getValue() {
		 return token;
	 }
	 public String getAuthorizationHeader(URL requestUrl, String requestMethod) {
		 return ""GoogleLogin auth="" + token;
	 }
 }",0,0,0,0
"public void moveFromLocalFile(Path src, Path dst) throws IOException {
	 rename(src, dst);
 }",0,0,0,0
"public interface Channel extends ChannelListenerManager, PropertyResolver, AttributeStore, PacketWriter, ChannelStreamPacketWriterResolverManager, Closeable {
	 String CHANNEL_EXEC = ""exec"";
	 String CHANNEL_SHELL = ""shell"";
	 String CHANNEL_SUBSYSTEM = ""subsystem"";
	 int getId();
	 int getRecipient();
	 Session getSession();
	 Window getLocalWindow();
	 Window getRemoteWindow();
	 List<RequestHandler<Channel>> getRequestHandlers();
	 void addRequestHandler(RequestHandler<Channel> handler);
	 default void addRequestHandlers(Collection<? extends RequestHandler<Channel>> handlers) {
		 GenericUtils.forEach(handlers, this::addRequestHandler);
	 }
	 void removeRequestHandler(RequestHandler<Channel> handler);
	 default void removeRequestHandlers(Collection<? extends RequestHandler<Channel>> handlers) {
		 GenericUtils.forEach(handlers, this::removeRequestHandler);
	 }
	 void handleClose() throws IOException;
	 void handleWindowAdjust(Buffer buffer) throws IOException;
	 void handleRequest(Buffer buffer) throws IOException;
	 void handleData(Buffer buffer) throws IOException;
	 void handleExtendedData(Buffer buffer) throws IOException;
	 void handleEof() throws IOException;
	 void handleSuccess() throws IOException;
	 void handleFailure() throws IOException;
	 void init(ConnectionService service, Session session, int id) throws IOException;
	 boolean isInitialized();
	 boolean isEofSignalled();
	 OpenFuture open(int recipient, long rwSize, long packetSize, Buffer buffer);
	 void handleOpenSuccess(int recipient, long rwSize, long packetSize, Buffer buffer) throws IOException;
	 void handleOpenFailure(Buffer buffer) throws IOException;
	 default <T> T resolveAttribute(AttributeRepository.AttributeKey<T> key) {
		 return resolveAttribute(this, key);
	 }
	 static <T> T resolveAttribute(Channel channel, AttributeRepository.AttributeKey<T> key) {
		 Objects.requireNonNull(key, ""No key"");
		 if (channel == null) {
			 return null;
		 }
		 T value = channel.getAttribute(key);
		 return (value != null) ? value : Session.resolveAttribute(channel.getSession(), key);
	 }
}",1,0,0,0
"public abstract class ImageSource{
	protected int height;
	protected int width;
	public ImageSource( int width, int height ){
		this.width = width;
		this.height = height;
	}
	public int getHeight( ){
		return height;
	}
	public int getWidth( ){
		return width;
	}
	public abstract int getRGB( int x, int y );
}",0,1,0,0
public void setValue(String value);,0,0,0,0
"public boolean getInError() {
	 return inError;
 }",0,0,0,0
"private static class BuildBinsUDAFEvaluator extends GenericUDAFEvaluator {
	 private PrimitiveObjectInspector weightOI;
	 private StructObjectInspector structOI;
	 private StructField autoShrinkField, histogramField, quantilesField;
	 private BooleanObjectInspector autoShrinkOI;
	 private StandardListObjectInspector histogramOI;
	 private DoubleObjectInspector histogramElOI;
	 private StandardListObjectInspector quantilesOI;
	 private DoubleObjectInspector quantileOI;
	 private int nBGBins = 10000;
	 private int nBins;
	 private boolean autoShrink = false;
	 private double[] quantiles;
	 static final class BuildBinsAggregationBuffer extends AbstractAggregationBuffer {
		 boolean autoShrink;
		 NumericHistogram histogram;
		 double[] quantiles;
		 BuildBinsAggregationBuffer() {
		}
		 public int estimate() {
			 return (histogram != null ? histogram.lengthFor() : 0) + 20 + 8 * (quantiles != null ? quantiles.length : 0) + 4;
		 }
	 }
	 public ObjectInspector init(Mode mode, ObjectInspector[] OIs) throws HiveException {
		 super.init(mode, OIs);
		 if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {
			 weightOI = HiveUtils.asDoubleCompatibleOI(OIs[0]);
			 nBins = HiveUtils.getConstInt(OIs[1]);
			 if (OIs.length == 3) {
				 autoShrink = HiveUtils.getConstBoolean(OIs[2]);
			 }
			 if (nBins < 2) {
				 throw new UDFArgumentException( ""Only greater than or equal to 2 is accepted but "" + nBins + "" was passed as `num_of_bins`."");
			 }
			 quantiles = getQuantiles();
		 }
		 else {
			 structOI = (StructObjectInspector) OIs[0];
			 autoShrinkField = structOI.getStructFieldRef(""autoShrink"");
			 histogramField = structOI.getStructFieldRef(""histogram"");
			 quantilesField = structOI.getStructFieldRef(""quantiles"");
			 autoShrinkOI = (WritableBooleanObjectInspector) autoShrinkField.getFieldObjectInspector();
			 histogramOI = (StandardListObjectInspector) histogramField.getFieldObjectInspector();
			 quantilesOI = (StandardListObjectInspector) quantilesField.getFieldObjectInspector();
			 histogramElOI = (WritableDoubleObjectInspector) histogramOI.getListElementObjectInspector();
			 quantileOI = (WritableDoubleObjectInspector) quantilesOI.getListElementObjectInspector();
		 }
		 if (mode == Mode.PARTIAL1 || mode == Mode.PARTIAL2) {
			 final ArrayList<ObjectInspector> fieldOIs = new ArrayList<ObjectInspector>();
			 fieldOIs.add(PrimitiveObjectInspectorFactory.writableBooleanObjectInspector);
			 fieldOIs.add(ObjectInspectorFactory.getStandardListObjectInspector( PrimitiveObjectInspectorFactory.writableDoubleObjectInspector));
			 fieldOIs.add(ObjectInspectorFactory.getStandardListObjectInspector( PrimitiveObjectInspectorFactory.writableDoubleObjectInspector));
			 return ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList(""autoShrink"", ""histogram"", ""quantiles""), fieldOIs);
		 }
		 else {
			 return ObjectInspectorFactory.getStandardListObjectInspector( PrimitiveObjectInspectorFactory.writableDoubleObjectInspector);
		 }
	 }
	 private double[] getQuantiles() throws HiveException {
		 final int nQuantiles = nBins - 1;
		 final double[] result = new double[nQuantiles];
		 for (int i = 0;
		 i < nQuantiles;
		 i++) {
			 result[i] = ((double) (i + 1)) / (nQuantiles + 1);
		 }
		 return result;
	 }
	 public AbstractAggregationBuffer getNewAggregationBuffer() throws HiveException {
		 final BuildBinsAggregationBuffer myAgg = new BuildBinsAggregationBuffer();
		 myAgg.histogram = new NumericHistogram();
		 reset(myAgg);
		 return myAgg;
	 }
	 public void reset( AggregationBuffer agg) throws HiveException {
		 final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;
		 myAgg.autoShrink = autoShrink;
		 myAgg.histogram.reset();
		 myAgg.histogram.allocate(nBGBins);
		 myAgg.quantiles = quantiles;
	 }
	 public void iterate( AggregationBuffer agg, Object[] parameters) throws HiveException {
		 Preconditions.checkArgument(parameters.length == 2 || parameters.length == 3);
		 if (parameters[0] == null || parameters[1] == null) {
			 return;
		 }
		 final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;
		 myAgg.histogram.add(PrimitiveObjectInspectorUtils.getDouble(parameters[0], weightOI));
	 }
	 public void merge( AggregationBuffer agg, Object other) throws HiveException {
		 if (other == null) {
			 return;
		 }
		 final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;
		 myAgg.autoShrink = autoShrinkOI.get(structOI.getStructFieldData(other, autoShrinkField));
		 final List<?> histogram = ((LazyBinaryArray) structOI.getStructFieldData(other, histogramField)).getList();
		 myAgg.histogram.merge(histogram, histogramElOI);
		 final double[] quantiles = HiveUtils.asDoubleArray( structOI.getStructFieldData(other, quantilesField), quantilesOI, quantileOI);
		 if (quantiles != null && quantiles.length > 0) {
			 myAgg.quantiles = quantiles;
		 }
	 }
	 public Object terminatePartial( AggregationBuffer agg) throws HiveException {
		 final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;
		 final Object[] partialResult = new Object[3];
		 partialResult[0] = new BooleanWritable(myAgg.autoShrink);
		 partialResult[1] = myAgg.histogram.serialize();
		 partialResult[2] = (myAgg.quantiles != null) ? WritableUtils.toWritableList(myAgg.quantiles) : Collections.singletonList(new DoubleWritable(0));
		 return partialResult;
	 }
	 public Object terminate( AggregationBuffer agg) throws HiveException {
		 final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;
		 if (myAgg.histogram.getUsedBins() < 1) {
			 return null;
		 }
		 else {
			 Preconditions.checkNotNull(myAgg.quantiles);
			 final List<DoubleWritable> result = new ArrayList<DoubleWritable>();
			 double prev = Double.NEGATIVE_INFINITY;
			 result.add(new DoubleWritable(Double.NEGATIVE_INFINITY));
			 for (int i = 0;
			 i < myAgg.quantiles.length;
			 i++) {
				 final double val = myAgg.histogram.quantile(myAgg.quantiles[i]);
				 if (prev == val) {
					 if (!myAgg.autoShrink) {
						 throw new HiveException( ""Quantiles were repeated even though `auto_shrink` is false."" + "" Reduce `num_of_bins` or enable `auto_shrink`."");
					 }
				 }
				 else {
					 result.add(new DoubleWritable(val));
					 prev = val;
				 }
			 }
			 result.add(new DoubleWritable(Double.POSITIVE_INFINITY));
			 return result;
		 }
	 }
 }",1,1,0,0
"public interface SuperPackageFactory extends EFactory{
	 SuperPackageFactory eINSTANCE = org.eclipse.xtext.generator.ecore.superPackage.impl.SuperPackageFactoryImpl.init();
	 SuperMain createSuperMain();
	 AnotherSuperMain createAnotherSuperMain();
	 SuperPackagePackage getSuperPackagePackage();
}",0,0,0,0
"public void buildSecondaryIndexes(Collection<SSTableReader> sstables, SortedSet<ByteBuffer> columns) {
	 logger.debug(""Submitting index build to compactionmanager"");
	 Table.IndexBuilder builder = table.createIndexBuilder(this, columns, new ReducingKeyIterator(sstables));
	 Future future = CompactionManager.instance.submitIndexBuild(this, builder);
	 try {
		 future.get();
		 for (ByteBuffer column : columns) getIndexedColumnFamilyStore(column).forceBlockingFlush();
	 }
	 catch (InterruptedException e) {
		 throw new AssertionError(e);
	 }
	 catch (ExecutionException e) {
		 throw new RuntimeException(e);
	 }
 }",0,0,0,0
"public class RemoteInterpreterEventServer implements RemoteInterpreterEventService.Iface {
	 private static final Logger LOGGER = LoggerFactory.getLogger(RemoteInterpreterEventServer.class);
	 private String portRange;
	 private int port;
	 private String host;
	 private TThreadPoolServer thriftServer;
	 private InterpreterSettingManager interpreterSettingManager;
	 private final ScheduledExecutorService appendService = Executors.newSingleThreadScheduledExecutor();
	 private ScheduledFuture<?> appendFuture;
	 private AppendOutputRunner runner;
	 private final RemoteInterpreterProcessListener listener;
	 private final ApplicationEventListener appListener;
	 private final Gson gson = new Gson();
	 public RemoteInterpreterEventServer(ZeppelinConfiguration zConf, InterpreterSettingManager interpreterSettingManager) {
		 this.portRange = zConf.getZeppelinServerRPCPortRange();
		 this.interpreterSettingManager = interpreterSettingManager;
		 this.listener = interpreterSettingManager.getRemoteInterpreterProcessListener();
		 this.appListener = interpreterSettingManager.getAppEventListener();
	 }
	 public void start() throws IOException {
		 Thread startingThread = new Thread() {
			 public void run() {
				 TServerSocket tSocket = null;
				 try {
					 tSocket = RemoteInterpreterUtils.createTServerSocket(portRange);
					 port = tSocket.getServerSocket().getLocalPort();
					 host = RemoteInterpreterUtils.findAvailableHostAddress();
				 }
				 catch (IOException e1) {
					 throw new RuntimeException(e1);
				 }
				 LOGGER.info(""InterpreterEventServer is starting at {
				}
				:{
				}
				"", host, port);
				 RemoteInterpreterEventService.Processor processor = new RemoteInterpreterEventService.Processor(RemoteInterpreterEventServer.this);
				 thriftServer = new TThreadPoolServer( new TThreadPoolServer.Args(tSocket).processor(processor));
				 thriftServer.serve();
			 }
		 }
		;
		 startingThread.start();
		 long start = System.currentTimeMillis();
		 while ((System.currentTimeMillis() - start) < 30 * 1000) {
			 if (thriftServer != null && thriftServer.isServing()) {
				 break;
			 }
			 try {
				 Thread.sleep(500);
			 }
			 catch (InterruptedException e) {
				 throw new IOException(e);
			 }
		 }
		 if (thriftServer != null && !thriftServer.isServing()) {
			 throw new IOException(""Fail to start InterpreterEventServer in 30 seconds."");
		 }
		 LOGGER.info(""RemoteInterpreterEventServer is started"");
		 runner = new AppendOutputRunner(listener);
		 appendFuture = appendService.scheduleWithFixedDelay( runner, 0, AppendOutputRunner.BUFFER_TIME_MS, TimeUnit.MILLISECONDS);
	 }
	 public void stop() {
		 if (thriftServer != null) {
			 thriftServer.stop();
		 }
		 if (appendFuture != null) {
			 appendFuture.cancel(true);
		 }
		 LOGGER.info(""RemoteInterpreterEventServer is stopped"");
	 }
	 public int getPort() {
		 return port;
	 }
	 public String getHost() {
		 return host;
	 }
	 public void registerInterpreterProcess(RegisterInfo registerInfo) throws TException {
		 InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(registerInfo.getInterpreterGroupId());
		 if (interpreterGroup == null) {
			 LOGGER.warn(""No such interpreterGroup: "" + registerInfo.getInterpreterGroupId());
			 return;
		 }
		 RemoteInterpreterProcess interpreterProcess = ((ManagedInterpreterGroup) interpreterGroup).getInterpreterProcess();
		 if (interpreterProcess == null) {
			 LOGGER.warn(""Interpreter process does not existed yet for InterpreterGroup: "" + registerInfo.getInterpreterGroupId());
		 }
		 interpreterProcess.processStarted(registerInfo.port, registerInfo.host);
	 }
	 public void appendOutput(OutputAppendEvent event) throws TException {
		 if (event.getAppId() == null) {
			 runner.appendBuffer( event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getData());
		 }
		 else {
			 appListener.onOutputAppend(event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getAppId(), event.getData());
		 }
	 }
	 public void updateOutput(OutputUpdateEvent event) throws TException {
		 if (event.getAppId() == null) {
			 listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(), InterpreterResult.Type.valueOf(event.getType()), event.getData());
		 }
		 else {
			 appListener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getAppId(), InterpreterResult.Type.valueOf(event.getType()), event.getData());
		 }
	 }
	 public void updateAllOutput(OutputUpdateAllEvent event) throws TException {
		 listener.onOutputClear(event.getNoteId(), event.getParagraphId());
		 for (int i = 0;
		 i < event.getMsg().size();
		 i++) {
			 RemoteInterpreterResultMessage msg = event.getMsg().get(i);
			 listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), i, InterpreterResult.Type.valueOf(msg.getType()), msg.getData());
		 }
	 }
	 public void appendAppOutput(AppOutputAppendEvent event) throws TException {
		 appListener.onOutputAppend(event.noteId, event.paragraphId, event.index, event.appId, event.data);
	 }
	 public void updateAppOutput(AppOutputUpdateEvent event) throws TException {
		 appListener.onOutputUpdated(event.noteId, event.paragraphId, event.index, event.appId, InterpreterResult.Type.valueOf(event.type), event.data);
	 }
	 public void updateAppStatus(AppStatusUpdateEvent event) throws TException {
		 appListener.onStatusChange(event.noteId, event.paragraphId, event.appId, event.status);
	 }
	 public void runParagraphs(RunParagraphsEvent event) throws TException {
		 try {
			 listener.runParagraphs(event.getNoteId(), event.getParagraphIndices(), event.getParagraphIds(), event.getCurParagraphId());
			 if (InterpreterContext.get() != null) {
				 LOGGER.info(""complete runParagraphs."" + InterpreterContext.get().getParagraphId() + "" "" + event);
			 }
			 else {
				 LOGGER.info(""complete runParagraphs."" + event);
			 }
		 }
		 catch (IOException e) {
			 throw new TException(e);
		 }
	 }
	 public void addAngularObject(String intpGroupId, String json) throws TException {
		 LOGGER.debug(""Add AngularObject, interpreterGroupId: "" + intpGroupId + "", json: "" + json);
		 AngularObject angularObject = AngularObject.fromJson(json);
		 InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);
		 if (interpreterGroup == null) {
			 throw new TException(""Invalid InterpreterGroupId: "" + intpGroupId);
		 }
		 interpreterGroup.getAngularObjectRegistry().add(angularObject.getName(), angularObject.get(), angularObject.getNoteId(), angularObject.getParagraphId());
	 }
	 public void updateAngularObject(String intpGroupId, String json) throws TException {
		 AngularObject angularObject = AngularObject.fromJson(json);
		 InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);
		 if (interpreterGroup == null) {
			 throw new TException(""Invalid InterpreterGroupId: "" + intpGroupId);
		 }
		 AngularObject localAngularObject = interpreterGroup.getAngularObjectRegistry().get( angularObject.getName(), angularObject.getNoteId(), angularObject.getParagraphId());
		 if (localAngularObject instanceof RemoteAngularObject) {
			 ((RemoteAngularObject) localAngularObject).set( angularObject.get(), true, false);
		 }
		 else {
			 localAngularObject.set(angularObject.get());
		 }
	 }
	 public void removeAngularObject(String intpGroupId, String noteId, String paragraphId, String name) throws TException {
		 InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);
		 if (interpreterGroup == null) {
			 throw new TException(""Invalid InterpreterGroupId: "" + intpGroupId);
		 }
		 interpreterGroup.getAngularObjectRegistry().remove(name, noteId, paragraphId);
	 }
	 public void sendParagraphInfo(String intpGroupId, String json) throws TException {
		 InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);
		 if (interpreterGroup == null) {
			 throw new TException(""Invalid InterpreterGroupId: "" + intpGroupId);
		 }
		 Map<String, String> paraInfos = gson.fromJson(json, new TypeToken<Map<String, String>>() {
		 }
		.getType());
		 String noteId = paraInfos.get(""noteId"");
		 String paraId = paraInfos.get(""paraId"");
		 String settingId = RemoteInterpreterUtils. getInterpreterSettingId(interpreterGroup.getId());
		 if (noteId != null && paraId != null && settingId != null) {
			 listener.onParaInfosReceived(noteId, paraId, settingId, paraInfos);
		 }
	 }
	 public List<String> getAllResources(String intpGroupId) throws TException {
		 ResourceSet resourceSet = getAllResourcePoolExcept(intpGroupId);
		 List<String> resourceList = new LinkedList<>();
		 for (Resource r : resourceSet) {
			 resourceList.add(r.toJson());
		 }
		 return resourceList;
	 }
	 public ByteBuffer getResource(String resourceIdJson) throws TException {
		 ResourceId resourceId = ResourceId.fromJson(resourceIdJson);
		 Object o = getResource(resourceId);
		 ByteBuffer obj;
		 if (o == null) {
			 obj = ByteBuffer.allocate(0);
		 }
		 else {
			 try {
				 obj = Resource.serializeObject(o);
			 }
			 catch (IOException e) {
				 throw new TException(e);
			 }
		 }
		 return obj;
	 }
	 public ByteBuffer invokeMethod(String intpGroupId, String invokeMethodJson) throws TException {
		 InvokeResourceMethodEventMessage invokeMethodMessage = InvokeResourceMethodEventMessage.fromJson(invokeMethodJson);
		 Object ret = invokeResourceMethod(intpGroupId, invokeMethodMessage);
		 ByteBuffer obj = null;
		 if (ret == null) {
			 obj = ByteBuffer.allocate(0);
		 }
		 else {
			 try {
				 obj = Resource.serializeObject(ret);
			 }
			 catch (IOException e) {
				 LOGGER.error(""invokeMethod failed"", e);
			 }
		 }
		 return obj;
	 }
	 public List<ParagraphInfo> getParagraphList(String user, String noteId) throws TException, ServiceException {
		 LOGGER.info(""get paragraph list from remote interpreter noteId: "" + noteId + "", user = "" + user);
		 if (user != null && noteId != null) {
			 List<ParagraphInfo> paragraphInfos = listener.getParagraphList(user, noteId);
			 return paragraphInfos;
		 }
		 else {
			 LOGGER.error(""user or noteId is null!"");
			 return null;
		 }
	 }
	 private Object invokeResourceMethod(String intpGroupId, final InvokeResourceMethodEventMessage message) {
		 final ResourceId resourceId = message.resourceId;
		 ManagedInterpreterGroup intpGroup = interpreterSettingManager.getInterpreterGroupById(resourceId.getResourcePoolId());
		 if (intpGroup == null) {
			 return null;
		 }
		 RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();
		 if (remoteInterpreterProcess == null) {
			 ResourcePool localPool = intpGroup.getResourcePool();
			 if (localPool != null) {
				 Resource res = localPool.get(resourceId.getName());
				 if (res != null) {
					 try {
						 return res.invokeMethod( message.methodName, message.getParamTypes(), message.params, message.returnResourceName);
					 }
					 catch (Exception e) {
						 LOGGER.error(e.getMessage(), e);
						 return null;
					 }
				 }
				 else {
					 LOGGER.error(""Can't invoke method {
					}
					 on null object"", message.methodName);
					 return null;
				 }
			 }
			 else {
				 LOGGER.error(""no resource pool"");
				 return null;
			 }
		 }
		 else if (remoteInterpreterProcess.isRunning()) {
			 ByteBuffer res = remoteInterpreterProcess.callRemoteFunction( new RemoteInterpreterProcess.RemoteFunction<ByteBuffer>() {
				 public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception {
					 return client.resourceInvokeMethod( resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName(), message.toJson());
				 }
			 }
			 );
			 try {
				 return Resource.deserializeObject(res);
			 }
			 catch (Exception e) {
				 LOGGER.error(e.getMessage(), e);
			 }
			 return null;
		 }
		 return null;
	 }
	 private Object getResource(final ResourceId resourceId) {
		 ManagedInterpreterGroup intpGroup = interpreterSettingManager .getInterpreterGroupById(resourceId.getResourcePoolId());
		 if (intpGroup == null) {
			 return null;
		 }
		 RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();
		 ByteBuffer buffer = remoteInterpreterProcess.callRemoteFunction( new RemoteInterpreterProcess.RemoteFunction<ByteBuffer>() {
			 public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception {
				 return client.resourceGet( resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName());
			 }
		 }
		 );
		 try {
			 Object o = Resource.deserializeObject(buffer);
			 return o;
		 }
		 catch (Exception e) {
			 LOGGER.error(e.getMessage(), e);
		 }
		 return null;
	 }
	 private ResourceSet getAllResourcePoolExcept(String interpreterGroupId) {
		 ResourceSet resourceSet = new ResourceSet();
		 for (ManagedInterpreterGroup intpGroup : interpreterSettingManager.getAllInterpreterGroup()) {
			 if (intpGroup.getId().equals(interpreterGroupId)) {
				 continue;
			 }
			 RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();
			 if (remoteInterpreterProcess == null) {
				 ResourcePool localPool = intpGroup.getResourcePool();
				 if (localPool != null) {
					 resourceSet.addAll(localPool.getAll());
				 }
			 }
			 else if (remoteInterpreterProcess.isRunning()) {
				 List<String> resourceList = remoteInterpreterProcess.callRemoteFunction( new RemoteInterpreterProcess.RemoteFunction<List<String>>() {
					 public List<String> call(RemoteInterpreterService.Client client) throws Exception {
						 return client.resourcePoolGetAll();
					 }
				 }
				 );
				 for (String res : resourceList) {
					 resourceSet.add(RemoteResource.fromJson(res));
				 }
			 }
		 }
		 return resourceSet;
	 }
}",1,1,0,0
"public static class Exceptions {
	 private Exceptions() {
	 }
	 public static IllegalArgumentException propertyKeyCanNotBeEmpty() {
		 return new IllegalArgumentException(""Property key can not be the empty string"");
	 }
	 public static IllegalArgumentException propertyKeyCanNotBeNull() {
		 return new IllegalArgumentException(""Property key can not be null"");
	 }
	 public static IllegalArgumentException propertyValueCanNotBeNull() {
		 return new IllegalArgumentException(""Property value can not be null"");
	 }
	 public static IllegalArgumentException propertyKeyCanNotBeAHiddenKey(final String key) {
		 return new IllegalArgumentException(""Property key can not be a hidden key: "" + key);
	 }
	 public static IllegalStateException propertyDoesNotExist() {
		 return new IllegalStateException(""The property does not exist as it has no key, value, or associated element"");
	 }
	 public static IllegalStateException propertyDoesNotExist(final Element element, final String key) {
		 return new IllegalStateException(""The property does not exist as the key has no associated value for the provided element: "" + element + "":"" + key);
	 }
	 public static IllegalArgumentException dataTypeOfPropertyValueNotSupported(final Object val) {
		 return dataTypeOfPropertyValueNotSupported(val, null);
	 }
	 public static IllegalArgumentException dataTypeOfPropertyValueNotSupported(final Object val, final Exception rootCause) {
		 return new IllegalArgumentException(String.format(""Property value [%s] is of type %s is not supported"", val, val.getClass()), rootCause);
	 }
	 public static IllegalStateException propertyRemovalNotSupported() {
		 return new IllegalStateException(""Property removal is not supported"");
	 }
 }",0,1,0,0
"public int getScale(ByteBuffer obj) {
	 return -1;
 }",0,0,0,0
"public RpcDispatcher(Channel channel, MessageListener l, MembershipListener l2, Object server_obj, boolean deadlock_detection, boolean concurrent_processing);",0,0,0,1
"private void init() {
	setUndecorated(true);
	try {
		if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			setOpacity(0.85f);
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	setTitle(""Downloading..."");
	setIconImage(ImageResource.get(""icon.png"").getImage());
	setSize(350, 250);
	setLocationRelativeTo(null);
	setResizable(false);
	getContentPane().setLayout(null);
	getContentPane().setBackground(ColorResource.getDarkestBgColor());
	titlePanel = new TitlePanel(null, this);
	titlePanel.setOpaque(false);
	titlePanel.setBounds(0, 0, 350, 50);
	closeBtn = new CustomButton();
	closeBtn.setBounds(320, 5, 24, 24);
	closeBtn.setIcon(ImageResource.get(""close_btn.png""));
	closeBtn.setBackground(ColorResource.getDarkestBgColor());
	closeBtn.setBorderPainted(false);
	closeBtn.setFocusPainted(false);
	closeBtn.setName(""PAUSE"");
	closeBtn.addActionListener(this);
	minBtn = new CustomButton();
	minBtn.setBounds(296, 5, 24, 24);
	minBtn.setIcon(ImageResource.get(""min_btn.png""));
	minBtn.setBackground(ColorResource.getDarkestBgColor());
	minBtn.setBorderPainted(false);
	minBtn.setFocusPainted(false);
	minBtn.setName(""MIN"");
	minBtn.addActionListener(this);
	titleLbl = new JLabel(StringResource.get(""DWN_TITLE""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(25, 15, 250, 30);
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, 55, 400, 2);
	lineLbl.setOpaque(true);
	prgCircle = new CircleProgressBar();
	prgCircle.setValue(0);
	prgCircle.setBounds(20, 80, 72, 72);
	titlePanel.add(titleLbl);
	titlePanel.add(minBtn);
	titlePanel.add(closeBtn);
	lblSpeed = new JLabel(""---"");
	lblSpeed.setHorizontalAlignment(JLabel.CENTER);
	lblSpeed.setBounds(15, 160, 80, 25);
	lblSpeed.setForeground(Color.WHITE);
	lblStat = new JLabel(StringResource.get(""DWN_TITLE""));
	lblStat.setBounds(120, 85, 200, 25);
	lblStat.setForeground(Color.WHITE);
	segProgress = new SegmentPanel();
	segProgress.setBounds(120, 115, 200, 5);
	lblDet = new JLabel(StringResource.get(""DWN_PLACEHOLDER""));
	lblDet.setBounds(120, 125, 200, 25);
	lblDet.setForeground(Color.WHITE);
	lblETA = new JLabel(""---"");
	lblETA.setBounds(120, 150, 200, 25);
	lblETA.setForeground(Color.WHITE);
	panel = new JPanel(null);
	panel.setBounds(0, 200, 350, 50);
	panel.setBackground(Color.DARK_GRAY);
	CustomButton btnMore = new CustomButton(StringResource.get(""DWN_HIDE""));
	CustomButton btnCN = new CustomButton(StringResource.get(""MENU_PAUSE""));
	btnMore.setBounds(0, 1, 175, 50);
	btnMore.setName(""BACKGROUND"");
	applyStyle(btnMore);
	btnCN.setBounds(176, 1, 175, 50);
	btnCN.setName(""PAUSE"");
	applyStyle(btnCN);
	add(titlePanel);
	add(lineLbl);
	add(prgCircle);
	add(lblSpeed);
	add(lblStat);
	add(segProgress);
	add(lblDet);
	add(lblETA);
	panel.add(btnMore);
	panel.add(btnCN);
	add(panel);
}",0,0,1,0
"public class TextureImageInfo{
	 Texture texture;
	 String name;
	 String diffuseFilename, specularFilename, hilightFilename, transparentFilename, emissiveFilename, bumpFilename;
	 double minu, minv, maxu, maxv;
	 double paramValue[];
	 public TextureImageInfo(Texture tex, double param[]) {
		 texture = tex;
		 paramValue = param;
		 minu = minv = Double.MAX_VALUE;
		 maxu = maxv = -Double.MAX_VALUE;
	 }
	 public Texture getTexture() {
		 return texture;
	 }
	 public String getName() {
		 return name;
	 }
	 public String getDiffuseFilename() {
		 return diffuseFilename;
	 }
	 public String getSpecularFilename() {
		 return specularFilename;
	 }
	 public String getHilightFilename() {
		 return hilightFilename;
	 }
	 public String getTransparentFilename() {
		 return transparentFilename;
	 }
	 public String getEmissiveFilename() {
		 return emissiveFilename;
	 }
	 public String getBumpFilename() {
		 return bumpFilename;
	 }
	 public double getMinU() {
		 return minu;
	 }
	 public double getMinV() {
		 return minv;
	 }
	 public double getMaxU() {
		 return maxu;
	 }
	 public double getMaxV() {
		 return maxv;
	 }
	 public double[] getParamValues() {
		 return paramValue;
	 }
}",0,1,0,0
"public static class ScanOptions extends CommonOpts {
	 of scan"") private String startRow;
	 of scan"") private String endRow;
	 private List<String> columns;
	 private String exactRow;
	 private String rowPrefix;
	 public boolean hexEncNonAscii = true;
	 public boolean scanAccumuloTable = false;
	 public boolean exportAsJson = false;
	 public boolean scanNtfy = false;
	 public String getStartRow() {
		 return startRow;
	 }
	 public String getEndRow() {
		 return endRow;
	 }
	 public String getExactRow() {
		 return exactRow;
	 }
	 public String getRowPrefix() {
		 return rowPrefix;
	 }
	 public List<String> getColumns() {
		 if (columns == null) {
			 return Collections.emptyList();
		 }
		 return columns;
	 }
	 private void checkScanOptions() {
		 if (this.scanAccumuloTable && this.exportAsJson) {
			 throw new IllegalArgumentException( ""Both \""--raw\"" and \""--json\"" can not be set together."");
		 }
		 if (this.scanAccumuloTable && this.scanNtfy) {
			 throw new IllegalArgumentException( ""Both \""--raw\"" and \""--ntfy\"" can not be set together."");
		 }
	 }
	 public ScanUtil.ScanOpts getScanOpts() {
		 EnumSet<ScanFlags> flags = EnumSet.noneOf(ScanFlags.class);
		 ScanUtil.setFlag(flags, help, ScanFlags.HELP);
		 ScanUtil.setFlag(flags, hexEncNonAscii, ScanFlags.HEX);
		 ScanUtil.setFlag(flags, scanAccumuloTable, ScanFlags.ACCUMULO);
		 ScanUtil.setFlag(flags, exportAsJson, ScanFlags.JSON);
		 ScanUtil.setFlag(flags, scanNtfy, ScanFlags.NTFY);
		 return new ScanUtil.ScanOpts(startRow, endRow, columns, exactRow, rowPrefix, flags);
	 }
	 public static ScanOptions parse(String[] args) {
		 ScanOptions opts = new ScanOptions();
		 parse(""fluo scan"", opts, args);
		 return opts;
	 }
 }",0,1,0,0
"protected String[] getFiles(File baseDir, DirectoryScanner ds) {
	 return restrict(ds.getIncludedFiles(), baseDir);
 }",0,0,0,0
"public static void serialize(TSerializer serializer, TBase struct, DataOutput out) throws IOException {
	 assert serializer != null;
	 assert struct != null;
	 assert out != null;
	 byte[] bytes;
	 try {
		 bytes = serializer.serialize(struct);
	 }
	 catch (TException e) {
		 throw new RuntimeException(e);
	 }
	 out.writeInt(bytes.length);
	 out.write(bytes);
 }",0,0,0,0
"public class TestJobSubmissionTez extends TestJobSubmission {
	 public static void oneTimeSetup() throws Exception{
		 String execType = System.getProperty(""test.exec.type"");
		 Assume.assumeTrue(""This test suite should only run in tez mode"", execType.equalsIgnoreCase(""tez""));
		 TestJobSubmission.oneTimeSetUp();
	 }
	 public void checkJobControlCompilerErrResult(PhysicalPlan pp, PigContext pc) throws Exception {
		 TezOperPlan tezPlan = buildTezPlan(pp, pc);
		 LoaderProcessor loaderStorer = new LoaderProcessor(tezPlan, pc);
		 loaderStorer.visit();
		 ParallelismSetter parallelismSetter = new ParallelismSetter(tezPlan, pc);
		 parallelismSetter.visit();
		 DAG tezDag = getTezDAG(tezPlan, pc);
		 TezDagBuilder dagBuilder = new TezDagBuilder(pc, tezPlan, tezDag, new HashMap<String, LocalResource>());
		 try {
			 dagBuilder.visit();
		 }
		 catch (VisitorException jce) {
			 assertTrue(((JobCreationException)jce.getCause()).getErrorCode() == 1068);
		 }
	 }
	 public void checkDefaultParallelResult(PhysicalPlan pp, PigContext pc) throws Exception {
		 TezOperPlan tezPlan = buildTezPlan(pp, pc);
		 LoaderProcessor loaderStorer = new LoaderProcessor(tezPlan, pc);
		 loaderStorer.visit();
		 ParallelismSetter parallelismSetter = new ParallelismSetter(tezPlan, pc);
		 parallelismSetter.visit();
		 DAG tezDag = getTezDAG(tezPlan, pc);
		 TezDagBuilder dagBuilder = new TezDagBuilder(pc, tezPlan, tezDag, new HashMap<String, LocalResource>());
		 dagBuilder.visit();
		 for (Vertex v : tezDag.getVertices()) {
			 if (!v.getInputVertices().isEmpty()) {
				 Configuration conf = TezUtils.createConfFromUserPayload(v.getProcessorDescriptor().getUserPayload());
				 int parallel = v.getParallelism();
				 assertEquals(parallel, 100);
				 Util.assertConfLong(conf, ""pig.info.reducers.default.parallel"", 100);
				 Util.assertConfLong(conf, ""pig.info.reducers.requested.parallel"", -1);
				 Util.assertConfLong(conf, ""pig.info.reducers.estimated.parallel"", -1);
			 }
		 }
	 }
	 private TezOperPlan buildTezPlan(PhysicalPlan pp, PigContext pc) throws Exception{
		 TezCompiler comp = new TezCompiler(pp, pc);
		 comp.compile();
		 return comp.getTezPlan();
	 }
	 private DAG getTezDAG(TezOperPlan tezPlan, PigContext pc) {
		 TezPlanContainerNode tezPlanNode = new TezPlanContainerNode(OperatorKey.genOpKey(""DAGName""), tezPlan);
		 TezScriptState scriptState = new TezScriptState(""test"");
		 ScriptState.start(scriptState);
		 scriptState.setDAGScriptInfo(tezPlanNode);
		 DAG tezDag = DAG.create(tezPlanNode.getOperatorKey().toString());
		 return tezDag;
	 }
}",1,0,0,0
"public final class MagicNames {
	 private MagicNames() {
	 }
	 public static final String ANTLIB_PREFIX = ""antlib:"";
	 public static final String ANT_VERSION = ""ant.version"";
	 public static final String BUILD_SYSCLASSPATH = ""build.sysclasspath"";
	 public static final String SCRIPT_REPOSITORY = ""org.apache.ant.scriptrepo"";
	 public static final String SYSTEM_LOADER_REF = ""ant.coreLoader"";
	 public static final String REPOSITORY_DIR_PROPERTY = ""ant.maven.repository.dir"";
	 public static final String REPOSITORY_URL_PROPERTY = ""ant.maven.repository.url"";
	 public static final String TASKDEF_PROPERTIES_RESOURCE = ""/org/apache/tools/ant/taskdefs/defaults.properties"";
	 public static final String TYPEDEFS_PROPERTIES_RESOURCE = ""/org/apache/tools/ant/types/defaults.properties"";
	 public static final String ANT_EXECUTOR_REFERENCE = ""ant.executor"";
	 public static final String ANT_EXECUTOR_CLASSNAME = ""ant.executor.class"";
	 public static final String PROJECT_BASEDIR = ""basedir"";
	 public static final String ANT_FILE = ""ant.file"";
	 public static final String ANT_JAVA_VERSION = ""ant.java.version"";
	 public static final String ANT_HOME = Launcher.ANTHOME_PROPERTY;
	 public static final String ANT_LIB = ""ant.core.lib"";
	 public static final String REGEXP_IMPL = ""ant.regexp.regexpimpl"";
	 public static final String BUILD_JAVAC_SOURCE = ""ant.build.javac.source"";
	 public static final String BUILD_JAVAC_TARGET = ""ant.build.javac.target"";
	 public static final String REFID_CLASSPATH_REUSE_LOADER = ""ant.reuse.loader"";
	 public static final String REFID_CLASSPATH_LOADER_PREFIX = ""ant.loader."";
	 public static final String REFID_PROPERTY_HELPER = ""ant.PropertyHelper"";
	 public static final String PROJECT_HELPER_CLASS = ""org.apache.tools.ant.ProjectHelper"";
	 public static final String PROJECT_HELPER_SERVICE = ""META-INF/services/org.apache.tools.ant.ProjectHelper"";
	 public static final String REFID_PROJECT_HELPER = ""ant.projectHelper"";
}",0,0,0,0
"public abstract class AbstractRestartResponseException extends AbortException{
	private static final long serialVersionUID = 1L;
	public AbstractRestartResponseException(){
		RequestCycle rc = RequestCycle.get();
		if (rc != null){
			rc.getResponse().reset();
		}
	}
}",0,0,0,0
"public void addWritable(WritableSelector w) {
	 appendSelector(w);
 }",0,0,0,0
"public JsonSchemaGeneratorBuilder useInterfaceProxies(boolean value) {
	super.useInterfaceProxies(value);
	return this;
}",0,0,0,0
"public String getCommand() {
	 return this.command;
 }",0,0,0,0
"public class SageRuntimeException extends RuntimeException implements SageExceptable{
	 protected final int kind;
	 public SageRuntimeException() {
		 kind = UNKNOWN;
	 }
	 public SageRuntimeException(String message, int kind) {
		 super(message);
		 this.kind = kind;
	 }
	 public SageRuntimeException(Throwable cause, int kind) {
		 super(cause);
		 this.kind = kind;
	 }
	 public SageRuntimeException(String message, Throwable cause, int kind) {
		 super(message, cause);
		 this.kind = kind;
	 }
	 public int getKind() {
		 return (kind);
	 }
	 public boolean isKind(int kind) {
		 return ((this.kind & kind) != 0);
	 }
	 public String getMessage() {
		 return (""kind="" + kind + "";
		 "" + super.getMessage());
	 }
}",0,1,0,0
"public final class LazyIterate{
	 private static final LazyIterable<?> EMPTY_ITERABLE = Lists.immutable.empty().asLazy();
	 private LazyIterate() {
		 throw new AssertionError(""Suppress default constructor for noninstantiability"");
	 }
	 public static <T> LazyIterable<T> adapt(Iterable<T> iterable) {
		 return new LazyIterableAdapter<>(iterable);
	 }
	 public static <T> LazyIterable<T> select(Iterable<T> iterable, Predicate<? super T> predicate) {
		 return new SelectIterable<>(iterable, predicate);
	 }
	 public static <T> LazyIterable<T> reject(Iterable<T> iterable, Predicate<? super T> predicate) {
		 return new RejectIterable<>(iterable, predicate);
	 }
	 public static <T> LazyIterable<T> selectInstancesOf(Iterable<?> iterable, Class<T> clazz) {
		 return new SelectInstancesOfIterable<>(iterable, clazz);
	 }
	 public static <T, V> LazyIterable<V> collect( Iterable<T> iterable, Function<? super T, ? extends V> function) {
		 return new CollectIterable<>(iterable, function);
	 }
	 public static <T, V> LazyIterable<V> flatCollect( Iterable<T> iterable, Function<? super T, ? extends Iterable<V>> function) {
		 return new FlatCollectIterable<>(iterable, function);
	 }
	 public static <T, V> LazyIterable<V> collectIf( Iterable<T> iterable, Predicate<? super T> predicate, Function<? super T, ? extends V> function) {
		 return LazyIterate.select(iterable, predicate).collect(function);
	 }
	 public static <T> LazyIterable<T> take(Iterable<T> iterable, int count) {
		 return new TakeIterable<>(iterable, count);
	 }
	 public static <T> LazyIterable<T> drop(Iterable<T> iterable, int count) {
		 return new DropIterable<>(iterable, count);
	 }
	 public static <T> LazyIterable<T> takeWhile(Iterable<T> iterable, Predicate<? super T> predicate) {
		 return new TakeWhileIterable<>(iterable, predicate);
	 }
	 public static <T> LazyIterable<T> dropWhile(Iterable<T> iterable, Predicate<? super T> predicate) {
		 return new DropWhileIterable<>(iterable, predicate);
	 }
	 public static <T> LazyIterable<T> distinct(Iterable<T> iterable) {
		 return new DistinctIterable<>(iterable);
	 }
	 public static <T> LazyIterable<T> concatenate(Iterable<T>... iterables) {
		 return CompositeIterable.with(iterables);
	 }
	 public static <T> LazyIterable<T> empty() {
		 return (LazyIterable<T>) EMPTY_ITERABLE;
	 }
	 public static <A, B> LazyIterable<Pair<A, B>> zip(Iterable<A> as, Iterable<B> bs) {
		 return new ZipIterable<>(as, bs);
	 }
	 public static <T> LazyIterable<Pair<T, Integer>> zipWithIndex(Iterable<T> iterable) {
		 return new ZipWithIndexIterable<>(iterable);
	 }
	 public static <T> LazyIterable<RichIterable<T>> chunk(Iterable<T> iterable, int size) {
		 return new ChunkIterable<>(iterable, size);
	 }
	 public static <T> LazyIterable<T> tap(Iterable<T> iterable, Procedure<? super T> procedure) {
		 return new TapIterable<>(iterable, procedure);
	 }
	 public static <A, B> LazyIterable<Pair<A, B>> cartesianProduct(Iterable<A> iterable1, Iterable<B> iterable2) {
		 return LazyIterate.cartesianProduct(iterable1, iterable2, Tuples::pair);
	 }
	 public static <A, B, C> LazyIterable<C> cartesianProduct(Iterable<A> iterable1, Iterable<B> iterable2, Function2<? super A, ? super B, ? extends C> function) {
		 return LazyIterate.flatCollect(iterable1, first -> LazyIterate.collect(iterable2, second -> function.value(first, second)));
	 }
}",1,0,0,0
"public static ConcurrentCompositeConfiguration createLocalConfig() {
	 MicroserviceConfigLoader loader = new MicroserviceConfigLoader();
	 loader.loadAndSort();
	 if (localConfig.size() > 0) {
		 ConfigModel model = new ConfigModel();
		 model.setConfig(localConfig);
		 loader.getConfigModels().add(model);
	 }
	 LOGGER.info(""create local config:"");
	 for (ConfigModel configModel : loader.getConfigModels()) {
		 LOGGER.info("" {
		}
		."", configModel.getUrl());
	 }
	 ConcurrentCompositeConfiguration config = ConfigUtil.createLocalConfig(loader.getConfigModels());
	 ConfigUtil.setMicroserviceConfigLoader(config, loader);
	 return config;
 }",0,0,1,0
"static class Event {
	 final Type type;
	 final TruffleFile file;
	 final IOException ioe;
	 final BasicFileAttributes attrs;
	 Event(Type type, TruffleFile file, BasicFileAttributes attrs) {
		 this.type = type;
		 this.file = file;
		 this.attrs = attrs;
		 this.ioe = null;
	 }
	 Event(Type type, TruffleFile file, IOException ioe) {
		 this.type = type;
		 this.file = file;
		 this.attrs = null;
		 this.ioe = ioe;
	 }
	 enum Type {
	 PRE_VISIT_DIRECTORY, VISIT, POST_VISIT_DIRECTORY }
 }",0,1,0,0
"public class XXTag extends XXDBBase implements Serializable {
	private static final long serialVersionUID = 1L;
	protected Long id;
	protected String guid;
	protected Long version;
	protected Long type;
	protected Short owner;
	protected String options;
	protected String tagAttrs;
	public void setId(Long id) {
		this.id = id;
	}
	public Long getId() {
		return id;
	}
	public String getGuid() {
		return guid;
	}
	public void setGuid(String guid) {
		this.guid = guid;
	}
	public Long getVersion() {
		return version;
	}
	public void setVersion(Long version) {
		this.version = version;
	}
	public Long getType() {
		return type;
	}
	public void setType(Long type) {
		this.type = type;
	}
	public Short getOwner() {
		 return owner;
	 }
	public void setOwner(Short owner) {
		 this.owner = owner;
	 }
	public void setOptions(String options) {
		this.options = options;
	}
	public String getOptions() {
		return this.options;
	}
	public String getTagAttrs() {
		 return tagAttrs;
	 }
	public void setTagAttrs(String tagAttrs) {
		 this.tagAttrs = tagAttrs;
	 }
	public int getMyClassType() {
		return AppConstants.CLASS_TYPE_XA_TAG;
	}
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((version == null) ? 0 : version.hashCode());
		result = prime * result + ((guid == null) ? 0 : guid.hashCode());
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((type == null) ? 0 : type.hashCode());
		result = prime * result + ((owner == null) ? 0 : owner.hashCode());
		result = prime * result + ((options == null) ? 0 : options.hashCode());
		result = prime * result + ((tagAttrs == null) ? 0 : tagAttrs.hashCode());
		return result;
	}
	public boolean equals(Object obj) {
		if (this == obj)return true;
		if (!super.equals(obj))return false;
		if (getClass() != obj.getClass())return false;
		XXTag other = (XXTag) obj;
		if (version == null) {
			if (other.version != null)return false;
		}
		 else if (!version.equals(other.version))return false;
		if (guid == null) {
			if (other.guid != null)return false;
		}
		 else if (!guid.equals(other.guid))return false;
		if (id == null) {
			if (other.id != null)return false;
		}
		 else if (!id.equals(other.id))return false;
		if (type == null) {
			if (other.type != null)return false;
		}
		 else if (!type.equals(other.type))return false;
		if (owner == null) {
			if (other.owner != null)return false;
		}
		 else if (!owner.equals(other.owner))return false;
		if (options == null) {
			if (other.options != null)return false;
		}
		 else if (!options.equals(other.options))if (tagAttrs == null) {
			if (other.tagAttrs != null)return false;
		}
		 else if (!tagAttrs.equals(other.tagAttrs))return false;
		return true;
	}
	public String toString() {
		StringBuilder sb = new StringBuilder();
		toString(sb);
		return sb.toString();
	}
	public StringBuilder toString(StringBuilder sb) {
		sb.append(""{
			 "");
		sb.append(super.toString() + ""}
		 "");
		sb.append(""id={
		"").append(id).append(""}
		 "");
		sb.append(""guid={
		"").append(guid).append(""}
		 "");
		sb.append(""type={
		"").append(type).append(""}
		 "");
		sb.append(""owned_by={
		"").append(owner).append(""}
		 "");
		sb.append(""options={
		"").append(options).append(""}
		 "");
		sb.append(""tagAttrs={
		"").append(tagAttrs).append(""}
		 "");
	sb.append("" }
	"");
	return sb;
}
}",0,0,0,0
"public void save() {
	FileWriter fw = null;
	try {
		File file = new File(System.getProperty(""user.home""), "".xdman/config.txt"");
		fw = new FileWriter(file);
		String newLine = ""\n"";
		fw.write(""monitoring:"" + this.monitoring + newLine);
		fw.write(""downloadFolder:"" + this.downloadFolder + newLine);
		fw.write(""maxDownloads:"" + this.maxDownloads + newLine);
		fw.write(""maxSegments:"" + this.maxSegments + newLine);
		fw.write(""networkTimeout:"" + this.networkTimeout + newLine);
		fw.write(""tcpWindowSize:"" + this.tcpWindowSize + newLine);
		fw.write(""minSegmentSize:"" + this.minSegmentSize + newLine);
		fw.write(""minVidSize:"" + this.minVidSize + newLine);
		fw.write(""duplicateAction:"" + this.duplicateAction + newLine);
		fw.write(""speedLimit:"" + this.speedLimit + newLine);
		fw.write(""showDownloadWindow:"" + this.showDownloadWindow + newLine);
		fw.write(""showDownloadCompleteWindow:"" + this.showDownloadCompleteWindow + newLine);
		fw.write(""blockedHosts:"" + XDMUtils.appendArray2Str(this.blockedHosts) + newLine);
		fw.write(""vidUrls:"" + XDMUtils.appendArray2Str(this.vidUrls) + newLine);
		fw.write(""fileExts:"" + XDMUtils.appendArray2Str(this.fileExts) + newLine);
		fw.write(""vidExts:"" + XDMUtils.appendArray2Str(this.vidExts) + newLine);
		fw.write(""proxyMode:"" + this.proxyMode + newLine);
		fw.write(""proxyPac:"" + this.proxyPac + newLine);
		fw.write(""proxyHost:"" + this.proxyHost + newLine);
		fw.write(""proxyPort:"" + this.proxyPort + newLine);
		fw.write(""socksHost:"" + this.socksHost + newLine);
		fw.write(""socksPort:"" + this.socksPort + newLine);
		fw.write(""proxyUser:"" + this.proxyUser + newLine);
		fw.write(""proxyPass:"" + this.proxyPass + newLine);
		fw.write(""autoShutdown:"" + this.autoShutdown + newLine);
		fw.write(""keepAwake:"" + this.keepAwake + newLine);
		fw.write(""execCmd:"" + this.execCmd + newLine);
		fw.write(""execAntivir:"" + this.execAntivir + newLine);
		fw.write(""version:"" + XDMApp.APP_VERSION + newLine);
		fw.write(""autoStart:"" + this.autoStart + newLine);
		fw.write(""language:"" + this.language + newLine);
		if (!StringUtils.isNullOrEmptyOrBlank(this.antivirExe))fw.write(""antivirExe:"" + this.antivirExe + newLine);
		if (!StringUtils.isNullOrEmptyOrBlank(this.antivirCmd))fw.write(""antivirCmd:"" + this.antivirCmd + newLine);
		if (!StringUtils.isNullOrEmptyOrBlank(this.customCmd))fw.write(""customCmd:"" + this.customCmd + newLine);
		fw.write(""showVideoNotification:"" + this.showVideoNotification + newLine);
	}
	 catch (Exception e) {
	}
	try {
		fw.close();
	}
	 catch (Exception e) {
	}
}",0,0,1,0
"class ResponseWrapper {
	 int mInt = -1;
	 boolean mBoolean = false;
	 String mString = """";
	 public void setInt(int pInt) {
		 mInt = pInt;
	 }
	 public int getInt() {
		 return mInt;
	 }
	 public void setBoolean(boolean pBoolean) {
		 mBoolean = pBoolean;
	 }
	 public boolean getBoolean() {
		 return mBoolean;
	 }
	 public void setString(String pString) {
		 mString = pString;
	 }
	 public String getString() {
		 return mString;
	 }
}",0,1,0,0
public MindMapLink getLinkForID(String ID);,0,0,0,0
"public static class NewItemFinishEvent<T extends Serializable> extends NewItemEvent<T> {
	 private static final String EVENT_DESCRIPTION = ""finish"";
	 private Serializable result;
	 public NewItemFinishEvent(final T item, final AjaxRequestTarget target) {
		 super(item, target);
	 }
	 public String getEventDescription() {
		 return NewItemFinishEvent.EVENT_DESCRIPTION;
	 }
	 public NewItemFinishEvent<T> setResult(final Serializable result) {
		 this.result = result;
		 return this;
	 }
	 public Serializable getResult() {
		 return result;
	 }
 }",0,1,0,0
"public final class DOMXPathFilter2Transform extends ApacheTransform {
	 public void init(TransformParameterSpec params) throws InvalidAlgorithmParameterException {
		 if (params == null) {
			 throw new InvalidAlgorithmParameterException(""params are required"");
		 }
		 else if (!(params instanceof XPathFilter2ParameterSpec)) {
			 throw new InvalidAlgorithmParameterException (""params must be of type XPathFilter2ParameterSpec"");
		 }
		 this.params = params;
	 }
	 public void init(XMLStructure parent, XMLCryptoContext context) throws InvalidAlgorithmParameterException {
		 super.init(parent, context);
		 try {
			 unmarshalParams(DOMUtils.getFirstChildElement(transformElem));
		 }
		 catch (MarshalException me) {
			 throw new InvalidAlgorithmParameterException(me);
		 }
	 }
	 private void unmarshalParams(Element curXPathElem) throws MarshalException {
		 List<XPathType> list = new ArrayList<>();
		 Element currentElement = curXPathElem;
		 while (currentElement != null) {
			 String xPath = currentElement.getFirstChild().getNodeValue();
			 String filterVal = DOMUtils.getAttributeValue(currentElement, ""Filter"");
			 if (filterVal == null) {
				 throw new MarshalException(""filter cannot be null"");
			 }
			 XPathType.Filter filter = null;
			 if (""intersect"".equals(filterVal)) {
				 filter = XPathType.Filter.INTERSECT;
			 }
			 else if (""subtract"".equals(filterVal)) {
				 filter = XPathType.Filter.SUBTRACT;
			 }
			 else if (""union"".equals(filterVal)) {
				 filter = XPathType.Filter.UNION;
			 }
			 else {
				 throw new MarshalException(""Unknown XPathType filter type"" + filterVal);
			 }
			 NamedNodeMap attributes = currentElement.getAttributes();
			 if (attributes != null) {
				 int length = attributes.getLength();
				 Map<String, String> namespaceMap = new HashMap<>(length);
				 for (int i = 0;
				 i < length;
				 i++) {
					 Attr attr = (Attr)attributes.item(i);
					 String prefix = attr.getPrefix();
					 if (prefix != null && ""xmlns"".equals(prefix)) {
						 namespaceMap.put(attr.getLocalName(), attr.getValue());
					 }
				 }
				 list.add(new XPathType(xPath, filter, namespaceMap));
			 }
			 else {
				 list.add(new XPathType(xPath, filter));
			 }
			 currentElement = DOMUtils.getNextSiblingElement(currentElement);
		 }
		 this.params = new XPathFilter2ParameterSpec(list);
	 }
	 public void marshalParams(XMLStructure parent, XMLCryptoContext context) throws MarshalException {
		 super.marshalParams(parent, context);
		 XPathFilter2ParameterSpec xp = (XPathFilter2ParameterSpec)getParameterSpec();
		 String prefix = DOMUtils.getNSPrefix(context, Transform.XPATH2);
		 String qname = prefix == null || prefix.length() == 0 ? ""xmlns"" : ""xmlns:"" + prefix;
		 List<XPathType> xpathList = xp.getXPathList();
		 for (XPathType xpathType : xpathList) {
			 Element elem = DOMUtils.createElement(ownerDoc, ""XPath"", Transform.XPATH2, prefix);
			 elem.appendChild (ownerDoc.createTextNode(xpathType.getExpression()));
			 DOMUtils.setAttribute(elem, ""Filter"", xpathType.getFilter().toString());
			 elem.setAttributeNS(""http: Transform.XPATH2);
			 Set<Map.Entry<String, String>> entries = xpathType.getNamespaceMap().entrySet();
			 for (Map.Entry<String, String> entry : entries) {
				 elem.setAttributeNS(""http: entry.getKey(), entry.getValue());
			 }
			 transformElem.appendChild(elem);
		 }
	 }
}",1,0,0,0
"public Provider createProvider(URI remoteURI, ProviderFutureFactory futureFactory) throws Exception {
	 CompositeData composite = URISupport.parseComposite(remoteURI);
	 Map<String, String> options = composite.getParameters();
	 Map<String, String> filtered = PropertyUtil.filterProperties(options, FAILOVER_OPTION_PREFIX);
	 Map<String, String> nested = PropertyUtil.filterProperties(filtered, FAILOVER_NESTED_OPTION_PREFIX_ADDON);
	 Map<String, String> providerOptions = PropertyUtil.filterProperties(options, ""provider."");
	 if (futureFactory == null) {
		 futureFactory = ProviderFutureFactory.create(providerOptions);
		 if (!providerOptions.isEmpty()) {
			 String msg = """" + "" Not all Provider options could be applied during Failover Provider creation."" + "" Check the options are spelled correctly."" + "" Unused parameters=["" + providerOptions + ""]."" + "" This provider instance cannot be started."";
			 throw new IllegalArgumentException(msg);
		 }
	 }
	 FailoverProvider provider = new FailoverProvider(composite.getComponents(), nested, futureFactory);
	 Map<String, String> unused = PropertyUtil.setProperties(provider, filtered);
	 if (!unused.isEmpty()) {
		 String msg = """" + "" Not all options could be set on the Failover provider."" + "" Check the options are spelled correctly."" + "" Unused parameters=["" + unused + ""]."" + "" This Provider cannot be started."";
		 throw new IllegalArgumentException(msg);
	 }
	 return provider;
 }",0,0,1,0
"public final class ImageMap extends WebMarkupContainer{
	private static final long serialVersionUID = 1L;
	private final List<ShapeLink> shapeLinks = new ArrayList<ShapeLink>();
	private static final class CircleLink extends ShapeLink{
		private static final long serialVersionUID = 1L;
		private final int radius;
		private final int x;
		private final int y;
		public CircleLink(final int x, final int y, final int radius, final Link<?> link){
			super(link);
			this.x = x;
			this.y = y;
			this.radius = radius;
		}
		String getCoordinates(){
			return x + "","" + y + "","" + radius;
		}
		String getType(){
			return ""circle"";
		}
	}
	private static final class PolygonLink extends ShapeLink{
		private static final long serialVersionUID = 1L;
		private final int[] coordinates;
		public PolygonLink(final int[] coordinates, final Link<?> link){
			super(link);
			this.coordinates = coordinates;
		}
		String getCoordinates(){
			final StringBuffer buffer = new StringBuffer();
			for (int i = 0;
			 i < coordinates.length;
			 i++){
				buffer.append(coordinates[i]);
				if (i < (coordinates.length - 1)){
					buffer.append(',');
				}
			}
			return buffer.toString();
		}
		String getType(){
			return ""polygon"";
		}
	}
	private static final class RectangleLink extends ShapeLink{
		private static final long serialVersionUID = 1L;
		private final int x1;
		private final int x2;
		private final int y1;
		private final int y2;
		public RectangleLink(final int x1, final int y1, final int x2, final int y2,final Link<?> link){
			super(link);
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
		}
		String getCoordinates(){
			return x1 + "","" + y1 + "","" + x2 + "","" + y2;
		}
		String getType(){
			return ""rectangle"";
		}
	}
	private static abstract class ShapeLink implements IClusterable{
		private static final long serialVersionUID = 1L;
		private final Link<?> link;
		public ShapeLink(final Link<?> link){
			this.link = link;
		}
		public String toString(){
			final String popupJavaScript;
			if (link.getPopupSettings() != null){
				popupJavaScript = link.getPopupSettings().getPopupJavaScript();
			}
			else{
				popupJavaScript = null;
			}
			return ""<area shape=\"""" + getType() + ""\"""" + "" coords=\"""" + getCoordinates() + ""\"""" +"" href=\"""" +link.getURL() +""\""""+ (link.getOutputMarkupId() ? "" id=\"""" + link.getMarkupId() + ""\"""" : """") +((popupJavaScript == null) ? """" : ("" onClick = \"""" + popupJavaScript + ""\"""")) + "">"";
		}
		abstract String getCoordinates();
		abstract String getType();
	}
	public ImageMap(final String id){
		super(id);
	}
	public ImageMap addCircleLink(final int x1, final int y1, final int radius, final Link<?> link){
		add(link);
		shapeLinks.add(new CircleLink(x1, y1, radius, link));
		return this;
	}
	public ImageMap addPolygonLink(final int[] coordinates, final Link<?> link){
		add(link);
		shapeLinks.add(new PolygonLink(coordinates, link));
		return this;
	}
	public ImageMap addRectangleLink(final int x1, final int y1, final int x2, final int y2,final Link<?> link){
		add(link);
		shapeLinks.add(new RectangleLink(x1, y1, x2, y2, link));
		return this;
	}
	protected void onRender(final MarkupStream markupStream){
		final ComponentTag tag = markupStream.getTag().mutable();
		checkComponentTag(tag, ""img"");
		tag.put(""usemap"", ""#"" + getPath());
		renderComponentTag(tag);
		markupStream.next();
		final StringBuffer imageMap = new StringBuffer();
		imageMap.append(""\n<map name=\"""").append(getPath()).append(""\""> "");
		for (Iterator<ShapeLink> iterator = shapeLinks.iterator();
		 iterator.hasNext();
		){
			final ShapeLink shapeLink = iterator.next();
			imageMap.append('\n');
			imageMap.append(shapeLink.toString());
			getPage().componentRendered(shapeLink.link);
		}
		imageMap.append(""\n</map>"");
		getResponse().write(imageMap.toString());
	}
}",0,0,0,0
"public class CrunchInputFormat<K, V> extends InputFormat<K, V> {
	 public List<InputSplit> getSplits(JobContext job) throws IOException, InterruptedException {
		 List<InputSplit> splits = Lists.newArrayList();
		 Configuration base = job.getConfiguration();
		 Map<FormatBundle, Map<Integer, List<Path>>> formatNodeMap = CrunchInputs.getFormatNodeMap(job);
		 for (Map.Entry<FormatBundle, Map<Integer, List<Path>>> entry : formatNodeMap.entrySet()) {
			 FormatBundle inputBundle = entry.getKey();
			 Configuration conf = new Configuration(base);
			 inputBundle.configure(conf);
			 Job jobCopy = new Job(conf);
			 InputFormat<?, ?> format = (InputFormat<?, ?>) ReflectionUtils.newInstance(inputBundle.getFormatClass(), jobCopy.getConfiguration());
			 if (format instanceof FileInputFormat && !conf.getBoolean(RuntimeParameters.DISABLE_COMBINE_FILE, true)) {
				 format = new CrunchCombineFileInputFormat<Object, Object>(jobCopy);
			 }
			 for (Map.Entry<Integer, List<Path>> nodeEntry : entry.getValue().entrySet()) {
				 Integer nodeIndex = nodeEntry.getKey();
				 List<Path> paths = nodeEntry.getValue();
				 FileInputFormat.setInputPaths(jobCopy, paths.toArray(new Path[paths.size()]));
				 List<InputSplit> pathSplits = format.getSplits(jobCopy);
				 for (InputSplit pathSplit : pathSplits) {
					 splits.add(new CrunchInputSplit(pathSplit, inputBundle, nodeIndex, jobCopy.getConfiguration()));
				 }
			 }
		 }
		 return splits;
	 }
	 public RecordReader<K, V> createRecordReader(InputSplit inputSplit, TaskAttemptContext context) throws IOException, InterruptedException {
		 return new CrunchRecordReader<K, V>(inputSplit, context);
	 }
}",1,0,0,0
"public boolean setFieldProperty(String field, String name, Object value, int inst[]) {
	 if (writer == null) throw new RuntimeException(MessageLocalization.getComposedMessage(""this.acrofields.instance.is.read.only""));
	 try {
		 Item item = fields.get(field);
		 if (item == null) return false;
		 InstHit hit = new InstHit(inst);
		 PdfDictionary merged;
		 PdfString da;
		 if (name.equalsIgnoreCase(""textfont"")) {
			 for (int k = 0;
			 k < item.size();
			 ++k) {
				 if (hit.isHit(k)) {
					 merged = item.getMerged( k );
					 da = merged.getAsString(PdfName.DA);
					 PdfDictionary dr = merged.getAsDict(PdfName.DR);
					 if (da != null && dr != null) {
						 Object dao[] = splitDAelements(da.toUnicodeString());
						 PdfAppearance cb = new PdfAppearance();
						 if (dao[DA_FONT] != null) {
							 BaseFont bf = (BaseFont)value;
							 PdfName psn = PdfAppearance.stdFieldFontNames.get(bf.getPostscriptFontName());
							 if (psn == null) {
								 psn = new PdfName(bf.getPostscriptFontName());
							 }
							 PdfDictionary fonts = dr.getAsDict(PdfName.FONT);
							 if (fonts == null) {
								 fonts = new PdfDictionary();
								 dr.put(PdfName.FONT, fonts);
							 }
							 PdfIndirectReference fref = (PdfIndirectReference)fonts.get(psn);
							 PdfDictionary top = reader.getCatalog().getAsDict(PdfName.ACROFORM);
							 markUsed(top);
							 dr = top.getAsDict(PdfName.DR);
							 if (dr == null) {
								 dr = new PdfDictionary();
								 top.put(PdfName.DR, dr);
							 }
							 markUsed(dr);
							 PdfDictionary fontsTop = dr.getAsDict(PdfName.FONT);
							 if (fontsTop == null) {
								 fontsTop = new PdfDictionary();
								 dr.put(PdfName.FONT, fontsTop);
							 }
							 markUsed(fontsTop);
							 PdfIndirectReference frefTop = (PdfIndirectReference)fontsTop.get(psn);
							 if (frefTop != null) {
								 if (fref == null) fonts.put(psn, frefTop);
							 }
							 else if (fref == null) {
								 FontDetails fd;
								 if (bf.getFontType() == BaseFont.FONT_TYPE_DOCUMENT) {
									 fd = new FontDetails(null, ((DocumentFont)bf).getIndirectReference(), bf);
								 }
								 else {
									 bf.setSubset(false);
									 fd = writer.addSimple(bf);
									 localFonts.put(psn.toString().substring(1), bf);
								 }
								 fontsTop.put(psn, fd.getIndirectReference());
								 fonts.put(psn, fd.getIndirectReference());
							 }
							 ByteBuffer buf = cb.getInternalBuffer();
							 buf.append(psn.getBytes()).append(' ').append(((Float)dao[DA_SIZE]).floatValue()).append("" Tf "");
							 if (dao[DA_COLOR] != null) cb.setColorFill((BaseColor)dao[DA_COLOR]);
							 PdfString s = new PdfString(cb.toString());
							 item.getMerged(k).put(PdfName.DA, s);
							 item.getWidget(k).put(PdfName.DA, s);
							 markUsed(item.getWidget(k));
						 }
					 }
				 }
			 }
		 }
		 else if (name.equalsIgnoreCase(""textcolor"")) {
			 for (int k = 0;
			 k < item.size();
			 ++k) {
				 if (hit.isHit(k)) {
					 merged = item.getMerged( k );
					 da = merged.getAsString(PdfName.DA);
					 if (da != null) {
						 Object dao[] = splitDAelements(da.toUnicodeString());
						 PdfAppearance cb = new PdfAppearance();
						 if (dao[DA_FONT] != null) {
							 ByteBuffer buf = cb.getInternalBuffer();
							 buf.append(new PdfName((String)dao[DA_FONT]).getBytes()).append(' ').append(((Float)dao[DA_SIZE]).floatValue()).append("" Tf "");
							 cb.setColorFill((BaseColor)value);
							 PdfString s = new PdfString(cb.toString());
							 item.getMerged(k).put(PdfName.DA, s);
							 item.getWidget(k).put(PdfName.DA, s);
							 markUsed(item.getWidget(k));
						 }
					 }
				 }
			 }
		 }
		 else if (name.equalsIgnoreCase(""textsize"")) {
			 for (int k = 0;
			 k < item.size();
			 ++k) {
				 if (hit.isHit(k)) {
					 merged = item.getMerged( k );
					 da = merged.getAsString(PdfName.DA);
					 if (da != null) {
						 Object dao[] = splitDAelements(da.toUnicodeString());
						 PdfAppearance cb = new PdfAppearance();
						 if (dao[DA_FONT] != null) {
							 ByteBuffer buf = cb.getInternalBuffer();
							 buf.append(new PdfName((String)dao[DA_FONT]).getBytes()).append(' ').append(((Float)value).floatValue()).append("" Tf "");
							 if (dao[DA_COLOR] != null) cb.setColorFill((BaseColor)dao[DA_COLOR]);
							 PdfString s = new PdfString(cb.toString());
							 item.getMerged(k).put(PdfName.DA, s);
							 item.getWidget(k).put(PdfName.DA, s);
							 markUsed(item.getWidget(k));
						 }
					 }
				 }
			 }
		 }
		 else if (name.equalsIgnoreCase(""bgcolor"") || name.equalsIgnoreCase(""bordercolor"")) {
			 PdfName dname = name.equalsIgnoreCase(""bgcolor"") ? PdfName.BG : PdfName.BC;
			 for (int k = 0;
			 k < item.size();
			 ++k) {
				 if (hit.isHit(k)) {
					 merged = item.getMerged( k );
					 PdfDictionary mk = merged.getAsDict(PdfName.MK);
					 if (mk == null) {
						 if (value == null) return true;
						 mk = new PdfDictionary();
						 item.getMerged(k).put(PdfName.MK, mk);
						 item.getWidget(k).put(PdfName.MK, mk);
						 markUsed(item.getWidget(k));
					 }
					 else {
						 markUsed( mk );
					 }
					 if (value == null) mk.remove(dname);
					 else mk.put(dname, PdfFormField.getMKColor((BaseColor)value));
				 }
			 }
		 }
		 else return false;
		 return true;
	 }
	 catch (Exception e) {
		 throw new ExceptionConverter(e);
	 }
 }",0,0,1,0
"public class QuerySpecification extends QueryExpression {
	 private final static int[] defaultLimits = new int[] {
	 0, Integer.MAX_VALUE, Integer.MAX_VALUE }
	;
	 public int resultRangePosition;
	 public boolean isDistinctSelect;
	 public boolean isAggregated;
	 public boolean isGrouped;
	 RangeVariable[] rangeVariables;
	 private HsqlArrayList rangeVariableList;
	 Expression queryCondition;
	 Expression checkQueryCondition;
	 private Expression havingCondition;
	 Expression rowExpression;
	 Expression[] exprColumns;
	 private HsqlArrayList exprColumnList;
	 public int indexLimitVisible;
	 private int indexLimitRowId;
	 private int groupByColumnCount;
	 private int havingColumnCount;
	 private int indexStartHaving;
	 public int indexStartOrderBy;
	 public int indexStartAggregates;
	 private int indexLimitExpressions;
	 public int indexLimitData;
	 private boolean hasRowID;
	 private boolean isSimpleCount;
	 private boolean hasMemoryRow;
	 public boolean isUniqueResultRows;
	 private boolean simpleLimit = true;
	 Type[] columnTypes;
	 private ArrayListIdentity aggregateSet;
	 private ArrayListIdentity resolvedSubqueryExpressions = null;
	 private boolean[] aggregateCheck;
	 private OrderedHashSet tempSet = new OrderedHashSet();
	 int[] columnMap;
	 private Table baseTable;
	 private OrderedHashSet conditionTables;
	 public Index groupIndex;
	 QuerySpecification(Session session, Table table, CompileContext compileContext) {
		 this(compileContext);
		 RangeVariable range = new RangeVariable(table, null, null, null, compileContext);
		 range.addTableColumns(exprColumnList, 0, null);
		 indexLimitVisible = exprColumnList.size();
		 addRangeVariable(range);
		 isMergeable = false;
		 resolveReferences(session);
		 resolveTypes(session);
		 sortAndSlice = SortAndSlice.noSort;
	 }
	 QuerySpecification(CompileContext compileContext) {
		 super(compileContext);
		 this.compileContext = compileContext;
		 resultRangePosition = compileContext.getNextRangeVarIndex();
		 rangeVariableList = new HsqlArrayList();
		 exprColumnList = new HsqlArrayList();
		 sortAndSlice = SortAndSlice.noSort;
		 isMergeable = true;
	 }
	 void addRangeVariable(RangeVariable rangeVar) {
		 rangeVariableList.add(rangeVar);
	 }
	 private void resolveRangeVariables(Session session) {
		 if (rangeVariables == null || rangeVariables.length < rangeVariableList.size()) {
			 rangeVariables = new RangeVariable[rangeVariableList.size()];
			 rangeVariableList.toArray(rangeVariables);
		 }
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 rangeVariables[i].resolveRangeTable(session, rangeVariables, i);
		 }
	 }
	 void addSelectColumnExpression(Expression e) {
		 if (e.getType() == OpTypes.ROW) {
			 throw Error.error(ErrorCode.X_42564);
		 }
		 if (indexLimitVisible > 0) {
			 if (e.opType == OpTypes.MULTICOLUMN) {
				 if (((ExpressionColumn) e).getTableName() == null) {
					 throw Error.error(ErrorCode.X_42578);
				 }
			 }
			 Expression first = ((Expression) exprColumnList.get(0));
			 if (first.opType == OpTypes.MULTICOLUMN && ((ExpressionColumn) first).getTableName() == null) {
				 throw Error.error(ErrorCode.X_42578);
			 }
		 }
		 exprColumnList.add(e);
		 indexLimitVisible++;
	 }
	 void addQueryCondition(Expression e) {
		 queryCondition = e;
	 }
	 void addGroupByColumnExpression(Expression e) {
		 if (e.getType() == OpTypes.ROW) {
			 throw Error.error(ErrorCode.X_42564);
		 }
		 exprColumnList.add(e);
		 isGrouped = true;
		 groupByColumnCount++;
	 }
	 void addHavingExpression(Expression e) {
		 exprColumnList.add(e);
		 havingCondition = e;
		 havingColumnCount = 1;
	 }
	 void addSortAndSlice(SortAndSlice sortAndSlice) {
		 this.sortAndSlice = sortAndSlice;
	 }
	 public void resolveReferences(Session session) {
		 resolveRangeVariables(session);
		 resolveColumnReferencesForAsterisk();
		 finaliseColumns();
		 resolveColumnReferences();
		 unionColumnTypes = new Type[indexLimitVisible];
		 setReferenceableColumns();
	 }
	 private void resolveColumnReferences() {
		 if (isDistinctSelect || isGrouped) {
			 acceptsSequences = false;
		 }
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 Expression e = rangeVariables[i].getJoinCondition();
			 if (e == null) {
				 continue;
			 }
			 resolveColumnReferencesAndAllocate(e, i + 1, false);
		 }
		 resolveColumnReferencesAndAllocate(queryCondition, rangeVariables.length, false);
		 if (resolvedSubqueryExpressions != null) {
			 resolvedSubqueryExpressions.setSize(0);
		 }
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 resolveColumnReferencesAndAllocate(exprColumns[i], rangeVariables.length, acceptsSequences);
		 }
		 for (int i = indexLimitVisible;
		 i < indexStartHaving;
		 i++) {
			 exprColumns[i] = resolveColumnReferencesInGroupBy(exprColumns[i]);
		 }
		 for (int i = indexStartHaving;
		 i < indexStartOrderBy;
		 i++) {
			 resolveColumnReferencesAndAllocate(exprColumns[i], rangeVariables.length, false);
		 }
		 resolveColumnRefernecesInOrderBy(sortAndSlice);
	 }
	 void resolveColumnRefernecesInOrderBy(SortAndSlice sortAndSlice) {
		 int orderCount = sortAndSlice.getOrderLength();
		 for (int i = 0;
		 i < orderCount;
		 i++) {
			 ExpressionOrderBy e = (ExpressionOrderBy) sortAndSlice.exprList.get(i);
			 replaceColumnIndexInOrderBy(e);
			 if (e.getLeftNode().queryTableColumnIndex != -1) {
				 continue;
			 }
			 if (sortAndSlice.sortUnion) {
				 if (e.getLeftNode().getType() != OpTypes.COLUMN) {
					 throw Error.error(ErrorCode.X_42576);
				 }
			 }
			 e.replaceAliasInOrderBy(exprColumns, indexLimitVisible);
			 resolveColumnReferencesAndAllocate(e, rangeVariables.length, false);
			 if (isAggregated || isGrouped) {
				 boolean check = e.getLeftNode().isComposedOf(exprColumns, 0, indexLimitVisible + groupByColumnCount, Expression.aggregateFunctionSet);
				 if (!check) {
					 throw Error.error(ErrorCode.X_42576);
				 }
			 }
		 }
		 sortAndSlice.prepare(this);
	 }
	 private boolean resolveColumnReferences(Expression e, int rangeCount, boolean withSequences) {
		 if (e == null) {
			 return true;
		 }
		 int oldSize = unresolvedExpressions == null ? 0 : unresolvedExpressions .size();
		 unresolvedExpressions = e.resolveColumnReferences(rangeVariables, rangeCount, unresolvedExpressions, withSequences);
		 int newSize = unresolvedExpressions == null ? 0 : unresolvedExpressions .size();
		 return oldSize == newSize;
	 }
	 private void resolveColumnReferencesForAsterisk() {
		 for (int pos = 0;
		 pos < indexLimitVisible;
		 ) {
			 Expression e = (Expression) (exprColumnList.get(pos));
			 if (e.getType() == OpTypes.MULTICOLUMN) {
				 exprColumnList.remove(pos);
				 String tablename = ((ExpressionColumn) e).getTableName();
				 if (tablename == null) {
					 addAllJoinedColumns(e);
				 }
				 else {
					 int rangeIndex = e.findMatchingRangeVariableIndex(rangeVariables);
					 if (rangeIndex == -1) {
						 throw Error.error(ErrorCode.X_42501, tablename);
					 }
					 RangeVariable range = rangeVariables[rangeIndex];
					 HashSet exclude = getAllNamedJoinColumns();
					 range.addTableColumns(e, exclude);
				 }
				 for (int i = 0;
				 i < e.nodes.length;
				 i++) {
					 exprColumnList.add(pos, e.nodes[i]);
					 pos++;
				 }
				 indexLimitVisible += e.nodes.length - 1;
			 }
			 else {
				 pos++;
			 }
		 }
	 }
	 private void resolveColumnReferencesAndAllocate(Expression expression, int count, boolean withSequences) {
		 if (expression == null) {
			 return;
		 }
		 HsqlList list = expression.resolveColumnReferences(rangeVariables, count, null, withSequences);
		 if (list != null) {
			 for (int i = 0;
			 i < list.size();
			 i++) {
				 Expression e = (Expression) list.get(i);
				 boolean resolved;
				 if (e.isSelfAggregate()) {
					 resolved = resolveColumnReferences(e.getLeftNode(), count, false);
				 }
				 else {
					 resolved = resolveColumnReferences(e, count, withSequences);
				 }
				 if (resolved) {
					 if (e.isSelfAggregate()) {
						 if (aggregateSet == null) {
							 aggregateSet = new ArrayListIdentity();
						 }
						 aggregateSet.add(e);
						 isAggregated = true;
						 expression.setAggregate();
					 }
					 if (resolvedSubqueryExpressions == null) {
						 resolvedSubqueryExpressions = new ArrayListIdentity();
					 }
					 resolvedSubqueryExpressions.add(e);
				 }
				 else {
					 if (unresolvedExpressions == null) {
						 unresolvedExpressions = new ArrayListIdentity();
					 }
					 unresolvedExpressions.add(e);
				 }
			 }
		 }
	 }
	 private Expression resolveColumnReferencesInGroupBy( Expression expression) {
		 if (expression == null) {
			 return null;
		 }
		 HsqlList list = expression.resolveColumnReferences(rangeVariables, rangeVariables.length, null, false);
		 if (list != null) {
			 if (expression.getType() == OpTypes.COLUMN) {
				 Expression resolved = expression.replaceAliasInOrderBy(exprColumns, indexLimitVisible);
				 if (resolved != expression) {
					 return resolved;
				 }
			 }
			 resolveColumnReferencesAndAllocate(expression, rangeVariables.length, false);
		 }
		 return expression;
	 }
	 private HashSet getAllNamedJoinColumns() {
		 HashSet set = null;
		 for (int i = 0;
		 i < rangeVariableList.size();
		 i++) {
			 RangeVariable range = (RangeVariable) rangeVariableList.get(i);
			 if (range.namedJoinColumns != null) {
				 if (set == null) {
					 set = new HashSet();
				 }
				 set.addAll(range.namedJoinColumns);
			 }
		 }
		 return set;
	 }
	 public Expression getEquiJoinExpressions(OrderedHashSet nameSet, RangeVariable rightRange, boolean fullList) {
		 HashSet set = new HashSet();
		 Expression result = null;
		 OrderedHashSet joinColumnNames = new OrderedHashSet();
		 for (int i = 0;
		 i < rangeVariableList.size();
		 i++) {
			 RangeVariable range = (RangeVariable) rangeVariableList.get(i);
			 HashMappedList columnList = range.rangeTable.columnList;
			 for (int j = 0;
			 j < columnList.size();
			 j++) {
				 ColumnSchema column = (ColumnSchema) columnList.get(j);
				 String name = range.getColumnAlias(j);
				 boolean columnInList = nameSet.contains(name);
				 boolean namedJoin = range.namedJoinColumns != null && range.namedJoinColumns.contains(name);
				 boolean repeated = !namedJoin && !set.add(name);
				 if (repeated && (!fullList || columnInList)) {
					 throw Error.error(ErrorCode.X_42578, name);
				 }
				 if (!columnInList) {
					 continue;
				 }
				 joinColumnNames.add(name);
				 int leftPosition = range.rangeTable.getColumnIndex(column.getNameString());
				 int rightPosition = rightRange.rangeTable.getColumnIndex(name);
				 Expression e = new ExpressionLogical(range, leftPosition, rightRange, rightPosition);
				 result = ExpressionLogical.andExpressions(result, e);
				 ExpressionColumn col = range.getColumnExpression(name);
				 if (col == null) {
					 col = new ExpressionColumn(new Expression[] {
					 e.getLeftNode(), e.getRightNode() }
					, name);
					 range.addNamedJoinColumnExpression(name, col);
				 }
				 else {
					 col.nodes = (Expression[]) ArrayUtil.resizeArray(col.nodes, col.nodes.length + 1);
					 col.nodes[col.nodes.length - 1] = e.getRightNode();
				 }
				 rightRange.addNamedJoinColumnExpression(name, col);
			 }
		 }
		 if (fullList && !joinColumnNames.containsAll(nameSet)) {
			 throw Error.error(ErrorCode.X_42501);
		 }
		 rightRange.addNamedJoinColumns(joinColumnNames);
		 return result;
	 }
	 private void addAllJoinedColumns(Expression e) {
		 HsqlArrayList list = new HsqlArrayList();
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 rangeVariables[i].addTableColumns(list);
		 }
		 Expression[] nodes = new Expression[list.size()];
		 list.toArray(nodes);
		 e.nodes = nodes;
	 }
	 private void finaliseColumns() {
		 indexLimitRowId = indexLimitVisible;
		 indexStartHaving = indexLimitRowId + groupByColumnCount;
		 indexStartOrderBy = indexStartHaving + havingColumnCount;
		 indexStartAggregates = indexStartOrderBy + sortAndSlice.getOrderLength();
		 indexLimitData = indexLimitExpressions = indexStartAggregates;
		 exprColumns = new Expression[indexLimitExpressions];
		 exprColumnList.toArray(exprColumns);
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 exprColumns[i].queryTableColumnIndex = i;
		 }
		 if (sortAndSlice.hasOrder()) {
			 for (int i = 0;
			 i < sortAndSlice.getOrderLength();
			 i++) {
				 exprColumns[indexStartOrderBy + i] = (Expression) sortAndSlice.exprList.get(i);
			 }
		 }
		 rowExpression = new Expression(OpTypes.ROW, exprColumns);
	 }
	 private void replaceColumnIndexInOrderBy(Expression orderBy) {
		 Expression e = orderBy.getLeftNode();
		 if (e.getType() != OpTypes.VALUE) {
			 return;
		 }
		 if (e.getDataType().typeCode == Types.SQL_INTEGER) {
			 int i = ((Integer) e.getValue(null)).intValue();
			 if (0 < i && i <= indexLimitVisible) {
				 orderBy.setLeftNode(exprColumns[i - 1]);
				 return;
			 }
		 }
		 throw Error.error(ErrorCode.X_42576);
	 }
	 void collectRangeVariables(RangeVariable[] rangeVars, Set set) {
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 exprColumns[i].collectRangeVariables(rangeVars, set);
		 }
		 if (queryCondition != null) {
			 queryCondition.collectRangeVariables(rangeVars, set);
		 }
		 if (havingCondition != null) {
			 havingCondition.collectRangeVariables(rangeVars, set);
		 }
	 }
	 public boolean hasReference(RangeVariable range) {
		 if (unresolvedExpressions == null) {
			 return false;
		 }
		 for (int i = 0;
		 i < unresolvedExpressions.size();
		 i++) {
			 if (((Expression) unresolvedExpressions.get(i)).hasReference( range)) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public void resolveExpressionTypes(Session session, Expression parent) {
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 Expression e = exprColumns[i];
			 e.resolveTypes(session, parent);
			 if (e.getType() == OpTypes.ROW) {
				 throw Error.error(ErrorCode.X_42564);
			 }
		 }
		 for (int i = 0, len = rangeVariables.length;
		 i < len;
		 i++) {
			 Expression e = rangeVariables[i].getJoinCondition();
			 if (e != null) {
				 e.resolveTypes(session, null);
				 if (e.getDataType() != Type.SQL_BOOLEAN) {
					 throw Error.error(ErrorCode.X_42568);
				 }
			 }
		 }
		 if (queryCondition != null) {
			 queryCondition.resolveTypes(session, null);
			 if (queryCondition.getDataType() != Type.SQL_BOOLEAN) {
				 throw Error.error(ErrorCode.X_42568);
			 }
		 }
		 if (havingCondition != null) {
			 havingCondition.resolveTypes(session, null);
			 if (havingCondition.getDataType() != Type.SQL_BOOLEAN) {
				 throw Error.error(ErrorCode.X_42568);
			 }
		 }
	 }
	 private void resolveAggregates() {
		 tempSet.clear();
		 if (isAggregated) {
			 aggregateCheck = new boolean[indexStartAggregates];
			 tempSet.addAll(aggregateSet);
			 indexLimitData = indexLimitExpressions = exprColumns.length + tempSet.size();
			 exprColumns = (Expression[]) ArrayUtil.resizeArray(exprColumns, indexLimitExpressions);
			 for (int i = indexStartAggregates, j = 0;
			 i < indexLimitExpressions;
			 i++, j++) {
				 Expression e = (Expression) tempSet.get(j);
				 exprColumns[i] = e.duplicate();
				 exprColumns[i].nodes = e.nodes;
				 exprColumns[i].dataType = e.dataType;
			 }
			 tempSet.clear();
		 }
	 }
	 public boolean areColumnsResolved() {
		 return unresolvedExpressions == null || unresolvedExpressions.isEmpty();
	 }
	 private void setRangeVariableConditions(Session session) {
		 RangeVariableResolver rangeResolver = new RangeVariableResolver(rangeVariables, queryCondition, compileContext);
		 rangeResolver.processConditions(session);
		 rangeVariables = rangeResolver.rangeVariables;
	 }
	 public void resolveTypes(Session session) {
		 if (isResolved) {
			 return;
		 }
		 resolveTypesPartOne(session);
		 resolveTypesPartTwo(session);
		 ArrayUtil.copyArray(resultTable.colTypes, unionColumnTypes, unionColumnTypes.length);
		 for (int i = 0;
		 i < indexStartHaving;
		 i++) {
			 if (exprColumns[i].dataType == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
		 }
	 }
	 void resolveTypesPartOne(Session session) {
		 resolveExpressionTypes(session, rowExpression);
		 resolveAggregates();
		 for (int i = 0;
		 i < unionColumnTypes.length;
		 i++) {
			 unionColumnTypes[i] = Type.getAggregateType(unionColumnTypes[i], exprColumns[i].getDataType());
		 }
	 }
	 void resolveTypesPartTwo(Session session) {
		 resolveGroups();
		 for (int i = 0;
		 i < unionColumnTypes.length;
		 i++) {
			 Type type = unionColumnTypes[i];
			 if (type == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
			 exprColumns[i].setDataType(session, type);
		 }
		 for (int i = 0;
		 i < indexStartHaving;
		 i++) {
			 if (exprColumns[i].dataType == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
		 }
		 checkLobUsage();
		 setMergeability();
		 setUpdatability();
		 createResultMetaData();
		 createTable(session);
		 if (isMergeable) {
			 mergeQuery();
		 }
		 setRangeVariableConditions(session);
		 if (isAggregated && !isGrouped && !sortAndSlice.hasOrder() && !sortAndSlice.hasLimit() && aggregateSet.size() == 1 && indexLimitVisible == 1) {
			 Expression e = exprColumns[indexStartAggregates];
			 int opType = e.getType();
			 switch (opType) {
				 case OpTypes.MAX : case OpTypes.MIN : {
					 SortAndSlice slice = new SortAndSlice();
					 slice.isGenerated = true;
					 slice.addLimitCondition(ExpressionOp.limitOneExpression);
					 if (slice.prepareSpecial(session, this)) {
						 this.sortAndSlice = slice;
					 }
					 break;
				 }
				 case OpTypes.COUNT : {
					 if (rangeVariables.length == 1 && queryCondition == null && e.getLeftNode().getType() == OpTypes.ASTERISK) {
						 isSimpleCount = true;
					 }
				 }
			 }
		 }
		 sortAndSlice.setSortRange(this);
		 isResolved = true;
	 }
	 void checkLobUsage() {
		 if (!isDistinctSelect && !isGrouped) {
			 return;
		 }
		 for (int i = 0;
		 i < indexStartHaving;
		 i++) {
			 if (exprColumns[i].dataType.isLobType()) {
				 throw Error.error(ErrorCode.X_42534);
			 }
		 }
	 }
	 private void resolveGroups() {
		 tempSet.clear();
		 if (isGrouped) {
			 for (int i = indexLimitVisible;
			 i < indexLimitVisible + groupByColumnCount;
			 i++) {
				 exprColumns[i].collectAllExpressions( tempSet, Expression.aggregateFunctionSet, Expression.subqueryExpressionSet);
				 if (!tempSet.isEmpty()) {
					 throw Error.error(ErrorCode.X_42572, ((Expression) tempSet.get(0)).getSQL());
				 }
			 }
			 for (int i = 0;
			 i < indexLimitVisible;
			 i++) {
				 if (!exprColumns[i].isComposedOf( exprColumns, indexLimitVisible, indexLimitVisible + groupByColumnCount, Expression.subqueryAggregateExpressionSet)) {
					 tempSet.add(exprColumns[i]);
				 }
			 }
			 if (!tempSet.isEmpty() && !resolveForGroupBy(tempSet)) {
				 throw Error.error(ErrorCode.X_42574, ((Expression) tempSet.get(0)).getSQL());
			 }
		 }
		 else if (isAggregated) {
			 for (int i = 0;
			 i < indexLimitVisible;
			 i++) {
				 exprColumns[i].collectAllExpressions( tempSet, Expression.columnExpressionSet, Expression.aggregateFunctionSet);
				 if (!tempSet.isEmpty()) {
					 throw Error.error(ErrorCode.X_42574, ((Expression) tempSet.get(0)).getSQL());
				 }
			 }
		 }
		 tempSet.clear();
		 if (havingCondition != null) {
			 if (unresolvedExpressions != null) {
				 tempSet.addAll(unresolvedExpressions);
			 }
			 for (int i = indexLimitVisible;
			 i < indexLimitVisible + groupByColumnCount;
			 i++) {
				 tempSet.add(exprColumns[i]);
			 }
			 if (!havingCondition.isComposedOf( tempSet, Expression.subqueryAggregateExpressionSet)) {
				 throw Error.error(ErrorCode.X_42573);
			 }
			 tempSet.clear();
		 }
		 if (isDistinctSelect) {
			 int orderCount = sortAndSlice.getOrderLength();
			 for (int i = 0;
			 i < orderCount;
			 i++) {
				 Expression e = (Expression) sortAndSlice.exprList.get(i);
				 if (e.queryTableColumnIndex != -1) {
					 continue;
				 }
				 if (!e.isComposedOf(exprColumns, 0, indexLimitVisible, Expression.emptyExpressionSet)) {
					 throw Error.error(ErrorCode.X_42576);
				 }
			 }
		 }
		 if (isGrouped) {
			 int orderCount = sortAndSlice.getOrderLength();
			 for (int i = 0;
			 i < orderCount;
			 i++) {
				 Expression e = (Expression) sortAndSlice.exprList.get(i);
				 if (e.queryTableColumnIndex != -1) {
					 continue;
				 }
				 if (!e.isAggregate() && !e.isComposedOf( exprColumns, 0, indexLimitVisible + groupByColumnCount, Expression.emptyExpressionSet)) {
					 throw Error.error(ErrorCode.X_42576);
				 }
			 }
		 }
		 if (isDistinctSelect || isGrouped) {
			 simpleLimit = false;
		 }
		 if (!isAggregated) {
			 return;
		 }
		 OrderedHashSet expressions = new OrderedHashSet();
		 OrderedHashSet columnExpressions = new OrderedHashSet();
		 for (int i = indexStartAggregates;
		 i < indexLimitExpressions;
		 i++) {
			 Expression e = exprColumns[i];
			 Expression c = new ExpressionColumn(e, i, resultRangePosition);
			 expressions.add(e);
			 columnExpressions.add(c);
		 }
		 for (int i = 0;
		 i < indexStartHaving;
		 i++) {
			 if (exprColumns[i].isAggregate()) {
				 continue;
			 }
			 Expression e = exprColumns[i];
			 if (expressions.add(e)) {
				 Expression c = new ExpressionColumn(e, i, resultRangePosition);
				 columnExpressions.add(c);
			 }
		 }
		 int orderCount = sortAndSlice.getOrderLength();
		 for (int i = 0;
		 i < orderCount;
		 i++) {
			 Expression e = (Expression) sortAndSlice.exprList.get(i);
			 if (e.getLeftNode().isAggregate()) {
				 e.setAggregate();
			 }
		 }
		 for (int i = indexStartOrderBy;
		 i < indexStartAggregates;
		 i++) {
			 if (exprColumns[i].getLeftNode().isAggregate()) {
				 exprColumns[i].setAggregate();
			 }
		 }
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 Expression e = exprColumns[i];
			 if (!e.isAggregate() && !e.isCorrelated() ) {
				 continue;
			 }
			 aggregateCheck[i] = true;
			 if (e.isAggregate()) {
				 e.convertToSimpleColumn(expressions, columnExpressions);
			 }
		 }
		 for (int i = 0;
		 i < aggregateSet.size();
		 i++) {
			 Expression e = (Expression) aggregateSet.get(i);
			 e.convertToSimpleColumn(expressions, columnExpressions);
		 }
		 if (resolvedSubqueryExpressions != null) {
			 for (int i = 0;
			 i < resolvedSubqueryExpressions.size();
			 i++) {
				 Expression e = (Expression) resolvedSubqueryExpressions.get(i);
				 e.convertToSimpleColumn(expressions, columnExpressions);
			 }
		 }
	 }
	 boolean resolveForGroupBy(HsqlList unresolvedSet) {
		 for (int i = indexLimitVisible;
		 i < indexLimitVisible + groupByColumnCount;
		 i++) {
			 Expression e = exprColumns[i];
			 if (e.getType() == OpTypes.COLUMN) {
				 RangeVariable range = e.getRangeVariable();
				 int colIndex = e.getColumnIndex();
				 range.columnsInGroupBy[colIndex] = true;
			 }
		 }
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 RangeVariable range = rangeVariables[i];
			 range.hasKeyedColumnInGroupBy = range.rangeTable.getUniqueNotNullColumnGroup( range.columnsInGroupBy) != null;
		 }
		 OrderedHashSet set = null;
		 for (int i = 0;
		 i < unresolvedSet.size();
		 i++) {
			 Expression e = (Expression) unresolvedSet.get(i);
			 set = e.getUnkeyedColumns(set);
		 }
		 return set == null;
	 }
	 int[] getLimits(Session session, int maxRows) {
		 int skipRows = 0;
		 int limitRows = Integer.MAX_VALUE;
		 int limitFetch = Integer.MAX_VALUE;
		 boolean hasLimits = false;
		 if (sortAndSlice.hasLimit()) {
			 Integer value = (Integer) sortAndSlice.limitCondition.getLeftNode().getValue( session);
			 if (value == null || value.intValue() < 0) {
				 throw Error.error(ErrorCode.X_2201X);
			 }
			 skipRows = value.intValue();
			 hasLimits = skipRows != 0;
			 if (sortAndSlice.limitCondition.getRightNode() != null) {
				 value = (Integer) sortAndSlice.limitCondition.getRightNode() .getValue(session);
				 if (value == null || value.intValue() <= 0) {
					 throw Error.error(ErrorCode.X_2201W);
				 }
				 if (value.intValue() == 0) {
					 limitRows = Integer.MAX_VALUE;
				 }
				 else {
					 limitRows = value.intValue();
					 hasLimits = true;
				 }
			 }
		 }
		 if (maxRows != 0) {
			 if (maxRows < limitRows) {
				 limitRows = maxRows;
			 }
			 hasLimits = true;
		 }
		 if (hasLimits && simpleLimit && (!sortAndSlice.hasOrder() || sortAndSlice.skipSort) && (!sortAndSlice.hasLimit() || sortAndSlice.skipFullResult)) {
			 if (limitFetch - skipRows > limitRows) {
				 limitFetch = skipRows + limitRows;
			 }
		 }
		 return hasLimits ? new int[] {
		 skipRows, limitRows, limitFetch }
		 : defaultLimits;
	 }
	 Result getResult(Session session, int maxrows) {
		 Result r = getSingleResult(session, maxrows);
		 r.getNavigator().reset();
		 return r;
	 }
	 private Result getSingleResult(Session session, int maxRows) {
		 int[] limits = getLimits(session, maxRows);
		 Result r = buildResult(session, limits[2]);
		 RowSetNavigatorData navigator = (RowSetNavigatorData) r.getNavigator();
		 if (isDistinctSelect) {
			 navigator.removeDuplicates();
		 }
		 if (sortAndSlice.hasOrder()) {
			 navigator.sortOrder();
		 }
		 if (limits != defaultLimits) {
			 navigator.trim(limits[0], limits[1]);
		 }
		 return r;
	 }
	 private Result buildResult(Session session, int limitcount) {
		 RowSetNavigatorData navigator = new RowSetNavigatorData(session, (QuerySpecification) this);
		 Result result = Result.newResult(navigator);
		 result.metaData = resultMetaData;
		 if (isUpdatable) {
			 result.rsProperties = ResultProperties.updatablePropsValue;
		 }
		 if (this.isSimpleCount) {
			 Object[] data = new Object[indexLimitData];
			 Table table = rangeVariables[0].getTable();
			 PersistentStore store = table.getRowStore(session);
			 int count = table.getIndex(0).size(session, store);
			 data[0] = data[indexStartAggregates] = ValuePool.getInt(count);
			 navigator.add(data);
			 return result;
		 }
		 int fullJoinIndex = 0;
		 RangeIterator[] rangeIterators = new RangeIterator[rangeVariables.length];
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 rangeIterators[i] = rangeVariables[i].getIterator(session);
		 }
		 for (int currentIndex = 0;
		 ;
		 ) {
			 if (currentIndex < fullJoinIndex) {
				 boolean end = true;
				 for (int i = fullJoinIndex + 1;
				 i < rangeVariables.length;
				 i++) {
					 if (rangeVariables[i].isRightJoin) {
						 fullJoinIndex = i;
						 currentIndex = i;
						 end = false;
						 ((RangeIteratorRight) rangeIterators[i]) .setOnOuterRows();
						 break;
					 }
				 }
				 if (end) {
					 break;
				 }
			 }
			 RangeIterator it = rangeIterators[currentIndex];
			 if (it.next()) {
				 if (currentIndex < rangeVariables.length - 1) {
					 currentIndex++;
					 continue;
				 }
			 }
			 else {
				 it.reset();
				 currentIndex--;
				 continue;
			 }
			 session.sessionData.startRowProcessing();
			 Object[] data = new Object[indexLimitData];
			 for (int i = 0;
			 i < indexStartAggregates;
			 i++) {
				 if (isAggregated && aggregateCheck[i]) {
					 continue;
				 }
				 else {
					 data[i] = exprColumns[i].getValue(session);
				 }
			 }
			 for (int i = indexLimitVisible;
			 i < indexLimitRowId;
			 i++) {
				 if (i == indexLimitVisible) {
					 data[i] = it.getRowidObject();
				 }
				 else {
					 data[i] = it.getCurrentRow();
				 }
			 }
			 Object[] groupData = null;
			 if (isAggregated || isGrouped) {
				 groupData = navigator.getGroupData(data);
				 if (groupData != null) {
					 data = groupData;
				 }
			 }
			 for (int i = indexStartAggregates;
			 i < indexLimitExpressions;
			 i++) {
				 data[i] = exprColumns[i].updateAggregatingValue(session, data[i]);
			 }
			 if (groupData == null) {
				 navigator.add(data);
			 }
			 else if (isAggregated) {
				 navigator.update(groupData, data);
			 }
			 int rowCount = navigator.getSize();
			 if (rowCount == session.resultMaxMemoryRows && !isAggregated && !hasMemoryRow) {
				 navigator = new RowSetNavigatorDataTable(session, this, navigator);
				 result.setNavigator(navigator);
			 }
			 if (isAggregated || isGrouped) {
				 if (!sortAndSlice.isGenerated) {
					 continue;
				 }
			 }
			 if (rowCount >= limitcount) {
				 break;
			 }
		 }
		 navigator.reset();
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 rangeIterators[i].reset();
		 }
		 if (!isGrouped && !isAggregated) {
			 return result;
		 }
		 if (isAggregated) {
			 if (!isGrouped && navigator.getSize() == 0) {
				 Object[] data = new Object[exprColumns.length];
				 navigator.add(data);
			 }
			 navigator.reset();
			 session.sessionContext.setRangeIterator(navigator);
			 while (navigator.next()) {
				 Object[] data = navigator.getCurrent();
				 for (int i = indexStartAggregates;
				 i < indexLimitExpressions;
				 i++) {
					 data[i] = exprColumns[i].getAggregatedValue(session, data[i]);
				 }
				 for (int i = 0;
				 i < indexStartAggregates;
				 i++) {
					 if (aggregateCheck[i]) {
						 data[i] = exprColumns[i].getValue(session);
					 }
				 }
			 }
		 }
		 navigator.reset();
		 if (havingCondition != null) {
			 while (navigator.hasNext()) {
				 Object[] data = (Object[]) navigator.getNext();
				 if (!Boolean.TRUE.equals( data[indexLimitVisible + groupByColumnCount])) {
					 navigator.remove();
				 }
			 }
			 navigator.reset();
		 }
		 return result;
	 }
	 void setReferenceableColumns() {
		 accessibleColumns = new boolean[indexLimitVisible];
		 IntValueHashMap aliases = new IntValueHashMap();
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 Expression expression = exprColumns[i];
			 String alias = expression.getAlias();
			 if (alias.length() == 0) {
				 SimpleName name = HsqlNameManager.getAutoColumnName(i);
				 expression.setAlias(name);
				 continue;
			 }
			 int index = aliases.get(alias, -1);
			 if (index == -1) {
				 aliases.put(alias, i);
				 accessibleColumns[i] = true;
			 }
			 else {
				 accessibleColumns[index] = false;
			 }
		 }
	 }
	 void setColumnAliases(SimpleName[] names) {
		 if (names.length != indexLimitVisible) {
			 throw Error.error(ErrorCode.X_42593);
		 }
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 exprColumns[i].setAlias(names[i]);
		 }
	 }
	 private void createResultMetaData() {
		 columnTypes = new Type[indexLimitData];
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 Expression e = exprColumns[i];
			 columnTypes[i] = e.getDataType();
		 }
		 for (int i = indexLimitVisible;
		 i < indexLimitRowId;
		 i++) {
			 if (i == indexLimitVisible) {
				 columnTypes[i] = Type.SQL_BIGINT;
			 }
			 else {
				 columnTypes[i] = Type.SQL_ALL_TYPES;
			 }
		 }
		 for (int i = indexLimitRowId;
		 i < indexLimitData;
		 i++) {
			 Expression e = exprColumns[i];
			 columnTypes[i] = e.getDataType();
		 }
		 resultMetaData = ResultMetaData.newResultMetaData(columnTypes, columnMap, indexLimitVisible, indexLimitRowId);
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 Expression e = exprColumns[i];
			 resultMetaData.columnTypes[i] = e.getDataType();
			 if (i < indexLimitVisible) {
				 ColumnBase column = e.getColumn();
				 if (column != null) {
					 resultMetaData.columns[i] = column;
					 resultMetaData.columnLabels[i] = e.getAlias();
					 continue;
				 }
				 column = new ColumnBase();
				 column.setType(e.getDataType());
				 resultMetaData.columns[i] = column;
				 resultMetaData.columnLabels[i] = e.getAlias();
			 }
		 }
	 }
	 void createTable(Session session) {
		 createResultTable(session);
		 mainIndex = resultTable.getPrimaryIndex();
		 if (sortAndSlice.hasOrder() && !sortAndSlice.skipSort) {
			 orderIndex = resultTable.createAndAddIndexStructure(session, null, sortAndSlice.sortOrder, sortAndSlice.sortDescending, sortAndSlice.sortNullsLast, false, false, false);
		 }
		 if (isDistinctSelect || isFullOrder) {
			 createFullIndex(session);
		 }
		 if (isGrouped) {
			 int[] groupCols = new int[groupByColumnCount];
			 for (int i = 0;
			 i < groupByColumnCount;
			 i++) {
				 groupCols[i] = indexLimitVisible + i;
			 }
			 groupIndex = resultTable.createAndAddIndexStructure(session, null, groupCols, null, null, false, false, false);
		 }
		 else if (isAggregated) {
			 groupIndex = mainIndex;
		 }
		 if (isUpdatable && view == null) {
			 int[] idCols = new int[]{
			 indexLimitVisible }
			;
			 idIndex = resultTable.createAndAddIndexStructure(session, null, idCols, null, null, false, false, false);
		 }
	 }
	 void createFullIndex(Session session) {
		 int[] fullCols = new int[indexLimitVisible];
		 ArrayUtil.fillSequence(fullCols);
		 fullIndex = resultTable.createAndAddIndexStructure(session, null, fullCols, null, null, false, false, false);
		 resultTable.fullIndex = fullIndex;
	 }
	 void createResultTable(Session session) {
		 HsqlName tableName;
		 HashMappedList columnList;
		 int tableType;
		 tableName = session.database.nameManager.getSubqueryTableName();
		 tableType = persistenceScope == TableBase.SCOPE_STATEMENT ? TableBase.SYSTEM_SUBQUERY : TableBase.RESULT_TABLE;
		 columnList = new HashMappedList();
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 Expression e = exprColumns[i];
			 SimpleName simpleName = e.getSimpleName();
			 String nameString = simpleName.name;
			 HsqlName name = session.database.nameManager.newColumnSchemaHsqlName(tableName, simpleName);
			 if (!accessibleColumns[i]) {
				 nameString = HsqlNameManager.getAutoNoNameColumnString(i);
			 }
			 ColumnSchema column = new ColumnSchema(name, e.dataType, true, false, null);
			 columnList.add(nameString, column);
		 }
		 try {
			 resultTable = new TableDerived(session.database, tableName, tableType, columnTypes, columnList, null, null);
		 }
		 catch (Exception e) {
		}
	 }
	 public String getSQL() {
		 StringBuffer sb = new StringBuffer();
		 int limit;
		 sb.append(Tokens.T_SELECT).append(' ');
		 limit = indexLimitVisible;
		 for (int i = 0;
		 i < limit;
		 i++) {
			 if (i > 0) {
				 sb.append(',');
			 }
			 sb.append(exprColumns[i].getSQL());
		 }
		 sb.append(Tokens.T_FROM);
		 limit = rangeVariables.length;
		 for (int i = 0;
		 i < limit;
		 i++) {
			 RangeVariable rangeVar = rangeVariables[i];
			 if (i > 0) {
				 if (rangeVar.isLeftJoin && rangeVar.isRightJoin) {
					 sb.append(Tokens.T_FULL).append(' ');
				 }
				 else if (rangeVar.isLeftJoin) {
					 sb.append(Tokens.T_LEFT).append(' ');
				 }
				 else if (rangeVar.isRightJoin) {
					 sb.append(Tokens.T_RIGHT).append(' ');
				 }
				 sb.append(Tokens.T_JOIN).append(' ');
			 }
			 sb.append(rangeVar.getTable().getName().statementName);
		 }
		 if (isGrouped) {
			 sb.append(' ').append(Tokens.T_GROUP).append(' ').append( Tokens.T_BY);
			 limit = indexLimitVisible + groupByColumnCount;
			 for (int i = indexLimitVisible;
			 i < limit;
			 i++) {
				 sb.append(exprColumns[i].getSQL());
				 if (i < limit - 1) {
					 sb.append(',');
				 }
			 }
		 }
		 if (havingCondition != null) {
			 sb.append(' ').append(Tokens.T_HAVING).append(' ');
			 sb.append(havingCondition.getSQL());
		 }
		 if (sortAndSlice.hasOrder()) {
			 limit = indexStartOrderBy + sortAndSlice.getOrderLength();
			 sb.append(' ').append(Tokens.T_ORDER).append(Tokens.T_BY).append( ' ');
			 for (int i = indexStartOrderBy;
			 i < limit;
			 i++) {
				 sb.append(exprColumns[i].getSQL());
				 if (i < limit - 1) {
					 sb.append(',');
				 }
			 }
		 }
		 if (sortAndSlice.hasLimit()) {
			 sb.append(sortAndSlice.limitCondition.getLeftNode().getSQL());
		 }
		 return sb.toString();
	 }
	 public ResultMetaData getMetaData() {
		 return resultMetaData;
	 }
	 public String describe(Session session, int blanks) {
		 StringBuffer sb;
		 String temp;
		 String b = ValuePool.spaceString.substring(0, blanks);
		 sb = new StringBuffer();
		 sb.append(b).append(""isDistinctSelect=["").append( isDistinctSelect).append(""]\n"");
		 sb.append(b).append(""isGrouped=["").append(isGrouped).append(""]\n"");
		 sb.append(b).append(""isAggregated=["").append(isAggregated).append( ""]\n"");
		 sb.append(b).append(""columns=["");
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 int index = i;
			 if (exprColumns[i].getType() == OpTypes.SIMPLE_COLUMN) {
				 index = exprColumns[i].columnIndex;
			 }
			 sb.append(b).append(exprColumns[index].describe(session, 2));
		 }
		 sb.append(""\n"");
		 sb.append(b).append(""]\n"");
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 sb.append(b).append(""["");
			 sb.append(""range variable "").append(i + 1).append(""\n"");
			 sb.append(rangeVariables[i].describe(session, blanks + 2));
			 sb.append(b).append(""]"");
		 }
		 sb.append(b).append(""]\n"");
		 temp = queryCondition == null ? ""null"" : queryCondition.describe(session, blanks);
		 if (isGrouped) {
			 sb.append(b).append(""groupColumns=["");
			 for (int i = indexLimitRowId;
			 i < indexLimitRowId + groupByColumnCount;
			 i++) {
				 int index = i;
				 if (exprColumns[i].getType() == OpTypes.SIMPLE_COLUMN) {
					 index = exprColumns[i].columnIndex;
				 }
				 sb.append(exprColumns[index].describe(session, blanks));
			 }
			 sb.append(b).append(""]\n"");
		 }
		 if (havingCondition != null) {
			 temp = havingCondition.describe(session, blanks);
			 sb.append(b).append(""havingCondition=["").append(temp).append( ""]\n"");
		 }
		 if (sortAndSlice.hasOrder()) {
			 sb.append(b).append(""order by=[\n"");
			 for (int i = 0;
			 i < sortAndSlice.exprList.size();
			 i++) {
				 sb.append(b).append( ((Expression) sortAndSlice.exprList.get(i)).describe( session, blanks));
				 sb.append(b).append(""\n]"");
			 }
			 sb.append(b).append(""]\n"");
		 }
		 if (sortAndSlice.hasLimit()) {
			 if (sortAndSlice.limitCondition.getLeftNode() != null) {
				 sb.append(b).append(""offset=["").append( sortAndSlice.limitCondition.getLeftNode().describe( session, 0)).append(""]\n"");
			 }
			 if (sortAndSlice.limitCondition.getRightNode() != null) {
				 sb.append(b).append(""limit=["").append( sortAndSlice.limitCondition.getRightNode().describe( session, 0)).append(""]\n"");
			 }
		 }
		 return sb.toString();
	 }
	 void setMergeability() {
		 if (isGrouped || isDistinctSelect) {
			 isMergeable = false;
			 return;
		 }
		 if (sortAndSlice.hasLimit() || sortAndSlice.hasOrder()) {
			 isMergeable = false;
			 return;
		 }
		 if (rangeVariables.length != 1) {
			 isMergeable = false;
			 return;
		 }
	 }
	 void setUpdatability() {
		 if (!isUpdatable) {
			 return;
		 }
		 isUpdatable = false;
		 if (!isMergeable) {
			 return;
		 }
		 if (!isTopLevel) {
			 return;
		 }
		 if (isAggregated) {
			 return;
		 }
		 if (sortAndSlice.hasLimit() || sortAndSlice.hasOrder()) {
			 return;
		 }
		 RangeVariable rangeVar = rangeVariables[0];
		 Table table = rangeVar.getTable();
		 Table baseTable = table.getBaseTable();
		 if (baseTable == null) {
			 return;
		 }
		 isInsertable = table.isInsertable();
		 isUpdatable = table.isUpdatable();
		 if (!isInsertable && !isUpdatable) {
			 return;
		 }
		 IntValueHashMap columns = new IntValueHashMap();
		 boolean[] checkList;
		 int[] baseColumnMap = table.getBaseTableColumnMap();
		 int[] columnMap = new int[indexLimitVisible];
		 if (queryCondition != null) {
			 tempSet.clear();
			 collectSubQueriesAndReferences(tempSet, queryCondition);
			 if (tempSet.contains(table.getName()) || tempSet.contains(baseTable.getName())) {
				 isUpdatable = false;
				 isInsertable = false;
				 return;
			 }
		 }
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 Expression expression = exprColumns[i];
			 if (expression.getType() == OpTypes.COLUMN) {
				 String name = expression.getColumn().getName().name;
				 if (columns.containsKey(name)) {
					 columns.put(name, 1);
					 continue;
				 }
				 columns.put(name, 0);
			 }
			 else {
				 tempSet.clear();
				 collectSubQueriesAndReferences(tempSet, expression);
				 if (tempSet.contains(table.getName())) {
					 isUpdatable = false;
					 isInsertable = false;
					 return;
				 }
			 }
		 }
		 isUpdatable = false;
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 if (accessibleColumns[i]) {
				 Expression expression = exprColumns[i];
				 if (expression.getType() == OpTypes.COLUMN) {
					 String name = expression.getColumn().getName().name;
					 if (columns.get(name) == 0) {
						 int index = table.findColumn(name);
						 columnMap[i] = baseColumnMap[index];
						 if (columnMap[i] != -1) {
							 isUpdatable = true;
						 }
						 continue;
					 }
				 }
			 }
			 columnMap[i] = -1;
			 isInsertable = false;
		 }
		 if (isInsertable) {
			 checkList = baseTable.getColumnCheckList(columnMap);
			 for (int i = 0;
			 i < checkList.length;
			 i++) {
				 if (checkList[i]) {
					 continue;
				 }
				 ColumnSchema column = baseTable.getColumn(i);
				 if (column.isIdentity() || column.isGenerated() || column.hasDefault() || column.isNullable()) {
				}
				 else {
					 isInsertable = false;
					 break;
				 }
			 }
		 }
		 if (!isUpdatable) {
			 isInsertable = false;
		 }
		 if (isUpdatable) {
			 this.columnMap = columnMap;
			 this.baseTable = baseTable;
			 if (view != null) {
				 return;
			 }
			 indexLimitRowId++;
			 hasRowID = true;
			 if (!baseTable.isFileBased()) {
				 indexLimitRowId++;
				 hasMemoryRow = true;
			 }
			 indexLimitData = indexLimitRowId;
		 }
	 }
	 void mergeQuery() {
		 RangeVariable rangeVar = rangeVariables[0];
		 Table table = rangeVar.getTable();
		 Expression localQueryCondition = queryCondition;
		 if (table instanceof TableDerived) {
			 QueryExpression baseQueryExpression = ((TableDerived) table).getQueryExpression();
			 if (baseQueryExpression == null || !baseQueryExpression.isMergeable) {
				 isMergeable = false;
				 return;
			 }
			 QuerySpecification baseSelect = baseQueryExpression.getMainSelect();
			 if (baseQueryExpression.view == null) {
				 rangeVariables[0] = baseSelect.rangeVariables[0];
				 rangeVariables[0].resetConditions();
				 Expression[] newExprColumns = new Expression[indexLimitData];
				 for (int i = 0;
				 i < indexLimitData;
				 i++) {
					 Expression e = exprColumns[i];
					 newExprColumns[i] = e.replaceColumnReferences(rangeVar, baseSelect.exprColumns);
				 }
				 exprColumns = newExprColumns;
				 if (localQueryCondition != null) {
					 localQueryCondition = localQueryCondition.replaceColumnReferences(rangeVar, baseSelect.exprColumns);
				 }
				 Expression baseQueryCondition = baseSelect.queryCondition;
				 checkQueryCondition = baseSelect.checkQueryCondition;
				 queryCondition = ExpressionLogical.andExpressions(baseQueryCondition, localQueryCondition);
			 }
			 else {
				 RangeVariable[] newRangeVariables = new RangeVariable[1];
				 newRangeVariables[0] = baseSelect.rangeVariables[0].duplicate();
				 Expression[] newBaseExprColumns = new Expression[baseSelect.indexLimitData];
				 for (int i = 0;
				 i < baseSelect.indexLimitData;
				 i++) {
					 Expression e = baseSelect.exprColumns[i].duplicate();
					 newBaseExprColumns[i] = e;
					 e.replaceRangeVariables(baseSelect.rangeVariables, newRangeVariables);
				 }
				 for (int i = 0;
				 i < indexLimitData;
				 i++) {
					 Expression e = exprColumns[i];
					 exprColumns[i] = e.replaceColumnReferences(rangeVar, newBaseExprColumns);
				 }
				 Expression baseQueryCondition = baseSelect.queryCondition;
				 if (baseQueryCondition != null) {
					 baseQueryCondition = baseQueryCondition.duplicate();
					 baseQueryCondition.replaceRangeVariables( baseSelect.rangeVariables, newRangeVariables);
				 }
				 if (localQueryCondition != null) {
					 localQueryCondition = localQueryCondition.replaceColumnReferences(rangeVar, newBaseExprColumns);
				 }
				 checkQueryCondition = baseSelect.checkQueryCondition;
				 if (checkQueryCondition != null) {
					 checkQueryCondition = checkQueryCondition.duplicate();
					 checkQueryCondition.replaceRangeVariables( baseSelect.rangeVariables, newRangeVariables);
				 }
				 queryCondition = ExpressionLogical.andExpressions(baseQueryCondition, localQueryCondition);
				 rangeVariables = newRangeVariables;
			 }
		 }
		 if (view != null) {
			 switch (view.getCheckOption()) {
				 case SchemaObject.ViewCheckModes.CHECK_LOCAL : if (!isUpdatable) {
					 throw Error.error(ErrorCode.X_42537);
				 }
				 checkQueryCondition = localQueryCondition;
				 break;
				 case SchemaObject.ViewCheckModes.CHECK_CASCADE : if (!isUpdatable) {
					 throw Error.error(ErrorCode.X_42537);
				 }
				 checkQueryCondition = queryCondition;
				 break;
			 }
		 }
		 if (isAggregated) {
			 isMergeable = false;
		 }
	 }
	 static void collectSubQueriesAndReferences(OrderedHashSet set, Expression expression) {
		 expression.collectAllExpressions(set, Expression.subqueryExpressionSet, Expression.emptyExpressionSet);
		 int size = set.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 Expression e = (Expression) set.get(i);
			 e.collectObjectNames(set);
		 }
	 }
	 public OrderedHashSet getSubqueries() {
		 OrderedHashSet set = null;
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 set = exprColumns[i].collectAllSubqueries(set);
		 }
		 if (queryCondition != null) {
			 set = queryCondition.collectAllSubqueries(set);
		 }
		 if (havingCondition != null) {
			 set = havingCondition.collectAllSubqueries(set);
		 }
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 OrderedHashSet temp = rangeVariables[i].getSubqueries();
			 set = OrderedHashSet.addAll(set, temp);
		 }
		 return set;
	 }
	 public Table getBaseTable() {
		 return baseTable;
	 }
	 public OrderedHashSet collectAllSubqueries(OrderedHashSet set) {
		 return set;
	 }
	 public OrderedHashSet collectAllExpressions(OrderedHashSet set, OrderedIntHashSet typeSet, OrderedIntHashSet stopAtTypeSet) {
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 set = exprColumns[i].collectAllExpressions(set, typeSet, stopAtTypeSet);
		 }
		 if (queryCondition != null) {
			 set = queryCondition.collectAllExpressions(set, typeSet, stopAtTypeSet);
		 }
		 if (havingCondition != null) {
			 set = havingCondition.collectAllExpressions(set, typeSet, stopAtTypeSet);
		 }
		 return set;
	 }
	 public void collectObjectNames(Set set) {
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 exprColumns[i].collectObjectNames(set);
		 }
		 if (queryCondition != null) {
			 queryCondition.collectObjectNames(set);
		 }
		 if (havingCondition != null) {
			 havingCondition.collectObjectNames(set);
		 }
		 for (int i = 0, len = rangeVariables.length;
		 i < len;
		 i++) {
			 HsqlName name = rangeVariables[i].getTable().getName();
			 set.add(name);
		 }
	 }
	 public void replaceColumnReference(RangeVariable range, Expression[] list) {
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 exprColumns[i].replaceColumnReferences(range, list);
		 }
		 if (queryCondition != null) {
			 queryCondition.replaceColumnReferences(range, list);
		 }
		 if (havingCondition != null) {
			 havingCondition.replaceColumnReferences(range, list);
		 }
		 for (int i = 0, len = rangeVariables.length;
		 i < len;
		 i++) {
		 }
	 }
	 public void replaceRangeVariables(RangeVariable[] ranges, RangeVariable[] newRanges) {
		 for (int i = 0;
		 i < indexStartAggregates;
		 i++) {
			 exprColumns[i].replaceRangeVariables(ranges, newRanges);
		 }
		 if (queryCondition != null) {
			 queryCondition.replaceRangeVariables(ranges, newRanges);
		 }
		 if (havingCondition != null) {
			 havingCondition.replaceRangeVariables(ranges, newRanges);
		 }
		 for (int i = 0, len = rangeVariables.length;
		 i < len;
		 i++) {
			 rangeVariables[i].getSubqueries();
		 }
	 }
	 public void setReturningResult() {
		 setReturningResultSet();
		 acceptsSequences = true;
		 isTopLevel = true;
	 }
	 void setReturningResultSet() {
		 persistenceScope = TableBase.SCOPE_SESSION;
	 }
	 public boolean isSingleColumn() {
		 return indexLimitVisible == 1;
	 }
	 public String[] getColumnNames() {
		 String[] names = new String[indexLimitVisible];
		 for (int i = 0;
		 i < indexLimitVisible;
		 i++) {
			 names[i] = exprColumns[i].getAlias();
		 }
		 return names;
	 }
	 public Type[] getColumnTypes() {
		 if (columnTypes.length == indexLimitVisible) {
			 return columnTypes;
		 }
		 Type[] types = new Type[indexLimitVisible];
		 ArrayUtil.copyArray(columnTypes, types, types.length);
		 return types;
	 }
	 public int getColumnCount() {
		 return indexLimitVisible;
	 }
	 public int[] getBaseTableColumnMap() {
		 return columnMap;
	 }
	 public Expression getCheckCondition() {
		 return queryCondition;
	 }
	 void getBaseTableNames(OrderedHashSet set) {
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 Table rangeTable = rangeVariables[i].rangeTable;
			 HsqlName name = rangeTable.getName();
			 if (rangeTable.isReadOnly() || rangeTable.isTemp()) {
				 continue;
			 }
			 if (name.schema == SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) {
				 continue;
			 }
			 set.add(name);
		 }
	 }
	 boolean isEquivalent(QueryExpression other) {
		 if (!(other instanceof QuerySpecification)) {
			 return false;
		 }
		 QuerySpecification otherSpec = (QuerySpecification) other;
		 if (!Expression.equals(exprColumns, otherSpec.exprColumns)) {
			 return false;
		 }
		 if (!Expression.equals(queryCondition, otherSpec.queryCondition)) {
			 return false;
		 }
		 if (rangeVariables.length != otherSpec.rangeVariables.length) {
			 return false;
		 }
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 if (rangeVariables[i].getTable() != otherSpec.rangeVariables[i].getTable()) {
				 return false;
			 }
		 }
		 return true;
	 }
}",1,0,0,0
"final class SegmentReader extends IndexReader {
	 private String segment;
	 FieldInfos fieldInfos;
	 private FieldsReader fieldsReader;
	 TermInfosReader tis;
	 TermVectorsReader termVectorsReader;
	 BitVector deletedDocs = null;
	 private boolean deletedDocsDirty = false;
	 private boolean normsDirty = false;
	 private boolean undeleteAll = false;
	 InputStream freqStream;
	 InputStream proxStream;
	 CompoundFileReader cfsReader;
	 private class Norm {
		 public Norm(InputStream in, int number) {
			 this.in = in;
			 this.number = number;
		 }
		 private InputStream in;
		 private byte[] bytes;
		 private boolean dirty;
		 private int number;
		 private void reWrite() throws IOException {
			 OutputStream out = directory().createFile(segment + "".tmp"");
			 try {
				 out.writeBytes(bytes, maxDoc());
			 }
			 finally {
				 out.close();
			 }
			 String fileName = segment + "".f"" + number;
			 directory().renameFile(segment + "".tmp"", fileName);
			 this.dirty = false;
		 }
	 }
	 private Hashtable norms = new Hashtable();
	 SegmentReader(SegmentInfos sis, SegmentInfo si, boolean closeDir) throws IOException {
		 super(si.dir, sis, closeDir);
		 initialize(si);
	 }
	 SegmentReader(SegmentInfo si) throws IOException {
		 super(si.dir);
		 initialize(si);
	 }
	 private void initialize(SegmentInfo si) throws IOException {
		 segment = si.name;
		 Directory cfsDir = directory();
		 if (directory().fileExists(segment + "".cfs"")) {
			 cfsReader = new CompoundFileReader(directory(), segment + "".cfs"");
			 cfsDir = cfsReader;
		 }
		 fieldInfos = new FieldInfos(cfsDir, segment + "".fnm"");
		 fieldsReader = new FieldsReader(cfsDir, segment, fieldInfos);
		 tis = new TermInfosReader(cfsDir, segment, fieldInfos);
		 if (hasDeletions(si)) deletedDocs = new BitVector(directory(), segment + "".del"");
		 freqStream = cfsDir.openFile(segment + "".frq"");
		 proxStream = cfsDir.openFile(segment + "".prx"");
		 openNorms(cfsDir);
		 if (fieldInfos.hasVectors()) {
			 termVectorsReader = new TermVectorsReader(cfsDir, segment, fieldInfos);
		 }
	 }
	 protected final void doCommit() throws IOException {
		 if (deletedDocsDirty) {
			 deletedDocs.write(directory(), segment + "".tmp"");
			 directory().renameFile(segment + "".tmp"", segment + "".del"");
		 }
		 if(undeleteAll && directory().fileExists(segment + "".del"")){
			 directory().deleteFile(segment + "".del"");
		 }
		 if (normsDirty) {
			 Enumeration values = norms.elements();
			 while (values.hasMoreElements()) {
				 Norm norm = (Norm) values.nextElement();
				 if (norm.dirty) {
					 norm.reWrite();
				 }
			 }
		 }
		 deletedDocsDirty = false;
		 normsDirty = false;
		 undeleteAll = false;
	 }
	 protected final void doClose() throws IOException {
		 fieldsReader.close();
		 tis.close();
		 if (freqStream != null) freqStream.close();
		 if (proxStream != null) proxStream.close();
		 closeNorms();
		 if (termVectorsReader != null) termVectorsReader.close();
		 if (cfsReader != null) cfsReader.close();
	 }
	 static final boolean hasDeletions(SegmentInfo si) throws IOException {
		 return si.dir.fileExists(si.name + "".del"");
	 }
	 public boolean hasDeletions() {
		 return deletedDocs != null;
	 }
	 static final boolean usesCompoundFile(SegmentInfo si) throws IOException {
		 return si.dir.fileExists(si.name + "".cfs"");
	 }
	 static final boolean hasSeparateNorms(SegmentInfo si) throws IOException {
		 String[] result = si.dir.list();
		 String pattern = si.name + "".f"";
		 int patternLength = pattern.length();
		 for(int i = 0;
		 i < 0;
		 i++){
			 if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength))) return true;
		 }
		 return false;
	 }
	 protected final void doDelete(int docNum) throws IOException {
		 if (deletedDocs == null) deletedDocs = new BitVector(maxDoc());
		 deletedDocsDirty = true;
		 undeleteAll = false;
		 deletedDocs.set(docNum);
	 }
	 protected final void doUndeleteAll() throws IOException {
		 deletedDocs = null;
		 deletedDocsDirty = false;
		 undeleteAll = true;
	 }
	 final Vector files() throws IOException {
		 Vector files = new Vector(16);
		 final String ext[] = new String[]{
		 ""cfs"", ""fnm"", ""fdx"", ""fdt"", ""tii"", ""tis"", ""frq"", ""prx"", ""del"", ""tvx"", ""tvd"", ""tvf"", ""tvp"" }
		;
		 for (int i = 0;
		 i < ext.length;
		 i++) {
			 String name = segment + ""."" + ext[i];
			 if (directory().fileExists(name)) files.addElement(name);
		 }
		 for (int i = 0;
		 i < fieldInfos.size();
		 i++) {
			 FieldInfo fi = fieldInfos.fieldInfo(i);
			 if (fi.isIndexed) files.addElement(segment + "".f"" + i);
		 }
		 return files;
	 }
	 public final TermEnum terms() throws IOException {
		 return tis.terms();
	 }
	 public final TermEnum terms(Term t) throws IOException {
		 return tis.terms(t);
	 }
	 public final synchronized Document document(int n) throws IOException {
		 if (isDeleted(n)) throw new IllegalArgumentException (""attempt to access a deleted document"");
		 return fieldsReader.doc(n);
	 }
	 public final synchronized boolean isDeleted(int n) {
		 return (deletedDocs != null && deletedDocs.get(n));
	 }
	 public final TermDocs termDocs() throws IOException {
		 return new SegmentTermDocs(this);
	 }
	 public final TermPositions termPositions() throws IOException {
		 return new SegmentTermPositions(this);
	 }
	 public final int docFreq(Term t) throws IOException {
		 TermInfo ti = tis.get(t);
		 if (ti != null) return ti.docFreq;
		 else return 0;
	 }
	 public final int numDocs() {
		 int n = maxDoc();
		 if (deletedDocs != null) n -= deletedDocs.count();
		 return n;
	 }
	 public final int maxDoc() {
		 return fieldsReader.size();
	 }
	 public Collection getFieldNames() throws IOException {
		 Set fieldSet = new HashSet();
		 for (int i = 0;
		 i < fieldInfos.size();
		 i++) {
			 FieldInfo fi = fieldInfos.fieldInfo(i);
			 fieldSet.add(fi.name);
		 }
		 return fieldSet;
	 }
	 public Collection getFieldNames(boolean indexed) throws IOException {
		 Set fieldSet = new HashSet();
		 for (int i = 0;
		 i < fieldInfos.size();
		 i++) {
			 FieldInfo fi = fieldInfos.fieldInfo(i);
			 if (fi.isIndexed == indexed) fieldSet.add(fi.name);
		 }
		 return fieldSet;
	 }
	 public Collection getIndexedFieldNames(boolean storedTermVector) {
		 Set fieldSet = new HashSet();
		 for (int i = 0;
		 i < fieldInfos.size();
		 i++) {
			 FieldInfo fi = fieldInfos.fieldInfo(i);
			 if (fi.isIndexed == true && fi.storeTermVector == storedTermVector){
				 fieldSet.add(fi.name);
			 }
		 }
		 return fieldSet;
	 }
	 public synchronized byte[] norms(String field) throws IOException {
		 Norm norm = (Norm) norms.get(field);
		 if (norm == null) return null;
		 if (norm.bytes == null) {
			 byte[] bytes = new byte[maxDoc()];
			 norms(field, bytes, 0);
			 norm.bytes = bytes;
		 }
		 return norm.bytes;
	 }
	 protected final void doSetNorm(int doc, String field, byte value) throws IOException {
		 Norm norm = (Norm) norms.get(field);
		 if (norm == null) return;
		 norm.dirty = true;
		 normsDirty = true;
		 norms(field)[doc] = value;
	 }
	 public synchronized void norms(String field, byte[] bytes, int offset) throws IOException {
		 Norm norm = (Norm) norms.get(field);
		 if (norm == null) return;
		 if (norm.bytes != null) {
			 System.arraycopy(norm.bytes, 0, bytes, offset, maxDoc());
			 return;
		 }
		 InputStream normStream = (InputStream) norm.in.clone();
		 try {
			 normStream.seek(0);
			 normStream.readBytes(bytes, offset, maxDoc());
		 }
		 finally {
			 normStream.close();
		 }
	 }
	 private final void openNorms(Directory cfsDir) throws IOException {
		 for (int i = 0;
		 i < fieldInfos.size();
		 i++) {
			 FieldInfo fi = fieldInfos.fieldInfo(i);
			 if (fi.isIndexed) {
				 String fileName = segment + "".f"" + fi.number;
				 Directory d = directory().fileExists(fileName) ? directory() : cfsDir;
				 norms.put(fi.name, new Norm(d.openFile(fileName), fi.number));
			 }
		 }
	 }
	 private final void closeNorms() throws IOException {
		 synchronized (norms) {
			 Enumeration enumerator = norms.elements();
			 while (enumerator.hasMoreElements()) {
				 Norm norm = (Norm) enumerator.nextElement();
				 norm.in.close();
			 }
		 }
	 }
	 public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException {
		 FieldInfo fi = fieldInfos.fieldInfo(field);
		 if (fi == null || !fi.storeTermVector) return null;
		 return termVectorsReader.get(docNumber, field);
	 }
	 public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException {
		 if (termVectorsReader == null) return null;
		 return termVectorsReader.get(docNumber);
	 }
}",1,0,0,0
"public interface ShareProductWritePlatformService {
	 CommandProcessingResult createShareProduct(JsonCommand jsonCommand);
	 CommandProcessingResult updateProduct(Long productId, JsonCommand command);
	 CommandProcessingResult createShareProductDividend(Long productId, JsonCommand jsonCommand);
	 CommandProcessingResult approveShareProductDividend(Long PayOutDetailId);
	 CommandProcessingResult deleteShareProductDividend(Long PayOutDetailId);
}",0,0,0,0
"private void setupLoader() {
	 if (classpath != null && loader == null) {
		 loader = getProject().createClassLoader(classpath);
		 loader.setThreadContextLoader();
	 }
 }",0,0,0,0
"private class HeaderWrapperRequest extends HttpServletRequestWrapper {
	 private PushbackInputStream inputStream = null;
	 private ServletInputStream servletInputStream = null;
	 private HttpServletRequest origRequest = null;
	 private BufferedReader reader = null;
	 private final Map<String, String> newHeaders = new HashMap<String, String>();
	 public HeaderWrapperRequest( HttpServletRequest request ) throws IOException {
		 super( request );
		 origRequest = request;
		 inputStream = new PushbackInputStream( request.getInputStream() );
		 servletInputStream = new DelegatingServletInputStream( inputStream );
	 }
	 private void adapt() throws IOException {
		 String path = origRequest.getRequestURI();
		 String method = origRequest.getMethod();
		 if (logger.isTraceEnabled()) {
			 logger.trace(""Content path is '{
			}
			'"", path);
		 }
		 Enumeration acceptHeaders = origRequest.getHeaders( HttpHeaders.ACCEPT );
		 if ( !acceptHeaders.hasMoreElements() ) {
			 setHeader( HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON );
		 }
		 int initial = inputStream.read();
		 if ( initial == -1 ) {
			 if ( ( HttpMethod.POST.equals( method ) || HttpMethod.PUT.equals( method ) ) && !MediaType.APPLICATION_FORM_URLENCODED.equals( getContentType() ) ) {
				 if (logger.isTraceEnabled()) {
					 logger.trace(""Setting content type to application/json for POST or PUT with no content at path '{
					}
					'"", path);
				 }
				 setHeader( HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON );
				 setHeader( HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON );
			 }
			 return;
		 }
		 char firstChar = ( char ) initial;
		 if ( ( firstChar == '{
			' || firstChar == '[' ) && !MediaType.APPLICATION_JSON.equals( getContentType() )) {
				 if (logger.isTraceEnabled()) {
					 logger.trace(""Setting content type to application/json for POST or PUT with json content at path '{
					}
					'"", path);
				 }
				 setHeader( HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON );
				 setHeader( HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON );
			 }
			 inputStream.unread( initial );
		 }
		 public void setHeader( String name, String value ) {
			 newHeaders.put( name.toLowerCase(), value );
		 }
		 public String getHeader( String name ) {
			 String header = newHeaders.get( name );
			 if ( header != null ) {
				 return header;
			 }
			 return super.getHeader( name );
		 }
		 public Enumeration getHeaders( String name ) {
			 Set<String> headers = new LinkedHashSet<String>();
			 String overridden = newHeaders.get( name );
			 if ( overridden != null ) {
				 headers.add( overridden );
				 return Collections.enumeration( headers );
			 }
			 return super.getHeaders( name );
		 }
		 public Enumeration getHeaderNames() {
			 Set<String> headers = new LinkedHashSet<String>();
			 for ( Enumeration e = super.getHeaderNames();
			 e.hasMoreElements();
			 ) {
				 headers.add( e.nextElement().toString() );
			 }
			 headers.addAll( newHeaders.keySet() );
			 return Collections.enumeration( headers );
		 }
		 public ServletInputStream getInputStream() throws IOException {
			 return servletInputStream;
		 }
		 public BufferedReader getReader() throws IOException {
			 if ( reader != null ) {
				 return reader;
			 }
			 reader = new BufferedReader( new InputStreamReader( servletInputStream ) );
			 return reader;
		 }
	 }",0,0,0,0
"public static void start() {
	 DavGatewaySSLProtocolSocketFactory.register();
	 DavGatewayHttpClientFacade.start();
	 SERVER_LIST.clear();
	 int smtpPort = Settings.getIntProperty(""davmail.smtpPort"");
	 if (smtpPort != 0) {
		 SERVER_LIST.add(new SmtpServer(smtpPort));
	 }
	 int popPort = Settings.getIntProperty(""davmail.popPort"");
	 if (popPort != 0) {
		 SERVER_LIST.add(new PopServer(popPort));
	 }
	 int imapPort = Settings.getIntProperty(""davmail.imapPort"");
	 if (imapPort != 0) {
		 SERVER_LIST.add(new ImapServer(imapPort));
	 }
	 int caldavPort = Settings.getIntProperty(""davmail.caldavPort"");
	 if (caldavPort != 0) {
		 SERVER_LIST.add(new CaldavServer(caldavPort));
	 }
	 int ldapPort = Settings.getIntProperty(""davmail.ldapPort"");
	 if (ldapPort != 0) {
		 SERVER_LIST.add(new LdapServer(ldapPort));
	 }
	 BundleMessage.BundleMessageList messages = new BundleMessage.BundleMessageList();
	 BundleMessage.BundleMessageList errorMessages = new BundleMessage.BundleMessageList();
	 for (AbstractServer server : SERVER_LIST) {
		 try {
			 server.bind();
			 server.start();
			 messages.add(new BundleMessage(""LOG_PROTOCOL_PORT"", server.getProtocolName(), server.getPort()));
		 }
		 catch (DavMailException e) {
			 errorMessages.add(e.getBundleMessage());
		 }
		 catch (IOException e) {
			 errorMessages.add(new BundleMessage(""LOG_SOCKET_BIND_FAILED"", server.getProtocolName(), server.getPort()));
		 }
	 }
	 final String currentVersion = getCurrentVersion();
	 boolean showStartupBanner = Settings.getBooleanProperty(""davmail.showStartupBanner"", true);
	 if (showStartupBanner) {
		 DavGatewayTray.info(new BundleMessage(""LOG_DAVMAIL_GATEWAY_LISTENING"", currentVersion == null ? """" : currentVersion, messages));
	 }
	 if (!errorMessages.isEmpty()) {
		 DavGatewayTray.error(new BundleMessage(""LOG_MESSAGE"", errorMessages));
	 }
	 new Thread(""CheckRelease"") {
		 public void run() {
			 String releasedVersion = getReleasedVersion();
			 if (currentVersion != null && currentVersion.length() > 0 && releasedVersion != null && currentVersion.compareTo(releasedVersion) < 0) {
				 DavGatewayTray.info(new BundleMessage(""LOG_NEW_VERSION_AVAILABLE"", releasedVersion));
			 }
		 }
	 }
	.start();
 }",0,0,1,0
"public class JGitInfoCommand extends AbstractCommand implements GitCommand{
	 protected ScmResult executeCommand( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters ) throws ScmException {
		 Git git = null;
		 try {
			 File basedir = fileSet.getBasedir();
			 git = Git.open( basedir );
			 ObjectId objectId = git.getRepository().resolve( ""HEAD"" );
			 InfoItem infoItem = new InfoItem();
			 infoItem.setRevision( StringUtils.trim( objectId.name() ) );
			 infoItem.setURL( basedir.toPath().toUri().toASCIIString() );
			 return new InfoScmResult( Collections.singletonList( infoItem ), new ScmResult( ""JGit.resolve(HEAD)"", """", objectId.toString(), true ) );
		 }
		 catch ( Exception e ) {
			 throw new ScmException( ""JGit resolve failure!"", e );
		 }
		 finally {
			 JGitUtils.closeRepo( git );
		 }
	 }
}",0,0,0,0
private void writeObject(ObjectOutputStream stream) throws IOException;,0,0,0,0
"protected HashMap<String, String> buildEtagHeader(String etag) {
	 if (etag != null) {
		 HashMap<String, String> etagHeader = new HashMap<String, String>();
		 etagHeader.put(""ETag"", etag);
		 return etagHeader;
	 }
	 else {
		 return null;
	 }
 }",0,0,0,0
void updateName();,0,0,0,0
"public class jsXe {
	 public static final String MIN_JAVA_VERSION = ""1.4.2"";
	 public static final String MIN_XERCES_VERSION = ""Xerces-J 2.7.0"";
	 public static void main(String args[]) {
		 try {
			 long startTime = System.currentTimeMillis();
			 String javaVersion = System.getProperty(""java.version"");
			 if(javaVersion.compareTo(MIN_JAVA_VERSION) < 0) {
				 System.err.println(getAppTitle() + "": ERROR: You are running Java version "" + javaVersion + ""."");
				 System.err.println(getAppTitle() + "": ERROR:"" + getAppTitle()+"" requires Java ""+MIN_JAVA_VERSION+"" or later."");
				 System.exit(1);
			 }
			 m_homeDirectory = System.getProperty(""user.home"");
			 String fileSep = System.getProperty(""file.separator"");
			 m_settingsDirectory = m_homeDirectory+fileSep+"".jsxe"";
			 File _settingsDirectory = new File(m_settingsDirectory);
			 if(!_settingsDirectory.exists()) _settingsDirectory.mkdirs();
			 String pluginsDirectory = m_settingsDirectory+""/jars"";
			 File _pluginsDirectory = new File(pluginsDirectory);
			 if(!_pluginsDirectory.exists()) _pluginsDirectory.mkdirs();
			 String jsXeHome = System.getProperty(""jsxe.home"");
			 if (jsXeHome == null) {
				 String classpath = System.getProperty(""java.class.path"");
				 int index = classpath.toLowerCase().indexOf(""jsxe.jar"");
				 int start = classpath.lastIndexOf(File.pathSeparator,index) + 1;
				 if (classpath.equalsIgnoreCase(""jsxe.jar"")) {
					 jsXeHome = System.getProperty(""user.dir"");
				 }
				 else {
					 if(index > start) {
						 jsXeHome = classpath.substring(start, index - 1);
					 }
					 else {
						 jsXeHome = System.getProperty(""user.dir"");
					 }
				 }
			 }
			 Messages.initializePropertiesObject(null, jsXeHome+fileSep+""messages"");
			 initDefaultProps();
			 String viewname = null;
			 ArrayList files = new ArrayList();
			 boolean debug = false;
			 for (int i=0;
			 i<args.length;
			 i++) {
				 if (args[i].equals(""--help"") || args[i].equals(""-h"")) {
					 printUsage();
					 System.exit(0);
				 }
				 if (args[i].equals(""--version"") || args[i].equals(""-V"")) {
					 System.out.println(getVersion());
					 System.exit(0);
				 }
				 if (args[i].equals(""--debug"")) {
					 debug = true;
				 }
				 else {
					 files.add(args[i]);
				 }
			 }
			 ProgressSplashScreenWindow progressScreen = new ProgressSplashScreenWindow();
			 int w = progressScreen.getSize().width;
			 int h = progressScreen.getSize().height;
			 Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
			 int x = (dim.width-w)/2;
			 int y = (dim.height-h)/2;
			 progressScreen.setLocation(x, y);
			 progressScreen.setVisible(true);
			 Log.init(true, Log.ERROR, debug);
			 try {
				 BufferedWriter stream = new BufferedWriter(new FileWriter(getSettingsDirectory()+fileSep+""jsXe.log""));
				 stream.flush();
				 stream.write(""Log file created on "" + new Date());
				 stream.write(System.getProperty(""line.separator""));
				 Log.setLogWriter(stream);
			 }
			 catch (IOException ioe) {
				 Log.log(Log.ERROR, jsXe.class, ioe);
			 }
			 progressScreen.updateSplashScreenDialog(10);
			 String xercesVersion = org.apache.xerces.impl.Version.getVersion();
			 if (MiscUtilities.compareStrings(xercesVersion, MIN_XERCES_VERSION, false) < 0) {
				 String msg = Messages.getMessage(""No.Xerces.Error"", new String[] {
				 MIN_XERCES_VERSION }
				);
				 Log.log(Log.ERROR, jsXe.class, msg);
				 JOptionPane.showMessageDialog(null, msg, Messages.getMessage(""No.Xerces.Error.Title"", new String[] {
				 MIN_XERCES_VERSION }
				), JOptionPane.WARNING_MESSAGE);
				 System.exit(1);
			 }
			 progressScreen.updateSplashScreenDialog(20);
			 File recentFiles = new File(getSettingsDirectory(), ""recent.xml"");
			 m_bufferHistory = new BufferHistory();
			 try {
				 m_bufferHistory.load(recentFiles);
			 }
			 catch (IOException ioe) {
				 System.err.println(getAppTitle() + "": I/O ERROR: Could not open recent files list"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+ioe.toString());
			 }
			 catch (SAXException saxe) {
				 System.err.println(getAppTitle() + "": I/O ERROR: recent.xml not formatted properly"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+saxe.toString());
			 }
			 catch (ParserConfigurationException pce) {
				 System.err.println(getAppTitle() + "": I/O ERROR: Could not parse recent.xml"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+pce.toString());
			 }
			 progressScreen.updateSplashScreenDialog(30);
			 Log.log(Log.NOTICE, jsXe.class, ""Loading plugins"");
			 m_pluginLoader = new JARClassLoader();
			 Log.log(Log.NOTICE, jsXe.class, ""Adding to plugin search path: ""+pluginsDirectory);
			 ArrayList pluginMessages = m_pluginLoader.addDirectory(pluginsDirectory);
			 Log.log(Log.NOTICE, jsXe.class, ""Adding to plugin search path: ""+jsXeHome+fileSep+""jars"");
			 pluginMessages.addAll(m_pluginLoader.addDirectory(jsXeHome+fileSep+""jars""));
			 progressScreen.updateSplashScreenDialog(40);
			 Log.log(Log.NOTICE, jsXe.class, ""Starting plugins"");
			 pluginMessages.addAll(m_pluginLoader.startPlugins());
			 Vector pluginErrors = new Vector();
			 if (pluginMessages.size() != 0) {
				 for (int i=0;
				 i<pluginMessages.size();
				 i++) {
					 Object error = pluginMessages.get(i);
					 if ((error instanceof IOException) || (error instanceof PluginDependencyException)) {
						 Log.log(Log.ERROR, jsXe.class, ((Exception)error).getMessage());
						 pluginErrors.add(((Exception)error).getMessage());
					 }
					 else {
						 if (error instanceof PluginLoadException) {
							 Log.log(Log.WARNING, jsXe.class, ((PluginLoadException)error).getMessage());
						 }
						 else {
							 Log.log(Log.WARNING, jsXe.class, error.toString());
						 }
					 }
				 }
			 }
			 progressScreen.updateSplashScreenDialog(50);
			 Iterator pluginItr = m_pluginLoader.getAllPlugins().iterator();
			 while (pluginItr.hasNext()) {
				 ActionPlugin plugin = (ActionPlugin)pluginItr.next();
				 Properties props = plugin.getProperties();
				 Enumeration names = props.propertyNames();
				 while (names.hasMoreElements()) {
					 String name = names.nextElement().toString();
					 setProperty(name, props.getProperty(name));
				 }
				 addActionSet(plugin.getActionSet());
			 }
			 progressScreen.updateSplashScreenDialog(60);
			 File properties = new File(getSettingsDirectory(),""properties"");
			 try {
				 FileInputStream filestream = new FileInputStream(properties);
				 props.load(filestream);
			 }
			 catch (FileNotFoundException fnfe) {
				 Log.log(Log.MESSAGE, jsXe.class, ""User has no properties file. Running jsXe for the first time?"");
			 }
			 catch (IOException ioe) {
				 System.err.println(getAppTitle() + "": I/O ERROR: Could not open settings file"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+ioe.toString());
			 }
			 CatalogManager.propertiesChanged();
			 progressScreen.updateSplashScreenDialog(70);
			 Log.log(Log.NOTICE, jsXe.class, ""Starting the main window"");
			 TabbedView tabbedview = null;
			 DocumentBuffer defaultBuffer = null;
			 try {
				 defaultBuffer = new DocumentBuffer();
				 m_buffers.add(defaultBuffer);
				 if (viewname == null) {
					 tabbedview = new TabbedView(defaultBuffer);
				 }
				 else {
					 try {
						 tabbedview = new TabbedView(defaultBuffer, viewname);
					 }
					 catch (UnrecognizedPluginException e) {
						 Log.log(Log.ERROR, jsXe.class, e.getMessage());
						 System.exit(1);
					 }
				 }
			 }
			 catch (IOException ioe) {
				 Log.log(Log.ERROR, jsXe.class, ioe);
				 JOptionPane.showMessageDialog(null, ioe.getMessage()+""."", Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
				 System.exit(1);
			 }
			 m_activeView = tabbedview;
			 progressScreen.updateSplashScreenDialog(85);
			 Log.log(Log.NOTICE, jsXe.class, ""Parsing files to open on command line"");
			 if (files.size() > 0) {
				 if (openXMLDocuments(tabbedview, (String[])files.toArray(new String[] {
				}
				))) {
					 try {
						 closeDocumentBuffer(tabbedview, defaultBuffer);
					 }
					 catch (IOException ioe) {
					 }
				 }
			 }
			 progressScreen.updateSplashScreenDialog(100);
			 tabbedview.setVisible(true);
			 progressScreen.dispose();
			 if (pluginErrors.size() > 0) {
				 new ErrorListDialog(tabbedview, ""Plugin Error"", ""The following plugins could not be loaded:"", new Vector(pluginErrors), true);
			 }
			 Log.log(Log.NOTICE, jsXe.class, ""jsXe started in ""+(System.currentTimeMillis()-startTime)+"" milliseconds"");
		 }
		 catch (Throwable e) {
			 exiterror(null, e, 1);
		 }
	 }
	 public static String getBuild() {
		 String major = buildProps.getProperty(""major.version"");
		 String minor = buildProps.getProperty(""minor.version"");
		 String beta = buildProps.getProperty(""beta.version"");
		 String bugfix = buildProps.getProperty(""build.version"");
		 if (major.length() == 1) {
			 major = ""0""+major;
		 }
		 if (minor.length() == 1) {
			 minor = ""0""+minor;
		 }
		 if (beta.length() == 1) {
			 beta = ""0""+beta;
		 }
		 if (bugfix.length() == 1) {
			 bugfix = ""0""+bugfix;
		 }
		 return major+"".""+ minor+"".""+ beta+"".""+ bugfix;
	 }
	 public static Date getBuildDate() {
		 String buildTime = buildProps.getProperty(""build.time"");
		 try {
			 SimpleDateFormat format = new SimpleDateFormat(""MM.dd.yyyy HH:mm:ss z"");
			 return format.parse(buildTime);
		 }
		 catch (ParseException e) {
			 Log.log(Log.ERROR, jsXe.class, e);
		 }
		 return null;
	 }
	 public static String getVersion() {
		 return MiscUtilities.buildToVersion(getBuild());
	 }
	 public static ImageIcon getIcon() {
		 return jsXeIcon;
	 }
	 public static String getSettingsDirectory() {
		 return m_settingsDirectory;
	 }
	 public static String getAppTitle() {
		 return buildProps.getProperty(""application.name"");
	 }
	 public static TabbedView getActiveView() {
		 return m_activeView;
	 }
	 public static boolean showOpenFileDialog(TabbedView view) throws IOException {
		 DocumentBuffer buffer = view.getDocumentBuffer();
		 File docFile = buffer.getFile();
		 JFileChooser loadDialog;
		 if (docFile == null) {
			 loadDialog = new jsxeFileDialog(m_homeDirectory);
		 }
		 else {
			 loadDialog = new jsxeFileDialog(docFile);
		 }
		 loadDialog.setMultiSelectionEnabled(true);
		 int returnVal = loadDialog.showOpenDialog(view);
		 if (returnVal == JFileChooser.APPROVE_OPTION) {
			 boolean success = false;
			 File[] files = loadDialog.getSelectedFiles();
			 for (int i = 0;
			 i < files.length;
			 i++) {
				 if (files[i] != null) {
					 try {
						 success = openXMLDocument(view, files[i]) || success;
					 }
					 catch (IOException ioe) {
						 Log.log(Log.WARNING, jsXe.class, ioe);
						 JOptionPane.showMessageDialog(view, ioe, Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
					 }
				 }
			 }
			 return success;
		 }
		 return false;
	 }
	 public static boolean openXMLDocument(TabbedView view, File file) throws IOException {
		 BufferHistory.BufferHistoryEntry entry = m_bufferHistory.getEntry(file.getPath());
		 if (entry != null) {
			 return openXMLDocument(view, file, entry.getProperties(), entry.getViewName());
		 }
		 else {
			 return openXMLDocument(view, file, new Properties(), null);
		 }
	 }
	 public static boolean openXMLDocument(TabbedView view, File file, Properties properties, String viewName) throws IOException {
		 if (file == null) return false;
		 DocumentBuffer buffer = getOpenBuffer(file);
		 if (buffer != null) {
			 view.setDocumentBuffer(buffer);
			 return true;
		 }
		 else {
			 Log.log(Log.NOTICE, jsXe.class, ""Loading file ""+file.getName());
			 try {
				 buffer = new DocumentBuffer(file, properties);
				 m_buffers.add(buffer);
				 if (viewName != null) {
					 try {
						 view.addDocumentBuffer(buffer, viewName);
					 }
					 catch (IOException ioe) {
						 view.addDocumentBuffer(buffer);
					 }
					 catch (UnrecognizedPluginException e) {
						 view.addDocumentBuffer(buffer);
					 }
				 }
				 else {
					 view.addDocumentBuffer(buffer);
				 }
				 DocumentBuffer[] buffers = getDocumentBuffers();
				 if (buffers.length == 2 && buffers[0].isUntitled() && !buffers[0].getStatus(DocumentBuffer.DIRTY)) {
					 closeDocumentBuffer(view, buffers[0]);
				 }
				 return true;
			 }
			 catch (IOException ioe) {
				 m_buffers.remove(buffer);
				 throw ioe;
			 }
		 }
	 }
	 public static boolean openXMLDocument(TabbedView view, String doc) throws IOException {
		 return openXMLDocument(view, new ByteArrayInputStream(doc.getBytes(""UTF-8"")));
	 }
	 public static boolean openXMLDocument(TabbedView view, InputStream stream) throws IOException {
		 Log.log(Log.NOTICE, jsXe.class, ""Loading Untitled Document"");
		 DocumentBuffer buffer = new DocumentBuffer(stream);
		 try {
			 m_buffers.add(buffer);
			 view.addDocumentBuffer(buffer);
			 return true;
		 }
		 catch (IOException ioe) {
			 m_buffers.remove(buffer);
			 throw ioe;
		 }
	 }
	 public static DocumentBuffer getOpenBuffer(File file) {
		 boolean caseInsensitiveFilesystem = (File.separatorChar == '\\' || File.separatorChar == ':' );
		 for(int i=0;
		 i < m_buffers.size();
		i++) {
			 try {
				 DocumentBuffer buffer = (DocumentBuffer)m_buffers.get(i);
				 if (buffer.equalsOnDisk(file)) {
					 return buffer;
				 }
			 }
			 catch (IOException ioe) {
				 exiterror(null, ioe, 1);
			 }
		 }
		 return null;
	 }
	 public static boolean closeDocumentBuffer(TabbedView view, DocumentBuffer buffer) throws IOException {
		 return closeDocumentBuffer(view, buffer, true);
	 }
	 public static boolean closeDocumentBuffer(TabbedView view, DocumentBuffer buffer, boolean confirmClose) throws IOException {
		 if (m_buffers.contains(buffer)) {
			 if (buffer.close(view, confirmClose)) {
				 Log.log(Log.NOTICE, jsXe.class, ""Closing ""+buffer.getName());
				 m_bufferHistory.setEntry(buffer, getPluginLoader().getPluginProperty(view.getDocumentView().getViewPlugin(), JARClassLoader.PLUGIN_NAME));
				 view.removeDocumentBuffer(buffer);
				 m_buffers.remove(buffer);
				 if (view.getBufferCount() == 0) {
					 if (!m_exiting) {
						 try {
							 openXMLDocument(view, getDefaultDocument());
						 }
						 catch (IOException ioe) {
							 exiterror(view, ""Could not open default document."", 1);
						 }
					 }
				 }
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 else {
			 return false;
		 }
	 }
	 public static boolean closeAllDocumentBuffers(TabbedView view) throws IOException {
		 DocumentBuffer[] buffers = jsXe.getDocumentBuffers();
		 ArrayList dirtyBufferList = new ArrayList();
		 for (int i=0;
		 i < buffers.length;
		 i++) {
			 DocumentBuffer db= buffers[i];
			 if (db.getStatus(DocumentBuffer.DIRTY)) {
				 dirtyBufferList.add(db);
			 }
		 }
		 boolean closeFiles = true;
		 if (dirtyBufferList.size() > 0) {
			 if (dirtyBufferList.size() > 1) {
				 DirtyFilesDialog dirtyDialog = new DirtyFilesDialog(view, dirtyBufferList);
				 dirtyDialog.setSize(200, 400);
				 dirtyDialog.setResizable(true);
				 closeFiles = !dirtyDialog.getCancelFlag();
			 }
			 else {
				 closeFiles = closeDocumentBuffer(view, (DocumentBuffer)dirtyBufferList.get(0), true);
			 }
		 }
		 if (closeFiles) {
			 buffers = jsXe.getDocumentBuffers();
			 for (int i=0;
			 i < buffers.length;
			 i++) {
				 if (!closeDocumentBuffer(view, buffers[i], false)) {
					 return false;
				 }
			 }
		 }
		 return closeFiles;
	 }
	 public static BufferHistory getBufferHistory() {
		 return m_bufferHistory;
	 }
	 public static InputStream getDefaultDocument() {
		 try {
			 return new ByteArrayInputStream(DefaultDocument.getBytes(""UTF-8""));
		 }
		 catch (UnsupportedEncodingException e) {
			 Log.log(Log.ERROR, jsXe.class, ""Broken JVM doesn't support UTF-8"");
			 Log.log(Log.ERROR, jsXe.class, e);
			 return null;
		 }
	 }
	 public static DocumentBuffer[] getDocumentBuffers() {
		 DocumentBuffer[] buffers = new DocumentBuffer[m_buffers.size()];
		 for (int i=0;
		 i < m_buffers.size();
		 i++) {
			 buffers[i] = (DocumentBuffer)m_buffers.get(i);
		 }
		 return buffers;
	 }
	 public static void exit(TabbedView view) {
		 m_exiting = true;
		 try {
			 if (view.close()) {
				 Log.log(Log.NOTICE, jsXe.class, ""Exiting"");
				 CatalogManager.save();
				 String settingsDirectory = getSettingsDirectory();
				 try {
					 File properties = new File(settingsDirectory,""properties"");
					 FileOutputStream filestream = new FileOutputStream(properties);
					 props.store(filestream, ""Autogenerated jsXe properties""+System.getProperty(""line.separator"")+""#This file is not really meant to be edited."");
				 }
				 catch (IOException ioe) {
					 exiterror(view, ""Could not save jsXe properites.\n""+ioe.toString(), 1);
				 }
				 catch (ClassCastException cce) {
					 exiterror(view, ""Could not save jsXe properties.\n""+cce.toString(), 1);
				 }
				 try {
					 File recentFiles = new File(settingsDirectory, ""recent.xml"");
					 m_bufferHistory.save(recentFiles);
				 }
				 catch (IOException ioe) {
					 exiterror(view, ""Could not save jsXe recent files list.\n""+ioe.toString(), 1);
				 }
				 Log.closeStream();
				 System.exit(0);
			 }
			 else {
				 m_exiting = false;
			 }
		 }
		 catch (IOException ioe) {
			 Log.log(Log.ERROR, jsXe.class, ioe);
			 JOptionPane.showMessageDialog(view, ioe, Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
			 m_exiting = false;
		 }
	 }
	 public static void exiterror(Object source, Object error, int errorcode) {
		 String errorhdr = ""jsXe has encountered a fatal error and is unable to continue.\n"";
		 errorhdr +=""This is most likely a bug and should be reported to the jsXe\n"";
		 errorhdr +=""developers. Please include your jsXe.log in a bug report at\n"";
		 errorhdr +=""http: Log.log(Log.ERROR, source, errorhdr);
		 Log.log(Log.ERROR, source, error);
		 if (source != null && source instanceof Component) {
			 JOptionPane.showMessageDialog((Component)source, errorhdr + error, ""Fatal Error"", JOptionPane.WARNING_MESSAGE);
		 }
		 Log.closeStream();
		 System.exit(errorcode);
	 }
	 public static Object setProperty(String key, String value) {
		 if (value == null) {
			 props.remove(key);
			 return null;
		 }
		 else {
			 return props.setProperty(key, value);
		 }
	 }
	 public static final String getDefaultProperty(String key) {
		 return defaultProps.getProperty(key);
	 }
	 public static final String getProperty(String key) {
		 return getProperty(key, null);
	 }
	 public static final String getProperty(String key, String defaultValue) {
		 return props.getProperty(key, defaultProps.getProperty(key, defaultValue));
	 }
	 public static final int getIntegerProperty(String key, int defaultValue) {
		 int intValue = defaultValue;
		 String value = getProperty(key);
		 if (value == null) {
			 return defaultValue;
		 }
		 else {
			 try {
				 return Integer.parseInt(value.trim());
			 }
			 catch(NumberFormatException nf) {
				 return defaultValue;
			 }
		 }
	 }
	 public static final void setIntegerProperty(String name, int value) {
		 setProperty(name, String.valueOf(value));
	 }
	 public static final boolean getBooleanProperty(String name, boolean defaultValue) {
		 boolean booleanValue = defaultValue;
		 String value = getProperty(name);
		 if (value == null) {
			 return defaultValue;
		 }
		 else {
			 return Boolean.valueOf(value).booleanValue();
		 }
	 }
	 public static final void setBooleanProperty(String name, boolean value) {
		 setProperty(name, String.valueOf(value));
	 }
	 public static void addActionSet(ActionSet set) {
		 m_actionSets.add(set);
	 }
	 public static Action getAction(String name) {
		 for (int i = 0;
		 i < m_actionSets.size();
		 i++) {
			 Action action = ((ActionSet)m_actionSets.get(i)).getAction(name);
			 if (action != null) {
				 return action;
			 }
		 }
		 return null;
	 }
	 public ArrayList getActionSets() {
		 return m_actionSets;
	 }
	 public static final OptionsPanel getOptionsPanel() {
		 jsXeOptions = new jsXeOptionsPanel();
		 return jsXeOptions;
	 }
	 public static JARClassLoader getPluginLoader() {
		 return m_pluginLoader;
	 }
	 public static final boolean isExiting() {
		 return m_exiting;
	 }
	 private jsXe() {
	}
	 private static boolean openXMLDocuments(TabbedView view, String args[]) {
		 boolean success = false;
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (args[i] != null) {
				 try {
					 Log.log(Log.NOTICE, jsXe.class, ""Trying to open ""+args[i]);
					 success = openXMLDocument(view, new File(args[i])) || success;
				 }
				 catch (IOException ioe) {
					 Log.log(Log.WARNING, jsXe.class, ioe);
					 JOptionPane.showMessageDialog(view, ioe, Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
				 }
			 }
		 }
		 return success;
	 }
	 private static void initDefaultProps() {
		 InputStream inputstream = jsXe.class.getResourceAsStream(""/net/sourceforge/jsxe/properties"");
		 try {
			 defaultProps.load(inputstream);
		 }
		 catch (IOException ioe) {
			 Log.log(Log.ERROR, jsXe.class, ""**** Could not open default settings file ****"");
			 Log.log(Log.ERROR, jsXe.class, ""**** jsXe was probably not built correctly ****"");
			 exiterror(null, ioe, 1);
		 }
		 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		 int windowWidth = (int)(screenSize.getWidth() / 2);
		 int windowHeight = (int)(3 * screenSize.getHeight() / 4);
		 int x = (int)(screenSize.getWidth() / 4);
		 int y = (int)(screenSize.getHeight() / 8);
		 defaultProps.setProperty(""tabbedview.height"",Integer.toString(windowHeight));
		 defaultProps.setProperty(""tabbedview.width"",Integer.toString(windowWidth));
		 defaultProps.setProperty(""tabbedview.x"",Integer.toString(x));
		 defaultProps.setProperty(""tabbedview.y"",Integer.toString(y));
		 inputstream = jsXe.class.getResourceAsStream(""/net/sourceforge/jsxe/build.properties"");
		 try {
			 buildProps.load(inputstream);
		 }
		 catch (IOException ioe) {
			 Log.log(Log.ERROR, jsXe.class, ""**** Could not open build properties file ****"");
			 Log.log(Log.ERROR, jsXe.class, ""**** jsXe was probably not built correctly ****"");
			 exiterror(null, ioe, 1);
		 }
	 }
	 private static class jsXeOptionsPanel extends OptionsPanel {
		 public jsXeOptionsPanel() {
			 GridBagLayout layout = new GridBagLayout();
			 GridBagConstraints constraints = new GridBagConstraints();
			 setLayout(layout);
			 int gridY = 0;
			 int maxRecentFiles = 20;
			 try {
				 maxRecentFiles = Integer.parseInt(jsXe.getProperty(""max.recent.files""));
			 }
			 catch (NumberFormatException nfe) {
				 try {
					 maxRecentFiles = Integer.parseInt(jsXe.getDefaultProperty(""max.recent.files""));
				 }
				 catch (NumberFormatException nfe2) {
					 Log.log(Log.ERROR, jsXe.class, ""Could not read max.recent.files property"");
				 }
			 }
			 JLabel maxRecentFilesLabel = new JLabel(Messages.getMessage(""Global.Options.Max.Recent.Files""));
			 maxRecentFilesLabel.setToolTipText(Messages.getMessage(""Global.Options.Max.Recent.Files.ToolTip""));
			 Vector sizes = new Vector(4);
			 sizes.add(""10"");
			 sizes.add(""20"");
			 sizes.add(""30"");
			 sizes.add(""40"");
			 maxRecentFilesComboBox = new JComboBox(sizes);
			 maxRecentFilesComboBox.setEditable(true);
			 maxRecentFilesComboBox.setSelectedItem(Integer.toString(maxRecentFiles));
			 maxRecentFilesComboBox.setToolTipText(Messages.getMessage(""Global.Options.Max.Recent.Files.ToolTip""));
			 JLabel networkLabel = new JLabel(Messages.getMessage(""Global.Options.network""));
			 String[] networkValues = {
			 Messages.getMessage(""Global.Options.network-always""), Messages.getMessage(""Global.Options.network-cache""), Messages.getMessage(""Global.Options.network-off"") }
			;
			 network = new JComboBox(networkValues);
			 network.setSelectedIndex(jsXe.getIntegerProperty(""xml.cache"", 1));
			 constraints.gridy = gridY;
			 constraints.gridx = 0;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(maxRecentFilesLabel, constraints);
			 add(maxRecentFilesLabel);
			 constraints.gridy = gridY++;
			 constraints.gridx = 1;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(maxRecentFilesComboBox, constraints);
			 add(maxRecentFilesComboBox);
			 constraints.gridy = gridY;
			 constraints.gridx = 0;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(networkLabel, constraints);
			 add(networkLabel);
			 constraints.gridy = gridY++;
			 constraints.gridx = 1;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(network, constraints);
			 add(network);
		 }
		 public String getName() {
			 return ""jsxeoptions"";
		 }
		 public void save() {
			 try {
				 jsXe.setProperty(""max.recent.files"", (new Integer(maxRecentFilesComboBox.getSelectedItem().toString())).toString());
			 }
			 catch (NumberFormatException nfe) {
			 }
			 jsXe.setIntegerProperty(""xml.cache"",network.getSelectedIndex());
			 CatalogManager.propertiesChanged();
		 }
		 public String getTitle() {
			 return Messages.getMessage(""Global.Options.Title"");
		 }
		 public String toString() {
			 return getTitle();
		 }
		 private JComboBox maxRecentFilesComboBox;
		 private JComboBox network;
	 }
	 private static void printUsage() {
		 System.out.println(""jsXe ""+getVersion());
		 System.out.println(""The Java Simple XML Editor"");
		 System.out.println();
		 System.out.println(""Copyright 2004 Ian Lewis"");
		 System.out.println(""This is free software;
		 see the source for copying conditions. There is NO"");
		 System.out.println(""warranty;
		 not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."");
		 System.out.println();
		 System.out.println(""Usage: jsXe [<options>] [<files>]"");
		 System.out.println("" --debug print debug information"");
		 System.out.println("" -h, --help display this help and exit"");
		 System.out.println("" -V, --version print version information and exit"");
		 System.out.println();
		 System.out.println(""Report bugs to <ian_lewis>"");
	 }
	 private static ArrayList m_buffers = new ArrayList();
	 private static final String DefaultDocument = ""<?xml version='1.0' encoding='UTF-8'?>\n<default_element>default_node</default_element>"";
	 private static final ImageIcon jsXeIcon = new ImageIcon(jsXe.class.getResource(""/net/sourceforge/jsxe/icons/jsxe.jpg""), ""jsXe"");
	 private static final Properties buildProps = new Properties();
	 private static boolean m_exiting=false;
	 private static final Properties defaultProps = new Properties();
	 private static Properties props = new Properties();
	 private static BufferHistory m_bufferHistory;
	 private static ArrayList m_actionSets = new ArrayList();
	 private static JARClassLoader m_pluginLoader;
	 private static TabbedView m_activeView;
	 private static String m_settingsDirectory;
	 private static String m_homeDirectory;
	 private static OptionsPanel jsXeOptions;
}",1,0,0,0
"public static class NamespaceFilter extends XMLFilterImpl {
	 private static final InputSource EMPTY_INPUT_SOURCE = new InputSource(new ByteArrayInputStream(new byte[0]));
	 public NamespaceFilter(XMLReader xmlReader) {
		 super(xmlReader);
	 }
	 public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
		 return EMPTY_INPUT_SOURCE;
	 }
 }",0,1,0,0
"abstract class _ListIsolationSegmentSpacesRelationshipResponse {
	 abstract List<Relationship> getData();
	 abstract Map<String, Link> getLinks();
}",0,0,0,0
"public void run(final Logger log){
	final Iterator<Entry> itor = modifiableToEntry.values().iterator();
	while (itor.hasNext()){
		final Entry entry = itor.next();
		final Time modifiableLastModified = entry.modifiable.lastModifiedTime();
		if ((modifiableLastModified != null) &&modifiableLastModified.after(entry.lastModifiedTime)){
			entry.listeners.notifyListeners();
			entry.lastModifiedTime = modifiableLastModified;
		}
	}
}",0,0,0,0
"public class Node{
	 public static final int FUNCTION_PROP = 1, LOCAL_PROP = 2, LOCAL_BLOCK_PROP = 3, REGEXP_PROP = 4, CASEARRAY_PROP = 5, TARGETBLOCK_PROP = 6, VARIABLE_PROP = 7, ISNUMBER_PROP = 8, DIRECTCALL_PROP = 9, SPECIALCALL_PROP = 10, SKIP_INDEXES_PROP = 11, OBJECT_IDS_PROP = 12, INCRDECR_PROP = 13, CATCH_SCOPE_PROP = 14, LABEL_ID_PROP = 15, MEMBER_TYPE_PROP = 16, NAME_PROP = 17, CONTROL_BLOCK_PROP = 18, PARENTHESIZED_PROP = 19, LAST_PROP = 19;
	 public static final int BOTH = 0, LEFT = 1, RIGHT = 2;
	 public static final int NON_SPECIALCALL = 0, SPECIALCALL_EVAL = 1, SPECIALCALL_WITH = 2;
	 public static final int DECR_FLAG = 0x1, POST_FLAG = 0x2;
	 public static final int PROPERTY_FLAG = 0x1, ATTRIBUTE_FLAG = 0x2, DESCENDANTS_FLAG = 0x4;
	 private static class NumberNode extends Node {
		 NumberNode(double number) {
			 super(Token.NUMBER);
			 this.number = number;
		 }
		 double number;
	 }
	 private static class StringNode extends Node {
		 StringNode(int type, String str) {
			 super(type);
			 this.str = str;
		 }
		 String str;
	 }
	 public static class Jump extends Node {
		 public Jump(int type) {
			 super(type);
		 }
		 Jump(int type, int lineno) {
			 super(type, lineno);
		 }
		 Jump(int type, Node child) {
			 super(type, child);
		 }
		 Jump(int type, Node child, int lineno) {
			 super(type, child, lineno);
		 }
		 public final Jump getJumpStatement() {
			 if (!(type == Token.BREAK || type == Token.CONTINUE)) Kit.codeBug();
			 return jumpNode;
		 }
		 public final void setJumpStatement(Jump jumpStatement) {
			 if (!(type == Token.BREAK || type == Token.CONTINUE)) Kit.codeBug();
			 if (jumpStatement == null) Kit.codeBug();
			 if (this.jumpNode != null) Kit.codeBug();
			 this.jumpNode = jumpStatement;
		 }
		 public final Node getDefault() {
			 if (!(type == Token.SWITCH)) Kit.codeBug();
			 return target2;
		 }
		 public final void setDefault(Node defaultTarget) {
			 if (!(type == Token.SWITCH)) Kit.codeBug();
			 if (defaultTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = defaultTarget;
		 }
		 public final Node getFinally() {
			 if (!(type == Token.TRY)) Kit.codeBug();
			 return target2;
		 }
		 public final void setFinally(Node finallyTarget) {
			 if (!(type == Token.TRY)) Kit.codeBug();
			 if (finallyTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = finallyTarget;
		 }
		 public final Jump getLoop() {
			 if (!(type == Token.LABEL)) Kit.codeBug();
			 return jumpNode;
		 }
		 public final void setLoop(Jump loop) {
			 if (!(type == Token.LABEL)) Kit.codeBug();
			 if (loop == null) Kit.codeBug();
			 if (jumpNode != null) Kit.codeBug();
			 jumpNode = loop;
		 }
		 public final Node getContinue() {
			 if (type != Token.LOOP) Kit.codeBug();
			 return target2;
		 }
		 public final void setContinue(Node continueTarget) {
			 if (type != Token.LOOP) Kit.codeBug();
			 if (continueTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = continueTarget;
		 }
		 public Node target;
		 private Node target2;
		 private Jump jumpNode;
	 }
	 private static class PropListItem {
		 PropListItem next;
		 int type;
		 int intValue;
		 Object objectValue;
	 }
	 public Node(int nodeType) {
		 type = nodeType;
	 }
	 public Node(int nodeType, Node child) {
		 type = nodeType;
		 first = last = child;
		 child.next = null;
	 }
	 public Node(int nodeType, Node left, Node right) {
		 type = nodeType;
		 first = left;
		 last = right;
		 left.next = right;
		 right.next = null;
	 }
	 public Node(int nodeType, Node left, Node mid, Node right) {
		 type = nodeType;
		 first = left;
		 last = right;
		 left.next = mid;
		 mid.next = right;
		 right.next = null;
	 }
	 public Node(int nodeType, int line) {
		 type = nodeType;
		 lineno = line;
	 }
	 public Node(int nodeType, Node child, int line) {
		 this(nodeType, child);
		 lineno = line;
	 }
	 public Node(int nodeType, Node left, Node right, int line) {
		 this(nodeType, left, right);
		 lineno = line;
	 }
	 public Node(int nodeType, Node left, Node mid, Node right, int line) {
		 this(nodeType, left, mid, right);
		 lineno = line;
	 }
	 public static Node newNumber(double number) {
		 return new NumberNode(number);
	 }
	 public static Node newString(String str) {
		 return new StringNode(Token.STRING, str);
	 }
	 public static Node newString(int type, String str) {
		 return new StringNode(type, str);
	 }
	 public int getType() {
		 return type;
	 }
	 public void setType(int type) {
		 this.type = type;
	 }
	 public boolean hasChildren() {
		 return first != null;
	 }
	 public Node getFirstChild() {
		 return first;
	 }
	 public Node getLastChild() {
		 return last;
	 }
	 public Node getNext() {
		 return next;
	 }
	 public Node getChildBefore(Node child) {
		 if (child == first) return null;
		 Node n = first;
		 while (n.next != child) {
			 n = n.next;
			 if (n == null) throw new RuntimeException(""node is not a child"");
		 }
		 return n;
	 }
	 public Node getLastSibling() {
		 Node n = this;
		 while (n.next != null) {
			 n = n.next;
		 }
		 return n;
	 }
	 public void addChildToFront(Node child) {
		 child.next = first;
		 first = child;
		 if (last == null) {
			 last = child;
		 }
	 }
	 public void addChildToBack(Node child) {
		 child.next = null;
		 if (last == null) {
			 first = last = child;
			 return;
		 }
		 last.next = child;
		 last = child;
	 }
	 public void addChildrenToFront(Node children) {
		 Node lastSib = children.getLastSibling();
		 lastSib.next = first;
		 first = children;
		 if (last == null) {
			 last = lastSib;
		 }
	 }
	 public void addChildrenToBack(Node children) {
		 if (last != null) {
			 last.next = children;
		 }
		 last = children.getLastSibling();
		 if (first == null) {
			 first = children;
		 }
	 }
	 public void addChildBefore(Node newChild, Node node) {
		 if (newChild.next != null) throw new RuntimeException( ""newChild had siblings in addChildBefore"");
		 if (first == node) {
			 newChild.next = first;
			 first = newChild;
			 return;
		 }
		 Node prev = getChildBefore(node);
		 addChildAfter(newChild, prev);
	 }
	 public void addChildAfter(Node newChild, Node node) {
		 if (newChild.next != null) throw new RuntimeException( ""newChild had siblings in addChildAfter"");
		 newChild.next = node.next;
		 node.next = newChild;
		 if (last == node) last = newChild;
	 }
	 public void removeChild(Node child) {
		 Node prev = getChildBefore(child);
		 if (prev == null) first = first.next;
		 else prev.next = child.next;
		 if (child == last) last = prev;
		 child.next = null;
	 }
	 public void replaceChild(Node child, Node newChild) {
		 newChild.next = child.next;
		 if (child == first) {
			 first = newChild;
		 }
		 else {
			 Node prev = getChildBefore(child);
			 prev.next = newChild;
		 }
		 if (child == last) last = newChild;
		 child.next = null;
	 }
	 public void replaceChildAfter(Node prevChild, Node newChild) {
		 Node child = prevChild.next;
		 newChild.next = child.next;
		 prevChild.next = newChild;
		 if (child == last) last = newChild;
		 child.next = null;
	 }
	 private static final String propToString(int propType) {
		 if (Token.printTrees) {
			 switch (propType) {
				 case FUNCTION_PROP: return ""function"";
				 case LOCAL_PROP: return ""local"";
				 case LOCAL_BLOCK_PROP: return ""local_block"";
				 case REGEXP_PROP: return ""regexp"";
				 case CASEARRAY_PROP: return ""casearray"";
				 case TARGETBLOCK_PROP: return ""targetblock"";
				 case VARIABLE_PROP: return ""variable"";
				 case ISNUMBER_PROP: return ""isnumber"";
				 case DIRECTCALL_PROP: return ""directcall"";
				 case SPECIALCALL_PROP: return ""specialcall"";
				 case SKIP_INDEXES_PROP: return ""skip_indexes"";
				 case OBJECT_IDS_PROP: return ""object_ids_prop"";
				 case INCRDECR_PROP: return ""incrdecr_prop"";
				 case CATCH_SCOPE_PROP: return ""catch_scope_prop"";
				 case LABEL_ID_PROP: return ""label_id_prop"";
				 case MEMBER_TYPE_PROP: return ""member_type_prop"";
				 case NAME_PROP: return ""name_prop"";
				 case CONTROL_BLOCK_PROP: return ""control_block_prop"";
				 case PARENTHESIZED_PROP: return ""parenthesized_prop"";
				 default: Kit.codeBug();
			 }
		 }
		 return null;
	 }
	 private PropListItem lookupProperty(int propType) {
		 PropListItem x = propListHead;
		 while (x != null && propType != x.type) {
			 x = x.next;
		 }
		 return x;
	 }
	 private PropListItem ensureProperty(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 item = new PropListItem();
			 item.type = propType;
			 item.next = propListHead;
			 propListHead = item;
		 }
		 return item;
	 }
	 public void removeProp(int propType) {
		 PropListItem x = propListHead;
		 if (x != null) {
			 PropListItem prev = null;
			 while (x.type != propType) {
				 prev = x;
				 x = x.next;
				 if (x == null) {
					 return;
				 }
			 }
			 if (prev == null) {
				 propListHead = x.next;
			 }
			 else {
				 prev.next = x.next;
			 }
		 }
	 }
	 public Object getProp(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 return null;
		 }
		 return item.objectValue;
	 }
	 public int getIntProp(int propType, int defaultValue) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 return defaultValue;
		 }
		 return item.intValue;
	 }
	 public int getExistingIntProp(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 Kit.codeBug();
		 }
		 return item.intValue;
	 }
	 public void putProp(int propType, Object prop) {
		 if (prop == null) {
			 removeProp(propType);
		 }
		 else {
			 PropListItem item = ensureProperty(propType);
			 item.objectValue = prop;
		 }
	 }
	 public void putIntProp(int propType, int prop) {
		 PropListItem item = ensureProperty(propType);
		 item.intValue = prop;
	 }
	 public int getLineno() {
		 return lineno;
	 }
	 public final double getDouble() {
		 return ((NumberNode)this).number;
	 }
	 public final void setDouble(double number) {
		 ((NumberNode)this).number = number;
	 }
	 public final String getString() {
		 return ((StringNode)this).str;
	 }
	 public final void setString(String s) {
		 if (s == null) Kit.codeBug();
		 ((StringNode)this).str = s;
	 }
	 public static Node newTarget() {
		 return new Node(Token.TARGET);
	 }
	 public final int labelId() {
		 if (type != Token.TARGET) Kit.codeBug();
		 return getIntProp(LABEL_ID_PROP, -1);
	 }
	 public void labelId(int labelId) {
		 if (type != Token.TARGET) Kit.codeBug();
		 putIntProp(LABEL_ID_PROP, labelId);
	 }
	 static final int END_UNREACHED = 0;
	 static final int END_DROPS_OFF = 1;
	 static final int END_RETURNS = 2;
	 static final int END_RETURNS_VALUE = 4;
	 public boolean hasConsistentReturnUsage() {
		 int n = endCheck();
		 return (n & END_RETURNS_VALUE) == 0 || (n & (END_DROPS_OFF|END_RETURNS)) == 0;
	 }
	 private int endCheckIf() {
		 Node th, el;
		 int rv = END_UNREACHED;
		 th = next;
		 el = ((Jump)this).target;
		 rv = th.endCheck();
		 if (el != null) rv |= el.endCheck();
		 else rv |= END_DROPS_OFF;
		 return rv;
	 }
	 private int endCheckSwitch() {
		 Node n;
		 int rv = END_UNREACHED;
		 for (n = first.next;
		 n != null;
		 n = n.next) {
			 if (n.type == Token.CASE) {
				 rv |= ((Jump)n).target.endCheck();
			 }
			 else break;
		 }
		 rv &= ~END_DROPS_OFF;
		 n = ((Jump)this).getDefault();
		 if (n != null) rv |= n.endCheck();
		 else rv |= END_DROPS_OFF;
		 rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);
		 return rv;
	 }
	 private int endCheckTry() {
		 Node n;
		 int rv = END_UNREACHED;
		 n = ((Jump)this).getFinally();
		 if(n != null) {
			 rv = n.next.first.endCheck();
		 }
		 else {
			 rv = END_DROPS_OFF;
		 }
		 if ((rv & END_DROPS_OFF) != 0) {
			 rv &= ~END_DROPS_OFF;
			 rv |= first.endCheck();
			 n = ((Jump)this).target;
			 if (n != null) {
				 for (n = n.next.first;
				 n != null;
				 n = n.next.next) {
					 rv |= n.next.first.next.first.endCheck();
				 }
			 }
		 }
		 return rv;
	 }
	 private int endCheckLoop() {
		 Node n;
		 int rv = END_UNREACHED;
		 for (n = first;
		 n.next != last;
		 n = n.next) ;
		 if (n.type != Token.IFEQ) return END_DROPS_OFF;
		 rv = ((Jump)n).target.next.endCheck();
		 if (n.first.type == Token.TRUE) rv &= ~END_DROPS_OFF;
		 rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);
		 return rv;
	 }
	 private int endCheckBlock() {
		 Node n;
		 int rv = END_DROPS_OFF;
		 for (n=first;
		 ((rv & END_DROPS_OFF) != 0) && n != null;
		 n = n.next) {
			 rv &= ~END_DROPS_OFF;
			 rv |= n.endCheck();
		 }
		 return rv;
	 }
	 private int endCheckLabel() {
		 int rv = END_UNREACHED;
		 rv = next.endCheck();
		 rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);
		 return rv;
	 }
	 private int endCheckBreak() {
		 Node n = ((Jump) this).jumpNode;
		 n.putIntProp(CONTROL_BLOCK_PROP, END_DROPS_OFF);
		 return END_UNREACHED;
	 }
	 private int endCheck() {
		 switch(type) {
			 case Token.BREAK: return endCheckBreak();
			 case Token.CONTINUE: case Token.THROW: return END_UNREACHED;
			 case Token.RETURN: if (this.first != null) return END_RETURNS_VALUE;
			 else return END_RETURNS;
			 case Token.TARGET: if (next != null) return next.endCheck();
			 else return END_DROPS_OFF;
			 case Token.LOOP: return endCheckLoop();
			 case Token.LOCAL_BLOCK: case Token.BLOCK: if (first == null) return END_DROPS_OFF;
			 switch(first.type) {
				 case Token.LABEL: return first.endCheckLabel();
				 case Token.IFNE: return first.endCheckIf();
				 case Token.SWITCH: return first.endCheckSwitch();
				 case Token.TRY: return first.endCheckTry();
				 default: return endCheckBlock();
			 }
			 default: return END_DROPS_OFF;
		 }
	 }
	 public boolean hasSideEffects() {
		 switch (type) {
			 case Token.EXPR_VOID: case Token.COMMA: if (last != null) return last.hasSideEffects();
			 else return true;
			 case Token.HOOK: if (first == null || first.next == null || first.next.next == null) Kit.codeBug();
			 return first.next.hasSideEffects() && first.next.next.hasSideEffects();
			 case Token.ERROR: case Token.EXPR_RESULT: case Token.ASSIGN: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ENTERWITH: case Token.LEAVEWITH: case Token.RETURN: case Token.GOTO: case Token.IFEQ: case Token.IFNE: case Token.NEW: case Token.DELPROP: case Token.SETNAME: case Token.SETPROP: case Token.SETELEM: case Token.CALL: case Token.THROW: case Token.RETHROW: case Token.SETVAR: case Token.CATCH_SCOPE: case Token.RETURN_RESULT: case Token.SET_REF: case Token.DEL_REF: case Token.REF_CALL: case Token.TRY: case Token.SEMI: case Token.INC: case Token.DEC: case Token.EXPORT: case Token.IMPORT: case Token.IF: case Token.ELSE: case Token.SWITCH: case Token.WHILE: case Token.DO: case Token.FOR: case Token.BREAK: case Token.CONTINUE: case Token.VAR: case Token.CONST: case Token.WITH: case Token.CATCH: case Token.FINALLY: case Token.BLOCK: case Token.LABEL: case Token.TARGET: case Token.LOOP: case Token.JSR: case Token.SETPROP_OP: case Token.SETELEM_OP: case Token.LOCAL_BLOCK: case Token.SET_REF_OP: return true;
			 default: return false;
		 }
	 }
	 public String toString() {
		 if (Token.printTrees) {
			 StringBuffer sb = new StringBuffer();
			 toString(new ObjToIntMap(), sb);
			 return sb.toString();
		 }
		 return String.valueOf(type);
	 }
	 private void toString(ObjToIntMap printIds, StringBuffer sb) {
		 if (Token.printTrees) {
			 sb.append(Token.name(type));
			 if (this instanceof StringNode) {
				 sb.append(' ');
				 sb.append(getString());
			 }
			 else if (this instanceof ScriptOrFnNode) {
				 ScriptOrFnNode sof = (ScriptOrFnNode)this;
				 if (this instanceof FunctionNode) {
					 FunctionNode fn = (FunctionNode)this;
					 sb.append(' ');
					 sb.append(fn.getFunctionName());
				 }
				 sb.append("" [source name: "");
				 sb.append(sof.getSourceName());
				 sb.append(""] [encoded source length: "");
				 sb.append(sof.getEncodedSourceEnd() - sof.getEncodedSourceStart());
				 sb.append(""] [base line: "");
				 sb.append(sof.getBaseLineno());
				 sb.append(""] [end line: "");
				 sb.append(sof.getEndLineno());
				 sb.append(']');
			 }
			 else if (this instanceof Jump) {
				 Jump jump = (Jump)this;
				 if (type == Token.BREAK || type == Token.CONTINUE) {
					 sb.append("" [label: "");
					 appendPrintId(jump.getJumpStatement(), printIds, sb);
					 sb.append(']');
				 }
				 else if (type == Token.TRY) {
					 Node catchNode = jump.target;
					 Node finallyTarget = jump.getFinally();
					 if (catchNode != null) {
						 sb.append("" [catch: "");
						 appendPrintId(catchNode, printIds, sb);
						 sb.append(']');
					 }
					 if (finallyTarget != null) {
						 sb.append("" [finally: "");
						 appendPrintId(finallyTarget, printIds, sb);
						 sb.append(']');
					 }
				 }
				 else if (type == Token.LABEL || type == Token.LOOP || type == Token.SWITCH) {
					 sb.append("" [break: "");
					 appendPrintId(jump.target, printIds, sb);
					 sb.append(']');
					 if (type == Token.LOOP) {
						 sb.append("" [continue: "");
						 appendPrintId(jump.getContinue(), printIds, sb);
						 sb.append(']');
					 }
				 }
				 else {
					 sb.append("" [target: "");
					 appendPrintId(jump.target, printIds, sb);
					 sb.append(']');
				 }
			 }
			 else if (type == Token.NUMBER) {
				 sb.append(' ');
				 sb.append(getDouble());
			 }
			 else if (type == Token.TARGET) {
				 sb.append(' ');
				 appendPrintId(this, printIds, sb);
			 }
			 if (lineno != -1) {
				 sb.append(' ');
				 sb.append(lineno);
			 }
			 for (PropListItem x = propListHead;
			 x != null;
			 x = x.next) {
				 int type = x.type;
				 sb.append("" ["");
				 sb.append(propToString(type));
				 sb.append("": "");
				 String value;
				 switch (type) {
					 case TARGETBLOCK_PROP : value = ""target block property"";
					 break;
					 case LOCAL_BLOCK_PROP : value = ""last local block"";
					 break;
					 case ISNUMBER_PROP: switch (x.intValue) {
						 case BOTH: value = ""both"";
						 break;
						 case RIGHT: value = ""right"";
						 break;
						 case LEFT: value = ""left"";
						 break;
						 default: throw Kit.codeBug();
					 }
					 break;
					 case SPECIALCALL_PROP: switch (x.intValue) {
						 case SPECIALCALL_EVAL: value = ""eval"";
						 break;
						 case SPECIALCALL_WITH: value = ""with"";
						 break;
						 default: throw Kit.codeBug();
					 }
					 break;
					 default : Object obj = x.objectValue;
					 if (obj != null) {
						 value = obj.toString();
					 }
					 else {
						 value = String.valueOf(x.intValue);
					 }
					 break;
				 }
				 sb.append(value);
				 sb.append(']');
			 }
		 }
	 }
	 public String toStringTree(ScriptOrFnNode treeTop) {
		 if (Token.printTrees) {
			 StringBuffer sb = new StringBuffer();
			 toStringTreeHelper(treeTop, this, null, 0, sb);
			 return sb.toString();
		 }
		 return null;
	 }
	 private static void toStringTreeHelper(ScriptOrFnNode treeTop, Node n, ObjToIntMap printIds, int level, StringBuffer sb) {
		 if (Token.printTrees) {
			 if (printIds == null) {
				 printIds = new ObjToIntMap();
				 generatePrintIds(treeTop, printIds);
			 }
			 for (int i = 0;
			 i != level;
			 ++i) {
				 sb.append("" "");
			 }
			 n.toString(printIds, sb);
			 sb.append('\n');
			 for (Node cursor = n.getFirstChild();
			 cursor != null;
			 cursor = cursor.getNext()) {
				 if (cursor.getType() == Token.FUNCTION) {
					 int fnIndex = cursor.getExistingIntProp(Node.FUNCTION_PROP);
					 FunctionNode fn = treeTop.getFunctionNode(fnIndex);
					 toStringTreeHelper(fn, fn, null, level + 1, sb);
				 }
				 else {
					 toStringTreeHelper(treeTop, cursor, printIds, level + 1, sb);
				 }
			 }
		 }
	 }
	 private static void generatePrintIds(Node n, ObjToIntMap map) {
		 if (Token.printTrees) {
			 map.put(n, map.size());
			 for (Node cursor = n.getFirstChild();
			 cursor != null;
			 cursor = cursor.getNext()) {
				 generatePrintIds(cursor, map);
			 }
		 }
	 }
	 private static void appendPrintId(Node n, ObjToIntMap printIds, StringBuffer sb) {
		 if (Token.printTrees) {
			 if (n != null) {
				 int id = printIds.get(n, -1);
				 sb.append('#');
				 if (id != -1) {
					 sb.append(id + 1);
				 }
				 else {
					 sb.append(""<not_available>"");
				 }
			 }
		 }
	 }
	 int type;
	 Node next;
	 private Node first;
	 private Node last;
	 private int lineno = -1;
	 private PropListItem propListHead;
}",1,0,0,0
"class LinkFrame implements Serializable {
	 private static final long serialVersionUID = 1L;
	 LinkFrame next;
	 Map<OLink, LinkInfo> links = new HashMap<OLink, LinkInfo>();
	 LinkFrame(LinkFrame next) {
		 this.next = next;
	 }
	 LinkInfo resolve(OLink link) {
		 LinkInfo li = links.get(link);
		 if (li == null && next != null) return next.resolve(link);
		 return li;
	 }
}",0,0,0,0
"public class MetadataTableUtil {
	 private static final Text EMPTY_TEXT = new Text();
	 private static final byte[] EMPTY_BYTES = new byte[0];
	 private static Map<Credentials,Writer> root_tables = new HashMap<>();
	 private static Map<Credentials,Writer> metadata_tables = new HashMap<>();
	 private static final Logger log = LoggerFactory.getLogger(MetadataTableUtil.class);
	 private MetadataTableUtil() {
	}
	 public static synchronized Writer getMetadataTable(ServerContext context) {
		 Credentials credentials = context.getCredentials();
		 Writer metadataTable = metadata_tables.get(credentials);
		 if (metadataTable == null) {
			 metadataTable = new Writer(context, MetadataTable.ID);
			 metadata_tables.put(credentials, metadataTable);
		 }
		 return metadataTable;
	 }
	 public static synchronized Writer getRootTable(ServerContext context) {
		 Credentials credentials = context.getCredentials();
		 Writer rootTable = root_tables.get(credentials);
		 if (rootTable == null) {
			 rootTable = new Writer(context, RootTable.ID);
			 root_tables.put(credentials, rootTable);
		 }
		 return rootTable;
	 }
	 public static void putLockID(ServerContext context, ZooLock zooLock, Mutation m) {
		 TabletsSection.ServerColumnFamily.LOCK_COLUMN.put(m, new Value(zooLock.getLockID().serialize(context.getZooKeeperRoot() + ""/"").getBytes(UTF_8)));
	 }
	 private static void update(ServerContext context, Mutation m, KeyExtent extent) {
		 update(context, null, m, extent);
	 }
	 public static void update(ServerContext context, ZooLock zooLock, Mutation m, KeyExtent extent) {
		 Writer t = extent.isMeta() ? getRootTable(context) : getMetadataTable(context);
		 update(context, t, zooLock, m);
	 }
	 public static void update(ServerContext context, Writer t, ZooLock zooLock, Mutation m) {
		 if (zooLock != null) putLockID(context, zooLock, m);
		 while (true) {
			 try {
				 t.update(m);
				 return;
			 }
			 catch (AccumuloException | TableNotFoundException | AccumuloSecurityException e) {
				 log.error(""{
				}
				"", e.getMessage(), e);
			 }
			 catch (ConstraintViolationException e) {
				 log.error(""{
				}
				"", e.getMessage(), e);
				 throw new RuntimeException(e);
			 }
			 sleepUninterruptibly(1, TimeUnit.SECONDS);
		 }
	 }
	 public static void updateTabletFlushID(KeyExtent extent, long flushID, ServerContext context, ZooLock zooLock) {
		 if (!extent.isRootTablet()) {
			 Mutation m = new Mutation(extent.getMetadataEntry());
			 TabletsSection.ServerColumnFamily.FLUSH_COLUMN.put(m, new Value((flushID + """").getBytes(UTF_8)));
			 update(context, zooLock, m, extent);
		 }
	 }
	 public static void updateTabletCompactID(KeyExtent extent, long compactID, ServerContext context, ZooLock zooLock) {
		 if (!extent.isRootTablet()) {
			 Mutation m = new Mutation(extent.getMetadataEntry());
			 TabletsSection.ServerColumnFamily.COMPACT_COLUMN.put(m, new Value((compactID + """").getBytes(UTF_8)));
			 update(context, zooLock, m, extent);
		 }
	 }
	 public static void updateTabletDataFile(long tid, KeyExtent extent, Map<FileRef,DataFileValue> estSizes, String time, ServerContext context, ZooLock zooLock) {
		 Mutation m = new Mutation(extent.getMetadataEntry());
		 byte[] tidBytes = Long.toString(tid).getBytes(UTF_8);
		 for (Entry<FileRef,DataFileValue> entry : estSizes.entrySet()) {
			 Text file = entry.getKey().meta();
			 m.put(DataFileColumnFamily.NAME, file, new Value(entry.getValue().encode()));
			 m.put(TabletsSection.BulkFileColumnFamily.NAME, file, new Value(tidBytes));
		 }
		 TabletsSection.ServerColumnFamily.TIME_COLUMN.put(m, new Value(time.getBytes(UTF_8)));
		 update(context, zooLock, m, extent);
	 }
	 public static void updateTabletDir(KeyExtent extent, String newDir, ServerContext context, ZooLock lock) {
		 Mutation m = new Mutation(extent.getMetadataEntry());
		 TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(newDir.getBytes(UTF_8)));
		 update(context, lock, m, extent);
	 }
	 public static void addTablet(KeyExtent extent, String path, ServerContext context, char timeType, ZooLock lock) {
		 Mutation m = extent.getPrevRowUpdateMutation();
		 TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(path.getBytes(UTF_8)));
		 TabletsSection.ServerColumnFamily.TIME_COLUMN.put(m, new Value((timeType + ""0"").getBytes(UTF_8)));
		 update(context, lock, m, extent);
	 }
	 public static void updateTabletVolumes(KeyExtent extent, List<LogEntry> logsToRemove, List<LogEntry> logsToAdd, List<FileRef> filesToRemove, SortedMap<FileRef,DataFileValue> filesToAdd, String newDir, ZooLock zooLock, ServerContext context) {
		 if (extent.isRootTablet()) {
			 if (newDir != null) throw new IllegalArgumentException(""newDir not expected for "" + extent);
			 if (filesToRemove.size() != 0 || filesToAdd.size() != 0) throw new IllegalArgumentException(""files not expected for "" + extent);
			 for (LogEntry logEntry : logsToAdd) addRootLogEntry(context, zooLock, logEntry);
			 removeUnusedWALEntries(context, extent, logsToRemove, zooLock);
		 }
		 else {
			 Mutation m = new Mutation(extent.getMetadataEntry());
			 for (LogEntry logEntry : logsToRemove) m.putDelete(logEntry.getColumnFamily(), logEntry.getColumnQualifier());
			 for (LogEntry logEntry : logsToAdd) m.put(logEntry.getColumnFamily(), logEntry.getColumnQualifier(), logEntry.getValue());
			 for (FileRef fileRef : filesToRemove) m.putDelete(DataFileColumnFamily.NAME, fileRef.meta());
			 for (Entry<FileRef,DataFileValue> entry : filesToAdd.entrySet()) m.put(DataFileColumnFamily.NAME, entry.getKey().meta(), new Value(entry.getValue().encode()));
			 if (newDir != null) ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(newDir.getBytes(UTF_8)));
			 update(context, m, extent);
		 }
	 }
	 private interface ZooOperation {
		 void run(IZooReaderWriter rw) throws KeeperException, InterruptedException, IOException;
	 }
	 private static void retryZooKeeperUpdate(ServerContext context, ZooLock zooLock, ZooOperation op) {
		 while (true) {
			 try {
				 IZooReaderWriter zoo = context.getZooReaderWriter();
				 if (zoo.isLockHeld(zooLock.getLockID())) {
					 op.run(zoo);
				 }
				 break;
			 }
			 catch (Exception e) {
				 log.error(""Unexpected exception {
				}
				"", e.getMessage(), e);
			 }
			 sleepUninterruptibly(1, TimeUnit.SECONDS);
		 }
	 }
	 private static void addRootLogEntry(ServerContext context, ZooLock zooLock, final LogEntry entry) {
		 retryZooKeeperUpdate(context, zooLock, new ZooOperation() {
			 public void run(IZooReaderWriter rw) throws KeeperException, InterruptedException, IOException {
				 String root = getZookeeperLogLocation(context);
				 rw.putPersistentData(root + ""/"" + entry.getUniqueID(), entry.toBytes(), NodeExistsPolicy.OVERWRITE);
			 }
		 }
		);
	 }
	 public static SortedMap<FileRef,DataFileValue> getDataFileSizes(KeyExtent extent, ServerContext context) {
		 TreeMap<FileRef,DataFileValue> sizes = new TreeMap<>();
		 try (Scanner mdScanner = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY)) {
			 mdScanner.fetchColumnFamily(DataFileColumnFamily.NAME);
			 Text row = extent.getMetadataEntry();
			 Key endKey = new Key(row, DataFileColumnFamily.NAME, new Text(""""));
			 endKey = endKey.followingKey(PartialKey.ROW_COLFAM);
			 mdScanner.setRange(new Range(new Key(row), endKey));
			 for (Entry<Key,Value> entry : mdScanner) {
				 if (!entry.getKey().getRow().equals(row)) break;
				 DataFileValue dfv = new DataFileValue(entry.getValue().get());
				 sizes.put(new FileRef(context.getVolumeManager(), entry.getKey()), dfv);
			 }
			 return sizes;
		 }
	 }
	 public static void rollBackSplit(Text metadataEntry, Text oldPrevEndRow, ServerContext context, ZooLock zooLock) {
		 KeyExtent ke = new KeyExtent(metadataEntry, oldPrevEndRow);
		 Mutation m = ke.getPrevRowUpdateMutation();
		 TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.putDelete(m);
		 TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.putDelete(m);
		 update(context, zooLock, m, new KeyExtent(metadataEntry, (Text) null));
	 }
	 public static void splitTablet(KeyExtent extent, Text oldPrevEndRow, double splitRatio, ServerContext context, ZooLock zooLock) {
		 Mutation m = extent.getPrevRowUpdateMutation();
		 TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.put(m, new Value(Double.toString(splitRatio).getBytes(UTF_8)));
		 TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.put(m, KeyExtent.encodePrevEndRow(oldPrevEndRow));
		 ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);
		 update(context, zooLock, m, extent);
	 }
	 public static void finishSplit(Text metadataEntry, Map<FileRef,DataFileValue> datafileSizes, List<FileRef> highDatafilesToRemove, final ServerContext context, ZooLock zooLock) {
		 Mutation m = new Mutation(metadataEntry);
		 TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.putDelete(m);
		 TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.putDelete(m);
		 ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);
		 for (Entry<FileRef,DataFileValue> entry : datafileSizes.entrySet()) {
			 m.put(DataFileColumnFamily.NAME, entry.getKey().meta(), new Value(entry.getValue().encode()));
		 }
		 for (FileRef pathToRemove : highDatafilesToRemove) {
			 m.putDelete(DataFileColumnFamily.NAME, pathToRemove.meta());
		 }
		 update(context, zooLock, m, new KeyExtent(metadataEntry, (Text) null));
	 }
	 public static void finishSplit(KeyExtent extent, Map<FileRef,DataFileValue> datafileSizes, List<FileRef> highDatafilesToRemove, ServerContext context, ZooLock zooLock) {
		 finishSplit(extent.getMetadataEntry(), datafileSizes, highDatafilesToRemove, context, zooLock);
	 }
	 public static void addDeleteEntries(KeyExtent extent, Set<FileRef> datafilesToDelete, ServerContext context) {
		 TableId tableId = extent.getTableId();
		 for (FileRef pathToRemove : datafilesToDelete) {
			 update(context, createDeleteMutation(context, tableId, pathToRemove.path().toString()), extent);
		 }
	 }
	 public static void addDeleteEntry(ServerContext context, TableId tableId, String path) {
		 update(context, createDeleteMutation(context, tableId, path), new KeyExtent(tableId, null, null));
	 }
	 public static Mutation createDeleteMutation(ServerContext context, TableId tableId, String pathToRemove) {
		 Path path = context.getVolumeManager().getFullPath(tableId, pathToRemove);
		 Mutation delFlag = new Mutation(new Text(MetadataSchema.DeletesSection.getRowPrefix() + path));
		 delFlag.put(EMPTY_TEXT, EMPTY_TEXT, new Value(new byte[] {
		}
		));
		 return delFlag;
	 }
	 public static void removeScanFiles(KeyExtent extent, Set<FileRef> scanFiles, ServerContext context, ZooLock zooLock) {
		 Mutation m = new Mutation(extent.getMetadataEntry());
		 for (FileRef pathToRemove : scanFiles) m.putDelete(ScanFileColumnFamily.NAME, pathToRemove.meta());
		 update(context, zooLock, m, extent);
	 }
	 public static void splitDatafiles(Text midRow, double splitRatio, Map<FileRef,FileUtil.FileInfo> firstAndLastRows, SortedMap<FileRef,DataFileValue> datafiles, SortedMap<FileRef,DataFileValue> lowDatafileSizes, SortedMap<FileRef,DataFileValue> highDatafileSizes, List<FileRef> highDatafilesToRemove) {
		 for (Entry<FileRef,DataFileValue> entry : datafiles.entrySet()) {
			 Text firstRow = null;
			 Text lastRow = null;
			 boolean rowsKnown = false;
			 FileUtil.FileInfo mfi = firstAndLastRows.get(entry.getKey());
			 if (mfi != null) {
				 firstRow = mfi.getFirstRow();
				 lastRow = mfi.getLastRow();
				 rowsKnown = true;
			 }
			 if (rowsKnown && firstRow.compareTo(midRow) > 0) {
				 long highSize = entry.getValue().getSize();
				 long highEntries = entry.getValue().getNumEntries();
				 highDatafileSizes.put(entry.getKey(), new DataFileValue(highSize, highEntries, entry.getValue().getTime()));
			 }
			 else if (rowsKnown && lastRow.compareTo(midRow) <= 0) {
				 long lowSize = entry.getValue().getSize();
				 long lowEntries = entry.getValue().getNumEntries();
				 lowDatafileSizes.put(entry.getKey(), new DataFileValue(lowSize, lowEntries, entry.getValue().getTime()));
				 highDatafilesToRemove.add(entry.getKey());
			 }
			 else {
				 long lowSize = (long) Math.floor((entry.getValue().getSize() * splitRatio));
				 long lowEntries = (long) Math.floor((entry.getValue().getNumEntries() * splitRatio));
				 lowDatafileSizes.put(entry.getKey(), new DataFileValue(lowSize, lowEntries, entry.getValue().getTime()));
				 long highSize = (long) Math.ceil((entry.getValue().getSize() * (1.0 - splitRatio)));
				 long highEntries = (long) Math .ceil((entry.getValue().getNumEntries() * (1.0 - splitRatio)));
				 highDatafileSizes.put(entry.getKey(), new DataFileValue(highSize, highEntries, entry.getValue().getTime()));
			 }
		 }
	 }
	 public static void deleteTable(TableId tableId, boolean insertDeletes, ServerContext context, ZooLock lock) throws AccumuloException {
		 try (Scanner ms = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY);
		 BatchWriter bw = new BatchWriterImpl(context, MetadataTable.ID, new BatchWriterConfig().setMaxMemory(1000000) .setMaxLatency(120000L, TimeUnit.MILLISECONDS).setMaxWriteThreads(2))) {
			 Mutation m = null;
			 ms.setRange(new KeyExtent(tableId, null, null).toMetadataRange());
			 if (insertDeletes) {
				 ms.fetchColumnFamily(DataFileColumnFamily.NAME);
				 TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(ms);
				 for (Entry<Key,Value> cell : ms) {
					 Key key = cell.getKey();
					 if (key.getColumnFamily().equals(DataFileColumnFamily.NAME)) {
						 FileRef ref = new FileRef(context.getVolumeManager(), key);
						 bw.addMutation(createDeleteMutation(context, tableId, ref.meta().toString()));
					 }
					 if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {
						 bw.addMutation(createDeleteMutation(context, tableId, cell.getValue().toString()));
					 }
				 }
				 bw.flush();
				 ms.clearColumns();
			 }
			 for (Entry<Key,Value> cell : ms) {
				 Key key = cell.getKey();
				 if (m == null) {
					 m = new Mutation(key.getRow());
					 if (lock != null) putLockID(context, lock, m);
				 }
				 if (key.getRow().compareTo(m.getRow(), 0, m.getRow().length) != 0) {
					 bw.addMutation(m);
					 m = new Mutation(key.getRow());
					 if (lock != null) putLockID(context, lock, m);
				 }
				 m.putDelete(key.getColumnFamily(), key.getColumnQualifier());
			 }
			 if (m != null) bw.addMutation(m);
		 }
	 }
	 static String getZookeeperLogLocation(ServerContext context) {
		 return context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_WALOGS;
	 }
	 public static void setRootTabletDir(ServerContext context, String dir) throws IOException {
		 IZooReaderWriter zoo = context.getZooReaderWriter();
		 String zpath = context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_PATH;
		 try {
			 zoo.putPersistentData(zpath, dir.getBytes(UTF_8), -1, NodeExistsPolicy.OVERWRITE);
		 }
		 catch (KeeperException e) {
			 throw new IOException(e);
		 }
		 catch (InterruptedException e) {
			 Thread.currentThread().interrupt();
			 throw new IOException(e);
		 }
	 }
	 public static String getRootTabletDir(ServerContext context) throws IOException {
		 IZooReaderWriter zoo = context.getZooReaderWriter();
		 String zpath = context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_PATH;
		 try {
			 return new String(zoo.getData(zpath, null), UTF_8);
		 }
		 catch (KeeperException e) {
			 throw new IOException(e);
		 }
		 catch (InterruptedException e) {
			 Thread.currentThread().interrupt();
			 throw new IOException(e);
		 }
	 }
	 public static Pair<List<LogEntry>,SortedMap<FileRef,DataFileValue>> getFileAndLogEntries( ServerContext context, KeyExtent extent) throws KeeperException, InterruptedException, IOException {
		 ArrayList<LogEntry> result = new ArrayList<>();
		 TreeMap<FileRef,DataFileValue> sizes = new TreeMap<>();
		 VolumeManager fs = context.getVolumeManager();
		 if (extent.isRootTablet()) {
			 getRootLogEntries(context, result);
			 Path rootDir = new Path(getRootTabletDir(context));
			 FileStatus[] files = fs.listStatus(rootDir);
			 for (FileStatus fileStatus : files) {
				 if (fileStatus.getPath().toString().endsWith(""_tmp"")) {
					 continue;
				 }
				 DataFileValue dfv = new DataFileValue(0, 0);
				 sizes.put(new FileRef(fileStatus.getPath().toString(), fileStatus.getPath()), dfv);
			 }
		 }
		 else {
			 try (TabletsMetadata tablets = TabletsMetadata.builder().forTablet(extent).fetchFiles() .fetchLogs().fetchPrev().build(context)) {
				 TabletMetadata tablet = Iterables.getOnlyElement(tablets);
				 if (!tablet.getExtent().equals(extent)) throw new RuntimeException( ""Unexpected extent "" + tablet.getExtent() + "" expected "" + extent);
				 result.addAll(tablet.getLogs());
				 tablet.getFilesMap().forEach((k, v) -> {
					 sizes.put(new FileRef(k, fs.getFullPath(tablet.getTableId(), k)), v);
				 }
				);
			 }
		 }
		 return new Pair<>(result, sizes);
	 }
	 public static List<LogEntry> getLogEntries(ServerContext context, KeyExtent extent) throws IOException, KeeperException, InterruptedException {
		 log.info(""Scanning logging entries for {
		}
		"", extent);
		 ArrayList<LogEntry> result = new ArrayList<>();
		 if (extent.equals(RootTable.EXTENT)) {
			 log.info(""Getting logs for root tablet from zookeeper"");
			 getRootLogEntries(context, result);
		 }
		 else {
			 log.info(""Scanning metadata for logs used for tablet {
			}
			"", extent);
			 Scanner scanner = getTabletLogScanner(context, extent);
			 Text pattern = extent.getMetadataEntry();
			 for (Entry<Key,Value> entry : scanner) {
				 Text row = entry.getKey().getRow();
				 if (entry.getKey().getColumnFamily().equals(LogColumnFamily.NAME)) {
					 if (row.equals(pattern)) {
						 result.add(LogEntry.fromKeyValue(entry.getKey(), entry.getValue()));
					 }
				 }
			 }
		 }
		 log.info(""Returning logs {
		}
		 for extent {
		}
		"", result, extent);
		 return result;
	 }
	 static void getRootLogEntries(ServerContext context, final ArrayList<LogEntry> result) throws KeeperException, InterruptedException, IOException {
		 IZooReaderWriter zoo = context.getZooReaderWriter();
		 String root = getZookeeperLogLocation(context);
		 while (true) {
			 result.clear();
			 for (String child : zoo.getChildren(root)) {
				 try {
					 LogEntry e = LogEntry.fromBytes(zoo.getData(root + ""/"" + child, null));
					 e = new LogEntry(RootTable.EXTENT, 0, e.server, e.filename);
					 result.add(e);
				 }
				 catch (KeeperException.NoNodeException ex) {
					 continue;
				 }
			 }
			 break;
		 }
	 }
	 private static Scanner getTabletLogScanner(ServerContext context, KeyExtent extent) {
		 TableId tableId = MetadataTable.ID;
		 if (extent.isMeta()) tableId = RootTable.ID;
		 Scanner scanner = new ScannerImpl(context, tableId, Authorizations.EMPTY);
		 scanner.fetchColumnFamily(LogColumnFamily.NAME);
		 Text start = extent.getMetadataEntry();
		 Key endKey = new Key(start, LogColumnFamily.NAME);
		 endKey = endKey.followingKey(PartialKey.ROW_COLFAM);
		 scanner.setRange(new Range(new Key(start), endKey));
		 return scanner;
	 }
	 private static class LogEntryIterator implements Iterator<LogEntry> {
		 Iterator<LogEntry> zookeeperEntries = null;
		 Iterator<LogEntry> rootTableEntries = null;
		 Iterator<Entry<Key,Value>> metadataEntries = null;
		 LogEntryIterator(ServerContext context) throws IOException, KeeperException, InterruptedException {
			 zookeeperEntries = getLogEntries(context, RootTable.EXTENT).iterator();
			 rootTableEntries = getLogEntries(context, new KeyExtent(MetadataTable.ID, null, null)) .iterator();
			 try {
				 Scanner scanner = context.createScanner(MetadataTable.NAME, Authorizations.EMPTY);
				 log.info(""Setting range to {
				}
				"", MetadataSchema.TabletsSection.getRange());
				 scanner.setRange(MetadataSchema.TabletsSection.getRange());
				 scanner.fetchColumnFamily(LogColumnFamily.NAME);
				 metadataEntries = scanner.iterator();
			 }
			 catch (Exception ex) {
				 throw new IOException(ex);
			 }
		 }
		 public boolean hasNext() {
			 return zookeeperEntries.hasNext() || rootTableEntries.hasNext() || metadataEntries.hasNext();
		 }
		 public LogEntry next() {
			 if (zookeeperEntries.hasNext()) {
				 return zookeeperEntries.next();
			 }
			 if (rootTableEntries.hasNext()) {
				 return rootTableEntries.next();
			 }
			 Entry<Key,Value> entry = metadataEntries.next();
			 return LogEntry.fromKeyValue(entry.getKey(), entry.getValue());
		 }
		 public void remove() {
			 throw new UnsupportedOperationException();
		 }
	 }
	 public static Iterator<LogEntry> getLogEntries(ServerContext context) throws IOException, KeeperException, InterruptedException {
		 return new LogEntryIterator(context);
	 }
	 public static void removeUnusedWALEntries(ServerContext context, KeyExtent extent, final List<LogEntry> entries, ZooLock zooLock) {
		 if (extent.isRootTablet()) {
			 retryZooKeeperUpdate(context, zooLock, new ZooOperation() {
				 public void run(IZooReaderWriter rw) throws KeeperException, InterruptedException {
					 String root = getZookeeperLogLocation(context);
					 for (LogEntry entry : entries) {
						 String path = root + ""/"" + entry.getUniqueID();
						 log.debug(""Removing "" + path + "" from zookeeper"");
						 rw.recursiveDelete(path, NodeMissingPolicy.SKIP);
					 }
				 }
			 }
			);
		 }
		 else {
			 Mutation m = new Mutation(extent.getMetadataEntry());
			 for (LogEntry entry : entries) {
				 m.putDelete(entry.getColumnFamily(), entry.getColumnQualifier());
			 }
			 update(context, zooLock, m, extent);
		 }
	 }
	 private static void getFiles(Set<String> files, Collection<String> tabletFiles, TableId srcTableId) {
		 for (String file : tabletFiles) {
			 if (srcTableId != null && !file.startsWith(""../"") && !file.contains("":"")) {
				 file = ""../"" + srcTableId + file;
			 }
			 files.add(file);
		 }
	 }
	 private static Mutation createCloneMutation(TableId srcTableId, TableId tableId, Map<Key,Value> tablet) {
		 KeyExtent ke = new KeyExtent(tablet.keySet().iterator().next().getRow(), (Text) null);
		 Mutation m = new Mutation(TabletsSection.getRow(tableId, ke.getEndRow()));
		 for (Entry<Key,Value> entry : tablet.entrySet()) {
			 if (entry.getKey().getColumnFamily().equals(DataFileColumnFamily.NAME)) {
				 String cf = entry.getKey().getColumnQualifier().toString();
				 if (!cf.startsWith(""../"") && !cf.contains("":"")) cf = ""../"" + srcTableId + entry.getKey().getColumnQualifier();
				 m.put(entry.getKey().getColumnFamily(), new Text(cf), entry.getValue());
			 }
			 else if (entry.getKey().getColumnFamily() .equals(TabletsSection.CurrentLocationColumnFamily.NAME)) {
				 m.put(TabletsSection.LastLocationColumnFamily.NAME, entry.getKey().getColumnQualifier(), entry.getValue());
			 }
			 else if (entry.getKey().getColumnFamily() .equals(TabletsSection.LastLocationColumnFamily.NAME)) {
			 }
			 else {
				 m.put(entry.getKey().getColumnFamily(), entry.getKey().getColumnQualifier(), entry.getValue());
			 }
		 }
		 return m;
	 }
	 private static Iterable<TabletMetadata> createCloneScanner(String testTableName, TableId tableId, AccumuloClient client) throws TableNotFoundException {
		 String tableName;
		 Range range;
		 if (testTableName != null) {
			 tableName = testTableName;
			 range = TabletsSection.getRange(tableId);
		 }
		 else if (tableId.equals(MetadataTable.ID)) {
			 tableName = RootTable.NAME;
			 range = TabletsSection.getRange();
		 }
		 else {
			 tableName = MetadataTable.NAME;
			 range = TabletsSection.getRange(tableId);
		 }
		 return TabletsMetadata.builder().scanTable(tableName).overRange(range).checkConsistency() .saveKeyValues().fetchFiles().fetchLocation().fetchLast().fetchCloned().fetchPrev() .fetchTime().build(client);
	 }
	 public static void initializeClone(String testTableName, TableId srcTableId, TableId tableId, AccumuloClient client, BatchWriter bw) throws TableNotFoundException, MutationsRejectedException {
		 Iterator<TabletMetadata> ti = createCloneScanner(testTableName, srcTableId, client).iterator();
		 if (!ti.hasNext()) throw new RuntimeException("" table deleted during clone? srcTableId = "" + srcTableId);
		 while (ti.hasNext()) bw.addMutation(createCloneMutation(srcTableId, tableId, ti.next().getKeyValues()));
		 bw.flush();
	 }
	 private static int compareEndRows(Text endRow1, Text endRow2) {
		 return new KeyExtent(TableId.of(""0""), endRow1, null) .compareTo(new KeyExtent(TableId.of(""0""), endRow2, null));
	 }
	 public static int checkClone(String testTableName, TableId srcTableId, TableId tableId, AccumuloClient client, BatchWriter bw) throws TableNotFoundException, MutationsRejectedException {
		 Iterator<TabletMetadata> srcIter = createCloneScanner(testTableName, srcTableId, client) .iterator();
		 Iterator<TabletMetadata> cloneIter = createCloneScanner(testTableName, tableId, client) .iterator();
		 if (!cloneIter.hasNext() || !srcIter.hasNext()) throw new RuntimeException( "" table deleted during clone? srcTableId = "" + srcTableId + "" tableId="" + tableId);
		 int rewrites = 0;
		 while (cloneIter.hasNext()) {
			 TabletMetadata cloneTablet = cloneIter.next();
			 Text cloneEndRow = cloneTablet.getEndRow();
			 HashSet<String> cloneFiles = new HashSet<>();
			 boolean cloneSuccessful = cloneTablet.getCloned() != null;
			 if (!cloneSuccessful) getFiles(cloneFiles, cloneTablet.getFiles(), null);
			 List<TabletMetadata> srcTablets = new ArrayList<>();
			 TabletMetadata srcTablet = srcIter.next();
			 srcTablets.add(srcTablet);
			 Text srcEndRow = srcTablet.getEndRow();
			 int cmp = compareEndRows(cloneEndRow, srcEndRow);
			 if (cmp < 0) throw new TabletDeletedException( ""Tablets deleted from src during clone : "" + cloneEndRow + "" "" + srcEndRow);
			 HashSet<String> srcFiles = new HashSet<>();
			 if (!cloneSuccessful) getFiles(srcFiles, srcTablet.getFiles(), srcTableId);
			 while (cmp > 0) {
				 srcTablet = srcIter.next();
				 srcTablets.add(srcTablet);
				 srcEndRow = srcTablet.getEndRow();
				 cmp = compareEndRows(cloneEndRow, srcEndRow);
				 if (cmp < 0) throw new TabletDeletedException( ""Tablets deleted from src during clone : "" + cloneEndRow + "" "" + srcEndRow);
				 if (!cloneSuccessful) getFiles(srcFiles, srcTablet.getFiles(), srcTableId);
			 }
			 if (cloneSuccessful) continue;
			 if (!srcFiles.containsAll(cloneFiles)) {
				 Mutation m = new Mutation(cloneTablet.getExtent().getMetadataEntry());
				 for (Entry<Key,Value> entry : cloneTablet.getKeyValues().entrySet()) {
					 Key k = entry.getKey();
					 m.putDelete(k.getColumnFamily(), k.getColumnQualifier(), k.getTimestamp());
				 }
				 bw.addMutation(m);
				 for (TabletMetadata st : srcTablets) bw.addMutation(createCloneMutation(srcTableId, tableId, st.getKeyValues()));
				 rewrites++;
			 }
			 else {
				 Mutation m = new Mutation(cloneTablet.getExtent().getMetadataEntry());
				 m.put(ClonedColumnFamily.NAME, new Text(""""), new Value(""OK"".getBytes(UTF_8)));
				 bw.addMutation(m);
			 }
		 }
		 bw.flush();
		 return rewrites;
	 }
	 public static void cloneTable(ServerContext context, TableId srcTableId, TableId tableId, VolumeManager volumeManager) throws Exception {
		 try (BatchWriter bw = context.createBatchWriter(MetadataTable.NAME, new BatchWriterConfig())) {
			 while (true) {
				 try {
					 initializeClone(null, srcTableId, tableId, context, bw);
					 while (true) {
						 int rewrites = checkClone(null, srcTableId, tableId, context, bw);
						 if (rewrites == 0) break;
					 }
					 bw.flush();
					 break;
				 }
				 catch (TabletDeletedException tde) {
					 bw.flush();
					 deleteTable(tableId, false, context, null);
					 log.debug(""Tablets merged in table {
					}
					 while attempting to clone, trying again"", srcTableId);
					 sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
				 }
			 }
			 Scanner mscanner = context.createScanner(MetadataTable.NAME, Authorizations.EMPTY);
			 mscanner.setRange(new KeyExtent(tableId, null, null).toMetadataRange());
			 mscanner.fetchColumnFamily(ClonedColumnFamily.NAME);
			 int dirCount = 0;
			 for (Entry<Key,Value> entry : mscanner) {
				 Key k = entry.getKey();
				 Mutation m = new Mutation(k.getRow());
				 m.putDelete(k.getColumnFamily(), k.getColumnQualifier());
				 VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironmentImpl(tableId, new KeyExtent(k.getRow(), (Text) null).getEndRow(), context);
				 String dir = volumeManager.choose(chooserEnv, ServerConstants.getBaseUris(context)) + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + tableId + Path.SEPARATOR + new String( FastFormat.toZeroPaddedString(dirCount++, 8, 16, Constants.CLONE_PREFIX_BYTES));
				 TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(dir.getBytes(UTF_8)));
				 bw.addMutation(m);
			 }
		 }
	 }
	 public static void chopped(ServerContext context, KeyExtent extent, ZooLock zooLock) {
		 Mutation m = new Mutation(extent.getMetadataEntry());
		 ChoppedColumnFamily.CHOPPED_COLUMN.put(m, new Value(""chopped"".getBytes(UTF_8)));
		 update(context, zooLock, m, extent);
	 }
	 public static void removeBulkLoadEntries(AccumuloClient client, TableId tableId, long tid) throws Exception {
		 try ( Scanner mscanner = new IsolatedScanner( client.createScanner(MetadataTable.NAME, Authorizations.EMPTY));
		 BatchWriter bw = client.createBatchWriter(MetadataTable.NAME, new BatchWriterConfig())) {
			 mscanner.setRange(new KeyExtent(tableId, null, null).toMetadataRange());
			 mscanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);
			 byte[] tidAsBytes = Long.toString(tid).getBytes(UTF_8);
			 for (Entry<Key,Value> entry : mscanner) {
				 log.trace(""Looking at entry {
				}
				 with tid {
				}
				"", entry, tid);
				 if (Arrays.equals(entry.getValue().get(), tidAsBytes)) {
					 log.trace(""deleting entry {
					}
					"", entry);
					 Key key = entry.getKey();
					 Mutation m = new Mutation(key.getRow());
					 m.putDelete(key.getColumnFamily(), key.getColumnQualifier());
					 bw.addMutation(m);
				 }
			 }
		 }
	 }
	 public static List<FileRef> getBulkFilesLoaded(ServerContext context, AccumuloClient client, KeyExtent extent, long tid) {
		 List<FileRef> result = new ArrayList<>();
		 try (Scanner mscanner = new IsolatedScanner(client.createScanner( extent.isMeta() ? RootTable.NAME : MetadataTable.NAME, Authorizations.EMPTY))) {
			 VolumeManager fs = context.getVolumeManager();
			 mscanner.setRange(extent.toMetadataRange());
			 mscanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);
			 for (Entry<Key,Value> entry : mscanner) {
				 if (Long.parseLong(entry.getValue().toString()) == tid) {
					 result.add(new FileRef(fs, entry.getKey()));
				 }
			 }
			 return result;
		 }
		 catch (TableNotFoundException ex) {
			 throw new RuntimeException(""Onos! teh metadata table has vanished!!"");
		 }
	 }
	 public static Map<Long,? extends Collection<FileRef>> getBulkFilesLoaded(ServerContext context, KeyExtent extent) {
		 Text metadataRow = extent.getMetadataEntry();
		 Map<Long,List<FileRef>> result = new HashMap<>();
		 VolumeManager fs = context.getVolumeManager();
		 try (Scanner scanner = new ScannerImpl(context, extent.isMeta() ? RootTable.ID : MetadataTable.ID, Authorizations.EMPTY)) {
			 scanner.setRange(new Range(metadataRow));
			 scanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);
			 for (Entry<Key,Value> entry : scanner) {
				 Long tid = Long.parseLong(entry.getValue().toString());
				 List<FileRef> lst = result.get(tid);
				 if (lst == null) {
					 result.put(tid, lst = new ArrayList<>());
				 }
				 lst.add(new FileRef(fs, entry.getKey()));
			 }
		 }
		 return result;
	 }
	 public static void addBulkLoadInProgressFlag(ServerContext context, String path) {
		 Mutation m = new Mutation(MetadataSchema.BlipSection.getRowPrefix() + path);
		 m.put(EMPTY_TEXT, EMPTY_TEXT, new Value(new byte[] {
		}
		));
		 update(context, m, new KeyExtent(TableId.of(""anythingNotMetadata""), null, null));
	 }
	 public static void removeBulkLoadInProgressFlag(ServerContext context, String path) {
		 Mutation m = new Mutation(MetadataSchema.BlipSection.getRowPrefix() + path);
		 m.putDelete(EMPTY_TEXT, EMPTY_TEXT);
		 update(context, m, new KeyExtent(TableId.of(""anythingNotMetadata""), null, null));
	 }
	 public static void createReplicationTable(ServerContext context) {
		 VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironmentImpl(ReplicationTable.ID, null, context);
		 String dir = context.getVolumeManager().choose(chooserEnv, ServerConstants.getBaseUris(context)) + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + ReplicationTable.ID + Constants.DEFAULT_TABLET_LOCATION;
		 Mutation m = new Mutation(new Text(TabletsSection.getRow(ReplicationTable.ID, null)));
		 m.put(DIRECTORY_COLUMN.getColumnFamily(), DIRECTORY_COLUMN.getColumnQualifier(), 0, new Value(dir.getBytes(UTF_8)));
		 m.put(TIME_COLUMN.getColumnFamily(), TIME_COLUMN.getColumnQualifier(), 0, new Value((TabletTime.LOGICAL_TIME_ID + ""0"").getBytes(UTF_8)));
		 m.put(PREV_ROW_COLUMN.getColumnFamily(), PREV_ROW_COLUMN.getColumnQualifier(), 0, KeyExtent.encodePrevEndRow(null));
		 update(context, getMetadataTable(context), null, m);
	 }
	 public static void moveMetaDeleteMarkers(ServerContext context) {
		 String oldDeletesPrefix = ""!!~del"";
		 Range oldDeletesRange = new Range(oldDeletesPrefix, true, ""!!~dem"", false);
		 try (Scanner scanner = new ScannerImpl(context, RootTable.ID, Authorizations.EMPTY)) {
			 scanner.setRange(oldDeletesRange);
			 for (Entry<Key,Value> entry : scanner) {
				 String row = entry.getKey().getRow().toString();
				 if (row.startsWith(oldDeletesPrefix)) {
					 moveDeleteEntry(context, RootTable.OLD_EXTENT, entry, row, oldDeletesPrefix);
				 }
				 else {
					 break;
				 }
			 }
		 }
	 }
	 public static void moveMetaDeleteMarkersFrom14(ServerContext context) {
		 KeyExtent notMetadata = new KeyExtent(TableId.of(""anythingNotMetadata""), null, null);
		 try (Scanner scanner = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY)) {
			 scanner.setRange(MetadataSchema.DeletesSection.getRange());
			 for (Entry<Key,Value> entry : scanner) {
				 String row = entry.getKey().getRow().toString();
				 if (row.startsWith(MetadataSchema.DeletesSection.getRowPrefix() + ""/"" + MetadataTable.ID)) {
					 moveDeleteEntry(context, notMetadata, entry, row, MetadataSchema.DeletesSection.getRowPrefix());
				 }
				 else {
					 break;
				 }
			 }
		 }
	 }
	 private static void moveDeleteEntry(ServerContext context, KeyExtent oldExtent, Entry<Key,Value> entry, String rowID, String prefix) {
		 String filename = rowID.substring(prefix.length());
		 log.info(""Moving {
		}
		 marker in {
		}
		"", filename, RootTable.NAME);
		 Mutation m = new Mutation(MetadataSchema.DeletesSection.getRowPrefix() + filename);
		 m.put(EMPTY_BYTES, EMPTY_BYTES, EMPTY_BYTES);
		 update(context, m, RootTable.EXTENT);
		 m = new Mutation(entry.getKey().getRow());
		 m.putDelete(EMPTY_BYTES, EMPTY_BYTES);
		 update(context, m, oldExtent);
	 }
	 public static SortedMap<Text,SortedMap<ColumnFQ,Value>> getTabletEntries( SortedMap<Key,Value> tabletKeyValues, List<ColumnFQ> columns) {
		 TreeMap<Text,SortedMap<ColumnFQ,Value>> tabletEntries = new TreeMap<>();
		 HashSet<ColumnFQ> colSet = null;
		 if (columns != null) {
			 colSet = new HashSet<>(columns);
		 }
		 for (Entry<Key,Value> entry : tabletKeyValues.entrySet()) {
			 ColumnFQ currentKey = new ColumnFQ(entry.getKey());
			 if (columns != null && !colSet.contains(currentKey)) {
				 continue;
			 }
			 Text row = entry.getKey().getRow();
			 SortedMap<ColumnFQ,Value> colVals = tabletEntries.get(row);
			 if (colVals == null) {
				 colVals = new TreeMap<>();
				 tabletEntries.put(row, colVals);
			 }
			 colVals.put(currentKey, entry.getValue());
		 }
		 return tabletEntries;
	 }
}",1,0,0,0
"protected void updateFlags(ExchangeSession.Message message, String action, String flags) throws IOException {
	 HashMap<String, String> properties = new HashMap<String, String>();
	 if (""-Flags"".equalsIgnoreCase(action) || ""-FLAGS.SILENT"".equalsIgnoreCase(action)) {
		 StringTokenizer flagtokenizer = new StringTokenizer(flags);
		 while (flagtokenizer.hasMoreTokens()) {
			 String flag = flagtokenizer.nextToken();
			 if (""\\Seen"".equalsIgnoreCase(flag)) {
				 if (message.read) {
					 properties.put(""read"", ""0"");
					 message.read = false;
				 }
			 }
			 else if (""\\Flagged"".equalsIgnoreCase(flag)) {
				 if (message.flagged) {
					 properties.put(""flagged"", ""0"");
					 message.flagged = false;
				 }
			 }
			 else if (""\\Deleted"".equalsIgnoreCase(flag)) {
				 if (message.deleted) {
					 properties.put(""deleted"", null);
					 message.deleted = false;
				 }
			 }
			 else if (""Junk"".equalsIgnoreCase(flag)) {
				 if (message.junk) {
					 properties.put(""junk"", ""0"");
					 message.junk = false;
				 }
			 }
			 else if (""$Forwarded"".equalsIgnoreCase(flag)) {
				 if (message.forwarded) {
					 properties.put(""forwarded"", null);
					 message.forwarded = false;
				 }
			 }
			 else if (""\\Answered"".equalsIgnoreCase(flag)) {
				 if (message.answered) {
					 properties.put(""answered"", null);
					 message.answered = false;
				 }
			 }
			 else if (message.keywords != null) {
				 properties.put(""keywords"", message.removeFlag(flag));
			 }
		 }
	 }
	 else if (""+Flags"".equalsIgnoreCase(action) || ""+FLAGS.SILENT"".equalsIgnoreCase(action)) {
		 StringTokenizer flagtokenizer = new StringTokenizer(flags);
		 while (flagtokenizer.hasMoreTokens()) {
			 String flag = flagtokenizer.nextToken();
			 if (""\\Seen"".equalsIgnoreCase(flag)) {
				 if (!message.read) {
					 properties.put(""read"", ""1"");
					 message.read = true;
				 }
			 }
			 else if (""\\Deleted"".equalsIgnoreCase(flag)) {
				 if (!message.deleted) {
					 message.deleted = true;
					 properties.put(""deleted"", ""1"");
				 }
			 }
			 else if (""\\Flagged"".equalsIgnoreCase(flag)) {
				 if (!message.flagged) {
					 properties.put(""flagged"", ""2"");
					 message.flagged = true;
				 }
			 }
			 else if (""\\Answered"".equalsIgnoreCase(flag)) {
				 if (!message.answered) {
					 properties.put(""answered"", ""102"");
					 message.answered = true;
				 }
			 }
			 else if (""$Forwarded"".equalsIgnoreCase(flag)) {
				 if (!message.forwarded) {
					 properties.put(""forwarded"", ""104"");
					 message.forwarded = true;
				 }
			 }
			 else if (""Junk"".equalsIgnoreCase(flag)) {
				 if (!message.junk) {
					 properties.put(""junk"", ""1"");
					 message.junk = true;
				 }
			 }
			 else {
				 properties.put(""keywords"", message.addFlag(flag));
			 }
		 }
	 }
	 else if (""FLAGS"".equalsIgnoreCase(action) || ""FLAGS.SILENT"".equalsIgnoreCase(action)) {
		 boolean read = false;
		 boolean deleted = false;
		 boolean junk = false;
		 boolean flagged = false;
		 boolean answered = false;
		 boolean forwarded = false;
		 HashSet<String> keywords = null;
		 StringTokenizer flagtokenizer = new StringTokenizer(flags);
		 while (flagtokenizer.hasMoreTokens()) {
			 String flag = flagtokenizer.nextToken();
			 if (""\\Seen"".equalsIgnoreCase(flag)) {
				 read = true;
			 }
			 else if (""\\Deleted"".equalsIgnoreCase(flag)) {
				 deleted = true;
			 }
			 else if (""\\Flagged"".equalsIgnoreCase(flag)) {
				 flagged = true;
			 }
			 else if (""\\Answered"".equalsIgnoreCase(flag)) {
				 answered = true;
			 }
			 else if (""$Forwarded"".equalsIgnoreCase(flag)) {
				 forwarded = true;
			 }
			 else if (""Junk"".equalsIgnoreCase(flag)) {
				 junk = true;
			 }
			 else {
				 if (keywords == null) {
					 keywords = new HashSet<String>();
				 }
				 keywords.add(flag);
			 }
		 }
		 if (keywords != null) {
			 properties.put(""keywords"", message.setFlags(keywords));
		 }
		 if (read != message.read) {
			 message.read = read;
			 if (message.read) {
				 properties.put(""read"", ""1"");
			 }
			 else {
				 properties.put(""read"", ""0"");
			 }
		 }
		 if (deleted != message.deleted) {
			 message.deleted = deleted;
			 if (message.deleted) {
				 properties.put(""deleted"", ""1"");
			 }
			 else {
				 properties.put(""deleted"", null);
			 }
		 }
		 if (flagged != message.flagged) {
			 message.flagged = flagged;
			 if (message.flagged) {
				 properties.put(""flagged"", ""2"");
			 }
			 else {
				 properties.put(""flagged"", ""0"");
			 }
		 }
		 if (answered != message.answered) {
			 message.answered = answered;
			 if (message.answered) {
				 properties.put(""answered"", ""102"");
			 }
			 else if (!forwarded) {
				 properties.put(""answered"", null);
			 }
		 }
		 if (forwarded != message.forwarded) {
			 message.forwarded = forwarded;
			 if (message.forwarded) {
				 properties.put(""forwarded"", ""104"");
			 }
			 else if (!answered) {
				 properties.put(""forwarded"", null);
			 }
		 }
		 if (junk != message.junk) {
			 message.junk = junk;
			 if (message.junk) {
				 properties.put(""junk"", ""1"");
			 }
			 else {
				 properties.put(""junk"", ""0"");
			 }
		 }
	 }
	 if (!properties.isEmpty()) {
		 session.updateMessage(message, properties);
		 message.recent = false;
	 }
 }",0,0,1,0
"public synchronized void setRelativePath(String r) {
	 checkAttributesAllowed();
	 if (url != null) {
		 throw new BuildException(""can't define URL and relativePath"" + "" attribute"");
	 }
	 relPath = r;
 }",0,0,0,0
"public abstract class TerminalOperator<T extends OperatorDesc> extends Operator<T> implements Serializable {
	 private static final long serialVersionUID = 1L;
	 protected TerminalOperator() {
		 super();
	 }
	 public TerminalOperator(CompilationOpContext ctx) {
		 super(ctx);
	 }
	 public String getName() {
		 return getOperatorName();
	 }
	 static public String getOperatorName() {
		 return ""END"";
	 }
}",0,0,0,0
"public class MqttConnectionState {
	private Integer receiveMaximum = 65535;
	private Integer maximumQoS = 2;
	private Boolean retainAvailable = true;
	private Long outgoingMaximumPacketSize = null;
	private Long incomingMaximumPacketSize = null;
	private Integer outgoingTopicAliasMaximum = 0;
	private Integer incomingTopicAliasMax = 0;
	private Boolean wildcardSubscriptionsAvailable = true;
	private Boolean subscriptionIdentifiersAvailable = true;
	private Boolean sharedSubscriptionsAvailable = true;
	private boolean sendReasonMessages = false;
	private long keepAlive = 60;
	private AtomicInteger nextOutgoingTopicAlias = new AtomicInteger(1);
	public void clearConnectionState() {
		nextOutgoingTopicAlias.set(1);
	}
	public Integer getReceiveMaximum() {
		if (receiveMaximum == null) {
			return 65535;
		}
		return receiveMaximum;
	}
	public void setReceiveMaximum(Integer receiveMaximum) {
		this.receiveMaximum = receiveMaximum;
	}
	public Integer getMaximumQoS() {
		return maximumQoS;
	}
	public void setMaximumQoS(Integer maximumQoS) {
		this.maximumQoS = maximumQoS;
	}
	public Boolean isRetainAvailable() {
		return retainAvailable;
	}
	public void setRetainAvailable(Boolean retainAvailable) {
		this.retainAvailable = retainAvailable;
	}
	public Long getOutgoingMaximumPacketSize() {
		return outgoingMaximumPacketSize;
	}
	public void setOutgoingMaximumPacketSize(Long maximumPacketSize) {
		this.outgoingMaximumPacketSize = maximumPacketSize;
	}
	public Long getIncomingMaximumPacketSize() {
		return incomingMaximumPacketSize;
	}
	public void setIncomingMaximumPacketSize(Long incomingMaximumPacketSize) {
		this.incomingMaximumPacketSize = incomingMaximumPacketSize;
	}
	public Integer getOutgoingTopicAliasMaximum() {
		return outgoingTopicAliasMaximum;
	}
	public void setOutgoingTopicAliasMaximum(Integer topicAliasMaximum) {
		this.outgoingTopicAliasMaximum = topicAliasMaximum;
	}
	public Boolean isWildcardSubscriptionsAvailable() {
		return wildcardSubscriptionsAvailable;
	}
	public void setWildcardSubscriptionsAvailable(Boolean wildcardSubscriptionsAvailable) {
		this.wildcardSubscriptionsAvailable = wildcardSubscriptionsAvailable;
	}
	public Boolean isSubscriptionIdentifiersAvailable() {
		return subscriptionIdentifiersAvailable;
	}
	public void setSubscriptionIdentifiersAvailable(Boolean subscriptionIdentifiersAvailable) {
		this.subscriptionIdentifiersAvailable = subscriptionIdentifiersAvailable;
	}
	public Boolean isSharedSubscriptionsAvailable() {
		return sharedSubscriptionsAvailable;
	}
	public void setSharedSubscriptionsAvailable(Boolean sharedSubscriptionsAvailable) {
		this.sharedSubscriptionsAvailable = sharedSubscriptionsAvailable;
	}
	public Integer getNextOutgoingTopicAlias() {
		return nextOutgoingTopicAlias.getAndIncrement();
	}
	public Integer getIncomingTopicAliasMax() {
		return incomingTopicAliasMax;
	}
	public void setIncomingTopicAliasMax(Integer incomingTopicAliasMax) {
		this.incomingTopicAliasMax = incomingTopicAliasMax;
	}
	public boolean isSendReasonMessages() {
		return sendReasonMessages;
	}
	public void setSendReasonMessages(boolean enableReasonMessages) {
		this.sendReasonMessages = enableReasonMessages;
	}
	public long getKeepAlive() {
		return keepAlive;
	}
	public void setKeepAliveSeconds(long keepAlive) {
		this.keepAlive = keepAlive * 1000;
	}
}",1,1,0,0
"public class XHtmlToWikiConfig{
	 private String m_outlink = ""outlink"";
	 private String m_pageInfoJsp = ""PageInfo.jsp"";
	 private String m_wikiJspPage = ""Wiki.jsp?page="";
	 private String m_editJspPage = ""Edit.jsp?page="";
	 private String m_attachPage = ""attach?page="";
	 private String m_pageName;
	 public XHtmlToWikiConfig() {
	}
	 public XHtmlToWikiConfig( WikiContext wikiContext ) {
		 setWikiContext( wikiContext );
		 m_wikiJspPage = wikiContext.getURL( WikiContext.VIEW, """" );
		 m_editJspPage = wikiContext.getURL( WikiContext.EDIT, """" );
		 m_attachPage = wikiContext.getURL( WikiContext.ATTACH, """" );
		 m_pageInfoJsp = wikiContext.getURL( WikiContext.INFO, """" );
	 }
	 private void setWikiContext( WikiContext wikiContext ) {
		 if( wikiContext.getPage() != null ) {
			 setPageName( wikiContext.getPage().getName() + '/' );
		 }
	 }
	 public String getAttachPage() {
		 return m_attachPage;
	 }
	 public void setAttachPage( String attachPage ) {
		 m_attachPage = attachPage;
	 }
	 public String getOutlink() {
		 return m_outlink;
	 }
	 public void setOutlink( String outlink ) {
		 m_outlink = outlink;
	 }
	 public String getPageInfoJsp() {
		 return m_pageInfoJsp;
	 }
	 public void setPageInfoJsp( String pageInfoJsp ) {
		 m_pageInfoJsp = pageInfoJsp;
	 }
	 public String getPageName() {
		 return m_pageName;
	 }
	 public void setPageName( String pageName ) {
		 m_pageName = pageName;
	 }
	 public String getWikiJspPage() {
		 return m_wikiJspPage;
	 }
	 public void setWikiJspPage( String wikiJspPage ) {
		 m_wikiJspPage = wikiJspPage;
	 }
	 public String getEditJspPage() {
		 return m_editJspPage;
	 }
	 public void setEditJspPage( String editJspPage ) {
		 m_editJspPage = editJspPage;
	 }
}",0,1,0,0
"public boolean readFrom(ByteBuffer buf, MessageReader reader) {
	 reader.setBuffer(buf);
	 if (!reader.beforeMessageRead()) return false;
	 if (!super.readFrom(buf, reader)) return false;
	 switch (reader.state()) {
		 case 3: futId = reader.readLong(""futId"");
		 if (!reader.isLastRead()) return false;
		 reader.incrementState();
		 case 4: locksArr = reader.readObjectArray(""locksArr"", MessageCollectionItemType.MSG, TxLockList.class);
		 if (!reader.isLastRead()) return false;
		 reader.incrementState();
		 case 5: nearTxKeysArr = reader.readObjectArray(""nearTxKeysArr"", MessageCollectionItemType.MSG, IgniteTxKey.class);
		 if (!reader.isLastRead()) return false;
		 reader.incrementState();
		 case 6: txKeysArr = reader.readObjectArray(""txKeysArr"", MessageCollectionItemType.MSG, IgniteTxKey.class);
		 if (!reader.isLastRead()) return false;
		 reader.incrementState();
	 }
	 return reader.afterMessageRead(TxLocksResponse.class);
 }",0,0,1,0
"public final class CouchbaseClusterUtil {
	 private CouchbaseClusterUtil() {
	 }
	 public static CouchbaseCluster getCouchbaseCluster(String database, CouchbaseCluster couchbaseCluster, String user, String password) {
		 Objects.requireNonNull(database, ""database is required"");
		 CouchbaseCluster authenticate = couchbaseCluster.authenticate(user, password);
		 return authenticate;
	 }
}",0,0,0,0
"public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder {
	private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers"");
	private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
	private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
	private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
	private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0);
	private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1);
	private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
	private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0);
	private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
	private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
	private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
	private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
	 public ParserRule getRule() {
		 return rule;
	 }
	public Alternatives getAlternatives() {
		 return cAlternatives;
	 }
	public Group getGroup_0() {
		 return cGroup_0;
	 }
	public Alternatives getAlternatives_0_0() {
		 return cAlternatives_0_0;
	 }
	public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() {
		 return cParameterizedTypeRefParserRuleCall_0_0_0;
	 }
	public RuleCall getThisTypeRefParserRuleCall_0_0_1() {
		 return cThisTypeRefParserRuleCall_0_0_1;
	 }
	public Assignment getDynamicAssignment_0_1() {
		 return cDynamicAssignment_0_1;
	 }
	public Keyword getDynamicPlusSignKeyword_0_1_0() {
		 return cDynamicPlusSignKeyword_0_1_0;
	 }
	public RuleCall getTypeTypeRefParserRuleCall_1() {
		 return cTypeTypeRefParserRuleCall_1;
	 }
	public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() {
		 return cFunctionTypeExpressionOLDParserRuleCall_2;
	 }
	public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() {
		 return cUnionTypeExpressionOLDParserRuleCall_3;
	 }
	public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() {
		 return cIntersectionTypeExpressionOLDParserRuleCall_4;
	 }
}",1,1,0,0
"public class ChatData implements ClientData, ClientIdentifiable, PoolableObject{
	privatestatic final Loggerlogger = Logger.getLogger(ChatData.class.getName());
	privatestatic Set usernameList= new HashSet();
	privateString username= null;
	privateString room= null;
	privateString info= null;
	private String lastAsked = null;
	private byte password[] = null;
	public void setLastAsked(String lastAsked) {
		this.lastAsked = lastAsked;
	}
	public String getLastAsked() {
		return lastAsked;
	}
	public void setPassword(byte[] password) {
		this.password = password;
	}
	public byte[] getPassword() {
		return password;
	}
	public boolean registerUsername(String username) {
		return usernameList.add(username);
	}
	public void deregisterUsername(String username) {
		usernameList.remove(username);
	}
	public voidsetUsername(String username) {
		this.username =username;
	}
	public String getUsername() {
		return username;
	}
	public voidsetRoom(String room) {
		this.room =room;
	}
	public String getRoom(){
		return room;
	}
	public String getClientId(){
		return username;
	}
	public String getClientKey() {
		if(room==null)return username;
		elsereturn username+""@""+room;
	}
	public voidsetClientInfo(String info) {
		this.info =info;
	}
	public String getClientInfo() {
		return getClientKey()+""- ""+info;
	}
	public String toString() {
		return getClientInfo();
	}
	public voidclean(){
		usernameList.remove(username);
		username = null;
		room = null;
		info = null;
		lastAsked = null;
	}
	public boolean isPoolable(){
		return true;
	}
	public PoolableObjectFactory getPoolableObjectFactory(){
		returnnewBasePoolableObjectFactory(){
			public Object makeObject() {
				 return new ChatData();
			}
			 public voidpassivateObject(Object obj){
				ChatData ed= (ChatData)obj;
				ed.clean();
			}
			 public voiddestroyObject(Object obj) {
				if(obj==null) return;
				passivateObject(obj);
				obj= null;
			}
			public boolean validateObject(Object obj) {
				if(obj==null) return false;
				elsereturn true;
			}
		}
		;
	}
}",0,1,0,0
"public class EventAdapterGenerator{
	 public static AdapterClassLoader ldr = new AdapterClassLoader();
	 static Class EVENTLISTENER = null;
	 static String CLASSPACKAGE = ""org/apache/bsf/util/event/adapters/"";
	 static String WRITEDIRECTORY = null;
	 static byte CLASSHEADER[];
	 static short BASECPCOUNT;
	 static byte BASECP[];
	 static byte FIXEDCLASSBYTES[];
	 static byte INITMETHOD[];
	 private static BSF_Log logger=null;
	 static {
		 logger = BSF_LogFactory.getLog((org.apache.bsf.util.event.generator.EventAdapterGenerator.class).getName());
		 String USERCLASSPACKAGE = System.getProperty(""DynamicEventClassPackage"", """");
		 if (!USERCLASSPACKAGE.equals("""")) {
			 CLASSPACKAGE = USERCLASSPACKAGE;
		 }
		 if(CLASSPACKAGE.length() > 0 ) {
			 CLASSPACKAGE = CLASSPACKAGE.replace('\\','/');
			 if(!CLASSPACKAGE.endsWith(""/"")) {
				 CLASSPACKAGE = CLASSPACKAGE+""/"";
			 }
		 }
		 WRITEDIRECTORY = System.getProperty(""DynamicEventClassWriteDirectory"",CLASSPACKAGE);
		 if(WRITEDIRECTORY.length() > 0 ) {
			 WRITEDIRECTORY = WRITEDIRECTORY.replace('\\','/');
			 if(!WRITEDIRECTORY.endsWith(""/"")) {
				 WRITEDIRECTORY = WRITEDIRECTORY+""/"";
			 }
		 }
		 try {
			 EVENTLISTENER=null;
			 ClassLoader tccl=Thread.currentThread().getContextClassLoader();
			 if (tccl!=null) {
				 try {
					 EVENTLISTENER = tccl.loadClass (""java.util.EventListener"");
				 }
				 catch(ClassNotFoundException ex01) {
				}
			 }
			 if (EVENTLISTENER==null) {
				 EVENTLISTENER = BSFManager.getDefinedClassLoader().loadClass (""java.util.EventListener"");
			 }
		 }
		 catch(ClassNotFoundException ex) {
			 System.err.println(ex.getMessage());
			 ex.printStackTrace();
		 }
		 CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xCA);
		 CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xFE);
		 CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xBA);
		 CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xBE);
		 CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(short)3);
		 CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(short)45);
		 BASECPCOUNT = 17;
		 BASECP = Bytecode.addUtf8(BASECP,""()V"");
		 BASECP = Bytecode.addUtf8(BASECP,""<init>"");
		 BASECP = Bytecode.addUtf8(BASECP,""Code"");
		 BASECP = Bytecode.addUtf8(BASECP,""eventProcessor"");
		 BASECP = Bytecode.addUtf8(BASECP,""java/lang/Object"");
		 BASECP = Bytecode.addUtf8(BASECP,""org/apache/bsf/util/event/EventAdapterImpl"");
		 BASECP = Bytecode.addUtf8(BASECP,""org/apache/bsf/util/event/EventProcessor"");
		 BASECP = Bytecode.addUtf8(BASECP,""(Ljava/lang/String;
		[Ljava/lang/Object;
		)V"");
		 BASECP = Bytecode.addUtf8(BASECP,""Lorg/apache/bsf/util/event/EventProcessor;
		"");
		 BASECP = Bytecode.addClass(BASECP,(short)5);
		 BASECP = Bytecode.addClass(BASECP,(short)6);
		 BASECP = Bytecode.addClass(BASECP,(short)7);
		 BASECP = Bytecode.addNameAndType(BASECP,(short)2,(short)1);
		 BASECP = Bytecode.addNameAndType(BASECP,(short)4,(short)9);
		 BASECP = Bytecode.addFieldRef(BASECP,(short)11,(short)14);
		 BASECP = Bytecode.addMethodRef(BASECP,(short)11,(short)13);
		 FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)0x21);
		 FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)20);
		 FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)11);
		 FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)1);
		 FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)19);
		 FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)0);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)2);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)3);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(long)17);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(long)5);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0x2A);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0xB7);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)16);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0xB1);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)0);
		 INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)0);
	 }
	 public static Class makeEventAdapterClass(Class listenerType,boolean writeClassFile) {
		 logger.debug(""EventAdapterGenerator"");
		 if( EVENTLISTENER.isAssignableFrom(listenerType) ) {
			 boolean exceptionable = false;
			 boolean nonExceptionable = false;
			 byte constantPool[] = null;
			 short cpBaseIndex;
			 short cpCount = 0;
			 short cpExceptionBaseIndex;
			 short exceptionableCount;
			 short nonExceptionableCount;
			 String listenerTypeName = listenerType.getName();
			 logger.debug(""ListenerTypeName: ""+listenerTypeName);
			 String adapterClassName = CLASSPACKAGE+ (listenerTypeName.endsWith(""Listener"") ? listenerTypeName.substring(0, listenerTypeName.length() - 8) : listenerTypeName).replace('.', '_') + ""Adapter"";
			 String finalAdapterClassName = adapterClassName;
			 Class cached = null;
			 int suffixIndex = 0;
			 do {
				 if (null != (cached = ldr.getLoadedClass(finalAdapterClassName))) {
					 logger.debug(""cached: ""+cached);
					 try {
						 if (!listenerType.isAssignableFrom(cached)) finalAdapterClassName = adapterClassName + ""_"" + suffixIndex++;
						 else return cached;
					 }
					 catch(VerifyError ex) {
						 System.err.println(ex.getMessage());
						 ex.printStackTrace();
						 return cached;
					 }
				 }
			 }
			 while (cached != null);
			 String eventListenerName = listenerTypeName.replace('.', '/');
			 java.lang.reflect.Method lms[] = listenerType.getMethods();
			 cpCount += 4;
			 constantPool = Bytecode.addUtf8(constantPool,eventListenerName);
			 constantPool = Bytecode.addUtf8(constantPool,finalAdapterClassName);
			 constantPool = Bytecode.addClass(constantPool,(short)17);
			 constantPool = Bytecode.addClass(constantPool,(short)18);
			 for (int i = 0 ;
			 i < lms.length ;
			 ++i) {
				 Class exceptionTypes[] = lms[i].getExceptionTypes();
				 if( 0 < exceptionTypes.length) {
					 exceptionable = true;
				 }
				 else {
					 nonExceptionable = true;
				 }
			 }
			 nonExceptionableCount = 0;
			 if(nonExceptionable) {
				 nonExceptionableCount = 3;
				 cpCount += nonExceptionableCount;
				 constantPool = Bytecode.addUtf8(constantPool,""processEvent"");
				 constantPool = Bytecode.addNameAndType(constantPool,(short)21,(short)8);
				 constantPool = Bytecode.addInterfaceMethodRef(constantPool,(short)12,(short)22);
			 }
			 exceptionableCount = 0;
			 if(exceptionable) {
				 int classIndex = BASECPCOUNT + cpCount + 1;
				 int nameIndex = BASECPCOUNT + cpCount + 0;
				 int natIndex = BASECPCOUNT + cpCount + 3;
				 exceptionableCount = 5;
				 cpCount += exceptionableCount;
				 constantPool = Bytecode.addUtf8(constantPool,""processExceptionableEvent"");
				 constantPool = Bytecode.addUtf8(constantPool,""java/lang/Exception"");
				 constantPool = Bytecode.addClass(constantPool,(short)classIndex);
				 constantPool = Bytecode.addNameAndType(constantPool,(short)nameIndex,(short)8);
				 constantPool = Bytecode.addInterfaceMethodRef(constantPool,(short)12,(short)natIndex);
			 }
			 cpBaseIndex = (short)(BASECPCOUNT + cpCount);
			 logger.debug(""cpBaseIndex: "" + cpBaseIndex);
			 for (int i = 0 ;
			 i < lms.length ;
			 ++i) {
				 String eventMethodName = lms[i].getName();
				 String eventName = lms[i].getParameterTypes()[0].getName().replace('.','/');
				 cpCount += 3;
				 constantPool = Bytecode.addUtf8(constantPool,eventMethodName);
				 constantPool = Bytecode.addUtf8(constantPool,(""(L"" + eventName + "";
				)V""));
				 constantPool = Bytecode.addString(constantPool,(short)(BASECPCOUNT+cpCount-3));
			 }
			 boolean propertyChangeFlag[] = new boolean[lms.length];
			 int cpIndexPCE = 0;
			 for (int i = 0 ;
			 i < lms.length ;
			 ++i) {
				 String eventName = lms[i].getParameterTypes()[0].getName().replace('.','/');
				 if(eventName.equalsIgnoreCase(""java/beans/PropertyChangeEvent"")) {
					 propertyChangeFlag[i] = true;
					 if( 0 == cpIndexPCE ) {
						 constantPool = Bytecode.addUtf8(constantPool,eventName);
						 constantPool = Bytecode.addUtf8(constantPool,""getPropertyName"");
						 constantPool = Bytecode.addUtf8(constantPool,""()Ljava/lang/String;
						"");
						 constantPool = Bytecode.addClass(constantPool,(short)(BASECPCOUNT + cpCount));
						 constantPool = Bytecode.addNameAndType(constantPool, (short)(BASECPCOUNT + cpCount + 1), (short)(BASECPCOUNT + cpCount + 2));
						 constantPool = Bytecode.addMethodRef(constantPool, (short)(BASECPCOUNT + cpCount + 3), (short)(BASECPCOUNT + cpCount + 4));
						 cpCount += 6;
						 cpIndexPCE = BASECPCOUNT + cpCount - 1;
					 }
				 }
				 else {
					 propertyChangeFlag[i] = false;
				 }
			 }
			 cpExceptionBaseIndex = (short)(BASECPCOUNT + cpCount);
			 logger.debug(""cpExceptionBaseIndex: "" + cpExceptionBaseIndex);
			 int excpIndex[][] = new int[lms.length][];
			 for (int i = 0 ;
			 i < lms.length ;
			 ++i) {
				 Class exceptionTypes[] = lms[i].getExceptionTypes();
				 excpIndex[i] = new int[exceptionTypes.length];
				 for ( int j = 0 ;
				 j < exceptionTypes.length ;
				 j++) {
					 constantPool = Bytecode.addUtf8(constantPool,exceptionTypes[j].getName().replace('.', '/'));
					 constantPool = Bytecode.addClass(constantPool,(short)(BASECPCOUNT+cpCount));
					 excpIndex[i][j] = BASECPCOUNT + cpCount + 1;
					 cpCount += 2;
				 }
			 }
			 byte newClass[] = CLASSHEADER;
			 short count = (short)(BASECPCOUNT + cpCount);
			 newClass = ByteUtility.addBytes(newClass,count);
			 newClass = ByteUtility.addBytes(newClass,BASECP);
			 newClass = ByteUtility.addBytes(newClass,constantPool);
			 newClass = ByteUtility.addBytes(newClass,FIXEDCLASSBYTES);
			 newClass = ByteUtility.addBytes(newClass,(short)(lms.length+1));
			 newClass = ByteUtility.addBytes(newClass,INITMETHOD);
			 for (int i = 0 ;
			 i < lms.length ;
			 ++i) {
				 newClass = ByteUtility.addBytes(newClass,(short)1);
				 newClass = ByteUtility.addBytes(newClass,(short)(cpBaseIndex+3*i+0));
				 newClass = ByteUtility.addBytes(newClass,(short)(cpBaseIndex+3*i+1));
				 newClass = ByteUtility.addBytes(newClass,(short)1);
				 newClass = ByteUtility.addBytes(newClass,(short)3);
				 int length = 32;
				 if( 0 < excpIndex[i].length ) {
					 length += 5 + 8 * ( 1 + excpIndex[i].length );
				 }
				 if(propertyChangeFlag[i]) {
					 length += 2;
				 }
				 newClass = ByteUtility.addBytes(newClass,(long)length);
				 newClass = ByteUtility.addBytes(newClass,(short)6);
				 newClass = ByteUtility.addBytes(newClass,(short)3);
				 length = 20;
				 if(exceptionable && 0 < excpIndex[i].length) {
					 length += 5;
				 }
				 if(propertyChangeFlag[i]) {
					 length += 2;
				 }
				 newClass = ByteUtility.addBytes(newClass,(long)length);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x2A);
				 newClass = ByteUtility.addBytes(newClass,(byte)0xB4);
				 newClass = ByteUtility.addBytes(newClass,(short)15);
				 if(propertyChangeFlag[i]) {
					 newClass = ByteUtility.addBytes(newClass,(byte)0x2B);
					 newClass = ByteUtility.addBytes(newClass,(byte)0xB6);
					 newClass = ByteUtility.addBytes(newClass,(short)cpIndexPCE);
				 }
				 else {
					 newClass = ByteUtility.addBytes(newClass,(byte)0x12);
					 newClass = ByteUtility.addBytes(newClass,(byte)(cpBaseIndex+3*i+2));
				 }
				 newClass = ByteUtility.addBytes(newClass,(byte)0x04);
				 newClass = ByteUtility.addBytes(newClass,(byte)0xBD);
				 newClass = ByteUtility.addBytes(newClass,(short)10);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x59);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x03);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x2B);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x53);
				 newClass = ByteUtility.addBytes(newClass,(byte)0xB9);
				 length = 23;
				 if(exceptionable && nonExceptionable) {
					 if( 0 < lms[i].getExceptionTypes().length ) {
						 length += 5;
					 }
				 }
				 else if(exceptionable) {
					 length += 2;
				 }
				 newClass = ByteUtility.addBytes(newClass,(short)length);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x03);
				 newClass = ByteUtility.addBytes(newClass,(byte)0x00);
				 newClass = ByteUtility.addBytes(newClass,(byte)0xB1);
				 if(exceptionable && 0 < excpIndex[i].length) {
					 newClass = ByteUtility.addBytes(newClass,(byte)0x4D);
					 newClass = ByteUtility.addBytes(newClass,(byte)0x2C);
					 newClass = ByteUtility.addBytes(newClass,(byte)0xBF);
					 newClass = ByteUtility.addBytes(newClass,(byte)0x57);
					 newClass = ByteUtility.addBytes(newClass,(byte)0xB1);
					 length = excpIndex[i].length;
					 newClass = ByteUtility.addBytes(newClass,(short)(1+length));
					 for( int j = 0 ;
					 j < length ;
					 j++ ) {
						 newClass = ByteUtility.addBytes(newClass,(short)0);
						 if(propertyChangeFlag[i]) {
							 newClass = ByteUtility.addBytes(newClass,(short)21);
							 newClass = ByteUtility.addBytes(newClass,(short)22);
						 }
						 else {
							 newClass = ByteUtility.addBytes(newClass,(short)19);
							 newClass = ByteUtility.addBytes(newClass,(short)20);
						 }
						 newClass = ByteUtility.addBytes(newClass,(short)excpIndex[i][j]);
					 }
					 newClass = ByteUtility.addBytes(newClass,(short)0);
					 if(propertyChangeFlag[i]) {
						 newClass = ByteUtility.addBytes(newClass,(short)21);
						 newClass = ByteUtility.addBytes(newClass,(short)25);
					 }
					 else {
						 newClass = ByteUtility.addBytes(newClass,(short)19);
						 newClass = ByteUtility.addBytes(newClass,(short)23);
					 }
					 if(nonExceptionable) {
						 newClass = ByteUtility.addBytes(newClass,(short)26);
					 }
					 else {
						 newClass = ByteUtility.addBytes(newClass,(short)23);
					 }
				 }
				 else {
					 newClass = ByteUtility.addBytes(newClass,(short)0);
				 }
				 newClass = ByteUtility.addBytes(newClass,(short)0);
			 }
			 newClass = ByteUtility.addBytes(newClass,(short)0);
			 logger.debug(""adapterName: "" + finalAdapterClassName);
			 logger.debug(""cpCount: "" + count + "" = "" + BASECPCOUNT + "" + "" + cpCount);
			 logger.debug(""methodCount: "" + (lms.length+1));
			 if (writeClassFile) {
				 try {
					 FileOutputStream fos = new FileOutputStream(finalAdapterClassName+"".class"");
					 fos.write(newClass);
					 fos.close();
				 }
				 catch(IOException ex) {
					 System.err.println(ex.getMessage());
					 ex.printStackTrace();
				 }
				 try {
					 Class ret = ldr.loadClass(finalAdapterClassName);
					 logger.debug(""EventAdapterGenerator: "" + ret.getName() + "" dynamically generated"");
					 return ret;
				 }
				 catch (ClassNotFoundException ex) {
					 System.err.println(ex.getMessage());
					 ex.printStackTrace();
				 }
			 }
			 try {
				 Class ret = ldr.defineClass(finalAdapterClassName,newClass);
				 logger.debug(""EventAdapterGenerator: "" + ret.getName() + "" dynamically generated"");
				 return ret;
			 }
			 catch(Throwable ex) {
				 System.err.println(ex.getMessage());
				 ex.printStackTrace();
			 }
		 }
		 return null;
	 }
}",1,0,0,0
"class LastAck {
	 long lastAckedSequence;
	 byte priority;
	 public LastAck(LastAck source) {
		 this.lastAckedSequence = source.lastAckedSequence;
		 this.priority = source.priority;
	 }
	 public LastAck() {
		 this.priority = MessageOrderIndex.HI;
	 }
	 public LastAck(long ackLocation) {
		 this.lastAckedSequence = ackLocation;
		 this.priority = MessageOrderIndex.LO;
	 }
	 public LastAck(long ackLocation, byte priority) {
		 this.lastAckedSequence = ackLocation;
		 this.priority = priority;
	 }
	 public String toString() {
		 return ""["" + lastAckedSequence + "":"" + priority + ""]"";
	 }
 }",0,1,0,0
"and Save Specification</a>.public class DOMInputImpl implements LSInput {
	protected String fPublicId = null;
	protected String fSystemId = null;
	protected String fBaseSystemId = null;
	protected InputStream fByteStream = null;
	protected Reader fCharStream= null;
	protected String fData = null;
	protected String fEncoding = null;
	 protected boolean fCertifiedText = false;
	 public DOMInputImpl() {
	}
	 public DOMInputImpl(String publicId, String systemId, String baseSystemId) {
		fPublicId = publicId;
		fSystemId = systemId;
		fBaseSystemId = baseSystemId;
	 }
	 public DOMInputImpl(String publicId, String systemId, String baseSystemId, InputStream byteStream, String encoding) {
		fPublicId = publicId;
		fSystemId = systemId;
		fBaseSystemId = baseSystemId;
		fByteStream = byteStream;
		fEncoding = encoding;
	 }
	 public DOMInputImpl(String publicId, String systemId, String baseSystemId, Reader charStream, String encoding) {
		fPublicId = publicId;
		fSystemId = systemId;
		fBaseSystemId = baseSystemId;
		fCharStream = charStream;
		fEncoding = encoding;
	 }
	 public DOMInputImpl(String publicId, String systemId, String baseSystemId, String data, String encoding) {
		 fPublicId = publicId;
		fSystemId = systemId;
		fBaseSystemId = baseSystemId;
		fData = data;
		fEncoding = encoding;
	 }
	 public InputStream getByteStream(){
		return fByteStream;
	 }
	 public void setByteStream(InputStream byteStream){
		 fByteStream = byteStream;
	 }
	 public Reader getCharacterStream(){
		return fCharStream;
	 }
	 public void setCharacterStream(Reader characterStream){
		fCharStream = characterStream;
	 }
	 public String getStringData(){
		return fData;
	 }
	 public void setStringData(String stringData){
		fData = stringData;
	 }
	 public String getEncoding(){
		return fEncoding;
	 }
	 public void setEncoding(String encoding){
		fEncoding = encoding;
	 }
	 public String getPublicId(){
		return fPublicId;
	 }
	 public void setPublicId(String publicId){
		fPublicId = publicId;
	 }
	 public String getSystemId(){
		return fSystemId;
	 }
	 public void setSystemId(String systemId){
		fSystemId = systemId;
	 }
	 public String getBaseURI(){
		return fBaseSystemId;
	 }
	 public void setBaseURI(String baseURI){
		fBaseSystemId = baseURI;
	 }
	 public boolean getCertifiedText(){
		 return fCertifiedText;
	 }
	 public void setCertifiedText(boolean certifiedText){
		 fCertifiedText = certifiedText;
	 }
}",0,1,0,0
"public void startElement(String uri, String localName, String qName) throws SAXException;",0,0,0,1
"public class OntologyJavaClassCreatorMojo extends AbstractMojo {
	 private String baseDir;
	 private String resourcePath;
	 private Properties namespaceOfOntology;
	 private File [] sources;
	 private MavenProject project;
	 private Map<String, String> supportedFormats = new HashMap<String, String>();
	 public void execute() throws MojoExecutionException {
		 supportedFormats.put("".nt"", ""application/n-triples"");
		 supportedFormats.put("".n3"", ""text/rdf+n3"");
		 supportedFormats.put("".rdf"", ""application/rdf+xml"");
		 supportedFormats.put("".ttl"", ""text/turtle"");
		 supportedFormats.put("".turtle"", ""text/turtle"");
		 File file = null;
		 if (resourcePath == null) {
			 resourcePath = baseDir + File.separator + ""src"" + File.separator + ""main"" + File.separator + ""ontologies"";
		 }
		 else if (resourcePath.contains(""/"")) {
			 resourcePath = resourcePath.replace(""/"", File.separator);
		 }
		 else if (resourcePath.contains(""\\"")) {
			 resourcePath = resourcePath.replace(""\\"", File.separator);
		 }
		 file = new File(resourcePath);
		 checkDir(file);
		 if(sources != null) {
			 for ( int i = 0;
			 i < sources.length;
			 ++i ) {
				 project.addCompileSourceRoot( this.sources[i].getAbsolutePath() );
				 getLog().info( ""Source directory: "" + this.sources[i] + "" added."" );
			 }
		 }
	 }
	 private void checkDir(File ontologiesDir) {
		 for (File file : ontologiesDir.listFiles()) {
			 if (file.isDirectory()) {
				 checkDir(file);
			 }
			 else {
				 String fileName = file.getName();
				 int indexOfLastDot = fileName.lastIndexOf(""."");
				 if (indexOfLastDot != -1) {
					 String fileEnding = fileName.substring(indexOfLastDot);
					 if (supportedFormats.containsKey(fileEnding)) {
						 createJavaClassFile(file, fileEnding);
					 }
				 }
			 }
		 }
	 }
	 private void createJavaClassFile(final File file, final String fileEnding) {
		 final String fileName = file.getName();
		 final String absolutePath = file.getAbsolutePath();
		 final String className = fileName.replace(fileEnding, """").toUpperCase();
		 final String pathToJavaClass = absolutePath.substring( absolutePath.indexOf(resourcePath) + resourcePath.length() + 1) .replace(fileName, """");
		 final String packageName = pathToJavaClass.replace(File.separator, ""."") + className;
		 SchemaGenArguments arguments = new SchemaGenArguments() {
			 public URL getSchemaUrl() {
				 try {
					 return file.toURI().toURL();
				 }
				 catch (MalformedURLException e) {
					 getLog().error(e.getMessage(), e);
				 }
				 return null;
			 }
			 public String getNamespace() {
				 if (namespaceOfOntology != null && namespaceOfOntology.containsKey(fileName)) {
					 return namespaceOfOntology.getProperty(fileName);
				 }
				 return null;
			 }
			 public String getFormatIdentifier() {
				 return supportedFormats.get(fileEnding);
			 }
			 public String getClassName() {
				 return packageName;
			 }
		 }
		;
		 SchemaGen schemaGen;
		 try {
			 schemaGen = new SchemaGen(arguments);
		 }
		 catch (IOException e) {
			 getLog().error(e.getMessage(), e);
			 return;
		 }
		 catch (URISyntaxException e) {
			 getLog().error(e.getMessage(), e);
			 return;
		 }
		 String rootPath = baseDir + File.separator + ""target"" + File.separator + ""generated-sources"" + File.separator + ""main"" + File.separator + ""java"" + File.separator;
		 File dir = new File(rootPath + pathToJavaClass);
		 dir.mkdirs();
		 PrintWriter out = null;
		 try {
			 out = new PrintWriter(new File(rootPath + pathToJavaClass + className + "".java""), ""utf-8"");
		 }
		 catch (FileNotFoundException e) {
			 getLog().error(e.getMessage(), e);
			 return;
		 }
		 catch (UnsupportedEncodingException e) {
			 getLog().error(e.getMessage(), e);
			 throw new RuntimeException(""utf-8 not supported!"");
		 }
		 try {
			 schemaGen.writeClass(out);
		 }
		 finally {
			 out.flush();
		 }
	 }
}",0,0,0,0
"class WSDLReaderImpl extends com.ibm.wsdl.xml.WSDLReaderImpl {
	 private WSDLFactory _localFactory;
	 WSDLReaderImpl(WSDLFactory factory) {
		 _localFactory = factory;
	 }
	 protected WSDLFactory getWSDLFactory() throws WSDLException {
		 return _localFactory;
	 }
	 public Binding parseBinding(Element bindingEl, Definition def) throws WSDLException {
		 Binding binding = super.parseBinding(bindingEl, def);
		 binding.setDocumentationElement(null);
		 return binding;
	 }
	 public BindingFault parseBindingFault(Element bindingFaultEl, Definition def) throws WSDLException {
		 BindingFault bindingFault = super.parseBindingFault(bindingFaultEl, def);
		 bindingFault.setDocumentationElement(null);
		 return bindingFault;
	 }
	 public BindingInput parseBindingInput(Element bindingInputEl, Definition def) throws WSDLException {
		 BindingInput bindingInput = super.parseBindingInput(bindingInputEl, def);
		 bindingInput.setDocumentationElement(null);
		 return bindingInput;
	 }
	 public BindingOperation parseBindingOperation(Element bindingOperationEl, PortType portType, Definition def) throws WSDLException {
		 BindingOperation bindingOperation = super.parseBindingOperation(bindingOperationEl, portType, def);
		 bindingOperation.setDocumentationElement(null);
		 return bindingOperation;
	 }
	 public BindingOutput parseBindingOutput(Element bindingOutputEl, Definition def) throws WSDLException {
		 BindingOutput BindingOutput = super.parseBindingOutput(bindingOutputEl, def);
		 BindingOutput.setDocumentationElement(null);
		 return BindingOutput;
	 }
	 public Definition parseDefinitions(String documentBaseURI, Element defEl, Map importedDefs) throws WSDLException {
		 Definition definition = super.parseDefinitions(documentBaseURI, defEl, importedDefs);
		 definition.setDocumentationElement(null);
		 return definition;
	 }
	 public Fault parseFault(Element faultEl, Definition def) throws WSDLException {
		 Fault fault = super.parseFault(faultEl, def);
		 fault.setDocumentationElement(null);
		 return fault;
	 }
	 public Input parseInput(Element inputEl, Definition def) throws WSDLException {
		 Input input = super.parseInput(inputEl, def);
		 input.setDocumentationElement(null);
		 return input;
	 }
	 public Message parseMessage(Element msgEl, Definition def) throws WSDLException {
		 Message message = super.parseMessage(msgEl, def);
		 message.setDocumentationElement(null);
		 return message;
	 }
	 public Operation parseOperation(Element opEl, PortType portType, Definition def) throws WSDLException {
		 Operation operation = super.parseOperation(opEl, portType, def);
		 operation.setDocumentationElement(null);
		 return operation;
	 }
	 public Output parseOutput(Element outputEl, Definition def) throws WSDLException {
		 Output output = super.parseOutput(outputEl, def);
		 output.setDocumentationElement(null);
		 return output;
	 }
	 public Part parsePart(Element partEl, Definition def) throws WSDLException {
		 Part part = super.parsePart(partEl, def);
		 part.setDocumentationElement(null);
		 return part;
	 }
	 public Port parsePort(Element portEl, Definition def) throws WSDLException {
		 Port Port = super.parsePort(portEl, def);
		 Port.setDocumentationElement(null);
		 return Port;
	 }
	 public PortType parsePortType(Element portTypeEl, Definition def) throws WSDLException {
		 PortType portType = super.parsePortType(portTypeEl, def);
		 portType.setDocumentationElement(null);
		 return portType;
	 }
	 public Service parseService(Element serviceEl, Definition def) throws WSDLException {
		 Service service = super.parseService(serviceEl, def);
		 service.setDocumentationElement(null);
		 return service;
	 }
	 public Types parseTypes(Element typesEl, Definition def) throws WSDLException {
		 Types types = super.parseTypes(typesEl, def);
		 types.setDocumentationElement(null);
		 return types;
	 }
}",1,0,0,0
"public class MidpointFieldIntegrator<T extends RealFieldElement<T>> extends RungeKuttaFieldIntegrator<T> {
	 public MidpointFieldIntegrator(final Field<T> field, final T step) {
		 super(field, ""midpoint"", step);
	 }
	 public T[] getC() {
		 final T[] c = MathArrays.buildArray(getField(), 1);
		 c[0] = getField().getOne().multiply(0.5);
		 return c;
	 }
	 public T[][] getA() {
		 final T[][] a = MathArrays.buildArray(getField(), 1, 1);
		 a[0][0] = fraction(1, 2);
		 return a;
	 }
	 public T[] getB() {
		 final T[] b = MathArrays.buildArray(getField(), 2);
		 b[0] = getField().getZero();
		 b[1] = getField().getOne();
		 return b;
	 }
	 protected MidpointFieldStepInterpolator<T> createInterpolator(final boolean forward, T[][] yDotK, final FieldODEStateAndDerivative<T> globalPreviousState, final FieldODEStateAndDerivative<T> globalCurrentState, final FieldEquationsMapper<T> mapper) {
		 return new MidpointFieldStepInterpolator<>(getField(), forward, yDotK, globalPreviousState, globalCurrentState, globalPreviousState, globalCurrentState, mapper);
	 }
}",0,0,0,0
"private boolean namedNodeMapsEqual(NamedNodeMap a, NamedNodeMap b) {
	 if (a.getLength() != b.getLength()) {
		 return false;
	 }
	 for (int i = 0;
	 i < a.getLength();
	 i++) {
		 Node aNode = a.item(i);
		 Node bNode = aNode.getLocalName() == null ? b.getNamedItem(aNode.getNodeName()) : b.getNamedItemNS(aNode.getNamespaceURI(), aNode.getLocalName());
		 if (bNode == null || !aNode.isEqualNode(bNode)) {
			 return false;
		 }
	 }
	 return true;
 }",0,0,0,0
"public void finalizeBlock(Block b) throws IOException {
	 synchronized (ongoingCreates) {
		 File f = ongoingCreates.get(b);
		 if (f == null || ! f.exists()) {
			 throw new IOException(""No temporary file "" + f + "" for block "" + b);
		 }
		 long finalLen = f.length();
		 b.setNumBytes(finalLen);
		 FSVolume v = volumeMap.get(b);
		 File dest = v.addBlock(b, f);
		 blockMap.put(b, dest);
		 ongoingCreates.remove(b);
	 }
 }",0,0,0,0
"public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements org.apache.drill.exec.proto.UserProtos.GetTablesReqOrBuilder {
	 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
		 return org.apache.drill.exec.proto.UserProtos.internal_static_exec_user_GetTablesReq_descriptor;
	 }
	 protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
		 return org.apache.drill.exec.proto.UserProtos.internal_static_exec_user_GetTablesReq_fieldAccessorTable .ensureFieldAccessorsInitialized( org.apache.drill.exec.proto.UserProtos.GetTablesReq.class, org.apache.drill.exec.proto.UserProtos.GetTablesReq.Builder.class);
	 }
	 private Builder() {
		 maybeForceBuilderInitialization();
	 }
	 private Builder( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
		 super(parent);
		 maybeForceBuilderInitialization();
	 }
	 private void maybeForceBuilderInitialization() {
		 if (com.google.protobuf.GeneratedMessageV3 .alwaysUseFieldBuilders) {
			 getCatalogNameFilterFieldBuilder();
			 getSchemaNameFilterFieldBuilder();
			 getTableNameFilterFieldBuilder();
		 }
	 }
	 public Builder clear() {
		 super.clear();
		 if (catalogNameFilterBuilder_ == null) {
			 catalogNameFilter_ = null;
		 }
		 else {
			 catalogNameFilterBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000001);
		 if (schemaNameFilterBuilder_ == null) {
			 schemaNameFilter_ = null;
		 }
		 else {
			 schemaNameFilterBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000002);
		 if (tableNameFilterBuilder_ == null) {
			 tableNameFilter_ = null;
		 }
		 else {
			 tableNameFilterBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000004);
		 tableTypeFilter_ = com.google.protobuf.LazyStringArrayList.EMPTY;
		 bitField0_ = (bitField0_ & ~0x00000008);
		 return this;
	 }
	 public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
		 return org.apache.drill.exec.proto.UserProtos.internal_static_exec_user_GetTablesReq_descriptor;
	 }
	 public org.apache.drill.exec.proto.UserProtos.GetTablesReq getDefaultInstanceForType() {
		 return org.apache.drill.exec.proto.UserProtos.GetTablesReq.getDefaultInstance();
	 }
	 public org.apache.drill.exec.proto.UserProtos.GetTablesReq build() {
		 org.apache.drill.exec.proto.UserProtos.GetTablesReq result = buildPartial();
		 if (!result.isInitialized()) {
			 throw newUninitializedMessageException(result);
		 }
		 return result;
	 }
	 public org.apache.drill.exec.proto.UserProtos.GetTablesReq buildPartial() {
		 org.apache.drill.exec.proto.UserProtos.GetTablesReq result = new org.apache.drill.exec.proto.UserProtos.GetTablesReq(this);
		 int from_bitField0_ = bitField0_;
		 int to_bitField0_ = 0;
		 if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
			 to_bitField0_ |= 0x00000001;
		 }
		 if (catalogNameFilterBuilder_ == null) {
			 result.catalogNameFilter_ = catalogNameFilter_;
		 }
		 else {
			 result.catalogNameFilter_ = catalogNameFilterBuilder_.build();
		 }
		 if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
			 to_bitField0_ |= 0x00000002;
		 }
		 if (schemaNameFilterBuilder_ == null) {
			 result.schemaNameFilter_ = schemaNameFilter_;
		 }
		 else {
			 result.schemaNameFilter_ = schemaNameFilterBuilder_.build();
		 }
		 if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
			 to_bitField0_ |= 0x00000004;
		 }
		 if (tableNameFilterBuilder_ == null) {
			 result.tableNameFilter_ = tableNameFilter_;
		 }
		 else {
			 result.tableNameFilter_ = tableNameFilterBuilder_.build();
		 }
		 if (((bitField0_ & 0x00000008) == 0x00000008)) {
			 tableTypeFilter_ = tableTypeFilter_.getUnmodifiableView();
			 bitField0_ = (bitField0_ & ~0x00000008);
		 }
		 result.tableTypeFilter_ = tableTypeFilter_;
		 result.bitField0_ = to_bitField0_;
		 onBuilt();
		 return result;
	 }
	 public Builder clone() {
		 return (Builder) super.clone();
	 }
	 public Builder setField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
		 return (Builder) super.setField(field, value);
	 }
	 public Builder clearField( com.google.protobuf.Descriptors.FieldDescriptor field) {
		 return (Builder) super.clearField(field);
	 }
	 public Builder clearOneof( com.google.protobuf.Descriptors.OneofDescriptor oneof) {
		 return (Builder) super.clearOneof(oneof);
	 }
	 public Builder setRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
		 return (Builder) super.setRepeatedField(field, index, value);
	 }
	 public Builder addRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
		 return (Builder) super.addRepeatedField(field, value);
	 }
	 public Builder mergeFrom(com.google.protobuf.Message other) {
		 if (other instanceof org.apache.drill.exec.proto.UserProtos.GetTablesReq) {
			 return mergeFrom((org.apache.drill.exec.proto.UserProtos.GetTablesReq)other);
		 }
		 else {
			 super.mergeFrom(other);
			 return this;
		 }
	 }
	 public Builder mergeFrom(org.apache.drill.exec.proto.UserProtos.GetTablesReq other) {
		 if (other == org.apache.drill.exec.proto.UserProtos.GetTablesReq.getDefaultInstance()) return this;
		 if (other.hasCatalogNameFilter()) {
			 mergeCatalogNameFilter(other.getCatalogNameFilter());
		 }
		 if (other.hasSchemaNameFilter()) {
			 mergeSchemaNameFilter(other.getSchemaNameFilter());
		 }
		 if (other.hasTableNameFilter()) {
			 mergeTableNameFilter(other.getTableNameFilter());
		 }
		 if (!other.tableTypeFilter_.isEmpty()) {
			 if (tableTypeFilter_.isEmpty()) {
				 tableTypeFilter_ = other.tableTypeFilter_;
				 bitField0_ = (bitField0_ & ~0x00000008);
			 }
			 else {
				 ensureTableTypeFilterIsMutable();
				 tableTypeFilter_.addAll(other.tableTypeFilter_);
			 }
			 onChanged();
		 }
		 this.mergeUnknownFields(other.unknownFields);
		 onChanged();
		 return this;
	 }
	 public final boolean isInitialized() {
		 return true;
	 }
	 public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 org.apache.drill.exec.proto.UserProtos.GetTablesReq parsedMessage = null;
		 try {
			 parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
		 }
		 catch (com.google.protobuf.InvalidProtocolBufferException e) {
			 parsedMessage = (org.apache.drill.exec.proto.UserProtos.GetTablesReq) e.getUnfinishedMessage();
			 throw e.unwrapIOException();
		 }
		 finally {
			 if (parsedMessage != null) {
				 mergeFrom(parsedMessage);
			 }
		 }
		 return this;
	 }
	 private int bitField0_;
	 private org.apache.drill.exec.proto.UserProtos.LikeFilter catalogNameFilter_ = null;
	 private com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder> catalogNameFilterBuilder_;
	 public boolean hasCatalogNameFilter() {
		 return ((bitField0_ & 0x00000001) == 0x00000001);
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilter getCatalogNameFilter() {
		 if (catalogNameFilterBuilder_ == null) {
			 return catalogNameFilter_ == null ? org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance() : catalogNameFilter_;
		 }
		 else {
			 return catalogNameFilterBuilder_.getMessage();
		 }
	 }
	 public Builder setCatalogNameFilter(org.apache.drill.exec.proto.UserProtos.LikeFilter value) {
		 if (catalogNameFilterBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 catalogNameFilter_ = value;
			 onChanged();
		 }
		 else {
			 catalogNameFilterBuilder_.setMessage(value);
		 }
		 bitField0_ |= 0x00000001;
		 return this;
	 }
	 public Builder setCatalogNameFilter( org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder builderForValue) {
		 if (catalogNameFilterBuilder_ == null) {
			 catalogNameFilter_ = builderForValue.build();
			 onChanged();
		 }
		 else {
			 catalogNameFilterBuilder_.setMessage(builderForValue.build());
		 }
		 bitField0_ |= 0x00000001;
		 return this;
	 }
	 public Builder mergeCatalogNameFilter(org.apache.drill.exec.proto.UserProtos.LikeFilter value) {
		 if (catalogNameFilterBuilder_ == null) {
			 if (((bitField0_ & 0x00000001) == 0x00000001) && catalogNameFilter_ != null && catalogNameFilter_ != org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance()) {
				 catalogNameFilter_ = org.apache.drill.exec.proto.UserProtos.LikeFilter.newBuilder(catalogNameFilter_).mergeFrom(value).buildPartial();
			 }
			 else {
				 catalogNameFilter_ = value;
			 }
			 onChanged();
		 }
		 else {
			 catalogNameFilterBuilder_.mergeFrom(value);
		 }
		 bitField0_ |= 0x00000001;
		 return this;
	 }
	 public Builder clearCatalogNameFilter() {
		 if (catalogNameFilterBuilder_ == null) {
			 catalogNameFilter_ = null;
			 onChanged();
		 }
		 else {
			 catalogNameFilterBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000001);
		 return this;
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder getCatalogNameFilterBuilder() {
		 bitField0_ |= 0x00000001;
		 onChanged();
		 return getCatalogNameFilterFieldBuilder().getBuilder();
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder getCatalogNameFilterOrBuilder() {
		 if (catalogNameFilterBuilder_ != null) {
			 return catalogNameFilterBuilder_.getMessageOrBuilder();
		 }
		 else {
			 return catalogNameFilter_ == null ? org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance() : catalogNameFilter_;
		 }
	 }
	 private com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder> getCatalogNameFilterFieldBuilder() {
		 if (catalogNameFilterBuilder_ == null) {
			 catalogNameFilterBuilder_ = new com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder>( getCatalogNameFilter(), getParentForChildren(), isClean());
			 catalogNameFilter_ = null;
		 }
		 return catalogNameFilterBuilder_;
	 }
	 private org.apache.drill.exec.proto.UserProtos.LikeFilter schemaNameFilter_ = null;
	 private com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder> schemaNameFilterBuilder_;
	 public boolean hasSchemaNameFilter() {
		 return ((bitField0_ & 0x00000002) == 0x00000002);
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilter getSchemaNameFilter() {
		 if (schemaNameFilterBuilder_ == null) {
			 return schemaNameFilter_ == null ? org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance() : schemaNameFilter_;
		 }
		 else {
			 return schemaNameFilterBuilder_.getMessage();
		 }
	 }
	 public Builder setSchemaNameFilter(org.apache.drill.exec.proto.UserProtos.LikeFilter value) {
		 if (schemaNameFilterBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 schemaNameFilter_ = value;
			 onChanged();
		 }
		 else {
			 schemaNameFilterBuilder_.setMessage(value);
		 }
		 bitField0_ |= 0x00000002;
		 return this;
	 }
	 public Builder setSchemaNameFilter( org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder builderForValue) {
		 if (schemaNameFilterBuilder_ == null) {
			 schemaNameFilter_ = builderForValue.build();
			 onChanged();
		 }
		 else {
			 schemaNameFilterBuilder_.setMessage(builderForValue.build());
		 }
		 bitField0_ |= 0x00000002;
		 return this;
	 }
	 public Builder mergeSchemaNameFilter(org.apache.drill.exec.proto.UserProtos.LikeFilter value) {
		 if (schemaNameFilterBuilder_ == null) {
			 if (((bitField0_ & 0x00000002) == 0x00000002) && schemaNameFilter_ != null && schemaNameFilter_ != org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance()) {
				 schemaNameFilter_ = org.apache.drill.exec.proto.UserProtos.LikeFilter.newBuilder(schemaNameFilter_).mergeFrom(value).buildPartial();
			 }
			 else {
				 schemaNameFilter_ = value;
			 }
			 onChanged();
		 }
		 else {
			 schemaNameFilterBuilder_.mergeFrom(value);
		 }
		 bitField0_ |= 0x00000002;
		 return this;
	 }
	 public Builder clearSchemaNameFilter() {
		 if (schemaNameFilterBuilder_ == null) {
			 schemaNameFilter_ = null;
			 onChanged();
		 }
		 else {
			 schemaNameFilterBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000002);
		 return this;
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder getSchemaNameFilterBuilder() {
		 bitField0_ |= 0x00000002;
		 onChanged();
		 return getSchemaNameFilterFieldBuilder().getBuilder();
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder getSchemaNameFilterOrBuilder() {
		 if (schemaNameFilterBuilder_ != null) {
			 return schemaNameFilterBuilder_.getMessageOrBuilder();
		 }
		 else {
			 return schemaNameFilter_ == null ? org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance() : schemaNameFilter_;
		 }
	 }
	 private com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder> getSchemaNameFilterFieldBuilder() {
		 if (schemaNameFilterBuilder_ == null) {
			 schemaNameFilterBuilder_ = new com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder>( getSchemaNameFilter(), getParentForChildren(), isClean());
			 schemaNameFilter_ = null;
		 }
		 return schemaNameFilterBuilder_;
	 }
	 private org.apache.drill.exec.proto.UserProtos.LikeFilter tableNameFilter_ = null;
	 private com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder> tableNameFilterBuilder_;
	 public boolean hasTableNameFilter() {
		 return ((bitField0_ & 0x00000004) == 0x00000004);
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilter getTableNameFilter() {
		 if (tableNameFilterBuilder_ == null) {
			 return tableNameFilter_ == null ? org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance() : tableNameFilter_;
		 }
		 else {
			 return tableNameFilterBuilder_.getMessage();
		 }
	 }
	 public Builder setTableNameFilter(org.apache.drill.exec.proto.UserProtos.LikeFilter value) {
		 if (tableNameFilterBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 tableNameFilter_ = value;
			 onChanged();
		 }
		 else {
			 tableNameFilterBuilder_.setMessage(value);
		 }
		 bitField0_ |= 0x00000004;
		 return this;
	 }
	 public Builder setTableNameFilter( org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder builderForValue) {
		 if (tableNameFilterBuilder_ == null) {
			 tableNameFilter_ = builderForValue.build();
			 onChanged();
		 }
		 else {
			 tableNameFilterBuilder_.setMessage(builderForValue.build());
		 }
		 bitField0_ |= 0x00000004;
		 return this;
	 }
	 public Builder mergeTableNameFilter(org.apache.drill.exec.proto.UserProtos.LikeFilter value) {
		 if (tableNameFilterBuilder_ == null) {
			 if (((bitField0_ & 0x00000004) == 0x00000004) && tableNameFilter_ != null && tableNameFilter_ != org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance()) {
				 tableNameFilter_ = org.apache.drill.exec.proto.UserProtos.LikeFilter.newBuilder(tableNameFilter_).mergeFrom(value).buildPartial();
			 }
			 else {
				 tableNameFilter_ = value;
			 }
			 onChanged();
		 }
		 else {
			 tableNameFilterBuilder_.mergeFrom(value);
		 }
		 bitField0_ |= 0x00000004;
		 return this;
	 }
	 public Builder clearTableNameFilter() {
		 if (tableNameFilterBuilder_ == null) {
			 tableNameFilter_ = null;
			 onChanged();
		 }
		 else {
			 tableNameFilterBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000004);
		 return this;
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder getTableNameFilterBuilder() {
		 bitField0_ |= 0x00000004;
		 onChanged();
		 return getTableNameFilterFieldBuilder().getBuilder();
	 }
	 public org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder getTableNameFilterOrBuilder() {
		 if (tableNameFilterBuilder_ != null) {
			 return tableNameFilterBuilder_.getMessageOrBuilder();
		 }
		 else {
			 return tableNameFilter_ == null ? org.apache.drill.exec.proto.UserProtos.LikeFilter.getDefaultInstance() : tableNameFilter_;
		 }
	 }
	 private com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder> getTableNameFilterFieldBuilder() {
		 if (tableNameFilterBuilder_ == null) {
			 tableNameFilterBuilder_ = new com.google.protobuf.SingleFieldBuilderV3< org.apache.drill.exec.proto.UserProtos.LikeFilter, org.apache.drill.exec.proto.UserProtos.LikeFilter.Builder, org.apache.drill.exec.proto.UserProtos.LikeFilterOrBuilder>( getTableNameFilter(), getParentForChildren(), isClean());
			 tableNameFilter_ = null;
		 }
		 return tableNameFilterBuilder_;
	 }
	 private com.google.protobuf.LazyStringList tableTypeFilter_ = com.google.protobuf.LazyStringArrayList.EMPTY;
	 private void ensureTableTypeFilterIsMutable() {
		 if (!((bitField0_ & 0x00000008) == 0x00000008)) {
			 tableTypeFilter_ = new com.google.protobuf.LazyStringArrayList(tableTypeFilter_);
			 bitField0_ |= 0x00000008;
		 }
	 }
	 public com.google.protobuf.ProtocolStringList getTableTypeFilterList() {
		 return tableTypeFilter_.getUnmodifiableView();
	 }
	 public int getTableTypeFilterCount() {
		 return tableTypeFilter_.size();
	 }
	 public java.lang.String getTableTypeFilter(int index) {
		 return tableTypeFilter_.get(index);
	 }
	 public com.google.protobuf.ByteString getTableTypeFilterBytes(int index) {
		 return tableTypeFilter_.getByteString(index);
	 }
	 public Builder setTableTypeFilter( int index, java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 ensureTableTypeFilterIsMutable();
		 tableTypeFilter_.set(index, value);
		 onChanged();
		 return this;
	 }
	 public Builder addTableTypeFilter( java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 ensureTableTypeFilterIsMutable();
		 tableTypeFilter_.add(value);
		 onChanged();
		 return this;
	 }
	 public Builder addAllTableTypeFilter( java.lang.Iterable<java.lang.String> values) {
		 ensureTableTypeFilterIsMutable();
		 com.google.protobuf.AbstractMessageLite.Builder.addAll( values, tableTypeFilter_);
		 onChanged();
		 return this;
	 }
	 public Builder clearTableTypeFilter() {
		 tableTypeFilter_ = com.google.protobuf.LazyStringArrayList.EMPTY;
		 bitField0_ = (bitField0_ & ~0x00000008);
		 onChanged();
		 return this;
	 }
	 public Builder addTableTypeFilterBytes( com.google.protobuf.ByteString value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 ensureTableTypeFilterIsMutable();
		 tableTypeFilter_.add(value);
		 onChanged();
		 return this;
	 }
	 public final Builder setUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) {
		 return super.setUnknownFields(unknownFields);
	 }
	 public final Builder mergeUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) {
		 return super.mergeUnknownFields(unknownFields);
	 }
 }",1,0,0,0
"public String toString() {
	 StringBuilder sb = new StringBuilder();
	 sb.append(major).append('.').append(minor).append('.').append(patch);
	 if (preRelease != null) sb.append('-').append(StringUtils.join(preRelease, "".""));
	 if (build != null) sb.append('+').append(StringUtils.join(build, "".""));
	 return sb.toString();
 }",0,0,0,0
"public final void onResourceRequested(){
	try{
		final RequestCycle cycle = RequestCycle.get();
		IResourceStream resourceStream = init();
		final Response response = cycle.getResponse();
		if (isCacheable()){
			response.setLastModifiedTime(resourceStream.lastModifiedTime());
		}
		else{
			response.setLastModifiedTime(Time.valueOf(-1));
		}
		configureResponse(response);
		cycle.setRequestTarget(new ResourceStreamRequestTarget(resourceStream));
	}
	finally{
		parameters.set(null);
	}
}",0,0,0,0
"protected void validateDefaultPages(Map defaultPages, String wicketFilterPath,String wicketFilterQuery){
	String viewPage = fixWicketUrl((String)defaultPages.get(PARAM_VIEW_PAGE), wicketFilterPath,wicketFilterQuery);
	defaultPages.put(PARAM_VIEW_PAGE, viewPage.startsWith(wicketFilterPath) ? viewPage: wicketFilterPath);
	String defaultPage = (String)defaultPages.get(PARAM_ACTION_PAGE);
	if (defaultPage == null){
		defaultPages.put(PARAM_ACTION_PAGE, viewPage);
	}
	else{
		defaultPage = fixWicketUrl(defaultPage, wicketFilterPath, wicketFilterQuery);
		defaultPages.put(PARAM_ACTION_PAGE, defaultPage.startsWith(wicketFilterPath)? defaultPage : viewPage);
	}
	defaultPage = (String)defaultPages.get(PARAM_CUSTOM_PAGE);
	if (defaultPage == null){
		defaultPages.put(PARAM_CUSTOM_PAGE, viewPage);
	}
	else{
		defaultPage = fixWicketUrl(defaultPage, wicketFilterPath, wicketFilterQuery);
		defaultPages.put(PARAM_CUSTOM_PAGE, defaultPage.startsWith(wicketFilterPath)? defaultPage : viewPage);
	}
	defaultPage = (String)defaultPages.get(PARAM_HELP_PAGE);
	if (defaultPage == null){
		defaultPages.put(PARAM_HELP_PAGE, viewPage);
	}
	else{
		defaultPage = fixWicketUrl(defaultPage, wicketFilterPath, wicketFilterQuery);
		defaultPages.put(PARAM_HELP_PAGE, defaultPage.startsWith(wicketFilterPath)? defaultPage : viewPage);
	}
	defaultPage = (String)defaultPages.get(PARAM_EDIT_PAGE);
	if (defaultPage == null){
		defaultPages.put(PARAM_EDIT_PAGE, viewPage);
	}
	else{
		defaultPage = fixWicketUrl(defaultPage, wicketFilterPath, wicketFilterQuery);
		defaultPages.put(PARAM_EDIT_PAGE, defaultPage.startsWith(wicketFilterPath)? defaultPage : viewPage);
	}
}",0,0,0,0
"public class RenameKeyspace extends Migration{
	 private String oldName;
	 private String newName;
	 protected RenameKeyspace() {
	 }
	 public RenameKeyspace(String oldName, String newName) throws ConfigurationException, IOException {
		 super(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress()), DatabaseDescriptor.getDefsVersion());
		 this.oldName = oldName;
		 this.newName = newName;
		 KSMetaData oldKsm = DatabaseDescriptor.getTableDefinition(oldName);
		 if (oldKsm == null) throw new ConfigurationException(""Keyspace either does not exist or does not match the one currently defined."");
		 if (DatabaseDescriptor.getTableDefinition(newName) != null) throw new ConfigurationException(""Keyspace already exists."");
		 if (!Migration.isLegalName(newName)) throw new ConfigurationException(""Invalid keyspace name: "" + newName);
		 KSMetaData newKsm = rename(oldKsm, newName, false);
		 rm = makeDefinitionMutation(newKsm, oldKsm, newVersion);
	 }
	 private static KSMetaData rename(KSMetaData ksm, String newName, boolean purgeOldCfs) {
		 List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().size());
		 for (CFMetaData oldCf : ksm.cfMetaData().values()) {
			 if (purgeOldCfs) CFMetaData.purge(oldCf);
			 newCfs.add(CFMetaData.renameTable(oldCf, newName));
		 }
		 return new KSMetaData(newName, ksm.strategyClass, ksm.strategyOptions, newCfs.toArray(new CFMetaData[newCfs.size()]));
	 }
	 public void applyModels() throws IOException {
		 if (!StorageService.instance.isClientMode()) renameKsStorageFiles(oldName, newName);
		 KSMetaData oldKsm = DatabaseDescriptor.getTableDefinition(oldName);
		 for (CFMetaData cfm : oldKsm.cfMetaData().values()) CFMetaData.purge(cfm);
		 KSMetaData newKsm = rename(oldKsm, newName, true);
		 for (CFMetaData cfm : newKsm.cfMetaData().values()) {
			 try {
				 CFMetaData.map(cfm);
			 }
			 catch (ConfigurationException ex) {
				 throw new RuntimeException(ex);
			 }
		 }
		 DatabaseDescriptor.clearTableDefinition(oldKsm, newVersion);
		 DatabaseDescriptor.setTableDefinition(newKsm, newVersion);
		 if (!StorageService.instance.isClientMode()) {
			 Table.clear(oldKsm.name);
			 Table.open(newName);
		 }
	 }
	 private static void renameKsStorageFiles(String oldKs, String newKs) throws IOException {
		 ArrayList<File> failed = new ArrayList<File>();
		 for (String dataDir : DatabaseDescriptor.getAllDataFileLocations()) {
			 File ksDir = new File(dataDir, oldKs);
			 if (ksDir.exists()) if (!ksDir.renameTo(new File(dataDir, newKs))) failed.add(ksDir);
		 }
		 if (!failed.isEmpty()) throw new IOException(""One or more problems encountered while renaming "" + StringUtils.join(failed, "",""));
	 }
	 public void subdeflate(org.apache.cassandra.db.migration.avro.Migration mi) {
		 org.apache.cassandra.db.migration.avro.RenameKeyspace rks = new org.apache.cassandra.db.migration.avro.RenameKeyspace();
		 rks.old_ksname = new org.apache.avro.util.Utf8(oldName);
		 rks.new_ksname = new org.apache.avro.util.Utf8(newName);
		 mi.migration = rks;
	 }
	 public void subinflate(org.apache.cassandra.db.migration.avro.Migration mi) {
		 org.apache.cassandra.db.migration.avro.RenameKeyspace rks = (org.apache.cassandra.db.migration.avro.RenameKeyspace)mi.migration;
		 oldName = rks.old_ksname.toString();
		 newName = rks.new_ksname.toString();
	 }
	 public String toString() {
		 return String.format(""Rename keyspace %s to %s"", oldName, newName);
	 }
}",0,0,0,0
"class ReduceTaskRunner extends TaskRunner {
	 private static final Logger LOG = LogFormatter.getLogger(""org.apache.hadoop.mapred.ReduceTaskRunner"");
	 private MapOutputFile mapOutputFile;
	 public ReduceTaskRunner(Task task, TaskTracker tracker, JobConf conf) {
		 super(task, tracker, conf);
		 this.mapOutputFile = new MapOutputFile();
		 this.mapOutputFile.setConf(conf);
	 }
	 public boolean prepare() throws IOException {
		 ReduceTask task = ((ReduceTask)getTask());
		 this.mapOutputFile.removeAll(task.getTaskId());
		 String[][] mapTaskIds = task.getMapTaskIds();
		 final Progress copyPhase = getTask().getProgress().phase();
		 Vector needed = new Vector();
		 for (int i = 0;
		 i < mapTaskIds.length;
		 i++) {
			 needed.add(mapTaskIds[i]);
			 copyPhase.addPhase();
		 }
		 InterTrackerProtocol jobClient = getTracker().getJobClient();
		 while (needed.size() > 0) {
			 LOG.info(task.getTaskId()+"" Need ""+needed.size()+"" map output(s)."");
			 getTask().reportProgress(getTracker());
			 Collections.shuffle(needed);
			 int checkSize = Math.min(10, needed.size());
			 String[][] neededStrings = new String[checkSize][];
			 for (int i = 0;
			 i < checkSize;
			 i++) {
				 neededStrings[i] = (String[]) needed.elementAt(i);
			 }
			 MapOutputLocation[] locs = null;
			 try {
				 locs = jobClient.locateMapOutputs(task.getTaskId(), neededStrings);
			 }
			 catch (IOException ie) {
				 LOG.info(""Problem locating map outputs: "" + StringUtils.stringifyException(ie));
			 }
			 if (locs == null || locs.length == 0) {
				 try {
					 if (killed) {
						 return false;
					 }
					 LOG.info(task.getTaskId()+"" No map outputs available;
					 sleeping..."");
					 Thread.sleep(10000);
				 }
				 catch (InterruptedException e) {
				 }
				 continue;
			 }
			 LOG.info(task.getTaskId()+"" Got ""+locs.length+"" map output locations."");
			 for (int i = 0;
			 i < locs.length;
			 i++) {
				 MapOutputLocation loc = locs[i];
				 InetSocketAddress addr = new InetSocketAddress(loc.getHost(), loc.getPort());
				 MapOutputProtocol client = (MapOutputProtocol)RPC.getProxy(MapOutputProtocol.class, addr, this.conf);
				 this.mapOutputFile.setProgressReporter(new MapOutputFile.ProgressReporter() {
					 public void progress(float progress) {
						 copyPhase.phase().set(progress);
						 try {
							 getTask().reportProgress(getTracker());
						 }
						 catch (IOException e) {
							 throw new RuntimeException(e);
						 }
					 }
				 }
				);
				 getTask().reportProgress(getTracker());
				 try {
					 copyPhase.phase().setStatus(loc.toString());
					 LOG.info(task.getTaskId()+"" Copying ""+loc.getMapTaskId() +"" output from ""+loc.getHost()+""."");
					 client.getFile(loc.getMapTaskId(), task.getTaskId(), new IntWritable(task.getPartition()));
					 boolean foundit = false;
					 for (Iterator it = needed.iterator();
					 it.hasNext() && !foundit;
					 ) {
						 String idsForSingleMap[] = (String[]) it.next();
						 for (int j = 0;
						 j < idsForSingleMap.length;
						 j++) {
							 if (idsForSingleMap[j].equals(loc.getMapTaskId())) {
								 it.remove();
								 foundit = true;
								 break;
							 }
						 }
					 }
					 copyPhase.startNextPhase();
				 }
				 catch (IOException e) {
					 LOG.log(Level.WARNING, task.getTaskId()+"" copy failed: "" +loc.getMapTaskId()+"" from ""+addr, e);
				 }
				 finally {
					 this.mapOutputFile.setProgressReporter(null);
				 }
			 }
		 }
		 getTask().reportProgress(getTracker());
		 return true;
	 }
	 public void close() throws IOException {
		 getTask().getProgress().setStatus(""closed"");
		 this.mapOutputFile.removeAll(getTask().getTaskId());
	 }
}",0,0,0,0
"public String readNullTerminatedString(int length) {
	 if (length == 0) {
		 return """";
	 }
	 int stringLength = length;
	 int lastIndex = position + length - 1;
	 if (lastIndex < limit && data[lastIndex] == 0) {
		 stringLength--;
	 }
	 String result = Util.fromUtf8Bytes(data, position, stringLength);
	 position += length;
	 return result;
 }",0,0,1,0
"public class OutboundTcpConnectionPool{
	 private IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();
	 private final InetAddress id;
	 public final OutboundTcpConnection cmdCon;
	 public final OutboundTcpConnection ackCon;
	 private InetAddress resetedEndpoint;
	 OutboundTcpConnectionPool(InetAddress remoteEp) {
		 id = remoteEp;
		 cmdCon = new OutboundTcpConnection(this);
		 cmdCon.start();
		 ackCon = new OutboundTcpConnection(this);
		 ackCon.start();
	 }
	 OutboundTcpConnection getConnection(Message msg) {
		 Stage stage = msg.getMessageType();
		 return stage == Stage.REQUEST_RESPONSE || stage == Stage.INTERNAL_RESPONSE || stage == Stage.GOSSIP ? ackCon : cmdCon;
	 }
	 synchronized void reset() {
		 for (OutboundTcpConnection con : new OutboundTcpConnection[] {
		 cmdCon, ackCon }
		) con.closeSocket();
	 }
	 public void reset(InetAddress remoteEP) {
		 resetedEndpoint = remoteEP;
		 for (OutboundTcpConnection con : new OutboundTcpConnection[] {
		 cmdCon, ackCon }
		) con.softCloseSocket();
	 }
	 public Socket newSocket() throws IOException {
		 if (isEncryptedChannel()) {
			 if (Config.getOutboundBindAny()) return SSLFactory.getSocket(DatabaseDescriptor.getEncryptionOptions(), endPoint(), DatabaseDescriptor.getSSLStoragePort());
			 else return SSLFactory.getSocket(DatabaseDescriptor.getEncryptionOptions(), endPoint(), DatabaseDescriptor.getSSLStoragePort(), FBUtilities.getLocalAddress(), 0);
		 }
		 else {
			 if (Config.getOutboundBindAny()) return new Socket(endPoint(), DatabaseDescriptor.getStoragePort());
			 else return new Socket(endPoint(), DatabaseDescriptor.getStoragePort(), FBUtilities.getLocalAddress(), 0);
		 }
	 }
	 InetAddress endPoint() {
		 return resetedEndpoint == null ? id : resetedEndpoint;
	 }
	 boolean isEncryptedChannel() {
		 switch (DatabaseDescriptor.getEncryptionOptions().internode_encryption) {
			 case none: return false;
			 case all: break;
			 case dc: if (snitch.getDatacenter(id).equals(snitch.getDatacenter(FBUtilities.getBroadcastAddress()))) return false;
			 break;
			 case rack: if (snitch.getRack(id).equals(snitch.getRack(FBUtilities.getBroadcastAddress())) && snitch.getDatacenter(id).equals(snitch.getDatacenter(FBUtilities.getBroadcastAddress()))) return false;
			 break;
		 }
		 return true;
	 }
}",0,0,0,0
"public Reader chain(final Reader rdr) {
	 LineContainsRegExp newFilter = new LineContainsRegExp(rdr);
	 newFilter.setRegexps(getRegexps());
	 newFilter.setNegate(isNegated());
	 return newFilter;
 }",0,0,0,0
"private abstract static class ElementParser {
	 private final String baseUri;
	 private final String tag;
	 private final ElementParser parent;
	 private final List<Pair<String, Object>> normalizedAttributes;
	 public ElementParser(ElementParser parent, String baseUri, String tag) {
		 this.parent = parent;
		 this.baseUri = baseUri;
		 this.tag = tag;
		 this.normalizedAttributes = new LinkedList<>();
	 }
	 public final Object parse(XmlPullParser xmlParser) throws XmlPullParserException, IOException {
		 String tagName;
		 boolean foundStartTag = false;
		 int skippingElementDepth = 0;
		 while (true) {
			 int eventType = xmlParser.getEventType();
			 switch (eventType) {
				 case XmlPullParser.START_TAG: tagName = xmlParser.getName();
				 if (tag.equals(tagName)) {
					 foundStartTag = true;
					 parseStartTag(xmlParser);
				 }
				 else if (foundStartTag) {
					 if (skippingElementDepth > 0) {
						 skippingElementDepth++;
					 }
					 else if (handleChildInline(tagName)) {
						 parseStartTag(xmlParser);
					 }
					 else {
						 ElementParser childElementParser = newChildParser(this, tagName, baseUri);
						 if (childElementParser == null) {
							 skippingElementDepth = 1;
						 }
						 else {
							 addChild(childElementParser.parse(xmlParser));
						 }
					 }
				 }
				 break;
				 case XmlPullParser.TEXT: if (foundStartTag && skippingElementDepth == 0) {
					 parseText(xmlParser);
				 }
				 break;
				 case XmlPullParser.END_TAG: if (foundStartTag) {
					 if (skippingElementDepth > 0) {
						 skippingElementDepth--;
					 }
					 else {
						 tagName = xmlParser.getName();
						 parseEndTag(xmlParser);
						 if (!handleChildInline(tagName)) {
							 return build();
						 }
					 }
				 }
				 break;
				 case XmlPullParser.END_DOCUMENT: return null;
				 default: break;
			 }
			 xmlParser.next();
		 }
	 }
	 private ElementParser newChildParser(ElementParser parent, String name, String baseUri) {
		 if (QualityLevelParser.TAG.equals(name)) {
			 return new QualityLevelParser(parent, baseUri);
		 }
		 else if (ProtectionParser.TAG.equals(name)) {
			 return new ProtectionParser(parent, baseUri);
		 }
		 else if (StreamIndexParser.TAG.equals(name)) {
			 return new StreamIndexParser(parent, baseUri);
		 }
		 return null;
	 }
	 protected final void putNormalizedAttribute(String key, Object value) {
		 normalizedAttributes.add(Pair.create(key, value));
	 }
	 protected final Object getNormalizedAttribute(String key) {
		 for (int i = 0;
		 i < normalizedAttributes.size();
		 i++) {
			 Pair<String, Object> pair = normalizedAttributes.get(i);
			 if (pair.first.equals(key)) {
				 return pair.second;
			 }
		 }
		 return parent == null ? null : parent.getNormalizedAttribute(key);
	 }
	 protected boolean handleChildInline(String tagName) {
		 return false;
	 }
	 protected void parseStartTag(XmlPullParser xmlParser) throws ParserException {
	 }
	 protected void parseText(XmlPullParser xmlParser) {
	 }
	 protected void parseEndTag(XmlPullParser xmlParser) {
	 }
	 protected void addChild(Object parsedChild) {
	 }
	 protected abstract Object build();
	 protected final String parseRequiredString(XmlPullParser parser, String key) throws MissingFieldException {
		 String value = parser.getAttributeValue(null, key);
		 if (value != null) {
			 return value;
		 }
		 else {
			 throw new MissingFieldException(key);
		 }
	 }
	 protected final int parseInt(XmlPullParser parser, String key, int defaultValue) throws ParserException {
		 String value = parser.getAttributeValue(null, key);
		 if (value != null) {
			 try {
				 return Integer.parseInt(value);
			 }
			 catch (NumberFormatException e) {
				 throw new ParserException(e);
			 }
		 }
		 else {
			 return defaultValue;
		 }
	 }
	 protected final int parseRequiredInt(XmlPullParser parser, String key) throws ParserException {
		 String value = parser.getAttributeValue(null, key);
		 if (value != null) {
			 try {
				 return Integer.parseInt(value);
			 }
			 catch (NumberFormatException e) {
				 throw new ParserException(e);
			 }
		 }
		 else {
			 throw new MissingFieldException(key);
		 }
	 }
	 protected final long parseLong(XmlPullParser parser, String key, long defaultValue) throws ParserException {
		 String value = parser.getAttributeValue(null, key);
		 if (value != null) {
			 try {
				 return Long.parseLong(value);
			 }
			 catch (NumberFormatException e) {
				 throw new ParserException(e);
			 }
		 }
		 else {
			 return defaultValue;
		 }
	 }
	 protected final long parseRequiredLong(XmlPullParser parser, String key) throws ParserException {
		 String value = parser.getAttributeValue(null, key);
		 if (value != null) {
			 try {
				 return Long.parseLong(value);
			 }
			 catch (NumberFormatException e) {
				 throw new ParserException(e);
			 }
		 }
		 else {
			 throw new MissingFieldException(key);
		 }
	 }
	 protected final boolean parseBoolean(XmlPullParser parser, String key, boolean defaultValue) {
		 String value = parser.getAttributeValue(null, key);
		 if (value != null) {
			 return Boolean.parseBoolean(value);
		 }
		 else {
			 return defaultValue;
		 }
	 }
 }",1,0,0,0
"public boolean drawImage(Image image, int i, int j, int k, int l, Color color, ImageObserver imageobserver);",0,0,0,1
"public class TestPigRunner {
	 private static MiniGenericCluster cluster;
	 private static String execType;
	 private static final String INPUT_FILE = ""input"";
	 private static final String OUTPUT_FILE = ""output"";
	 private static final String PIG_FILE = ""test.pig"";
	 public TemporaryFolder temporaryFolder = new TemporaryFolder();
	 public static void setUpBeforeClass() throws Exception {
		 cluster = MiniGenericCluster.buildCluster();
		 execType = cluster.getExecType().name().toLowerCase();
		 PrintWriter w = new PrintWriter(new FileWriter(INPUT_FILE));
		 w.println(""1\t2\t3"");
		 w.println(""5\t3\t4"");
		 w.println(""3\t4\t5"");
		 w.println(""5\t6\t7"");
		 w.println(""3\t7\t8"");
		 w.close();
		 Util.copyFromLocalToCluster(cluster, INPUT_FILE, INPUT_FILE);
	 }
	 public static void tearDownAfterClass() throws Exception {
		 new File(INPUT_FILE).delete();
		 cluster.shutDown();
	 }
	 public void setUp() {
		 deleteAll(new File(OUTPUT_FILE));
		 Util.resetStateForExecModeSwitch();
	 }
	 public void testErrorLogFile() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = foreach A generate StringSize(a0);
		"");
		 w.println(""store B into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", ""local"", PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 assertTrue(!stats.isSuccessful());
			 Properties props = stats.getPigProperties();
			 String logfile = props.getProperty(""pig.logfile"");
			 File f = new File(logfile);
			 assertTrue(f.exists());
		 }
		 finally {
			 new File(PIG_FILE).delete();
		 }
	 }
	 public void testErrorLogFile2() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = foreach A generate StringSize(a0);
		"");
		 w.println(""store B into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-M"", ""-x"", ""local"", PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 assertTrue(!stats.isSuccessful());
			 Properties props = stats.getPigProperties();
			 if (props!=null) {
				 String logfile = props.getProperty(""pig.logfile"");
				 File f = new File(logfile);
				 assertTrue(f.exists());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
		 }
	 }
	 public void simpleTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = group A by a0;
		"");
		 w.println(""C = foreach B generate group, COUNT(A);
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-Dstop.on.failure=true"", ""-Dopt.multiquery=false"", ""-Dopt.fetch=false"", ""-Daggregate.warning=false"", ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 assertEquals(1, stats.getNumberJobs());
			 String name = stats.getOutputNames().get(0);
			 assertEquals(OUTPUT_FILE, name);
			 assertEquals(12, stats.getBytesWritten());
			 assertEquals(3, stats.getRecordWritten());
			 assertEquals(""A,B,C"", ((JobStats)stats.getJobGraph().getSinks().get(0)).getAlias());
			 Configuration conf = ConfigurationUtil.toConfiguration(stats.getPigProperties());
			 assertTrue(conf.getBoolean(""stop.on.failure"", false));
			 assertTrue(!conf.getBoolean(""aggregate.warning"", true));
			 assertTrue(!conf.getBoolean(PigConfiguration.PIG_OPT_MULTIQUERY, true));
			 assertTrue(!conf.getBoolean(""opt.fetch"", true));
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void simpleTest2() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = filter A by a0 == 3;
		"");
		 w.println(""C = limit B 1;
		"");
		 w.println(""dump C;
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-Dstop.on.failure=true"", ""-Dopt.multiquery=false"", ""-Daggregate.warning=false"", ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""mapreduce"")) {
				 assertEquals(2, stats.getNumberJobs());
				 assertEquals(stats.getJobGraph().size(), 2);
			 }
			 else {
				 assertEquals(1, stats.getNumberJobs());
				 assertEquals(stats.getJobGraph().size(), 1);
			 }
			 Configuration conf = ConfigurationUtil.toConfiguration(stats.getPigProperties());
			 assertTrue(conf.getBoolean(""stop.on.failure"", false));
			 assertTrue(!conf.getBoolean(""aggregate.warning"", true));
			 assertTrue(!conf.getBoolean(PigConfiguration.PIG_OPT_MULTIQUERY, true));
			 assertTrue(conf.getBoolean(""opt.fetch"", true));
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void scriptsInDfsTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = group A by a0;
		"");
		 w.println(""C = foreach B generate group, COUNT(A);
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 Util.copyFromLocalToCluster(cluster, PIG_FILE, PIG_FILE);
		 Path inputInDfs = new Path(cluster.getFileSystem().getHomeDirectory(), PIG_FILE);
		 try {
			 String[] args = {
			 ""-x"", execType, inputInDfs.toString() }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 assertTrue(stats.getJobGraph().size() == 1);
			 String name = stats.getOutputNames().get(0);
			 assertEquals(OUTPUT_FILE, name);
			 assertEquals(12, stats.getBytesWritten());
			 assertEquals(3, stats.getRecordWritten());
			 assertEquals(""A,B,C"", ((JobStats)stats.getJobGraph().getSinks().get(0)).getAlias());
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, PIG_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void orderByTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = order A by a0;
		"");
		 w.println(""C = limit B 2;
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 String[] args = {
		 ""-x"", execType, PIG_FILE }
		;
		 try {
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""tez"")) {
				 assertEquals(stats.getJobGraph().size(), 1);
				 assertEquals(stats.getJobGraph().getSources().get(0).getPlan().size(), 5);
			 }
			 else if (execType.equals(""spark"")) {
				 assertEquals(stats.getJobGraph().size(), 1);
			 }
			 else {
				 assertEquals(stats.getJobGraph().size(), 4);
			 }
			 assertTrue(stats.getJobGraph().getSinks().size() == 1);
			 assertTrue(stats.getJobGraph().getSources().size() == 1);
			 JobStats js = (JobStats) stats.getJobGraph().getSinks().get(0);
			 assertEquals(OUTPUT_FILE, js.getOutputs().get(0).getName());
			 assertEquals(2, js.getOutputs().get(0).getNumberRecords());
			 assertEquals(12, js.getOutputs().get(0).getBytes());
			 assertEquals(OUTPUT_FILE, stats.getOutputNames().get(0));
			 assertEquals(2, stats.getRecordWritten());
			 assertEquals(12, stats.getBytesWritten());
			 if (execType.equals(""tez"")) {
				 assertEquals(""A,B"", ((JobStats) stats.getJobGraph().getSources().get( 0)).getAlias());
			 }
			 else if (execType.equals(""spark"")) {
				 assertEquals(""A,B"", ((JobStats) stats.getJobGraph().getSources().get( 0)).getAlias());
			 }
			 else {
				 assertEquals(""A"", ((JobStats) stats.getJobGraph().getSources().get( 0)).getAlias());
				 assertEquals(""B"", ((JobStats) stats.getJobGraph().getPredecessors( js).get(0)).getAlias());
				 assertEquals(""B"", js.getAlias());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void simpleMultiQueryTest() throws Exception {
		 final String OUTPUT_FILE_2 = ""output2"";
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = filter A by a0 >= 4;
		"");
		 w.println(""C = filter A by a0 < 4;
		"");
		 w.println(""store B into '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""spark"")) {
				 assertTrue(stats.getJobGraph().size() == 2);
			 }
			 else {
				 assertTrue(stats.getJobGraph().size() == 1);
			 }
			 final int numOfRecords = 5;
			 final int numOfCharsPerRecord = 6;
			 assertEquals(numOfRecords, stats.getRecordWritten());
			 assertEquals(numOfRecords * numOfCharsPerRecord, stats.getBytesWritten());
			 assertTrue(stats.getOutputNames().size() == 2);
			 for (String fname : stats.getOutputNames()) {
				 assertTrue(fname.equals(OUTPUT_FILE) || fname.equals(OUTPUT_FILE_2));
				 if (fname.equals(OUTPUT_FILE)) {
					 assertEquals(3, stats.getNumberRecords(fname));
				 }
				 else {
					 assertEquals(2, stats.getNumberRecords(fname));
				 }
			 }
			 assertEquals(""A,B,C"", ((JobStats)stats.getJobGraph().getSinks().get(0)).getAlias());
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE_2);
		 }
	 }
	 public void simpleMultiQueryTest2() throws Exception {
		 final String OUTPUT_FILE_2 = ""output2"";
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = filter A by a0 >= 4;
		"");
		 w.println(""C = filter A by a0 < 4;
		"");
		 w.println(""D = group C by a0;
		"");
		 w.println(""E = foreach D generate group, COUNT(C);
		"");
		 w.println(""store B into '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.println(""store E into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""spark"")) {
				 assertEquals(stats.getJobGraph().size(), 2);
			 }
			 else {
				 assertEquals(stats.getJobGraph().size(), 1);
			 }
			 final int numOfRecords1 = 2;
			 final int numOfRecords2 = 2;
			 final int numOfCharsPerRecord1 = 6;
			 final int numOfCharsPerRecord2 = 4;
			 assertEquals(numOfRecords1 + numOfRecords2, stats.getRecordWritten());
			 assertEquals((numOfRecords1 * numOfCharsPerRecord1) + (numOfRecords2 * numOfCharsPerRecord2), stats.getBytesWritten());
			 assertTrue(stats.getOutputNames().size() == 2);
			 for (String fname : stats.getOutputNames()) {
				 assertTrue(fname.equals(OUTPUT_FILE) || fname.equals(OUTPUT_FILE_2));
				 if (fname.equals(OUTPUT_FILE)) {
					 assertEquals(2, stats.getNumberRecords(fname));
				 }
				 else {
					 assertEquals(2, stats.getNumberRecords(fname));
				 }
			 }
			 assertEquals(""A,B,C,D,E"", ((JobStats)stats.getJobGraph().getSinks().get(0)).getAlias());
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE_2);
		 }
	 }
	 public void simpleMultiQueryTest3() throws Exception {
		 final String INPUT_FILE_2 = ""input2"";
		 final String OUTPUT_FILE_2 = ""output2"";
		 PrintWriter w = new PrintWriter(new FileWriter(INPUT_FILE_2));
		 w.println(""3\t4\t5"");
		 w.println(""5\t6\t7"");
		 w.println(""3\t7\t8"");
		 w.close();
		 Util.copyFromLocalToCluster(cluster, INPUT_FILE_2, INPUT_FILE_2);
		 new File(INPUT_FILE_2).delete();
		 w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""A1 = load '"" + INPUT_FILE_2 + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = filter A by a0 == 3;
		"");
		 w.println(""C = filter A by a1 <=5;
		"");
		 w.println(""D = join C by a0, B by a0, A1 by a0 using 'replicated';
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.println(""store D into '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.close();
		 try {
			 String[] args = null;
			 args = new String[]{
			""-x"", execType, PIG_FILE}
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (Util.isMapredExecType(cluster.getExecType())) {
				 assertEquals(3, stats.getJobGraph().size());
			 }
			 else if (Util.isSparkExecType(cluster.getExecType())) {
				 assertEquals(4, stats.getJobGraph().size());
			 }
			 else {
				 assertEquals(1, stats.getJobGraph().size());
			 }
			 final int numOfRecords1 = 3;
			 final int numOfRecords2 = 4;
			 final int numOfBytesWritten1 = 18;
			 final int numOfBytesWritten2 = 72;
			 assertEquals(numOfRecords1 + numOfRecords2, stats.getRecordWritten());
			 assertEquals(numOfBytesWritten1 + numOfBytesWritten2, stats.getBytesWritten());
			 List<String> outputNames = new ArrayList<String>(stats.getOutputNames());
			 assertTrue(outputNames.size() == 2);
			 Collections.sort(outputNames);
			 assertEquals(OUTPUT_FILE, outputNames.get(0));
			 assertEquals(OUTPUT_FILE_2, outputNames.get(1));
			 assertEquals(3, stats.getNumberRecords(OUTPUT_FILE));
			 assertEquals(4, stats.getNumberRecords(OUTPUT_FILE_2));
			 List<InputStats> inputStats = new ArrayList<InputStats>(stats.getInputStats());
			 assertTrue(inputStats.size() == 2);
			 Collections.sort(inputStats, new Comparator<InputStats>() {
				 public int compare(InputStats o1, InputStats o2) {
					 return o1.getLocation().compareTo(o2.getLocation());
				 }
			 }
			);
			 assertEquals(5, inputStats.get(0).getNumberRecords());
			 assertEquals(3, inputStats.get(1).getNumberRecords());
			 if (!Util.isMapredExecType(cluster.getExecType())) {
				 assertEquals(30, inputStats.get(0).getBytes());
			 }
			 if (!Util.isMapredExecType(cluster.getExecType()) && !Util.isSparkExecType(cluster.getExecType())) {
				 assertEquals(18, inputStats.get(1).getBytes());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, INPUT_FILE_2);
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE_2);
		 }
	 }
	 public void MQDepJobFailedTest() throws Exception {
		 final String OUTPUT_FILE_2 = ""output2"";
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (name:chararray, a1:int, a2:int);
		"");
		 w.println(""store A into '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.println(""B = FOREACH A GENERATE org.apache.pig.test.utils.UPPER(name);
		"");
		 w.println(""C= order B by $0;
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 Iterator<JobStats> iter = stats.getJobGraph().iterator();
			 while (iter.hasNext()) {
				 JobStats js=iter.next();
				 if (execType.equals(""mapreduce"")) {
					 if (js.getState().name().equals(""FAILED"")) {
						 List<Operator> ops = stats.getJobGraph().getSuccessors(js);
						 for (Operator op : ops) {
							 assertEquals(((JobStats) op).getState().toString(), ""UNKNOWN"");
						 }
					 }
				 }
				 else {
					 assertEquals(js.getState().name(), ""FAILED"");
				 }
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE_2);
		 }
	 }
	 public void simpleNegativeTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = group A by a;
		"");
		 w.println(""C = foreach B generate group, COUNT(A);
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 String[] args = {
		 ""-x"", execType, ""-c"", PIG_FILE }
		;
		 PigStats stats = PigRunner.run(args, null);
		 assertTrue(stats.getReturnCode() == ReturnCode.PIG_EXCEPTION);
	 }
	 public void simpleNegativeTest2() throws Exception {
		 String[] args = {
		 ""-x"", execType, ""-c"", ""-e"", ""this is a test"" }
		;
		 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
		 assertTrue(stats.getReturnCode() == ReturnCode.ILLEGAL_ARGS);
	 }
	 public void simpleNegativeTest3() throws Exception {
		 String[] args = {
		 ""-x"", execType, ""-c"", ""-y"" }
		;
		 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
		 assertTrue(stats.getReturnCode() == ReturnCode.PARSE_EXCEPTION);
		 assertEquals(""Found unknown option (-y) at position 4"", stats.getErrorMessage());
	 }
	 public void streamNegativeTest() throws Exception {
		 Assume.assumeTrue(""Skip this test for TEZ temporarily as it hangs"", Util.isMapredExecType(cluster.getExecType()));
		 final String OUTPUT_FILE_2 = ""output2"";
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = foreach A generate 1;
		"");
		 w.println(""C = foreach A generate 0/0;
		"");
		 w.println(""store B into '"" + OUTPUT_FILE + ""';
		"");
		 w.println(""store C into '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.println(""D = load '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.println(""E = stream D through `false`;
		"");
		 w.println(""store E into 'ee';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 assertTrue(!stats.isSuccessful());
			 if (execType.equals(""tez"")) {
				 assertTrue(stats.getReturnCode() == ReturnCode.FAILURE);
				 assertTrue(stats.getJobGraph().size() == 1);
				 JobStats job = (JobStats)stats.getJobGraph().getSinks().get(0);
				 assertTrue(!job.isSuccessful());
				 assertTrue(stats.getOutputStats().size() == 3);
				 for (OutputStats output : stats.getOutputStats()) {
					 assertTrue(!output.isSuccessful());
				 }
			 }
			 else {
				 assertTrue(stats.getReturnCode() == ReturnCode.PARTIAL_FAILURE);
				 assertTrue(stats.getJobGraph().size() == 2);
				 JobStats job = (JobStats)stats.getJobGraph().getSources().get(0);
				 assertTrue(job.isSuccessful());
				 job = (JobStats)stats.getJobGraph().getSinks().get(0);
				 assertTrue(!job.isSuccessful());
				 assertTrue(stats.getOutputStats().size() == 3);
				 for (OutputStats output : stats.getOutputStats()) {
					 if (output.getName().equals(""ee"")) {
						 assertTrue(!output.isSuccessful());
					 }
					 else {
						 assertTrue(output.isSuccessful());
					 }
				 }
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE_2);
		 }
	 }
	 public void testIsTempFile() throws Exception {
		 PigContext context = new PigContext(Util.getLocalTestMode(), new Properties());
		 context.connect();
		 for (int i=0;
		 i<100;
		 i++) {
			 String file = FileLocalizer.getTemporaryPath(context).toString();
			 assertTrue(""not a temp file: "" + file, PigStatsUtil.isTempFile(file));
		 }
	 }
	 public void testCounterName() throws Exception {
		 String s = ""jdbc:hsqldb:file:/tmp/batchtest;
		hsqldb.default_table_type=cached;
		hsqldb.cache_rows=100"";
		 String name = MRPigStatsUtil.getMultiInputsCounterName(s, 0);
		 assertEquals(MRPigStatsUtil.MULTI_INPUTS_RECORD_COUNTER + ""_0_batchtest"", name);
		 s = ""file: name = MRPigStatsUtil.getMultiInputsCounterName(s, 1);
		 assertEquals(MRPigStatsUtil.MULTI_INPUTS_RECORD_COUNTER + ""_1_batchtest{
		1,2}
		.txt"", name);
		 s = ""file: name = MRPigStatsUtil.getMultiInputsCounterName(s, 2);
		 assertEquals(MRPigStatsUtil.MULTI_INPUTS_RECORD_COUNTER + ""_2_batchtest*.txt"", name);
	 }
	 public void testLongCounterName() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(""myinputfile""));
		 w.println(""1\t2\t3"");
		 w.println(""5\t3\t4"");
		 w.println(""3\t4\t5"");
		 w.println(""5\t6\t7"");
		 w.println(""3\t7\t8"");
		 w.close();
		 String longfilename = ""longlonglonglonglonglonglonglonglonglonglonglongfilefilefilename"";
		 Util.copyFromLocalToCluster(cluster, ""myinputfile"", longfilename);
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = load '"" + longfilename + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""C = join A by a0, B by a0;
		"");
		 w1.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 assertEquals(1, stats.getNumberJobs());
			 List<InputStats> inputs = stats.getInputStats();
			 assertEquals(2, inputs.size());
			 for (InputStats instats : inputs) {
				 assertEquals(5, instats.getNumberRecords());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void testDuplicateCounterName() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(""myinputfile""));
		 w.println(""1\t2\t3"");
		 w.println(""5\t3\t4"");
		 w.close();
		 String samefilename = ""tmp/input"";
		 Util.copyFromLocalToCluster(cluster, ""myinputfile"", samefilename);
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = load '"" + samefilename + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""C = join A by a0, B by a0;
		"");
		 w1.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 assertEquals(1, stats.getNumberJobs());
			 List<InputStats> inputs = stats.getInputStats();
			 assertEquals(2, inputs.size());
			 for (InputStats instats : inputs) {
				 if (instats.getLocation().endsWith(""tmp/input"")) {
					 assertEquals(2, instats.getNumberRecords());
				 }
				 else {
					 assertEquals(5, instats.getNumberRecords());
				 }
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void testDuplicateCounterName2() throws Exception {
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = filter A by a0 > 3;
		"");
		 w1.println(""store A into 'output';
		"");
		 w1.println(""store B into 'tmp/output';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""spark"")) {
				 assertEquals(2, stats.getNumberJobs());
			 }
			 else {
				 assertEquals(1, stats.getNumberJobs());
			 }
			 List<OutputStats> outputs = stats.getOutputStats();
			 assertEquals(2, outputs.size());
			 for (OutputStats outstats : outputs) {
				 if (outstats.getLocation().endsWith(""tmp/output"")) {
					 assertEquals(2, outstats.getNumberRecords());
				 }
				 else {
					 assertEquals(5, outstats.getNumberRecords());
				 }
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, ""tmp/output"");
		 }
	 }
	 public void testRegisterExternalJar() throws Exception {
		 String jarName = Util.findPigJarName();
		 String[] args = {
			 ""-Dpig.additional.jars="" + jarName, ""-Dmapred.job.queue.name=default"", ""-x"", execType, ""-e"", ""A = load '"" + INPUT_FILE + ""';
			store A into '"" + OUTPUT_FILE + ""';
		\n"" }
		;
		 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
		 Util.deleteFile(cluster, OUTPUT_FILE);
		 PigContext ctx = stats.getPigContext();
		 assertNotNull(ctx);
		 assertTrue(ctx.extraJars.contains(ClassLoader.getSystemResource(jarName)));
		 assertTrue(""default"", ctx.getProperties().getProperty(MRConfiguration.JOB_QUEUE_NAME) != null && ctx.getProperties().getProperty(MRConfiguration.JOB_QUEUE_NAME).equals(""default"") || ctx.getProperties().getProperty(""mapreduce.job.queuename"") != null && ctx.getProperties().getProperty(""mapreduce.job.queuename"").equals(""default""));
	 }
	 public void classLoaderTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""register test/org/apache/pig/test/data/pigtestloader.jar"");
		 w.println(""A = load '"" + INPUT_FILE + ""' using org.apache.pig.test.PigTestLoader();
		"");
		 w.println(""store A into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void fsCommandTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""fs -mv nonexist.file dummy.file"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(!stats.isSuccessful());
			 assertTrue(stats.getReturnCode() == PigRunner.ReturnCode.IO_EXCEPTION);
		 }
		 finally {
			 new File(PIG_FILE).delete();
		 }
	 }
	 public void testEmptyFile() throws IOException {
		 File f1 = new File(PIG_FILE);
		 FileWriter fw1 = new FileWriter(f1);
		 fw1.close();
		 try {
			 String[] args = {
			 ""-x"", ""local"", ""-c"", PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 assertTrue(stats.isSuccessful());
			 assertEquals( 0, stats.getReturnCode() );
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void returnCodeTest() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load 'non-existine.file' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = filter A by a0 > 0;
		;
		"");
		 w.println(""C = group B by $0;
		"");
		 w.println(""D = join C by $0, B by $0;
		"");
		 w.println(""store D into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 assertTrue(!stats.isSuccessful());
			 assertTrue(stats.getReturnCode() != 0);
			 if (execType.equals(""spark"")) {
				 assertTrue(stats.getOutputStats().size() == 1);
				 assertTrue(stats.getOutputStats().get(0).isSuccessful() == false);
			 }
			 else {
				 assertTrue(stats.getOutputStats().size() == 0);
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void returnCodeTest2() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load 'non-existine.file' as (a0, a1);
		"");
		 w.println(""B = load 'data' as (b0, b1);
		"");
		 w.println(""C = join B by b0, A by a0 using 'repl';
		"");
		 w.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, null);
			 assertTrue(!stats.isSuccessful());
			 assertTrue(stats.getReturnCode() != 0);
			 if (execType.equals(""spark"")) {
				 assertTrue(stats.getOutputStats().size() == 1);
				 assertTrue(stats.getOutputStats().get(0).isSuccessful() == false);
			 }
			 else {
				 assertTrue(stats.getOutputStats().size() == 0);
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void testEmptyFileCounter() throws Exception {
		 PrintWriter w = new PrintWriter(new FileWriter(""myinputfile""));
		 w.close();
		 Util.copyFromLocalToCluster(cluster, ""myinputfile"", ""1.txt"");
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = load '1.txt' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""C = join A by a0, B by a0;
		"");
		 w1.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 assertEquals(1, stats.getNumberJobs());
			 List<InputStats> inputs = stats.getInputStats();
			 assertEquals(2, inputs.size());
			 for (InputStats instats : inputs) {
				 if (instats.getLocation().endsWith(""1.txt"")) {
					 assertEquals(0, instats.getNumberRecords());
				 }
				 else {
					 assertEquals(5, instats.getNumberRecords());
				 }
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void testEmptyFileCounter2() throws Exception {
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = filter A by a0 < 0;
		"");
		 w1.println(""store A into '"" + OUTPUT_FILE + ""';
		"");
		 w1.println(""store B into 'output2';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""spark"")) {
				 assertEquals(2, stats.getNumberJobs());
			 }
			 else {
				 assertEquals(1, stats.getNumberJobs());
			 }
			 List<OutputStats> outputs = stats.getOutputStats();
			 assertEquals(2, outputs.size());
			 for (OutputStats outstats : outputs) {
				 if (outstats.getLocation().endsWith(""output2"")) {
					 assertEquals(0, outstats.getNumberRecords());
				 }
				 else {
					 assertEquals(5, outstats.getNumberRecords());
				 }
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, ""output2"");
		 }
	 }
	 public void testDisablePigCounters() throws Exception {
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""C = join A by a0, B by a0;
		"");
		 w1.println(""store C into '"" + OUTPUT_FILE + ""';
		"");
		 w1.close();
		 try {
			 String[] args = {
			""-Dpig.disable.counter=true"", ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 assertEquals(1, stats.getNumberJobs());
			 List<InputStats> inputs = stats.getInputStats();
			 assertEquals(2, inputs.size());
			 if (execType.equals(""tez"")) {
				 assertEquals(5, inputs.get(0).getNumberRecords());
				 assertEquals(5, inputs.get(1).getNumberRecords());
			 }
			 else {
				 for (InputStats instats : inputs) {
					 assertEquals(-1, instats.getNumberRecords());
				 }
			 }
			 List<OutputStats> outputs = stats.getOutputStats();
			 assertEquals(1, outputs.size());
			 OutputStats outstats = outputs.get(0);
			 if (execType.equals(""spark"")) {
				 assertEquals(-1, outstats.getNumberRecords());
			 }
			 else {
				 assertEquals(9, outstats.getNumberRecords());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
		 }
	 }
	 public void testGetHadoopCounters() throws Exception {
		 final String OUTPUT_FILE_2 = ""output2"";
		 PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE));
		 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w.println(""B = filter A by a0 >= 4;
		"");
		 w.println(""C = filter A by a0 < 4;
		"");
		 w.println(""D = group C by a0;
		"");
		 w.println(""E = foreach D generate group, COUNT(C);
		"");
		 w.println(""store B into '"" + OUTPUT_FILE_2 + ""';
		"");
		 w.println(""store E into '"" + OUTPUT_FILE + ""';
		"");
		 w.close();
		 try {
			 String[] args = {
			 ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 String TASK_COUNTER_GROUP = execType.equals(""tez"") ? ""org.apache.tez.common.counters.TaskCounter"" : MRPigStatsUtil.TASK_COUNTER_GROUP;
			 String FS_COUNTER_GROUP = execType.equals(""tez"") ? ""org.apache.tez.common.counters.FileSystemCounter"" : MRPigStatsUtil.FS_COUNTER_GROUP;
			 if (execType.equals(""tez"")) {
				 Counters counter= ((JobStats)stats.getJobGraph().getSinks().get(0)).getHadoopCounters();
				 assertEquals(5, counter.getGroup(TASK_COUNTER_GROUP).getCounterForName( ""INPUT_RECORDS_PROCESSED"").getValue());
				 assertEquals(2, counter.getGroup(TASK_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.REDUCE_INPUT_RECORDS).getValue());
				 assertEquals(7, counter.getGroup(TASK_COUNTER_GROUP).getCounterForName( ""OUTPUT_RECORDS"").getValue());
				 assertEquals(20,counter.getGroup(FS_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.HDFS_BYTES_WRITTEN).getValue());
				 assertEquals(new File(INPUT_FILE).length(),counter.getGroup(FS_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.HDFS_BYTES_READ).getValue());
			 }
			 else if (execType.equals(""spark"")) {
			 }
			 else {
				 Counters counter= ((MRJobStats)stats.getJobGraph().getSinks().get(0)).getHadoopCounters();
				 assertEquals(5, counter.getGroup(MRPigStatsUtil.TASK_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.MAP_INPUT_RECORDS).getValue());
				 assertEquals(3, counter.getGroup(MRPigStatsUtil.TASK_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.MAP_OUTPUT_RECORDS).getValue());
				 assertEquals(2, counter.getGroup(MRPigStatsUtil.TASK_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.REDUCE_INPUT_RECORDS).getValue());
				 assertEquals(0, counter.getGroup(MRPigStatsUtil.TASK_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.REDUCE_OUTPUT_RECORDS).getValue());
				 assertEquals(20,counter.getGroup(MRPigStatsUtil.FS_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.HDFS_BYTES_WRITTEN).getValue());
				 if (Util.isHadoop203plus()) return;
				 assertEquals(30,counter.getGroup(MRPigStatsUtil.FS_COUNTER_GROUP).getCounterForName( MRPigStatsUtil.HDFS_BYTES_READ).getValue());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, OUTPUT_FILE_2);
		 }
	 }
	 public void testDisablePigCounters2() throws Exception {
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
		"");
		 w1.println(""B = filter A by a0 > 3;
		"");
		 w1.println(""store A into 'output';
		"");
		 w1.println(""store B into 'tmp/output';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-Dpig.disable.counter=true"", ""-x"", execType, PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(stats.isSuccessful());
			 if (execType.equals(""spark"")) {
				 assertEquals(2, stats.getNumberJobs());
			 }
			 else {
				 assertEquals(1, stats.getNumberJobs());
			 }
			 List<OutputStats> outputs = stats.getOutputStats();
			 assertEquals(2, outputs.size());
			 if (execType.equals(""tez"")) {
				 if( outputs.get(0).getLocation().endsWith(""tmp/output"") ) {
					 assertEquals(2, outputs.get(0).getNumberRecords());
					 assertEquals(5, outputs.get(1).getNumberRecords());
				 }
				 else {
					 assertEquals(5, outputs.get(0).getNumberRecords());
					 assertEquals(2, outputs.get(1).getNumberRecords());
				 }
			 }
			 else {
				 for (OutputStats outstats : outputs) {
					 assertEquals(-1, outstats.getNumberRecords());
				 }
			 }
			 List<InputStats> inputs = stats.getInputStats();
			 assertEquals(1, inputs.size());
			 InputStats instats = inputs.get(0);
			 if (execType.equals(""spark"")) {
				 assertEquals(-1, instats.getNumberRecords());
			 }
			 else {
				 assertEquals(5, instats.getNumberRecords());
			 }
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, ""tmp/output"");
		 }
	 }
	 public void testStopOnFailure() throws Exception {
		 PrintWriter w1 = new PrintWriter(new FileWriter(PIG_FILE));
		 w1.println(""A1 = load '"" + INPUT_FILE + ""';
		"");
		 w1.println(""B1 = load 'nonexist';
		"");
		 w1.println(""C1 = load '"" + INPUT_FILE + ""';
		"");
		 w1.println(""A2 = distinct A1;
		"");
		 w1.println(""B2 = distinct B1;
		"");
		 w1.println(""C2 = distinct C1;
		"");
		 w1.println(""ret = union A2,B2,C2;
		"");
		 w1.println(""store ret into 'tmp/output';
		"");
		 w1.close();
		 try {
			 String[] args = {
			 ""-x"", execType, ""-F"", PIG_FILE }
			;
			 PigStats stats = PigRunner.run(args, new TestNotificationListener(execType));
			 assertTrue(!stats.isSuccessful());
			 int successfulJobs = 0;
			 Iterator<Operator> it = stats.getJobGraph().getOperators();
			 while (it.hasNext()){
				 JobStats js = (JobStats)it.next();
				 if (js.isSuccessful()) successfulJobs++;
			 }
			 assertTrue(""Should have less than 2 successful jobs"", successfulJobs < 2);
		 }
		 finally {
			 new File(PIG_FILE).delete();
			 Util.deleteFile(cluster, OUTPUT_FILE);
			 Util.deleteFile(cluster, ""tmp/output"");
		 }
	 }
	 public void testStoredScriptContents() throws Exception {
		 String scriptContents = ""sh echo success;
		\n"";
		 FileUtils.writeStringToFile(new File(PIG_FILE), scriptContents);
		 Util.copyFromLocalToCluster(cluster, PIG_FILE, PIG_FILE);
		 Path inputInDfs = new Path(cluster.getFileSystem().getHomeDirectory(), PIG_FILE);
		 try {
			 runAndValidateStoredScriptContents(PIG_FILE, scriptContents);
			 runAndValidateStoredScriptContents(inputInDfs.toString(), scriptContents);
		 }
		 finally {
			 FileUtils.deleteQuietly(new File(PIG_FILE));
			 Util.deleteQuietly(cluster, PIG_FILE);
		 }
	 }
	 public void testErrorLogUnderCustomDir() throws Exception {
		 try (PrintWriter w = new PrintWriter(new FileWriter(PIG_FILE))) {
			 w.println(""A = load '"" + INPUT_FILE + ""' as (a0:int, a1:int, a2:int);
			"");
			 w.println(""B = foreach A generate StringSize(a0);
			"");
			 w.println(""store B into '"" + OUTPUT_FILE + ""';
			"");
		 }
		 Util.copyFromLocalToCluster(cluster, PIG_FILE, PIG_FILE);
		 Path inputInDfs = new Path(cluster.getFileSystem().getHomeDirectory(), PIG_FILE);
		 try {
			 runAndValidateCustomErrorLogDir(PIG_FILE);
			 runAndValidateCustomErrorLogDir(inputInDfs.toString());
		 }
		 finally {
			 FileUtils.deleteQuietly(new File(PIG_FILE));
			 Util.deleteQuietly(cluster, PIG_FILE);
		 }
	 }
	 private void runAndValidateStoredScriptContents(String scriptPath, String expectedContents) {
		 PigStats stats = runPigLocally(scriptPath);
		 assertTrue(stats.isSuccessful());
		 assertEquals(expectedContents, stats.getScript());
		 stats = runPigLocally(""-f"", scriptPath);
		 assertTrue(stats.isSuccessful());
		 assertEquals(expectedContents, stats.getScript());
	 }
	 private void runAndValidateCustomErrorLogDir(String scriptPath) throws IOException {
		 File logsFolder = temporaryFolder.newFolder();
		 String logsPath = logsFolder.getAbsolutePath();
		 assertFileCountUnderDir(logsFolder, 0);
		 PigStats stats = runPigLocally(""-l"", logsPath, scriptPath);
		 assertFalse(stats.isSuccessful());
		 assertFileCountUnderDir(logsFolder, 1);
		 stats = runPigLocally(""-l"", logsPath, ""-f"", scriptPath);
		 assertFalse(stats.isSuccessful());
		 assertFileCountUnderDir(logsFolder, 2);
	 }
	 private void assertFileCountUnderDir(File directory, int expectedFileCount) throws IOException {
		 String[] files = directory.list();
		 assertNotNull(files);
		 assertEquals(expectedFileCount, files.length);
	 }
	 private PigStats runPigLocally(String... extraArgs) {
		 String[] args = ArrayUtils.addAll(new String[]{
		""-x"", ""local""}
		, extraArgs);
		 return PigRunner.run(args, new TestNotificationListener(""local""));
	 }
	 public static class TestNotificationListener implements PigProgressNotificationListener {
		 private Map<String, int[]> numMap = new HashMap<String, int[]>();
		 private static final int JobsToLaunch = 0;
		 private static final int JobsSubmitted = 1;
		 private static final int JobStarted = 2;
		 private static final int JobFinished = 3;
		 private String execType;
		 public TestNotificationListener(String execType) {
			 this.execType = execType;
		 }
		 public TestNotificationListener() {
			 this.execType = ""mr"";
		 }
		 public void initialPlanNotification(String id, OperatorPlan<?> plan) {
			 System.out.println(""id: "" + id + "" planNodes: "" + plan.getKeys().size());
			 assertNotNull(plan);
		 }
		 public void launchStartedNotification(String id, int numJobsToLaunch) {
			 System.out.println(""id: "" + id + "" numJobsToLaunch: "" + numJobsToLaunch);
			 int[] nums = new int[4];
			 numMap.put(id, nums);
			 nums[JobsToLaunch] = numJobsToLaunch;
		 }
		 public void jobFailedNotification(String id, JobStats jobStats) {
			 System.out.println(""id: "" + id + "" job failed: "" + jobStats.getJobId());
		 }
		 public void jobFinishedNotification(String id, JobStats jobStats) {
			 System.out.println(""id: "" + id + "" job finished: "" + jobStats.getJobId());
			 int[] nums = numMap.get(id);
			 nums[JobFinished]++;
		 }
		 public void jobStartedNotification(String id, String assignedJobId) {
			 System.out.println(""id: "" + id + "" job started: "" + assignedJobId);
			 int[] nums = numMap.get(id);
			 nums[JobStarted]++;
		 }
		 public void jobsSubmittedNotification(String id, int numJobsSubmitted) {
			 System.out.println(""id: "" + id + "" jobs submitted: "" + numJobsSubmitted);
			 int[] nums = numMap.get(id);
			 nums[JobsSubmitted] += numJobsSubmitted;
		 }
		 public void launchCompletedNotification(String id, int numJobsSucceeded) {
			 System.out.println(""id: "" + id + "" numJobsSucceeded: "" + numJobsSucceeded);
			 System.out.println("""");
			 int[] nums = numMap.get(id);
			 assertEquals(nums[JobsToLaunch], numJobsSucceeded);
			 assertEquals(nums[JobsSubmitted], numJobsSucceeded);
			 assertEquals(nums[JobStarted], numJobsSucceeded);
			 assertEquals(nums[JobFinished], numJobsSucceeded);
		 }
		 public void outputCompletedNotification(String id, OutputStats outputStats) {
			 System.out.println(""id: "" + id + "" output done: "" + outputStats.getLocation());
		 }
		 public void progressUpdatedNotification(String id, int progress) {
			 System.out.println(""id: "" + id + "" progress: "" + progress + ""%"");
		 }
	 }
	 private void deleteAll(File d) {
		 if (!d.exists()) return;
		 if (d.isDirectory()) {
			 for (File f : d.listFiles()) {
				 deleteAll(f);
			 }
		 }
		 d.delete();
	 }
}",1,0,0,0
"public ExitCode runWithoutHelp(CommandRunnerParams params) throws Exception {
	 ProjectFilesystem projectFilesystem = params.getCell().getFilesystem();
	 try (ProjectBuildFileParser parser = new DefaultProjectBuildFileParserFactory( new DefaultTypeCoercerFactory(), params.getConsole(), new ParserPythonInterpreterProvider( params.getCell().getBuckConfig(), params.getExecutableFinder()), params.getKnownRuleTypesProvider(), params.getManifestServiceSupplier(), params.getFileHashCache()) .createBuildFileParser( params.getBuckEventBus(), params.getCell(), params.getWatchman())) {
		 try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
		 PrintStream out = new PrintStream(new BufferedOutputStream(byteOut))) {
			 for (String pathToBuildFile : getArguments()) {
				 out.printf(""# %s\n\n"", pathToBuildFile);
				 Path path = Paths.get(pathToBuildFile);
				 if (!path.isAbsolute()) {
					 Path root = projectFilesystem.getRootPath();
					 path = root.resolve(path);
				 }
				 ImmutableMap<String, Map<String, Object>> rawRules = parser.getBuildFileManifest(path).getTargets();
				 ImmutableSet<String> types = getTypes();
				 Predicate<String> includeType = type -> types.isEmpty() || types.contains(type);
				 printRulesToStdout(out, rawRules, includeType);
			 }
			 params.getBuckEventBus().post(new FlushConsoleEvent());
			 out.close();
			 params.getConsole().getStdOut().write(byteOut.toByteArray());
		 }
	 }
	 return ExitCode.SUCCESS;
 }",0,0,1,0
"public NotionalPeriod(Calendar startCalendar, Calendar endCalendar, double amount, Iso4217Currency currency);",0,0,0,0
"public class ManifestClassPath extends Task {
	 private String name;
	 private File dir;
	 private int maxParentLevels = 2;
	 private Path path;
	 public void execute() {
		 if (name == null) {
			 throw new BuildException(""Missing 'property' attribute!"");
		 }
		 if (dir == null) {
			 throw new BuildException(""Missing 'jarfile' attribute!"");
		 }
		 if (getProject().getProperty(name) != null) {
			 throw new BuildException(""Property '"" + name + ""' already set!"");
		 }
		 if (path == null) {
			 throw new BuildException(""Missing nested <classpath>!"");
		 }
		 StringBuffer tooLongSb = new StringBuffer();
		 for (int i = 0;
		 i < maxParentLevels + 1;
		 i++) {
			 tooLongSb.append(""../"");
		 }
		 final String tooLongPrefix = tooLongSb.toString();
		 final FileUtils fileUtils = FileUtils.getFileUtils();
		 dir = fileUtils.normalize(dir.getAbsolutePath());
		 String[] elements = path.list();
		 StringBuffer buffer = new StringBuffer();
		 for (int i = 0;
		 i < elements.length;
		 ++i) {
			 File pathEntry = new File(elements[i]);
			 String fullPath = pathEntry.getAbsolutePath();
			 pathEntry = fileUtils.normalize(fullPath);
			 String relPath = null;
			 String canonicalPath = null;
			 try {
				 relPath = FileUtils.getRelativePath(dir, pathEntry);
				 canonicalPath = pathEntry.getCanonicalPath();
				 if (File.separatorChar != '/') {
					 canonicalPath = canonicalPath.replace(File.separatorChar, '/');
				 }
			 }
			 catch (Exception e) {
				 throw new BuildException(""error trying to get the relative path"" + "" from "" + dir + "" to "" + fullPath, e);
			 }
			 if (relPath.equals(canonicalPath) || relPath.startsWith(tooLongPrefix)) {
				 throw new BuildException( ""No suitable relative path from "" + dir + "" to "" + fullPath);
			 }
			 if (pathEntry.isDirectory() && !relPath.endsWith(""/"")) {
				 relPath = relPath + '/';
			 }
			 try {
				 relPath = Locator.encodeURI(relPath);
			 }
			 catch (UnsupportedEncodingException exc) {
				 throw new BuildException(exc);
			 }
			 buffer.append(relPath);
			 buffer.append(' ');
		 }
		 getProject().setNewProperty(name, buffer.toString().trim());
	 }
	 public void setProperty(String name) {
		 this.name = name;
	 }
	 public void setJarFile(File jarfile) {
		 File parent = jarfile.getParentFile();
		 if (!parent.isDirectory()) {
			 throw new BuildException(""Jar's directory not found: "" + parent);
		 }
		 this.dir = parent;
	 }
	 public void setMaxParentLevels(int levels) {
		 if (levels < 0) {
			 throw new BuildException(""maxParentLevels must not be a negative"" + "" number"");
		 }
		 this.maxParentLevels = levels;
	 }
	 public void addClassPath(Path path) {
		 this.path = path;
	 }
}",0,0,0,0
"public class VariableStack implements Cloneable{
	 public static final int CLEARLIMITATION= 1024;
	 public VariableStack() {
		 reset();
	 }
	 public VariableStack(int initStackSize) {
		 reset(initStackSize, initStackSize*2);
	 }
	 public synchronized Object clone() throws CloneNotSupportedException {
		 VariableStack vs = (VariableStack) super.clone();
		 vs._stackFrames = (XObject[]) _stackFrames.clone();
		 vs._links = (int[]) _links.clone();
		 return vs;
	 }
	 XObject[] _stackFrames;
	 int _frameTop;
	 private int _currentFrameBottom;
	 int[] _links;
	 int _linksTop;
	 public XObject elementAt(final int i) {
		 return _stackFrames[i];
	 }
	 public int size() {
		 return _frameTop;
	 }
	 public void reset() {
		 int linksSize = (_links == null) ? XPathContext.RECURSIONLIMIT : _links.length;
		 int varArraySize = (_stackFrames == null) ? XPathContext.RECURSIONLIMIT * 2 : _stackFrames.length;
		 reset(linksSize, varArraySize);
	 }
	 protected void reset(int linksSize, int varArraySize) {
		 _frameTop = 0;
		 _linksTop = 0;
		 if (_links == null) {
			 _links = new int[linksSize];
		 }
		 _links[_linksTop++] = 0;
		 _stackFrames = new XObject[varArraySize];
	 }
	 public void setStackFrame(int sf) {
		 _currentFrameBottom = sf;
	 }
	 public int getStackFrame() {
		 return _currentFrameBottom;
	 }
	 public int link(final int size) {
		 _currentFrameBottom = _frameTop;
		 _frameTop += size;
		 if (_frameTop >= _stackFrames.length) {
			 XObject newsf[] = new XObject[_stackFrames.length + XPathContext.RECURSIONLIMIT + size];
			 System.arraycopy(_stackFrames, 0, newsf, 0, _stackFrames.length);
			 _stackFrames = newsf;
		 }
		 if (_linksTop + 1 >= _links.length) {
			 int newlinks[] = new int[_links.length + (CLEARLIMITATION * 2)];
			 System.arraycopy(_links, 0, newlinks, 0, _links.length);
			 _links = newlinks;
		 }
		 _links[_linksTop++] = _currentFrameBottom;
		 return _currentFrameBottom;
	 }
	 public void unlink() {
		 _frameTop = _links[--_linksTop];
		 _currentFrameBottom = _links[_linksTop - 1];
	 }
	 public void unlink(int currentFrame) {
		 _frameTop = _links[--_linksTop];
		 _currentFrameBottom = currentFrame;
	 }
	 public void setLocalVariable(int index, XObject val) {
		 _stackFrames[index + _currentFrameBottom] = val;
	 }
	 public void setLocalVariable(int index, XObject val, int stackFrame) {
		 _stackFrames[index + stackFrame] = val;
	 }
	 public XObject getLocalVariable(XPathContext xctxt, int index) throws TransformerException {
		 index += _currentFrameBottom;
		 XObject val = _stackFrames[index];
		 if(null == val) throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null), xctxt.getSAXLocator());
		 if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE) return (_stackFrames[index] = val.execute(xctxt));
		 return val;
	 }
	 public XObject getLocalVariable(int index, int frame) throws TransformerException {
		 index += frame;
		 XObject val = _stackFrames[index];
		 return val;
	 }
	 public XObject getLocalVariable(XPathContext xctxt, int index, boolean destructiveOK) throws TransformerException {
		 index += _currentFrameBottom;
		 XObject val = _stackFrames[index];
		 if(null == val) throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null), xctxt.getSAXLocator());
		 if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE) return (_stackFrames[index] = val.execute(xctxt));
		 return destructiveOK ? val : val.getFresh();
	 }
	 public boolean isLocalSet(int index) throws TransformerException {
		 return (_stackFrames[index + _currentFrameBottom] != null);
	 }
	 private static XObject[] m_nulls = new XObject[CLEARLIMITATION];
	 public void clearLocalSlots(int start, int len) {
		 start += _currentFrameBottom;
		 System.arraycopy(m_nulls, 0, _stackFrames, start, len);
	 }
	 public void setGlobalVariable(final int index, final XObject val) {
		 _stackFrames[index] = val;
	 }
	 public XObject getGlobalVariable(XPathContext xctxt, final int index) throws TransformerException {
		 XObject val = _stackFrames[index];
		 if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE) return (_stackFrames[index] = val.execute(xctxt));
		 return val;
	 }
	 public XObject getGlobalVariable(XPathContext xctxt, final int index, boolean destructiveOK) throws TransformerException {
		 XObject val = _stackFrames[index];
		 if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE) return (_stackFrames[index] = val.execute(xctxt));
		 return destructiveOK ? val : val.getFresh();
	 }
	 public XObject getVariableOrParam( XPathContext xctxt, org.apache.xml.utils.QName qname) throws javax.xml.transform.TransformerException {
		 org.apache.xml.utils.PrefixResolver prefixResolver = xctxt.getNamespaceContext();
		 if (prefixResolver instanceof org.apache.xalan.templates.ElemTemplateElement) {
			 org.apache.xalan.templates.ElemVariable vvar;
			 org.apache.xalan.templates.ElemTemplateElement prev = (org.apache.xalan.templates.ElemTemplateElement) prefixResolver;
			 if (!(prev instanceof org.apache.xalan.templates.Stylesheet)) {
				 while ( !(prev.getParentNode() instanceof org.apache.xalan.templates.Stylesheet) ) {
					 org.apache.xalan.templates.ElemTemplateElement savedprev = prev;
					 while (null != (prev = prev.getPreviousSiblingElem())) {
						 if (prev instanceof org.apache.xalan.templates.ElemVariable) {
							 vvar = (org.apache.xalan.templates.ElemVariable) prev;
							 if (vvar.getName().equals(qname)) return getLocalVariable(xctxt, vvar.getIndex());
						 }
					 }
					 prev = savedprev.getParentElem();
				 }
			 }
			 vvar = prev.getStylesheetRoot().getVariableOrParamComposed(qname);
			 if (null != vvar) return getGlobalVariable(xctxt, vvar.getIndex());
		 }
		 throw new javax.xml.transform.TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VAR_NOT_RESOLVABLE, new Object[]{
		qname.toString()}
		));
	 }
}",1,0,0,0
"public class Untar extends Expand {
	 private UntarCompressionMethod compression = new UntarCompressionMethod();
	 public void setCompression(UntarCompressionMethod method) {
		 compression = method;
	 }
	 public void setEncoding(String encoding) {
		 throw new BuildException(""The "" + getTaskName() + "" task doesn't support the encoding"" + "" attribute"", getLocation());
	 }
	 public void setScanForUnicodeExtraFields(boolean b) {
		 throw new BuildException(""The "" + getTaskName() + "" task doesn't support the encoding"" + "" attribute"", getLocation());
	 }
	 protected void expandFile(FileUtils fileUtils, File srcF, File dir) {
		 FileInputStream fis = null;
		 if (!srcF.exists()) {
			 throw new BuildException(""Unable to untar "" + srcF + "" as the file does not exist"", getLocation());
		 }
		 try {
			 fis = new FileInputStream(srcF);
			 expandStream(srcF.getPath(), fis, dir);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Error while expanding "" + srcF.getPath() + ""\n"" + ioe.toString(), ioe, getLocation());
		 }
		 finally {
			 FileUtils.close(fis);
		 }
	 }
	 protected void expandResource(Resource srcR, File dir) {
		 if (!srcR.isExists()) {
			 throw new BuildException(""Unable to untar "" + srcR.getName() + "" as the it does not exist"", getLocation());
		 }
		 InputStream i = null;
		 try {
			 i = srcR.getInputStream();
			 expandStream(srcR.getName(), i, dir);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Error while expanding "" + srcR.getName(), ioe, getLocation());
		 }
		 finally {
			 FileUtils.close(i);
		 }
	 }
	 private void expandStream(String name, InputStream stream, File dir) throws IOException {
		 TarInputStream tis = null;
		 try {
			 tis = new TarInputStream(compression.decompress(name, new BufferedInputStream(stream)));
			 log(""Expanding: "" + name + "" into "" + dir, Project.MSG_INFO);
			 TarEntry te = null;
			 boolean empty = true;
			 FileNameMapper mapper = getMapper();
			 while ((te = tis.getNextEntry()) != null) {
				 empty = false;
				 extractFile(FileUtils.getFileUtils(), null, dir, tis, te.getName(), te.getModTime(), te.isDirectory(), mapper);
			 }
			 if (empty && getFailOnEmptyArchive()) {
				 throw new BuildException(""archive '"" + name + ""' is empty"");
			 }
			 log(""expand complete"", Project.MSG_VERBOSE);
		 }
		 finally {
			 FileUtils.close(tis);
		 }
	 }
	 public static final class UntarCompressionMethod extends EnumeratedAttribute {
		 private static final String NONE = ""none"";
		 private static final String GZIP = ""gzip"";
		 private static final String BZIP2 = ""bzip2"";
		 public UntarCompressionMethod() {
			 super();
			 setValue(NONE);
		 }
		 public String[] getValues() {
			 return new String[] {
			NONE, GZIP, BZIP2}
			;
		 }
		 public InputStream decompress(final String name, final InputStream istream) throws IOException, BuildException {
			 final String v = getValue();
			 if (GZIP.equals(v)) {
				 return new GZIPInputStream(istream);
			 }
			 else {
				 if (BZIP2.equals(v)) {
					 final char[] magic = new char[] {
					'B', 'Z'}
					;
					 for (int i = 0;
					 i < magic.length;
					 i++) {
						 if (istream.read() != magic[i]) {
							 throw new BuildException( ""Invalid bz2 file."" + name);
						 }
					 }
					 return new CBZip2InputStream(istream);
				 }
			 }
			 return istream;
		 }
	 }
}",0,0,0,0
"private void readColumns(User u, ResultSet rs) throws SQLException {
	 for (int i = 0;
	 i<dbp.columns.length;
	 i++) {
		 String cname = dbp.names[i];
		 int idx = i+1;
		 if (""userright"".equals(cname)) {
			 String val = rs.getString(idx);
			 if (val == null || val.length()==0 || ""null"".equalsIgnoreCase(val)) {
				 u.setPermission(IUserStates.ROLE_USER);
			 }
			 else if (""true"".equalsIgnoreCase (val) || ""yes"".equalsIgnoreCase(val) || ""vip"".equalsIgnoreCase(val)) {
				 u.setPermission(IUserStates.ROLE_VIP);
			 }
			 else if (""admin"".equalsIgnoreCase(val)) {
				 u.setPermission(IUserStates.ROLE_GOD);
			 }
			 else if (""moderator"".equalsIgnoreCase(val)) {
				 u.setPermission(IUserStates.ROLE_VIP | IUserStates.IS_MODERATOR);
			 }
			 else if (""guest"".equalsIgnoreCase(val)) {
				 u.setPermission(IUserStates.IS_GUEST);
			 }
			 else if (""asshole"".equalsIgnoreCase(val)) {
				 u.setPermission(IUserStates.ROLE_ASSHOLE);
			 }
			 else {
				 try {
					 u.setPermission(Integer.parseInt(val));
				 }
				 catch (NumberFormatException nfe) {
					 Server.log(Thread.currentThread(), this.toString() + ""LOGIN userrights-column contains unknown value, corrected to ROLE_USER\r\n(must be null/true,yes,vip or VIP/admin/moderator/guest/user/assohle) "", Server.MSG_AUTH, Server.LVL_MAJOR);
					 u.setPermission(IUserStates.ROLE_USER);
				 }
			 }
		 }
		 else if (""id"".equals(cname)) {
			 u.setID(rs.getString(idx));
		 }
		 else if (""color"".equals(cname)) {
			 u.setColCode(rs.getString(idx));
		 }
		 else if (""fadecolor"".equals(cname)) {
			 Server.srv.USE_FADECOLOR =true;
			 if (rs.getString(idx)!= null ){
				 u.setFadeColCode(rs.getString(idx));
			 }
		 }
		 else if (""bgcolor"".equals(cname)) {
			 Server.srv.USE_BGCOLOR =true;
			 if (rs.getString(idx)!= null ){
				 u.setBgColCode(rs.getString(idx));
			 }
		 }
		 else if (""chattime"".equals(cname)) {
			 u.setProperty(""chattime"", new Long(rs.getLong(idx)));
		 }
		 else if (""lastlogin"".equals(cname)) {
			 switch (dbp.types[i]) {
				 case Types.BIGINT: case Types.INTEGER: case Types.NUMERIC: case Types.SMALLINT: u.setProperty(""lastlogin"", new Timestamp (rs.getLong(idx)));
				 break;
				 case Types.DATE: case Types.TIMESTAMP: Timestamp ts = rs.getTimestamp(idx);
				 u.setProperty(""lastlogin"", ts);
				 break;
				 default: String s = rs.getString(idx);
				 if (rs.wasNull()) {
					 u.setProperty(""lastlogin"", new Timestamp (System.currentTimeMillis()));
					 break;
				 }
				 try {
					 long l = Long.parseLong (s);
					 u.setProperty(""lastlogin"", new Timestamp(l));
				 }
				 catch (NumberFormatException nfe) {
					 try {
						 u.setProperty(""lastlogin"", Timestamp.valueOf(s));
					 }
					 catch (IllegalArgumentException iae) {
						 Server.log (this, ""LOGIN Unable to retrieve lastlogin-value! "" + s, Server.MSG_AUTH, Server.LVL_MAJOR);
					 }
				 }
			 }
		 }
		 else if (""friends"".equals(cname)) {
			 List<T> users = pool.authenticator.parseUserList(rs.getString(idx));
			 for (Iterator<T> it = users.iterator();
			 it.hasNext();
			 ) {
				 u.addFriend((String) it.next());
			 }
		 }
		 else if (""ignorelist"".equals(cname)) {
			 List<T> ignores = pool.authenticator.parseUserList(rs.getString(idx));
			 for (Iterator<T> it = ignores.iterator();
			 it.hasNext();
			 ) {
				 u.ignoreUser((String) it.next());
			 }
		 }
		 else if (""notifyfriends"".equals(cname)) {
			 switch (dbp.types[i]) {
				 case Types.BIGINT: case Types.INTEGER: case Types.NUMERIC: case Types.SMALLINT: u.setFriendsNotification(rs.getShort(idx));
				 break;
				 default: u.setFriendsNotification(pool.authenticator.parseBoolean(rs.getString(idx)) ? Server.srv.FN_DEFAULT_MODE_TRUE : Server.srv.FN_DEFAULT_MODE_FALSE);
			 }
		 }
		 else if (""customtitle"".equals(cname)) {
			 u.setCustomTitle(rs.getString(idx));
		 }
		 else if (""blocked"".equals(cname)) {
			 u.blocked = pool.authenticator.parseBoolean(rs.getString(idx));
		 }
		 else if (""activated"".equals(cname)) {
			 u.activated = pool.authenticator.parseBoolean(rs.getString(idx));
		 }
		 else {
			 String strg = getEncodedString (rs, idx);
			 u.setProperty(cname, strg);
		 }
	 }
 }",0,0,1,0
"private NameRegion[] findLinkComponentsInClosure(ClosureExpression firstArg, int offset) {
	 if (! (firstArg.getCode() instanceof BlockStatement)) {
		 return null;
	 }
	 BlockStatement code = (BlockStatement) firstArg.getCode();
	 if (code.getStatements() == null) {
		 return null;
	 }
	 NameRegion controllerName = null;
	 NameRegion actionName = null;
	 NameRegion viewName = null;
	 for (Statement state : code.getStatements()) {
		 if (state instanceof ExpressionStatement) {
			 if (((ExpressionStatement) state).getExpression() instanceof BinaryExpression) {
				 BinaryExpression bexpr = (BinaryExpression) ((ExpressionStatement) state).getExpression();
				 Expression left = bexpr.getLeftExpression();
				 if (bexpr.getOperation().getText().equals(""="") && left instanceof VariableExpression) {
					 Expression right = bexpr.getRightExpression();
					 Region region;
					 if (right.getStart() <= offset && right.getEnd() >= offset) {
						 region = new Region(right.getStart(), right.getLength());
					 }
					 else {
						 region = null;
					 }
					 String name = left.getText();
					 if (name.equals(""controller"")) {
						 controllerName = new NameRegion(right.getText(), region);
					 }
					 else if (name.equals(""action"")) {
						 actionName = new NameRegion(right.getText(), region);
					 }
					 else if (name.equals(""view"")) {
						 viewName = new NameRegion(right.getText(), region);
					 }
				 }
			 }
		 }
	 }
	 return new NameRegion[] {
	 controllerName, actionName, viewName }
	;
 }",0,0,1,0
"public final class None<T> extends Option<T> {
	 private static final None INSTANCE = new None<>();
	 public static final <T> None<T> getInstance() {
		 return INSTANCE;
	 }
	 public None() {
	 }
	 public boolean hasValue() {
		 return false;
	 }
	 public T getValue() {
		 throw new NoSuchElementException(""None does not contain a value"");
	 }
	 public String toString() {
		 return ""None()"";
	 }
	 public boolean equals(Object other) {
		 return (other == null || other.getClass() != None.class) ? false : true;
	 }
	 public int hashCode() {
		 return -31;
	 }
}",0,1,0,0
"public class UnrecognizedExtraField implements ZipExtraField {
	 private ZipShort headerId;
	 public void setHeaderId(ZipShort headerId) {
		 this.headerId = headerId;
	 }
	 public ZipShort getHeaderId() {
		 return headerId;
	 }
	 private byte[] localData;
	 public void setLocalFileDataData(byte[] data) {
		 localData = data;
	 }
	 public ZipShort getLocalFileDataLength() {
		 return new ZipShort(localData.length);
	 }
	 public byte[] getLocalFileDataData() {
		 return localData;
	 }
	 private byte[] centralData;
	 public void setCentralDirectoryData(byte[] data) {
		 centralData = data;
	 }
	 public ZipShort getCentralDirectoryLength() {
		 if (centralData != null) {
			 return new ZipShort(centralData.length);
		 }
		 return getLocalFileDataLength();
	 }
	 public byte[] getCentralDirectoryData() {
		 if (centralData != null) {
			 return centralData;
		 }
		 return getLocalFileDataData();
	 }
	 public void parseFromLocalFileData(byte[] data, int offset, int length) {
		 byte[] tmp = new byte[length];
		 System.arraycopy(data, offset, tmp, 0, length);
		 setLocalFileDataData(tmp);
	 }
}",0,0,0,0
"protected void addBlankCell(JRExporterGridCell gridCell, int colIndex, int rowIndex) throws JRException;",0,0,0,0
"public String getResponseRequestEncoding(){
	return responseRequestEncoding;
}",0,0,0,0
"public void actionPerformed(ActionEvent e) {
	JComponent c = (JComponent) e.getSource();
	String name = c.getName();
	if (""START"".equals(name)) {
		model.clear();
		if (txtURL.getText().length() < 1) {
			JOptionPane.showMessageDialog(this, StringResource.get(""MSG_NO_URL""));
			return;
		}
		if(!XDMUtils.checkComponentsInstalled()) {
			JOptionPane.showMessageDialog(this, StringResource.get(""LBL_COMPONENT_MISSING""));
			return;
		}
		if (!txtURL.getText().startsWith(""http"")) {
		txtURL.setText(""http:}
		jsp.setVisible(false);
		prg.setVisible(true);
		btnDwn.setVisible(true);
		btnDwn.setText(StringResource.get(""BTN_STOP_PROCESSING""));
		btnDwn.setName(""STOP"");
		btnStart.setVisible(false);
		txtURL.setVisible(false);
		stop = false;
		getVideoItems(txtURL.getText());
	}
	if (""DOWNLOAD"".equals(name)) {
		table.getDefaultEditor(YdlVideo.class).stopCellEditing();
		downloadVideo();
	}
	if (""CLOSE"".equals(name)) {
		stop();
		dispose();
	}
	if (""STOP"".equals(name)) {
		stop();
	}
	if (""BACK"".equals(name)) {
		table.getDefaultEditor(YdlVideo.class).stopCellEditing();
		model.clear();
		prg.setVisible(false);
		txtURL.setVisible(true);
		btnStart.setVisible(true);
		btnDwn.setName(""DOWNLOAD"");
		btnDwn.setText(StringResource.get(""BTN_DOWNLOAD_NOW""));
		btnDwn.setVisible(false);
		btnQ.setVisible(false);
		jsp.setVisible(false);
		btnBack.setVisible(false);
	}
}",0,0,1,0
"public class PhotonMap{
	 private Raytracer rt;
	 private ArrayList<Photon> photonList;
	 private Photon photon[], workspace[];
	 private int numWanted, filter, numEstimate;
	 private BoundingBox bounds;
	 private Vec3 direction[];
	 private boolean includeCaustics, includeDirect, includeIndirect, includeVolume;
	 private double lightScale;
	 private float cutoffDist2;
	 public Random random;
	 public PhotonMap(int totalPhotons, int numEstimate, boolean includeCaustics, boolean includeDirect, boolean includeIndirect, boolean includeVolume, Raytracer raytracer, BoundingBox bounds, int filter, PhotonMap shared) {
		 numWanted = totalPhotons;
		 this.bounds = bounds;
		 this.includeCaustics = includeCaustics;
		 this.includeDirect = includeDirect;
		 this.includeIndirect = includeIndirect;
		 this.includeVolume = includeVolume;
		 this.filter = filter;
		 this.numEstimate = numEstimate;
		 rt = raytracer;
		 if (shared != null) direction = shared.direction;
		 else direction = new Vec3 [65536];
		 random = new Random(1);
	 }
	 public Raytracer getRaytracer() {
		 return rt;
	 }
	 public RaytracerContext getContext() {
		 return (RaytracerContext) getRaytracer().threadContext.get();
	 }
	 public BoundingBox getBounds() {
		 return bounds;
	 }
	 public int getNumToEstimate() {
		 return numEstimate;
	 }
	 public void generatePhotons(PhotonSource source[]) {
		 Thread currentThread = Thread.currentThread();
		 double totalIntensity = 0.0, currentIntensity, totalRequested = 0.0;
		 double sourceIntensity[] = new double [source.length], totalSourceIntensity = 0.0;
		 for (int i = 0;
		 i < source.length;
		 i++) {
			 sourceIntensity[i] = source[i].getTotalIntensity();
			 totalSourceIntensity += sourceIntensity[i];
		 }
		 currentIntensity = 0.1*numWanted;
		 photonList = new ArrayList<Photon>((int) (1.1*numWanted));
		 int iteration = 0;
		 ThreadManager threads = new ThreadManager();
		 try {
			 while (photonList.size() < numWanted) {
				 for (int i = 0;
				 i < source.length;
				 i++) {
					 if (rt.renderThread != currentThread) return;
					 source[i].generatePhotons(this, currentIntensity*sourceIntensity[i]/totalSourceIntensity, threads);
					 totalRequested += currentIntensity*sourceIntensity[i]/totalSourceIntensity;
				 }
				 if (photonList.size() >= numWanted*0.9) break;
				 if (photonList.size() == 0 && currentIntensity > 5.0 && iteration > 2) break;
				 totalIntensity += currentIntensity;
				 if (photonList.size() < 10) currentIntensity *= 10.0;
				 else currentIntensity = (numWanted-photonList.size())*totalIntensity/photonList.size();
				 iteration++;
			 }
		 }
		 finally {
			 threads.finish();
		 }
		 lightScale = totalSourceIntensity/totalRequested;
		 if (filter == 2) lightScale *= 3.0f;
		 else if (filter == 1) lightScale *= 1.5f;
		 int numPhotons = photonList.size();
		 workspace = photonList.toArray(new Photon [numPhotons]);
		 photonList = null;
		 photon = new Photon [numPhotons];
		 buildTree(0, numPhotons-1, 0);
		 workspace = null;
		 PhotonList nearbyPhotons = new PhotonList(numEstimate);
		 RGBColor tempColor = new RGBColor();
		 nearbyPhotons.init(0.0f);
		 for (int i = 0;
		 i < photon.length;
		 i++) {
			 tempColor.setERGB(photon[i].ergb);
			 float intensity = -(tempColor.getRed()+tempColor.getGreen()+tempColor.getBlue());
			 if (intensity <= nearbyPhotons.cutoff2) nearbyPhotons.addPhoton(photon[i], intensity);
		 }
		 float red = 0.0f, green = 0.0f, blue = 0.0f;
		 for (int i = 0;
		 i < nearbyPhotons.numFound;
		 i++) {
			 tempColor.setERGB(nearbyPhotons.photon[i].ergb);
			 red += tempColor.getRed();
			 green += tempColor.getGreen();
			 blue += tempColor.getBlue();
		 }
		 float max = Math.max(Math.max(red, green), blue);
		 double cutoff1;
		 if (includeVolume) cutoff1 = Math.pow(max*lightScale/((4.0/3.0)*Math.PI*0.1), 1.0/3.0);
		 else cutoff1 = Math.sqrt(max*lightScale/(Math.PI*0.1));
		 double volume = (bounds.maxx-bounds.minx)*(bounds.maxy-bounds.miny)*(bounds.maxz-bounds.minz);
		 double cutoff2 = Math.pow(0.5*volume*nearbyPhotons.photon.length/photon.length, 1.0/3.0);
		 cutoffDist2 = (float) (cutoff1 < cutoff2 ? cutoff1*cutoff1 : cutoff2*cutoff2);
	 }
	 public void spawnPhoton(Ray r, RGBColor color, boolean indirect) {
		 if (!r.intersects(bounds)) return;
		 OctreeNode node = rt.rootNode.findNode(r.getOrigin());
		 if (node == null) node = rt.rootNode.findFirstNode(r);
		 if (node == null) return;
		 color = color.duplicate();
		 RTObject materialObject = rt.getMaterialAtPoint(r.rt, r.getOrigin(), node);
		 if (materialObject == null) tracePhoton(r, color, 0, node, null, null, null, null, null, 0.0, indirect, false);
		 else tracePhoton(r, color, 0, node, null, materialObject.getMaterialMapping(), null, materialObject.toLocal(), null, 0.0, indirect, false);
	 }
	 private void tracePhoton(Ray r, RGBColor color, int treeDepth, OctreeNode node, RTObject first, MaterialMapping currentMaterial, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans, double totalDist, boolean diffuse, boolean caustic) {
		 RTObject second = null;
		 double dist, truedot, n = 1.0, beta = 0.0, d;
		 RaytracerContext context = (RaytracerContext) getRaytracer().threadContext.get();
		 Vec3 intersectionPoint = context.pos[treeDepth], norm = context.normal[treeDepth], trueNorm = context.trueNormal[treeDepth];
		 TextureSpec spec = context.surfSpec[treeDepth];
		 MaterialMapping nextMaterial, oldMaterial;
		 Mat4 nextMatTrans, oldMatTrans = null;
		 OctreeNode nextNode;
		 SurfaceIntersection intersect = SurfaceIntersection.NO_INTERSECTION;
		 if (first != null) intersect = r.findIntersection(first);
		 if (intersect != SurfaceIntersection.NO_INTERSECTION) {
			 intersect.intersectionPoint(0, intersectionPoint);
			 nextNode = rt.rootNode.findNode(intersectionPoint);
		 }
		 else {
			 nextNode = rt.traceRay(r, node);
			 if (nextNode == null) return;
			 first = context.intersect.first;
			 second = context.intersect.second;
			 intersect = context.lastRayResult[first.index];
			 intersect.intersectionPoint(0, intersectionPoint);
		 }
		 dist = intersect.intersectionDist(0);
		 totalDist += dist;
		 intersect.trueNormal(trueNorm);
		 truedot = trueNorm.dot(r.getDirection());
		 double texSmoothing = (diffuse ? rt.smoothScale*rt.extraGISmoothing : rt.smoothScale);
		 if (truedot > 0.0) intersect.intersectionProperties(spec, norm, r.getDirection(), totalDist*texSmoothing*3.0/(2.0+truedot), rt.time);
		 else intersect.intersectionProperties(spec, norm, r.getDirection(), totalDist*texSmoothing*3.0/(2.0-truedot), rt.time);
		 if (currentMaterial != null) {
			 if (includeVolume && currentMaterial.isScattering()) {
				 propagateRay(r, nextNode, second, dist, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, color, treeDepth, totalDist, caustic, diffuse);
			 }
			 else {
				 RGBColor emissive = new RGBColor();
				 rt.propagateRay(r, nextNode, dist, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, emissive, color, treeDepth, totalDist);
			 }
		 }
		 else if (rt.fog) color.scale((float) Math.exp(-dist/rt.fogDist));
		 if (color.getRed()+color.getGreen()+color.getBlue() < rt.minRayIntensity) return;
		 if (!includeVolume) {
			 if ((includeDirect && treeDepth == 0) || (includeIndirect && diffuse) || (includeCaustics && caustic)) {
				 if (spec.diffuse.getRed()+spec.diffuse.getGreen()+spec.diffuse.getBlue()+ spec.hilight.getRed()+spec.hilight.getGreen()+spec.hilight.getBlue() > rt.minRayIntensity) addPhoton(intersectionPoint, r.getDirection(), color);
			 }
		 }
		 if (treeDepth == rt.maxRayDepth-1) return;
		 boolean spawnSpecular = false, spawnTransmitted = false, spawnDiffuse = false;
		 if (includeCaustics || includeVolume) {
			 if (spec.specular.getRed()+spec.specular.getGreen()+spec.specular.getBlue() > rt.minRayIntensity) spawnSpecular = true;
		 }
		 if (includeCaustics || includeVolume) {
			 if (spec.transparent.getRed()+spec.transparent.getGreen()+spec.transparent.getBlue() > rt.minRayIntensity) spawnTransmitted = true;
		 }
		 if (includeIndirect && !includeVolume) {
			 if (spec.diffuse.getRed()+spec.diffuse.getGreen()+spec.diffuse.getBlue() > rt.minRayIntensity) spawnDiffuse = true;
		 }
		 double dot = norm.dot(r.getDirection());
		 RGBColor col = context.rayIntensity[treeDepth+1];
		 boolean totalReflect = false;
		 if (spawnTransmitted) {
			 col.copy(color);
			 col.multiply(spec.transparent);
			 context.ray[treeDepth+1].getOrigin().set(intersectionPoint);
			 Vec3 temp = context.ray[treeDepth+1].getDirection();
			 if (first.getMaterialMapping() == null) {
				 temp.set(r.getDirection());
				 nextMaterial = currentMaterial;
				 nextMatTrans = currentMatTrans;
				 oldMaterial = prevMaterial;
				 oldMatTrans = prevMatTrans;
			 }
			 else if (dot < 0.0) {
				 nextMaterial = first.getMaterialMapping();
				 nextMatTrans = first.toLocal();
				 oldMaterial = currentMaterial;
				 oldMatTrans = currentMatTrans;
				 if (currentMaterial == null) n = nextMaterial.indexOfRefraction()/1.0;
				 else n = nextMaterial.indexOfRefraction()/currentMaterial.indexOfRefraction();
				 beta = -(dot+Math.sqrt(n*n-1.0+dot*dot));
				 temp.set(norm);
				 temp.scale(beta);
				 temp.add(r.getDirection());
				 temp.scale(1.0/n);
			 }
			 else {
				 if (currentMaterial == first.getMaterialMapping()) {
					 nextMaterial = prevMaterial;
					 nextMatTrans = prevMatTrans;
					 oldMaterial = null;
					 if (nextMaterial == null) n = 1.0/currentMaterial.indexOfRefraction();
					 else n = nextMaterial.indexOfRefraction()/currentMaterial.indexOfRefraction();
				 }
				 else {
					 nextMaterial = currentMaterial;
					 nextMatTrans = currentMatTrans;
					 if (prevMaterial == first.getMaterialMapping()) oldMaterial = null;
					 else {
						 oldMaterial = prevMaterial;
						 oldMatTrans = prevMatTrans;
					 }
					 n = 1.0;
				 }
				 beta = dot-Math.sqrt(n*n-1.0+dot*dot);
				 temp.set(norm);
				 temp.scale(-beta);
				 temp.add(r.getDirection());
				 temp.scale(1.0/n);
			 }
			 if (Double.isNaN(beta)) totalReflect = true;
			 else {
				 d = (truedot > 0.0 ? temp.dot(trueNorm) : -temp.dot(trueNorm));
				 if (d < 0.0) {
					 d += Raytracer.TOL;
					 temp.x -= d*trueNorm.x;
					 temp.y -= d*trueNorm.y;
					 temp.z -= d*trueNorm.z;
					 temp.normalize();
				 }
				 context.ray[treeDepth+1].newID();
				 if (rt.gloss) randomizeDirection(temp, norm, spec.cloudiness);
				 boolean newCaustic = (caustic || n != 1.0);
				 tracePhoton(context.ray[treeDepth+1], col, treeDepth+1, nextNode, second, nextMaterial, oldMaterial, nextMatTrans, oldMatTrans, totalDist, diffuse, newCaustic);
			 }
		 }
		 if (spawnSpecular || totalReflect) {
			 col.copy(spec.specular);
			 if (totalReflect) col.add(spec.transparent.getRed(), spec.transparent.getGreen(), spec.transparent.getBlue());
			 col.multiply(color);
			 Vec3 temp = context.ray[treeDepth+1].getDirection();
			 temp.set(norm);
			 temp.scale(-2.0*dot);
			 temp.add(r.getDirection());
			 d = (truedot > 0.0 ? temp.dot(trueNorm) : -temp.dot(trueNorm));
			 if (d >= 0.0) {
				 d += Raytracer.TOL;
				 temp.x += d*trueNorm.x;
				 temp.y += d*trueNorm.y;
				 temp.z += d*trueNorm.z;
				 temp.normalize();
			 }
			 context.ray[treeDepth+1].getOrigin().set(intersectionPoint);
			 context.ray[treeDepth+1].newID();
			 if (rt.gloss) randomizeDirection(temp, norm, spec.roughness);
			 tracePhoton(context.ray[treeDepth+1], col, treeDepth+1, nextNode, second, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, totalDist, diffuse, true);
		 }
		 if (spawnDiffuse) {
			 col.copy(spec.diffuse);
			 col.multiply(color);
			 Vec3 temp = context.ray[treeDepth+1].getDirection();
			 do {
				 temp.set(0.0, 0.0, 0.0);
				 randomizePoint(temp, 1.0);
				 temp.normalize();
				 d = temp.dot(trueNorm) * (truedot > 0.0 ? 1.0 : -1.0);
			 }
			 while (random.nextDouble() > (d < 0.0 ? -d : d));
			 if (d > 0.0) {
				 temp.scale(-1.0);
			 }
			 context.ray[treeDepth+1].getOrigin().set(intersectionPoint);
			 context.ray[treeDepth+1].newID();
			 tracePhoton(context.ray[treeDepth+1], col, treeDepth+1, nextNode, second, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, totalDist, true, caustic);
		 }
	 }
	 void propagateRay(Ray r, OctreeNode node, RTObject first, double dist, MaterialMapping material, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans, RGBColor color, int treeDepth, double totalDist, boolean caustic, boolean scattered) {
		 MaterialSpec matSpec = r.rt.matSpec;
		 Vec3 v = r.rt.ray[treeDepth+1].origin, origin = r.origin, direction = r.direction;
		 double x = 0.0, newx, dx, distToScreen = rt.theCamera.getDistToScreen(), step;
		 double origx, origy, origz, dirx, diry, dirz;
		 v.set(origin);
		 currentMatTrans.transform(v);
		 origx = v.x;
		 origy = v.y;
		 origz = v.z;
		 v.set(direction);
		 currentMatTrans.transformDirection(v);
		 dirx = v.x;
		 diry = v.y;
		 dirz = v.z;
		 step = rt.stepSize*material.getStepSize();
		 do {
			 dx = step*(1.5*r.rt.random.nextDouble());
			 if (this.rt.adaptive && totalDist > distToScreen) dx *= totalDist/distToScreen;
			 newx = x+dx;
			 if (newx > dist) {
				 dx = dist-x;
				 x = dist;
			 }
			 else x = newx;
			 totalDist += dx;
			 v.set(origx+dirx*x, origy+diry*x, origz+dirz*x);
			 material.getMaterialSpec(v, matSpec, dx, this.rt.time);
			 RGBColor trans = matSpec.transparency;
			 RGBColor scat = matSpec.scattering;
			 float rt, gt, bt;
			 if (trans.getRed() == 1.0f) rt = 1.0f;
			 else rt = (float) Math.pow(trans.getRed(), dx);
			 if (trans.getGreen() == 1.0f) gt = 1.0f;
			 else gt = (float) Math.pow(trans.getGreen(), dx);
			 if (trans.getBlue() == 1.0f) bt = 1.0f;
			 else bt = (float) Math.pow(trans.getBlue(), dx);
			 float averageTrans = (rt+gt+bt)/3.0f;
			 if (random.nextFloat() < averageTrans) {
				 color.multiply(rt/averageTrans, gt/averageTrans, bt/averageTrans);
				 continue;
			 }
			 float scatProb = (scat.getRed()+scat.getGreen()+scat.getBlue())/3.0f;
			 if (scatProb > 0.98f) scatProb = 0.98f;
			 if (random.nextFloat() < scatProb && treeDepth < this.rt.maxRayDepth-1) {
				 if (treeDepth < this.rt.maxRayDepth-1) {
					 RGBColor rayIntensity = r.rt.rayIntensity[treeDepth+1];
					 rayIntensity.copy(color);
					 rayIntensity.multiply(matSpec.scattering);
					 rayIntensity.scale(1.0f/scatProb);
					 if (rayIntensity.getMaxComponent() > this.rt.minRayIntensity) {
						 v.set(origin.x+direction.x*x, origin.y+direction.y*x, origin.z+direction.z*x);
						 while (node != null && !node.contains(v)) {
							 OctreeNode nextNode = node.findNextNode(r);
							 node = nextNode;
						 }
						 if (node == null) break;
						 double g = matSpec.eccentricity;
						 Vec3 newdir = r.rt.ray[treeDepth+1].getDirection();
						 if (g > 0.01 || g < -0.01) {
							 double theta = Math.acos((1.0+g*g-Math.pow((1-g*g)/(1-g+2*g*random.nextDouble()), 2.0))/Math.abs(2*g));
							 double phi = 2*Math.PI*random.nextDouble();
							 newdir.set(Math.sin(theta)*Math.cos(phi), Math.sin(theta)*Math.sin(phi), Math.cos(theta));
							 Mat4 m = Mat4.objectTransform(new Vec3(), direction, Math.abs(direction.y) > 0.9 ? Vec3.vx() : Vec3.vy());
							 m.transformDirection(newdir);
						 }
						 else {
							 newdir.set(0.0, 0.0, 0.0);
							 randomizePoint(newdir, 1.0);
							 newdir.normalize();
						 }
						 tracePhoton(r.rt.ray[treeDepth+1], rayIntensity, treeDepth+1, node, first, material, prevMaterial, currentMatTrans, prevMatTrans, totalDist, true, caustic);
					 }
				 }
				 color.setRGB(0.0, 0.0, 0.0);
				 break;
			 }
			 color.scale(1.0/(1.0-scatProb));
			 if ((includeDirect || scattered) && color.getMaxComponent() > this.rt.minRayIntensity) addPhoton(v, direction, color);
			 color.setRGB(0.0, 0.0, 0.0);
			 break;
		 }
		 while (x < dist);
	 }
	 private void addPhoton(Vec3 pos, Vec3 dir, RGBColor color) {
		 Photon p = new Photon(pos, dir, color);
		 synchronized (this) {
			 photonList.add(p);
		 }
		 if (direction[p.direction&0xFFFF] == null) {
			 int i = (p.direction>>8) & 0xFF;
			 int j = p.direction & 0xFF;
			 double phi = i*Math.PI/128, theta = j*Math.PI/256;
			 double sphi = Math.sin(phi), cphi = Math.cos(phi);
			 double stheta = Math.sin(theta), ctheta = Math.cos(theta);
			 direction[p.direction&0xFFFF] = new Vec3(cphi*stheta, ctheta, sphi*stheta);
		 }
	 }
	 void randomizePoint(Vec3 pos, double size) {
		 if (size == 0.0) return;
		 double x, y, z;
		 do {
			 x = random.nextDouble()-0.5;
			 y = random.nextDouble()-0.5;
			 z = random.nextDouble()-0.5;
		 }
		 while (x*x + y*y + z*z > 0.25);
		 pos.x += 2.0*size*x;
		 pos.y += 2.0*size*y;
		 pos.z += 2.0*size*z;
	 }
	 void randomizeDirection(Vec3 dir, Vec3 norm, double roughness) {
		 if (roughness == 0.0) return;
		 double x, y, z, scale, dot1, dot2;
		 do {
			 x = random.nextDouble()-0.5;
			 y = random.nextDouble()-0.5;
			 z = random.nextDouble()-0.5;
		 }
		 while (x*x + y*y + z*z > 0.25);
		 scale = Math.pow(roughness, 1.7)*0.5;
		 dot1 = dir.dot(norm);
		 dir.x += 2.0*scale*x;
		 dir.y += 2.0*scale*y;
		 dir.z += 2.0*scale*z;
		 dot2 = 2.0*dir.dot(norm);
		 if (dot1 < 0.0 && dot2 > 0.0) {
			 dir.x -= dot2*norm.x;
			 dir.y -= dot2*norm.y;
			 dir.z -= dot2*norm.z;
		 }
		 else if (dot1 > 0.0 && dot2 < 0.0) {
			 dir.x += dot2*norm.x;
			 dir.y += dot2*norm.y;
			 dir.z += dot2*norm.z;
		 }
		 dir.normalize();
	 }
	 private void buildTree(int start, int end, int root) {
		 if (start == end) photon[root] = workspace[start];
		 if (start >= end) return;
		 float minx = Float.MAX_VALUE, miny = Float.MAX_VALUE, minz = Float.MAX_VALUE;
		 float maxx = -Float.MAX_VALUE, maxy = -Float.MAX_VALUE, maxz = -Float.MAX_VALUE;
		 for (int i = start;
		 i <= end;
		 i++) {
			 Photon p = workspace[i];
			 if (p.x < minx) minx = p.x;
			 if (p.y < miny) miny = p.y;
			 if (p.z < minz) minz = p.z;
			 if (p.x > maxx) maxx = p.x;
			 if (p.y > maxy) maxy = p.y;
			 if (p.z > maxz) maxz = p.z;
		 }
		 float xsize = maxx-minx, ysize = maxy-miny, zsize = maxz-minz;
		 int axis;
		 if (xsize > ysize && xsize > zsize) axis = 0;
		 else if (ysize > zsize) axis = 1;
		 else axis = 2;
		 int size = end-start+1;
		 int medianPos = 1;
		 while (4*medianPos <= size) medianPos += medianPos;
		 if (3*medianPos <= size) medianPos = 2*medianPos+start-1;
		 else medianPos = end-medianPos+1;
		 medianSplit(start, end, medianPos, axis);
		 photon[root] = workspace[medianPos];
		 photon[root].axis = (short) axis;
		 buildTree(start, medianPos-1, 2*root+1);
		 buildTree(medianPos+1, end, 2*root+2);
	 }
	 private void medianSplit(int start, int end, int medianPos, int axis) {
		 float medianEstimate;
		 if (start == end) return;
		 if (end-start == 1) {
			 if (axisPosition(start, axis) > axisPosition(end, axis)) swap(start, end);
			 return;
		 }
		 while (start < end) {
			 float a = axisPosition(start, axis);
			 float b = axisPosition(start+1, axis);
			 float c = axisPosition(end, axis);
			 if (a > b) {
				 if (a > c) medianEstimate = (b > c ? b : c);
				 else medianEstimate = a;
			 }
			 else {
				 if (b > c) medianEstimate = (a > c ? a : c);
				 else medianEstimate = b;
			 }
			 int i = start, j = end;
			 while (true) {
				 for (;
				 i < end && axisPosition(i, axis) < medianEstimate;
				 i++);
				 for (;
				 axisPosition(j, axis) > medianEstimate;
				 j--);
				 if (i >= j) break;
				 swap(i, j);
				 i++;
				 j--;
			 }
			 swap(i, end);
			 if (i > medianPos) end = i-1;
			 if (i <= medianPos) start = i;
		 }
	 }
	 private float axisPosition(int index, int axis) {
		 switch (axis) {
			 case 0: return workspace[index].x;
			 case 1: return workspace[index].y;
			 default: return workspace[index].z;
		 }
	 }
	 private void swap(int first, int second) {
		 Photon temp = workspace[first];
		 workspace[first] = workspace[second];
		 workspace[second] = temp;
	 }
	 public void getLight(Vec3 pos, TextureSpec spec, Vec3 normal, Vec3 viewDir, boolean front, RGBColor light, PhotonMapContext pmc) {
		 light.setRGB(0.0f, 0.0f, 0.0f);
		 if (photon.length == 0) return;
		 PhotonList nearbyPhotons = pmc.nearbyPhotons;
		 RGBColor tempColor = pmc.tempColor;
		 RGBColor tempColor2 = pmc.tempColor2;
		 Vec3 tempVec = pmc.tempVec;
		 float startCutoff2 = (float) (Math.sqrt(pmc.lastCutoff2)+pos.distance(pmc.lastPos));
		 startCutoff2 *= startCutoff2;
		 if (startCutoff2 > cutoffDist2) startCutoff2 = cutoffDist2;
		 nearbyPhotons.init(startCutoff2);
		 findPhotons(pos, 0, pmc);
		 pmc.lastPos.set(pos);
		 pmc.lastCutoff2 = nearbyPhotons.cutoff2;
		 if (nearbyPhotons.numFound == 0) return;
		 float r2inv = 1.0f/nearbyPhotons.cutoff2;
		 boolean hilight = false;
		 if (spec.hilight.getMaxComponent() > rt.minRayIntensity) {
			 hilight = true;
			 tempColor2.setRGB(0.0f, 0.0f, 0.0f);
		 }
		 for (int i = 0;
		 i < nearbyPhotons.numFound;
		 i++) {
			 Photon p = nearbyPhotons.photon[i];
			 Vec3 dir = direction[p.direction&0xFFFF];
			 double dot = normal.dot(dir);
			 if ((front && dot < -1.0e-10) || (!front && dot > 1.0e-10)) {
				 tempColor.setERGB(p.ergb);
				 float x = nearbyPhotons.dist2[i]*r2inv;
				 if (filter == 2) tempColor.scale(x*(x-2.0f)+1.0f);
				 else if (filter == 1) tempColor.scale(1.0f-x*x);
				 light.add(tempColor);
				 if (hilight) {
					 tempVec.set(dir);
					 tempVec.add(viewDir);
					 tempVec.normalize();
					 double viewDot = (front ? -tempVec.dot(normal) : tempVec.dot(normal));
					 if (viewDot > 0.0) {
						 float scale = (float) FastMath.pow(viewDot, (int) ((1.0-spec.roughness)*128.0)+1);
						 tempColor2.add(tempColor.getRed()*scale, tempColor.getGreen()*scale, tempColor.getBlue()*scale);
					 }
				 }
			 }
		 }
		 light.multiply(spec.diffuse);
		 if (hilight) {
			 tempColor2.multiply(spec.hilight);
			 light.add(tempColor2);
		 }
		 light.scale(lightScale/(Math.PI*nearbyPhotons.cutoff2));
	 }
	 public void getVolumeLight(Vec3 pos, MaterialSpec spec, Vec3 viewDir, RGBColor light, PhotonMapContext pmc) {
		 light.setRGB(0.0f, 0.0f, 0.0f);
		 if (photon.length == 0) return;
		 PhotonList nearbyPhotons = pmc.nearbyPhotons;
		 RGBColor tempColor = pmc.tempColor;
		 float startCutoff2 = pmc.lastCutoff2+(float) pos.distance2(pmc.lastPos);
		 if (startCutoff2 > cutoffDist2) startCutoff2 = cutoffDist2;
		 nearbyPhotons.init(startCutoff2);
		 findPhotons(pos, 0, pmc);
		 pmc.lastPos.set(pos);
		 pmc.lastCutoff2 = nearbyPhotons.cutoff2;
		 if (nearbyPhotons.numFound == 0) return;
		 double eccentricity = spec.eccentricity;
		 double ec2 = eccentricity*eccentricity;
		 for (int i = 0;
		 i < nearbyPhotons.numFound;
		 i++) {
			 Photon p = nearbyPhotons.photon[i];
			 tempColor.setERGB(p.ergb);
			 if (eccentricity != 0.0) {
				 Vec3 dir = direction[p.direction&0xFFFF];
				 double dot = dir.dot(viewDir);
				 double fatt = (1.0-ec2)/Math.pow(1.0+ec2+2.0*eccentricity*dot, 1.5);
				 tempColor.scale(fatt);
			 }
			 light.add(tempColor);
		 }
		 light.scale(lightScale/((4.0/3.0)*Math.PI*Math.pow(nearbyPhotons.cutoff2, 1.5)));
	 }
	 private void findPhotons(Vec3 pos, int index, PhotonMapContext pmc) {
		 Photon p = photon[index];
		 float dx = p.x-(float) pos.x, dy = p.y-(float) pos.y, dz = p.z-(float) pos.z;
		 float dist2 = dx*dx + dy*dy + dz*dz;
		 float delta;
		 switch (p.axis) {
			 case 0: delta = dx;
			 break;
			 case 1: delta = dy;
			 break;
			 default: delta = dz;
		 }
		 if (delta > 0.0f) {
			 int child = (index<<1)+1;
			 if (child < photon.length) {
				 findPhotons(pos, child, pmc);
				 delta *= delta;
				 child++;
				 if (child < photon.length && delta < pmc.nearbyPhotons.cutoff2) findPhotons(pos, child, pmc);
			 }
		 }
		 else {
			 int child = (index<<1)+2;
			 if (child < photon.length) findPhotons(pos, child, pmc);
			 delta *= delta;
			 child--;
			 if (child < photon.length && delta < pmc.nearbyPhotons.cutoff2) findPhotons(pos, child, pmc);
		 }
		 if (dist2 < pmc.nearbyPhotons.cutoff2) pmc.nearbyPhotons.addPhoton(p, dist2);
	 }
	 private void validateTree(int pos) {
		 int child1 = 2*pos+1, child2 = 2*pos+2;
		 if (child1 < photon.length) {
			 validateLowerBranch(child1, photon[pos].axis, median(pos, photon[pos].axis));
			 validateTree(child1);
		 }
		 if (child2 < photon.length) {
			 validateUpperBranch(child2, photon[pos].axis, median(pos, photon[pos].axis));
			 validateTree(child2);
		 }
	 }
	 private void validateLowerBranch(int pos, int axis, float median) {
		 float value = median(pos, axis);
		 if (value > median) System.out.println(""error!"");
		 int child1 = 2*pos+1, child2 = 2*pos+2;
		 if (child1 < photon.length) validateLowerBranch(child1, axis, median);
		 if (child2 < photon.length) validateLowerBranch(child2, axis, median);
	 }
	 private void validateUpperBranch(int pos, int axis, float median) {
		 float value = median(pos, axis);
		 if (value < median) System.out.println(""error!"");
		 int child1 = 2*pos+1, child2 = 2*pos+2;
		 if (child1 < photon.length) validateUpperBranch(child1, axis, median);
		 if (child2 < photon.length) validateUpperBranch(child2, axis, median);
	 }
	 private float median(int index, int axis) {
		 switch (axis) {
			 case 0: return photon[index].x;
			 case 1: return photon[index].y;
			 default: return photon[index].z;
		 }
	 }
}",1,0,0,0
"boolean unprotectedRenameTo(UTF8 src, UTF8 dst) {
	 synchronized(rootDir) {
		 INode removedNode = rootDir.getNode(src.toString());
		 if (removedNode == null) {
			 return false;
		 }
		 removedNode.removeNode();
		 if (isDir(dst)) {
			 dst = new UTF8(dst.toString() + ""/"" + new File(src.toString()).getName());
		 }
		 INode newNode = rootDir.addNode(dst.toString(), removedNode.blocks);
		 if (newNode != null) {
			 newNode.children = removedNode.children;
			 for (Iterator it = newNode.children.values().iterator();
			 it.hasNext();
			 ) {
				 INode child = (INode) it.next();
				 child.parent = newNode;
			 }
			 return true;
		 }
		 else {
			 rootDir.addNode(src.toString(), removedNode.blocks);
			 return false;
		 }
	 }
 }",0,0,0,0
"public List<Long> getOrderedLogFileIds() {
	 File fileLogDir = new File(logDir);
	 String[] logFileNames = null;
	 List<Long> logFileIds = null;
	 if (!fileLogDir.exists()) {
		 LOGGER.log(Level.INFO, ""log dir "" + logDir + "" doesn't exist. returning empty list"");
		 return Collections.emptyList();
	 }
	 if (!fileLogDir.isDirectory()) {
		 throw new IllegalStateException(""log dir "" + logDir + "" exists but it is not a directory"");
	 }
	 logFileNames = fileLogDir.list((dir, name) -> name.startsWith(logFilePrefix));
	 if (logFileNames == null) {
		 throw new IllegalStateException(""listing of log dir ("" + logDir + "") files returned null. "" + ""Either an IO error occurred or the dir was just deleted by another process/thread"");
	 }
	 if (logFileNames.length == 0) {
		 LOGGER.log(Level.INFO, ""the log dir ("" + logDir + "") is empty. returning empty list"");
		 return Collections.emptyList();
	 }
	 logFileIds = new ArrayList<>();
	 for (String fileName : logFileNames) {
		 logFileIds.add(Long.parseLong(fileName.substring(logFilePrefix.length() + 1)));
	 }
	 logFileIds.sort(Long::compareTo);
	 return logFileIds;
 }",0,0,1,0
"public static boolean validateTypeSize(final Component parent, final JTextField size) {
	 if (validateTypeSize(size)) {
		 return true;
	 }
	 else {
		 CMessageBox.showWarning(parent, ""Please enter a valid type size."");
		 return false;
	 }
 }",0,0,0,0
"public static class LocalMessageManager<M extends Writable> extends AbstractMessageManager<M> {
	 private static final ConcurrentHashMap<InetSocketAddress, LocalMessageManager> MANAGER_MAP = new ConcurrentHashMap<InetSocketAddress, LocalBSPRunner.LocalMessageManager>();
	 private InetSocketAddress selfAddress;
	 public void init(TaskAttemptID attemptId, BSPPeer<?, ?, ?, ?, M> peer, HamaConfiguration conf, InetSocketAddress peerAddress) {
		 super.init(attemptId, peer, conf, peerAddress);
		 MANAGER_MAP.put(peerAddress, this);
		 selfAddress = peerAddress;
	 }
	 public void transfer(InetSocketAddress addr, BSPMessageBundle<M> bundle) throws IOException {
		 MANAGER_MAP.get(addr).localQueueForNextIteration.addBundle(bundle);
		 peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGES_RECEIVED, bundle.size());
	 }
	 public InetSocketAddress getListenerAddress() {
		 return selfAddress;
	 }
	 public void transfer(InetSocketAddress addr, M msg) throws IOException {
		 MANAGER_MAP.get(addr).localQueueForNextIteration.add(msg);
		 peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGES_RECEIVED, 1);
	 }
 }",0,0,0,0
"public final class DQ_EvaluationMethodTypeCode extends CodeListAdapter<DQ_EvaluationMethodTypeCode, EvaluationMethodType>{
	 public DQ_EvaluationMethodTypeCode() {
	 }
	 private DQ_EvaluationMethodTypeCode(final CodeListUID value) {
		 super(value);
	 }
	 protected DQ_EvaluationMethodTypeCode wrap(final CodeListUID value) {
		 return new DQ_EvaluationMethodTypeCode(value);
	 }
	 protected Class<EvaluationMethodType> getCodeListClass() {
		 return EvaluationMethodType.class;
	 }
	 public CodeListUID getElement() {
		 return identifier;
	 }
	 public void setElement(final CodeListUID value) {
		 identifier = value;
	 }
}",0,1,0,0
"public static Memory allocate(long bytes) {
	 if (bytes < 0) throw new IllegalArgumentException();
	 return new Memory(bytes);
 }",0,0,0,0
"public final void rule__XWhileExpression__Group__0__Impl() throws RecognitionException {
	 int stackSize = keepStackSize();
	 try {
		 {
			 {
				 if ( state.backtracking==0 ) {
					 before(grammarAccess.getXWhileExpressionAccess().getXWhileExpressionAction_0());
				 }
				 {
				 }
				 if ( state.backtracking==0 ) {
					 after(grammarAccess.getXWhileExpressionAccess().getXWhileExpressionAction_0());
				 }
			 }
		 }
	 }
	 finally {
		 restoreStackSize(stackSize);
	 }
	 return ;
 }",0,0,1,0
"public class PropertyHelper implements GetProperty {
	 public interface Delegate {
	 }
	 public interface PropertyEvaluator extends Delegate {
		 Object evaluate(String property, PropertyHelper propertyHelper);
	 }
	 public interface PropertySetter extends Delegate {
		 boolean setNew( String property, Object value, PropertyHelper propertyHelper);
		 boolean set( String property, Object value, PropertyHelper propertyHelper);
	 }
	 private static final PropertyEvaluator TO_STRING = new PropertyEvaluator() {
		 private final String PREFIX = ""toString:"";
		 private final int PREFIX_LEN = PREFIX.length();
		 public Object evaluate(String property, PropertyHelper propertyHelper) {
			 Object o = null;
			 if (property.startsWith(PREFIX) && propertyHelper.getProject() != null) {
				 o = propertyHelper.getProject().getReference(property.substring(PREFIX_LEN));
			 }
			 return o == null ? null : o.toString();
		 }
	 }
	;
	 private static final PropertyExpander DEFAULT_EXPANDER = new PropertyExpander() {
		 public String parsePropertyName( String s, ParsePosition pos, ParseNextProperty notUsed) {
			 int index = pos.getIndex();
			 if (s.length() - index >= 3 && '$' == s.charAt(index) && '{
				' == s.charAt(index + 1)) {
					 int start = index + 2;
				 int end = s.indexOf('}
				', start);
				 if (end < 0) {
					 throw new BuildException(""Syntax error in property: "" + s.substring(index));
				 }
				 pos.setIndex(end + 1);
				 return start == end ? """" : s.substring(start, end);
			 }
			 return null;
		 }
	 }
	;
	 private static final PropertyExpander SKIP_DOUBLE_DOLLAR = new PropertyExpander() {
		 public String parsePropertyName( String s, ParsePosition pos, ParseNextProperty notUsed) {
			 int index = pos.getIndex();
			 if (s.length() - index >= 2) {
				 if ('$' == s.charAt(index) && '$' == s.charAt(++index)) {
					 pos.setIndex(index);
				 }
			 }
			 return null;
		 }
	 }
	;
	 private static final PropertyEvaluator FROM_REF = new PropertyEvaluator() {
		 private final String PREFIX = ""ant.refid:"";
		 private final int PREFIX_LEN = PREFIX.length();
		 public Object evaluate(String prop, PropertyHelper helper) {
			 return prop.startsWith(PREFIX) && helper.getProject() != null ? helper.getProject().getReference(prop.substring(PREFIX_LEN)) : null;
		 }
	 }
	;
	 private Project project;
	 private PropertyHelper next;
	 private Hashtable delegates = new Hashtable();
	 private Hashtable properties = new Hashtable();
	 private Hashtable userProperties = new Hashtable();
	 private Hashtable inheritedProperties = new Hashtable();
	 protected PropertyHelper() {
		 add(FROM_REF);
		 add(TO_STRING);
		 add(SKIP_DOUBLE_DOLLAR);
		 add(DEFAULT_EXPANDER);
	 }
	 public static Object getProperty(Project project, String name) {
		 return PropertyHelper.getPropertyHelper(project) .getProperty(name);
	 }
	 public static void setProperty(Project project, String name, Object value) {
		 PropertyHelper.getPropertyHelper(project) .setProperty(name, value, true);
	 }
	 public static void setNewProperty( Project project, String name, Object value) {
		 PropertyHelper.getPropertyHelper(project) .setNewProperty(name, value);
	 }
	 public void setProject(Project p) {
		 this.project = p;
	 }
	 public Project getProject() {
		 return project;
	 }
	 public void setNext(PropertyHelper next) {
		 this.next = next;
	 }
	 public PropertyHelper getNext() {
		 return next;
	 }
	 public static synchronized PropertyHelper getPropertyHelper(Project project) {
		 PropertyHelper helper = null;
		 if (project != null) {
			 helper = (PropertyHelper) project.getReference(MagicNames .REFID_PROPERTY_HELPER);
		 }
		 if (helper != null) {
			 return helper;
		 }
		 helper = new PropertyHelper();
		 helper.setProject(project);
		 if (project != null) {
			 project.addReference(MagicNames.REFID_PROPERTY_HELPER, helper);
		 }
		 return helper;
	 }
	 public Collection getExpanders() {
		 return getDelegates(PropertyExpander.class);
	 }
	 public boolean setPropertyHook(String ns, String name, Object value, boolean inherited, boolean user, boolean isNew) {
		 if (getNext() != null) {
			 boolean subst = getNext().setPropertyHook(ns, name, value, inherited, user, isNew);
			 if (subst) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public Object getPropertyHook(String ns, String name, boolean user) {
		 if (getNext() != null) {
			 Object o = getNext().getPropertyHook(ns, name, user);
			 if (o != null) {
				 return o;
			 }
		 }
		 if (project != null && name.startsWith(""toString:"")) {
			 name = name.substring(""toString:"".length());
			 Object v = project.getReference(name);
			 return (v == null) ? null : v.toString();
		 }
		 return null;
	 }
	 public void parsePropertyString(String value, Vector fragments, Vector propertyRefs) throws BuildException {
		 parsePropertyStringDefault(value, fragments, propertyRefs);
	 }
	 public String replaceProperties(String ns, String value, Hashtable keys) throws BuildException {
		 return replaceProperties(value);
	 }
	 public String replaceProperties(String value) throws BuildException {
		 Object o = parseProperties(value);
		 return o == null || o instanceof String ? (String) o : o.toString();
	 }
	 public Object parseProperties(String value) throws BuildException {
		 return new ParseProperties(getProject(), getExpanders(), this) .parseProperties(value);
	 }
	 public boolean containsProperties(String value) {
		 return new ParseProperties(getProject(), getExpanders(), this) .containsProperties(value);
	 }
	 public boolean setProperty(String ns, String name, Object value, boolean verbose) {
		 return setProperty(name, value, verbose);
	 }
	 public boolean setProperty(String name, Object value, boolean verbose) {
		 for (Iterator iter = getDelegates(PropertySetter.class).iterator();
		 iter.hasNext();
		) {
			 PropertySetter setter = (PropertySetter) iter.next();
			 if (setter.set(name, value, this)) {
				 return true;
			 }
		 }
		 synchronized (this) {
			 if (userProperties.containsKey(name)) {
				 if (project != null && verbose) {
					 project.log(""Override ignored for user property \"""" + name + ""\"""", Project.MSG_VERBOSE);
				 }
				 return false;
			 }
			 if (project != null && verbose) {
				 if (properties.containsKey(name)) {
					 project.log(""Overriding previous definition of property \"""" + name + ""\"""", Project.MSG_VERBOSE);
				 }
				 project.log(""Setting project property: "" + name + "" -> "" + value, Project.MSG_DEBUG);
			 }
			 if (name != null && value != null) {
				 properties.put(name, value);
			 }
			 return true;
		 }
	 }
	 public void setNewProperty(String ns, String name, Object value) {
		 setNewProperty(name, value);
	 }
	 public void setNewProperty(String name, Object value) {
		 for (Iterator iter = getDelegates(PropertySetter.class).iterator();
		 iter.hasNext();
		) {
			 PropertySetter setter = (PropertySetter) iter.next();
			 if (setter.setNew(name, value, this)) {
				 return;
			 }
		 }
		 synchronized (this) {
			 if (project != null && properties.containsKey(name)) {
				 project.log(""Override ignored for property \"""" + name + ""\"""", Project.MSG_VERBOSE);
				 return;
			 }
			 if (project != null) {
				 project.log(""Setting project property: "" + name + "" -> "" + value, Project.MSG_DEBUG);
			 }
			 if (name != null && value != null) {
				 properties.put(name, value);
			 }
		 }
	 }
	 public void setUserProperty(String ns, String name, Object value) {
		 setUserProperty(name, value);
	 }
	 public void setUserProperty(String name, Object value) {
		 if (project != null) {
			 project.log(""Setting ro project property: "" + name + "" -> "" + value, Project.MSG_DEBUG);
		 }
		 synchronized (this) {
			 userProperties.put(name, value);
			 properties.put(name, value);
		 }
	 }
	 public void setInheritedProperty(String ns, String name, Object value) {
		 setInheritedProperty(name, value);
	 }
	 public void setInheritedProperty(String name, Object value) {
		 if (project != null) {
			 project.log(""Setting ro project property: "" + name + "" -> "" + value, Project.MSG_DEBUG);
		 }
		 synchronized (this) {
			 inheritedProperties.put(name, value);
			 userProperties.put(name, value);
			 properties.put(name, value);
		 }
	 }
	 public Object getProperty(String ns, String name) {
		 return getProperty(name);
	 }
	 public Object getProperty(String name) {
		 if (name == null) {
			 return null;
		 }
		 for (Iterator iter = getDelegates(PropertyEvaluator.class).iterator();
		 iter.hasNext();
		) {
			 Object o = ((PropertyEvaluator) iter.next()).evaluate(name, this);
			 if (o != null) {
				 if (o instanceof NullReturn) {
					 return null;
				 }
				 return o;
			 }
		 }
		 return properties.get(name);
	 }
	 public Object getUserProperty(String ns, String name) {
		 return getUserProperty(name);
	 }
	 public Object getUserProperty(String name) {
		 if (name == null) {
			 return null;
		 }
		 return userProperties.get(name);
	 }
	 public Hashtable getProperties() {
		 synchronized (properties) {
			 return new Hashtable(properties);
		 }
	 }
	 public Hashtable getUserProperties() {
		 synchronized (userProperties) {
			 return new Hashtable(userProperties);
		 }
	 }
	 public Hashtable getInheritedProperties() {
		 synchronized (inheritedProperties) {
			 return new Hashtable(inheritedProperties);
		 }
	 }
	 protected Hashtable getInternalProperties() {
		 return properties;
	 }
	 protected Hashtable getInternalUserProperties() {
		 return userProperties;
	 }
	 protected Hashtable getInternalInheritedProperties() {
		 return inheritedProperties;
	 }
	 public void copyInheritedProperties(Project other) {
		 synchronized (inheritedProperties) {
			 Enumeration e = inheritedProperties.keys();
			 while (e.hasMoreElements()) {
				 String arg = e.nextElement().toString();
				 if (other.getUserProperty(arg) != null) {
					 continue;
				 }
				 Object value = inheritedProperties.get(arg);
				 other.setInheritedProperty(arg, value.toString());
			 }
		 }
	 }
	 public void copyUserProperties(Project other) {
		 synchronized (userProperties) {
			 Enumeration e = userProperties.keys();
			 while (e.hasMoreElements()) {
				 Object arg = e.nextElement();
				 if (inheritedProperties.containsKey(arg)) {
					 continue;
				 }
				 Object value = userProperties.get(arg);
				 other.setUserProperty(arg.toString(), value.toString());
			 }
		 }
	 }
	 static void parsePropertyStringDefault(String value, Vector fragments, Vector propertyRefs) throws BuildException {
		 int prev = 0;
		 int pos;
		 while ((pos = value.indexOf(""$"", prev)) >= 0) {
			 if (pos > 0) {
				 fragments.addElement(value.substring(prev, pos));
			 }
			 if (pos == (value.length() - 1)) {
				 fragments.addElement(""$"");
				 prev = pos + 1;
			 }
			 else if (value.charAt(pos + 1) != '{
				') {
					 if (value.charAt(pos + 1) == '$') {
						 fragments.addElement(""$"");
						 prev = pos + 2;
					 }
					 else {
						 fragments.addElement(value.substring(pos, pos + 2));
						 prev = pos + 2;
					 }
				 }
				 else {
				 int endName = value.indexOf('}
				', pos);
				 if (endName < 0) {
					 throw new BuildException(""Syntax error in property: "" + value);
				 }
				 String propertyName = value.substring(pos + 2, endName);
				 fragments.addElement(null);
				 propertyRefs.addElement(propertyName);
				 prev = endName + 1;
			 }
		 }
		 if (prev < value.length()) {
			 fragments.addElement(value.substring(prev));
		 }
	 }
	 public void add(Delegate delegate) {
		 synchronized (delegates) {
			 for (Iterator iter = getDelegateInterfaces(delegate).iterator();
			 iter.hasNext();
			) {
				 Object key = iter.next();
				 List list = (List) delegates.get(key);
				 if (list == null) {
					 list = new ArrayList();
				 }
				 else {
					 list = new ArrayList(list);
					 list.remove(delegate);
				 }
				 list.add(0, delegate);
				 delegates.put(key, Collections.unmodifiableList(list));
			 }
		 }
	 }
	 protected List getDelegates(Class type) {
		 List r = (List) delegates.get(type);
		 return r == null ? Collections.EMPTY_LIST : r;
	 }
	 protected static Set getDelegateInterfaces(Delegate d) {
		 HashSet result = new HashSet();
		 Class c = d.getClass();
		 while (c != null) {
			 Class[] ifs = c.getInterfaces();
			 for (int i = 0;
			 i < ifs.length;
			 i++) {
				 if (Delegate.class.isAssignableFrom(ifs[i])) {
					 result.add(ifs[i]);
				 }
			 }
			 c = c.getSuperclass();
		 }
		 result.remove(Delegate.class);
		 return result;
	 }
	 public static Boolean toBoolean(Object value) {
		 if (value instanceof Boolean) {
			 return (Boolean) value;
		 }
		 if (value instanceof String) {
			 String s = (String) value;
			 if (Project.toBoolean(s)) {
				 return Boolean.TRUE;
			 }
			 if (""off"".equalsIgnoreCase(s) || ""false"".equalsIgnoreCase(s) || ""no"".equalsIgnoreCase(s)) {
				 return Boolean.FALSE;
			 }
		 }
		 return null;
	 }
	 private static boolean nullOrEmpty(Object value) {
		 return value == null || """".equals(value);
	 }
	 private boolean evalAsBooleanOrPropertyName(Object value) {
		 Boolean b = toBoolean(value);
		 if (b != null) {
			 return b.booleanValue();
		 }
		 return getProperty(String.valueOf(value)) != null;
	 }
	 public boolean testIfCondition(Object value) {
		 return nullOrEmpty(value) || evalAsBooleanOrPropertyName(value);
	 }
	 public boolean testUnlessCondition(Object value) {
		 return nullOrEmpty(value) || !evalAsBooleanOrPropertyName(value);
	 }
}",0,0,0,0
"final class JsonObjects {
	 private static final Jsonb JSON = JsonbBuilder.create();
	 private JsonObjects() {
	 }
	 static List<Column> getColumns(JsonObject jsonObject) {
		 Map<String, Object> map = JSON.fromJson(jsonObject.toString(), Map.class);
		 return Columns.of(map);
	 }
}",0,1,0,0
"public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	 NutchBean.LOG.info(""query request from "" + request.getRemoteAddr());
	 request.setCharacterEncoding(""UTF-8"");
	 String queryString = request.getParameter(""query"");
	 if (queryString == null) queryString = """";
	 String urlQuery = URLEncoder.encode(queryString, ""UTF-8"");
	 int start = 0;
	 String startString = request.getParameter(""start"");
	 if (startString != null) start = Integer.parseInt(startString);
	 int hitsPerPage = 10;
	 String hitsString = request.getParameter(""hitsPerPage"");
	 if (hitsString != null) hitsPerPage = Integer.parseInt(hitsString);
	 String sort = request.getParameter(""sort"");
	 boolean reverse = sort!=null && ""true"".equals(request.getParameter(""reverse""));
	 String dedupField = request.getParameter(""dedupField"");
	 if (dedupField == null || dedupField.length() == 0) {
		 dedupField = ""site"";
	 }
	 int hitsPerDup = 2;
	 String hitsPerDupString = request.getParameter(""hitsPerDup"");
	 if (hitsPerDupString != null && hitsPerDupString.length() > 0) {
		 hitsPerDup = Integer.parseInt(hitsPerDupString);
	 }
	 else {
		 String hitsPerSiteString = request.getParameter(""hitsPerSite"");
		 if (hitsPerSiteString != null && hitsPerSiteString.length() > 0) {
			 hitsPerDup = Integer.parseInt(hitsPerSiteString);
		 }
	 }
	 String params = ""&hitsPerPage="" + hitsPerPage + (sort == null ? """" : ""&sort="" + sort + (reverse? ""&reverse=true"": """") + (dedupField == null ? """" : ""&dedupField="" + dedupField));
	 Query query = Query.parse(queryString);
	 NutchBean.LOG.info(""query: "" + queryString);
	 Hits hits;
	 try {
		 hits = bean.search(query, start + hitsPerPage, hitsPerDup, dedupField, sort, reverse);
	 }
	 catch (IOException e) {
		 NutchBean.LOG.log(Level.WARNING, ""Search Error"", e);
		 hits = new Hits(0,new Hit[0]);
	 }
	 NutchBean.LOG.info(""total hits: "" + hits.getTotal());
	 int end = (int)Math.min(hits.getLength(), start + hitsPerPage);
	 int length = end-start;
	 Hit[] show = hits.getHits(start, end-start);
	 HitDetails[] details = bean.getDetails(show);
	 String[] summaries = bean.getSummary(details, query);
	 String requestUrl = request.getRequestURL().toString();
	 String base = requestUrl.substring(0, requestUrl.lastIndexOf('/'));
	 try {
		 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		 factory.setNamespaceAware(true);
		 Document doc = factory.newDocumentBuilder().newDocument();
		 Element rss = addNode(doc, doc, ""rss"");
		 addAttribute(doc, rss, ""version"", ""2.0"");
		 addAttribute(doc, rss, ""xmlns:opensearch"", (String)NS_MAP.get(""opensearch""));
		 addAttribute(doc, rss, ""xmlns:nutch"", (String)NS_MAP.get(""nutch""));
		 Element channel = addNode(doc, rss, ""channel"");
		 addNode(doc, channel, ""title"", ""Nutch: "" + queryString);
		 addNode(doc, channel, ""description"", ""Nutch search results for query: "" + queryString);
		 addNode(doc, channel, ""link"", base+""/search.jsp"" +""?query=""+urlQuery +""&start=""+start +""&hitsPerDup=""+hitsPerDup +params);
		 addNode(doc, channel, ""opensearch"", ""totalResults"", """"+hits.getTotal());
		 addNode(doc, channel, ""opensearch"", ""startIndex"", """"+start);
		 addNode(doc, channel, ""opensearch"", ""itemsPerPage"", """"+hitsPerPage);
		 addNode(doc, channel, ""nutch"", ""query"", queryString);
		 if ((hits.totalIsExact() && end < hits.getTotal()) || (!hits.totalIsExact() && (hits.getLength() > start+hitsPerPage))){
			 addNode(doc, channel, ""nutch"", ""nextPage"", requestUrl +""?query=""+urlQuery +""&start=""+end +""&hitsPerDup=""+hitsPerDup +params);
		 }
		 if ((!hits.totalIsExact() && (hits.getLength() <= start+hitsPerPage))) {
			 addNode(doc, channel, ""nutch"", ""showAllHits"", requestUrl +""?query=""+urlQuery +""&hitsPerDup=""+0 +params);
		 }
		 for (int i = 0;
		 i < length;
		 i++) {
			 Hit hit = show[i];
			 HitDetails detail = details[i];
			 String title = detail.getValue(""title"");
			 String url = detail.getValue(""url"");
			 String id = ""idx="" + hit.getIndexNo() + ""&id="" + hit.getIndexDocNo();
			 if (title == null || title.equals("""")) title = url;
			 Element item = addNode(doc, channel, ""item"");
			 addNode(doc, item, ""title"", title);
			 addNode(doc, item, ""description"", summaries[i]);
			 addNode(doc, item, ""link"", url);
			 addNode(doc, item, ""nutch"", ""site"", hit.getDedupValue());
			 addNode(doc, item, ""nutch"", ""cache"", base+""/cached.jsp?""+id);
			 addNode(doc, item, ""nutch"", ""explain"", base+""/explain.jsp?""+id +""&query=""+urlQuery);
			 if (hit.moreFromDupExcluded()) {
				 addNode(doc, item, ""nutch"", ""moreFromSite"", requestUrl +""?query="" +URLEncoder.encode(""site:""+hit.getDedupValue() +"" ""+queryString, ""UTF-8"") +""&hitsPerSite=""+0 +params);
			 }
			 for (int j = 0;
			 j < detail.getLength();
			 j++) {
				 String field = detail.getField(j);
				 if (!SKIP_DETAILS.contains(field)) addNode(doc, item, ""nutch"", field, detail.getValue(j));
			 }
		 }
		 DOMSource source = new DOMSource(doc);
		 TransformerFactory transFactory = TransformerFactory.newInstance();
		 Transformer transformer = transFactory.newTransformer();
		 transformer.setOutputProperty(""indent"", ""yes"");
		 StreamResult result = new StreamResult(response.getOutputStream());
		 response.setContentType(""text/xml"");
		 transformer.transform(source, result);
	 }
	 catch (javax.xml.parsers.ParserConfigurationException e) {
		 throw new ServletException(e);
	 }
	 catch (javax.xml.transform.TransformerException e) {
		 throw new ServletException(e);
	 }
 }",0,0,1,0
"private static final class SimpleNameParser implements NameParser {
	 private static final Properties PARSER_PROPERTIES = new Properties();
	 static {
		 PARSER_PROPERTIES.put(""jndi.syntax.direction"", ""left_to_right"");
		 PARSER_PROPERTIES.put(""jndi.syntax.separator"", ""/"");
	 }
	 private SimpleNameParser() {
	 }
	 public Name parse(final String name) throws NamingException {
		 return new CompoundName(name, PARSER_PROPERTIES);
	 }
 }",0,0,0,0
"private static void doRawReceiveFile(File path, int size, InputStream clientInput) throws IOException {
	 File tempfile = File.createTempFile( AgentUtil.TEMP_PREFIX + path.getName() + ""-"", "".tmp"", path.getParentFile());
	 FileOutputStream output = new FileOutputStream(tempfile);
	 long receiveStartMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
	 long totalSize = 0;
	 long totalReceiveTimeoutMs = RECEIVE_TIMEOUT_MS + TOTAL_RECEIVE_TIMEOUT_MS_PER_MB * (size / 1024 / 1024);
	 try {
		 int bufferSize = 128 * 1024;
		 byte[] buf = new byte[bufferSize];
		 while (true) {
			 long currentTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
			 if (currentTimeMs - receiveStartMs > totalReceiveTimeoutMs) {
				 throw new RuntimeException(""Receive failed to complete before timeout."");
			 }
			 int remaining = size - (int) totalSize;
			 if (remaining == 0) {
				 break;
			 }
			 int want = bufferSize;
			 if (want > remaining) {
				 want = remaining;
			 }
			 int got = clientInput.read(buf, 0, want);
			 if (got == -1) {
				 break;
			 }
			 output.write(buf, 0, got);
			 totalSize += got;
		 }
	 }
	 finally {
		 output.close();
	 }
	 if (totalSize != size) {
		 throw new RuntimeException(""Received only "" + totalSize + "" of "" + size + "" bytes."");
	 }
	 boolean success = tempfile.renameTo(path);
	 if (!success) {
		 throw new RuntimeException(""Failed to rename temp file."");
	 }
 }",0,0,1,0
"class ColumnFamilyRegionInfo {
	 private RegionInfo regionInfo;
	 private Set<byte[]> familySet;
	 public ColumnFamilyRegionInfo(RegionInfo regionInfo, Set<byte[]> familySet) {
		 this.regionInfo = regionInfo;
		 this.familySet = familySet;
	 }
	 public RegionInfo getRegionInfo() {
		 return regionInfo;
	 }
	 public Set<byte[]> getFamilySet() {
		 return familySet;
	 }
	 public boolean equals(Object obj) {
		 if (obj == this) {
			 return true;
		 }
		 if (!(obj instanceof ColumnFamilyRegionInfo)) {
			 return false;
		 }
		 ColumnFamilyRegionInfo c = (ColumnFamilyRegionInfo)obj;
		 return c.getRegionInfo().equals(this.regionInfo) && ByteUtil.match(this.familySet, c.getFamilySet());
	 }
	 public int hashCode() {
		 return this.getRegionInfo().hashCode();
	 }
 }",0,1,0,0
"public boolean equals( Object to ) {
	 return (name.equals(((DatanodeID)to).getName()) && storageID.equals(((DatanodeID)to).getStorageID()));
 }",0,0,0,0
"public class MavenWarningSection extends GroupSection {
	private static final GrailsM2EUtils m2e = GrailsM2EUtils.getInstance();
	private static class IgnoreMavenWarning extends WizardPageSection {
		private String msg;
		private final GrailsImportWizardCore model;
		public IgnoreMavenWarning(GrailsImportWizardPage owner, String msg) {
			super(owner);
			this.msg = msg;
			this.model = owner.model;
		}
		public LiveExpression<ValidationResult> getValidator() {
			return model.mavenValidator;
		}
		public void createContents(Composite page) {
			final Button checkBox = new Button(page, SWT.CHECK);
			checkBox.setSelection(model.ignoreMavenWarning.getValue());
			checkBox.setText(msg);
			checkBox.addSelectionListener(new SelectionAdapter() {
				public void widgetSelected(SelectionEvent e) {
					model.ignoreMavenWarning.setValue(checkBox.getSelection());
				}
			}
			);
		}
	}
	public MavenWarningSection(GrailsImportWizardPage owner, String title) {
		super(owner, title,new CommentSection(owner, ""The selected project looks like a Mavenized project and should be imported using m2e's "" +""'Import Existing Maven Projects' wizard. If you proceed the project may not be imported correctly.""),new IgnoreMavenWarning(owner, ""Ignore this warning and allow me to proceed""),new OpenM2EImportWizardSection(owner));
		owner.model.isMaven.addListener(new ValueListener<Boolean>() {
			public void gotValue(LiveExpression<Boolean> exp, Boolean isMaven) {
				isVisible.setValue(isMaven);
			}
		}
		);
	}
	private static class OpenM2EImportWizardSection extends WizardPageSection {
		private GrailsImportWizardPage page;
		private GrailsImportWizardCore model;
		public OpenM2EImportWizardSection(GrailsImportWizardPage page) {
			super(page);
			this.page = page;
			this.model = page.model;
		}
		private void openWizard() {
			owner.getShell().close();
			m2e.openM2EImportWizard(model.location.getValue());
		}
		public LiveExpression<ValidationResult> getValidator() {
			return Validator.constant(ValidationResult.OK);
		}
		public void createContents(Composite page) {
			if (m2e.isInstalled()) {
				Button button = new Button(page, SWT.PUSH);
				button.setText(""Switch to Maven Import"");
				button.addSelectionListener(new SelectionAdapter() {
					public void widgetSelected(SelectionEvent e) {
						openWizard();
					}
				}
				);
			}
			 else {
				Label label = new Label(page, SWT.WRAP);
				label.setText(""Can't open M2E Wizard because M2E is not installed."");
			}
		}
	}
}",1,0,0,0
"public boolean encloses(Interval interval) {
	 return (this.min.compareTo(interval.min) <= 0 && this.max.compareTo(interval.max) >= 0);
 }",0,0,0,0
"final class AttributesDeletedStrategy extends AbstractEventStrategy<AttributesDeleted> {
	 protected ThingBuilder.FromCopy applyEvent(final AttributesDeleted event, final ThingBuilder.FromCopy thingBuilder) {
		 return thingBuilder.removeAllAttributes();
	 }
}",0,0,0,0
"public class ColumnBase {
	 private String name;
	 private String table;
	 private String schema;
	 private String catalog;
	 private boolean isWriteable;
	 private boolean isSearchable;
	 protected byte parameterMode;
	 protected boolean isIdentity;
	 protected byte nullability;
	 protected Type dataType;
	 ColumnBase() {
	}
	 public ColumnBase(String catalog, String schema, String table, String name) {
		 this.catalog = catalog;
		 this.schema = schema;
		 this.table = table;
		 this.name = name;
	 }
	 public String getNameString() {
		 return name;
	 }
	 public String getTableNameString() {
		 return table;
	 }
	 public String getSchemaNameString() {
		 return schema;
	 }
	 public String getCatalogNameString() {
		 return catalog;
	 }
	 public void setIdentity(boolean value) {
		 isIdentity = value;
	 }
	 public boolean isIdentity() {
		 return isIdentity;
	 }
	 protected void setType(ColumnBase other) {
		 nullability = other.nullability;
		 dataType = other.dataType;
	 }
	 public void setType(Type type) {
		 this.dataType = type;
	 }
	 public boolean isNullable() {
		 return !isIdentity && nullability == SchemaObject.Nullability.NULLABLE;
	 }
	 protected void setNullable(boolean value) {
		 nullability = value ? SchemaObject.Nullability.NULLABLE : SchemaObject.Nullability.NO_NULLS;
	 }
	 public byte getNullability() {
		 return isIdentity ? SchemaObject.Nullability.NO_NULLS : nullability;
	 }
	 public void setNullability(byte value) {
		 nullability = value;
	 }
	 public boolean isWriteable() {
		 return isWriteable;
	 }
	 public boolean isSearchable() {
		 return isSearchable;
	 }
	 public void setWriteable(boolean value) {
		 isWriteable = value;
	 }
	 public Type getDataType() {
		 return dataType;
	 }
	 public byte getParameterMode() {
		 return parameterMode;
	 }
	 public void setParameterMode(byte mode) {
		 this.parameterMode = mode;
	 }
}",0,1,0,0
"public class TransportConnectionState extends org.apache.activemq.state.ConnectionState {
	 private ConnectionContext context;
	 private TransportConnection connection;
	 private AtomicInteger referenceCounter = new AtomicInteger();
	 private final Object connectionMutex = new Object();
	 public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {
		 super(info);
		 connection = transportConnection;
	 }
	 public ConnectionContext getContext() {
		 return context;
	 }
	 public TransportConnection getConnection() {
		 return connection;
	 }
	 public void setContext(ConnectionContext context) {
		 this.context = context;
	 }
	 public void setConnection(TransportConnection connection) {
		 this.connection = connection;
	 }
	 public int incrementReference() {
		 return referenceCounter.incrementAndGet();
	 }
	 public int decrementReference() {
		 return referenceCounter.decrementAndGet();
	 }
	public AtomicInteger getReferenceCounter() {
		return referenceCounter;
	}
	public void setReferenceCounter(AtomicInteger referenceCounter) {
		this.referenceCounter = referenceCounter;
	}
	public Object getConnectionMutex() {
		return connectionMutex;
	}
}",0,1,0,0
"public void bind(PropertyList pList) throws FOPException {
	 super.bind(pList);
	 alignmentAdjust = pList.get(PR_ALIGNMENT_ADJUST).getLength();
	 alignmentBaseline = pList.get(PR_ALIGNMENT_BASELINE).getEnum();
	 baselineShift = pList.get(PR_BASELINE_SHIFT).getLength();
	 dominantBaseline = pList.get(PR_DOMINANT_BASELINE).getEnum();
	 leaderAlignment = pList.get(PR_LEADER_ALIGNMENT).getEnum();
	 leaderLength = pList.get(PR_LEADER_LENGTH).getLengthRange();
	 leaderPattern = pList.get(PR_LEADER_PATTERN).getEnum();
	 leaderPatternWidth = pList.get(PR_LEADER_PATTERN_WIDTH).getLength();
	 ruleThickness = getPropertyMakerFor(PR_RULE_THICKNESS).make(pList).getLength();
	 switch(leaderPattern) {
		 case EN_SPACE: break;
		 case EN_RULE: ruleStyle = pList.get(PR_RULE_STYLE).getEnum();
		 ruleThickness = pList.get(PR_RULE_THICKNESS).getLength();
		 break;
		 case EN_DOTS: break;
		 case EN_USECONTENT: break;
		 default: throw new RuntimeException(""Invalid leader pattern: "" + leaderPattern);
	 }
 }",0,0,1,0
"public class GetOperationCompletedEvent extends OperationCompletedEvent {
	 private final GetRequest[] requests;
	 private final GetStatus status;
	 public GetOperationCompletedEvent( final EventSource source, final Workspace workspace, final GetRequest[] requests, final GetStatus status) {
		 super(source, workspace, ProcessType.GET);
		 Check.notNull(requests, ""requests"");
		 this.requests = requests;
		 this.status = status;
	 }
	 public GetStatus getStatus() {
		 return status;
	 }
	 public GetRequest[] getRequests() {
		 return requests;
	 }
}",0,1,0,0
"public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent event) throws Exception {
	 try {
		 if (isConnected() && (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED) || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED) || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))) {
			 synchronized (this) {
				 Participant participant = leaderLatch.getLeader();
				 if (isLeader(participant) && !leaderLatch.hasLeadership()) {
					 currentLeader = participant;
				 }
			 }
		 }
	 }
	 catch (InterruptedException e) {
		 log.warn(""Oracle leadership watcher has been interrupted unexpectedly"");
	 }
 }",0,0,1,0
"public class LoadResource extends Task {
	 private Resource src;
	 private boolean failOnError = true;
	 private boolean quiet = false;
	 private String encoding = null;
	 private String property = null;
	 private final Vector filterChains = new Vector();
	 public final void setEncoding(final String encoding) {
		 this.encoding = encoding;
	 }
	 public final void setProperty(final String property) {
		 this.property = property;
	 }
	 public final void setFailonerror(final boolean fail) {
		 failOnError = fail;
	 }
	 public void setQuiet(final boolean quiet) {
		 this.quiet = quiet;
		 if (quiet) {
			 this.failOnError = false;
		 }
	 }
	 public final void execute() throws BuildException {
		 if (src == null) {
			 throw new BuildException(""source resource not defined"");
		 }
		 if (property == null) {
			 throw new BuildException(""output property not defined"");
		 }
		 if (quiet && failOnError) {
			 throw new BuildException(""quiet and failonerror cannot both be "" + ""set to true"");
		 }
		 if (!src.isExists()) {
			 String message = src + "" doesn't exist"";
			 if (failOnError) {
				 throw new BuildException(message);
			 }
			 else {
				 log(message, quiet ? Project.MSG_WARN : Project.MSG_ERR);
				 return;
			 }
		 }
		 InputStream is = null;
		 BufferedInputStream bis = null;
		 Reader instream = null;
		 log(""loading "" + src + "" into property "" + property, Project.MSG_VERBOSE);
		 try {
			 final long len = src.getSize();
			 log(""resource size = "" + (len != Resource.UNKNOWN_SIZE ? String.valueOf(len) : ""unknown""), Project.MSG_DEBUG);
			 final int size = (int) len;
			 is = src.getInputStream();
			 bis = new BufferedInputStream(is);
			 if (encoding == null) {
				 instream = new InputStreamReader(bis);
			 }
			 else {
				 instream = new InputStreamReader(bis, encoding);
			 }
			 String text = """";
			 if (size != 0) {
				 ChainReaderHelper crh = new ChainReaderHelper();
				 if (len != Resource.UNKNOWN_SIZE) {
					 crh.setBufferSize(size);
				 }
				 crh.setPrimaryReader(instream);
				 crh.setFilterChains(filterChains);
				 crh.setProject(getProject());
				 instream = crh.getAssembledReader();
				 text = crh.readFully(instream);
			 }
			 else {
				 log(""Do not set property "" + property + "" as its length is 0."");
			 }
			 if (text != null) {
				 if (text.length() > 0) {
					 getProject().setNewProperty(property, text);
					 log(""loaded "" + text.length() + "" characters"", Project.MSG_VERBOSE);
					 log(property + "" := "" + text, Project.MSG_DEBUG);
				 }
			 }
		 }
		 catch (final IOException ioe) {
			 final String message = ""Unable to load resource: "" + ioe.toString();
			 if (failOnError) {
				 throw new BuildException(message, ioe, getLocation());
			 }
			 else {
				 log(message, quiet ? Project.MSG_VERBOSE : Project.MSG_ERR);
			 }
		 }
		 catch (final BuildException be) {
			 if (failOnError) {
				 throw be;
			 }
			 else {
				 log(be.getMessage(), quiet ? Project.MSG_VERBOSE : Project.MSG_ERR);
			 }
		 }
		 finally {
			 FileUtils.close(is);
		 }
	 }
	 public final void addFilterChain(FilterChain filter) {
		 filterChains.addElement(filter);
	 }
	 public void addConfigured(ResourceCollection a) {
		 if (a.size() != 1) {
			 throw new BuildException(""only single argument resource collections"" + "" are supported"");
		 }
		 src = (Resource) a.iterator().next();
	 }
}",0,0,0,0
"public class ObserveUtil {
	 public static final String CTX_ENDPOINT = ""leshan-endpoint"";
	 public static final String CTX_REGID = ""leshan-regId"";
	 public static final String CTX_LWM2M_PATH = ""leshan-path"";
	 public static Observation createLwM2mObservation(Request request) {
		 String regId = null;
		 String lwm2mPath = null;
		 Map<String, String> context = null;
		 for (Entry<String, String> ctx : request.getUserContext().entrySet()) {
			 switch (ctx.getKey()) {
				 case CTX_REGID: regId = ctx.getValue();
				 break;
				 case CTX_LWM2M_PATH: lwm2mPath = ctx.getValue();
				 break;
				 case CTX_ENDPOINT: break;
				 default: if (context == null) {
					 context = new HashMap<>();
				 }
				 context.put(ctx.getKey(), ctx.getValue());
			 }
		 }
		 ContentFormat contentFormat = null;
		 if (request.getOptions().hasAccept()) {
			 contentFormat = ContentFormat.fromCode(request.getOptions().getAccept());
		 }
		 return new Observation(request.getToken().getBytes(), regId, new LwM2mPath(lwm2mPath), contentFormat, context);
	 }
	 public static Map<String, String> createCoapObserveRequestContext(String endpoint, String registrationId, ObserveRequest request) {
		 Map<String, String> context = new HashMap<>();
		 context.put(CTX_ENDPOINT, endpoint);
		 context.put(CTX_REGID, registrationId);
		 context.put(CTX_LWM2M_PATH, request.getPath().toString());
		 for (Entry<String, String> ctx : request.getContext().entrySet()) {
			 context.put(ctx.getKey(), ctx.getValue());
		 }
		 return context;
	 }
	 public static String extractRegistrationId(org.eclipse.californium.core.observe.Observation observation) {
		 return observation.getRequest().getUserContext().get(CTX_REGID);
	 }
	 public static String extractLwm2mPath(org.eclipse.californium.core.observe.Observation observation) {
		 return observation.getRequest().getUserContext().get(CTX_LWM2M_PATH);
	 }
	 public static String extractEndpoint(org.eclipse.californium.core.observe.Observation observation) {
		 return observation.getRequest().getUserContext().get(CTX_ENDPOINT);
	 }
	 public static String validateCoapObservation(org.eclipse.californium.core.observe.Observation observation) {
		 if (!observation.getRequest().getUserContext().containsKey(CTX_REGID)) throw new IllegalStateException(""missing registrationId info in the request context"");
		 if (!observation.getRequest().getUserContext().containsKey(CTX_LWM2M_PATH)) throw new IllegalStateException(""missing lwm2m path info in the request context"");
		 String endpoint = observation.getRequest().getUserContext().get(CTX_ENDPOINT);
		 if (endpoint == null) throw new IllegalStateException(""missing endpoint info in the request context"");
		 return endpoint;
	 }
}",1,0,0,0
"public class JdbVariable implements Variable {
	 private final LocalVariable jdiVariable;
	 private final SimpleValue value;
	 public JdbVariable(StackFrame jdiStackFrame, LocalVariable jdiVariable) {
		 Value jdiValue = jdiStackFrame.getValue(jdiVariable);
		 this.jdiVariable = jdiVariable;
		 this.value = jdiValue == null ? new JdbNullValue() : new JdbValue(jdiValue, getVariablePath());
	 }
	 public JdbVariable(SimpleValue value, LocalVariable jdiVariable) {
		 this.jdiVariable = jdiVariable;
		 this.value = value;
	 }
	 public String getName() {
		 return jdiVariable.name();
	 }
	 public boolean isPrimitive() {
		 return JdbType.isPrimitive(jdiVariable.signature());
	 }
	 public SimpleValue getValue() {
		 return value;
	 }
	 public String getType() {
		 return jdiVariable.typeName();
	 }
	 public VariablePath getVariablePath() {
		 return new VariablePathImpl(getName());
	 }
}",0,1,0,0
"static class State {
	 private EnabledState enabled = EnabledState.UNKNOWN;
	 public JavaFormatterOptions.Style style = JavaFormatterOptions.Style.GOOGLE;
	 public void setEnabled( String enabledStr) {
		 if (enabledStr == null) {
			 enabled = EnabledState.UNKNOWN;
		 }
		 else if (Boolean.valueOf(enabledStr)) {
			 enabled = EnabledState.ENABLED;
		 }
		 else {
			 enabled = EnabledState.DISABLED;
		 }
	 }
	 public String getEnabled() {
		 switch (enabled) {
			 case ENABLED: return ""true"";
			 case DISABLED: return ""false"";
			 default: return null;
		 }
	 }
 }",0,1,0,0
"public class DefaultTypeDeclaration extends AbstractDeclaration implements TypeDeclaration {
	 private final Element m_componentMetadata;
	 private final String m_componentName;
	 private final String m_componentVersion;
	 private final String m_extension;
	 private boolean visible = true;
	 public DefaultTypeDeclaration(BundleContext bundleContext, Element componentMetadata) {
		 super(bundleContext, TypeDeclaration.class);
		 m_componentMetadata = componentMetadata;
		 visible = initVisible();
		 m_componentName = initComponentName();
		 m_componentVersion = initComponentVersion(bundleContext);
		 m_extension = initExtension();
	 }
	 private String initExtension() {
		 if (m_componentMetadata.getNameSpace() == null) {
			 return m_componentMetadata.getName();
		 }
		 return m_componentMetadata.getNameSpace() + "":"" + m_componentMetadata.getName();
	 }
	 private String initComponentVersion(BundleContext bundleContext) {
		 String version = m_componentMetadata.getAttribute(""version"");
		 if (version != null) {
			 if (""bundle"".equalsIgnoreCase(version)) {
				 return bundleContext.getBundle().getHeaders().get(Constants.BUNDLE_VERSION);
			 }
		 }
		 return version;
	 }
	 private String initComponentName() {
		 String name = m_componentMetadata.getAttribute(""name"");
		 if (name == null) {
			 name = m_componentMetadata.getAttribute(""classname"");
		 }
		 return name;
	 }
	 private boolean initVisible() {
		 String publicAttribute = m_componentMetadata.getAttribute(""public"");
		 return (publicAttribute == null) || !publicAttribute.equalsIgnoreCase(""false"");
	 }
	 public String getComponentName() {
		 return m_componentName;
	 }
	 public String getComponentVersion() {
		 return m_componentVersion;
	 }
	 public String getExtension() {
		 return m_extension;
	 }
	 public Element getComponentMetadata() {
		 return m_componentMetadata;
	 }
	 public boolean isPublic() {
		 return visible;
	 }
}",1,1,0,0
"public ZipShort getHeaderId() {
	 return HEADER_ID;
 }",0,0,0,0
"public interface GroupForumPermissionList {
	 java.util.List getGroupForumPermission();
}",0,1,0,0
"public class GroupByMergingQueryRunnerV2 implements QueryRunner<Row>{
	 private static final Logger log = new Logger(GroupByMergingQueryRunnerV2.class);
	 private static final String CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION = ""mergeRunnersUsingChainedExecution"";
	 private final GroupByQueryConfig config;
	 private final Iterable<QueryRunner<Row>> queryables;
	 private final ListeningExecutorService exec;
	 private final QueryWatcher queryWatcher;
	 private final int concurrencyHint;
	 private final BlockingPool<ByteBuffer> mergeBufferPool;
	 private final ObjectMapper spillMapper;
	 private final String processingTmpDir;
	 private final int mergeBufferSize;
	 public GroupByMergingQueryRunnerV2( GroupByQueryConfig config, ExecutorService exec, QueryWatcher queryWatcher, Iterable<QueryRunner<Row>> queryables, int concurrencyHint, BlockingPool<ByteBuffer> mergeBufferPool, int mergeBufferSize, ObjectMapper spillMapper, String processingTmpDir ) {
		 this.config = config;
		 this.exec = MoreExecutors.listeningDecorator(exec);
		 this.queryWatcher = queryWatcher;
		 this.queryables = Iterables.unmodifiableIterable(Iterables.filter(queryables, Predicates.notNull()));
		 this.concurrencyHint = concurrencyHint;
		 this.mergeBufferPool = mergeBufferPool;
		 this.spillMapper = spillMapper;
		 this.processingTmpDir = processingTmpDir;
		 this.mergeBufferSize = mergeBufferSize;
	 }
	 public Sequence<Row> run(final QueryPlus<Row> queryPlus, final Map<String, Object> responseContext) {
		 final GroupByQuery query = (GroupByQuery) queryPlus.getQuery();
		 final GroupByQueryConfig querySpecificConfig = config.withOverrides(query);
		 final boolean forceChainedExecution = query.getContextBoolean( CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION, false );
		 final QueryPlus<Row> queryPlusForRunners = queryPlus .withQuery( query.withOverriddenContext(ImmutableMap.of(CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION, true)) ) .withoutThreadUnsafeState();
		 if (QueryContexts.isBySegment(query) || forceChainedExecution) {
			 ChainedExecutionQueryRunner<Row> runner = new ChainedExecutionQueryRunner<>(exec, queryWatcher, queryables);
			 return runner.run(queryPlusForRunners, responseContext);
		 }
		 final boolean isSingleThreaded = querySpecificConfig.isSingleThreaded();
		 final AggregatorFactory[] combiningAggregatorFactories = new AggregatorFactory[query.getAggregatorSpecs().size()];
		 for (int i = 0;
		 i < query.getAggregatorSpecs().size();
		 i++) {
			 combiningAggregatorFactories[i] = query.getAggregatorSpecs().get(i).getCombiningFactory();
		 }
		 final File temporaryStorageDirectory = new File( processingTmpDir, StringUtils.format(""druid-groupBy-%s_%s"", UUID.randomUUID(), query.getId()) );
		 final int priority = QueryContexts.getPriority(query);
		 final long queryTimeout = QueryContexts.getTimeout(query);
		 final boolean hasTimeout = QueryContexts.hasTimeout(query);
		 final long timeoutAt = System.currentTimeMillis() + queryTimeout;
		 return new BaseSequence<>( new BaseSequence.IteratorMaker<Row, CloseableGrouperIterator<RowBasedKey, Row>>() {
			 public CloseableGrouperIterator<RowBasedKey, Row> make() {
				 final List<ReferenceCountingResourceHolder> resources = new ArrayList<>();
				 try {
					 final LimitedTemporaryStorage temporaryStorage = new LimitedTemporaryStorage( temporaryStorageDirectory, querySpecificConfig.getMaxOnDiskStorage() );
					 final ReferenceCountingResourceHolder<LimitedTemporaryStorage> temporaryStorageHolder = ReferenceCountingResourceHolder.fromCloseable(temporaryStorage);
					 resources.add(temporaryStorageHolder);
					 final int numMergeBuffers = querySpecificConfig.getNumParallelCombineThreads() > 1 ? 2 : 1;
					 final List<ReferenceCountingResourceHolder<ByteBuffer>> mergeBufferHolders = getMergeBuffersHolder( numMergeBuffers, hasTimeout, timeoutAt );
					 resources.addAll(mergeBufferHolders);
					 final ReferenceCountingResourceHolder<ByteBuffer> mergeBufferHolder = mergeBufferHolders.get(0);
					 final ReferenceCountingResourceHolder<ByteBuffer> combineBufferHolder = numMergeBuffers == 2 ? mergeBufferHolders.get(1) : null;
					 Pair<Grouper<RowBasedKey>, Accumulator<AggregateResult, Row>> pair = RowBasedGrouperHelper.createGrouperAccumulatorPair( query, false, null, config, Suppliers.ofInstance(mergeBufferHolder.get()), combineBufferHolder, concurrencyHint, temporaryStorage, spillMapper, combiningAggregatorFactories, exec, priority, hasTimeout, timeoutAt, mergeBufferSize );
					 final Grouper<RowBasedKey> grouper = pair.lhs;
					 final Accumulator<AggregateResult, Row> accumulator = pair.rhs;
					 grouper.init();
					 final ReferenceCountingResourceHolder<Grouper<RowBasedKey>> grouperHolder = ReferenceCountingResourceHolder.fromCloseable(grouper);
					 resources.add(grouperHolder);
					 ListenableFuture<List<AggregateResult>> futures = Futures.allAsList( Lists.newArrayList( Iterables.transform( queryables, new Function<QueryRunner<Row>, ListenableFuture<AggregateResult>>() {
						 public ListenableFuture<AggregateResult> apply(final QueryRunner<Row> input) {
							 if (input == null) {
								 throw new ISE( ""Null queryRunner! Looks to be some segment unmapping action happening"" );
							 }
							 ListenableFuture<AggregateResult> future = exec.submit( new AbstractPrioritizedCallable<AggregateResult>(priority) {
								 public AggregateResult call() {
									 try ( Releaser bufferReleaser = mergeBufferHolder.increment();
									 Releaser grouperReleaser = grouperHolder.increment() ) {
										 final AggregateResult retVal = input.run(queryPlusForRunners, responseContext) .accumulate( AggregateResult.ok(), accumulator );
										 return retVal;
									 }
									 catch (QueryInterruptedException e) {
										 throw e;
									 }
									 catch (Exception e) {
										 log.error(e, ""Exception with one of the sequences!"");
										 throw new RuntimeException(e);
									 }
								 }
							 }
							 );
							 if (isSingleThreaded) {
								 waitForFutureCompletion( query, Futures.allAsList(ImmutableList.of(future)), hasTimeout, timeoutAt - System.currentTimeMillis() );
							 }
							 return future;
						 }
					 }
					 ) ) );
					 if (!isSingleThreaded) {
						 waitForFutureCompletion(query, futures, hasTimeout, timeoutAt - System.currentTimeMillis());
					 }
					 return RowBasedGrouperHelper.makeGrouperIterator( grouper, query, new Closeable() {
						 public void close() {
							 for (Closeable closeable : Lists.reverse(resources)) {
								 CloseQuietly.close(closeable);
							 }
						 }
					 }
					 );
				 }
				 catch (Throwable e) {
					 for (Closeable closeable : Lists.reverse(resources)) {
						 CloseQuietly.close(closeable);
					 }
					 throw e;
				 }
			 }
			 public void cleanup(CloseableGrouperIterator<RowBasedKey, Row> iterFromMake) {
				 iterFromMake.close();
			 }
		 }
		 );
	 }
	 private List<ReferenceCountingResourceHolder<ByteBuffer>> getMergeBuffersHolder( int numBuffers, boolean hasTimeout, long timeoutAt ) {
		 try {
			 if (numBuffers > mergeBufferPool.maxSize()) {
				 throw new ResourceLimitExceededException( ""Query needs "" + numBuffers + "" merge buffers, but only "" + mergeBufferPool.maxSize() + "" merge buffers were configured. "" + ""Try raising druid.processing.numMergeBuffers."" );
			 }
			 final List<ReferenceCountingResourceHolder<ByteBuffer>> mergeBufferHolder;
			 if (hasTimeout) {
				 final long timeout = timeoutAt - System.currentTimeMillis();
				 if (timeout <= 0) {
					 throw new TimeoutException();
				 }
				 if ((mergeBufferHolder = mergeBufferPool.takeBatch(numBuffers, timeout)).isEmpty()) {
					 throw new TimeoutException(""Cannot acquire enough merge buffers"");
				 }
			 }
			 else {
				 mergeBufferHolder = mergeBufferPool.takeBatch(numBuffers);
			 }
			 return mergeBufferHolder;
		 }
		 catch (Exception e) {
			 throw new QueryInterruptedException(e);
		 }
	 }
	 private void waitForFutureCompletion( GroupByQuery query, ListenableFuture<List<AggregateResult>> future, boolean hasTimeout, long timeout ) {
		 try {
			 if (queryWatcher != null) {
				 queryWatcher.registerQuery(query, future);
			 }
			 if (hasTimeout && timeout <= 0) {
				 throw new TimeoutException();
			 }
			 final List<AggregateResult> results = hasTimeout ? future.get(timeout, TimeUnit.MILLISECONDS) : future.get();
			 for (AggregateResult result : results) {
				 if (!result.isOk()) {
					 future.cancel(true);
					 throw new ResourceLimitExceededException(result.getReason());
				 }
			 }
		 }
		 catch (InterruptedException e) {
			 log.warn(e, ""Query interrupted, cancelling pending results, query id [%s]"", query.getId());
			 future.cancel(true);
			 throw new QueryInterruptedException(e);
		 }
		 catch (CancellationException e) {
			 throw new QueryInterruptedException(e);
		 }
		 catch (TimeoutException e) {
			 log.info(""Query timeout, cancelling pending results for query id [%s]"", query.getId());
			 future.cancel(true);
			 throw new QueryInterruptedException(e);
		 }
		 catch (ExecutionException e) {
			 throw new RuntimeException(e);
		 }
	 }
}",1,0,0,0
"class AppInfoCollector {
	 private final DiagOozieClient client;
	 private final OozieLauncherLogFetcher oozieLauncherLogFetcher;
	 AppInfoCollector(final Configuration hadoopConfig, final DiagOozieClient client) {
		 this.client = client;
		 oozieLauncherLogFetcher = new OozieLauncherLogFetcher(hadoopConfig);
	 }
	 private void storeWorkflowJobDetails(final File outputDir, final String jobId, int maxChildActions) {
		 if (jobId == null || !isWorkflow(jobId)) {
			 return;
		 }
		 try {
			 System.out.print(""Getting Details for "" + jobId + ""..."");
			 final File workflowOutputDir = new File(outputDir, jobId);
			 if (!createOutputDirectory(workflowOutputDir)) {
				 return;
			 }
			 final File resolvedActionsDir = new File(workflowOutputDir, ""resolved-actions"");
			 if (!createOutputDirectory(resolvedActionsDir)) {
				 System.out.println(""Workflow details already stored."");
				 return;
			 }
			 final WorkflowJob job = client.getJobInfo(jobId);
			 try (DiagBundleEntryWriter diagBundleEntryWriter = new DiagBundleEntryWriter(workflowOutputDir,""info.txt"")) {
				 persistWorkflowJobInfo(maxChildActions, resolvedActionsDir, job, diagBundleEntryWriter);
			 }
			 storeCommonDetails(workflowOutputDir, jobId, ""workflow"", job.getConf());
			 System.out.println(""Done"");
		 }
		 catch (IOException | OozieClientException e) {
			 System.err.printf(""Exception occurred during the retrieval of workflow information: %s%n"", e.getMessage());
		 }
	 }
	 private void persistWorkflowJobInfo(int maxChildActions, final File resolvedActionsDir, final WorkflowJob job, final DiagBundleEntryWriter bundleEntryWriter) throws IOException {
		 bundleEntryWriter.writeString(""WORKFLOW\n"") .writeString(""--------\n"") .writeStringValue(""Workflow Id : "", job.getId()) .writeStringValue(""Name : "", job.getAppName()) .writeStringValue(""App Path : "", job.getAppPath()) .writeStringValue(""User : "", job.getUser()) .writeStringValue(""ACL : "", job.getAcl()) .writeStringValue(""Status : "", job.getStatus().toString()) .writeStringValue(""Console URL : "", job.getConsoleUrl()) .writeStringValue(""External Id : "", job.getExternalId()) .writeStringValue(""Parent Id : "", job.getParentId()) .writeDateValue(""Created Time : "", job.getCreatedTime()) .writeDateValue(""End Time : "", job.getEndTime()) .writeDateValue(""Last Modified Time : "", job.getLastModifiedTime()) .writeDateValue(""Start Time : "", job.getStartTime()) .writeIntValue(""Run : "", job.getRun()) .writeIntValue(""Action Count : "", job.getActions().size()) .writeNewLine() .writeString(""ACTIONS\n"") .writeString(""------\n"") .flush();
		 final List<WorkflowAction> workflowActions = job.getActions();
		 for (int actionCount = 0;
		 actionCount != workflowActions.size() && actionCount < maxChildActions;
		 ++actionCount) {
			 final WorkflowAction action = workflowActions.get(actionCount);
			 bundleEntryWriter.writeStringValue(""Action Id : "", action.getId()) .writeStringValue(""Name : "", action.getName()) .writeStringValue(""Type : "", action.getType()) .writeStringValue(""Status : "", action.getStatus().toString()) .writeStringValue(""Transition : "", action.getTransition()) .writeDateValue(""Start Time : "", action.getStartTime()) .writeDateValue(""End Time : "", action.getEndTime()) .writeStringValue(""Error Code : "", action.getErrorCode()) .writeStringValue(""Error Message : "", action.getErrorMessage()) .writeStringValue(""Console URL : "", action.getConsoleUrl()) .writeStringValue(""Tracker URI : "", action.getTrackerUri()) .writeStringValue(""External Child Ids : "", action.getExternalChildIDs()) .writeStringValue(""External Id : "", action.getExternalId()) .writeStringValue(""External Status : "", action.getExternalStatus()) .writeStringValue(""Data : "", action.getData()) .writeStringValue(""Stats : "", action.getStats()) .writeStringValue(""Credentials : "", action.getCred()) .writeIntValue(""Retries : "", action.getRetries()) .writeIntValue(""User Retry Int : "", action.getUserRetryInterval()) .writeIntValue(""User Retry Count : "", action.getUserRetryCount()) .writeIntValue(""User Retry Max : "", action.getUserRetryMax()) .writeNewLine() .flush();
			 final String actionType = action.getType();
			 persistResolvedActionDefinition(action, resolvedActionsDir);
			 if (!isControlNode(actionType)) {
				 storeOozieLauncherLog(resolvedActionsDir, action, job.getUser());
			 }
		 }
	 }
	 private boolean isControlNode(final String actionType) {
		 return isNonDecisionControlNode(actionType) || isDecisionNode(actionType);
	 }
	 private boolean isDecisionNode(final String actionType) {
		 return actionType.contains(""switch"");
	 }
	 private boolean isNonDecisionControlNode(final String actionType) {
		 return actionType.contains("":"");
	 }
	 private void persistResolvedActionDefinition(final WorkflowAction action, final File resolvedActionsDir) throws IOException {
		 persistWorkflowDefinition(resolvedActionsDir, action.getName(), action.getConf());
	 }
	 private void storeOozieLauncherLog(final File outputDir, final WorkflowAction action, final String user) {
		 try (PrintStream fw = new PrintStream(new File(outputDir, ""launcher_"" + action.getName() + "".log""), StandardCharsets.UTF_8.toString())) {
			 final ApplicationId appId = ConverterUtils.toApplicationId(action.getExternalId());
			 oozieLauncherLogFetcher.dumpAllContainersLogs(appId, user, fw);
		 }
		 catch (IOException e) {
			 System.err.printf(""Exception occurred during the retrieval of Oozie launcher logs for workflow(s): %s%n"", e.getMessage());
		 }
	 }
	 private void getCoordJob(final File outputDir, final String jobId, int maxChildActions) {
		 if (jobId == null || !isCoordinator(jobId)) {
			 return;
		 }
		 try {
			 System.out.print(""Getting Details for "" + jobId + ""..."");
			 final File coordOutputDir = new File(outputDir, jobId);
			 if (!createOutputDirectory(coordOutputDir)) {
				 return;
			 }
			 final CoordinatorJob job = client.getCoordJobInfo(jobId);
			 try (DiagBundleEntryWriter bundleEntryWriter = new DiagBundleEntryWriter(coordOutputDir, ""info.txt"")) {
				 persistCoordinatorJobInfo(maxChildActions, job, bundleEntryWriter);
			 }
			 storeCommonDetails(coordOutputDir, jobId, ""coordinator"", job.getConf());
			 System.out.println(""Done"");
			 final List<CoordinatorAction> coordinatorActions = job.getActions();
			 for (int i = 0;
			 i != coordinatorActions.size() && i < maxChildActions;
			 ++i) {
				 storeWorkflowJobDetails(outputDir, coordinatorActions.get(i).getExternalId(), maxChildActions);
			 }
		 }
		 catch (IOException | OozieClientException e) {
			 System.err.printf(String.format(""Exception occurred during the retrieval of coordinator information:%s%n"", e.getMessage()));
		 }
	 }
	 private void persistCoordinatorJobInfo(int maxChildActions, final CoordinatorJob job, final DiagBundleEntryWriter bundleEntryWriter) throws IOException {
		 bundleEntryWriter.writeString(""COORDINATOR\n"") .writeString(""-----------\n"") .writeStringValue(""Coordinator Id : "", job.getId()) .writeStringValue(""Name : "", job.getAppName()) .writeStringValue(""App Path : "", job.getAppPath()) .writeStringValue(""User : "", job.getUser()) .writeStringValue(""ACL : "", job.getAcl()) .writeStringValue(""Status : "", job.getStatus().toString()) .writeStringValue(""Console URL : "", job.getConsoleUrl()) .writeStringValue(""External Id : "", job.getExternalId()) .writeStringValue(""Bundle Id : "", job.getBundleId()) .writeStringValue(""Frequency : "", job.getFrequency()) .writeStringValue(""Time Unit : "", job.getTimeUnit().toString()) .writeDateValue(""Start Time : "", job.getStartTime()) .writeDateValue(""End Time : "", job.getEndTime()) .writeDateValue(""Last Action Time : "", job.getLastActionTime()) .writeDateValue(""Next Materialized Time : "", job.getNextMaterializedTime()) .writeDateValue(""Pause Time : "", job.getPauseTime()) .writeStringValue(""Timezone : "", job.getTimeZone()) .writeIntValue(""Concurrency : "", job.getConcurrency()) .writeIntValue(""Timeout : "", job.getTimeout()) .writeStringValue(""Execution Order : "", job.getExecutionOrder().toString()) .writeIntValue(""Action Count : "", job.getActions().size()) .writeNewLine() .writeString(""ACTIONS\n"") .writeString(""------\n"") .flush();
		 final List<CoordinatorAction> coordinatorActions = job.getActions();
		 for (int i = 0;
		 i < maxChildActions && i != coordinatorActions.size();
		 ++i) {
			 final CoordinatorAction action = coordinatorActions.get(i);
			 bundleEntryWriter.writeStringValue(""Action Id : "", action.getId()) .writeIntValue(""Action Number : "", action.getActionNumber()) .writeStringValue(""Job Id : "", action.getJobId()) .writeStringValue(""Status : "", action.getStatus().toString()) .writeStringValue(""External Id : "", action.getExternalId()) .writeStringValue(""External Status : "", action.getExternalStatus()) .writeStringValue(""Console URL : "", action.getConsoleUrl()) .writeStringValue(""Tracker URI : "", action.getTrackerUri()) .writeDateValue(""Created Time : "", action.getCreatedTime()) .writeDateValue(""Nominal Time : "", action.getNominalTime()) .writeDateValue(""Last Modified Time : "", action.getLastModifiedTime()) .writeStringValue(""Error Code : "", action.getErrorCode()) .writeStringValue(""Error Message : "", action.getErrorMessage()) .writeStringValue(""Missing Dependencies : "", action.getMissingDependencies()) .writeStringValue(""Push Missing Dependencies : "", action.getPushMissingDependencies()) .writeNewLine() .flush();
		 }
	 }
	 private void getBundleJob(final File outputDir, final String jobId, int maxChildActions) {
		 if (jobId == null || !isBundle(jobId)) {
			 return;
		 }
		 try {
			 System.out.print(""Getting Details for "" + jobId + ""..."");
			 final File bundleOutputDir = new File(outputDir, jobId);
			 if (!createOutputDirectory(bundleOutputDir)) {
				 return;
			 }
			 final BundleJob job = client.getBundleJobInfo(jobId);
			 try (DiagBundleEntryWriter bundleEntryWriter = new DiagBundleEntryWriter(bundleOutputDir, ""info.txt"")) {
				 persistBundleJobInfo(job, bundleEntryWriter);
			 }
			 storeCommonDetails(bundleOutputDir, jobId, ""bundle"", job.getConf());
			 System.out.println(""Done"");
			 for (CoordinatorJob coordJob : job.getCoordinators()) {
				 getCoordJob(outputDir, coordJob.getId(), maxChildActions);
			 }
		 }
		 catch (IOException | OozieClientException e) {
			 System.err.printf(String.format(""Exception occurred during the retrieval of bundle information: %s%n"", e.getMessage()));
		 }
	 }
	 private boolean createOutputDirectory(final File outputDir) throws IOException {
		 if (outputDir.isDirectory()) {
			 System.out.println(""(Already) Done"");
			 return false;
		 }
		 if (!outputDir.mkdirs()) {
			 throw new IOException(""Could not create output directory: "" + outputDir.getAbsolutePath());
		 }
		 return true;
	 }
	 private void persistBundleJobInfo(final BundleJob job, final DiagBundleEntryWriter bundleEntryWriter) throws IOException {
		 bundleEntryWriter.writeString(""BUNDLE\n"") .writeString(""-----------\n"") .writeStringValue(""Bundle Id : "", job.getId()) .writeStringValue(""Name : "", job.getAppName()) .writeStringValue(""App Path : "", job.getAppPath()) .writeStringValue(""User : "", job.getUser()) .writeStringValue(""Status : "", job.getStatus().toString()) .writeDateValue(""Created Time : "", job.getCreatedTime()) .writeDateValue(""Start Time : "", job.getStartTime()) .writeDateValue(""End Time : "", job.getEndTime()) .writeDateValue(""KickoffTime : "", job.getKickoffTime()) .writeDateValue(""Pause Time : "", job.getPauseTime()) .writeIntValue(""Timeout : "", job.getTimeout()) .writeStringValue(""Console URL : "", job.getConsoleUrl()) .writeStringValue( ""ACL : "", job.getAcl()) .flush();
	 }
	 private void storeCommonDetails(final File outputDir, final String jobId, final String definitionName, final String jobPropsConfStr) {
		 try {
			 final String definition = client.getJobDefinition(jobId);
			 if (definition != null) {
				 persistWorkflowDefinition(outputDir, definitionName, definition);
			 }
			 if (jobPropsConfStr != null) {
				 persistJobProperties(outputDir, jobPropsConfStr);
			 }
			 persistJobLog(outputDir, jobId);
		 }
		 catch (OozieClientException | IOException e) {
			 System.err.printf(String.format(""Exception occurred during the retrieval of common job details: %s%n"", e.getMessage()));
		 }
	 }
	 private void persistJobLog(final File outputDir, final String jobId) throws FileNotFoundException, UnsupportedEncodingException, OozieClientException {
		 try (PrintStream ps = new PrintStream(new File(outputDir, ""log.txt""), StandardCharsets.UTF_8.toString())) {
			 client.getJobLog(jobId, null, null, null, ps);
		 }
	 }
	 private void persistJobProperties(final File outputDir, final String jobPropsConfStr) throws IOException {
		 final StringReader sr = new StringReader(jobPropsConfStr);
		 final XConfiguration jobPropsConf = new XConfiguration(sr);
		 final Properties jobProps = jobPropsConf.toProperties();
		 try (OutputStream outputStream = new FileOutputStream(new File(outputDir, ""job.properties""))) {
			 jobProps.store(outputStream, """");
		 }
	 }
	 private void persistWorkflowDefinition(final File outputDir, final String definitionName, String definition) throws IOException {
		 try (DiagBundleEntryWriter bundleEntryWriter = new DiagBundleEntryWriter(outputDir, definitionName + "".xml"")) {
			 bundleEntryWriter.writeString(definition);
		 }
	 }
	 void storeLastWorkflows(final File outputDir, int numWorkflows, int maxChildActions) {
		 if (numWorkflows == 0) {
			 return;
		 }
		 try {
			 final List<WorkflowJob> jobs = client.getJobsInfo(null, 0, numWorkflows);
			 for (WorkflowJob job : jobs) {
				 storeWorkflowJobDetails(outputDir, job.getId(), maxChildActions);
			 }
		 }
		 catch (OozieClientException e) {
			 System.err.printf(""Exception occurred during the retrieval of information on the last %d workflow(s): %s.%n"", numWorkflows, e.getMessage());
		 }
	 }
	 void storeLastCoordinators(final File outputDir, int numCoordinators, int maxChildActions) {
		 if (numCoordinators == 0) {
			 return;
		 }
		 try {
			 final List<CoordinatorJob> jobs = client.getCoordJobsInfo(null, 0, numCoordinators);
			 for (CoordinatorJob job : jobs) {
				 getCoordJob(outputDir, job.getId(), maxChildActions);
			 }
		 }
		 catch (OozieClientException e) {
			 System.err.printf(""Exception occurred during the retrieval of information on the last %d coordinator(s): %s.%n"", numCoordinators, e.getMessage());
		 }
	 }
	 void storeLastBundles(final File outputDir, int numBundles, int maxChildActions) {
		 if (numBundles == 0) {
			 return;
		 }
		 try {
			 final List<BundleJob> jobs = client.getBundleJobsInfo(null, 0, numBundles);
			 for (BundleJob job : jobs) {
				 getBundleJob(outputDir, job.getId(), maxChildActions);
			 }
		 }
		 catch (OozieClientException e) {
			 System.err.printf(""Exception occurred during the retrieval of information on the last %d bundle(s): %s.%n"", numBundles, e.getMessage());
		 }
	 }
	 void getSpecificJobs(final File outputDir, final String[] jobIds, int maxChildActions) {
		 if (jobIds == null) {
			 return;
		 }
		 for (String jobId : jobIds) {
			 if (isWorkflow(jobId)) {
				 storeWorkflowJobDetails(outputDir, jobId, maxChildActions);
			 }
			 else if (isCoordinator(jobId)) {
				 getCoordJob(outputDir, jobId, maxChildActions);
			 }
			 else if (isBundle(jobId)) {
				 getBundleJob(outputDir, jobId, maxChildActions);
			 }
		 }
	 }
	 private boolean isBundle(final String jobId) {
		 return jobId.endsWith(""-B"");
	 }
	 private boolean isCoordinator(final String jobId) {
		 return jobId.endsWith(""-C"");
	 }
	 private boolean isWorkflow(final String jobId) {
		 return jobId.endsWith(""-W"");
	 }
}",1,0,0,0
"protected void refreshInternal(Collection objs, OpCallbacks call) {
	 if (objs == null || objs.isEmpty()) return;
	 List<Exception> exceps = null;
	 try {
		 Collection<OpenJPAStateManager> load = null;
		 StateManagerImpl sm;
		 Object obj;
		 for (Iterator<T> itr = objs.iterator();
		 itr.hasNext();
		) {
			 obj = itr.next();
			 if (obj == null) continue;
			 try {
				 sm = getStateManagerImpl(obj, true);
				 if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call) & OpCallbacks.ACT_RUN) == 0) continue;
				 if (sm != null) {
					 if (sm.isDetached()) throw newDetachedException(obj, ""refresh"");
					 else if (sm.beforeRefresh(true)) {
						 if (load == null) load = new ArrayList<>(objs.size());
						 load.add(sm);
					 }
					 int level = _fc.getReadLockLevel();
					 int timeout = _fc.getLockTimeout();
					 _lm.refreshLock(sm, level, timeout, null);
					 sm.readLocked(level, level);
				 }
				 else if (assertPersistenceCapable(obj).pcIsDetached() == Boolean.TRUE) throw newDetachedException(obj, ""refresh"");
			 }
			 catch (OpenJPAException ke) {
				 exceps = add(exceps, ke);
			 }
		 }
		 if (load != null) {
			 Collection<Object> failed = _store.loadAll(load, null, StoreManager.FORCE_LOAD_REFRESH, _fc, null);
			 if (failed != null && !failed.isEmpty()) exceps = add(exceps, newObjectNotFoundException(failed));
			 for (Iterator<OpenJPAStateManager> itr = load.iterator();
			 itr.hasNext();
			) {
				 sm = (StateManagerImpl) itr.next();
				 if (failed != null && failed.contains(sm.getId())) continue;
				 try {
					 sm.afterRefresh();
					 sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null, false);
				 }
				 catch (OpenJPAException ke) {
					 exceps = add(exceps, ke);
				 }
			 }
		 }
		 for (Iterator<T> itr = objs.iterator();
		 itr.hasNext();
		) {
			 try {
				 sm = getStateManagerImpl(itr.next(), true);
				 if (sm != null && !sm.isDetached()) fireLifecycleEvent(sm.getManagedInstance(), null, sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);
			 }
			 catch (OpenJPAException ke) {
				 exceps = add(exceps, ke);
			 }
		 }
	 }
	 catch (OpenJPAException ke) {
		 throw ke;
	 }
	 catch (RuntimeException re) {
		 throw new GeneralException(re);
	 }
	 throwNestedExceptions(exceps, false);
 }",0,0,1,0
"public final void execute() throws BuildException {
	 if (cvsRoot == null) {
		 throw new BuildException(""cvsroot is required"");
	 }
	 if (password == null) {
		 throw new BuildException(""password is required"");
	 }
	 log(""cvsRoot: "" + cvsRoot, Project.MSG_DEBUG);
	 log(""password: "" + password, Project.MSG_DEBUG);
	 log(""passFile: "" + passFile, Project.MSG_DEBUG);
	 BufferedReader reader = null;
	 PrintWriter writer = null;
	 try {
		 StringBuffer buf = new StringBuffer();
		 if (passFile.exists()) {
			 reader = new BufferedReader(new FileReader(passFile));
			 String line = null;
			 while ((line = reader.readLine()) != null) {
				 if (!line.startsWith(cvsRoot)) {
					 buf.append(line).append(StringUtils.LINE_SEP);
				 }
			 }
		 }
		 String pwdfile = buf.toString() + cvsRoot + "" A"" + mangle(password);
		 log(""Writing -> "" + pwdfile , Project.MSG_DEBUG);
		 writer = new PrintWriter(new FileWriter(passFile));
		 writer.println(pwdfile);
	 }
	 catch (IOException e) {
		 throw new BuildException(e);
	 }
	 finally {
		 if (reader != null) {
			 try {
				 reader.close();
			 }
			 catch (IOException e) {
			 }
		 }
		 if (writer != null) {
			 writer.close();
		 }
	 }
 }",0,0,0,0
"public class RunScriptOnNodeAndAddToGoodMapOrPutExceptionIntoBadMap implements Callable<ExecResponse> {
	 protected Logger logger = Logger.NULL;
	 private final RunScriptOnNode runScriptOnNode;
	 private final Map<NodeMetadata, Exception> badNodes;
	 private final Map<NodeMetadata, ExecResponse> goodNodes;
	 private transient boolean tainted;
	 public RunScriptOnNodeAndAddToGoodMapOrPutExceptionIntoBadMap(RunScriptOnNode runScriptOnNode, Map<NodeMetadata, ExecResponse> goodNodes, Map<NodeMetadata, Exception> badNodes) {
		 this.runScriptOnNode = checkNotNull(runScriptOnNode, ""runScriptOnNode"");
		 this.badNodes = checkNotNull(badNodes, ""badNodes"");
		 this.goodNodes = checkNotNull(goodNodes, ""goodNodes"");
	 }
	 public ExecResponse call() {
		 checkState(runScriptOnNode != null, ""runScriptOnNode must be set"");
		 checkState(!tainted, ""this object is not designed to be reused: %s"", toString());
		 tainted = true;
		 try {
			 ExecResponse exec = runScriptOnNode.call();
			 logger.debug(""<< options applied node(%s)"", runScriptOnNode.getNode().getId());
			 logger.trace(""<< script output for node(%s): %s"", runScriptOnNode.getNode().getId(), exec);
			 goodNodes.put(runScriptOnNode.getNode(), exec);
			 return exec;
		 }
		 catch (Exception e) {
			 logger.error(e, ""<< problem applying options to node(%s): "", runScriptOnNode.getNode().getId(), getRootCause(e).getMessage());
			 badNodes.put(runScriptOnNode.getNode(), e);
		 }
		 return null;
	 }
	 public String toString() {
		 return MoreObjects.toStringHelper(this).add(""runScriptOnNode"", runScriptOnNode).add(""goodNodes"", goodNodes).add( ""badNodes"", badNodes).toString();
	 }
}",0,0,0,0
"public int getTrackerPort() {
	 return port;
 }",0,0,0,0
"public void setShowWarnings(boolean b) {
	 showWarnings = b;
 }",0,0,0,0
"protected String resourceKey(T object){
	return object.getDeclaringClass().getSimpleName() + ""."" + object.name();
}",0,0,0,0
"public class Problems {
	 public enum FatalError {
		 FILE_NOT_FOUND(""File '%s' not found."", 1), UNKNOWN_INPUT_TYPE(""Cannot recognize input type for file '%s'."", 1), OUTPUT_LOCATION(""Output location '%s' must be a directory or .zip file."", 1), CANNOT_EXTRACT_ZIP(""Cannot extract zip '%s'."", 1), CANNOT_CREATE_ZIP(""Cannot create zip '%s': %s."", 2), CANNOT_CLOSE_ZIP(""Cannot close zip: %s."", 1), CANNOT_CREATE_TEMP_DIR(""Cannot create temporary directory: %s."", 1), CANNOT_OPEN_FILE(""Cannot open file: %s."", 1), CANNOT_WRITE_FILE(""Cannot write file: %s."", 1), CANNOT_COPY_FILE(""Cannot copy file: %s."", 1), PACKAGE_INFO_PARSE(""Resource '%s' was found but it failed to parse."", 1), CLASS_PATH_URL(""Class path entry '%s' is not a valid url."", 1), GWT_INCOMPATIBLE_FOUND_IN_COMPILE( "" annotations found in %s "" + ""Please run this library through the stripper tool."", 1), ;
		 private final String message;
		 private final int numberOfArguments;
		 FatalError(String message, int numberOfArguments) {
			 this.message = message;
			 this.numberOfArguments = numberOfArguments;
		 }
		 public String getMessage() {
			 return message;
		 }
		 private int getNumberOfArguments() {
			 return numberOfArguments;
		 }
	 }
	 public enum Severity {
		 ERROR(""Error""), WARNING(""Warning""), INFO(""Info"");
		 Severity(String messagePrefix) {
			 this.messagePrefix = messagePrefix;
		 }
		 private final String messagePrefix;
		 public String getMessagePrefix() {
			 return messagePrefix;
		 }
	 }
	 private final Multimap<Severity, String> problemsBySeverity = LinkedHashMultimap.create();
	 public void fatal(FatalError fatalError, Object... args) {
		 checkArgument(fatalError.getNumberOfArguments() == args.length);
		 problemsBySeverity.put( Severity.ERROR, ""Error: "" + String.format(fatalError.getMessage(), args));
		 abort();
	 }
	 public void error(SourcePosition sourcePosition, String detailMessage, Object... args) {
		 problem(Severity.ERROR, sourcePosition, detailMessage, args);
	 }
	 public void error(int lineNumber, String filePath, String detailMessage, Object... args) {
		 problem(Severity.ERROR, lineNumber, filePath, detailMessage, args);
	 }
	 public void warning(SourcePosition sourcePosition, String detailMessage, Object... args) {
		 problem(Severity.WARNING, sourcePosition, detailMessage, args);
	 }
	 private void problem( Severity severity, SourcePosition sourcePosition, String detailMessage, Object... args) {
		 problem( severity, sourcePosition.getStartFilePosition().getLine() + 1, sourcePosition.getFilePath(), detailMessage, args);
	 }
	 private void problem( Severity severity, int lineNumber, String filePath, String detailMessage, Object... args) {
		 String message = args.length == 0 ? detailMessage : String.format(detailMessage, args);
		 problemsBySeverity.put( severity, String.format( ""%s:%s:%s: %s"", severity.getMessagePrefix(), filePath.substring(filePath.lastIndexOf('/') + 1), lineNumber, message));
	 }
	 public void error(String detailMessage, Object... args) {
		 problemsBySeverity.put(Severity.ERROR, ""Error: "" + String.format(detailMessage, args));
	 }
	 public void warning(String detailMessage, Object... args) {
		 problemsBySeverity.put(Severity.WARNING, String.format(detailMessage, args));
	 }
	 public void info(String detailMessage, Object... args) {
		 problemsBySeverity.put(Severity.INFO, String.format(detailMessage, args));
	 }
	 public int reportAndGetExitCode(PrintStream output) {
		 return reportAndGetExitCode(new PrintWriter(output, true));
	 }
	 public int reportAndGetExitCode(PrintWriter output) {
		 for (Map.Entry<Severity, String> severityMessagePair : problemsBySeverity.entries()) {
			 output.println(severityMessagePair.getValue());
		 }
		 if (hasErrors() || hasWarnings()) {
			 output.printf( ""%d error(s), %d warning(s).\n"", problemsBySeverity.get(Severity.ERROR).size(), problemsBySeverity.get(Severity.WARNING).size());
		 }
		 return hasErrors() ? 1 : 0;
	 }
	 public boolean hasWarnings() {
		 return problemsBySeverity.containsKey(Severity.WARNING);
	 }
	 public boolean hasErrors() {
		 return problemsBySeverity.containsKey(Severity.ERROR);
	 }
	 public boolean hasProblems() {
		 return !problemsBySeverity.isEmpty();
	 }
	 public void abortIfHasErrors() {
		 if (hasErrors()) {
			 abort();
		 }
	 }
	 public void abort() {
		 throw new Exit(this);
	 }
	 public List<String> getErrors() {
		 return getMessages(Severity.ERROR);
	 }
	 public List<String> getWarnings() {
		 return getMessages(Severity.WARNING);
	 }
	 public List<String> getInfoMessages() {
		 return getMessages(Severity.INFO);
	 }
	 public List<String> getMessages() {
		 return getMessages(EnumSet.allOf(Severity.class));
	 }
	 private List<String> getMessages(Severity severity) {
		 return getMessages(Collections.singleton(severity));
	 }
	 private List<String> getMessages(Collection<Severity> severities) {
		 return problemsBySeverity .entries() .stream() .filter(e -> severities.contains(e.getKey())) .map(Map.Entry::getValue) .collect(Collectors.toList());
	 }
	 public static class Exit extends java.lang.Error {
		 private final Problems problems;
		 private Exit(Problems problems) {
			 this.problems = problems;
		 }
		 public Problems getProblems() {
			 return problems;
		 }
	 }
}",1,1,0,0
"public class BuildException extends RuntimeException {
	 private static final long serialVersionUID = -5419014565354664240L;
	 private Throwable cause;
	 private Location location = Location.UNKNOWN_LOCATION;
	 public BuildException() {
		 super();
	 }
	 public BuildException(String message) {
		 super(message);
	 }
	 public BuildException(String message, Throwable cause) {
		 super(message);
		 this.cause = cause;
	 }
	 public BuildException(String msg, Throwable cause, Location location) {
		 this(msg, cause);
		 this.location = location;
	 }
	 public BuildException(Throwable cause) {
		 super(cause.toString());
		 this.cause = cause;
	 }
	 public BuildException(String message, Location location) {
		 super(message);
		 this.location = location;
	 }
	 public BuildException(Throwable cause, Location location) {
		 this(cause);
		 this.location = location;
	 }
	 public Throwable getException() {
		 return cause;
	 }
	 public Throwable getCause() {
		 return getException();
	 }
	 public String toString() {
		 return location.toString() + getMessage();
	 }
	 public void setLocation(Location location) {
		 this.location = location;
	 }
	 public Location getLocation() {
		 return location;
	 }
	 public void printStackTrace() {
		 printStackTrace(System.err);
	 }
	 public void printStackTrace(PrintStream ps) {
		 synchronized (ps) {
			 super.printStackTrace(ps);
			 if (cause != null) {
				 ps.println(""--- Nested Exception ---"");
				 cause.printStackTrace(ps);
			 }
		 }
	 }
	 public void printStackTrace(PrintWriter pw) {
		 synchronized (pw) {
			 super.printStackTrace(pw);
			 if (cause != null) {
				 pw.println(""--- Nested Exception ---"");
				 cause.printStackTrace(pw);
			 }
		 }
	 }
}",0,0,0,0
"public class TestMultiQueryCompiler {
	 private static MiniGenericCluster cluster;
	 private PigServer myPig;
	 public static void setUpBeforeClass() throws IOException {
		 cluster = MiniGenericCluster.buildCluster(MiniGenericCluster.EXECTYPE_MR);
		 Util.copyFromLocalToCluster(cluster, ""test/org/apache/pig/test/data/passwd"", ""passwd"");
		 Util.copyFromLocalToCluster(cluster, ""test/org/apache/pig/test/data/passwd2"", ""passwd2"");
	 }
	 public static void tearDownAfterClass() throws IOException {
		 Util.deleteFile(cluster, ""passwd"");
		 Util.deleteFile(cluster, ""passwd2"");
		 cluster.shutDown();
	 }
	 public void setUp() throws Exception {
		 cluster.setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """"+true);
		 myPig = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());
		 deleteOutputFiles();
	 }
	 public void tearDown() throws Exception {
		 myPig = null;
	 }
	 public void testMultiQueryJiraPig1438() {
		 String INPUT_FILE = ""abc"";
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""A = load '"" + INPUT_FILE + ""' as (col1:int, col2:int, col3:int);
			"");
			 myPig.registerQuery(""B1 = foreach A generate col1, col2;
			"");
			 myPig.registerQuery(""B2 = foreach A generate col2, col3;
			"");
			 myPig.registerQuery(""C1 = distinct B1;
			"");
			 myPig.registerQuery(""C2 = group B2 by (col2, col3);
			"");
			 myPig.registerQuery(""D1 = foreach C1 generate col1, col2;
			"");
			 myPig.registerQuery(""D2 = foreach C2 generate B2.col2, B2.col3;
			"");
			 myPig.registerQuery(""store D1 into '/tmp/output1';
			"");
			 myPig.registerQuery(""store D2 into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 12);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 15);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryJiraPig1060() {
		 String INPUT_FILE = ""pig-1060.txt"";
		 try {
			 PrintWriter w = new PrintWriter(new FileWriter(INPUT_FILE));
			 w.println(""apple\t2"");
			 w.println(""apple\t12"");
			 w.println(""orange\t3"");
			 w.println(""orange\t23"");
			 w.println(""strawberry\t10"");
			 w.println(""strawberry\t34"");
			 w.close();
			 Util.copyFromLocalToCluster(cluster, INPUT_FILE, INPUT_FILE);
			 myPig.setBatchOn();
			 myPig.registerQuery(""data = load '"" + INPUT_FILE + ""' as (name:chararray, gid:int);
			"");
			 myPig.registerQuery(""f1 = filter data by gid < 5;
			"");
			 myPig.registerQuery(""g1 = group f1 by name;
			"");
			 myPig.registerQuery(""p1 = foreach g1 generate group, COUNT(f1.gid);
			"");
			 myPig.registerQuery(""store p1 into '/tmp/output1';
			"");
			 myPig.registerQuery(""f2 = filter data by gid > 5;
			"");
			 myPig.registerQuery(""g2 = group f2 by name;
			"");
			 myPig.registerQuery(""p2 = foreach g2 generate group, COUNT(f2.gid);
			"");
			 myPig.registerQuery(""store p2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""f3 = filter f2 by gid > 10;
			"");
			 myPig.registerQuery(""g3 = group f3 by name;
			"");
			 myPig.registerQuery(""p3 = foreach g3 generate group, COUNT(f3.gid);
			"");
			 myPig.registerQuery(""store p3 into '/tmp/output3';
			"");
			 myPig.registerQuery(""f4 = filter f3 by gid < 20;
			"");
			 myPig.registerQuery(""g4 = group f4 by name;
			"");
			 myPig.registerQuery(""p4 = foreach g4 generate group, COUNT(f4.gid);
			"");
			 myPig.registerQuery(""store p4 into '/tmp/output4';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 4, 26);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 4, 35);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
		 finally {
			 new File(INPUT_FILE).delete();
			 try {
				 Util.deleteFile(cluster, INPUT_FILE);
			 }
			 catch (IOException e) {
				 e.printStackTrace();
				 Assert.fail();
			 }
		 }
	 }
	 public void testMultiQueryJiraPig920() {
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by gid >= 5;
			"");
			 myPig.registerQuery(""d = cogroup c by $0, b by $0;
			"");
			 myPig.registerQuery(""e = foreach d generate group, COUNT(c), COUNT(b);
			"");
			 myPig.registerQuery(""store e into '/tmp/output1';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 1, 9);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 13);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryJiraPig920_1() {
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by gid >= 5;
			"");
			 myPig.registerQuery(""d = filter a by uid >= 5;
			"");
			 myPig.registerQuery(""e = filter a by gid < 5;
			"");
			 myPig.registerQuery(""f = cogroup c by $0, b by $0;
			"");
			 myPig.registerQuery(""f1 = foreach f generate group, COUNT(c), COUNT(b);
			"");
			 myPig.registerQuery(""store f1 into '/tmp/output1';
			"");
			 myPig.registerQuery(""g = cogroup d by $0, e by $0;
			"");
			 myPig.registerQuery(""g1 = foreach g generate group, COUNT(d), COUNT(e);
			"");
			 myPig.registerQuery(""store g1 into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 16);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 23);
			 checkMRPlan(pp, 2, 2, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithDemoCase() {
		 System.out.println(""===== multi-query with demo case 2 ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = foreach a generate uname, uid, gid;
			"");
			 myPig.registerQuery(""c = filter b by uid < 5;
			"");
			 myPig.registerQuery(""d = filter c by gid >= 5;
			"");
			 myPig.registerQuery(""store d into '/tmp/output1';
			"");
			 myPig.registerQuery(""e = filter b by uid >= 5;
			"");
			 myPig.registerQuery(""store e into '/tmp/output2';
			"");
			 myPig.registerQuery(""f = filter c by gid < 5;
			"");
			 myPig.registerQuery(""g = group f by uname;
			"");
			 myPig.registerQuery(""h = foreach g generate group, COUNT(f.uid);
			"");
			 myPig.registerQuery(""store h into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 17);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 19);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithSingleMapReduceSplittee() {
		 System.out.println(""===== multi-query with single map reduce splittee ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname, passwd, uid, gid);
			"");
			 myPig.registerQuery(""b = foreach a generate uname, uid, gid;
			"");
			 myPig.registerQuery(""split b into c1 if uid > 5, c2 if uid <= 5 ;
			"");
			 myPig.registerQuery(""f = group c2 by uname;
			"");
			 myPig.registerQuery(""f1 = foreach f generate group, SUM(c2.gid);
			"");
			 myPig.registerQuery(""store f1 into '/tmp/output1';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 1, 7);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 9);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryPhase3BaseCase() {
		 System.out.println(""===== multi-query phase 3 base case ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by uid >= 5 and uid < 10;
			"");
			 myPig.registerQuery(""d = filter a by uid >= 10;
			"");
			 myPig.registerQuery(""b1 = group b by gid;
			"");
			 myPig.registerQuery(""b2 = foreach b1 generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""b3 = filter b2 by $1 > 5;
			"");
			 myPig.registerQuery(""store b3 into '/tmp/output1';
			"");
			 myPig.registerQuery(""c1 = group c by gid;
			"");
			 myPig.registerQuery(""c2 = foreach c1 generate group, SUM(c.uid);
			"");
			 myPig.registerQuery(""store c2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""d1 = group d by gid;
			"");
			 myPig.registerQuery(""d2 = foreach d1 generate group, AVG(d.uid);
			"");
			 myPig.registerQuery(""store d2 into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryJiraPig983() {
		 System.out.println(""===== multi-query Jira Pig-983 ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by uid >= 5;
			"");
			 myPig.registerQuery(""d = join b by uname, c by uname;
			"");
			 myPig.registerQuery(""e = group d by b::gid;
			"");
			 myPig.registerQuery(""e1 = foreach e generate group, COUNT(d.b::uid);
			"");
			 myPig.registerQuery(""store e1 into '/tmp/output1';
			"");
			 myPig.registerQuery(""f = group d by c::gid;
			"");
			 myPig.registerQuery(""f1 = foreach f generate group, SUM(d.c::uid);
			"");
			 myPig.registerQuery(""store f1 into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 16);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 25);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryPhase3WithoutCombiner() {
		 System.out.println(""===== multi-query phase 3 without combiner ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by uid >= 5 and uid < 10;
			"");
			 myPig.registerQuery(""d = filter a by uid >= 10;
			"");
			 myPig.registerQuery(""b1 = group b by gid;
			"");
			 myPig.registerQuery(""b2 = foreach b1 generate group, COUNT(b.uid) + SUM(b.uid);
			"");
			 myPig.registerQuery(""b3 = filter b2 by $1 > 5;
			"");
			 myPig.registerQuery(""store b3 into '/tmp/output1';
			"");
			 myPig.registerQuery(""c1 = group c by gid;
			"");
			 myPig.registerQuery(""c2 = foreach c1 generate group, SUM(c.uid) - COUNT(c.uid);
			"");
			 myPig.registerQuery(""store c2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""d1 = group d by gid;
			"");
			 myPig.registerQuery(""d2 = foreach d1 generate group, MAX(d.uid) - MIN(d.uid);
			"");
			 myPig.registerQuery(""store d2 into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryPhase3WithMixedCombiner() {
		 System.out.println(""===== multi-query phase 3 with mixed combiner ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by uid >= 5 and uid < 10;
			"");
			 myPig.registerQuery(""d = filter a by uid >= 10;
			"");
			 myPig.registerQuery(""b1 = group b by gid;
			"");
			 myPig.registerQuery(""b2 = foreach b1 generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""b3 = filter b2 by $1 > 5;
			"");
			 myPig.registerQuery(""store b3 into '/tmp/output1';
			"");
			 myPig.registerQuery(""c1 = group c by gid;
			"");
			 myPig.registerQuery(""c2 = foreach c1 generate group, SUM(c.uid);
			"");
			 myPig.registerQuery(""store c2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""d1 = group d by gid;
			"");
			 myPig.registerQuery(""d2 = foreach d1 generate group, d.uname, MAX(d.uid) - MIN(d.uid);
			"");
			 myPig.registerQuery(""store d2 into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryPhase3WithDifferentMapDataTypes() {
		 System.out.println(""===== multi-query phase 3 with different map datatypes ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by uid >= 5 and uid < 10;
			"");
			 myPig.registerQuery(""d = filter a by uid >= 10;
			"");
			 myPig.registerQuery(""b1 = group b by gid parallel 2;
			"");
			 myPig.registerQuery(""b2 = foreach b1 generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""b3 = filter b2 by $1 > 5;
			"");
			 myPig.registerQuery(""store b3 into '/tmp/output1';
			"");
			 myPig.registerQuery(""c1 = group c by $1 parallel 3;
			"");
			 myPig.registerQuery(""c2 = foreach c1 generate group, SUM(c.uid);
			"");
			 myPig.registerQuery(""store c2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""d1 = group d by $1 parallel 4;
			"");
			 myPig.registerQuery(""d2 = foreach d1 generate group, COUNT(d.uid);
			"");
			 myPig.registerQuery(""store d2 into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryPhase3StreamingInReducer() {
		 System.out.println(""===== multi-query phase 3 with streaming in reducer ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""A = load 'passwd';
			"");
			 myPig.registerQuery(""Split A into A1 if $2 > 5, A2 if $2 >= 5;
			"");
			 myPig.registerQuery(""Split A1 into A3 if $0 > 'm', A4 if $0 >= 'm';
			"");
			 myPig.registerQuery(""B = group A3 by $2;
			"");
			 myPig.registerQuery(""C = foreach B generate flatten(A3);
			"");
			 myPig.registerQuery(""D = stream B through `cat`;
			"");
			 myPig.registerQuery(""store D into '/tmp/output1';
			"");
			 myPig.registerQuery(""E = group A4 by $2;
			"");
			 myPig.registerQuery(""F = foreach E generate group, COUNT(A4);
			"");
			 myPig.registerQuery(""store F into '/tmp/output2';
			"");
			 myPig.registerQuery(""G = group A1 by $2;
			"");
			 myPig.registerQuery(""H = foreach G generate group, COUNT(A1);
			"");
			 myPig.registerQuery(""store H into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 24);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithPigMixL12() {
		 System.out.println(""===== multi-query with PigMix L12 ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname, passwd, uid, gid);
			"");
			 myPig.registerQuery(""b = foreach a generate uname, passwd, uid, gid;
			"");
			 myPig.registerQuery(""split b into c1 if uid > 5, c2 if uid <= 5 ;
			"");
			 myPig.registerQuery(""split c1 into d1 if gid < 5, d2 if gid >= 5;
			"");
			 myPig.registerQuery(""e = group d1 by uname;
			"");
			 myPig.registerQuery(""e1 = foreach e generate group, MAX(d1.uid);
			"");
			 myPig.registerQuery(""store e1 into '/tmp/output1';
			"");
			 myPig.registerQuery(""f = group c2 by uname;
			"");
			 myPig.registerQuery(""f1 = foreach f generate group, SUM(c2.gid);
			"");
			 myPig.registerQuery(""store f1 into '/tmp/output2';
			"");
			 myPig.registerQuery(""g = group d2 by uname;
			"");
			 myPig.registerQuery(""g1 = foreach g generate group, COUNT(d2);
			"");
			 myPig.registerQuery(""store g1 into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 17);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 23);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithCoGroup() {
		 System.out.println(""===== multi-query with CoGroup ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname, passwd, uid, gid);
			"");
			 myPig.registerQuery(""store a into '/tmp/output1' using BinStorage();
			"");
			 myPig.registerQuery(""b = load '/tmp/output1' using BinStorage() as (uname, passwd, uid, gid);
			"");
			 myPig.registerQuery(""c = load 'passwd2' "" + ""using PigStorage(':') as (uname, passwd, uid, gid);
			"");
			 myPig.registerQuery(""d = cogroup b by (uname, uid) inner, c by (uname, uid) inner;
			"");
			 myPig.registerQuery(""e = foreach d generate flatten(b), flatten(c);
			"");
			 myPig.registerQuery(""store e into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(2, 1, 7);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 2, 1, 13);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithFJ() {
		 System.out.println(""===== multi-query with FJ ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""c = filter a by uid > 5;
			"");
			 myPig.registerQuery(""store c into '/tmp/output1';
			"");
			 myPig.registerQuery(""d = filter b by gid > 10;
			"");
			 myPig.registerQuery(""store d into '/tmp/output2';
			"");
			 myPig.registerQuery(""e = join c by gid, d by gid using 'repl';
			"");
			 myPig.registerQuery(""store e into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(2, 3, 14);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 2, 3, 16);
			 checkMRPlan(pp, 2, 1, 3);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithExplicitSplitAndSideFiles() {
		 System.out.println(""===== multi-query with explicit split and side files ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""split a into b if uid > 500, c if uid <= 500;
			"");
			 myPig.registerQuery(""store b into '/tmp/output1';
			"");
			 myPig.registerQuery(""store c into '/tmp/output2';
			"");
			 myPig.registerQuery(""e = cogroup b by gid, c by gid;
			"");
			 myPig.registerQuery(""d = foreach e generate flatten(c), flatten(b);
			"");
			 myPig.registerQuery(""store d into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 15);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 19);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithExplicitSplitAndOrderByAndSideFiles() {
		 System.out.println(""===== multi-query with explicit split, orderby and side files ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""split a into a1 if uid > 500, a2 if gid > 500;
			"");
			 myPig.registerQuery(""b1 = distinct a1;
			"");
			 myPig.registerQuery(""b2 = order a2 by uname;
			"");
			 myPig.registerQuery(""store b1 into '/tmp/output1';
			"");
			 myPig.registerQuery(""store b2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""c = cogroup b1 by uname, b2 by uname;
			"");
			 myPig.registerQuery(""d = foreach c generate flatten(group), flatten($1), flatten($2);
			"");
			 myPig.registerQuery(""store d into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 17);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 21);
			 checkMRPlan(pp, 1, 1, 4);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithIntermediateStores() {
		 System.out.println(""===== multi-query with intermediate stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""store a into '/tmp/output1';
			"");
			 myPig.registerQuery(""b = load '/tmp/output1' using PigStorage(':');
			 "");
			 myPig.registerQuery(""store b into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 1, 4);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 5);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithImplicitSplitAndSideFiles() {
		 System.out.println(""===== multi-query with implicit split and side files ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 500;
			"");
			 myPig.registerQuery(""c = filter a by gid > 500;
			"");
			 myPig.registerQuery(""store c into '/tmp/output1';
			"");
			 myPig.registerQuery(""d = cogroup b by uname, c by uname;
			"");
			 myPig.registerQuery(""e = foreach d generate flatten(c), flatten(b);
			"");
			 myPig.registerQuery(""store e into '/tmp/output2';
			"");
			 myPig.registerQuery(""f = filter e by b::uid < 1000;
			"");
			 myPig.registerQuery(""store f into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 22);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithTwoLoadsAndTwoStores() {
		 System.out.println(""===== multi-query with two loads and two stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = load 'passwd2' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""c = filter a by uid > 5;
			"");
			 myPig.registerQuery(""d = filter b by uid > 10;
			"");
			 myPig.registerQuery(""e = cogroup c by uid, d by uid;
			"");
			 myPig.registerQuery(""f = foreach e generate flatten(c), flatten(d);
			"");
			 myPig.registerQuery(""g = group f by d::gid;
			"");
			 myPig.registerQuery(""h = filter f by c::gid > 5;
			"");
			 myPig.registerQuery(""store g into '/tmp/output1';
			"");
			 myPig.registerQuery(""store h into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(2, 2, 13);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 2, 2, 20);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithSplitInReduce() {
		 System.out.println(""===== multi-query with split in reduce ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 5;
			"");
			 myPig.registerQuery(""c = group b by gid;
			"");
			 myPig.registerQuery(""d = foreach c generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""store d into '/tmp/output1';
			"");
			 myPig.registerQuery(""e = filter d by $1 > 5;
			"");
			 myPig.registerQuery(""store e into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 10);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 13);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithSplitInReduceAndReduceSplitee() {
		 System.out.println(""===== multi-query with split in reduce and reduce splitee ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 5;
			"");
			 myPig.registerQuery(""c = group b by gid;
			"");
			 myPig.registerQuery(""d = foreach c generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""store d into '/tmp/output1';
			"");
			 myPig.registerQuery(""e = filter d by $1 > 5;
			"");
			 myPig.registerQuery(""f = group e by $1;
			"");
			 myPig.registerQuery(""g = foreach f generate group, SUM(e.$0);
			"");
			 myPig.registerQuery(""store g into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 12);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 17);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithSplitInReduceAndReduceSplitees() {
		 System.out.println(""===== multi-query with split in reduce and reduce splitees ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 5;
			"");
			 myPig.registerQuery(""c = group b by gid;
			"");
			 myPig.registerQuery(""d = foreach c generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""e = filter d by $1 > 5;
			"");
			 myPig.registerQuery(""e1 = group e by $1;
			"");
			 myPig.registerQuery(""e2 = foreach e1 generate group, SUM(e.$0);
			"");
			 myPig.registerQuery(""store e2 into '/tmp/output1';
			"");
			 myPig.registerQuery(""f = filter d by $1 < 5;
			"");
			 myPig.registerQuery(""f1 = group f by $1;
			"");
			 myPig.registerQuery(""f2 = foreach f1 generate group, COUNT(f.$0);
			"");
			 myPig.registerQuery(""store f2 into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 15);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 22);
			 checkMRPlan(pp, 1, 1, 2);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithSplitInReduceAndReduceSpliteesAndMore() {
		 System.out.println(""===== multi-query with split in reduce and reduce splitees and more ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 500;
			"");
			 myPig.registerQuery(""c = group b by gid;
			"");
			 myPig.registerQuery(""d = foreach c generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""e = filter d by $1 > 5;
			"");
			 myPig.registerQuery(""e1 = group e by $1;
			"");
			 myPig.registerQuery(""e2 = foreach e1 generate group, SUM(e.$0);
			"");
			 myPig.registerQuery(""e3 = filter e2 by $1 > 10;
			"");
			 myPig.registerQuery(""e4 = group e3 by $1;
			"");
			 myPig.registerQuery(""e5 = foreach e4 generate group, SUM(e3.$0);
			"");
			 myPig.registerQuery(""store e5 into '/tmp/output1';
			"");
			 myPig.registerQuery(""f = filter d by $1 < 5;
			"");
			 myPig.registerQuery(""f1 = group f by $1;
			"");
			 myPig.registerQuery(""f2 = foreach f1 generate group, COUNT(f.$0);
			"");
			 myPig.registerQuery(""f3 = filter f2 by $1 < 100;
			"");
			 myPig.registerQuery(""f4 = group f3 by $1;
			"");
			 myPig.registerQuery(""f5 = foreach f4 generate group, COUNT(f3.$0);
			"");
			 myPig.registerQuery(""store f5 into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 21);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 32);
			 checkMRPlan(pp, 1, 2, 4);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithSplitInMapAndReduceSplitees() {
		 System.out.println(""===== multi-query with split in map and reduce splitees ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid < 5;
			"");
			 myPig.registerQuery(""c = filter a by uid >= 5 and uid < 10;
			"");
			 myPig.registerQuery(""d = filter a by uid >= 10;
			"");
			 myPig.registerQuery(""b1 = group b by gid;
			"");
			 myPig.registerQuery(""b2 = foreach b1 generate group, COUNT(b.uid);
			"");
			 myPig.registerQuery(""b3 = filter b2 by $1 > 5;
			"");
			 myPig.registerQuery(""store b3 into '/tmp/output1';
			"");
			 myPig.registerQuery(""c1 = group c by $1;
			"");
			 myPig.registerQuery(""c2 = foreach c1 generate group, SUM(c.uid);
			"");
			 myPig.registerQuery(""store c2 into '/tmp/output2';
			"");
			 myPig.registerQuery(""d1 = group d by $1;
			"");
			 myPig.registerQuery(""d2 = foreach d1 generate group, COUNT(d.uid);
			"");
			 myPig.registerQuery(""store d2 into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 18);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithTwoStores() {
		 System.out.println(""===== multi-query with 2 stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 5;
			"");
			 myPig.registerQuery(""store b into '/tmp/output1';
			"");
			 myPig.registerQuery(""c = group b by gid;
			"");
			 myPig.registerQuery(""store c into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 8);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 11);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithThreeStores() {
		 System.out.println(""===== multi-query with 3 stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 5;
			"");
			 myPig.registerQuery(""store b into '/tmp/output1';
			"");
			 myPig.registerQuery(""c = filter b by uid > 10;
			"");
			 myPig.registerQuery(""store c into '/tmp/output2';
			"");
			 myPig.registerQuery(""d = filter c by uid > 15;
			"");
			 myPig.registerQuery(""store d into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 13);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 14);
			 checkMRPlan(pp, 1, 1, 1);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithTwoLoads() {
		 System.out.println(""===== multi-query with two loads ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = load 'passwd2' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""c = filter a by uid > 5;
			"");
			 myPig.registerQuery(""d = filter b by uid > 10;
			"");
			 myPig.registerQuery(""store c into '/tmp/output1';
			"");
			 myPig.registerQuery(""store d into '/tmp/output2';
			"");
			 myPig.registerQuery(""e = cogroup c by uid, d by uid;
			"");
			 myPig.registerQuery(""store e into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(2, 3, 14);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 2, 3, 19);
			 checkMRPlan(pp, 2, 1, 3);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testStoreOrder() {
		 System.out.println(""===== multi-query store order ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd';
			"");
			 myPig.registerQuery(""store a into '/tmp/output1' using BinStorage();
			"");
			 myPig.registerQuery(""a = load '/tmp/output1';
			"");
			 myPig.registerQuery(""store a into '/tmp/output2';
			"");
			 myPig.registerQuery(""a = load '/tmp/output1';
			"");
			 myPig.registerQuery(""store a into '/tmp/output3';
			"");
			 myPig.registerQuery(""a = load '/tmp/output2' using BinStorage();
			"");
			 myPig.registerQuery(""store a into '/tmp/output4';
			"");
			 myPig.registerQuery(""a = load '/tmp/output2';
			"");
			 myPig.registerQuery(""b = load '/tmp/output1';
			"");
			 myPig.registerQuery(""c = cogroup a by $0, b by $0;
			"");
			 myPig.registerQuery(""store c into '/tmp/output5';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 12);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 15);
			 MROperPlan mp = checkMRPlan(pp, 1, 3, 5);
			 myPig.executeBatch();
			 myPig.discardBatch();
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output1""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output2""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output3""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output4""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output5""));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testUnnecessaryStoreRemoval() {
		 System.out.println(""===== multi-query unnecessary stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = group a by uname;
			"");
			 myPig.registerQuery(""store b into '/tmp/output1';
			"");
			 myPig.registerQuery(""store b into '/tmp/output2';
			"");
			 myPig.registerQuery(""c = load '/tmp/output1';
			"");
			 myPig.registerQuery(""d = group c by $0;
			"");
			 myPig.registerQuery(""e = store d into '/tmp/output3';
			"");
			 myPig.registerQuery(""f = load '/tmp/output2';
			"");
			 myPig.registerQuery(""g = group f by $0;
			"");
			 myPig.registerQuery(""store g into '/tmp/output4';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 13);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 20);
			 MROperPlan mp = checkMRPlan(pp, 1, 2, 3);
			 MapReduceOper mo1 = mp.getRoots().get(0);
			 MapReduceOper mo2 = mp.getLeaves().get(0);
			 MapReduceOper mo3 = mp.getLeaves().get(1);
			 checkPhysicalPlan(mo1.mapPlan, 1, 1, 3);
			 checkPhysicalPlan(mo1.reducePlan, 1, 1, 2);
			 PhysicalOperator leaf = mo1.reducePlan.getLeaves().get(0);
			 Assert.assertTrue(leaf instanceof POSplit);
			 POSplit split = (POSplit)leaf;
			 int i = 0;
			 for (PhysicalPlan p: split.getPlans()) {
				 checkPhysicalPlan(p, 1, 1, 1);
				 ++i;
			 }
			 Assert.assertEquals(i,2);
			 checkPhysicalPlan(mo2.mapPlan, 1, 1, 2);
			 checkPhysicalPlan(mo2.reducePlan, 1, 1, 2);
			 leaf = mo2.reducePlan.getLeaves().get(0);
			 Assert.assertTrue(leaf instanceof POStore);
			 checkPhysicalPlan(mo3.mapPlan, 1, 1, 2);
			 checkPhysicalPlan(mo3.reducePlan, 1, 1, 2);
			 leaf = mo3.reducePlan.getLeaves().get(0);
			 Assert.assertTrue(leaf instanceof POStore);
			 myPig.executeBatch();
			 myPig.discardBatch();
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output1""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output2""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output3""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output4""));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testUnnecessaryStoreRemovalCollapseSplit() {
		 System.out.println(""===== multi-query unnecessary stores collapse split ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = group a by uname;
			"");
			 myPig.registerQuery(""store b into '/tmp/output1';
			"");
			 myPig.registerQuery(""c = load '/tmp/output1';
			"");
			 myPig.registerQuery(""d = group c by $0;
			"");
			 myPig.registerQuery(""e = store d into '/tmp/output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 1, 6);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 11);
			 MROperPlan mp = checkMRPlan(pp, 1, 1, 2);
			 MapReduceOper mo1 = mp.getRoots().get(0);
			 MapReduceOper mo2 = mp.getLeaves().get(0);
			 checkPhysicalPlan(mo1.mapPlan, 1, 1, 3);
			 checkPhysicalPlan(mo1.reducePlan, 1, 1, 2);
			 PhysicalOperator leaf = mo1.reducePlan.getLeaves().get(0);
			 Assert.assertTrue(leaf instanceof POStore);
			 checkPhysicalPlan(mo2.mapPlan, 1, 1, 2);
			 checkPhysicalPlan(mo2.reducePlan, 1, 1, 2);
			 leaf = mo2.reducePlan.getLeaves().get(0);
			 Assert.assertTrue(leaf instanceof POStore);
			 myPig.executeBatch();
			 myPig.discardBatch();
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output1""));
			 Assert.assertTrue(myPig.getPigContext().getDfs().isContainer(""/tmp/output2""));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testEmptyFilterRemoval() {
		 System.out.println(""===== multi-query empty filters ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid>0;
			"");
			 myPig.registerQuery(""c = filter a by uid>5;
			"");
			 myPig.registerQuery(""d = filter c by uid<10;
			"");
			 myPig.registerQuery(""store b into '/tmp/output1';
			"");
			 myPig.registerQuery(""store b into '/tmp/output2';
			"");
			 myPig.registerQuery(""store b into '/tmp/output3';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 3, 9);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 10);
			 MROperPlan mp = checkMRPlan(pp, 1, 1, 1);
			 MapReduceOper mo = mp.getRoots().get(0);
			 checkPhysicalPlan(mo.mapPlan, 1, 1, 4);
			 PhysicalOperator leaf = mo.mapPlan.getLeaves().get(0);
			 Assert.assertTrue(leaf instanceof POSplit);
			 POSplit split = (POSplit)leaf;
			 int i = 0;
			 for (PhysicalPlan p: split.getPlans()) {
				 checkPhysicalPlan(p, 1, 1, 1);
				 ++i;
			 }
			 Assert.assertEquals(i,3);
			 myPig.executeBatch();
			 myPig.discardBatch();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithDescribe() {
		 System.out.println(""===== multi-query with describe ====="");
		 try {
			 String script = ""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"" + ""b = filter a by uid > 5;
			"" + ""describe b;
			"" + ""store b into '/tmp/output1';
			\n"";
			 GruntParser parser = new GruntParser(new StringReader(script), myPig);
			 parser.setInteractive(false);
			 parser.parseStopOnError();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithIllustrate() {
		 System.out.println(""===== multi-query with illustrate ====="");
		 try {
			 String script = ""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"" + ""b = filter a by uid > 5;
			"" + ""illustrate b;
			"" + ""store b into '/tmp/output1';
			\n"";
			 GruntParser parser = new GruntParser(new StringReader(script), myPig);
			 parser.setInteractive(false);
			 parser.parseStopOnError();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithExplain() {
		 System.out.println(""===== multi-query with explain ====="");
		 try {
			 String script = ""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"" + ""b = filter a by uid > 5;
			"" + ""explain b;
			"" + ""store b into '/tmp/output1';
			\n"";
			 GruntParser parser = new GruntParser(new StringReader(script), myPig);
			 parser.setInteractive(false);
			 parser.parseStopOnError();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithDump() {
		 System.out.println(""===== multi-query with dump ====="");
		 try {
			 String script = ""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"" + ""b = filter a by uid > 5;
			"" + ""dump b;
			"" + ""store b into '/tmp/output1';
			\n"";
			 GruntParser parser = new GruntParser(new StringReader(script), myPig);
			 parser.setInteractive(false);
			 parser.parseStopOnError();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testEmptyExecute() {
		 System.out.println(""==== empty execute ===="");
		 try {
			 myPig.setBatchOn();
			 myPig.executeBatch();
			 myPig.executeBatch();
			 myPig.discardBatch();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testLoadStoreLoop() {
		 try {
			 String script = ""a = load 'dummy';
			 b = filter a by $0 == 1;
			 store b into 'dummy';
			\n"";
			 GruntParser parser = new GruntParser(new StringReader(script), myPig);
			 parser.setInteractive(false);
			 myPig.getPigContext().inExplain = true;
			 parser.parseStopOnError();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithNoStore2() {
		 System.out.println(""===== multi-query with no store (2) ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int,gid:int);
			"");
			 myPig.registerQuery(""b = filter a by uid > 5;
			"");
			 myPig.registerQuery(""group b by gid;
			"");
			 myPig.executeBatch();
			 myPig.discardBatch();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryWithCustomPartitioner() {
		 System.out.println(""===== multi-query with intermediate stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""l = FILTER a BY uname == 'foo';
			"");
			 myPig.registerQuery(""b = GROUP a BY uname PARTITION BY "" + SimpleCustomPartitioner.class.getName() + "" PARALLEL 3;
			"");
			 myPig.registerQuery(""c = FOREACH b GENERATE FLATTEN(a) PARALLEL 3;
			"");
			 myPig.registerQuery(""STORE c INTO 'output1';
			"");
			 myPig.registerQuery(""STORE l INTO 'output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 9);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 12);
			 MROperPlan mrp = checkMRPlan(pp, 1, 1, 2);
			 MapReduceOper mrop = mrp.getLeaves().get(0);
			 Assert.assertTrue(mrop.getCustomPartitioner().equals(SimpleCustomPartitioner.class.getName()));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
	 public void testMultiQueryDoNotMergeMRwithDifferentPartitioners() {
		 System.out.println(""===== multi-query with intermediate stores ====="");
		 try {
			 myPig.setBatchOn();
			 myPig.registerQuery(""a = load 'passwd' "" + ""using PigStorage(':') as (uname:chararray, passwd:chararray, uid:int, gid:int);
			"");
			 myPig.registerQuery(""b1 = FILTER a BY gid != 0;
			"");
			 myPig.registerQuery(""b2 = FILTER a BY uid > 100;
			"");
			 myPig.registerQuery(""c1 = GROUP b1 BY uname PARTITION BY "" + SimpleCustomPartitioner.class.getName() + "" PARALLEL 3;
			"");
			 myPig.registerQuery(""c2 = GROUP b2 BY uname PARALLEL 3;
			"");
			 myPig.registerQuery(""STORE c1 INTO 'output1';
			"");
			 myPig.registerQuery(""STORE c2 INTO 'output2';
			"");
			 LogicalPlan lp = checkLogicalPlan(1, 2, 10);
			 PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 15);
			 MROperPlan mrp = checkMRPlan(pp, 1, 1, 2);
			 MapReduceOper mrop;
			 mrop = mrp.getRoots().get(0);
			 Assert.assertTrue(mrop.getCustomPartitioner() == null );
			 mrop = mrp.getLeaves().get(0);
			 Assert.assertTrue(mrop.getCustomPartitioner().equals(SimpleCustomPartitioner.class.getName()));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 Assert.fail(e.toString());
		 }
	 }
	 private <T extends OperatorPlan<? extends Operator<?>>> void showPlanOperators(T p) {
		 System.out.println(""Operators:"");
		 ArrayList<Operator<?>> ops = new ArrayList<Operator<?>>(p.getKeys() .values());
		 Collections.sort(ops);
		 for (Operator<?> op : ops) {
			 System.out.println("" op: "" + op.name());
		 }
		 System.out.println();
	 }
	 private LogicalPlan checkLogicalPlan(int expectedRoots, int expectedLeaves, int expectedSize) throws IOException, ParseException {
		 System.out.println(""===== check logical plan ====="");
		 LogicalPlan lp = null;
		 try {
			 java.lang.reflect.Method buildLp = myPig.getClass().getDeclaredMethod(""buildLp"");
			 buildLp.setAccessible(true);
			 lp = (LogicalPlan) buildLp.invoke( myPig );
			 Assert.assertNotNull(lp);
		 }
		 catch (Exception e) {
			 PigException pe = LogUtils.getPigException(e);
			 if (pe != null) {
				 throw pe;
			 }
			 else {
				 e.printStackTrace();
				 Assert.fail();
			 }
		 }
		 showLPOperators(lp);
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 System.out.println(""Logical Plan: "" + lp );
		 System.out.println(""===== Display Logical Plan ====="");
		 System.out.println(out.toString());
		 Assert.assertEquals(expectedRoots, lp.getSources().size());
		 Assert.assertEquals(expectedLeaves, lp.getSinks().size());
		 Assert.assertEquals(expectedSize, lp.size());
		 return lp;
	 }
	 static void showLPOperators(LogicalPlan lp) {
		 System.out.println(""Operators:"");
		 Iterator<org.apache.pig.newplan.Operator> it = lp.getOperators();
		 while( it.hasNext() ) {
			 System.out.println("" op: "" + it.next().getName());
		 }
		 System.out.println();
	}
	private void checkPhysicalPlan(PhysicalPlan pp, int expectedRoots, int expectedLeaves, int expectedSize) throws IOException {
		 System.out.println(""===== check physical plan ====="");
		 showPlanOperators(pp);
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 pp.explain(out);
		 System.out.println(""===== Display Physical Plan ====="");
		 System.out.println(out.toString());
		 Assert.assertEquals(expectedRoots, pp.getRoots().size());
		 Assert.assertEquals(expectedLeaves, pp.getLeaves().size());
		 Assert.assertEquals(expectedSize, pp.size());
	 }
	 private PhysicalPlan checkPhysicalPlan(LogicalPlan lp, int expectedRoots, int expectedLeaves, int expectedSize) throws IOException {
		 lp.optimize(myPig.getPigContext());
		 System.out.println(""===== check physical plan ====="");
		 PhysicalPlan pp = ((MRExecutionEngine)myPig.getPigContext().getExecutionEngine()).compile( lp, null);
		 showPlanOperators(pp);
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 pp.explain(out);
		 System.out.println(""===== Display Physical Plan ====="");
		 System.out.println(out.toString());
		 Assert.assertEquals(expectedRoots, pp.getRoots().size());
		 Assert.assertEquals(expectedLeaves, pp.getLeaves().size());
		 Assert.assertEquals(expectedSize, pp.size());
		 return pp;
	 }
	 private MROperPlan checkMRPlan(PhysicalPlan pp, int expectedRoots, int expectedLeaves, int expectedSize) throws IOException {
		 System.out.println(""===== check map-reduce plan ====="");
		 MapRedUtil.checkLeafIsStore(pp, myPig.getPigContext());
		 MapReduceLauncher launcher = new MapReduceLauncher();
		 MROperPlan mrp = null;
		 try {
			 mrp = launcher.compile(pp, myPig.getPigContext());
			 Assert.assertNotNull(mrp);
		 }
		 catch (Exception e) {
			 PigException pe = LogUtils.getPigException(e);
			 if (pe != null) {
				 throw pe;
			 }
			 else {
				 e.printStackTrace();
				 Assert.fail();
			 }
		 }
		 showPlanOperators(mrp);
		 System.out.println(""===== Display map-reduce Plan ====="");
		 System.out.println(mrp.toString());
		 Assert.assertEquals(expectedRoots, mrp.getRoots().size());
		 Assert.assertEquals(expectedLeaves, mrp.getLeaves().size());
		 Assert.assertEquals(expectedSize, mrp.size());
		 return mrp;
	 }
	 private void deleteOutputFiles() {
		 try {
			 FileLocalizer.delete(""/tmp/output1"", myPig.getPigContext());
			 FileLocalizer.delete(""/tmp/output2"", myPig.getPigContext());
			 FileLocalizer.delete(""/tmp/output3"", myPig.getPigContext());
			 FileLocalizer.delete(""/tmp/output4"", myPig.getPigContext());
			 FileLocalizer.delete(""/tmp/output5"", myPig.getPigContext());
		 }
		 catch (IOException e) {
			 e.printStackTrace();
			 Assert.fail();
		 }
	 }
}",1,0,0,0
"public class SecuredModelImpl extends SecuredItemImpl implements SecuredModel {
	 private class SecuredModelChangedListener implements ModelChangedListener {
		 private final ModelChangedListener wrapped;
		 private SecuredModelChangedListener(final ModelChangedListener wrapped) {
			 this.wrapped = wrapped;
		 }
		 public void addedStatement(final Statement s) throws AuthenticationRequiredException {
			 if (canRead(s)) {
				 wrapped.addedStatement(s);
			 }
		 }
		 public void addedStatements(final List<Statement> statements) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.addedStatements(statements);
			 }
			 else {
				 final SecuredStatementIterator iter = new SecuredStatementIterator(holder.getSecuredItem(), WrappedIterator.create(statements.iterator()));
				 try {
					 wrapped.addedStatements(iter.toList());
				 }
				 finally {
					 iter.close();
				 }
			 }
		 }
		 public void addedStatements(final Model m) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.addedStatements(m);
			 }
			 else {
				 wrapped.addedStatements(SecuredModelImpl.getInstance(holder.getSecuredItem(), m));
			 }
		 }
		 public void addedStatements(final Statement[] statements) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.addedStatements(statements);
			 }
			 else {
				 final SecuredStatementIterator iter = new SecuredStatementIterator(holder.getSecuredItem(), WrappedIterator.create(Arrays.asList(statements).iterator()));
				 try {
					 final List<Statement> stmts = iter.toList();
					 wrapped.addedStatements(stmts.toArray(new Statement[stmts.size()]));
				 }
				 finally {
					 iter.close();
				 }
			 }
		 }
		 public void addedStatements(final StmtIterator statements) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.addedStatements(statements);
			 }
			 else {
				 final SecuredStatementIterator iter = new SecuredStatementIterator(holder.getSecuredItem(), statements);
				 try {
					 wrapped.addedStatements(iter);
				 }
				 finally {
					 iter.close();
				 }
			 }
		 }
		 public void notifyEvent(final Model m, final Object event) {
			 wrapped.notifyEvent(m, event);
		 }
		 public void removedStatement(final Statement s) throws AuthenticationRequiredException {
			 if (canRead(s)) {
				 wrapped.removedStatement(s);
			 }
		 }
		 public void removedStatements(final List<Statement> statements) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.removedStatements(statements);
			 }
			 else {
				 final SecuredStatementIterator iter = new SecuredStatementIterator(holder.getSecuredItem(), WrappedIterator.create(statements.iterator()));
				 try {
					 wrapped.removedStatements(iter.toList());
				 }
				 finally {
					 iter.close();
				 }
			 }
		 }
		 public void removedStatements(final Model m) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.removedStatements(m);
			 }
			 else {
				 wrapped.removedStatements(SecuredModelImpl.getInstance(holder.getSecuredItem(), m));
			 }
		 }
		 public void removedStatements(final Statement[] statements) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.removedStatements(statements);
			 }
			 else {
				 final SecuredStatementIterator iter = new SecuredStatementIterator(holder.getSecuredItem(), WrappedIterator.create(Arrays.asList(statements).iterator()));
				 try {
					 final List<Statement> stmts = iter.toList();
					 wrapped.removedStatements(stmts.toArray(new Statement[stmts.size()]));
				 }
				 finally {
					 iter.close();
				 }
			 }
		 }
		 public void removedStatements(final StmtIterator statements) throws AuthenticationRequiredException {
			 if (canRead(Triple.ANY)) {
				 wrapped.removedStatements(statements);
			 }
			 else {
				 final SecuredStatementIterator iter = new SecuredStatementIterator(holder.getSecuredItem(), statements);
				 try {
					 wrapped.removedStatements(iter);
				 }
				 finally {
					 iter.close();
				 }
			 }
		 }
	 }
	 private static final RDFReaderF readerFactory = new RDFReaderFImpl();
	 public static SecuredModel getInstance(final SecuredItem securedItem, final Model model) {
		 return org.apache.jena.permissions.Factory.getInstance(securedItem.getSecurityEvaluator(), securedItem.getModelIRI(), model);
	 }
	 public static SecuredModel getInstance(final SecurityEvaluator securityEvaluator, final String modelIRI, final Model model) {
		 final ItemHolder<Model, SecuredModel> holder = new ItemHolder<>(model);
		 final SecuredModelImpl checker = new SecuredModelImpl(securityEvaluator, modelIRI, holder);
		 if (model instanceof SecuredModel) {
			 if (checker.isEquivalent((SecuredModel) model)) {
				 return (SecuredModel) model;
			 }
		 }
		 return holder.setSecuredItem(new SecuredItemInvoker(model.getClass(), checker));
	 }
	 private final ItemHolder<Model, SecuredModel> holder;
	 private final SecuredGraph graph;
	 private Map<ModelChangedListener, SecuredModelChangedListener> listeners = new HashMap<>();
	 private SecuredModelImpl(final SecurityEvaluator securityEvaluator, final String modelURI, final ItemHolder<Model, SecuredModel> holder) {
		 super(securityEvaluator, modelURI, holder);
		 this.graph = org.apache.jena.permissions.Factory.getInstance(securityEvaluator, modelURI, holder.getBaseItem().getGraph());
		 this.holder = holder;
	 }
	 private SecuredStatementIterator stmtIterator(Supplier<ExtendedIterator<Statement>> supplier) throws ReadDeniedException, AuthenticationRequiredException {
		 ExtendedIterator<Statement> iter = checkSoftRead() ? supplier.get() : NiceIterator.emptyIterator();
		 return new SecuredStatementIterator(holder.getSecuredItem(), iter);
	 }
	 private SecuredResIterator resIterator(Supplier<ExtendedIterator<Resource>> supplier, ResourceFilter filter) {
		 ExtendedIterator<Resource> rIter = null;
		 if (checkSoftRead()) {
			 rIter = supplier.get();
			 if (!canRead(Triple.ANY)) {
				 rIter = rIter.filterKeep(filter);
			 }
		 }
		 else {
			 rIter = NiceIterator.emptyIterator();
		 }
		 return new SecuredResIterator(holder.getSecuredItem(), rIter);
	 }
	 private RDFNode asObject(Object o) {
		 return o instanceof RDFNode ? (RDFNode) o : ResourceFactory.createTypedLiteral(o);
	 }
	 public SecuredModel abort() {
		 holder.getBaseItem().abort();
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final List<Statement> statements) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(() -> WrappedIterator.create(statements.iterator()).mapWith(s -> s.asTriple()));
		 holder.getBaseItem().add(statements);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Model m) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(() -> m.listStatements().mapWith(s -> s.asTriple()));
		 holder.getBaseItem().add(m);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Resource s, final Property p, final RDFNode o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(s.asNode(), p.asNode(), o.asNode()));
		 holder.getBaseItem().add(s, p, o);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Resource s, final Property p, final String o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, o, false);
	 }
	 public SecuredModel add(final Resource s, final Property p, final String o, final boolean wellFormed) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(s.asNode(), p.asNode(), NodeFactory.createLiteral(o, """", wellFormed)));
		 holder.getBaseItem().add(s, p, o, wellFormed);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Resource s, final Property p, final String lex, final RDFDatatype datatype) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(s.asNode(), p.asNode(), NodeFactory.createLiteral(lex, datatype)));
		 holder.getBaseItem().add(s, p, lex, datatype);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Resource s, final Property p, final String o, final String l) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(s.asNode(), p.asNode(), NodeFactory.createLiteral(o, l, false)));
		 holder.getBaseItem().add(s, p, o, l);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Statement s) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(s);
		 holder.getBaseItem().add(s);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final Statement[] statements) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(() -> WrappedIterator.create(Arrays.asList(statements).iterator()).mapWith(s -> s.asTriple()));
		 holder.getBaseItem().add(statements);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel add(final StmtIterator iter) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 StmtIterator updateFrom = iter;
		 if (!canCreate(Triple.ANY)) {
			 List<Statement> stmt = iter.filterKeep(s -> {
				 checkCreate(s);
				 return true;
			 }
			).toList();
			 updateFrom = new StmtIteratorImpl(stmt.iterator());
		 }
		 holder.getBaseItem().add(updateFrom);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final boolean o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final char o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final double o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final float o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final int o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final Literal o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, o);
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final long o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredModel addLiteral(final Resource s, final Property p, final Object o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return add(s, p, asObject(o));
	 }
	 public SecuredRDFNode asRDFNode(final Node n) {
		 return SecuredRDFNodeImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().asRDFNode(n));
	 }
	 public SecuredStatement asStatement(final Triple t) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 final ExtendedIterator<Triple> iter = holder.getBaseItem().getGraph().find(t);
		 final boolean exists = iter.hasNext();
		 iter.close();
		 if ((exists && canRead() && canRead(t)) || (canUpdate() && canCreate(t))) {
			 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().asStatement(t));
		 }
		 throw new AccessDeniedException(String.format(""Converting %s to Statement"", t));
	 }
	 public SecuredModel begin() {
		 holder.getBaseItem().begin();
		 return holder.getSecuredItem();
	 }
	 public void close() {
		 holder.getBaseItem().close();
	 }
	 public SecuredModel commit() {
		 holder.getBaseItem().commit();
		 return holder.getSecuredItem();
	 }
	 private boolean containsAny(Supplier<ExtendedIterator<Statement>> supplier) {
		 if (checkSoftRead()) {
			 ExtendedIterator<Statement> iter = supplier.get();
			 try {
				 return iter.filterKeep(stmt -> canRead(stmt)).hasNext();
			 }
			 finally {
				 iter.close();
			 }
		 }
		 return false;
	 }
	 public boolean contains(final Resource s, final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return containsAny(() -> holder.getBaseItem().listStatements(s, p, (RDFNode) null));
	 }
	 public boolean contains(final Resource s, final Property p, final RDFNode o) throws ReadDeniedException, AuthenticationRequiredException {
		 return containsAny(() -> holder.getBaseItem().listStatements(s, p, o));
	 }
	 public boolean contains(final Resource s, final Property p, final String o) throws ReadDeniedException, AuthenticationRequiredException {
		 return containsAny(() -> holder.getBaseItem().listStatements(s, p, o));
	 }
	 public boolean contains(final Resource s, final Property p, final String o, final String l) throws ReadDeniedException, AuthenticationRequiredException {
		 return containsAny(() -> holder.getBaseItem().listStatements(s, p, o, l));
	 }
	 public boolean contains(final Statement s) throws ReadDeniedException, AuthenticationRequiredException {
		 return (checkSoftRead() && canRead(s)) ? holder.getBaseItem().contains(s) : false;
	 }
	 private boolean containsAll(Supplier<StmtIterator> supplier) {
		 StmtIterator iter = supplier.get();
		 try {
			 while (iter.hasNext()) {
				 Statement stmt = iter.next();
				 if (!canRead(stmt) || !holder.getBaseItem().contains(stmt)) {
					 return false;
				 }
			 }
		 }
		 finally {
			 iter.close();
		 }
		 return true;
	 }
	 public boolean containsAll(final Model model) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().containsAll(model);
			 }
			 return containsAll(() -> model.listStatements());
		 }
		 return false;
	 }
	 public boolean containsAll(final StmtIterator iter) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().containsAll(iter);
			 }
			 return containsAll(() -> iter);
		 }
		 return false;
	 }
	 public boolean containsAny(final Model model) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().containsAll(model);
			 }
			 containsAny(() -> model.listStatements());
		 }
		 return false;
	 }
	 public boolean containsAny(final StmtIterator iter) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().containsAny(iter);
			 }
			 containsAny(() -> iter);
		 }
		 return false;
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final boolean o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final char o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final double o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final float o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final int o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final long o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public boolean containsLiteral(final Resource s, final Property p, final Object o) throws ReadDeniedException, AuthenticationRequiredException {
		 return contains(s, p, asObject(o));
	 }
	 public boolean containsResource(final RDFNode r) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().containsResource(r);
			 }
			 ExtendedIterator<Statement> iter = listStatements(null, null, r);
			 if (r.isResource()) {
				 if (r.isURIResource()) {
					 iter = iter.andThen( listStatements(null, ResourceFactory.createProperty(r.asNode().getURI()), (RDFNode) null));
				 }
				 else {
					 iter = iter.andThen(listStatements(null, ResourceFactory.createProperty(r.asNode().getBlankNodeLabel()), (RDFNode) null));
				 }
				 iter = iter.andThen(listStatements(r.asResource(), null, (RDFNode) null));
			 }
			 try {
				 return iter.hasNext();
			 }
			 finally {
				 iter.close();
			 }
		 }
		 return false;
	 }
	 public SecuredAlt createAlt() throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.type.asNode(), RDF.Alt.asNode()));
		 return SecuredAltImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createAlt());
	 }
	 public SecuredAlt createAlt(final String uri) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(NodeFactory.createURI(uri), RDF.type.asNode(), RDF.Alt.asNode()));
		 return SecuredAltImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createAlt(uri));
	 }
	 public SecuredBag createBag() throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.type.asNode(), RDF.Bag.asNode()));
		 return SecuredBagImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createBag());
	 }
	 public SecuredBag createBag(final String uri) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(NodeFactory.createURI(uri), RDF.type.asNode(), RDF.Bag.asNode()));
		 return SecuredBagImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createBag(uri));
	 }
	 private Model createCopy() throws ReadDeniedException, AuthenticationRequiredException {
		 return ModelFactory.createDefaultModel().add(holder.getSecuredItem());
	 }
	 public SecuredRDFList createList() throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.type.asNode(), RDF.List.asNode()));
		 return SecuredRDFListImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createList());
	 }
	 private SecuredRDFList createList(Supplier<ExtendedIterator<? extends RDFNode>> supplier) {
		 checkUpdate();
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.type.asNode(), RDF.List.asNode()));
		 ExtendedIterator<? extends RDFNode> iter = supplier.get();
		 List<RDFNode> lst = new ArrayList<RDFNode>();
		 try {
			 if (iter.hasNext()) {
				 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.rest.asNode(), RDF.nil.asNode()));
				 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.rest.asNode(), SecurityEvaluator.FUTURE));
			 }
			 while (iter.hasNext()) {
				 RDFNode n = iter.next();
				 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), n.asNode()));
				 lst.add(n);
			 }
			 return SecuredRDFListImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createList(lst.iterator()));
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public SecuredRDFList createList(final Iterator<? extends RDFNode> members) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return createList(() -> WrappedIterator.create(members));
	 }
	 public SecuredRDFList createList(RDFNode... members) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return createList(() -> WrappedIterator.create(Arrays.asList(members).iterator()));
	 }
	 public SecuredLiteral createLiteral(final String v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createLiteral(v));
	 }
	 public SecuredLiteral createLiteral(final String v, final boolean wellFormed) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createLiteral(v, wellFormed));
	 }
	 public SecuredLiteral createLiteral(final String v, final String language) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createLiteral(v, language));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final boolean o) {
		 return createStatement(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final char o) {
		 return createStatement(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final double o) {
		 return createStatement(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final float o) {
		 return createStatement(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final int o) {
		 return createStatement(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final long o) {
		 return createStatement(s, p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredStatement createLiteralStatement(final Resource s, final Property p, final Object o) {
		 return createStatement(s, p, asObject(o));
	 }
	 public SecuredProperty createProperty(final String uri) {
		 return SecuredPropertyImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createProperty(uri));
	 }
	 public SecuredProperty createProperty(final String nameSpace, final String localName) {
		 return SecuredPropertyImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createProperty(nameSpace, localName));
	 }
	 public SecuredReifiedStatement createReifiedStatement(final Statement s) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkCreateReified(null, s);
		 return SecuredReifiedStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createReifiedStatement(s));
	 }
	 public SecuredReifiedStatement createReifiedStatement(final String uri, final Statement s) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkCreateReified(uri, s);
		 return SecuredReifiedStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createReifiedStatement(uri, s));
	 }
	 public SecuredResource createResource() {
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource());
	 }
	 public SecuredResource createResource(final AnonId id) {
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource(id));
	 }
	 public SecuredResource createResource(final Resource type) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 final Triple t = Triple.create(SecurityEvaluator.FUTURE, RDF.type.asNode(), type.asNode());
		 checkCreate(t);
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource(type));
	 }
	 public SecuredResource createResource(final ResourceF f) throws AuthenticationRequiredException {
		 return createResource(null, f);
	 }
	 public SecuredResource createResource(final String uri) {
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource(uri));
	 }
	 public Resource createResource(Statement statement) {
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource(statement));
	 }
	 private void checkReadOrUpdate(Resource s, Property p, RDFNode o) {
		 if (!canReadOrUpdate(s, p, o)) {
			 throw new AddDeniedException(String.format(""Can not create Statement [ %s ,%s %s ]"", s, p, o));
		 }
	 }
	 private boolean canReadOrUpdate(Resource s, Property p, RDFNode o) {
		 Triple t = Triple.create(s.asNode(), p.asNode(), o.asNode());
		 boolean canExecute = canUpdate() && canCreate(t);
		 if (!canExecute && holder.getBaseItem().contains(s, p, o)) {
			 canExecute |= (canRead() && canRead(t));
		 }
		 return canExecute;
	 }
	 public SecuredResource createResource(final String uri, final Resource type) throws AccessDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(ResourceFactory.createResource(uri), RDF.type, type);
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource(uri, type));
	 }
	 public SecuredResource createResource(final String uri, final ResourceF f) {
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createResource(uri, f));
	 }
	 public SecuredSeq createSeq() throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.type.asNode(), RDF.Alt.asNode()));
		 return SecuredSeqImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createSeq());
	 }
	 public SecuredSeq createSeq(final String uri) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(ResourceFactory.createResource(uri), RDF.type, RDF.Alt);
		 return SecuredSeqImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createSeq(uri));
	 }
	 public SecuredStatement createStatement(final Resource s, final Property p, final RDFNode o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(s, p, o);
		 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createStatement(s, p, o));
	 }
	 public SecuredStatement createStatement(final Resource s, final Property p, final String o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(s, p, ResourceFactory.createProperty(o));
		 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createStatement(s, p, o));
	 }
	 public SecuredStatement createStatement(final Resource s, final Property p, final String o, final boolean wellFormed) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return createStatement(s, p, o, """", wellFormed);
	 }
	 public SecuredStatement createStatement(final Resource s, final Property p, final String o, final String l) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return createStatement(s, p, o, l, false);
	 }
	 public SecuredStatement createStatement(final Resource s, final Property p, final String o, final String l, final boolean wellFormed) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 Node n = NodeFactory.createLiteral(o, l, wellFormed);
		 checkReadOrUpdate(s, p, holder.getBaseItem().getRDFNode(n));
		 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createStatement(s, p, o, l, wellFormed));
	 }
	 public SecuredLiteral createTypedLiteral(final boolean v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final Calendar d) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(d));
	 }
	 public SecuredLiteral createTypedLiteral(final char v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final double v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final float v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final int v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final long v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final Object value) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(value));
	 }
	 public SecuredLiteral createTypedLiteral(final Object value, final RDFDatatype dtype) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(value, dtype));
	 }
	 public SecuredLiteral createTypedLiteral(final Object value, final String typeURI) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(value, typeURI));
	 }
	 public SecuredLiteral createTypedLiteral(final String v) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(v));
	 }
	 public SecuredLiteral createTypedLiteral(final String lex, final RDFDatatype dtype) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(lex, dtype));
	 }
	 public SecuredLiteral createTypedLiteral(final String lex, final String typeURI) {
		 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().createTypedLiteral(lex, typeURI));
	 }
	 public Model difference(final Model model) throws AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().difference(model);
			 }
			 return createCopy().difference(model);
		 }
		 return ModelFactory.createDefaultModel();
	 }
	 public void enterCriticalSection(final boolean readLockRequested) throws UpdateDeniedException, ReadDeniedException, AuthenticationRequiredException {
		 holder.getBaseItem().enterCriticalSection(readLockRequested);
	 }
	 public void executeInTxn(Runnable action) {
		 holder.getBaseItem().executeInTxn(action);
	 }
	 public <T> T calculateInTxn(Supplier<T> action) {
		 return holder.getBaseItem().calculateInTxn(action);
	 }
	 public String expandPrefix(final String prefixed) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().expandPrefix(prefixed) : prefixed;
	 }
	 public SecuredAlt getAlt(final Resource r) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(r, RDF.type, RDF.Alt);
		 return SecuredAltImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getAlt(r));
	 }
	 public SecuredAlt getAlt(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(ResourceFactory.createResource(uri), RDF.type, RDF.Alt);
		 return SecuredAltImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getAlt(uri));
	 }
	 public SecuredReifiedStatement getAnyReifiedStatement(final Statement s) throws ReadDeniedException, UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 if (canRead()) {
			 final RSIterator it = listReifiedStatements(s);
			 if (it.hasNext()) {
				 try {
					 return SecuredReifiedStatementImpl.getInstance(holder.getSecuredItem(), it.nextRS());
				 }
				 finally {
					 it.close();
				 }
			 }
		 }
		 return createReifiedStatement(s);
	 }
	 public SecuredBag getBag(final Resource r) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(r, RDF.type, RDF.Bag);
		 return SecuredBagImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getBag(r));
	 }
	 public SecuredBag getBag(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(ResourceFactory.createResource(uri), RDF.type, RDF.Bag);
		 return SecuredBagImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getBag(uri));
	 }
	 public SecuredSeq getSeq(final Resource r) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(r, RDF.type, RDF.Seq);
		 return SecuredSeqImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getSeq(r));
	 }
	 public SecuredSeq getSeq(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(ResourceFactory.createResource(uri), RDF.type, RDF.Seq);
		 return SecuredSeqImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getSeq(uri));
	 }
	 public SecuredRDFList getList(String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(ResourceFactory.createResource(uri), RDF.type, RDF.List);
		 return SecuredRDFListImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getList(uri));
	 }
	 public SecuredRDFList getList(Resource r) throws ReadDeniedException, AuthenticationRequiredException {
		 checkReadOrUpdate(r, RDF.type, RDF.List);
		 return SecuredRDFListImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getList(r));
	 }
	 public SecuredGraph getGraph() {
		 return graph;
	 }
	 public Lock getLock() {
		 return holder.getBaseItem().getLock();
	 }
	 public Map<String, String> getNsPrefixMap() throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().getNsPrefixMap() : Collections.emptyMap();
	 }
	 public String getNsPrefixURI(final String prefix) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().getNsPrefixURI(prefix) : null;
	 }
	 public String getNsURIPrefix(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().getNsURIPrefix(uri) : null;
	 }
	 private SecuredStatement _getProperty(Supplier<StmtIterator> supplier) {
		 if (checkSoftRead()) {
			 ExtendedIterator<Statement> iter = supplier.get().filterKeep(s -> canRead(s));
			 try {
				 return iter.hasNext() ? SecuredStatementImpl.getInstance(holder.getSecuredItem(), iter.next()) : null;
			 }
			 finally {
				 iter.close();
			 }
		 }
		 return null;
	 }
	 public SecuredStatement getProperty(final Resource s, final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return _getProperty(() -> holder.getBaseItem().listStatements(s, p, (RDFNode) null));
	 }
	 public SecuredStatement getProperty(Resource s, Property p, String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 return _getProperty(() -> holder.getBaseItem().listStatements(s, p, null, lang));
	 }
	 public SecuredProperty getProperty(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 return SecuredPropertyImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getProperty(uri));
	 }
	 public SecuredProperty getProperty(final String nameSpace, final String localName) throws ReadDeniedException, AuthenticationRequiredException {
		 return SecuredPropertyImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getProperty(nameSpace, localName));
	 }
	 public SecuredRDFNode getRDFNode(final Node n) throws ReadDeniedException, UpdateDeniedException, AuthenticationRequiredException {
		 if (n.isLiteral()) {
			 return SecuredLiteralImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getRDFNode(n).asLiteral());
		 }
		 else if (n.isURI() || n.isBlank()) {
			 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getRDFNode(n).asResource());
		 }
		 throw new IllegalArgumentException(""Illegal Node type: "" + n.getClass());
	 }
	 public RDFReaderI getReader() {
		 return holder.getBaseItem().getReader();
	 }
	 public RDFReaderI getReader(final String lang) {
		 return holder.getBaseItem().getReader(lang);
	 }
	 public SecuredStatement getRequiredProperty(final Resource s, final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getRequiredProperty(s, p));
			 }
			 ExtendedIterator<Statement> iter = holder.getBaseItem().listStatements(s, p, (RDFNode) null) .filterKeep(f -> canRead(f));
			 try {
				 if (iter.hasNext()) {
					 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), iter.next());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 throw new PropertyNotFoundException(p);
	 }
	 public SecuredStatement getRequiredProperty(final Resource s, final Property p, String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().getRequiredProperty(s, p, lang));
			 }
			 ExtendedIterator<Statement> iter = holder.getBaseItem().listStatements(s, p, null, lang) .filterKeep(f -> canRead(f));
			 try {
				 if (iter.hasNext()) {
					 return SecuredStatementImpl.getInstance(holder.getSecuredItem(), iter.next());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 throw new PropertyNotFoundException(p);
	 }
	 public SecuredResource getResource(final String uri) {
		 return createResource(uri);
	 }
	 public SecuredResource getResource(final String uri, final ResourceF f) {
		 return createResource(uri, f);
	 }
	 public RDFWriterI getWriter() {
		 return holder.getBaseItem().getWriter();
	 }
	 public RDFWriterI getWriter(final String lang) {
		 return holder.getBaseItem().getWriter(lang);
	 }
	 public boolean independent() {
		 return false;
	 }
	 public Model intersection(final Model model) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 return canRead(Triple.ANY) ? holder.getBaseItem().intersection(model) : createCopy().intersection(model);
		 }
		 return ModelFactory.createDefaultModel();
	 }
	 public boolean isClosed() {
		 return holder.getBaseItem().isClosed();
	 }
	 public boolean isEmpty() throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? !holder.getBaseItem().contains(holder.getBaseItem().asStatement(Triple.ANY)) : true;
	 }
	 public boolean isIsomorphicWith(final Model g) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().isIsomorphicWith(g);
			 }
			 return createCopy().isIsomorphicWith(g);
		 }
		 return g.isEmpty();
	 }
	 public boolean isReified(final Statement s) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(s)) {
			 return holder.getBaseItem().isReified(s);
		 }
		 return false;
	 }
	 public void leaveCriticalSection() {
		 holder.getBaseItem().leaveCriticalSection();
	 }
	 public SecuredStatementIterator listLiteralStatements(final Resource subject, final Property predicate, final boolean object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listLiteralStatements(subject, predicate, object));
	 }
	 public SecuredStatementIterator listLiteralStatements(final Resource subject, final Property predicate, final char object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listLiteralStatements(subject, predicate, object));
	 }
	 public SecuredStatementIterator listLiteralStatements(final Resource subject, final Property predicate, final double object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listLiteralStatements(subject, predicate, object));
	 }
	 public SecuredStatementIterator listLiteralStatements(final Resource subject, final Property predicate, final float object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listLiteralStatements(subject, predicate, object));
	 }
	 public SecuredStatementIterator listLiteralStatements(final Resource subject, final Property predicate, final long object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listLiteralStatements(subject, predicate, object));
	 }
	 public SecuredStatementIterator listLiteralStatements(final Resource subject, final Property predicate, final int object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listLiteralStatements(subject, predicate, object));
	 }
	 public NsIterator listNameSpaces() throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().listNameSpaces() : new NsIteratorImpl(Collections.emptyIterator(), null);
	 }
	 private SecuredNodeIterator<RDFNode> nodeIterator(Supplier<ExtendedIterator<RDFNode>> supplier, Predicate<RDFNode> filter) {
		 ExtendedIterator<RDFNode> nIter = null;
		 if (checkSoftRead()) {
			 nIter = supplier.get();
			 if (!canRead(Triple.ANY)) {
				 nIter = nIter.filterKeep(filter);
			 }
		 }
		 else {
			 nIter = NiceIterator.emptyIterator();
		 }
		 return new SecuredNodeIterator<>(holder.getSecuredItem(), nIter);
	 }
	 public SecuredNodeIterator<RDFNode> listObjects() throws ReadDeniedException, AuthenticationRequiredException {
		 return nodeIterator(() -> holder.getBaseItem().listObjects(), new ObjectFilter());
	 }
	 public SecuredNodeIterator<RDFNode> listObjectsOfProperty(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return nodeIterator(() -> holder.getBaseItem().listObjectsOfProperty(p), new ObjectFilter(p));
	 }
	 public SecuredNodeIterator<RDFNode> listObjectsOfProperty(final Resource s, final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return nodeIterator(() -> holder.getBaseItem().listObjectsOfProperty(s, p), new ObjectFilter(p));
	 }
	 private SecuredRSIterator reifiedIterator(Supplier<ExtendedIterator<ReifiedStatement>> supplier) {
		 ExtendedIterator<ReifiedStatement> iter = checkSoftRead() ? supplier.get() : NiceIterator.emptyIterator();
		 return new SecuredRSIterator(holder.getSecuredItem(), iter);
	 }
	 public SecuredRSIterator listReifiedStatements() throws ReadDeniedException, AuthenticationRequiredException {
		 return reifiedIterator(() -> holder.getBaseItem().listReifiedStatements());
	 }
	 public SecuredRSIterator listReifiedStatements(final Statement st) throws ReadDeniedException, AuthenticationRequiredException {
		 return reifiedIterator(() -> holder.getBaseItem().listReifiedStatements(st));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p), new ResourceFilter(p));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final boolean o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createTypedLiteral(o)));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final char o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createTypedLiteral(o)));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final double o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createTypedLiteral(o)));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final float o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createTypedLiteral(o)));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final long o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createTypedLiteral(o)));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final Object o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createTypedLiteral(o)));
	 }
	 public SecuredResIterator listResourcesWithProperty(final Property p, final RDFNode o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listResourcesWithProperty(p, o), new ResourceFilter(p, o));
	 }
	 public SecuredStatementIterator listStatements() throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listStatements());
	 }
	 public SecuredStatementIterator listStatements(final Resource s, final Property p, final RDFNode o) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listStatements(s, p, o));
	 }
	 public SecuredStatementIterator listStatements(final Resource subject, final Property predicate, final String object) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listStatements(subject, predicate, object));
	 }
	 public SecuredStatementIterator listStatements(final Resource subject, final Property predicate, final String object, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listStatements(subject, predicate, object, lang));
	 }
	 public SecuredStatementIterator listStatements(final Selector s) throws ReadDeniedException, AuthenticationRequiredException {
		 return stmtIterator(() -> holder.getBaseItem().listStatements(s));
	 }
	 public SecuredResIterator listSubjects() throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listSubjects(), new ResourceFilter());
	 }
	 public SecuredResIterator listSubjectsWithProperty(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listSubjectsWithProperty(p), new ResourceFilter(p));
	 }
	 public SecuredResIterator listSubjectsWithProperty(final Property p, final RDFNode o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listSubjectsWithProperty(p, o), new ResourceFilter(p, o));
	 }
	 public SecuredResIterator listSubjectsWithProperty(final Property p, final String o) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listSubjectsWithProperty(p, o), new ResourceFilter(p, ResourceFactory.createPlainLiteral(o)));
	 }
	 public SecuredResIterator listSubjectsWithProperty(final Property p, final String o, final String l) throws ReadDeniedException, AuthenticationRequiredException {
		 return resIterator(() -> holder.getBaseItem().listSubjectsWithProperty(p, o, l), new ResourceFilter(p, ResourceFactory.createLangLiteral(o, l)));
	 }
	 public SecuredPrefixMapping lock() throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().lock();
		 return holder.getSecuredItem();
	 }
	 public SecuredModel notifyEvent(final Object e) {
		 holder.getBaseItem().notifyEvent(e);
		 return holder.getSecuredItem();
	 }
	 public String qnameFor(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().qnameFor(uri) : null;
	 }
	 public Model query(final Selector s) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().query(new SecuredSelector(holder.getSecuredItem(), s)) : ModelFactory.createDefaultModel();
	 }
	 public SecuredModel read(final InputStream in, final String base) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredModelImpl.readerFactory.getReader().read(holder.getSecuredItem(), in, base);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel read(final InputStream in, final String base, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredModelImpl.readerFactory.getReader(lang).read(holder.getSecuredItem(), in, base);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel read(final Reader reader, final String base) throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredModelImpl.readerFactory.getReader().read(holder.getSecuredItem(), reader, base);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel read(final Reader reader, final String base, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredModelImpl.readerFactory.getReader(lang).read(holder.getSecuredItem(), reader, base);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel read(final String url) throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredModelImpl.readerFactory.getReader().read(holder.getSecuredItem(), url);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel read(final String url, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredModelImpl.readerFactory.getReader(lang).read(holder.getSecuredItem(), url);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel read(final String url, final String base, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 try (InputStream is = new URL(url).openStream()) {
			 read(is, base, lang);
		 }
		 catch (final IOException e) {
			 throw new WrappedIOException(e);
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel register(final ModelChangedListener listener) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (!listeners.containsKey(listener)) {
				 final SecuredModelChangedListener secL = new SecuredModelChangedListener(listener);
				 listeners.put(listener, secL);
				 holder.getBaseItem().register(secL);
			 }
			 return holder.getSecuredItem();
		 }
		 throw new ReadDeniedException(SecuredItem.Util.modelPermissionMsg(getModelNode()));
	 }
	 public SecuredModel remove(final List<Statement> statements) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.ANY)) {
			 for (final Statement s : statements) {
				 checkDelete(s);
			 }
		 }
		 holder.getBaseItem().remove(statements);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel remove(final Model m) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.ANY)) {
			 final StmtIterator iter = m.listStatements();
			 try {
				 while (iter.hasNext()) {
					 final Statement stmt = iter.next();
					 checkDelete(stmt);
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 holder.getBaseItem().remove(m);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel remove(final Resource s, final Property p, final RDFNode o) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkDelete(Triple.create(s.asNode(), p.asNode(), o.asNode()));
		 holder.getBaseItem().remove(s, p, o);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel remove(final Statement s) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkDelete(wildCardTriple(s));
		 holder.getBaseItem().remove(s);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel remove(final Statement[] statements) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.ANY)) {
			 for (final Statement s : statements) {
				 checkDelete(s);
			 }
		 }
		 holder.getBaseItem().remove(statements);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel remove(final StmtIterator iter) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.ANY)) {
			 final List<Triple> lst = new ArrayList<>();
			 try {
				 while (iter.hasNext()) {
					 final Statement s = iter.next();
					 checkDelete(s);
					 lst.add(s.asTriple());
				 }
				 final Model m = ModelFactory.createModelForGraph(new CollectionGraph(lst));
				 holder.getBaseItem().remove(m.listStatements());
			 }
			 finally {
				 iter.close();
			 }
		 }
		 else {
			 holder.getBaseItem().remove(iter);
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel removeAll() throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.ANY)) {
			 final StmtIterator iter = holder.getBaseItem().listStatements();
			 try {
				 while (iter.hasNext()) {
					 checkDelete(iter.next());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 holder.getBaseItem().removeAll();
		 return holder.getSecuredItem();
	 }
	 public SecuredModel removeAll(final Resource s, final Property p, final RDFNode r) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.create(wildCardNode(s), wildCardNode(p), wildCardNode(r)))) {
			 final StmtIterator iter = holder.getBaseItem().listStatements(s, p, r);
			 try {
				 while (iter.hasNext()) {
					 checkDelete(iter.next());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 holder.getBaseItem().removeAll(s, p, r);
		 return holder.getSecuredItem();
	 }
	 public void removeAllReifications(final Statement s) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (canDelete(Triple.create(Node.ANY, RDF.subject.asNode(), wildCardNode(s.getSubject()))) && canDelete(Triple.create(Node.ANY, RDF.predicate.asNode(), wildCardNode(s.getPredicate()))) && canDelete(Triple.create(Node.ANY, RDF.object.asNode(), wildCardNode(s.getObject())))) {
			 holder.getBaseItem().removeAllReifications(s);
		 }
		 else {
			 final RSIterator iter = holder.getBaseItem().listReifiedStatements(s);
			 try {
				 while (iter.hasNext()) {
					 final ReifiedStatement rs = iter.next();
					 checkDelete(Triple.create(rs.asNode(), RDF.subject.asNode(), wildCardNode(s.getSubject())));
					 checkDelete(Triple.create(rs.asNode(), RDF.predicate.asNode(), wildCardNode(s.getPredicate())));
					 checkDelete(Triple.create(rs.asNode(), RDF.object.asNode(), wildCardNode(s.getObject())));
				 }
				 holder.getBaseItem().removeAllReifications(s);
			 }
			 finally {
				 iter.close();
			 }
		 }
	 }
	 public SecuredModel removeNsPrefix(final String prefix) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().removeNsPrefix(prefix);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel clearNsPrefixMap() {
		 checkUpdate();
		 holder.getBaseItem().clearNsPrefixMap();
		 return holder.getSecuredItem();
	 }
	 public void removeReification(final ReifiedStatement rs) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.ANY)) {
			 final StmtIterator stmtIter = rs.listProperties();
			 try {
				 while (stmtIter.hasNext()) {
					 checkDelete(stmtIter.next());
				 }
			 }
			 finally {
				 stmtIter.close();
			 }
		 }
		 holder.getBaseItem().removeReification(rs);
	 }
	 public boolean samePrefixMappingAs(final PrefixMapping other) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().samePrefixMappingAs(other) : other.hasNoMappings();
	 }
	 public SecuredModel setNsPrefix(final String prefix, final String uri) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().setNsPrefix(prefix, uri);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel setNsPrefixes(final Map<String, String> map) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().setNsPrefixes(map);
		 return holder.getSecuredItem();
	 }
	 public SecuredModel setNsPrefixes(final PrefixMapping other) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().setNsPrefixes(other);
		 return holder.getSecuredItem();
	 }
	 public String shortForm(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().shortForm(uri) : uri;
	 }
	 public boolean hasNoMappings() {
		 return checkSoftRead() ? holder.getBaseItem().hasNoMappings() : true;
	 }
	 public int numPrefixes() {
		 return checkSoftRead() ? holder.getBaseItem().numPrefixes() : 0;
	 }
	 public long size() throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().size();
			 }
			 return createCopy().size();
		 }
		 return 0;
	 }
	 public boolean supportsSetOperations() {
		 return holder.getBaseItem().supportsSetOperations();
	 }
	 public boolean supportsTransactions() {
		 return holder.getBaseItem().supportsTransactions();
	 }
	 public Model union(final Model model) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 return holder.getBaseItem().union(model);
			 }
			 return createCopy().union(model);
		 }
		 return ModelFactory.createDefaultModel().add(model);
	 }
	 public SecuredModel unregister(final ModelChangedListener listener) {
		 if (listeners.containsKey(listener)) {
			 final SecuredModelChangedListener secL = listeners.get(listener);
			 holder.getBaseItem().unregister(secL);
			 listeners.remove(listener);
		 }
		 return holder.getSecuredItem();
	 }
	 private Node wildCardNode(final RDFNode node) {
		 return node == null ? Node.ANY : node.asNode();
	 }
	 private Triple wildCardTriple(final Statement s) {
		 return Triple.create(wildCardNode(s.getSubject()), wildCardNode(s.getPredicate()), wildCardNode(s.getObject()));
	 }
	 public SecuredModel withDefaultMappings(final PrefixMapping map) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().withDefaultMappings(map);
		 return holder.getSecuredItem();
	 }
	 public SecuredResource wrapAsResource(final Node n) {
		 return SecuredResourceImpl.getInstance(holder.getSecuredItem(), holder.getBaseItem().wrapAsResource(n));
	 }
	 public SecuredModel write(final OutputStream out) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 holder.getBaseItem().write(out);
			 }
			 else {
				 getWriter().write(holder.getSecuredItem(), out, """");
			 }
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel write(final OutputStream out, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 holder.getBaseItem().write(out, lang);
			 }
			 else {
				 getWriter(lang).write(holder.getSecuredItem(), out, """");
			 }
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel write(final OutputStream out, final String lang, final String base) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 holder.getBaseItem().write(out, lang, base);
			 }
			 else {
				 getWriter(lang).write(holder.getSecuredItem(), out, base);
			 }
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel write(final Writer writer) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 holder.getBaseItem().write(writer);
			 }
			 else {
				 getWriter().write(holder.getSecuredItem(), writer, """");
			 }
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel write(final Writer writer, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 holder.getBaseItem().write(writer, lang);
			 }
			 else {
				 getWriter(lang).write(holder.getSecuredItem(), writer, """");
			 }
		 }
		 return holder.getSecuredItem();
	 }
	 public SecuredModel write(final Writer writer, final String lang, final String base) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 if (canRead(Triple.ANY)) {
				 holder.getBaseItem().write(writer, lang, base);
			 }
			 else {
				 getWriter(lang).write(holder.getSecuredItem(), writer, base);
			 }
		 }
		 return holder.getSecuredItem();
	 }
	 private class ResourceFilter implements Predicate<Resource> {
		 Property p;
		 RDFNode o;
		 ResourceFilter() {
			 this(null, null);
		 }
		 ResourceFilter(Property p) {
			 this(p, null);
		 }
		 ResourceFilter(Property p, RDFNode o) {
			 this.p = p;
			 this.o = o;
		 }
		 public boolean test(Resource s) {
			 StmtIterator iter = listStatements(s, p, o);
			 try {
				 return iter.hasNext();
			 }
			 finally {
				 iter.close();
			 }
		 }
	 }
	 private class ObjectFilter implements Predicate<RDFNode> {
		 Resource s;
		 Property p;
		 ObjectFilter() {
			 this(null, null);
		 }
		 ObjectFilter(Property p) {
			 this(null, p);
		 }
		 ObjectFilter(Resource s, Property p) {
			 this.s = s;
			 this.p = p;
		 }
		 public boolean test(RDFNode o) {
			 StmtIterator iter = listStatements(s, p, o);
			 try {
				 return iter.hasNext();
			 }
			 finally {
				 iter.close();
			 }
		 }
	 }
}",1,0,0,0
"public class MessageStatisticsBean {
	 private int fromID;
	 private int toID;
	 private Timestamp messageCreationDate;
	 private int messageAttachCount;
	 private int messageType;
	 private int messageOption;
	 private int messageStatus;
	 public int getFromID() {
		 return fromID;
	 }
	 public void setFromID(int fromID) {
		 this.fromID = fromID;
	 }
	 public int getToID() {
		 return toID;
	 }
	 public void setToID(int toID) {
		 this.toID = toID;
	 }
	 public Timestamp getMessageCreationDate() {
		 return messageCreationDate;
	 }
	 public void setMessageCreationDate(Timestamp messageCreationDate) {
		 this.messageCreationDate = messageCreationDate;
	 }
	 public int getMessageAttachCount() {
		 return messageAttachCount;
	 }
	 public void setMessageAttachCount(int messageAttachCount) {
		 this.messageAttachCount = messageAttachCount;
	 }
	 public int getMessageType() {
		 return messageType;
	 }
	 public void setMessageType(int messageType) {
		 this.messageType = messageType;
	 }
	 public int getMessageOption() {
		 return messageOption;
	 }
	 public void setMessageOption(int messageOption) {
		 this.messageOption = messageOption;
	 }
	 public int getMessageStatus() {
		 return messageStatus;
	 }
	 public void setMessageStatus(int messageStatus) {
		 this.messageStatus = messageStatus;
	 }
}",0,1,0,0
"public class RabbitBusCleaner implements BusCleaner {
	private final static Logger logger = LoggerFactory.getLogger(RabbitBusCleaner.class);
	public Map<String, List<String>> clean(String entity, boolean isJob) {
	return clean(""http:}
	public Map<String, List<String>> clean(String adminUri, String user, String pw, String vhost,String busPrefix, String entity, boolean isJob) {
		return doClean(adminUri == null ? ""http:user == null ? ""guest"" : user,pw == null ? ""guest"" : pw,vhost == null ? ""/"" : vhost,busPrefix == null ? ""xdbus."" : busPrefix,entity, isJob);
	}
	private Map<String, List<String>> doClean(String adminUri, String user, String pw, String vhost,String busPrefix, String entity, boolean isJob) {
		RestTemplate restTemplate = RabbitManagementUtils.buildRestTemplate(adminUri, user, pw);
		List<String> removedQueues = isJob? findJobQueues(adminUri, vhost, busPrefix, entity, restTemplate): findStreamQueues(adminUri, vhost, busPrefix, entity, restTemplate);
		ExchangeCandidateCallback callback;
		if (isJob) {
			String pattern;
			if (entity.endsWith(""*"")) {
				pattern = entity.substring(0, entity.length() - 1) + ""[^.]*"";
			}
			else {
				pattern = entity;
			}
			Collection<String> exchangeNames = JobEventsListenerPlugin.getEventListenerChannels(pattern).values();
			final Set<Pattern> jobExchanges = new HashSet<>();
			for (String exchange : exchangeNames) {
				jobExchanges.add(Pattern.compile(MessageBusSupport.applyPrefix(busPrefix,MessageBusSupport.applyPubSub(exchange))));
			}
			jobExchanges.add(Pattern.compile(MessageBusSupport.applyPrefix(busPrefix, MessageBusSupport.applyPubSub(JobEventsListenerPlugin.getEventListenerChannelName(pattern)))));
			callback = new ExchangeCandidateCallback() {
				public boolean isCandidate(String exchangeName) {
					for (Pattern pattern : jobExchanges) {
						Matcher matcher = pattern.matcher(exchangeName);
						if (matcher.matches()) {
							return true;
						}
					}
					return false;
				}
			}
			;
		}
		else {
			final String tapPrefix = adjustPrefix(MessageBusSupport.applyPrefix(busPrefix,MessageBusSupport.applyPubSub(BusUtils.constructTapPrefix(entity))));
			callback = new ExchangeCandidateCallback() {
				public boolean isCandidate(String exchangeName) {
					return exchangeName.startsWith(tapPrefix);
				}
			}
			;
		}
		List<String> removedExchanges = findExchanges(adminUri, vhost, busPrefix, entity, restTemplate, callback);
		for (int i = removedQueues.size() - 1;
		 i >= 0;
		 i--) {
			String queueName = removedQueues.get(i);
			URI uri = UriComponentsBuilder.fromUriString(adminUri + ""/api"").pathSegment(""queues"", ""{
			vhost}
			"", ""{
			stream}
			"").buildAndExpand(vhost, queueName).encode().toUri();
			restTemplate.delete(uri);
			if (logger.isDebugEnabled()) {
				logger.debug(""deleted queue: "" + queueName);
			}
		}
		Map<String, List<String>> results = new HashMap<>();
		if (removedQueues.size() > 0) {
			results.put(""queues"", removedQueues);
		}
		for (String exchange : removedExchanges) {
			URI uri = UriComponentsBuilder.fromUriString(adminUri + ""/api"").pathSegment(""exchanges"", ""{
			vhost}
			"", ""{
			name}
			"").buildAndExpand(vhost, exchange).encode().toUri();
			restTemplate.delete(uri);
			if (logger.isDebugEnabled()) {
				logger.debug(""deleted exchange: "" + exchange);
			}
		}
		if (removedExchanges.size() > 0) {
			results.put(""exchanges"", removedExchanges);
		}
		return results;
	}
	private List<String> findStreamQueues(String adminUri, String vhost, String busPrefix, String stream,RestTemplate restTemplate) {
		String queueNamePrefix = adjustPrefix(MessageBusSupport.applyPrefix(busPrefix, stream));
		List<Map<String, Object>> queues = listAllQueues(adminUri, vhost, restTemplate);
		List<String> removedQueues = new ArrayList<>();
		for (Map<String, Object> queue : queues) {
			String queueName = (String) queue.get(""name"");
			if (queueName.startsWith(queueNamePrefix)) {
				checkNoConsumers(queueName, queue);
				removedQueues.add(queueName);
			}
		}
		return removedQueues;
	}
	private List<String> findJobQueues(String adminUri, String vhost, String busPrefix, String job,RestTemplate restTemplate) {
		List<String> removedQueues = new ArrayList<>();
		String jobQueueName = MessageBusSupport.applyPrefix(busPrefix,AbstractJobPlugin.getJobChannelName(job));
		String jobRequestsQueuePrefix = adjustPrefix(MessageBusSupport.applyPrefix(busPrefix,AbstractJobPlugin.getJobChannelName(job)));
		List<Map<String, Object>> queues = listAllQueues(adminUri, vhost, restTemplate);
		for (Map<String, Object> queue : queues) {
			String queueName = (String) queue.get(""name"");
			if (job.endsWith(""*"")) {
				if (queueName.startsWith(jobQueueName.substring(0, jobQueueName.length() - 1))) {
					checkNoConsumers(queueName, queue);
					removedQueues.add(queueName);
				}
			}
			else {
				if (queueName.equals(jobQueueName)) {
					checkNoConsumers(queueName, queue);
					removedQueues.add(queueName);
				}
				else if (queueName.startsWith(jobRequestsQueuePrefix)&& queueName.endsWith(MessageBusSupport.applyRequests(""""))) {
					checkNoConsumers(queueName, queue);
					removedQueues.add(queueName);
				}
			}
		}
		return removedQueues;
	}
	private List<Map<String, Object>> listAllQueues(String adminUri, String vhost, RestTemplate restTemplate) {
		URI uri = UriComponentsBuilder.fromUriString(adminUri + ""/api"").pathSegment(""queues"", ""{
		vhost}
		"").buildAndExpand(vhost).encode().toUri();
		List<Map<String, Object>> queues = restTemplate.getForObject(uri, List.class);
		return queues;
	}
	private String adjustPrefix(String prefix) {
		if (prefix.endsWith(""*"")) {
			return prefix.substring(0, prefix.length() - 1);
		}
		else {
			return prefix + BusUtils.GROUP_INDEX_DELIMITER;
		}
	}
	private void checkNoConsumers(String queueName, Map<String, Object> queue) {
		if (!queue.get(""consumers"").equals(Integer.valueOf(0))) {
			throw new RabbitAdminException(""Queue "" + queueName + "" is in use"");
		}
	}
	private List<String> findExchanges(String adminUri, String vhost, String busPrefix, String entity,RestTemplate restTemplate, ExchangeCandidateCallback callback) {
		List<String> removedExchanges = new ArrayList<>();
		URI uri = UriComponentsBuilder.fromUriString(adminUri + ""/api"").pathSegment(""exchanges"", ""{
		vhost}
		"").buildAndExpand(vhost).encode().toUri();
		List<Map<String, Object>> exchanges = restTemplate.getForObject(uri, List.class);
		for (Map<String, Object> exchange : exchanges) {
			String exchangeName = (String) exchange.get(""name"");
			if (callback.isCandidate(exchangeName)) {
				uri = UriComponentsBuilder.fromUriString(adminUri + ""/api"").pathSegment(""exchanges"", ""{
				vhost}
				"", ""{
				name}
				"", ""bindings"", ""source"").buildAndExpand(vhost, exchangeName).encode().toUri();
				List<Map<String, Object>> bindings = restTemplate.getForObject(uri, List.class);
				if (bindings.size() == 0) {
					uri = UriComponentsBuilder.fromUriString(adminUri + ""/api"").pathSegment(""exchanges"", ""{
					vhost}
					"", ""{
					name}
					"", ""bindings"", ""destination"").buildAndExpand(vhost, exchangeName).encode().toUri();
					bindings = restTemplate.getForObject(uri, List.class);
					if (bindings.size() == 0) {
						removedExchanges.add((String) exchange.get(""name""));
					}
					else {
						throw new RabbitAdminException(""Cannot delete exchange "" + exchangeName+ "";
						 it is a destination: "" + bindings);
					}
				}
				else {
					throw new RabbitAdminException(""Cannot delete exchange "" + exchangeName + "";
					 it has bindings: ""+ bindings);
				}
			}
		}
		return removedExchanges;
	}
	private interface ExchangeCandidateCallback {
		boolean isCandidate(String exchangeName);
	}
}",1,0,0,0
"public class UtilitiesModel implements Model {
	 private static Log log = LogFactory.getLog(UtilitiesModel.class);
	 private static Pattern mLinkPattern = Pattern.compile(""<a href=.*?>"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern OPENING_B_TAG_PATTERN = Pattern.compile(""&lt;
	b&gt;
	"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern CLOSING_B_TAG_PATTERN = Pattern.compile(""&lt;
	/b&gt;
	"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern OPENING_I_TAG_PATTERN = Pattern.compile(""&lt;
	i&gt;
	"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern CLOSING_I_TAG_PATTERN = Pattern.compile(""&lt;
	/i&gt;
	"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern OPENING_BLOCKQUOTE_TAG_PATTERN = Pattern.compile(""&lt;
	blockquote&gt;
	"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern CLOSING_BLOCKQUOTE_TAG_PATTERN = Pattern.compile(""&lt;
	/blockquote&gt;
	"", Pattern.CASE_INSENSITIVE);
	 private static final Pattern BR_TAG_PATTERN = Pattern.compile(""&lt;
	br * public String getModelName() {
		 return ""utils"";
	 }
	 public void init(Map initData) throws PlanetException {
	 }
	 public static Date getNow() {
		 return new Date();
	 }
	 public String formatDate(Date d, String fmt) {
		 if(d == null || fmt == null) return fmt;
		 SimpleDateFormat format = new SimpleDateFormat(fmt);
		 if (tz != null) {
			 format.setTimeZone(tz);
		 }
		 return format.format(d);
	 }
	 public static String formatDate(Date d, String fmt, TimeZone tzOverride) {
		 if(d == null || fmt == null) return fmt;
		 SimpleDateFormat format = new SimpleDateFormat(fmt);
		 format.setTimeZone(tzOverride);
		 return format.format(d);
	 }
	 public static String formatIso8601Date(Date d) {
		 return DateUtil.formatIso8601(d);
	 }
	 public static String formatIso8601Day(Date d) {
		 return DateUtil.formatIso8601Day(d);
	 }
	 public static String formatRfc822Date(Date date) {
		 return DateUtil.formatRfc822(date);
	 }
	 public static String format8charsDate(Date date) {
		 return DateUtil.format8chars(date);
	 }
	 public static boolean isEmpty(String str) {
		 if (str == null) return true;
		 return """".equals(str.trim());
	 }
	 public static boolean isNotEmpty(String str) {
		 return !isEmpty(str);
	 }
	 public static String[] split(String str1, String str2) {
		 return StringUtils.split(str1, str2);
	 }
	 public static boolean equals(String str1, String str2) {
		 return StringUtils.equals(str1, str2);
	 }
	 public static boolean isAlphanumeric(String str) {
		 return StringUtils.isAlphanumeric(str);
	 }
	 public static String[] stripAll(String[] strs) {
		 return StringUtils.stripAll(strs);
	 }
	 public static String left(String str, int length) {
		 return StringUtils.left(str, length);
	 }
	 public static String escapeHTML(String str) {
		 return StringEscapeUtils.escapeHtml(str);
	 }
	 public static String unescapeHTML(String str) {
		 return StringEscapeUtils.unescapeHtml(str);
	 }
	 public static String escapeXML(String str) {
		 return StringEscapeUtils.escapeXml(str);
	 }
	 public static String unescapeXML(String str) {
		 return StringEscapeUtils.unescapeXml(str);
	 }
	 public static String replace(String src, String target, String rWith) {
		 return StringUtils.replace(src, target, rWith);
	 }
	 public static String replace(String src, String target, String rWith, int maxCount) {
		 return StringUtils.replace(src, target, rWith, maxCount);
	 }
	 private static String replace(String string, Pattern pattern, String replacement) {
		 Matcher m = pattern.matcher(string);
		 return m.replaceAll(replacement);
	 }
	 public static String removeHTML(String str) {
		 return removeHTML(str, true);
	 }
	 public static String removeHTML(String str, boolean addSpace) {
		 return Utilities.removeHTML(str, addSpace);
	 }
	 public static String autoformat(String s) {
		 String ret = StringUtils.replace(s, ""\n"", ""<br />"");
		 return ret;
	 }
	 public static String truncate( String str, int lower, int upper, String appendToEnd) {
		 String str2 = removeHTML(str, false);
		 if (upper < lower) {
			 upper = lower;
		 }
		 if(str2.length() > upper) {
			 int loc;
			 loc = str2.lastIndexOf(' ', upper);
			 if(loc >= lower) {
				 str2 = str2.substring(0, loc);
			 }
			 else {
				 str2 = str2.substring(0, upper);
				 loc = upper;
			 }
			 str2 = str2 + appendToEnd;
		 }
		 return str2;
	 }
	 public static String truncateNicely(String str, int lower, int upper, String appendToEnd) {
		 return Utilities.truncateNicely(str, lower, upper, appendToEnd);
	 }
	 public static String truncateText(String str, int lower, int upper, String appendToEnd) {
		 String str2 = removeHTML(str, false);
		 boolean diff = (str2.length() < str.length());
		 if(upper < lower) {
			 upper = lower;
		 }
		 if(str2.length() > upper) {
			 int loc;
			 loc = str2.lastIndexOf(' ', upper);
			 if(loc >= lower) {
				 str2 = str2.substring(0, loc);
			 }
			 else {
				 str2 = str2.substring(0, upper);
				 loc = upper;
			 }
			 str = str2 + appendToEnd;
		 }
		 return str;
	 }
	 public static String hexEncode(String str) {
		 if (StringUtils.isEmpty(str)) return str;
		 return RegexUtil.encode(str);
	 }
	 public static String encodeEmail(String str) {
		 return str!=null ? RegexUtil.encodeEmail(str) : null;
	 }
	 public static final String encode(String s) {
		 try {
			 if (s != null) return URLEncoder.encode(s, ""UTF-8"");
			 else return s;
		 }
		 catch (UnsupportedEncodingException e) {
			 return s;
		 }
	 }
	 public static final String decode(String s) {
		 try {
			 if (s != null) return URLDecoder.decode(s, ""UTF-8"");
			 else return s;
		 }
		 catch (UnsupportedEncodingException e) {
			 return s;
		 }
	 }
	 public static String addNofollow(String html) {
		 if (html == null || html.length() == 0) {
			 return html;
		 }
		 Matcher m = mLinkPattern.matcher(html);
		 StringBuffer buf = new StringBuffer();
		 while (m.find()) {
			 int start = m.start();
			 int end = m.end();
			 String link = html.substring(start, end);
			 buf.append(html.substring(0, start));
			 if (link.indexOf(""rel=\""nofollow\"""") == -1) {
				 buf.append( link.substring(0, link.length() - 1) + "" rel=\""nofollow\"">"");
			 }
			 else {
				 buf.append(link);
			 }
			 html = html.substring(end, html.length());
			 m = mLinkPattern.matcher(html);
		 }
		 buf.append(html);
		 return buf.toString();
	 }
	 public static String transformToHTMLSubset(String s) {
		 if (s == null) {
			 return null;
		 }
		 s = replace(s, OPENING_B_TAG_PATTERN, ""<b>"");
		 s = replace(s, CLOSING_B_TAG_PATTERN, ""</b>"");
		 s = replace(s, OPENING_I_TAG_PATTERN, ""<i>"");
		 s = replace(s, CLOSING_I_TAG_PATTERN, ""</i>"");
		 s = replace(s, OPENING_BLOCKQUOTE_TAG_PATTERN, ""<blockquote>"");
		 s = replace(s, CLOSING_BLOCKQUOTE_TAG_PATTERN, ""</blockquote>"");
		 s = replace(s, BR_TAG_PATTERN, ""<br />"");
		 s = replace(s, OPENING_P_TAG_PATTERN, ""<p>"");
		 s = replace(s, CLOSING_P_TAG_PATTERN, ""</p>"");
		 s = replace(s, OPENING_PRE_TAG_PATTERN, ""<pre>"");
		 s = replace(s, CLOSING_PRE_TAG_PATTERN, ""</pre>"");
		 s = replace(s, OPENING_UL_TAG_PATTERN, ""<ul>"");
		 s = replace(s, CLOSING_UL_TAG_PATTERN, ""</ul>"");
		 s = replace(s, OPENING_OL_TAG_PATTERN, ""<ol>"");
		 s = replace(s, CLOSING_OL_TAG_PATTERN, ""</ol>"");
		 s = replace(s, OPENING_LI_TAG_PATTERN, ""<li>"");
		 s = replace(s, CLOSING_LI_TAG_PATTERN, ""</li>"");
		 s = replace(s, QUOTE_PATTERN, ""\"""");
		 s = replace(s, CLOSING_A_TAG_PATTERN, ""</a>"");
		 Matcher m = OPENING_A_TAG_PATTERN.matcher(s);
		 while (m.find()) {
			 int start = m.start();
			 int end = m.end();
			 String link = s.substring(start, end);
			 link = ""<"" + link.substring(4, link.length() - 4) + "">"";
			 s = s.substring(0, start) + link + s.substring(end, s.length());
			 m = OPENING_A_TAG_PATTERN.matcher(s);
		 }
		 s = s.replaceAll(""&amp;
		lt;
		"", ""&lt;
		"");
		 s = s.replaceAll(""&amp;
		gt;
		"", ""&gt;
		"");
		 s = s.replaceAll(""&amp;
		#"", ""&#"");
		 return s;
	 }
	 public static String toBase64(byte[] aValue) {
		 final String m_strBase64Chars = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
		 int byte1;
		 int byte2;
		 int byte3;
		 int iByteLen = aValue.length;
		 StringBuffer tt = new StringBuffer();
		 for (int i = 0;
		 i < iByteLen;
		 i += 3) {
			 boolean bByte2 = (i + 1) < iByteLen;
			 boolean bByte3 = (i + 2) < iByteLen;
			 byte1 = aValue[i] & 0xFF;
			 byte2 = (bByte2) ? (aValue[i + 1] & 0xFF) : 0;
			 byte3 = (bByte3) ? (aValue[i + 2] & 0xFF) : 0;
			 tt.append(m_strBase64Chars.charAt(byte1 / 4));
			 tt.append(m_strBase64Chars.charAt((byte2 / 16) + ((byte1 & 0x3) * 16)));
			 tt.append(((bByte2) ? m_strBase64Chars.charAt((byte3 / 64) + ((byte2 & 0xF) * 4)) : '='));
			 tt.append(((bByte3) ? m_strBase64Chars.charAt(byte3 & 0x3F) : '='));
		 }
		 return tt.toString();
	 }
}",0,0,0,0
"public final class SAXInputSource extends XMLInputSource {
	 private XMLReader fXMLReader;
	 private InputSource fInputSource;
	 public SAXInputSource() {
		 this(null);
	 }
	 public SAXInputSource(InputSource inputSource) {
		 this(null, inputSource);
	 }
	 public SAXInputSource(XMLReader reader, InputSource inputSource) {
		 super(inputSource != null ? inputSource.getPublicId() : null, inputSource != null ? inputSource.getSystemId() : null, null);
		 if (inputSource != null) {
			 setByteStream(inputSource.getByteStream());
			 setCharacterStream(inputSource.getCharacterStream());
			 setEncoding(inputSource.getEncoding());
		 }
		 fInputSource = inputSource;
		 fXMLReader = reader;
	 }
	 public void setXMLReader(XMLReader reader) {
		 fXMLReader = reader;
	 }
	 public XMLReader getXMLReader() {
		 return fXMLReader;
	 }
	 public void setInputSource(InputSource inputSource) {
		 if (inputSource != null) {
			 setPublicId(inputSource.getPublicId());
			 setSystemId(inputSource.getSystemId());
			 setByteStream(inputSource.getByteStream());
			 setCharacterStream(inputSource.getCharacterStream());
			 setEncoding(inputSource.getEncoding());
		 }
		 else {
			 setPublicId(null);
			 setSystemId(null);
			 setByteStream(null);
			 setCharacterStream(null);
			 setEncoding(null);
		 }
		 fInputSource = inputSource;
	 }
	 public InputSource getInputSource() {
		 return fInputSource;
	 }
	 public void setPublicId(String publicId) {
		 super.setPublicId(publicId);
		 if (fInputSource == null) {
			 fInputSource = new InputSource();
		 }
		 fInputSource.setPublicId(publicId);
	 }
	 public void setSystemId(String systemId) {
		 super.setSystemId(systemId);
		 if (fInputSource == null) {
			 fInputSource = new InputSource();
		 }
		 fInputSource.setSystemId(systemId);
	 }
	 public void setByteStream(InputStream byteStream) {
		 super.setByteStream(byteStream);
		 if (fInputSource == null) {
			 fInputSource = new InputSource();
		 }
		 fInputSource.setByteStream(byteStream);
	 }
	 public void setCharacterStream(Reader charStream) {
		 super.setCharacterStream(charStream);
		 if (fInputSource == null) {
			 fInputSource = new InputSource();
		 }
		 fInputSource.setCharacterStream(charStream);
	 }
	 public void setEncoding(String encoding) {
		 super.setEncoding(encoding);
		 if (fInputSource == null) {
			 fInputSource = new InputSource();
		 }
		 fInputSource.setEncoding(encoding);
	 }
 }",0,1,0,0
"protected String convertZuluDateToBday(String value) {
	 String result = null;
	 if (value != null && value.length() > 0) {
		 try {
			 SimpleDateFormat parser = ExchangeSession.getZuluDateFormat();
			 Calendar cal = Calendar.getInstance();
			 cal.setTime(parser.parse(value));
			 cal.add(Calendar.HOUR_OF_DAY, 12);
			 result = ExchangeSession.getVcardBdayFormat().format(cal.getTime());
		 }
		 catch (ParseException e) {
			 LOGGER.warn(""Invalid date: "" + value);
		 }
	 }
	 return result;
 }",0,0,0,0
"public static String[] getPathStack(String path) {
	 String normalizedPath = path.replace(File.separatorChar, '/');
	 Object[] tokens = StringUtils.split(normalizedPath, '/').toArray();
	 String[] rv = new String[tokens.length];
	 System.arraycopy(tokens, 0, rv, 0, tokens.length);
	 return rv;
 }",0,0,0,0
"public void processSearchAttachments(GenericRequest request, GenericResponse response) throws AuthenticationException, DatabaseException, BadInputException, IOException, ObjectNotFoundException {
	 OnlineUser onlineUser = onlineUserManager.getOnlineUser(request);
	 MVNForumPermission permission = onlineUser.getPermission();
	 permission.ensureCanGetAttachmentInAnyForum();
	 Locale locale = I18nUtil.getLocaleInRequest(request);
	 MyUtil.saveVNTyperMode(request, response);
	 CategoryBuilder builder = categoryBuilderService.getCategoryTreeBuilder();
	 CategoryTree tree = new CategoryTree(builder);
	 CategoryTreeListener listener = categoryService.getManagementCategorySelector(request, response, ""searchattachments"");
	 tree.addCategeoryTreeListener(listener);
	 request.setAttribute(""Result"", tree.build());
	 String key = GenericParamUtil.getParameter(request, ""key"");
	 String attachmentName = GenericParamUtil.getParameter(request, ""attachmentname"");
	 if ( (key.length() == 0) && (attachmentName.length() == 0) ) {
		 return;
	 }
	 int forumID = GenericParamUtil.getParameterInt(request, ""forum"", 0);
	 int offset = GenericParamUtil.getParameterUnsignedInt(request, ""offset"", 0);
	 int rows = GenericParamUtil.getParameterUnsignedInt(request, ""rows"", 20);
	 if (rows == 0) {
		 rows = 20;
	 }
	 offset = (offset / rows) * rows;
	 AttachmentSearchQuery query = new AttachmentSearchQuery();
	 if (key.length() > 0) {
		 query.setSearchString(key);
	 }
	 if (attachmentName.length() > 0) {
		 query.setSearchFileName(attachmentName);
	 }
	 int searchDate = GenericParamUtil.getParameterUnsignedInt(request, ""date"", AttachmentSearchQuery.SEARCH_ANY_DATE);
	 int searchBeforeAfter = GenericParamUtil.getParameterInt(request, ""beforeafter"", AttachmentSearchQuery.SEARCH_NEWER);
	 if ((searchDate != AttachmentSearchQuery.SEARCH_ANY_DATE) && (searchDate < 365 * 10)) {
		 long deltaTime = DateUtil.DAY * searchDate;
		 Timestamp now = DateUtil.getCurrentGMTTimestamp();
		 Timestamp from = null;
		 Timestamp to = null;
		 long currentTime = now.getTime();
		 if (searchBeforeAfter == AttachmentSearchQuery.SEARCH_NEWER) {
			 from = new Timestamp(currentTime - deltaTime);
		 }
		 else {
			 to = new Timestamp(currentTime - deltaTime);
		 }
		 query.setFromDate(from);
		 query.setToDate(to);
	 }
	 if (forumID > 0) {
		 query.setForumId(forumID);
	 }
	 else if (forumID < 0) {
		 query.setForumId(forumID);
	 }
	 else {
	 }
	 query.searchDocuments(offset, rows, permission);
	 int hitCount = query.getHitCount();
	 Collection result = query.getAttachmentResult();
	 for (Iterator iter = result.iterator();
	 iter.hasNext();
	 ) {
		 AttachmentBean attachBean = (AttachmentBean)iter.next();
		 int currentForumID = attachBean.getForumID();
		 if (permission.canGetAttachment(currentForumID) == false) {
			 iter.remove();
		 }
		 else if (ForumCache.getInstance().getBean(currentForumID).getForumStatus() == ForumBean.FORUM_STATUS_DISABLED) {
			 iter.remove();
		 }
	 }
	 if (offset > hitCount) {
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""mvncore.exception.BadInputException.offset_greater_than_total_rows"");
		 throw new BadInputException(localizedMessage);
	 }
	 request.setAttribute(""rows"", new Integer(rows));
	 request.setAttribute(""TotalAttachs"", new Integer(hitCount));
	 request.setAttribute(""AttachBeans"", result);
 }",0,0,1,0
"public class SimpleStorage extends FileStorage {
	 public static final String user_domain_separator=""|"";
	 protected Hashtable resources;
	 protected Hashtable vdoms;
	 protected ExpireableCache user_cache;
	 protected int user_cache_size=100;
	 public SimpleStorage(WebMailServer parent) {
		super(parent);
		saveXMLSysData();
	 }
	 protected void initConfig() {
		System.err.print("" * Configuration ... "");
		loadXMLSysData();
		System.err.println(""successfully parsed XML configuration file."");
	 }
	 protected void loadXMLSysData() {
		String datapath=parent.getProperty(""webmail.data.path"");
		String file=""file:Document root;
		 try {
			 DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
			 root=parser.parse(file);
			 if(debug) System.err.println(""\nConfiguration file parsed, document: ""+root);
			 sysdata=new XMLSystemData(root,cs);
			 log(Storage.LOG_DEBUG, ""SimpleStorage: WebMail configuration loaded."");
		 }
		 catch(Exception ex) {
			 log(Storage.LOG_ERR, ""SimpleStorage: Failed to load WebMail configuration file. Reason: ""+ex.getMessage());
			 ex.printStackTrace();
			 System.exit(0);
		 }
	 }
	 protected void saveXMLSysData() {
		try {
			 Document d=sysdata.getRoot();
			 OutputStream cfg_out=new FileOutputStream(parent.getProperty(""webmail.data.path"")+ System.getProperty(""file.separator"")+ ""webmail.xml"");
			 XMLCommon.writeXML(d,cfg_out,""file: System.getProperty(""file.separator"")+""sysdata.dtd"");
			 cfg_out.flush();
			 cfg_out.close();
			 sysdata.setLoadTime(System.currentTimeMillis());
			 log(Storage.LOG_DEBUG, ""SimpleStorage: WebMail configuration saved."");
		}
		 catch(Exception ex) {
			 log(Storage.LOG_ERR,""SimpleStorage: Error while trying to save WebMail configuration (""+ex.getMessage()+"")."");
			 ex.printStackTrace();
		}
	 }
	 protected void initCache() {
		super.initCache();
		cs.configRegisterIntegerKey(this,""CACHE SIZE USER"",""100"",""Size of the user cache"");
		try {
			 user_cache_size=100;
			 user_cache_size=Integer.parseInt(getConfig(""CACHE SIZE USER""));
		}
		 catch(NumberFormatException e) {
		}
		if(user_cache==null) {
			 user_cache=new ExpireableCache(user_cache_size);
		}
		 else {
			 user_cache.setCapacity(user_cache_size);
		}
	 }
	 public Enumeration getUsers(String domain) {
		String path=parent.getProperty(""webmail.data.path"")+System.getProperty(""file.separator"")+ domain+System.getProperty(""file.separator"");
		File f=new File(path);
		if(f.canRead() && f.isDirectory()) {
			 final String[] files=f.list(new FilenameFilter() {
				 public boolean accept(File file, String s) {
					if(s.endsWith("".xml"")) {
						 return true;
					}
					 else {
						 return false;
					}
				 }
			}
			 );
			 return new Enumeration() {
				 int i=0;
				 public boolean hasMoreElements() {
					return i<files.length;
				 }
				 public Object nextElement() {
					int cur=i++;
					return files[cur].substring(0,files[cur].length()-4);
				 }
			}
			;
		}
		 else {
			 log(Storage.LOG_WARN,""SimpleStorage: Could not list files in directory ""+path);
			 return new Enumeration() {
				 public boolean hasMoreElements() {
					 return false;
				 }
				 public Object nextElement() {
					 return null;
				 }
			}
			;
		}
	 }
	 public XMLUserData createUserData(String user, String domain, String password) throws CreateUserDataException {
		XMLUserData data;
		String template=parent.getProperty(""webmail.xml.path"")+ System.getProperty(""file.separator"")+""userdata.xml"";
		File f=new File(template);
		if(!f.exists()) {
			 log(Storage.LOG_WARN,""SimpleStorage: User configuration template (""+template+"") doesn't exist!"");
			 throw new CreateUserDataException(""User configuration template (""+template+"") doesn't exist!"",user,domain);
		}
		 else if(!f.canRead()) {
			 log(Storage.LOG_WARN,""SimpleStorage: User configuration template (""+template+"") is not readable!"");
			 throw new CreateUserDataException(""User configuration template (""+template+"") is not readable!"",user,domain);
		}
		Document root;
		try {
			 DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
			 root=parser.parse(""file: data=new XMLUserData(root);
			 data.init(user,domain,password);
			 if(getConfig(""SHOW ADVERTISEMENTS"").toUpperCase().equals(""YES"")) {
				 if(domain.equals("""")) {
					 data.setSignature(user+""\n\n""+ getConfig(""ADVERTISEMENT MESSAGE""));
				}
				 else {
					 data.setSignature(user+""@""+domain+""\n\n""+ getConfig(""ADVERTISEMENT MESSAGE""));
				}
			 }
			 else {
				 if(domain.equals("""")) {
					 data.setSignature(user);
				}
				 else {
					 data.setSignature(user+""@""+domain);
				}
			 }
			 data.setTheme(parent.getDefaultTheme());
			 WebMailVirtualDomain vdom=getVirtualDomain(domain);
			 data.addMailHost(""Default"",getConfig(""DEFAULT PROTOCOL"")+"": vdom.getDefaultServer(),user,password);
		}
		 catch(Exception ex) {
			 log(Storage.LOG_WARN,""SimpleStorage: User configuration template (""+template+"") exists but could not be parsed"");
			 if(debug) ex.printStackTrace();
			 throw new CreateUserDataException(""User configuration template (""+template+"") exists but could not be parsed"",user,domain);
		}
		return data;
	 }
	 public XMLUserData getUserData(String user, String domain, String password, boolean authenticate) throws UserDataException, InvalidPasswordException {
		if(authenticate) {
			 auth.authenticatePreUserData(user,domain,password);
		}
		if(user.equals("""")) {
			 return null;
		}
		XMLUserData data=(XMLUserData)user_cache.get(user+user_domain_separator+domain);
		if(data == null) {
			 user_cache.miss();
			 String filename=parent.getProperty(""webmail.data.path"")+System.getProperty(""file.separator"")+domain+System.getProperty(""file.separator"")+user+"".xml"";
			 boolean error=true;
			 File f=new File(filename);
			 if(f.exists() && f.canRead()) {
				log(Storage.LOG_INFO,""SimpleStorage: Reading user configuration (""+f.getAbsolutePath()+"") for ""+user);
				long t_start=System.currentTimeMillis();
				try {
					 DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
					 Document root = parser.parse(new InputSource(new InputStreamReader(new FileInputStream(filename), ""UTF-8"")));
					 data=new XMLUserData(root);
					 if(debug) System.err.println(""SimpleStorage: Parsed Document ""+root);
					 error=false;
				}
				 catch(Exception ex) {
					 log(Storage.LOG_WARN,""SimpleStorage: User configuration for ""+user+"" exists but could not be parsed (""+ex.getMessage()+"")"");
					 if(debug) ex.printStackTrace();
					 error=true;
				}
				long t_end=System.currentTimeMillis();
				log(Storage.LOG_DEBUG,""SimpleStorage: Parsing of XML userdata for ""+user+"", domain "" +domain+"" took ""+(t_end-t_start)+""ms."");
				if(authenticate) {
					 auth.authenticatePostUserData(data,domain,password);
				}
			 }
			 if(error && !f.exists()) {
				log(Storage.LOG_INFO,""UserConfig: Creating user configuration for ""+user);
				data=createUserData(user,domain,password);
				error=false;
				if(authenticate) {
					 auth.authenticatePostUserData(data,domain,password);
				}
			 }
			 if(error) {
				log(Storage.LOG_ERR,""UserConfig: Could not read userdata for ""+user+""!"");
				throw new UserDataException(""Could not read userdata!"",user,domain);
			 }
			 user_cache.put(user+user_domain_separator+domain,data);
		}
		 else {
			 user_cache.hit();
			 if(authenticate) {
				auth.authenticatePostUserData(data,domain,password);
			 }
		}
		return data;
	 }
	 public void saveUserData(String user, String domain) {
		try {
			 String path=parent.getProperty(""webmail.data.path"")+System.getProperty(""file.separator"")+domain;
			 File p=new File(path);
			 if((p.exists() && p.isDirectory()) || p.mkdirs()) {
				File f=new File(path+System.getProperty(""file.separator"")+user+"".xml"");
				if((!f.exists() && p.canWrite()) || f.canWrite()) {
					 XMLUserData userdata=getUserData(user,domain,"""",false);
					 Document d=userdata.getRoot();
					 long t_start=System.currentTimeMillis();
					 FileOutputStream out=new FileOutputStream(f);
					 XMLCommon.writeXML(d,out,""file: System.getProperty(""file.separator"")+""userdata.dtd"");
					 out.flush();
					 out.close();
					 long t_end=System.currentTimeMillis();
					 log(Storage.LOG_DEBUG,""SimpleStorage: Serializing userdata for ""+user+"", domain ""+domain+"" took ""+(t_end-t_start)+""ms."");
				}
				 else {
					 log(Storage.LOG_WARN,""SimpleStorage: Could not write userdata (""+f.getAbsolutePath()+"") for user ""+user);
				}
			 }
			 else {
				log(Storage.LOG_ERR,""SimpleStorage: Could not create path ""+path+ "". Aborting with user ""+user);
			 }
		}
		 catch(Exception ex) {
			 log(Storage.LOG_ERR,""SimpleStorage: Unexpected error while trying to save user configuration ""+""for user ""+user+""(""+ex.getMessage()+"")."");
			 if(debug) ex.printStackTrace();
		}
	 }
	 public void deleteUserData(String user, String domain) {
		String path=parent.getProperty(""webmail.data.path"")+System.getProperty(""file.separator"")+ domain+System.getProperty(""file.separator"")+user+"".xml"";
		File f=new File(path);
		if(!f.canWrite() || !f.delete()) {
			 log(Storage.LOG_ERR,""SimpleStorage: Could not delete user ""+user+"" (""+path+"")!"");
		}
		 else {
			 log(Storage.LOG_INFO,""SimpleStorage: Deleted user ""+user+""!"");
		}
		user_cache.remove(user+user_domain_separator+domain);
	 }
	 public String toString() {
		String s=""SimpleStorage:\n""+super.toString();
		s+="" - user cache: Capacity ""+user_cache.getCapacity()+"", Usage ""+user_cache.getUsage();
		s+="", ""+user_cache.getHits()+"" hits, ""+user_cache.getMisses()+"" misses\n"";
		return s;
	 }
}",1,0,0,0
"private void alterTableStatsForTruncate(RawStore ms, String catName, String dbName, String tableName, Table table, List<String> partNames, String validWriteIds, long writeId) throws Exception {
	 if (partNames == null) {
		 if (0 != table.getPartitionKeysSize()) {
			 for (Partition partition : ms.getPartitions(catName, dbName, tableName, Integer.MAX_VALUE)) {
				 alterPartitionForTruncate(ms, catName, dbName, tableName, table, partition, validWriteIds, writeId);
			 }
		 }
		 else {
			 EnvironmentContext environmentContext = new EnvironmentContext();
			 updateStatsForTruncate(table.getParameters(), environmentContext);
			 if (!transactionalListeners.isEmpty()) {
				 MetaStoreListenerNotifier.notifyEvent(transactionalListeners, EventType.ALTER_TABLE, new AlterTableEvent(table, table, true, true, writeId, this));
			 }
			 if (!listeners.isEmpty()) {
				 MetaStoreListenerNotifier.notifyEvent(listeners, EventType.ALTER_TABLE, new AlterTableEvent(table, table, true, true, writeId, this));
			 }
			 if (writeId > 0) {
				 table.setWriteId(writeId);
			 }
			 alterHandler.alterTable(ms, wh, catName, dbName, tableName, table, environmentContext, this, validWriteIds);
		 }
	 }
	 else {
		 for (Partition partition : ms.getPartitionsByNames(catName, dbName, tableName, partNames)) {
			 alterPartitionForTruncate(ms, catName, dbName, tableName, table, partition, validWriteIds, writeId);
		 }
	 }
	 return;
 }",0,0,1,0
"public AsyncContextEvent(Context context,AsyncContextState asyncContext, HttpChannelState state, Request baseRequest, ServletRequest request, ServletResponse response) {
	 super(null,request,response,null);
	 _context=context;
	 _asyncContext=asyncContext;
	 _state=state;
	 if (baseRequest.getAttribute(AsyncContext.ASYNC_REQUEST_URI)==null) {
		 String uri=(String)baseRequest.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);
		 if (uri!=null) {
			 baseRequest.setAttribute(AsyncContext.ASYNC_REQUEST_URI,uri);
			 baseRequest.setAttribute(AsyncContext.ASYNC_CONTEXT_PATH,baseRequest.getAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH));
			 baseRequest.setAttribute(AsyncContext.ASYNC_SERVLET_PATH,baseRequest.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH));
			 baseRequest.setAttribute(AsyncContext.ASYNC_PATH_INFO,baseRequest.getAttribute(RequestDispatcher.FORWARD_PATH_INFO));
			 baseRequest.setAttribute(AsyncContext.ASYNC_QUERY_STRING,baseRequest.getAttribute(RequestDispatcher.FORWARD_QUERY_STRING));
		 }
		 else {
			 baseRequest.setAttribute(AsyncContext.ASYNC_REQUEST_URI,baseRequest.getRequestURI());
			 baseRequest.setAttribute(AsyncContext.ASYNC_CONTEXT_PATH,baseRequest.getContextPath());
			 baseRequest.setAttribute(AsyncContext.ASYNC_SERVLET_PATH,baseRequest.getServletPath());
			 baseRequest.setAttribute(AsyncContext.ASYNC_PATH_INFO,baseRequest.getPathInfo());
			 baseRequest.setAttribute(AsyncContext.ASYNC_QUERY_STRING,baseRequest.getQueryString());
		 }
	 }
 }",0,0,1,0
"public BufferedImage processImage(BufferedImage image) {
	 int width = image.getWidth();
	int height = image.getHeight();
	 while (width % N != 0) {
		 width--;
	 }
	 while (height % N != 0) {
		 height--;
	 }
	 originalImage = resize(image, width, height);
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 int numXpatches = width/N;
	 int numYpatches = height/N;
	 double [][] T = createT();
	 double [][] Tinv = null;
	 if (N == 8) Tinv = createTinv();
	 if (N==16) Tinv = createTinv16X16();
	 for (int i = 0;
	 i < numXpatches;
	 i++) {
		 for (int j = 0;
		 j < numYpatches;
		 j++) {
			 double [][] M = createM(i, j);
			 double[][] D = multiply(multiply(T, M), Tinv);
			 int [][] Q = null;
			 if (N == 8) {
				 Q = createQ50();
				 updateQ(Q);
			 }
			 if (N == 16) {
				 Q = createQ16X16();
			 }
			 int [][] C = createC(D, Q);
			 double [][] R = createR(Q, C);
			 int [][] Nmatrix = createN(Tinv, R, T);
			 fillFilteredImage(i, j, Nmatrix);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public void readFields(DataInput in) throws IOException {
	 byte version = in.readByte();
	 if (version > CUR_VERSION) throw new VersionMismatchException(CUR_VERSION, version);
	 url.readFields(in);
	 md5.readFields(in);
	 nextFetch = in.readLong();
	 retries = in.readByte();
	 fetchInterval = in.readByte();
	 numOutlinks = (version > 2) ? in.readInt() : 0;
	 score = (version>1) ? in.readFloat() : 1.0f;
	 nextScore = (version>3) ? in.readFloat() : 1.0f;
 }",0,0,0,0
"static <T> Sketch<T> create(CountMinSketch sketch) {
	 int width = (int) Math.ceil(2 / sketch.getRelativeError());
	 int depth = (int) Math.ceil(-Math.log(1 - sketch.getConfidence()) / Math.log(2));
	 return new AutoValue_SketchFrequencies_Sketch<>(depth, width, sketch);
 }",0,0,1,0
"class LexerPath extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {
	 private static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 2048;
	 public static final int YYINITIAL = 0;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 1 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\11\15\1\1\1\1\2\15\1\1\22\15\1\14\1\6\1\20\1\0""+ ""\1\6\1\7\7\6\1\5\1\2\1\3\1\11\1\12\1\10\7\12""+ ""\1\4\1\6\1\20\1\6\1\20\1\0\1\4\6\12\24\5\1\0""+ ""\1\20\1\0\1\20\1\5\1\20\1\13\5\13\24\5\3\20\1\5""+ ""\6\17\1\16\32\17\ud760\23\u0400\21\u0400\22\u2000\23"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\2\0\1\1\1\2\2\3\1\4\1\5\1\6\1\7""+ ""\1\10\1\11\1\12\1\13\1\14\2\15\1\16\1\3""+ ""\1\17\1\20\3\0\1\21\1\22\1\0\1\23\1\24""+ ""\1\25\1\26\1\27\1\30\1\31\1\0"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[35];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\24\0\50\0\50\0\50\0\74\0\50\0\50""+ ""\0\50\0\120\0\144\0\50\0\50\0\50\0\50\0\170""+ ""\0\50\0\50\0\214\0\144\0\240\0\264\0\310\0\334""+ ""\0\50\0\50\0\360\0\u0104\0\50\0\50\0\50\0\50""+ ""\0\u0118\0\50\0\214"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[35];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12""+ ""\4\10\1\13\1\14\1\15\1\16\1\17\1\20\1\21""+ ""\1\22\1\3\1\4\1\23\1\6\1\7\1\10\1\11""+ ""\1\12\4\10\1\24\1\14\1\15\1\16\1\17\1\20""+ ""\1\21\1\22\26\0\1\25\31\0\1\26\2\27\1\30""+ ""\24\0\1\31\31\0\1\32\3\0\1\33\23\0\1\34""+ ""\1\35\30\0\1\36\1\37\1\36\1\40\20\0\3\36""+ ""\1\40\20\0\4\40\13\0\1\41\23\0\1\42\22\0""+ ""\1\43\21\0"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[300];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\2\0\3\11\1\1\3\11\2\1\4\11\1\1\2\11""+ ""\3\1\3\0\2\11\1\0\1\1\4\11\1\1\1\11""+ ""\1\0"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[35];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 private int lastChar;
	 char[] zzBuffer() {
		 yyreset(null);
		 this.zzAtEOF = true;
		 int length = parser.end(range)-parser.start(range);
		 lastChar = length - 1;
		 zzEndRead = length;
		 while (length > zzBuffer.length) zzBuffer = new char[zzBuffer.length*2];
		 return zzBuffer;
	 }
	 LexerPath(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 LexerPath(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 94) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead > 0) {
			 zzEndRead+= numRead;
			 return false;
		 }
		 if (numRead == 0) {
			 int c = zzReader.read();
			 if (c == -1) {
				 return true;
			 }
			 else {
				 zzBuffer[zzEndRead++] = (char) c;
				 return false;
			 }
		 }
		 return true;
	 }
	 private final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 private final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEOFDone = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 private final int yystate() {
		 return zzLexicalState;
	 }
	 private final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 private final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 private final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 public void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	 public int yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 yychar+= zzMarkedPosL-zzStartRead;
			 if (zzMarkedPosL > zzStartRead) {
				 switch (zzBufferL[zzMarkedPosL-1]) {
					 case '\n': case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': zzAtBOL = true;
					 break;
					 case '\r': if (zzMarkedPosL < zzEndReadL) zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 else if (zzAtEOF) zzAtBOL = false;
					 else {
						 boolean eof = zzRefill();
						 zzMarkedPosL = zzMarkedPos;
						 zzEndReadL = zzEndRead;
						 zzBufferL = zzBuffer;
						 if (eof) zzAtBOL = false;
						 else zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 }
					 break;
					 default: zzAtBOL = false;
				 }
			 }
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 if (zzAtBOL) zzState = ZZ_LEXSTATE[zzLexicalState+1];
			 else zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 17: {
					 rule(-70);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 26: break;
				 case 11: {
					 rule(-115);
					 error(DISCOURAGED_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 27: break;
				 case 14: {
					 rule(-150);
					 difficultChar();
				 }
				 case 28: break;
				 case 20: {
					 rule(5);
					 error(NON_INITIAL_DOT_SEGMENT);
				 }
				 case 29: break;
				 case 18: {
					 rule(-130);
					 surrogatePair();
				 }
				 case 30: break;
				 case 25: {
					 rule(4);
					 error(NON_INITIAL_DOT_SEGMENT);
				 }
				 case 31: break;
				 case 4: {
					 rule(3);
				 }
				 case 32: break;
				 case 21: {
					 rule(-40);
					 error(PERCENT);
				 }
				 case 33: break;
				 case 13: {
					 rule(-140);
					 error(LONE_SURROGATE);
					 difficultChar();
				 }
				 case 34: break;
				 case 15: {
					 rule(-80);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 35: break;
				 case 23: {
					 rule(-50);
					 error(PERCENT);
					 error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
				 }
				 case 36: break;
				 case 8: {
					 rule(-90);
					 if (yychar==lastChar) error(DOUBLE_WHITESPACE);
					 else error(WHITESPACE);
				 }
				 case 37: break;
				 case 12: {
					 rule(-120);
					 error(UNWISE_CHARACTER);
				 }
				 case 38: break;
				 case 10: {
					 rule(-113);
					 error(CONTROL_CHARACTER);
				 }
				 case 39: break;
				 case 19: {
					 rule(7);
					 if (yychar == lastChar-2) error(NON_INITIAL_DOT_SEGMENT);
				 }
				 case 40: break;
				 case 5: {
					 rule(-10);
				 }
				 case 41: break;
				 case 24: {
					 rule(2);
				 }
				 case 42: break;
				 case 22: {
					 rule(-30);
					 error(PERCENT_20);
				 }
				 case 43: break;
				 case 7: {
					 rule(-60);
					 error(ILLEGAL_PERCENT_ENCODING);
				 }
				 case 44: break;
				 case 16: {
					 rule(8);
					 if (yychar == lastChar-1) error(NON_INITIAL_DOT_SEGMENT);
				 }
				 case 45: break;
				 case 6: {
					 rule(-20);
				 }
				 case 46: break;
				 case 2: {
					 rule(-100);
					 error(CONTROL_CHARACTER);
					 error(NOT_XML_SCHEMA_WHITESPACE);
				 }
				 case 47: break;
				 case 1: {
					 rule(-160);
					 error(ILLEGAL_CHARACTER);
				 }
				 case 48: break;
				 case 3: {
					 rule(6);
				 }
				 case 49: break;
				 case 9: {
					 rule(-110);
					 error(NON_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 50: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 return YYEOF;
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public PigServer(PigContext context, boolean connect) throws ExecException {
	 this.pigContext = context;
	 currDAG = new Graph(false);
	 jobName = pigContext.getProperties().getProperty( PigContext.JOB_NAME, PigContext.JOB_NAME_PREFIX + "":DefaultJobName"");
	 if (connect) {
		 pigContext.connect();
	 }
	 this.filter = new BlackAndWhitelistFilter(this);
	 addHadoopProperties();
	 addJarsFromProperties();
	 markPredeployedJarsFromProperties();
	 if (ScriptState.get() == null) {
		 ScriptState.start(pigContext.getExecutionEngine().instantiateScriptState());
	 }
	 PigStats.start(pigContext.getExecutionEngine().instantiatePigStats());
	 String auditId = PigATSClient.getPigAuditId(pigContext);
	 String callerId = (String)pigContext.getProperties().get(PigConfiguration.PIG_LOG_TRACE_ID);
	 log.info(""Pig Script ID for the session: "" + auditId);
	 if (callerId != null) {
		 log.info(""Caller ID for session: "" + callerId);
	 }
	 if (Boolean.parseBoolean(pigContext.getProperties() .getProperty(PigConfiguration.PIG_ATS_ENABLED))) {
		 if (Boolean.parseBoolean(pigContext.getProperties() .getProperty(""yarn.timeline-service.enabled"", ""false""))) {
			 PigATSClient.ATSEvent event = new PigATSClient.ATSEvent(auditId, callerId);
			 try {
				 PigATSClient.getInstance().logEvent(event);
			 }
			 catch (Exception e) {
				 log.warn(""Error posting to ATS: "", e);
			 }
		 }
		 else {
			 log.warn(""ATS is disabled since"" + "" yarn.timeline-service.enabled set to false"");
		 }
	 }
	 Class callerContextClass = null;
	 try {
		 callerContextClass = Class.forName(""org.apache.hadoop.ipc.CallerContext"");
	 }
	 catch (ClassNotFoundException e) {
	 }
	 if (callerContextClass != null) {
		 try {
			 Class callerContextBuilderClass = Class.forName(""org.apache.hadoop.ipc.CallerContext$Builder"");
			 Constructor callerContextBuilderConstruct = callerContextBuilderClass.getConstructor(String.class);
			 Object builder = callerContextBuilderConstruct.newInstance(auditId);
			 Method builderBuildMethod = builder.getClass().getMethod(""build"");
			 Object hdfsContext = builderBuildMethod.invoke(builder);
			 Method callerContextSetCurrentMethod = callerContextClass.getMethod(""setCurrent"", hdfsContext.getClass());
			 callerContextSetCurrentMethod.invoke(callerContextClass, hdfsContext);
		 }
		 catch (Exception e) {
			 throw new ExecException(e);
		 }
	 }
 }",0,0,1,0
"public ValueEval evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1,ValueEval arg2, ValueEval arg3);",0,0,0,1
"public class MRCompiler extends PhyPlanVisitor {
	 PigContext pigContext;
	 PhysicalPlan plan;
	 MROperPlan MRPlan;
	 MapReduceOper curMROp;
	 MapReduceOper[] compiledInputs = null;
	 Map<OperatorKey, MapReduceOper> splitsSeen;
	 NodeIdGenerator nig;
	 private String scope;
	 private UDFFinder udfFinder;
	 private CompilationMessageCollector messageCollector = null;
	 private Map<PhysicalOperator,MapReduceOper> phyToMROpMap;
	 public static final String USER_COMPARATOR_MARKER = ""user.comparator.func:"";
	 private static final Log LOG = LogFactory.getLog(MRCompiler.class);
	 public static final String FILE_CONCATENATION_THRESHOLD = ""pig.files.concatenation.threshold"";
	 public static final String OPTIMISTIC_FILE_CONCATENATION = ""pig.optimistic.files.concatenation"";
	 private int fileConcatenationThreshold = 100;
	 private boolean optimisticFileConcatenation = false;
	 public MRCompiler(PhysicalPlan plan) throws MRCompilerException {
		 this(plan,null);
	 }
	 public MRCompiler(PhysicalPlan plan, PigContext pigContext) throws MRCompilerException {
		 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
		 this.plan = plan;
		 this.pigContext = pigContext;
		 splitsSeen = new HashMap<OperatorKey, MapReduceOper>();
		 MRPlan = new MROperPlan();
		 nig = NodeIdGenerator.getGenerator();
		 udfFinder = new UDFFinder();
		 List<PhysicalOperator> roots = plan.getRoots();
		 if((roots == null) || (roots.size() <= 0)) {
			 int errCode = 2053;
			 String msg = ""Internal error. Did not find roots in the physical plan."";
			 throw new MRCompilerException(msg, errCode, PigException.BUG);
		 }
		 scope = roots.get(0).getOperatorKey().getScope();
		 messageCollector = new CompilationMessageCollector() ;
		 phyToMROpMap = new HashMap<PhysicalOperator, MapReduceOper>();
		 fileConcatenationThreshold = Integer.parseInt(pigContext.getProperties() .getProperty(FILE_CONCATENATION_THRESHOLD, ""100""));
		 optimisticFileConcatenation = pigContext.getProperties().getProperty( OPTIMISTIC_FILE_CONCATENATION, ""false"").equals(""true"");
		 LOG.info(""File concatenation threshold: "" + fileConcatenationThreshold + "" optimistic? "" + optimisticFileConcatenation);
	 }
	 public void aggregateScalarsFiles() throws PlanException, IOException {
		 List<MapReduceOper> mrOpList = new ArrayList<MapReduceOper>();
		 for(MapReduceOper mrOp: MRPlan) {
			 mrOpList.add(mrOp);
		 }
		 Configuration conf = ConfigurationUtil.toConfiguration(pigContext.getProperties());
		 boolean combinable = !conf.getBoolean(""pig.noSplitCombination"", false);
		 Set<FileSpec> seen = new HashSet<FileSpec>();
		 for(MapReduceOper mro_scalar_consumer: mrOpList) {
			 for(PhysicalOperator scalar: mro_scalar_consumer.scalars) {
				 MapReduceOper mro_scalar_producer = phyToMROpMap.get(scalar);
				 if (scalar instanceof POStore) {
					 FileSpec oldSpec = ((POStore)scalar).getSFile();
					 if( seen.contains(oldSpec) ) {
						 continue;
					 }
					 seen.add(oldSpec);
					 if ( combinable && (mro_scalar_producer.reducePlan.isEmpty() ? hasTooManyInputFiles(mro_scalar_producer, conf) : (mro_scalar_producer.requestedParallelism >= fileConcatenationThreshold))) {
						 PhysicalPlan pl = mro_scalar_producer.reducePlan.isEmpty() ? mro_scalar_producer.mapPlan : mro_scalar_producer.reducePlan;
						 FileSpec newSpec = getTempFileSpec();
						 new FindStoreNameVisitor(pl, newSpec, oldSpec).visit();
						 seen.add(newSpec);
						 POStore newSto = getStore();
						 newSto.setSFile(oldSpec);
						 MapReduceOper catMROp = getConcatenateJob(newSpec, mro_scalar_producer, newSto);
						 MRPlan.connect(mro_scalar_producer, catMROp);
						 phyToMROpMap.put(newSto, catMROp);
						 plan.add(newSto);
						 for (PhysicalOperator succ : plan.getSoftLinkSuccessors(scalar).toArray(new PhysicalOperator[0])) {
							 plan.createSoftLink(newSto, succ);
							 plan.removeSoftLink(scalar, succ);
						 }
					 }
				 }
			 }
		 }
	 }
	 public MROperPlan getMRPlan() {
		 return MRPlan;
	 }
	 public PhysicalPlan getPlan() {
		 return plan;
	 }
	 public CompilationMessageCollector getMessageCollector() {
		 return messageCollector;
	 }
	 public MROperPlan compile() throws IOException, PlanException, VisitorException {
		 List<PhysicalOperator> leaves = plan.getLeaves();
		 if (!pigContext.inIllustrator) for (PhysicalOperator op : leaves) {
			 if (!(op instanceof POStore)) {
				 int errCode = 2025;
				 String msg = ""Expected leaf of reduce plan to "" + ""always be POStore. Found "" + op.getClass().getSimpleName();
				 throw new MRCompilerException(msg, errCode, PigException.BUG);
			 }
		 }
		 List<POStore> stores = PlanHelper.getPhysicalOperators(plan, POStore.class);
		 List<PONative> nativeMRs= PlanHelper.getPhysicalOperators(plan, PONative.class);
		 List<PhysicalOperator> ops;
		 if (!pigContext.inIllustrator) {
			 ops = new ArrayList<PhysicalOperator>(stores.size() + nativeMRs.size());
			 ops.addAll(stores);
		 }
		 else {
			 ops = new ArrayList<PhysicalOperator>(leaves.size() + nativeMRs.size());
			 ops.addAll(leaves);
		 }
		 ops.addAll(nativeMRs);
		 Collections.sort(ops);
		 for (PhysicalOperator op : ops) {
			 compile(op);
		 }
		 return MRPlan;
	 }
	 public void connectSoftLink() throws PlanException, IOException {
		 for (PhysicalOperator op : plan) {
			 if (plan.getSoftLinkPredecessors(op)!=null) {
				 for (PhysicalOperator pred : plan.getSoftLinkPredecessors(op)) {
					 MapReduceOper from = phyToMROpMap.get(pred);
					 MapReduceOper to = phyToMROpMap.get(op);
					 if (from==to) continue;
					 if (MRPlan.getPredecessors(to)==null || !MRPlan.getPredecessors(to).contains(from)) {
						 MRPlan.connect(from, to);
					 }
				 }
			 }
		 }
	 }
	 private void compile(PhysicalOperator op) throws IOException, PlanException, VisitorException {
		 MapReduceOper[] prevCompInp = compiledInputs;
		 List<PhysicalOperator> predecessors = plan.getPredecessors(op);
		 if(op instanceof PONative){
		 }
		 else if (predecessors != null && predecessors.size() > 0) {
			 if (op instanceof POLoad) {
				 if (predecessors.size() != 1) {
					 int errCode = 2125;
					 String msg = ""Expected at most one predecessor of load. Got ""+predecessors.size();
					 throw new PlanException(msg, errCode, PigException.BUG);
				 }
				 PhysicalOperator p = predecessors.get(0);
				 MapReduceOper oper = null;
				 if(p instanceof POStore || p instanceof PONative){
					 oper = phyToMROpMap.get(p);
				 }
				else{
					 int errCode = 2126;
					 String msg = ""Predecessor of load should be a store or mapreduce operator. Got ""+p.getClass();
					 throw new PlanException(msg, errCode, PigException.BUG);
				 }
				 curMROp = getMROp();
				 curMROp.mapPlan.add(op);
				 MRPlan.add(curMROp);
				 plan.disconnect(op, p);
				 MRPlan.connect(oper, curMROp);
				 phyToMROpMap.put(op, curMROp);
				 return;
			 }
			 Collections.sort(predecessors);
			 compiledInputs = new MapReduceOper[predecessors.size()];
			 int i = -1;
			 for (PhysicalOperator pred : predecessors) {
				 if(pred instanceof POSplit && splitsSeen.containsKey(pred.getOperatorKey())){
					 compiledInputs[++i] = startNew(((POSplit)pred).getSplitStore(), splitsSeen.get(pred.getOperatorKey()));
					 continue;
				 }
				 compile(pred);
				 compiledInputs[++i] = curMROp;
			 }
		 }
		 else {
			 curMROp = getMROp();
			 curMROp.mapPlan.add(op);
			 if (op !=null && op instanceof POLoad) {
				 if (((POLoad)op).getLFile()!=null && ((POLoad)op).getLFile().getFuncSpec()!=null) curMROp.UDFs.add(((POLoad)op).getLFile().getFuncSpec().toString());
			 }
			 MRPlan.add(curMROp);
			 phyToMROpMap.put(op, curMROp);
			 return;
		 }
		 op.visit(this);
		 if(op.getRequestedParallelism() > curMROp.requestedParallelism ) {
			 if (!curMROp.isSkewedJoin()) {
				 curMROp.requestedParallelism = op.getRequestedParallelism();
			 }
		 }
		 compiledInputs = prevCompInp;
	 }
	 private MapReduceOper getMROp(){
		 return new MapReduceOper(new OperatorKey(scope,nig.getNextNodeId(scope)));
	 }
	 private NativeMapReduceOper getNativeMROp(String mrJar, String[] parameters) {
		 return new NativeMapReduceOper(new OperatorKey(scope,nig.getNextNodeId(scope)), mrJar, parameters);
	 }
	 private POLoad getLoad(){
		 POLoad ld = new POLoad(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 ld.setPc(pigContext);
		 ld.setIsTmpLoad(true);
		 return ld;
	 }
	 private POStore getStore(){
		 POStore st = new POStore(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 st.setIsTmpStore(true);
		 return st;
	 }
	 private void nonBlocking(PhysicalOperator op) throws PlanException, IOException{
		 if (compiledInputs.length == 1) {
			 MapReduceOper mro = compiledInputs[0];
			 if (!mro.isMapDone()) {
				 mro.mapPlan.addAsLeaf(op);
			 }
			 else if (mro.isMapDone() && !mro.isReduceDone()) {
				 mro.reducePlan.addAsLeaf(op);
			 }
			 else {
				 int errCode = 2022;
				 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 curMROp = mro;
		 }
		 else {
			 List<MapReduceOper> mergedPlans = merge(compiledInputs);
			 MapReduceOper mro = mergedPlans.remove(0);
			 mro.mapPlan.addAsLeaf(op);
			 if(mergedPlans.size()>0) connRedOper(mergedPlans, mro);
			 curMROp = mro;
		 }
	 }
	 private void addToMap(PhysicalOperator op) throws PlanException, IOException{
		 if (compiledInputs.length == 1) {
			 MapReduceOper mro = compiledInputs[0];
			 if (!mro.isMapDone()) {
				 mro.mapPlan.addAsLeaf(op);
			 }
			 else if (mro.isMapDone() && !mro.isReduceDone()) {
				 FileSpec fSpec = getTempFileSpec();
				 POStore st = getStore();
				 st.setSFile(fSpec);
				 mro.reducePlan.addAsLeaf(st);
				 mro.setReduceDone(true);
				 mro = startNew(fSpec, mro);
				 mro.mapPlan.addAsLeaf(op);
				 compiledInputs[0] = mro;
			 }
			 else {
				 int errCode = 2022;
				 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 curMROp = mro;
		 }
		 else {
			 List<MapReduceOper> mergedPlans = merge(compiledInputs);
			 MapReduceOper mro = mergedPlans.remove(0);
			 mro.mapPlan.addAsLeaf(op);
			 if(mergedPlans.size()>0) connRedOper(mergedPlans, mro);
			 curMROp = mro;
		 }
	 }
	 private void blocking(PhysicalOperator op) throws IOException, PlanException{
		 if(compiledInputs.length==1){
			 MapReduceOper mro = compiledInputs[0];
			 if (!mro.isMapDone()) {
				 mro.setMapDoneSingle(true);
				 curMROp = mro;
			 }
			 else if(mro.isMapDone() && !mro.isReduceDone()){
				 FileSpec fSpec = getTempFileSpec();
				 POStore st = getStore();
				 st.setSFile(fSpec);
				 mro.reducePlan.addAsLeaf(st);
				 mro.setReduceDone(true);
				 curMROp = startNew(fSpec, mro);
				 curMROp.setMapDone(true);
			 }
		 }
		 else{
			 List<MapReduceOper> mergedPlans = merge(compiledInputs);
			 MapReduceOper mro = mergedPlans.remove(0);
			 if(mergedPlans.size()>0) mro.setMapDoneMultiple(true);
			 else mro.setMapDoneSingle(true);
			 if(mergedPlans.size()>0) connRedOper(mergedPlans, mro);
			 curMROp = mro;
		 }
	 }
	 private void connRedOper(List<MapReduceOper> mergedPlans, MapReduceOper mro) throws PlanException, IOException{
		 PhysicalOperator leaf = null;
		 List<PhysicalOperator> leaves = mro.mapPlan.getLeaves();
		 if(leaves!=null && leaves.size()>0) leaf = leaves.get(0);
		 for (MapReduceOper mmro : mergedPlans) {
			 mmro.setReduceDone(true);
			 FileSpec fileSpec = getTempFileSpec();
			 POLoad ld = getLoad();
			 ld.setLFile(fileSpec);
			 POStore str = getStore();
			 str.setSFile(fileSpec);
			 mmro.reducePlan.addAsLeaf(str);
			 mro.mapPlan.add(ld);
			 if(leaf!=null) mro.mapPlan.connect(ld, leaf);
			 MRPlan.connect(mmro, mro);
		 }
	 }
	 private MapReduceOper endSingleInputPlanWithStr(FileSpec fSpec) throws PlanException{
		 if(compiledInputs.length>1) {
			 int errCode = 2023;
			 String msg = ""Received a multi input plan when expecting only a single input one."";
			 throw new PlanException(msg, errCode, PigException.BUG);
		 }
		 MapReduceOper mro = compiledInputs[0];
		 POStore str = getStore();
		 str.setSFile(fSpec);
		 if (!mro.isMapDone()) {
			 mro.mapPlan.addAsLeaf(str);
			 mro.setMapDoneSingle(true);
		 }
		 else if (mro.isMapDone() && !mro.isReduceDone()) {
			 mro.reducePlan.addAsLeaf(str);
			 mro.setReduceDone(true);
		 }
		 else {
			 int errCode = 2022;
			 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
			 throw new PlanException(msg, errCode, PigException.BUG);
		 }
		 return mro;
	 }
	 private MapReduceOper startNew(FileSpec fSpec, MapReduceOper old) throws PlanException{
		 POLoad ld = getLoad();
		 ld.setLFile(fSpec);
		 MapReduceOper ret = getMROp();
		 ret.mapPlan.add(ld);
		 MRPlan.add(ret);
		 MRPlan.connect(old, ret);
		 return ret;
	 }
	 private FileSpec getTempFileSpec() throws IOException {
		 return new FileSpec(FileLocalizer.getTemporaryPath(pigContext).toString(), new FuncSpec(Utils.getTmpFileCompressorName(pigContext)));
	 }
	 private List<MapReduceOper> merge(MapReduceOper[] compiledInputs) throws PlanException {
		 List<MapReduceOper> ret = new ArrayList<MapReduceOper>();
		 MapReduceOper mergedMap = getMROp();
		 ret.add(mergedMap);
		 MRPlan.add(mergedMap);
		 Set<MapReduceOper> toBeConnected = new HashSet<MapReduceOper>();
		 List<MapReduceOper> remLst = new ArrayList<MapReduceOper>();
		 List<PhysicalPlan> mpLst = new ArrayList<PhysicalPlan>();
		 for (MapReduceOper mro : compiledInputs) {
			 if (!mro.isMapDone()) {
				 remLst.add(mro);
				 mpLst.add(mro.mapPlan);
				 List<MapReduceOper> pmros = MRPlan.getPredecessors(mro);
				 if(pmros!=null){
					 for(MapReduceOper pmro : pmros) toBeConnected.add(pmro);
				 }
			 }
			 else if (mro.isMapDone() && !mro.isReduceDone()) {
				 ret.add(mro);
			 }
			 else {
				 int errCode = 2027;
				 String msg = ""Both map and reduce phases have been done. This is unexpected for a merge."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
		 }
		 merge(ret.get(0).mapPlan, mpLst);
		 Iterator<MapReduceOper> it = toBeConnected.iterator();
		 while(it.hasNext()) MRPlan.connect(it.next(), mergedMap);
		 for(MapReduceOper rmro : remLst){
			 if(rmro.requestedParallelism > mergedMap.requestedParallelism) mergedMap.requestedParallelism = rmro.requestedParallelism;
			 for (String udf:rmro.UDFs) {
				 if (!mergedMap.UDFs.contains(udf)) mergedMap.UDFs.add(udf);
			 }
			 for(PhysicalOperator physOp: rmro.scalars) {
				 if(!mergedMap.scalars.contains(physOp)) {
					 mergedMap.scalars.add(physOp);
				 }
			 }
			 Set<PhysicalOperator> opsToChange = new HashSet<PhysicalOperator>();
			 for (Map.Entry<PhysicalOperator, MapReduceOper> entry : phyToMROpMap.entrySet()) {
				 if (entry.getValue()==rmro) {
					 opsToChange.add(entry.getKey());
				 }
			 }
			 for (PhysicalOperator op : opsToChange) {
				 phyToMROpMap.put(op, mergedMap);
			 }
			 MRPlan.remove(rmro);
		 }
		 return ret;
	 }
	 private <O extends Operator, E extends OperatorPlan<O>> void merge( E finPlan, List<E> plans) throws PlanException {
		 for (E e : plans) {
			 finPlan.merge(e);
		 }
	 }
	 private void processUDFs(PhysicalPlan plan) throws VisitorException{
		 if(plan!=null){
			 ScalarPhyFinder scalarPhyFinder = new ScalarPhyFinder(plan);
			 scalarPhyFinder.visit();
			 curMROp.scalars.addAll(scalarPhyFinder.getScalars());
			 udfFinder.setPlan(plan);
			 udfFinder.visit();
			 curMROp.UDFs.addAll(udfFinder.getUDFs());
		 }
	 }
	 public void visitSplit(POSplit op) throws VisitorException{
		 try{
			 FileSpec fSpec = op.getSplitStore();
			 MapReduceOper mro = endSingleInputPlanWithStr(fSpec);
			 mro.setSplitter(true);
			 splitsSeen.put(op.getOperatorKey(), mro);
			 curMROp = startNew(fSpec, mro);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitLoad(POLoad op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitNative(PONative op) throws VisitorException{
		 try{
			 MapReduceOper nativeMROper = getNativeMROp(op.getNativeMRjar(), op.getParams());
			 MRPlan.add(nativeMROper);
			 MRPlan.connect(curMROp, nativeMROper);
			 phyToMROpMap.put(op, nativeMROper);
			 curMROp = nativeMROper;
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitStore(POStore op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 phyToMROpMap.put(op, curMROp);
			 if (op.getSFile()!=null && op.getSFile().getFuncSpec()!=null) curMROp.UDFs.add(op.getSFile().getFuncSpec().toString());
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitFilter(POFilter op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 processUDFs(op.getPlan());
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitCross(POCross op) throws VisitorException {
		 try{
			 nonBlocking(op);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitStream(POStream op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitLimit(POLimit op) throws VisitorException{
		 try{
			 MapReduceOper mro = compiledInputs[0];
			 mro.limit = op.getLimit();
			 if (op.getLimitPlan() != null) {
				 processUDFs(op.getLimitPlan());
				 mro.limitPlan = op.getLimitPlan();
			 }
			 if (!mro.isMapDone()) {
				 if (!pigContext.inIllustrator) {
					 mro.mapPlan.addAsLeaf(op);
					 mro.setMapDone(true);
				 }
				 if (mro.reducePlan.isEmpty()) {
					 MRUtil.simpleConnectMapToReduce(mro, scope, nig);
					 mro.requestedParallelism = 1;
					 if (!pigContext.inIllustrator) {
						 POLimit pLimit2 = new POLimit(new OperatorKey(scope,nig.getNextNodeId(scope)));
						 pLimit2.setLimit(op.getLimit());
						 pLimit2.setLimitPlan(op.getLimitPlan());
						 mro.reducePlan.addAsLeaf(pLimit2);
					 }
					 else {
						 mro.reducePlan.addAsLeaf(op);
					 }
				 }
				 else {
					 messageCollector.collect(""Something in the reduce plan while map plan is not done. Something wrong!"", MessageType.Warning, PigWarning.REDUCE_PLAN_NOT_EMPTY_WHILE_MAP_PLAN_UNDER_PROCESS);
				 }
			 }
			 else if (mro.isMapDone() && !mro.isReduceDone()) {
				 mro.reducePlan.addAsLeaf(op);
			 }
			 else {
				 messageCollector.collect(""Both map and reduce phases have been done. This is unexpected while compiling!"", MessageType.Warning, PigWarning.UNREACHABLE_CODE_BOTH_MAP_AND_REDUCE_PLANS_PROCESSED);
			 }
			 phyToMROpMap.put(op, mro);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitLocalRearrange(POLocalRearrange op) throws VisitorException {
		 try{
			 addToMap(op);
			 List<PhysicalPlan> plans = op.getPlans();
			 if(plans!=null) for(PhysicalPlan ep : plans) processUDFs(ep);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitCollectedGroup(POCollectedGroup op) throws VisitorException {
		 if(!curMROp.mapDone){
			 List<PhysicalOperator> roots = curMROp.mapPlan.getRoots();
			 if(roots.size() != 1){
				 int errCode = 2171;
				 String errMsg = ""Expected one but found more then one root physical operator in physical plan."";
				 throw new MRCompilerException(errMsg,errCode,PigException.BUG);
			 }
			 PhysicalOperator phyOp = roots.get(0);
			 if(! (phyOp instanceof POLoad)){
				 int errCode = 2172;
				 String errMsg = ""Expected physical operator at root to be POLoad. Found : ""+phyOp.getClass().getCanonicalName();
				 throw new MRCompilerException(errMsg,errCode,PigException.BUG);
			 }
			 LoadFunc loadFunc = ((POLoad)phyOp).getLoadFunc();
			 try {
				 if(!(CollectableLoadFunc.class.isAssignableFrom(loadFunc.getClass()))){
					 int errCode = 2249;
					 throw new MRCompilerException(""While using 'collected' on group;
					 data must be loaded via loader implementing CollectableLoadFunc."", errCode);
				 }
				 ((CollectableLoadFunc)loadFunc).ensureAllKeyInstancesInSameSplit();
			 }
			 catch (MRCompilerException e){
				 throw (e);
			 }
			 catch (IOException e) {
				 int errCode = 2034;
				 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
				 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
			 }
			 try{
				 nonBlocking(op);
				 List<PhysicalPlan> plans = op.getPlans();
				 if(plans!=null) for(PhysicalPlan ep : plans) processUDFs(ep);
				 phyToMROpMap.put(op, curMROp);
			 }
			catch(Exception e){
				 int errCode = 2034;
				 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
				 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
			 }
		 }
		 else if(!curMROp.reduceDone){
			 int errCode=2250;
			 String msg = ""Blocking operators are not allowed before Collected Group. Consider dropping using 'collected'."";
			 throw new MRCompilerException(msg, errCode, PigException.BUG);
		 }
		 else{
			 int errCode = 2022;
			 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
			 throw new MRCompilerException(msg, errCode, PigException.BUG);
		 }
	 }
	 public void visitPOForEach(POForEach op) throws VisitorException{
		 try{
			 if (op.isMapSideOnly() && curMROp.isMapDone()) {
				 FileSpec fSpec = getTempFileSpec();
				 MapReduceOper prevMROper = endSingleInputPlanWithStr(fSpec);
				 curMROp = startNew(fSpec, prevMROper);
				 curMROp.mapPlan.addAsLeaf(op);
			 }
			 else {
				 nonBlocking(op);
			 }
			 List<PhysicalPlan> plans = op.getInputPlans();
			 if(plans!=null) for (PhysicalPlan plan : plans) {
				 processUDFs(plan);
			 }
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitGlobalRearrange(POGlobalRearrange op) throws VisitorException{
		 try{
			 blocking(op);
			 curMROp.customPartitioner = op.getCustomPartitioner();
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitPackage(POPackage op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 phyToMROpMap.put(op, curMROp);
			 if (op.getPkgr().getPackageType() == PackageType.JOIN || op.getPkgr().getPackageType() == PackageType.BLOOMJOIN) {
				 curMROp.markRegularJoin();
			 }
			 else if (op.getPkgr().getPackageType() == PackageType.GROUP) {
				 if (op.getNumInps() == 1) {
					 curMROp.markGroupBy();
				 }
				 else if (op.getNumInps() > 1) {
					 curMROp.markCogroup();
				 }
			 }
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitUnion(POUnion op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitFRJoin(POFRJoin op) throws VisitorException {
		 try{
			 FileSpec[] replFiles = new FileSpec[op.getInputs().size()];
			 for (int i=0;
			 i<replFiles.length;
			 i++) {
				 if(i==op.getFragment()) continue;
				 replFiles[i] = getTempFileSpec();
			 }
			 op.setReplFiles(replFiles);
			 curMROp = phyToMROpMap.get(op.getInputs().get(op.getFragment()));
			 for(int i=0;
			i<compiledInputs.length;
			i++){
				 MapReduceOper mro = compiledInputs[i];
				 if(curMROp.equals(mro)) continue;
				 POStore str = getStore();
				 str.setSFile(replFiles[i]);
				 Configuration conf = ConfigurationUtil.toConfiguration(pigContext.getProperties());
				 boolean combinable = !conf.getBoolean(""pig.noSplitCombination"", false);
				 if (!mro.isMapDone()) {
					 if (combinable && hasTooManyInputFiles(mro, conf)) {
						 POStore tmpSto = getStore();
						 FileSpec fSpec = getTempFileSpec();
						 tmpSto.setSFile(fSpec);
						 mro.mapPlan.addAsLeaf(tmpSto);
						 mro.setMapDoneSingle(true);
						 MapReduceOper catMROp = getConcatenateJob(fSpec, mro, str);
						 MRPlan.connect(catMROp, curMROp);
					 }
					 else {
						 mro.mapPlan.addAsLeaf(str);
						 mro.setMapDoneSingle(true);
						 MRPlan.connect(mro, curMROp);
					 }
				 }
				 else if (mro.isMapDone() && !mro.isReduceDone()) {
					 if (combinable && (mro.requestedParallelism >= fileConcatenationThreshold)) {
						 POStore tmpSto = getStore();
						 FileSpec fSpec = getTempFileSpec();
						 tmpSto.setSFile(fSpec);
						 mro.reducePlan.addAsLeaf(tmpSto);
						 mro.setReduceDone(true);
						 MapReduceOper catMROp = getConcatenateJob(fSpec, mro, str);
						 MRPlan.connect(catMROp, curMROp);
					 }
					 else {
						 mro.reducePlan.addAsLeaf(str);
						 mro.setReduceDone(true);
						 MRPlan.connect(mro, curMROp);
					 }
				 }
				 else {
					 int errCode = 2022;
					 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
					 throw new PlanException(msg, errCode, PigException.BUG);
				 }
			 }
			 if (!curMROp.isMapDone()) {
				 curMROp.mapPlan.addAsLeaf(op);
			 }
			 else if (curMROp.isMapDone() && !curMROp.isReduceDone()) {
				 curMROp.reducePlan.addAsLeaf(op);
			 }
			 else {
				 int errCode = 2022;
				 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 List<List<PhysicalPlan>> joinPlans = op.getJoinPlans();
			 if(joinPlans!=null) for (List<PhysicalPlan> joinPlan : joinPlans) {
				 if(joinPlan!=null) for (PhysicalPlan plan : joinPlan) {
					 processUDFs(plan);
				 }
			 }
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 private boolean hasTooManyInputFiles(MapReduceOper mro, Configuration conf) {
		 if (pigContext == null || pigContext.getExecType() == ExecType.LOCAL) {
			 return false;
		 }
		 if (mro instanceof NativeMapReduceOper) {
			 return optimisticFileConcatenation ? false : true;
		 }
		 PhysicalPlan mapPlan = mro.mapPlan;
		 List<PhysicalOperator> roots = mapPlan.getRoots();
		 if (roots == null || roots.size() == 0) return false;
		 int numFiles = 0;
		 boolean ret = false;
		 try {
			 for (PhysicalOperator root : roots) {
				 POLoad ld = (POLoad) root;
				 String fileName = ld.getLFile().getFileName();
				 if(UriUtil.isHDFSFile(fileName)){
					 String [] locations = LoadFunc.getPathStrings(fileName);
					 for(String location : locations){
						 if(!UriUtil.isHDFSFile(location)) continue;
						 Path path = new Path(location);
						 FileSystem fs = path.getFileSystem(conf);
						 if (fs.exists(path)) {
							 LoadFunc loader = (LoadFunc) PigContext .instantiateFuncFromSpec(ld.getLFile() .getFuncSpec());
							 Job job = new Job(conf);
							 loader.setUDFContextSignature(ld.getSignature());
							 loader.setLocation(location, job);
							 InputFormat inf = loader.getInputFormat();
							 List<InputSplit> splits = inf.getSplits(HadoopShims.cloneJobContext(job));
							 List<List<InputSplit>> results = MapRedUtil .getCombinePigSplits(splits, fs.getDefaultBlockSize(path), conf);
							 numFiles += results.size();
						 }
						 else {
							 List<MapReduceOper> preds = MRPlan.getPredecessors(mro);
							 if (preds != null && preds.size() == 1) {
								 MapReduceOper pred = preds.get(0);
								 if (!pred.reducePlan.isEmpty()) {
									 numFiles += pred.requestedParallelism;
								 }
								 else {
									 ret = hasTooManyInputFiles(pred, conf);
									 break;
								 }
							 }
							 else if (!optimisticFileConcatenation) {
								 numFiles = fileConcatenationThreshold;
								 break;
							 }
						 }
					 }
				 }
			 }
		 }
		 catch (IOException e) {
			 LOG.warn(""failed to get number of input files"", e);
		 }
		 catch (InterruptedException e) {
			 LOG.warn(""failed to get number of input files"", e);
		 }
		 LOG.info(""number of input files: "" + numFiles);
		 return ret ? true : (numFiles >= fileConcatenationThreshold);
	 }
	 private MapReduceOper getConcatenateJob(FileSpec fSpec, MapReduceOper old, POStore str) throws PlanException, ExecException {
		 MapReduceOper mro = startNew(fSpec, old);
		 mro.mapPlan.addAsLeaf(str);
		 mro.setMapDone(true);
		 LOG.info(""Insert a file-concatenation job"");
		 return mro;
	 }
	 public void visitMergeCoGroup(POMergeCogroup poCoGrp) throws VisitorException {
		 if(compiledInputs.length < 2){
			 int errCode=2251;
			 String errMsg = ""Merge Cogroup work on two or more relations."" + ""To use map-side group-by on single relation, use 'collected' qualifier."";
			 throw new MRCompilerException(errMsg, errCode);
		 }
		 List<FuncSpec> funcSpecs = new ArrayList<FuncSpec>(compiledInputs.length-1);
		 List<String> fileSpecs = new ArrayList<String>(compiledInputs.length-1);
		 List<String> loaderSigns = new ArrayList<String>(compiledInputs.length-1);
		 try{
			 for(int i=0 ;
			 i < compiledInputs.length;
			 i++){
				 MapReduceOper mrOper = compiledInputs[i];
				 PhysicalPlan mapPlan = mrOper.mapPlan;
				 if(mapPlan.getRoots().size() != 1){
					 int errCode = 2171;
					 String errMsg = ""Expected one but found more then one root physical operator in physical plan."";
					 throw new MRCompilerException(errMsg,errCode,PigException.BUG);
				 }
				 PhysicalOperator rootPOOp = mapPlan.getRoots().get(0);
				 if(! (rootPOOp instanceof POLoad)){
					 int errCode = 2172;
					 String errMsg = ""Expected physical operator at root to be POLoad. Found : ""+rootPOOp.getClass().getCanonicalName();
					 throw new MRCompilerException(errMsg,errCode);
				 }
				 POLoad sideLoader = (POLoad)rootPOOp;
				 FileSpec loadFileSpec = sideLoader.getLFile();
				 FuncSpec funcSpec = loadFileSpec.getFuncSpec();
				 LoadFunc loadfunc = sideLoader.getLoadFunc();
				 if(i == 0){
					 if(!(CollectableLoadFunc.class.isAssignableFrom(loadfunc.getClass()))){
						 int errCode = 2252;
						 throw new MRCompilerException(""Base loader in Cogroup must implement CollectableLoadFunc."", errCode);
					 }
					 ((CollectableLoadFunc)loadfunc).ensureAllKeyInstancesInSameSplit();
					 continue;
				 }
				 if(!(IndexableLoadFunc.class.isAssignableFrom(loadfunc.getClass()))){
					 int errCode = 2253;
					 throw new MRCompilerException(""Side loaders in cogroup must implement IndexableLoadFunc."", errCode);
				 }
				 funcSpecs.add(funcSpec);
				 fileSpecs.add(loadFileSpec.getFileName());
				 loaderSigns.add(sideLoader.getSignature());
				 MRPlan.remove(mrOper);
			 }
			 poCoGrp.setSideLoadFuncs(funcSpecs);
			 poCoGrp.setSideFileSpecs(fileSpecs);
			 poCoGrp.setLoaderSignatures(loaderSigns);
			 MapReduceOper baseMROp = phyToMROpMap.get(poCoGrp.getInputs().get(0));
			 if(baseMROp.mapDone || !baseMROp.reducePlan.isEmpty()){
				 int errCode = 2254;
				 throw new MRCompilerException(""Currently merged cogroup is not supported after blocking operators."", errCode);
			 }
			 MapReduceOper indexerMROp = getMROp();
			 FileSpec idxFileSpec = getIndexingJob(indexerMROp, baseMROp, poCoGrp.getLRInnerPlansOf(0));
			 poCoGrp.setIdxFuncSpec(idxFileSpec.getFuncSpec());
			 poCoGrp.setIndexFileName(idxFileSpec.getFileName());
			 baseMROp.mapPlan.addAsLeaf(poCoGrp);
			 for (FuncSpec funcSpec : funcSpecs) baseMROp.UDFs.add(funcSpec.toString());
			 MRPlan.add(indexerMROp);
			 MRPlan.connect(indexerMROp, baseMROp);
			 phyToMROpMap.put(poCoGrp,baseMROp);
			 curMROp = baseMROp;
		 }
		 catch (ExecException e){
			 throw new MRCompilerException(e.getDetailedMessage(),e.getErrorCode(),e.getErrorSource(),e);
		 }
		 catch (MRCompilerException mrce){
			 throw(mrce);
		 }
		 catch (CloneNotSupportedException e) {
			 throw new MRCompilerException(e);
		 }
		 catch(PlanException e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + poCoGrp.getClass().getCanonicalName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
		 catch (IOException e){
			 int errCode = 3000;
			 String errMsg = ""IOException caught while compiling POMergeCoGroup"";
			 throw new MRCompilerException(errMsg, errCode,e);
		 }
	 }
	 private FileSpec getIndexingJob(MapReduceOper indexerMROp, final MapReduceOper baseMROp, final List<PhysicalPlan> mapperLRInnerPlans) throws MRCompilerException, PlanException, ExecException, IOException, CloneNotSupportedException {
		 PhysicalPlan baseMapPlan = baseMROp.mapPlan;
		 POLoad baseLoader = (POLoad)baseMapPlan.getRoots().get(0);
		 FileSpec origLoaderFileSpec = baseLoader.getLFile();
		 FuncSpec funcSpec = origLoaderFileSpec.getFuncSpec();
		 LoadFunc loadFunc = baseLoader.getLoadFunc();
		 if (! (OrderedLoadFunc.class.isAssignableFrom(loadFunc.getClass()))){
			 int errCode = 1104;
			 String errMsg = ""Base relation of merge-coGroup must implement "" + ""OrderedLoadFunc interface. The specified loader "" + funcSpec + "" doesn't implement it"";
			 throw new MRCompilerException(errMsg,errCode);
		 }
		 String[] indexerArgs = new String[6];
		 indexerArgs[0] = funcSpec.toString();
		 indexerArgs[1] = ObjectSerializer.serialize((Serializable)mapperLRInnerPlans);
		 indexerArgs[3] = baseLoader.getSignature();
		 indexerArgs[4] = baseLoader.getOperatorKey().scope;
		 indexerArgs[5] = Boolean.toString(false);
		 PhysicalPlan phyPlan;
		 if (baseMapPlan.getSuccessors(baseLoader) == null || baseMapPlan.getSuccessors(baseLoader).isEmpty()){
			 phyPlan = null;
		 }
		 else{
			 phyPlan = baseMapPlan.clone();
			 PhysicalOperator root = phyPlan.getRoots().get(0);
			 phyPlan.disconnect(root, phyPlan.getSuccessors(root).get(0));
			 phyPlan.remove(root);
		 }
		 indexerArgs[2] = ObjectSerializer.serialize(phyPlan);
		 POLoad idxJobLoader = getLoad();
		 idxJobLoader.setLFile(new FileSpec(origLoaderFileSpec.getFileName(), new FuncSpec(MergeJoinIndexer.class.getName(), indexerArgs)));
		 indexerMROp.mapPlan.add(idxJobLoader);
		 indexerMROp.UDFs.add(baseLoader.getLFile().getFuncSpec().toString());
		 MRUtil.simpleConnectMapToReduce(indexerMROp, scope, nig);
		 indexerMROp.requestedParallelism = 1;
		 indexerMROp.useTypedComparator(true);
		 POStore st = getStore();
		 FileSpec strFile = getTempFileSpec();
		 st.setSFile(strFile);
		 indexerMROp.reducePlan.addAsLeaf(st);
		 indexerMROp.setReduceDone(true);
		 return strFile;
	 }
	 public void visitMergeJoin(POMergeJoin joinOp) throws VisitorException {
		 try{
			 if(compiledInputs.length != 2 || joinOp.getInputs().size() != 2){
				 int errCode=1101;
				 throw new MRCompilerException(""Merge Join must have exactly two inputs. Found : ""+compiledInputs.length, errCode);
			 }
			 curMROp = phyToMROpMap.get(joinOp.getInputs().get(0));
			 MapReduceOper rightMROpr = null;
			 if(curMROp.equals(compiledInputs[0])) rightMROpr = compiledInputs[1];
			 else rightMROpr = compiledInputs[0];
			 PhysicalPlan rightPipelinePlan;
			 if(!rightMROpr.mapDone){
				 PhysicalPlan rightMapPlan = rightMROpr.mapPlan;
				 if(rightMapPlan.getRoots().size() != 1){
					 int errCode = 2171;
					 String errMsg = ""Expected one but found more then one root physical operator in physical plan."";
					 throw new MRCompilerException(errMsg,errCode,PigException.BUG);
				 }
				 PhysicalOperator rightLoader = rightMapPlan.getRoots().get(0);
				 if(! (rightLoader instanceof POLoad)){
					 int errCode = 2172;
					 String errMsg = ""Expected physical operator at root to be POLoad. Found : ""+rightLoader.getClass().getCanonicalName();
					 throw new MRCompilerException(errMsg,errCode);
				 }
				 if (rightMapPlan.getSuccessors(rightLoader) == null || rightMapPlan.getSuccessors(rightLoader).isEmpty()) rightPipelinePlan = null;
				 else{
					 rightPipelinePlan = rightMapPlan.clone();
					 PhysicalOperator root = rightPipelinePlan.getRoots().get(0);
					 rightPipelinePlan.disconnect(root, rightPipelinePlan.getSuccessors(root).get(0));
					 rightPipelinePlan.remove(root);
					 rightMapPlan.trimBelow(rightLoader);
				 }
			 }
			 else if(!rightMROpr.reduceDone){
				 POStore rightStore = getStore();
				 FileSpec rightStrFile = getTempFileSpec();
				 rightStore.setSFile(rightStrFile);
				 rightMROpr.reducePlan.addAsLeaf(rightStore);
				 rightMROpr.setReduceDone(true);
				 rightMROpr = startNew(rightStrFile, rightMROpr);
				 rightPipelinePlan = null;
			 }
			 else{
				 int errCode = 2022;
				 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 joinOp.setupRightPipeline(rightPipelinePlan);
			 rightMROpr.requestedParallelism = 1;
			 POLoad rightLoader = (POLoad)rightMROpr.mapPlan.getRoots().get(0);
			 joinOp.setSignature(rightLoader.getSignature());
			 LoadFunc rightLoadFunc = rightLoader.getLoadFunc();
			 List<String> udfs = new ArrayList<String>();
			 if(IndexableLoadFunc.class.isAssignableFrom(rightLoadFunc.getClass())) {
				 joinOp.setRightLoaderFuncSpec(rightLoader.getLFile().getFuncSpec());
				 joinOp.setRightInputFileName(rightLoader.getLFile().getFileName());
				 udfs.add(rightLoader.getLFile().getFuncSpec().toString());
				 MRPlan.remove(rightMROpr);
				 if(rightMROpr == compiledInputs[0]) {
					 compiledInputs[0] = null;
				 }
				 else if(rightMROpr == compiledInputs[1]) {
					 compiledInputs[1] = null;
				 }
				 rightMROpr = null;
				 int numInputs = mPlan.getPredecessors(joinOp).size();
				 for(int i = 0;
				 i < numInputs;
				 i++) {
					 List<PhysicalPlan> keyPlans = joinOp.getInnerPlansOf(i);
					 for (PhysicalPlan keyPlan : keyPlans) {
						 for(PhysicalOperator op : keyPlan) {
							 if(!(op instanceof POProject)) {
								 int errCode = 1106;
								 String errMsg = ""Merge join is possible only for simple column or '*' join keys when using "" + rightLoader.getLFile().getFuncSpec() + "" as the loader"";
								 throw new MRCompilerException(errMsg, errCode, PigException.INPUT);
							 }
						 }
					 }
				 }
			 }
			 else {
				 LoadFunc loadFunc = rightLoader.getLoadFunc();
				 if (joinOp.getJoinType() == LOJoin.JOINTYPE.MERGESPARSE) {
					 int errCode = 1104;
					 String errMsg = ""Right input of merge-join must implement IndexableLoadFunc. "" + ""The specified loader "" + loadFunc + "" doesn't implement it"";
					 throw new MRCompilerException(errMsg,errCode);
				 }
				 if (! (OrderedLoadFunc.class.isAssignableFrom(loadFunc.getClass()))){
					 int errCode = 1104;
					 String errMsg = ""Right input of merge-join must implement "" + ""OrderedLoadFunc interface. The specified loader "" + loadFunc + "" doesn't implement it"";
					 throw new MRCompilerException(errMsg,errCode);
				 }
				 String[] indexerArgs = new String[6];
				 List<PhysicalPlan> rightInpPlans = joinOp.getInnerPlansOf(1);
				 FileSpec origRightLoaderFileSpec = rightLoader.getLFile();
				 indexerArgs[0] = origRightLoaderFileSpec.getFuncSpec().toString();
				 indexerArgs[1] = ObjectSerializer.serialize((Serializable)rightInpPlans);
				 indexerArgs[2] = ObjectSerializer.serialize(rightPipelinePlan);
				 indexerArgs[3] = rightLoader.getSignature();
				 indexerArgs[4] = rightLoader.getOperatorKey().scope;
				 indexerArgs[5] = Boolean.toString(true);
				 FileSpec lFile = new FileSpec(rightLoader.getLFile().getFileName(),new FuncSpec(MergeJoinIndexer.class.getName(), indexerArgs));
				 rightLoader.setLFile(lFile);
				 MRUtil.simpleConnectMapToReduce(rightMROpr, scope, nig);
				 rightMROpr.useTypedComparator(true);
				 POStore st = getStore();
				 FileSpec strFile = getTempFileSpec();
				 st.setSFile(strFile);
				 rightMROpr.reducePlan.addAsLeaf(st);
				 rightMROpr.setReduceDone(true);
				 String[] defaultIndexableLoaderArgs = new String[5];
				 defaultIndexableLoaderArgs[0] = origRightLoaderFileSpec.getFuncSpec().toString();
				 defaultIndexableLoaderArgs[1] = strFile.getFileName();
				 defaultIndexableLoaderArgs[2] = strFile.getFuncSpec().toString();
				 defaultIndexableLoaderArgs[3] = joinOp.getOperatorKey().scope;
				 defaultIndexableLoaderArgs[4] = origRightLoaderFileSpec.getFileName();
				 joinOp.setRightLoaderFuncSpec((new FuncSpec(DefaultIndexableLoader.class.getName(), defaultIndexableLoaderArgs)));
				 joinOp.setRightInputFileName(origRightLoaderFileSpec.getFileName());
				 joinOp.setIndexFile(strFile.getFileName());
				 udfs.add(origRightLoaderFileSpec.getFuncSpec().toString());
			 }
			 if(!curMROp.mapDone) curMROp.mapPlan.addAsLeaf(joinOp);
			 else if(!curMROp.reduceDone){
				 POStore leftStore = getStore();
				 FileSpec leftStrFile = getTempFileSpec();
				 leftStore.setSFile(leftStrFile);
				 curMROp.reducePlan.addAsLeaf(leftStore);
				 curMROp.setReduceDone(true);
				 curMROp = startNew(leftStrFile, curMROp);
				 curMROp.mapPlan.addAsLeaf(joinOp);
			 }
			 else{
				 int errCode = 2022;
				 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 if(rightMROpr != null) {
				 rightMROpr.markIndexer();
				 MRPlan.connect(rightMROpr, curMROp);
			 }
			 phyToMROpMap.put(joinOp, curMROp);
			 curMROp.noCombineSmallSplits();
			 curMROp.UDFs.addAll(udfs);
		 }
		 catch(PlanException e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + joinOp.getClass().getCanonicalName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
		 catch (IOException e){
			 int errCode = 3000;
			 String errMsg = ""IOException caught while compiling POMergeJoin"";
			 throw new MRCompilerException(errMsg, errCode,e);
		 }
		 catch(CloneNotSupportedException e){
			 int errCode = 2127;
			 String errMsg = ""Cloning exception caught while compiling POMergeJoin"";
			 throw new MRCompilerException(errMsg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitDistinct(PODistinct op) throws VisitorException {
		 try{
			 PhysicalPlan ep = new PhysicalPlan();
			 POProject prjStar = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prjStar.setResultType(DataType.TUPLE);
			 prjStar.setStar(true);
			 ep.add(prjStar);
			 List<PhysicalPlan> eps = new ArrayList<PhysicalPlan>();
			 eps.add(ep);
			 POLocalRearrange lr = new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 lr.setIndex(0);
			 lr.setKeyType(DataType.TUPLE);
			 lr.setPlans(eps);
			 lr.setResultType(DataType.TUPLE);
			 lr.setDistinct(true);
			 addToMap(lr);
			 blocking(op);
			 curMROp.customPartitioner = op.getCustomPartitioner();
			 POPackage pkg = new POPackage(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 Packager pkgr = pkg.getPkgr();
			 pkgr.setKeyType(DataType.TUPLE);
			 pkgr.setDistinct(true);
			 pkg.setNumInps(1);
			 boolean[] inner = {
			false}
			;
			 pkgr.setInner(inner);
			 curMROp.reducePlan.add(pkg);
			 List<PhysicalPlan> eps1 = new ArrayList<PhysicalPlan>();
			 List<Boolean> flat1 = new ArrayList<Boolean>();
			 PhysicalPlan ep1 = new PhysicalPlan();
			 POProject prj1 = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prj1.setResultType(DataType.TUPLE);
			 prj1.setStar(false);
			 prj1.setColumn(0);
			 prj1.setOverloaded(false);
			 ep1.add(prj1);
			 eps1.add(ep1);
			 flat1.add(true);
			 POForEach nfe1 = new POForEach(new OperatorKey(scope, nig .getNextNodeId(scope)), op.getRequestedParallelism(), eps1, flat1);
			 nfe1.setResultType(DataType.BAG);
			 curMROp.reducePlan.addAsLeaf(nfe1);
			 curMROp.setNeedsDistinctCombiner(true);
			 phyToMROpMap.put(op, curMROp);
			 curMROp.phyToMRMap.put(op, nfe1);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitSkewedJoin(POSkewedJoin op) throws VisitorException {
		 try {
			 if (compiledInputs.length != 2) {
				 int errCode = 2255;
				 throw new VisitorException(""POSkewedJoin operator has "" + compiledInputs.length + "" inputs. It should have 2."", errCode);
			 }
			 FileSpec fSpec = getTempFileSpec();
			 MapReduceOper mro = compiledInputs[0];
			 POStore str = getStore();
			 str.setSFile(fSpec);
			 if (!mro.isMapDone()) {
				 mro.mapPlan.addAsLeaf(str);
				 mro.setMapDoneSingle(true);
			 }
			 else if (mro.isMapDone() && !mro.isReduceDone()) {
				 mro.reducePlan.addAsLeaf(str);
				 mro.setReduceDone(true);
			 }
			 else {
				 int errCode = 2022;
				 String msg = ""Both map and reduce phases have been done. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 FileSpec partitionFile = getTempFileSpec();
			 int rp = op.getRequestedParallelism();
			 Pair<MapReduceOper, Integer> sampleJobPair = getSkewedJoinSampleJob(op, mro, fSpec, partitionFile, rp);
			 rp = sampleJobPair.second;
			 op.setRequestedParallelism(rp);
			 MapReduceOper[] joinInputs = new MapReduceOper[] {
			startNew(fSpec, sampleJobPair.first), compiledInputs[1]}
			;
			 MapReduceOper[] rearrangeOutputs = new MapReduceOper[2];
			 compiledInputs = new MapReduceOper[] {
			joinInputs[0]}
			;
			 POLocalRearrange lr = new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)), rp);
			 try {
				 lr.setIndex(0);
			 }
			 catch (ExecException e) {
				 int errCode = 2058;
				 String msg = ""Unable to set index on newly created POLocalRearrange."";
				 throw new PlanException(msg, errCode, PigException.BUG, e);
			 }
			 List<PhysicalOperator> l = plan.getPredecessors(op);
			 MultiMap<PhysicalOperator, PhysicalPlan> joinPlans = op.getJoinPlans();
			 List<PhysicalPlan> groups = joinPlans.get(l.get(0));
			 byte type = DataType.TUPLE;
			 if (groups.size() == 1) {
				 type = groups.get(0).getLeaves().get(0).getResultType();
			 }
			 lr.setKeyType(type);
			 lr.setPlans(groups);
			 lr.setResultType(DataType.TUPLE);
			 lr.visit(this);
			 if(lr.getRequestedParallelism() > curMROp.requestedParallelism) curMROp.requestedParallelism = lr.getRequestedParallelism();
			 rearrangeOutputs[0] = curMROp;
			 compiledInputs = new MapReduceOper[] {
			joinInputs[1]}
			;
			 if (compiledInputs[0].isMapDone() && !compiledInputs[0].isReduceDone()) {
				 FileSpec f = getTempFileSpec();
				 POStore s = getStore();
				 s.setSFile(f);
				 compiledInputs[0].reducePlan.addAsLeaf(s);
				 compiledInputs[0].setReduceDone(true);
				 compiledInputs[0] = startNew(f, compiledInputs[0]);
			 }
			 POPartitionRearrange pr = new POPartitionRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)), rp);
			 pr.setPigContext(pigContext);
			 lr = pr;
			 try {
				 lr.setIndex(1);
			 }
			 catch (ExecException e) {
				 int errCode = 2058;
				 String msg = ""Unable to set index on newly created POLocalRearrange."";
				 throw new PlanException(msg, errCode, PigException.BUG, e);
			 }
			 groups = joinPlans.get(l.get(1));
			 lr.setPlans(groups);
			 lr.setKeyType(type);
			 lr.setResultType(DataType.BAG);
			 lr.visit(this);
			 if(lr.getRequestedParallelism() > curMROp.requestedParallelism) curMROp.requestedParallelism = lr.getRequestedParallelism();
			 rearrangeOutputs[1] = curMROp;
			 compiledInputs = rearrangeOutputs;
			 POGlobalRearrange gr = new POGlobalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)), rp);
			 gr.setResultType(DataType.TUPLE);
			 gr.visit(this);
			 if(gr.getRequestedParallelism() > curMROp.requestedParallelism) curMROp.requestedParallelism = gr.getRequestedParallelism();
			 compiledInputs = new MapReduceOper[] {
			curMROp}
			;
			 POPackage pkg = new POPackage(new OperatorKey(scope,nig.getNextNodeId(scope)), rp);
			 Packager pkgr = pkg.getPkgr();
			 pkgr.setKeyType(type);
			 pkg.setResultType(DataType.TUPLE);
			 pkg.setNumInps(2);
			 boolean [] inner = op.getInnerFlags();
			 pkgr.setInner(inner);
			 pkg.visit(this);
			 compiledInputs = new MapReduceOper[] {
			curMROp}
			;
			 List<PhysicalPlan> eps = new ArrayList<PhysicalPlan>();
			 List<Boolean> flat = new ArrayList<Boolean>();
			 PhysicalPlan ep;
			 for (int i=0;
			 i < 2;
			 i++ ) {
				 ep = new PhysicalPlan();
				 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
				 prj.setColumn(i+1);
				 prj.setOverloaded(false);
				 prj.setResultType(DataType.BAG);
				 ep.add(prj);
				 eps.add(ep);
				 if (!inner[i]) {
					 if (i == 0) {
						 CompilerUtils.addEmptyBagOuterJoin(ep, op.getSchema(i), true, IsFirstReduceOfKey.class.getName());
					 }
					 else {
						 CompilerUtils.addEmptyBagOuterJoin(ep, op.getSchema(i), false, IsFirstReduceOfKey.class.getName());
					 }
				 }
				 flat.add(true);
			 }
			 POForEach fe = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, eps, flat);
			 fe.setResultType(DataType.TUPLE);
			 fe.visit(this);
			 curMROp.setSkewedJoinPartitionFile(partitionFile.getFileName());
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(PlanException e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
		catch(IOException e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitSort(POSort op) throws VisitorException {
		 try{
			 FileSpec fSpec = getTempFileSpec();
			 MapReduceOper mro = endSingleInputPlanWithStr(fSpec);
			 FileSpec quantFile = getTempFileSpec();
			 int rp = op.getRequestedParallelism();
			 Pair<POProject, Byte>[] fields = getSortCols(op.getSortPlans());
			 Pair<MapReduceOper, Integer> quantJobParallelismPair = getQuantileJob(op, mro, fSpec, quantFile, rp);
			 curMROp = getSortJob(op, quantJobParallelismPair.first, fSpec, quantFile, quantJobParallelismPair.second, fields);
			 if(op.isUDFComparatorUsed){
				 curMROp.UDFs.add(op.getMSortFunc().getFuncSpec().toString());
				 curMROp.isUDFComparatorUsed = true;
			 }
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitCounter(POCounter op) throws VisitorException {
		 try{
			 if(op.isRowNumber()) {
				 List<PhysicalOperator> mpLeaves = curMROp.mapPlan.getLeaves();
				 PhysicalOperator leaf = mpLeaves.get(0);
				 if ( !curMROp.isMapDone() && !curMROp.isRankOperation() ) {
					 curMROp.mapPlan.addAsLeaf(op);
				 }
				 else {
					 FileSpec fSpec = getTempFileSpec();
					 MapReduceOper prevMROper = endSingleInputPlanWithStr(fSpec);
					 MapReduceOper mrCounter = startNew(fSpec, prevMROper);
					 mrCounter.mapPlan.addAsLeaf(op);
					 curMROp = mrCounter;
				 }
			 }
			 else {
				 curMROp.reducePlan.addAsLeaf(op);
			 }
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitRank(PORank op) throws VisitorException {
		 try{
			 FileSpec fSpec = getTempFileSpec();
			 MapReduceOper prevMROper = endSingleInputPlanWithStr(fSpec);
			 curMROp = startNew(fSpec, prevMROper);
			 curMROp.mapPlan.addAsLeaf(op);
			 phyToMROpMap.put(op, curMROp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 private Pair<POProject,Byte> [] getSortCols(List<PhysicalPlan> plans) throws PlanException, ExecException {
		 if(plans!=null){
			 Pair<POProject,Byte>[] ret = new Pair[plans.size()];
			 int i=-1;
			 for (PhysicalPlan plan : plans) {
				 PhysicalOperator op = plan.getLeaves().get(0);
				 POProject proj;
				 if (op instanceof POProject) {
					 if (((POProject)op).isStar()) return null;
					 proj = (POProject)op;
				 }
				 else {
					 proj = null;
				 }
				 byte type = op.getResultType();
				 ret[++i] = new Pair<POProject, Byte>(proj, type);
			 }
			 return ret;
		 }
		 int errCode = 2026;
		 String msg = ""No expression plan found in POSort."";
		 throw new PlanException(msg, errCode, PigException.BUG);
	 }
	 private MapReduceOper getSortJob( POSort sort, MapReduceOper quantJob, FileSpec lFile, FileSpec quantFile, int rp, Pair<POProject, Byte>[] fields) throws PlanException{
		 MapReduceOper mro = startNew(lFile, quantJob);
		 mro.setQuantFile(quantFile.getFileName());
		 mro.setGlobalSort(true);
		 mro.requestedParallelism = rp;
		 long limit = sort.getLimit();
		 mro.limit = limit;
		 List<PhysicalPlan> eps1 = new ArrayList<PhysicalPlan>();
		 byte keyType = DataType.UNKNOWN;
		 boolean[] sortOrder;
		 List<Boolean> sortOrderList = sort.getMAscCols();
		 if(sortOrderList != null) {
			 sortOrder = new boolean[sortOrderList.size()];
			 for(int i = 0;
			 i < sortOrderList.size();
			 ++i) {
				 sortOrder[i] = sortOrderList.get(i);
			 }
			 mro.setSortOrder(sortOrder);
		 }
		 if (fields == null) {
			 PhysicalPlan ep = new PhysicalPlan();
			 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prj.setStar(true);
			 prj.setOverloaded(false);
			 prj.setResultType(DataType.TUPLE);
			 ep.add(prj);
			 eps1.add(ep);
		 }
		 else {
			 eps1.addAll(sort.getSortPlans());
			 try {
				 FindKeyTypeVisitor fktv = new FindKeyTypeVisitor(sort.getSortPlans().get(0));
				 fktv.visit();
				 keyType = fktv.keyType;
			 }
			 catch (VisitorException ve) {
				 int errCode = 2035;
				 String msg = ""Internal error. Could not compute key type of sort operator."";
				 throw new PlanException(msg, errCode, PigException.BUG, ve);
			 }
		 }
		 POLocalRearrange lr = new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 try {
			 lr.setIndex(0);
		 }
		 catch (ExecException e) {
			 int errCode = 2058;
			 String msg = ""Unable to set index on newly created POLocalRearrange."";
			 throw new PlanException(msg, errCode, PigException.BUG, e);
		 }
		 lr.setKeyType((fields == null || fields.length>1) ? DataType.TUPLE : keyType);
		 lr.setPlans(eps1);
		 lr.setResultType(DataType.TUPLE);
		 lr.addOriginalLocation(sort.getAlias(), sort.getOriginalLocations());
		 mro.mapPlan.addAsLeaf(lr);
		 mro.setMapDone(true);
		 if (limit!=-1) {
			 POPackage pkg_c = new POPackage(new OperatorKey(scope, nig.getNextNodeId(scope)));
			 LitePackager pkgr = new LitePackager();
			 pkgr.setKeyType((fields.length > 1) ? DataType.TUPLE : keyType);
			 pkg_c.setPkgr(pkgr);
			 pkg_c.setNumInps(1);
			 mro.combinePlan.add(pkg_c);
			 List<PhysicalPlan> eps_c1 = new ArrayList<PhysicalPlan>();
			 List<Boolean> flat_c1 = new ArrayList<Boolean>();
			 PhysicalPlan ep_c1 = new PhysicalPlan();
			 POProject prj_c1 = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prj_c1.setColumn(1);
			 prj_c1.setOverloaded(false);
			 prj_c1.setResultType(DataType.BAG);
			 ep_c1.add(prj_c1);
			 eps_c1.add(ep_c1);
			 flat_c1.add(true);
			 POForEach fe_c1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, eps_c1, flat_c1);
			 fe_c1.setResultType(DataType.TUPLE);
			 mro.combinePlan.addAsLeaf(fe_c1);
			 POLimit pLimit = new POLimit(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 pLimit.setLimit(limit);
			 mro.combinePlan.addAsLeaf(pLimit);
			 List<PhysicalPlan> eps_c2 = new ArrayList<PhysicalPlan>();
			 eps_c2.addAll(sort.getSortPlans());
			 POLocalRearrange lr_c2 = new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 try {
				 lr_c2.setIndex(0);
			 }
			 catch (ExecException e) {
				 int errCode = 2058;
				 String msg = ""Unable to set index on newly created POLocalRearrange."";
				 throw new PlanException(msg, errCode, PigException.BUG, e);
			 }
			 lr_c2.setKeyType((fields.length>1) ? DataType.TUPLE : keyType);
			 lr_c2.setPlans(eps_c2);
			 lr_c2.setResultType(DataType.TUPLE);
			 mro.combinePlan.addAsLeaf(lr_c2);
		 }
		 POPackage pkg = new POPackage(new OperatorKey(scope, nig.getNextNodeId(scope)));
		 LitePackager pkgr = new LitePackager();
		 pkgr.setKeyType((fields == null || fields.length > 1) ? DataType.TUPLE : keyType);
		 pkg.setPkgr(pkgr);
		 pkg.setNumInps(1);
		 mro.reducePlan.add(pkg);
		 PhysicalPlan ep = new PhysicalPlan();
		 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 prj.setColumn(1);
		 prj.setOverloaded(false);
		 prj.setResultType(DataType.BAG);
		 ep.add(prj);
		 List<PhysicalPlan> eps2 = new ArrayList<PhysicalPlan>();
		 eps2.add(ep);
		 List<Boolean> flattened = new ArrayList<Boolean>();
		 flattened.add(true);
		 POForEach nfe1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,eps2,flattened);
		 mro.reducePlan.add(nfe1);
		 mro.reducePlan.connect(pkg, nfe1);
		 mro.phyToMRMap.put(sort, nfe1);
		 if (limit!=-1) {
			 POLimit pLimit2 = new POLimit(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 pLimit2.setLimit(limit);
			 mro.reducePlan.addAsLeaf(pLimit2);
			 mro.phyToMRMap.put(sort, pLimit2);
		 }
		 return mro;
	 }
	 private Pair<MapReduceOper,Integer> getQuantileJob( POSort inpSort, MapReduceOper prevJob, FileSpec lFile, FileSpec quantFile, int rp) throws PlanException, VisitorException {
		 POSort sort = new POSort(inpSort.getOperatorKey(), inpSort .getRequestedParallelism(), null, inpSort.getSortPlans(), inpSort.getMAscCols(), inpSort.getMSortFunc());
		 sort.addOriginalLocation(inpSort.getAlias(), inpSort.getOriginalLocations());
		 List<Boolean> ascCols = inpSort.getMAscCols();
		 String[] ascs = new String[ascCols.size()];
		 for (int i = 0;
		 i < ascCols.size();
		 i++) ascs[i] = ascCols.get(i).toString();
		 String[] ctorArgs = ascs;
		 if(sort.isUDFComparatorUsed) {
			 String userComparatorFuncSpec = sort.getMSortFunc().getFuncSpec().toString();
			 ctorArgs = new String[ascs.length + 1];
			 ctorArgs[0] = USER_COMPARATOR_MARKER + userComparatorFuncSpec;
			 for(int j = 0;
			 j < ascs.length;
			 j++) {
				 ctorArgs[j+1] = ascs[j];
			 }
		 }
		 return getSamplingJob(sort, prevJob, null, lFile, quantFile, rp, null, FindQuantiles.class.getName(), ctorArgs, RandomSampleLoader.class.getName());
	 }
	 private Pair<MapReduceOper, Integer> getSkewedJoinSampleJob(POSkewedJoin op, MapReduceOper prevJob, FileSpec lFile, FileSpec sampleFile, int rp ) throws PlanException, VisitorException {
		 MultiMap<PhysicalOperator, PhysicalPlan> joinPlans = op.getJoinPlans();
		 List<PhysicalOperator> l = plan.getPredecessors(op);
		 List<PhysicalPlan> groups = joinPlans.get(l.get(0));
		 List<Boolean> ascCol = new ArrayList<Boolean>();
		 for(int i=0;
		 i<groups.size();
		 i++) {
			 ascCol.add(false);
		 }
		 POSort sort = new POSort(op.getOperatorKey(), op.getRequestedParallelism(), null, groups, ascCol, null);
		 List<PhysicalPlan> transformPlans = new ArrayList<PhysicalPlan>();
		 transformPlans.addAll(groups);
		 POProject prjStar = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 prjStar.setResultType(DataType.TUPLE);
		 prjStar.setStar(true);
		 List<PhysicalOperator> ufInps = new ArrayList<PhysicalOperator>();
		 ufInps.add(prjStar);
		 PhysicalPlan ep = new PhysicalPlan();
		 POUserFunc uf = new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ufInps, new FuncSpec(GetMemNumRows.class.getName(), (String[])null));
		 uf.setResultType(DataType.TUPLE);
		 ep.add(uf);
		 ep.add(prjStar);
		 ep.connect(prjStar, uf);
		 transformPlans.add(ep);
		 try{
			 String per = pigContext.getProperties().getProperty(""pig.skewedjoin.reduce.memusage"", String.valueOf(PartitionSkewedKeys.DEFAULT_PERCENT_MEMUSAGE));
			 String mc = pigContext.getProperties().getProperty(""pig.skewedjoin.reduce.maxtuple"", ""0"");
			 String inputFile = lFile.getFileName();
			 return getSamplingJob(sort, prevJob, transformPlans, lFile, sampleFile, rp, null, PartitionSkewedKeys.class.getName(), new String[]{
			per, mc, inputFile}
			, PoissonSampleLoader.class.getName());
		 }
		catch(Exception e) {
			 throw new PlanException(e);
		 }
	 }
	 private Pair<MapReduceOper,Integer> getSamplingJob(POSort sort, MapReduceOper prevJob, List<PhysicalPlan> transformPlans, FileSpec lFile, FileSpec sampleFile, int rp, List<PhysicalPlan> sortKeyPlans, String udfClassName, String[] udfArgs, String sampleLdrClassName ) throws PlanException, VisitorException {
		 String[] rslargs = new String[2];
		 rslargs[0] = (new FuncSpec(Utils.getTmpFileCompressorName(pigContext))).toString();
		 rslargs[1] = pigContext.getProperties().getProperty(PigConfiguration.PIG_RANDOM_SAMPLER_SAMPLE_SIZE, ""100"");
		 FileSpec quantLdFilName = new FileSpec(lFile.getFileName(), new FuncSpec(sampleLdrClassName, rslargs));
		 MapReduceOper mro = startNew(quantLdFilName, prevJob);
		 if(sort.isUDFComparatorUsed) {
			 mro.UDFs.add(sort.getMSortFunc().getFuncSpec().toString());
			 curMROp.isUDFComparatorUsed = true;
		 }
		 List<Boolean> flat1 = new ArrayList<Boolean>();
		 List<PhysicalPlan> eps1 = new ArrayList<PhysicalPlan>();
		 if (transformPlans == null) {
			 Pair<POProject, Byte>[] sortProjs = null;
			 try{
				 sortProjs = getSortCols(sort.getSortPlans());
			 }
			catch(Exception e) {
				 throw new RuntimeException(e);
			 }
			 if (sortProjs == null) {
				 PhysicalPlan ep = new PhysicalPlan();
				 POProject prj = new POProject(new OperatorKey(scope, nig.getNextNodeId(scope)));
				 prj.setStar(true);
				 prj.setOverloaded(false);
				 prj.setResultType(DataType.TUPLE);
				 ep.add(prj);
				 eps1.add(ep);
				 flat1.add(false);
			 }
			 else {
				 for (Pair<POProject, Byte> sortProj : sortProjs) {
					 if(sortProj == null){
						 int errCode = 2174;
						 String msg = ""Internal exception. Could not create a sampler job"";
						 throw new MRCompilerException(msg, errCode, PigException.BUG);
					 }
					 PhysicalPlan ep = new PhysicalPlan();
					 POProject prj;
					 try {
						 prj = sortProj.first.clone();
					 }
					 catch (CloneNotSupportedException e) {
						 throw new AssertionError( ""Error cloning project caught exception"" + e );
					 }
					 ep.add(prj);
					 eps1.add(ep);
					 flat1.add(false);
				 }
			 }
		 }
		else{
			 for(int i=0;
			 i<transformPlans.size();
			 i++) {
				 eps1.add(transformPlans.get(i));
				 flat1.add(i == transformPlans.size() - 1 ? true : false);
			 }
		 }
		 POForEach nfe1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,eps1,flat1);
		 mro.mapPlan.addAsLeaf(nfe1);
		 PhysicalPlan ep1 = new PhysicalPlan();
		 ConstantExpression ce = new ConstantExpression(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 ce.setValue(""all"");
		 ce.setResultType(DataType.CHARARRAY);
		 ep1.add(ce);
		 List<PhysicalPlan> eps = new ArrayList<PhysicalPlan>();
		 eps.add(ep1);
		 POLocalRearrange lr = new POLocalRearrange(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 try {
			 lr.setIndex(0);
		 }
		 catch (ExecException e) {
			 int errCode = 2058;
			 String msg = ""Unable to set index on newly created POLocalRearrange."";
			 throw new PlanException(msg, errCode, PigException.BUG, e);
		 }
		 lr.setKeyType(DataType.CHARARRAY);
		 lr.setPlans(eps);
		 lr.setResultType(DataType.TUPLE);
		 lr.addOriginalLocation(sort.getAlias(), sort.getOriginalLocations());
		 mro.mapPlan.add(lr);
		 mro.mapPlan.connect(nfe1, lr);
		 mro.setMapDone(true);
		 POPackage pkg = new POPackage(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 Packager pkgr = new Packager();
		 pkg.setPkgr(pkgr);
		 pkgr.setKeyType(DataType.CHARARRAY);
		 pkg.setNumInps(1);
		 boolean[] inner = {
		false}
		;
		 pkgr.setInner(inner);
		 mro.reducePlan.add(pkg);
		 PhysicalPlan fe2Plan = new PhysicalPlan();
		 POProject topPrj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 topPrj.setColumn(1);
		 topPrj.setResultType(DataType.BAG);
		 topPrj.setOverloaded(true);
		 fe2Plan.add(topPrj);
		 List<PhysicalPlan> nesSortPlanLst = new ArrayList<PhysicalPlan>();
		 if (sortKeyPlans != null) {
			 for(int i=0;
			 i<sortKeyPlans.size();
			 i++) {
				 nesSortPlanLst.add(sortKeyPlans.get(i));
			 }
		 }
		else{
			 Pair<POProject, Byte>[] sortProjs = null;
			 try{
				 sortProjs = getSortCols(sort.getSortPlans());
			 }
			catch(Exception e) {
				 throw new RuntimeException(e);
			 }
			 if (sortProjs == null) {
				 PhysicalPlan ep = new PhysicalPlan();
				 POProject prj = new POProject(new OperatorKey(scope, nig.getNextNodeId(scope)));
				 prj.setStar(true);
				 prj.setOverloaded(false);
				 prj.setResultType(DataType.TUPLE);
				 ep.add(prj);
				 nesSortPlanLst.add(ep);
			 }
			 else {
				 for (int i=0;
				 i<sortProjs.length;
				 i++) {
					 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
					 prj.setResultType(sortProjs[i].second);
					 if(sortProjs[i].first != null && sortProjs[i].first.isProjectToEnd()){
						 if(i != sortProjs.length -1){
							 throw new AssertionError(""Project-range to end (x..)"" + "" is supported in order-by only as last sort column"");
						 }
						 prj.setProjectToEnd(i);
						 break;
					 }
					 else{
						 prj.setColumn(i);
					 }
					 prj.setOverloaded(false);
					 PhysicalPlan ep = new PhysicalPlan();
					 ep.add(prj);
					 nesSortPlanLst.add(ep);
				 }
			 }
		 }
		 sort.setSortPlans(nesSortPlanLst);
		 sort.setResultType(DataType.BAG);
		 fe2Plan.add(sort);
		 fe2Plan.connect(topPrj, sort);
		 PhysicalPlan rpep = new PhysicalPlan();
		 ConstantExpression rpce = new ConstantExpression(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 rpce.setRequestedParallelism(rp);
		 rpce.setValue(rp);
		 rpce.setResultType(DataType.INTEGER);
		 rpep.add(rpce);
		 List<PhysicalPlan> genEps = new ArrayList<PhysicalPlan>();
		 genEps.add(rpep);
		 genEps.add(fe2Plan);
		 List<Boolean> flattened2 = new ArrayList<Boolean>();
		 flattened2.add(false);
		 flattened2.add(false);
		 POForEach nfe2 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1, genEps, flattened2);
		 mro.reducePlan.add(nfe2);
		 mro.reducePlan.connect(pkg, nfe2);
		 PhysicalPlan ep4 = new PhysicalPlan();
		 POProject prjStar4 = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 prjStar4.setResultType(DataType.TUPLE);
		 prjStar4.setStar(true);
		 ep4.add(prjStar4);
		 List<PhysicalOperator> ufInps = new ArrayList<PhysicalOperator>();
		 ufInps.add(prjStar4);
		 POUserFunc uf = new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ufInps, new FuncSpec(udfClassName, udfArgs));
		 ep4.add(uf);
		 ep4.connect(prjStar4, uf);
		 List<PhysicalPlan> ep4s = new ArrayList<PhysicalPlan>();
		 ep4s.add(ep4);
		 List<Boolean> flattened3 = new ArrayList<Boolean>();
		 flattened3.add(false);
		 POForEach nfe3 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ep4s, flattened3);
		 mro.reducePlan.add(nfe3);
		 mro.reducePlan.connect(nfe2, nfe3);
		 POStore str = getStore();
		 str.setSFile(sampleFile);
		 mro.reducePlan.add(str);
		 mro.reducePlan.connect(nfe3, str);
		 mro.setReduceDone(true);
		 mro.requestedParallelism = 1;
		 mro.markSampler();
		 return new Pair<MapReduceOper, Integer>(mro, rp);
	 }
	 static class LastInputStreamingOptimizer extends MROpPlanVisitor {
		 String chunkSize;
		 LastInputStreamingOptimizer(MROperPlan plan, String chunkSize) {
			 super(plan, new DepthFirstWalker<MapReduceOper, MROperPlan>(plan));
			 this.chunkSize = chunkSize;
		 }
		 public void visitMROp(MapReduceOper mr) throws VisitorException {
			 if (mr.mapPlan.isEmpty()) return;
			 if (mr.reducePlan.isEmpty()) return;
			 if (!mr.combinePlan.isEmpty()) {
				 return;
			 }
			 List<PhysicalOperator> mpLeaves = mr.mapPlan.getLeaves();
			 if (mpLeaves.size()!=1) {
				 return;
			 }
			 PhysicalOperator op = mpLeaves.get(0);
			 if (!(op instanceof POUnion)) {
				 return;
			 }
			 List<PhysicalOperator> mrRoots = mr.reducePlan.getRoots();
			 if (mrRoots.size()!=1) {
				 return;
			 }
			 op = mrRoots.get(0);
			 if (!(op instanceof POPackage)) {
				 return;
			 }
			 POPackage pack = (POPackage)op;
			 List<PhysicalOperator> sucs = mr.reducePlan.getSuccessors(pack);
			 if (sucs == null || sucs.size()!=1) {
				 return;
			 }
			 op = sucs.get(0);
			 boolean lastInputFlattened = true;
			 boolean allSimple = true;
			 if (op instanceof POForEach) {
				 POForEach forEach = (POForEach)op;
				 List<PhysicalPlan> planList = forEach.getInputPlans();
				 List<Boolean> flatten = forEach.getToBeFlattened();
				 POProject projOfLastInput = null;
				 int i = 0;
				 for (PhysicalPlan p:planList) {
					 PhysicalOperator opProj = p.getRoots().get(0);
					 if (!(opProj instanceof POProject)) {
						 allSimple = false;
						 break;
					 }
					 POProject proj = (POProject)opProj;
					 if(proj.isProjectToEnd() || proj.getColumns().size() != 1) {
						 allSimple = false;
						 break;
					 }
					 try {
						 if (proj.getColumn() == pack.getNumInps()) {
							 if(projOfLastInput != null) {
								 allSimple = false;
								 break;
							 }
							 projOfLastInput = proj;
							 if (!flatten.get(i) || proj.getResultType() != DataType.BAG) {
								 lastInputFlattened = false;
								 break;
							 }
						 }
					 }
					 catch (ExecException e) {
						 int errCode = 2069;
						 String msg = ""Error during map reduce compilation. Problem in accessing column from project operator."";
						 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
					 }
					 PhysicalOperator succ = p.getSuccessors(proj)!=null?p.getSuccessors(proj).get(0):null;
					 while (succ!=null) {
						 if (!(succ instanceof POProject)) {
							 allSimple = false;
							 break;
						 }
						 if(proj == projOfLastInput && ((POProject)succ).getResultType() != DataType.BAG) {
							 allSimple = false;
							 break;
						 }
						 succ = p.getSuccessors(succ)!=null?p.getSuccessors(succ).get(0):null;
					 }
					 i++;
					 if (allSimple==false) break;
				 }
				 if (lastInputFlattened && allSimple && projOfLastInput != null) {
					 replaceWithPOJoinPackage(mr.reducePlan, mr, pack, forEach, chunkSize);
				 }
			 }
		 }
		 public static void replaceWithPOJoinPackage(PhysicalPlan plan, MapReduceOper mr, POPackage pack, POForEach forEach, String chunkSize) throws VisitorException {
			 JoinPackager pkgr = new JoinPackager(pack.getPkgr(), forEach);
			 pkgr.setChunkSize(Long.parseLong(chunkSize));
			 pack.setPkgr(pkgr);
			 List<PhysicalOperator> succs = plan.getSuccessors(forEach);
			 if (succs != null) {
				 if (succs.size() != 1) {
					 int errCode = 2028;
					 String msg = ""ForEach can only have one successor. Found "" + succs.size() + "" successors."";
					 throw new MRCompilerException(msg, errCode, PigException.BUG);
				 }
			 }
			 plan.remove(pack);
			 try {
				 plan.replace(forEach, pack);
			 }
			 catch (PlanException e) {
				 int errCode = 2029;
				 String msg = ""Error rewriting join package."";
				 throw new MRCompilerException(msg, errCode, PigException.BUG, e);
			 }
			 mr.phyToMRMap.put(forEach, pack);
			 LogFactory.getLog(LastInputStreamingOptimizer.class).info( ""Rewrite: POPackage->POForEach to POPackage(JoinPackager)"");
		 }
	 }
	 private static class FindKeyTypeVisitor extends PhyPlanVisitor {
		 byte keyType = DataType.UNKNOWN;
		 FindKeyTypeVisitor(PhysicalPlan plan) {
			 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
		 }
		 public void visitProject(POProject p) throws VisitorException {
			 keyType = p.getResultType();
		 }
	 }
	 private static class FindStoreNameVisitor extends PhyPlanVisitor {
		 FileSpec newSpec;
		 FileSpec oldSpec;
		 FindStoreNameVisitor (PhysicalPlan plan, FileSpec newSpec, FileSpec oldSpec) {
			 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
			 this.newSpec = newSpec;
			 this.oldSpec = oldSpec;
		 }
		 public void visitStore(POStore sto) throws VisitorException {
			 FileSpec spec = sto.getSFile();
			 if (oldSpec.equals(spec)) {
				 sto.setSFile(newSpec);
			 }
		 }
	 }
}",1,0,0,0
"public class AggregatorColumns implements Comparable<AggregatorColumns> {
	 private List<String> columnNames;
	 private List<String> columnValues;
	 public AggregatorColumns(List<String> columnNames, List<String> columnValues) {
		 this.columnNames = columnNames;
		 this.columnValues = columnValues;
	 }
	 public List<String> getColumnNames() {
		 return columnNames;
	 }
	 public List<String> getColumnValues() {
		 return columnValues;
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 for (String columnValue : columnValues) {
			 sb.append(columnValue);
			 sb.append("","");
		 }
		 return sb.deleteCharAt(sb.length() - 1).toString();
	 }
	 public int compareTo(AggregatorColumns o) {
		 if (this.columnValues.size() > o.columnValues.size()) {
			 return 1;
		 }
		 else if (this.columnValues.size() < o.columnValues.size()) {
			 return -1;
		 }
		 else {
			 return this.toString().compareTo(o.toString());
		 }
	 }
}",0,1,0,0
"public void startElement(final String uri, final String localName, final String qname, final Attributes attributes) throws SAXException {
	 if (contextStack.size() == 0) {
		 if (!qname.equals(rootElement)) {
			 throw new SAXConfigurationException( new ConfigurationException.IncorrectElement(rootElement, qname, this.source, locator.getLineNumber()), locator);
		 }
		 String all = attributes.getValue(""includeAllClasses"");
		 if (""true"".equals(all)) allClasses = true;
		 contextStack.push(qname);
		 return;
	 }
	 else {
		 if (qname.equals(""classEntry"")) {
			 String path = attributes.getValue(""path"");
			 includedClasses.add(path);
		 }
		 else if (qname.equals(""namespaceManifestEntry"")) {
			 String manifest = attributes.getValue(""manifest"");
			 String namespace = attributes.getValue(""namespace"");
			 fbArgs.add(""-namespace"");
			 fbArgs.add(namespace);
			 String mf = contextPath + ""/"" + manifest;
			 File f = new File(mf);
			 if (!f.exists()) {
				 mf = contextPath + ""/src/"" + manifest;
			 }
			 fbArgs.add(mf);
			 fbArgs.add(""-include-namespaces"");
			 fbArgs.add(namespace);
		 }
	 }
 }",0,0,1,0
"public final class WindowsJavaThreads extends JavaThreads {
	 WindowsJavaThreads() {
	 }
	 protected void doStartThread(Thread thread, long stackSize) {
		 int threadStackSize = (int) stackSize;
		 int initFlag = Process.CREATE_SUSPENDED();
		 WindowsThreadStartData startData = UnmanagedMemory.malloc(SizeOf.get(WindowsThreadStartData.class));
		 prepareStartData(thread, startData);
		 if (threadStackSize != 0) {
			 initFlag |= Process.STACK_SIZE_PARAM_IS_A_RESERVATION();
		 }
		 CIntPointer osThreadID = StackValue.get(CIntPointer.class);
		 WinBase.HANDLE osThreadHandle = Process._beginthreadex(WordFactory.nullPointer(), threadStackSize, WindowsJavaThreads.osThreadStartRoutine.getFunctionPointer(), startData, initFlag, osThreadID);
		 VMError.guarantee(osThreadHandle.rawValue() != 0, ""Could not create thread"");
		 startData.setOSThreadHandle(osThreadHandle);
		 Process.ResumeThread(osThreadHandle);
	 }
	 protected void setNativeName(Thread thread, String name) {
	 }
	 protected void yield() {
		 Process.SwitchToThread();
	 }
	 interface WindowsThreadStartData extends ThreadStartData {
		 WinBase.HANDLE getOSThreadHandle();
		 void setOSThreadHandle(WinBase.HANDLE osHandle);
	 }
	 private static final CEntryPointLiteral<CFunctionPointer> osThreadStartRoutine = CEntryPointLiteral.create(WindowsJavaThreads.class, ""osThreadStartRoutine"", WindowsThreadStartData.class);
	 private static class OSThreadStartRoutinePrologue {
		 private static final CGlobalData<CCharPointer> errorMessage = CGlobalDataFactory.createCString(""Failed to attach a newly launched thread."");
		 static void enter(WindowsThreadStartData data) {
			 int code = CEntryPointActions.enterAttachThread(data.getIsolate());
			 if (code != 0) {
				 CEntryPointActions.failFatally(code, errorMessage.get());
			 }
		 }
	 }
	 static WordBase osThreadStartRoutine(WindowsThreadStartData data) {
		 ObjectHandle threadHandle = data.getThreadHandle();
		 WinBase.HANDLE osThreadHandle = data.getOSThreadHandle();
		 UnmanagedMemory.free(data);
		 try {
			 threadStartRoutine(threadHandle);
		 }
		 finally {
			 WinBase.CloseHandle(osThreadHandle);
		 }
		 return WordFactory.nullPointer();
	 }
}",0,0,0,0
"public interface DataSchemaResolver{
	 Map<String, NamedDataSchema> bindings();
	 Map<String, DataSchemaLocation> nameToDataSchemaLocations();
	 NamedDataSchema findDataSchema(String name, StringBuilder errorMessageBuilder);
	 void bindNameToSchema(Name name, NamedDataSchema schema, DataSchemaLocation location);
	 NamedDataSchema existingDataSchema(String name);
	 boolean locationResolved(DataSchemaLocation location);
	 void addPendingSchema(String name);
	 void updatePendingSchema(String name, Boolean isParsingInclude);
	 void removePendingSchema(String name);
	 LinkedHashMap<String, Boolean> getPendingSchemas();
}",0,0,0,0
"public class FilesMatch implements Condition {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private File file1, file2;
	 private boolean textfile = false;
	 public void setFile1(File file1) {
		 this.file1 = file1;
	 }
	 public void setFile2(File file2) {
		 this.file2 = file2;
	 }
	 public void setTextfile(boolean textfile) {
		 this.textfile = textfile;
	 }
	 public boolean eval() throws BuildException {
		 if (file1 == null || file2 == null) {
			 throw new BuildException(""both file1 and file2 are required in "" + ""filesmatch"");
		 }
		 boolean matches = false;
		 try {
			 matches = FILE_UTILS.contentEquals(file1, file2, textfile);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""when comparing files: "" + ioe.getMessage(), ioe);
		 }
		 return matches;
	 }
}",0,0,0,0
"public class TestTezAutoParallelism {
	 private static final String INPUT_FILE1 = TestTezAutoParallelism.class.getName() + ""_1"";
	 private static final String INPUT_FILE2 = TestTezAutoParallelism.class.getName() + ""_2"";
	 private static final String INPUT_DIR = Util.getTestDirectory(TestTezAutoParallelism.class);
	 private static PigServer pigServer;
	 private static Properties properties;
	 private static MiniGenericCluster cluster;
	 private static final PathFilter PART_FILE_FILTER = new PathFilter() {
		 public boolean accept(Path path) {
			 if (path.getName().startsWith(""part"")) {
				 return true;
			 }
			 return false;
		 }
	 }
	;
	 public static void oneTimeSetUp() throws Exception {
		 cluster = MiniGenericCluster.buildCluster(MiniGenericCluster.EXECTYPE_TEZ);
		 properties = cluster.getProperties();
		 properties.setProperty(PigConfiguration.PIG_TEZ_INPUT_SPLITS_MEM_THRESHOLD, ""10"");
		 properties.setProperty(PigConfiguration.PIG_TEZ_GRACE_PARALLELISM, ""false"");
		 createFiles();
	 }
	 public static void oneTimeTearDown() throws Exception {
		 deleteFiles();
		 cluster.shutDown();
	 }
	 public void setUp() throws Exception {
		 pigServer = new PigServer(MiniGenericCluster.EXECTYPE_TEZ, properties);
	 }
	 public void tearDown() throws Exception {
		 removeProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION);
		 removeProperty(MRConfiguration.MAX_SPLIT_SIZE);
		 removeProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM);
		 removeProperty(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART);
		 removeProperty(TezConfiguration.TEZ_AM_LOG_LEVEL);
		 pigServer.shutdown();
		 pigServer = null;
	 }
	 private static void createFiles() throws IOException {
		 new File(INPUT_DIR).mkdirs();
		 PrintWriter w = new PrintWriter(new FileWriter(INPUT_DIR + ""/"" + INPUT_FILE1));
		 String boyNames[] = {
		""Noah"", ""Liam"", ""Jacob"", ""Mason"", ""William"", ""Ethan"", ""Michael"", ""Alexander"", ""Jayden"", ""Daniel""}
		;
		 String girlNames[] = {
		""Sophia"", ""Emma"", ""Olivia"", ""Isabella"", ""Ava"", ""Mia"", ""Emily"", ""Abigail"", ""Madison"", ""Elizabeth""}
		;
		 String names[] = new String[boyNames.length + girlNames.length];
		 for (int i=0;
		i<boyNames.length;
		i++) {
			 names[i] = boyNames[i];
		 }
		 for (int i=0;
		i<girlNames.length;
		i++) {
			 names[boyNames.length+i] = girlNames[i];
		 }
		 Random rand = new Random(1);
		 for (int i=0;
		i<1000;
		i++) {
			 w.println(names[rand.nextInt(names.length)] + ""\t"" + rand.nextInt(18));
		 }
		 w.close();
		 Util.copyFromLocalToCluster(cluster, INPUT_DIR + ""/"" + INPUT_FILE1, INPUT_FILE1);
		 w = new PrintWriter(new FileWriter(INPUT_DIR + ""/"" + INPUT_FILE2));
		 for (String name : boyNames) {
			 w.println(name + ""\t"" + ""M"");
		 }
		 for (String name : girlNames) {
			 w.println(name + ""\t"" + ""F"");
		 }
		 w.close();
		 Util.copyFromLocalToCluster(cluster, INPUT_DIR + ""/"" + INPUT_FILE2, INPUT_FILE2);
	 }
	 private static void deleteFiles() {
		 Util.deleteDirectory(new File(INPUT_DIR));
	 }
	 public void testGroupBy() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, Long.toString(InputSizeReducerEstimator.DEFAULT_BYTES_PER_REDUCER));
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = group A by name;
		"");
		 pigServer.store(""B"", ""output1"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output1""), PART_FILE_FILTER);
		 assertEquals(files.length, 1);
		 fs.delete(new Path(""output1""), true);
	 }
	 public void testBytesPerReducer() throws IOException{
		 NodeIdGenerator.reset();
		 PigServer.resetScope();
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""1000"");
		 StringWriter writer = new StringWriter();
		 Util.createLogAppender(""testAutoParallelism"", writer, TezDagBuilder.class);
		 try {
			 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
			"");
			 pigServer.registerQuery(""B = group A by name;
			"");
			 pigServer.store(""B"", ""output1"");
			 FileSystem fs = cluster.getFileSystem();
			 FileStatus[] files = fs.listStatus(new Path(""output1""), PART_FILE_FILTER);
			 assertEquals(files.length, 10);
			 String log = writer.toString();
			 assertTrue(log.contains(""For vertex - scope-13: parallelism=3""));
			 assertTrue(log.contains(""For vertex - scope-14: parallelism=10""));
		 }
		 finally {
			 Util.removeLogAppender(""testAutoParallelism"", TezDagBuilder.class);
			 Util.deleteFile(cluster, ""output1"");
		 }
	 }
	 public void testOrderbyDecreaseParallelism() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, Long.toString(InputSizeReducerEstimator.DEFAULT_BYTES_PER_REDUCER));
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = group A by name parallel 3;
		"");
		 pigServer.registerQuery(""C = foreach B generate group as name, AVG(A.age) as age;
		"");
		 pigServer.registerQuery(""D = order C by age;
		"");
		 pigServer.store(""D"", ""output2"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output2""), PART_FILE_FILTER);
		 assertEquals(files.length, 1);
	 }
	 public void testOrderbyIncreaseParallelism() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""1000"");
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = group A by name parallel 3;
		"");
		 pigServer.registerQuery(""C = foreach B generate group as name, AVG(A.age) as age;
		"");
		 pigServer.registerQuery(""D = order C by age;
		"");
		 pigServer.store(""D"", ""output3"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output3""), PART_FILE_FILTER);
		 assertEquals(files.length, 4);
	 }
	 public void testSkewedJoinDecreaseParallelism() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, Long.toString(InputSizeReducerEstimator.DEFAULT_BYTES_PER_REDUCER));
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"");
		 pigServer.registerQuery(""C = join A by name, B by name using 'skewed';
		"");
		 pigServer.store(""C"", ""output4"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output4""), PART_FILE_FILTER);
		 assertEquals(files.length, 1);
	 }
	 public void testSkewedJoinIncreaseParallelism() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""40000"");
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"");
		 pigServer.registerQuery(""C = join A by name, B by name using 'skewed';
		"");
		 pigServer.store(""C"", ""output5"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output5""), PART_FILE_FILTER);
		 assertEquals(files.length, 5);
	 }
	 public void testSkewedFullJoinIncreaseParallelism() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""40000"");
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"");
		 pigServer.registerQuery(""C = join A by name full, B by name using 'skewed';
		"");
		 pigServer.store(""C"", ""output6"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output5""), PART_FILE_FILTER);
		 assertEquals(files.length, 5);
	 }
	 public void testSkewedJoinIncreaseParallelismWithScalar() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""40000"");
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"");
		 pigServer.registerQuery(""C = join A by name, B by name using 'skewed';
		"");
		 pigServer.registerQuery(""D = load 'org.apache.pig.tez.TestTezAutoParallelism_1' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""E = group D all;
		"");
		 pigServer.registerQuery(""F = foreach E generate COUNT(D) as count;
		"");
		 pigServer.registerQuery(""G = foreach C generate age/F.count, gender;
		"");
		 pigServer.store(""G"", ""output7"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output7""), PART_FILE_FILTER);
		 assertEquals(files.length, 4);
	 }
	 public void testSkewedJoinRightInputAutoParallelism() throws IOException{
		 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""3000"");
		 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""40000"");
		 setProperty(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, ""1.0"");
		 setProperty(TezConfiguration.TEZ_AM_LOG_LEVEL, ""DEBUG"");
		 pigServer.registerQuery(""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"");
		 pigServer.registerQuery(""B = FILTER B by name == 'Noah';
		"");
		 pigServer.registerQuery(""B1 = group B by name;
		"");
		 pigServer.registerQuery(""C = join A by name, B1 by group using 'skewed';
		"");
		 pigServer.store(""C"", ""output8"");
		 FileSystem fs = cluster.getFileSystem();
		 FileStatus[] files = fs.listStatus(new Path(""output8""), PART_FILE_FILTER);
		 assertEquals(5, files.length);
	 }
	 public void testFlattenParallelism() throws IOException{
		 String outputDir = ""/tmp/testFlattenParallelism"";
		 String script = ""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"" + ""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"" + ""C = join A by name, B by name using 'skewed' parallel 1;
		"" + ""C1 = group C by A::name;
		"" + ""C2 = FOREACH C1 generate group, FLATTEN(C);
		"" + ""D = group C2 by group;
		"" + ""E = foreach D generate group, COUNT(C2.A::name);
		"" + ""STORE E into '"" + outputDir + ""/finalout';
		"";
		 String log = testAutoParallelism(script, outputDir, true, TezJobCompiler.class, TezDagBuilder.class);
		 assertTrue(log.contains(""For vertex - scope-74: parallelism=10""));
		 assertTrue(log.contains(""For vertex - scope-75: parallelism=70""));
		 assertTrue(log.contains(""Total estimated parallelism is 89""));
	 }
	 public void testIncreaseIntermediateParallelism1() throws IOException{
		 String outputDir = ""/tmp/testIncreaseIntermediateParallelism"";
		 String script = ""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"" + ""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"" + ""C = join A by name, B by name using 'skewed' parallel 1;
		"" + ""D = group C by A::name;
		"" + ""E = foreach D generate group, COUNT(C.A::name);
		"" + ""STORE E into '"" + outputDir + ""/finalout';
		"";
		 String log = testIncreaseIntermediateParallelism(script, outputDir, true);
		 assertTrue(log.contains(""Increased requested parallelism of scope-59 to 4""));
		 assertEquals(1, StringUtils.countMatches(log, ""Increased requested parallelism""));
		 assertTrue(log.contains(""Total estimated parallelism is 40""));
	 }
	 public void testIncreaseIntermediateParallelism2() throws IOException{
		 String outputDir = ""/tmp/testIncreaseIntermediateParallelism"";
		 String script = ""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
		"" + ""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
		"" + ""C = join A by name, B by name using 'skewed' parallel 2;
		"" + ""STORE C into '/tmp/testIncreaseIntermediateParallelism';
		"" + ""D = group C by A::name parallel 2;
		"" + ""E = foreach D generate group, COUNT(C.A::name);
		"" + ""STORE E into '"" + outputDir + ""/finalout';
		"";
		 String log = testIncreaseIntermediateParallelism(script, outputDir, true);
		 assertEquals(0, StringUtils.countMatches(log, ""Increased requested parallelism""));
	 }
	 public void testIncreaseIntermediateParallelism3() throws IOException{
		 try {
			 String outputDir = ""/tmp/testIncreaseIntermediateParallelism"";
			 String script = ""set default_parallel 1\n"" + ""A = load '"" + INPUT_FILE1 + ""' as (name:chararray, age:int);
			"" + ""B = load '"" + INPUT_FILE2 + ""' as (name:chararray, gender:chararray);
			"" + ""C = join A by name, B by name;
			"" + ""STORE C into '/tmp/testIncreaseIntermediateParallelism';
			"" + ""C1 = group C by A::name;
			"" + ""C2 = FOREACH C1 generate group, FLATTEN(C);
			"" + ""D = group C2 by group;
			"" + ""E = foreach D generate group, COUNT(C2.A::name);
			"" + ""F = order E by $0;
			"" + ""STORE F into '"" + outputDir + ""/finalout';
			"";
			 String log = testIncreaseIntermediateParallelism(script, outputDir, false);
			 assertEquals(1, StringUtils.countMatches(log, ""Increased requested parallelism""));
			 assertTrue(log.contains(""Increased requested parallelism of scope-65 to 10""));
			 assertTrue(log.contains(""Total estimated parallelism is 19""));
		 }
		 finally {
			 pigServer.setDefaultParallel(-1);
		 }
	 }
	 private String testIncreaseIntermediateParallelism(String script, String outputDir, boolean sortAndCheck) throws IOException {
		 return testAutoParallelism(script, outputDir, sortAndCheck, ParallelismSetter.class, TezJobCompiler.class);
	 }
	 private String testAutoParallelism(String script, String outputDir, boolean sortAndCheck, Class... classesToLog) throws IOException {
		 NodeIdGenerator.reset();
		 PigServer.resetScope();
		 StringWriter writer = new StringWriter();
		 Util.createLogAppender(""testAutoParallelism"", writer, classesToLog);
		 try {
			 setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
			 setProperty(MRConfiguration.MAX_SPLIT_SIZE, ""4000"");
			 setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""80000"");
			 pigServer.setBatchOn();
			 pigServer.registerScript(new ByteArrayInputStream(script.getBytes()));
			 pigServer.executeBatch();
			 pigServer.registerQuery(""A = load '"" + outputDir + ""/finalout' as (name:chararray, count:long);
			"");
			 Iterator<Tuple> iter = pigServer.openIterator(""A"");
			 List<Tuple> expectedResults = Util .getTuplesFromConstantTupleStrings(new String[] {
			 ""('Abigail',56L)"", ""('Alexander',45L)"", ""('Ava',60L)"", ""('Daniel',68L)"", ""('Elizabeth',42L)"", ""('Emily',57L)"", ""('Emma',50L)"", ""('Ethan',50L)"", ""('Isabella',43L)"", ""('Jacob',43L)"", ""('Jayden',59L)"", ""('Liam',46L)"", ""('Madison',46L)"", ""('Mason',54L)"", ""('Mia',51L)"", ""('Michael',47L)"", ""('Noah',38L)"", ""('Olivia',50L)"", ""('Sophia',52L)"", ""('William',43L)"" }
			);
			 if (sortAndCheck) {
				 Util.checkQueryOutputsAfterSort(iter, expectedResults);
			 }
			 else {
				 Util.checkQueryOutputs(iter, expectedResults);
			 }
			 return writer.toString();
		 }
		 finally {
			 Util.removeLogAppender(""testAutoParallelism"", classesToLog);
			 Util.deleteFile(cluster, outputDir);
		 }
	 }
	 private void setProperty(String property, String value) {
		 pigServer.getPigContext().getProperties().setProperty(property, value);
	 }
	 private void removeProperty(String property) {
		 pigServer.getPigContext().getProperties().remove(property);
	 }
}",1,0,0,0
"public class Utils {
	 public static final String TENANT_IDENTIFIER = ""tenantIdentifier=default"";
	 public static final String TENANT_TIME_ZONE = ""Asia/Kolkata"";
	 private static final String LOGIN_URL = ""/fineract-provider/api/v1/authentication?username=mifos&password=password&"" + TENANT_IDENTIFIER;
	 public static void initializeRESTAssured() {
		 RestAssured.baseURI = ""https: RestAssured.port = 8443;
		 RestAssured.keystore(""src/main/resources/keystore.jks"", ""openmf"");
	 }
	 public static String loginIntoServerAndGetBase64EncodedAuthenticationKey() {
		 try {
			 System.out.println(""-----------------------------------LOGIN-----------------------------------------"");
			 final String json = RestAssured.post(LOGIN_URL).asString();
			 assertThat(""Failed to login into fineract platform"", StringUtils.isBlank(json), is(false));
			 return JsonPath.with(json).get(""base64EncodedAuthenticationKey"");
		 }
		 catch (final Exception e) {
			 if (e instanceof HttpHostConnectException) {
				 final HttpHostConnectException hh = (HttpHostConnectException) e;
				 fail(""Failed to connect to fineract platform:"" + hh.getMessage());
			 }
			 throw new RuntimeException(e);
		 }
	 }
	 public static <T> T performServerGet(final RequestSpecification requestSpec, final ResponseSpecification responseSpec, final String getURL, final String jsonAttributeToGetBack) {
		 final String json = given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().get(getURL).andReturn().asString();
		 if (jsonAttributeToGetBack == null) {
			 return (T) json;
		 }
		 return (T) from(json).get(jsonAttributeToGetBack);
	 }
	 public static String performGetTextResponse(final RequestSpecification requestSpec, final ResponseSpecification responseSpec, final String getURL){
		 return given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().get(getURL).andReturn().asString();
	 }
	 public static byte[] performGetBinaryResponse(final RequestSpecification requestSpec, final ResponseSpecification responseSpec, final String getURL){
		 return given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().get(getURL).andReturn().asByteArray();
	 }
	 public static <T> T performServerPost(final RequestSpecification requestSpec, final ResponseSpecification responseSpec, final String postURL, final String jsonBodyToSend, final String jsonAttributeToGetBack) {
		 final String json = given().spec(requestSpec).body(jsonBodyToSend).expect().spec(responseSpec).log().ifError().when().post(postURL) .andReturn().asString();
		 if (jsonAttributeToGetBack == null) {
			 return (T) json;
		 }
		 return (T) from(json).get(jsonAttributeToGetBack);
	 }
	 public static <T> T performServerPut(final RequestSpecification requestSpec, final ResponseSpecification responseSpec, final String putURL, final String jsonBodyToSend, final String jsonAttributeToGetBack) {
		 final String json = given().spec(requestSpec).body(jsonBodyToSend).expect().spec(responseSpec).log().ifError().when().put(putURL) .andReturn().asString();
		 return (T) from(json).get(jsonAttributeToGetBack);
	 }
	 public static <T> T performServerDelete(final RequestSpecification requestSpec, final ResponseSpecification responseSpec, final String deleteURL, final String jsonAttributeToGetBack) {
		 final String json = given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().delete(deleteURL).andReturn() .asString();
		 return (T) from(json).get(jsonAttributeToGetBack);
	 }
	 public static String convertDateToURLFormat(final String dateToBeConvert) {
		 final SimpleDateFormat oldFormat = new SimpleDateFormat(""dd MMMMMM yyyy"", Locale.US);
		 final SimpleDateFormat newFormat = new SimpleDateFormat(""yyyy-MM-dd"");
		 String reformattedStr = """";
		 try {
			 reformattedStr = newFormat.format(oldFormat.parse(dateToBeConvert));
		 }
		 catch (final ParseException e) {
			 e.printStackTrace();
		 }
		 return reformattedStr;
	 }
	 public static String randomStringGenerator(final String prefix, final int len, final String sourceSetString) {
		 final int lengthOfSource = sourceSetString.length();
		 final Random rnd = new Random();
		 final StringBuilder sb = new StringBuilder(len);
		 for (int i = 0;
		 i < len;
		 i++) {
			 sb.append((sourceSetString).charAt(rnd.nextInt(lengthOfSource)));
		 }
		 return (prefix + (sb.toString()));
	 }
	 public static String randomStringGenerator(final String prefix, final int len) {
		 return randomStringGenerator(prefix, len, ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"");
	 }
	 public static String randomNameGenerator(final String prefix, final int lenOfRandomSuffix) {
		 return randomStringGenerator(prefix, lenOfRandomSuffix);
	 }
	 public static Long randomNumberGenerator(final int expectedLength){
		 final String source=""1234567890"";
		 final int lengthofSource=source.length();
		 final Random random=new Random();
		 StringBuilder stringBuilder=new StringBuilder(expectedLength);
		 for (int i = 0;
		 i < expectedLength;
		 i++) {
			 stringBuilder.append(source.charAt(random.nextInt(lengthofSource)));
		 }
		 return Long.parseLong(stringBuilder.toString());
	 }
	 public static String convertDateToURLFormat(final Calendar dateToBeConvert) {
		 DateFormat dateFormat = new SimpleDateFormat(""dd MMMMMM yyyy"");
		 dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());
		 return dateFormat.format(dateToBeConvert.getTime());
	 }
	 public static LocalDate getLocalDateOfTenant() {
		 LocalDate today = new LocalDate();
		 final DateTimeZone zone = DateTimeZone.forID(TENANT_TIME_ZONE);
		 if (zone != null) {
			 today = new LocalDate(zone);
		 }
		 return today;
	 }
	 public static TimeZone getTimeZoneOfTenant() {
		 return TimeZone.getTimeZone(TENANT_TIME_ZONE);
	 }
	 public static String performServerTemplatePost(final RequestSpecification requestSpec,final ResponseSpecification responseSpec, final String postURL,final String legalFormType,final File file,final String locale,final String dateFormat) {
		 final String importDocumentId=given().spec(requestSpec) .queryParam(""legalFormType"",legalFormType) .multiPart(""file"",file) .formParam(""locale"",locale) .formParam(""dateFormat"",dateFormat) .expect().spec(responseSpec). log().ifError().when().post(postURL) .andReturn().asString();
		 return importDocumentId;
	 }
	 public static String performServerOutputTemplateLocationGet(final RequestSpecification requestSpec,final ResponseSpecification responseSpec, final String getURL,final String importDocumentId){
		 final String templateLocation=given().spec(requestSpec). queryParam(""importDocumentId"",importDocumentId) .expect().spec(responseSpec) .log().ifError().when().get(getURL) .andReturn().asString();
		 return templateLocation.substring(1,templateLocation.length()-1);
	 }
}",1,0,0,0
"public void configure(TestElement el) {
	 setName(el.getName());
	 Arguments arguments = (Arguments) el.getProperty(HTTPSamplerBase.ARGUMENTS).getObjectValue();
	 boolean useRaw = el.getPropertyAsBoolean(HTTPSamplerBase.POST_BODY_RAW, HTTPSamplerBase.POST_BODY_RAW_DEFAULT);
	 if(useRaw) {
		 String postBody = computePostBody(arguments, true);
		 postBodyContent.setInitialText(postBody);
		 postBodyContent.setCaretPosition(0);
		 argsPanel.clear();
		 postContentTabbedPane.setSelectedIndex(tabRawBodyIndex, false);
	 }
	 else {
		 postBodyContent.setInitialText("""");
		 argsPanel.configure(arguments);
		 postContentTabbedPane.setSelectedIndex(TAB_PARAMETERS, false);
	 }
	 if(showFileUploadPane) {
		 filesPanel.configure(el);
	 }
	 domain.setText(el.getPropertyAsString(HTTPSamplerBase.DOMAIN));
	 String portString = el.getPropertyAsString(HTTPSamplerBase.PORT);
	 if (portString.equals(HTTPSamplerBase.UNSPECIFIED_PORT_AS_STRING)) {
		 port.setText("""");
	 }
	 else {
		 port.setText(portString);
	 }
	 protocol.setText(el.getPropertyAsString(HTTPSamplerBase.PROTOCOL));
	 contentEncoding.setText(el.getPropertyAsString(HTTPSamplerBase.CONTENT_ENCODING));
	 path.setText(el.getPropertyAsString(HTTPSamplerBase.PATH));
	 if (notConfigOnly){
		 method.setText(el.getPropertyAsString(HTTPSamplerBase.METHOD));
		 followRedirects.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.FOLLOW_REDIRECTS));
		 autoRedirects.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.AUTO_REDIRECTS));
		 useKeepAlive.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.USE_KEEPALIVE));
		 useMultipart.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.DO_MULTIPART_POST));
		 useBrowserCompatibleMultipartMode.setSelected(el.getPropertyAsBoolean( HTTPSamplerBase.BROWSER_COMPATIBLE_MULTIPART, HTTPSamplerBase.BROWSER_COMPATIBLE_MULTIPART_MODE_DEFAULT));
	 }
 }",0,0,1,0
"private CompoundAction createFoldAction(ListIterator iterator,boolean fold, boolean undo);",0,0,0,0
"public final class Attributes implements AttributeList {
	 private int _element;
	 private DOM _document;
	 public Attributes(DOM document, int element) {
		_element = element;
		_document = document;
	 }
	 public int getLength() {
		return 0;
	 }
	 public String getName(int i) {
		return null;
	 }
	 public String getType(int i) {
		return null;
	 }
	 public String getType(String name) {
		return null;
	 }
	 public String getValue(int i) {
		return null;
	 }
	 public String getValue(String name) {
		return null;
	 }
}",0,1,0,0
"public class PrintXmlBean{
	 private int edgesScale;
	 private boolean showEdges;
	 public int getEdgesScale() {
		 return edgesScale;
	 }
	 public void setEdgesScale(int edgesScale) {
		 this.edgesScale = edgesScale;
	 }
	 public boolean isShowEdges() {
		 return showEdges;
	 }
	 public void setShowEdges(boolean showEdges) {
		 this.showEdges = showEdges;
	 }
}",0,1,0,0
"public class SplitRulesetNodes extends SkippingTreeVisitor implements CssCompilerPass {
	 private final MutatingVisitController visitController;
	 public SplitRulesetNodes(MutatingVisitController visitController) {
		 this(visitController, false);
	 }
	 public SplitRulesetNodes(MutatingVisitController visitController, boolean skipping) {
		 super(skipping);
		 this.visitController = visitController;
	 }
	 public boolean enterRuleset(CssRulesetNode node) {
		 boolean canModifyRuleset = canModifyRuleset(node);
		 if (canModifyRuleset) {
			 List<CssNode> replacementNodes = Lists.newArrayList();
			 CssSelectorListNode selectors = node.getSelectors();
			 CssDeclarationBlockNode declarations = node.getDeclarations();
			 for (CssSelectorNode sel : selectors.childIterable()) {
				 for (CssNode child : declarations.childIterable()) {
					 CssRulesetNode ruleset = new CssRulesetNode();
					 ruleset.setSourceCodeLocation(node.getSourceCodeLocation());
					 ruleset.addDeclaration(child.deepCopy());
					 ruleset.addSelector(sel.deepCopy());
					 replacementNodes.add(ruleset);
				 }
			 }
			 visitController.replaceCurrentBlockChildWith( replacementNodes, false);
		 }
		 return canModifyRuleset;
	 }
	 public void runPass() {
		 visitController.startVisit(this);
	 }
}",0,0,0,0
"public class CollectionPermutationIter<E>{
	 private ArrayPermutationsIter permOrder;
	 private List<E> sourceArray;
	 private int [] currPermutationArray;
	 public CollectionPermutationIter(Set<E> objectsSet) {
		 this( new ArrayList<E>(objectsSet), new IntegerPermutationIter(objectsSet.size()));
	 }
	 public CollectionPermutationIter(List<E> objectsArray) {
		 this( objectsArray, new IntegerPermutationIter(objectsArray.size()));
	 }
	 public CollectionPermutationIter( List<E> objectsArray, ArrayPermutationsIter permuter) {
		 this.permOrder = permuter;
		 this.sourceArray = objectsArray;
	 }
	 public boolean hasNext() {
		 return this.permOrder.hasNextPermutaions();
	 }
	 public List<E> getNextArray() {
		 List<E> permutationResult;
		 if (this.permOrder.hasNextPermutaions()) {
			 this.currPermutationArray = this.permOrder.nextPermutation();
			 permutationResult = applyPermutation();
		 }
		 else {
			 permutationResult = null;
		 }
		 return permutationResult;
	 }
	 private List<E> applyPermutation() {
		 ArrayList<E> output = new ArrayList<E>(sourceArray);
		 for (int i = 0;
		 i < output.size();
		 i++) {
			 output.set( i, this.sourceArray.get(this.currPermutationArray[i]));
		 }
		 return output;
	 }
	 public Set<E> getNextSet() {
		 List<E> result = getNextArray();
		 if (result == null) {
			 return null;
		 }
		 else {
			 Set<E> resultSet = new LinkedHashSet<E>(result);
			 return resultSet;
		 }
	 }
	 public int [] getCurrentPermutationArray() {
		 return this.currPermutationArray;
	 }
	 public String toString() {
		 StringBuffer sb = new StringBuffer();
		 sb.append(""Permutation int[]="");
		 sb.append(Arrays.toString(getCurrentPermutationArray()));
		 List<E> permutationResult = applyPermutation();
		 sb.append(""\nPermutationSet Source Object[]="");
		 sb.append(this.sourceArray.toString());
		 sb.append(""\nPermutationSet Result Object[]="");
		 sb.append(permutationResult.toString());
		 return sb.toString();
	 }
}",0,0,0,0
public boolean forEach(TObjectProcedure<T> procedure);,0,0,0,0
"public class BarcodeQRCode {
	 ByteMatrix bm;
	 public BarcodeQRCode(String content, int width, int height, Map<EncodeHintType,Object> hints) {
		 try {
			 QRCodeWriter qc = new QRCodeWriter();
			 bm = qc.encode(content, width, height, hints);
		 }
		 catch (WriterException ex) {
			 throw new ExceptionConverter(ex);
		 }
	 }
	 private byte[] getBitMatrix() {
		 int width = bm.getWidth();
		 int height = bm.getHeight();
		 int stride = (width + 7) / 8;
		 byte[] b = new byte[stride * height];
		 byte[][] mt = bm.getArray();
		 for (int y = 0;
		 y < height;
		 ++y) {
			 byte[] line = mt[y];
			 for (int x = 0;
			 x < width;
			 ++x) {
				 if (line[x] != 0) {
					 int offset = stride * y + x / 8;
					 b[offset] |= (byte)(0x80 >> (x % 8));
				 }
			 }
		 }
		 return b;
	 }
	 public Image getImage() throws BadElementException {
		 byte[] b = getBitMatrix();
		 byte g4[] = CCITTG4Encoder.compress(b, bm.getWidth(), bm.getHeight());
		 return Image.getInstance(bm.getWidth(), bm.getHeight(), false, Image.CCITTG4, Image.CCITT_BLACKIS1, g4, null);
	 }
	 public java.awt.Image createAwtImage(java.awt.Color foreground, java.awt.Color background) {
		 int f = foreground.getRGB();
		 int g = background.getRGB();
		 Canvas canvas = new Canvas();
		 int width = bm.getWidth();
		 int height = bm.getHeight();
		 int pix[] = new int[width * height];
		 byte[][] mt = bm.getArray();
		 for (int y = 0;
		 y < height;
		 ++y) {
			 byte[] line = mt[y];
			 for (int x = 0;
			 x < width;
			 ++x) {
				 pix[y * width + x] = line[x] == 0 ? f : g;
			 }
		 }
		 java.awt.Image img = canvas.createImage(new MemoryImageSource(width, height, pix, 0, width));
		 return img;
	 }
}",0,1,0,0
"private void executeAddKeySpace(Tree statement) {
	 if (!CliMain.isConnected()) return;
	 String keyspaceName = statement.getChild(0).getText();
	 KsDef ksDef = new KsDef(keyspaceName, DEFAULT_PLACEMENT_STRATEGY, new LinkedList<CfDef>());
	 try {
		 String mySchemaVersion = thriftClient.system_add_keyspace(updateKsDefAttributes(statement, ksDef));
		 sessionState.out.println(mySchemaVersion);
		 validateSchemaIsSettled(mySchemaVersion);
		 keyspacesMap.put(keyspaceName, thriftClient.describe_keyspace(keyspaceName));
	 }
	 catch (InvalidRequestException e) {
		 throw new RuntimeException(e.getWhy());
	 }
	 catch (Exception e) {
		 throw new RuntimeException(e.getMessage(), e);
	 }
 }",0,0,0,0
"public Object eval(Object item, QName returnType) throws javax.xml.transform.TransformerException;",0,0,0,0
"public class PluginDevelopmentPerspective extends AbstractPerspective {
	public PluginDevelopmentPerspective() {
		super(""Plug-in Development"");
	}
}",0,0,0,0
"public void hasColumnFamilySchemaAccess(Permission perm) throws InvalidRequestException {
	 validateLogin();
	 validateKeyspace();
	 if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE) throw new InvalidRequestException(""system keyspace is not user-modifiable"");
	 resourceClear();
	 resource.add(keyspace);
	 Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
	 hasAccess(user, perms, perm, resource);
 }",0,0,0,0
"float writeLineToContent(PdfLine line, PdfContentByte text, PdfContentByte graphics, Object currentValues[], float ratio) throws DocumentException {
	 PdfFont currentFont = (PdfFont)currentValues[0];
	 float lastBaseFactor = ((Float)currentValues[1]).floatValue();
	 PdfChunk chunk;
	 int numberOfSpaces;
	 int lineLen;
	 boolean isJustified;
	 float hangingCorrection = 0;
	 float hScale = 1;
	 float lastHScale = Float.NaN;
	 float baseWordSpacing = 0;
	 float baseCharacterSpacing = 0;
	 float glueWidth = 0;
	 float lastX = text.getXTLM() + line.getOriginalWidth();
	 numberOfSpaces = line.numberOfSpaces();
	 lineLen = line.getLineLengthUtf32();
	 isJustified = line.hasToBeJustified() && (numberOfSpaces != 0 || lineLen > 1);
	 int separatorCount = line.getSeparatorCount();
	 if (separatorCount > 0) {
		 glueWidth = line.widthLeft() / separatorCount;
	 }
	 else if (isJustified && separatorCount == 0) {
		 if (line.isNewlineSplit() && line.widthLeft() >= lastBaseFactor * (ratio * numberOfSpaces + lineLen - 1)) {
			 if (line.isRTL()) {
				 text.moveText(line.widthLeft() - lastBaseFactor * (ratio * numberOfSpaces + lineLen - 1), 0);
			 }
			 baseWordSpacing = ratio * lastBaseFactor;
			 baseCharacterSpacing = lastBaseFactor;
		 }
		 else {
			 float width = line.widthLeft();
			 PdfChunk last = line.getChunk(line.size() - 1);
			 if (last != null) {
				 String s = last.toString();
				 char c;
				 if (s.length() > 0 && hangingPunctuation.indexOf((c = s.charAt(s.length() - 1))) >= 0) {
					 float oldWidth = width;
					 width += last.font().width(c) * 0.4f;
					 hangingCorrection = width - oldWidth;
				 }
			 }
			 float baseFactor = width / (ratio * numberOfSpaces + lineLen - 1);
			 baseWordSpacing = ratio * baseFactor;
			 baseCharacterSpacing = baseFactor;
			 lastBaseFactor = baseFactor;
		 }
	 }
	 else if (line.alignment == Element.ALIGN_LEFT || line.alignment == Element.ALIGN_UNDEFINED) {
		 lastX -= line.widthLeft();
	 }
	 int lastChunkStroke = line.getLastStrokeChunk();
	 int chunkStrokeIdx = 0;
	 float xMarker = text.getXTLM();
	 float baseXMarker = xMarker;
	 float yMarker = text.getYTLM();
	 boolean adjustMatrix = false;
	 float tabPosition = 0;
	 for (Iterator<PdfChunk> j = line.iterator();
	 j.hasNext();
	 ) {
		 chunk = j.next();
		 BaseColor color = chunk.color();
		 float fontSize = chunk.font().size();
		 float ascender = chunk.font().getFont().getFontDescriptor(BaseFont.ASCENT, fontSize);
		 float descender = chunk.font().getFont().getFontDescriptor(BaseFont.DESCENT, fontSize);
		 hScale = 1;
		 if (chunkStrokeIdx <= lastChunkStroke) {
			 float width;
			 if (isJustified) {
				 width = chunk.getWidthCorrected(baseCharacterSpacing, baseWordSpacing);
			 }
			 else {
				 width = chunk.width();
			 }
			 if (chunk.isStroked()) {
				 PdfChunk nextChunk = line.getChunk(chunkStrokeIdx + 1);
				 if (chunk.isSeparator()) {
					 width = glueWidth;
					 Object[] sep = (Object[])chunk.getAttribute(Chunk.SEPARATOR);
					 DrawInterface di = (DrawInterface)sep[0];
					 Boolean vertical = (Boolean)sep[1];
					 if (vertical.booleanValue()) {
						 di.draw(graphics, baseXMarker, yMarker + descender, baseXMarker + line.getOriginalWidth(), ascender - descender, yMarker);
					 }
					 else {
						 di.draw(graphics, xMarker, yMarker + descender, xMarker + width, ascender - descender, yMarker);
					 }
				 }
				 if (chunk.isTab()) {
					 Object[] tab = (Object[])chunk.getAttribute(Chunk.TAB);
					 DrawInterface di = (DrawInterface)tab[0];
					 tabPosition = ((Float)tab[1]).floatValue() + ((Float)tab[3]).floatValue();
					 if (tabPosition > xMarker) {
						 di.draw(graphics, xMarker, yMarker + descender, tabPosition, ascender - descender, yMarker);
					 }
					 float tmp = xMarker;
					 xMarker = tabPosition;
					 tabPosition = tmp;
				 }
				 if (chunk.isAttribute(Chunk.BACKGROUND)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.BACKGROUND)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 Object bgr[] = (Object[])chunk.getAttribute(Chunk.BACKGROUND);
					 graphics.setColorFill((BaseColor)bgr[0]);
					 float extra[] = (float[])bgr[1];
					 graphics.rectangle(xMarker - extra[0], yMarker + descender - extra[1] + chunk.getTextRise(), width - subtract + extra[0] + extra[2], ascender - descender + extra[1] + extra[3]);
					 graphics.fill();
					 graphics.setGrayFill(0);
				 }
				 if (chunk.isAttribute(Chunk.UNDERLINE)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.UNDERLINE)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 Object unders[][] = (Object[][])chunk.getAttribute(Chunk.UNDERLINE);
					 BaseColor scolor = null;
					 for (int k = 0;
					 k < unders.length;
					 ++k) {
						 Object obj[] = unders[k];
						 scolor = (BaseColor)obj[0];
						 float ps[] = (float[])obj[1];
						 if (scolor == null) scolor = color;
						 if (scolor != null) graphics.setColorStroke(scolor);
						 graphics.setLineWidth(ps[0] + fontSize * ps[1]);
						 float shift = ps[2] + fontSize * ps[3];
						 int cap2 = (int)ps[4];
						 if (cap2 != 0) graphics.setLineCap(cap2);
						 graphics.moveTo(xMarker, yMarker + shift);
						 graphics.lineTo(xMarker + width - subtract, yMarker + shift);
						 graphics.stroke();
						 if (scolor != null) graphics.resetGrayStroke();
						 if (cap2 != 0) graphics.setLineCap(0);
					 }
					 graphics.setLineWidth(1);
				 }
				 if (chunk.isAttribute(Chunk.ACTION)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.ACTION)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 text.addAnnotation(new PdfAnnotation(writer, xMarker, yMarker + descender + chunk.getTextRise(), xMarker + width - subtract, yMarker + ascender + chunk.getTextRise(), (PdfAction)chunk.getAttribute(Chunk.ACTION)));
				 }
				 if (chunk.isAttribute(Chunk.REMOTEGOTO)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.REMOTEGOTO)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 Object obj[] = (Object[])chunk.getAttribute(Chunk.REMOTEGOTO);
					 String filename = (String)obj[0];
					 if (obj[1] instanceof String) remoteGoto(filename, (String)obj[1], xMarker, yMarker + descender + chunk.getTextRise(), xMarker + width - subtract, yMarker + ascender + chunk.getTextRise());
					 else remoteGoto(filename, ((Integer)obj[1]).intValue(), xMarker, yMarker + descender + chunk.getTextRise(), xMarker + width - subtract, yMarker + ascender + chunk.getTextRise());
				 }
				 if (chunk.isAttribute(Chunk.LOCALGOTO)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.LOCALGOTO)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 localGoto((String)chunk.getAttribute(Chunk.LOCALGOTO), xMarker, yMarker, xMarker + width - subtract, yMarker + fontSize);
				 }
				 if (chunk.isAttribute(Chunk.LOCALDESTINATION)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.LOCALDESTINATION)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 localDestination((String)chunk.getAttribute(Chunk.LOCALDESTINATION), new PdfDestination(PdfDestination.XYZ, xMarker, yMarker + fontSize, 0));
				 }
				 if (chunk.isAttribute(Chunk.GENERICTAG)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.GENERICTAG)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 Rectangle rect = new Rectangle(xMarker, yMarker, xMarker + width - subtract, yMarker + fontSize);
					 PdfPageEvent pev = writer.getPageEvent();
					 if (pev != null) pev.onGenericTag(writer, this, rect, (String)chunk.getAttribute(Chunk.GENERICTAG));
				 }
				 if (chunk.isAttribute(Chunk.PDFANNOTATION)) {
					 float subtract = lastBaseFactor;
					 if (nextChunk != null && nextChunk.isAttribute(Chunk.PDFANNOTATION)) subtract = 0;
					 if (nextChunk == null) subtract += hangingCorrection;
					 PdfAnnotation annot = PdfFormField.shallowDuplicate((PdfAnnotation)chunk.getAttribute(Chunk.PDFANNOTATION));
					 annot.put(PdfName.RECT, new PdfRectangle(xMarker, yMarker + descender, xMarker + width - subtract, yMarker + ascender));
					 text.addAnnotation(annot);
				 }
				 float params[] = (float[])chunk.getAttribute(Chunk.SKEW);
				 Float hs = (Float)chunk.getAttribute(Chunk.HSCALE);
				 if (params != null || hs != null) {
					 float b = 0, c = 0;
					 if (params != null) {
						 b = params[0];
						 c = params[1];
					 }
					 if (hs != null) hScale = hs.floatValue();
					 text.setTextMatrix(hScale, b, c, 1, xMarker, yMarker);
				 }
				 if (chunk.isAttribute(Chunk.CHAR_SPACING)) {
					 Float cs = (Float) chunk.getAttribute(Chunk.CHAR_SPACING);
					text.setCharacterSpacing(cs.floatValue());
				}
				 if (chunk.isImage()) {
					 Image image = chunk.getImage();
					 float matrix[] = image.matrix();
					 matrix[Image.CX] = xMarker + chunk.getImageOffsetX() - matrix[Image.CX];
					 matrix[Image.CY] = yMarker + chunk.getImageOffsetY() - matrix[Image.CY];
					 graphics.addImage(image, matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
					 text.moveText(xMarker + lastBaseFactor + image.getScaledWidth() - text.getXTLM(), 0);
				 }
			 }
			 xMarker += width;
			 ++chunkStrokeIdx;
		 }
		 if (chunk.font().compareTo(currentFont) != 0) {
			 currentFont = chunk.font();
			 text.setFontAndSize(currentFont.getFont(), currentFont.size());
		 }
		 float rise = 0;
		 Object textRender[] = (Object[])chunk.getAttribute(Chunk.TEXTRENDERMODE);
		 int tr = 0;
		 float strokeWidth = 1;
		 BaseColor strokeColor = null;
		 Float fr = (Float)chunk.getAttribute(Chunk.SUBSUPSCRIPT);
		 if (textRender != null) {
			 tr = ((Integer)textRender[0]).intValue() & 3;
			 if (tr != PdfContentByte.TEXT_RENDER_MODE_FILL) text.setTextRenderingMode(tr);
			 if (tr == PdfContentByte.TEXT_RENDER_MODE_STROKE || tr == PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE) {
				 strokeWidth = ((Float)textRender[1]).floatValue();
				 if (strokeWidth != 1) text.setLineWidth(strokeWidth);
				 strokeColor = (BaseColor)textRender[2];
				 if (strokeColor == null) strokeColor = color;
				 if (strokeColor != null) text.setColorStroke(strokeColor);
			 }
		 }
		 if (fr != null) rise = fr.floatValue();
		 if (color != null) text.setColorFill(color);
		 if (rise != 0) text.setTextRise(rise);
		 if (chunk.isImage()) {
			 adjustMatrix = true;
		 }
		 else if (chunk.isHorizontalSeparator()) {
			 PdfTextArray array = new PdfTextArray();
			 array.add(-glueWidth * 1000f / chunk.font.size() / hScale);
			 text.showText(array);
		 }
		 else if (chunk.isTab()) {
			 PdfTextArray array = new PdfTextArray();
			 array.add((tabPosition - xMarker) * 1000f / chunk.font.size() / hScale);
			 text.showText(array);
		 }
		 else if (isJustified && numberOfSpaces > 0 && chunk.isSpecialEncoding()) {
			 if (hScale != lastHScale) {
				 lastHScale = hScale;
				 text.setWordSpacing(baseWordSpacing / hScale);
				 text.setCharacterSpacing(baseCharacterSpacing / hScale + text.getCharacterSpacing());
			 }
			 String s = chunk.toString();
			 int idx = s.indexOf(' ');
			 if (idx < 0) text.showText(s);
			 else {
				 float spaceCorrection = - baseWordSpacing * 1000f / chunk.font.size() / hScale;
				 PdfTextArray textArray = new PdfTextArray(s.substring(0, idx));
				 int lastIdx = idx;
				 while ((idx = s.indexOf(' ', lastIdx + 1)) >= 0) {
					 textArray.add(spaceCorrection);
					 textArray.add(s.substring(lastIdx, idx));
					 lastIdx = idx;
				 }
				 textArray.add(spaceCorrection);
				 textArray.add(s.substring(lastIdx));
				 text.showText(textArray);
			 }
		 }
		 else {
			 if (isJustified && hScale != lastHScale) {
				 lastHScale = hScale;
				 text.setWordSpacing(baseWordSpacing / hScale);
				 text.setCharacterSpacing(baseCharacterSpacing / hScale + text.getCharacterSpacing());
			 }
			 text.showText(chunk.toString());
		 }
		 if (rise != 0) text.setTextRise(0);
		 if (color != null) text.resetRGBColorFill();
		 if (tr != PdfContentByte.TEXT_RENDER_MODE_FILL) text.setTextRenderingMode(PdfContentByte.TEXT_RENDER_MODE_FILL);
		 if (strokeColor != null) text.resetRGBColorStroke();
		 if (strokeWidth != 1) text.setLineWidth(1);
		 if (chunk.isAttribute(Chunk.SKEW) || chunk.isAttribute(Chunk.HSCALE)) {
			 adjustMatrix = true;
			 text.setTextMatrix(xMarker, yMarker);
		 }
		 if (chunk.isAttribute(Chunk.CHAR_SPACING)) {
			text.setCharacterSpacing(baseCharacterSpacing);
		 }
	 }
	 if (isJustified) {
		 text.setWordSpacing(0);
		 text.setCharacterSpacing(0);
		 if (line.isNewlineSplit()) lastBaseFactor = 0;
	 }
	 if (adjustMatrix) text.moveText(baseXMarker - text.getXTLM(), 0);
	 currentValues[0] = currentFont;
	 currentValues[1] = new Float(lastBaseFactor);
	 return lastX;
 }",0,0,1,0
"static void generateP2P(String templateName, String pathPrefix, String pathSuffix, File input_path, File output_path) throws IOException;",0,0,0,1
"public final class WhileNode extends AbstractLoopNode implements RSyntaxNode, RSyntaxCall {
	 private LoopNode loop;
	 private SetVisibilityNode visibility = SetVisibilityNode.create();
	 public WhileNode(SourceSection src, RSyntaxLookup operator, RSyntaxNode condition, RSyntaxNode body) {
		 super(src, operator);
		 this.loop = Truffle.getRuntime().createLoopNode(new WhileRepeatingNode(this, ConvertBooleanNode.create(condition), body.asRNode()));
	 }
	 public Object execute(VirtualFrame frame) {
		 loop.executeLoop(frame);
		 visibility.execute(frame, false);
		 return RNull.instance;
	 }
	 private static final class WhileRepeatingNode extends AbstractRepeatingNode {
		 private ConvertBooleanNode condition;
		 private final ConditionProfile conditionProfile = ConditionProfile.createCountingProfile();
		 private final BranchProfile normalBlock = BranchProfile.create();
		 private final BranchProfile breakBlock = BranchProfile.create();
		 private final BranchProfile nextBlock = BranchProfile.create();
		 private final WhileNode whileNode;
		 WhileRepeatingNode(WhileNode whileNode, ConvertBooleanNode condition, RNode body) {
			 super(body);
			 this.whileNode = whileNode;
			 this.condition = condition;
			 conditionProfile.profile(false);
		 }
		 public boolean executeRepeating(VirtualFrame frame) {
			 try {
				 if (conditionProfile.profile(condition.executeByte(frame) == RRuntime.LOGICAL_TRUE)) {
					 body.voidExecute(frame);
					 normalBlock.enter();
					 return true;
				 }
				 else {
					 return false;
				 }
			 }
			 catch (BreakException e) {
				 breakBlock.enter();
				 return false;
			 }
			 catch (NextException e) {
				 nextBlock.enter();
				 return true;
			 }
		 }
		 public String toString() {
			 return whileNode.toString();
		 }
	 }
	 public RSyntaxElement[] getSyntaxArguments() {
		 WhileRepeatingNode repeatingNode = (WhileRepeatingNode) loop.getRepeatingNode();
		 return new RSyntaxElement[]{
		repeatingNode.condition.asRSyntaxNode(), repeatingNode.body.asRSyntaxNode()}
		;
	 }
	 public ArgumentsSignature getSyntaxSignature() {
		 return ArgumentsSignature.empty(2);
	 }
}",1,0,0,0
"public static class Header {
	 private String key;
	 private String type;
	 private String value;
	 public String getKey() {
		 return key;
	 }
	 public void setKey(String key) {
		 this.key = key;
	 }
	 public String getType() {
		 return type;
	 }
	 public void setType(String type) {
		 this.type = type;
	 }
	 public String getValue() {
		 return value;
	 }
	 public void setValue(String value) {
		 this.value = value;
	 }
 }",0,1,0,0
"public T get(Duration duration) throws InterruptedException, ExecutionException, TimeoutException {
	 long start = System.currentTimeMillis();
	 Long end = duration==null ? null : start + duration.toMillisecondsRoundingUp();
	 while (end==null || end > System.currentTimeMillis()) {
		 if (cancelled) throw new CancellationException();
		 if (internalFuture == null) {
			 synchronized (this) {
				 long remaining = end - System.currentTimeMillis();
				 if (internalFuture==null && remaining>0) wait(remaining);
			 }
		 }
		 if (internalFuture != null) break;
	 }
	 Long remaining = end==null ? null : end - System.currentTimeMillis();
	 if (isDone()) {
		 return internalFuture.get(1, TimeUnit.MILLISECONDS);
	 }
	 else if (remaining == null) {
		 return internalFuture.get();
	 }
	 else if (remaining > 0) {
		 return internalFuture.get(remaining, TimeUnit.MILLISECONDS);
	 }
	 else {
		 throw new TimeoutException();
	 }
 }",0,0,1,0
"public class Util {
	 private static BagFactory mBagFactory = BagFactory.getInstance();
	 private static TupleFactory mTupleFactory = TupleFactory.getInstance();
	 public static final boolean WINDOWS = System.getProperty(""os.name"").startsWith(""Windows"");
	 public static final String TEST_DIR = System.getProperty(""test.build.dir"", ""build/test"");
	 static public Tuple loadFlatTuple(Tuple t, int[] input) throws ExecException {
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 t.set(i, new Integer(input[i]));
		 }
		 return t;
	 }
	 static public Tuple loadTuple(Tuple t, String[] input) throws ExecException {
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 t.set(i, input[i]);
		 }
		 return t;
	 }
	 static public Tuple loadTuple(Tuple t, DataByteArray[] input) throws ExecException {
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 t.set(i, input[i]);
		 }
		 return t;
	 }
	 static public Tuple loadNestTuple(Tuple t, int[] input) throws ExecException {
		 DataBag bag = BagFactory.getInstance().newDefaultBag();
		 for(int i = 0;
		 i < input.length;
		 i++) {
			 Tuple f = TupleFactory.getInstance().newTuple(1);
			 f.set(0, input[i]);
			 bag.add(f);
		 }
		 t.set(0, bag);
		 return t;
	 }
	 static public Tuple loadNestTuple(Tuple t, long[] input) throws ExecException {
		 DataBag bag = BagFactory.getInstance().newDefaultBag();
		 for(int i = 0;
		 i < input.length;
		 i++) {
			 Tuple f = TupleFactory.getInstance().newTuple(1);
			 f.set(0, new Long(input[i]));
			 bag.add(f);
		 }
		 t.set(0, bag);
		 return t;
	 }
	 static public <T> Tuple loadNestTuple(Tuple t, T[] input) throws ExecException {
		 DataBag bag = BagFactory.getInstance().newDefaultBag();
		 for(int i = 0;
		 i < input.length;
		 i++) {
			 Tuple f = TupleFactory.getInstance().newTuple(1);
			 f.set(0, input[i]);
			 bag.add(f);
		 }
		 t.set(0, bag);
		 return t;
	 }
	 static public <T> Tuple[] splitCreateBagOfTuples(T[] input, int bagSize) throws ExecException {
		 List<Tuple> result = new ArrayList<Tuple>();
		 for (int from = 0;
		 from < input.length;
		 from += bagSize) {
			 Tuple t = TupleFactory.getInstance().newTuple(1);
			 int to = from + bagSize < input.length ? from + bagSize : input.length;
			 T[] array = Arrays.copyOfRange(input, from, to);
			 result.add(loadNestTuple(t, array));
		 }
		 return result.toArray(new Tuple[0]);
	 }
	 static public <T>void addToTuple(Tuple t, T[] b) {
		 for(int i = 0;
		 i < b.length;
		 i++) t.append(b[i]);
	 }
	 static public Tuple buildTuple(Object... args) throws ExecException {
		 return TupleFactory.getInstance().newTupleNoCopy(Lists.newArrayList(args));
	 }
	 static public Tuple buildBinTuple(final Object... args) throws IOException {
		 return TupleFactory.getInstance().newTuple(Lists.transform( Lists.newArrayList(args), new Function<Object, DataByteArray>() {
			 public DataByteArray apply(Object o) {
				 if (o == null) {
					 return null;
				 }
				 try {
					 return new DataByteArray(DataType.toBytes(o));
				 }
				 catch (ExecException e) {
					 return null;
				 }
			 }
		 }
		));
	 }
	 static public <T>Tuple createTuple(T[] s) {
		 Tuple t = mTupleFactory.newTuple();
		 addToTuple(t, s);
		 return t;
	 }
	 static public DataBag createBag(Tuple[] t) {
		 DataBag b = mBagFactory.newDefaultBag();
		 for(int i = 0;
		 i < t.length;
		 i++)b.add(t[i]);
		 return b;
	 }
	 static public<T> DataBag createBagOfOneColumn(T[] input) throws ExecException {
		 DataBag result = mBagFactory.newDefaultBag();
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 Tuple t = mTupleFactory.newTuple(1);
			 t.set(0, input[i]);
			 result.add(t);
		 }
		 return result;
	 }
	 static public Map<String, Object> createMap(String[] contents) {
		 Map<String, Object> m = new HashMap<String, Object>();
		 for(int i = 0;
		 i < contents.length;
		 ) {
			 m.put(contents[i], contents[i+1]);
			 i += 2;
		 }
		 return m;
	 }
	 static public<T> DataByteArray[] toDataByteArrays(T[] input) {
		 DataByteArray[] dbas = new DataByteArray[input.length];
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 dbas[i] = (input[i] == null)?null:new DataByteArray(input[i].toString().getBytes());
		 }
		 return dbas;
	 }
	 static public Tuple loadNestTuple(Tuple t, int[][] input) throws ExecException {
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 DataBag bag = BagFactory.getInstance().newDefaultBag();
			 Tuple f = loadFlatTuple(TupleFactory.getInstance().newTuple(input[i].length), input[i]);
			 bag.add(f);
			 t.set(i, bag);
		 }
		 return t;
	 }
	 static public Tuple loadTuple(Tuple t, String[][] input) throws ExecException {
		 for (int i = 0;
		 i < input.length;
		 i++) {
			 DataBag bag = BagFactory.getInstance().newDefaultBag();
			 Tuple f = loadTuple(TupleFactory.getInstance().newTuple(input[i].length), input[i]);
			 bag.add(f);
			 t.set(i, bag);
		 }
		 return t;
	 }
	 static public String removeColon(String origPath) {
		 return origPath.replaceAll("":"", """");
	 }
	 static public String standardizeNewline(String origPath) {
		 return origPath.replaceAll(""\r\n"", ""\n"");
	 }
	static public File createInputFile(String tmpFilenamePrefix, String tmpFilenameSuffix, String[] inputData)throws IOException {
		File f = File.createTempFile(tmpFilenamePrefix, tmpFilenameSuffix);
		 f.deleteOnExit();
		 writeToFile(f, inputData);
		return f;
	}
	static public File createLocalInputFile(String filename, String[] inputData) throws IOException {
		 File f = new File(filename);
		 f.deleteOnExit();
		 writeToFile(f, inputData);
		 return f;
	 }
	public static void writeToFile(File f, String[] inputData) throwsIOException {
		 PrintWriter pw = new PrintWriter(new OutputStreamWriter(new FileOutputStream(f), ""UTF-8""));
		 for (int i=0;
		 i<inputData.length;
		 i++){
			 pw.print(inputData[i]);
			 pw.print(""\n"");
		 }
		 pw.close();
	}
	 static public void createInputFile(MiniGenericCluster miniCluster, String fileName, String[] inputData) throws IOException {
		 FileSystem fs = miniCluster.getFileSystem();
		 createInputFile(fs, fileName, inputData);
	 }
	 static public void createInputFile(FileSystem fs, String fileName, String[] inputData) throws IOException {
		 if(Util.WINDOWS){
			 fileName = fileName.replace('\\','/');
		 }
		 if(fs.exists(new Path(fileName))) {
			 throw new IOException(""File "" + fileName + "" already exists on the FileSystem"");
		 }
		 FSDataOutputStream stream = fs.create(new Path(fileName));
		 PrintWriter pw = new PrintWriter(new OutputStreamWriter(stream, ""UTF-8""));
		 for (int i=0;
		 i<inputData.length;
		 i++){
			 pw.print(inputData[i]);
			 pw.print(""\n"");
		 }
		 pw.close();
	 }
	 static public String[] readOutput(FileSystem fs, String fileName) throws IOException {
		 if(Util.WINDOWS){
			 fileName = fileName.replace('\\','/');
		 }
		 Path path = new Path(fileName);
		 if(!fs.exists(path)) {
			 throw new IOException(""Path "" + fileName + "" does not exist on the FileSystem"");
		 }
		 FileStatus fileStatus = fs.getFileStatus(path);
		 FileStatus[] files;
		 if (fileStatus.isDirectory()) {
			 files = fs.listStatus(path, new PathFilter() {
				 public boolean accept(Path p) {
					 return !p.getName().startsWith(""_"");
				 }
			 }
			);
		 }
		 else {
			 files = new FileStatus[] {
			 fileStatus }
			;
		 }
		 List<String> result = new ArrayList<String>();
		 for (FileStatus f : files) {
			 FSDataInputStream stream = fs.open(f.getPath());
			 BufferedReader br = new BufferedReader(new InputStreamReader(stream, ""UTF-8""));
			 String line;
			 while ((line = br.readLine()) != null) {
				 result.add(line);
			 }
			 br.close();
		 }
		 return result.toArray(new String[result.size()]);
	 }
	 static public OutputStream createInputFile(MiniGenericCluster cluster, String fileName) throws IOException {
		 FileSystem fs = cluster.getFileSystem();
		 if(Util.WINDOWS){
			 fileName = fileName.replace('\\','/');
		 }
		 if (fs.exists(new Path(fileName))) {
			 throw new IOException(""File "" + fileName + "" already exists on the minicluster"");
		 }
		 return fs.create(new Path(fileName));
	 }
	 static public File createTempFileDelOnExit(String prefix, String suffix) throws IOException {
		 File tmpFile = File.createTempFile(prefix, suffix);
		 tmpFile.deleteOnExit();
		 return tmpFile;
	 }
	 static public void deleteFile(MiniGenericCluster miniCluster, String fileName) throws IOException {
		 FileSystem fs = miniCluster.getFileSystem();
		 if(Util.WINDOWS){
			 fileName = fileName.replace('\\','/');
		 }
		 fs.delete(new Path(fileName), true);
	 }
	 public static void deleteQuietly(MiniGenericCluster miniCluster, String fileName) {
		 try {
			 deleteFile(miniCluster, fileName);
		 }
		 catch (IOException ignored) {
		 }
	 }
	 static public void deleteFile(PigContext pigContext, String fileName) throws IOException {
		 Configuration conf = ConfigurationUtil.toConfiguration( pigContext.getProperties());
		 FileSystem fs = FileSystem.get(conf);
		 if(Util.WINDOWS){
			 fileName = fileName.replace('\\','/');
		 }
		 fs.delete(new Path(fileName), true);
	 }
	 static public boolean exists(PigContext pigContext, String fileName) throws IOException {
		 Configuration conf = ConfigurationUtil.toConfiguration( pigContext.getProperties());
		 FileSystem fs = FileSystem.get(conf);
		 if(Util.WINDOWS){
			 fileName = fileName.replace('\\','/');
		 }
		 return fs.exists(new Path(fileName));
	 }
	 static public void checkQueryOutputs(Iterator<Tuple> actualResults, Tuple[] expectedResults) {
		 checkQueryOutputs(actualResults, Arrays.asList(expectedResults));
	 }
	 static public void checkQueryOutputs(Iterator<Tuple> actualResults, List<Tuple> expectedResults) {
		 checkQueryOutputs(actualResults, expectedResults.iterator(), null );
	 }
	 static public void checkQueryOutputs(Iterator<Tuple> actualResults, Iterator<Tuple> expectedResults, Integer expectedRows) {
		 int count = 0;
		 while (expectedResults.hasNext()) {
			 Tuple expected = expectedResults.next();
			 Assert.assertTrue(""Actual result has less records than expected results"", actualResults.hasNext());
			 Tuple actual = actualResults.next();
			 if( !expected.equals(actual) ) {
				 Assert.assertEquals(expected.toString(), actual.toString());
				 Assert.assertEquals(expected, actual);
			 }
			 count++;
		 }
		 Assert.assertFalse(""Actual result has more records than expected results"", actualResults.hasNext());
		 if (expectedRows != null) {
			 Assert.assertEquals((int)expectedRows, count);
		 }
	 }
	 static public void checkQueryOutputsAfterSort(Iterator<Tuple> actualResultsIt, List<Tuple> expectedResList) {
		 List<Tuple> actualResList = new ArrayList<Tuple>();
		 while(actualResultsIt.hasNext()){
			 actualResList.add(actualResultsIt.next());
		 }
		 checkQueryOutputsAfterSort(actualResList, expectedResList);
	 }
	 static public void checkQueryOutputsAfterSort(Iterator<Tuple> actualResultsIt, Object[][] expectedTwoDimensionObjects) {
		 List<Tuple> expectedResTupleList = new ArrayList<Tuple>();
		 for (int i = 0;
		 i < expectedTwoDimensionObjects.length;
		 ++i) {
			 Tuple t = TupleFactory.getInstance().newTuple();
			 for (int j = 0;
			 j < expectedTwoDimensionObjects[i].length;
			 ++j) {
				 t.append(expectedTwoDimensionObjects[i][j]);
			 }
			 expectedResTupleList.add(t);
		 }
		 checkQueryOutputsAfterSort(actualResultsIt, expectedResTupleList);
	 }
	 static public void checkQueryOutputsAfterSort( List<Tuple> actualResList, List<Tuple> expectedResList) {
		 Collections.sort(actualResList);
		 Collections.sort(expectedResList);
		 checkQueryOutputs(actualResList.iterator(), expectedResList);
	 }
	 static public void checkStrContainsSubStr(String str, String subStr){
		 if(!str.contains(subStr)){
			 fail(""String '""+ subStr + ""' is not a substring of '"" + str + ""'"");
		 }
	 }
	 static public void checkExceptionMessage(String query, String alias, String expectedErr) throws IOException {
		 PigServer pig = new PigServer(ExecType.LOCAL);
		 boolean foundEx = false;
		 try{
			 Util.registerMultiLineQuery(pig, query);
			 pig.explain(alias, System.out);
		 }
		catch(FrontendException e){
			 foundEx = true;
			 checkMessageInException(e, expectedErr);
		 }
		 if(!foundEx) fail(""No exception thrown. Exception is expected."");
	 }
	 public static void checkMessageInException(FrontendException e, String expectedErr) {
		 PigException pigEx = LogUtils.getPigException(e);
		 String message = pigEx.getMessage();
		 checkErrorMessageContainsExpected(message, expectedErr);
	 }
	 public static void checkErrorMessageContainsExpected(String message, String expectedMessage){
		 if(!message.contains(expectedMessage)){
			 String msg = ""Expected error message containing '"" + expectedMessage + ""' but got '"" + message + ""'"" ;
			 fail(msg);
		 }
	 }
	 static private String getFSMkDirCommand(String fileName) {
		 Path parentDir = new Path(fileName).getParent();
		 String mkdirCommand = parentDir.getName().isEmpty() ? """" : ""fs -mkdir -p "" + parentDir + ""\n"";
		 return mkdirCommand;
	 }
	 static public void copyFromLocalToCluster(MiniGenericCluster cluster, String localFileName, String fileNameOnCluster) throws IOException {
		 if(Util.WINDOWS){
			 if (!localFileName.contains("":"")) {
				 localFileName = localFileName.replace('\\','/');
			 }
			 else {
				 localFileName = localFileName.replace('/','\\');
			 }
			 fileNameOnCluster = fileNameOnCluster.replace('\\','/');
		 }
		 PigServer ps = new PigServer(cluster.getExecType(), cluster.getProperties());
		 String script = getFSMkDirCommand(fileNameOnCluster) + ""fs -put "" + localFileName + "" "" + fileNameOnCluster;
		 GruntParser parser = new GruntParser(new StringReader(script), ps);
		 parser.setInteractive(false);
		 try {
			 parser.parseStopOnError();
		 }
		 catch (org.apache.pig.tools.pigscript.parser.ParseException e) {
			 throw new IOException(e);
		 }
	}
	 static public void copyFromLocalToLocal(String fromLocalFileName, String toLocalFileName) throws IOException {
		 FileUtils.copyFile(new File(fromLocalFileName), new File(toLocalFileName));
	 }
	 static public void copyFromClusterToLocal(MiniGenericCluster cluster, String fileNameOnCluster, String localFileName) throws IOException {
		 if(Util.WINDOWS){
			 fileNameOnCluster = fileNameOnCluster.replace('\\','/');
			 localFileName = localFileName.replace('\\','/');
		 }
		 File parent = new File(localFileName).getParentFile();
		 if (!parent.exists()) {
			 parent.mkdirs();
		 }
		 PrintWriter writer = new PrintWriter(new FileWriter(localFileName));
		 FileSystem fs = FileSystem.get(ConfigurationUtil.toConfiguration( cluster.getProperties()));
		 if(!fs.exists(new Path(fileNameOnCluster))) {
			 throw new IOException(""File "" + fileNameOnCluster + "" does not exists on the minicluster"");
		 }
		 String line = null;
		 FileStatus fst = fs.getFileStatus(new Path(fileNameOnCluster));
		 if(fst.isDirectory()) {
			 throw new IOException(""Only files from cluster can be copied locally,"" + "" "" + fileNameOnCluster + "" is a directory"");
		 }
		 FSDataInputStream stream = fs.open(new Path(fileNameOnCluster));
		 BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
		 while( (line = reader.readLine()) != null) {
			 writer.println(line);
		 }
		 reader.close();
		 writer.close();
	}
	static public void printQueryOutput(Iterator<Tuple> actualResults, Tuple[] expectedResults) {
		 System.out.println(""Expected :"") ;
		 for (Tuple expected : expectedResults) {
			 System.out.println(expected.toString()) ;
		 }
		 System.out.println(""---End----"") ;
		 System.out.println(""Actual :"") ;
		 while (actualResults.hasNext()) {
			 System.out.println(actualResults.next().toString()) ;
		 }
		 System.out.println(""---End----"") ;
	 }
	public static String encodeEscape(String str) {
		 String regex = ""\\\\"";
		 String replacement = quoteReplacement(""\\\\"");
		 return str.replaceAll(regex, replacement);
	}
	 public static String generateURI(String filename, PigContext context) throws IOException {
		 if(Util.WINDOWS){
			 filename = filename.replace('\\','/');
		 }
		 if (context.getExecType() == ExecType.MAPREDUCE || context.getExecType().name().equals(""TEZ"") || context.getExecType().name().equals(""SPARK"")) {
			 return FileLocalizer.hadoopify(filename, context);
		 }
		 else if (context.getExecType().isLocal()) {
			 return filename;
		 }
		 else {
			 throw new IllegalStateException(""ExecType: "" + context.getExecType());
		 }
	 }
	 public static Object getPigConstant(String pigConstantAsString) throws ParserException {
		 QueryParserDriver queryParser = new QueryParserDriver( new PigContext(), ""util"", new HashMap<String, String>() ) ;
		 return queryParser.parseConstant(pigConstantAsString);
	 }
	 public static List<Tuple> getTuplesFromConstantTupleStrings(String[] tupleConstants) throws ParserException {
		 List<Tuple> result = new ArrayList<Tuple>(tupleConstants.length);
		 for(int i = 0;
		 i < tupleConstants.length;
		 i++) {
			 result.add((Tuple) getPigConstant(tupleConstants[i]));
		 }
		 return result;
	 }
	 public static List<Tuple> getTuplesFromConstantTupleStringAsByteArray(String[] tupleConstants) throws ParserException, ExecException {
		 List<Tuple> tuples = getTuplesFromConstantTupleStrings(tupleConstants);
		 for(Tuple t : tuples){
			 convertStringToDataByteArray(t);
		 }
		 return tuples;
	 }
	 private static void convertStringToDataByteArray(Tuple t) throws ExecException {
		 if(t == null) return;
		 for(int i=0;
		 i<t.size();
		 i++){
			 Object col = t.get(i);
			 if(col == null) continue;
			 if(col instanceof String){
				 DataByteArray dba = (col == null) ? null : new DataByteArray((String)col);
				 t.set(i, dba);
			 }
			else if(col instanceof Tuple){
				 convertStringToDataByteArray((Tuple)col);
			 }
			else if(col instanceof DataBag){
				 Iterator<Tuple> it = ((DataBag)col).iterator();
				 while(it.hasNext()){
					 convertStringToDataByteArray(it.next());
				 }
			 }
		 }
	 }
	 public static File createFile(String[] data) throws Exception{
		 return createFile(null,data);
	 }
	 public static File createFile(String filePath, String[] data) throws Exception {
		 File f;
		 if( null == filePath || filePath.isEmpty() ) {
			 f = File.createTempFile(""tmp"", """");
		 }
		 else {
			 f = new File(filePath);
		 }
		 if (f.getParent() != null && !(new File(f.getParent())).exists()) {
			 (new File(f.getParent())).mkdirs();
		 }
		 f.deleteOnExit();
		 PrintWriter pw = new PrintWriter(f);
		 for (int i=0;
		 i<data.length;
		 i++){
			 pw.println(data[i]);
		 }
		 pw.close();
		 return f;
	 }
	 public static LogicalPlan optimizeNewLP( LogicalPlan lp) throws FrontendException{
		 DanglingNestedNodeRemover DanglingNestedNodeRemover = new DanglingNestedNodeRemover( lp );
		 DanglingNestedNodeRemover.visit();
		 UidResetter uidResetter = new UidResetter( lp );
		 uidResetter.visit();
		 SchemaResetter schemaResetter = new SchemaResetter( lp, true );
		 schemaResetter.visit();
		 StoreAliasSetter storeAliasSetter = new StoreAliasSetter( lp );
		 storeAliasSetter.visit();
		 org.apache.pig.newplan.logical.optimizer.LogicalPlanOptimizer optimizer = new org.apache.pig.newplan.logical.optimizer.LogicalPlanOptimizer(lp, 100, null);
		 optimizer.optimize();
		 SortInfoSetter sortInfoSetter = new SortInfoSetter( lp );
		 sortInfoSetter.visit();
		 return lp;
	 }
	 public static PhysicalPlan buildPhysicalPlanFromNewLP( LogicalPlan lp, PigContext pc) throws Exception {
		 LogToPhyTranslationVisitor visitor = new LogToPhyTranslationVisitor(lp);
		 visitor.setPigContext(pc);
		 visitor.visit();
		 return visitor.getPhysicalPlan();
	 }
	 public static MROperPlan buildMRPlan(PhysicalPlan pp, PigContext pc) throws Exception{
		 MRCompiler comp = new MRCompiler(pp, pc);
		 comp.compile();
		 comp.aggregateScalarsFiles();
		 comp.connectSoftLink();
		 return comp.getMRPlan();
	 }
	 public static MROperPlan buildMRPlanWithOptimizer(PhysicalPlan pp, PigContext pc) throws Exception {
		 MapRedUtil.checkLeafIsStore(pp, pc);
		 MapReduceLauncher launcher = new MapReduceLauncher();
		 return launcher.compile(pp,pc);
	 }
	 public static MROperPlan buildMRPlan(String query, PigContext pc) throws Exception {
		 LogicalPlan lp = Util.parse(query, pc);
		 Util.optimizeNewLP(lp);
		 PhysicalPlan pp = Util.buildPhysicalPlanFromNewLP(lp, pc);
		 MROperPlan mrp = Util.buildMRPlanWithOptimizer(pp, pc);
		 return mrp;
	 }
	 public static void registerMultiLineQuery(PigServer pigServer, String query) throws IOException {
		 File f = File.createTempFile(""tmp"", """");
		 PrintWriter pw = new PrintWriter(f);
		 pw.println(query);
		 pw.close();
		 pigServer.registerScript(f.getCanonicalPath());
	 }
	 public static int executeJavaCommand(String cmd) throws Exception {
		 return executeJavaCommandAndReturnInfo(cmd).exitCode;
	 }
	 public static class ReadStream implements Runnable {
		 InputStream is;
		 Thread thread;
		 String message = """";
		 public ReadStream(InputStream is) {
			 this.is = is;
		 }
		 public void start () {
			 thread = new Thread (this);
			 thread.start ();
		 }
		 public void run () {
			 try {
				 InputStreamReader isr = new InputStreamReader (is);
				 BufferedReader br = new BufferedReader (isr);
				 while (true) {
					 String s = br.readLine ();
					 if (s == null) break;
					 if (!message.isEmpty()) {
						 message += ""\n"";
					 }
					 message += s;
				 }
				 is.close ();
			 }
			 catch (Exception ex) {
				 ex.printStackTrace ();
			 }
		 }
		 public String getMessage() {
			 return message;
		 }
	 }
	 public static ProcessReturnInfo executeJavaCommandAndReturnInfo(String cmd) throws Exception {
		 String javaHome = System.getenv(""JAVA_HOME"");
		 if(javaHome != null) {
			 String fileSeparator = System.getProperty(""file.separator"");
			 cmd = javaHome + fileSeparator + ""bin"" + fileSeparator + cmd;
		 }
		 Process cmdProc = Runtime.getRuntime().exec(cmd);
		 ProcessReturnInfo pri = new ProcessReturnInfo();
		 ReadStream stdoutStream = new ReadStream(cmdProc.getInputStream ());
		 ReadStream stderrStream = new ReadStream(cmdProc.getErrorStream ());
		 stdoutStream.start();
		 stderrStream.start();
		 cmdProc.waitFor();
		 pri.exitCode = cmdProc.exitValue();
		 pri.stdoutContents = stdoutStream.getMessage();
		 pri.stderrContents = stderrStream.getMessage();
		 return pri;
	 }
	 public static class ProcessReturnInfo {
		 public int exitCode;
		 public String stderrContents;
		 public String stdoutContents;
		 public String toString() {
			 return ""[Exit code: "" + exitCode + "", stdout: <"" + stdoutContents + "">, "" + ""stderr: <"" + stderrContents + "">"";
		 }
	 }
	 static public boolean deleteDirectory(File path) {
		 if(path.exists()) {
			 File[] files = path.listFiles();
			 for(int i=0;
			 i<files.length;
			 i++) {
				 if(files[i].isDirectory()) {
					 deleteDirectory(files[i]);
				 }
				 else {
					 files[i].delete();
				 }
			 }
		 }
		 return(path.delete());
	 }
	 public static void createInputFile(PigContext pigContext, String fileName, String[] input) throws IOException {
		 Configuration conf = ConfigurationUtil.toConfiguration( pigContext.getProperties());
		 createInputFile(FileSystem.get(conf), fileName, input);
	 }
	 public static String[] readOutput(PigContext pigContext, String fileName) throws IOException {
		 Configuration conf = ConfigurationUtil.toConfiguration( pigContext.getProperties());
		 return readOutput(FileSystem.get(conf), fileName);
	 }
	 public static void printPlan(LogicalPlan logicalPlan ) throws Exception {
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 PrintStream ps = new PrintStream(out);
		 LogicalPlanPrinter pp = new LogicalPlanPrinter(logicalPlan,ps);
		 pp.visit();
		 System.err.println(out.toString());
	 }
	 public static void printPlan(PhysicalPlan physicalPlan) throws Exception {
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 PrintStream ps = new PrintStream(out);
		 physicalPlan.explain(ps, ""text"", true);
		 System.err.println(out.toString());
	 }
	 public static List<Tuple> readFile2TupleList(String file, String delimiter) throws IOException{
		 List<Tuple> tuples=new ArrayList<Tuple>();
		 String line=null;
		 BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(file)));
		 while((line=reader.readLine())!=null){
			 String[] tokens=line.split(delimiter);
			 Tuple tuple=TupleFactory.getInstance().newTuple(Arrays.asList(tokens));
			 tuples.add(tuple);
		 }
		 reader.close();
		 return tuples;
	 }
	 public static File resetLog(Class<?> clazz, File logFile) throws Exception {
		 if (logFile != null) logFile.delete();
		 Logger logger = Logger.getLogger(clazz);
		 logger.removeAllAppenders();
		 logger.setLevel(Level.DEBUG);
		 PatternLayout layout = new PatternLayout();
		 File newLogFile = File.createTempFile(""log"", """");
		 FileAppender appender = new FileAppender(layout, newLogFile.toString(), false, false, 0);
		 logger.addAppender(appender);
		 return newLogFile;
	 }
	 public static void checkLogFileMessage(File logFile, String[] messages, boolean expected) {
		 BufferedReader reader = null;
		 try {
			 reader = new BufferedReader(new FileReader(logFile));
			 String logMessage = """";
			 String line;
			 while ((line = reader.readLine()) != null) {
				 logMessage = logMessage + line + ""\n"";
			 }
			 reader.close();
			 for (int i = 0;
			 i < messages.length;
			 i++) {
				 boolean present = logMessage.contains(messages[i]);
				 if (expected) {
					 if(!present){
						 fail(""The message "" + messages[i] + "" is not present in"" + ""log file contents: "" + logMessage);
					 }
				 }
				else{
					 if(present){
						 fail(""The message "" + messages[i] + "" is present in"" + ""log file contents: "" + logMessage);
					 }
				 }
			 }
			 return ;
		 }
		 catch (IOException e) {
			 fail(""caught exception while checking log message :"" + e);
		 }
	 }
	 public static LogicalPlan buildLp(PigServer pigServer, String query) throws Exception {
		 pigServer.setBatchOn();
		 pigServer.registerQuery( query );
		 java.lang.reflect.Method buildLp = pigServer.getClass().getDeclaredMethod(""buildLp"");
		 buildLp.setAccessible(true);
		 return (LogicalPlan ) buildLp.invoke( pigServer );
	 }
	 public static PhysicalPlan buildPp(PigServer pigServer, String query) throws Exception {
		 LogicalPlan lp = buildLp( pigServer, query );
		 lp.optimize(pigServer.getPigContext());
		 return ((HExecutionEngine)pigServer.getPigContext().getExecutionEngine()).compile(lp, pigServer.getPigContext().getProperties());
	 }
	 public static LogicalPlan parse(String query, PigContext pc) throws FrontendException {
		 Map<String, String> fileNameMap = new HashMap<String, String>();
		 QueryParserDriver parserDriver = new QueryParserDriver( pc, ""test"", fileNameMap );
		 org.apache.pig.newplan.logical.relational.LogicalPlan lp = parserDriver.parse( query );
		 lp.validate(pc, ""test"", false);
		 return lp;
	 }
	 public static LogicalPlan parseAndPreprocess(String query, PigContext pc) throws FrontendException {
		 Map<String, String> fileNameMap = new HashMap<String, String>();
		 QueryParserDriver parserDriver = new QueryParserDriver( pc, ""test"", fileNameMap );
		 org.apache.pig.newplan.logical.relational.LogicalPlan lp = parserDriver.parse( query );
		 lp.validate(pc, ""test"", false);
		 return lp;
	 }
	 public static void schemaReplaceNullAlias(Schema sch){
		 if(sch == null) return ;
		 for(FieldSchema fs : sch.getFields()){
			 if(fs.alias != null && fs.alias.toLowerCase().startsWith(""nullalias"")){
				 fs.alias = null;
			 }
			 schemaReplaceNullAlias(fs.schema);
		 }
	 }
	 static public void checkQueryOutputsAfterSort(Iterator<Tuple> actualResultsIt, Tuple[] expectedResArray) {
		 List<Tuple> list = new ArrayList<Tuple>();
		 Collections.addAll(list, expectedResArray);
		 checkQueryOutputsAfterSort(actualResultsIt, list);
	 }
	 static public void convertBagToSortedBag(Tuple t) {
		 for (int i=0;
		i<t.size();
		i++) {
			 Object obj = null;
			 try {
				 obj = t.get(i);
			 }
			 catch (ExecException e) {
			 }
			 if (obj instanceof DataBag) {
				 DataBag bag = (DataBag)obj;
				 Iterator<Tuple> iter = bag.iterator();
				 DataBag sortedBag = DefaultBagFactory.getInstance().newSortedBag(null);
				 while (iter.hasNext()) {
					 Tuple t2 = iter.next();
					 sortedBag.add(t2);
					 convertBagToSortedBag(t2);
				 }
				 try {
					 t.set(i, sortedBag);
				 }
				 catch (ExecException e) {
				 }
			 }
		 }
	 }
	 static public void checkQueryOutputsAfterSortRecursive(Iterator<Tuple> actualResultsIt, String[] expectedResArray, String schemaString) throws IOException {
		 LogicalSchema resultSchema = org.apache.pig.impl.util.Utils.parseSchema(schemaString);
		 checkQueryOutputsAfterSortRecursive(actualResultsIt, expectedResArray, resultSchema);
	 }
	 static public void checkQueryOutputsAfterSortRecursive(Iterator<Tuple> actualResultsIt, String[] expectedResArray, LogicalSchema schema) throws IOException {
		 LogicalFieldSchema fs = new LogicalFieldSchema(""tuple"", schema, DataType.TUPLE);
		 ResourceFieldSchema rfs = new ResourceFieldSchema(fs);
		 LoadCaster caster = new Utf8StorageConverter();
		 List<Tuple> actualResList = new ArrayList<Tuple>();
		 while(actualResultsIt.hasNext()){
			 actualResList.add(actualResultsIt.next());
		 }
		 List<Tuple> expectedResList = new ArrayList<Tuple>();
		 for (String str : expectedResArray) {
			 Tuple newTuple = caster.bytesToTuple(str.getBytes(), rfs);
			 expectedResList.add(newTuple);
		 }
		 for (Tuple t : actualResList) {
			 convertBagToSortedBag(t);
		 }
		 for (Tuple t : expectedResList) {
			 convertBagToSortedBag(t);
		 }
		 Collections.sort(actualResList);
		 Collections.sort(expectedResList);
		 Assert.assertEquals(""Comparing actual and expected results. "", expectedResList, actualResList);
	 }
	 public static String readFile(File file) throws IOException {
		 BufferedReader reader = new BufferedReader(new FileReader(file));
		 String result = """";
		 String line;
		 while ((line=reader.readLine())!=null) {
			 result += line;
			 result += ""\n"";
		 }
		 reader.close();
		 return result;
	 }
	 public static String removeSignature(String plan) {
		 return plan.replaceAll(""','','[^']*','scope','true'\\)\\)"", ""','','','scope','true'))"");
	 }
	 public static boolean isHadoop203plus() {
		 String version = org.apache.hadoop.util.VersionInfo.getVersion();
		 if (version.matches(""\\b0\\.20\\.2\\b"")) return false;
		 return true;
	 }
	 public static boolean isHadoop205() {
		 String version = org.apache.hadoop.util.VersionInfo.getVersion();
		 if (version.matches(""\\b0\\.20\\.205\\..+"")) return true;
		 return false;
	 }
	 public static boolean isHadoop1_x() {
		 String version = org.apache.hadoop.util.VersionInfo.getVersion();
		 if (version.matches(""\\b1\\.*\\..+"")) return true;
		 return false;
	 }
	 public static void sortQueryOutputsIfNeed(List<Tuple> actualResList, boolean toSort){
		 if( toSort == true) {
			 for (Tuple t : actualResList) {
				 Util.convertBagToSortedBag(t);
			 }
			 Collections.sort(actualResList);
		 }
	 }
	 public static void checkQueryOutputs(Iterator<Tuple> actualResults, List<Tuple> expectedResults, boolean checkAfterSort) {
		 if (checkAfterSort) {
			 checkQueryOutputsAfterSort(actualResults, expectedResults);
		 }
		 else {
			 checkQueryOutputs(actualResults, expectedResults);
		 }
	 }
	 static public void checkQueryOutputs(Iterator<Tuple> actualResultsIt, String[] expectedResArray, LogicalSchema schema, boolean checkAfterSort) throws IOException {
		 if (checkAfterSort) {
			 checkQueryOutputsAfterSortRecursive(actualResultsIt, expectedResArray, schema);
		 }
		 else {
			 checkQueryOutputs(actualResultsIt, expectedResArray, schema);
		 }
	 }
	 static void checkQueryOutputs(Iterator<Tuple> actualResultsIt, String[] expectedResArray, LogicalSchema schema) throws IOException {
		 LogicalFieldSchema fs = new LogicalFieldSchema(""tuple"", schema, DataType.TUPLE);
		 ResourceFieldSchema rfs = new ResourceFieldSchema(fs);
		 LoadCaster caster = new Utf8StorageConverter();
		 List<Tuple> actualResList = new ArrayList<Tuple>();
		 while (actualResultsIt.hasNext()) {
			 actualResList.add(actualResultsIt.next());
		 }
		 List<Tuple> expectedResList = new ArrayList<Tuple>();
		 for (String str : expectedResArray) {
			 Tuple newTuple = caster.bytesToTuple(str.getBytes(), rfs);
			 expectedResList.add(newTuple);
		 }
		 for (Tuple t : actualResList) {
			 convertBagToSortedBag(t);
		 }
		 for (Tuple t : expectedResList) {
			 convertBagToSortedBag(t);
		 }
		 Assert.assertEquals(""Comparing actual and expected results. "", expectedResList, actualResList);
	 }
	 public static void assertParallelValues(long defaultParallel, long requestedParallel, long estimatedParallel, long runtimeParallel, Configuration conf) {
		 assertConfLong(conf, ""pig.info.reducers.default.parallel"", defaultParallel);
		 assertConfLong(conf, ""pig.info.reducers.requested.parallel"", requestedParallel);
		 assertConfLong(conf, ""pig.info.reducers.estimated.parallel"", estimatedParallel);
		 assertConfLong(conf, MRConfiguration.REDUCE_TASKS, runtimeParallel);
	 }
	 public static void assertConfLong(Configuration conf, String param, long expected) {
		 assertEquals(""Unexpected value found in configs for "" + param, expected, conf.getLong(param, -1));
	 }
	 public static PathFilter getSuccessMarkerPathFilter() {
		 return new PathFilter() {
			 public boolean accept(Path p) {
				 return !p.getName().startsWith(""_"");
			 }
		 }
		;
	 }
	 public static void assertExceptionAndMessage(Class<?> expected, Exception found, String message) {
		 assertEquals(expected, found.getClass());
		 assertEquals(found.getMessage(), message);
	 }
	 public static void resetStateForExecModeSwitch() {
		 FileLocalizer.setInitialized(false);
		 TezResourceManager.dropInstance();
		 ScriptState.start(null);
	 }
	 public static boolean isMapredExecType(ExecType execType) {
		 return execType == ExecType.MAPREDUCE;
	 }
	 public static boolean isTezExecType(ExecType execType) {
		 if (execType.name().toLowerCase().startsWith(""tez"")) {
			 return true;
		 }
		 return false;
	 }
	 public static boolean isSparkExecType(ExecType execType) {
		 if (execType.name().toLowerCase().startsWith(""spark"")) {
			 return true;
		 }
		 return false;
	 }
	 public static String findPigJarName() {
		 final String suffix = System.getProperty(""hadoopversion"", ""2"");
		 File baseDir = new File(""."");
		 String[] jarNames = baseDir.list(new FilenameFilter() {
			 public boolean accept(File dir, String name) {
				 if (!name.matches(""pig.*h"" + suffix + ""\\.jar"")) {
					 return false;
				 }
				 if (name.contains(""all"")) {
					 return false;
				 }
				 return true;
			 }
		 }
		);
		 if (jarNames==null || jarNames.length!=1) {
			 throw new RuntimeException(""Cannot find pig.jar"");
		 }
		 return jarNames[0];
	 }
	 public static ExecType getLocalTestMode() throws Exception {
		 String execType = System.getProperty(""test.exec.type"");
		 if (execType != null) {
			 if (execType.equals(""tez"")) {
				 return ExecTypeProvider.fromString(""tez_local"");
			 }
			 else if (execType.equals(""spark"")) {
				 return ExecTypeProvider.fromString(""spark_local"");
			 }
		 }
		 return ExecTypeProvider.fromString(""local"");
	 }
	 public static void createLogAppender(String appenderName, Writer writer, Class...clazzes) {
		 WriterAppender writerAppender = new WriterAppender(new PatternLayout(""%d [%t] %-5p %c %x - %m%n""), writer);
		 writerAppender.setName(appenderName);
		 for (Class clazz : clazzes) {
			 Logger logger = Logger.getLogger(clazz);
			 logger.addAppender(writerAppender);
		 }
	 }
	 public static void removeLogAppender(String appenderName, Class...clazzes) {
		 for (Class clazz : clazzes) {
			 Logger logger = Logger.getLogger(clazz);
			 Appender appender = logger.getAppender(appenderName);
			 appender.close();
			 logger.removeAppender(appenderName);
		 }
	 }
	 public static Path getFirstPartFile(Path path) throws Exception {
		 FileStatus[] parts = FileSystem.get(path.toUri(), new Configuration()).listStatus(path, new PathFilter() {
			 public boolean accept(Path path) {
				 return path.getName().startsWith(""part-"");
			 }
		 }
		);
		 return parts[0].getPath();
	 }
	 public static File getFirstPartFile(File dir) throws Exception {
		 File[] parts = dir.listFiles(new FilenameFilter() {
			 public boolean accept(File dir, String name) {
				 return name.startsWith(""part-"");
			 }
			;
		 }
		);
		 return parts[0];
	 }
	 public static String getTestDirectory(Class testClass) {
		 return TEST_DIR + Path.SEPARATOR + ""testdata"" + Path.SEPARATOR +testClass.getSimpleName();
	 }
}",1,0,0,0
"public class Javadoc extends Task {
	 private static final boolean JAVADOC_4 = !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2) && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3);
	 private static final boolean JAVADOC_5 = JAVADOC_4 && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4);
	 public class DocletParam {
		 private String name;
		 private String value;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setValue(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
	 }
	 public static class ExtensionInfo extends ProjectComponent {
		 private String name;
		 private Path path;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setPath(Path path) {
			 if (this.path == null) {
				 this.path = path;
			 }
			 else {
				 this.path.append(path);
			 }
		 }
		 public Path getPath() {
			 return path;
		 }
		 public Path createPath() {
			 if (path == null) {
				 path = new Path(getProject());
			 }
			 return path.createPath();
		 }
		 public void setPathRef(Reference r) {
			 createPath().setRefid(r);
		 }
	 }
	 public class DocletInfo extends ExtensionInfo {
		 private Vector params = new Vector();
		 public DocletParam createParam() {
			 DocletParam param = new DocletParam();
			 params.addElement(param);
			 return param;
		 }
		 public Enumeration getParams() {
			 return params.elements();
		 }
	 }
	 public static class PackageName {
		 private String name;
		 public void setName(String name) {
			 this.name = name.trim();
		 }
		 public String getName() {
			 return name;
		 }
		 public String toString() {
			 return getName();
		 }
	 }
	 public static class SourceFile {
		 private File file;
		 public SourceFile() {
		 }
		 public SourceFile(File file) {
			 this.file = file;
		 }
		 public void setFile(File file) {
			 this.file = file;
		 }
		 public File getFile() {
			 return file;
		 }
	 }
	 public static class Html {
		 private StringBuffer text = new StringBuffer();
		 public void addText(String t) {
			 text.append(t);
		 }
		 public String getText() {
			 return text.substring(0);
		 }
	 }
	 public static class AccessType extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""protected"", ""public"", ""package"", ""private""}
			;
		 }
	 }
	 public class ResourceCollectionContainer {
		 private ArrayList rcs = new ArrayList();
		 public void add(ResourceCollection rc) {
			 rcs.add(rc);
		 }
		 private Iterator iterator() {
			 return rcs.iterator();
		 }
	 }
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private Commandline cmd = new Commandline();
	 private void addArgIf(boolean b, String arg) {
		 if (b) {
			 cmd.createArgument().setValue(arg);
		 }
	 }
	 private void addArgIfNotEmpty(String key, String value) {
		 if (value != null && value.length() != 0) {
			 cmd.createArgument().setValue(key);
			 cmd.createArgument().setValue(value);
		 }
		 else {
			 log(""Warning: Leaving out empty argument '"" + key + ""'"", Project.MSG_WARN);
		 }
	 }
	 private boolean failOnError = false;
	 private Path sourcePath = null;
	 private File destDir = null;
	 private Vector sourceFiles = new Vector();
	 private Vector packageNames = new Vector();
	 private Vector excludePackageNames = new Vector(1);
	 private boolean author = true;
	 private boolean version = true;
	 private DocletInfo doclet = null;
	 private Path classpath = null;
	 private Path bootclasspath = null;
	 private String group = null;
	 private String packageList = null;
	 private Vector links = new Vector();
	 private Vector groups = new Vector();
	 private Vector tags = new Vector();
	 private boolean useDefaultExcludes = true;
	 private Html doctitle = null;
	 private Html header = null;
	 private Html footer = null;
	 private Html bottom = null;
	 private boolean useExternalFile = false;
	 private String source = null;
	 private boolean linksource = false;
	 private boolean breakiterator = false;
	 private String noqualifier;
	 private boolean includeNoSourcePackages = false;
	 private boolean old = false;
	 private String executable = null;
	 private ResourceCollectionContainer nestedSourceFiles = new ResourceCollectionContainer();
	 private Vector packageSets = new Vector();
	 public void setUseExternalFile(boolean b) {
		 useExternalFile = b;
	 }
	 public void setDefaultexcludes(boolean useDefaultExcludes) {
		 this.useDefaultExcludes = useDefaultExcludes;
	 }
	 public void setMaxmemory(String max) {
		 cmd.createArgument().setValue(""-J-Xmx"" + max);
	 }
	 public void setAdditionalparam(String add) {
		 cmd.createArgument().setLine(add);
	 }
	 public Commandline.Argument createArg() {
		 return cmd.createArgument();
	 }
	 public void setSourcepath(Path src) {
		 if (sourcePath == null) {
			 sourcePath = src;
		 }
		 else {
			 sourcePath.append(src);
		 }
	 }
	 public Path createSourcepath() {
		 if (sourcePath == null) {
			 sourcePath = new Path(getProject());
		 }
		 return sourcePath.createPath();
	 }
	 public void setSourcepathRef(Reference r) {
		 createSourcepath().setRefid(r);
	 }
	 public void setDestdir(File dir) {
		 destDir = dir;
		 cmd.createArgument().setValue(""-d"");
		 cmd.createArgument().setFile(destDir);
	 }
	 public void setSourcefiles(String src) {
		 StringTokenizer tok = new StringTokenizer(src, "","");
		 while (tok.hasMoreTokens()) {
			 String f = tok.nextToken();
			 SourceFile sf = new SourceFile();
			 sf.setFile(getProject().resolveFile(f.trim()));
			 addSource(sf);
		 }
	 }
	 public void addSource(SourceFile sf) {
		 sourceFiles.addElement(sf);
	 }
	 public void setPackagenames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addPackage(pn);
		 }
	 }
	 public void addPackage(PackageName pn) {
		 packageNames.addElement(pn);
	 }
	 public void setExcludePackageNames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addExcludePackage(pn);
		 }
	 }
	 public void addExcludePackage(PackageName pn) {
		 excludePackageNames.addElement(pn);
	 }
	 public void setOverview(File f) {
		 cmd.createArgument().setValue(""-overview"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setPublic(boolean b) {
		 addArgIf(b, ""-public"");
	 }
	 public void setProtected(boolean b) {
		 addArgIf(b, ""-protected"");
	 }
	 public void setPackage(boolean b) {
		 addArgIf(b, ""-package"");
	 }
	 public void setPrivate(boolean b) {
		 addArgIf(b, ""-private"");
	 }
	 public void setAccess(AccessType at) {
		 cmd.createArgument().setValue(""-"" + at.getValue());
	 }
	 public void setDoclet(String docletName) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setName(docletName);
	 }
	 public void setDocletPath(Path docletPath) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setPath(docletPath);
	 }
	 public void setDocletPathRef(Reference r) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.createPath().setRefid(r);
	 }
	 public DocletInfo createDoclet() {
		 if (doclet == null) {
			 doclet = new DocletInfo();
		 }
		 return doclet;
	 }
	 public void addTaglet(ExtensionInfo tagletInfo) {
		 tags.addElement(tagletInfo);
	 }
	 public void setOld(boolean b) {
		 old = b;
	 }
	 public void setClasspath(Path path) {
		 if (classpath == null) {
			 classpath = path;
		 }
		 else {
			 classpath.append(path);
		 }
	 }
	 public Path createClasspath() {
		 if (classpath == null) {
			 classpath = new Path(getProject());
		 }
		 return classpath.createPath();
	 }
	 public void setClasspathRef(Reference r) {
		 createClasspath().setRefid(r);
	 }
	 public void setBootclasspath(Path path) {
		 if (bootclasspath == null) {
			 bootclasspath = path;
		 }
		 else {
			 bootclasspath.append(path);
		 }
	 }
	 public Path createBootclasspath() {
		 if (bootclasspath == null) {
			 bootclasspath = new Path(getProject());
		 }
		 return bootclasspath.createPath();
	 }
	 public void setBootClasspathRef(Reference r) {
		 createBootclasspath().setRefid(r);
	 }
	 public void setExtdirs(String path) {
		 cmd.createArgument().setValue(""-extdirs"");
		 cmd.createArgument().setValue(path);
	 }
	 public void setExtdirs(Path path) {
		 cmd.createArgument().setValue(""-extdirs"");
		 cmd.createArgument().setPath(path);
	 }
	 public void setVerbose(boolean b) {
		 addArgIf(b, ""-verbose"");
	 }
	 public void setLocale(String locale) {
		 cmd.createArgument(true).setValue(locale);
		 cmd.createArgument(true).setValue(""-locale"");
	 }
	 public void setEncoding(String enc) {
		 cmd.createArgument().setValue(""-encoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setVersion(boolean b) {
		 this.version = b;
	 }
	 public void setUse(boolean b) {
		 addArgIf(b, ""-use"");
	 }
	 public void setAuthor(boolean b) {
		 author = b;
	 }
	 public void setSplitindex(boolean b) {
		 addArgIf(b, ""-splitindex"");
	 }
	 public void setWindowtitle(String title) {
		 addArgIfNotEmpty(""-windowtitle"", title);
	 }
	 public void setDoctitle(String doctitle) {
		 Html h = new Html();
		 h.addText(doctitle);
		 addDoctitle(h);
	 }
	 public void addDoctitle(Html text) {
		 doctitle = text;
	 }
	 public void setHeader(String header) {
		 Html h = new Html();
		 h.addText(header);
		 addHeader(h);
	 }
	 public void addHeader(Html text) {
		 header = text;
	 }
	 public void setFooter(String footer) {
		 Html h = new Html();
		 h.addText(footer);
		 addFooter(h);
	 }
	 public void addFooter(Html text) {
		 footer = text;
	 }
	 public void setBottom(String bottom) {
		 Html h = new Html();
		 h.addText(bottom);
		 addBottom(h);
	 }
	 public void addBottom(Html text) {
		 bottom = text;
	 }
	 public void setLinkoffline(String src) {
		 LinkArgument le = createLink();
		 le.setOffline(true);
		 String linkOfflineError = ""The linkoffline attribute must include"" + "" a URL and a package-list file location separated by a"" + "" space"";
		 if (src.trim().length() == 0) {
			 throw new BuildException(linkOfflineError);
		 }
		 StringTokenizer tok = new StringTokenizer(src, "" "", false);
		 le.setHref(tok.nextToken());
		 if (!tok.hasMoreTokens()) {
			 throw new BuildException(linkOfflineError);
		 }
		 le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
	 }
	 public void setGroup(String src) {
		 group = src;
	 }
	 public void setLink(String src) {
		 createLink().setHref(src);
	 }
	 public void setNodeprecated(boolean b) {
		 addArgIf(b, ""-nodeprecated"");
	 }
	 public void setNodeprecatedlist(boolean b) {
		 addArgIf(b, ""-nodeprecatedlist"");
	 }
	 public void setNotree(boolean b) {
		 addArgIf(b, ""-notree"");
	 }
	 public void setNoindex(boolean b) {
		 addArgIf(b, ""-noindex"");
	 }
	 public void setNohelp(boolean b) {
		 addArgIf(b, ""-nohelp"");
	 }
	 public void setNonavbar(boolean b) {
		 addArgIf(b, ""-nonavbar"");
	 }
	 public void setSerialwarn(boolean b) {
		 addArgIf(b, ""-serialwarn"");
	 }
	 public void setStylesheetfile(File f) {
		 cmd.createArgument().setValue(""-stylesheetfile"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setHelpfile(File f) {
		 cmd.createArgument().setValue(""-helpfile"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setDocencoding(String enc) {
		 cmd.createArgument().setValue(""-docencoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setPackageList(String src) {
		 packageList = src;
	 }
	 public LinkArgument createLink() {
		 LinkArgument la = new LinkArgument();
		 links.addElement(la);
		 return la;
	 }
	 public class LinkArgument {
		 private String href;
		 private boolean offline = false;
		 private File packagelistLoc;
		 private boolean resolveLink = false;
		 public LinkArgument() {
		 }
		 public void setHref(String hr) {
			 href = hr;
		 }
		 public String getHref() {
			 return href;
		 }
		 public void setPackagelistLoc(File src) {
			 packagelistLoc = src;
		 }
		 public File getPackagelistLoc() {
			 return packagelistLoc;
		 }
		 public void setOffline(boolean offline) {
			 this.offline = offline;
		 }
		 public boolean isLinkOffline() {
			 return offline;
		 }
		 public void setResolveLink(boolean resolve) {
			 this.resolveLink = resolve;
		 }
		 public boolean shouldResolveLink() {
			 return resolveLink;
		 }
	 }
	 public TagArgument createTag() {
		 TagArgument ta = new TagArgument();
		 tags.addElement (ta);
		 return ta;
	 }
	 static final String[] SCOPE_ELEMENTS = {
	 ""overview"", ""packages"", ""types"", ""constructors"", ""methods"", ""fields"" }
	;
	 public class TagArgument extends FileSet {
		 private String name = null;
		 private boolean enabled = true;
		 private String scope = ""a"";
		 public TagArgument () {
		 }
		 public void setName (String name) {
			 this.name = name;
		 }
		 public void setScope (String verboseScope) throws BuildException {
			 verboseScope = verboseScope.toLowerCase(Locale.US);
			 boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
			 boolean gotAll = false;
			 boolean gotNotAll = false;
			 StringTokenizer tok = new StringTokenizer (verboseScope, "","");
			 while (tok.hasMoreTokens()) {
				 String next = tok.nextToken().trim();
				 if (next.equals(""all"")) {
					 if (gotAll) {
						 getProject().log (""Repeated tag scope element: all"", Project.MSG_VERBOSE);
					 }
					 gotAll = true;
				 }
				 else {
					 int i;
					 for (i = 0;
					 i < SCOPE_ELEMENTS.length;
					 i++) {
						 if (next.equals (SCOPE_ELEMENTS[i])) {
							 break;
						 }
					 }
					 if (i == SCOPE_ELEMENTS.length) {
						 throw new BuildException (""Unrecognised scope element: "" + next);
					 }
					 else {
						 if (elements[i]) {
							 getProject().log (""Repeated tag scope element: "" + next, Project.MSG_VERBOSE);
						 }
						 elements[i] = true;
						 gotNotAll = true;
					 }
				 }
			 }
			 if (gotNotAll && gotAll) {
				 throw new BuildException (""Mixture of \""all\"" and other scope "" + ""elements in tag parameter."");
			 }
			 if (!gotNotAll && !gotAll) {
				 throw new BuildException (""No scope elements specified in tag "" + ""parameter."");
			 }
			 if (gotAll) {
				 this.scope = ""a"";
			 }
			 else {
				 StringBuffer buff = new StringBuffer (elements.length);
				 for (int i = 0;
				 i < elements.length;
				 i++) {
					 if (elements[i]) {
						 buff.append (SCOPE_ELEMENTS[i].charAt(0));
					 }
				 }
				 this.scope = buff.toString();
			 }
		 }
		 public void setEnabled (boolean enabled) {
			 this.enabled = enabled;
		 }
		 public String getParameter() throws BuildException {
			 if (name == null || name.equals("""")) {
				 throw new BuildException (""No name specified for custom tag."");
			 }
			 if (getDescription() != null) {
				 return name + "":"" + (enabled ? """" : ""X"") + scope + "":"" + getDescription();
			 }
			 else if (!enabled || !""a"".equals(scope)) {
				 return name + "":"" + (enabled ? """" : ""X"") + scope;
			 }
			 else {
				 return name;
			 }
		 }
	 }
	 public GroupArgument createGroup() {
		 GroupArgument ga = new GroupArgument();
		 groups.addElement(ga);
		 return ga;
	 }
	 public class GroupArgument {
		 private Html title;
		 private Vector packages = new Vector();
		 public GroupArgument() {
		 }
		 public void setTitle(String src) {
			 Html h = new Html();
			 h.addText(src);
			 addTitle(h);
		 }
		 public void addTitle(Html text) {
			 title = text;
		 }
		 public String getTitle() {
			 return title != null ? title.getText() : null;
		 }
		 public void setPackages(String src) {
			 StringTokenizer tok = new StringTokenizer(src, "","");
			 while (tok.hasMoreTokens()) {
				 String p = tok.nextToken();
				 PackageName pn = new PackageName();
				 pn.setName(p);
				 addPackage(pn);
			 }
		 }
		 public void addPackage(PackageName pn) {
			 packages.addElement(pn);
		 }
		 public String getPackages() {
			 StringBuffer p = new StringBuffer();
			 for (int i = 0;
			 i < packages.size();
			 i++) {
				 if (i > 0) {
					 p.append("":"");
				 }
				 p.append(packages.elementAt(i).toString());
			 }
			 return p.toString();
		 }
	 }
	 public void setCharset(String src) {
		 this.addArgIfNotEmpty(""-charset"", src);
	 }
	 public void setFailonerror(boolean b) {
		 failOnError = b;
	 }
	 public void setSource(String source) {
		 this.source = source;
	 }
	 public void setExecutable(String executable) {
		 this.executable = executable;
	 }
	 public void addPackageset(DirSet packageSet) {
		 packageSets.addElement(packageSet);
	 }
	 public void addFileset(FileSet fs) {
		 createSourceFiles().add(fs);
	 }
	 public ResourceCollectionContainer createSourceFiles() {
		 return nestedSourceFiles;
	 }
	 public void setLinksource(boolean b) {
		 this.linksource = b;
	 }
	 public void setBreakiterator(boolean b) {
		 this.breakiterator = b;
	 }
	 public void setNoqualifier(String noqualifier) {
		 this.noqualifier = noqualifier;
	 }
	 public void setIncludeNoSourcePackages(boolean b) {
		 this.includeNoSourcePackages = b;
	 }
	 public void execute() throws BuildException {
		 checkTaskName();
		 Vector packagesToDoc = new Vector();
		 Path sourceDirs = new Path(getProject());
		 checkPackageAndSourcePath();
		 if (sourcePath != null) {
			 sourceDirs.addExisting(sourcePath);
		 }
		 parsePackages(packagesToDoc, sourceDirs);
		 checkPackages(packagesToDoc, sourceDirs);
		 Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
		 addSourceFiles(sourceFilesToDoc);
		 checkPackagesToDoc(packagesToDoc, sourceFilesToDoc);
		 log(""Generating Javadoc"", Project.MSG_INFO);
		 Commandline toExecute = (Commandline) cmd.clone();
		 if (executable != null) {
			 toExecute.setExecutable(executable);
		 }
		 else {
			 toExecute.setExecutable(JavaEnvUtils.getJdkExecutable(""javadoc""));
		 }
		 generalJavadocArguments(toExecute);
		 doSourcePath(toExecute, sourceDirs);
		 doDoclet(toExecute);
		 doBootPath(toExecute);
		 doLinks(toExecute);
		 doGroup(toExecute);
		 doGroups(toExecute);
		 if (JAVADOC_4 || executable != null) {
			 doJava14(toExecute);
			 if (breakiterator && (doclet == null || JAVADOC_5)) {
				 toExecute.createArgument().setValue(""-breakiterator"");
			 }
		 }
		 else {
			 doNotJava14();
		 }
		 if (!JAVADOC_4 || executable != null) {
			 if (old) {
				 toExecute.createArgument().setValue(""-1.1"");
			 }
		 }
		 else {
			 if (old) {
				 log(""Javadoc 1.4 doesn't support the -1.1 switch anymore"", Project.MSG_WARN);
			 }
		 }
		 if (useExternalFile && JAVADOC_4) {
			 writeExternalArgs(toExecute);
		 }
		 File tmpList = null;
		 PrintWriter srcListWriter = null;
		 try {
			 if (useExternalFile) {
				 tmpList = FILE_UTILS.createTempFile(""javadoc"", """", null, true, true);
				 toExecute.createArgument() .setValue(""@"" + tmpList.getAbsolutePath());
				 srcListWriter = new PrintWriter( new FileWriter(tmpList.getAbsolutePath(), true));
			 }
			 doSourceAndPackageNames( toExecute, packagesToDoc, sourceFilesToDoc, useExternalFile, tmpList, srcListWriter);
		 }
		 catch (IOException e) {
			 tmpList.delete();
			 throw new BuildException(""Error creating temporary file"", e, getLocation());
		 }
		 finally {
			 if (srcListWriter != null) {
				 srcListWriter.close();
			 }
		 }
		 if (packageList != null) {
			 toExecute.createArgument().setValue(""@"" + packageList);
		 }
		 log(toExecute.describeCommand(), Project.MSG_VERBOSE);
		 log(""Javadoc execution"", Project.MSG_INFO);
		 JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
		 JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
		 Execute exe = new Execute(new PumpStreamHandler(out, err));
		 exe.setAntRun(getProject());
		 exe.setWorkingDirectory(null);
		 try {
			 exe.setCommandline(toExecute.getCommandline());
			 int ret = exe.execute();
			 if (ret != 0 && failOnError) {
				 throw new BuildException(""Javadoc returned "" + ret, getLocation());
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(""Javadoc failed: "" + e, e, getLocation());
		 }
		 finally {
			 if (tmpList != null) {
				 tmpList.delete();
				 tmpList = null;
			 }
			 out.logFlush();
			 err.logFlush();
			 try {
				 out.close();
				 err.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 private void checkTaskName() {
		 if (""javadoc2"".equals(getTaskType())) {
			 log(""Warning: the task name <javadoc2> is deprecated."" + "" Use <javadoc> instead."", Project.MSG_WARN);
		 }
	 }
	 private void checkPackageAndSourcePath() {
		 if (packageList != null && sourcePath == null) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying packagelist."";
			 throw new BuildException(msg);
		 }
	 }
	 private void checkPackages(Vector packagesToDoc, Path sourceDirs) {
		 if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying package names."";
			 throw new BuildException(msg);
		 }
	 }
	 private void checkPackagesToDoc( Vector packagesToDoc, Vector sourceFilesToDoc) {
		 if (packageList == null && packagesToDoc.size() == 0 && sourceFilesToDoc.size() == 0) {
			 throw new BuildException(""No source files and no packages have "" + ""been specified."");
		 }
	 }
	 private void doSourcePath(Commandline toExecute, Path sourceDirs) {
		 if (sourceDirs.size() > 0) {
			 toExecute.createArgument().setValue(""-sourcepath"");
			 toExecute.createArgument().setPath(sourceDirs);
		 }
	 }
	 private void generalJavadocArguments(Commandline toExecute) {
		 if (doctitle != null) {
			 toExecute.createArgument().setValue(""-doctitle"");
			 toExecute.createArgument().setValue(expand(doctitle.getText()));
		 }
		 if (header != null) {
			 toExecute.createArgument().setValue(""-header"");
			 toExecute.createArgument().setValue(expand(header.getText()));
		 }
		 if (footer != null) {
			 toExecute.createArgument().setValue(""-footer"");
			 toExecute.createArgument().setValue(expand(footer.getText()));
		 }
		 if (bottom != null) {
			 toExecute.createArgument().setValue(""-bottom"");
			 toExecute.createArgument().setValue(expand(bottom.getText()));
		 }
		 if (classpath == null) {
			 classpath = (new Path(getProject())).concatSystemClasspath(""last"");
		 }
		 else {
			 classpath = classpath.concatSystemClasspath(""ignore"");
		 }
		 if (classpath.size() > 0) {
			 toExecute.createArgument().setValue(""-classpath"");
			 toExecute.createArgument().setPath(classpath);
		 }
		 if (version && doclet == null) {
			 toExecute.createArgument().setValue(""-version"");
		 }
		 if (author && doclet == null) {
			 toExecute.createArgument().setValue(""-author"");
		 }
		 if (doclet == null && destDir == null) {
			 throw new BuildException(""destdir attribute must be set!"");
		 }
	 }
	 private void doDoclet(Commandline toExecute) {
		 if (doclet != null) {
			 if (doclet.getName() == null) {
				 throw new BuildException(""The doclet name must be "" + ""specified."", getLocation());
			 }
			 else {
				 toExecute.createArgument().setValue(""-doclet"");
				 toExecute.createArgument().setValue(doclet.getName());
				 if (doclet.getPath() != null) {
					 Path docletPath = doclet.getPath().concatSystemClasspath(""ignore"");
					 if (docletPath.size() != 0) {
						 toExecute.createArgument().setValue(""-docletpath"");
						 toExecute.createArgument().setPath(docletPath);
					 }
				 }
				 for (Enumeration e = doclet.getParams();
				 e.hasMoreElements();
				) {
					 DocletParam param = (DocletParam) e.nextElement();
					 if (param.getName() == null) {
						 throw new BuildException(""Doclet parameters must "" + ""have a name"");
					 }
					 toExecute.createArgument().setValue(param.getName());
					 if (param.getValue() != null) {
						 toExecute.createArgument() .setValue(param.getValue());
					 }
				 }
			 }
		 }
	 }
	 private void writeExternalArgs(Commandline toExecute) {
		 File optionsTmpFile = null;
		 PrintWriter optionsListWriter = null;
		 try {
			 optionsTmpFile = FILE_UTILS.createTempFile( ""javadocOptions"", """", null, true, true);
			 String[] listOpt = toExecute.getArguments();
			 toExecute.clearArgs();
			 toExecute.createArgument().setValue( ""@"" + optionsTmpFile.getAbsolutePath());
			 optionsListWriter = new PrintWriter( new FileWriter(optionsTmpFile.getAbsolutePath(), true));
			 for (int i = 0;
			 i < listOpt.length;
			 i++) {
				 String string = listOpt[i];
				 if (string.startsWith(""-J-"")) {
					 toExecute.createArgument().setValue(string);
				 }
				 else {
					 if (string.startsWith(""-"")) {
						 optionsListWriter.print(string);
						 optionsListWriter.print("" "");
					 }
					 else {
						 optionsListWriter.println(quoteString(string));
					 }
				 }
			 }
			 optionsListWriter.close();
		 }
		 catch (IOException ex) {
			 if (optionsTmpFile != null) {
				 optionsTmpFile.delete();
			 }
			 throw new BuildException( ""Error creating or writing temporary file for javadoc options"", ex, getLocation());
		 }
		 finally {
			 FILE_UTILS.close(optionsListWriter);
		 }
	 }
	 private void doBootPath(Commandline toExecute) {
		 Path bcp = new Path(getProject());
		 if (bootclasspath != null) {
			 bcp.append(bootclasspath);
		 }
		 bcp = bcp.concatSystemBootClasspath(""ignore"");
		 if (bcp.size() > 0) {
			 toExecute.createArgument().setValue(""-bootclasspath"");
			 toExecute.createArgument().setPath(bcp);
		 }
	 }
	 private void doLinks(Commandline toExecute) {
		 if (links.size() != 0) {
			 for (Enumeration e = links.elements();
			 e.hasMoreElements();
			) {
				 LinkArgument la = (LinkArgument) e.nextElement();
				 if (la.getHref() == null || la.getHref().length() == 0) {
					 log(""No href was given for the link - skipping"", Project.MSG_VERBOSE);
					 continue;
				 }
				 String link = null;
				 if (la.shouldResolveLink()) {
					 File hrefAsFile = getProject().resolveFile(la.getHref());
					 if (hrefAsFile.exists()) {
						 try {
							 link = FILE_UTILS.getFileURL(hrefAsFile) .toExternalForm();
						 }
						 catch (MalformedURLException ex) {
							 log(""Warning: link location was invalid "" + hrefAsFile, Project.MSG_WARN);
						 }
					 }
				 }
				 if (link == null) {
					 try {
						 URL base = new URL(""file: new URL(base, la.getHref());
						 link = la.getHref();
					 }
					 catch (MalformedURLException mue) {
						 log(""Link href \"""" + la.getHref() + ""\"" is not a valid url - skipping link"", Project.MSG_WARN);
						 continue;
					 }
				 }
				 if (la.isLinkOffline()) {
					 File packageListLocation = la.getPackagelistLoc();
					 if (packageListLocation == null) {
						 throw new BuildException(""The package list"" + "" location for link "" + la.getHref() + "" must be provided "" + ""because the link is "" + ""offline"");
					 }
					 File packageListFile = new File(packageListLocation, ""package-list"");
					 if (packageListFile.exists()) {
						 try {
							 String packageListURL = FILE_UTILS.getFileURL(packageListLocation) .toExternalForm();
							 toExecute.createArgument() .setValue(""-linkoffline"");
							 toExecute.createArgument() .setValue(link);
							 toExecute.createArgument() .setValue(packageListURL);
						 }
						 catch (MalformedURLException ex) {
							 log(""Warning: Package list location was "" + ""invalid "" + packageListLocation, Project.MSG_WARN);
						 }
					 }
					 else {
						 log(""Warning: No package list was found at "" + packageListLocation, Project.MSG_VERBOSE);
					 }
				 }
				 else {
					 toExecute.createArgument().setValue(""-link"");
					 toExecute.createArgument().setValue(link);
				 }
			 }
		 }
	 }
	 private void doGroup(Commandline toExecute) {
		 if (group != null) {
			 StringTokenizer tok = new StringTokenizer(group, "","", false);
			 while (tok.hasMoreTokens()) {
				 String grp = tok.nextToken().trim();
				 int space = grp.indexOf("" "");
				 if (space > 0) {
					 String name = grp.substring(0, space);
					 String pkgList = grp.substring(space + 1);
					 toExecute.createArgument().setValue(""-group"");
					 toExecute.createArgument().setValue(name);
					 toExecute.createArgument().setValue(pkgList);
				 }
			 }
		 }
	 }
	 private void doGroups(Commandline toExecute) {
		 if (groups.size() != 0) {
			 for (Enumeration e = groups.elements();
			 e.hasMoreElements();
			) {
				 GroupArgument ga = (GroupArgument) e.nextElement();
				 String title = ga.getTitle();
				 String packages = ga.getPackages();
				 if (title == null || packages == null) {
					 throw new BuildException(""The title and packages must "" + ""be specified for group "" + ""elements."");
				 }
				 toExecute.createArgument().setValue(""-group"");
				 toExecute.createArgument().setValue(expand(title));
				 toExecute.createArgument().setValue(packages);
			 }
		 }
	 }
	 private void doJava14(Commandline toExecute) {
		 for (Enumeration e = tags.elements();
		 e.hasMoreElements();
		) {
			 Object element = e.nextElement();
			 if (element instanceof TagArgument) {
				 TagArgument ta = (TagArgument) element;
				 File tagDir = ta.getDir(getProject());
				 if (tagDir == null) {
					 toExecute.createArgument().setValue (""-tag"");
					 toExecute.createArgument() .setValue (ta.getParameter());
				 }
				 else {
					 DirectoryScanner tagDefScanner = ta.getDirectoryScanner(getProject());
					 String[] files = tagDefScanner.getIncludedFiles();
					 for (int i = 0;
					 i < files.length;
					 i++) {
						 File tagDefFile = new File(tagDir, files[i]);
						 try {
							 BufferedReader in = new BufferedReader( new FileReader(tagDefFile) );
							 String line = null;
							 while ((line = in.readLine()) != null) {
								 toExecute.createArgument() .setValue(""-tag"");
								 toExecute.createArgument() .setValue(line);
							 }
							 in.close();
						 }
						 catch (IOException ioe) {
							 throw new BuildException( ""Couldn't read "" + "" tag file from "" + tagDefFile.getAbsolutePath(), ioe);
						 }
					 }
				 }
			 }
			 else {
				 ExtensionInfo tagletInfo = (ExtensionInfo) element;
				 toExecute.createArgument().setValue(""-taglet"");
				 toExecute.createArgument().setValue(tagletInfo .getName());
				 if (tagletInfo.getPath() != null) {
					 Path tagletPath = tagletInfo.getPath() .concatSystemClasspath(""ignore"");
					 if (tagletPath.size() != 0) {
						 toExecute.createArgument() .setValue(""-tagletpath"");
						 toExecute.createArgument().setPath(tagletPath);
					 }
				 }
			 }
		 }
		 String sourceArg = source != null ? source : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
		 if (sourceArg != null) {
			 toExecute.createArgument().setValue(""-source"");
			 toExecute.createArgument().setValue(sourceArg);
		 }
		 if (linksource && doclet == null) {
			 toExecute.createArgument().setValue(""-linksource"");
		 }
		 if (noqualifier != null && doclet == null) {
			 toExecute.createArgument().setValue(""-noqualifier"");
			 toExecute.createArgument().setValue(noqualifier);
		 }
	 }
	 private void doNotJava14() {
		 if (!tags.isEmpty()) {
			 log(""-tag and -taglet options not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
		 }
		 if (source != null) {
			 log(""-source option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
		 }
		 if (linksource) {
			 log(""-linksource option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
		 }
		 if (breakiterator) {
			 log(""-breakiterator option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
		 }
		 if (noqualifier != null) {
			 log(""-noqualifier option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
		 }
	 }
	 private void doSourceAndPackageNames( Commandline toExecute, Vector packagesToDoc, Vector sourceFilesToDoc, boolean useExternalFile, File tmpList, PrintWriter srcListWriter) throws IOException {
		 Enumeration e = packagesToDoc.elements();
		 while (e.hasMoreElements()) {
			 String packageName = (String) e.nextElement();
			 if (useExternalFile) {
				 srcListWriter.println(packageName);
			 }
			 else {
				 toExecute.createArgument().setValue(packageName);
			 }
		 }
		 e = sourceFilesToDoc.elements();
		 while (e.hasMoreElements()) {
			 SourceFile sf = (SourceFile) e.nextElement();
			 String sourceFileName = sf.getFile().getAbsolutePath();
			 if (useExternalFile) {
				 if (JAVADOC_4 && sourceFileName.indexOf("" "") > -1) {
					 String name = sourceFileName;
					 if (File.separatorChar == '\\') {
						 name = sourceFileName.replace(File.separatorChar, '/');
					 }
					 srcListWriter.println(""\"""" + name + ""\"""");
				 }
				 else {
					 srcListWriter.println(sourceFileName);
				 }
			 }
			 else {
				 toExecute.createArgument().setValue(sourceFileName);
			 }
		 }
	 }
	 private String quoteString(String str) {
		 if (str.indexOf(' ') == -1 && str.indexOf('\'') == -1 && str.indexOf('""') == -1) {
			 return str;
		 }
		 if (str.indexOf('\'') == -1) {
			 return quoteString(str, '\'');
		 }
		 else {
			 return quoteString(str, '""');
		 }
	 }
	 private String quoteString(String str, char delim) {
		 StringBuffer buf = new StringBuffer(str.length() * 2);
		 buf.append(delim);
		 if (str.indexOf('\\') != -1) {
			 str = replace(str, '\\', ""\\\\"");
		 }
		 if (str.indexOf(delim) != -1) {
			 str = replace(str, delim, ""\\"" + delim);
		 }
		 buf.append(str);
		 buf.append(delim);
		 return buf.toString();
	 }
	 private String replace(String str, char fromChar, String toString) {
		 StringBuffer buf = new StringBuffer(str.length() * 2);
		 for (int i = 0;
		 i < str.length();
		 ++i) {
			 char ch = str.charAt(i);
			 if (ch == fromChar) {
				 buf.append(toString);
			 }
			 else {
				 buf.append(ch);
			 }
		 }
		 return buf.toString();
	 }
	 private void addSourceFiles(Vector sf) {
		 Iterator e = nestedSourceFiles.iterator();
		 while (e.hasNext()) {
			 ResourceCollection rc = (ResourceCollection) e.next();
			 if (!rc.isFilesystemOnly()) {
				 throw new BuildException(""only file system based resources are"" + "" supported by javadoc"");
			 }
			 if (rc instanceof FileSet) {
				 FileSet fs = (FileSet) rc;
				 if (!fs.hasPatterns() && !fs.hasSelectors()) {
					 FileSet fs2 = (FileSet) fs.clone();
					 fs2.createInclude().setName(""**package.html"");
				 }
				 rc = fs2;
			 }
		 }
		 Iterator iter = rc.iterator();
		 while (iter.hasNext()) {
			 sf.addElement(new SourceFile(((FileResource) iter.next()) .getFile()));
		 }
	 }
 }
 private void parsePackages(Vector pn, Path sp) {
	 Vector addedPackages = new Vector();
	 Vector dirSets = (Vector) packageSets.clone();
	 if (sourcePath != null) {
		 PatternSet ps = new PatternSet();
		 if (packageNames.size() > 0) {
			 Enumeration e = packageNames.elements();
			 while (e.hasMoreElements()) {
				 PackageName p = (PackageName) e.nextElement();
				 String pkg = p.getName().replace('.', '/');
				 if (pkg.endsWith(""*"")) {
					 pkg += ""*"";
				 }
				 ps.createInclude().setName(pkg);
			 }
		 }
		 else {
			 ps.createInclude().setName(""**"");
		 }
		 Enumeration e = excludePackageNames.elements();
		 while (e.hasMoreElements()) {
			 PackageName p = (PackageName) e.nextElement();
			 String pkg = p.getName().replace('.', '/');
			 if (pkg.endsWith(""*"")) {
				 pkg += ""*"";
			 }
			 ps.createExclude().setName(pkg);
		 }
		 String[] pathElements = sourcePath.list();
		 for (int i = 0;
		 i < pathElements.length;
		 i++) {
			 File dir = new File(pathElements[i]);
			 if (dir.isDirectory()) {
				 DirSet ds = new DirSet();
				 ds.setDefaultexcludes(useDefaultExcludes);
				 ds.setDir(dir);
				 ds.createPatternSet().addConfiguredPatternset(ps);
				 dirSets.addElement(ds);
			 }
			 else {
				 log(""Skipping "" + pathElements[i] + "" since it is no directory."", Project.MSG_WARN);
			 }
		 }
	 }
	 Enumeration e = dirSets.elements();
	 while (e.hasMoreElements()) {
		 DirSet ds = (DirSet) e.nextElement();
		 File baseDir = ds.getDir(getProject());
		 log(""scanning "" + baseDir + "" for packages."", Project.MSG_DEBUG);
		 DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
		 String[] dirs = dsc.getIncludedDirectories();
		 boolean containsPackages = false;
		 for (int i = 0;
		 i < dirs.length;
		 i++) {
			 File pd = new File(baseDir, dirs[i]);
			 String[] files = pd.list(new FilenameFilter () {
				 public boolean accept(File dir1, String name) {
					 return name.endsWith("".java"") || (includeNoSourcePackages && name.equals(""package.html""));
				 }
			 }
			);
			 if (files.length > 0) {
				 if ("""".equals(dirs[i])) {
					 log(baseDir + "" contains source files in the default package,"" + "" you must specify them as source files"" + "" not packages."", Project.MSG_WARN);
				 }
				 else {
					 containsPackages = true;
					 String packageName = dirs[i].replace(File.separatorChar, '.');
					 if (!addedPackages.contains(packageName)) {
						 addedPackages.addElement(packageName);
						 pn.addElement(packageName);
					 }
				 }
			 }
		 }
		 if (containsPackages) {
			 sp.createPathElement().setLocation(baseDir);
		 }
		 else {
			 log(baseDir + "" doesn\'t contain any packages, dropping it."", Project.MSG_VERBOSE);
		 }
	 }
 }
 private class JavadocOutputStream extends LogOutputStream {
	 JavadocOutputStream(int level) {
		 super(Javadoc.this, level);
	 }
	 private String queuedLine = null;
	 protected void processLine(String line, int messageLevel) {
		 if (messageLevel == Project.MSG_INFO && line.startsWith(""Generating "")) {
			 if (queuedLine != null) {
				 super.processLine(queuedLine, Project.MSG_VERBOSE);
			 }
			 queuedLine = line;
		 }
		 else {
			 if (queuedLine != null) {
				 if (line.startsWith(""Building "")) {
					 super.processLine(queuedLine, Project.MSG_VERBOSE);
				 }
				 else {
					 super.processLine(queuedLine, Project.MSG_INFO);
				 }
				 queuedLine = null;
			 }
			 super.processLine(line, messageLevel);
		 }
	 }
	 protected void logFlush() {
		 if (queuedLine != null) {
			 super.processLine(queuedLine, Project.MSG_VERBOSE);
			 queuedLine = null;
		 }
	 }
 }
 protected String expand(String content) {
	 return getProject().replaceProperties(content);
 }
}",1,0,0,0
"protected void initScriptRunner() {
	 if (runner != null) {
		 return;
	 }
	 helper.setProjectComponent(this);
	 runner = helper.getScriptRunner();
 }",0,0,0,0
"public class Int32Type extends AbstractType<Integer>{
	 public static final Int32Type instance = new Int32Type();
	 Int32Type() {
	}
	 public Integer compose(ByteBuffer bytes) {
		 return JdbcInt32.instance.compose(bytes);
	 }
	 public ByteBuffer decompose(Integer value) {
		 return JdbcInt32.instance.decompose(value);
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 if (o1.remaining() == 0) {
			 return o2.remaining() == 0 ? 0 : -1;
		 }
		 if (o2.remaining() == 0) {
			 return 1;
		 }
		 int diff = o1.get(o1.position()) - o2.get(o2.position());
		 if (diff != 0) return diff;
		 return ByteBufferUtil.compareUnsigned(o1, o2);
	 }
	 public String getString(ByteBuffer bytes) {
		 try {
			 return JdbcInt32.instance.getString(bytes);
		 }
		 catch (org.apache.cassandra.cql.jdbc.MarshalException e) {
			 throw new MarshalException(e.getMessage());
		 }
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
		 int int32Type;
		 try {
			 int32Type = Integer.parseInt(source);
		 }
		 catch (Exception e) {
			 throw new MarshalException(String.format(""unable to make int from '%s'"", source), e);
		 }
		 return decompose(int32Type);
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 if (bytes.remaining() != 4 && bytes.remaining() != 0) throw new MarshalException(String.format(""Expected 4 or 0 byte int (%d)"", bytes.remaining()));
	 }
}",0,0,0,0
"public Object processNode (Node node, String prefix, Object container) {
	 Object addedPath = null;
	 String id = null;
	 if (node.hasAttributes()) {
		 NamedNodeMap nodeAttributes = node.getAttributes();
		 Node idNode = nodeAttributes.getNamedItem(ID);
		 id = (semanticAttributes && idNode != null ? idNode.getNodeValue() : null);
		 for (int i = 0;
		 i < nodeAttributes.getLength();
		 i++) {
			 Node attributeNode = nodeAttributes.item(i);
			 if (!semanticAttributes) {
				 String attributeName = getAttributeName(attributeNode);
				 String attributeValue = getAttributeValue(attributeNode);
				 addProperty(prefix + attributeName, attributeValue, null);
			 }
			 else {
				 String nodeName = attributeNode.getNodeName();
				 String attributeValue = getAttributeValue(attributeNode);
				 Path containingPath = (container != null && container instanceof Path ? (Path) container : null);
				 if (nodeName.equals(ID)) {
					 continue;
				 }
				 else if (containingPath != null && nodeName.equals(PATH)) {
					 containingPath.setPath(attributeValue);
				 }
				 else if (container instanceof Path && nodeName.equals(REF_ID)) {
					 containingPath.setPath(attributeValue);
				 }
				 else if (container instanceof Path && nodeName.equals(LOCATION)) {
					 containingPath.setLocation(resolveFile(attributeValue));
				 }
				 else if (nodeName.equals(PATHID)) {
					 if (container != null) {
						 throw new BuildException(""XmlProperty does not "" + ""support nested paths"");
					 }
					 addedPath = new Path(getProject());
					 getProject().addReference(attributeValue, addedPath);
				 }
				 else {
					 String attributeName = getAttributeName(attributeNode);
					 addProperty(prefix + attributeName, attributeValue, id);
				 }
			 }
		 }
	 }
	 String nodeText = null;
	 boolean emptyNode = false;
	 boolean semanticEmptyOverride = false;
	 if (node.getNodeType() == Node.ELEMENT_NODE && semanticAttributes && node.hasAttributes() && (node.getAttributes().getNamedItem(VALUE) != null || node.getAttributes().getNamedItem(LOCATION) != null || node.getAttributes().getNamedItem(REF_ID) != null || node.getAttributes().getNamedItem(PATH) != null || node.getAttributes().getNamedItem(PATHID) != null)) {
		 semanticEmptyOverride = true;
	 }
	 if (node.getNodeType() == Node.TEXT_NODE) {
		 nodeText = getAttributeValue(node);
	 }
	 else if ((node.getNodeType() == Node.ELEMENT_NODE) && (node.getChildNodes().getLength() == 1) && (node.getFirstChild().getNodeType() == Node.CDATA_SECTION_NODE)) {
		 nodeText = node.getFirstChild().getNodeValue();
		 if ("""".equals(nodeText) && !semanticEmptyOverride) {
			 emptyNode = true;
		 }
	 }
	 else if ((node.getNodeType() == Node.ELEMENT_NODE) && (node.getChildNodes().getLength() == 0) && !semanticEmptyOverride) {
		 nodeText = """";
		 emptyNode = true;
	 }
	 else if ((node.getNodeType() == Node.ELEMENT_NODE) && (node.getChildNodes().getLength() == 1) && (node.getFirstChild().getNodeType() == Node.TEXT_NODE) && ("""".equals(node.getFirstChild().getNodeValue())) && !semanticEmptyOverride) {
		 nodeText = """";
		 emptyNode = true;
	 }
	 if (nodeText != null) {
		 if (semanticAttributes && id == null && container instanceof String) {
			 id = (String) container;
		 }
		 if (nodeText.trim().length() != 0 || emptyNode) {
			 addProperty(prefix, nodeText, id);
		 }
	 }
	 return (addedPath != null ? addedPath : id);
 }",0,0,1,0
"public void paintComponent(Graphics g) {
	 XPStyle xp = XPStyle.getXP();
	 paintTitleBackground(g);
	 String title = frame.getTitle();
	 if (title != null) {
		 boolean isSelected = frame.isSelected();
		 Font oldFont = g.getFont();
		 Font newFont = (titleFont != null) ? titleFont : getFont();
		 g.setFont(newFont);
		 FontMetrics fm = SwingUtilities2.getFontMetrics(frame, g, newFont);
		 int baseline = (getHeight() + fm.getAscent() - fm.getLeading() - fm.getDescent()) / 2;
		 Rectangle lastIconBounds = new Rectangle(0, 0, 0, 0);
		 if (frame.isIconifiable()) {
			 lastIconBounds = iconButton.getBounds();
		 }
		 else if (frame.isMaximizable()) {
			 lastIconBounds = maxButton.getBounds();
		 }
		 else if (frame.isClosable()) {
			 lastIconBounds = closeButton.getBounds();
		 }
		 int titleX;
		 int titleW;
		 int gap = 2;
		 if (WindowsGraphicsUtils.isLeftToRight(frame)) {
			 if (lastIconBounds.x == 0) {
				 lastIconBounds.x = frame.getWidth() - frame.getInsets().right;
			 }
			 titleX = systemLabel.getX() + systemLabel.getWidth() + gap;
			 if (xp != null) {
				 titleX += 2;
			 }
			 titleW = lastIconBounds.x - titleX - gap;
		 }
		 else {
			 if (lastIconBounds.x == 0) {
				 lastIconBounds.x = frame.getInsets().left;
			 }
			 titleW = SwingUtilities2.stringWidth(frame, fm, title);
			 int minTitleX = lastIconBounds.x + lastIconBounds.width + gap;
			 if (xp != null) {
				 minTitleX += 2;
			 }
			 int availableWidth = systemLabel.getX() - gap - minTitleX;
			 if (availableWidth > titleW) {
				 titleX = systemLabel.getX() - gap - titleW;
			 }
			 else {
				 titleX = minTitleX;
				 titleW = availableWidth;
			 }
		 }
		 title = getTitle(frame.getTitle(), fm, titleW);
		 if (xp != null) {
			 String shadowType = null;
			 if (isSelected) {
				 shadowType = xp.getString(this, Part.WP_CAPTION, State.ACTIVE, Prop.TEXTSHADOWTYPE);
			 }
			 if (""single"".equalsIgnoreCase(shadowType)) {
				 Point shadowOffset = xp.getPoint(this, Part.WP_WINDOW, State.ACTIVE, Prop.TEXTSHADOWOFFSET);
				 Color shadowColor = xp.getColor(this, Part.WP_WINDOW, State.ACTIVE, Prop.TEXTSHADOWCOLOR, null);
				 if (shadowOffset != null && shadowColor != null) {
					 g.setColor(shadowColor);
					 SwingUtilities2.drawString(frame, g, title, titleX + shadowOffset.x, baseline + shadowOffset.y);
				 }
			 }
		 }
		 g.setColor(isSelected ? selectedTextColor : notSelectedTextColor);
		 SwingUtilities2.drawString(frame, g, title, titleX, baseline);
		 g.setFont(oldFont);
	 }
 }",0,0,1,0
"private JPanel createOverviewPanel() {
	JPanel panel = new JPanel();
	panel.setOpaque(false);
	panel.setLayout(null);
	int y = 0, h = 0;
	y += 10;
	y += 10;
	h = 30;
	JLabel lblMonitorHeader = new JLabel(StringResource.get(""SETTINGS_MONITORING""));
	lblMonitorHeader.setForeground(Color.WHITE);
	lblMonitorHeader.setFont(FontResource.getItemFont());
	lblMonitorHeader.setBounds(15, y, 350 - 30, h);
	panel.add(lblMonitorHeader);
	y += h;
	y += 10;
	h = 50;
	JTextArea lblMonitoringTitle = new JTextArea();
	lblMonitoringTitle.setOpaque(false);
	lblMonitoringTitle.setWrapStyleWord(true);
	lblMonitoringTitle.setLineWrap(true);
	lblMonitoringTitle.setEditable(false);
	lblMonitoringTitle.setForeground(Color.WHITE);
	lblMonitoringTitle.setText(StringResource.get(""HINT_BROWSER_MON""));
	lblMonitoringTitle.setFont(FontResource.getNormalFont());
	lblMonitoringTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblMonitoringTitle);
	y += h;
	JButton btViewMonitoring = createButton1(""SETTINGS_VIEW"", 15, y);
	btViewMonitoring.setName(""BTN_MONITORING"");
	panel.add(btViewMonitoring);
	y += btViewMonitoring.getHeight();
	y += 10;
	y += 20;
	h = 30;
	JLabel lblGenHeader = new JLabel(StringResource.get(""SETTINGS_GENERAL""));
	lblGenHeader.setForeground(Color.WHITE);
	lblGenHeader.setFont(FontResource.getItemFont());
	lblGenHeader.setBounds(15, y, 350 - 30, h);
	panel.add(lblGenHeader);
	y += h;
	y += 10;
	h = 30;
	chkPrgWnd = createCheckBox(""SHOW_DWN_PRG"");
	chkPrgWnd.setBounds(15, y, 350 - 30, h);
	panel.add(chkPrgWnd);
	y += h;
	h = 30;
	chkEndWnd = createCheckBox(""SHOW_DWN_COMPLETE"");
	chkEndWnd.setBounds(15, y, 350 - 30, h);
	panel.add(chkEndWnd);
	y += h;
	y += 10;
	h = 30;
	JLabel lblMaxTitle = new JLabel(StringResource.get(""MSG_MAX_DOWNLOAD""));
	lblMaxTitle.setForeground(Color.WHITE);
	lblMaxTitle.setFont(FontResource.getNormalFont());
	lblMaxTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblMaxTitle);
	y += 3;
	h = 25;
	cmbMax = new JComboBox<String>(new String[] {
	 ""1"", ""2"", ""5"", ""10"", ""50"", ""N/A"" }
	);
	cmbMax.setBackground(ColorResource.getDarkerBgColor());
	cmbMax.setBounds(250, y, 75, h);
	cmbMax.setRenderer(new SimpleListRenderer());
	panel.add(cmbMax);
	y += h;
	y += 10;
	y += 10;
	y += 10;
	h = 30;
	JLabel lblFolderTitle = new JLabel(StringResource.get(""SETTINGS_FOLDER""));
	lblFolderTitle.setForeground(Color.WHITE);
	lblFolderTitle.setFont(FontResource.getNormalFont());
	lblFolderTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblFolderTitle);
	y += h;
	h = 25;
	txtDefFolder = new JTextField();
	txtDefFolder.setBounds(15, y, 350 - 30 - 110, h);
	txtDefFolder.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtDefFolder.setEditable(false);
	txtDefFolder.setForeground(Color.WHITE);
	txtDefFolder.setOpaque(false);
	panel.add(txtDefFolder);
	JButton btnBrowseFolder = createButton2(""SETTINGS_FOLDER_CHANGE"");
	btnBrowseFolder.setName(""SETTINGS_FOLDER_CHANGE"");
	btnBrowseFolder.setBackground(ColorResource.getDarkBtnColor());
	btnBrowseFolder.setFont(FontResource.getNormalFont());
	btnBrowseFolder.setBounds(15 + 350 - 30 - 110 + 10, y, 90, h);
	panel.add(btnBrowseFolder);
	y += h;
	y += 10;
	y += 20;
	y += 10;
	h = 30;
	JLabel lblNetHeader = new JLabel(StringResource.get(""SETTINGS_NETWORK""));
	lblNetHeader.setForeground(Color.WHITE);
	lblNetHeader.setFont(FontResource.getItemFont());
	lblNetHeader.setBounds(15, y, 350 - 30, h);
	panel.add(lblNetHeader);
	y += h;
	h = 40;
	JTextArea lblNetworkTitle = new JTextArea();
	lblNetworkTitle.setOpaque(false);
	lblNetworkTitle.setWrapStyleWord(true);
	lblNetworkTitle.setLineWrap(true);
	lblNetworkTitle.setEditable(false);
	lblNetworkTitle.setForeground(Color.WHITE);
	lblNetworkTitle.setText(StringResource.get(""HINT_NETWORK""));
	lblNetworkTitle.setFont(FontResource.getNormalFont());
	lblNetworkTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblNetworkTitle);
	y += h;
	JButton btViewNet = createButton1(""SETTINGS_VIEW"", 15, y);
	btViewNet.setName(""BTN_NETWORK"");
	panel.add(btViewNet);
	y += btViewNet.getHeight();
	y += 10;
	y += 10;
	y += 10;
	h = 30;
	JLabel lblSchHeader = new JLabel(StringResource.get(""SETTINGS_SCHEDULER""));
	lblSchHeader.setForeground(Color.WHITE);
	lblSchHeader.setFont(FontResource.getItemFont());
	lblSchHeader.setBounds(15, y, 350 - 30, h);
	panel.add(lblSchHeader);
	y += h;
	h = 50;
	JTextArea lblScheduleTitle = new JTextArea();
	lblScheduleTitle.setOpaque(false);
	lblScheduleTitle.setWrapStyleWord(true);
	lblScheduleTitle.setLineWrap(true);
	lblScheduleTitle.setEditable(false);
	lblScheduleTitle.setForeground(Color.WHITE);
	lblScheduleTitle.setText(StringResource.get(""HINT_SCHEDULER""));
	lblScheduleTitle.setFont(FontResource.getNormalFont());
	lblScheduleTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblScheduleTitle);
	y += h;
	JButton btViewScheduler = createButton1(""SETTINGS_VIEW"", 15, y);
	btViewScheduler.setName(""Q_MAN"");
	panel.add(btViewScheduler);
	y += btViewScheduler.getHeight();
	y += 10;
	y += 10;
	y += 10;
	h = 30;
	JLabel lblPwdHeader = new JLabel(StringResource.get(""SETTINGS_CRED""));
	lblPwdHeader.setForeground(Color.WHITE);
	lblPwdHeader.setFont(FontResource.getItemFont());
	lblPwdHeader.setBounds(15, y, 350 - 30, h);
	panel.add(lblPwdHeader);
	y += h;
	h = 40;
	JTextArea lblCredTitle = new JTextArea();
	lblCredTitle.setOpaque(false);
	lblCredTitle.setWrapStyleWord(true);
	lblCredTitle.setLineWrap(true);
	lblCredTitle.setEditable(false);
	lblCredTitle.setForeground(Color.WHITE);
	lblCredTitle.setText(StringResource.get(""HINT_PASSWORD""));
	lblCredTitle.setFont(FontResource.getNormalFont());
	lblCredTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblCredTitle);
	y += h;
	JButton btViewCred = createButton1(""SETTINGS_VIEW"", 15, y);
	btViewCred.setName(""PASS_MAN"");
	panel.add(btViewCred);
	y += btViewCred.getHeight();
	y += 10;
	y += 10;
	y += 10;
	h = 30;
	JLabel lblAdvHeader = new JLabel(StringResource.get(""SETTINGS_ADV""));
	lblAdvHeader.setForeground(Color.WHITE);
	lblAdvHeader.setFont(FontResource.getItemFont());
	lblAdvHeader.setBounds(15, y, 350 - 30, h);
	panel.add(lblAdvHeader);
	y += h;
	h = 50;
	JTextArea lblAdvTitle = new JTextArea();
	lblAdvTitle.setOpaque(false);
	lblAdvTitle.setWrapStyleWord(true);
	lblAdvTitle.setLineWrap(true);
	lblAdvTitle.setEditable(false);
	lblAdvTitle.setForeground(Color.WHITE);
	lblAdvTitle.setText(StringResource.get(""HINT_ADV""));
	lblAdvTitle.setFont(FontResource.getNormalFont());
	lblAdvTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblAdvTitle);
	y += h;
	JButton btViewAdv = createButton1(""SETTINGS_VIEW"", 15, y);
	btViewAdv.setName(""ADV_MAN"");
	panel.add(btViewAdv);
	y += btViewAdv.getHeight();
	y += 10;
	h = 30;
	panel.setPreferredSize(new Dimension(300, y + 50));
	return panel;
}",0,0,1,0
"public void execute() throws BuildException {
	 File savedDir = dir;
	 String savedAntFile = antFile;
	 Vector locals = new VectorSet(targets);
	 try {
		 getNewProject();
		 if (dir == null && inheritAll) {
			 dir = getProject().getBaseDir();
		 }
		 initializeProject();
		 if (dir != null) {
			 if (!useNativeBasedir) {
				 newProject.setBaseDir(dir);
				 if (savedDir != null) {
					 newProject.setInheritedProperty(MagicNames.PROJECT_BASEDIR, dir.getAbsolutePath());
				 }
			 }
		 }
		 else {
			 dir = getProject().getBaseDir();
		 }
		 overrideProperties();
		 if (antFile == null) {
			 antFile = getDefaultBuildFile();
		 }
		 File file = FILE_UTILS.resolveFile(dir, antFile);
		 antFile = file.getAbsolutePath();
		 log(""calling target(s) "" + ((locals.size() > 0) ? locals.toString() : ""[default]"") + "" in build file "" + antFile, Project.MSG_VERBOSE);
		 newProject.setUserProperty(MagicNames.ANT_FILE , antFile);
		 String thisAntFile = getProject().getProperty(MagicNames.ANT_FILE);
		 if (thisAntFile != null && file.equals(getProject().resolveFile(thisAntFile)) && getOwningTarget() != null) {
			 if (getOwningTarget().getName().equals("""")) {
				 if (getTaskName().equals(""antcall"")) {
					 throw new BuildException(""antcall must not be used at"" + "" the top level."");
				 }
				 throw new BuildException(getTaskName() + "" task at the"" + "" top level must not invoke"" + "" its own build file."");
			 }
		 }
		 try {
			 ProjectHelper.configureProject(newProject, file);
		 }
		 catch (BuildException ex) {
			 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
		 }
		 if (locals.size() == 0) {
			 String defaultTarget = newProject.getDefaultTarget();
			 if (defaultTarget != null) {
				 locals.add(defaultTarget);
			 }
		 }
		 if (newProject.getProperty(MagicNames.ANT_FILE) .equals(getProject().getProperty(MagicNames.ANT_FILE)) && getOwningTarget() != null) {
			 String owningTargetName = getOwningTarget().getName();
			 if (locals.contains(owningTargetName)) {
				 throw new BuildException(getTaskName() + "" task calling "" + ""its own parent target."");
			 }
			 boolean circular = false;
			 for (Iterator it = locals.iterator();
			 !circular && it.hasNext();
			) {
				 Target other = (Target) (getProject().getTargets().get(it.next()));
				 circular |= (other != null && other.dependsOn(owningTargetName));
			 }
			 if (circular) {
				 throw new BuildException(getTaskName() + "" task calling a target"" + "" that depends on"" + "" its parent target \'"" + owningTargetName + ""\'."");
			 }
		 }
		 addReferences();
		 if (locals.size() > 0 && !(locals.size() == 1 && """".equals(locals.get(0)))) {
			 BuildException be = null;
			 try {
				 log(""Entering "" + antFile + ""..."", Project.MSG_VERBOSE);
				 newProject.fireSubBuildStarted();
				 newProject.executeTargets(locals);
			 }
			 catch (BuildException ex) {
				 be = ProjectHelper .addLocationToBuildException(ex, getLocation());
				 throw be;
			 }
			 finally {
				 log(""Exiting "" + antFile + ""."", Project.MSG_VERBOSE);
				 newProject.fireSubBuildFinished(be);
			 }
		 }
	 }
	 finally {
		 newProject = null;
		 Enumeration e = properties.elements();
		 while (e.hasMoreElements()) {
			 Property p = (Property) e.nextElement();
			 p.setProject(null);
		 }
		 if (output != null && out != null) {
			 try {
				 out.close();
			 }
			 catch (final Exception ex) {
			 }
		 }
		 dir = savedDir;
		 antFile = savedAntFile;
	 }
 }",0,0,1,0
"public class NullResponse extends Response{
	private static final NullResponse instance = new NullResponse();
	private NullResponse(){
	}
	public static final NullResponse getInstance(){
		return instance;
	}
	public void write(CharSequence string){
	}
	public OutputStream getOutputStream(){
		return new OutputStream(){
			public void write(int b) throws IOException{
			}
		}
		;
	}
}",0,0,0,0
"protected void loadVtimezone() {
	 try {
		 String folderPath = getFolderPath(""davmailtemp"");
		 createCalendarFolder(folderPath, null);
		 String fakeEventUrl = null;
		 if (""Exchange2003"".equals(serverVersion)) {
			 PostMethod postMethod = new PostMethod(URIUtil.encodePath(folderPath));
			 postMethod.addParameter(""Cmd"", ""saveappt"");
			 postMethod.addParameter(""FORMTYPE"", ""appointment"");
			 try {
				 int statusCode = httpClient.executeMethod(postMethod);
				 if (statusCode == HttpStatus.SC_OK) {
					 fakeEventUrl = StringUtil.getToken(postMethod.getResponseBodyAsString(), ""<span id=\""itemHREF\"">"", ""</span>"");
					 if (fakeEventUrl != null) {
						 fakeEventUrl = URIUtil.decode(fakeEventUrl);
					 }
				 }
			 }
			 finally {
				 postMethod.releaseConnection();
			 }
		 }
		 if (fakeEventUrl == null) {
			 ArrayList<PropEntry> propertyList = new ArrayList<PropEntry>();
			 propertyList.add(Field.createDavProperty(""contentclass"", ""urn:content-classes:appointment""));
			 propertyList.add(Field.createDavProperty(""outlookmessageclass"", ""IPM.Appointment""));
			 propertyList.add(Field.createDavProperty(""instancetype"", ""0""));
			 String timezoneId = Settings.getProperty(""davmail.timezoneId"");
			 if (timezoneId == null) {
				 timezoneId = getTimezoneIdFromExchange();
			 }
			 if (timezoneId != null) {
				 propertyList.add(Field.createDavProperty(""timezoneid"", timezoneId));
			 }
			 String patchMethodUrl = folderPath + '/' + UUID.randomUUID().toString() + "".EML"";
			 PropPatchMethod patchMethod = new PropPatchMethod(URIUtil.encodePath(patchMethodUrl), propertyList);
			 try {
				 int statusCode = httpClient.executeMethod(patchMethod);
				 if (statusCode == HttpStatus.SC_MULTI_STATUS) {
					 fakeEventUrl = patchMethodUrl;
				 }
			 }
			 finally {
				 patchMethod.releaseConnection();
			 }
		 }
		 if (fakeEventUrl != null) {
			 GetMethod getMethod = new GetMethod(URIUtil.encodePath(fakeEventUrl));
			 getMethod.setRequestHeader(""Translate"", ""f"");
			 try {
				 httpClient.executeMethod(getMethod);
				 this.vTimezone = new VObject(""BEGIN:VTIMEZONE"" + StringUtil.getToken(getMethod.getResponseBodyAsString(), ""BEGIN:VTIMEZONE"", ""END:VTIMEZONE"") + ""END:VTIMEZONE\r\n"");
			 }
			 finally {
				 getMethod.releaseConnection();
			 }
		 }
		 deleteFolder(""davmailtemp"");
	 }
	 catch (IOException e) {
		 LOGGER.warn(""Unable to get VTIMEZONE info: "" + e, e);
	 }
 }",0,0,1,0
"public String validateSkelet() {
	 boolean atLeastOneCompositePK = false;
	 boolean valid = true;
	 boolean autoGeneratedStringInvalidHibernate = false;
	 boolean isRelatedEntityComposite = false;
	 String message = """";
	 String businessTier = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_BUSINESS_TIER);
	 String webTier = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_WEB_TIER);
	 String appServer = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_APPLICATION_SERVER);
	 String useJava5 = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_JAVA5);
	 try {
		 if (root.app.nameText.getText() == null || """".equals(root.app.nameText.getText())) {
			 valid = false;
			 message += ""No valid application name has been set in the 'Application settings'.\r\n"";
		 }
		 else if (!root.app.nameText.getText().toLowerCase().equals(root.app.nameText.getText())) {
			 valid = false;
			 message += ""No valid application name in the 'Application settings'. Should be only lowercase!.\r\n"";
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""No valid application name has been set in the 'Application settings'.\r\n"";
	 }
	 try {
		 if (root.app.descriptionText.getText() == null || """".equals(root.app.descriptionText.getText())) {
			 valid = false;
			 message += ""No valid application description has been set in the 'Application settings'.\r\n"";
		 }
		 else {
			 String firstChar = root.app.descriptionText.getText().substring(0, 1);
			 if (!firstChar.toUpperCase().equals(firstChar)) {
				 valid = false;
				 message += ""No valid application description has been set in the 'Application settings'. First character should be uppercase!\r\n"";
			 }
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""No valid application description has been set in the 'Application settings'.\r\n"";
	 }
	 try {
		 if (root.app.rootPackageText.getText() == null || """".equals(root.app.rootPackageText.getText())) {
			 valid = false;
			 message += ""No valid root package set in the 'Application settings'.\r\n"";
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""No valid root package set in the 'Application settings'.\r\n"";
	 }
	 try {
		 if (root.datasource.jdbcURLCombo.getSelectedItem() == null || """".equals(root.datasource.jdbcURLCombo.getSelectedItem())) {
			 valid = false;
			 message += ""No valid datasource URL set in the Datasource form.\r\n"";
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""No valid datasource URL set in the Datasource form.\r\n"";
	 }
	 try {
		 if (root.datasource.jndiText.getText() == null || """".equals(root.datasource.jndiText.getText()) || ""jdbc/"".equals(root.datasource.jndiText.getText())) {
			 valid = false;
			 message += ""No valid datasource jndi-name set in the Datasource form.\r\n"";
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""No valid datasource jndi-name set in the Datasource form.\r\n"";
	 }
	 HashMap entityRefs = new HashMap();
	 ArrayList el = root.getEntityEjbs();
	 for (int i = 0;
	 i < el.size();
	 i++) {
		 Entity e = (Entity) el.get(i);
		 entityRefs.put(e.getRefName(), null);
	 }
	 for (int i = 0;
	 i < el.size();
	 i++) {
		 Entity entity = (Entity) el.get(i);
		 if (""true"".equals(entity.getIsAssociationEntity())) {
			 if (entity.getRelations() != null && entity.getRelations().size() == 2 && entity.getFields().size() == 2) {
				 if (((Relation) entity.getRelations().get(0)).isTargetMultiple() && ((Relation) entity.getRelations().get(1)).isTargetMultiple() ) {
				 }
				 else {
					 valid = false;
					 message += ""Entity "" + entity.getName() + "" is not a valid assocation Entity.\r\nThere should be exactly 2 many-to-one relations in the assocation entity.\r\n"";
				 }
			 }
			 else {
				 valid = false;
				 message += ""Entity "" + entity.getName() + "" is not a valid assocation Entity.\r\nThere should be exactly 2 many-to-one relations in the assocation entity.\r\n"";
			 }
		 }
	 }
	 try {
		 ArrayList sl = root.getSessionEjbs();
		 for (int i = 0;
		 i < sl.size();
		 i++) {
			 Session s = (Session) sl.get(i);
			 ArrayList allRefs = s.getEntityRefs();
			 for (int j = 0;
			 j < allRefs.size();
			 j++) {
				 if (!entityRefs.containsKey(allRefs.get(j))) {
					 valid = false;
					 message += ""The reference "" + allRefs.get(j) + "" in Service Bean "" + s.getRefName() + "" doesn't exist .\r\n"";
				 }
			 }
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""Error in Service Bean.\r\n"";
	 }
	 try {
		 ArrayList nl = root.getEntityEjbs();
		 for (int i = 0;
		 i < nl.size();
		 i++) {
			 Entity e = (Entity) nl.get(i);
			 List relations = e.getRelations();
			 for (int r = 0;
			 r < relations.size();
			 r++) {
				 Relation relation = (Relation) relations.get(r);
				 if (relation.getRelatedEntity().isCompositeKey()) {
					 isRelatedEntityComposite = true;
				 }
			 }
			 String displayName = """";
			 boolean validDisplayName = false;
			 if (e.getDisplayName() == null || """".equals(e.getDisplayName().toString())) {
				 validDisplayName = true;
			 }
			 else {
				 displayName = e.getDisplayName().toString();
			 }
			 List fields = e.getFields();
			 for (int j = 0;
			 j < fields.size();
			 j++) {
				 Field field = (Field) fields.get(j);
				 if (displayName.equals(field.getName().toString())) {
					 validDisplayName = true;
				 }
				 if (field.autoGeneratedCheckBox.isSelected() && field.foreignKeyCheckBox.isSelected() && ""false"".equals(e.getIsAssociationEntity()) ) {
					 logger.log(""Field: "" + field.getName() + "" of entity : "" + e.getName() + "" cannot have autogenerated primary key selected and be a foreign key!"");
					 valid = false;
					 message += ""Field: "" + field.getName() + "" of entity : "" + e.getName() + "" cannot have autogenerated primary key selected and be a foreign key!.\r\n"";
				 }
				 if (field.autoGeneratedCheckBox.isSelected()) {
					 if (""java.lang.String"".equalsIgnoreCase(field.getType())) {
						 String fieldSize = field.getSize();
						 try {
							 int size = Integer.parseInt(fieldSize);
							 if (size < 32) {
								 autoGeneratedStringInvalidHibernate = true;
							 }
						 }
						 catch (Exception ex) {
						 }
					 }
				 }
			 }
			 if (!validDisplayName) {
				 logger.log(""No valid display name set: "" + displayName);
				 valid = false;
				 message += ""Display name "" + displayName + "" of entity : "" + e.getName() + "" should be a field of this entity."";
			 }
			 if (e.isCompositeCombo.getSelectedItem().equals(""true"") && e.isAssociationEntity.getSelectedItem().equals(""false"")) {
				 atLeastOneCompositePK = true;
				 if (e.pKeyTypeText.getText() == null || e.pKeyTypeText.getText().equals("""")) {
					 logger.log(""Primary key type is empty, but should be set since composite primary key has been set to true for Entity EJB: "" + e.getRefName());
					 valid = false;
					 message += ""Primary key type is empty, but should be set since composite primary key has been set to true for Entity EJB: "" + e.getRefName() + "".\r\n"";
				 }
				 if (e.pKeyText.getText() != null && !e.pKeyText.getText().equals("""")) {
					 logger.log(""Primary key should be empty since the since composite primary key has been set to true for Entity EJB: "" + e.getRefName());
					 valid = false;
					 message += ""Primary key should be empty, since composite primary key has been set to true for Entity EJB: "" + e.getRefName() + "".\r\n"";
				 }
				 if (e.countPrimaryKeyFields() <= 1) {
					 logger.log(""In the field specifications for Entity EJB: "" + e.getRefName() + "" there should be more than one field that has been marked as primary key. Now only "" + e.countPrimaryKeyFields() + "" have been marked as primary key!"");
					 valid = false;
					 message += ""In the field specifications for Entity EJB: "" + e.getRefName() + "" there should be more than one field that has been marked as primary key. Now only "" + e.countPrimaryKeyFields() + "" have been marked as primary key!.\r\n"";
				 }
			 }
			 else if ((e.isCompositeCombo.getSelectedItem()).equals(""false"")) {
				 if (e.pKeyTypeText.getText() == null || e.pKeyTypeText.getText().equals("""")) {
					 logger.log(""No primary key set for entity bean: "" + e.getRefName());
					 valid = false;
					 message += ""No primary key set for entity bean: "" + e.getRefName() + "".\r\n"";
				 }
				 if (e.countPrimaryKeyFields() > 1) {
					 if (e.countPrimaryKeyFields() > 1) {
						 logger.log(""More than 1 primary key declared, while composite primary key is set to false for entity bean '"" + e.getRefName() + ""' ."");
						 valid = false;
						 message += ""More than 1 primary key declared, while composite primary key is set to false for entity bean '"" + e.getRefName() + ""' .\r\n"";
					 }
				 }
				 if (e.countPrimaryKeyFields() == 1) {
					 String name = e.getFirstPrimaryKeyFieldName();
					 String type = e.getPrimaryKeyClass();
					 if ((name == null) || e.pKeyText.getText() == null || !name.equals(e.pKeyText.getText())) {
						 logger.log(""Non-matching primary keys! In entity bean '"" + e.getRefName() + ""' the field '"" + name + ""' has been marked as primary key, yet that entity has primary key '"" + e.pKeyText.getText() + ""'."");
						 valid = false;
						 message += ""Non-matching primary keys! In entity bean '"" + e.getRefName() + ""' the field '"" + name + ""' has been marked as primary key, yet that entity has primary key '"" + e.pKeyText.getText() + ""'.\r\n"";
					 }
					 if ((type == null) || e.pKeyTypeText.getText() == null || !type.equals(e.pKeyTypeText.getText())) {
						 logger.log(""Non-matching primary key types! In entity bean '"" + e.getRefName() + ""' the field '"" + name + ""' has been marked as primary key and has type '"" + type + ""', yet the entity has primary key type '"" + e.pKeyTypeText.getText() + ""'."");
						 valid = false;
						 message += ""Non-matching primary key types! In entity bean '"" + e.getRefName() + ""' the field '"" + name + ""' has been marked as primary key and has type '"" + type + ""', yet the entity has primary key type '"" + e.pKeyTypeText.getText() + ""'.\r\n"";
					 }
				 }
			 }
		 }
	 }
	 catch (Exception e) {
		 valid = false;
		 message += ""Error in Entity Bean.\r\n"";
	 }
	 String badEntity = getEntityWithDuplicateRelationNames();
	 if (badEntity != null) {
		 valid = false;
		 message += ""Entity bean "" + badEntity + "" has more than one relation with the same 'relation name'.\n"" + ""This is not allowed! Please rename at least one of the relation names.\r\n"";
	 }
	 List unreferencedEntities = getEntityWithUnreferencedRelations();
	 if (!unreferencedEntities.isEmpty()) {
		 valid = false;
		 StringBuffer tmp = new StringBuffer();
		 Iterator i = unreferencedEntities.iterator();
		 while (i.hasNext()) {
			 String[] details = (String[]) i.next();
			 if (!"""".equals(details[2])) {
				 tmp.append(""Entity bean '"" + details[0] + ""' contains a relation '"" + details[1] + ""' that references a table '"" + details[2] + ""',\n"" + ""which doesn't correspond to any entity bean. Please either:\n"" + ""\ta) delete the relation,\n"" + ""\tb) create an entity bean for the table '"" + details[2] + ""', or\n"" + ""\tc) in the relation, correct the 'foreign table' value.\r\n"");
			 }
		 }
		 message += tmp.toString();
	 }
	 String relationErrorMessage = getRelationWithInvalidData();
	 if (relationErrorMessage != null) {
		 valid = false;
		 message += relationErrorMessage;
	 }
	 if (isRelatedEntityComposite) {
		 String msg = ""At least one target entity of a relation has a composite primary key. JAG doesn't support this.\r\n"";
		 logger.log(msg);
		 valid = false;
		 message += msg;
	 }
	 String templateValue = (String) root.config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_RELATIONS);
	 if (""false"".equalsIgnoreCase(templateValue)) {
		 if (isRelationPresentInModel()) {
			 valid = false;
			 message += ""The Container-managed relations checkbox in the Configuration screen was unchecked,\r\n"" + ""but there are still relations defined in the project.\r\n"" + ""Either enable Container-managed relations or remove the relations from the project.\r\n"";
		 }
	 }
	 if (atLeastOneCompositePK) {
		 if (JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE2.equalsIgnoreCase(businessTier) || (JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE3.equalsIgnoreCase(businessTier) && ""false"".equals(useJava5) ) ) {
			 logger.log(""JAG does not support composite primary keys for Hibernate."");
			 valid = false;
			 message += ""JAG does not support composite primary keys for Hibernate.\r\n"";
		 }
	 }
	 if (autoGeneratedStringInvalidHibernate) {
		 if (JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE2.equalsIgnoreCase(businessTier) || JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE3.equalsIgnoreCase(businessTier) ) {
			 String msg = ""At least one autogenerated primary key field of type string has size < 32. Hibernate cannot autogenerate this primary key.\r\n"";
			 logger.log(msg);
			 valid = false;
			 message += msg;
		 }
	 }
	 if (JagGenerator.TEMPLATE_APPLICATION_SERVER_TOMCAT_5.equalsIgnoreCase(appServer)) {
		 if (!JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE2.equalsIgnoreCase(businessTier) && !JagGenerator.TEMPLATE_BUSINESS_TIER_HIBERNATE3.equalsIgnoreCase(businessTier) ) {
			 String msg = ""Only hibernate can be selected for the Tomcat application server.\r\n"";
			 logger.log(msg);
			 valid = false;
			 message += msg;
		 }
	 }
	 if (!JagGenerator.TEMPLATE_APPLICATION_SERVER_JBOSS_4_X.equalsIgnoreCase(appServer)) {
		 if (JagGenerator.TEMPLATE_BUSINESS_TIER_EJB3.equalsIgnoreCase(businessTier)) {
			 logger.log(""EJB3 is only supported for the JBoss 4.x application server."");
			 valid = false;
			 message += ""EJB3 is only supported for the JBoss 4.x application server.\r\n"";
		 }
	 }
	 if (!valid) {
		 return message;
	 }
	 else {
		 return null;
	 }
 }",0,0,1,0
"class XComparator implements Comparator {
	public int compare(Object arg0, Object arg1) {
		InternalNode n1 = (InternalNode) arg0;
		InternalNode n2 = (InternalNode) arg1;
		if (n1.getInternalX() > n2.getInternalX())return +1;
		else if (n1.getInternalX() < n2.getInternalX())return -1;
		else {
			return n1.toString().compareTo(n2.toString());
		}
	}
}",0,0,0,0
"public class JobTracker implements MRConstants, InterTrackerProtocol, JobSubmissionProtocol {
	 static long JOBINIT_SLEEP_INTERVAL = 2000;
	 static long RETIRE_JOB_INTERVAL;
	 static long RETIRE_JOB_CHECK_INTERVAL;
	 static float TASK_ALLOC_EPSILON;
	 static float PAD_FRACTION;
	 static final int MIN_CLUSTER_SIZE_FOR_PADDING = 3;
	 private static NumberFormat idFormat = NumberFormat.getInstance();
	 static {
		 idFormat.setMinimumIntegerDigits(4);
		 idFormat.setGroupingUsed(false);
	 }
	 private int nextJobId = 1;
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.mapred.JobTracker"");
	 private static JobTracker tracker = null;
	 private static boolean runTracker = true;
	 public static void startTracker(Configuration conf) throws IOException {
		 if (tracker != null) throw new IOException(""JobTracker already running."");
		 runTracker = true;
		 while (runTracker) {
			 try {
				 tracker = new JobTracker(conf);
				 break;
			 }
			 catch (IOException e) {
				 LOG.warn(""Starting tracker"", e);
			 }
			 try {
				 Thread.sleep(1000);
			 }
			 catch (InterruptedException e) {
			 }
		 }
		 if (runTracker) {
			 tracker.offerService();
		 }
	 }
	 public static JobTracker getTracker() {
		 return tracker;
	 }
	 public static void stopTracker() throws IOException {
		 if (tracker == null) throw new IOException(""Trying to stop JobTracker that is not running."");
		 runTracker = false;
		 tracker.close();
		 tracker = null;
	 }
	 public long getProtocolVersion(String protocol, long clientVersion) {
		 if (protocol.equals(InterTrackerProtocol.class.getName())) {
			 return InterTrackerProtocol.versionID;
		 }
		 else {
			 return JobSubmissionProtocol.versionID;
		 }
	 }
	 private class ExpireLaunchingTasks implements Runnable {
		 private volatile boolean shouldRun = true;
		 private Map launchingTasks = new LinkedHashMap();
		 public void run() {
			 try {
				 while (shouldRun) {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL/3);
					 long now = System.currentTimeMillis();
					 LOG.debug(""Starting launching task sweep"");
					 synchronized (JobTracker.this) {
						 synchronized (launchingTasks) {
							 Iterator itr = launchingTasks.entrySet().iterator();
							 while (itr.hasNext()) {
								 Map.Entry pair = (Map.Entry) itr.next();
								 String taskId = (String) pair.getKey();
								 long age = now - ((Long) pair.getValue()).longValue();
								 LOG.info(taskId + "" is "" + age + "" ms debug."");
								 if (age > TASKTRACKER_EXPIRY_INTERVAL) {
									 LOG.info(""Launching task "" + taskId + "" timed out."");
									 TaskInProgress tip = null;
									 tip = (TaskInProgress) taskidToTIPMap.get(taskId);
									 if (tip != null) {
										 JobInProgress job = tip.getJob();
										 String trackerName = getAssignedTracker(taskId);
										 TaskTrackerStatus trackerStatus = getTaskTracker(trackerName);
										 job.failedTask(tip, taskId, ""Error launching task"", tip.isMapTask()?Phase.MAP:Phase.STARTING, trackerStatus.getHost(), trackerName, myMetrics);
									 }
									 itr.remove();
								 }
								 else {
									 break;
								 }
							 }
						 }
					 }
				 }
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 public void addNewTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.put(taskName, new Long(System.currentTimeMillis()));
			 }
		 }
		 public void removeTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.remove(taskName);
			 }
		 }
		 public void stop() {
			 shouldRun = false;
		 }
	 }
	 class ExpireTrackers implements Runnable {
		 boolean shouldRun = true;
		 public ExpireTrackers() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL / 3);
				 }
				 catch (InterruptedException ie) {
				 }
				 synchronized (taskTrackers) {
					 synchronized (trackerExpiryQueue) {
						 long now = System.currentTimeMillis();
						 TaskTrackerStatus leastRecent = null;
						 while ((trackerExpiryQueue.size() > 0) && ((leastRecent = (TaskTrackerStatus) trackerExpiryQueue.first()) != null) && (now - leastRecent.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL)) {
							 trackerExpiryQueue.remove(leastRecent);
							 String trackerName = leastRecent.getTrackerName();
							 TaskTrackerStatus newProfile = (TaskTrackerStatus) taskTrackers.get(leastRecent.getTrackerName());
							 if (newProfile != null) {
								 if (now - newProfile.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL) {
									 updateTaskTrackerStatus(trackerName, null);
									 lostTaskTracker(leastRecent.getTrackerName(), leastRecent.getHost());
								 }
								 else {
									 trackerExpiryQueue.add(newProfile);
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 public void stopTracker() {
			 shouldRun = false;
		 }
	 }
	 class RetireJobs implements Runnable {
		 boolean shouldRun = true;
		 public RetireJobs() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(RETIRE_JOB_CHECK_INTERVAL);
				 }
				 catch (InterruptedException ie) {
				 }
				 synchronized (jobs) {
					 synchronized (jobsByArrival) {
						 synchronized (jobInitQueue) {
							 for (Iterator it = jobs.keySet().iterator();
							 it.hasNext();
							 ) {
								 String jobid = (String) it.next();
								 JobInProgress job = (JobInProgress) jobs.get(jobid);
								 if (job.getStatus().getRunState() != JobStatus.RUNNING && job.getStatus().getRunState() != JobStatus.PREP && (job.getFinishTime() + RETIRE_JOB_INTERVAL < System.currentTimeMillis())) {
									 it.remove();
									 jobInitQueue.remove(job);
									 jobsByArrival.remove(job);
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 public void stopRetirer() {
			 shouldRun = false;
		 }
	 }
	 class JobInitThread implements Runnable {
		 boolean shouldRun = true;
		 public JobInitThread() {
		 }
		 public void run() {
			 while (shouldRun) {
				 JobInProgress job = null;
				 synchronized (jobInitQueue) {
					 if (jobInitQueue.size() > 0) {
						 job = (JobInProgress) jobInitQueue.elementAt(0);
						 jobInitQueue.remove(job);
					 }
					 else {
						 try {
							 jobInitQueue.wait(JOBINIT_SLEEP_INTERVAL);
						 }
						 catch (InterruptedException iex) {
						 }
					 }
				 }
				 try {
					 if (job != null) {
						 job.initTasks();
					 }
				 }
				 catch (Exception e) {
					 LOG.warn(""job init failed"", e);
					 job.kill();
				 }
			 }
		 }
		 public void stopIniter() {
			 shouldRun = false;
		 }
	 }
	 static class JobTrackerMetrics {
		 private MetricsRecord metricsRecord = null;
		 private long numMapTasksLaunched = 0L;
		 private long numMapTasksCompleted = 0L;
		 private long numReduceTasksLaunched = 0L;
		 private long numReduceTasksCompleted = 0L;
		 private long numJobsSubmitted = 0L;
		 private long numJobsCompleted = 0L;
		 JobTrackerMetrics() {
			 metricsRecord = Metrics.createRecord(""mapred"", ""jobtracker"");
		 }
		 synchronized void launchMap() {
			 Metrics.report(metricsRecord, ""maps-launched"", ++numMapTasksLaunched);
		 }
		 synchronized void completeMap() {
			 Metrics.report(metricsRecord, ""maps-completed"", ++numMapTasksCompleted);
		 }
		 synchronized void launchReduce() {
			 Metrics.report(metricsRecord, ""reduces-launched"", ++numReduceTasksLaunched);
		 }
		 synchronized void completeReduce() {
			 Metrics.report(metricsRecord, ""reduces-completed"", ++numReduceTasksCompleted);
		 }
		 synchronized void submitJob() {
			 Metrics.report(metricsRecord, ""jobs-submitted"", ++numJobsSubmitted);
		 }
		 synchronized void completeJob() {
			 Metrics.report(metricsRecord, ""jobs-completed"", ++numJobsCompleted);
		 }
	 }
	 private JobTrackerMetrics myMetrics = null;
	 int port;
	 String localMachine;
	 long startTime;
	 int totalSubmissions = 0;
	 Random r = new Random();
	 private int maxCurrentTasks;
	 TreeMap jobs = new TreeMap();
	 Vector jobsByArrival = new Vector();
	 Map<String, TaskInProgress> taskidToTIPMap = new TreeMap();
	 TreeMap taskidToTrackerMap = new TreeMap();
	 TreeMap trackerToTaskMap = new TreeMap();
	 int totalMaps = 0;
	 int totalReduces = 0;
	 private TreeMap taskTrackers = new TreeMap();
	 Vector jobInitQueue = new Vector();
	 ExpireTrackers expireTrackers = new ExpireTrackers();
	 Thread expireTrackersThread = null;
	 RetireJobs retireJobs = new RetireJobs();
	 Thread retireJobsThread = null;
	 JobInitThread initJobs = new JobInitThread();
	 Thread initJobsThread = null;
	 ExpireLaunchingTasks expireLaunchingTasks = new ExpireLaunchingTasks();
	 Thread expireLaunchingTaskThread = new Thread(expireLaunchingTasks);
	 TreeSet trackerExpiryQueue = new TreeSet(new Comparator() {
		 public int compare(Object o1, Object o2) {
			 TaskTrackerStatus p1 = (TaskTrackerStatus) o1;
			 TaskTrackerStatus p2 = (TaskTrackerStatus) o2;
			 if (p1.getLastSeen() < p2.getLastSeen()) {
				 return -1;
			 }
			 else if (p1.getLastSeen() > p2.getLastSeen()) {
				 return 1;
			 }
			 else {
				 return (p1.getTrackerName().compareTo(p2.getTrackerName()));
			 }
		 }
	 }
	);
	 StatusHttpServer infoServer;
	 String infoBindAddress;
	 int infoPort;
	 Server interTrackerServer;
	 static final String SUBDIR = ""jobTracker"";
	 FileSystem fs;
	 Path systemDir;
	 private Configuration conf;
	 JobTracker(Configuration conf) throws IOException {
		 maxCurrentTasks = conf.getInt(""mapred.tasktracker.tasks.maximum"", 2);
		 RETIRE_JOB_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.interval"", 24 * 60 * 60 * 1000);
		 RETIRE_JOB_CHECK_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.check"", 60 * 1000);
		 TASK_ALLOC_EPSILON = conf.getFloat(""mapred.jobtracker.taskalloc.loadbalance.epsilon"", 0.2f);
		 PAD_FRACTION = conf.getFloat(""mapred.jobtracker.taskalloc.capacitypad"", 0.01f);
		 this.conf = conf;
		 JobConf jobConf = new JobConf(conf);
		 this.systemDir = jobConf.getSystemDir();
		 this.fs = FileSystem.get(conf);
		 fs.delete(systemDir);
		 fs.mkdirs(systemDir);
		 jobConf.deleteLocalFiles(SUBDIR);
		 InetSocketAddress addr = getAddress(conf);
		 this.localMachine = addr.getHostName();
		 this.port = addr.getPort();
		 this.interTrackerServer = RPC.getServer(this,addr.getHostName(), addr.getPort(), 10, false, conf);
		 this.interTrackerServer.start();
		 Properties p = System.getProperties();
		 for (Iterator it = p.keySet().iterator();
		 it.hasNext();
		 ) {
			 String key = (String) it.next();
			 String val = (String) p.getProperty(key);
			 LOG.info(""Property '"" + key + ""' is "" + val);
		 }
		 this.infoPort = conf.getInt(""mapred.job.tracker.info.port"", 50030);
		 this.infoBindAddress = conf.get(""mapred.job.tracker.info.bindAddress"",""0.0.0.0"");
		 this.infoServer = new StatusHttpServer(""job"", infoBindAddress, infoPort, false);
		 this.infoServer.start();
		 this.startTime = System.currentTimeMillis();
		 myMetrics = new JobTrackerMetrics();
		 this.expireTrackersThread = new Thread(this.expireTrackers);
		 this.expireTrackersThread.start();
		 this.retireJobsThread = new Thread(this.retireJobs);
		 this.retireJobsThread.start();
		 this.initJobsThread = new Thread(this.initJobs);
		 this.initJobsThread.start();
		 expireLaunchingTaskThread.start();
	 }
	 public static InetSocketAddress getAddress(Configuration conf) {
		 String jobTrackerStr = conf.get(""mapred.job.tracker"", ""localhost:8012"");
		 int colon = jobTrackerStr.indexOf("":"");
		 if (colon < 0) {
			 throw new RuntimeException(""Bad mapred.job.tracker: ""+jobTrackerStr);
		 }
		 String jobTrackerName = jobTrackerStr.substring(0, colon);
		 int jobTrackerPort = Integer.parseInt(jobTrackerStr.substring(colon+1));
		 return new InetSocketAddress(jobTrackerName, jobTrackerPort);
	 }
	 public void offerService() {
		 try {
			 this.interTrackerServer.join();
		 }
		 catch (InterruptedException ie) {
		 }
		 LOG.info(""Stopped interTrackerServer"");
	 }
	 void close() throws IOException {
		 if (this.infoServer != null) {
			 LOG.info(""Stopping infoServer"");
			 try {
				 this.infoServer.stop();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.interTrackerServer != null) {
			 LOG.info(""Stopping interTrackerServer"");
			 this.interTrackerServer.stop();
		 }
		 if (this.expireTrackers != null) {
			 LOG.info(""Stopping expireTrackers"");
			 this.expireTrackers.stopTracker();
			 try {
				 this.expireTrackersThread.interrupt();
				 this.expireTrackersThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.retireJobs != null) {
			 LOG.info(""Stopping retirer"");
			 this.retireJobs.stopRetirer();
			 try {
				 this.retireJobsThread.interrupt();
				 this.retireJobsThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.initJobs != null) {
			 LOG.info(""Stopping initer"");
			 this.initJobs.stopIniter();
			 try {
				 this.initJobsThread.interrupt();
				 this.initJobsThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.expireLaunchingTaskThread != null) {
			 LOG.info(""Stopping expireLaunchingTasks"");
			 this.expireLaunchingTasks.stop();
			 try {
				 this.expireLaunchingTaskThread.interrupt();
				 this.expireLaunchingTaskThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 LOG.info(""stopped all jobtracker services"");
		 return;
	 }
	 void createTaskEntry(String taskid, String taskTracker, TaskInProgress tip) {
		 LOG.info(""Adding task '"" + taskid + ""' to tip "" + tip.getTIPId() + "", for tracker '"" + taskTracker + ""'"");
		 taskidToTrackerMap.put(taskid, taskTracker);
		 TreeSet taskset = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskset == null) {
			 taskset = new TreeSet();
			 trackerToTaskMap.put(taskTracker, taskset);
		 }
		 taskset.add(taskid);
		 taskidToTIPMap.put(taskid, tip);
	 }
	 void removeTaskEntry(String taskid) {
		 String tracker = (String) taskidToTrackerMap.remove(taskid);
		 TreeSet trackerSet = (TreeSet) trackerToTaskMap.get(tracker);
		 if (trackerSet != null) {
			 trackerSet.remove(taskid);
		 }
		 taskidToTIPMap.remove(taskid);
	 }
	 public int getTotalSubmissions() {
		 return totalSubmissions;
	 }
	 public String getJobTrackerMachine() {
		 return localMachine;
	 }
	 public int getTrackerPort() {
		 return port;
	 }
	 public int getInfoPort() {
		 return infoPort;
	 }
	 public long getStartTime() {
		 return startTime;
	 }
	 public Vector runningJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector failedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.FAILED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector completedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.SUCCEEDED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Collection taskTrackers() {
		 synchronized (taskTrackers) {
			 return taskTrackers.values();
		 }
	 }
	 public TaskTrackerStatus getTaskTracker(String trackerID) {
		 synchronized (taskTrackers) {
			 return (TaskTrackerStatus) taskTrackers.get(trackerID);
		 }
	 }
	 private boolean updateTaskTrackerStatus(String trackerName, TaskTrackerStatus status) {
		 TaskTrackerStatus oldStatus = (TaskTrackerStatus) taskTrackers.get(trackerName);
		 if (oldStatus != null) {
			 totalMaps -= oldStatus.countMapTasks();
			 totalReduces -= oldStatus.countReduceTasks();
			 if (status == null) {
				 taskTrackers.remove(trackerName);
			 }
		 }
		 if (status != null) {
			 totalMaps += status.countMapTasks();
			 totalReduces += status.countReduceTasks();
			 taskTrackers.put(trackerName, status);
		 }
		 return oldStatus != null;
	 }
	 public synchronized int emitHeartbeat(TaskTrackerStatus trackerStatus, boolean initialContact) {
		 String trackerName = trackerStatus.getTrackerName();
		 trackerStatus.setLastSeen(System.currentTimeMillis());
		 synchronized (taskTrackers) {
			 synchronized (trackerExpiryQueue) {
				 boolean seenBefore = updateTaskTrackerStatus(trackerName, trackerStatus);
				 if (initialContact) {
					 if (seenBefore) {
						 lostTaskTracker(trackerName, trackerStatus.getHost());
					 }
				 }
				 else {
					 if (!seenBefore) {
						 LOG.warn(""Status from unknown Tracker : "" + trackerName);
						 taskTrackers.remove(trackerName);
						 return InterTrackerProtocol.UNKNOWN_TASKTRACKER;
					 }
				 }
				 if (initialContact) {
					 trackerExpiryQueue.add(trackerStatus);
				 }
			 }
		 }
		 updateTaskStatuses(trackerStatus);
		 return InterTrackerProtocol.TRACKERS_OK;
	 }
	 public synchronized Task pollForNewTask(String taskTracker) {
		 int remainingReduceLoad = 0;
		 int remainingMapLoad = 0;
		 int numTaskTrackers;
		 TaskTrackerStatus tts;
		 synchronized (taskTrackers) {
			 numTaskTrackers = taskTrackers.size();
			 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
		 }
		 if (tts == null) {
			 LOG.warn(""Unknown task tracker polling;
			 ignoring: "" + taskTracker);
			 return null;
		 }
		 int totalCapacity = numTaskTrackers * maxCurrentTasks;
		 synchronized(jobsByArrival){
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
					 int totalMapTasks = job.desiredMaps();
					 int totalReduceTasks = job.desiredReduces();
					 remainingMapLoad += (totalMapTasks - job.finishedMaps());
					 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
				 }
			 }
		 }
		 int maxMapLoad = 0;
		 int maxReduceLoad = 0;
		 if (numTaskTrackers > 0) {
			 maxMapLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingMapLoad / numTaskTrackers));
			 maxReduceLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingReduceLoad / numTaskTrackers));
		 }
		 int numMaps = tts.countMapTasks();
		 int numReduces = tts.countReduceTasks();
		 synchronized (jobsByArrival) {
			 if (numMaps < maxMapLoad) {
				 int totalNeededMaps = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
						 continue;
					 }
					 Task t = job.obtainNewMapTask(tts, numTaskTrackers);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 myMetrics.launchMap();
						 return t;
					 }
					 totalNeededMaps += job.desiredMaps();
					 int padding = 0;
					 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, (int)(totalNeededMaps * PAD_FRACTION));
					 }
					 if (totalMaps + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
			 if (numReduces < maxReduceLoad) {
				 int totalNeededReduces = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING || job.numReduceTasks == 0) {
						 continue;
					 }
					 Task t = job.obtainNewReduceTask(tts, numTaskTrackers);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 myMetrics.launchReduce();
						 return t;
					 }
					 totalNeededReduces += job.desiredReduces();
					 int padding = 0;
					 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, (int) (totalNeededReduces * PAD_FRACTION));
					 }
					 if (totalReduces + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 public synchronized String[] pollForTaskWithClosedJob(String taskTracker) {
		 TreeSet taskIds = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskIds != null) {
			 ArrayList list = new ArrayList();
			 for (Iterator it = taskIds.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.shouldCloseForClosedJob(taskId)) {
					 list.add(taskId);
				 }
			 }
			 return (String[]) list.toArray(new String[list.size()]);
		 }
		 return null;
	 }
	 public synchronized MapOutputLocation[] locateMapOutputs(String jobId, int[] mapTasksNeeded, int reduce) {
		 ArrayList result = new ArrayList(mapTasksNeeded.length);
		 JobInProgress job = getJob(jobId);
		 for (int i = 0;
		 i < mapTasksNeeded.length;
		 i++) {
			 TaskStatus status = job.findFinishedMap(mapTasksNeeded[i]);
			 if (status != null) {
				 String trackerId = (String) taskidToTrackerMap.get(status.getTaskId());
				 TaskTrackerStatus tracker;
				 synchronized (taskTrackers) {
					 tracker = (TaskTrackerStatus) taskTrackers.get(trackerId);
				 }
				 result.add(new MapOutputLocation(status.getTaskId(), mapTasksNeeded[i], tracker.getHost(), tracker.getHttpPort()));
			 }
		 }
		 return (MapOutputLocation[]) result.toArray(new MapOutputLocation[result.size()]);
	 }
	 public synchronized String getFilesystemName() throws IOException {
		 return fs.getName();
	 }
	 public void reportTaskTrackerError(String taskTracker, String errorClass, String errorMessage) throws IOException {
		 LOG.warn(""Report from "" + taskTracker + "": "" + errorMessage);
	 }
	 public synchronized JobStatus submitJob(String jobFile) throws IOException {
		 totalSubmissions++;
		 JobInProgress job = new JobInProgress(jobFile, this, this.conf);
		 synchronized (jobs) {
			 synchronized (jobsByArrival) {
				 synchronized (jobInitQueue) {
					 jobs.put(job.getProfile().getJobId(), job);
					 jobsByArrival.add(job);
					 jobInitQueue.add(job);
					 jobInitQueue.notifyAll();
				 }
			 }
		 }
		 myMetrics.submitJob();
		 return job.getStatus();
	 }
	 public synchronized ClusterStatus getClusterStatus() {
		 synchronized (taskTrackers) {
			 return new ClusterStatus(taskTrackers.size(), totalMaps, totalReduces, maxCurrentTasks);
		 }
	 }
	 public synchronized void killJob(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 job.kill();
	 }
	 public synchronized JobProfile getJobProfile(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getProfile();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized JobStatus getJobStatus(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getStatus();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized TaskReport[] getMapTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeMapTasks = job.reportTasksInProgress(true, true);
			 for (Iterator it = completeMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteMapTasks = job.reportTasksInProgress(true, false);
			 for (Iterator it = incompleteMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 public synchronized TaskReport[] getReduceTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeReduceTasks = job.reportTasksInProgress(false, true);
			 for (Iterator it = completeReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteReduceTasks = job.reportTasksInProgress(false, false);
			 for (Iterator it = incompleteReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 public synchronized List<String> getTaskDiagnostics(String jobId, String tipId, String taskId) {
		 JobInProgress job = (JobInProgress) jobs.get(jobId);
		 if (job == null) {
			 throw new IllegalArgumentException(""Job "" + jobId + "" not found."");
		 }
		 TaskInProgress tip = job.getTaskInProgress(tipId);
		 if (tip == null) {
			 throw new IllegalArgumentException(""TIP "" + tipId + "" not found."");
		 }
		 return tip.getDiagnosticInfo(taskId);
	 }
	 TaskStatus[] getTaskStatuses(String jobid, String tipid){
		JobInProgress job = (JobInProgress) jobs.get(jobid);
		if (job == null){
			 return new TaskStatus[0];
		}
		TaskInProgress tip = (TaskInProgress) job.getTaskInProgress(tipid);
		if (tip == null){
			 return new TaskStatus[0];
		}
		return tip.getTaskStatuses();
	 }
	 public synchronized String getAssignedTracker(String taskId) {
		 return (String) taskidToTrackerMap.get(taskId);
	 }
	 public JobStatus[] jobsToComplete() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING || status.getRunState() == JobStatus.PREP) {
				status.setStartTime(jip.getStartTime());
				 status.setUsername(jip.getProfile().getUser());
				 v.add(status);
			 }
		 }
		 return (JobStatus[]) v.toArray(new JobStatus[v.size()]);
	 }
	 public JobInProgress getJob(String jobid) {
		 return (JobInProgress) jobs.get(jobid);
	 }
	 String createUniqueId() {
		 return idFormat.format(nextJobId++);
	 }
	 void updateTaskStatuses(TaskTrackerStatus status) {
		 for (Iterator it = status.taskReports();
		 it.hasNext();
		 ) {
			 TaskStatus report = (TaskStatus) it.next();
			 report.setTaskTracker(status.getTrackerName());
			 String taskId = report.getTaskId();
			 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
			 if (tip == null) {
				 LOG.info(""Serious problem. While updating status, cannot find taskid "" + report.getTaskId());
			 }
			 else {
				 expireLaunchingTasks.removeTask(taskId);
				 tip.getJob().updateTaskStatus(tip, report, myMetrics);
			 }
		 }
	 }
	 void lostTaskTracker(String trackerName, String hostname) {
		 LOG.info(""Lost tracker '"" + trackerName + ""'"");
		 TreeSet lostTasks = (TreeSet) trackerToTaskMap.get(trackerName);
		 trackerToTaskMap.remove(trackerName);
		 if (lostTasks != null) {
			 for (Iterator it = lostTasks.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.isMapTask() || !tip.isComplete()) {
					 JobInProgress job = tip.getJob();
					 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
						 job.failedTask(tip, taskId, ""Lost task tracker"", Phase.MAP, hostname, trackerName, myMetrics);
					 }
				 }
			 }
		 }
	 }
	 public static void main(String argv[]) throws IOException, InterruptedException {
		 if (argv.length != 0) {
			 System.out.println(""usage: JobTracker"");
			 System.exit(-1);
		 }
		 Configuration conf=new Configuration();
		 startTracker(conf);
	 }
}",0,0,0,0
"public class Size implements ResourceSelector {
	 private long size = -1;
	 private Comparison when = Comparison.EQUAL;
	 public void setSize(long l) {
		 size = l;
	 }
	 public long getSize() {
		 return size;
	 }
	 public void setWhen(Comparison c) {
		 when = c;
	 }
	 public Comparison getWhen() {
		 return when;
	 }
	 public boolean isSelected(Resource r) {
		 long diff = r.getSize() - size;
		 return when.evaluate(diff == 0 ? 0 : (int) (diff / Math.abs(diff)));
	 }
}",0,0,0,0
"private void init() {
	y = 25;
	h = 40;
	btnNav = new JLabel(ImageResource.get(""back24.png""));
	btnNav.setFont(FontResource.getBiggerFont());
	btnNav.setForeground(ColorResource.getSelectionColor());
	btnNav.setBounds(15, y, 25, h);
	add(btnNav);
	btnNav.addMouseListener(new MouseAdapter() {
		public void mouseReleased(MouseEvent e) {
			if (currentPage == overviewPanel) {
				saveOverviewSettings();
			}
			 else if (currentPage == browserIntPanel) {
				saveMonitoringSettings();
			}
			 else if (currentPage == networkPanel) {
				saveNetworkSettings();
			}
			 else if (currentPage == advPanel) {
				saveAdvSettings();
			}
			if (level == 0) {
				close();
			}
			if (level == 1) {
				level = 0;
				setPage(""PG_SETTINGS"");
			}
		}
	}
	);
	titleLbl = new JLabel(StringResource.get(""TITLE_SETTINGS""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(50, y, 200, h);
	add(titleLbl);
	y += h;
	y += 10;
	h = 2;
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, y, 400, h);
	lineLbl.setOpaque(true);
	add(lineLbl);
	y += h;
}",0,0,1,0
"public Enumeration keys() {
	 initAll();
	 return super.keys();
 }",0,0,0,0
"private static void countCompiledInstructions(ProgramBlock pb, ExplainCounts counts, boolean MR, boolean CP, boolean SP) {
	if (pb instanceof WhileProgramBlock){
		WhileProgramBlock tmp = (WhileProgramBlock)pb;
		countCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);
		for (ProgramBlock pb2 : tmp.getChildBlocks())countCompiledInstructions(pb2, counts, MR, CP, SP);
	}
	else if (pb instanceof IfProgramBlock){
		IfProgramBlock tmp = (IfProgramBlock)pb;
		countCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);
		for( ProgramBlock pb2 : tmp.getChildBlocksIfBody() )countCompiledInstructions(pb2, counts, MR, CP, SP);
		for( ProgramBlock pb2 : tmp.getChildBlocksElseBody() )countCompiledInstructions(pb2, counts, MR, CP, SP);
	}
	else if (pb instanceof ForProgramBlock) {
		 ForProgramBlock tmp = (ForProgramBlock)pb;
		countCompiledInstructions(tmp.getFromInstructions(), counts, MR, CP, SP);
		countCompiledInstructions(tmp.getToInstructions(), counts, MR, CP, SP);
		countCompiledInstructions(tmp.getIncrementInstructions(), counts, MR, CP, SP);
		for( ProgramBlock pb2 : tmp.getChildBlocks() )countCompiledInstructions(pb2, counts, MR, CP, SP);
	}
	else if ( pb instanceof FunctionProgramBlock ) {
		FunctionProgramBlock fpb = (FunctionProgramBlock)pb;
		for( ProgramBlock pb2 : fpb.getChildBlocks() )countCompiledInstructions(pb2, counts, MR, CP, SP);
	}
	else {
		countCompiledInstructions(pb.getInstructions(), counts, MR, CP, SP);
	}
}",0,0,1,0
"public class DefaultInteger {
	 private final int originalValue;
	 private int currentValue;
	 public DefaultInteger(int value) {
		 originalValue = value;
		 currentValue = value;
	 }
	 public int value() {
		 return currentValue;
	 }
	 public void set(int i) {
		 currentValue = i;
	 }
	 public boolean isModified() {
		 return originalValue != currentValue;
	 }
}",0,0,0,0
"public class LocalStrategy extends AbstractReplicationStrategy{
	 public LocalStrategy(String table, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> configOptions) {
		 super(table, tokenMetadata, snitch, configOptions);
	 }
	 public List<InetAddress> calculateNaturalEndpoints(Token token, TokenMetadata metadata) {
		 return Arrays.asList(FBUtilities.getBroadcastAddress());
	 }
	 public int getReplicationFactor() {
		 return 1;
	 }
	 public void validateOptions() throws ConfigurationException {
	 }
}",0,0,0,0
"public class BC_idiv extends JTTTest {
	 public static int test(int a, int b) {
		 return a / b;
	 }
	 public void run0() throws Throwable {
		 runTest(""test"", 1, 2);
	 }
	 public void run1() throws Throwable {
		 runTest(""test"", 11, 0);
	 }
}",0,0,0,0
"public void checkAlternativeConstructor() {
	MasterDetailsPair mDetailsP;
	DataComponent dComponent;
	String MasterType1 = ""TypeOne!"";
	dComponent = new DataComponent();
	dComponent.setName(MasterType1);
	IEntry entry = new StringEntry();
	dComponent.addEntry(entry);
	mDetailsP = new MasterDetailsPair(MasterType1, dComponent);
	assertEquals(MasterType1, mDetailsP.getMaster());
	assertTrue(dComponent.equals(mDetailsP.getDetails()));
	mDetailsP = new MasterDetailsPair(null, dComponent);
	 assertNull(mDetailsP.getMaster());
	assertTrue(dComponent.equals(mDetailsP.getDetails()));
	mDetailsP = new MasterDetailsPair(MasterType1, null);
	assertEquals(MasterType1, mDetailsP.getMaster());
	assertNull(mDetailsP.getDetails());
	mDetailsP = new MasterDetailsPair(null, null);
	assertNull(mDetailsP.getMaster());
	assertNull(mDetailsP.getDetails());
}",0,0,1,0
"public MatchGenerator(int access_flags, Type return_type, Type[] arg_types, String[] arg_names, String method_name, String class_name, InstructionList il, ConstantPoolGen cp);",0,0,0,1
"public class SysInfo implements Serializable {
	 static final long serialVersionUID = -3096346807579L;
	 public int numCores;
	 public long maxMemory;
	 public SysInfo(int nc, long mm) {
		 numCores = nc;
		 maxMemory = mm;
	 }
}",1,1,0,0
"public void drawRect(int x, int y, int width, int height);",0,0,0,1
"private void addRelevantPluginDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {
	 if (hasCommandlineArgs()) {
		 arguments = parseCommandlineArgs();
	 }
	 try {
		 Iterator<Artifact> iter = this.determineRelevantPluginDependencies().iterator();
		 while (iter.hasNext()) {
			 Artifact classPathElement = iter.next();
			 if (classPathElement.getArtifactId().equals(""org.osgi.core"")) {
				 if (getLog().isDebugEnabled()) {
					 getLog().debug(""Skipping org.osgi.core -> "" + classPathElement.getGroupId() + ""/"" + classPathElement.getArtifactId() + ""/"" + classPathElement.getVersion());
				 }
				 continue;
			 }
			 getLog().debug(""Adding plugin dependency artifact: "" + classPathElement.getArtifactId() + "" to classpath"");
			 path.add(classPathElement.getFile().toURI().toURL());
		 }
	 }
	 catch (MalformedURLException e) {
		 throw new MojoExecutionException(""Error during setting up classpath"", e);
	 }
 }",0,0,1,0
"public class PreferencesInitializer extends AbstractPreferenceInitializer {
	public void initializeDefaultPreferences() {
		IPreferenceStore store = BootActivator.getDefault().getPreferenceStore();
		store.setDefault(PREF_IGNORE_SILENT_EXIT, DEFAULT_PREF_IGNORE_SILENT_EXIT);
		store.setDefault(PREF_INITIALIZR_URL, StsProperties.getInstance().get(""spring.initializr.json.url""));
		store.setDefault(PREF_BOOT_FAST_STARTUP_DEFAULT, true);
		store.setDefault(PREF_BOOT_FAST_STARTUP_REMIND_MESSAGE, true);
		store.setDefault(PREF_BOOT_FAST_STARTUP_JVM_ARGS, BOOT_FAST_STARTUP_DEFAULT_JVM_ARGS);
	}
}",0,0,0,0
"public class TransformerIdentityImpl extends Transformer implements TransformerHandler, DeclHandler{
	 public TransformerIdentityImpl(boolean isSecureProcessing) {
		 m_outputFormat = new OutputProperties(Method.XML);
		 m_isSecureProcessing = isSecureProcessing;
	 }
	 public TransformerIdentityImpl() {
		 this(false);
	 }
	 public void setResult(Result result) throws IllegalArgumentException {
		 if(null == result) throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null));
		 m_result = result;
	 }
	 public void setSystemId(String systemID) {
		 m_systemID = systemID;
	 }
	 public String getSystemId() {
		 return m_systemID;
	 }
	 public Transformer getTransformer() {
		 return this;
	 }
	 public void reset() {
		 m_flushedStartDoc = false;
		 m_foundFirstElement = false;
		 m_outputStream = null;
		 clearParameters();
		 m_result = null;
		 m_resultContentHandler = null;
		 m_resultDeclHandler = null;
		 m_resultDTDHandler = null;
		 m_resultLexicalHandler = null;
		 m_serializer = null;
		 m_systemID = null;
		 m_URIResolver = null;
		 m_outputFormat = new OutputProperties(Method.XML);
	 }
	 private void createResultContentHandler(Result outputTarget) throws TransformerException {
		 if (outputTarget instanceof SAXResult) {
			 SAXResult saxResult = (SAXResult) outputTarget;
			 m_resultContentHandler = saxResult.getHandler();
			 m_resultLexicalHandler = saxResult.getLexicalHandler();
			 if (m_resultContentHandler instanceof Serializer) {
				 m_serializer = (Serializer) m_resultContentHandler;
			 }
		 }
		 else if (outputTarget instanceof DOMResult) {
			 DOMResult domResult = (DOMResult) outputTarget;
			 Node outputNode = domResult.getNode();
			 Node nextSibling = domResult.getNextSibling();
			 Document doc;
			 short type;
			 if (null != outputNode) {
				 type = outputNode.getNodeType();
				 doc = (Node.DOCUMENT_NODE == type) ? (Document) outputNode : outputNode.getOwnerDocument();
			 }
			 else {
				 try {
					 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
					 dbf.setNamespaceAware(true);
					 if (m_isSecureProcessing) {
						 try {
							 dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
						 }
						 catch (ParserConfigurationException pce) {
						}
					 }
					 DocumentBuilder db = dbf.newDocumentBuilder();
					 doc = db.newDocument();
				 }
				 catch (ParserConfigurationException pce) {
					 throw new TransformerException(pce);
				 }
				 outputNode = doc;
				 type = outputNode.getNodeType();
				 ((DOMResult) outputTarget).setNode(outputNode);
			 }
			 DOMBuilder domBuilder = (Node.DOCUMENT_FRAGMENT_NODE == type) ? new DOMBuilder(doc, (DocumentFragment) outputNode) : new DOMBuilder(doc, outputNode);
			 if (nextSibling != null) domBuilder.setNextSibling(nextSibling);
			 m_resultContentHandler = domBuilder;
			 m_resultLexicalHandler = domBuilder;
		 }
		 else if (outputTarget instanceof StreamResult) {
			 StreamResult sresult = (StreamResult) outputTarget;
			 try {
				 Serializer serializer = SerializerFactory.getSerializer(m_outputFormat.getProperties());
				 m_serializer = serializer;
				 if (null != sresult.getWriter()) serializer.setWriter(sresult.getWriter());
				 else if (null != sresult.getOutputStream()) serializer.setOutputStream(sresult.getOutputStream());
				 else if (null != sresult.getSystemId()) {
					 String fileURL = sresult.getSystemId();
					 if (fileURL.startsWith(""file: if (fileURL.substring(8).indexOf("":"") >0) {
						 fileURL = fileURL.substring(8);
					 }
					 else {
						 fileURL = fileURL.substring(7);
					 }
				 }
				 else if (fileURL.startsWith(""file:/"")) {
					 if (fileURL.substring(6).indexOf("":"") >0) {
						 fileURL = fileURL.substring(6);
					 }
					 else {
						 fileURL = fileURL.substring(5);
					 }
				 }
				 m_outputStream = new java.io.FileOutputStream(fileURL);
				 serializer.setOutputStream(m_outputStream);
			 }
			 else throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null));
			 m_resultContentHandler = serializer.asContentHandler();
		 }
		 catch (IOException ioe) {
			 throw new TransformerException(ioe);
		 }
	 }
	 else {
		 throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[]{
		outputTarget.getClass().getName()}
		));
	 }
	 if (m_resultContentHandler instanceof DTDHandler) m_resultDTDHandler = (DTDHandler) m_resultContentHandler;
	 if (m_resultContentHandler instanceof DeclHandler) m_resultDeclHandler = (DeclHandler) m_resultContentHandler;
	 if (m_resultContentHandler instanceof LexicalHandler) m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;
 }
 public void transform(Source source, Result outputTarget) throws TransformerException {
	 createResultContentHandler(outputTarget);
	 if ((source instanceof StreamSource && source.getSystemId()==null && ((StreamSource)source).getInputStream()==null && ((StreamSource)source).getReader()==null)|| (source instanceof SAXSource && ((SAXSource)source).getInputSource()==null && ((SAXSource)source).getXMLReader()==null )|| (source instanceof DOMSource && ((DOMSource)source).getNode()==null)){
		 try {
			 DocumentBuilderFactory builderF = DocumentBuilderFactory.newInstance();
			 DocumentBuilder builder = builderF.newDocumentBuilder();
			 String systemID = source.getSystemId();
			 source = new DOMSource(builder.newDocument());
			 if (systemID != null) {
				 source.setSystemId(systemID);
			 }
		 }
		 catch (ParserConfigurationException e){
			 throw new TransformerException(e.getMessage());
		 }
	 }
	 try {
		 if (source instanceof DOMSource) {
			 DOMSource dsource = (DOMSource) source;
			 m_systemID = dsource.getSystemId();
			 Node dNode = dsource.getNode();
			 if (null != dNode) {
				 try {
					 if(dNode.getNodeType() == Node.ATTRIBUTE_NODE) this.startDocument();
					 try {
						 if(dNode.getNodeType() == Node.ATTRIBUTE_NODE) {
							 String data = dNode.getNodeValue();
							 char[] chars = data.toCharArray();
							 characters(chars, 0, chars.length);
						 }
						 else {
							 org.apache.xml.serializer.TreeWalker walker;
							 walker = new org.apache.xml.serializer.TreeWalker(this, m_systemID);
							 walker.traverse(dNode);
						 }
					 }
					 finally {
						 if(dNode.getNodeType() == Node.ATTRIBUTE_NODE) this.endDocument();
					 }
				 }
				 catch (SAXException se) {
					 throw new TransformerException(se);
				 }
				 return;
			 }
			 else {
				 String messageStr = XSLMessages.createMessage( XSLTErrorResources.ER_ILLEGAL_DOMSOURCE_INPUT, null);
				 throw new IllegalArgumentException(messageStr);
			 }
		 }
		 InputSource xmlSource = SAXSource.sourceToInputSource(source);
		 if (null == xmlSource) {
			 throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_SOURCE_TYPE, new Object[]{
			source.getClass().getName()}
			));
		 }
		 if (null != xmlSource.getSystemId()) m_systemID = xmlSource.getSystemId();
		 XMLReader reader = null;
		 boolean managedReader = false;
		 try {
			 if (source instanceof SAXSource) {
				 reader = ((SAXSource) source).getXMLReader();
			 }
			 if (null == reader) {
				 try {
					 reader = XMLReaderManager.getInstance().getXMLReader();
					 managedReader = true;
				 }
				 catch (SAXException se) {
					 throw new TransformerException(se);
				 }
			 }
			 else {
				 try {
					 reader.setFeature(""http: true);
				 }
				 catch (org.xml.sax.SAXException se) {
				 }
			 }
			 ContentHandler inputHandler = this;
			 reader.setContentHandler(inputHandler);
			 if (inputHandler instanceof org.xml.sax.DTDHandler) reader.setDTDHandler((org.xml.sax.DTDHandler) inputHandler);
			 try {
				 if (inputHandler instanceof org.xml.sax.ext.LexicalHandler) reader.setProperty(""http: inputHandler);
				 if (inputHandler instanceof org.xml.sax.ext.DeclHandler) reader.setProperty( ""http: inputHandler);
			 }
			 catch (org.xml.sax.SAXException se){
			}
			 try {
				 if (inputHandler instanceof org.xml.sax.ext.LexicalHandler) reader.setProperty(""http: inputHandler);
				 if (inputHandler instanceof org.xml.sax.ext.DeclHandler) reader.setProperty(""http: inputHandler);
			 }
			 catch (org.xml.sax.SAXNotRecognizedException snre){
			}
			 reader.parse(xmlSource);
		 }
		 catch (org.apache.xml.utils.WrappedRuntimeException wre) {
			 Throwable throwable = wre.getException();
			 while (throwable instanceof org.apache.xml.utils.WrappedRuntimeException) {
				 throwable = ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
			 }
			 throw new TransformerException(wre.getException());
		 }
		 catch (org.xml.sax.SAXException se) {
			 throw new TransformerException(se);
		 }
		 catch (IOException ioe) {
			 throw new TransformerException(ioe);
		 }
		 finally {
			 if (managedReader) {
				 XMLReaderManager.getInstance().releaseXMLReader(reader);
			 }
		 }
	 }
	 finally {
		 if(null != m_outputStream) {
			 try {
				 m_outputStream.close();
			 }
			 catch(IOException ioe){
			}
			 m_outputStream = null;
		 }
	 }
 }
 public void setParameter(String name, Object value) {
	 if (value == null) {
		 throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_SET_PARAM_VALUE, new Object[]{
		name}
		));
	 }
	 if (null == m_params) {
		 m_params = new Hashtable();
	 }
	 m_params.put(name, value);
 }
 public Object getParameter(String name) {
	 if (null == m_params) return null;
	 return m_params.get(name);
 }
 public void clearParameters() {
	 if (null == m_params) return;
	 m_params.clear();
 }
 public void setURIResolver(URIResolver resolver) {
	 m_URIResolver = resolver;
 }
 public URIResolver getURIResolver() {
	 return m_URIResolver;
 }
 public void setOutputProperties(Properties oformat) throws IllegalArgumentException {
	 if (null != oformat) {
		 String method = (String) oformat.get(OutputKeys.METHOD);
		 if (null != method) m_outputFormat = new OutputProperties(method);
		 else m_outputFormat = new OutputProperties();
		 m_outputFormat.copyFrom(oformat);
	 }
	 else {
		 m_outputFormat = null;
	 }
 }
 public Properties getOutputProperties() {
	 return (Properties) m_outputFormat.getProperties().clone();
 }
 public void setOutputProperty(String name, String value) throws IllegalArgumentException {
	 if (!OutputProperties.isLegalPropertyKey(name)) throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{
	name}
	));
	 m_outputFormat.setProperty(name, value);
 }
 public String getOutputProperty(String name) throws IllegalArgumentException {
	 String value = null;
	 OutputProperties props = m_outputFormat;
	 value = props.getProperty(name);
	 if (null == value) {
		 if (!OutputProperties.isLegalPropertyKey(name)) throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{
		name}
		));
	 }
	 return value;
 }
 public void setErrorListener(ErrorListener listener) throws IllegalArgumentException {
	 if (listener == null) throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_ERROR_HANDLER, null));
	 else m_errorListener = listener;
 }
 public ErrorListener getErrorListener() {
	 return m_errorListener;
 }
 public void notationDecl(String name, String publicId, String systemId) throws SAXException {
	 if (null != m_resultDTDHandler) m_resultDTDHandler.notationDecl(name, publicId, systemId);
 }
 public void unparsedEntityDecl( String name, String publicId, String systemId, String notationName) throws SAXException {
	 if (null != m_resultDTDHandler) m_resultDTDHandler.unparsedEntityDecl(name, publicId, systemId, notationName);
 }
 public void setDocumentLocator(Locator locator) {
	 try {
		 if (null == m_resultContentHandler) createResultContentHandler(m_result);
	 }
	 catch (TransformerException te) {
		 throw new org.apache.xml.utils.WrappedRuntimeException(te);
	 }
	 m_resultContentHandler.setDocumentLocator(locator);
 }
 public void startDocument() throws SAXException {
	 try {
		 if (null == m_resultContentHandler) createResultContentHandler(m_result);
	 }
	 catch (TransformerException te) {
		 throw new SAXException(te.getMessage(), te);
	 }
	 m_flushedStartDoc = false;
	 m_foundFirstElement = false;
 }
 boolean m_flushedStartDoc = false;
 protected final void flushStartDoc() throws SAXException {
	 if(!m_flushedStartDoc) {
		 if (m_resultContentHandler == null) {
			 try {
				 createResultContentHandler(m_result);
			 }
			 catch(TransformerException te) {
				 throw new SAXException(te);
			 }
		 }
		 m_resultContentHandler.startDocument();
		 m_flushedStartDoc = true;
	 }
 }
 public void endDocument() throws SAXException {
	 flushStartDoc();
	 m_resultContentHandler.endDocument();
 }
 public void startPrefixMapping(String prefix, String uri) throws SAXException {
	 flushStartDoc();
	 m_resultContentHandler.startPrefixMapping(prefix, uri);
 }
 public void endPrefixMapping(String prefix) throws SAXException {
	 flushStartDoc();
	 m_resultContentHandler.endPrefixMapping(prefix);
 }
 public void startElement( String uri, String localName, String qName, Attributes attributes) throws SAXException {
	 if (!m_foundFirstElement && null != m_serializer) {
		 m_foundFirstElement = true;
		 Serializer newSerializer;
		 try {
			 newSerializer = SerializerSwitcher.switchSerializerIfHTML(uri, localName, m_outputFormat.getProperties(), m_serializer);
		 }
		 catch (TransformerException te) {
			 throw new SAXException(te);
		 }
		 if (newSerializer != m_serializer) {
			 try {
				 m_resultContentHandler = newSerializer.asContentHandler();
			 }
			 catch (IOException ioe) {
				 throw new SAXException(ioe);
			 }
			 if (m_resultContentHandler instanceof DTDHandler) m_resultDTDHandler = (DTDHandler) m_resultContentHandler;
			 if (m_resultContentHandler instanceof LexicalHandler) m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;
			 m_serializer = newSerializer;
		 }
	 }
	 flushStartDoc();
	 m_resultContentHandler.startElement(uri, localName, qName, attributes);
 }
 public void endElement(String uri, String localName, String qName) throws SAXException {
	 m_resultContentHandler.endElement(uri, localName, qName);
 }
 public void characters(char ch[], int start, int length) throws SAXException {
	 flushStartDoc();
	 m_resultContentHandler.characters(ch, start, length);
 }
 public void ignorableWhitespace(char ch[], int start, int length) throws SAXException {
	 m_resultContentHandler.ignorableWhitespace(ch, start, length);
 }
 public void processingInstruction(String target, String data) throws SAXException {
	 flushStartDoc();
	 m_resultContentHandler.processingInstruction(target, data);
 }
 public void skippedEntity(String name) throws SAXException {
	 flushStartDoc();
	 m_resultContentHandler.skippedEntity(name);
 }
 public void startDTD(String name, String publicId, String systemId) throws SAXException {
	 flushStartDoc();
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.startDTD(name, publicId, systemId);
 }
 public void endDTD() throws SAXException {
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.endDTD();
 }
 public void startEntity(String name) throws SAXException {
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.startEntity(name);
 }
 public void endEntity(String name) throws SAXException {
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.endEntity(name);
 }
 public void startCDATA() throws SAXException {
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.startCDATA();
 }
 public void endCDATA() throws SAXException {
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.endCDATA();
 }
 public void comment(char ch[], int start, int length) throws SAXException {
	 flushStartDoc();
	 if (null != m_resultLexicalHandler) m_resultLexicalHandler.comment(ch, start, length);
 }
 public void elementDecl (String name, String model) throws SAXException {
	 if (null != m_resultDeclHandler) m_resultDeclHandler.elementDecl(name, model);
 }
 public void attributeDecl (String eName, String aName, String type, String valueDefault, String value) throws SAXException {
	 if (null != m_resultDeclHandler) m_resultDeclHandler.attributeDecl(eName, aName, type, valueDefault, value);
 }
 public void internalEntityDecl (String name, String value) throws SAXException {
	 if (null != m_resultDeclHandler) m_resultDeclHandler.internalEntityDecl(name, value);
 }
 public void externalEntityDecl (String name, String publicId, String systemId) throws SAXException {
	 if (null != m_resultDeclHandler) m_resultDeclHandler.externalEntityDecl(name, publicId, systemId);
 }
 private java.io.FileOutputStream m_outputStream = null;
 private ContentHandler m_resultContentHandler;
 private LexicalHandler m_resultLexicalHandler;
 private DTDHandler m_resultDTDHandler;
 private DeclHandler m_resultDeclHandler;
 private Serializer m_serializer;
 private Result m_result;
 private String m_systemID;
 private Hashtable m_params;
 private ErrorListener m_errorListener = new org.apache.xml.utils.DefaultErrorHandler(false);
 URIResolver m_URIResolver;
 private OutputProperties m_outputFormat;
 boolean m_foundFirstElement;
 private boolean m_isSecureProcessing = false;
}",1,0,0,0
"public class HTMLTagBalancer implements XMLDocumentFilter, HTMLComponent {
	 protected static final String NAMESPACES = ""http: protected static final String AUGMENTATIONS = ""http: protected static final String REPORT_ERRORS = ""http: protected static final String DOCUMENT_FRAGMENT_DEPRECATED = ""http: protected static final String DOCUMENT_FRAGMENT = ""http: protected static final String IGNORE_OUTSIDE_CONTENT = ""http: private static final String[] RECOGNIZED_FEATURES = {
	 NAMESPACES, AUGMENTATIONS, REPORT_ERRORS, DOCUMENT_FRAGMENT_DEPRECATED, DOCUMENT_FRAGMENT, IGNORE_OUTSIDE_CONTENT, }
	;
	 private static final Boolean[] RECOGNIZED_FEATURES_DEFAULTS = {
	 null, null, null, null, Boolean.FALSE, Boolean.FALSE, }
	;
	 protected static final String NAMES_ELEMS = ""http: protected static final String NAMES_ATTRS = ""http: protected static final String ERROR_REPORTER = ""http: public static final String FRAGMENT_CONTEXT_STACK = ""http: private static final String[] RECOGNIZED_PROPERTIES = {
	 NAMES_ELEMS, NAMES_ATTRS, ERROR_REPORTER, FRAGMENT_CONTEXT_STACK, }
	;
	 private static final Object[] RECOGNIZED_PROPERTIES_DEFAULTS = {
	 null, null, null, null, }
	;
	 protected static final short NAMES_NO_CHANGE = 0;
	 protected static final short NAMES_MATCH = 0;
	 protected static final short NAMES_UPPERCASE = 1;
	 protected static final short NAMES_LOWERCASE = 2;
	 protected static final HTMLEventInfo SYNTHESIZED_ITEM = new HTMLEventInfo.SynthesizedItem();
	 protected boolean fNamespaces;
	 protected boolean fAugmentations;
	 protected boolean fReportErrors;
	 protected boolean fDocumentFragment;
	 protected boolean fIgnoreOutsideContent;
	 protected short fNamesElems;
	 protected short fNamesAttrs;
	 protected HTMLErrorReporter fErrorReporter;
	 protected XMLDocumentSource fDocumentSource;
	 protected XMLDocumentHandler fDocumentHandler;
	 protected final InfoStack fElementStack = new InfoStack();
	 protected final InfoStack fInlineStack = new InfoStack();
	 protected boolean fSeenAnything;
	 protected boolean fSeenDoctype;
	 protected boolean fSeenRootElement;
	 protected boolean fSeenRootElementEnd;
	 protected boolean fSeenHeadElement;
	 protected boolean fSeenBodyElement;
	 protected boolean fOpenedForm;
	 private final QName fQName = new QName();
	 private final XMLAttributes fEmptyAttrs = new XMLAttributesImpl();
	 private final HTMLAugmentations fInfosetAugs = new HTMLAugmentations();
	 protected HTMLTagBalancingListener tagBalancingListener;
	 private LostText lostText_ = new LostText();
	 private boolean forcedStartElement_ = false;
	 private boolean forcedEndElement_ = false;
	private QName[] fragmentContextStack_ = null;
	private int fragmentContextStackSize_ = 0;
	 private List endElementsBuffer_ = new ArrayList();
	 public Boolean getFeatureDefault(String featureId) {
		 int length = RECOGNIZED_FEATURES != null ? RECOGNIZED_FEATURES.length : 0;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return RECOGNIZED_FEATURES_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 int length = RECOGNIZED_PROPERTIES != null ? RECOGNIZED_PROPERTIES.length : 0;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return RECOGNIZED_PROPERTIES_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public String[] getRecognizedFeatures() {
		 return RECOGNIZED_FEATURES;
	 }
	 public String[] getRecognizedProperties() {
		 return RECOGNIZED_PROPERTIES;
	 }
	 public void reset(XMLComponentManager manager) throws XMLConfigurationException {
		 fNamespaces = manager.getFeature(NAMESPACES);
		 fAugmentations = manager.getFeature(AUGMENTATIONS);
		 fReportErrors = manager.getFeature(REPORT_ERRORS);
		 fDocumentFragment = manager.getFeature(DOCUMENT_FRAGMENT) || manager.getFeature(DOCUMENT_FRAGMENT_DEPRECATED);
		 fIgnoreOutsideContent = manager.getFeature(IGNORE_OUTSIDE_CONTENT);
		 fNamesElems = getNamesValue(String.valueOf(manager.getProperty(NAMES_ELEMS)));
		 fNamesAttrs = getNamesValue(String.valueOf(manager.getProperty(NAMES_ATTRS)));
		 fErrorReporter = (HTMLErrorReporter)manager.getProperty(ERROR_REPORTER);
		 fragmentContextStack_ = (QName[]) manager.getProperty(FRAGMENT_CONTEXT_STACK);
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
		 if (featureId.equals(AUGMENTATIONS)) {
			 fAugmentations = state;
			 return;
		 }
		 if (featureId.equals(REPORT_ERRORS)) {
			 fReportErrors = state;
			 return;
		 }
		 if (featureId.equals(IGNORE_OUTSIDE_CONTENT)) {
			 fIgnoreOutsideContent = state;
			 return;
		 }
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
		 if (propertyId.equals(NAMES_ELEMS)) {
			 fNamesElems = getNamesValue(String.valueOf(value));
			 return;
		 }
		 if (propertyId.equals(NAMES_ATTRS)) {
			 fNamesAttrs = getNamesValue(String.valueOf(value));
			 return;
		 }
	 }
	 public void setDocumentHandler(XMLDocumentHandler handler) {
		 fDocumentHandler = handler;
	 }
	 public XMLDocumentHandler getDocumentHandler() {
		 return fDocumentHandler;
	 }
	 public void startDocument(XMLLocator locator, String encoding, NamespaceContext nscontext, Augmentations augs) throws XNIException {
		 fElementStack.top = 0;
		 if (fragmentContextStack_ != null) {
			 fragmentContextStackSize_ = fragmentContextStack_.length;
			 for (int i=0;
			 i<fragmentContextStack_.length;
			 ++i) {
				 final QName name = fragmentContextStack_[i];
				 final Element elt = HTMLElements.getElement(name.localpart);
				 fElementStack.push(new Info(elt, name));
			 }
		 }
		 else {
			 fragmentContextStackSize_ = 0;
		 }
		 fSeenAnything = false;
		 fSeenDoctype = false;
		 fSeenRootElement = false;
		 fSeenRootElementEnd = false;
		 fSeenHeadElement = false;
		 fSeenBodyElement = false;
		 if (fDocumentHandler != null) {
			 XercesBridge.getInstance().XMLDocumentHandler_startDocument(fDocumentHandler, locator, encoding, nscontext, augs);
		 }
	 }
	 public void xmlDecl(String version, String encoding, String standalone, Augmentations augs) throws XNIException {
		 if (!fSeenAnything && fDocumentHandler != null) {
			 fDocumentHandler.xmlDecl(version, encoding, standalone, augs);
		 }
	 }
	 public void doctypeDecl(String rootElementName, String publicId, String systemId, Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 if (fReportErrors) {
			 if (fSeenRootElement) {
				 fErrorReporter.reportError(""HTML2010"", null);
			 }
			 else if (fSeenDoctype) {
				 fErrorReporter.reportError(""HTML2011"", null);
			 }
		 }
		 if (!fSeenRootElement && !fSeenDoctype) {
			 fSeenDoctype = true;
			 if (fDocumentHandler != null) {
				 fDocumentHandler.doctypeDecl(rootElementName, publicId, systemId, augs);
			 }
		 }
	 }
	 public void endDocument(Augmentations augs) throws XNIException {
		 fIgnoreOutsideContent = true;
		 consumeBufferedEndElements();
		 if (!fSeenRootElement && !fDocumentFragment) {
			 if (fReportErrors) {
				 fErrorReporter.reportError(""HTML2000"", null);
			 }
			 if (fDocumentHandler != null) {
				 fSeenRootElementEnd = false;
				 forceStartBody();
				 final String body = modifyName(""body"", fNamesElems);
				 fQName.setValues(null, body, body, null);
				 callEndElement(fQName, synthesizedAugs());
				 final String ename = modifyName(""html"", fNamesElems);
				 fQName.setValues(null, ename, ename, null);
				 callEndElement(fQName, synthesizedAugs());
			 }
		 }
		 else {
			 int length = fElementStack.top - fragmentContextStackSize_;
			 for (int i = 0;
			 i < length;
			 i++) {
				 Info info = fElementStack.pop();
				 if (fReportErrors) {
					 String ename = info.qname.rawname;
					 fErrorReporter.reportWarning(""HTML2001"", new Object[]{
					ename}
					);
				 }
				 if (fDocumentHandler != null) {
					 callEndElement(info.qname, synthesizedAugs());
				 }
			 }
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endDocument(augs);
		 }
	 }
	 private void consumeBufferedEndElements() {
		final List toConsume = new ArrayList(endElementsBuffer_);
		endElementsBuffer_.clear();
		for (int i=0;
		 i<toConsume.size();
		 ++i) {
			 final ElementEntry entry = (ElementEntry) toConsume.get(i);
			 forcedEndElement_ = true;
			 endElement(entry.name_, entry.augs_);
		 }
		endElementsBuffer_.clear();
	}
	 public void comment(XMLString text, Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 consumeEarlyTextIfNeeded();
		 if (fDocumentHandler != null) {
			 fDocumentHandler.comment(text, augs);
		 }
	 }
	 private void consumeEarlyTextIfNeeded() {
		if (!lostText_.isEmpty()) {
			 if (!fSeenBodyElement) {
				 forceStartBody();
			 }
			 lostText_.refeed(this);
		 }
	}
	 public void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 consumeEarlyTextIfNeeded();
		 if (fDocumentHandler != null) {
			 fDocumentHandler.processingInstruction(target, data, augs);
		 }
	 }
	 public void startElement(final QName elem, XMLAttributes attrs, final Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 final boolean isForcedCreation = forcedStartElement_;
		 forcedStartElement_ = false;
		 if (fSeenRootElementEnd) {
			 notifyDiscardedStartElement(elem, attrs, augs);
			 return;
		 }
		 final HTMLElements.Element element = getElement(elem);
		 final short elementCode = element.code;
		 if (isForcedCreation && (elementCode == HTMLElements.TABLE || elementCode == HTMLElements.SELECT)) {
			 return;
		 }
		if (fSeenRootElement && elementCode == HTMLElements.HTML) {
			 notifyDiscardedStartElement(elem, attrs, augs);
			 return;
		 }
		 if (elementCode == HTMLElements.HEAD) {
			 if (fSeenHeadElement) {
				 notifyDiscardedStartElement(elem, attrs, augs);
				 return;
			 }
			 fSeenHeadElement = true;
		 }
		 else if (elementCode == HTMLElements.FRAMESET) {
			 consumeBufferedEndElements();
		 }
		 else if (elementCode == HTMLElements.BODY) {
			 if (!fSeenHeadElement) {
				 final QName head = createQName(""head"");
				 forceStartElement(head, null, synthesizedAugs());
				 endElement(head, synthesizedAugs());
			 }
			 consumeBufferedEndElements();
			 if (fSeenBodyElement) {
				 notifyDiscardedStartElement(elem, attrs, augs);
				 return;
			 }
			 fSeenBodyElement = true;
		 }
		 else if (elementCode == HTMLElements.FORM) {
			 if (fOpenedForm) {
				 notifyDiscardedStartElement(elem, attrs, augs);
				 return;
			 }
			 fOpenedForm = true;
		 }
		 else if (elementCode == HTMLElements.UNKNOWN) {
			 consumeBufferedEndElements();
		 }
		 if (element.parent != null) {
			 final HTMLElements.Element preferedParent = element.parent[0];
			 if (fDocumentFragment && (preferedParent.code == HTMLElements.HEAD || preferedParent.code == HTMLElements.BODY)) {
			 }
			 else if (!fSeenRootElement && !fDocumentFragment) {
				 String pname = preferedParent.name;
				 pname = modifyName(pname, fNamesElems);
				 if (fReportErrors) {
					 String ename = elem.rawname;
					 fErrorReporter.reportWarning(""HTML2002"", new Object[]{
					ename,pname}
					);
				 }
				 final QName qname = new QName(null, pname, pname, null);
				 final boolean parentCreated = forceStartElement(qname, null, synthesizedAugs());
				 if (!parentCreated) {
					 if (!isForcedCreation) {
						 notifyDiscardedStartElement(elem, attrs, augs);
					 }
					 return;
				 }
			 }
			 else {
				 if (preferedParent.code != HTMLElements.HEAD || (!fSeenBodyElement && !fDocumentFragment)) {
					 int depth = getParentDepth(element.parent, element.bounds);
					 if (depth == -1) {
						 final String pname = modifyName(preferedParent.name, fNamesElems);
						 final QName qname = new QName(null, pname, pname, null);
						 if (fReportErrors) {
							 String ename = elem.rawname;
							 fErrorReporter.reportWarning(""HTML2004"", new Object[]{
							ename,pname}
							);
						 }
						 final boolean parentCreated = forceStartElement(qname, null, synthesizedAugs());
						 if (!parentCreated) {
							 if (!isForcedCreation) {
								 notifyDiscardedStartElement(elem, attrs, augs);
							 }
							 return;
						 }
					 }
				 }
			 }
		 }
		 int depth = 0;
		 if (element.flags == 0) {
			 int length = fElementStack.top;
			 fInlineStack.top = 0;
			 for (int i = length - 1;
			 i >= 0;
			 i--) {
				 Info info = fElementStack.data[i];
				 if (!info.element.isInline()) {
					 break;
				 }
				 fInlineStack.push(info);
				 endElement(info.qname, synthesizedAugs());
			 }
			 depth = fInlineStack.top;
		 }
		 if ((fElementStack.top > 1 && (fElementStack.peek().element.code == HTMLElements.SCRIPT)) || fElementStack.top > 2 && fElementStack.data[fElementStack.top-2].element.code == HTMLElements.HEAD) {
			 final Info info = fElementStack.pop();
			 if (fDocumentHandler != null) {
				 callEndElement(info.qname, synthesizedAugs());
			 }
		 }
		 if (element.closes != null) {
			 int length = fElementStack.top;
			 for (int i = length - 1;
			 i >= 0;
			 i--) {
				 Info info = fElementStack.data[i];
				 if (element.closes(info.element.code)) {
					 if (fReportErrors) {
						 String ename = elem.rawname;
						 String iname = info.qname.rawname;
						 fErrorReporter.reportWarning(""HTML2005"", new Object[]{
						ename,iname}
						);
					 }
					 for (int j = length - 1;
					 j >= i;
					 j--) {
						 info = fElementStack.pop();
						 if (fDocumentHandler != null) {
							 callEndElement(info.qname, synthesizedAugs());
						 }
					 }
					 length = i;
					 continue;
				 }
				 if (info.element.isBlock() || element.isParent(info.element)) {
					 break;
				 }
			 }
		 }
		 else if (elementCode == HTMLElements.TABLE) {
			 for (int i=fElementStack.top-1;
			 i >= 0;
			 i--) {
				 final Info info = fElementStack.data[i];
				 if (!info.element.isInline()) {
					 break;
				 }
				 endElement(info.qname, synthesizedAugs());
			 }
		 }
		 fSeenRootElement = true;
		 if (element != null && element.isEmpty()) {
			 if (attrs == null) {
				 attrs = emptyAttributes();
			 }
			 if (fDocumentHandler != null) {
				 fDocumentHandler.emptyElement(elem, attrs, augs);
			 }
		 }
		 else {
			 boolean inline = element != null && element.isInline();
			 fElementStack.push(new Info(element, elem, inline ? attrs : null));
			 if (attrs == null) {
				 attrs = emptyAttributes();
			 }
			 if (fDocumentHandler != null) {
				 callStartElement(elem, attrs, augs);
			 }
		 }
		 for (int i = 0;
		 i < depth;
		 i++) {
			 Info info = fInlineStack.pop();
			 forceStartElement(info.qname, info.attributes, synthesizedAugs());
		 }
		 if (elementCode == HTMLElements.BODY) {
			 lostText_.refeed(this);
		 }
	 }
	 private boolean forceStartElement(final QName elem, XMLAttributes attrs, final Augmentations augs) throws XNIException {
		 forcedStartElement_ = true;
		 startElement(elem, attrs, augs);
		 return fElementStack.top > 0 && elem.equals(fElementStack.peek().qname);
	 }
	 private QName createQName(String tagName) {
		tagName = modifyName(tagName, fNamesElems);
		return new QName(null, tagName, tagName, NamespaceBinder.XHTML_1_0_URI);
	}
	 public void emptyElement(final QName element, XMLAttributes attrs, Augmentations augs) throws XNIException {
		 startElement(element, attrs, augs);
		 final HTMLElements.Element elem = getElement(element);
		 if (elem.isEmpty() || elem.code == HTMLElements.UNKNOWN) {
			 endElement(element, augs);
		 }
	 }
	 public void startGeneralEntity(String name, XMLResourceIdentifier id, String encoding, Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (!fDocumentFragment) {
			 boolean insertBody = !fSeenRootElement;
			 if (!insertBody) {
				 Info info = fElementStack.peek();
				 if (info.element.code == HTMLElements.HEAD || info.element.code == HTMLElements.HTML) {
					 String hname = modifyName(""head"", fNamesElems);
					 String bname = modifyName(""body"", fNamesElems);
					 if (fReportErrors) {
						 fErrorReporter.reportWarning(""HTML2009"", new Object[]{
						hname,bname}
						);
					 }
					 fQName.setValues(null, hname, hname, null);
					 endElement(fQName, synthesizedAugs());
					 insertBody = true;
				 }
			 }
			 if (insertBody) {
				 forceStartBody();
			 }
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startGeneralEntity(name, id, encoding, augs);
		 }
	 }
	 private void forceStartBody() {
		final QName body = createQName(""body"");
		if (fReportErrors) {
			 fErrorReporter.reportWarning(""HTML2006"", new Object[]{
			body.localpart}
			);
		}
		forceStartElement(body, null, synthesizedAugs());
	}
	 public void textDecl(String version, String encoding, Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.textDecl(version, encoding, augs);
		 }
	 }
	 public void endGeneralEntity(String name, Augmentations augs) throws XNIException {
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endGeneralEntity(name, augs);
		 }
	 }
	 public void startCDATA(Augmentations augs) throws XNIException {
		 fSeenAnything = true;
		 consumeEarlyTextIfNeeded();
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startCDATA(augs);
		 }
	 }
	 public void endCDATA(Augmentations augs) throws XNIException {
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endCDATA(augs);
		 }
	 }
	 public void characters(final XMLString text, final Augmentations augs) throws XNIException {
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fElementStack.top == 0 && !fDocumentFragment) {
			 lostText_.add(text, augs);
			 return;
		 }
		 boolean whitespace = true;
		 for (int i = 0;
		 i < text.length;
		 i++) {
			 if (!Character.isWhitespace(text.ch[text.offset + i])) {
				 whitespace = false;
				 break;
			 }
		 }
		 if (!fDocumentFragment) {
			 if (!fSeenRootElement) {
				 if (whitespace) {
					 return;
				 }
				 forceStartBody();
			 }
			 if (whitespace && (fElementStack.top < 2 || endElementsBuffer_.size() == 1)) {
				 return;
			 }
			 else if (!whitespace) {
				 Info info = fElementStack.peek();
				 if (info.element.code == HTMLElements.HEAD || info.element.code == HTMLElements.HTML) {
					 String hname = modifyName(""head"", fNamesElems);
					 String bname = modifyName(""body"", fNamesElems);
					 if (fReportErrors) {
						 fErrorReporter.reportWarning(""HTML2009"", new Object[]{
						hname,bname}
						);
					 }
					 forceStartBody();
				 }
			 }
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.characters(text, augs);
		 }
	 }
	 public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException {
		 characters(text, augs);
	 }
	 public void endElement(final QName element, final Augmentations augs) throws XNIException {
		 final boolean forcedEndElement = forcedEndElement_;
		 if (fSeenRootElementEnd) {
			 notifyDiscardedEndElement(element, augs);
			 return;
		 }
		 HTMLElements.Element elem = getElement(element);
		 if (!fIgnoreOutsideContent && (elem.code == HTMLElements.BODY || elem.code == HTMLElements.HTML)) {
			 endElementsBuffer_.add(new ElementEntry(element, augs));
			 return;
		 }
		 if (elem.code == HTMLElements.HTML) {
			 fSeenRootElementEnd = true;
		 }
		 else if (elem.code == HTMLElements.FORM) {
			 fOpenedForm = false;
		 }
		 else if (elem.code == HTMLElements.HEAD && !forcedEndElement) {
			 endElementsBuffer_.add(new ElementEntry(element, augs));
			 return;
		 }
		 int depth = getElementDepth(elem);
		 if (depth == -1) {
			 if (elem.code == HTMLElements.P) {
				 forceStartElement(element, emptyAttributes(), synthesizedAugs());
				 endElement(element, augs);
			 }
			 else if (!elem.isEmpty()) {
				 notifyDiscardedEndElement(element, augs);
			 }
			 return;
		 }
		 if (depth > 1 && elem.isInline()) {
			 final int size = fElementStack.top;
			 fInlineStack.top = 0;
			 for (int i = 0;
			 i < depth - 1;
			 i++) {
				 final Info info = fElementStack.data[size - i - 1];
				 final HTMLElements.Element pelem = info.element;
				 if (pelem.isInline() || pelem.code == HTMLElements.FONT) {
					 fInlineStack.push(info);
				 }
			 }
		 }
		 for (int i = 0;
		 i < depth;
		 i++) {
			 Info info = fElementStack.pop();
			 if (fReportErrors && i < depth - 1) {
				 String ename = modifyName(element.rawname, fNamesElems);
				 String iname = info.qname.rawname;
				 fErrorReporter.reportWarning(""HTML2007"", new Object[]{
				ename,iname}
				);
			 }
			 if (fDocumentHandler != null) {
				 callEndElement(info.qname, i < depth - 1 ? synthesizedAugs() : augs);
			 }
		 }
		 if (depth > 1) {
			 int size = fInlineStack.top;
			 for (int i = 0;
			 i < size;
			 i++) {
				 Info info = (Info)fInlineStack.pop();
				 XMLAttributes attributes = info.attributes;
				 if (fReportErrors) {
					 String iname = info.qname.rawname;
					 fErrorReporter.reportWarning(""HTML2008"", new Object[]{
					iname}
					);
				 }
				 forceStartElement(info.qname, attributes, synthesizedAugs());
			 }
		 }
	 }
	 public void setDocumentSource(XMLDocumentSource source) {
		 fDocumentSource = source;
	 }
	 public XMLDocumentSource getDocumentSource() {
		 return fDocumentSource;
	 }
	 public void startDocument(XMLLocator locator, String encoding, Augmentations augs) throws XNIException {
		 startDocument(locator, encoding, null, augs);
	 }
	 public void startPrefixMapping(String prefix, String uri, Augmentations augs) throws XNIException {
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fDocumentHandler != null) {
			 XercesBridge.getInstance().XMLDocumentHandler_startPrefixMapping(fDocumentHandler, prefix, uri, augs);
		 }
	 }
	 public void endPrefixMapping(String prefix, Augmentations augs) throws XNIException {
		 if (fSeenRootElementEnd) {
			 return;
		 }
		 if (fDocumentHandler != null) {
			 XercesBridge.getInstance().XMLDocumentHandler_endPrefixMapping(fDocumentHandler, prefix, augs);
		 }
	 }
	 protected HTMLElements.Element getElement(final QName elementName) {
		 String name = elementName.rawname;
		 if (fNamespaces && NamespaceBinder.XHTML_1_0_URI.equals(elementName.uri)) {
			 int index = name.indexOf(':');
			 if (index != -1) {
				 name = name.substring(index+1);
			 }
		 }
		 return HTMLElements.getElement(name);
	 }
	 protected final void callStartElement(QName element, XMLAttributes attrs, Augmentations augs) throws XNIException {
		 fDocumentHandler.startElement(element, attrs, augs);
	 }
	 protected final void callEndElement(QName element, Augmentations augs) throws XNIException {
		 fDocumentHandler.endElement(element, augs);
	 }
	 protected final int getElementDepth(HTMLElements.Element element) {
		 final boolean container = element.isContainer();
		 final short elementCode = element.code;
		 final boolean tableBodyOrHtml = (elementCode == HTMLElements.TABLE)|| (elementCode == HTMLElements.BODY) || (elementCode == HTMLElements.HTML);
		 int depth = -1;
		 for (int i = fElementStack.top - 1;
		 i >=fragmentContextStackSize_;
		 i--) {
			 Info info = fElementStack.data[i];
			 if (info.element.code == element.code) {
				 depth = fElementStack.top - i;
				 break;
			 }
			 if (!container && info.element.isBlock()) {
				 break;
			 }
			 if (info.element.code == HTMLElements.TABLE && !tableBodyOrHtml) {
				 return -1;
			 }
		 }
		 return depth;
	 }
	 protected int getParentDepth(HTMLElements.Element[] parents, short bounds) {
		 if (parents != null) {
			 for (int i = fElementStack.top - 1;
			 i >= 0;
			 i--) {
				 Info info = fElementStack.data[i];
				 if (info.element.code == bounds) {
					 break;
				 }
				 for (int j = 0;
				 j < parents.length;
				 j++) {
					 if (info.element.code == parents[j].code) {
						 return fElementStack.top - i;
					 }
				 }
			 }
		 }
		 return -1;
	 }
	 protected final XMLAttributes emptyAttributes() {
		 fEmptyAttrs.removeAllAttributes();
		 return fEmptyAttrs;
	 }
	 protected final Augmentations synthesizedAugs() {
		 HTMLAugmentations augs = null;
		 if (fAugmentations) {
			 augs = fInfosetAugs;
			 augs.removeAllItems();
			 augs.putItem(AUGMENTATIONS, SYNTHESIZED_ITEM);
		 }
		 return augs;
	 }
	 protected static final String modifyName(String name, short mode) {
		 switch (mode) {
			 case NAMES_UPPERCASE: return name.toUpperCase();
			 case NAMES_LOWERCASE: return name.toLowerCase();
		 }
		 return name;
	 }
	 protected static final short getNamesValue(String value) {
		 if (value.equals(""lower"")) {
			 return NAMES_LOWERCASE;
		 }
		 if (value.equals(""upper"")) {
			 return NAMES_UPPERCASE;
		 }
		 return NAMES_NO_CHANGE;
	 }
	 public static class Info {
		 public HTMLElements.Element element;
		 public QName qname;
		 public XMLAttributes attributes;
		 public Info(HTMLElements.Element element, QName qname) {
			 this(element, qname, null);
		 }
		 public Info(HTMLElements.Element element, QName qname, XMLAttributes attributes) {
			 this.element = element;
			 this.qname = new QName(qname);
			 if (attributes != null) {
				 int length = attributes.getLength();
				 if (length > 0) {
					 QName aqname = new QName();
					 XMLAttributes newattrs = new XMLAttributesImpl();
					 for (int i = 0;
					 i < length;
					 i++) {
						 attributes.getName(i, aqname);
						 String type = attributes.getType(i);
						 String value = attributes.getValue(i);
						 String nonNormalizedValue = attributes.getNonNormalizedValue(i);
						 boolean specified = attributes.isSpecified(i);
						 newattrs.addAttribute(aqname, type, value);
						 newattrs.setNonNormalizedValue(i, nonNormalizedValue);
						 newattrs.setSpecified(i, specified);
					 }
					 this.attributes = newattrs;
				 }
			 }
		 }
		 public String toString() {
			 return super.toString() + qname;
		 }
	 }
	 public static class InfoStack {
		 public int top;
		 public Info[] data = new Info[10];
		 public void push(Info info) {
			 if (top == data.length) {
				 Info[] newarray = new Info[top + 10];
				 System.arraycopy(data, 0, newarray, 0, top);
				 data = newarray;
			 }
			 data[top++] = info;
		 }
		 public Info peek() {
			 return data[top-1];
		 }
		 public Info pop() {
			 return data[--top];
		 }
		 public String toString() {
			 final StringBuffer sb = new StringBuffer(""InfoStack("");
			 for (int i=top-1;
			 i>=0;
			 --i) {
				 sb.append(data[i]);
				 if (i != 0) sb.append("", "");
			 }
			 sb.append("")"");
			 return sb.toString();
		 }
	 }
	 void setTagBalancingListener(final HTMLTagBalancingListener tagBalancingListener) {
		this.tagBalancingListener = tagBalancingListener;
	}
	 private void notifyDiscardedStartElement(final QName elem, final XMLAttributes attrs, final Augmentations augs) {
		 if (tagBalancingListener != null) tagBalancingListener.ignoredStartElement(elem, attrs, augs);
	}
	 private void notifyDiscardedEndElement(final QName element, final Augmentations augs) {
		 if (tagBalancingListener != null) tagBalancingListener.ignoredEndElement(element, augs);
	}
	 static class ElementEntry {
		 private final QName name_;
		 private final Augmentations augs_;
		 ElementEntry(final QName element, final Augmentations augs) {
			 name_ = new QName(element);
			 augs_ = (augs == null) ? null : new HTMLAugmentations(augs);
		 }
	 }
}",1,0,0,0
"public final class BitScanForwardNode extends UnaryNode implements ArithmeticLIRLowerable {
	 public static final NodeClass<BitScanForwardNode> TYPE = NodeClass.create(BitScanForwardNode.class);
	 public BitScanForwardNode(ValueNode value) {
		 super(TYPE, StampFactory.forInteger(JavaKind.Int, 0, ((PrimitiveStamp) value.stamp(NodeView.DEFAULT)).getBits()), value);
		 assert value.getStackKind() == JavaKind.Int || value.getStackKind() == JavaKind.Long;
	 }
	 public Stamp foldStamp(Stamp newStamp) {
		 assert newStamp.isCompatible(getValue().stamp(NodeView.DEFAULT));
		 IntegerStamp valueStamp = (IntegerStamp) newStamp;
		 int min;
		 int max;
		 long mask = CodeUtil.mask(valueStamp.getBits());
		 int firstAlwaysSetBit = scan(valueStamp.downMask() & mask);
		 int firstMaybeSetBit = scan(valueStamp.upMask() & mask);
		 if (firstAlwaysSetBit == -1) {
			 int lastMaybeSetBit = BitScanReverseNode.scan(valueStamp.upMask() & mask);
			 min = firstMaybeSetBit;
			 max = lastMaybeSetBit;
		 }
		 else {
			 min = firstMaybeSetBit;
			 max = firstAlwaysSetBit;
		 }
		 return StampFactory.forInteger(JavaKind.Int, min, max);
	 }
	 public static ValueNode tryFold(ValueNode value) {
		 if (value.isConstant()) {
			 JavaConstant c = value.asJavaConstant();
			 if (c.asLong() != 0) {
				 return ConstantNode.forInt(value.getStackKind() == JavaKind.Int ? scan(c.asInt()) : scan(c.asLong()));
			 }
		 }
		 return null;
	 }
	 public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {
		 ValueNode folded = tryFold(forValue);
		 return folded != null ? folded : this;
	 }
	 public static int scan(long v) {
		 if (v == 0) {
			 return -1;
		 }
		 return Long.numberOfTrailingZeros(v);
	 }
	 public static int scan(int v) {
		 return scan(0xffffffffL & v);
	 }
	 public static native int unsafeScan(long v);
	 public static native int unsafeScan(int v);
	 public void generate(NodeLIRBuilderTool builder, ArithmeticLIRGeneratorTool gen) {
		 builder.setResult(this, gen.emitBitScanForward(builder.operand(getValue())));
	 }
}",1,0,0,0
"public class WebadminRequestHandler extends AbstractRequestHandler {
	 private static final String handler= ""/admin"";
	 private final String version = ""1.0"";
	 private static final IRequestHandler selve= new WebadminRequestHandler(handler);
	 public static IRequestHandler getHandlerInstance () {
		 return selve;
	 }
	 public Object instanceForSystem() {
		 return this;
	 }
	 public String getHandler() {
		 return handler;
	 }
	 public String getVersion() {
		 return version;
	 }
	public WebadminRequestHandler(String handlerName) {
		super(handlerName);
	}
	public void handle(IRequest req, ContentContainer c) throws AccessForbiddenException {
		checkAccessIp(req, c);
		checkAccessAuth(req, c);
		StringBuffer sb = new StringBuffer();
		renderTemplate(req, ""admin_header"", sb);
		StringBuffer action = null;
		if (req.getValue(""do"") != null)action = new StringBuffer(req.getValue(""do""));
		else action = new StringBuffer();
		 if (""removeuser"".equalsIgnoreCase(action.toString())) {
			 removeUser(req, sb);
		 }
		 else if (""removeright"".equalsIgnoreCase(action.toString())) {
			 removeRight(req, sb);
		 }
		 else if (""giveright"".equalsIgnoreCase(action.toString())) {
			 giveRight(req, sb);
		 }
		 else if (""unpunish"".equalsIgnoreCase(action.toString())) {
			 unpunishUser(req, sb);
		 }
		 else if (""changestate"".equalsIgnoreCase(action.toString())) {
			 changeState(req, sb);
		 }
		 else if (""refreshgp"".equalsIgnoreCase(action.toString())) {
			 refreshGp(req, sb);
		 }
		 else if (""removeban"".equalsIgnoreCase(action.toString())) {
			 removeBan(req, sb);
		 }
		 else if (""removeaction"".equalsIgnoreCase(action.toString())) {
			 removeActionstore(req, sb);
		 }
		 else if (""sendmessage"".equalsIgnoreCase(action.toString())) {
			 sendMessage(req, sb);
		 }
		 else if (""sendmessagetouser"".equalsIgnoreCase(action.toString())) {
			 sendMessageToUser(req, sb);
		 }
		 else if (""sendmessagetogroup"".equalsIgnoreCase(action.toString())) {
			 sendMessageToGroup(req, sb);
		 }
		 else if (""grouplist"".equalsIgnoreCase(action.toString())) {
			 renderGrouplist(req, sb);
		 }
		 else if (""userlist"".equalsIgnoreCase(action.toString())) {
			 renderUserlist(req, sb);
		}
		 else if (""searchuser"".equalsIgnoreCase(action.toString())) {
			 searchUser(req, sb);
		}
		 else if (""searchgroup"".equalsIgnoreCase(action.toString())) {
			 searchGroup(req, sb);
		}
		 else if (""banlist"".equalsIgnoreCase(action.toString())) {
			renderBanlist(req, sb);
		}
		 else if (""actionstorelist"".equalsIgnoreCase(action.toString())) {
			renderActionstorelist(req, sb);
		}
		 else if (""configoverview"".equalsIgnoreCase(action.toString())) {
			renderConfigoverview(req, sb);
		}
		 else if (""shutdown"".equalsIgnoreCase(action.toString())) {
			if (slevel() == 1){
				 SelectionKey key = req.getKey ();
				 InetAddress ia = null;
				 try {
					 SocketChannel sc = (SocketChannel) key.channel ();
					 ia = sc.socket ().getInetAddress ();
				 }
				 catch (Exception e) {
					 Server.debug (this, """" + ia.toString (), e, Server.MSG_STATE, Server.LVL_MAJOR);
					 throw new AccessForbiddenException(true);
				 }
				 Server.log (""[Admin]"", ""Server shutdown ""+ia.getHostAddress(), Server.MSG_STATE, Server.LVL_MAJOR);
				 System.exit(0);
			}
			 else {
				sb.append(""Access denied."");
			}
		 }
		 else {
			 renderTemplate(req, ""admin_index"", sb);
			 TemplateSet ts = Server.srv.templatemanager.getTemplateSet(""admin"");
			 Template tpl = ts.getTemplate(""admin_index"");
			 if (tpl == null){
				 standartIndex(req, sb);
			 }
		 }
		 sb.append(""</body></html>"");
		 c.wrap(sb.toString(), req.getCookieDomain());
	 }
	 private void standartIndex(IRequest req, StringBuffer sb){
		 sb.append(""<form action=/ADMIN method=post>"");
		 sb.append(""send message: <input type=text name=msg><input type=submit value=send>"");
		 sb.append(""<input type=hidden name=do value=sendmessage></form>"");
		 sb.append(""<form action=/ADMIN method=post>"");
		 sb.append(""send message: <input type=text name=msg><br>"");
		 sb.append("" to user: <input type=text name=username><input type=submit value=send>"");
		 sb.append(""<input type=hidden name=do value=sendmessagetouser></form>"");
		 sb.append(""<form action=/ADMIN method=post>"");
		 sb.append(""send message: <input type=text name=msg><br>"");
		 sb.append("" to group: <input type=text name=groupname><input type=submit value=send>"");
		 sb.append(""<input type=hidden name=do value=sendmessagetogroup></form>"");
		 sb.append(""<form action=/ADMIN method=post>"");
		 sb.append(""<input type=text name=usr>"");
		 sb.append(""<input type=submit value=search&nbsp;
		User>"");
		 sb.append(""<input type=hidden name=do value=searchuser></form>"");
		 sb.append(""<form action=/ADMIN method=post>"");
		 sb.append(""<input type=text name=group>"");
		 sb.append(""<input type=submit value=search&nbsp;
		Group>"");
		 sb.append(""<input type=hidden name=do value=searchgroup></form>"");
		 sb.append(""<a href=/ADMIN?do=userlist>show&nbsp;
		userlist</a>&nbsp;
		|&nbsp;
		"");
		 sb.append(""<a href=/ADMIN?do=banlist>show&nbsp;
		banlist</a>&nbsp;
		|&nbsp;
		"");
		 sb.append(""<a href=/ADMIN?do=actionstorelist>show&nbsp;
		actionstorelist</a>&nbsp;
		|&nbsp;
		"");
		 sb.append(""<a href=/ADMIN?do=grouplist>grouplist</a>&nbsp;
		|&nbsp;
		"");
		 sb.append(""<a href=/ADMIN?do=configoverview>configoverview</a>&nbsp;
		|&nbsp;
		"");
		 sb.append(""<a href=/ADMIN?do=shutdown>shutdown</a>"");
	 }
	private void refreshGp(IRequest req, StringBuffer sb) {
		String group = req.getValue(""group"");
		Group g = GroupManager.mgr.getGroup(group);
		StringBuffer file = new StringBuffer (Server.BASE_PATH);
		 file.append (""/grouppolicies/"");
		 file.append (group.toLowerCase());
		 file.append ("".properties"");
		 File f = new File (file.toString());
		 if (f.exists()) {
			 g = checkProperties (f, g);
			 sb.append (""<b>FreeCS-Grouplist</b><br><table class=mainTable>"");
			 displayGroup(g, sb);
			 sb.append (""</table>"");
		 }
		 else {
			 sb.append (""<b>FreeCS-Grouplist</b><br><table class=mainTable>"");
			 displayGroup(g, sb);
			 sb.append (""<tr>"");
			 sb.append (""<td class=name>"");
			 sb.append (""File:"").append(file).append(""&nbsp;
			not&nbsp;
			found"");
			 sb.append (""</td></tr>"");
			 sb.append (""</table>"");
		 }
	}
	private Group checkProperties (File f, Group g) {
		if (g == null)return null;
		 Properties props = new Properties();
		 try {
			 FileInputStream in = new FileInputStream(f);
			 props.load(in);
			 in.close();
		 }
		 catch (FileNotFoundException fnfe) {
			 return g;
		 }
		 catch (IOException ioe) {
			 Server.debug(this, ""crateByProperties:"", ioe, Server.MSG_ERROR, Server.LVL_HALT);
			 return g;
		 }
		 HashMap<String, Properties> map = new HashMap<String, Properties>();
		 for (Iterator<Object> i = props.keySet().iterator();
		 i.hasNext();
		 ) {
			 String key = i.next().toString();
			 String low = key.toLowerCase();
			 String val = props.getProperty(key);
			 if (""timelock"".equals(low)) {
				 if (!g.hasState(IGroupState.MODERATED)) return null;
				 try {
					 int sec = Integer.parseInt(val);
					 g.setTimelockSec(sec);
				 }
				 catch (NumberFormatException nfe) {
					 Server.log(g, ""Timelock value isn't a number"", Server.MSG_ERROR, Server.LVL_MINOR);
				 }
			 }
			 else if (""membershiproom"".equals(low)) {
				 String[] memberships = val.toLowerCase().split("","");
				 Vector<Membership> msObjects = new Vector<Membership>();
				 for (int j = 0;
				 j < memberships.length;
				 j++) {
					 Membership cms = MembershipManager.instance.getMembership(memberships[j]);
					 if (cms == null) continue;
					 msObjects.add(cms);
				 }
				 g.setMembershipRoom ((Membership[]) msObjects.toArray(new Membership[0]));
			 }
			 else if (""autosulist"".equals(low)) {
				 g.unsetAutoSu();
				 g.setAutoSu (val.split("",""));
			 }
			 else if (""autosumembershiplist"".equals(low)) {
				 String[] memberships = val.toLowerCase().split("","");
				 Vector<Membership> msObjects = new Vector<Membership>();
				 for (int j = 0;
				 j < memberships.length;
				 j++) {
					 Membership cms = MembershipManager.instance.getMembership(memberships[j]);
					 if (cms == null) continue;
					 msObjects.add(cms);
				 }
				 g.setAutoSuMembership ((Membership[]) msObjects.toArray(new Membership[0]));
			 }
			 else if (""lockprotected"".equals(low) && ""true"".equals(val)) {
				 if (!g.hasState(IGroupState.OPEN)) g.setState (IGroupState.OPEN);
				 g.setState (IGroupState.LOCKPROTECTED);
			 }
			 else if (""autosu"".equals(low) && ""false"".equals(val)) {
				 g.unsetState (IGroupState.AUTO_SU_FIRST);
			 }
			 else if (""allowsu"".equals(low) && ""false"".equals(val)) {
				 g.unsetState (IGroupState.ALLOW_SU);
			 }
			 else if (""nosufirst"".equals(low) && ""true"".equals(val)) {
				 g.setState (IGroupState.NO_SU_FIRST);
			 }
			 else if (""minuserrolesu"".equals(low)) {
				 if (""vip"".equals(val)) g.setMinRightSu(IUserStates.ROLE_VIP);
				 else if (""moderator"".equals(val)) g.setMinRightSu(IUserStates.IS_MODERATOR);
				 else if (""admin"".equals(val)) g.setMinRightSu(IUserStates.ROLE_GOD);
				 else Server.log (this, ""minuserrolesu has wrong value '"" + val + ""' for group "" + g.getRawName(), Server.MSG_STATE, Server.LVL_MINOR);
			 }
			 else if (""membershipsu"".equals(low)) {
				 String[] memberships = val.toLowerCase().split("","");
				 Vector<Membership> msObjects = new Vector<Membership>();
				 for (int j = 0;
				 j < memberships.length;
				 j++) {
					 Membership cms = MembershipManager.instance.getMembership(memberships[j]);
					 if (cms == null) continue;
					 msObjects.add(cms);
				 }
				 g.setMembershipSu ((Membership[]) msObjects.toArray(new Membership[0]));
			 }
			 else if (""soundprooffor"".equals(low)) {
				 String[] roles = val.toLowerCase().split("","");
				 for (int j = 0;
				 j < roles.length;
				 j++) {
					 String curr = roles[j].trim();
					 if (""vip"".equals(curr)) g.setState(IGroupState.SND_PRF_VIP);
					else if (""guest"".equals(curr))g.setState(IGroupState.SND_PRF_GUEST);
					 else if (""moderator"".equals(curr)) g.setState(IGroupState.SND_PRF_MODERATOR);
					 else if (""admin"".equals(curr)) g.setState(IGroupState.SND_PRF_GOD);
					 else if (""user"".equals(curr)) g.setState(IGroupState.SND_PRF_USER);
				 }
			 }
			 else if (""suforbidden"".equals(low)) {
				 g.setSuForbiddenMembership(val);
			 }
			 else if (""memberroom"".equals(low)) {
				 String[] memberships = val.toLowerCase().split("","");
				 Vector<Membership> msObjects = new Vector<Membership>();
				 for (int j = 0;
				 j < memberships.length;
				 j++) {
					 Membership cms = MembershipManager.instance.getMembership(memberships[j]);
					 if (cms == null) continue;
					 msObjects.add(cms);
				 }
				 g.setMemberRoom ((Membership[]) msObjects.toArray(new Membership[0]));
			 }
			 else if (""allowusebbcodes"".equals(low) && ""true"".equals(val)) {
				 g.setState(IGroupState.ALLOW_USE_BBCODES);
			 }
			 else if (""allowusebbcodes"".equals(low) && ""false"".equals(val)) {
				 g.unsetState(IGroupState.ALLOW_USE_BBCODES);
			 }
			 else if (""allowusesmiley"".equals(low) && ""true"".equals(val)) {
				 g.setState(IGroupState.ALLOW_USE_SMILEY);
			 }
			 else if (""allowusesmiley"".equals(low) && ""false"".equals(val)) {
				 g.unsetState(IGroupState.ALLOW_USE_SMILEY);
			 }
			 else if (""deactivatehitdice"".equals(low) && ""true"".equals(val)){
				 g.setState (IGroupState.DEACTIVATE_HITDICE);
			 }
			 else if (""sucanban"".equals(low) && ""true"".equals(val)){
				 g.setState (IGroupState.SU_CAN_BAN);
			 }
			 else if (""sucanban"".equals(low) && ""false"".equals(val)){
				 g.unsetState (IGroupState.SU_CAN_BAN);
			 }
			 else if (""sucansettheme"".equals(low) && ""true"".equals(val)){
				 g.setState (IGroupState.SU_CAN_SETTHEME);
			 }
			 else if (""sucansettheme"".equals(low) && ""false"".equals(val)){
				 g.unsetState (IGroupState.SU_CAN_SETTHEME);
			 }
			 else if (""cansetpunishable"".equals(low) && ""true"".equals(val)){
				 g.setState (IGroupState.CAN_SET_PUNISHABLE);
			 }
			 else if (""notallowjoinunreg"".equals(low) && ""true"".equals(val)){
				 g.setState (IGroupState.NOT_ALLOW_JOIN_UNREG);
			 }
			 else if (low.startsWith(""extension."")) {
				 String namespace = low.substring(10);
				 int idx = namespace.indexOf(""."");
				 if (idx == -1) {
					 Server.log (this, ""invalid GroupPolicy for extension: "" + low, Server.MSG_ERROR, Server.LVL_MINOR);
					 continue;
				 }
				 String propName = namespace.substring(idx+1);
				 namespace = namespace.substring(0,idx);
				 Properties p = (Properties) map.get(namespace);
				 if (p==null) {
					 p = new Properties();
					 map.put(namespace, p);
				 }
				 p.setProperty(propName, val);
			 }
		 }
		 if (map.size() > 0) {
			 Vector<IGroupPlugin> plugins = new Vector<IGroupPlugin>();
			 for (Iterator<String> i = map.keySet().iterator();
			 i.hasNext();
			 ) {
				 String namespace = (String) i.next();
				 Properties p = (Properties) map.get(namespace);
				 String url = p.getProperty(""url"");
				 Object o;
				 synchronized (GroupManager.pluginStore) {
					 o = GroupManager.pluginStore.get(url);
					 if (o == null) {
						 try {
							 Class<?> piClass = Class.forName(url);
							 Method getInstance = piClass.getMethod(""getMasterInstance"", null);
							 if (getInstance==null) throw new Exception (""Specified plugin-object doesn't implement static getMasterInstance"");
							 o = getInstance.invoke(null, null);
							 if (!(o instanceof IGroupPlugin)) throw new Exception (""Specified plugin-object doesn't implement interface IGroupPlugin"");
							 GroupManager.pluginStore.put(url, o);
						 }
						 catch (Exception e) {
							 Server.log (this, ""invalid url for extension: (""+e+"") "" + url, Server.MSG_ERROR, Server.LVL_MINOR);
							 continue;
						 }
					 }
				 }
				 try {
					 plugins.add(((IGroupPlugin) o).instanceForGroup(namespace, g, p));
				 }
				 catch (Exception e) {
					 Server.debug(this, ""catched exception while getting GroupPlugin-instance"", e, Server.MSG_STATE, Server.LVL_MAJOR);
				 }
			 }
			 g.setPlugins((IGroupPlugin[]) plugins.toArray(new IGroupPlugin[0]));
		 }
		 return g;
	 }
	private void changeState(IRequest req, StringBuffer sb) {
		 String group = req.getValue(""group"");
		 String state = req.getValue(""state"");
		 String right = req.getValue(""right"");
		 Group g = GroupManager.mgr.getGroup(group);
		 if (g != null){
			 if (state.equals(""timelocksub"")){
				 int t_old=g.getTimelockSec();
				 g.setTimelockSec(t_old-5);
			 }
			 else if (state.equals(""timelockadd"")){
				 int t_old=g.getTimelockSec();
				 g.setTimelockSec(t_old+5);
			 }
			 else if (state.equals(""allowusebbcodes"")){
				 if (g.hasState(IGroupState.ALLOW_USE_BBCODES)){
					 g.unsetState(IGroupState.ALLOW_USE_BBCODES);
				 }
				 else g.setState(IGroupState.ALLOW_USE_BBCODES);
			 }
			 else if (state.equals(""allowusesmiley"")) {
				 if (g.hasState(IGroupState.ALLOW_USE_SMILEY)) {
					 g.unsetState(IGroupState.ALLOW_USE_SMILEY);
				 }
				 else {
					 g.setState(IGroupState.ALLOW_USE_SMILEY);
				 }
			 }
			 else if (state.equals(""lockprotected"")){
				 if (g.hasState(IGroupState.LOCKPROTECTED)){
					 g.unsetState(IGroupState.LOCKPROTECTED);
				 }
				 else {
					 g.setState (IGroupState.OPEN);
					 g.setState (IGroupState.LOCKPROTECTED);
				 }
			 }
			 else if (state.equals(""allowsu"")){
				 if (g.hasState(IGroupState.ALLOW_SU)){
					 g.unsetState(IGroupState.ALLOW_SU);
				 }
				 else g.setState(IGroupState.ALLOW_SU);
			 }
			 else if (state.equals(""minuserrolesu"")) {
				 if (right.equals(""user"")) {
					 g.setMinRightSu(IUserStates.ROLE_USER);
				 }
				 else if (right.equals(""vip"")) {
					 g.setMinRightSu(IUserStates.ROLE_VIP);
				 }
				 else if (right.equals(""moderator"")) {
					 g.setMinRightSu(IUserStates.IS_MODERATOR);
				 }
				 else if (right.equals(""admin"")) {
					 g.setMinRightSu(IUserStates.ROLE_GOD);
				 }
			 }
			 else if (state.equals(""moderated"")){
				 if (g.hasState(IGroupState.MODERATED)){
					 g.unsetState(IGroupState.MODERATED);
				 }
				 else g.setState(IGroupState.MODERATED);
			 }
			 else if (state.equals(""hitdice"")){
				 if (g.hasState(IGroupState.DEACTIVATE_HITDICE)){
					 g.unsetState(IGroupState.DEACTIVATE_HITDICE);
				 }
				 else g.setState(IGroupState.DEACTIVATE_HITDICE);
			 }
			 else if (state.equals(""nosufirst"")){
				 if (g.hasState(IGroupState.NO_SU_FIRST)){
					 g.unsetState(IGroupState.NO_SU_FIRST);
				 }
				 else g.setState(IGroupState.NO_SU_FIRST);
			 }
			 else if (state.equals(""sucanban"")){
				 if (g.hasState(IGroupState.SU_CAN_BAN)){
					 g.unsetState(IGroupState.SU_CAN_BAN);
				 }
				 else g.setState(IGroupState.SU_CAN_BAN);
			 }
			 else if (state.equals(""sucansettheme"")){
				 if (g.hasState(IGroupState.SU_CAN_SETTHEME)){
					 g.unsetState(IGroupState.SU_CAN_SETTHEME);
				 }
				 else g.setState(IGroupState.SU_CAN_SETTHEME);
			 }
			 else if (state.equals(""cansetpunishable"")){
				 if (g.hasState(IGroupState.CAN_SET_PUNISHABLE)){
					 g.unsetState(IGroupState.CAN_SET_PUNISHABLE);
				 }
				 else g.setState(IGroupState.CAN_SET_PUNISHABLE);
			 }
			 else if (state.equals(""joinunreg"")) {
				 if (g.hasState(IGroupState.NOT_ALLOW_JOIN_UNREG)) {
					 g.unsetState(IGroupState.NOT_ALLOW_JOIN_UNREG);
				 }
				 else {
					 g.setState(IGroupState.NOT_ALLOW_JOIN_UNREG);
				 }
			 }
			 else if (state.equals(""joinmembershiplocked"")) {
				 if (g.hasState(IGroupState.JOIN_MEMBERSHIP_LOCKED)) {
					 g.unsetState(IGroupState.JOIN_MEMBERSHIP_LOCKED);
				 }
				 else {
					 g.setState(IGroupState.JOIN_MEMBERSHIP_LOCKED);
				 }
			 }
			 sb.append (""<b>FreeCS-Grouplist</b><br /><table class=mainTable>"");
			 displayGroup(g, sb);
			 sb.append (""</table>"");
		 }
		 else {
			 sb.append (""<b>FreeCS-Grouplist</b><br /><table class=mainTable>"");
			 sb.append(""<tr>"");
			 sb.append(""<td class=name"");
			 sb.append(""group not found"");
			 sb.append(""</td></tr>"");
			 sb.append (""</table>"");
		 }
	}
	private void removeRight(IRequest req, StringBuffer sb) {
		 String usrName = req.getValue(""name"");
		 String right = req.getValue(""right"");
		 User ur = UserManager.mgr.getUserByName (usrName);
		 if (ur!=null) {
			 if (right.equals(""user"")){
				 ur.setNewPermission(IUserStates.ROLE_ASSHOLE);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""vip"")){
				 ur.setNewPermission(IUserStates.ROLE_USER);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""admin"")){
				 ur.setNewPermission(IUserStates.ROLE_USER);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""moderator"")){
				 ur.takePermission(IUserStates.IS_MODERATOR);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""guest"")){
				 ur.takePermission(IUserStates.IS_GUEST);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 sb.append (""</table>"");
		 }
		 else {
			 sb.append (""<table class=mainTable>"");
			 sb.append(""<tr>"");
			 sb.append(""<td class=name"");
			 sb.append(""user not found"");
			 sb.append(""</td></tr>"");
			 sb.append (""</table>"");
		 }
	 }
	private void giveRight(IRequest req, StringBuffer sb) {
		 String usrName = req.getValue(""name"");
		 String right = req.getValue(""right"");
		 User ur = UserManager.mgr.getUserByName (usrName);
		 if (ur!=null) {
			 if (right.equals(""user"")){
				 ur.setNewPermission(IUserStates.ROLE_USER);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""vip"")){
				 ur.setNewPermission(IUserStates.ROLE_VIP);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""admin"")){
				 if (slevel() == 1) ur.setNewPermission(IUserStates.ROLE_GOD);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""moderator"")){
				 ur.givePermission(IUserStates.IS_MODERATOR);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 else if (right.equals(""guest"")){
				 ur.givePermission(IUserStates.IS_GUEST);
				 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
				 displayUser(ur, sb);
			 }
			 sb.append (""</table>"");
		 }
		 else {
			 sb.append (""<table class=mainTable>"");
			 sb.append(""<tr>"");
			 sb.append(""<td class=name >"");
			 sb.append(""user not found"");
			 sb.append(""</td></tr>"");
			 sb.append (""</table>"");
		 }
	 }
	private void unpunishUser(IRequest req, StringBuffer sb) {
		 String usrName = req.getValue(""name"");
		 User ur = UserManager.mgr.getUserByName (usrName);
		 if (ur!=null) {
			 ur.setPunish(false);
			 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
			 displayUser(ur, sb);
		 }
		 else {
			 sb.append (""<table class=mainTable>"");
			 sb.append(""<tr>"");
			 sb.append(""<td class=name >"");
			 sb.append(""user not found"");
			 sb.append(""</td></tr>"");
		 }
	}
	private void removeUser(IRequest req, StringBuffer sb) {
		 String usrName = req.getValue(""name"");
		 String usrCookie = req.getValue(""cookie"");
		 String force = req.getValue(""force"");
		 User ur = UserManager.mgr.getUserByCookie(usrCookie);
		 if (ur==null) ur = UserManager.mgr.getUserByName (usrName);
		 if (ur!=null) {
			 ur.sendQuitMessage(false, null);
			 if (""true"".equalsIgnoreCase(force)) {
				 UserManager.mgr.ustr.removeUser(ur);
				 sb.append(""forcibly removed user"");
			 }
			 else {
				 sb.append(""removed user"");
			 }
		 }
		 else {
			 sb.append(""user not found"");
		 }
	}
	private void removeBan(IRequest req, StringBuffer sb) {
		 String val = req.getValue(""name"");
		 if (val != null) {
			 if (Server.srv.removeBan(val)) sb.append(""removed ban for user "" + val);
			 else sb.append(""No ban found for user "" + val);
		 }
		 else {
			 val = req.getValue(""host"");
			 if (Server.srv.removeBan(val)) sb.append(""removed ban for host "" + val);
			 else sb.append(""No ban found for host "" + val);
		 }
	}
	private void removeActionstore(IRequest req, StringBuffer sb) {
		 String val = req.getValue(""name"");
		 String action = req.getValue(""action"");
		 int reason = new Integer(action).intValue();
		 if (val != null) {
			 if (Server.srv.removeStore(val, reason)) sb.append(""removed action for user "" + val);
			 else sb.append(""No action found for user "" + val);
		 }
	 }
	private void sendMessage(IRequest req, StringBuffer sb) {
		 if (req.getValue(""msg"") == null) {
			 sb.append(""no message!"");
		 }
		 else {
			 AdminCore.messageToAll(req.getValue(""msg""));
			 sb.append(""message sent!"");
		 }
	}
	private void sendMessageToUser(IRequest req, StringBuffer sb) {
		 if (req.getValue(""msg"") == null || req.getValue(""username"") == null) {
			 sb.append(""no message or username!"");
		 }
		 else {
			 AdminCore.messageToUser(req.getValue(""msg""),req.getValue(""username""));
			 sb.append(""message sent!"");
		 }
	}
	private void sendMessageToGroup(IRequest req, StringBuffer sb) {
		 if (req.getValue(""msg"") == null || req.getValue(""groupname"") == null) {
			 sb.append(""no message or groupname!"");
		 }
		 else {
			 AdminCore.messageToGroup(req.getValue(""msg""),req.getValue(""groupname""));
			 sb.append(""message sent!"");
		 }
	}
	private void renderUserlist(IRequest req, StringBuffer sb) {
		 sb.append (""<b>FreeCS-Userlist</b><br><table class=mainTable>"");
		 User[] users = UserManager.mgr.ustr.toArray();
		 for (int i = 0;
		 i < users.length;
		 i++) {
			 User u = users[i];
			 displayUser(u, sb);
		 }
	}
	private void searchUser(IRequest req, StringBuffer sb) {
		String usrName = req.getValue(""usr"");
		User u = null;
		sb.append (""<b>FreeCS-Usersearch</b><br><table class=mainTable>"");
		if (usrName == null ){
			sb.append (""<br>missing Username"");
		}
		 else u = UserManager.mgr.getUserByName(usrName);
		 if (u != null) {
			 displayUser(u, sb);
		 }
		 else if (usrName != null) {
			sb.append (""<br>User not found"");
		}
	}
	private void searchGroup(IRequest req, StringBuffer sb) {
		String group = req.getValue(""group"");
		Group g = null;
		sb.append (""<b>FreeCS-Groupsearch</b><br><table class=mainTable>"");
		if (group == null){
			sb.append (""<br>missing Groupname"");
		}
		 else g = GroupManager.mgr.getGroup(group);
		 if (g != null) {
			 displayGroup(g, sb);
		 }
		 else if (group != null){
			 sb.append (""<br>group ("").append(group).append("") not found"");
		}
	}
	 private void displayGroup(Group g, StringBuffer sb){
		 if (g == null){
			 sb.append(""group not found"");
			 return;
		 }
		 String groupname = g.getRawName().toLowerCase();
		 sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Groupname"");
		sb.append (""</td>"");
		sb.append (""<td width=200px class=param>"");
		sb.append (groupname);
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Entrace"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.ENTRANCE)) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		 sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Open"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.OPEN)) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		 sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Lockprotected"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.LOCKPROTECTED)) sb.append (""<a href=\""/ADMIN?do=changestate&state=lockprotected&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=lockprotected&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Allow&nbsp;
		SU"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.ALLOW_SU)) sb.append (""<a href=\""/ADMIN?do=changestate&state=allowsu&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=allowsu&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Minright&nbsp;
		SU"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasMinRightSu(IUserStates.ROLE_USER)) sb.append (""<a href=\""/ADMIN?do=changestate&state=minuserrolesu&group="").append(groupname).append(""&right=vip\"">"").append(""USER"").append(""</a>"");
		 else if (g.hasMinRightSu(IUserStates.ROLE_VIP)) sb.append (""<a href=\""/ADMIN?do=changestate&state=minuserrolesu&group="").append(groupname).append(""&right=admin\"">"").append(""VIP"").append(""</a>"");
		 else if (g.hasMinRightSu(IUserStates.ROLE_GOD)) sb.append (""<a href=\""/ADMIN?do=changestate&state=minuserrolesu&group="").append(groupname).append(""&right=moderator\"">"").append(""ADMIN"").append(""</a>"");
		 else if (g.hasMinRightSu(IUserStates.IS_MODERATOR)) sb.append (""<a href=\""/ADMIN?do=changestate&state=minuserrolesu&group="").append(groupname).append(""&right=user\"">"").append(""MOD"").append(""</a>"");
		 sb.append (""</td>"");
		 sb.append (""<td class=name>"");
		sb.append (""Minright&nbsp;
		Open"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasMinRight(IUserStates.ROLE_USER) || g.hasMinRight(IUserStates.MAY_JOIN_GROUP)) sb.append (""USER"");
		 else if (g.hasMinRight(IUserStates.ROLE_VIP)) sb.append (""VIP"");
		 else if (g.hasMinRight(IUserStates.ROLE_GOD)) sb.append (""ADMIN"");
		 else if (g.hasMinRight(IUserStates.IS_MODERATOR)) sb.append (""MOD"");
		 sb.append (""</td>"");
		 sb.append (""<td class=name>"");
		sb.append (""Membership&nbsp;
		Open"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.getMembershipRoom() != null) sb.append (g.getMembershipRoom());
		else sb.append(""<img src =\""../static/no.gif\"" border =\""0\"">"");
		 sb.append(""</td>"");
		 sb.append(""\r\n<td class=name>"");
		 sb.append(""Membershiplock"");
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n<td class=param>"");
		 if (g.hasState(IGroupState.JOIN_MEMBERSHIP_LOCKED)) {
			 sb.append(""\r\n<a href=\""/ADMIN?do=changestate&state=joinmembershiplocked&group="");
			 sb.append(groupname);
			 sb.append( ""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 }
		 else {
			 sb.append(""\r\n<a href=\""/ADMIN?do=changestate&state=joinmembershiplocked&group="") .append(groupname) .append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 }
		 sb.append(""\r\n</td>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name colspan=2>"");
		sb.append (""<a href=\""/ADMIN?do=refreshgp&&group="").append(groupname).append(""\""><img src =\""../static/refresh.gif\"" border =\""0\"" alt=\""refresh Grouppolice\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""BBC"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.ALLOW_USE_BBCODES)) sb.append (""<a href=\""/ADMIN?do=changestate&state=allowusebbcodes&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		else sb.append (""<a href=\""/ADMIN?do=changestate&state=allowusebbcodes&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Hitdice"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (!g.hasState(IGroupState.DEACTIVATE_HITDICE)) sb.append (""<a href=\""/ADMIN?do=changestate&state=hitdice&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=hitdice&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""No&nbsp;
		SU first"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.NO_SU_FIRST)) sb.append (""<a href=\""/ADMIN?do=changestate&state=nosufirst&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=nosufirst&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""SU&nbsp;
		setTheme"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.SU_CAN_SETTHEME)) sb.append (""<a href=\""/ADMIN?do=changestate&state=sucansettheme&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=sucansettheme&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		 sb.append (""<td class=name>"");
		sb.append (""SU&nbsp;
		Ban"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.SU_CAN_BAN)) sb.append (""<a href=\""/ADMIN?do=changestate&state=sucanban&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=sucanban&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		 sb.append (""<td class=name>"");
		sb.append (""AutoSuList"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.getAutoSuList() != null && g.getAutoSuList().size()>0){
			 for (Enumeration<String> e = g.getAutoSuList().elements();
			 e.hasMoreElements();
			 ) {
				 sb.append((String) e.nextElement());
				 if (e.hasMoreElements()){
					 sb.append(""<b>,</b>"");
				 }
			 }
		}
		 else sb.append(""<img src =\""../static/no.gif\"" border =\""0\"">"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""AutoSuMembershipList"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.getAutoSuMembership() != null && g.getAutoSuMembership().length>0){
			Membership[] values = g.getAutoSuMembership();
			 for (int i=0;
			i< values.length;
			 i++ ) {
				 sb.append(values[i].key);
				 if (i<values.length-1){
					 sb.append(""<b>,</b>"");
				 }
			 }
		}
		 else sb.append(""<img src =\""../static/no.gif\"" border =\""0\"">"");
		sb.append (""<td class=name>"");
		sb.append (""MemberRoom"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.getMemberships() != null && g.getMemberships().length>0){
			Membership[] values = g.getMemberships();
			 for (int i=0;
			i< values.length;
			 i++ ) {
				 sb.append(values[i].key);
				 if (i<values.length-1){
					 sb.append(""<b>,</b>"");
				 }
			 }
		}
		 else sb.append(""<img src =\""../static/no.gif\"" border =\""0\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""\r\n<tr>"");
		sb.append (""\r\n<td class=name colspan=2>"");
		 sb.append (""\r\n<img title=\""opener\"" src=\""../static/schluessel.gif\""> "");
		 User u = UserManager.mgr.getUserByName(g.getOpener());
		 if (u != null){
			 if (Server.srv.USE_FADECOLOR){
				 if (u.getFadeColCode() != null && u.getFadeColorUsername()!=null){
					 sb.append(u.getFadeColorUsername().toString());
				 }
				 else sb.append(u.getNoFadeColorUsername());
			 }
			 else sb.append (EntityDecoder.charToHtml (u.getName ()));
		 }
		 else {
			 sb.append(""<i>"").append(g.getOpener()).append(""</i>"");
		 }
		sb.append (""\r\n</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Punishable"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.CAN_SET_PUNISHABLE)) sb.append (""<a href=\""/ADMIN?do=changestate&state=cansetpunishable&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		else sb.append (""<a href=\""/ADMIN?do=changestate&state=cansetpunishable&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		sb.append (""<td class=name>"");
		sb.append (""Moderated"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (g.hasState(IGroupState.MODERATED)) sb.append (""<a href=\""/ADMIN?do=changestate&state=moderated&group="").append(groupname).append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 else sb.append (""<a href=\""/ADMIN?do=changestate&state=moderated&group="").append(groupname).append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		sb.append (""</td>"");
		 if (Server.srv.USE_SMILEY) {
			 sb.append(""\r\n<td class=name>"");
			 sb.append(""Smiley"");
			 sb.append(""\r\n</td>"");
			 sb.append(""\r\n<td class=param>"");
			 if (g.hasState(IGroupState.ALLOW_USE_SMILEY)) {
				 sb.append(""<a href=\""/ADMIN?do=changestate&state=allowusesmiley&group="") .append(groupname) .append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
			 }
			 else {
				 sb.append(""\r\n<a href=\""/ADMIN?do=changestate&state=allowusesmiley&group="") .append(groupname) .append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
			 }
			 sb.append(""\r\n</td>"");
		 }
		sb.append (""<td class=name>"");
		sb.append (""Mod&nbsp;
		Timelock"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (g.getTimelockSec());
		sb.append (""&nbsp;
		sec<br>"");
		sb.append (""<a style=\""text-decoration:none\"" href=\""/ADMIN?do=changestate&state=timelocksub&group="").append(groupname).append(""\"">-</a>"");
		sb.append (""<b>/</b>"");
		 sb.append (""<a style=\""text-decoration:none\"" href=\""/ADMIN?do=changestate&state=timelockadd&group="").append(groupname).append(""\"">+</a>"");
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n<td class=name>"");
		 sb.append(""join Unreg"");
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n<td class=param>"");
		 if (g.hasState(IGroupState.NOT_ALLOW_JOIN_UNREG)){
			 sb.append(""\r\n<a href=\""/ADMIN?do=changestate&state=joinunreg&group="") .append(groupname) .append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 }
		 else {
			 sb.append(""\r\n<a href=\""/ADMIN?do=changestate&state=joinunreg&group="") .append(groupname) .append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""change\""></a>"");
		 }
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n</tr>\r\n"");
	 }
	 private void displayUser(User u, StringBuffer sb) {
		 sb.append(""\r\n<tr>"");
		 sb.append(""\r\n<td class=logout><a href=\""/admin?do=removeuser&name="");
		 sb.append(u.getName().toLowerCase());
		 sb.append(""&cookie="");
		 sb.append(u.getCookie());
		 sb.append(""\"">logout</a>"");
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n<td class=remove>"");
		 sb.append(""\r\n<a href=\""/admin?do=removeuser&name="");
		 sb.append(u.getName().toLowerCase());
		 sb.append(""&cookie="");
		 sb.append(u.getCookie());
		 sb.append(""&force=true\"">remove</a>"");
		 sb.append(""</td>"");
		 sb.append(""\r\n<td class=username>"");
		 sb.append(u.getName());
		 sb.append(""\r\n</td>"");
		 sb.append(has_Right(u, IUserStates.ROLE_USER, ""user""));
		 sb.append(has_Right(u, IUserStates.ROLE_VIP, ""vip""));
		 sb.append(has_Right(u, IUserStates.ROLE_GOD, ""admin""));
		 sb.append(has_Right(u, IUserStates.IS_MODERATOR, ""moderator""));
		 sb.append(has_Right(u, IUserStates.IS_GUEST, ""guest""));
		 sb.append(has_RightAsshole(u, IUserStates.ROLE_ASSHOLE));
		 if (Server.srv.USE_SMILEY) sb.append(may_use_Smiley(u));
		 sb.append(may_set_Theme(u));
		 sb.append(may_call_Memberships(u));
		 sb.append(""\r\n<td class=name>"");
		 sb.append(""is&nbsp;
		punished"");
		 sb.append(""\r\n<td class=param>"");
		 if (u.isPunished()) {
			 sb.append(""\r\n<a href=\""/ADMIN?do=unpunish&name="") .append(u.getName().toLowerCase()) .append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""remove\""></a>"");
		 }
		 else {
			 sb.append(""<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n<td class=name>"");
		 sb.append(""is&nbsp;
		reg"");
		 sb.append(""\r\n<td class=param>"");
		 if (!u.isUnregistered) {
			 sb.append(""<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n<td class=groupname>in&nbsp;
		"");
		 Group g = u.getGroup();
		 sb.append(g != null ? g.getRawName() : ""<i>currently changing group</i>"");
		 sb.append(""\r\n</td>"");
		 sb.append(""\r\n</tr>\r\n"");
	 }
	private void renderBanlist(IRequest req, StringBuffer sb) {
		 BanObject[] bArr = Server.srv.getBanList();
		 sb.append (""<b>FreeCS-BanList</b><br>"");
		 if (bArr.length<1) {
			 sb.append (""There are no BanObjects at the moment"");
		 }
		 else {
			 StringBuffer ub = new StringBuffer(""<table border=0><tr><td class=\""param\""><b>User (ip)</b></td><td class=\""param\""><b>Banned by</b></td><td class=\""param\"">Banned until</td><td class=\""param\"">Release</td><td class=\""param\"">Message</td></tr>"");
			 StringBuffer hb = new StringBuffer(""<table border=0><tr><td class=\""param\""><b>Host</b></td><td class=\""param\""><b>Hostname</b></td><td class=\""param\"">Banned until</td><td class=\""param\"">Release</td><td class=\""param\"">details</td></tr>"");
			 Vector<BanObject> v = new Vector<BanObject>();
			 for (int i = 0;
			 i < bArr.length;
			 i++) {
				 BanObject curr = bArr[i];
				 if (curr.hostban == null) {
					 if (v.contains(curr)) {
						 continue;
					 }
					 v.add(curr);
					 ub.append(""<tr><td class=\""param\"">"");
					 ub.append(curr.usr);
					 ub.append("" ("");
					 ub.append(curr.con);
					 ub.append("")</td><td class=\""param\"">"");
					 ub.append(curr.bannedBy);
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(Server.formatDefaultTimeStamp(curr.time));
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(""<a href=/admin?do=removeban&name="");
					 ub.append(curr.usr);
					 ub.append("">X</a></td><td class=\""param\"">"");
					 ub.append(curr.msg);
					 ub.append(""</td></tr>"");
				 }
				 else {
					 hb.append(""<tr><td class=\""param\"">"");
					 hb.append(curr.hostban);
					 hb.append(""</td><td class=\""param\"">"");
					 InetAddress ia;
					 try {
						 ia = InetAddress.getByName(curr.hostban);
						 hb.append(ia.getHostName());
					 }
					 catch (UnknownHostException e) {
					 }
					 hb.append(""</td><td class=\""param\"">"");
					 if (curr.time > 0) {
						 hb.append(Server.formatDefaultTimeStamp(curr.time));
					 }
					 else {
						 hb.append(""--.--.----"");
					 }
					 hb.append(""</td><td class=\""param\"">"");
					 hb.append(""<a href=/admin?do=removeban&host="");
					 hb.append(curr.hostban);
					 hb.append("">X</a></td><td class=\""param\"">"");
					 hb.append(curr.msg);
					 hb.append(""</td></tr>"");
				 }
			 }
			 ub.append(""</table>"");
			 hb.append(""</table>"");
			 sb.append (""<table border=0><tr><td valign=top>"");
			 sb.append (ub.toString());
			 sb.append (""</td><td width=2 bgcolor=#000000></td><td valign=top>"");
			 sb.append (hb.toString());
			 sb.append (""</td></tr></table>"");
		 }
		 sb.append (""</table>"");
	}
	 private void renderActionstorelist(IRequest req, StringBuffer sb) {
		 ActionstoreObject[] pArr = Server.srv.getStoreList();
		 sb.append(""<b>FreeCS-ActionstoreList</b><br>"");
		 if (pArr.length < 1) {
			 sb.append(""There are no ActionstoreObjects at the moment"");
		 }
		 else {
			 StringBuffer ub = new StringBuffer();
			 StringBuffer hb = new StringBuffer();
			 ub.append(""<table border=0><tr><td class=\""param\""><b>Action</b></td><td class=\""param\""><b>Room</b></td><td class=\""param\""><b>User </b></td><td class=\""param\""><b>Stored by</b></td><td class=\""param\"">Stored until</td><td class=\""param\"">Release</td><td class=\""param\"">Message</td></tr>"");
			 for (int i = 0;
			 i < pArr.length;
			 i++) {
				 ActionstoreObject curr = pArr[i];
				 if (curr.usr != null) {
					 ub.append(""<tr><td class=\""param\"">"");
					 ub.append(curr.rendererActionState());
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(curr.room);
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(curr.usr);
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(curr.storedBy);
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(Server.formatDefaultTimeStamp(curr.time));
					 ub.append(""</td><td class=\""param\"">"");
					 ub.append(""<a href=\""/admin?do=removeaction&name="");
					 ub.append(curr.usr);
					 ub.append(""&action="");
					 ub.append(curr.action);
					 ub.append(""\"">X</a></td><td class=\""param\"">"");
					 ub.append(curr.msg);
					 ub.append(""</td></tr>"");
				 }
			 }
			 ub.append(""</table>"");
			 sb.append(""<table border=0><tr><td valign=top>"");
			 sb.append(ub.toString());
			 sb.append(""</td><td width=2 bgcolor=#000000></td><td valign=top>"");
			 sb.append(hb.toString());
			 sb.append(""</td></tr></table>"");
		 }
		 sb.append(""</table>"");
	 }
	private void renderGrouplist(IRequest req, StringBuffer sb) {
		 Group[] grps = GroupManager.mgr.currentGroupList();
		 sb.append (""<b>FreeCS Grouplist</b><br>"");
		sb.append (""<table class=mainTable>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""open group(s): "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (GroupManager.mgr.openGroupsCount());
		sb.append (""</td>"");
		sb.append (""</tr>"");
		 for (int i = 0;
		 i < grps.length;
		 i++) {
			 Group g = grps[i];
			 displayGroup(g, sb);
		 }
		 sb.append(""</table"");
	}
	private void renderConfigoverview(IRequest req, StringBuffer sb) {
		sb.append (""<b>FreeCS-Config Overview</b><br>"");
		sb.append (""<table class=mainTable>"");
		 sb.append(""<td class=name>"");
		 sb.append(""System: "");
		 sb.append(""</td>"");
		 sb.append(""<td class=param>"");
		 if (System.getProperty(""java.version"") != null) sb.append(System.getProperty(""java.version""));
		 sb.append("" "");
		 if (System.getProperty(""os.name"") != null) sb.append(System.getProperty(""os.name""));
		 sb.append("" "");
		 if (System.getProperty(""os.version"") != null) sb.append(System.getProperty(""os.version""));
		 sb.append("" "");
		 sb.append(""</td>"");
		 sb.append(""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Plugin: "");
		sb.append (""</td>"");
		 int r = 1;
		 for (Iterator<String> i = Server.srv.pluginStore.keySet() .iterator();
		 i.hasNext();
		) {
			 String key = (String) i.next();
			 sb.append(""<td class=param>"");
			 sb.append(key);
			 sb.append(""</td>"");
			 r++;
			 if (r >= 6){
				 r=0;
				 sb.append(""</tr>"");
				 sb.append(""<tr>"");
				 sb.append(""<td class=param>"");
				 sb.append(""</td>"");
			 }
		 }
		 for (Iterator<String> i = GroupManager.mgr.getGroupPlugins().keySet() .iterator();
		 i.hasNext();
		) {
			 String key = (String) i.next();
			 sb.append(""<td class=param>"");
			 sb.append(key);
			 sb.append(""</td>"");
			 r++;
			 if (r >= 6){
				 r=0;
				 sb.append(""</tr>"");
				 sb.append(""<tr>"");
				 sb.append(""<td class=param>"");
				 sb.append(""</td>"");
			 }
		 }
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""maxUsers: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MAX_USERS);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Usertimeout: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.USER_TIMEOUT == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.USER_TIMEOUT/60000+"" min"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Userawaytimeout: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.USER_AWAY_TIMEOUT == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.USER_AWAY_TIMEOUT/60000+"" min"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Viptimeout: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.VIP_TIMEOUT == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else if (Server.srv.VIP_TIMEOUT == 0)sb.append (""same as User"");
		else sb.append (Server.srv.VIP_TIMEOUT/60000+"" min"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append(""<tr>"");
		 sb.append(""<td class=name>"");
		 sb.append(""VipAwaytimeout: "");
		 sb.append(""</td>"");
		 sb.append(""<td class=param>"");
		 if (Server.srv.VIP_AWAY_TIMEOUT == -1) {
			 sb.append(""<img src =\""../static/no.gif\"">"");
		 }
		 else if (Server.srv.VIP_AWAY_TIMEOUT == 0) {
			 sb.append(""same as User"");
		 }
		 else {
			 sb.append(Server.srv.VIP_AWAY_TIMEOUT / 60000 + "" min"");
		 }
		 sb.append(""</td>"");
		 sb.append(""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Suusers: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MAX_SUUSERS_PER_STARTGROUP);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Groupnamelength: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.MAX_GROUPNAME_LENGTH == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.MAX_GROUPNAME_LENGTH);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Groupthemelength: "");
		 sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.MAX_GROUPTHEME_LENGTH == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.MAX_GROUPTHEME_LENGTH);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Banduration: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MAX_BAN_DURATION+"" min"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Floodbanduration: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.FLOOD_BAN_DURATION+"" millis"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Floodprotectmillis: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.FLOOD_PROTECT_MILLIS);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Floodprotecttoleranc: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.FLOOD_PROTECT_TOLERANC);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Toolbanduration: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.TOOL_BAN_DURATION+"" millis"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Toolprotectcounter: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.TOOL_PROTECT_COUNTER);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Toolprotecttoleranc: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.TOOL_PROTECT_TOLERANC);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Toolprotectminmills: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.TOOL_PROTECT_MINMILLS);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Toolprotectmincounter: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.TOOL_PROTECT_MINCOUNTER);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Max Su Banduration: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.MAX_SU_BAN_DURATION == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.MAX_SU_BAN_DURATION).append("" min"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Punish Duration: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.PUNISH_DURATION == -1)sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.PUNISH_DURATION /1000).append("" sec"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		 sb.append (""<tr>"");
		 sb.append (""<td class=name>"");
		 sb.append (""Lock Duration: "");
		 sb.append( ""</td>"");
		 sb.append (""<td class=param>"");
		 if (Server.srv.MAX_FLOCK_DURATION == -1) {
			 sb.append(""<img src =\""../static/no.gif\"">"");
		 }
		 else {
			 sb.append(Server.srv.MAX_FLOCK_DURATION).append("" min"");
		 }
		 sb.append (""</td>"");
		 sb.append (""</tr>"");
		sb.append (""<td class=name>"");
		sb.append (""<b>Use Trafficmonitor:</b> "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.USE_TRAFFIC_MONITOR) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""maxRequestsPerProxy:"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MAX_REQUESTS_PER_PROXY_IP);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""maxRequestsPerIP:"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MAX_REQUESTS_PER_IP);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Startgroups/Theme: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		 String sgroups = Server.srv.props.getProperty(""startgroups"");
		 String sgNames[] = sgroups.split("","");
		 for (int i = 0;
		 i < sgNames.length;
		 i++) {
			 int pos = sgNames[i].indexOf(""/"");
			 String[] c = sgNames[i].split(""/"");
			 String key = c[0].trim().toLowerCase();
			 if (key.equals(""exil"")) {
				 continue;
			 }
			 if (Server.srv.USE_PLUGINS && Server.srv.serverPlugin!=null) {
				 IServerPlugin [] svp = Server.srv.serverPlugin;
				 if (svp !=null) {
					 String gName = null;
					 for (int s = 0;
					 s<svp.length;
					 s++) {
						 try {
							 gName = svp[s].convertGroupname(key);
						 }
						 catch (Exception e) {
							 Server.debug (svp[s], ""catched exception from plugin"", e, Server.MSG_ERROR, Server.LVL_MINOR);
						 }
					 }
					 sb.append(gName);
				 }
			 }
			 else {
				 sb.append(key);
			 }
			 if (c.length > 1) {
				 String theme = sgNames[i].substring(pos + 1);
				 if (Server.srv.USE_PLUGINS && Server.srv.serverPlugin!=null) {
					 String gTheme = null;
					 IServerPlugin [] svp = Server.srv.serverPlugin;
					 if (svp !=null) {
						 for (int s = 0;
						 s<svp.length;
						 s++) {
							 try {
								 gTheme = svp[s].convertGroutheme(theme);
							 }
							 catch (Exception e) {
								 Server.debug (svp[s], ""catched exception from plugin"", e, Server.MSG_ERROR, Server.LVL_MINOR);
							 }
						 }
						 sb.append(""("").append(gTheme).append("")"");
					 }
				 }
				 else {
					 sb.append(""("").append(theme).append("")"");
				 }
			 }
			 sb.append(""</td>"");
			 if (i < sgNames.length - 1) {
				 sb.append(""<td class=param>"");
			 }
		 }
		 sb.append(""</tr>"");
		 sb.append(""<tr>"");
		 sb.append(""<td class=name>"");
		 sb.append(""<b>use Plugins: </>"");
		 sb.append(""</td>"");
		 sb.append(""<td class=param>"");
		 if (Server.srv.USE_PLUGINS) {
			 sb.append(""<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""</td>"");
		 sb.append(""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""<b>use BBC: </>"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.USE_BBC) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""bbcConvertGroupname: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.BBC_CONVERT_GROUPNAME) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""bbcConvertGrouptheme: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.BBC_CONVERT_GROUPTHEME) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""maxBBCTags: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MAX_BBCTAGS);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>Font</b>RightEntrace: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_FONT_RIGHT_ENTRACE);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>Font</b>RightSepa: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_FONT_RIGHT_SEPA);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>B</b>RightEntrace: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_B_RIGHT_ENTRACE);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>B</b>RightSepa: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_B_RIGHT_SEPA);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>I</b>RightEntrace: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_I_RIGHT_ENTRACE);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>I</b>RightSepa: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_I_RIGHT_SEPA);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>U</b>RightEntrace: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_U_RIGHT_ENTRACE);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""minBbc<b>U</b>RightSepa: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.MIN_BBC_U_RIGHT_SEPA);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""<b>canDelLogs: </>"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.CAN_DEL_LOGS) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""logfileDelhour: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.LOGFILE_DELHOUR);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""logfileDeldays: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.LOGFILE_DELDAYS);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""<b>Use Fadecolor:</b> "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.USE_FADECOLOR) sb.append (""<img src =\""../static/ok.gif\"">"");
		else sb.append (""<img src =\""../static/no.gif\"">"");
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""<b>Colorlock: </b>"");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.COLOR_LOCK_MODE == 0) sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.COLOR_LOCK_MODE);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Locklevel: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		sb.append (Server.srv.COLOR_LOCK_LEVEL);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""<tr>"");
		sb.append (""<td class=name>"");
		sb.append (""Fadelocklevel: "");
		sb.append (""</td>"");
		sb.append (""<td class=param>"");
		if (Server.srv.FADECOLOR_LOCK_LEVEL == -1) sb.append (""<img src =\""../static/no.gif\"">"");
		else sb.append (Server.srv.FADECOLOR_LOCK_LEVEL);
		sb.append (""</td>"");
		sb.append (""</tr>"");
		sb.append (""</table>"");
	}
	private void renderTemplate(IRequest req, String name, StringBuffer sb) {
		sb.append(renderTemplate(req, name));
	}
	private String renderTemplate(IRequest req, String name) {
		 TemplateSet ts = Server.srv.templatemanager.getTemplateSet (""admin"");
		 Template tpl = ts.getTemplate (name);
		 if (tpl == null){
			 Server.log(this, ""File ""+name+"" not loaded"", Server.MSG_ERROR, Server.LVL_MAJOR);
			 return """";
		 }
		 return tpl.render(req);
	}
	 private String may_set_Theme(User u) {
		 StringBuffer sb = new StringBuffer(""\r\n<td class=name>"");
		 sb.append(""\r\nSet Theme"");
		 sb.append(""\r\n<td class=param>"");
		 if (u.hasRight(IUserStates.MAY_SET_THEME)) {
			 sb.append(""\r\n<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""\r\n<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td>"");
		 return sb.toString();
	 }
	 private String may_use_Smiley(User u) {
		 StringBuffer sb = new StringBuffer(""\r\n<td class=name>"");
		 sb.append(""\r\nSM"");
		 sb.append(""\r\n<td class=param>"");
		 if (u.hasRight(IUserStates.MAY_USE_SMILEY)) {
			 sb.append(""\r\n<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""\r\n<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td>"");
		 return sb.toString();
	 }
	 private String may_call_Memberships(User u) {
		 StringBuffer sb = new StringBuffer(""\r\n<td class=name>"");
		 sb.append(""\r\nMcall"");
		 sb.append(""\r\n<td class=param>"");
		 if (u.hasRight(IUserStates.MAY_CALL_MEMBERSHIPS)) {
			 sb.append(""\r\n<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""\r\n<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td>"");
		 return sb.toString();
	 }
	 private String has_Right(User u,int right,String rname) {
		 String displayName = null;
		 if (rname.equals(""moderator"")){
			 displayName = ""mod"";
		 }
		 else displayName = rname;
		 StringBuffer sb = new StringBuffer(""\r\n<td class=name>"");
		 sb.append(displayName.toUpperCase());
		 sb.append(""\r\n<td class=param>"");
		 if (u.hasDefaultRight(right)) {
			 sb.append(""\r\n<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""\r\n<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td><td class=param>"");
		 if (u.hasRight(right)) {
			 sb.append(""\r\n<a href=\""/ADMIN?do=removeright&right="").append(rname). append(""&name="").append(u.getName().toLowerCase()) .append(""\""><img src =\""../static/ok.gif\"" border =\""0\"" alt=\""remove\""></a>"");
		 }
		 else {
			 sb.append(""\r\n<a href=\""/ADMIN?do=giveright&right="").append(rname). append(""&name="").append(u.getName().toLowerCase()) .append(""\""><img src =\""../static/no.gif\"" border =\""0\"" alt=\""give\""></a>"");
		 }
		 sb.append(""\r\n</td>"");
		 return sb.toString();
	 }
	 private String has_RightAsshole(User u,int right) {
		 StringBuffer sb = new StringBuffer(""\r\n<td class=name>"");
		 sb.append(""\r\nASSHOLE"");
		 sb.append(""\r\n<td class=param>"");
		 if (u.hasDefaultRight(right)) {
			 sb.append(""\r\n<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""\r\n<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td><td class=param>"");
		 if (u.hasRight(right)) {
			 sb.append(""\r\n<img src =\""../static/ok.gif\"">"");
		 }
		 else {
			 sb.append(""\r\n<img src =\""../static/no.gif\"">"");
		 }
		 sb.append(""\r\n</td>"");
		 return sb.toString();
	 }
 }",1,0,0,0
"public OutputStream writeToBlock(Block b) throws IOException {
	 if (isValidBlock(b)) {
		 throw new IOException(""Block "" + b + "" is valid, and cannot be written to."");
	 }
	 File f = null;
	 synchronized (ongoingCreates) {
		 if (ongoingCreates.contains(b)) {
			 throw new IOException(""Block "" + b + "" has already been started (though not completed), and thus cannot be created."");
		 }
		 if (getRemaining() < BLOCK_SIZE) {
			 throw new IOException(""Insufficient space for an additional block"");
		 }
		 ongoingCreates.add(b);
		 reserved += BLOCK_SIZE;
		 f = getTmpFile(b);
		 if (f.exists()) {
			 throw new IOException(""Unexpected problem in startBlock() for "" + b + "". File "" + f + "" should not be present, but is."");
		 }
	 }
	 if (!f.createNewFile()) {
		 throw new IOException(""Unexpected problem in startBlock() for "" + b + "". File "" + f + "" should be creatable, but is already present."");
	 }
	 return new FileOutputStream(f);
 }",0,0,0,0
"public void offerService() throws Exception {
	 long lastHeartbeat = 0, lastBlockReport = 0;
	 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
	 while (shouldRun) {
		 try {
			 long now = System.currentTimeMillis();
			 if (now - lastHeartbeat > HEARTBEAT_INTERVAL) {
				 BlockCommand cmd = namenode.sendHeartbeat(dnRegistration, data.getCapacity(), data.getRemaining(), xmitsInProgress, xceiverCount.getValue());
				 lastHeartbeat = now;
				 if( cmd != null ) {
					 data.checkDataDir();
					 if (cmd.transferBlocks()) {
						 Block blocks[] = cmd.getBlocks();
						 DatanodeInfo xferTargets[][] = cmd.getTargets();
						 for (int i = 0;
						 i < blocks.length;
						 i++) {
							 if (!data.isValidBlock(blocks[i])) {
								 String errStr = ""Can't send invalid block "" + blocks[i];
								 LOG.info(errStr);
								 namenode.errorReport( dnRegistration, DatanodeProtocol.INVALID_BLOCK, errStr);
								 break;
							 }
							 else {
								 if (xferTargets[i].length > 0) {
									 LOG.info(""Starting thread to transfer block "" + blocks[i] + "" to "" + xferTargets[i]);
									 new Daemon(new DataTransfer(xferTargets[i], blocks[i])).start();
								 }
							 }
						 }
					 }
					 else if (cmd.invalidateBlocks()) {
						 Block toDelete[] = cmd.getBlocks();
						 data.invalidate(toDelete);
						 myMetrics.removedBlocks(toDelete.length);
					 }
					 else if( cmd.shutdownNode()) {
						 this.shutdown();
						 continue;
					 }
				 }
			 }
			 if (now - lastBlockReport > blockReportInterval) {
				 data.checkDataDir();
				 Block toDelete[] = namenode.blockReport(dnRegistration, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			 }
			 Block [] blockArray=null;
			 synchronized( receivedBlockList ) {
				 if (receivedBlockList.size() > 0) {
					 blockArray = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
				 }
			 }
			 if( blockArray != null ) {
				 namenode.blockReceived( dnRegistration, blockArray );
				 synchronized (receivedBlockList) {
					 for(Block b: blockArray) {
						 receivedBlockList.remove(b);
					 }
				 }
			 }
			 long waitTime = HEARTBEAT_INTERVAL - (System.currentTimeMillis() - lastHeartbeat);
			 synchronized( receivedBlockList ) {
				 if (waitTime > 0 && receivedBlockList.size() == 0) {
					 try {
						 receivedBlockList.wait(waitTime);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
		 catch(DiskErrorException e) {
			 handleDiskError(e.getLocalizedMessage());
			 return;
		 }
		 catch( RemoteException re ) {
			 String reClass = re.getClassName();
			 if( UnregisteredDatanodeException.class.getName().equals( reClass )) {
				 LOG.warn( ""DataNode is shutting down: "" + StringUtils.stringifyException(re));
				 shutdown();
				 return;
			 }
			 LOG.warn(StringUtils.stringifyException(re));
		 }
		 catch (IOException e) {
			 LOG.warn(StringUtils.stringifyException(e));
		 }
	 }
 }",0,0,1,0
"public class UntypedResultSet implements Iterable<UntypedResultSet.Row>{
	 private final List<CqlRow> cqlRows;
	 public UntypedResultSet(List<CqlRow> cqlRows) {
		 this.cqlRows = cqlRows;
	 }
	 public Row one() {
		 if (cqlRows.size() != 1) throw new IllegalStateException(""One row required, "" + cqlRows.size() + "" found"");
		 return new Row(cqlRows.get(0));
	 }
	 public Iterator<Row> iterator() {
		 return new AbstractIterator<Row>() {
			 Iterator<CqlRow> iter = cqlRows.iterator();
			 protected Row computeNext() {
				 if (!iter.hasNext()) return endOfData();
				 return new Row(iter.next());
			 }
		 }
		;
	 }
	 public static class Row {
		 Map<String, ByteBuffer> data = new HashMap<String, ByteBuffer>();
		 public Row(CqlRow cqlRow) {
			 for (Column column : cqlRow.columns) data.put(UTF8Type.instance.compose(column.name), column.value);
		 }
		 public boolean has(String column) {
			 return data.get(column) != null;
		 }
		 public String getString(String column) {
			 return UTF8Type.instance.compose(data.get(column));
		 }
		 public boolean getBoolean(String column) {
			 return BooleanType.instance.compose(data.get(column));
		 }
		 public int getInt(String column) {
			 return Int32Type.instance.compose(data.get(column));
		 }
		 public double getDouble(String column) {
			 return DoubleType.instance.compose(data.get(column));
		 }
		 public ByteBuffer getBytes(String column) {
			 return data.get(column);
		 }
	 }
}",0,0,0,0
"public static ICompactSerializer2<BloomFilter> serializer() {
	 return serializer_;
 }",0,0,0,0
"public synchronized void start(BundleContext context) throws Exception {
	 PermissionAdminImpl pai = null;
	 SecureAction action = new SecureAction();
	 Permissions permissions = new Permissions(context, action);
	 File tmp = context.getDataFile(""security"" + File.separator + ""tmp"");
	 if ((tmp == null) || (!tmp.isDirectory() && !tmp.mkdirs())) {
		 throw new IOException(""Can't create tmp dir."");
	 }
	 File[] old = tmp.listFiles();
	 if (old != null) {
		 for (int i = 0;
		 i < old.length;
		 i++) {
			 old[i].delete();
		 }
	 }
	 if (""TRUE"".equalsIgnoreCase(getProperty(context, SecurityConstants.ENABLE_PERMISSIONADMIN_PROP, SecurityConstants.ENABLE_PERMISSIONADMIN_VALUE))) {
		 File cache = context.getDataFile(""security"" + File.separator + ""pa.txt"");
		 if ((cache == null) || (!cache.isFile() && !cache.createNewFile())) {
			 throw new IOException(""Can't create cache file"");
		 }
		 pai = new PermissionAdminImpl(permissions, new PropertiesCache( cache, tmp, action));
	 }
	 ConditionalPermissionAdminImpl cpai = null;
	 if (""TRUE"".equalsIgnoreCase(getProperty(context, SecurityConstants.ENABLE_CONDPERMADMIN_PROP, SecurityConstants.ENABLE_CONDPERMADMIN_VALUE))) {
		 File cpaCache = context.getDataFile(""security"" + File.separator + ""cpa.txt"");
		 if ((cpaCache == null) || (!cpaCache.isFile() && !cpaCache.createNewFile())) {
			 throw new IOException(""Can't create cache file"");
		 }
		 LocalPermissions localPermissions = new LocalPermissions( permissions);
		 cpai = new ConditionalPermissionAdminImpl(permissions, new Conditions(action), localPermissions, new PropertiesCache( cpaCache, tmp, action), pai);
	 }
	 if ((pai != null) || (cpai != null)) {
		 String crlList = getProperty(context, SecurityConstants.CRL_FILE_PROP, SecurityConstants.CRL_FILE_VALUE);
		 String storeList = getProperty(context, SecurityConstants.KEYSTORE_FILE_PROP, SecurityConstants.KEYSTORE_FILE_VALUE);
		 String passwdList = getProperty(context, SecurityConstants.KEYSTORE_PASS_PROP, SecurityConstants.KEYSTORE_PASS_VALUE);
		 String typeList = getProperty(context, SecurityConstants.KEYSTORE_TYPE_PROP, SecurityConstants.KEYSTORE_TYPE_VALUE);
		 String osgi_keystores = getProperty(context, Constants.FRAMEWORK_TRUST_REPOSITORIES, null);
		 if (osgi_keystores != null) {
			 StringTokenizer tok = new StringTokenizer(osgi_keystores, File.pathSeparator);
			 if (storeList.length() == 0) {
				 storeList += ""file:"" + tok.nextToken();
				 passwdList += "" "";
				 typeList += ""JKS"";
			 }
			 while (tok.hasMoreTokens()) {
				 storeList += ""|file:"" + tok.nextToken();
				 passwdList += ""| "";
				 typeList += ""|JKS"";
			 }
		 }
		 StringTokenizer storeTok = new StringTokenizer(storeList, ""|"");
		 StringTokenizer passwdTok = new StringTokenizer(passwdList, ""|"");
		 StringTokenizer typeTok = new StringTokenizer(typeList, ""|"");
		 if ((storeTok.countTokens() != typeTok.countTokens()) || (passwdTok.countTokens() != storeTok.countTokens())) {
			 throw new BundleException( ""Each CACerts keystore must have one type and one passwd entry and vice versa."");
		 }
		 SecurityProvider provider = new SecurityProviderImpl(crlList, typeList, passwdList, storeList, pai, cpai, action, ((Felix) context.getBundle(0)).getLogger());
		 ((Felix) context.getBundle(0)).setSecurityProvider(provider);
	 }
	 if (pai != null) {
		 context.registerService(PermissionAdmin.class.getName(), pai, null);
	 }
	 if (cpai != null) {
		 context.registerService(ConditionalPermissionAdmin.class.getName(), cpai, null);
	 }
 }",0,0,1,0
"public class SSTableWriter extends SSTable{
	 private static Logger logger = LoggerFactory.getLogger(SSTableWriter.class);
	 private IndexWriter iwriter;
	 private SegmentedFile.Builder dbuilder;
	 private final BufferedRandomAccessFile dataFile;
	 private DecoratedKey lastWrittenKey;
	 private FileMark dataMark;
	 public SSTableWriter(String filename, long keyCount) throws IOException {
		 this(filename, keyCount, DatabaseDescriptor.getCFMetaData(Descriptor.fromFilename(filename)), StorageService.getPartitioner(), ReplayPosition.NONE);
	 }
	 public SSTableWriter(String filename, long keyCount, CFMetaData metadata, IPartitioner partitioner, ReplayPosition replayPosition) throws IOException {
		 super(Descriptor.fromFilename(filename), new HashSet<Component>(Arrays.asList(Component.DATA, Component.FILTER, Component.PRIMARY_INDEX, Component.STATS)), metadata, replayPosition, partitioner, SSTable.defaultRowHistogram(), SSTable.defaultColumnHistogram());
		 iwriter = new IndexWriter(descriptor, partitioner, keyCount);
		 dbuilder = SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());
		 dataFile = new BufferedRandomAccessFile(new File(getFilename()), ""rw"", BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE, true);
	 }
	 public void mark() {
		 dataMark = dataFile.mark();
		 iwriter.mark();
	 }
	 public void reset() {
		 try {
			 dataFile.reset(dataMark);
			 iwriter.reset();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 private long beforeAppend(DecoratedKey decoratedKey) throws IOException {
		 if (decoratedKey == null) {
			 throw new IOException(""Keys must not be null."");
		 }
		 if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) > 0) {
			 logger.info(""Last written key : "" + lastWrittenKey);
			 logger.info(""Current key : "" + decoratedKey);
			 logger.info(""Writing into file "" + getFilename());
			 throw new IOException(""Keys must be written in ascending order."");
		 }
		 return (lastWrittenKey == null) ? 0 : dataFile.getFilePointer();
	 }
	 private void afterAppend(DecoratedKey decoratedKey, long dataPosition) throws IOException {
		 lastWrittenKey = decoratedKey;
		 if (logger.isTraceEnabled()) logger.trace(""wrote "" + decoratedKey + "" at "" + dataPosition);
		 iwriter.afterAppend(decoratedKey, dataPosition);
		 dbuilder.addPotentialBoundary(dataPosition);
	 }
	 public long append(AbstractCompactedRow row) throws IOException {
		 long currentPosition = beforeAppend(row.key);
		 ByteBufferUtil.writeWithShortLength(row.key.key, dataFile);
		 row.write(dataFile);
		 estimatedRowSize.add(dataFile.getFilePointer() - currentPosition);
		 estimatedColumnCount.add(row.columnCount());
		 afterAppend(row.key, currentPosition);
		 return currentPosition;
	 }
	 public void append(DecoratedKey decoratedKey, ColumnFamily cf) throws IOException {
		 long startPosition = beforeAppend(decoratedKey);
		 ByteBufferUtil.writeWithShortLength(decoratedKey.key, dataFile);
		 long sizePosition = dataFile.getFilePointer();
		 dataFile.writeLong(-1);
		 int columnCount = ColumnFamily.serializer().serializeWithIndexes(cf, dataFile);
		 long endPosition = dataFile.getFilePointer();
		 dataFile.seek(sizePosition);
		 long dataSize = endPosition - (sizePosition + 8);
		 assert dataSize > 0;
		 dataFile.writeLong(dataSize);
		 dataFile.seek(endPosition);
		 afterAppend(decoratedKey, startPosition);
		 estimatedRowSize.add(endPosition - startPosition);
		 estimatedColumnCount.add(columnCount);
	 }
	 public void append(DecoratedKey decoratedKey, ByteBuffer value) throws IOException {
		 long currentPosition = beforeAppend(decoratedKey);
		 ByteBufferUtil.writeWithShortLength(decoratedKey.key, dataFile);
		 assert value.remaining() > 0;
		 dataFile.writeLong(value.remaining());
		 ByteBufferUtil.write(value, dataFile);
		 afterAppend(decoratedKey, currentPosition);
	 }
	 public SSTableReader closeAndOpenReader() throws IOException {
		 return closeAndOpenReader(System.currentTimeMillis());
	 }
	 public SSTableReader closeAndOpenReader(long maxDataAge) throws IOException {
		 iwriter.close();
		 long position = dataFile.getFilePointer();
		 dataFile.close();
		 FileUtils.truncate(dataFile.getPath(), position);
		 writeMetadata(descriptor, estimatedRowSize, estimatedColumnCount, replayPosition);
		 final Descriptor newdesc = rename(descriptor, components);
		 SegmentedFile ifile = iwriter.builder.complete(newdesc.filenameFor(SSTable.COMPONENT_INDEX));
		 SegmentedFile dfile = dbuilder.complete(newdesc.filenameFor(SSTable.COMPONENT_DATA));
		 SSTableReader sstable = SSTableReader.internalOpen(newdesc, components, metadata, replayPosition, partitioner, ifile, dfile, iwriter.summary, iwriter.bf, maxDataAge, estimatedRowSize, estimatedColumnCount);
		 iwriter = null;
		 dbuilder = null;
		 return sstable;
	 }
	 private static void writeMetadata(Descriptor desc, EstimatedHistogram rowSizes, EstimatedHistogram columnCounts, ReplayPosition rp) throws IOException {
		 BufferedRandomAccessFile out = new BufferedRandomAccessFile(new File(desc.filenameFor(SSTable.COMPONENT_STATS)), ""rw"", BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE, true);
		 EstimatedHistogram.serializer.serialize(rowSizes, out);
		 EstimatedHistogram.serializer.serialize(columnCounts, out);
		 ReplayPosition.serializer.serialize(rp, out);
		 out.close();
	 }
	 static Descriptor rename(Descriptor tmpdesc, Set<Component> components) {
		 Descriptor newdesc = tmpdesc.asTemporary(false);
		 try {
			 for (Component component : Sets.difference(components, Collections.singleton(Component.DATA))) FBUtilities.renameWithConfirm(tmpdesc.filenameFor(component), newdesc.filenameFor(component));
			 FBUtilities.renameWithConfirm(tmpdesc.filenameFor(Component.DATA), newdesc.filenameFor(Component.DATA));
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 return newdesc;
	 }
	 public long getFilePointer() {
		 return dataFile.getFilePointer();
	 }
	 public static Builder createBuilder(Descriptor desc, OperationType type) {
		 if (!desc.isLatestVersion) throw new RuntimeException(String.format(""Cannot recover SSTable %s due to version mismatch. (current version is %s)."", desc.toString() , Descriptor.CURRENT_VERSION));
		 return new Builder(desc, type);
	 }
	 public static class Builder implements CompactionInfo.Holder {
		 private final Descriptor desc;
		 private final OperationType type;
		 private final ColumnFamilyStore cfs;
		 private RowIndexer indexer;
		 public Builder(Descriptor desc, OperationType type) {
			 this.desc = desc;
			 this.type = type;
			 cfs = Table.open(desc.ksname).getColumnFamilyStore(desc.cfname);
		 }
		 public CompactionInfo getCompactionInfo() {
			 maybeOpenIndexer();
			 try {
				 return new CompactionInfo(desc.ksname, desc.cfname, CompactionType.SSTABLE_BUILD, indexer.dfile.getFilePointer(), indexer.dfile.length());
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
		 private void maybeOpenIndexer() {
			 if (indexer != null) return;
			 try {
				 if (cfs.metadata.getDefaultValidator().isCommutative()) indexer = new CommutativeRowIndexer(desc, cfs, type);
				 else indexer = new RowIndexer(desc, cfs, type);
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
		 public SSTableReader build() throws IOException {
			 if (cfs.isInvalid()) return null;
			 maybeOpenIndexer();
			 File ifile = new File(desc.filenameFor(SSTable.COMPONENT_INDEX));
			 File ffile = new File(desc.filenameFor(SSTable.COMPONENT_FILTER));
			 assert !ifile.exists();
			 assert !ffile.exists();
			 long estimatedRows = indexer.prepareIndexing();
			 long rows = indexer.index();
			 logger.debug(""estimated row count was {
			}
			 of real count"", ((double)estimatedRows) / rows);
			 return SSTableReader.open(rename(desc, SSTable.componentsFor(desc, false)));
		 }
	 }
	 static class RowIndexer {
		 protected final Descriptor desc;
		 public final BufferedRandomAccessFile dfile;
		 private final OperationType type;
		 protected IndexWriter iwriter;
		 protected ColumnFamilyStore cfs;
		 RowIndexer(Descriptor desc, ColumnFamilyStore cfs, OperationType type) throws IOException {
			 this(desc, new BufferedRandomAccessFile(new File(desc.filenameFor(SSTable.COMPONENT_DATA)), ""r"", 8 * 1024 * 1024, true), cfs, type);
		 }
		 protected RowIndexer(Descriptor desc, BufferedRandomAccessFile dfile, ColumnFamilyStore cfs, OperationType type) throws IOException {
			 this.desc = desc;
			 this.dfile = dfile;
			 this.type = type;
			 this.cfs = cfs;
		 }
		 long prepareIndexing() throws IOException {
			 long estimatedRows;
			 try {
				 estimatedRows = SSTable.estimateRowsFromData(desc, dfile);
				 iwriter = new IndexWriter(desc, StorageService.getPartitioner(), estimatedRows);
				 return estimatedRows;
			 }
			 catch(IOException e) {
				 dfile.close();
				 throw e;
			 }
		 }
		 long index() throws IOException {
			 try {
				 return doIndexing();
			 }
			 finally {
				 try {
					 close();
				 }
				 catch (IOException e) {
					 throw new IOError(e);
				 }
			 }
		 }
		 void close() throws IOException {
			 dfile.close();
			 iwriter.close();
		 }
		 protected void updateCache(DecoratedKey key, long dataSize, AbstractCompactedRow row) throws IOException {
			 ColumnFamily cached = cfs.getRawCachedRow(key);
			 if (cached != null) {
				 switch (type) {
					 case AES: if (dataSize > DatabaseDescriptor.getInMemoryCompactionLimit()) {
						 logger.warn(""Found a cached row over the in memory compaction limit during post-streaming rebuilt;
						 it is highly recommended to avoid huge row on column family with row cache enabled."");
						 cfs.invalidateCachedRow(key);
					 }
					 else {
						 ColumnFamily cf;
						 if (row == null) {
							 long position = dfile.getFilePointer();
							 cf = ColumnFamily.create(cfs.metadata);
							 ColumnFamily.serializer().deserializeColumns(dfile, cf, true, true);
							 dfile.seek(position);
						 }
						 else {
							 assert row instanceof PrecompactedRow;
							 cf = ((PrecompactedRow)row).getFullColumnFamily();
						 }
						 cfs.updateRowCache(key, cf);
					 }
					 break;
					 default: cfs.invalidateCachedRow(key);
					 break;
				 }
			 }
		 }
		 protected long doIndexing() throws IOException {
			 EstimatedHistogram rowSizes = SSTable.defaultRowHistogram();
			 EstimatedHistogram columnCounts = SSTable.defaultColumnHistogram();
			 long rows = 0;
			 DecoratedKey key;
			 long rowPosition = 0;
			 while (rowPosition < dfile.length()) {
				 key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));
				 iwriter.afterAppend(key, rowPosition);
				 long dataSize = SSTableReader.readRowSize(dfile, desc);
				 rowPosition = dfile.getFilePointer() + dataSize;
				 IndexHelper.skipBloomFilter(dfile);
				 IndexHelper.skipIndex(dfile);
				 ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
				 updateCache(key, dataSize, null);
				 rowSizes.add(dataSize);
				 columnCounts.add(dfile.readInt());
				 dfile.seek(rowPosition);
				 rows++;
			 }
			 writeMetadata(desc, rowSizes, columnCounts, ReplayPosition.NONE);
			 return rows;
		 }
	 }
	 static class CommutativeRowIndexer extends RowIndexer {
		 protected BufferedRandomAccessFile writerDfile;
		 CommutativeRowIndexer(Descriptor desc, ColumnFamilyStore cfs, OperationType type) throws IOException {
			 super(desc, new BufferedRandomAccessFile(new File(desc.filenameFor(SSTable.COMPONENT_DATA)), ""r"", 8 * 1024 * 1024, true), cfs, type);
			 writerDfile = new BufferedRandomAccessFile(new File(desc.filenameFor(SSTable.COMPONENT_DATA)), ""rw"", 8 * 1024 * 1024, true);
		 }
		 protected long doIndexing() throws IOException {
			 EstimatedHistogram rowSizes = SSTable.defaultRowHistogram();
			 EstimatedHistogram columnCounts = SSTable.defaultColumnHistogram();
			 long rows = 0L;
			 DecoratedKey key;
			 CompactionController controller = new CompactionController(cfs, Collections.<SSTableReader>emptyList(), Integer.MAX_VALUE, true);
			 while (!dfile.isEOF()) {
				 key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));
				 long dataSize = SSTableReader.readRowSize(dfile, desc);
				 SSTableIdentityIterator iter = new SSTableIdentityIterator(cfs.metadata, dfile, key, dfile.getFilePointer(), dataSize, true);
				 AbstractCompactedRow row = controller.getCompactedRow(iter);
				 updateCache(key, dataSize, row);
				 rowSizes.add(dataSize);
				 columnCounts.add(row.columnCount());
				 iwriter.afterAppend(key, writerDfile.getFilePointer());
				 ByteBufferUtil.writeWithShortLength(key.key, writerDfile);
				 row.write(writerDfile);
				 rows++;
			 }
			 writeMetadata(desc, rowSizes, columnCounts, ReplayPosition.NONE);
			 if (writerDfile.getFilePointer() != dfile.getFilePointer()) {
				 writerDfile.setLength(writerDfile.getFilePointer());
			 }
			 writerDfile.sync();
			 return rows;
		 }
		 void close() throws IOException {
			 super.close();
			 writerDfile.close();
		 }
	 }
	 static class IndexWriter {
		 private final BufferedRandomAccessFile indexFile;
		 public final Descriptor desc;
		 public final IPartitioner partitioner;
		 public final SegmentedFile.Builder builder;
		 public final IndexSummary summary;
		 public final BloomFilter bf;
		 private FileMark mark;
		 IndexWriter(Descriptor desc, IPartitioner part, long keyCount) throws IOException {
			 this.desc = desc;
			 this.partitioner = part;
			 indexFile = new BufferedRandomAccessFile(new File(desc.filenameFor(SSTable.COMPONENT_INDEX)), ""rw"", 8 * 1024 * 1024, true);
			 builder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
			 summary = new IndexSummary(keyCount);
			 bf = BloomFilter.getFilter(keyCount, 15);
		 }
		 public void afterAppend(DecoratedKey key, long dataPosition) throws IOException {
			 bf.add(key.key);
			 long indexPosition = indexFile.getFilePointer();
			 ByteBufferUtil.writeWithShortLength(key.key, indexFile);
			 indexFile.writeLong(dataPosition);
			 if (logger.isTraceEnabled()) logger.trace(""wrote index of "" + key + "" at "" + indexPosition);
			 summary.maybeAddEntry(key, indexPosition);
			 builder.addPotentialBoundary(indexPosition);
		 }
		 public void close() throws IOException {
			 FileOutputStream fos = new FileOutputStream(desc.filenameFor(SSTable.COMPONENT_FILTER));
			 DataOutputStream stream = new DataOutputStream(fos);
			 BloomFilter.serializer().serialize(bf, stream);
			 stream.flush();
			 fos.getFD().sync();
			 stream.close();
			 long position = indexFile.getFilePointer();
			 indexFile.close();
			 FileUtils.truncate(indexFile.getPath(), position);
			 summary.complete();
		 }
		 public void mark() {
			 mark = indexFile.mark();
		 }
		 public void reset() throws IOException {
			 indexFile.reset(mark);
		 }
	 }
}",0,0,0,0
"public class ResourceStreamLocator implements IResourceStreamLocator{
	private static final Logger log = LoggerFactory.getLogger(ResourceStreamLocator.class);
	private IResourceFinder finder;
	public ResourceStreamLocator(){
	}
	public ResourceStreamLocator(final IResourceFinder finder){
		this.finder = finder;
	}
	public IResourceStream locate(final Class<?> clazz, final String path){
		IResourceStream stream = locateByResourceFinder(clazz, path);
		if (stream != null){
			return stream;
		}
		stream = locateByClassLoader(clazz, path);
		if (stream != null){
			return stream;
		}
		return null;
	}
	public IResourceStream locate(final Class<?> clazz, String path, final String style,final Locale locale, final String extension){
		ResourceNameIterator iter = new ResourceNameIterator(path, style, locale, extension);
		while (iter.hasNext()){
			String newPath = iter.next();
			IResourceStream stream = locate(clazz, newPath);
			if (stream != null){
				stream.setLocale(iter.getLocale());
				return stream;
			}
		}
		return null;
	}
	protected IResourceStream locateByClassLoader(final Class<?> clazz, final String path){
		IResourceStream resourceStream = null;
		if (clazz != null){
			resourceStream = getResourceStream(clazz.getClassLoader(), path);
			if (resourceStream != null){
				return resourceStream;
			}
		}
		resourceStream = getResourceStream(Thread.currentThread().getContextClassLoader(), path);
		if (resourceStream != null){
			return resourceStream;
		}
		resourceStream = getResourceStream(getClass().getClassLoader(), path);
		if (resourceStream != null){
			return resourceStream;
		}
		return null;
	}
	private IResourceStream getResourceStream(final ClassLoader classLoader, final String path){
		if (classLoader == null){
			return null;
		}
		if (log.isDebugEnabled()){
			log.debug(""Attempting to locate resource '"" + path + ""' using classloader "" +classLoader);
		}
		final URL url = classLoader.getResource(path);
		if (url != null){
			return new UrlResourceStream(url);
		}
		return null;
	}
	protected IResourceStream locateByResourceFinder(final Class<?> clazz, final String path){
		if (finder == null){
			finder = Application.get().getResourceSettings().getResourceFinder();
		}
		if (log.isDebugEnabled()){
			log.debug(""Attempting to locate resource '"" + path + ""' on path "" + finder);
		}
		return finder.find(clazz, path);
	}
}",0,0,0,0
",}
)public class SubtaskCheckpointStatistics {
public static final String FIELD_NAME_INDEX = ""index"";
public static final String FIELD_NAME_CHECKPOINT_STATUS = ""status"";
private final int index;
private final String checkpointStatus;
private SubtaskCheckpointStatistics( int index, String checkpointStatus) {
	this.index = index;
	this.checkpointStatus = checkpointStatus;
}
public int getIndex() {
	return index;
}
public String getCheckpointStatus() {
	return checkpointStatus;
}
public boolean equals(Object o) {
	if (this == o) {
		return true;
	}
	if (o == null || getClass() != o.getClass()) {
		return false;
	}
	SubtaskCheckpointStatistics that = (SubtaskCheckpointStatistics) o;
	return index == that.index &&Objects.equals(checkpointStatus, that.checkpointStatus);
}
public int hashCode() {
	return Objects.hash(index, checkpointStatus);
}
public static final class CompletedSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {
	public static final String FIELD_NAME_ACK_TIMESTAMP = ""ack_timestamp"";
	public static final String FIELD_NAME_DURATION = ""end_to_end_duration"";
	public static final String FIELD_NAME_STATE_SIZE = ""state_size"";
	public static final String FIELD_NAME_CHECKPOINT_DURATION = ""checkpoint"";
	public static final String FIELD_NAME_ALIGNMENT = ""alignment"";
	private final long ackTimestamp;
	private final long duration;
	private final long stateSize;
	private final CheckpointDuration checkpointDuration;
	private final CheckpointAlignment alignment;
	public CompletedSubtaskCheckpointStatistics( int index, long ackTimestamp, long duration, long stateSize, CheckpointDuration checkpointDuration, CheckpointAlignment alignment) {
		super(index, ""completed"");
		this.ackTimestamp = ackTimestamp;
		this.duration = duration;
		this.stateSize = stateSize;
		this.checkpointDuration = checkpointDuration;
		this.alignment = alignment;
	}
	public long getAckTimestamp() {
		return ackTimestamp;
	}
	public long getDuration() {
		return duration;
	}
	public long getStateSize() {
		return stateSize;
	}
	public CheckpointDuration getCheckpointDuration() {
		return checkpointDuration;
	}
	public CheckpointAlignment getAlignment() {
		return alignment;
	}
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		CompletedSubtaskCheckpointStatistics that = (CompletedSubtaskCheckpointStatistics) o;
		return ackTimestamp == that.ackTimestamp &&duration == that.duration &&stateSize == that.stateSize &&Objects.equals(checkpointDuration, that.checkpointDuration) &&Objects.equals(alignment, that.alignment);
	}
	public int hashCode() {
		return Objects.hash(ackTimestamp, duration, stateSize, checkpointDuration, alignment);
	}
	public static final class CheckpointDuration {
		public static final String FIELD_NAME_SYNC_DURATION = ""sync"";
		public static final String FIELD_NAME_ASYNC_DURATION = ""async"";
		private final long syncDuration;
		private final long asyncDuration;
		public CheckpointDuration( long syncDuration, long asyncDuration) {
			this.syncDuration = syncDuration;
			this.asyncDuration = asyncDuration;
		}
		public long getSyncDuration() {
			return syncDuration;
		}
		public long getAsyncDuration() {
			return asyncDuration;
		}
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (o == null || getClass() != o.getClass()) {
				return false;
			}
			CheckpointDuration that = (CheckpointDuration) o;
			return syncDuration == that.syncDuration &&asyncDuration == that.asyncDuration;
		}
		public int hashCode() {
			return Objects.hash(syncDuration, asyncDuration);
		}
	}
	public static final class CheckpointAlignment {
		public static final String FIELD_NAME_ALIGNMENT_BUFFERED = ""buffered"";
		public static final String FIELD_NAME_ALIGNMENT_DURATION = ""duration"";
		private final long alignmentBuffered;
		private final long alignmentDuration;
		public CheckpointAlignment( long alignmentBuffered, long alignmentDuration) {
			this.alignmentBuffered = alignmentBuffered;
			this.alignmentDuration = alignmentDuration;
		}
		public long getAlignmentBuffered() {
			return alignmentBuffered;
		}
		public long getAlignmentDuration() {
			return alignmentDuration;
		}
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (o == null || getClass() != o.getClass()) {
				return false;
			}
			CheckpointAlignment that = (CheckpointAlignment) o;
			return alignmentBuffered == that.alignmentBuffered &&alignmentDuration == that.alignmentDuration;
		}
		public int hashCode() {
			return Objects.hash(alignmentBuffered, alignmentDuration);
		}
	}
}
public static final class PendingSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {
	public PendingSubtaskCheckpointStatistics( int index) {
		super(index, ""pending_or_failed"");
	}
}
}",1,1,0,0
"abstract class FastByteComparisons {
	 public static int compareTo(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
		 return LexicographicalComparerHolder.BEST_COMPARER.compareTo( b1, s1, l1, b2, s2, l2);
	 }
	 private interface Comparer<T> {
		 abstract public int compareTo(T buffer1, int offset1, int length1, T buffer2, int offset2, int length2);
	 }
	 private static Comparer<byte[]> lexicographicalComparerJavaImpl() {
		 return LexicographicalComparerHolder.PureJavaComparer.INSTANCE;
	 }
	 private static class LexicographicalComparerHolder {
		 static final String UNSAFE_COMPARER_NAME = LexicographicalComparerHolder.class.getName() + ""$UnsafeComparer"";
		 static final Comparer<byte[]> BEST_COMPARER = getBestComparer();
		 static Comparer<byte[]> getBestComparer() {
			 try {
				 Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);
				 Comparer<byte[]> comparer = (Comparer<byte[]>) theClass.getEnumConstants()[0];
				 return comparer;
			 }
			 catch (Throwable t) {
				 return lexicographicalComparerJavaImpl();
			 }
		 }
		 private enum PureJavaComparer implements Comparer<byte[]> {
			 INSTANCE;
			 public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2) {
				 if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2) {
					 return 0;
				 }
				 int end1 = offset1 + length1;
				 int end2 = offset2 + length2;
				 for (int i = offset1, j = offset2;
				 i < end1 && j < end2;
				 i++, j++) {
					 int a = (buffer1[i] & 0xff);
					 int b = (buffer2[j] & 0xff);
					 if (a != b) {
						 return a - b;
					 }
				 }
				 return length1 - length2;
			 }
		 }
		 private enum UnsafeComparer implements Comparer<byte[]> {
			 INSTANCE;
			 static final Unsafe theUnsafe;
			 static final int BYTE_ARRAY_BASE_OFFSET;
			 static {
				 theUnsafe = (Unsafe) AccessController.doPrivileged( new PrivilegedAction<Object>() {
					 public Object run() {
						 try {
							 Field f = Unsafe.class.getDeclaredField(""theUnsafe"");
							 f.setAccessible(true);
							 return f.get(null);
						 }
						 catch (NoSuchFieldException e) {
							 throw new Error();
						 }
						 catch (IllegalAccessException e) {
							 throw new Error();
						 }
					 }
				 }
				);
				 BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);
				 if (theUnsafe.arrayIndexScale(byte[].class) != 1) {
					 throw new AssertionError();
				 }
			 }
			 static final boolean littleEndian = ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN);
			 static boolean lessThanUnsigned(long x1, long x2) {
				 return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);
			 }
			 public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2) {
				 if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2) {
					 return 0;
				 }
				 int minLength = Math.min(length1, length2);
				 int minWords = minLength / Longs.BYTES;
				 int offset1Adj = offset1 + BYTE_ARRAY_BASE_OFFSET;
				 int offset2Adj = offset2 + BYTE_ARRAY_BASE_OFFSET;
				 for (int i = 0;
				 i < minWords * Longs.BYTES;
				 i += Longs.BYTES) {
					 long lw = theUnsafe.getLong(buffer1, offset1Adj + (long) i);
					 long rw = theUnsafe.getLong(buffer2, offset2Adj + (long) i);
					 long diff = lw ^ rw;
					 if (diff != 0) {
						 if (!littleEndian) {
							 return lessThanUnsigned(lw, rw) ? -1 : 1;
						 }
						 int n = 0;
						 int y;
						 int x = (int) diff;
						 if (x == 0) {
							 x = (int) (diff >>> 32);
							 n = 32;
						 }
						 y = x << 16;
						 if (y == 0) {
							 n += 16;
						 }
						 else {
							 x = y;
						 }
						 y = x << 8;
						 if (y == 0) {
							 n += 8;
						 }
						 return (int) (((lw >>> n) & 0xFFL) - ((rw >>> n) & 0xFFL));
					 }
				 }
				 for (int i = minWords * Longs.BYTES;
				 i < minLength;
				 i++) {
					 int result = UnsignedBytes.compare( buffer1[offset1 + i], buffer2[offset2 + i]);
					 if (result != 0) {
						 return result;
					 }
				 }
				 return length1 - length2;
			 }
		 }
	 }
}",0,0,0,0
"public class Node{
	 public static final int FUNCTION_PROP = 1, LOCAL_PROP = 2, LOCAL_BLOCK_PROP = 3, REGEXP_PROP = 4, CASEARRAY_PROP = 5, TARGETBLOCK_PROP = 6, VARIABLE_PROP = 7, ISNUMBER_PROP = 8, DIRECTCALL_PROP = 9, SPECIALCALL_PROP = 10, SKIP_INDEXES_PROP = 11, OBJECT_IDS_PROP = 12, INCRDECR_PROP = 13, CATCH_SCOPE_PROP = 14, LABEL_ID_PROP = 15, MEMBER_TYPE_PROP = 16, NAME_PROP = 17, LAST_PROP = 17;
	 public static final int BOTH = 0, LEFT = 1, RIGHT = 2;
	 public static final int NON_SPECIALCALL = 0, SPECIALCALL_EVAL = 1, SPECIALCALL_WITH = 2;
	 public static final int DECR_FLAG = 0x1, POST_FLAG = 0x2;
	 public static final int PROPERTY_FLAG = 0x1, ATTRIBUTE_FLAG = 0x2, DESCENDANTS_FLAG = 0x4;
	 private static class NumberNode extends Node {
		 NumberNode(double number) {
			 super(Token.NUMBER);
			 this.number = number;
		 }
		 double number;
	 }
	 private static class StringNode extends Node {
		 StringNode(int type, String str) {
			 super(type);
			 this.str = str;
		 }
		 String str;
	 }
	 public static class Jump extends Node {
		 public Jump(int type) {
			 super(type);
		 }
		 Jump(int type, int lineno) {
			 super(type, lineno);
		 }
		 Jump(int type, Node child) {
			 super(type, child);
		 }
		 Jump(int type, Node child, int lineno) {
			 super(type, child, lineno);
		 }
		 public final Jump getJumpStatement() {
			 if (!(type == Token.BREAK || type == Token.CONTINUE)) Kit.codeBug();
			 return jumpNode;
		 }
		 public final void setJumpStatement(Jump jumpStatement) {
			 if (!(type == Token.BREAK || type == Token.CONTINUE)) Kit.codeBug();
			 if (jumpStatement == null) Kit.codeBug();
			 if (this.jumpNode != null) Kit.codeBug();
			 this.jumpNode = jumpStatement;
		 }
		 public final Node getDefault() {
			 if (!(type == Token.SWITCH)) Kit.codeBug();
			 return target2;
		 }
		 public final void setDefault(Node defaultTarget) {
			 if (!(type == Token.SWITCH)) Kit.codeBug();
			 if (defaultTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = defaultTarget;
		 }
		 public final Node getFinally() {
			 if (!(type == Token.TRY)) Kit.codeBug();
			 return target2;
		 }
		 public final void setFinally(Node finallyTarget) {
			 if (!(type == Token.TRY)) Kit.codeBug();
			 if (finallyTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = finallyTarget;
		 }
		 public final Jump getLoop() {
			 if (!(type == Token.LABEL)) Kit.codeBug();
			 return jumpNode;
		 }
		 public final void setLoop(Jump loop) {
			 if (!(type == Token.LABEL)) Kit.codeBug();
			 if (loop == null) Kit.codeBug();
			 if (jumpNode != null) Kit.codeBug();
			 jumpNode = loop;
		 }
		 public final Node getContinue() {
			 if (type != Token.LOOP) Kit.codeBug();
			 return target2;
		 }
		 public final void setContinue(Node continueTarget) {
			 if (type != Token.LOOP) Kit.codeBug();
			 if (continueTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = continueTarget;
		 }
		 public Node target;
		 private Node target2;
		 private Jump jumpNode;
	 }
	 private static class PropListItem {
		 PropListItem next;
		 int type;
		 int intValue;
		 Object objectValue;
	 }
	 public Node(int nodeType) {
		 type = nodeType;
	 }
	 public Node(int nodeType, Node child) {
		 type = nodeType;
		 first = last = child;
		 child.next = null;
	 }
	 public Node(int nodeType, Node left, Node right) {
		 type = nodeType;
		 first = left;
		 last = right;
		 left.next = right;
		 right.next = null;
	 }
	 public Node(int nodeType, Node left, Node mid, Node right) {
		 type = nodeType;
		 first = left;
		 last = right;
		 left.next = mid;
		 mid.next = right;
		 right.next = null;
	 }
	 public Node(int nodeType, int line) {
		 type = nodeType;
		 lineno = line;
	 }
	 public Node(int nodeType, Node child, int line) {
		 this(nodeType, child);
		 lineno = line;
	 }
	 public Node(int nodeType, Node left, Node right, int line) {
		 this(nodeType, left, right);
		 lineno = line;
	 }
	 public Node(int nodeType, Node left, Node mid, Node right, int line) {
		 this(nodeType, left, mid, right);
		 lineno = line;
	 }
	 public static Node newNumber(double number) {
		 return new NumberNode(number);
	 }
	 public static Node newString(String str) {
		 return new StringNode(Token.STRING, str);
	 }
	 public static Node newString(int type, String str) {
		 return new StringNode(type, str);
	 }
	 public int getType() {
		 return type;
	 }
	 public void setType(int type) {
		 this.type = type;
	 }
	 public boolean hasChildren() {
		 return first != null;
	 }
	 public Node getFirstChild() {
		 return first;
	 }
	 public Node getLastChild() {
		 return last;
	 }
	 public Node getNext() {
		 return next;
	 }
	 public Node getChildBefore(Node child) {
		 if (child == first) return null;
		 Node n = first;
		 while (n.next != child) {
			 n = n.next;
			 if (n == null) throw new RuntimeException(""node is not a child"");
		 }
		 return n;
	 }
	 public Node getLastSibling() {
		 Node n = this;
		 while (n.next != null) {
			 n = n.next;
		 }
		 return n;
	 }
	 public void addChildToFront(Node child) {
		 child.next = first;
		 first = child;
		 if (last == null) {
			 last = child;
		 }
	 }
	 public void addChildToBack(Node child) {
		 child.next = null;
		 if (last == null) {
			 first = last = child;
			 return;
		 }
		 last.next = child;
		 last = child;
	 }
	 public void addChildrenToFront(Node children) {
		 Node lastSib = children.getLastSibling();
		 lastSib.next = first;
		 first = children;
		 if (last == null) {
			 last = lastSib;
		 }
	 }
	 public void addChildrenToBack(Node children) {
		 if (last != null) {
			 last.next = children;
		 }
		 last = children.getLastSibling();
		 if (first == null) {
			 first = children;
		 }
	 }
	 public void addChildBefore(Node newChild, Node node) {
		 if (newChild.next != null) throw new RuntimeException( ""newChild had siblings in addChildBefore"");
		 if (first == node) {
			 newChild.next = first;
			 first = newChild;
			 return;
		 }
		 Node prev = getChildBefore(node);
		 addChildAfter(newChild, prev);
	 }
	 public void addChildAfter(Node newChild, Node node) {
		 if (newChild.next != null) throw new RuntimeException( ""newChild had siblings in addChildAfter"");
		 newChild.next = node.next;
		 node.next = newChild;
		 if (last == node) last = newChild;
	 }
	 public void removeChild(Node child) {
		 Node prev = getChildBefore(child);
		 if (prev == null) first = first.next;
		 else prev.next = child.next;
		 if (child == last) last = prev;
		 child.next = null;
	 }
	 public void replaceChild(Node child, Node newChild) {
		 newChild.next = child.next;
		 if (child == first) {
			 first = newChild;
		 }
		 else {
			 Node prev = getChildBefore(child);
			 prev.next = newChild;
		 }
		 if (child == last) last = newChild;
		 child.next = null;
	 }
	 public void replaceChildAfter(Node prevChild, Node newChild) {
		 Node child = prevChild.next;
		 newChild.next = child.next;
		 prevChild.next = newChild;
		 if (child == last) last = newChild;
		 child.next = null;
	 }
	 private static final String propToString(int propType) {
		 if (Token.printTrees) {
			 switch (propType) {
				 case FUNCTION_PROP: return ""function"";
				 case LOCAL_PROP: return ""local"";
				 case LOCAL_BLOCK_PROP: return ""local_block"";
				 case REGEXP_PROP: return ""regexp"";
				 case CASEARRAY_PROP: return ""casearray"";
				 case TARGETBLOCK_PROP: return ""targetblock"";
				 case VARIABLE_PROP: return ""variable"";
				 case ISNUMBER_PROP: return ""isnumber"";
				 case DIRECTCALL_PROP: return ""directcall"";
				 case SPECIALCALL_PROP: return ""specialcall"";
				 case SKIP_INDEXES_PROP: return ""skip_indexes"";
				 case OBJECT_IDS_PROP: return ""object_ids_prop"";
				 case INCRDECR_PROP: return ""incrdecr_prop"";
				 case CATCH_SCOPE_PROP: return ""catch_scope_prop"";
				 case LABEL_ID_PROP: return ""label_id_prop"";
				 case MEMBER_TYPE_PROP: return ""member_type_prop"";
				 case NAME_PROP: return ""name_prop"";
				 default: Kit.codeBug();
			 }
		 }
		 return null;
	 }
	 private PropListItem lookupProperty(int propType) {
		 PropListItem x = propListHead;
		 while (x != null && propType != x.type) {
			 x = x.next;
		 }
		 return x;
	 }
	 private PropListItem ensureProperty(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 item = new PropListItem();
			 item.type = propType;
			 item.next = propListHead;
			 propListHead = item;
		 }
		 return item;
	 }
	 public void removeProp(int propType) {
		 PropListItem x = propListHead;
		 if (x != null) {
			 PropListItem prev = null;
			 while (x.type != propType) {
				 prev = x;
				 x = x.next;
				 if (x == null) {
					 return;
				 }
			 }
			 if (prev == null) {
				 propListHead = x.next;
			 }
			 else {
				 prev.next = x.next;
			 }
		 }
	 }
	 public Object getProp(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 return null;
		 }
		 return item.objectValue;
	 }
	 public int getIntProp(int propType, int defaultValue) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 return defaultValue;
		 }
		 return item.intValue;
	 }
	 public int getExistingIntProp(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 Kit.codeBug();
		 }
		 return item.intValue;
	 }
	 public void putProp(int propType, Object prop) {
		 if (prop == null) {
			 removeProp(propType);
		 }
		 else {
			 PropListItem item = ensureProperty(propType);
			 item.objectValue = prop;
		 }
	 }
	 public void putIntProp(int propType, int prop) {
		 PropListItem item = ensureProperty(propType);
		 item.intValue = prop;
	 }
	 public int getLineno() {
		 return lineno;
	 }
	 public final double getDouble() {
		 return ((NumberNode)this).number;
	 }
	 public final void setDouble(double number) {
		 ((NumberNode)this).number = number;
	 }
	 public final String getString() {
		 return ((StringNode)this).str;
	 }
	 public final void setString(String s) {
		 if (s == null) Kit.codeBug();
		 ((StringNode)this).str = s;
	 }
	 public static Node newTarget() {
		 return new Node(Token.TARGET);
	 }
	 public final int labelId() {
		 if (type != Token.TARGET) Kit.codeBug();
		 return getIntProp(LABEL_ID_PROP, -1);
	 }
	 public void labelId(int labelId) {
		 if (type != Token.TARGET) Kit.codeBug();
		 putIntProp(LABEL_ID_PROP, labelId);
	 }
	 public String toString() {
		 if (Token.printTrees) {
			 StringBuffer sb = new StringBuffer();
			 toString(new ObjToIntMap(), sb);
			 return sb.toString();
		 }
		 return String.valueOf(type);
	 }
	 private void toString(ObjToIntMap printIds, StringBuffer sb) {
		 if (Token.printTrees) {
			 sb.append(Token.name(type));
			 if (this instanceof StringNode) {
				 sb.append(' ');
				 sb.append(getString());
			 }
			 else if (this instanceof ScriptOrFnNode) {
				 ScriptOrFnNode sof = (ScriptOrFnNode)this;
				 if (this instanceof FunctionNode) {
					 FunctionNode fn = (FunctionNode)this;
					 sb.append(' ');
					 sb.append(fn.getFunctionName());
				 }
				 sb.append("" [source name: "");
				 sb.append(sof.getSourceName());
				 sb.append(""] [encoded source length: "");
				 sb.append(sof.getEncodedSourceEnd() - sof.getEncodedSourceStart());
				 sb.append(""] [base line: "");
				 sb.append(sof.getBaseLineno());
				 sb.append(""] [end line: "");
				 sb.append(sof.getEndLineno());
				 sb.append(']');
			 }
			 else if (this instanceof Jump) {
				 Jump jump = (Jump)this;
				 if (type == Token.BREAK || type == Token.CONTINUE) {
					 sb.append("" [label: "");
					 appendPrintId(jump.getJumpStatement(), printIds, sb);
					 sb.append(']');
				 }
				 else if (type == Token.TRY) {
					 Node catchNode = jump.target;
					 Node finallyTarget = jump.getFinally();
					 if (catchNode != null) {
						 sb.append("" [catch: "");
						 appendPrintId(catchNode, printIds, sb);
						 sb.append(']');
					 }
					 if (finallyTarget != null) {
						 sb.append("" [finally: "");
						 appendPrintId(finallyTarget, printIds, sb);
						 sb.append(']');
					 }
				 }
				 else if (type == Token.LABEL || type == Token.LOOP || type == Token.SWITCH) {
					 sb.append("" [break: "");
					 appendPrintId(jump.target, printIds, sb);
					 sb.append(']');
					 if (type == Token.LOOP) {
						 sb.append("" [continue: "");
						 appendPrintId(jump.getContinue(), printIds, sb);
						 sb.append(']');
					 }
				 }
				 else {
					 sb.append("" [target: "");
					 appendPrintId(jump.target, printIds, sb);
					 sb.append(']');
				 }
			 }
			 else if (type == Token.NUMBER) {
				 sb.append(' ');
				 sb.append(getDouble());
			 }
			 else if (type == Token.TARGET) {
				 sb.append(' ');
				 appendPrintId(this, printIds, sb);
			 }
			 if (lineno != -1) {
				 sb.append(' ');
				 sb.append(lineno);
			 }
			 for (PropListItem x = propListHead;
			 x != null;
			 x = x.next) {
				 int type = x.type;
				 sb.append("" ["");
				 sb.append(propToString(type));
				 sb.append("": "");
				 String value;
				 switch (type) {
					 case TARGETBLOCK_PROP : value = ""target block property"";
					 break;
					 case LOCAL_BLOCK_PROP : value = ""last local block"";
					 break;
					 case ISNUMBER_PROP: switch (x.intValue) {
						 case BOTH: value = ""both"";
						 break;
						 case RIGHT: value = ""right"";
						 break;
						 case LEFT: value = ""left"";
						 break;
						 default: throw Kit.codeBug();
					 }
					 break;
					 case SPECIALCALL_PROP: switch (x.intValue) {
						 case SPECIALCALL_EVAL: value = ""eval"";
						 break;
						 case SPECIALCALL_WITH: value = ""with"";
						 break;
						 default: throw Kit.codeBug();
					 }
					 break;
					 default : Object obj = x.objectValue;
					 if (obj != null) {
						 value = obj.toString();
					 }
					 else {
						 value = String.valueOf(x.intValue);
					 }
					 break;
				 }
				 sb.append(value);
				 sb.append(']');
			 }
		 }
	 }
	 public String toStringTree(ScriptOrFnNode treeTop) {
		 if (Token.printTrees) {
			 StringBuffer sb = new StringBuffer();
			 toStringTreeHelper(treeTop, this, null, 0, sb);
			 return sb.toString();
		 }
		 return null;
	 }
	 private static void toStringTreeHelper(ScriptOrFnNode treeTop, Node n, ObjToIntMap printIds, int level, StringBuffer sb) {
		 if (Token.printTrees) {
			 if (printIds == null) {
				 printIds = new ObjToIntMap();
				 generatePrintIds(treeTop, printIds);
			 }
			 for (int i = 0;
			 i != level;
			 ++i) {
				 sb.append("" "");
			 }
			 n.toString(printIds, sb);
			 sb.append('\n');
			 for (Node cursor = n.getFirstChild();
			 cursor != null;
			 cursor = cursor.getNext()) {
				 if (cursor.getType() == Token.FUNCTION) {
					 int fnIndex = cursor.getExistingIntProp(Node.FUNCTION_PROP);
					 FunctionNode fn = treeTop.getFunctionNode(fnIndex);
					 toStringTreeHelper(fn, fn, null, level + 1, sb);
				 }
				 else {
					 toStringTreeHelper(treeTop, cursor, printIds, level + 1, sb);
				 }
			 }
		 }
	 }
	 private static void generatePrintIds(Node n, ObjToIntMap map) {
		 if (Token.printTrees) {
			 map.put(n, map.size());
			 for (Node cursor = n.getFirstChild();
			 cursor != null;
			 cursor = cursor.getNext()) {
				 generatePrintIds(cursor, map);
			 }
		 }
	 }
	 private static void appendPrintId(Node n, ObjToIntMap printIds, StringBuffer sb) {
		 if (Token.printTrees) {
			 if (n != null) {
				 int id = printIds.get(n, -1);
				 sb.append('#');
				 if (id != -1) {
					 sb.append(id + 1);
				 }
				 else {
					 sb.append(""<not_available>"");
				 }
			 }
		 }
	 }
	 int type;
	 Node next;
	 private Node first;
	 private Node last;
	 private int lineno = -1;
	 private PropListItem propListHead;
}",1,0,0,0
"public int getActiveCount() {
	 return 1;
 }",0,0,0,0
"public Path createFactoryPath() {
	 if (factoryPath == null) {
		 factoryPath = new Path(getProject());
	 }
	 return factoryPath.createPath();
 }",0,0,0,0
"public class ProgressLogger extends ProgressMonitor{
	 public ProgressLogger(Logger log, String label, long tickPoint, int superTick) {
		 super(label, tickPoint, superTick, (fmt, args)->print(log, fmt, args) ) ;
	 }
	 static void print(Logger log, String fmt, Object...args) {
		 if ( log != null && log.isInfoEnabled() ) {
			 String str = String.format(fmt, args) ;
			 log.info(str) ;
		 }
	 }
}",0,0,0,0
"public class KafkaTestServer {
	 public static final int CACHE_TTL_MS = 1;
	 private static final Logger LOGGER = LoggerFactory.getLogger(KafkaTestServer.class);
	 private int kafkaPort = -1;
	 private TestingServer zkServer;
	 private KafkaServerStartable kafkaServer = null;
	 private File sentrySitePath = null;
	 public KafkaTestServer(File sentrySitePath) throws Exception {
		 this.sentrySitePath = sentrySitePath;
		 createZkServer();
		 this.kafkaPort = TestUtils.getFreePort();
		 createKafkaServer();
	 }
	 public void start() throws Exception {
		 kafkaServer.startup();
		 LOGGER.info(""Started Kafka broker."");
	 }
	 public void shutdown() {
		 if (kafkaServer != null) {
			 kafkaServer.shutdown();
			 kafkaServer.awaitShutdown();
			 LOGGER.info(""Stopped Kafka server."");
		 }
		 if (zkServer != null) {
			 try {
				 zkServer.stop();
				 LOGGER.info(""Stopped ZK server."");
			 }
			 catch (IOException e) {
				 LOGGER.error(""Failed to shutdown ZK server."", e);
			 }
		 }
	 }
	 private Path getTempDirectory() {
		 Path tempDirectory = null;
		 try {
			 tempDirectory = Files.createTempDirectory(""kafka-sentry-"");
		 }
		 catch (IOException e) {
			 LOGGER.error(""Failed to create temp dir for Kafka's log dir."");
			 throw new RuntimeException(e);
		 }
		 return tempDirectory;
	 }
	 private void setupKafkaProps(Properties props) throws UnknownHostException {
		 props.put(""listeners"", ""SSL: props.put(""log.dir"", getTempDirectory().toAbsolutePath().toString());
		 props.put(""zookeeper.connect"", zkServer.getConnectString());
		 props.put(""replica.socket.timeout.ms"", ""1500"");
		 props.put(""controller.socket.timeout.ms"", ""1500"");
		 props.put(""controlled.shutdown.enable"", true);
		 props.put(""delete.topic.enable"", false);
		 props.put(""controlled.shutdown.retry.backoff.ms"", ""100"");
		 props.put(""port"", kafkaPort);
		 props.put(""offsets.topic.replication.factor"", ""1"");
		 props.put(""authorizer.class.name"", ""org.apache.sentry.kafka.authorizer.SentryKafkaAuthorizer"");
		 props.put(""sentry.kafka.site.url"", ""file: props.put(""allow.everyone.if.no.acl.found"", ""true"");
		 props.put(""ssl.keystore.location"", KafkaTestServer.class.getResource(""/test.keystore.jks"").getPath());
		 props.put(""ssl.keystore.password"", ""test-ks-passwd"");
		 props.put(""ssl.key.password"", ""test-key-passwd"");
		 props.put(""ssl.truststore.location"", KafkaTestServer.class.getResource(""/test.truststore.jks"").getPath());
		 props.put(""ssl.truststore.password"", ""test-ts-passwd"");
		 props.put(""security.inter.broker.protocol"", ""SSL"");
		 props.put(""ssl.client.auth"", ""required"");
		 props.put(KafkaAuthConf.KAFKA_SUPER_USERS, ""User:CN=superuser;
		User:CN=superuser1;
		 User:CN=Superuser2 "");
		 props.put(KafkaAuthConf.SENTRY_KAFKA_CACHING_ENABLE_NAME, ""true"");
		 props.put(KafkaAuthConf.SENTRY_KAFKA_CACHING_TTL_MS_NAME, String.valueOf(CACHE_TTL_MS));
	 }
	 private void createKafkaServer() throws UnknownHostException {
		 Properties props = new Properties();
		 setupKafkaProps(props);
		 kafkaServer = KafkaServerStartable.fromProps(props);
	 }
	 private void createZkServer() throws Exception {
		 try {
			 zkServer = new TestingServer();
		 }
		 catch (Exception e) {
			 LOGGER.error(""Failed to create testing zookeeper server."");
			 throw new RuntimeException(e);
		 }
	 }
	 public String getBootstrapServers() throws UnknownHostException {
		 return InetAddress.getLocalHost().getHostAddress() + "":"" + kafkaPort;
	 }
}",1,0,0,0
"private JPanel createAdvPanel() {
	JPanel p = new JPanel();
	p.setLayout(null);
	p.setOpaque(false);
	int y = 20;
	int h = 0;
	y += h;
	h = 30;
	chkHaltAfterFinish = createCheckBox(""MSG_HALT"");
	chkHaltAfterFinish.setBounds(15, y, 350, h);
	p.add(chkHaltAfterFinish);
	y += h;
	h = 30;
	chkKeepAwake = createCheckBox(""MSG_AWAKE"");
	chkKeepAwake.setBounds(15, y, 350, h);
	p.add(chkKeepAwake);
	y += h;
	h = 30;
	chkExecCmd = createCheckBox(""EXEC_CMD"");
	chkExecCmd.setBounds(15, y, 350, h);
	p.add(chkExecCmd);
	y += h;
	h = 25;
	txtCustomCmd = new JTextField();
	txtCustomCmd.setBounds(15, y, 350 - 30 - 10, h);
	txtCustomCmd.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtCustomCmd.setForeground(Color.WHITE);
	txtCustomCmd.setOpaque(false);
	p.add(txtCustomCmd);
	y += h;
	y += 20;
	h = 30;
	chkExecAntivir = createCheckBox(""EXE_ANTI_VIR"");
	chkExecAntivir.setBounds(15, y, 350, h);
	p.add(chkExecAntivir);
	y += h;
	y += 5;
	h = 30;
	JLabel lbl12 = new JLabel(StringResource.get(""ANTIVIR_CMD""));
	lbl12.setForeground(Color.WHITE);
	lbl12.setFont(FontResource.getNormalFont());
	lbl12.setBounds(15, y, 350 - 30, h);
	p.add(lbl12);
	y += h;
	h = 25;
	txtAntivirCmd = new JTextField();
	txtAntivirCmd.setBounds(15, y, 350 - 30 - 10 - 100, h);
	txtAntivirCmd.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtAntivirCmd.setForeground(Color.WHITE);
	txtAntivirCmd.setOpaque(false);
	p.add(txtAntivirCmd);
	JButton btnBrowse = createButton2(""BTN_BROWSE"");
	btnBrowse.setName(""BROWSE_ANTIVIR"");
	btnBrowse.setBackground(ColorResource.getDarkBtnColor());
	btnBrowse.setFont(FontResource.getNormalFont());
	btnBrowse.setBounds(15 + 350 - 30 - 110 + 10, y, 90, h);
	p.add(btnBrowse);
	y += h;
	h = 30;
	JLabel lbl1 = new JLabel(StringResource.get(""ANTIVIR_ARGS""));
	lbl1.setForeground(Color.WHITE);
	lbl1.setFont(FontResource.getNormalFont());
	lbl1.setBounds(15, y, 350 - 30, h);
	p.add(lbl1);
	y += h;
	h = 25;
	txtAntivirArgs = new JTextField();
	txtAntivirArgs.setBounds(15, y, 350 - 30 - 10, h);
	txtAntivirArgs.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtAntivirArgs.setForeground(Color.WHITE);
	txtAntivirArgs.setOpaque(false);
	p.add(txtAntivirArgs);
	y += h;
	y += 20;
	h = 30;
	chkAutoStart = createCheckBox(""AUTO_START"");
	chkAutoStart.setBounds(15, y, 350, h);
	p.add(chkAutoStart);
	y += h;
	y += 50;
	p.setPreferredSize(new Dimension(350, y));
	return p;
}",0,0,1,0
"public void bind() throws DavMailException {
	 String bindAddress = Settings.getProperty(""davmail.bindAddress"");
	 String keystoreFile = Settings.getProperty(""davmail.ssl.keystoreFile"");
	 ServerSocketFactory serverSocketFactory;
	 if (keystoreFile == null || keystoreFile.length() == 0 || nosslFlag) {
		 serverSocketFactory = ServerSocketFactory.getDefault();
	 }
	 else {
		 FileInputStream keyStoreInputStream = null;
		 try {
			 keyStoreInputStream = new FileInputStream(keystoreFile);
			 KeyStore keystore = KeyStore.getInstance(Settings.getProperty(""davmail.ssl.keystoreType""));
			 keystore.load(keyStoreInputStream, Settings.getCharArrayProperty(""davmail.ssl.keystorePass""));
			 KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
			 kmf.init(keystore, Settings.getCharArrayProperty(""davmail.ssl.keyPass""));
			 SSLContext sslContext = SSLContext.getInstance(""SSLv3"");
			 sslContext.init(kmf.getKeyManagers(), null, null);
			 serverSocketFactory = sslContext.getServerSocketFactory();
		 }
		 catch (IOException ex) {
			 throw new DavMailException(""LOG_EXCEPTION_CREATING_SSL_SERVER_SOCKET"", getProtocolName(), port, ex.getMessage() == null ? ex.toString() : ex.getMessage());
		 }
		 catch (GeneralSecurityException ex) {
			 throw new DavMailException(""LOG_EXCEPTION_CREATING_SSL_SERVER_SOCKET"", getProtocolName(), port, ex.getMessage() == null ? ex.toString() : ex.getMessage());
		 }
		 finally {
			 if (keyStoreInputStream != null) {
				 try {
					 keyStoreInputStream.close();
				 }
				 catch (IOException exc) {
					 DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_KEYSTORE_INPUT_STREAM""), exc);
				 }
			 }
		 }
	 }
	 try {
		 if (bindAddress == null || bindAddress.length() == 0) {
			 serverSocket = serverSocketFactory.createServerSocket(port);
		 }
		 else {
			 serverSocket = serverSocketFactory.createServerSocket(port, 0, Inet4Address.getByName(bindAddress));
		 }
	 }
	 catch (IOException e) {
		 throw new DavMailException(""LOG_SOCKET_BIND_FAILED"", getProtocolName(), port);
	 }
 }",0,0,1,0
"public int compareTo(Object o) {
	 DatanodeInfo d = (DatanodeInfo) o;
	 return name.compareTo(d.getName());
 }",0,0,0,0
"public JRSourceCompileTask(JasperDesign jasperDesign, JRDesignDataset dataset, JRExpressionCollector expressionCollector, String unitName);",0,0,0,0
"protected void populateHSLArrays(Image image) {
	 double red;
	 double green;
	 double blue;
	 double Cmax;
	 double Cmin;
	 double delta;
	 for (int j = 0;
	 j < width;
	 j++) {
		 for (int i = 0;
		 i < height;
		 i++) {
			 Color color= new Color(image.getPixel(j, i));
			 red = color.getRed();
			 green = color.getGreen();
			 blue = color.getBlue();
			 red = red/255;
			 green = green/255;
			 blue = blue/255;
			 Cmax = Math.max(red, Math.max(green, blue));
			 Cmin = Math.min(red, Math.min(green, blue));
			 delta = Cmax-Cmin;
			 double hue = 0;
			 if (delta != 0) {
				 if (Cmax == red) hue = 60*(((green - blue)/delta)%6);
				 if (Cmax == green) hue = 60*(((blue-red)/delta)+2);
				 if (Cmax == blue) hue = 60*((red-green)/delta + 4);
			 }
			 else {
				 double a = (2*red-green-blue)/2;
				 double b = (green-blue)*Math.sqrt(3)/2;
				 hue = Math.atan2(b, a);
			 }
			 hueValues[i][j] = hue/360;
			 double lightness = (Cmax + Cmin)/2;
			 lightnessValues[i][j] = lightness;
			 double saturation = 0;
			 if (delta == 0) saturation = 0;
			 else saturation = delta/(1-Math.abs(2*lightness-1));
			 saturationValues[i][j] = saturation;
		 }
	 }
 }",0,0,1,0
"public class MainFragment extends Fragment implements Updatable {
	 private OnRefreshObservable refreshObservable;
	 private UsernamesRepository usernamesRepository;
	 private ListAdapter listAdapter;
	 private ListView listView;
	 private SwipeRefreshLayout swipeRefreshLayout;
	 public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		 View root = inflater.inflate(R.layout.main_frag, container, false);
		 listView = (ListView) root.findViewById(R.id.list);
		 refreshObservable = new OnRefreshObservable();
		 swipeRefreshLayout = (SwipeRefreshLayout) root.findViewById(R.id.refresh_layout);
		 swipeRefreshLayout.setColorSchemeColors( ContextCompat.getColor(getActivity(), R.color.colorPrimary), ContextCompat.getColor(getActivity(), R.color.colorAccent), ContextCompat.getColor(getActivity(), R.color.colorPrimaryDark));
		 swipeRefreshLayout.setOnRefreshListener(refreshObservable);
		 usernamesRepository = new UsernamesRepository(new UsernamesFetcher());
		 return root;
	 }
	 public void onResume() {
		 super.onResume();
		 refreshObservable.addUpdatable(usernamesRepository);
		 usernamesRepository.addUpdatable(this);
		 swipeRefreshLayout.post(new Runnable() {
			 public void run() {
				 swipeRefreshLayout.setRefreshing(true);
			 }
		 }
		);
	 }
	 public void onPause() {
		 super.onPause();
		 refreshObservable.removeUpdatable(usernamesRepository);
		 usernamesRepository.removeUpdatable(this);
	 }
	 public void update() {
		 swipeRefreshLayout.post(new Runnable() {
			 public void run() {
				 swipeRefreshLayout.setRefreshing(false);
			 }
		 }
		);
		 if (usernamesRepository.isError()) {
			 Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_LONG).show();
		 }
		 else {
			 listAdapter = new ArrayAdapter<String>(getContext(), android.R.layout.simple_list_item_1, usernamesRepository.get());
			 listView.setAdapter(listAdapter);
		 }
	 }
}",1,0,0,0
"protected void updateNeuronWeights(Neuron neuron, double desiredOutput) {
	for (Connection connection : neuron.getInputConnections()) {
		double input = connection.getInput();
		double deltaWeight = input * desiredOutput * this.learningRate;
		connection.getWeight().inc(deltaWeight);
	}
}",0,0,0,0
"public class CreateProcedureAction extends CayenneAction {
	 public CreateProcedureAction(Application application) {
		 super(getActionName(), application);
	 }
	 public static String getActionName() {
		 return ""Create Stored Procedure"";
	 }
	 static void fireProcedureEvent(Object src, ProjectController mediator, DataMap dataMap, Procedure procedure) {
		 mediator.fireProcedureEvent(new ProcedureEvent(src, procedure, MapEvent.ADD));
		 mediator.fireProcedureDisplayEvent(new ProcedureDisplayEvent(src, procedure, mediator.getCurrentDataMap(), (DataChannelDescriptor) mediator.getProject().getRootNode()));
	 }
	 public void performAction(ActionEvent e) {
		 ProjectController mediator = getProjectController();
		 DataMap map = mediator.getCurrentDataMap();
		 Procedure procedure = new Procedure();
		 procedure.setName(NameBuilder.builder(procedure, map).name());
		 createProcedure(map, procedure);
		 application.getUndoManager().addEdit(new CreateProcedureUndoableEdit(map, procedure));
	 }
	 public void createProcedure(DataMap map, Procedure procedure) {
		 ProjectController mediator = getProjectController();
		 procedure.setSchema(map.getDefaultSchema());
		 procedure.setCatalog(map.getDefaultCatalog());
		 map.addProcedure(procedure);
		 fireProcedureEvent(this, mediator, map, procedure);
	 }
	 public boolean enableForPath(ConfigurationNode object) {
		 if (object == null) {
			 return false;
		 }
		 return ((Procedure) object).getDataMap() != null;
	 }
	 public String getIconName() {
		 return ""icon-stored-procedure.png"";
	 }
}",0,0,0,0
"public void addCustomEntriesToTable(UIDefaults table) {
	super.addCustomEntriesToTable(table);
	table.put(""Menu.foreground"", ColorResource.getDeepFontColor());
	table.put(""PopupMenu.border"", new LineBorder(ColorResource.getDarkBgColor()));
	table.put(""PopupMenu.background"", ColorResource.getDarkerBgColor());
	table.put(""MenuItem.foreground"", ColorResource.getDeepFontColor());
	table.put(""MenuItem.selectionForeground"", Color.WHITE);
	table.put(""Menu.selectionForeground"", Color.WHITE);
	table.put(""ComboBox.selectionBackground"", ColorResource.getSelectionColor());
	table.put(""ComboBox.selectionForeground"", Color.WHITE);
	table.put(""ComboBox.disabledForeground"", Color.GRAY);
	table.put(""ComboBox.disabledBackground"", ColorResource.getDarkerBgColor());
	table.put(""ComboBox.foreground"", Color.WHITE);
	table.put(""ComboBox.background"", ColorResource.getDarkBgColor());
	table.put(""Label.foreground"", Color.WHITE);
	table.put(""Panel.background"", ColorResource.getDarkerBgColor());
	table.put(""ScrollBar.width"", new Integer(15));
	table.put(""Popup.background"", ColorResource.getDarkerBgColor());
	table.put(""TextArea.background"", ColorResource.getDarkerBgColor());
	table.put(""TextArea.foreground"", Color.WHITE);
	table.put(""TextArea.selectionBackground"", ColorResource.getSelectionColor());
	table.put(""TextArea.selectionForeground"", Color.WHITE);
	table.put(""TextArea.caretForeground"", ColorResource.getSelectionColor());
	table.put(""TextField.background"", ColorResource.getDarkerBgColor());
	table.put(""TextField.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
	table.put(""TextField.foreground"", Color.WHITE);
	table.put(""TextField.selectionBackground"", ColorResource.getSelectionColor());
	table.put(""TextField.selectionForeground"", Color.WHITE);
	table.put(""TextField.caretForeground"", ColorResource.getSelectionColor());
	table.put(""PasswordField.background"", ColorResource.getDarkerBgColor());
	table.put(""PasswordField.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
	table.put(""PasswordField.foreground"", Color.WHITE);
	table.put(""PasswordField.selectionBackground"", ColorResource.getSelectionColor());
	table.put(""PasswordField.selectionForeground"", Color.WHITE);
	table.put(""PasswordField.caretForeground"", ColorResource.getSelectionColor());
	table.put(""ComboBox.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
	table.put(""List.selectionBackground"", ColorResource.getSelectionColor());
	table.put(""List.selectionForeground"", Color.WHITE);
	table.put(""List.focusCellHighlightBorder"", ColorResource.getSelectionColor());
	table.put(""List.border"", new LineBorder(Color.WHITE, 1));
	table.put(""ScrollPane.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
	table.put(""TableHeader.background"", ColorResource.getDarkerBgColor());
	table.put(""TableHeader.cellBorder"", new LineBorder(ColorResource.getDarkBgColor(), 1));
	table.put(""TableHeader.foreground"", Color.WHITE);
	table.put(""OptionPane.messageForeground"", Color.WHITE);
	table.put(""OptionPane.background"", ColorResource.getDarkerBgColor());
	table.put(""Tree.textBackground"", ColorResource.getDarkestBgColor());
	table.put(""Tree.selectionBackground"", ColorResource.getSelectionColor());
	table.put(""Tree.selectionForeground"", Color.WHITE);
	table.put(""Tree.selectionBorderColor"", ColorResource.getSelectionColor());
	table.put(""Tree.textForeground"", Color.WHITE);
	table.put(""ToggleButton.background"", ColorResource.getDarkerBgColor());
	table.put(""ToggleButton.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
	table.put(""ToggleButton.foreground"", Color.WHITE);
	table.put(""ToggleButton.select"", ColorResource.getSelectionColor());
}",0,0,1,0
"XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias, XSLTElementDef[] elements, XSLTAttributeDef[] attributes, XSLTElementProcessor contentHandler, Class classObject);",0,0,0,1
"public static class PutAllEntryData {
	 final Object key;
	 private Object value;
	 private final Object oldValue;
	 private final Operation op;
	 private EventID eventID;
	 transient EntryEventImpl event;
	 private Integer bucketId = Integer.valueOf(-1);
	 protected transient boolean callbacksInvoked = false;
	 public FilterRoutingInfo filterRouting;
	 protected byte flags = 0x00;
	 private Long tailKey = 0L;
	 public VersionTag versionTag;
	 transient boolean inhibitDistribution;
	 public PutAllEntryData(EntryEventImpl event) {
		 this.key = event.getKey();
		 this.value = event.getRawNewValueAsHeapObject();
		 Object oldValue = event.getRawOldValueAsHeapObject();
		 if (oldValue == Token.NOT_AVAILABLE || Token.isRemoved(oldValue)) {
			 this.oldValue = null;
		 }
		 else {
			 this.oldValue = oldValue;
		 }
		 this.op = event.getOperation();
		 this.eventID = event.getEventId();
		 this.tailKey = event.getTailKey();
		 this.versionTag = event.getVersionTag();
		 setNotifyOnly(!event.getInvokePRCallbacks());
		 setCallbacksInvoked(event.callbacksInvoked());
		 setPossibleDuplicate(event.isPossibleDuplicate());
		 setInhibitDistribution(event.getInhibitDistribution());
	 }
	 public PutAllEntryData(DataInput in, EventID baseEventID, int idx, Version version, ByteArrayDataInput bytesIn) throws IOException, ClassNotFoundException {
		 this.key = DataSerializer.readObject(in);
		 byte flgs = in.readByte();
		 if ((flgs & IS_OBJECT) != 0) {
			 this.value = DataSerializer.readObject(in);
		 }
		 else {
			 byte[] bb = DataSerializer.readByteArray(in);
			 if ((flgs & IS_CACHED_DESER) != 0) {
				 this.value = new FutureCachedDeserializable(bb);
			 }
			 else {
				 this.value = bb;
			 }
		 }
		 this.oldValue = null;
		 this.op = Operation.fromOrdinal(in.readByte());
		 this.flags = in.readByte();
		 if ((this.flags & FILTER_ROUTING) != 0) {
			 this.filterRouting = (FilterRoutingInfo) DataSerializer.readObject(in);
		 }
		 if ((this.flags & VERSION_TAG) != 0) {
			 boolean persistentTag = (this.flags & PERSISTENT_TAG) != 0;
			 this.versionTag = VersionTag.create(persistentTag, in);
		 }
		 if (isUsedFakeEventId()) {
			 this.eventID = new EventID();
			 InternalDataSerializer.invokeFromData(this.eventID, in);
		 }
		 else {
			 this.eventID = new EventID(baseEventID, idx);
		 }
		 if ((this.flags & HAS_TAILKEY) != 0) {
			 this.tailKey = DataSerializer.readLong(in);
		 }
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder(50);
		 sb.append(""("").append(getKey()).append("","").append(this.value).append("","") .append(getOldValue());
		 if (this.bucketId > 0) {
			 sb.append("", b"").append(this.bucketId);
		 }
		 if (versionTag != null) {
			 sb.append(versionTag);
		 }
		 if (filterRouting != null) {
			 sb.append("", "").append(filterRouting);
		 }
		 sb.append("")"");
		 return sb.toString();
	 }
	 void setSender(InternalDistributedMember sender) {
		 if (this.versionTag != null) {
			 this.versionTag.replaceNullIDs(sender);
		 }
	 }
	 public void toData(final DataOutput out) throws IOException {
		 Object key = this.key;
		 final Object v = this.value;
		 DataSerializer.writeObject(key, out);
		 if (v instanceof byte[] || v == null) {
			 out.writeByte(0);
			 DataSerializer.writeByteArray((byte[]) v, out);
		 }
		 else if (v instanceof CachedDeserializable) {
			 CachedDeserializable cd = (CachedDeserializable) v;
			 out.writeByte(IS_CACHED_DESER);
			 DataSerializer.writeByteArray(cd.getSerializedValue(), out);
		 }
		 else {
			 out.writeByte(IS_CACHED_DESER);
			 DataSerializer.writeObjectAsByteArray(v, out);
		 }
		 out.writeByte(this.op.ordinal);
		 byte bits = this.flags;
		 if (this.filterRouting != null) bits |= FILTER_ROUTING;
		 if (this.versionTag != null) {
			 bits |= VERSION_TAG;
			 if (this.versionTag instanceof DiskVersionTag) {
				 bits |= PERSISTENT_TAG;
			 }
		 }
		 bits |= HAS_TAILKEY;
		 out.writeByte(bits);
		 if (this.filterRouting != null) {
			 DataSerializer.writeObject(this.filterRouting, out);
		 }
		 if (this.versionTag != null) {
			 InternalDataSerializer.invokeToData(this.versionTag, out);
		 }
		 if (isUsedFakeEventId()) {
			 InternalDataSerializer.invokeToData(this.eventID, out);
		 }
		 DataSerializer.writeLong(this.tailKey, out);
	 }
	 public Object getKey() {
		 return this.key;
	 }
	 public Object getValue(InternalCache cache) {
		 Object result = this.value;
		 if (result instanceof FutureCachedDeserializable) {
			 FutureCachedDeserializable future = (FutureCachedDeserializable) result;
			 result = future.create(cache);
			 this.value = result;
		 }
		 return result;
	 }
	 public Object getOldValue() {
		 return this.oldValue;
	 }
	 public Long getTailKey() {
		 return this.tailKey;
	 }
	 public void setTailKey(Long key) {
		 this.tailKey = key;
	 }
	 public Operation getOp() {
		 return this.op;
	 }
	 public EventID getEventID() {
		 return this.eventID;
	 }
	 public void setEventId(EventID eventId) {
		 this.eventID = eventId;
	 }
	 public void setBucketId(Integer bucketId) {
		 this.bucketId = bucketId;
	 }
	 public Integer getBucketId() {
		 return this.bucketId;
	 }
	 public boolean setFakeEventID() {
		 if (bucketId.intValue() < 0) {
			 return false;
		 }
		 if (!isUsedFakeEventId()) {
			 long threadId = ThreadIdentifier.createFakeThreadIDForBulkOp(bucketId.intValue(), eventID.getThreadID());
			 this.eventID = new EventID(eventID.getMembershipID(), threadId, eventID.getSequenceID());
			 this.setUsedFakeEventId(true);
		 }
		 return true;
	 }
	 public boolean isUsedFakeEventId() {
		 return (flags & USED_FAKE_EVENT_ID) != 0;
	 }
	 public void setUsedFakeEventId(boolean usedFakeEventId) {
		 if (usedFakeEventId) {
			 flags |= USED_FAKE_EVENT_ID;
		 }
		 else {
			 flags &= ~(USED_FAKE_EVENT_ID);
		 }
	 }
	 public boolean isNotifyOnly() {
		 return (flags & NOTIFY_ONLY) != 0;
	 }
	 public void setNotifyOnly(boolean notifyOnly) {
		 if (notifyOnly) {
			 flags |= NOTIFY_ONLY;
		 }
		 else {
			 flags &= ~(NOTIFY_ONLY);
		 }
	 }
	 boolean isPossibleDuplicate() {
		 return (this.flags & POSDUP) != 0;
	 }
	 public void setPossibleDuplicate(boolean possibleDuplicate) {
		 if (possibleDuplicate) {
			 flags |= POSDUP;
		 }
		 else {
			 flags &= ~(POSDUP);
		 }
	 }
	 public boolean isInhibitDistribution() {
		 return this.inhibitDistribution;
	 }
	 public void setInhibitDistribution(boolean inhibitDistribution) {
		 this.inhibitDistribution = inhibitDistribution;
	 }
	 public boolean isCallbacksInvoked() {
		 return this.callbacksInvoked;
	 }
	 public void setCallbacksInvoked(boolean callbacksInvoked) {
		 this.callbacksInvoked = callbacksInvoked;
	 }
 }",1,1,0,0
"public class TestRunConfiguration extends AbstractCorrosionTest {
	public void testErrorPopup() {
		Shell errorPopup = getErrorPopup();
		if (errorPopup != null) {
			errorPopup.close();
		}
	}
	public void testBasicRun() throws IOException, CoreException, InterruptedException {
		CargoRunDelegate delegate = new CargoRunDelegate();
		IProject project = getProject(BASIC_PROJECT_NAME);
		delegate.launch(new StructuredSelection(project), ""run"");
		new DisplayHelper() {
			protected boolean condition() {
				return DebugPlugin.getDefault().getLaunchManager().getProcesses().length != 0 || getErrorPopup() != null;
			}
		}
		.waitForCondition(Display.getCurrent(), 15000);
		assertNull(getErrorPopup());
		assertTrue(DebugPlugin.getDefault().getLaunchManager().getProcesses().length != 0);
		for (IProcess process : DebugPlugin.getDefault().getLaunchManager().getProcesses()) {
			if (process.getLabel().equals(""cargo run"")) {
				while (!process.isTerminated()) {
					Thread.sleep(50);
				}
				assertEquals(0, process.getExitValue());
				return;
			}
		}
	}
	public void testFailOnFakeProjectName() throws IOException, CoreException {
		IProject project = getProject(BASIC_PROJECT_NAME);
		ILaunchConfigurationWorkingCopy launchConfiguration = createLaunchConfiguration(project);
		launchConfiguration.setAttribute(""PROJECT"", ""fakeProjectName"");
		confirmErrorPopup(launchConfiguration);
	}
	public void testFailOnDeletedProject() throws IOException, CoreException {
		IProject project = getProject(BASIC_PROJECT_NAME);
		ILaunchConfigurationWorkingCopy launchConfiguration = createLaunchConfiguration(project);
		project.delete(true, new NullProgressMonitor());
		confirmErrorPopup(launchConfiguration);
	}
	public void testFailOnNonCargoProject() throws IOException, CoreException {
		IProject project = getProject(NOT_CARGO_PROJECT_NAME);
		ILaunchConfigurationWorkingCopy launchConfiguration = createLaunchConfiguration(project);
		confirmErrorPopup(launchConfiguration);
	}
	public void testTranslateVariablesInBuildCommand() throws InterruptedException, IOException, CoreException {
		IProject project = getProject(BASIC_PROJECT_NAME);
		ILaunchConfigurationWorkingCopy launchConfiguration = createLaunchConfiguration(project);
		launchConfiguration.setAttribute(""BUILD_COMMAND"", ""-- ${
		workspace_loc}
		"");
		ILaunch launch = launchConfiguration.launch(ILaunchManager.RUN_MODE, new NullProgressMonitor());
		new DisplayHelper() {
			protected boolean condition() {
				return launch.getProcesses().length != 0;
			}
		}
		.waitForCondition(Display.getDefault(), 15000);
		for (IProcess process : launch.getProcesses()) {
			if (process.getLabel().equals(""cargo run"")) {
				while (!process.isTerminated()) {
					Thread.sleep(50);
				}
				String command = process.getAttribute(IProcess.ATTR_CMDLINE);
				assertTrue(command.matches("".*"" + ResourcesPlugin.getWorkspace().getRoot().getLocation().toString() + "".*""));
				assertEquals(0, process.getExitValue());
				return;
			}
		}
		fail();
	}
	private static ILaunchConfigurationWorkingCopy createLaunchConfiguration(IProject project) throws CoreException {
		ILaunchManager launchManager = DebugPlugin.getDefault().getLaunchManager();
		ILaunchConfigurationType configType = launchManager.getLaunchConfigurationType(""org.eclipse.corrosion.run.CargoRunDelegate"");
		ILaunchConfigurationWorkingCopy wc = configType.newInstance(project, ""launch"");
		wc.setAttribute(""PROJECT"", project.getName());
		return wc;
	}
	private static void confirmErrorPopup(ILaunchConfiguration configuration) throws CoreException {
		configuration.launch(ILaunchManager.RUN_MODE, new NullProgressMonitor());
		new DisplayHelper() {
			protected boolean condition() {
				return getErrorPopup() != null;
			}
		}
		.waitForCondition(Display.getDefault(), 15000);
		assertNotNull(getErrorPopup());
	}
	private static Shell getErrorPopup() {
		for (Shell shell : Display.getDefault().getShells()) {
			if (shell.getText().equals(""Unable to Launch"")) {
				return shell;
			}
		}
		return null;
	}
}",0,0,0,0
"public class UUEncoder {
	 protected static final int DEFAULT_MODE = 644;
	 private static final int MAX_CHARS_PER_LINE = 45;
	 private static final int INPUT_BUFFER_SIZE = MAX_CHARS_PER_LINE * 100;
	 private OutputStream out;
	 private String name;
	 public UUEncoder(String name) {
		 this.name = name;
	 }
	 public void encode(InputStream is, OutputStream out) throws IOException {
		 this.out = out;
		 encodeBegin();
		 byte[] buffer = new byte[INPUT_BUFFER_SIZE];
		 int count;
		 while ((count = is.read(buffer, 0, buffer.length)) != -1) {
			 int pos = 0;
			 while (count > 0) {
				 int num = count > MAX_CHARS_PER_LINE ? MAX_CHARS_PER_LINE : count;
				 encodeLine(buffer, pos, num, out);
				 pos += num;
				 count -= num;
			 }
		 }
		 out.flush();
		 encodeEnd();
	 }
	 private void encodeString(String n) throws IOException {
		 PrintStream writer = new PrintStream(out);
		 writer.print(n);
		 writer.flush();
	 }
	 private void encodeBegin() throws IOException {
		 encodeString(""begin "" + DEFAULT_MODE + "" "" + name + ""\n"");
	 }
	 private void encodeEnd() throws IOException {
		 encodeString("" \nend\n"");
	 }
	 private void encodeLine( byte[] data, int offset, int length, OutputStream out) throws IOException {
		 out.write((byte) ((length & 0x3F) + ' '));
		 byte a;
		 byte b;
		 byte c;
		 for (int i = 0;
		 i < length;
		) {
			 b = 1;
			 c = 1;
			 a = data[offset + i++];
			 if (i < length) {
				 b = data[offset + i++];
				 if (i < length) {
					 c = data[offset + i++];
				 }
			 }
			 byte d1 = (byte) (((a >>> 2) & 0x3F) + ' ');
			 byte d2 = (byte) ((((a << 4) & 0x30) | ((b >>> 4) & 0x0F)) + ' ');
			 byte d3 = (byte) ((((b << 2) & 0x3C) | ((c >>> 6) & 0x3)) + ' ');
			 byte d4 = (byte) ((c & 0x3F) + ' ');
			 out.write(d1);
			 out.write(d2);
			 out.write(d3);
			 out.write(d4);
		 }
		 out.write('\n');
	 }
}",0,0,0,0
"public class DefaultMessagePropertiesConverter implements MessagePropertiesConverter {
	private static final int DEFAULT_LONG_STRING_LIMIT = 1024;
	private final int longStringLimit;
	private final boolean convertLongLongStrings;
	public DefaultMessagePropertiesConverter() {
		this(DEFAULT_LONG_STRING_LIMIT, false);
	}
	public DefaultMessagePropertiesConverter(int longStringLimit) {
		this(longStringLimit, false);
	}
	public DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) {
		this.longStringLimit = longStringLimit;
		this.convertLongLongStrings = convertLongLongStrings;
	}
	public MessageProperties toMessageProperties(final BasicProperties source, final Envelope envelope,final String charset) {
		MessageProperties target = new MessageProperties();
		Map<String, Object> headers = source.getHeaders();
		if (!CollectionUtils.isEmpty(headers)) {
			for (Map.Entry<String, Object> entry : headers.entrySet()) {
				String key = entry.getKey();
				if (MessageProperties.X_DELAY.equals(key)) {
					Object value = entry.getValue();
					if (value instanceof Integer) {
						target.setReceivedDelay((Integer) value);
					}
				}
				else {
					target.setHeader(key, convertLongStringIfNecessary(entry.getValue(), charset));
				}
			}
		}
		target.setTimestamp(source.getTimestamp());
		target.setMessageId(source.getMessageId());
		target.setReceivedUserId(source.getUserId());
		target.setAppId(source.getAppId());
		target.setClusterId(source.getClusterId());
		target.setType(source.getType());
		Integer deliveryMode = source.getDeliveryMode();
		if (deliveryMode != null) {
			target.setReceivedDeliveryMode(MessageDeliveryMode.fromInt(deliveryMode));
		}
		target.setDeliveryMode(null);
		target.setExpiration(source.getExpiration());
		target.setPriority(source.getPriority());
		target.setContentType(source.getContentType());
		target.setContentEncoding(source.getContentEncoding());
		String correlationId = source.getCorrelationId();
		if (StringUtils.hasText(correlationId)) {
			target.setCorrelationId(source.getCorrelationId());
		}
		String replyTo = source.getReplyTo();
		if (replyTo != null) {
			target.setReplyTo(replyTo);
		}
		if (envelope != null) {
			target.setReceivedExchange(envelope.getExchange());
			target.setReceivedRoutingKey(envelope.getRoutingKey());
			target.setRedelivered(envelope.isRedeliver());
			target.setDeliveryTag(envelope.getDeliveryTag());
		}
		return target;
	}
	public BasicProperties fromMessageProperties(final MessageProperties source, final String charset) {
		BasicProperties.Builder target = new BasicProperties.Builder();
		target.headers(this.convertHeadersIfNecessary(source.getHeaders())).timestamp(source.getTimestamp()).messageId(source.getMessageId()).userId(source.getUserId()).appId(source.getAppId()).clusterId(source.getClusterId()).type(source.getType());
		MessageDeliveryMode deliveryMode = source.getDeliveryMode();
		if (deliveryMode != null) {
			target.deliveryMode(MessageDeliveryMode.toInt(deliveryMode));
		}
		target.expiration(source.getExpiration()).priority(source.getPriority()).contentType(source.getContentType()).contentEncoding(source.getContentEncoding());
		String correlationId = source.getCorrelationId();
		if (StringUtils.hasText(correlationId)) {
			target.correlationId(correlationId);
		}
		String replyTo = source.getReplyTo();
		if (replyTo != null) {
			target.replyTo(replyTo);
		}
		return target.build();
	}
	private Map<String, Object> convertHeadersIfNecessary(Map<String, Object> headers) {
		if (CollectionUtils.isEmpty(headers)) {
			return Collections.<String, Object>emptyMap();
		}
		Map<String, Object> writableHeaders = new HashMap<String, Object>();
		for (Map.Entry<String, Object> entry : headers.entrySet()) {
			writableHeaders.put(entry.getKey(), this.convertHeaderValueIfNecessary(entry.getValue()));
		}
		return writableHeaders;
	}
	private Object convertHeaderValueIfNecessary( Object valueArg) {
		Object value = valueArg;
		boolean valid = (value instanceof String) || (value instanceof byte[]) || (value instanceof Boolean)|| (value instanceof LongString) || (value instanceof Integer) || (value instanceof Long)|| (value instanceof Float) || (value instanceof Double) || (value instanceof BigDecimal)|| (value instanceof Short) || (value instanceof Byte) || (value instanceof Date)|| (value instanceof List) || (value instanceof Map) || (value instanceof Object[]);
		if (!valid && value != null) {
			value = value.toString();
		}
		else if (value instanceof Object[]) {
			Object[] array = (Object[]) value;
			Object[] writableArray = new Object[array.length];
			for (int i = 0;
			 i < writableArray.length;
			 i++) {
				writableArray[i] = convertHeaderValueIfNecessary(array[i]);
			}
			value = writableArray;
		}
		else if (value instanceof List<?>) {
			List<Object> writableList = new ArrayList<Object>(((List<?>) value).size());
			for (Object listValue : (List<?>) value) {
				writableList.add(convertHeaderValueIfNecessary(listValue));
			}
			value = writableList;
		}
		else if (value instanceof Map<?, ?>) {
			Map<String, Object> originalMap = (Map<String, Object>) value;
			Map<String, Object> writableMap = new HashMap<String, Object>(originalMap.size());
			for (Map.Entry<String, Object> entry : originalMap.entrySet()) {
				writableMap.put(entry.getKey(), this.convertHeaderValueIfNecessary(entry.getValue()));
			}
			value = writableMap;
		}
		return value;
	}
	private Object convertLongString(LongString longString, String charset) {
		try {
			if (longString.length() <= this.longStringLimit) {
				return new String(longString.getBytes(), charset);
			}
			else {
				return this.convertLongLongStrings ? longString.getStream() : longString;
			}
		}
		catch (Exception e) {
			throw RabbitExceptionTranslator.convertRabbitAccessException(e);
		}
	}
	private Object convertLongStringIfNecessary(Object valueArg, String charset) {
		Object value = valueArg;
		if (value instanceof LongString) {
			value = convertLongString((LongString) value, charset);
		}
		else if (value instanceof List<?>) {
			List<Object> convertedList = new ArrayList<Object>(((List<?>) value).size());
			for (Object listValue : (List<?>) value) {
				convertedList.add(this.convertLongStringIfNecessary(listValue, charset));
			}
			value = convertedList;
		}
		else if (value instanceof Map<?, ?>) {
			Map<String, Object> originalMap = (Map<String, Object>) value;
			Map<String, Object> convertedMap = new HashMap<String, Object>();
			for (Map.Entry<String, Object> entry : originalMap.entrySet()) {
				convertedMap.put(entry.getKey(), this.convertLongStringIfNecessary(entry.getValue(), charset));
			}
			value = convertedMap;
		}
		return value;
	}
}",0,0,0,0
"public class IntIntTextVertexValueReader extends TextVertexValueReaderFromEachLineProcessed<IntPair> {
	 protected IntPair preprocessLine(Text line) throws IOException {
		 String[] tokens = SEPARATOR.split(line.toString());
		 return new IntPair(Integer.parseInt(tokens[0]), Integer.parseInt(tokens[1]));
	 }
	 protected IntWritable getId(IntPair data) throws IOException {
		 return new IntWritable(data.getFirst());
	 }
	 protected IntWritable getValue(IntPair data) throws IOException {
		 return new IntWritable(data.getSecond());
	 }
 }",0,0,0,0
"public class SingleCodetemplateSyntacticSequencer extends AbstractSyntacticSequencer {
	protected SingleCodetemplateGrammarAccess grammarAccess;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_1_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_0_1_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_2_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_4_0_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_4_2_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_4_3_1_0_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_4_3_1_2_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_2_1_4_3_2_a;
	protected AbstractElementAlias match_Variable_WSTerminalRuleCall_3_a;
	protected void init(IGrammarAccess access) {
		grammarAccess = (SingleCodetemplateGrammarAccess) access;
		match_Variable_WSTerminalRuleCall_1_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_1());
		match_Variable_WSTerminalRuleCall_2_1_0_1_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_0_1());
		match_Variable_WSTerminalRuleCall_2_1_2_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_2());
		match_Variable_WSTerminalRuleCall_2_1_4_0_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_4_0());
		match_Variable_WSTerminalRuleCall_2_1_4_2_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_4_2());
		match_Variable_WSTerminalRuleCall_2_1_4_3_1_0_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_4_3_1_0());
		match_Variable_WSTerminalRuleCall_2_1_4_3_1_2_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_4_3_1_2());
		match_Variable_WSTerminalRuleCall_2_1_4_3_2_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_2_1_4_3_2());
		match_Variable_WSTerminalRuleCall_3_a = new TokenAlias(true, true, grammarAccess.getVariableAccess().getWSTerminalRuleCall_3());
	}
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getWSRule())return getWSToken(semanticObject, ruleCall, node);
		return """";
	}
	protected String getWSToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)return getTokenText(node);
		return "" "";
	}
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_Variable_WSTerminalRuleCall_1_a.equals(syntax))emit_Variable_WSTerminalRuleCall_1_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_0_1_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_0_1_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_2_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_2_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_4_0_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_4_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_4_2_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_4_2_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_4_3_1_0_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_4_3_1_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_4_3_1_2_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_4_3_1_2_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_2_1_4_3_2_a.equals(syntax))emit_Variable_WSTerminalRuleCall_2_1_4_3_2_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Variable_WSTerminalRuleCall_3_a.equals(syntax))emit_Variable_WSTerminalRuleCall_3_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}
	protected void emit_Variable_WSTerminalRuleCall_1_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_0_1_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_2_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_4_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_4_2_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_4_3_1_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_4_3_1_2_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_2_1_4_3_2_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	protected void emit_Variable_WSTerminalRuleCall_3_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
}",0,0,0,0
"public void updateDigest(MessageDigest digest) {
	 digest.update(name.duplicate());
	 digest.update(value.duplicate());
	 DataOutputBuffer buffer = new DataOutputBuffer();
	 try {
		 buffer.writeLong(timestamp);
		 buffer.writeByte((isMarkedForDelete()) ? ColumnSerializer.DELETION_MASK : 0);
	 }
	 catch (IOException e) {
		 throw new RuntimeException(e);
	 }
	 digest.update(buffer.getData(), 0, buffer.getLength());
 }",0,0,0,0
"public class Or extends ResourceSelectorContainer implements ResourceSelector {
	 public Or() {
	 }
	 public Or(ResourceSelector[] r) {
		 super(r);
	 }
	 public boolean isSelected(Resource r) {
		 for (Iterator i = getSelectors();
		 i.hasNext();
		) {
			 if (((ResourceSelector) i.next()).isSelected(r)) {
				 return true;
			 }
		 }
		 return false;
	 }
}",0,0,0,0
"public int run(String[] args) throws IOException {
	 String srcPath = null;
	 String destPath = null;
	 boolean ignoreReadFailures = false;
	 for (int idx = 0;
	 idx < args.length;
	 idx++) {
		 if (""-i"".equals(args[idx])) {
			 ignoreReadFailures = true;
		 }
		 else if (srcPath == null) {
			 srcPath = args[idx];
		 }
		 else if (destPath == null) {
			 destPath = args[idx];
		 }
		 else {
			 System.out.println(usage);
			 return -1;
		 }
	 }
	 if (srcPath == null || destPath == null) {
		 System.out.println(usage);
		 return -1;
	 }
	 URI srcurl = null;
	 URI desturl = null;
	 try {
		 srcurl = new URI(srcPath);
		 desturl = new URI(destPath);
	 }
	 catch (URISyntaxException ex) {
		 throw new RuntimeException(""URL syntax error."", ex);
	 }
	 JobConf jobConf = (JobConf)conf;
	 jobConf.setJobName(""copy-files"");
	 String srcFileSysName = getFileSysName(srcurl);
	 String destFileSysName = getFileSysName(desturl);
	 jobConf.set(""copy.src.fs"", srcFileSysName);
	 jobConf.set(""copy.dest.fs"", destFileSysName);
	 FileSystem srcfs;
	 srcfs = FileSystem.getNamed(srcFileSysName, jobConf);
	 FileSystem destfs = FileSystem.getNamed(destFileSysName, jobConf);
	 srcPath = srcurl.getPath();
	 if ("""".equals(srcPath)) {
		 srcPath = ""/"";
	 }
	 destPath = desturl.getPath();
	 if ("""".equals(destPath)) {
		 destPath = ""/"";
	 }
	 Path tmpPath = new Path(srcPath);
	 Path rootPath = new Path(srcPath);
	 if (srcfs.isFile(tmpPath)) {
		 tmpPath = tmpPath.getParent();
		 rootPath = rootPath.getParent();
		 jobConf.set(""copy.src.path"", tmpPath.toString());
	 }
	 else {
		 jobConf.set(""copy.src.path"", srcPath);
	 }
	 jobConf.set(""copy.dest.path"", destPath);
	 if (!srcfs.exists(tmpPath)) {
		 System.out.println(srcPath+"" does not exist."");
		 return -1;
	 }
	 jobConf.setSpeculativeExecution(false);
	 jobConf.setInputKeyClass(UTF8.class);
	 jobConf.setInputValueClass(UTF8.class);
	 jobConf.setInputFormat(SequenceFileInputFormat.class);
	 jobConf.setOutputKeyClass(UTF8.class);
	 jobConf.setOutputValueClass(UTF8.class);
	 jobConf.setOutputFormat(SequenceFileOutputFormat.class);
	 jobConf.setMapperClass(CopyFilesMapper.class);
	 jobConf.setReducerClass(CopyFilesReducer.class);
	 jobConf.setNumReduceTasks(1);
	 jobConf.setBoolean(readFailuresAttribute, ignoreReadFailures);
	 Path tmpDir = new Path(""copy-files"");
	 Path inDir = new Path(tmpDir, ""in"");
	 Path fakeOutDir = new Path(tmpDir, ""out"");
	 FileSystem fileSys = FileSystem.get(jobConf);
	 fileSys.delete(tmpDir);
	 fileSys.mkdirs(inDir);
	 jobConf.setInputPath(inDir);
	 jobConf.setOutputPath(fakeOutDir);
	 ArrayList pathList = new ArrayList();
	 ArrayList finalPathList = new ArrayList();
	 pathList.add(new Path(srcPath));
	 long totalBytes = 0;
	 while(!pathList.isEmpty()) {
		 Path top = (Path) pathList.remove(0);
		 if (srcfs.isFile(top)) {
			 totalBytes += srcfs.getLength(top);
			 top = makeRelative(rootPath, top);
			 finalPathList.add(top.toString());
		 }
		 else {
			 Path[] paths = srcfs.listPaths(top);
			 for (int idx = 0;
			 idx < paths.length;
			 idx++) {
				 pathList.add(paths[idx]);
			 }
		 }
	 }
	 int nFiles = finalPathList.size();
	 int numMaps = nFiles;
	 if (numMaps > MAX_NUM_MAPS) {
		 numMaps = MAX_NUM_MAPS;
	 }
	 if (numMaps > (int) (totalBytes / MIN_BYTES_PER_MAP)) {
		 numMaps = (int) (totalBytes / MIN_BYTES_PER_MAP);
	 }
	 JobClient client = new JobClient(jobConf);
	 ClusterStatus cluster = client.getClusterStatus();
	 int tmpMaps = cluster.getTaskTrackers() * MAX_MAPS_PER_NODE;
	 if (numMaps > tmpMaps) {
		 numMaps = tmpMaps;
	 }
	 if (numMaps == 0) {
		 numMaps = 1;
	 }
	 jobConf.setNumMapTasks(numMaps);
	 for(int idx=0;
	 idx < numMaps;
	 ++idx) {
		 Path file = new Path(inDir, ""part""+idx);
		 SequenceFile.Writer writer = new SequenceFile.Writer(fileSys, file, UTF8.class, UTF8.class);
		 for (int ipath = idx;
		 ipath < nFiles;
		 ipath += numMaps) {
			 String path = (String) finalPathList.get(ipath);
			 writer.append(new UTF8(path), new UTF8(""""));
		 }
		 writer.close();
	 }
	 finalPathList = null;
	 int exitCode = -1;
	 try {
		 JobClient.runJob(jobConf);
		 exitCode = 0;
	 }
	 finally {
		 fileSys.delete(tmpDir);
	 }
	 return exitCode;
 }",0,0,1,0
"public class MethodEffector<T> extends AbstractEffector<T> {
	 private static final long serialVersionUID = 6989688364011965968L;
	 private static final Logger log = LoggerFactory.getLogger(MethodEffector.class);
	 public static Effector<?> create(Method m) {
		 return new MethodEffector(m);
	 }
	 protected static class AnnotationsOnMethod {
		 final Class<?> clazz;
		 final String name;
		 final String description;
		 final Class<?> returnType;
		 final List<ParameterType<?>> parameters;
		 public AnnotationsOnMethod(Class<?> clazz, String methodName) {
			 this(clazz, inferBestMethod(clazz, methodName));
		 }
		 public AnnotationsOnMethod(Class<?> clazz, Method method) {
			 this.clazz = clazz;
			 this.name = method.getName();
			 this.returnType = method.getReturnType();
			 org.apache.brooklyn.core.annotation.Effector effectorAnnotation = method.getAnnotation(org.apache.brooklyn.core.annotation.Effector.class);
			 description = (effectorAnnotation != null) ? effectorAnnotation.description() : null;
			 parameters = Lists.newArrayList();
			 int numParameters = method.getParameterTypes().length;
			 for (int i = 0;
			 i < numParameters;
			 i++) {
				 parameters.add(toParameterType(method, i));
			 }
		 }
		 protected static ParameterType<?> toParameterType(Method method, int paramIndex) {
			 Annotation[] anns = method.getParameterAnnotations()[paramIndex];
			 Class<?> type = method.getParameterTypes()[paramIndex];
			 EffectorParam paramAnnotation = findAnnotation(anns, EffectorParam.class);
			 String name = (paramAnnotation != null) ? paramAnnotation.name() : null;
			 String paramDescription = (paramAnnotation == null || EffectorParam.MAGIC_STRING_MEANING_NULL.equals(paramAnnotation.description())) ? null : paramAnnotation.description();
			 String description = (paramDescription != null) ? paramDescription : null;
			 String paramDefaultValue = (paramAnnotation == null || EffectorParam.MAGIC_STRING_MEANING_NULL.equals(paramAnnotation.defaultValue())) ? null : paramAnnotation.defaultValue();
			 Object defaultValue = (paramDefaultValue != null) ? TypeCoercions.coerce(paramDefaultValue, type) : null;
			 return new BasicParameterType(name, type, description, defaultValue);
		 }
		 protected static <T extends Annotation> T findAnnotation(Annotation[] anns, Class<T> type) {
			 for (Annotation ann : anns) {
				 if (type.isInstance(ann)) return (T) ann;
			 }
			 return null;
		 }
		 protected static Method inferBestMethod(Class<?> clazz, String methodName) {
			 Method best = null;
			 for (Method it : clazz.getMethods()) {
				 if (it.getName().equals(methodName)) {
					 if (best==null || best.getParameterTypes().length < it.getParameterTypes().length) best=it;
				 }
			 }
			 if (best==null) {
				 throw new IllegalStateException(""Cannot find method ""+methodName+"" on ""+clazz.getCanonicalName());
			 }
			 return best;
		 }
	 }
	 public MethodEffector(Class<?> whereEffectorDefined, String methodName) {
		 this(new AnnotationsOnMethod(whereEffectorDefined, methodName), null);
	 }
	 public MethodEffector(Method method) {
		 this(new AnnotationsOnMethod(method.getDeclaringClass(), method), null);
	 }
	 public MethodEffector(MethodClosure mc) {
		 this(new AnnotationsOnMethod((Class<?>)mc.getDelegate(), mc.getMethod()), null);
	 }
	 protected MethodEffector(AnnotationsOnMethod anns, String description) {
		 super(anns.name, (Class<T>)anns.returnType, anns.parameters, JavaGroovyEquivalents.elvis(description, anns.description));
	 }
	 public T call(Entity entity, Map parameters) {
		 if (entity instanceof AbstractEntity) {
			 return EffectorUtils.invokeMethodEffector(entity, this, (Map<String,?>)parameters);
		 }
		 else {
			 Object[] parametersArray = EffectorUtils.prepareArgsForEffector(this, parameters);
			 Method[] methods = entity.getClass().getMethods();
			 for (Method method : methods) {
				 if (method.getName().equals(getName())) {
					 if (parametersArray.length == method.getParameterTypes().length) {
						 try {
							 return (T) method.invoke(entity, parametersArray);
						 }
						 catch (Exception e) {
							 throw Exceptions.propagate(e);
						 }
					 }
				 }
			 }
			 String msg = ""Could not find method for effector ""+getName()+"" with ""+parametersArray.length+"" parameters on ""+entity;
			 log.warn(msg+"" (throwing);
			 available methods are: ""+Arrays.toString(methods));
			 throw new IllegalStateException(msg);
		 }
	 }
}",0,0,0,0
"public class JobControlCompiler{
	 MROperPlan plan;
	 Configuration conf;
	 Configuration defaultConf;
	 PigContext pigContext;
	 private static final Matcher DISTRIBUTED_CACHE_ARCHIVE_MATCHER = Pattern .compile(""\\.(zip|tgz|tar\\.gz|tar)$"").matcher("""");
	 private static final Log log = LogFactory.getLog(JobControlCompiler.class);
	 public static final String LOG_DIR = ""_logs"";
	 public static final String END_OF_INP_IN_MAP = ""pig.invoke.close.in.map"";
	 public static final String PIG_MAP_COUNTER = ""pig.counters.counter_"";
	 public static final String PIG_MAP_RANK_NAME = ""pig.rank_"";
	 public static final String PIG_MAP_SEPARATOR = ""_"";
	 public HashMap<String, ArrayList<Pair<String,Long>>> globalCounters = new HashMap<String, ArrayList<Pair<String,Long>>>();
	 private static final Random RAND = new Random();
	 private static final String CACHE_TMP_FILE_TEMPLATE = ""tmp%d.tmp"";
	 public static final String SMALL_JOB_LOG_MSG = ""This job was detected as a small job, will run in-process instead"";
	 public static final String BIG_JOB_LOG_MSG = ""This job cannot be converted run in-process"";
	 public static final String PIG_MAP_STORES = ""pig.map.stores"";
	 public static final String PIG_REDUCE_STORES = ""pig.reduce.stores"";
	 private Map<Job, Pair<List<POStore>, Path>> jobStoreMap;
	 private Map<Job, MapReduceOper> jobMroMap;
	 public JobControlCompiler(PigContext pigContext, Configuration conf) {
		 this(pigContext, conf, null);
	 }
	 public JobControlCompiler(PigContext pigContext, Configuration conf, Configuration defaultConf) {
		 this.pigContext = pigContext;
		 this.conf = conf;
		 this.defaultConf = defaultConf;
		 jobStoreMap = new HashMap<Job, Pair<List<POStore>, Path>>();
		 jobMroMap = new HashMap<Job, MapReduceOper>();
	 }
	 public List<POStore> getStores(Job job) {
		 Pair<List<POStore>, Path> pair = jobStoreMap.get(job);
		 if (pair != null && pair.first != null) {
			 return pair.first;
		 }
		 else {
			 return new ArrayList<POStore>();
		 }
	 }
	 public void reset() {
		 jobStoreMap = new HashMap<Job, Pair<List<POStore>, Path>>();
		 jobMroMap = new HashMap<Job, MapReduceOper>();
		 UDFContext.getUDFContext().reset();
	 }
	 public Map<Job, MapReduceOper> getJobMroMap() {
		 return Collections.unmodifiableMap(jobMroMap);
	 }
	 public void moveResults(List<Job> completedJobs) throws IOException {
		 for (Job job: completedJobs) {
			 Pair<List<POStore>, Path> pair = jobStoreMap.get(job);
			 if (pair != null && pair.second != null) {
				 Path tmp = pair.second;
				 Path abs = new Path(tmp, ""abs"");
				 Path rel = new Path(tmp, ""rel"");
				 FileSystem fs = tmp.getFileSystem(conf);
				 if (fs.exists(abs)) {
					 moveResults(abs, abs.toUri().getPath(), fs);
				 }
				 if (fs.exists(rel)) {
					 moveResults(rel, rel.toUri().getPath()+""/"", fs);
				 }
			 }
		 }
	 }
	 private void moveResults(Path p, String rem, FileSystem fs) throws IOException {
		 for (FileStatus fstat: fs.listStatus(p)) {
			 Path src = fstat.getPath();
			 if (fstat.isDir()) {
				 log.info(""mkdir: ""+src);
				 fs.mkdirs(removePart(src, rem));
				 moveResults(fstat.getPath(), rem, fs);
			 }
			 else {
				 Path dst = removePart(src, rem);
				 log.info(""mv: ""+src+"" ""+dst);
				 fs.rename(src,dst);
			 }
		 }
	 }
	 private Path removePart(Path src, String part) {
		 URI uri = src.toUri();
		 String pathStr = uri.getPath().replace(part, """");
		 return new Path(pathStr);
	 }
	 public JobControl compile(MROperPlan plan, String grpName) throws JobCreationException{
		 this.plan = plan;
		 int timeToSleep;
		 String defaultPigJobControlSleep = pigContext.getExecType().isLocal() ? ""100"" : ""5000"";
		 String pigJobControlSleep = conf.get(""pig.jobcontrol.sleep"", defaultPigJobControlSleep);
		 if (!pigJobControlSleep.equals(defaultPigJobControlSleep)) {
			 log.info(""overriding default JobControl sleep ("" + defaultPigJobControlSleep + "") to "" + pigJobControlSleep);
		 }
		 try {
			 timeToSleep = Integer.parseInt(pigJobControlSleep);
		 }
		 catch (NumberFormatException e) {
			 throw new RuntimeException(""Invalid configuration "" + ""pig.jobcontrol.sleep="" + pigJobControlSleep + "" should be a time in ms. default="" + defaultPigJobControlSleep, e);
		 }
		 JobControl jobCtrl = new PigJobControl(grpName, timeToSleep);
		 try {
			 List<MapReduceOper> roots = new LinkedList<MapReduceOper>();
			 roots.addAll(plan.getRoots());
			 for (MapReduceOper mro: roots) {
				 if(mro instanceof NativeMapReduceOper) {
					 return null;
				 }
				 if (conf.getBoolean(PigConfiguration.PIG_PRINT_EXEC_PLAN, false)) {
					 log.info(mro.toString());
				 }
				 Job job = getJob(plan, mro, conf, pigContext);
				 jobMroMap.put(job, mro);
				 jobCtrl.addJob(job);
			 }
		 }
		 catch (JobCreationException jce) {
			 throw jce;
		 }
		 catch(Exception e) {
			 int errCode = 2017;
			 String msg = ""Internal error creating job configuration."";
			 throw new JobCreationException(msg, errCode, PigException.BUG, e);
		 }
		 return jobCtrl;
	 }
	 public int updateMROpPlan(List<Job> completeFailedJobs) {
		 int sizeBefore = plan.size();
		 for (Job job : completeFailedJobs) {
			 MapReduceOper mrOper = jobMroMap.get(job);
			 plan.trimBelow(mrOper);
			 plan.remove(mrOper);
		 }
		 for (Job job : jobMroMap.keySet()) {
			 if (!completeFailedJobs.contains(job)) {
				 MapReduceOper mro = jobMroMap.get(job);
				 if (!pigContext.inIllustrator && mro.isCounterOperation()) saveCounters(job,mro.getOperationID(), mro.isRowNumber());
				 plan.remove(mro);
			 }
		 }
		 jobMroMap.clear();
		 int sizeAfter = plan.size();
		 return sizeBefore-sizeAfter;
	 }
	 private void saveCounters(Job job, String operationID, boolean isRowNumber ) {
		 Counters counters;
		 Group groupCounters;
		 int counterSize = -1;
		 Long previousValue = 0L;
		 Long previousSum = 0L;
		 ArrayList<Pair<String,Long>> counterPairs;
		 try {
			 counters = MRJobStats.getCounters(job);
			 String groupName = getGroupName(counters.getGroupNames());
			 if (groupName == null) {
				 Counter outputRecords = counters.getGroup(MRPigStatsUtil.TASK_COUNTER_GROUP) .getCounterForName(MRPigStatsUtil.MAP_OUTPUT_RECORDS);
				 if(outputRecords.getCounter() == 0) {
					 globalCounters.put(operationID, new ArrayList<Pair<String, Long>>());
					 return;
				 }
				 else {
					 throw new RuntimeException(""Did not found RANK counter group for operationId: "" + operationID);
				 }
			 }
			 groupCounters = counters.getGroup(groupName);
			 TreeMap<Integer,Long> counterList = new TreeMap<Integer, Long>();
			 Iterator<Counter> it = groupCounters.iterator();
			 while (it.hasNext()) {
				 try {
					 Counter c = it.next();
					 counterList.put(Integer.valueOf(c.getDisplayName()), c.getValue());
				 }
				 catch (Exception ex) {
					 ex.printStackTrace();
				 }
			 }
			 counterSize = counterList.size();
			 counterPairs = new ArrayList<Pair<String,Long>>();
			 for (Entry<Integer, Long> entry : counterList.entrySet()) {
				 previousSum += previousValue;
				 previousValue = entry.getValue();
				 counterPairs.add(new Pair<String, Long>(JobControlCompiler.PIG_MAP_COUNTER + operationID + JobControlCompiler.PIG_MAP_SEPARATOR + entry.getKey(), previousSum));
			 }
			 globalCounters.put(operationID, counterPairs);
		 }
		 catch (Exception e) {
			 String msg = ""Error to read counters into Rank operation counterSize ""+counterSize;
			 throw new RuntimeException(msg, e);
		 }
	 }
	 private String getGroupName(Collection<String> collection) {
		 for (String name : collection) {
			 if (name.contains(PIG_MAP_RANK_NAME)) return name;
		 }
		 return null;
	 }
	 private boolean okToRunLocal(org.apache.hadoop.mapreduce.Job job, MapReduceOper mro, List<POLoad> lds) throws IOException {
		 Configuration conf = job.getConfiguration();
		 if(!conf.getBoolean(PigConfiguration.PIG_AUTO_LOCAL_ENABLED, false)) {
			 return false;
		 }
		 long inputByteMax = conf.getLong(PigConfiguration.PIG_AUTO_LOCAL_INPUT_MAXBYTES, 100*1000*1000l);
		 long totalInputFileSize = InputSizeReducerEstimator.getTotalInputFileSize(conf, lds, job, inputByteMax);
		 log.info(""Size of input: "" + totalInputFileSize +"" bytes. Small job threshold: "" + inputByteMax );
		 if (totalInputFileSize < 0 || totalInputFileSize > inputByteMax) {
			 return false;
		 }
		 int reducers = conf.getInt(MRConfiguration.REDUCE_TASKS, 1);
		 log.info(""No of reducers: "" + reducers);
		 if (reducers > 1) {
			 return false;
		 }
		 return true;
	 }
	 private Job getJob(MROperPlan plan, MapReduceOper mro, Configuration config, PigContext pigContext) throws JobCreationException{
		 org.apache.hadoop.mapreduce.Job nwJob = null;
		 try{
			 nwJob = new org.apache.hadoop.mapreduce.Job(config);
		 }
		catch(Exception e) {
			 throw new JobCreationException(e);
		 }
		 Configuration conf = nwJob.getConfiguration();
		 ArrayList<POLoad> inp = new ArrayList<POLoad>();
		 ArrayList<List<OperatorKey>> inpTargets = new ArrayList<List<OperatorKey>>();
		 ArrayList<String> inpSignatureLists = new ArrayList<String>();
		 ArrayList<Long> inpLimits = new ArrayList<Long>();
		 ArrayList<POStore> storeLocations = new ArrayList<POStore>();
		 Path tmpLocation = null;
		 String setScriptProp = conf.get(PigConfiguration.PIG_SCRIPT_INFO_ENABLED, ""true"");
		 if (setScriptProp.equalsIgnoreCase(""true"")) {
			 MRScriptState ss = MRScriptState.get();
			 ss.addSettingsToConf(mro, conf);
		 }
		 conf.set(MRConfiguration.MAPPER_NEW_API, ""true"");
		 conf.set(MRConfiguration.REDUCER_NEW_API, ""true"");
		 String buffPercent = conf.get(MRConfiguration.JOB_REDUCE_MARKRESET_BUFFER_PERCENT);
		 if (buffPercent == null || Double.parseDouble(buffPercent) <= 0) {
			 log.info(MRConfiguration.JOB_REDUCE_MARKRESET_BUFFER_PERCENT + "" is not set, set to default 0.3"");
			 conf.set(MRConfiguration.JOB_REDUCE_MARKRESET_BUFFER_PERCENT, ""0.3"");
		 }
		else{
			 log.info(MRConfiguration.JOB_REDUCE_MARKRESET_BUFFER_PERCENT + "" is set to "" + conf.get(MRConfiguration.JOB_REDUCE_MARKRESET_BUFFER_PERCENT));
		 }
		 DateTimeWritable.setupAvailableZoneIds();
		 configureCompression(conf);
		 try{
			 List<POLoad> lds = PlanHelper.getPhysicalOperators(mro.mapPlan, POLoad.class);
			 if(lds!=null && lds.size()>0){
				 for (POLoad ld : lds) {
					 LoadFunc lf = ld.getLoadFunc();
					 lf.setLocation(ld.getLFile().getFileName(), nwJob);
					 lf.addCredentials(nwJob.getCredentials(), conf);
					 ld.setParentPlan(null);
					 inp.add(ld);
				 }
			 }
			 List<POUserFunc> userFuncs = PlanHelper.getPhysicalOperators(mro.mapPlan, POUserFunc.class);
			 userFuncs.addAll(PlanHelper.getPhysicalOperators(mro.reducePlan, POUserFunc.class));
			 for (POUserFunc userFunc : userFuncs) {
				 userFunc.getFunc().addCredentials(nwJob.getCredentials(), conf);
			 }
			 if(!mro.reducePlan.isEmpty()){
				 log.info(""Reduce phase detected, estimating # of required reducers."");
				 adjustNumReducers(plan, mro, nwJob);
			 }
			 else {
				 nwJob.setNumReduceTasks(0);
			 }
			 if (!pigContext.inIllustrator && ! pigContext.getExecType().isLocal()) {
				 if (okToRunLocal(nwJob, mro, lds)) {
					 log.info(SMALL_JOB_LOG_MSG);
					 for (Entry<String, String> entry : defaultConf) {
						 String key = entry.getKey();
						 if (key.equals(MRConfiguration.REDUCE_TASKS) || key.equals(MRConfiguration.JOB_REDUCES)) {
							 continue;
						 }
						 if (key.startsWith(""fs."")) {
							 continue;
						 }
						 if (key.startsWith(""io."")) {
							 continue;
						 }
						 String value = entry.getValue();
						 if (conf.get(key) == null || !conf.get(key).equals(value)) {
							 conf.set(key, value);
						 }
					 }
					 conf.setBoolean(PigImplConstants.CONVERTED_TO_LOCAL, true);
				 }
				 else {
					 log.info(BIG_JOB_LOG_MSG);
					 List<String> cacheFiles = new ArrayList<String>();
					 List<String> shipFiles = new ArrayList<String>();
					 UdfCacheShipFilesVisitor mapUdfCacheFileVisitor = new UdfCacheShipFilesVisitor(mro.mapPlan);
					 mapUdfCacheFileVisitor.visit();
					 cacheFiles.addAll(mapUdfCacheFileVisitor.getCacheFiles());
					 shipFiles.addAll(mapUdfCacheFileVisitor.getShipFiles());
					 UdfCacheShipFilesVisitor reduceUdfCacheFileVisitor = new UdfCacheShipFilesVisitor(mro.reducePlan);
					 reduceUdfCacheFileVisitor.visit();
					 cacheFiles.addAll(reduceUdfCacheFileVisitor.getCacheFiles());
					 shipFiles.addAll(reduceUdfCacheFileVisitor.getShipFiles());
					 setupDistributedCache(pigContext, conf, cacheFiles.toArray(new String[]{
					}
					), false);
					 List<URL> allJars = new ArrayList<URL>();
					 for (URL extraJar : pigContext.extraJars) {
						 if (!allJars.contains(extraJar)) {
							 allJars.add(extraJar);
						 }
					 }
					 for (String udf : mro.UDFs) {
						 Class clazz = pigContext.getClassForAlias(udf);
						 if (clazz != null) {
							 String jar = JarManager.findContainingJar(clazz);
							 if (jar!=null) {
								 URL jarURL = new File(jar).toURI().toURL();
								 if (!allJars.contains(jarURL)) {
									 allJars.add(jarURL);
								 }
							 }
						 }
					 }
					 for (String scriptJar : pigContext.scriptJars) {
						 URL jar = new File(scriptJar).toURI().toURL();
						 if (!allJars.contains(jar)) {
							 allJars.add(jar);
						 }
					 }
					 for (String shipFile : shipFiles) {
						 URL jar = new File(shipFile).toURI().toURL();
						 if (!allJars.contains(jar)) {
							 allJars.add(jar);
						 }
					 }
					 for (String defaultJar : JarManager.getDefaultJars()) {
						 URL jar = new File(defaultJar).toURI().toURL();
						 if (!allJars.contains(jar)) {
							 allJars.add(jar);
						 }
					 }
					 for (URL jar : allJars) {
						 boolean predeployed = false;
						 for (String predeployedJar : pigContext.predeployedJars) {
							 if (predeployedJar.contains(new File(jar.toURI()).getName())) {
								 predeployed = true;
							 }
						 }
						 if (!predeployed) {
							 if (jar.getFile().toLowerCase().endsWith("".jar"")) {
								 putJarOnClassPathThroughDistributedCache(pigContext, conf, jar);
							 }
							 else {
								 setupDistributedCache(pigContext, conf, new String[] {
								jar.getPath()}
								, true);
							 }
						 }
					 }
					 File scriptUDFJarFile = JarManager.createPigScriptUDFJar(pigContext);
					 if (scriptUDFJarFile != null) {
						 putJarOnClassPathThroughDistributedCache(pigContext, conf, scriptUDFJarFile.toURI().toURL());
					 }
				 }
			 }
			 for (String udf : mro.UDFs) {
				 if (udf.contains(""GFCross"")) {
					 Object func = PigContext.instantiateFuncFromSpec(new FuncSpec(udf));
					 if (func instanceof GFCross) {
						 String crossKey = ((GFCross)func).getCrossKey();
						 conf.set(PigImplConstants.PIG_CROSS_PARALLELISM + ""."" + crossKey, Integer.toString(mro.getRequestedParallelism()));
					 }
				 }
			 }
			 if(lds!=null && lds.size()>0){
				 for (POLoad ld : lds) {
					 List<PhysicalOperator> ldSucs = mro.mapPlan.getSuccessors(ld);
					 List<OperatorKey> ldSucKeys = new ArrayList<OperatorKey>();
					 if(ldSucs!=null){
						 for (PhysicalOperator operator2 : ldSucs) {
							 ldSucKeys.add(operator2.getOperatorKey());
						 }
					 }
					 inpTargets.add(ldSucKeys);
					 inpSignatureLists.add(ld.getSignature());
					 inpLimits.add(ld.getLimit());
					 if (!pigContext.inIllustrator) mro.mapPlan.remove(ld);
				 }
			 }
			 if(Utils.isLocal(pigContext, conf)) {
				 ConfigurationUtil.replaceConfigForLocalMode(conf);
			 }
			 conf.set(PigInputFormat.PIG_LOADS, ObjectSerializer.serialize(inp));
			 conf.set(PigInputFormat.PIG_INPUT_TARGETS, ObjectSerializer.serialize(inpTargets));
			 conf.set(PigInputFormat.PIG_INPUT_SIGNATURES, ObjectSerializer.serialize(inpSignatureLists));
			 conf.set(PigInputFormat.PIG_INPUT_LIMITS, ObjectSerializer.serialize(inpLimits));
			 pigContext.getProperties().remove(""mapreduce.job.credentials.binary"");
			 conf.setBoolean(PigImplConstants.PIG_EXECTYPE_MODE_LOCAL, pigContext.getExecType().isLocal());
			 conf.set(PigImplConstants.PIG_LOG4J_PROPERTIES, ObjectSerializer.serialize(pigContext.getLog4jProperties()));
			 conf.set(""udf.import.list"", ObjectSerializer.serialize(PigContext.getPackageImportList()));
			 if (System.getProperty(MRConfiguration.JOB_NAME) == null && pigContext.getProperties().getProperty(PigContext.JOB_NAME) != null){
				 nwJob.setJobName(pigContext.getProperties().getProperty(PigContext.JOB_NAME));
			 }
			 if (pigContext.getProperties().getProperty(PigContext.JOB_PRIORITY) != null) {
				 String jobPriority = pigContext.getProperties().getProperty(PigContext.JOB_PRIORITY).toUpperCase();
				 try {
					 conf.set(MRConfiguration.JOB_PRIORITY, JobPriority.valueOf(jobPriority).toString());
				 }
				 catch (IllegalArgumentException e) {
					 StringBuffer sb = new StringBuffer(""The job priority must be one of ["");
					 JobPriority[] priorities = JobPriority.values();
					 for (int i = 0;
					 i < priorities.length;
					 ++i) {
						 if (i > 0) sb.append("", "");
						 sb.append(priorities[i]);
					 }
					 sb.append(""]. You specified ["" + jobPriority + ""]"");
					 throw new JobCreationException(sb.toString());
				 }
			 }
			 setupDistributedCache(pigContext, conf, pigContext.getProperties(), ""pig.streaming.ship.files"", true);
			 setupDistributedCache(pigContext, conf, pigContext.getProperties(), ""pig.streaming.cache.files"", false);
			 nwJob.setInputFormatClass(PigInputFormat.class);
			 Utils.setTmpFileCompressionOnConf(pigContext, conf);
			 LinkedList<POStore> mapStores = PlanHelper.getPhysicalOperators(mro.mapPlan, POStore.class);
			 LinkedList<POStore> reduceStores = PlanHelper.getPhysicalOperators(mro.reducePlan, POStore.class);
			 for (POStore st : mapStores) {
				 storeLocations.add(st);
				 StoreFuncInterface sFunc = st.getStoreFunc();
				 sFunc.setStoreLocation(st.getSFile().getFileName(), nwJob);
				 if (sFunc instanceof OverwritableStoreFunc) {
					 OverwritableStoreFunc osf = (OverwritableStoreFunc) sFunc;
					 if (osf.shouldOverwrite()) {
						 osf.cleanupOutput(st, nwJob);
					 }
				 }
				 sFunc.addCredentials(nwJob.getCredentials(), conf);
			 }
			 for (POStore st : reduceStores) {
				 storeLocations.add(st);
				 StoreFuncInterface sFunc = st.getStoreFunc();
				 sFunc.setStoreLocation(st.getSFile().getFileName(), nwJob);
				 if (sFunc instanceof OverwritableStoreFunc) {
					 OverwritableStoreFunc osf = (OverwritableStoreFunc) sFunc;
					 if (osf.shouldOverwrite()) {
						 osf.cleanupOutput(st, nwJob);
					 }
				 }
				 sFunc.addCredentials(nwJob.getCredentials(), conf);
			 }
			 setOutputFormat(nwJob);
			 if (mapStores.size() + reduceStores.size() == 1) {
				 log.info(""Setting up single store job"");
				 POStore st;
				 if (reduceStores.isEmpty()) {
					 st = mapStores.get(0);
					 if(!pigContext.inIllustrator) mro.mapPlan.remove(st);
				 }
				 else {
					 st = reduceStores.get(0);
					 if(!pigContext.inIllustrator) mro.reducePlan.remove(st);
				 }
				 MapRedUtil.setupStreamingDirsConfSingle(st, pigContext, conf);
			 }
			 else if (mapStores.size() + reduceStores.size() > 0) {
				 log.info(""Setting up multi store job"");
				 MapRedUtil.setupStreamingDirsConfMulti(pigContext, conf);
				 boolean disableCounter = conf.getBoolean(""pig.disable.counter"", false);
				 if (disableCounter) {
					 log.info(""Disable Pig custom output counters"");
				 }
				 int idx = 0;
				 for (POStore sto: storeLocations) {
					 sto.setDisableCounter(disableCounter);
					 sto.setMultiStore(true);
					 sto.setIndex(idx++);
				 }
			 }
			 conf.set(""pig.map.keytype"", ObjectSerializer.serialize(new byte[] {
			 mro.mapKeyType }
			));
			 new PhyPlanSetter(mro.mapPlan).visit();
			 new PhyPlanSetter(mro.combinePlan).visit();
			 new PhyPlanSetter(mro.reducePlan).visit();
			 setupDistributedCacheForJoin(mro, pigContext, conf);
			 SchemaTupleFrontend.copyAllGeneratedToDistributedCache(pigContext, conf);
			 POPackage pack = null;
			 if(mro.reducePlan.isEmpty()){
				 nwJob.setMapperClass(PigMapOnly.Map.class);
				 if(!pigContext.inIllustrator) conf.set(""pig.mapPlan"", ObjectSerializer.serialize(mro.mapPlan));
				 if(mro.isEndOfAllInputSetInMap()) {
					 conf.set(END_OF_INP_IN_MAP, ""true"");
				 }
			 }
			 else{
				 if(!mro.combinePlan.isEmpty()){
					 POPackage combPack = (POPackage)mro.combinePlan.getRoots().get(0);
					 mro.combinePlan.remove(combPack);
					 nwJob.setCombinerClass(PigCombiner.Combine.class);
					 conf.set(""pig.combinePlan"", ObjectSerializer.serialize(mro.combinePlan));
					 conf.set(""pig.combine.package"", ObjectSerializer.serialize(combPack));
				 }
				 else if (mro.needsDistinctCombiner()) {
					 nwJob.setCombinerClass(DistinctCombiner.Combine.class);
					 log.info(""Setting identity combiner class."");
				 }
				 pack = (POPackage)mro.reducePlan.getRoots().get(0);
				 if (!pigContext.inIllustrator) {
					 mro.reducePlan.remove(pack);
				 }
				 nwJob.setMapperClass(PigMapReduce.Map.class);
				 nwJob.setReducerClass(PigMapReduce.Reduce.class);
				 if (mro.customPartitioner != null) nwJob.setPartitionerClass(PigContext.resolveClassName(mro.customPartitioner));
				 if(!pigContext.inIllustrator) conf.set(""pig.mapPlan"", ObjectSerializer.serialize(mro.mapPlan));
				 if(mro.isEndOfAllInputSetInMap()) {
					 conf.set(END_OF_INP_IN_MAP, ""true"");
				 }
				 if(!pigContext.inIllustrator) conf.set(""pig.reducePlan"", ObjectSerializer.serialize(mro.reducePlan));
				 if(mro.isEndOfAllInputSetInReduce()) {
					 conf.set(""pig.stream.in.reduce"", ""true"");
				 }
				 if (!pigContext.inIllustrator) conf.set(""pig.reduce.package"", ObjectSerializer.serialize(pack));
				 conf.set(""pig.reduce.key.type"", Byte.toString(pack.getPkgr().getKeyType()));
				 if (mro.getUseSecondaryKey()) {
					 nwJob.setGroupingComparatorClass(PigSecondaryKeyGroupComparator.class);
					 nwJob.setPartitionerClass(SecondaryKeyPartitioner.class);
					 nwJob.setSortComparatorClass(PigSecondaryKeyComparator.class);
					 nwJob.setOutputKeyClass(NullableTuple.class);
					 conf.set(""pig.secondarySortOrder"", ObjectSerializer.serialize(mro.getSecondarySortOrder()));
				 }
				 else {
					 Class<? extends WritableComparable> keyClass = HDataType .getWritableComparableTypes( pack.getPkgr().getKeyType()).getClass();
					 nwJob.setOutputKeyClass(keyClass);
					 selectComparator(mro, pack.getPkgr().getKeyType(), nwJob);
				 }
				 nwJob.setOutputValueClass(NullableTuple.class);
			 }
			 if(mro.isGlobalSort() || mro.isLimitAfterSort()){
				 if (mro.isGlobalSort()) {
					 String symlink = addSingleFileToDistributedCache( pigContext, conf, mro.getQuantFile(), ""pigsample"");
					 conf.set(""pig.quantilesFile"", symlink);
					 nwJob.setPartitionerClass(WeightedRangePartitioner.class);
				 }
				 if (mro.isUDFComparatorUsed) {
					 boolean usercomparator = false;
					 for (String compFuncSpec : mro.UDFs) {
						 Class comparator = PigContext.resolveClassName(compFuncSpec);
						 if(ComparisonFunc.class.isAssignableFrom(comparator)) {
							 nwJob.setMapperClass(PigMapReduce.MapWithComparator.class);
							 nwJob.setReducerClass(PigMapReduce.ReduceWithComparator.class);
							 conf.set(""pig.reduce.package"", ObjectSerializer.serialize(pack));
							 conf.set(""pig.usercomparator"", ""true"");
							 nwJob.setOutputKeyClass(NullableTuple.class);
							 nwJob.setSortComparatorClass(comparator);
							 usercomparator = true;
							 break;
						 }
					 }
					 if (!usercomparator) {
						 String msg = ""Internal error. Can't find the UDF comparator"";
						 throw new IOException (msg);
					 }
				 }
				 else {
					 conf.set(""pig.sortOrder"", ObjectSerializer.serialize(mro.getSortOrder()));
				 }
			 }
			 if (mro.isSkewedJoin()) {
				 String symlink = addSingleFileToDistributedCache(pigContext, conf, mro.getSkewedJoinPartitionFile(), ""pigdistkey"");
				 conf.set(""pig.keyDistFile"", symlink);
				 nwJob.setPartitionerClass(SkewedPartitioner.class);
				 nwJob.setMapperClass(PigMapReduce.MapWithPartitionIndex.class);
				 nwJob.setMapOutputKeyClass(NullablePartitionWritable.class);
				 nwJob.setGroupingComparatorClass(PigGroupingPartitionWritableComparator.class);
			 }
			 if (mro.isCounterOperation()) {
				 if (mro.isRowNumber()) {
					 nwJob.setMapperClass(PigMapReduceCounter.PigMapCounter.class);
				 }
				 else {
					 nwJob.setReducerClass(PigMapReduceCounter.PigReduceCounter.class);
				 }
			 }
			 if(mro.isRankOperation()) {
				 Iterator<String> operationIDs = mro.getRankOperationId().iterator();
				 while(operationIDs.hasNext()) {
					 String operationID = operationIDs.next();
					 Iterator<Pair<String, Long>> itPairs = globalCounters.get(operationID).iterator();
					 Pair<String,Long> pair = null;
					 while(itPairs.hasNext()) {
						 pair = itPairs.next();
						 conf.setLong(pair.first, pair.second);
					 }
				 }
			 }
			 if (!pigContext.inIllustrator) {
				 for (POStore st: mapStores) {
					 st.setInputs(null);
					 st.setParentPlan(null);
				}
				 for (POStore st: reduceStores) {
					 st.setInputs(null);
					 st.setParentPlan(null);
				}
				 conf.set(PIG_MAP_STORES, ObjectSerializer.serialize(mapStores));
				 conf.set(PIG_REDUCE_STORES, ObjectSerializer.serialize(reduceStores));
			 }
			 String tmp;
			 long maxCombinedSplitSize = 0;
			 if (!mro.combineSmallSplits() || pigContext.getProperties().getProperty(""pig.splitCombination"", ""true"").equals(""false"")) conf.setBoolean(""pig.noSplitCombination"", true);
			 else if ((tmp = pigContext.getProperties().getProperty(""pig.maxCombinedSplitSize"", null)) != null) {
				 try {
					 maxCombinedSplitSize = Long.parseLong(tmp);
				 }
				 catch (NumberFormatException e) {
					 log.warn(""Invalid numeric format for pig.maxCombinedSplitSize;
					 use the default maximum combined split size"");
				 }
			 }
			 if (maxCombinedSplitSize > 0) conf.setLong(""pig.maxCombinedSplitSize"", maxCombinedSplitSize);
			 if (pigContext.getExecType() == ExecType.MAPREDUCE) {
				 String newfiles = conf.get(""alternative.mapreduce.job.cache.files"");
				 if (newfiles!=null) {
					 String files = conf.get(MRConfiguration.JOB_CACHE_FILES);
					 conf.set(MRConfiguration.JOB_CACHE_FILES, files == null ? newfiles.toString() : files + "","" + newfiles);
				 }
			 }
			 UDFContext.getUDFContext().serialize(conf);
			 Job cjob = new Job(new JobConf(conf), new ArrayList<Job>());
			 jobStoreMap.put(cjob,new Pair<List<POStore>, Path>(storeLocations, tmpLocation));
			 return cjob;
		 }
		 catch (JobCreationException jce) {
			 throw jce;
		 }
		 catch(Exception e) {
			 int errCode = 2017;
			 String msg = ""Internal error creating job configuration."";
			 throw new JobCreationException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public static void configureCompression(Configuration conf) {
		 if( ""true"".equals( conf.get(MRConfiguration.OUTPUT_COMPRESS) ) ) {
			 conf.set( ""output.compression.enabled"", ""true"" );
			 String codec = conf.get(MRConfiguration.OUTPUT_COMPRESSION_CODEC);
			 if( codec == null ) {
				 throw new IllegalArgumentException(""'"" + MRConfiguration.OUTPUT_COMPRESS + ""' is set but no value is specified for '"" + MRConfiguration.OUTPUT_COMPRESSION_CODEC + ""'."" );
			 }
			 else {
				 conf.set( ""output.compression.codec"", codec );
			 }
		 }
	 }
	 public void adjustNumReducers(MROperPlan plan, MapReduceOper mro, org.apache.hadoop.mapreduce.Job nwJob) throws IOException {
		 int jobParallelism = calculateRuntimeReducers(mro, nwJob);
		 if (mro.isSampler() && plan.getSuccessors(mro) != null) {
			 MapReduceOper nextMro = plan.getSuccessors(mro).get(0);
			 int nPartitions = calculateRuntimeReducers(nextMro, nwJob);
			 ParallelConstantVisitor visitor = new ParallelConstantVisitor(mro.reducePlan, nPartitions);
			 visitor.visit();
		 }
		 log.info(""Setting Parallelism to "" + jobParallelism);
		 Configuration conf = nwJob.getConfiguration();
		 conf.setInt(PigImplConstants.REDUCER_DEFAULT_PARALLELISM, pigContext.defaultParallel);
		 conf.setInt(PigImplConstants.REDUCER_REQUESTED_PARALLELISM, mro.requestedParallelism);
		 conf.setInt(PigImplConstants.REDUCER_ESTIMATED_PARALLELISM, mro.estimatedParallelism);
		 mro.requestedParallelism = jobParallelism;
		 conf.setInt(MRConfiguration.REDUCE_TASKS, jobParallelism);
	 }
	 private int calculateRuntimeReducers(MapReduceOper mro, org.apache.hadoop.mapreduce.Job nwJob) throws IOException{
		 if (mro.runtimeParallelism != -1) {
			 return mro.runtimeParallelism;
		 }
		 int jobParallelism = -1;
		 if (mro.requestedParallelism > 0) {
			 jobParallelism = mro.requestedParallelism;
		 }
		 else if (pigContext.defaultParallel > 0) {
			 jobParallelism = pigContext.defaultParallel;
		 }
		 else {
			 mro.estimatedParallelism = estimateNumberOfReducers(nwJob, mro);
			 if (mro.estimatedParallelism > 0) {
				 jobParallelism = mro.estimatedParallelism;
			 }
			 else {
				 log.info(""Could not estimate number of reducers and no requested or default "" + ""parallelism set. Defaulting to 1 reducer."");
				 jobParallelism = 1;
			 }
		 }
		 mro.runtimeParallelism = jobParallelism;
		 return jobParallelism;
	 }
	 public static int estimateNumberOfReducers(org.apache.hadoop.mapreduce.Job job, MapReduceOper mapReducerOper) throws IOException {
		 Configuration conf = job.getConfiguration();
		 PigReducerEstimator estimator = conf.get(PIG_EXEC_REDUCER_ESTIMATOR) == null ? new InputSizeReducerEstimator() : PigContext.instantiateObjectFromParams(conf, PIG_EXEC_REDUCER_ESTIMATOR, PIG_EXEC_REDUCER_ESTIMATOR_CONSTRUCTOR_ARG_KEY, PigReducerEstimator.class);
		 log.info(""Using reducer estimator: "" + estimator.getClass().getName());
		 int numberOfReducers = estimator.estimateNumberOfReducers(job, mapReducerOper);
		 return numberOfReducers;
	 }
	 public static class PigSecondaryKeyGroupComparator extends WritableComparator {
		 public PigSecondaryKeyGroupComparator() {
			 super(NullableTuple.class, true);
		 }
		 public int compare(WritableComparable a, WritableComparable b) {
			 PigNullableWritable wa = (PigNullableWritable)a;
			 PigNullableWritable wb = (PigNullableWritable)b;
			 if ((wa.getIndex() & PigNullableWritable.mqFlag) != 0) {
				 if ((wa.getIndex() & PigNullableWritable.idxSpace) < (wb.getIndex() & PigNullableWritable.idxSpace)) return -1;
				 else if ((wa.getIndex() & PigNullableWritable.idxSpace) > (wb.getIndex() & PigNullableWritable.idxSpace)) return 1;
			 }
			 Object valuea = null;
			 Object valueb = null;
			 try {
				 valuea = ((Tuple)wa.getValueAsPigType()).get(0);
				 valueb = ((Tuple)wb.getValueAsPigType()).get(0);
			 }
			 catch (ExecException e) {
				 throw new RuntimeException(""Unable to access tuple field"", e);
			 }
			 if (!wa.isNull() && !wb.isNull()) {
				 int result = DataType.compare(valuea, valueb);
				 if (result == 0 && valuea instanceof Tuple && valueb instanceof Tuple) {
					 try {
						 for (int i=0;
						i<((Tuple)valuea).size();
						i++) if (((Tuple)valueb).get(i)==null) return (wa.getIndex()&PigNullableWritable.idxSpace) - (wb.getIndex()&PigNullableWritable.idxSpace);
					 }
					 catch (ExecException e) {
						 throw new RuntimeException(""Unable to access tuple field"", e);
					 }
				 }
				 return result;
			 }
			 else if (valuea==null && valueb==null) {
				 if ((wa.getIndex() & PigNullableWritable.idxSpace) < (wb.getIndex() & PigNullableWritable.idxSpace)) return -1;
				 else if ((wa.getIndex() & PigNullableWritable.idxSpace) > (wb.getIndex() & PigNullableWritable.idxSpace)) return 1;
				 else return 0;
			 }
			 else if (valuea==null) return -1;
			 else return 1;
		 }
	 }
	 public static class PigWritableComparator extends WritableComparator {
		 protected PigWritableComparator(Class c) {
			 super(c);
		 }
		 public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2){
			 return WritableComparator.compareBytes(b1, s1, l1, b2, s2, l2);
		 }
	 }
	 public static class PigBooleanWritableComparator extends PigWritableComparator {
		 public PigBooleanWritableComparator() {
			 super(NullableBooleanWritable.class);
		 }
	 }
	 public static class PigIntWritableComparator extends PigWritableComparator {
		 public PigIntWritableComparator() {
			 super(NullableIntWritable.class);
		 }
	 }
	 public static class PigLongWritableComparator extends PigWritableComparator {
		 public PigLongWritableComparator() {
			 super(NullableLongWritable.class);
		 }
	 }
	 public static class PigFloatWritableComparator extends PigWritableComparator {
		 public PigFloatWritableComparator() {
			 super(NullableFloatWritable.class);
		 }
	 }
	 public static class PigDoubleWritableComparator extends PigWritableComparator {
		 public PigDoubleWritableComparator() {
			 super(NullableDoubleWritable.class);
		 }
	 }
	 public static class PigBigIntegerWritableComparator extends PigWritableComparator {
		 public PigBigIntegerWritableComparator() {
			 super(NullableBigIntegerWritable.class);
		 }
	 }
	 public static class PigBigDecimalWritableComparator extends PigWritableComparator {
		 public PigBigDecimalWritableComparator() {
			 super(NullableBigDecimalWritable.class);
		 }
	 }
	 public static class PigDateTimeWritableComparator extends PigWritableComparator {
		 public PigDateTimeWritableComparator() {
			 super(NullableDateTimeWritable.class);
		 }
	 }
	 public static class PigCharArrayWritableComparator extends PigWritableComparator {
		 public PigCharArrayWritableComparator() {
			 super(NullableText.class);
		 }
	 }
	 public static class PigDBAWritableComparator extends PigWritableComparator {
		 public PigDBAWritableComparator() {
			 super(NullableBytesWritable.class);
		 }
	 }
	 public static class PigTupleWritableComparator extends PigWritableComparator {
		 public PigTupleWritableComparator() {
			 super(TupleFactory.getInstance().tupleClass());
		 }
	 }
	 public static class PigBagWritableComparator extends PigWritableComparator {
		 public PigBagWritableComparator() {
			 super(BagFactory.getInstance().newDefaultBag().getClass());
		 }
	 }
	 public static class PigGroupingBooleanWritableComparator extends WritableComparator {
		 public PigGroupingBooleanWritableComparator() {
			 super(NullableBooleanWritable.class, true);
		 }
	 }
	 public static class PigGroupingIntWritableComparator extends WritableComparator {
		 public PigGroupingIntWritableComparator() {
			 super(NullableIntWritable.class, true);
		 }
	 }
	 public static class PigGroupingLongWritableComparator extends WritableComparator {
		 public PigGroupingLongWritableComparator() {
			 super(NullableLongWritable.class, true);
		 }
	 }
	 public static class PigGroupingFloatWritableComparator extends WritableComparator {
		 public PigGroupingFloatWritableComparator() {
			 super(NullableFloatWritable.class, true);
		 }
	 }
	 public static class PigGroupingDoubleWritableComparator extends WritableComparator {
		 public PigGroupingDoubleWritableComparator() {
			 super(NullableDoubleWritable.class, true);
		 }
	 }
	 public static class PigGroupingDateTimeWritableComparator extends WritableComparator {
		 public PigGroupingDateTimeWritableComparator() {
			 super(NullableDateTimeWritable.class, true);
		 }
	 }
	 public static class PigGroupingCharArrayWritableComparator extends WritableComparator {
		 public PigGroupingCharArrayWritableComparator() {
			 super(NullableText.class, true);
		 }
	 }
	 public static class PigGroupingDBAWritableComparator extends WritableComparator {
		 public PigGroupingDBAWritableComparator() {
			 super(NullableBytesWritable.class, true);
		 }
	 }
	 public static class PigGroupingTupleWritableComparator extends WritableComparator {
		 public PigGroupingTupleWritableComparator() {
			 super(NullableTuple.class, true);
		 }
	 }
	 public static class PigGroupingPartitionWritableComparator extends WritableComparator {
		 public PigGroupingPartitionWritableComparator() {
			 super(NullablePartitionWritable.class, true);
		 }
	 }
	 public static class PigGroupingBagWritableComparator extends WritableComparator {
		 public PigGroupingBagWritableComparator() {
			 super(BagFactory.getInstance().newDefaultBag().getClass(), true);
		 }
	 }
	 public static class PigGroupingBigIntegerWritableComparator extends WritableComparator {
		 public PigGroupingBigIntegerWritableComparator() {
			 super(NullableBigIntegerWritable.class, true);
		 }
	 }
	 public static class PigGroupingBigDecimalWritableComparator extends WritableComparator {
		 public PigGroupingBigDecimalWritableComparator() {
			 super(NullableBigDecimalWritable.class, true);
		 }
	 }
	 private void selectComparator( MapReduceOper mro, byte keyType, org.apache.hadoop.mapreduce.Job job) throws JobCreationException {
		 boolean hasOrderBy = false;
		 if (mro.isGlobalSort() || mro.isLimitAfterSort() || mro.usingTypedComparator()) {
			 hasOrderBy = true;
		 }
		 else {
			 List<MapReduceOper> succs = plan.getSuccessors(mro);
			 if (succs != null) {
				 MapReduceOper succ = succs.get(0);
				 if (succ.isGlobalSort()) hasOrderBy = true;
			 }
		 }
		 if (hasOrderBy) {
			 switch (keyType) {
				 case DataType.BOOLEAN: job.setSortComparatorClass(PigBooleanRawComparator.class);
				 break;
				 case DataType.INTEGER: job.setSortComparatorClass(PigIntRawComparator.class);
				 break;
				 case DataType.LONG: job.setSortComparatorClass(PigLongRawComparator.class);
				 break;
				 case DataType.FLOAT: job.setSortComparatorClass(PigFloatRawComparator.class);
				 break;
				 case DataType.DOUBLE: job.setSortComparatorClass(PigDoubleRawComparator.class);
				 break;
				 case DataType.DATETIME: job.setSortComparatorClass(PigDateTimeRawComparator.class);
				 break;
				 case DataType.CHARARRAY: job.setSortComparatorClass(PigTextRawComparator.class);
				 break;
				 case DataType.BYTEARRAY: job.setSortComparatorClass(PigBytesRawComparator.class);
				 break;
				 case DataType.BIGINTEGER: job.setSortComparatorClass(PigBigIntegerRawComparator.class);
				 break;
				 case DataType.BIGDECIMAL: job.setSortComparatorClass(PigBigDecimalRawComparator.class);
				 break;
				 case DataType.MAP: int errCode = 1068;
				 String msg = ""Using Map as key not supported."";
				 throw new JobCreationException(msg, errCode, PigException.INPUT);
				 case DataType.TUPLE: job.setSortComparatorClass(PigTupleSortComparator.class);
				 break;
				 case DataType.BAG: errCode = 1068;
				 msg = ""Using Bag as key not supported."";
				 throw new JobCreationException(msg, errCode, PigException.INPUT);
				 default: break;
			 }
			 return;
		 }
		 switch (keyType) {
			 case DataType.BOOLEAN: job.setSortComparatorClass(PigBooleanWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingBooleanWritableComparator.class);
			 break;
			 case DataType.INTEGER: job.setSortComparatorClass(PigIntWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingIntWritableComparator.class);
			 break;
			 case DataType.BIGINTEGER: job.setSortComparatorClass(PigBigIntegerWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingBigIntegerWritableComparator.class);
			 break;
			 case DataType.BIGDECIMAL: job.setSortComparatorClass(PigBigDecimalWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingBigDecimalWritableComparator.class);
			 break;
			 case DataType.LONG: job.setSortComparatorClass(PigLongWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingLongWritableComparator.class);
			 break;
			 case DataType.FLOAT: job.setSortComparatorClass(PigFloatWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingFloatWritableComparator.class);
			 break;
			 case DataType.DOUBLE: job.setSortComparatorClass(PigDoubleWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingDoubleWritableComparator.class);
			 break;
			 case DataType.DATETIME: job.setSortComparatorClass(PigDateTimeWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingDateTimeWritableComparator.class);
			 break;
			 case DataType.CHARARRAY: job.setSortComparatorClass(PigCharArrayWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingCharArrayWritableComparator.class);
			 break;
			 case DataType.BYTEARRAY: job.setSortComparatorClass(PigDBAWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingDBAWritableComparator.class);
			 break;
			 case DataType.MAP: int errCode = 1068;
			 String msg = ""Using Map as key not supported."";
			 throw new JobCreationException(msg, errCode, PigException.INPUT);
			 case DataType.TUPLE: job.setSortComparatorClass(PigTupleWritableComparator.class);
			 job.setGroupingComparatorClass(PigGroupingTupleWritableComparator.class);
			 break;
			 case DataType.BAG: errCode = 1068;
			 msg = ""Using Bag as key not supported."";
			 throw new JobCreationException(msg, errCode, PigException.INPUT);
			 default: errCode = 2036;
			 msg = ""Unhandled key type "" + DataType.findTypeName(keyType);
			 throw new JobCreationException(msg, errCode, PigException.BUG);
		 }
	 }
	 private void setupDistributedCacheForJoin(MapReduceOper mro, PigContext pigContext, Configuration conf) throws IOException {
		 new JoinDistributedCacheVisitor(mro.mapPlan, pigContext, conf) .visit();
		 new JoinDistributedCacheVisitor(mro.reducePlan, pigContext, conf) .visit();
	 }
	 private static void setupDistributedCache(PigContext pigContext, Configuration conf, Properties properties, String key, boolean shipToCluster) throws IOException {
		 String fileNames = properties.getProperty(key);
		 if (fileNames != null) {
			 String[] paths = fileNames.split("","");
			 setupDistributedCache(pigContext, conf, paths, shipToCluster);
		 }
	 }
	 private static void addToDistributedCache(URI uri, Configuration conf) {
		 if (DISTRIBUTED_CACHE_ARCHIVE_MATCHER.reset(uri.toString()).find()) {
			 DistributedCache.addCacheArchive(uri, conf);
		 }
		 else {
			 DistributedCache.addCacheFile(uri, conf);
		 }
	 }
	 private static void setupDistributedCache(PigContext pigContext, Configuration conf, String[] paths, boolean shipToCluster) throws IOException {
		 DistributedCache.createSymlink(conf);
		 for (String path : paths) {
			 path = path.trim();
			 if (path.length() != 0) {
				 Path src = new Path(path);
				 URI srcURI = toURI(src);
				 if (shipToCluster) {
					 Path dst = new Path(FileLocalizer.getTemporaryPath(pigContext).toString());
					 FileSystem fs = dst.getFileSystem(conf);
					 fs.copyFromLocalFile(src, dst);
					 fs.setReplication(dst, (short)conf.getInt(MRConfiguration.SUMIT_REPLICATION, 3));
					 URI dstURI = null;
					 try {
						 dstURI = new URI(dst.toString() + ""#"" + src.getName());
					 }
					 catch (URISyntaxException ue) {
						 byte errSrc = pigContext.getErrorSource();
						 int errCode = 0;
						 switch(errSrc) {
							 case PigException.REMOTE_ENVIRONMENT: errCode = 6004;
							 break;
							 case PigException.USER_ENVIRONMENT: errCode = 4004;
							 break;
							 default: errCode = 2037;
							 break;
						 }
						 String msg = ""Invalid ship specification. "" + ""File doesn't exist: "" + dst;
						 throw new ExecException(msg, errCode, errSrc);
					 }
					 addToDistributedCache(dstURI, conf);
				 }
				 else {
					 addToDistributedCache(srcURI, conf);
				 }
			 }
		 }
	 }
	 private static String addSingleFileToDistributedCache( PigContext pigContext, Configuration conf, String filename, String prefix) throws IOException {
		 if (!pigContext.inIllustrator && !FileLocalizer.fileExists(filename, pigContext)) {
			 throw new IOException( ""Internal error: skew join partition file "" + filename + "" does not exist"");
		 }
		 String symlink = filename;
		 if (!Utils.isLocal(pigContext, conf)) {
			 symlink = prefix + ""_"" + Integer.toString(System.identityHashCode(filename)) + ""_"" + Long.toString(System.currentTimeMillis());
			 filename = filename + ""#"" + symlink;
			 setupDistributedCache(pigContext, conf, new String[] {
			 filename }
			, false);
		 }
		 return symlink;
	 }
	 private static URI toURI(Path src) throws ExecException {
		 String pathInString = src.toString();
		 String fragment = null;
		 if (pathInString.contains(""#"")) {
			 fragment = pathInString.substring(pathInString.indexOf(""#""));
			 pathInString = pathInString.substring(0, pathInString.indexOf(""#""));
		 }
		 URI uri = new Path(pathInString).toUri();
		 String uriEncoded = uri.toString();
		 if (fragment!=null) {
			 uriEncoded = uriEncoded + fragment;
		 }
		 try {
			 return new URI(uriEncoded);
		 }
		 catch (URISyntaxException ue) {
			 int errCode = 6003;
			 String msg = ""Invalid cache specification. "" + ""File doesn't exist: "" + src;
			 throw new ExecException(msg, errCode, PigException.USER_ENVIRONMENT);
		 }
	 }
	 private static void putJarOnClassPathThroughDistributedCache( PigContext pigContext, Configuration conf, URL url) throws IOException {
		 DistributedCache.createSymlink(conf);
		 Path distCachePath = getExistingDistCacheFilePath(conf, url);
		 if (distCachePath != null) {
			 log.info(""Jar file "" + url + "" already in DistributedCache as "" + distCachePath + "". Not copying to hdfs and adding again"");
		 }
		 else {
			 Path pathInHDFS = shipToHDFS(pigContext, conf, url);
			 DistributedCache.addFileToClassPath(pathInHDFS, conf, FileSystem.get(conf));
			 log.info(""Added jar "" + url + "" to DistributedCache through "" + pathInHDFS);
		 }
	 }
	 private static Path getExistingDistCacheFilePath(Configuration conf, URL url) throws IOException {
		 URI[] cacheFileUris = DistributedCache.getCacheFiles(conf);
		 if (cacheFileUris != null) {
			 String fileName = url.getRef() == null ? FilenameUtils.getName(url.getPath()) : url.getRef();
			 for (URI cacheFileUri : cacheFileUris) {
				 Path path = new Path(cacheFileUri);
				 String cacheFileName = cacheFileUri.getFragment() == null ? path.getName() : cacheFileUri.getFragment();
				 if (fileName.equals(cacheFileName)) {
					 return path;
				 }
			 }
		 }
		 return null;
	 }
	 public static Path getCacheStagingDir(Configuration conf) throws IOException {
		 String pigTempDir = conf.get(PigConfiguration.PIG_USER_CACHE_LOCATION, conf.get(PigConfiguration.PIG_TEMP_DIR, ""/tmp""));
		 String currentUser = System.getProperty(""user.name"");
		 Path stagingDir = new Path(pigTempDir + ""/"" + currentUser + ""/"", "".pigcache"");
		 FileSystem fs = FileSystem.get(conf);
		 fs.mkdirs(stagingDir);
		 fs.setPermission(stagingDir, FileLocalizer.OWNER_ONLY_PERMS);
		 return stagingDir;
	 }
	 public static Path getFromCache(PigContext pigContext, Configuration conf, URL url) throws IOException {
		 InputStream is1 = null;
		 InputStream is2 = null;
		 try {
			 Path stagingDir = getCacheStagingDir(conf);
			 String filename = FilenameUtils.getName(url.getPath());
			 is1 = url.openStream();
			 String checksum = DigestUtils.shaHex(is1);
			 FileSystem fs = FileSystem.get(conf);
			 Path cacheDir = new Path(stagingDir, checksum);
			 Path cacheFile = new Path(cacheDir, filename);
			 if (fs.exists(cacheFile)) {
				 log.debug(""Found "" + url + "" in jar cache at ""+ cacheDir);
				 long curTime = System.currentTimeMillis();
				 fs.setTimes(cacheFile, -1, curTime);
				 return cacheFile;
			 }
			 log.info(""Url ""+ url + "" was not found in jarcache at ""+ cacheDir);
			 fs.mkdirs(cacheDir, FileLocalizer.OWNER_ONLY_PERMS);
			 is2 = url.openStream();
			 short replication = (short)conf.getInt(PigConfiguration.PIG_USER_CACHE_REPLICATION, conf.getInt(""mapred.submit.replication"", 10));
			 Path tempCacheFile = new Path(cacheDir, String.format(CACHE_TMP_FILE_TEMPLATE, RAND.nextInt()));
			 try {
				 try (OutputStream os = fs.create(tempCacheFile, replication)) {
					 fs.setPermission(tempCacheFile, FileLocalizer.OWNER_ONLY_PERMS);
					 IOUtils.copyBytes(is2, os, 4096, true);
				 }
				 fs.rename(tempCacheFile, cacheFile);
			 }
			 catch (IOException ioe) {
				 if (fs.exists(tempCacheFile)) {
					 fs.delete(tempCacheFile, false);
				 }
				 throw ioe;
			 }
			 return cacheFile;
		 }
		 catch (IOException ioe) {
			 log.info(""Unable to retrieve jar from jar cache "", ioe);
			 return null;
		 }
		 finally {
			 org.apache.commons.io.IOUtils.closeQuietly(is1);
			 org.apache.commons.io.IOUtils.closeQuietly(is2);
		 }
	 }
	 private static Path shipToHDFS( PigContext pigContext, Configuration conf, URL url) throws IOException {
		 short replication = (short) conf.getInt(MRConfiguration.SUMIT_REPLICATION, 3);
		 boolean cacheEnabled = conf.getBoolean(PigConfiguration.PIG_USER_CACHE_ENABLED, false);
		 if (cacheEnabled) {
			 Path pathOnDfs = getFromCache(pigContext, conf, url);
			 if(pathOnDfs != null) {
				 return pathOnDfs;
			 }
		 }
		 String suffix = FilenameUtils.getName(url.getPath());
		 Path dst = new Path(FileLocalizer.getTemporaryPath(pigContext).toUri().getPath(), suffix);
		 FileSystem fs = dst.getFileSystem(conf);
		 OutputStream os = null;
		 InputStream is = null;
		 try {
			 is = url.openStream();
			 os = fs.create(dst);
			 IOUtils.copyBytes(is, os, 4096, true);
		 }
		 finally {
			 org.apache.commons.io.IOUtils.closeQuietly(is);
			 if (os != null) {
				 os.close();
			 }
		 }
		 fs.setReplication(dst, replication);
		 return dst;
	 }
	 private static class JoinDistributedCacheVisitor extends PhyPlanVisitor {
		 private PigContext pigContext = null;
		 private Configuration conf = null;
		 public JoinDistributedCacheVisitor(PhysicalPlan plan, PigContext pigContext, Configuration conf) {
			 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>( plan));
			 this.pigContext = pigContext;
			 this.conf = conf;
		 }
		 public void visitFRJoin(POFRJoin join) throws VisitorException {
			 if (Utils.isLocal(pigContext, conf)) return;
			 FileSpec[] replFiles = join.getReplFiles();
			 ArrayList<String> replicatedPath = new ArrayList<String>();
			 FileSpec[] newReplFiles = new FileSpec[replFiles.length];
			 long maxSize = Long.valueOf(pigContext.getProperties().getProperty( PigConfiguration.PIG_JOIN_REPLICATED_MAX_BYTES, ""1000000000""));
			 long sizeOfReplicatedInputs = 0;
			 try {
				 for (int i = 0;
				 i < replFiles.length;
				 i++) {
					 String symlink = """";
					 if (i != join.getFragment()) {
						 symlink = ""pigrepl_"" + join.getOperatorKey().toString() + ""_"" + Integer.toString(System.identityHashCode( replFiles[i].getFileName())) + ""_"" + Long.toString(System.currentTimeMillis()) + ""_"" + i;
						 replicatedPath.add(replFiles[i].getFileName() + ""#"" + symlink);
						 Path path = new Path(replFiles[i].getFileName());
						 FileSystem fs = path.getFileSystem(conf);
						 sizeOfReplicatedInputs += MapRedUtil.getPathLength(fs, fs.getFileStatus(path), maxSize);
					 }
					 newReplFiles[i] = new FileSpec(symlink, (replFiles[i] == null ? null : replFiles[i].getFuncSpec()));
				 }
				 join.setReplFiles(newReplFiles);
				 if (sizeOfReplicatedInputs > maxSize) {
					 throw new VisitorException(""Replicated input files size: "" + sizeOfReplicatedInputs + "" exceeds "" + PigConfiguration.PIG_JOIN_REPLICATED_MAX_BYTES + "": "" + maxSize);
				 }
				 setupDistributedCache(pigContext, conf, replicatedPath .toArray(new String[0]), false);
			 }
			 catch (IOException e) {
				 String msg = ""Internal error. Distributed cache could not "" + ""be set up for the replicated files"";
				 throw new VisitorException(msg, e);
			 }
		 }
		 public void visitMergeJoin(POMergeJoin join) throws VisitorException {
			 if (Utils.isLocal(pigContext, conf)) return;
			 String indexFile = join.getIndexFile();
			 if (indexFile == null) return;
			 try {
				 String symlink = addSingleFileToDistributedCache(pigContext, conf, indexFile, ""indexfile_"");
				 join.setIndexFile(symlink);
			 }
			 catch (IOException e) {
				 String msg = ""Internal error. Distributed cache could not "" + ""be set up for merge join index file"";
				 throw new VisitorException(msg, e);
			 }
		 }
		 public void visitMergeCoGroup(POMergeCogroup mergeCoGrp) throws VisitorException {
			 if (Utils.isLocal(pigContext, conf)) return;
			 String indexFile = mergeCoGrp.getIndexFileName();
			 if (indexFile == null) throw new VisitorException(""No index file"");
			 try {
				 String symlink = addSingleFileToDistributedCache(pigContext, conf, indexFile, ""indexfile_mergecogrp_"");
				 mergeCoGrp.setIndexFileName(symlink);
			 }
			 catch (IOException e) {
				 String msg = ""Internal error. Distributed cache could not "" + ""be set up for merge cogrp index file"";
				 throw new VisitorException(msg, e);
			 }
		 }
	 }
	 private static class ParallelConstantVisitor extends PhyPlanVisitor {
		 private int rp;
		 private boolean replaced = false;
		 public ParallelConstantVisitor(PhysicalPlan plan, int rp) {
			 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>( plan));
			 this.rp = rp;
		 }
		 public void visitConstant(ConstantExpression cnst) throws VisitorException {
			 if (cnst.getRequestedParallelism() == -1) {
				 Object obj = cnst.getValue();
				 if (obj instanceof Integer) {
					 if (replaced) {
						 throw new VisitorException(""Invalid reduce plan: more "" + ""than one ConstantExpression found in sampling job"");
					 }
					 cnst.setValue(rp);
					 cnst.setRequestedParallelism(rp);
					 replaced = true;
				 }
			 }
		 }
	 }
	 public static void setOutputFormat(org.apache.hadoop.mapreduce.Job job) {
		 if (""true"".equalsIgnoreCase(job.getConfiguration().get(PigConfiguration.PIG_OUTPUT_LAZY))) {
			 LazyOutputFormat.setOutputFormatClass(job,PigOutputFormat.class);
		 }
		 else {
			 job.setOutputFormatClass(PigOutputFormat.class);
		 }
	 }
}",1,0,0,0
"public deleteAll_result deepCopy() {
	 return new deleteAll_result(this);
 }",0,0,0,0
"public class ParsedTabItem {
	 private String name = null;
	 private String action = null;
	 private String[] subActions = null;
	 private String perm = null;
	 private String role = null;
	 private String enabledProperty = null;
	 private String disabledProperty = null;
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getAction() {
		 return action;
	 }
	 public void setAction(String action) {
		 this.action = action;
	 }
	 public String[] getSubActions() {
		 return subActions;
	 }
	 public void setSubActions(String[] subActions) {
		 this.subActions = subActions;
	 }
	 public String getPerm() {
		 return perm;
	 }
	 public void setPerm(String perm) {
		 this.perm = perm;
	 }
	 public String getRole() {
		 return role;
	 }
	 public void setRole(String role) {
		 this.role = role;
	 }
	 public String getEnabledProperty() {
		 return enabledProperty;
	 }
	 public void setEnabledProperty(String enabledProperty) {
		 this.enabledProperty = enabledProperty;
	 }
	 public String getDisabledProperty() {
		 return disabledProperty;
	 }
	 public void setDisabledProperty(String disabledProperty) {
		 this.disabledProperty = disabledProperty;
	 }
}",0,1,0,0
"public class Parser{
	 final static int CLEAR_TI_MASK = 0xFFFF, TI_AFTER_EOL = 1 << 16, TI_CHECK_LABEL = 1 << 17;
	 CompilerEnvirons compilerEnv;
	 private ErrorReporter errorReporter;
	 private String sourceURI;
	 boolean calledByCompileFunction;
	 private TokenStream ts;
	 private int currentFlaggedToken;
	 private int syntaxErrorCount;
	 private IRFactory nf;
	 private int nestingOfFunction;
	 private Decompiler decompiler;
	 private String encodedSource;
	 ScriptOrFnNode currentScriptOrFn;
	 private int nestingOfWith;
	 private Hashtable labelSet;
	 private ObjArray loopSet;
	 private ObjArray loopAndSwitchSet;
	 private static class ParserException extends RuntimeException {
		 static final long serialVersionUID = 5882582646773765630L;
	 }
	 public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {
		 this.compilerEnv = compilerEnv;
		 this.errorReporter = errorReporter;
	 }
	 protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {
		 return new Decompiler();
	 }
	 void addWarning(String messageId, String messageArg) {
		 String message = ScriptRuntime.getMessage1(messageId, messageArg);
		 errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 void addError(String messageId) {
		 ++syntaxErrorCount;
		 String message = ScriptRuntime.getMessage0(messageId);
		 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 RuntimeException reportError(String messageId) {
		 addError(messageId);
		 throw new ParserException();
	 }
	 private int peekToken() throws IOException {
		 int tt = currentFlaggedToken;
		 if (tt == Token.EOF) {
			 tt = ts.getToken();
			 if (tt == Token.EOL) {
				 do {
					 tt = ts.getToken();
				 }
				 while (tt == Token.EOL);
				 tt |= TI_AFTER_EOL;
			 }
			 currentFlaggedToken = tt;
		 }
		 return tt & CLEAR_TI_MASK;
	 }
	 private int peekFlaggedToken() throws IOException {
		 peekToken();
		 return currentFlaggedToken;
	 }
	 private void consumeToken() {
		 currentFlaggedToken = Token.EOF;
	 }
	 private int nextToken() throws IOException {
		 int tt = peekToken();
		 consumeToken();
		 return tt;
	 }
	 private int nextFlaggedToken() throws IOException {
		 peekToken();
		 int ttFlagged = currentFlaggedToken;
		 consumeToken();
		 return ttFlagged;
	 }
	 private boolean matchToken(int toMatch) throws IOException {
		 int tt = peekToken();
		 if (tt != toMatch) {
			 return false;
		 }
		 consumeToken();
		 return true;
	 }
	 private int peekTokenOrEOL() throws IOException {
		 int tt = peekToken();
		 if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {
			 tt = Token.EOL;
		 }
		 return tt;
	 }
	 private void setCheckForLabel() {
		 if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME) throw Kit.codeBug();
		 currentFlaggedToken |= TI_CHECK_LABEL;
	 }
	 private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {
		 if (!matchToken(toMatch)) {
			 reportError(messageId);
		 }
	 }
	 private void mustHaveXML() {
		 if (!compilerEnv.isXmlAvailable()) {
			 reportError(""msg.XML.not.available"");
		 }
	 }
	 public String getEncodedSource() {
		 return encodedSource;
	 }
	 public boolean eof() {
		 return ts.eof();
	 }
	 boolean insideFunction() {
		 return nestingOfFunction != 0;
	 }
	 private Node enterLoop(Node loopLabel) {
		 Node loop = nf.createLoopNode(loopLabel, ts.getLineno());
		 if (loopSet == null) {
			 loopSet = new ObjArray();
			 if (loopAndSwitchSet == null) {
				 loopAndSwitchSet = new ObjArray();
			 }
		 }
		 loopSet.push(loop);
		 loopAndSwitchSet.push(loop);
		 return loop;
	 }
	 private void exitLoop() {
		 loopSet.pop();
		 loopAndSwitchSet.pop();
	 }
	 private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel) {
		 Node switchNode = nf.createSwitch(switchSelector, lineno);
		 if (loopAndSwitchSet == null) {
			 loopAndSwitchSet = new ObjArray();
		 }
		 loopAndSwitchSet.push(switchNode);
		 return switchNode;
	 }
	 private void exitSwitch() {
		 loopAndSwitchSet.pop();
	 }
	 public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, null, sourceString, lineno);
		 try {
			 return parse();
		 }
		 catch (IOException ex) {
			 throw new IllegalStateException();
		 }
	 }
	 public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, sourceReader, null, lineno);
		 return parse();
	 }
	 private ScriptOrFnNode parse() throws IOException {
		 this.decompiler = createDecompiler(compilerEnv);
		 this.nf = new IRFactory(this);
		 currentScriptOrFn = nf.createScript();
		 int sourceStartOffset = decompiler.getCurrentOffset();
		 this.encodedSource = null;
		 decompiler.addToken(Token.SCRIPT);
		 this.currentFlaggedToken = Token.EOF;
		 this.syntaxErrorCount = 0;
		 int baseLineno = ts.getLineno();
		 Node pn = nf.createLeaf(Token.BLOCK);
		 try {
			 for (;
			;
			) {
				 int tt = peekToken();
				 if (tt <= Token.EOF) {
					 break;
				 }
				 Node n;
				 if (tt == Token.FUNCTION) {
					 consumeToken();
					 try {
						 n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);
					 }
					 catch (ParserException e) {
						 break;
					 }
				 }
				 else {
					 n = statement();
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (StackOverflowError ex) {
			 String msg = ScriptRuntime.getMessage0( ""mag.too.deep.parser.recursion"");
			 throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);
		 }
		 if (this.syntaxErrorCount != 0) {
			 String msg = String.valueOf(this.syntaxErrorCount);
			 msg = ScriptRuntime.getMessage1(""msg.got.syntax.errors"", msg);
			 throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);
		 }
		 currentScriptOrFn.setSourceName(sourceURI);
		 currentScriptOrFn.setBaseLineno(baseLineno);
		 currentScriptOrFn.setEndLineno(ts.getLineno());
		 int sourceEndOffset = decompiler.getCurrentOffset();
		 currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);
		 nf.initScript(currentScriptOrFn, pn);
		 if (compilerEnv.isGeneratingSource()) {
			 encodedSource = decompiler.getEncodedSource();
		 }
		 this.decompiler = null;
		 return currentScriptOrFn;
	 }
	 private Node parseFunctionBody() throws IOException {
		 ++nestingOfFunction;
		 Node pn = nf.createBlock(ts.getLineno());
		 try {
			 bodyLoop: for (;
			;
			) {
				 Node n;
				 int tt = peekToken();
				 switch (tt) {
					 case Token.ERROR: case Token.EOF: case Token.RC: break bodyLoop;
					 case Token.FUNCTION: consumeToken();
					 n = function(FunctionNode.FUNCTION_STATEMENT);
					 break;
					 default: n = statement();
					 break;
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (ParserException e) {
		 }
		 finally {
			 --nestingOfFunction;
		 }
		 return pn;
	 }
	 private Node function(int functionType) throws IOException, ParserException {
		 int syntheticType = functionType;
		 int baseLineno = ts.getLineno();
		 int functionSourceStart = decompiler.markFunctionStart(functionType);
		 String name;
		 Node memberExprNode = null;
		 if (matchToken(Token.NAME)) {
			 name = ts.getString();
			 decompiler.addName(name);
			 if (!matchToken(Token.LP)) {
				 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
					 Node memberExprHead = nf.createName(name);
					 name = """";
					 memberExprNode = memberExprTail(false, memberExprHead);
				 }
				 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
			 }
		 }
		 else if (matchToken(Token.LP)) {
			 name = """";
		 }
		 else {
			 name = """";
			 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
				 memberExprNode = memberExpr(false);
			 }
			 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
		 }
		 if (memberExprNode != null) {
			 syntheticType = FunctionNode.FUNCTION_EXPRESSION;
		 }
		 boolean nested = insideFunction();
		 FunctionNode fnNode = nf.createFunction(name);
		 if (nested || nestingOfWith > 0) {
			 fnNode.itsIgnoreDynamicScope = true;
		 }
		 int functionIndex = currentScriptOrFn.addFunction(fnNode);
		 int functionSourceEnd;
		 ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;
		 currentScriptOrFn = fnNode;
		 int savedNestingOfWith = nestingOfWith;
		 nestingOfWith = 0;
		 Hashtable savedLabelSet = labelSet;
		 labelSet = null;
		 ObjArray savedLoopSet = loopSet;
		 loopSet = null;
		 ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;
		 loopAndSwitchSet = null;
		 Node body;
		 String source;
		 try {
			 decompiler.addToken(Token.LP);
			 if (!matchToken(Token.RP)) {
				 boolean first = true;
				 do {
					 if (!first) decompiler.addToken(Token.COMMA);
					 first = false;
					 mustMatchToken(Token.NAME, ""msg.no.parm"");
					 String s = ts.getString();
					 if (fnNode.hasParamOrVar(s)) {
						 addWarning(""msg.dup.parms"", s);
					 }
					 fnNode.addParam(s);
					 decompiler.addName(s);
				 }
				 while (matchToken(Token.COMMA));
				 mustMatchToken(Token.RP, ""msg.no.paren.after.parms"");
			 }
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.LC, ""msg.no.brace.body"");
			 decompiler.addEOL(Token.LC);
			 body = parseFunctionBody();
			 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
			 decompiler.addToken(Token.RC);
			 functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {
					 int tt = peekTokenOrEOL();
					 if (tt == Token.FUNCTION) {
						 reportError(""msg.no.semi.stmt"");
					 }
				 }
				 decompiler.addToken(Token.EOL);
			 }
		 }
		 finally {
			 loopAndSwitchSet = savedLoopAndSwitchSet;
			 loopSet = savedLoopSet;
			 labelSet = savedLabelSet;
			 nestingOfWith = savedNestingOfWith;
			 currentScriptOrFn = savedScriptOrFn;
		 }
		 fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);
		 fnNode.setSourceName(sourceURI);
		 fnNode.setBaseLineno(baseLineno);
		 fnNode.setEndLineno(ts.getLineno());
		 Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
		 if (memberExprNode != null) {
			 pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 pn = nf.createExprStatementNoReturn(pn, baseLineno);
			 }
		 }
		 return pn;
	 }
	 private Node statements() throws IOException {
		 Node pn = nf.createBlock(ts.getLineno());
		 int tt;
		 while((tt = peekToken()) > Token.EOF && tt != Token.RC) {
			 nf.addChildToBack(pn, statement());
		 }
		 return pn;
	 }
	 private Node condition() throws IOException, ParserException {
		 Node pn;
		 mustMatchToken(Token.LP, ""msg.no.paren.cond"");
		 decompiler.addToken(Token.LP);
		 pn = expr(false);
		 mustMatchToken(Token.RP, ""msg.no.paren.after.cond"");
		 decompiler.addToken(Token.RP);
		 return pn;
	 }
	 private Node matchJumpLabelName() throws IOException, ParserException {
		 Node label = null;
		 int tt = peekTokenOrEOL();
		 if (tt == Token.NAME) {
			 consumeToken();
			 String name = ts.getString();
			 decompiler.addName(name);
			 if (labelSet != null) {
				 label = (Node)labelSet.get(name);
			 }
			 if (label == null) {
				 reportError(""msg.undef.label"");
			 }
		 }
		 return label;
	 }
	 private Node statement() throws IOException {
		 try {
			 Node pn = statementHelper(null);
			 if (pn != null) {
				 return pn;
			 }
		 }
		 catch (ParserException e) {
		 }
		 int lineno = ts.getLineno();
		 guessingStatementEnd: for (;
		;
		) {
			 int tt = peekTokenOrEOL();
			 consumeToken();
			 switch (tt) {
				 case Token.ERROR: case Token.EOF: case Token.EOL: case Token.SEMI: break guessingStatementEnd;
			 }
		 }
		 return nf.createExprStatement(nf.createName(""error""), lineno);
	 }
	 private Node statementHelper(Node statementLabel) throws IOException, ParserException {
		 Node pn = null;
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.IF: {
				 consumeToken();
				 decompiler.addToken(Token.IF);
				 int lineno = ts.getLineno();
				 Node cond = condition();
				 decompiler.addEOL(Token.LC);
				 Node ifTrue = statement();
				 Node ifFalse = null;
				 if (matchToken(Token.ELSE)) {
					 decompiler.addToken(Token.RC);
					 decompiler.addToken(Token.ELSE);
					 decompiler.addEOL(Token.LC);
					 ifFalse = statement();
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createIf(cond, ifTrue, ifFalse, lineno);
				 return pn;
			 }
			 case Token.SWITCH: {
				 consumeToken();
				 decompiler.addToken(Token.SWITCH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.switch"");
				 decompiler.addToken(Token.LP);
				 pn = enterSwitch(expr(false), lineno, statementLabel);
				 try {
					 mustMatchToken(Token.RP, ""msg.no.paren.after.switch"");
					 decompiler.addToken(Token.RP);
					 mustMatchToken(Token.LC, ""msg.no.brace.switch"");
					 decompiler.addEOL(Token.LC);
					 boolean hasDefault = false;
					 switchLoop: for (;
					;
					) {
						 tt = nextToken();
						 Node caseExpression;
						 switch (tt) {
							 case Token.RC: break switchLoop;
							 case Token.CASE: decompiler.addToken(Token.CASE);
							 caseExpression = expr(false);
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 case Token.DEFAULT: if (hasDefault) {
								 reportError(""msg.double.switch.default"");
							 }
							 decompiler.addToken(Token.DEFAULT);
							 hasDefault = true;
							 caseExpression = null;
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 default: reportError(""msg.bad.switch"");
							 break switchLoop;
						 }
						 Node block = nf.createLeaf(Token.BLOCK);
						 while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {
							 nf.addChildToBack(block, statement());
						 }
						 nf.addSwitchCase(pn, caseExpression, block);
					 }
					 decompiler.addEOL(Token.RC);
					 nf.closeSwitch(pn);
				 }
				 finally {
					 exitSwitch();
				 }
				 return pn;
			 }
			 case Token.WHILE: {
				 consumeToken();
				 decompiler.addToken(Token.WHILE);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node cond = condition();
					 decompiler.addEOL(Token.LC);
					 Node body = statement();
					 decompiler.addEOL(Token.RC);
					 pn = nf.createWhile(loop, cond, body);
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.DO: {
				 consumeToken();
				 decompiler.addToken(Token.DO);
				 decompiler.addEOL(Token.LC);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node body = statement();
					 decompiler.addToken(Token.RC);
					 mustMatchToken(Token.WHILE, ""msg.no.while.do"");
					 decompiler.addToken(Token.WHILE);
					 Node cond = condition();
					 pn = nf.createDoWhile(loop, body, cond);
				 }
				 finally {
					 exitLoop();
				 }
				 matchToken(Token.SEMI);
				 decompiler.addEOL(Token.SEMI);
				 return pn;
			 }
			 case Token.FOR: {
				 consumeToken();
				 boolean isForEach = false;
				 decompiler.addToken(Token.FOR);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node init;
					 Node cond;
					 Node incr = null;
					 Node body;
					 if (matchToken(Token.NAME)) {
						 decompiler.addName(ts.getString());
						 if (ts.getString().equals(""each"")) {
							 isForEach = true;
						 }
						 else {
							 reportError(""msg.no.paren.for"");
						 }
					 }
					 mustMatchToken(Token.LP, ""msg.no.paren.for"");
					 decompiler.addToken(Token.LP);
					 tt = peekToken();
					 if (tt == Token.SEMI) {
						 init = nf.createLeaf(Token.EMPTY);
					 }
					 else {
						 if (tt == Token.VAR) {
							 consumeToken();
							 init = variables(true);
						 }
						 else {
							 init = expr(true);
						 }
					 }
					 if (matchToken(Token.IN)) {
						 decompiler.addToken(Token.IN);
						 cond = expr(false);
					 }
					 else {
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.SEMI) {
							 cond = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 cond = expr(false);
						 }
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for.cond"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.RP) {
							 incr = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 incr = expr(false);
						 }
					 }
					 mustMatchToken(Token.RP, ""msg.no.paren.for.ctrl"");
					 decompiler.addToken(Token.RP);
					 decompiler.addEOL(Token.LC);
					 body = statement();
					 decompiler.addEOL(Token.RC);
					 if (incr == null) {
						 pn = nf.createForIn(loop, init, cond, body, isForEach);
					 }
					 else {
						 pn = nf.createFor(loop, init, cond, incr, body);
					 }
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.TRY: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 Node tryblock;
				 Node catchblocks = null;
				 Node finallyblock = null;
				 decompiler.addToken(Token.TRY);
				 decompiler.addEOL(Token.LC);
				 tryblock = statement();
				 decompiler.addEOL(Token.RC);
				 catchblocks = nf.createLeaf(Token.BLOCK);
				 boolean sawDefaultCatch = false;
				 int peek = peekToken();
				 if (peek == Token.CATCH) {
					 while (matchToken(Token.CATCH)) {
						 if (sawDefaultCatch) {
							 reportError(""msg.catch.unreachable"");
						 }
						 decompiler.addToken(Token.CATCH);
						 mustMatchToken(Token.LP, ""msg.no.paren.catch"");
						 decompiler.addToken(Token.LP);
						 mustMatchToken(Token.NAME, ""msg.bad.catchcond"");
						 String varName = ts.getString();
						 decompiler.addName(varName);
						 Node catchCond = null;
						 if (matchToken(Token.IF)) {
							 decompiler.addToken(Token.IF);
							 catchCond = expr(false);
						 }
						 else {
							 sawDefaultCatch = true;
						 }
						 mustMatchToken(Token.RP, ""msg.bad.catchcond"");
						 decompiler.addToken(Token.RP);
						 mustMatchToken(Token.LC, ""msg.no.brace.catchblock"");
						 decompiler.addEOL(Token.LC);
						 nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(), ts.getLineno()));
						 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
						 decompiler.addEOL(Token.RC);
					 }
				 }
				 else if (peek != Token.FINALLY) {
					 mustMatchToken(Token.FINALLY, ""msg.try.no.catchfinally"");
				 }
				 if (matchToken(Token.FINALLY)) {
					 decompiler.addToken(Token.FINALLY);
					 decompiler.addEOL(Token.LC);
					 finallyblock = statement();
					 decompiler.addEOL(Token.RC);
				 }
				 pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);
				 return pn;
			 }
			 case Token.THROW: {
				 consumeToken();
				 if (peekTokenOrEOL() == Token.EOL) {
					 reportError(""msg.bad.throw.eol"");
				 }
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.THROW);
				 pn = nf.createThrow(expr(false), lineno);
				 break;
			 }
			 case Token.BREAK: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.BREAK);
				 Node breakStatement = matchJumpLabelName();
				 if (breakStatement == null) {
					 if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {
						 reportError(""msg.bad.break"");
						 return null;
					 }
					 breakStatement = (Node)loopAndSwitchSet.peek();
				 }
				 pn = nf.createBreak(breakStatement, lineno);
				 break;
			 }
			 case Token.CONTINUE: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.CONTINUE);
				 Node loop;
				 Node label = matchJumpLabelName();
				 if (label == null) {
					 if (loopSet == null || loopSet.size() == 0) {
						 reportError(""msg.continue.outside"");
						 return null;
					 }
					 loop = (Node)loopSet.peek();
				 }
				 else {
					 loop = nf.getLabelLoop(label);
					 if (loop == null) {
						 reportError(""msg.continue.nonloop"");
						 return null;
					 }
				 }
				 pn = nf.createContinue(loop, lineno);
				 break;
			 }
			 case Token.WITH: {
				 consumeToken();
				 decompiler.addToken(Token.WITH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.with"");
				 decompiler.addToken(Token.LP);
				 Node obj = expr(false);
				 mustMatchToken(Token.RP, ""msg.no.paren.after.with"");
				 decompiler.addToken(Token.RP);
				 decompiler.addEOL(Token.LC);
				 ++nestingOfWith;
				 Node body;
				 try {
					 body = statement();
				 }
				 finally {
					 --nestingOfWith;
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createWith(obj, body, lineno);
				 return pn;
			 }
			 case Token.VAR: {
				 consumeToken();
				 pn = variables(false);
				 break;
			 }
			 case Token.RETURN: {
				 if (!insideFunction()) {
					 reportError(""msg.bad.return"");
				 }
				 consumeToken();
				 decompiler.addToken(Token.RETURN);
				 int lineno = ts.getLineno();
				 Node retExpr;
				 tt = peekTokenOrEOL();
				 switch (tt) {
					 case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null;
					 break;
					 default: retExpr = expr(false);
				 }
				 pn = nf.createReturn(retExpr, lineno);
				 break;
			 }
			 case Token.LC: consumeToken();
			 if (statementLabel != null) {
				 decompiler.addToken(Token.LC);
			 }
			 pn = statements();
			 mustMatchToken(Token.RC, ""msg.no.brace.block"");
			 if (statementLabel != null) {
				 decompiler.addEOL(Token.RC);
			 }
			 return pn;
			 case Token.ERROR: case Token.SEMI: consumeToken();
			 pn = nf.createLeaf(Token.EMPTY);
			 return pn;
			 case Token.FUNCTION: {
				 consumeToken();
				 pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);
				 return pn;
			 }
			 case Token.DEFAULT : consumeToken();
			 mustHaveXML();
			 decompiler.addToken(Token.DEFAULT);
			 int nsLine = ts.getLineno();
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""xml""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""namespace""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!matchToken(Token.ASSIGN)) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addToken(Token.ASSIGN);
			 Node expr = expr(false);
			 pn = nf.createDefaultNamespace(expr, nsLine);
			 break;
			 case Token.NAME: {
				 int lineno = ts.getLineno();
				 String name = ts.getString();
				 setCheckForLabel();
				 pn = expr(false);
				 if (pn.getType() != Token.LABEL) {
					 pn = nf.createExprStatement(pn, lineno);
				 }
				 else {
					 if (peekToken() != Token.COLON) Kit.codeBug();
					 consumeToken();
					 decompiler.addName(name);
					 decompiler.addEOL(Token.COLON);
					 if (labelSet == null) {
						 labelSet = new Hashtable();
					 }
					 else if (labelSet.containsKey(name)) {
						 reportError(""msg.dup.label"");
					 }
					 boolean firstLabel;
					 if (statementLabel == null) {
						 firstLabel = true;
						 statementLabel = pn;
					 }
					 else {
						 firstLabel = false;
					 }
					 labelSet.put(name, statementLabel);
					 try {
						 pn = statementHelper(statementLabel);
					 }
					 finally {
						 labelSet.remove(name);
					 }
					 if (firstLabel) {
						 pn = nf.createLabeledStatement(statementLabel, pn);
					 }
					 return pn;
				 }
				 break;
			 }
			 default: {
				 int lineno = ts.getLineno();
				 pn = expr(false);
				 pn = nf.createExprStatement(pn, lineno);
				 break;
			 }
		 }
		 int ttFlagged = peekFlaggedToken();
		 switch (ttFlagged & CLEAR_TI_MASK) {
			 case Token.SEMI: consumeToken();
			 break;
			 case Token.ERROR: case Token.EOF: case Token.RC: break;
			 default: if ((ttFlagged & TI_AFTER_EOL) == 0) {
				 reportError(""msg.no.semi.stmt"");
			 }
			 break;
		 }
		 decompiler.addEOL(Token.SEMI);
		 return pn;
	 }
	 private Node variables(boolean inForInit) throws IOException, ParserException {
		 Node pn = nf.createVariables(ts.getLineno());
		 boolean first = true;
		 decompiler.addToken(Token.VAR);
		 for (;
		;
		) {
			 Node name;
			 Node init;
			 mustMatchToken(Token.NAME, ""msg.bad.var"");
			 String s = ts.getString();
			 if (!first) decompiler.addToken(Token.COMMA);
			 first = false;
			 decompiler.addName(s);
			 currentScriptOrFn.addVar(s);
			 name = nf.createName(s);
			 if (matchToken(Token.ASSIGN)) {
				 decompiler.addToken(Token.ASSIGN);
				 init = assignExpr(inForInit);
				 nf.addChildToBack(name, init);
			 }
			 nf.addChildToBack(pn, name);
			 if (!matchToken(Token.COMMA)) break;
		 }
		 return pn;
	 }
	 private Node expr(boolean inForInit) throws IOException, ParserException {
		 Node pn = assignExpr(inForInit);
		 while (matchToken(Token.COMMA)) {
			 decompiler.addToken(Token.COMMA);
			 pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node assignExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = condExpr(inForInit);
		 int tt = peekToken();
		 if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
			 consumeToken();
			 decompiler.addToken(tt);
			 pn = nf.createAssignment(tt, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node condExpr(boolean inForInit) throws IOException, ParserException {
		 Node ifTrue;
		 Node ifFalse;
		 Node pn = orExpr(inForInit);
		 if (matchToken(Token.HOOK)) {
			 decompiler.addToken(Token.HOOK);
			 ifTrue = assignExpr(false);
			 mustMatchToken(Token.COLON, ""msg.no.colon.cond"");
			 decompiler.addToken(Token.COLON);
			 ifFalse = assignExpr(inForInit);
			 return nf.createCondExpr(pn, ifTrue, ifFalse);
		 }
		 return pn;
	 }
	 private Node orExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = andExpr(inForInit);
		 if (matchToken(Token.OR)) {
			 decompiler.addToken(Token.OR);
			 pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node andExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitOrExpr(inForInit);
		 if (matchToken(Token.AND)) {
			 decompiler.addToken(Token.AND);
			 pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitXorExpr(inForInit);
		 while (matchToken(Token.BITOR)) {
			 decompiler.addToken(Token.BITOR);
			 pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitAndExpr(inForInit);
		 while (matchToken(Token.BITXOR)) {
			 decompiler.addToken(Token.BITXOR);
			 pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = eqExpr(inForInit);
		 while (matchToken(Token.BITAND)) {
			 decompiler.addToken(Token.BITAND);
			 pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node eqExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = relExpr(inForInit);
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: consumeToken();
				 int decompilerToken = tt;
				 int parseToken = tt;
				 if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
					 switch (tt) {
						 case Token.EQ: parseToken = Token.SHEQ;
						 break;
						 case Token.NE: parseToken = Token.SHNE;
						 break;
						 case Token.SHEQ: decompilerToken = Token.EQ;
						 break;
						 case Token.SHNE: decompilerToken = Token.NE;
						 break;
					 }
				 }
				 decompiler.addToken(decompilerToken);
				 pn = nf.createBinary(parseToken, pn, relExpr(inForInit));
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node relExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = shiftExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.IN: if (inForInit) break;
				 case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, shiftExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node shiftExpr() throws IOException, ParserException {
		 Node pn = addExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.LSH: case Token.URSH: case Token.RSH: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, addExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node addExpr() throws IOException, ParserException {
		 Node pn = mulExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 if (tt == Token.ADD || tt == Token.SUB) {
				 consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, mulExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node mulExpr() throws IOException, ParserException {
		 Node pn = unaryExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.MUL: case Token.DIV: case Token.MOD: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, unaryExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node unaryExpr() throws IOException, ParserException {
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createUnary(tt, unaryExpr());
			 case Token.ADD: consumeToken();
			 decompiler.addToken(Token.POS);
			 return nf.createUnary(Token.POS, unaryExpr());
			 case Token.SUB: consumeToken();
			 decompiler.addToken(Token.NEG);
			 return nf.createUnary(Token.NEG, unaryExpr());
			 case Token.INC: case Token.DEC: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createIncDec(tt, false, memberExpr(true));
			 case Token.DELPROP: consumeToken();
			 decompiler.addToken(Token.DELPROP);
			 return nf.createUnary(Token.DELPROP, unaryExpr());
			 case Token.ERROR: consumeToken();
			 break;
			 case Token.LT: if (compilerEnv.isXmlAvailable()) {
				 consumeToken();
				 Node pn = xmlInitializer();
				 return memberExprTail(true, pn);
			 }
			 default: Node pn = memberExpr(true);
			 tt = peekTokenOrEOL();
			 if (tt == Token.INC || tt == Token.DEC) {
				 consumeToken();
				 decompiler.addToken(tt);
				 return nf.createIncDec(tt, true, pn);
			 }
			 return pn;
		 }
		 return nf.createName(""err"");
	 }
	 private Node xmlInitializer() throws IOException {
		 int tt = ts.getFirstXMLToken();
		 if (tt != Token.XML && tt != Token.XMLEND) {
			 reportError(""msg.syntax"");
			 return null;
		 }
		 Node pnXML = nf.createLeaf(Token.NEW);
		 decompiler.addToken(Token.NEW);
		 decompiler.addToken(Token.DOT);
		 String xml = ts.getString();
		 boolean fAnonymous = xml.trim().startsWith(""<>"");
		 decompiler.addName(fAnonymous ? ""XMLList"" : ""XML"");
		 Node pn = nf.createName(fAnonymous ? ""XMLList"" : ""XML"");
		 nf.addChildToBack(pnXML, pn);
		 pn = null;
		 Node expr;
		 for (;
		;
		tt = ts.getNextXMLToken()) {
			 switch (tt) {
				 case Token.XML: xml = ts.getString();
				 decompiler.addString(xml);
				 mustMatchToken(Token.LC, ""msg.syntax"");
				 decompiler.addToken(Token.LC);
				 expr = (peekToken() == Token.RC) ? nf.createString("""") : expr(false);
				 mustMatchToken(Token.RC, ""msg.syntax"");
				 decompiler.addToken(Token.RC);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 int nodeType;
				 if (ts.isXMLAttribute()) {
					 nodeType = Token.ESCXMLATTR;
				 }
				 else {
					 nodeType = Token.ESCXMLTEXT;
				 }
				 expr = nf.createUnary(nodeType, expr);
				 pn = nf.createBinary(Token.ADD, pn, expr);
				 break;
				 case Token.XMLEND: xml = ts.getString();
				 decompiler.addString(xml);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 nf.addChildToBack(pnXML, pn);
				 return pnXML;
				 default: reportError(""msg.syntax"");
				 return null;
			 }
		 }
	 }
	 private void argumentList(Node listNode) throws IOException, ParserException {
		 boolean matched;
		 matched = matchToken(Token.RP);
		 if (!matched) {
			 boolean first = true;
			 do {
				 if (!first) decompiler.addToken(Token.COMMA);
				 first = false;
				 nf.addChildToBack(listNode, assignExpr(false));
			 }
			 while (matchToken(Token.COMMA));
			 mustMatchToken(Token.RP, ""msg.no.paren.arg"");
		 }
		 decompiler.addToken(Token.RP);
	 }
	 private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {
		 int tt;
		 Node pn;
		 tt = peekToken();
		 if (tt == Token.NEW) {
			 consumeToken();
			 decompiler.addToken(Token.NEW);
			 pn = nf.createCallOrNew(Token.NEW, memberExpr(false));
			 if (matchToken(Token.LP)) {
				 decompiler.addToken(Token.LP);
				 argumentList(pn);
			 }
			 tt = peekToken();
			 if (tt == Token.LC) {
				 nf.addChildToBack(pn, primaryExpr());
			 }
		 }
		 else {
			 pn = primaryExpr();
		 }
		 return memberExprTail(allowCallSyntax, pn);
	 }
	 private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {
		 tailLoop: for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.DOT: case Token.DOTDOT: {
					 int memberTypeFlags;
					 String s;
					 consumeToken();
					 decompiler.addToken(tt);
					 memberTypeFlags = 0;
					 if (tt == Token.DOTDOT) {
						 mustHaveXML();
						 memberTypeFlags = Node.DESCENDANTS_FLAG;
					 }
					 if (!compilerEnv.isXmlAvailable()) {
						 mustMatchToken(Token.NAME, ""msg.no.name.after.dot"");
						 s = ts.getString();
						 decompiler.addName(s);
						 pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);
						 break;
					 }
					 tt = nextToken();
					 switch (tt) {
						 case Token.NAME: s = ts.getString();
						 decompiler.addName(s);
						 pn = propertyName(pn, s, memberTypeFlags);
						 break;
						 case Token.MUL: decompiler.addName(""*"");
						 pn = propertyName(pn, ""*"", memberTypeFlags);
						 break;
						 case Token.XMLATTR: decompiler.addToken(Token.XMLATTR);
						 pn = attributeAccess(pn, memberTypeFlags);
						 break;
						 default: reportError(""msg.no.name.after.dot"");
					 }
				 }
				 break;
				 case Token.DOTQUERY: consumeToken();
				 mustHaveXML();
				 decompiler.addToken(Token.DOTQUERY);
				 pn = nf.createDotQuery(pn, expr(false), ts.getLineno());
				 mustMatchToken(Token.RP, ""msg.no.paren"");
				 decompiler.addToken(Token.RP);
				 break;
				 case Token.LB: consumeToken();
				 decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, null, expr(false), 0);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 break;
				 case Token.LP: if (!allowCallSyntax) {
					 break tailLoop;
				 }
				 consumeToken();
				 decompiler.addToken(Token.LP);
				 pn = nf.createCallOrNew(Token.CALL, pn);
				 argumentList(pn);
				 break;
				 default: break tailLoop;
			 }
		 }
		 return pn;
	 }
	 private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {
		 memberTypeFlags |= Node.ATTRIBUTE_FLAG;
		 int tt = nextToken();
		 switch (tt) {
			 case Token.NAME: {
				 String s = ts.getString();
				 decompiler.addName(s);
				 pn = propertyName(pn, s, memberTypeFlags);
			 }
			 break;
			 case Token.MUL: decompiler.addName(""*"");
			 pn = propertyName(pn, ""*"", memberTypeFlags);
			 break;
			 case Token.LB: decompiler.addToken(Token.LB);
			 pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);
			 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
			 decompiler.addToken(Token.RB);
			 break;
			 default: reportError(""msg.no.name.after.xmlAttr"");
			 pn = nf.createPropertyGet(pn, null, ""?"", memberTypeFlags);
			 break;
		 }
		 return pn;
	 }
	 private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {
		 String namespace = null;
		 if (matchToken(Token.COLONCOLON)) {
			 decompiler.addToken(Token.COLONCOLON);
			 namespace = name;
			 int tt = nextToken();
			 switch (tt) {
				 case Token.NAME: name = ts.getString();
				 decompiler.addName(name);
				 break;
				 case Token.MUL: decompiler.addName(""*"");
				 name = ""*"";
				 break;
				 case Token.LB: decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 return pn;
				 default: reportError(""msg.no.name.after.coloncolon"");
				 name = ""?"";
			 }
		 }
		 pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);
		 return pn;
	 }
	 private Node primaryExpr() throws IOException, ParserException {
		 Node pn;
		 int ttFlagged = nextFlaggedToken();
		 int tt = ttFlagged & CLEAR_TI_MASK;
		 switch(tt) {
			 case Token.FUNCTION: return function(FunctionNode.FUNCTION_EXPRESSION);
			 case Token.LB: {
				 ObjArray elems = new ObjArray();
				 int skipCount = 0;
				 decompiler.addToken(Token.LB);
				 boolean after_lb_or_comma = true;
				 for (;
				;
				) {
					 tt = peekToken();
					 if (tt == Token.COMMA) {
						 consumeToken();
						 decompiler.addToken(Token.COMMA);
						 if (!after_lb_or_comma) {
							 after_lb_or_comma = true;
						 }
						 else {
							 elems.add(null);
							 ++skipCount;
						 }
					 }
					 else if (tt == Token.RB) {
						 consumeToken();
						 decompiler.addToken(Token.RB);
						 break;
					 }
					 else {
						 if (!after_lb_or_comma) {
							 reportError(""msg.no.bracket.arg"");
						 }
						 elems.add(assignExpr(false));
						 after_lb_or_comma = false;
					 }
				 }
				 return nf.createArrayLiteral(elems, skipCount);
			 }
			 case Token.LC: {
				 ObjArray elems = new ObjArray();
				 decompiler.addToken(Token.LC);
				 if (!matchToken(Token.RC)) {
					 boolean first = true;
					 commaloop: do {
						 Object property;
						 if (!first) decompiler.addToken(Token.COMMA);
						 else first = false;
						 tt = peekToken();
						 switch(tt) {
							 case Token.NAME: case Token.STRING: consumeToken();
							 String s = ts.getString();
							 if (tt == Token.NAME) {
								 decompiler.addName(s);
							 }
							 else {
								 decompiler.addString(s);
							 }
							 property = ScriptRuntime.getIndexObject(s);
							 break;
							 case Token.NUMBER: consumeToken();
							 double n = ts.getNumber();
							 decompiler.addNumber(n);
							 property = ScriptRuntime.getIndexObject(n);
							 break;
							 case Token.RC: break commaloop;
							 default: reportError(""msg.bad.prop"");
							 break commaloop;
						 }
						 mustMatchToken(Token.COLON, ""msg.no.colon.prop"");
						 decompiler.addToken(Token.OBJECTLIT);
						 elems.add(property);
						 elems.add(assignExpr(false));
					 }
					 while (matchToken(Token.COMMA));
					 mustMatchToken(Token.RC, ""msg.no.brace.prop"");
				 }
				 decompiler.addToken(Token.RC);
				 return nf.createObjectLiteral(elems);
			 }
			 case Token.LP: decompiler.addToken(Token.LP);
			 pn = expr(false);
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.RP, ""msg.no.paren"");
			 return pn;
			 case Token.XMLATTR: mustHaveXML();
			 decompiler.addToken(Token.XMLATTR);
			 pn = attributeAccess(null, 0);
			 return pn;
			 case Token.NAME: {
				 String name = ts.getString();
				 if ((ttFlagged & TI_CHECK_LABEL) != 0) {
					 if (peekToken() == Token.COLON) {
						 return nf.createLabel(ts.getLineno());
					 }
				 }
				 decompiler.addName(name);
				 if (compilerEnv.isXmlAvailable()) {
					 pn = propertyName(null, name, 0);
				 }
				 else {
					 pn = nf.createName(name);
				 }
				 return pn;
			 }
			 case Token.NUMBER: {
				 double n = ts.getNumber();
				 decompiler.addNumber(n);
				 return nf.createNumber(n);
			 }
			 case Token.STRING: {
				 String s = ts.getString();
				 decompiler.addString(s);
				 return nf.createString(s);
			 }
			 case Token.DIV: case Token.ASSIGN_DIV: {
				 ts.readRegExp(tt);
				 String flags = ts.regExpFlags;
				 ts.regExpFlags = null;
				 String re = ts.getString();
				 decompiler.addRegexp(re, flags);
				 int index = currentScriptOrFn.addRegexp(re, flags);
				 return nf.createRegExp(index);
			 }
			 case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: decompiler.addToken(tt);
			 return nf.createLeaf(tt);
			 case Token.RESERVED: reportError(""msg.reserved.id"");
			 break;
			 case Token.ERROR: break;
			 case Token.EOF: reportError(""msg.unexpected.eof"");
			 break;
			 default: reportError(""msg.syntax"");
			 break;
		 }
		 return null;
	 }
}",1,0,0,0
"public class DoubleType extends AbstractType<Double>{
	 public static final DoubleType instance = new DoubleType();
	 DoubleType() {
	}
	 public Double compose(ByteBuffer bytes) {
		 return JdbcDouble.instance.compose(bytes);
	 }
	 public ByteBuffer decompose(Double value) {
		 return JdbcDouble.instance.decompose(value);
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 if (o1.remaining() == 0) {
			 return o2.remaining() == 0 ? 0 : -1;
		 }
		 if (o2.remaining() == 0) {
			 return 1;
		 }
		 return compose(o1).compareTo(compose(o2));
	 }
	 public String getString(ByteBuffer bytes) {
		 try {
			 return JdbcDouble.instance.getString(bytes);
		 }
		 catch (org.apache.cassandra.cql.jdbc.MarshalException e) {
			 throw new MarshalException(e.getMessage());
		 }
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
		 Double d;
		 try {
			 d = Double.parseDouble(source);
		 }
		 catch (NumberFormatException e1) {
			 throw new MarshalException(String.format(""unable to coerce '%s' to a double"", source), e1);
		 }
		 return decompose(d);
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 if (bytes.remaining() != 8 && bytes.remaining() != 0) throw new MarshalException(String.format(""Expected 8 or 0 byte value for a double (%d)"", bytes.remaining()));
	 }
}",0,0,0,0
"public void testGroupByOrderPreservingDescSort() throws Exception {
	 Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
	 Connection conn = DriverManager.getConnection(getUrl(), props);
	 String tableName = generateUniqueName();
	 conn.createStatement().execute(""CREATE TABLE "" + tableName + "" (k1 char(1) not null, k2 char(1) not null,"" + "" constraint pk primary key (k1,k2)) split on ('ac','jc','nc')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'a')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'b')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'c')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'd')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'a')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'b')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'c')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'd')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'a')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'b')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'c')"");
	 conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'd')"");
	 conn.commit();
	 QueryBuilder queryBuilder = new QueryBuilder() .setSelectExpression(""K1,COUNT(*)"") .setSelectColumns(Lists.newArrayList(""K1"")) .setFullTableName(tableName) .setGroupByClause(""K1"") .setOrderByClause(""K1 DESC"");
	 ResultSet rs = executeQuery(conn, queryBuilder);
	 assertTrue(rs.next());
	 assertEquals(""n"", rs.getString(1));
	 assertEquals(4, rs.getLong(2));
	 assertTrue(rs.next());
	 assertEquals(""j"", rs.getString(1));
	 assertEquals(4, rs.getLong(2));
	 assertTrue(rs.next());
	 assertEquals(""a"", rs.getString(1));
	 assertEquals(4, rs.getLong(2));
	 assertFalse(rs.next());
	 String expectedPhoenixPlan = ""CLIENT PARALLEL 1-WAY REVERSE FULL SCAN OVER "" + tableName + ""\n"" + "" SERVER FILTER BY FIRST KEY ONLY\n"" + "" SERVER AGGREGATE INTO ORDERED DISTINCT ROWS BY [K1]"";
	 validateQueryPlan(conn, queryBuilder, expectedPhoenixPlan, null);
 }",0,0,1,0
"public final class AutoLinkResolver implements IComponentResolver{
	public static abstract class AbstractAutolinkResolverDelegateimplementsIAutolinkResolverDelegate{
		protected final Component newPackageResourceReferenceAutoComponent(final MarkupContainer container, final String autoId, final PathInfo pathInfo,final String attribute){
			if (!pathInfo.absolute && (pathInfo.path != null) && (pathInfo.path.length() > 0)){
				Class<? extends Component> clazz = container.getMarkupStream().getContainerClass();
				if (container.getMarkupStream().getTag().getMarkupClass() != null){
					clazz = container.getMarkupStream().getTag().getMarkupClass();
				}
				ResourceReferenceAutolink autoLink = new ResourceReferenceAutolink(autoId, clazz,pathInfo.reference, attribute, container);
				if (autoLink.resourceReference != null){
					return autoLink;
				}
			}
			return null;
		}
	}
	public final static class AutolinkBookmarkablePageLink<T> extends BookmarkablePageLink<T>{
		private static final long serialVersionUID = 1L;
		private final String anchor;
		public static boolean autoEnable = true;
		public <C extends Page> AutolinkBookmarkablePageLink(final String id,final Class<C> pageClass, final PageParameters parameters, final String anchor){
			super(id, pageClass, parameters);
			this.anchor = anchor;
			setAutoEnable(autoEnable);
		}
		public boolean isTransparentResolver(){
			return true;
		}
		protected CharSequence getURL(){
			CharSequence url = super.getURL();
			if (anchor != null){
				url = url + anchor;
			}
			return url;
		}
	}
	public static interface IAutolinkResolverDelegate{
		Component newAutoComponent(final MarkupContainer container, final String autoId,final PathInfo pathInfo);
	}
	public static final class PathInfo{
		private final boolean absolute;
		private final String anchor;
		private final String extension;
		private final PageParameters pageParameters;
		private final String path;
		private final String reference;
		public PathInfo(final String reference){
			this.reference = reference;
			String infoPath;
			int queryStringPos = reference.indexOf(""?"");
			if (queryStringPos != -1){
				final String queryString = reference.substring(queryStringPos + 1);
				pageParameters = new PageParameters();
				RequestUtils.decodeParameters(queryString, pageParameters);
				infoPath = reference.substring(0, queryStringPos);
			}
			else{
				pageParameters = null;
				infoPath = reference;
			}
			absolute = (infoPath.startsWith(""/"") || infoPath.startsWith(""\\""));
			String extension = null;
			int pos = infoPath.lastIndexOf(""."");
			if (pos != -1){
				extension = infoPath.substring(pos + 1);
				infoPath = infoPath.substring(0, pos);
			}
			String anchor = null;
			if (extension != null){
				pos = extension.indexOf('#');
				if (pos != -1){
					anchor = extension.substring(pos);
					extension = extension.substring(0, pos);
				}
			}
			if (anchor == null){
				pos = infoPath.indexOf(""#"");
				if (pos != -1){
					anchor = infoPath.substring(pos);
					infoPath = infoPath.substring(0, pos);
				}
			}
			path = infoPath;
			this.extension = extension;
			this.anchor = anchor;
		}
		public final String getAnchor(){
			return anchor;
		}
		public final String getExtension(){
			return extension;
		}
		public final PageParameters getPageParameters(){
			return pageParameters;
		}
		public final String getPath(){
			return path;
		}
		public final String getReference(){
			return reference;
		}
		public final boolean isAbsolute(){
			return absolute;
		}
	}
	private static final class AnchorResolverDelegate extends AbstractAutolinkResolverDelegate{
		private static final String attribute = ""href"";
		private final Set<String> supportedPageExtensions = new HashSet<String>(4);
		public AnchorResolverDelegate(){
			supportedPageExtensions.add(""html"");
			supportedPageExtensions.add(""xml"");
			supportedPageExtensions.add(""wml"");
			supportedPageExtensions.add(""svg"");
		}
		public Component newAutoComponent(final MarkupContainer container, final String autoId,PathInfo pathInfo){
			if ((pathInfo.extension != null) &&supportedPageExtensions.contains(pathInfo.extension)){
				Page page = container.getPage();
				final IClassResolver defaultClassResolver = page.getApplication().getApplicationSettings().getClassResolver();
				String className = Packages.absolutePath(page.getClass(), pathInfo.path);
				className = Strings.replaceAll(className, ""/"", ""."").toString();
				if (className.startsWith(""."")){
					className = className.substring(1);
				}
				try{
					final Class<? extends Page> clazz = (Class<? extends Page>)defaultClassResolver.resolveClass(className);
					return new AutolinkBookmarkablePageLink<Void>(autoId, clazz,pathInfo.pageParameters, pathInfo.anchor);
				}
				catch (ClassNotFoundException ex){
					log.warn(""Did not find corresponding java class: "" + className);
				}
				MarkupContainer parentWithContainer = container;
				if (container.getParent() != null){
					parentWithContainer = container.findParentWithAssociatedMarkup();
				}
				if ((parentWithContainer instanceof Page) && !pathInfo.path.startsWith(""/"") &&page.getMarkupStream().isMergedMarkup()){
					Class<? extends Page> clazz = (Class<? extends Page>)container.getMarkupStream().getTag().getMarkupClass();
					if (clazz != null){
						className = Packages.absolutePath(clazz, pathInfo.path);
						className = Strings.replaceAll(className, ""/"", ""."").toString();
						if (className.startsWith(""."")){
							className = className.substring(1);
						}
						try{
							clazz = (Class<? extends Page>)defaultClassResolver.resolveClass(className);
							return new AutolinkBookmarkablePageLink<Void>(autoId, clazz,pathInfo.getPageParameters(), pathInfo.anchor);
						}
						catch (ClassNotFoundException ex){
							log.warn(""Did not find corresponding java class: "" + className);
						}
					}
				}
			}
			else{
				return newPackageResourceReferenceAutoComponent(container, autoId, pathInfo,attribute);
			}
			return null;
		}
	}
	private final static class AutolinkExternalLink extends ExternalLink{
		private static final long serialVersionUID = 1L;
		public AutolinkExternalLink(final String id, final String href){
			super(id, href);
		}
		public boolean isTransparentResolver(){
			return true;
		}
	}
	private static interface ITagReferenceResolver{
		String getReference(final ComponentTag tag);
	}
	private final static class ResourceReferenceAutolink extends WebMarkupContainer{
		private static final long serialVersionUID = 1L;
		private final String attribute;
		private final ResourceReference resourceReference;
		private final MarkupContainer parent;
		public ResourceReferenceAutolink(final String id, final Class<?> clazz, final String href,final String attribute, final MarkupContainer parent){
			super(id);
			this.attribute = attribute;
			this.parent = parent;
			if (PackageResource.exists(clazz, href, getLocale(), getStyle())){
				resourceReference = new ResourceReference(clazz, href, getLocale(), getStyle());
			}
			else{
				resourceReference = null;
			}
		}
		public String getVariation(){
			if (parent != null){
				return parent.getVariation();
			}
			return super.getVariation();
		}
		public boolean isTransparentResolver(){
			return true;
		}
		protected final void onComponentTag(final ComponentTag tag){
			super.onComponentTag(tag);
			if (resourceReference != null){
				CharSequence url = getRequestCycle().urlFor(resourceReference);
				tag.put(attribute, Strings.replaceAll(url, ""&"", ""&amp;
				""));
			}
		}
	}
	private static final class ResourceReferenceResolverDelegate extendsAbstractAutolinkResolverDelegate{
		private final String attribute;
		public ResourceReferenceResolverDelegate(final String attribute){
			this.attribute = attribute;
		}
		public Component newAutoComponent(final MarkupContainer container, final String autoId,final PathInfo pathInfo){
			return newPackageResourceReferenceAutoComponent(container, autoId, pathInfo, attribute);
		}
	}
	private static final class TagReferenceResolver implements ITagReferenceResolver{
		private final String attribute;
		public TagReferenceResolver(final String attribute){
			this.attribute = attribute;
		}
		public String getReference(final ComponentTag tag){
			return tag.getAttributes().getString(attribute);
		}
	}
	private static final TagReferenceResolver DEFAULT_ATTRIBUTE_RESOLVER = new TagReferenceResolver(""href"");
	private static final Logger log = LoggerFactory.getLogger(AutoLinkResolver.class);
	private static final long serialVersionUID = 1L;
	private final Map<String, IAutolinkResolverDelegate> tagNameToAutolinkResolverDelegates = new HashMap<String, IAutolinkResolverDelegate>();
	private final Map<String, ITagReferenceResolver> tagNameToTagReferenceResolvers = new HashMap<String, ITagReferenceResolver>();
	public AutoLinkResolver(){
		TagReferenceResolver hrefTagReferenceResolver = new TagReferenceResolver(""href"");
		TagReferenceResolver srcTagReferenceResolver = new TagReferenceResolver(""src"");
		tagNameToTagReferenceResolvers.put(""a"", hrefTagReferenceResolver);
		tagNameToTagReferenceResolvers.put(""link"", hrefTagReferenceResolver);
		tagNameToTagReferenceResolvers.put(""script"", srcTagReferenceResolver);
		tagNameToTagReferenceResolvers.put(""img"", srcTagReferenceResolver);
		tagNameToTagReferenceResolvers.put(""input"", srcTagReferenceResolver);
		tagNameToTagReferenceResolvers.put(""embed"", srcTagReferenceResolver);
		tagNameToAutolinkResolverDelegates.put(""a"", new AnchorResolverDelegate());
		tagNameToAutolinkResolverDelegates.put(""link"",new ResourceReferenceResolverDelegate(""href""));
		ResourceReferenceResolverDelegate srcResRefResolver = new ResourceReferenceResolverDelegate(""src"");
		tagNameToAutolinkResolverDelegates.put(""script"", srcResRefResolver);
		tagNameToAutolinkResolverDelegates.put(""img"", srcResRefResolver);
		tagNameToAutolinkResolverDelegates.put(""input"", srcResRefResolver);
		tagNameToAutolinkResolverDelegates.put(""embed"", srcResRefResolver);
	}
	public final void addTagReferenceResolver(final String tagName, final String attributeName,final IAutolinkResolverDelegate resolver){
		TagReferenceResolver tagReferenceResolver = new TagReferenceResolver(attributeName);
		tagNameToTagReferenceResolvers.put(tagName, tagReferenceResolver);
		tagNameToAutolinkResolverDelegates.put(tagName, resolver);
	}
	public final IAutolinkResolverDelegate getAutolinkResolverDelegate(final String tagName){
		return tagNameToAutolinkResolverDelegates.get(tagName);
	}
	public final boolean resolve(final MarkupContainer container, final MarkupStream markupStream,final ComponentTag tag){
		if (tag.isAutolinkEnabled()){
			final Component link = resolveAutomaticLink(container,WicketLinkTagHandler.AUTOLINK_ID, tag);
			container.autoAdd(link, markupStream);
			if (log.isDebugEnabled()){
				log.debug(""Added autolink "" + link);
			}
			return true;
		}
		return false;
	}
	private final Component resolveAutomaticLink(final MarkupContainer container, final String id,final ComponentTag tag){
		final Page page = container.getPage();
		final String autoId = id + Integer.toString(page.getAutoIndex());
		final String tagName = tag.getName();
		if (tag.getId() == null){
			tag.setId(autoId);
			tag.setAutoComponentTag(true);
		}
		ITagReferenceResolver referenceResolver = tagNameToTagReferenceResolvers.get(tagName);
		if (referenceResolver == null){
			referenceResolver = DEFAULT_ATTRIBUTE_RESOLVER;
		}
		String reference = referenceResolver.getReference(tag);
		PathInfo pathInfo = new PathInfo(reference);
		IAutolinkResolverDelegate autolinkResolverDelegate = tagNameToAutolinkResolverDelegates.get(tagName);
		Component autoComponent = null;
		if (autolinkResolverDelegate != null){
			autoComponent = autolinkResolverDelegate.newAutoComponent(container, autoId, pathInfo);
		}
		if (autoComponent == null){
			autoComponent = new AutolinkExternalLink(autoId, pathInfo.reference);
		}
		return autoComponent;
	}
}",0,0,0,0
"public class TestBuiltin {
	 private static final Log LOG = LogFactory.getLog(TestBuiltin.class);
	 private static PigServer pigServer;
	 private static Properties properties;
	 private static MiniGenericCluster cluster;
	 private TupleFactory tupleFactory = TupleFactory.getInstance();
	 private BagFactory bagFactory = DefaultBagFactory.getInstance();
	 private static Tuple NULL_INPUT_TUPLE;
	 private static Integer[] intInput = {
	 3, 1, 2, 4, 5, 7, null, 6, 8, 9, 10 }
	;
	 private static Long[] intAsLong = {
	 3L, 1L, 2L, 4L, 5L, 7L, null, 6L, 8L, 9L, 10L }
	;
	 private static Long[] longInput = {
	 145769183483345L, null, 4345639849L, 3435543121L, 2L, 5L, 9L, 7L, 8L, 6L, 10L }
	;
	 private static Float[] floatInput = {
	 10.4f, 2.35f, 3.099f, null, 4.08495f, 5.350f, 6.78f, 7.0f, 8.0f, 9.0f, 0.09f }
	;
	 private static Double[] floatAsDouble = {
	 10.4, 2.35, 3.099, null, 4.08495, 5.350, 6.78, 7.0, 8.0, 9.0, 0.09 }
	;
	 private static Double[] doubleInput = {
	 5.5673910, 121.0, 3.0, 0.000000834593, 1.0, 6.0, 7.0, 8.0, 9.0, 10.0, null }
	;
	 private static BigDecimal[] bigDecimalInput = {
	BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN, new BigDecimal(""99999999999999977.9999999999999999999999999999999999999999"")}
	;
	 private static BigInteger[] bigIntegerInput = {
	BigInteger.ZERO, BigInteger.ONE, BigInteger.TEN, new BigInteger(""999999999998888888887777777777777744444488888889999999999977"")}
	;
	 private static String[] ba = {
	 ""7"", ""2"", ""3"", null, ""4"", ""5"", ""6"", ""1"", ""8"", ""9"", ""10""}
	;
	 private static Double[] baAsDouble = {
	 7.0, 2.0, 3.0, null, 4.0, 5.0, 6.0, 1.0, 8.0, 9.0, 10.0}
	;
	 private static String[] stringInput = {
	""unit"", ""test"", null, ""input"", ""string""}
	;
	 private static DataByteArray[] ByteArrayInput = Util.toDataByteArrays(ba);
	 private static DateTime[] datetimeInput = {
	new DateTime(""2009-01-07T01:07:02.000Z""), new DateTime(""2008-10-09T01:07:02.000Z""), null, new DateTime(""2014-12-25T11:11:11.000Z""), new DateTime(""2009-01-07T01:07:02.000Z"")}
	;
	 private static HashMap<String, EvalFunc<?>> evalFuncMap = new HashMap<String, EvalFunc<?>>();
	 private static HashMap<String, Tuple> inputMap = new HashMap<String, Tuple>();
	 private static HashMap<String, Tuple[]> inputMapForAccumulate = new HashMap<String, Tuple[]>();
	 private static HashMap<String, String> allowedInput = new HashMap<String, String>();
	 private static HashMap<String, Object> expectedMap = new HashMap<String, Object>();
	 String[] stages = {
	""Initial"", ""Intermediate"", ""Final""}
	;
	 String[][] aggs = {
		 {
		""SUM"", ""IntSum"", ""LongSum"", ""FloatSum"", ""DoubleSum"", ""BigDecimalSum"", ""BigIntegerSum""}
		, {
		""AVG"", ""IntAvg"", ""LongAvg"", ""FloatAvg"", ""DoubleAvg"", ""BigDecimalAvg"", ""BigIntegerAvg""}
		, {
		""MIN"", ""IntMin"", ""LongMin"", ""FloatMin"", ""DoubleMin"", ""BigDecimalMin"", ""BigIntegerMin"",""StringMin"", ""DateTimeMin""}
		, {
		""MAX"", ""IntMax"", ""LongMax"", ""FloatMax"", ""DoubleMax"", ""BigDecimalMax"", ""BigIntegerMax"",""StringMax"", ""DateTimeMax""}
		, {
		""COUNT""}
	, }
	;
	 String[] inputTypeAsString = {
	""ByteArray"", ""Integer"", ""Long"", ""Float"", ""Double"", ""BigDecimal"", ""BigInteger"", ""String"", ""DateTime""}
	;
	 public void setUp() throws Exception {
		 Util.resetStateForExecModeSwitch();
		 pigServer = new PigServer(Util.getLocalTestMode(), new Properties());
		 pigServer.setValidateEachStatement(true);
		 setupEvalFuncMap();
		 NULL_INPUT_TUPLE = TupleFactory.getInstance().newTuple(1);
		 NULL_INPUT_TUPLE.set(0, null);
		 expectedMap.put(""SUM"", new Double(55));
		 expectedMap.put(""DoubleSum"", new Double(170.567391834593));
		 expectedMap.put(""IntSum"", new Long(55));
		 expectedMap.put(""LongSum"", new Long(145776964666362L));
		 expectedMap.put(""FloatSum"", new Double(56.15395));
		 expectedMap.put(""BigDecimalSum"", new BigDecimal(""99999999999999988.9999999999999999999999999999999999999999""));
		 expectedMap.put(""BigIntegerSum"", new BigInteger(""999999999998888888887777777777777744444488888889999999999988""));
		 expectedMap.put(""AVG"", new Double(5.5));
		 expectedMap.put(""DoubleAvg"", new Double(17.0567391834593));
		 expectedMap.put(""LongAvg"", new Double(14577696466636.2));
		 expectedMap.put(""IntAvg"", new Double(5.5));
		 expectedMap.put(""FloatAvg"", new Double(5.615394958853722));
		 expectedMap.put(""BigDecimalAvg"", new BigDecimal(""24999999999999997.25000000000000000""));
		 expectedMap.put(""BigIntegerAvg"", new BigDecimal(""2.499999999997222222219444444444444E+59""));
		 expectedMap.put(""MIN"", new Double(1));
		 expectedMap.put(""IntMin"", new Integer(1));
		 expectedMap.put(""LongMin"", new Long(2));
		 expectedMap.put(""FloatMin"", new Float(0.09f));
		 expectedMap.put(""DoubleMin"", new Double(0.000000834593));
		 expectedMap.put(""BigDecimalMin"", BigDecimal.ZERO);
		 expectedMap.put(""BigIntegerMin"", BigInteger.ZERO);
		 expectedMap.put(""StringMin"", ""input"");
		 expectedMap.put(""DateTimeMin"", new DateTime(""2008-10-09T01:07:02.000Z""));
		 expectedMap.put(""MAX"", new Double(10));
		 expectedMap.put(""IntMax"", new Integer(10));
		 expectedMap.put(""LongMax"", new Long(145769183483345L));
		 expectedMap.put(""FloatMax"", new Float(10.4f));
		 expectedMap.put(""DoubleMax"", new Double(121.0));
		 expectedMap.put(""BigDecimalMax"", new BigDecimal(""99999999999999977.9999999999999999999999999999999999999999""));
		 expectedMap.put(""BigIntegerMax"", new BigInteger(""999999999998888888887777777777777744444488888889999999999977""));
		 expectedMap.put(""StringMax"", ""unit"");
		 expectedMap.put(""DateTimeMax"", new DateTime(""2014-12-25T11:11:11.000Z""));
		 expectedMap.put(""COUNT"", new Long(10));
		 for (String[] aggGroups : aggs) {
			 int i = 0;
			 for (String agg: aggGroups) {
				 allowedInput.put(agg, inputTypeAsString[i++]);
			 }
		 }
		 for (String[] aggGroups : aggs) {
			 for (String agg: aggGroups) {
				 for (String stage : stages) {
					 if (stage.equals(""Initial"")) {
						 allowedInput.put(agg + stage, allowedInput.get(agg));
					 }
					 else {
						 if ((agg).equals(""IntSum"") || (agg).equals(""IntAvg"")) {
							 allowedInput.put(agg + stage, ""IntegerAsLong"");
						 }
						 else if ((agg).equals(""FloatSum"") || agg.equals(""FloatAvg"")) {
							 allowedInput.put(agg + stage, ""FloatAsDouble"");
						 }
						else if ((agg).equals(""MIN"") || agg.equals(""MAX"") || (agg.equals(""SUM"")) || agg.equals(""AVG"")) {
							 allowedInput.put(agg + stage, ""ByteArrayAsDouble"");
						 }
						 else {
							 allowedInput.put(agg + stage, allowedInput.get(agg));
						 }
						 if (! agg.matches(""(?i)avg"") || stage.equals(""Final"")) {
							 expectedMap.put(agg + stage, expectedMap.get(agg));
						 }
					 }
				 }
			 }
		 }
		 expectedMap.put(""AVGIntermediate"", expectedMap.get(""SUM""));
		 expectedMap.put(""DoubleAvgIntermediate"", expectedMap.get(""DoubleSum""));
		 expectedMap.put(""LongAvgIntermediate"", expectedMap.get(""LongSum""));
		 expectedMap.put(""IntAvgIntermediate"", expectedMap.get(""IntSum""));
		 expectedMap.put(""FloatAvgIntermediate"", expectedMap.get(""FloatSum""));
		 expectedMap.put(""BigDecimalAvgIntermediate"", expectedMap.get(""BigDecimalSum""));
		 expectedMap.put(""BigIntegerAvgIntermediate"", expectedMap.get(""BigIntegerSum""));
		 inputMap.put(""Integer"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), intInput));
		 inputMap.put(""IntegerAsLong"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), intAsLong));
		 inputMap.put(""Long"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), longInput));
		 inputMap.put(""Float"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), floatInput));
		 inputMap.put(""FloatAsDouble"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), floatAsDouble));
		 inputMap.put(""Double"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), doubleInput));
		 inputMap.put(""BigDecimal"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), bigDecimalInput));
		 inputMap.put(""BigInteger"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), bigIntegerInput));
		 inputMap.put(""ByteArray"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), ByteArrayInput));
		 inputMap.put(""ByteArrayAsDouble"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), baAsDouble));
		 inputMap.put(""String"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), stringInput));
		 inputMap.put(""DateTime"", Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), datetimeInput));
		 inputMapForAccumulate.put(""Integer"", Util.splitCreateBagOfTuples(intInput,3));
		 inputMapForAccumulate.put(""IntegerAsLong"", Util.splitCreateBagOfTuples(intAsLong,3));
		 inputMapForAccumulate.put(""Long"", Util.splitCreateBagOfTuples(longInput,3));
		 inputMapForAccumulate.put(""Float"", Util.splitCreateBagOfTuples(floatInput,3));
		 inputMapForAccumulate.put(""FloatAsDouble"", Util.splitCreateBagOfTuples(floatAsDouble,3));
		 inputMapForAccumulate.put(""Double"", Util.splitCreateBagOfTuples(doubleInput,3));
		 inputMapForAccumulate.put(""BigDecimal"", Util.splitCreateBagOfTuples(bigDecimalInput,3));
		 inputMapForAccumulate.put(""BigInteger"", Util.splitCreateBagOfTuples(bigIntegerInput,3));
		 inputMapForAccumulate.put(""ByteArray"", Util.splitCreateBagOfTuples(ByteArrayInput,3));
		 inputMapForAccumulate.put(""ByteArrayAsDouble"", Util.splitCreateBagOfTuples(baAsDouble,3));
		 inputMapForAccumulate.put(""String"", Util.splitCreateBagOfTuples(stringInput,3));
		 inputMapForAccumulate.put(""DateTime"", Util.splitCreateBagOfTuples(datetimeInput,3));
	 }
	 public static void oneTimeSetUp() throws Exception {
		 cluster = MiniGenericCluster.buildCluster();
		 properties = cluster.getProperties();
	 }
	 public static void shutDown() {
		 cluster.shutDown();
	 }
	 private void setupEvalFuncMap() {
		 for (String[] aggGroup : aggs) {
			 for (String agg : aggGroup) {
				 EvalFunc<?> func = (EvalFunc<?>)PigContext.instantiateFuncFromSpec(agg);
				 evalFuncMap.put(agg, func);
				 evalFuncMap.put(agg + ""Initial"", (EvalFunc<?>)PigContext.instantiateFuncFromSpec(((Algebraic)func).getInitial()));
				 evalFuncMap.put(agg + ""Intermediate"", (EvalFunc<?>)PigContext.instantiateFuncFromSpec(((Algebraic)func).getIntermed()));
				 evalFuncMap.put(agg + ""Final"", (EvalFunc<?>)PigContext.instantiateFuncFromSpec(((Algebraic)func).getFinal()));
			 }
		 }
	 }
	 public void testAddSubtractDuration() throws Exception {
		 AddDuration func1 = new AddDuration();
		 SubtractDuration func2 = new SubtractDuration();
		 Tuple t1 = TupleFactory.getInstance().newTuple(2);
		 t1.set(0, new DateTime(""2009-01-07T01:07:01.000Z""));
		 t1.set(1, ""PT1S"");
		 Tuple t2 = TupleFactory.getInstance().newTuple(2);
		 t2.set(0, new DateTime(""2008-02-06T02:06:02.000Z""));
		 t2.set(1, ""PT1M"");
		 Tuple t3 = TupleFactory.getInstance().newTuple(2);
		 t3.set(0, new DateTime(""2007-03-05T03:05:03.000Z""));
		 t3.set(1, ""P1D"");
		 assertEquals(func1.exec(t1), new DateTime(""2009-01-07T01:07:02.000Z""));
		 assertEquals(func1.exec(t2), new DateTime(""2008-02-06T02:07:02.000Z""));
		 assertEquals(func1.exec(t3), new DateTime(""2007-03-06T03:05:03.000Z""));
		 assertEquals(func2.exec(t1), new DateTime(""2009-01-07T01:07:00.000Z""));
		 assertEquals(func2.exec(t2), new DateTime(""2008-02-06T02:05:02.000Z""));
		 assertEquals(func2.exec(t3), new DateTime(""2007-03-04T03:05:03.000Z""));
	 }
	 public void testConversionBetweenDateTimeAndString() throws Exception {
		 ToDate func1 = new ToDate();
		 Tuple t1 = TupleFactory.getInstance().newTuple(1);
		 t1.set(0, 1231290421000L);
		 DateTime dt1 = func1.exec(t1);
		 assertEquals(dt1.compareTo(new DateTime(""2009-01-07T01:07:01.000Z"")), 0);
		 ToDateISO func2 = new ToDateISO();
		 Tuple t2 = TupleFactory.getInstance().newTuple(1);
		 t2.set(0, ""2009-01-07T01:07:01.000Z"");
		 DateTime dt2 = func2.exec(t2);
		 assertEquals(dt2.compareTo(new DateTime(""2009-01-07T01:07:01.000Z"")), 0);
		 Tuple t2space = TupleFactory.getInstance().newTuple(1);
		 t2space.set(0, ""2009-01-07 01:07:01.000Z"");
		 DateTime dt2space = func2.exec(t2space);
		 assertEquals(dt2space.compareTo(new DateTime(""2009-01-07T01:07:01.000Z"")), 0);
		 Tuple t2dateOnly = TupleFactory.getInstance().newTuple(1);
		 t2dateOnly.set(0, ""2015-05-29"");
		 DateTime dt2dateOnly = func2.exec(t2dateOnly);
		 assertEquals(dt2dateOnly.compareTo(new DateTime(""2015-05-29"")), 0);
		 Tuple t2dateSpaceHour = TupleFactory.getInstance().newTuple(1);
		 t2dateSpaceHour.set(0, ""2015-05-29 11"");
		 DateTime dt2dateSpaceHour = func2.exec(t2dateSpaceHour);
		 assertEquals(dt2dateSpaceHour.compareTo(new DateTime(""2015-05-29T11"")), 0);
		 Tuple t2dateSpaceHourMin = TupleFactory.getInstance().newTuple(1);
		 t2dateSpaceHourMin.set(0, ""2015-05-29 11:38"");
		 DateTime dt2dateSpaceHourMin = func2.exec(t2dateSpaceHourMin);
		 assertEquals(dt2dateSpaceHourMin.compareTo(new DateTime(""2015-05-29T11:38"")), 0);
		 Tuple t2dateSpaceHourMinSec = TupleFactory.getInstance().newTuple(1);
		 t2dateSpaceHourMinSec.set(0, ""2015-05-29 11:38:39"");
		 DateTime dt2dateSpaceHourMinSec = func2.exec(t2dateSpaceHourMinSec);
		 assertEquals(dt2dateSpaceHourMinSec.compareTo(new DateTime(""2015-05-29T11:38:39"")), 0);
		 Tuple t3 = TupleFactory.getInstance().newTuple(1);
		 t3.set(0, ""2009-01-07T01:07:01.000+08:00"");
		 DateTime dt3 = func2.exec(t3);
		 assertEquals(dt3.compareTo(new DateTime(""2009-01-07T01:07:01.000+08:00"", DateTimeZone.forID(""+08:00""))), 0);
		 Tuple t3space = TupleFactory.getInstance().newTuple(1);
		 t3space.set(0, ""2009-01-07 01:07:01.000+08:00"");
		 DateTime dt3space = func2.exec(t3space);
		 assertEquals(dt3space.compareTo(new DateTime(""2009-01-07T01:07:01.000+08:00"", DateTimeZone.forID(""+08:00""))), 0);
		 ToDate2ARGS func3 = new ToDate2ARGS();
		 Tuple t4 = TupleFactory.getInstance().newTuple(2);
		 t4.set(0, ""2009.01.07 AD at 01:07:01"");
		 t4.set(1, ""yyyy.MM.dd G 'at' HH:mm:ss"");
		 DateTime dt4 = func3.exec(t4);
		 assertEquals(dt4.compareTo(new DateTime(""2009-01-07T01:07:01.000"")), 0);
		 Tuple t5 = TupleFactory.getInstance().newTuple(2);
		 t5.set(0, ""2009.01.07 AD at 01:07:01 +0800"");
		 t5.set(1, ""yyyy.MM.dd G 'at' HH:mm:ss Z"");
		 DateTime dt5 = func3.exec(t5);
		 assertEquals(dt5.compareTo(new DateTime(""2009-01-07T01:07:01.000+08:00"")), 0);
		 ToDate3ARGS func4 = new ToDate3ARGS();
		 Tuple t6 = TupleFactory.getInstance().newTuple(3);
		 t6.set(0, ""2009.01.07 AD at 01:07:01"");
		 t6.set(1, ""yyyy.MM.dd G 'at' HH:mm:ss"");
		 t6.set(2, ""+00:00"");
		 DateTime dt6 = func4.exec(t6);
		 assertEquals(dt6.compareTo(new DateTime(""2009-01-07T01:07:01.000"", DateTimeZone.forID(""+00:00""))), 0);
		 Tuple t7 = TupleFactory.getInstance().newTuple(3);
		 t7.set(0, ""2009.01.07 AD at 01:07:01 +0800"");
		 t7.set(1, ""yyyy.MM.dd G 'at' HH:mm:ss Z"");
		 t7.set(2, ""Asia/Singapore"");
		 DateTime dt7 = func4.exec(t7);
		 assertEquals(dt7.compareTo(new DateTime(""2009-01-07T01:07:01.000+08:00"", DateTimeZone.forID(""+08:00""))), 0);
		 ToUnixTime func5 = new ToUnixTime();
		 Tuple t8 = TupleFactory.getInstance().newTuple(1);
		 t8.set(0, new DateTime(1231290421000L));
		 Long ut1 = func5.exec(t8);
		 assertEquals(ut1.longValue(), 1231290421L);
		 ToString func6 = new ToString();
		 Tuple t9 = TupleFactory.getInstance().newTuple(1);
		 t9.set(0, ToDate.extractDateTime(""2009-01-07T01:07:01.000Z""));
		 String dtStr1 = func6.exec(t9);
		 assertEquals(dtStr1, ""2009-01-07T01:07:01.000Z"");
		 Tuple t10 = TupleFactory.getInstance().newTuple(1);
		 t10.set(0, new DateTime(""2009-01-07T09:07:01.000+08:00"", DateTimeZone.UTC));
		 String dtStr2 = func6.exec(t10);
		 assertEquals(dtStr2, ""2009-01-07T01:07:01.000Z"");
		 Tuple t11 = TupleFactory.getInstance().newTuple(2);
		 t11.set(0, ToDate.extractDateTime(""2009-01-07T01:07:01.000Z""));
		 t11.set(1, ""yyyy.MM.dd G 'at' HH:mm:ss"");
		 String dtStr3 = func6.exec(t11);
		 assertEquals(dtStr3, ""2009.01.07 AD at 01:07:01"");
		 Tuple t12 = TupleFactory.getInstance().newTuple(2);
		 t12.set(0, new DateTime(""2009-01-07T01:07:01.000+08:00"", DateTimeZone.forID(""+08:00"")));
		 t12.set(1, ""yyyy.MM.dd G 'at' HH:mm:ss Z"");
		 String dtStr4 = func6.exec(t12);
		 assertEquals(dtStr4, ""2009.01.07 AD at 01:07:01 +0800"");
		 ToMilliSeconds func7 = new ToMilliSeconds();
		 Tuple t13 = TupleFactory.getInstance().newTuple(1);
		 t13.set(0, new DateTime(1231290421000L));
		 Long ut2 = func7.exec(t13);
		 assertEquals(ut2.longValue(), 1231290421000L);
		 Tuple t14 = TupleFactory.getInstance().newTuple(3);
		 t14.set(0, ""2014-02-02 18:00:00.000Z"");
		 t14.set(1, ""yyyy-MM-dd HH:mm:ss.SSSZ"");
		 t14.set(2, ""Europe/Berlin"");
		 DateTime dt8 = func4.exec(t14);
		 assertEquals(dt8.toString(), ""2014-02-02T19:00:00.000+01:00"");
		 t1.set(0, null);
		 assertEquals(func1.exec(t1), null);
		 assertEquals(func2.exec(t1), null);
		 assertEquals(func3.exec(t1), null);
		 assertEquals(func4.exec(t1), null);
		 assertEquals(func5.exec(t1), null);
		 assertEquals(func6.exec(t1), null);
		 assertEquals(func7.exec(t1), null);
	 }
	 public void testAggNoCombine() throws Exception {
		 for (String[] aggGroup : aggs) {
			 String[] aggFinalTypes = null;
			 String[] aggInitialTypes = null;
			 for (String stage: stages) {
				 String[] aggTypesArray = null;
				 if (stage.equals(""Initial"")) {
					 aggInitialTypes = new String[aggGroup.length];
					 aggTypesArray = aggInitialTypes;
				 }
				 else if (stage.equals(""Final"")) {
					 aggFinalTypes = new String[aggGroup.length];
					 aggTypesArray = aggFinalTypes;
				 }
				 else {
					 continue;
				 }
				 for (int i = 0;
				 i < aggTypesArray.length;
				 i++) {
					 aggTypesArray[i] = aggGroup[i] + stage;
				 }
			 }
			 for (int k = 0;
			 k < aggFinalTypes.length;
			 k++) {
				 EvalFunc<?> avgInitial = evalFuncMap.get(aggInitialTypes[k]);
				 Tuple tup = inputMap.get(getInputType(aggInitialTypes[k]));
				 DataBag bg = (DataBag) tup.get(0);
				 DataBag finalInputBg = bagFactory.newDefaultBag();
				 for (Tuple tuple : bg) {
					 DataBag initialInputBg = bagFactory.newDefaultBag();
					 initialInputBg.add(tuple);
					 Tuple initialInputTuple = tupleFactory.newTuple(initialInputBg);
					 finalInputBg.add((Tuple)avgInitial.exec(initialInputTuple));
				 }
				 Tuple finalInputTuple = tupleFactory.newTuple(finalInputBg);
				 EvalFunc<?> aggFinal = evalFuncMap.get(aggFinalTypes[k]);
				 String msg = ""[Testing "" + aggGroup[k] + "" on input type: "" + getInputType(aggFinalTypes[k]);
				 System.err.println(msg + "" for no combiner case]"");
				 Object output = aggFinal.exec(finalInputTuple);
				 msg += "" ( (output) "" + output + "" == "" + getExpected(aggFinalTypes[k]) + "" (expected) )]"";
				 if (getExpected(aggFinalTypes[k]) instanceof Double) {
					 assertEquals(msg, (Double)getExpected(aggFinalTypes[k]), (Double)output, 0.00001);
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof BigDecimal) {
					 assertEquals(msg, ((BigDecimal)getExpected(aggFinalTypes[k])).toPlainString(), ((BigDecimal)output).toPlainString());
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof BigInteger) {
					 assertEquals(msg, ((BigInteger)getExpected(aggFinalTypes[k])).toString(), ((BigInteger)output).toString());
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof DateTime) {
					 assertEquals(msg, ((DateTime)getExpected(aggFinalTypes[k])).getMillis(), ((DateTime)output).getMillis());
				 }
				 else {
					 assertEquals(msg, getExpected(aggFinalTypes[k]), output);
				 }
			 }
		 }
	 }
	 public void testAggSingleCombine() throws Exception {
		 for (String[] aggGroup : aggs) {
			 String[] aggFinalTypes = null;
			 String[] aggInitialTypes = null;
			 String[] aggIntermediateTypes = null;
			 for (String stage: stages) {
				 String[] aggTypesArray = null;
				 if (stage.equals(""Initial"")) {
					 aggInitialTypes = new String[aggGroup.length];
					 aggTypesArray = aggInitialTypes;
				 }
				 else if (stage.equals(""Intermediate"")) {
					 aggIntermediateTypes = new String[aggGroup.length];
					 aggTypesArray = aggIntermediateTypes;
				 }
				 else {
					 aggFinalTypes = new String[aggGroup.length];
					 aggTypesArray = aggFinalTypes;
				 }
				 for (int i = 0;
				 i < aggTypesArray.length;
				 i++) {
					 aggTypesArray[i] = aggGroup[i] + stage;
				 }
			 }
			 for (int k = 0;
			 k < aggFinalTypes.length;
			 k++) {
				 EvalFunc<?> aggInitial = evalFuncMap.get(aggInitialTypes[k]);
				 Tuple tup = inputMap.get(getInputType(aggInitialTypes[k]));
				 DataBag bg = (DataBag) tup.get(0);
				 DataBag intermediateInputBg1 = bagFactory.newDefaultBag();
				 DataBag intermediateInputBg2 = bagFactory.newDefaultBag();
				 int i = 0;
				 for (Tuple tuple : bg) {
					 DataBag initialInputBg = bagFactory.newDefaultBag();
					 initialInputBg.add(tuple);
					 Tuple initialInputTuple = tupleFactory.newTuple(initialInputBg);
					 if (i < bg.size()/2) {
						 intermediateInputBg1.add((Tuple)aggInitial.exec(initialInputTuple));
					 }
					 else {
						 intermediateInputBg2.add((Tuple)aggInitial.exec(initialInputTuple));
					 }
					 i++;
				 }
				 EvalFunc<?> avgIntermediate = evalFuncMap.get(aggIntermediateTypes[k]);
				 DataBag finalInputBg = bagFactory.newDefaultBag();
				 Tuple intermediateInputTuple = tupleFactory.newTuple(intermediateInputBg1);
				 finalInputBg.add((Tuple)avgIntermediate.exec(intermediateInputTuple));
				 intermediateInputTuple = tupleFactory.newTuple(intermediateInputBg2);
				 finalInputBg.add((Tuple)avgIntermediate.exec(intermediateInputTuple));
				 Tuple finalInputTuple = tupleFactory.newTuple(finalInputBg);
				 EvalFunc<?> aggFinal = evalFuncMap.get(aggFinalTypes[k]);
				 String msg = ""[Testing "" + aggGroup[k] + "" on input type: "" + getInputType(aggFinalTypes[k]);
				 System.err.println(msg + "" for single combiner case]"");
				 Object output = aggFinal.exec(finalInputTuple);
				 msg += "" ( (output) "" + output + "" == "" + getExpected(aggFinalTypes[k]) + "" (expected) )]"";
				 if (getExpected(aggFinalTypes[k]) instanceof Double) {
					 assertEquals(msg, (Double)getExpected(aggFinalTypes[k]), (Double)output, 0.00001);
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof BigDecimal) {
					 assertEquals(msg, ((BigDecimal)getExpected(aggFinalTypes[k])).toPlainString(), ((BigDecimal)output).toPlainString());
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof BigInteger) {
					 assertEquals(msg, ((BigInteger)getExpected(aggFinalTypes[k])).toString(), ((BigInteger)output).toString());
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof DateTime) {
					 assertEquals(msg, ((DateTime)getExpected(aggFinalTypes[k])).getMillis(), ((DateTime)output).getMillis());
				 }
				 else {
					 assertEquals(msg, getExpected(aggFinalTypes[k]), output);
				 }
			 }
		 }
	 }
	 public void testAggMultipleCombine() throws Exception {
		 for (String[] aggGroup : aggs) {
			 String[] aggFinalTypes = null;
			 String[] aggInitialTypes = null;
			 String[] aggIntermediateTypes = null;
			 for (String stage: stages) {
				 String[] aggTypesArray = null;
				 if (stage.equals(""Initial"")) {
					 aggInitialTypes = new String[aggGroup.length];
					 aggTypesArray = aggInitialTypes;
				 }
				 else if (stage.equals(""Intermediate"")) {
					 aggIntermediateTypes = new String[aggGroup.length];
					 aggTypesArray = aggIntermediateTypes;
				 }
				 else {
					 aggFinalTypes = new String[aggGroup.length];
					 aggTypesArray = aggFinalTypes;
				 }
				 for (int i = 0;
				 i < aggTypesArray.length;
				 i++) {
					 aggTypesArray[i] = aggGroup[i] + stage;
				 }
			 }
			 for (int k = 0;
			 k < aggFinalTypes.length;
			 k++) {
				 EvalFunc<?> aggInitial = evalFuncMap.get(aggInitialTypes[k]);
				 Tuple tup = inputMap.get(getInputType(aggInitialTypes[k]));
				 DataBag bg = (DataBag) tup.get(0);
				 DataBag[] mapIntermediateInputBgs = new DataBag[4];
				 for (int i = 0;
				 i < mapIntermediateInputBgs.length;
				 i++) {
					 mapIntermediateInputBgs[i] = bagFactory.newDefaultBag();
				 }
				 Iterator<Tuple> it = bg.iterator();
				 for (int i = 0;
				 i < 4;
				 i++) {
					 for (int j = 0;
					 j < bg.size()/4;
					 j++) {
						 DataBag initialInputBg = bagFactory.newDefaultBag();
						 initialInputBg.add(it.next());
						 Tuple initialInputTuple = tupleFactory.newTuple(initialInputBg);
						 mapIntermediateInputBgs[i].add((Tuple)aggInitial.exec(initialInputTuple));
					 }
					 if (i == 3) {
						 while(it.hasNext()) {
							 DataBag initialInputBg = bagFactory.newDefaultBag();
							 initialInputBg.add(it.next());
							 Tuple initialInputTuple = tupleFactory.newTuple(initialInputBg);
							 mapIntermediateInputBgs[i].add((Tuple)aggInitial.exec(initialInputTuple));
						 }
					 }
				 }
				 EvalFunc<?> aggIntermediate = evalFuncMap.get(aggIntermediateTypes[k]);
				 DataBag[] reduceIntermediateInputBgs = new DataBag[2];
				 for (int i = 0;
				 i < reduceIntermediateInputBgs.length;
				 i++) {
					 reduceIntermediateInputBgs[i] = bagFactory.newDefaultBag();
				 }
				 for (int i = 0;
				 i < 4;
				 i++) {
					 Tuple intermediateInputTuple = tupleFactory.newTuple(mapIntermediateInputBgs[i]);
					 if (i < 2) {
						 reduceIntermediateInputBgs[0].add((Tuple)aggIntermediate.exec(intermediateInputTuple));
					 }
					 else {
						 reduceIntermediateInputBgs[1].add((Tuple)aggIntermediate.exec(intermediateInputTuple));
					 }
				 }
				 DataBag finalInputBag = bagFactory.newDefaultBag();
				 for (int i = 0;
				 i < 2;
				 i++) {
					 Tuple intermediateInputTuple = tupleFactory.newTuple(reduceIntermediateInputBgs[i]);
					 finalInputBag.add((Tuple)aggIntermediate.exec(intermediateInputTuple));
				 }
				 Tuple finalInputTuple = tupleFactory.newTuple(finalInputBag);
				 EvalFunc<?> aggFinal = evalFuncMap.get(aggFinalTypes[k]);
				 String msg = ""[Testing "" + aggGroup[k] + "" on input type: "" + getInputType(aggFinalTypes[k]);
				 System.err.println(msg + "" for multiple combiner case]"");
				 Object output = aggFinal.exec(finalInputTuple);
				 msg += "" ( (output) "" + output + "" == "" + getExpected(aggFinalTypes[k]) + "" (expected) )]"";
				 if (getExpected(aggFinalTypes[k]) instanceof Double) {
					 assertEquals(msg, (Double)getExpected(aggFinalTypes[k]), (Double)output, 0.00001);
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof BigDecimal) {
					 assertEquals(msg, ((BigDecimal)getExpected(aggFinalTypes[k])).toPlainString(), ((BigDecimal)output).toPlainString());
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof BigInteger) {
					 assertEquals(msg, ((BigInteger)getExpected(aggFinalTypes[k])).toString(), ((BigInteger)output).toString());
				 }
				 else if (getExpected(aggFinalTypes[k]) instanceof DateTime) {
					 assertEquals(msg, ((DateTime)getExpected(aggFinalTypes[k])).getMillis(), ((DateTime)output).getMillis());
				 }
				 else {
					 assertEquals(msg, getExpected(aggFinalTypes[k]), output);
				 }
			 }
		 }
	 }
	 public void testAggEmptyBagWithCombiner() throws Exception {
		 for (String[] aggGroup : aggs) {
			 String[] aggFinalTypes = null;
			 String[] aggInitialTypes = null;
			 String[] aggIntermediateTypes = null;
			 for (String stage: stages) {
				 String[] aggTypesArray = null;
				 if (stage.equals(""Initial"")) {
					 aggInitialTypes = new String[aggGroup.length];
					 aggTypesArray = aggInitialTypes;
				 }
				 else if (stage.equals(""Intermediate"")) {
					 aggIntermediateTypes = new String[aggGroup.length];
					 aggTypesArray = aggIntermediateTypes;
				 }
				 else {
					 aggFinalTypes = new String[aggGroup.length];
					 aggTypesArray = aggFinalTypes;
				 }
				 for (int i = 0;
				 i < aggTypesArray.length;
				 i++) {
					 aggTypesArray[i] = aggGroup[i] + stage;
				 }
			 }
			 for (int k = 0;
			 k < aggFinalTypes.length;
			 k++) {
				 EvalFunc<?> aggInitial = evalFuncMap.get(aggInitialTypes[k]);
				 DataBag intermediateInputBg1 = bagFactory.newDefaultBag();
				 DataBag intermediateInputBg2 = bagFactory.newDefaultBag();
				 Tuple outputTuple = null;
				 for (int i = 0;
				 i < 10;
				 i++) {
					 DataBag initialInputBg = bagFactory.newDefaultBag();
					 Tuple initialInputTuple = tupleFactory.newTuple(initialInputBg);
					 if (i < 5) {
						 outputTuple = (Tuple)aggInitial.exec(initialInputTuple);
						 checkZeroOrNull(aggInitial, outputTuple.get(0));
						 intermediateInputBg1.add(outputTuple);
					 }
					 else {
						 outputTuple = (Tuple)aggInitial.exec(initialInputTuple);
						 checkZeroOrNull(aggInitial, outputTuple.get(0));
						 intermediateInputBg2.add(outputTuple);
					 }
				 }
				 EvalFunc<?> aggIntermediate = evalFuncMap.get(aggIntermediateTypes[k]);
				 DataBag finalInputBg = bagFactory.newDefaultBag();
				 Tuple intermediateInputTuple = tupleFactory.newTuple(intermediateInputBg1);
				 outputTuple = (Tuple)aggIntermediate.exec(intermediateInputTuple);
				 checkZeroOrNull(aggIntermediate, outputTuple.get(0));
				 finalInputBg.add(outputTuple);
				 intermediateInputTuple = tupleFactory.newTuple(intermediateInputBg2);
				 outputTuple = (Tuple)aggIntermediate.exec(intermediateInputTuple);
				 checkZeroOrNull(aggIntermediate, outputTuple.get(0));
				 finalInputBg.add(outputTuple);
				 Tuple finalInputTuple = tupleFactory.newTuple(finalInputBg);
				 EvalFunc<?> aggFinal = evalFuncMap.get(aggFinalTypes[k]);
				 Object output = aggFinal.exec(finalInputTuple);
				 checkZeroOrNull(aggFinal, output);
			 }
		 }
	 }
	 public void testAggEmptyBag() throws Exception {
		 for (String[] aggGroup : aggs) {
			 for (int k = 0;
			 k < aggGroup.length;
			 k++) {
				 EvalFunc<?> agg = evalFuncMap.get(aggGroup[k]);
				 DataBag inputBag = bagFactory.newDefaultBag();
				 Tuple inputTuple = tupleFactory.newTuple(inputBag);
				 Object output = agg.exec(inputTuple);
				 checkZeroOrNull(agg, output);
			 }
		 }
	 }
	 private void checkZeroOrNull(EvalFunc<?> func, Object output) {
		 if (func.getClass().getName().contains(""COUNT"")) {
			 assertEquals(new Long(0), output);
		 }
		 else {
			 assertEquals(null, output);
		 }
	 }
	 public void testAVG() throws Exception {
		 String[] avgTypes = {
		""AVG"", ""DoubleAvg"", ""LongAvg"", ""IntAvg"", ""FloatAvg"", ""BigDecimalAvg"", ""BigIntegerAvg""}
		;
		 for (int k = 0;
		 k < avgTypes.length;
		 k++) {
			 EvalFunc<?> avg = evalFuncMap.get(avgTypes[k]);
			 Tuple tup = inputMap.get(getInputType(avgTypes[k]));
			 Object output = avg.exec(tup);
			 String msg = ""[Testing "" + avgTypes[k] + "" on input type: "" + getInputType(avgTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(avgTypes[k]) + "" (expected) )]"";
			 if (getInputType(avgTypes[k]) == ""BigDecimal"" || getInputType(avgTypes[k]) == ""BigInteger"") {
				 assertEquals(msg, ((BigDecimal)output).toPlainString(), ((BigDecimal)getExpected(avgTypes[k])).toPlainString());
			 }
			 else {
				 assertEquals(msg, (Double)output, (Double)getExpected(avgTypes[k]), 0.00001);
			 }
			 assertNull(avg.exec(NULL_INPUT_TUPLE));
		 }
	 }
	 public void testAVGIntermediate() throws Exception {
		 String[] avgTypes = {
		""AVGIntermediate"", ""DoubleAvgIntermediate"", ""LongAvgIntermediate"", ""IntAvgIntermediate"", ""FloatAvgIntermediate"", ""BigDecimalAvgIntermediate"", ""BigIntegerAvgIntermediate""}
		;
		 for (int k = 0;
		 k < avgTypes.length;
		 k++) {
			 EvalFunc<?> avg = evalFuncMap.get(avgTypes[k]);
			 String inputType = getInputType(avgTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 DataBag bag = (DataBag) tup.get(0);
			 DataBag bg = bagFactory.newDefaultBag();
			 for (Tuple t: bag) {
				 Tuple newTuple = tupleFactory.newTuple(2);
				 newTuple.set(0, t.get(0));
				 if (inputType == ""BigDecimal"") {
					 newTuple.set(1, BigDecimal.ONE);
				 }
				 else if (inputType == ""BigInteger"") {
					 newTuple.set(1, BigInteger.ONE);
				 }
				 else {
					 newTuple.set(1, new Long(1));
				 }
				 bg.add(newTuple);
			 }
			 Tuple intermediateInput = tupleFactory.newTuple();
			 intermediateInput.append(bg);
			 Object output = avg.exec(intermediateInput);
			 if (inputType == ""Long"" || inputType == ""Integer"" || inputType == ""IntegerAsLong"") {
				 Long l = (Long)((Tuple)output).get(0);
				 String msg = ""[Testing "" + avgTypes[k] + "" on input type: "" + getInputType(avgTypes[k]) + "" ( (output) "" + l + "" == "" + getExpected(avgTypes[k]) + "" (expected) )]"";
				 assertEquals(msg, getExpected(avgTypes[k]), l);
			 }
			 else if (inputType == ""BigDecimal"") {
				 BigDecimal f1 = (BigDecimal)((Tuple)output).get(0);
				 String msg = ""[Testing "" + avgTypes[k] + "" on input type: "" + getInputType(avgTypes[k]) + "" ( (output) "" + f1 + "" == "" + getExpected(avgTypes[k]) + "" (expected) )]"";
				 assertEquals(msg, ((BigDecimal)getExpected(avgTypes[k])).toPlainString(), f1.toPlainString());
			 }
			 else if (inputType == ""BigInteger"") {
				 BigInteger f1 = (BigInteger)((Tuple)output).get(0);
				 String msg = ""[Testing "" + avgTypes[k] + "" on input type: "" + getInputType(avgTypes[k]) + "" ( (output) "" + f1 + "" == "" + getExpected(avgTypes[k]) + "" (expected) )]"";
				 assertEquals(msg, ((BigInteger)getExpected(avgTypes[k])).toString(), f1.toString());
			 }
			 else {
				 Double f1 = (Double)((Tuple)output).get(0);
				 String msg = ""[Testing "" + avgTypes[k] + "" on input type: "" + getInputType(avgTypes[k]) + "" ( (output) "" + f1 + "" == "" + getExpected(avgTypes[k]) + "" (expected) )]"";
				 assertEquals(msg, (Double)getExpected(avgTypes[k]), f1, 0.00001);
			 }
			 if (inputType == ""BigDecimal"") {
				 BigDecimal f2 = (BigDecimal)((Tuple)output).get(1);
				 assertEquals(""[Testing "" + avgTypes[k] + "" on input type: ""+ inputType+""]Expected count to be 4"", ""4"", f2.toPlainString());
			 }
			 else if (inputType == ""BigInteger"") {
				 BigInteger f2 = (BigInteger)((Tuple)output).get(1);
				 assertEquals(""[Testing "" + avgTypes[k] + "" on input type: ""+ inputType+""]Expected count to be 4"", ""4"", f2.toString());
			 }
			 else {
				 Long f2 = (Long)((Tuple)output).get(1);
				 assertEquals(""[Testing "" + avgTypes[k] + "" on input type: ""+ inputType+""]Expected count to be 11"", 11, f2.longValue());
			 }
		 }
	 }
	 public void testAVGFinal() throws Exception {
		 String[] avgTypes = {
		""AVGFinal"", ""DoubleAvgFinal"", ""LongAvgFinal"", ""IntAvgFinal"", ""FloatAvgFinal"", ""BigDecimalAvgFinal"", ""BigIntegerAvgFinal""}
		;
		 String[] avgIntermediateTypes = {
		""AVGIntermediate"", ""DoubleAvgIntermediate"", ""LongAvgIntermediate"", ""IntAvgIntermediate"", ""FloatAvgIntermediate"", ""BigDecimalAvgIntermediate"", ""BigIntegerAvgIntermediate""}
		;
		 for (int k = 0;
		 k < avgTypes.length;
		 k++) {
			 EvalFunc<?> avg = evalFuncMap.get(avgTypes[k]);
			 Tuple tup = inputMap.get(getInputType(avgTypes[k]));
			 EvalFunc<?> avgIntermediate = evalFuncMap.get(avgIntermediateTypes[k]);
			 DataBag bg = (DataBag) tup.get(0);
			 DataBag bg1 = bagFactory.newDefaultBag();
			 DataBag bg2 = bagFactory.newDefaultBag();
			 int i = 0;
			 for (Tuple t: bg) {
				 Tuple newTuple = tupleFactory.newTuple(2);
				 newTuple.set(0, t.get(0));
				 if ( t.get(0) == null) {
					 if (getInputType(avgTypes[k]) == ""BigDecimal"") {
						 newTuple.set(1, BigDecimal.ZERO);
					 }
					 else if (getInputType(avgTypes[k]) == ""BigInteger"") {
						 newTuple.set(1, BigInteger.ZERO);
					 }
					 else {
						 newTuple.set(1, new Long(0));
					 }
				 }
				 else {
					 if (getInputType(avgTypes[k]) == ""BigDecimal"") {
						 newTuple.set(1, BigDecimal.ONE);
					 }
					 else if (getInputType(avgTypes[k]) == ""BigInteger"") {
						 newTuple.set(1, BigInteger.ONE);
					 }
					 else {
						 newTuple.set(1, new Long(1));
					 }
				 }
				 if (i < 5) {
					 bg1.add(newTuple);
				 }
				 else {
					 bg2.add(newTuple);
				 }
				 i++;
			 }
			 Tuple intermediateInput1 = tupleFactory.newTuple();
			 intermediateInput1.append(bg1);
			 Object output1 = avgIntermediate.exec(intermediateInput1);
			 Tuple intermediateInput2 = tupleFactory.newTuple();
			 intermediateInput2.append(bg2);
			 Object output2 = avgIntermediate.exec(intermediateInput2);
			 DataBag bag = Util.createBag(new Tuple[]{
			(Tuple)output1, (Tuple)output2}
			);
			 Tuple finalTuple = TupleFactory.getInstance().newTuple(1);
			 finalTuple.set(0, bag);
			 Object output = avg.exec(finalTuple);
			 String msg = ""[Testing "" + avgTypes[k] + "" on input type: "" + getInputType(avgTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(avgTypes[k]) + "" (expected) )]"";
			 if (getInputType(avgTypes[k]) == ""BigDecimal"" || getInputType(avgTypes[k]) == ""BigInteger"") {
				 assertEquals(msg, ((BigDecimal)getExpected(avgTypes[k])).toPlainString(), ((BigDecimal)output).toPlainString());
			 }
			 else {
				 assertEquals(msg, (Double)getExpected(avgTypes[k]), (Double)output, 0.00001);
			 }
		 }
	 }
	 public void testCOUNT() throws Exception {
		 Integer input[] = {
		 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, null }
		;
		 long expected = input.length - 1;
		 EvalFunc<Long> count = new COUNT();
		 Tuple tup = Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), input);
		 Long output = count.exec(tup);
		 assertTrue(output == expected);
	 }
	 public void testCOUNTIntermed() throws Exception {
		 Integer input[] = {
		 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
		;
		 DataBag intermediateInputBag = bagFactory.newDefaultBag();
		 for (Integer i : input) {
			 Tuple t = tupleFactory.newTuple(i);
			 DataBag b = bagFactory.newDefaultBag();
			 b.add(t);
			 Tuple initialInput = tupleFactory.newTuple(b);
			 EvalFunc<?> initial = new COUNT.Initial();
			 intermediateInputBag.add((Tuple)initial.exec(initialInput));
		 }
		 EvalFunc<Tuple> countIntermed = new COUNT.Intermediate();
		 Tuple intermediateInput = tupleFactory.newTuple(intermediateInputBag);
		 Tuple output = countIntermed.exec(intermediateInput);
		 Long f1 = DataType.toLong(output.get(0));
		 assertEquals(""Expected count to be 10"", 10, f1.longValue());
	 }
	 public void testCOUNTFinal() throws Exception {
		 long input[] = {
		 23, 38, 39 }
		;
		 Tuple tup = Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), input);
		 EvalFunc<Long> count = new COUNT.Final();
		 Long output = count.exec(tup);
		 assertEquals(""Expected count to be 100"", 100, output.longValue());
	 }
	 public void testCOUNTBagNullCheck() throws Exception{
		 DataBag b = null;
		 Tuple t = TupleFactory.getInstance().newTuple(b);
		 EvalFunc<Long> count = new COUNT();
		 assertNull(count.exec(t));
	 }
	 public void testCount_ValidNumberOfArguments_WithoutInputSchema_One() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""';
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1.$0);
			"");
			 assertValidCount();
		 }
		 catch (TypeCheckerException e) {
			 Assert.fail(""Query is in accordance with schema, still it failed to execute"");
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 public void testCount_ValidNumberOfArguments_WithoutInputSchema_Two() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""';
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1);
			"");
			 assertValidCount();
		 }
		 catch (TypeCheckerException e) {
			 Assert.fail(""Query is in accordance with schema, still it failed to execute"");
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 public void testCount_ValidNumberOfArguments_WithNullTuplesInInput_CaseOne() throws Exception {
		 String inputFileName = ""CountTest.txt"";
		 String[] inputData = new String[] {
		 ""1 2 3 4\n"", ""\n"", ""a b c d\n"", ""\n"", ""r s t u""}
		;
		 File inputFile = Util.createInputFile(""tmp"", inputFileName, inputData);
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""';
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1);
			"");
			 assertValidCount();
		 }
		 catch (TypeCheckerException e) {
			 Assert.fail(""Query is in accordance with schema, still it failed to execute"");
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 public void testCount_ValidNumberOfArguments_WithNullTuplesInInput_CaseTwo() throws Exception {
		 String[] inputData = new String[] {
		 ""1 2 3 4\n"", ""\n"", ""a b c d\n"", ""\n"", ""r s t u""}
		;
		 File file = Util.createInputFile(""tmp"", ""CountTest.txt"", inputData);
		 String inputFileName = file.getAbsolutePath();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFileName) + ""';
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1.$0);
			"");
			 assertValidCount();
		 }
		 catch (TypeCheckerException e) {
			 Assert.fail(""Query is in accordance with schema, still it failed to execute"");
		 }
		 finally {
			 file.delete();
		 }
	 }
	 public void testCount_ValidNumberOfArguments_WithInputSchema_One() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' as (data:chararray);
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1.$0);
			"");
			 assertValidCount();
		 }
		 catch (TypeCheckerException e) {
			 Assert.fail(""Query is in accordance with schema, still it failed to execute"");
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 public void testCount_ValidNumberOfArguments_WithInputSchema_Two() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' as (data:chararray);
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1);
			"");
			 assertValidCount();
		 }
		 catch (TypeCheckerException e) {
			 Assert.fail(""Query is in accordance with schema, still it failed to execute"");
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 private void assertValidCount() throws IOException, ExecException {
		 Iterator<Tuple> it = pigServer.openIterator(""C"");
		 int i=0;
		 final int expectedOutputTupleSize = 1;
		 final long expectedCount = 3;
		 while (it.hasNext()) {
			 Tuple t = it.next();
			 assertEquals(""Testing SIZE(<Tuple>): "", expectedOutputTupleSize, t.size());
			 assertEquals(""Testing Value within<Tuple>: "", expectedCount, t.get(0));
			 i++;
		 }
		 assertEquals(""Testing the above loop ran only once."",1,i);
	 }
	 public void testCount_InvalidNumberOfArguments_WithoutInputSchema() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""';
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1.$0, $1.$0);
			"");
			 pigServer.openIterator(""C"");
			 Assert.fail(""COUNT is suppose to run with one argument of type BAG, however it ran with couple of arguments."");
		 }
		 catch (FrontendException e) {
			 Assert.assertTrue( e.getCause() instanceof TypeCheckerException );
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 public void testCount_InvalidNumberOfArguments_WithInputSchema() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' as (data:chararray);
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT($1.$0, $1.$0);
			"");
			 pigServer.openIterator(""C"");
			 Assert.fail(""COUNT is suppose to run with one argument of type BAG, however it ran with couple of arguments."");
		 }
		 catch (FrontendException e) {
			 Assert.assertTrue( e.getCause() instanceof TypeCheckerException );
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 public void testCount_InvalidArgumentType() throws Exception {
		 File inputFile = createCountInputFile();
		 try {
			 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' as (data:chararray);
			"");
			 pigServer.registerQuery(""=> group @ all;
			"");
			 pigServer.registerQuery(""C = foreach @ generate COUNT('data');
			"");
			 pigServer.openIterator(""C"");
			 Assert.fail(""COUNT is suppose to run with one argument of type BAG, however it ran with an argument of type chararray."");
		 }
		 catch (FrontendException e) {
			 Assert.assertTrue( e.getCause() instanceof TypeCheckerException );
		 }
		 finally {
			 inputFile.delete();
		 }
	 }
	 protected File createCountInputFile() throws IOException {
		 String inputFileName = ""CountTest.txt"";
		 String[] inputData = new String[] {
		 ""1 2 3 4\n"", ""a b c d\n"", ""r s t u""}
		;
		 return Util.createInputFile(""tmp"", inputFileName, inputData);
	 }
	 public void testCOUNT_STAR() throws Exception {
		 Integer input[] = {
		 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, null }
		;
		 long expected = input.length;
		 EvalFunc<Long> count = new COUNT_STAR();
		 Tuple tup = Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), input);
		 Long output = count.exec(tup);
		 assertTrue(output == expected);
	 }
	 public void testCOUNT_STARIntermed() throws Exception {
		 Integer input[] = {
		 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
		;
		 DataBag intermediateInputBag = bagFactory.newDefaultBag();
		 for (Integer i : input) {
			 Tuple t = tupleFactory.newTuple(i);
			 DataBag b = bagFactory.newDefaultBag();
			 b.add(t);
			 Tuple initialInput = tupleFactory.newTuple(b);
			 EvalFunc<?> initial = new COUNT_STAR.Initial();
			 intermediateInputBag.add((Tuple)initial.exec(initialInput));
		 }
		 EvalFunc<Tuple> countIntermed = new COUNT_STAR.Intermediate();
		 Tuple intermediateInput = tupleFactory.newTuple(intermediateInputBag);
		 Tuple output = countIntermed.exec(intermediateInput);
		 Long f1 = DataType.toLong(output.get(0));
		 assertEquals(""Expected count to be 10"", 10, f1.longValue());
	 }
	 public void testCOUNT_STARFinal() throws Exception {
		 long input[] = {
		 23, 38, 39 }
		;
		 Tuple tup = Util.loadNestTuple(TupleFactory.getInstance().newTuple(1), input);
		 EvalFunc<Long> count = new COUNT_STAR.Final();
		 Long output = count.exec(tup);
		 assertEquals(""Expected count to be 100"", 100, output.longValue());
	 }
	 public void testSUM() throws Exception {
		 String[] sumTypes = {
		""SUM"", ""DoubleSum"", ""LongSum"", ""IntSum"", ""FloatSum"", ""BigDecimalSum"", ""BigIntegerSum""}
		;
		 for (int k = 0;
		 k < sumTypes.length;
		 k++) {
			 EvalFunc<?> sum = evalFuncMap.get(sumTypes[k]);
			 String inputType = getInputType(sumTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = sum.exec(tup);
			 String msg = ""[Testing "" + sumTypes[k] + "" on input type: "" + getInputType(sumTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(sumTypes[k]) + "" (expected) )]"";
			 if (inputType == ""Integer"" || inputType == ""Long"") {
				 assertEquals(msg, (Long)output, (Long)getExpected(sumTypes[k]), 0.00001);
			 }
			 else if (inputType == ""BigDecimal"") assertEquals(msg, ((BigDecimal) output).toPlainString(), ((BigDecimal)getExpected(sumTypes[k])).toPlainString());
			 else if (inputType == ""BigInteger"") assertEquals(msg, ((BigInteger) output).toString(), ((BigInteger)getExpected(sumTypes[k])).toString());
			 else {
				 assertEquals(msg, (Double)output, (Double)getExpected(sumTypes[k]), 0.00001);
			 }
			 assertNull(sum.exec(NULL_INPUT_TUPLE));
		 }
	 }
	 public void testSUMIntermed() throws Exception {
		 String[] sumTypes = {
		""SUMIntermediate"", ""DoubleSumIntermediate"", ""LongSumIntermediate"", ""IntSumIntermediate"", ""FloatSumIntermediate"", ""BigDecimalSumIntermediate"", ""BigIntegerSumIntermediate""}
		;
		 for (int k = 0;
		 k < sumTypes.length;
		 k++) {
			 EvalFunc<?> sum = evalFuncMap.get(sumTypes[k]);
			 String inputType = getInputType(sumTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = sum.exec(tup);
			 String msg = ""[Testing "" + sumTypes[k] + "" on input type: "" + getInputType(sumTypes[k]) + "" ( (output) "" + ((Tuple)output).get(0) + "" == "" + getExpected(sumTypes[k]) + "" (expected) )]"";
			 if (inputType.equals(""Integer"") || inputType.equals(""Long"") || inputType.equals(""IntegerAsLong"")) {
				 assertEquals(msg, (Long) ((Tuple)output).get(0), (Long)getExpected(sumTypes[k]), 0.00001);
			 }
			 else if (inputType == ""BigDecimal"") {
				 assertEquals(msg, ((BigDecimal) ((Tuple)output).get(0)).toPlainString(), ((BigDecimal)getExpected(sumTypes[k])).toPlainString());
			 }
			 else if (inputType == ""BigInteger"") {
				 assertEquals(msg, ((BigInteger) ((Tuple)output).get(0)).toString(), ((BigInteger)getExpected(sumTypes[k])).toString());
			 }
			 else {
				 assertEquals(msg, (Double) ((Tuple)output).get(0), (Double)getExpected(sumTypes[k]), 0.00001);
			 }
		 }
	 }
	 public void testSUMFinal() throws Exception {
		 String[] sumTypes = {
		""SUMFinal"", ""DoubleSumFinal"", ""LongSumFinal"", ""IntSumFinal"", ""FloatSumFinal"", ""BigDecimalSumFinal"", ""BigIntegerSumFinal""}
		;
		 for (int k = 0;
		 k < sumTypes.length;
		 k++) {
			 EvalFunc<?> sum = evalFuncMap.get(sumTypes[k]);
			 String inputType = getInputType(sumTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = sum.exec(tup);
			 String msg = ""[Testing "" + sumTypes[k] + "" on input type: "" + getInputType(sumTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(sumTypes[k]) + "" (expected) )]"";
			 if (inputType.equals(""Integer"") || inputType.equals(""Long"") || inputType.equals(""IntegerAsLong"")) {
				 assertEquals(msg, (Long)output, (Long)getExpected(sumTypes[k]), 0.00001);
			 }
			 else if (inputType == ""BigDecimal"") assertEquals(msg, ((BigDecimal) output).toPlainString(), ((BigDecimal)getExpected(sumTypes[k])).toPlainString());
			 else if (inputType == ""BigInteger"") assertEquals(msg, ((BigInteger) output).toString(), ((BigInteger)getExpected(sumTypes[k])).toString());
			 else {
				 assertEquals(msg, (Double)output, (Double)getExpected(sumTypes[k]), 0.00001);
			 }
		 }
	 }
	 public void testMIN() throws Exception {
		 String[] minTypes = {
		""MIN"", ""LongMin"", ""IntMin"", ""FloatMin"",""BigDecimalMin"",""BigIntegerMin"", ""StringMin"", ""DateTimeMin""}
		;
		 for (int k = 0;
		 k < minTypes.length;
		 k++) {
			 EvalFunc<?> min = evalFuncMap.get(minTypes[k]);
			 String inputType = getInputType(minTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = min.exec(tup);
			 String msg = ""[Testing "" + minTypes[k] + "" on input type: "" + getInputType(minTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(minTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(minTypes[k]), output);
			 assertNull(min.exec(NULL_INPUT_TUPLE));
		 }
	 }
	 public void testMINIntermediate() throws Exception {
		 String[] minTypes = {
		""MINIntermediate"", ""LongMinIntermediate"", ""IntMinIntermediate"", ""FloatMinIntermediate"", ""BigDecimalMinIntermediate"", ""BigIntegerMinIntermediate"", ""StringMinIntermediate"", ""DateTimeMinIntermediate""}
		;
		 for (int k = 0;
		 k < minTypes.length;
		 k++) {
			 EvalFunc<?> min = evalFuncMap.get(minTypes[k]);
			 String inputType = getInputType(minTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = min.exec(tup);
			 String msg = ""[Testing "" + minTypes[k] + "" on input type: "" + getInputType(minTypes[k]) + "" ( (output) "" + ((Tuple)output).get(0) + "" == "" + getExpected(minTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(minTypes[k]), ((Tuple)output).get(0));
		 }
	 }
	 public void testMINFinal() throws Exception {
		 String[] minTypes = {
		""MINFinal"", ""LongMinFinal"", ""IntMinFinal"", ""FloatMinFinal"", ""BigDecimalMinFinal"", ""BigIntegerMinFinal"", ""StringMinFinal"", ""DateTimeMinFinal""}
		;
		 for (int k = 0;
		 k < minTypes.length;
		 k++) {
			 EvalFunc<?> min = evalFuncMap.get(minTypes[k]);
			 String inputType = getInputType(minTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = min.exec(tup);
			 String msg = ""[Testing "" + minTypes[k] + "" on input type: "" + getInputType(minTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(minTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(minTypes[k]), output);
		 }
	 }
	 public void testMINAccumulate() throws Exception {
		 String[] minTypes = {
		""MIN"", ""LongMin"", ""IntMin"", ""FloatMin"",""BigDecimalMin"",""BigIntegerMin"", ""StringMin"", ""DateTimeMin""}
		;
		 for (int k = 0;
		 k < minTypes.length;
		 k++) {
			 Accumulator<?> min = (Accumulator<?>)evalFuncMap.get(minTypes[k]);
			 String inputType = getInputType(minTypes[k]);
			 Tuple[] tuples = inputMapForAccumulate.get(inputType);
			 for (Tuple tup : tuples) min.accumulate(tup);
			 Object output = min.getValue();
			 String msg = ""[Testing "" + minTypes[k] + "" accumulate on input type: "" + getInputType(minTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(minTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(minTypes[k]), output);
		 }
	 }
	 public void testMAX() throws Exception {
		 String[] maxTypes = {
		""MAX"", ""LongMax"", ""IntMax"", ""FloatMax"", ""BigDecimalMax"", ""BigIntegerMax"", ""StringMax"", ""DateTimeMax""}
		;
		 for (int k = 0;
		 k < maxTypes.length;
		 k++) {
			 EvalFunc<?> max = evalFuncMap.get(maxTypes[k]);
			 String inputType = getInputType(maxTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = max.exec(tup);
			 String msg = ""[Testing "" + maxTypes[k] + "" on input type: "" + getInputType(maxTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(maxTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(maxTypes[k]), output);
			 assertNull(max.exec(NULL_INPUT_TUPLE));
		 }
	 }
	 public void testMAXIntermed() throws Exception {
		 String[] maxTypes = {
		""MAXIntermediate"", ""LongMaxIntermediate"", ""IntMaxIntermediate"", ""FloatMaxIntermediate"", ""BigDecimalMaxIntermediate"", ""BigIntegerMaxIntermediate"", ""StringMaxIntermediate"", ""DateTimeMaxIntermediate""}
		;
		 for (int k = 0;
		 k < maxTypes.length;
		 k++) {
			 EvalFunc<?> max = evalFuncMap.get(maxTypes[k]);
			 String inputType = getInputType(maxTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = max.exec(tup);
			 String msg = ""[Testing "" + maxTypes[k] + "" on input type: "" + getInputType(maxTypes[k]) + "" ( (output) "" + ((Tuple)output).get(0) + "" == "" + getExpected(maxTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(maxTypes[k]), ((Tuple)output).get(0));
		 }
	 }
	 public void testMAXFinal() throws Exception {
		 String[] maxTypes = {
		""MAXFinal"", ""LongMaxFinal"", ""IntMaxFinal"", ""FloatMaxFinal"", ""BigDecimalMaxFinal"", ""BigIntegerMaxFinal"", ""StringMaxFinal"", ""DateTimeMaxFinal""}
		;
		 for (int k = 0;
		 k < maxTypes.length;
		 k++) {
			 EvalFunc<?> max = evalFuncMap.get(maxTypes[k]);
			 String inputType = getInputType(maxTypes[k]);
			 Tuple tup = inputMap.get(inputType);
			 Object output = max.exec(tup);
			 String msg = ""[Testing "" + maxTypes[k] + "" on input type: "" + getInputType(maxTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(maxTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(maxTypes[k]), output);
		 }
	 }
	 public void testMAXAccumulate() throws Exception {
		 String[] maxTypes = {
		""MAX"", ""LongMax"", ""IntMax"", ""FloatMax"", ""BigDecimalMax"", ""BigIntegerMax"", ""StringMax"", ""DateTimeMax""}
		;
		 for (int k = 0;
		 k < maxTypes.length;
		 k++) {
			 Accumulator<?> max = (Accumulator<?>)evalFuncMap.get(maxTypes[k]);
			 String inputType = getInputType(maxTypes[k]);
			 Tuple[] tuples = inputMapForAccumulate.get(inputType);
			 for (Tuple tup : tuples) max.accumulate(tup);
			 Object output = max.getValue();
			 String msg = ""[Testing "" + maxTypes[k] + "" accumulate on input type: "" + getInputType(maxTypes[k]) + "" ( (output) "" + output + "" == "" + getExpected(maxTypes[k]) + "" (expected) )]"";
			 assertForInputType(inputType, msg, getExpected(maxTypes[k]), output);
		 }
	 }
	 public void testMathFuncs() throws Exception {
		 Random generator = new Random();
		 generator.setSeed(System.currentTimeMillis());
		 Double delta = 0.1;
		 String[] mathFuncs = {
		 ""SIN"", ""SINH"", ""ASIN"", ""COS"", ""COSH"", ""ACOS"", ""TAN"", ""TANH"", ""ATAN"", ""LOG"", ""LOG10"", ""SQRT"", ""CEIL"", ""EXP"", ""FLOOR"", ""CBRT"" }
		;
		 String udfPackage = ""org.apache.pig.builtin."";
		 EvalFunc<Double> evalFunc;
		 Tuple tup;
		 Double input, actual, expected;
		 Method mathMethod;
		 String msg;
		 for (String func: mathFuncs) {
			 evalFunc = (EvalFunc<Double>) Class.forName(udfPackage + func).newInstance();
			 tup = TupleFactory.getInstance().newTuple(1);
			 input = generator.nextDouble();
			 tup.set(0, input);
			 mathMethod = Math.class.getDeclaredMethod(func.toLowerCase(), double.class);
			 actual = evalFunc.exec(tup);
			 expected = (Double)mathMethod.invoke(null, input);
			 msg = ""[Testing "" + func + "" on input: "" + input + "" ( (actual) "" + actual + "" == "" + expected + "" (expected) )]"";
			 assertEquals(msg, actual, expected, delta);
		 }
	 }
	 public void testROUND() throws Exception {
		 Double dbl = 0.987654321d;
		 Float flt = 0.987654321f;
		 EvalFunc<Long> rounder = new ROUND();
		 Tuple tup = TupleFactory.getInstance().newTuple(1);
		 long expected, lng_out;
		 tup.set(0, dbl);
		 expected = Math.round(dbl);
		 lng_out = rounder.exec(tup);
		 assertEquals(expected, lng_out);
		 tup.set(0, flt);
		 expected = Math.round(flt);
		 lng_out = rounder.exec(tup);
		 assertEquals(expected, lng_out);
		 tup.set(0, 4.6d);
		 assertEquals( 5l, lng_out = rounder.exec(tup));
		 tup.set(0, 2.4d);
		 assertEquals( 2l, lng_out = rounder.exec(tup));
		 tup.set(0, 1.0d);
		 assertEquals( 1l, lng_out = rounder.exec(tup));
		 tup.set(0, -1.0d);
		 assertEquals(-1l, lng_out = rounder.exec(tup));
		 tup.set(0, -2.4d);
		 assertEquals(-2l, lng_out = rounder.exec(tup));
		 tup.set(0, -4.6d);
		 assertEquals(-5l, lng_out = rounder.exec(tup));
		 tup.set(0, 3.5d);
		 assertEquals( 4l, lng_out = rounder.exec(tup));
		 tup.set(0, -3.5d);
		 assertEquals(-3l, lng_out = rounder.exec(tup));
		 tup.set(0, 2.5d);
		 assertEquals( 3l, lng_out = rounder.exec(tup));
		 tup.set(0, -2.5d);
		 assertEquals(-2l, lng_out = rounder.exec(tup));
	 }
	 public void testROUND_TO() throws Exception {
		 Double dbl_out;
		 EvalFunc<Double> rounder = new ROUND_TO();
		 Tuple tup;
		 String expected;
		 tup = TupleFactory.getInstance().newTuple(2);
		 tup.set(0,1234.1789d);
		 tup.set(1, 8);
		 expected = ""1234.1789"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1, 4);
		 expected = ""1234.1789"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1, 2);
		 expected = ""1234.18"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1, 1);
		 expected = ""1234.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1, 0);
		 expected = ""1234.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1,-1);
		 expected = ""1230.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1,-3);
		 expected = ""1000.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1,-4);
		 expected = ""0.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0,1234.1789d);
		 tup.set(1,-5);
		 expected = ""0.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.25000001d);
		 tup.set(1, 1);
		 expected = ""3.3"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.25d);
		 tup.set(1, 1);
		 expected = ""3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.25d);
		 tup.set(1, 1);
		 expected = ""-3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.15d);
		 tup.set(1, 1);
		 expected = ""3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.15d);
		 tup.set(1, 1);
		 expected = ""-3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.5d);
		 tup.set(1, 0);
		 expected = ""4.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.5d);
		 tup.set(1, 0);
		 expected = ""-4.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 2.5d);
		 tup.set(1, 0);
		 expected = ""2.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -2.5d);
		 tup.set(1, 0);
		 expected = ""-2.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup = TupleFactory.getInstance().newTuple(3);
		 tup.set(2, 6);
		 tup.set(0, 3.25d);
		 tup.set(1, 1);
		 expected = ""3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.25d);
		 tup.set(1, 1);
		 expected = ""-3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.15d);
		 tup.set(1, 1);
		 expected = ""3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.15d);
		 tup.set(1, 1);
		 expected = ""-3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.5d);
		 tup.set(1, 0);
		 expected = ""4.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.5d);
		 tup.set(1, 0);
		 expected = ""-4.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 2.5d);
		 tup.set(1, 0);
		 expected = ""2.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -2.5d);
		 tup.set(1, 0);
		 expected = ""-2.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup = TupleFactory.getInstance().newTuple(3);
		 tup.set(2, 4);
		 tup.set(0, 3.25000001d);
		 tup.set(1, 1);
		 expected = ""3.3"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.25d);
		 tup.set(1, 1);
		 expected = ""3.3"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.25d);
		 tup.set(1, 1);
		 expected = ""-3.3"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.15d);
		 tup.set(1, 1);
		 expected = ""3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.15d);
		 tup.set(1, 1);
		 expected = ""-3.2"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 3.5d);
		 tup.set(1, 0);
		 expected = ""4.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -3.5d);
		 tup.set(1, 0);
		 expected = ""-4.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, 2.5d);
		 tup.set(1, 0);
		 expected = ""3.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
		 tup.set(0, -2.5d);
		 tup.set(1, 0);
		 expected = ""-3.0"";
		 dbl_out = rounder.exec(tup);
		 assertEquals(expected, dbl_out.toString());
	 }
	 public void testStringFuncs() throws Exception {
		 String inputStr = ""Hello World!"";
		 String inputStrLower = ""hello world!"";
		 String inputStrUpper = ""HELLO WORLD!"";
		 String inputStrCamel = ""hello World!"";
		 String inputStroWitha = ""Hella Warld!"";
		 String inputStrSpaceRight = ""Hello World! "";
		 String inputStrSpaceLeft = "" Hello World!"";
		 String inputStrSpaceBoth = "" Hello World! "";
		 List<Object> l = new LinkedList<Object>();
		 l.add(inputStr);
		 l.add(""o"");
		 String expected = null;
		 Tuple input;
		 String output;
		 Integer intOutput;
		 EvalFunc<String> strFunc;
		 EvalFunc<Integer> intFunc;
		 strFunc = new LCFIRST();
		 input = TupleFactory.getInstance().newTuple(inputStr);
		 expected = inputStrCamel;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new UCFIRST();
		 input = TupleFactory.getInstance().newTuple(inputStrCamel);
		 expected = inputStr;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 intFunc = new LAST_INDEX_OF();
		 input = TupleFactory.getInstance().newTuple(l);
		 intOutput = intFunc.exec(input);
		 assertTrue(intOutput.intValue()==7);
		 intFunc = new INDEXOF();
		 input = TupleFactory.getInstance().newTuple(l);
		 intOutput = intFunc.exec(input);
		 assertTrue(intOutput.intValue()==4);
		 strFunc = new UPPER();
		 input = TupleFactory.getInstance().newTuple(inputStr);
		 expected = inputStrUpper;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new LOWER();
		 input = TupleFactory.getInstance().newTuple(inputStr);
		 expected = inputStrLower;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new REPLACE();
		 l.clear();
		 l.add(inputStr);
		 l.add(""o"");
		 l.add(""a"");
		 input = TupleFactory.getInstance().newTuple(l);
		 expected = inputStroWitha;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new SUBSTRING();
		 l.clear();
		 l.add(inputStr);
		 l.add(1);
		 l.add(5);
		 input = TupleFactory.getInstance().newTuple(l);
		 expected = ""ello"";
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new TRIM();
		 input = TupleFactory.getInstance().newTuple(inputStrSpaceBoth);
		 expected = inputStr;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new LTRIM();
		 input = TupleFactory.getInstance().newTuple(inputStrSpaceLeft);
		 expected = inputStr;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 strFunc = new RTRIM();
		 input = TupleFactory.getInstance().newTuple(inputStrSpaceRight);
		 expected = inputStr;
		 output = strFunc.exec(input);
		 assertTrue(output.equals(expected));
		 STRSPLIT splitter = new STRSPLIT();
		 Tuple test1 = TupleFactory.getInstance().newTuple(1);
		 Tuple test2 = TupleFactory.getInstance().newTuple(2);
		 Tuple test3 = TupleFactory.getInstance().newTuple(3);
		 test2.set(0, ""foo"");
		 test2.set(1, "":"");
		 Tuple splits = splitter.exec(test2);
		 assertEquals(""no matches should return tuple with original string"", 1, splits.size());
		 assertEquals(""no matches should return tuple with original string"", ""foo"", splits.get(0));
		 test1.set(0, ""f ooo bar"");
		 splits = splitter.exec(test1);
		 assertEquals(""split on default value "", 3, splits.size());
		 assertEquals(""f"", splits.get(0));
		 assertEquals(""ooo"", splits.get(1));
		 assertEquals(""bar"", splits.get(2));
		 test1.set(0, ""foo bar "");
		 splits = splitter.exec(test1);
		 assertEquals(""whitespace trimmed if no length arg"", 2, splits.size());
		 test3.set(0, ""foo bar "");
		 test3.set(1, ""\\s"");
		 test3.set(2, 10);
		 splits = splitter.exec(test3);
		 assertEquals(""length forces empty string matches on end"", 5, splits.size());
		 test3.set(0, ""foo:bar:baz"");
		 test3.set(1, "":"");
		 test3.set(2, 2);
		 splits = splitter.exec(test3);
		 assertEquals(2, splits.size());
		 assertEquals(""foo"", splits.get(0));
		 assertEquals(""bar:baz"", splits.get(1));
		 Tuple t1 = TupleFactory.getInstance().newTuple(3);
		 t1.set(0, ""/search/iy/term1/test"");
		 t1.set(1, ""^\\/search\\/iy\\/(.*?)\\/.*"");
		 t1.set(2, 1);
		 Tuple t2 = TupleFactory.getInstance().newTuple(3);
		 t2.set(0, ""/search/iy/term1/test"");
		 t2.set(1, ""^\\/search\\/iy\\/(.*?)\\/.*"");
		 t2.set(2, 2);
		 Tuple t3 = TupleFactory.getInstance().newTuple(3);
		 t3.set(0, null);
		 t3.set(1, ""^\\/search\\/iy\\/(.*?)\\/.*"");
		 t3.set(2, 2);
		 Tuple t4 = tupleFactory.newTuple(3);
		 t4.set(0,""this is a match"");
		 t4.set(1, ""this is a (.+?)"");
		 t4.set(2, 1);
		 REGEX_EXTRACT func = new REGEX_EXTRACT();
		 String r = func.exec(t1);
		 assertTrue(r.equals(""term1""));
		 r = func.exec(t2);
		 assertTrue(r==null);
		 r = func.exec(t3);
		 assertTrue(r==null);
		 r = func.exec(t4);
		 assertEquals(""m"", r);
		 func = new REGEX_EXTRACT(""true"");
		 r = func.exec(t4);
		 assertEquals(""match"", r);
		 String matchRegex = ""^(.+)\\b\\s+is a\\s+\\b(.+)$"";
		 TupleFactory tupleFactory = TupleFactory.getInstance();
		 Tuple te1 = tupleFactory.newTuple(2);
		 te1.set(0,""this is a match"");
		 te1.set(1, matchRegex);
		 Tuple te2 = tupleFactory.newTuple(2);
		 te2.set(0, ""no match"");
		 te2.set(1, matchRegex);
		 Tuple te3 = tupleFactory.newTuple(2);
		 te3.set(0, null);
		 te3.set(1, matchRegex);
		 REGEX_EXTRACT_ALL funce = new REGEX_EXTRACT_ALL();
		 Tuple re = funce.exec(te1);
		 assertEquals(re.size(), 2);
		 assertEquals(""this"", re.get(0));
		 assertEquals(""match"", re.get(1));
		 re = funce.exec(te2);
		 assertTrue(re==null);
		 re = funce.exec(te3);
		 assertTrue(re==null);
		 matchRegex = ""(.+?)(.+?)"";
		 tupleFactory = TupleFactory.getInstance();
		 te1 = tupleFactory.newTuple(2);
		 te1.set(0,""this is a match"");
		 te1.set(1, matchRegex);
		 funce = new REGEX_EXTRACT_ALL();
		 re = funce.exec(te1);
		 assertEquals(re.size(), 2);
		 assertEquals(""t"", re.get(0));
		 assertEquals(""his is a match"", re.get(1));
		 funce = new REGEX_EXTRACT_ALL(""false"");
		 re = funce.exec(te1);
		 assertEquals(re.size(), 2);
		 assertEquals(""t"", re.get(0));
		 assertEquals(""h"", re.get(1));
		 re = funce.exec(te2);
		 assertTrue(re==null);
		 re = funce.exec(te3);
		 assertTrue(re==null);
		 String matchSearch = ""(=\\d+\\s)"";
		 tupleFactory = TupleFactory.getInstance();
		 Tuple ts1 = tupleFactory.newTuple(2);
		 ts1.set(0, ""a=04 b=06 c=96 or more"");
		 ts1.set(1, matchSearch);
		 Tuple ts2 = tupleFactory.newTuple(2);
		 ts2.set(0, ""a is 04 b is 06"");
		 ts2.set(1, matchSearch);
		 Tuple ts3 = tupleFactory.newTuple(2);
		 ts3.set(0, null);
		 ts3.set(1, matchSearch);
		 REGEX_SEARCH funcs = new REGEX_SEARCH();
		 DataBag reb = funcs.exec(ts1);
		 DataBag b = Util.createBag(new Tuple[]{
		Util.buildTuple(""=04 ""), Util.buildTuple(""=06 ""), Util.buildTuple(""=96 "")}
		);
		 assertEquals(b, reb);
		 reb = funcs.exec(ts2);
		 assertTrue(reb==null);
		 reb = funcs.exec(ts3);
		 assertTrue(reb==null);
	 }
	 public void testStatsFunc() throws Exception {
		 COV cov = new COV(""a"",""b"");
		 DataBag dBag = DefaultBagFactory.getInstance().newDefaultBag();
		 Tuple tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 1.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 4.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 8.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 4.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 7.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 8.0);
		 dBag.add(tup1);
		 DataBag dBag1 = DefaultBagFactory.getInstance().newDefaultBag();
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 2.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 2.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 3.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 3.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 2.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 4.0);
		 dBag1.add(tup1);
		 Tuple input = TupleFactory.getInstance().newTuple(2);
		 input.set(0, dBag);
		 input.set(1, dBag1);
		 DataBag output = cov.exec(input);
		 Iterator<Tuple> it = output.iterator();
		 Tuple ans = it.next();
		 assertEquals(ans.get(0),""a"");
		 assertEquals(ans.get(1),""b"");
		 assertEquals(1.11111, (Double)ans.get(2),0.0005);
		 COR cor = new COR(""a"",""b"");
		 dBag = DefaultBagFactory.getInstance().newDefaultBag();
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 1.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 4.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 8.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 4.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 7.0);
		 dBag.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 8.0);
		 dBag.add(tup1);
		 dBag1 = DefaultBagFactory.getInstance().newDefaultBag();
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 2.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 2.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 3.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 3.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 2.0);
		 dBag1.add(tup1);
		 tup1 = TupleFactory.getInstance().newTuple(1);
		 tup1.set(0, 4.0);
		 dBag1.add(tup1);
		 input = TupleFactory.getInstance().newTuple(2);
		 input.set(0, dBag);
		 input.set(1, dBag1);
		 output = cor.exec(input);
		 it = output.iterator();
		 ans = it.next();
		 assertEquals(ans.get(0),""a"");
		 assertEquals(ans.get(1),""b"");
		 assertEquals(0.582222509739582, (Double)ans.get(2) ,0.0005);
	 }
	 public void testToBag() throws Exception {
		 TOBAG tb = new TOBAG();
		 Schema expectedSch = Schema.generateNestedSchema(DataType.BAG, DataType.INTEGER);
		 Schema inputSch = new Schema();
		 inputSch.add(new FieldSchema(null, DataType.INTEGER));
		 assertEquals(""schema of tobag when input has only ints"", expectedSch, tb.outputSchema(inputSch));
		 inputSch.add(new FieldSchema(null, DataType.INTEGER));
		 assertEquals(""schema of tobag when input has only ints"", expectedSch, tb.outputSchema(inputSch));
		 inputSch.add(new FieldSchema(null, DataType.LONG));
		 expectedSch = Schema.generateNestedSchema(DataType.BAG, DataType.NULL);
		 assertEquals(""schema of tobag when input has ints and long"", expectedSch, tb.outputSchema(inputSch));
		 Schema tupInSchema = new Schema(new FieldSchema(""x"", DataType.CHARARRAY));
		 inputSch = new Schema();
		 inputSch.add(new FieldSchema(""a"", tupInSchema, DataType.TUPLE));
		 Schema inputSchCp = new Schema(inputSch);
		 inputSchCp.getField(0).alias = null;
		 expectedSch = new Schema(new FieldSchema(null, inputSchCp, DataType.BAG));
		 assertEquals(""schema of tobag when input has cols of type tuple "", expectedSch, tb.outputSchema(inputSch));
		 inputSch.add(new FieldSchema(""b"", tupInSchema, DataType.TUPLE));
		 assertEquals(""schema of tobag when input has cols of type tuple "", expectedSch, tb.outputSchema(inputSch));
		 tupInSchema = new Schema(new FieldSchema(""x"", DataType.BYTEARRAY));
		 inputSch.add(new FieldSchema(""c"", tupInSchema, DataType.TUPLE));
		 expectedSch = Schema.generateNestedSchema(DataType.BAG, DataType.NULL);
		 assertEquals(""schema of tobag when input has cols of type tuple with diff inner schema"", expectedSch, tb.outputSchema(inputSch));
		 Tuple input = TupleFactory.getInstance().newTuple();
		 for (int i = 0;
		 i < 100;
		 ++i) {
			 input.append(i);
		 }
		 input.append(null);
		 Set<Integer> s = new HashSet<Integer>();
		 DataBag db = tb.exec(input);
		 for (Tuple t : db) {
			 s.add((Integer) t.get(0));
		 }
		 assertEquals(101, s.size());
		 for (int i = 0;
		 i < 100;
		 ++i) {
			 assertTrue(s.contains(i));
		 }
		 assertTrue(""null in tobag result"", s.contains(null));
	 }
	 public void testTOBAGSupportsTuplesInInput() throws IOException {
		 String[][] expected = {
			 {
			 ""a"", ""b"" }
			, {
			 ""c"", ""d"" }
		 }
		;
		 TOBAG function = new TOBAG();
		 Tuple input = TupleFactory.getInstance().newTuple();
		 Tuple firstItem = TupleFactory.getInstance().newTuple();
		 firstItem.append(expected[0][0]);
		 firstItem.append(expected[0][1]);
		 Tuple secondItem = TupleFactory.getInstance().newTuple();
		 secondItem.append(expected[1][0]);
		 secondItem.append(expected[1][1]);
		 input.append(firstItem);
		 input.append(secondItem);
		 DataBag result = function.exec(input);
		 assertEquals(""number of tuples in the bag"", 2, result.size());
		 int position = 0;
		 for (Tuple t : result) {
			 assertEquals(""number of items in tuple "" + position, 2, t.size());
			 assertEquals(""first item in tuple "" + position, expected[position][0], t.get(0));
			 assertEquals(""second item in tuple "" + position, expected[position][1], t.get(1));
			 position++;
		 }
	 }
	 public void testMiscFunc() throws Exception {
		 TOTUPLE tt = new TOTUPLE();
		 Tuple input = TupleFactory.getInstance().newTuple();
		 for (int i = 0;
		 i < 100;
		 ++i) {
			 input.append(i);
		 }
		 Tuple output = tt.exec(input);
		 assertEquals(input, output);
		 TOMAP tm = new TOMAP();
		 Tuple t = TupleFactory.getInstance().newTuple(6);
		 t.set(0, ""k1"");
		 t.set(1, 1);
		 t.set(2, ""k2"");
		 t.set(3, 2.0);
		 t.set(4, ""k3"");
		 t.set(5, ""foo"");
		 Map m = tm.exec(t);
		 assertEquals("""", m.get(""k1""), 1);
		 assertEquals("""", m.get(""k2""), 2.0);
		 assertEquals("""", m.get(""k3""), ""foo"");
	 }
	 public void testDistinct() throws Exception {
		 Integer[] inp = new Integer[] {
		 1, 2 , 3, 1 ,4, 5, 3}
		;
		 DataBag inputBag = Util.createBagOfOneColumn(inp);
		 EvalFunc<Tuple> initial = new Distinct.Initial();
		 DataBag intermedInputBg1 = bagFactory.newDefaultBag();
		 DataBag intermedInputBg2 = bagFactory.newDefaultBag();
		 int i = 0;
		 for (Tuple t : inputBag) {
			 Tuple initialOutput = initial.exec(tupleFactory.newTuple(t));
			 if (i < inp.length/2 ) {
				 intermedInputBg1.add(initialOutput);
			 }
			 else {
				 intermedInputBg2.add(initialOutput);
			 }
			 i++;
		 }
		 EvalFunc<Tuple> intermed = new Distinct.Intermediate();
		 DataBag finalInputBg = bagFactory.newDefaultBag();
		 finalInputBg.add(intermed.exec(tupleFactory.newTuple(intermedInputBg1)));
		 finalInputBg.add(intermed.exec(tupleFactory.newTuple(intermedInputBg2)));
		 EvalFunc<DataBag> fin = new Distinct.Final();
		 DataBag result = fin.exec(tupleFactory.newTuple(finalInputBg));
		 Integer[] exp = new Integer[] {
		 1, 2, 3, 4, 5}
		;
		 DataBag expectedBag = Util.createBagOfOneColumn(exp);
		 assertEquals(expectedBag, result);
	 }
	 public void testDistinctIsNullSafe() throws Exception {
		 DataBag empty = bagFactory.newDefaultBag();
		 Tuple tupleOfNull = tupleFactory.newTuple(1);
		 Tuple tupleOfEmpty = tupleFactory.newTuple(empty);
		 assertEquals(empty, new Distinct().exec(tupleOfNull));
		 assertEquals(tupleOfEmpty, new Distinct.Initial().exec(tupleOfNull));
		 assertEquals(tupleOfEmpty, new Distinct.Intermediate().exec(tupleOfNull));
		 assertEquals(empty, new Distinct.Final().exec(tupleOfNull));
	 }
	 public void testDistinctProgressNonAlgebraic() throws Exception {
		 int inputSize = 2002;
		 Integer[] inp = new Integer[inputSize];
		 for (int i = 0;
		 i < inputSize;
		 i+=2) {
			 inp[i] = i/2;
			 inp[i+1] = i/2;
		 }
		 DataBag inputBag = Util.createBagOfOneColumn(inp);
		 EvalFunc<DataBag> distinct = new Distinct();
		 DataBag result = distinct.exec(tupleFactory.newTuple(inputBag));
		 Integer[] exp = new Integer[inputSize/2];
		 for (int j = 0;
		 j < inputSize/2;
		 ++j) {
			 exp[j] = j;
		 }
		 DataBag expectedBag = Util.createBagOfOneColumn(exp);
		 assertEquals(expectedBag, result);
	 }
	 public void testCONCAT() throws Exception {
		 byte[] a = {
		1,2,3}
		;
		 byte[] b = {
		4,5,6}
		;
		 byte[] expected = {
		1,2,3,4,5,6}
		;
		 DataByteArray dbaExpected = new DataByteArray(expected);
		 DataByteArray dbaA = new DataByteArray(a);
		 DataByteArray dbaB = new DataByteArray(b);
		 EvalFunc<DataByteArray> concat = new CONCAT();
		 Tuple t = TupleFactory.getInstance().newTuple(2);
		 t.set(0, dbaA);
		 t.set(1, dbaB);
		 DataByteArray result = concat.exec(t);
		 String msg = ""[Testing CONCAT on input type: bytearray]"";
		 assertTrue(msg, result.equals(dbaExpected));
		 String s1 = ""unit "";
		 String s2 = ""test"";
		 String exp = ""unit test"";
		 EvalFunc<String> sConcat = new StringConcat();
		 Tuple ts = TupleFactory.getInstance().newTuple(2);
		 ts.set(0, s1);
		 ts.set(1, s2);
		 String res = sConcat.exec(ts);
		 msg = ""[Testing StringConcat on input type: String]"";
		 assertTrue(msg, res.equals(exp));
	 }
	 public void testMultiCONCAT() throws Exception {
		 byte[] a = {
		1,2,3}
		;
		 byte[] b = {
		4,5,6}
		;
		 byte[] c = {
		7,8,9}
		;
		 byte[] d = {
		10,11,12}
		;
		 byte[] e = {
		13,14,15}
		;
		 byte[] expected = {
		1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}
		;
		 DataByteArray dbaExpected = new DataByteArray(expected);
		 DataByteArray dbaA = new DataByteArray(a);
		 DataByteArray dbaB = new DataByteArray(b);
		 DataByteArray dbaC = new DataByteArray(c);
		 DataByteArray dbaD = new DataByteArray(d);
		 DataByteArray dbaE = new DataByteArray(e);
		 EvalFunc<DataByteArray> concat = new CONCAT();
		 Tuple t = TupleFactory.getInstance().newTuple(5);
		 t.set(0, dbaA);
		 t.set(1, dbaB);
		 t.set(2, dbaC);
		 t.set(3, dbaD);
		 t.set(4, dbaE);
		 DataByteArray result = concat.exec(t);
		 String msg = ""[Testing CONCAT on >2 tuples for input type: bytearray]"";
		 assertTrue(msg, result.equals(dbaExpected));
		 String s1 = ""high "";
		 String s2 = ""fives "";
		 String s3 = ""kick "";
		 String s4 = ""ass "";
		 String s5 = ""yo"";
		 String exp = ""high fives kick ass yo"";
		 EvalFunc<String> sConcat = new StringConcat();
		 Tuple ts = TupleFactory.getInstance().newTuple(5);
		 ts.set(0, s1);
		 ts.set(1, s2);
		 ts.set(2, s3);
		 ts.set(3, s4);
		 ts.set(4, s5);
		 String res = sConcat.exec(ts);
		 msg = ""[Testing StringConcat on >2 tuples input type: String]"";
		 assertTrue(msg, res.equals(exp));
	 }
	 public void testComplexMultiCONCAT() throws Exception {
		 String input = ""vararg_concat_test_jira_3444.txt"";
		 Util.createLocalInputFile(input, new String[]{
		""dummy""}
		);
		 PigServer pigServer = new PigServer(Util.getLocalTestMode());
		 pigServer.registerQuery(""A = LOAD '""+input+""' as (x:chararray);
		"");
		 pigServer.registerQuery(""B = foreach A generate CONCAT('a', CONCAT('b',CONCAT('c','d')));
		"");
		 Iterator<Tuple> its = pigServer.openIterator(""B"");
		 Tuple t = its.next();
		 assertEquals(""abcd"",t.get(0));
		 pigServer.registerQuery(""B = foreach A generate CONCAT('a', 'b', 'c', 'd');
		"");
		 its = pigServer.openIterator(""B"");
		 t = its.next();
		 assertEquals(""abcd"",t.get(0));
		 pigServer.registerQuery(""B = foreach A generate CONCAT('a', CONCAT('b','c'), 'd');
		"");
		 its = pigServer.openIterator(""B"");
		 t = its.next();
		 assertEquals(""abcd"",t.get(0));
		 pigServer.registerQuery(""B = foreach A generate CONCAT('a', CONCAT('b',Null), 'd');
		"");
		 its = pigServer.openIterator(""B"");
		 t = its.next();
		 assertNull(t.get(0));
	 }
	 public void testSPRINTF() throws Exception {
		 String fmt = ""%2$10s <%1$-6s< %2$,10d >%1$7s> %2$8x %3$10.3f"";
		 String s1 = ""meep"";
		 Integer ii = 665568;
		 Float ff = 993.14159265f;
		 String exp = "" 665568 <meep < 665,568 > meep> a27e0 993.142"";
		 Tuple ts;
		 String res;
		 EvalFunc<String> sprinter = new SPRINTF();
		 ts = TupleFactory.getInstance().newTuple(5);
		 ts.set(0, fmt);
		 ts.set(1, s1);
		 ts.set(2, ii);
		 ts.set(3, ff);
		 ts.set(4, (long)(ii * 1000000L));
		 res = sprinter.exec(ts);
		 assertEquals(exp, res);
		 ts.set(2, 665568l);
		 ts.set(3, 993.14159265d);
		 res = sprinter.exec(ts);
		 assertEquals(exp, res);
		 ts.set(3, null);
		 res = sprinter.exec(ts);
		 assertNull(res);
		 ts.set(3, ff);
		 ts.set(0, null);
		 res = sprinter.exec(ts);
		 assertNull(res);
		 ts = TupleFactory.getInstance().newTuple(1);
		 ts.set(0, ""meep!"");
		 res = sprinter.exec(ts);
		 assertEquals(""meep!"", res);
		 String input = ""vararg_sprintf_test_jira_3939.txt"";
		 Util.createLocalInputFile(input, new String[]{
		""dummy""}
		);
		 PigServer pigServer = new PigServer(Util.getLocalTestMode());
		 pigServer.registerQuery(""A = LOAD '""+input+""' as (x:chararray);
		"");
		 pigServer.registerQuery(""B = foreach A generate SPRINTF('%6s|%-8s|%2$,+12d %2$8x', 'yay', 665568);
		"");
		 Iterator<Tuple> its = pigServer.openIterator(""B"");
		 Tuple t = its.next();
		 assertEquals("" yay|665568 | +665,568 a27e0"", t.get(0));
	 }
	 public void testSIZE() throws Exception {
		 byte[] a = {
		1,2,3}
		;
		 DataByteArray dba = new DataByteArray(a);
		 Long expected = new Long(3);
		 Tuple t = TupleFactory.getInstance().newTuple(1);
		 t.set(0, dba);
		 EvalFunc<Long> size = new SIZE();
		 String msg = ""[Testing SIZE on input type: bytearray]"";
		 assertTrue(msg, expected.equals(size.exec(t)));
		 String s = ""Unit test case"";
		 expected = new Long(14);
		 t.set(0, s);
		 size = new StringSize();
		 msg = ""[Testing StringSize on input type: String]"";
		 assertTrue(msg, expected.equals(size.exec(t)));
		 String[] mapContents = new String[]{
		""key1"", ""value1"", ""key2"", ""value2""}
		;
		 Map<String, Object> map = Util.createMap(mapContents);
		 expected = new Long(2);
		 t.set(0, map);
		 size = new MapSize();
		 msg = ""[Testing MapSize on input type: Map]"";
		 assertTrue(msg, expected.equals(size.exec(t)));
		 Tuple t1 = Util.createTuple(new String[]{
		""a"", ""b"", ""c""}
		);
		 Tuple t2 = Util.createTuple(new String[]{
		""d"", ""e"", ""f""}
		);
		 Tuple t3 = Util.createTuple(new String[]{
		""g"", ""h"", ""i""}
		);
		 Tuple t4 = Util.createTuple(new String[]{
		""j"", ""k"", ""l""}
		);
		 DataBag b = Util.createBag(new Tuple[]{
		t1, t2, t3, t4}
		);
		 expected = new Long(4);
		 t.set(0, b);
		 size = new BagSize();
		 msg = ""[Testing BagSize on input type: Bag]"";
		 assertTrue(msg, expected.equals(size.exec(t)));
		 Tuple suspect = Util.createTuple(new String[]{
		""key1"", ""str1""}
		);
		 size = new TupleSize();
		 msg = ""[Testing TupleSize on input type: Tuple]"";
		 expected = new Long(2);
		 Tuple suspectStuffer = TupleFactory.getInstance().newTuple(1);
		 suspectStuffer.set(0, suspect);
		 assertTrue(msg, expected.equals(size.exec(suspectStuffer)));
		 int expectedSize = 4;
		 Tuple suspect2 = TupleFactory.getInstance().newTuple(expectedSize);
		 suspect2.set(0, a);
		 suspect2.set(1, s);
		 suspect2.set(2, b);
		 suspect2.set(3, suspect);
		 expected = new Long(expectedSize);
		 size = new TupleSize();
		 msg = ""[Testing TupleSize on input type: Tuple]"";
		 suspectStuffer.set(0, suspect2);
		 assertTrue(msg, expected.equals(size.exec(suspectStuffer)));
		 ARITY arrity = new ARITY();
		 expected = new Long(3);
		 msg = ""[Testing ARRITY on input type: Tuple]"";
		 assertTrue(msg, expected.equals(new Long(arrity.exec(t1))));
	 }
	 public void testTupleSize() throws Exception {
		 String inputFileName = ""TupleSizeIn.txt"";
		 String[] inputData = new String[] {
		 ""Don't call my name, don't call my name, Alejandro"", ""I'm not your babe, I'm not your babe, Fernando"", ""Don't wanna kiss, don't wanna touch"", ""Just smoke my cigarette and hush"", ""Don't call my name, don't call my name, Roberto""}
		;
		 File inputFile = Util.createInputFile(""tmp"", inputFileName, inputData);
		 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' AS value:chararray;
		"");
		 pigServer.registerQuery(""=> foreach @ generate STRSPLIT(value, ' ') AS values;
		"");
		 pigServer.registerQuery(""C = foreach @ generate values, SIZE(values) as cnt;
		"");
		 Iterator<Tuple> it = pigServer.openIterator(""C"");
		 int i=0;
		 while (it.hasNext()) {
			 Tuple t = it.next();
			 assertEquals(""Testing SIZE(<Tuple>): "", new Long(new StringTokenizer(inputData[i]).countTokens()), t.get(1));
			 i++;
		 }
		 inputFile.delete();
		 assertTrue(!it.hasNext());
		 assertTrue(i==inputData.length);
	 }
	 public void testLFPig() throws Exception {
		 Util.createInputFile(cluster, ""input.txt"", new String[] {
		""this:is:delimited:by:a:colon\n""}
		);
		 int arity1 = 6;
		 LoadFunc lf = new PigStorage("":"");
		 LoadFunc p1 = new ReadToEndLoader(lf, ConfigurationUtil. toConfiguration(cluster.getProperties()), ""input.txt"", 0);
		 Tuple f1 = p1.getNext();
		 assertTrue(f1.size() == arity1);
		 Util.deleteFile(cluster, ""input.txt"");
		 int LOOP_COUNT = 100;
		 String[] input = new String[LOOP_COUNT * LOOP_COUNT];
		 int n = 0;
		 for (int i = 0;
		 i < LOOP_COUNT;
		 i++) {
			 for (int j = 0;
			 j < LOOP_COUNT;
			 j++) {
				 input[n++] = (i + ""\t"" + i + ""\t"" + j % 2);
			 }
		 }
		 Util.createInputFile(cluster, ""input.txt"", input);
		 LoadFunc p15 = new ReadToEndLoader(new PigStorage(), ConfigurationUtil. toConfiguration(cluster.getProperties()), ""input.txt"", 0);
		 int count = 0;
		 while (true) {
			 Tuple f15 = p15.getNext();
			 if (f15 == null) break;
			 count++;
			 assertEquals(3, f15.size());
		 }
		 assertEquals(LOOP_COUNT * LOOP_COUNT, count);
		 Util.deleteFile(cluster, ""input.txt"");
		 String input2 = "":this:has:a:leading:colon\n"";
		 int arity2 = 6;
		 Util.createInputFile(cluster, ""input.txt"", new String[] {
		input2}
		);
		 LoadFunc p2 = new ReadToEndLoader(new PigStorage("":""), ConfigurationUtil. toConfiguration(cluster.getProperties()), ""input.txt"", 0);
		 Tuple f2 = p2.getNext();
		 assertTrue(f2.size() == arity2);
		 Util.deleteFile(cluster, ""input.txt"");
		 String input3 = ""this:has:a:trailing:colon:\n"";
		 int arity3 = 6;
		 Util.createInputFile(cluster, ""input.txt"", new String[] {
		input3}
		);
		 LoadFunc p3 = new ReadToEndLoader(new PigStorage("":""), ConfigurationUtil. toConfiguration(cluster.getProperties()), ""input.txt"", 0);
		 Tuple f3 = p3.getNext();
		 assertTrue(f3.size() == arity3);
		 Util.deleteFile(cluster, ""input.txt"");
	 }
	 public void testLFText() throws Exception {
		 String input1 = ""This is some text.\nWith a newline in it.\n"";
		 String expected1 = ""This is some text."";
		 String expected2 = ""With a newline in it."";
		 Util.createInputFile(cluster, ""testLFTest-input1.txt"", new String[] {
		input1}
		);
		 LoadFunc text1 = new ReadToEndLoader(new TextLoader(), ConfigurationUtil. toConfiguration(cluster.getProperties()), ""testLFTest-input1.txt"", 0);
		 Tuple f1 = text1.getNext();
		 Tuple f2 = text1.getNext();
		 Util.deleteFile(cluster, ""testLFTest-input1.txt"");
		 assertTrue(expected1.equals(f1.get(0).toString()) && expected2.equals(f2.get(0).toString()));
		 Util.createInputFile(cluster, ""testLFTest-input2.txt"", new String[] {
		}
		);
		 LoadFunc text2 = new ReadToEndLoader(new TextLoader(), ConfigurationUtil. toConfiguration(cluster.getProperties()), ""testLFTest-input2.txt"", 0);
		 Tuple f3 = text2.getNext();
		 Util.deleteFile(cluster, ""testLFTest-input2.txt"");
		 assertTrue(f3 == null);
	 }
	 public void testSFPig() throws Exception {
		 Util.resetStateForExecModeSwitch();
		 PigServer mrPigServer = new PigServer(cluster.getExecType(), properties);
		 String inputStr = ""amy\tbob\tcharlene\tdavid\terin\tfrank"";
		 Util.createInputFile(cluster, ""testSFPig-input.txt"", new String[] {
		inputStr}
		);
		 DataByteArray[] input = {
		 new DataByteArray(""amy""), new DataByteArray(""bob""), new DataByteArray(""charlene""), new DataByteArray(""david""), new DataByteArray(""erin""), new DataByteArray(""frank"") }
		;
		 Tuple f1 = Util.loadTuple(TupleFactory.getInstance(). newTuple(input.length), input);
		 String outputLocation = ""testSFPig-output.txt"";
		 String query = ""a = load 'testSFPig-input.txt';
		"" + ""store a into '"" + outputLocation + ""';
		"";
		 mrPigServer.setBatchOn();
		 Util.registerMultiLineQuery(mrPigServer, query);
		 mrPigServer.executeBatch();
		 LoadFunc lfunc = new ReadToEndLoader(new PigStorage(), ConfigurationUtil. toConfiguration(cluster.getProperties()), outputLocation, 0);
		 Tuple f2 = lfunc.getNext();
		 Util.deleteFile(cluster, ""testSFPig-input.txt"");
		 Util.deleteFile(cluster, outputLocation);
		 assertEquals(f1, f2);
	 }
	 public void testStringUDFs() throws Exception {
		 String inputStr = ""amy smith "";
		 File inputFile = Util.createInputFile(""tmp"", ""testStrUDFsIn.txt"", new String[] {
		inputStr}
		);
		 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' as (name: chararray);
		"");
		 pigServer.registerQuery(""B = foreach @ generate SUBSTRING(name, 0, 3), "" + ""INDEXOF(name, 'a'), INDEXOF(name, 'a', 3), LAST_INDEX_OF(name, 'a'), REPLACE(name, 'a', 'b'), "" + ""STRSPLIT(name), STRSPLIT(name, ' '), STRSPLIT(name, ' ', 0), STRSPLITTOBAG(name), STRSPLITTOBAG(name,' ')"" + "", STRSPLITTOBAG(name,' ',0), TRIM(name);
		"");
		 Iterator<Tuple> it = pigServer.openIterator(""B"");
		 assertTrue(it.hasNext());
		 Tuple t = it.next();
		 Tuple expected = Util.buildTuple(""amy"", ""smith"");
		 DataBag expectedBag = Util.createBag(new Tuple[]{
		Util.buildTuple(""amy""), Util.buildTuple(""smith"")}
		);
		 assertTrue(!it.hasNext());
		 assertEquals(12, t.size());
		 assertEquals(""amy"", t.get(0));
		 assertEquals(0, t.get(1));
		 assertEquals(-1, t.get(2));
		 assertEquals(0, t.get(3));
		 assertEquals(""bmy smith "", t.get(4));
		 assertEquals(expected, t.get(5));
		 assertEquals(expected, t.get(6));
		 assertEquals(expected, t.get(7));
		 assertEquals(expectedBag, t.get(8));
		 assertEquals(expectedBag, t.get(9));
		 assertEquals(expectedBag, t.get(10));
		 assertEquals(""amy smith"", t.get(11));
		 pigServer.registerQuery(""=> load '"" + Util.encodeEscape(inputFile.getAbsolutePath()) + ""' as (name);
		"");
		 pigServer.registerQuery(""B = foreach @ generate SUBSTRING(name, 0, 3), "" + ""LAST_INDEX_OF(name, 'a'), REPLACE(name, 'a', 'b'), TRIM(name);
		"");
		 it = pigServer.openIterator(""B"");
		 assertTrue(it.hasNext());
		 t = it.next();
		 assertTrue(!it.hasNext());
		 assertEquals(4, t.size());
		 assertEquals(""amy"", t.get(0));
		 assertEquals(0, t.get(1));
		 assertEquals(""bmy smith "", t.get(2));
		 assertEquals(""amy smith"", t.get(3));
	 }
	 public void testTOKENIZE() throws Exception {
		 TupleFactory tf = TupleFactory.getInstance();
		 Tuple t1 = tf.newTuple(1);
		 t1.set(0, ""123 456\""789"");
		 Tuple t2 = tf.newTuple(1);
		 t2.set(0, null);
		 Tuple t3 = tf.newTuple(0);
		 TOKENIZE f = new TOKENIZE();
		 DataBag b = f.exec(t1);
		 assertTrue(b.size()==3);
		 Iterator<Tuple> i = b.iterator();
		 Tuple rt = i.next();
		 assertTrue(rt.get(0).equals(""123""));
		 rt = i.next();
		 assertTrue(rt.get(0).equals(""456""));
		 rt = i.next();
		 assertTrue(rt.get(0).equals(""789""));
		 Tuple t4 = tf.newTuple(2);
		 t4.set(0, ""123|456|78\""9"");
		 t4.set(1, ""|"");
		 b = f.exec(t4);
		 assertTrue(b.size()==3);
		 i = b.iterator();
		 rt = i.next();
		 assertTrue(rt.get(0).equals(""123""));
		 rt = i.next();
		 assertTrue(rt.get(0).equals(""456""));
		 rt = i.next();
		 assertTrue(rt.get(0).equals(""78\""9""));
		 b = f.exec(t2);
		 assertTrue(b==null);
		 b = f.exec(t3);
		 assertTrue(b==null);
	 }
	 public void testDIFF() throws Exception {
		 BagFactory bf = BagFactory.getInstance();
		 TupleFactory tf = TupleFactory.getInstance();
		 DataBag b1 = bf.newDefaultBag();
		 DataBag b2 = bf.newDefaultBag();
		 for (int i = 0;
		 i < 10;
		 i++) b1.add(tf.newTuple(new Integer(i)));
		 for (int i = 0;
		 i < 10;
		 i += 2) b2.add(tf.newTuple(new Integer(i)));
		 Tuple t = tf.newTuple(2);
		 t.set(0, b1);
		 t.set(1, b2);
		 DIFF d = new DIFF();
		 DataBag result = d.exec(t);
		 assertEquals(5, result.size());
		 Iterator<Tuple> i = result.iterator();
		 int[] values = new int[5];
		 for (int j = 0;
		 j < 5;
		 j++) values[j] = (Integer)i.next().get(0);
		 Arrays.sort(values);
		 for (int j = 1;
		 j < 10;
		 j += 2) assertEquals(j, values[j/2]);
		 t = tf.newTuple(2);
		 t.set(0, new Integer(1));
		 t.set(1, new Integer(1));
		 result = d.exec(t);
		 assertEquals(0, result.size());
		 t = tf.newTuple(2);
		 t.set(0, new Integer(1));
		 t.set(1, new Integer(2));
		 result = d.exec(t);
		 assertEquals(2, result.size());
	 }
	 public void testURIwithCurlyBrace() throws Exception {
		 String inputFileName = ""input.txt"";
		 String inputFileName1 =""part-1"";
		 Util.deleteFile(pigServer.getPigContext(), inputFileName);
		 Util.deleteFile(pigServer.getPigContext(), inputFileName1);
		 String[] inputData = new String[] {
		 ""1"", ""a"", ""r""}
		;
		 Util.createLocalInputFile(inputFileName, inputData);
		 pigServer.registerQuery(""a = load '"" + inputFileName + ""'AS (s:chararray);
		"");
		 pigServer.store(""a"", inputFileName1, ""BinStorage"");
		 pigServer.registerQuery(""b = load 'part-{
		1,2}
		' using BinStorage() AS (s:chararray);
		"");
		 Iterator<Tuple> it = pigServer.openIterator(""b"");
		 int i=0;
		 while(it.hasNext()) {
			 assertTrue(it.next().get(0).equals(inputData[i]));
			 i++;
		 }
		 assertTrue(i==3);
		 Util.deleteFile(pigServer.getPigContext(), inputFileName);
		 Util.deleteFile(pigServer.getPigContext(), inputFileName1);
	 }
	 private static String getInputType(String typeFor) {
		 return allowedInput.get(typeFor);
	 }
	 private Object getExpected(String expectedFor) {
		 return expectedMap.get(expectedFor);
	 }
	 private void assertForInputType(String inputType, String assertMsg, Object expected, Object actual) {
		 if (inputType == ""ByteArray"") {
			 assertEquals(assertMsg, expected, actual);
		 }
		 else if (inputType == ""Long"") {
			 assertEquals(assertMsg, expected, actual);
		 }
		 else if (inputType == ""Integer"") {
			 assertEquals(assertMsg, expected, actual);
		 }
		 else if (inputType == ""Double"") {
			 assertEquals(assertMsg, expected, actual);
		 }
		 else if (inputType == ""Float"") {
			 assertEquals(assertMsg, expected, actual);
		 }
		 else if (inputType == ""BigDecimal"") {
			 assertEquals(assertMsg, ((BigDecimal)expected).toPlainString(), ((BigDecimal)expected).toPlainString());
		 }
		 else if (inputType == ""BigInteger"") {
			 assertEquals(assertMsg, ((BigInteger)expected).toString(), ((BigInteger)actual).toString());
		 }
		 else if (inputType == ""String"") {
			 assertEquals(assertMsg, expected, actual);
		 }
		 else if (inputType == ""DateTime"") {
			 assertEquals(assertMsg, ((DateTime)expected).getMillis(), ((DateTime)actual).getMillis());
		 }
	 }
	 public void testKeySet() throws Exception {
		 Map<String, Object> m = new HashMap<String, Object>();
		 m.put(""open"", ""apache"");
		 m.put(""1"", ""hadoop"");
		 m.put(""source"", ""code"");
		 Tuple input = TupleFactory.getInstance().newTuple(m);
		 KEYSET keySet = new KEYSET();
		 DataBag result = keySet.exec(input);
		 Iterator<Tuple> i = result.iterator();
		 assertEquals(result.size(), m.size());
		 while(i.hasNext()) {
			 Tuple t = i.next();
			 assertTrue(m.containsKey((String)t.get(0)));
		 }
	 }
	 public void testValueSet() throws Exception {
		 Map<String, Object> m = new HashMap<String, Object>();
		 m.put(""open"", ""apache"");
		 m.put(""1"", ""hadoop"");
		 m.put(""source"", ""apache"");
		 Tuple input = TupleFactory.getInstance().newTuple(m);
		 VALUESET valueSet = new VALUESET();
		 DataBag result = valueSet.exec(input);
		 assertEquals(result.size(), 2);
		 Iterator<Tuple> i = result.iterator();
		 List resultList = new ArrayList<String>();
		 while(i.hasNext()) {
			 resultList.add(i.next().get(0));
		 }
		 Collections.sort(resultList);
		 assertEquals(resultList.get(0), ""apache"");
		 assertEquals(resultList.get(1), ""hadoop"");
	 }
	 public void testValueSetOutputSchemaPrimitiveType() throws FrontendException {
		 Schema inputSchema = new Schema();
		 Schema charArraySchema = new Schema(new FieldSchema(null, DataType.CHARARRAY));
		 FieldSchema mapSchema = new FieldSchema(null, charArraySchema, DataType.MAP);
		 inputSchema.add(mapSchema);
		 Schema tupleSchema = new Schema(new FieldSchema(null, charArraySchema, DataType.TUPLE));
		 Schema expectedSchema = new Schema(new FieldSchema(null, tupleSchema, DataType.BAG));
		 VALUESET vs = new VALUESET();
		 assertEquals(expectedSchema, vs.outputSchema(inputSchema));
	 }
	 public void testValueSetOutputSchemaComplexType() throws FrontendException {
		 Schema inputSchema = new Schema();
		 Schema tupleSchema = Schema.generateNestedSchema(DataType.TUPLE, DataType.CHARARRAY);
		 Schema bagSchema = new Schema(new FieldSchema(null, tupleSchema, DataType.BAG));
		 FieldSchema mapSchema = new FieldSchema(null, bagSchema, DataType.MAP);
		 inputSchema.add(mapSchema);
		 Schema tupleOfBagSchema = new Schema(new FieldSchema(null, bagSchema, DataType.TUPLE));
		 Schema expectedSchema = new Schema(new FieldSchema(null, tupleOfBagSchema, DataType.BAG));
		 VALUESET vs = new VALUESET();
		 assertEquals(expectedSchema, vs.outputSchema(inputSchema));
	 }
	 public void testValueList() throws Exception {
		 Map<String, Object> m = new HashMap<String, Object>();
		 m.put(""open"", ""apache"");
		 m.put(""1"", ""hadoop"");
		 m.put(""source"", ""apache"");
		 Tuple input = TupleFactory.getInstance().newTuple(m);
		 VALUELIST valueList = new VALUELIST();
		 DataBag result = valueList.exec(input);
		 assertEquals(result.size(), 3);
		 Iterator<Tuple> i = result.iterator();
		 List resultList = new ArrayList();
		 while(i.hasNext()) {
			 Tuple t = i.next();
			 resultList.add(t.get(0));
		 }
		 Collections.sort(resultList);
		 assertEquals((String)resultList.get(0), ""apache"");
		 assertEquals((String)resultList.get(1), ""apache"");
		 assertEquals((String)resultList.get(2), ""hadoop"");
	 }
	 public void testValueListOutputSchemaPrimitiveType() throws FrontendException {
		 Schema inputSchema = new Schema();
		 Schema charArraySchema = new Schema(new FieldSchema(null, DataType.CHARARRAY));
		 FieldSchema mapSchema = new FieldSchema(null, charArraySchema, DataType.MAP);
		 inputSchema.add(mapSchema);
		 Schema tupleSchema = new Schema(new FieldSchema(null, charArraySchema, DataType.TUPLE));
		 Schema expectedSchema = new Schema(new FieldSchema(null, tupleSchema, DataType.BAG));
		 VALUELIST vl = new VALUELIST();
		 assertEquals(expectedSchema, vl.outputSchema(inputSchema));
	 }
	 public void testValueListOutputSchemaComplexType() throws FrontendException {
		 Schema inputSchema = new Schema();
		 Schema tupleSchema = Schema.generateNestedSchema(DataType.TUPLE, DataType.CHARARRAY);
		 Schema bagSchema = new Schema(new FieldSchema(null, tupleSchema, DataType.BAG));
		 FieldSchema mapSchema = new FieldSchema(null, bagSchema, DataType.MAP);
		 inputSchema.add(mapSchema);
		 Schema tupleOfBagSchema = new Schema(new FieldSchema(null, bagSchema, DataType.TUPLE));
		 Schema expectedSchema = new Schema(new FieldSchema(null, tupleOfBagSchema, DataType.BAG));
		 VALUELIST vl = new VALUELIST();
		 assertEquals(expectedSchema, vl.outputSchema(inputSchema));
	 }
	 public void testInverseMap() throws Exception {
		 Map<String, Object> m = new HashMap<String, Object>();
		 m.put(""open"", ""apache"");
		 m.put(""1"", ""hadoop"");
		 m.put(""source"", ""pig"");
		 m.put(""integer"", new Integer(100));
		 m.put(""floating"", new Float(100.012));
		 m.put(""long"", new Long(10000000000000l));
		 m.put(""boolean"", true);
		 Tuple input = TupleFactory.getInstance().newTuple(m);
		 INVERSEMAP inverseMap = new INVERSEMAP();
		 Map inverse = inverseMap.exec(input);
		 assertEquals(inverse.size(), 7);
		 assertTrue(inverse.containsKey(""apache""));
		 assertTrue(inverse.containsKey(""hadoop""));
		 assertTrue(inverse.containsKey(""pig""));
		 assertTrue(inverse.containsKey(""100""));
		 assertTrue(inverse.containsKey(""true""));
		 assertTrue(inverse.containsKey(""100.012""));
		 m.clear();
		 m.put(""open"", ""apache"");
		 m.put(""1"", ""hadoop"");
		 m.put(""source"", ""apache"");
		 input.set(0, m);
		 inverse = inverseMap.exec(input);
		 assertEquals(inverse.size(), 2);
		 assertTrue(inverse.containsKey(""apache""));
		 assertTrue(inverse.containsKey(""hadoop""));
		 DataBag bag = (DataBag)inverse.get(""apache"");
		 List resultList = new ArrayList<String>();
		 Iterator<Tuple> i = bag.iterator();
		 while(i.hasNext()) {
			 Tuple t = i.next();
			 resultList.add(t.get(0));
		 }
		 Collections.sort(resultList);
		 assertEquals((String)resultList.get(0), ""open"");
		 assertEquals((String)resultList.get(1), ""source"");
	 }
	 public void testDiffDateTime() throws Exception {
		 Tuple t = TupleFactory.getInstance().newTuple(2);
		 t.set(0, new DateTime(""2009-01-07T00:00:00.000Z""));
		 t.set(1, new DateTime(""2002-01-01T00:00:00.000Z""));
		 YearsBetween func1 = new YearsBetween();
		 Long years = func1.exec(t);
		 System.out.println(""Years: "" + years.toString());
		 Assert.assertEquals(years.longValue(), 7L);
		 MonthsBetween func2 = new MonthsBetween();
		 Long months = func2.exec(t);
		 System.out.println(""Months: "" + months.toString());
		 Assert.assertEquals(months.longValue(),84L);
		 WeeksBetween func3 = new WeeksBetween();
		 Long weeks = func3.exec(t);
		 System.out.println(""Weeks: "" + weeks.toString());
		 Assert.assertEquals(weeks.longValue(), 366L);
		 DaysBetween func4 = new DaysBetween();
		 Long days = func4.exec(t);
		 System.out.println(""Days: "" + days.toString());
		 Assert.assertEquals(days.longValue(), 2563L);
		 HoursBetween func5 = new HoursBetween();
		 Long hours = func5.exec(t);
		 System.out.println(""Hours: "" + hours.toString());
		 Assert.assertEquals(hours.longValue(), 61512L);
		 MinutesBetween func6 = new MinutesBetween();
		 Long mins = func6.exec(t);
		 System.out.println(""Minutes: "" + mins.toString());
		 Assert.assertEquals(mins.longValue(), 3690720L);
		 SecondsBetween func7 = new SecondsBetween();
		 Long secs = func7.exec(t);
		 System.out.println(""Seconds: "" + secs.toString());
		 Assert.assertEquals(secs.longValue(), 221443200L);
		 MilliSecondsBetween func8 = new MilliSecondsBetween();
		 Long millis = func8.exec(t);
		 System.out.println(""MilliSeconds: "" + millis.toString());
		 Assert.assertEquals(millis.longValue(), 221443200000L);
	 }
	 public void testGetDateTimeField() throws Exception {
		 Tuple t1 = TupleFactory.getInstance().newTuple(1);
		 t1.set(0, ToDate.extractDateTime(""2010-04-15T08:11:33.020Z""));
		 Tuple t2 = TupleFactory.getInstance().newTuple(1);
		 t2.set(0, ToDate.extractDateTime(""2010-04-15T08:11:33.020+08:00""));
		 GetYear func1 = new GetYear();
		 Integer year = func1.exec(t1);
		 assertEquals(year.intValue(), 2010);
		 year = func1.exec(t2);
		 assertEquals(year.intValue(), 2010);
		 GetMonth func2 = new GetMonth();
		 Integer month = func2.exec(t1);
		 assertEquals(month.intValue(), 4);
		 month = func2.exec(t2);
		 assertEquals(month.intValue(), 4);
		 GetDay func3 = new GetDay();
		 Integer day = func3.exec(t1);
		 assertEquals(day.intValue(), 15);
		 day = func3.exec(t2);
		 assertEquals(day.intValue(), 15);
		 GetHour func4 = new GetHour();
		 Integer hour = func4.exec(t1);
		 assertEquals(hour.intValue(), 8);
		 hour = func4.exec(t2);
		 assertEquals(hour.intValue(), 8);
		 GetMinute func5 = new GetMinute();
		 Integer minute = func5.exec(t1);
		 assertEquals(minute.intValue(), 11);
		 minute = func5.exec(t2);
		 assertEquals(minute.intValue(), 11);
		 GetSecond func6 = new GetSecond();
		 Integer second = func6.exec(t1);
		 assertEquals(second.intValue(), 33);
		 second = func6.exec(t2);
		 assertEquals(second.intValue(), 33);
		 GetMilliSecond func7 = new GetMilliSecond();
		 Integer milli = func7.exec(t1);
		 assertEquals(milli.intValue(), 20);
		 milli = func7.exec(t2);
		 assertEquals(milli.intValue(), 20);
		 GetWeekYear func8 = new GetWeekYear();
		 Integer weekyear = func8.exec(t1);
		 assertEquals(weekyear.intValue(), 2010);
		 weekyear = func8.exec(t2);
		 assertEquals(weekyear.intValue(), 2010);
		 GetWeek func9 = new GetWeek();
		 Integer week = func9.exec(t1);
		 assertEquals(week.intValue(), 15);
		 week = func9.exec(t2);
		 assertEquals(week.intValue(), 15);
		 t1.set(0, null);
		 assertEquals(func1.exec(t1), null);
		 assertEquals(func2.exec(t1), null);
		 assertEquals(func3.exec(t1), null);
		 assertEquals(func4.exec(t1), null);
		 assertEquals(func5.exec(t1), null);
		 assertEquals(func6.exec(t1), null);
		 assertEquals(func7.exec(t1), null);
		 assertEquals(func8.exec(t1), null);
		 assertEquals(func9.exec(t1), null);
	 }
	 public void testUniqueID() throws Exception {
		 Util.resetStateForExecModeSwitch();
		 Properties copyproperties = new Properties();
		 copyproperties.putAll(cluster.getProperties());
		 PigServer pigServer = new PigServer(cluster.getExecType(), copyproperties);
		 String TMP_DIR = FileLocalizer.getTemporaryPath(pigServer.getPigContext()).toUri().getPath();
		 Util.createInputFile(cluster, TMP_DIR + ""/input1.txt"", new String[] {
		""1\n2\n3\n4\n5""}
		);
		 Util.createInputFile(cluster, TMP_DIR + ""/input2.txt"", new String[] {
		""1\n2\n3\n4\n5""}
		);
		 pigServer.getPigContext().getProperties().setProperty(""pig.noSplitCombination"", ""true"");
		 pigServer.registerQuery(""A = load '"" + TMP_DIR + ""' as (name);
		"");
		 pigServer.registerQuery(""B = foreach A generate name, UniqueID();
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertEquals(""0-0"",iter.next().get(1));
		 assertEquals(""0-1"",iter.next().get(1));
		 assertEquals(""0-2"",iter.next().get(1));
		 assertEquals(""0-3"",iter.next().get(1));
		 assertEquals(""0-4"",iter.next().get(1));
		 assertEquals(""1-0"",iter.next().get(1));
		 assertEquals(""1-1"",iter.next().get(1));
		 assertEquals(""1-2"",iter.next().get(1));
		 assertEquals(""1-3"",iter.next().get(1));
		 assertEquals(""1-4"",iter.next().get(1));
		 Util.deleteFile(cluster, TMP_DIR + ""/input1.txt"");
		 Util.deleteFile(cluster, TMP_DIR + ""/input2.txt"");
	 }
	 public void testRANDOMWithJob() throws Exception {
		 Util.resetStateForExecModeSwitch();
		 Properties copyproperties = new Properties();
		 copyproperties.putAll(cluster.getProperties());
		 PigServer pigServer = new PigServer(cluster.getExecType(), copyproperties);
		 String TMP_DIR = FileLocalizer.getTemporaryPath(pigServer.getPigContext()).toUri().getPath();
		 Util.createInputFile(cluster, TMP_DIR + ""/input1.txt"", new String[] {
		""1\n2\n3\n4\n5""}
		);
		 Util.createInputFile(cluster, TMP_DIR + ""/input2.txt"", new String[] {
		""1\n2\n3\n4\n5""}
		);
		 pigServer.getPigContext().getProperties().setProperty(""pig.noSplitCombination"", ""true"");
		 pigServer.registerQuery(""A = load '"" + TMP_DIR + ""' as (name);
		"");
		 pigServer.registerQuery(""B = foreach A generate name, RANDOM();
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 double [] mapper1 = new double[5];
		 double [] mapper2 = new double[5];
		 for( int i = 0;
		 i < 5;
		 i++ ){
			 mapper1[i] = (Double) iter.next().get(1);
			 if( i != 0 ) {
				 assertNotEquals(mapper1[i-1], mapper1[i], 0.0001);
			 }
		 }
		 for( int i = 0;
		 i < 5;
		 i++ ){
			 mapper2[i] = (Double) iter.next().get(1);
			 if( i != 0 ) {
				 assertNotEquals(mapper2[i-1], mapper2[i], 0.0001);
			 }
		 }
		 for( int i = 0;
		 i < 5;
		 i++ ){
			 assertNotEquals(mapper1[i], mapper2[i], 0.0001);
		 }
		 Util.deleteFile(cluster, TMP_DIR + ""/input1.txt"");
		 Util.deleteFile(cluster, TMP_DIR + ""/input2.txt"");
	 }
	 public void testRANDOM() throws Exception {
		 Configuration conf = new Configuration();
		 PigMapReduce.sJobConfInternal.set(conf);
		 PigMapReduce.sJobConfInternal.get().set(MRConfiguration.JOB_ID,""job_1111_111"");
		 PigMapReduce.sJobConfInternal.get().set(PigConstants.TASK_INDEX, ""0"");
		 org.apache.pig.builtin.RANDOM.resetSeedUniquifier();
		 org.apache.pig.builtin.RANDOM r = new org.apache.pig.builtin.RANDOM();
		 double [] tmpresult = new double [5];
		 for( int i = 0;
		 i < 5 ;
		 i++ ) {
			 tmpresult[i] = r.exec(null).doubleValue();
			 LOG.info(""Return value of RANDOM(): "" + tmpresult[i]);
			 if( i != 0 ) {
				 assertNotEquals(tmpresult[i-1], tmpresult[i], 0.0001);
			 }
		 }
		 org.apache.pig.builtin.RANDOM.resetSeedUniquifier();
		 PigMapReduce.sJobConfInternal.get().set(MRConfiguration.JOB_ID,""job_1111_111"");
		 PigMapReduce.sJobConfInternal.get().set(PigConstants.TASK_INDEX, ""1"");
		 r = new org.apache.pig.builtin.RANDOM();
		 for( int i = 0;
		 i < 5 ;
		 i++ ) {
			 assertNotEquals(tmpresult[i], r.exec(null).doubleValue(), 0.0001);
		 }
		 org.apache.pig.builtin.RANDOM.resetSeedUniquifier();
		 PigMapReduce.sJobConfInternal.get().set(MRConfiguration.JOB_ID,""job_1111_112"");
		 PigMapReduce.sJobConfInternal.get().set(PigConstants.TASK_INDEX, ""0"");
		 r = new org.apache.pig.builtin.RANDOM();
		 for( int i = 0;
		 i < 5 ;
		 i++ ) {
			 assertNotEquals(tmpresult[i], r.exec(null).doubleValue(), 0.0001);
		 }
		 org.apache.pig.builtin.RANDOM.resetSeedUniquifier();
		 PigMapReduce.sJobConfInternal.get().set(MRConfiguration.JOB_ID,""job_1111_111"");
		 PigMapReduce.sJobConfInternal.get().set(PigConstants.TASK_INDEX, ""0"");
		 r = new org.apache.pig.builtin.RANDOM();
		 for( int i = 0;
		 i < 5 ;
		 i++ ) {
			 assertEquals(tmpresult[i], r.exec(null).doubleValue(), 0.0001 );
		 }
		 r = new org.apache.pig.builtin.RANDOM();
		 for( int i = 0;
		 i < 5 ;
		 i++ ) {
			 assertNotEquals(tmpresult[i], r.exec(null).doubleValue(), 0.0001 );
		 }
	 }
	 public void testToMapSchema() throws Exception {
		 PigServer pigServer = new PigServer(Util.getLocalTestMode(), new Properties());
		 pigServer.registerQuery(""A = load '1.txt' as (a0:chararray, a1:int, a2:double, a3);
		"");
		 pigServer.registerQuery(""B = foreach A generate [a0,a1];
		"");
		 Schema s = pigServer.dumpSchema(""B"");
		 Assert.assertEquals(s.toString(), ""{
		map[int]}
		"");
		 pigServer.registerQuery(""B = foreach A generate [a0,a1,a0,a2];
		"");
		 s = pigServer.dumpSchema(""B"");
		 Assert.assertEquals(s.toString(), ""{
		map[]}
		"");
		 pigServer.registerQuery(""B = foreach A generate [a0,a3];
		"");
		 s = pigServer.dumpSchema(""B"");
		 Assert.assertEquals(s.toString(), ""{
		map[]}
		"");
		 pigServer.registerQuery(""A = load '1.txt' as (a:{
		(a0:chararray, a1:int)}
		);
		"");
		 pigServer.registerQuery(""B = foreach A generate TOMAP(a);
		"");
		 s = pigServer.dumpSchema(""B"");
		 Assert.assertEquals(s.toString(), ""{
		map[int]}
		"");
		 pigServer.registerQuery(""A = load '1.txt' as (a:{
		(a0, a1, a2, a3:int)}
		);
		"");
		 pigServer.registerQuery(""B = foreach A generate TOMAP(a);
		"");
		 s = pigServer.dumpSchema(""B"");
		 Assert.assertEquals(s.toString(), ""{
		map[]}
		"");
	 }
}",1,0,0,0
"public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
	 TokenStream input = (TokenStream)_input;
	 int _s = s;
	 switch ( s ) {
		 case 0 : int LA102_1 = input.LA(1);
		 int index102_1 = input.index();
		 input.rewind();
		 s = -1;
		 if ( (synpred145_InternalDomainmodel()) ) {
			s = 77;
		}
		 else if ( (true) ) {
			s = 2;
		}
		 input.seek(index102_1);
		 if ( s>=0 ) return s;
		 break;
	 }
	 if (state.backtracking>0) {
		state.failed=true;
		 return -1;
	}
	 NoViableAltException nvae = new NoViableAltException(getDescription(), 102, _s, input);
	 error(nvae);
	 throw nvae;
 }",0,0,1,0
"public class HFileBlockDefaultEncodingContext implements HFileBlockEncodingContext {
	 private BlockType blockType;
	 private final DataBlockEncoding encodingAlgo;
	 private byte[] dummyHeader;
	 private Compressor compressor;
	 private CompressionOutputStream compressionStream;
	 private ByteArrayOutputStream compressedByteStream;
	 private HFileContext fileContext;
	 private TagCompressionContext tagCompressionContext;
	 private ByteArrayOutputStream cryptoByteStream;
	 private byte[] iv;
	 private EncodingState encoderState;
	 public HFileBlockDefaultEncodingContext(DataBlockEncoding encoding, byte[] headerBytes, HFileContext fileContext) {
		 this.encodingAlgo = encoding;
		 this.fileContext = fileContext;
		 Compression.Algorithm compressionAlgorithm = fileContext.getCompression() == null ? NONE : fileContext.getCompression();
		 if (compressionAlgorithm != NONE) {
			 compressor = compressionAlgorithm.getCompressor();
			 compressedByteStream = new ByteArrayOutputStream();
			 try {
				 compressionStream = compressionAlgorithm.createPlainCompressionStream( compressedByteStream, compressor);
			 }
			 catch (IOException e) {
				 throw new RuntimeException( ""Could not create compression stream for algorithm "" + compressionAlgorithm, e);
			 }
		 }
		 Encryption.Context cryptoContext = fileContext.getEncryptionContext();
		 if (cryptoContext != Encryption.Context.NONE) {
			 cryptoByteStream = new ByteArrayOutputStream();
			 iv = new byte[cryptoContext.getCipher().getIvLength()];
			 new SecureRandom().nextBytes(iv);
		 }
		 dummyHeader = Preconditions.checkNotNull(headerBytes, ""Please pass HConstants.HFILEBLOCK_DUMMY_HEADER instead of null for param headerBytes"");
	 }
	 public void prepareEncoding(DataOutputStream out) throws IOException {
		 if (encodingAlgo != null && encodingAlgo != DataBlockEncoding.NONE) {
			 encodingAlgo.writeIdInBytes(out);
		 }
	 }
	 public void postEncoding(BlockType blockType) throws IOException {
		 this.blockType = blockType;
	 }
	 public Bytes compressAndEncrypt(byte[] data, int offset, int length) throws IOException {
		 return compressAfterEncoding(data, offset, length, dummyHeader);
	 }
	 private Bytes compressAfterEncoding(byte[] uncompressedBytesWithHeaderBuffer, int uncompressedBytesWithHeaderOffset, int uncompressedBytesWithHeaderLength, byte[] headerBytes) throws IOException {
		 Encryption.Context cryptoContext = fileContext.getEncryptionContext();
		 if (cryptoContext != Encryption.Context.NONE) {
			 cryptoByteStream.reset();
			 cryptoByteStream.write(headerBytes);
			 InputStream in;
			 int plaintextLength;
			 if (fileContext.getCompression() != Compression.Algorithm.NONE) {
				 compressedByteStream.reset();
				 compressionStream.resetState();
				 compressionStream.write(uncompressedBytesWithHeaderBuffer, headerBytes.length + uncompressedBytesWithHeaderOffset, uncompressedBytesWithHeaderLength - headerBytes.length);
				 compressionStream.flush();
				 compressionStream.finish();
				 byte[] plaintext = compressedByteStream.toByteArray();
				 plaintextLength = plaintext.length;
				 in = new ByteArrayInputStream(plaintext);
			 }
			 else {
				 plaintextLength = uncompressedBytesWithHeaderLength - headerBytes.length;
				 in = new ByteArrayInputStream(uncompressedBytesWithHeaderBuffer, headerBytes.length + uncompressedBytesWithHeaderOffset, plaintextLength);
			 }
			 if (plaintextLength > 0) {
				 Cipher cipher = cryptoContext.getCipher();
				 Encryptor encryptor = cipher.getEncryptor();
				 encryptor.setKey(cryptoContext.getKey());
				 int ivLength = iv.length;
				 Preconditions.checkState(ivLength <= Byte.MAX_VALUE, ""IV length out of range"");
				 cryptoByteStream.write(ivLength);
				 if (ivLength > 0) {
					 encryptor.setIv(iv);
					 cryptoByteStream.write(iv);
				 }
				 Encryption.encrypt(cryptoByteStream, in, encryptor);
				 Encryption.incrementIv(iv, 1 + (cryptoByteStream.size() / encryptor.getBlockSize()));
				 return new Bytes(cryptoByteStream.getBuffer(), 0, cryptoByteStream.size());
			 }
			 else {
				 cryptoByteStream.write(0);
				 return new Bytes(cryptoByteStream.getBuffer(), 0, cryptoByteStream.size());
			 }
		 }
		 else {
			 if (this.fileContext.getCompression() != NONE) {
				 compressedByteStream.reset();
				 compressedByteStream.write(headerBytes);
				 compressionStream.resetState();
				 compressionStream.write(uncompressedBytesWithHeaderBuffer, headerBytes.length + uncompressedBytesWithHeaderOffset, uncompressedBytesWithHeaderLength - headerBytes.length);
				 compressionStream.flush();
				 compressionStream.finish();
				 return new Bytes(compressedByteStream.getBuffer(), 0, compressedByteStream.size());
			 }
			 else {
				 return null;
			 }
		 }
	 }
	 public BlockType getBlockType() {
		 return blockType;
	 }
	 public void close() {
		 if (compressor != null) {
			 this.fileContext.getCompression().returnCompressor(compressor);
			 compressor = null;
		 }
	 }
	 public DataBlockEncoding getDataBlockEncoding() {
		 return this.encodingAlgo;
	 }
	 public HFileContext getHFileContext() {
		 return this.fileContext;
	 }
	 public TagCompressionContext getTagCompressionContext() {
		 return tagCompressionContext;
	 }
	 public void setTagCompressionContext(TagCompressionContext tagCompressionContext) {
		 this.tagCompressionContext = tagCompressionContext;
	 }
	 public EncodingState getEncodingState() {
		 return this.encoderState;
	 }
	 public void setEncodingState(EncodingState state) {
		 this.encoderState = state;
	 }
}",1,1,0,0
"public String decodeURL(final String url){
	return url;
}",0,0,0,0
"public static class DefaultExpiredCallback<K> implements ExpiredCallback<K> {
	 protected static final Logger LOG = LoggerFactory.getLogger(TimeCacheQueue.DefaultExpiredCallback.class);
	 protected String queueName;
	 public DefaultExpiredCallback(String queueName) {
		 this.queueName = queueName;
	 }
	 public void expire(K entry) {
		 LOG.info(""TimeCacheQueue "" + queueName + "" entry:"" + entry + "", timeout"");
	 }
 }",0,0,0,0
"public class SOSGet extends SOS {
	 public final void setFile(String filename) {
		 super.setInternalFilename(filename);
	 }
	 public void setRecursive(boolean recursive) {
		 super.setInternalRecursive(recursive);
	 }
	 public void setVersion(String version) {
		 super.setInternalVersion(version);
	 }
	 public void setLabel(String label) {
		 super.setInternalLabel(label);
	 }
	 protected Commandline buildCmdLine() {
		 commandLine = new Commandline();
		 if (getFilename() != null) {
			 commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
			 commandLine.createArgument().setValue(SOSCmd.COMMAND_GET_FILE);
			 commandLine.createArgument().setValue(SOSCmd.FLAG_FILE);
			 commandLine.createArgument().setValue(getFilename());
			 if (getVersion() != null) {
				 commandLine.createArgument().setValue(SOSCmd.FLAG_VERSION);
				 commandLine.createArgument().setValue(getVersion());
			 }
		 }
		 else {
			 commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
			 commandLine.createArgument().setValue(SOSCmd.COMMAND_GET_PROJECT);
			 commandLine.createArgument().setValue(getRecursive());
			 if (getLabel() != null) {
				 commandLine.createArgument().setValue(SOSCmd.FLAG_LABEL);
				 commandLine.createArgument().setValue(getLabel());
			 }
		 }
		 getRequiredAttributes();
		 getOptionalAttributes();
		 return commandLine;
	 }
}",0,0,0,0
"public class ResourceNameIterator implements Iterator<String>{
	private static final Pattern LOCALE_PATTERN = Pattern.compile(""_([a-z]{
	2}
	)(_([A-Z]{
	2}
	)(_([^_]+))?)?$"");
	private final Locale locale;
	private final String extensions;
	private final Iterator<String> styleIterator;
	private LocaleResourceNameIterator localeIterator;
	private Iterator<String> extenstionsIterator;
	private Locale currentLocale;
	private final static Set<String> isoCountries = new ConcurrentHashSet<String>(Arrays.asList(Locale.getISOCountries()));
	private final static Set<String> isoLanguages = new ConcurrentHashSet<String>(Arrays.asList(Locale.getISOLanguages()));
	public ResourceNameIterator(String path, final String style, final Locale locale,final String extensions){
		this.locale = locale;
		if ((extensions == null) && (path.indexOf('.') != -1)){
			this.extensions = Strings.afterLast(path, '.');
			path = Strings.beforeLast(path, '.');
		}
		else{
			this.extensions = extensions;
		}
		String filename = Strings.lastPathComponent(path, '/');
		Matcher matcher = LOCALE_PATTERN.matcher(filename);
		if (matcher.find()){
			String language = matcher.group(1);
			String country = matcher.group(3);
			String variant = matcher.group(5);
			if (language != null){
				if (isoLanguages.contains(language) == false){
					language = null;
					country = null;
					variant = null;
				}
			}
			if ((language != null) && (country != null)){
				if (isoCountries.contains(country) == false){
					country = null;
					variant = null;
				}
			}
			if (language != null){
				path = path.substring(0, path.length() - filename.length() + matcher.start());
				localeIterator = new LocaleResourceNameIterator(path, new Locale(language,country != null ? country : """", variant != null ? variant : """"));
			}
		}
		 styleIterator = new StyleAndVariationResourceNameIterator(path, style, null);
	}
	public final Locale getLocale(){
		return currentLocale;
	}
	public boolean hasNext(){
		if (extenstionsIterator != null){
			if (extenstionsIterator.hasNext() == true){
				return true;
			}
			extenstionsIterator = null;
		}
		if (localeIterator != null){
			while (localeIterator.hasNext()){
				String newPath = localeIterator.next();
				currentLocale = localeIterator.getLocale();
				extenstionsIterator = new ExtensionResourceNameIterator(newPath, extensions);
				if (extenstionsIterator.hasNext() == true){
					return true;
				}
			}
			localeIterator = null;
		}
		while (styleIterator.hasNext()){
			String newPath = styleIterator.next();
			localeIterator = new LocaleResourceNameIterator(newPath, locale);
			while (localeIterator.hasNext()){
				newPath = localeIterator.next();
				currentLocale = localeIterator.getLocale();
				extenstionsIterator = new ExtensionResourceNameIterator(newPath, extensions);
				if (extenstionsIterator.hasNext() == true){
					return true;
				}
			}
		}
		return false;
	}
	public String next(){
		if (extenstionsIterator != null){
			return extenstionsIterator.next();
		}
		throw new WicketRuntimeException(""Illegal call of next(). Iterator not properly initialized"");
	}
	public void remove(){
	}
}",0,0,0,0
"protected String getEndSeparator(){
	return """";
}",0,0,0,0
"Iterator getResourceDirectories() {
	 if (src == null) {
		 return new FileResourceIterator(getBasedir(), getIncludedDirectories());
	 }
	 scanme();
	 return matchDirEntries.values().iterator();
 }",0,0,0,0
public Type typeCheck(SymbolTable stable) throws TypeCheckError;,0,0,0,0
"public class JdbcLexicalUUID extends AbstractJdbcUUID{
	 public static final JdbcLexicalUUID instance = new JdbcLexicalUUID();
	 public JdbcLexicalUUID() {
	}
	 public String getString(ByteBuffer bytes) {
		 if (bytes.remaining() == 0) {
			 return """";
		 }
		 if (bytes.remaining() != 16) {
			 throw new MarshalException(""UUIDs must be exactly 16 bytes"");
		 }
		 return UUIDGen.getUUID(bytes).toString();
	 }
	 public UUID compose(ByteBuffer bytes) {
		 return UUIDGen.getUUID(bytes);
	 }
	 public ByteBuffer decompose(UUID value) {
		 return ByteBuffer.wrap(UUIDGen.decompose(value));
	 }
}",0,0,0,0
"public class MultiResponse200 {
	 private String message;
	 private int code;
	 private long t200;
	 public String getMessage() {
		 return message;
	 }
	 public void setMessage(String message) {
		 this.message = message;
	 }
	 public int getCode() {
		 return code;
	 }
	 public void setCode(int code) {
		 this.code = code;
	 }
	 public long getT200() {
		 return t200;
	 }
	 public void setT200(long t200) {
		 this.t200 = t200;
	 }
}",0,1,0,0
"public class BacktrackingBug325745TestLanguagePackageImpl extends EPackageImpl implements BacktrackingBug325745TestLanguagePackage{
	 private EClass modelEClass = null;
	 private EClass elementEClass = null;
	 private EClass dataTypeEClass = null;
	 private EClass expressionEClass = null;
	 private EClass simpleTermEClass = null;
	 private BacktrackingBug325745TestLanguagePackageImpl() {
		 super(eNS_URI, BacktrackingBug325745TestLanguageFactory.eINSTANCE);
	 }
	 private static boolean isInited = false;
	 public static BacktrackingBug325745TestLanguagePackage init() {
		 if (isInited) return (BacktrackingBug325745TestLanguagePackage)EPackage.Registry.INSTANCE.getEPackage(BacktrackingBug325745TestLanguagePackage.eNS_URI);
		 BacktrackingBug325745TestLanguagePackageImpl theBacktrackingBug325745TestLanguagePackage = (BacktrackingBug325745TestLanguagePackageImpl)(EPackage.Registry.INSTANCE.get(eNS_URI) instanceof BacktrackingBug325745TestLanguagePackageImpl ? EPackage.Registry.INSTANCE.get(eNS_URI) : new BacktrackingBug325745TestLanguagePackageImpl());
		 isInited = true;
		 EcorePackage.eINSTANCE.eClass();
		 theBacktrackingBug325745TestLanguagePackage.createPackageContents();
		 theBacktrackingBug325745TestLanguagePackage.initializePackageContents();
		 theBacktrackingBug325745TestLanguagePackage.freeze();
		 EPackage.Registry.INSTANCE.put(BacktrackingBug325745TestLanguagePackage.eNS_URI, theBacktrackingBug325745TestLanguagePackage);
		 return theBacktrackingBug325745TestLanguagePackage;
	 }
	 public EClass getModel() {
		 return modelEClass;
	 }
	 public EReference getModel_Fields() {
		 return (EReference)modelEClass.getEStructuralFeatures().get(0);
	 }
	 public EClass getElement() {
		 return elementEClass;
	 }
	 public EAttribute getElement_Name() {
		 return (EAttribute)elementEClass.getEStructuralFeatures().get(0);
	 }
	 public EReference getElement_DataType() {
		 return (EReference)elementEClass.getEStructuralFeatures().get(1);
	 }
	 public EReference getElement_Expression() {
		 return (EReference)elementEClass.getEStructuralFeatures().get(2);
	 }
	 public EClass getDataType() {
		 return dataTypeEClass;
	 }
	 public EAttribute getDataType_BaseType() {
		 return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(0);
	 }
	 public EAttribute getDataType_DefaultValue() {
		 return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(1);
	 }
	 public EClass getExpression() {
		 return expressionEClass;
	 }
	 public EAttribute getExpression_Prefix() {
		 return (EAttribute)expressionEClass.getEStructuralFeatures().get(0);
	 }
	 public EReference getExpression_Terms() {
		 return (EReference)expressionEClass.getEStructuralFeatures().get(1);
	 }
	 public EAttribute getExpression_Postfix() {
		 return (EAttribute)expressionEClass.getEStructuralFeatures().get(2);
	 }
	 public EClass getSimpleTerm() {
		 return simpleTermEClass;
	 }
	 public EAttribute getSimpleTerm_LineCount() {
		 return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(0);
	 }
	 public EAttribute getSimpleTerm_CharCount() {
		 return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(1);
	 }
	 public EAttribute getSimpleTerm_CharSet() {
		 return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(2);
	 }
	 public EAttribute getSimpleTerm_RefChar() {
		 return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(3);
	 }
	 public BacktrackingBug325745TestLanguageFactory getBacktrackingBug325745TestLanguageFactory() {
		 return (BacktrackingBug325745TestLanguageFactory)getEFactoryInstance();
	 }
	 private boolean isCreated = false;
	 public void createPackageContents() {
		 if (isCreated) return;
		 isCreated = true;
		 modelEClass = createEClass(MODEL);
		 createEReference(modelEClass, MODEL__FIELDS);
		 elementEClass = createEClass(ELEMENT);
		 createEAttribute(elementEClass, ELEMENT__NAME);
		 createEReference(elementEClass, ELEMENT__DATA_TYPE);
		 createEReference(elementEClass, ELEMENT__EXPRESSION);
		 dataTypeEClass = createEClass(DATA_TYPE);
		 createEAttribute(dataTypeEClass, DATA_TYPE__BASE_TYPE);
		 createEAttribute(dataTypeEClass, DATA_TYPE__DEFAULT_VALUE);
		 expressionEClass = createEClass(EXPRESSION);
		 createEAttribute(expressionEClass, EXPRESSION__PREFIX);
		 createEReference(expressionEClass, EXPRESSION__TERMS);
		 createEAttribute(expressionEClass, EXPRESSION__POSTFIX);
		 simpleTermEClass = createEClass(SIMPLE_TERM);
		 createEAttribute(simpleTermEClass, SIMPLE_TERM__LINE_COUNT);
		 createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_COUNT);
		 createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_SET);
		 createEAttribute(simpleTermEClass, SIMPLE_TERM__REF_CHAR);
	 }
	 private boolean isInitialized = false;
	 public void initializePackageContents() {
		 if (isInitialized) return;
		 isInitialized = true;
		 setName(eNAME);
		 setNsPrefix(eNS_PREFIX);
		 setNsURI(eNS_URI);
		 EcorePackage theEcorePackage = (EcorePackage)EPackage.Registry.INSTANCE.getEPackage(EcorePackage.eNS_URI);
		 initEClass(modelEClass, Model.class, ""Model"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
		 initEReference(getModel_Fields(), this.getElement(), null, ""fields"", null, 0, -1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEClass(elementEClass, Element.class, ""Element"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
		 initEAttribute(getElement_Name(), theEcorePackage.getEString(), ""name"", null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEReference(getElement_DataType(), this.getDataType(), null, ""dataType"", null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEReference(getElement_Expression(), this.getExpression(), null, ""expression"", null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEClass(dataTypeEClass, DataType.class, ""DataType"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
		 initEAttribute(getDataType_BaseType(), theEcorePackage.getEString(), ""baseType"", null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEAttribute(getDataType_DefaultValue(), theEcorePackage.getEString(), ""defaultValue"", null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEClass(expressionEClass, Expression.class, ""Expression"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
		 initEAttribute(getExpression_Prefix(), theEcorePackage.getEString(), ""prefix"", null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEReference(getExpression_Terms(), this.getSimpleTerm(), null, ""terms"", null, 0, -1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEAttribute(getExpression_Postfix(), theEcorePackage.getEString(), ""postfix"", null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEClass(simpleTermEClass, SimpleTerm.class, ""SimpleTerm"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
		 initEAttribute(getSimpleTerm_LineCount(), theEcorePackage.getEInt(), ""lineCount"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEAttribute(getSimpleTerm_CharCount(), theEcorePackage.getEInt(), ""charCount"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEAttribute(getSimpleTerm_CharSet(), theEcorePackage.getEString(), ""charSet"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 initEAttribute(getSimpleTerm_RefChar(), theEcorePackage.getEString(), ""refChar"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
		 createResource(eNS_URI);
	 }
}",1,1,0,0
"public final class ZoneOffsetTransitionRule implements Serializable {
	 private static final long serialVersionUID = 6889046316657758795L;
	 private final Month month;
	 private final byte dom;
	 private final DayOfWeek dow;
	 private final LocalTime time;
	 private final boolean timeEndOfDay;
	 private final TimeDefinition timeDefinition;
	 private final ZoneOffset standardOffset;
	 private final ZoneOffset offsetBefore;
	 private final ZoneOffset offsetAfter;
	 public static ZoneOffsetTransitionRule of( Month month, int dayOfMonthIndicator, DayOfWeek dayOfWeek, LocalTime time, boolean timeEndOfDay, TimeDefinition timeDefnition, ZoneOffset standardOffset, ZoneOffset offsetBefore, ZoneOffset offsetAfter) {
		 Objects.requireNonNull(month, ""month"");
		 Objects.requireNonNull(time, ""time"");
		 Objects.requireNonNull(timeDefnition, ""timeDefnition"");
		 Objects.requireNonNull(standardOffset, ""standardOffset"");
		 Objects.requireNonNull(offsetBefore, ""offsetBefore"");
		 Objects.requireNonNull(offsetAfter, ""offsetAfter"");
		 if (dayOfMonthIndicator < -28 || dayOfMonthIndicator > 31 || dayOfMonthIndicator == 0) {
			 throw new IllegalArgumentException(""Day of month indicator must be between -28 and 31 inclusive excluding zero"");
		 }
		 if (timeEndOfDay && time.equals(LocalTime.MIDNIGHT) == false) {
			 throw new IllegalArgumentException(""Time must be midnight when end of day flag is true"");
		 }
		 if (time.getNano() != 0) {
			 throw new IllegalArgumentException(""Time's nano-of-second must be zero"");
		 }
		 return new ZoneOffsetTransitionRule(month, dayOfMonthIndicator, dayOfWeek, time, timeEndOfDay, timeDefnition, standardOffset, offsetBefore, offsetAfter);
	 }
	 ZoneOffsetTransitionRule( Month month, int dayOfMonthIndicator, DayOfWeek dayOfWeek, LocalTime time, boolean timeEndOfDay, TimeDefinition timeDefnition, ZoneOffset standardOffset, ZoneOffset offsetBefore, ZoneOffset offsetAfter) {
		 assert time.getNano() == 0;
		 this.month = month;
		 this.dom = (byte) dayOfMonthIndicator;
		 this.dow = dayOfWeek;
		 this.time = time;
		 this.timeEndOfDay = timeEndOfDay;
		 this.timeDefinition = timeDefnition;
		 this.standardOffset = standardOffset;
		 this.offsetBefore = offsetBefore;
		 this.offsetAfter = offsetAfter;
	 }
	 private void readObject(ObjectInputStream s) throws InvalidObjectException {
		 throw new InvalidObjectException(""Deserialization via serialization delegate"");
	 }
	 private Object writeReplace() {
		 return new Ser(Ser.ZOTRULE, this);
	 }
	 void writeExternal(DataOutput out) throws IOException {
		 final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());
		 final int stdOffset = standardOffset.getTotalSeconds();
		 final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;
		 final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;
		 final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);
		 final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);
		 final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);
		 final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);
		 final int dowByte = (dow == null ? 0 : dow.getValue());
		 int b = (month.getValue() << 28) + ((dom + 32) << 22) + (dowByte << 19) + (timeByte << 14) + (timeDefinition.ordinal() << 12) + (stdOffsetByte << 4) + (beforeByte << 2) + afterByte;
		 out.writeInt(b);
		 if (timeByte == 31) {
			 out.writeInt(timeSecs);
		 }
		 if (stdOffsetByte == 255) {
			 out.writeInt(stdOffset);
		 }
		 if (beforeByte == 3) {
			 out.writeInt(offsetBefore.getTotalSeconds());
		 }
		 if (afterByte == 3) {
			 out.writeInt(offsetAfter.getTotalSeconds());
		 }
	 }
	 static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {
		 int data = in.readInt();
		 Month month = Month.of(data >>> 28);
		 int dom = ((data & (63 << 22)) >>> 22) - 32;
		 int dowByte = (data & (7 << 19)) >>> 19;
		 DayOfWeek dow = dowByte == 0 ? null : DayOfWeek.of(dowByte);
		 int timeByte = (data & (31 << 14)) >>> 14;
		 TimeDefinition defn = TimeDefinition.values()[(data & (3 << 12)) >>> 12];
		 int stdByte = (data & (255 << 4)) >>> 4;
		 int beforeByte = (data & (3 << 2)) >>> 2;
		 int afterByte = (data & 3);
		 LocalTime time = (timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24, 0));
		 ZoneOffset std = (stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));
		 ZoneOffset before = (beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));
		 ZoneOffset after = (afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));
		 return ZoneOffsetTransitionRule.of(month, dom, dow, time, timeByte == 24, defn, std, before, after);
	 }
	 public Month getMonth() {
		 return month;
	 }
	 public int getDayOfMonthIndicator() {
		 return dom;
	 }
	 public DayOfWeek getDayOfWeek() {
		 return dow;
	 }
	 public LocalTime getLocalTime() {
		 return time;
	 }
	 public boolean isMidnightEndOfDay() {
		 return timeEndOfDay;
	 }
	 public TimeDefinition getTimeDefinition() {
		 return timeDefinition;
	 }
	 public ZoneOffset getStandardOffset() {
		 return standardOffset;
	 }
	 public ZoneOffset getOffsetBefore() {
		 return offsetBefore;
	 }
	 public ZoneOffset getOffsetAfter() {
		 return offsetAfter;
	 }
	 public ZoneOffsetTransition createTransition(int year) {
		 LocalDate date;
		 if (dom < 0) {
			 date = LocalDate.of(year, month, month.length(IsoChronology.INSTANCE.isLeapYear(year)) + 1 + dom);
			 if (dow != null) {
				 date = date.with(previousOrSame(dow));
			 }
		 }
		 else {
			 date = LocalDate.of(year, month, dom);
			 if (dow != null) {
				 date = date.with(nextOrSame(dow));
			 }
		 }
		 if (timeEndOfDay) {
			 date = date.plusDays(1);
		 }
		 LocalDateTime localDT = LocalDateTime.of(date, time);
		 LocalDateTime transition = timeDefinition.createDateTime(localDT, standardOffset, offsetBefore);
		 return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);
	 }
	 public boolean equals(Object otherRule) {
		 if (otherRule == this) {
			 return true;
		 }
		 if (otherRule instanceof ZoneOffsetTransitionRule) {
			 ZoneOffsetTransitionRule other = (ZoneOffsetTransitionRule) otherRule;
			 return month == other.month && dom == other.dom && dow == other.dow && timeDefinition == other.timeDefinition && time.equals(other.time) && timeEndOfDay == other.timeEndOfDay && standardOffset.equals(other.standardOffset) && offsetBefore.equals(other.offsetBefore) && offsetAfter.equals(other.offsetAfter);
		 }
		 return false;
	 }
	 public int hashCode() {
		 int hash = ((time.toSecondOfDay() + (timeEndOfDay ? 1 : 0)) << 15) + (month.ordinal() << 11) + ((dom + 32) << 5) + ((dow == null ? 7 : dow.ordinal()) << 2) + (timeDefinition.ordinal());
		 return hash ^ standardOffset.hashCode() ^ offsetBefore.hashCode() ^ offsetAfter.hashCode();
	 }
	 public String toString() {
		 StringBuilder buf = new StringBuilder();
		 buf.append(""TransitionRule["") .append(offsetBefore.compareTo(offsetAfter) > 0 ? ""Gap "" : ""Overlap "") .append(offsetBefore).append("" to "").append(offsetAfter).append("", "");
		 if (dow != null) {
			 if (dom == -1) {
				 buf.append(dow.name()).append("" on or before last day of "").append(month.name());
			 }
			 else if (dom < 0) {
				 buf.append(dow.name()).append("" on or before last day minus "").append(-dom - 1).append("" of "").append(month.name());
			 }
			 else {
				 buf.append(dow.name()).append("" on or after "").append(month.name()).append(' ').append(dom);
			 }
		 }
		 else {
			 buf.append(month.name()).append(' ').append(dom);
		 }
		 buf.append("" at "").append(timeEndOfDay ? ""24:00"" : time.toString()) .append("" "").append(timeDefinition) .append("", standard offset "").append(standardOffset) .append(']');
		 return buf.toString();
	 }
	 public static enum TimeDefinition {
		 UTC, WALL, STANDARD;
		 public LocalDateTime createDateTime(LocalDateTime dateTime, ZoneOffset standardOffset, ZoneOffset wallOffset) {
			 switch (this) {
				 case UTC: {
					 int difference = wallOffset.getTotalSeconds() - ZoneOffset.UTC.getTotalSeconds();
					 return dateTime.plusSeconds(difference);
				 }
				 case STANDARD: {
					 int difference = wallOffset.getTotalSeconds() - standardOffset.getTotalSeconds();
					 return dateTime.plusSeconds(difference);
				 }
				 default: return dateTime;
			 }
		 }
	 }
}",1,1,0,0
"public void setDefinitions(String params) {
	 definitions = params;
 }",0,0,0,0
"public class IgfsHandshakeResponse implements Externalizable {
	 private static final long serialVersionUID = 0L;
	 private String igfsName;
	 private long blockSize;
	 private Boolean sampling;
	 public IgfsHandshakeResponse() {
	 }
	 public IgfsHandshakeResponse(String igfsName, long blockSize, Boolean sampling) {
		 this.igfsName = igfsName;
		 this.blockSize = blockSize;
		 this.sampling = sampling;
	 }
	 public String igfsName() {
		 return igfsName;
	 }
	 public long blockSize() {
		 return blockSize;
	 }
	 public Boolean sampling() {
		 return sampling;
	 }
	 public void writeExternal(ObjectOutput out) throws IOException {
		 U.writeString(out, igfsName);
		 out.writeLong(blockSize);
		 if (sampling != null) {
			 out.writeBoolean(true);
			 out.writeBoolean(sampling);
		 }
		 else out.writeBoolean(false);
	 }
	 public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
		 igfsName = U.readString(in);
		 blockSize = in.readLong();
		 if (in.readBoolean()) sampling = in.readBoolean();
	 }
}",0,1,0,0
"public static class InvalidACLException extends KeeperException {
	 public InvalidACLException() {
		 super(Code.INVALIDACL);
	 }
	 public InvalidACLException(String path) {
		 super(Code.INVALIDACL, path);
	 }
 }",0,0,0,0
"private JPanel createNetworkPanel() {
	JPanel p = new JPanel();
	p.setLayout(null);
	p.setOpaque(false);
	int y = 20;
	int h = 50;
	h = 30;
	JLabel lbl1 = new JLabel(StringResource.get(""DESC_NET""));
	lbl1.setForeground(Color.WHITE);
	lbl1.setFont(FontResource.getItemFont());
	lbl1.setBounds(15, y, 350 - 30, h);
	p.add(lbl1);
	y += h;
	y += 20;
	h = 25;
	JLabel lbl2 = new JLabel(StringResource.get(""DESC_NET1""));
	lbl2.setForeground(Color.WHITE);
	lbl2.setFont(FontResource.getNormalFont());
	lbl2.setBounds(15, y, 200, h);
	p.add(lbl2);
	y += 5;
	h = 20;
	cmbTimeout = new JComboBox<String>(new String[] {
	 ""10"", ""30"", ""60"", ""120"", ""180"", ""360"", ""N/A"" }
	);
	cmbTimeout.setBackground(ColorResource.getDarkerBgColor());
	cmbTimeout.setBounds(250, y, 75, h);
	cmbTimeout.setRenderer(new SimpleListRenderer());
	p.add(cmbTimeout);
	y += h;
	y += 10;
	h = 25;
	JLabel lbl3 = new JLabel(StringResource.get(""DESC_NET2""));
	lbl3.setForeground(Color.WHITE);
	lbl3.setFont(FontResource.getNormalFont());
	lbl3.setBounds(15, y, 200, h);
	p.add(lbl3);
	y += 5;
	h = 20;
	cmbSeg = new JComboBox<String>(new String[] {
	 ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10"", ""11"", ""12"",""13"", ""14"", ""15"", ""16"", ""20"", ""25"", ""30"", ""32"" }
	);
	cmbSeg.setBackground(ColorResource.getDarkerBgColor());
	cmbSeg.setBounds(250, y, 75, h);
	cmbSeg.setRenderer(new SimpleListRenderer());
	p.add(cmbSeg);
	y += h;
	y += 10;
	h = 25;
	JLabel lbl4 = new JLabel(StringResource.get(""DESC_NET3""));
	lbl4.setForeground(Color.WHITE);
	lbl4.setFont(FontResource.getNormalFont());
	lbl4.setBounds(15, y, 200, h);
	p.add(lbl4);
	y += 5;
	h = 20;
	cmbTcp = new JComboBox<String>(new String[] {
	 ""8"", ""16"", ""32"", ""64"" }
	);
	cmbTcp.setBackground(ColorResource.getDarkerBgColor());
	cmbTcp.setBounds(250, y, 75, h);
	cmbTcp.setRenderer(new SimpleListRenderer());
	p.add(cmbTcp);
	y += h;
	y += 50;
	h = 30;
	JLabel lbl51 = new JLabel(StringResource.get(""SPEED_LIMIT_TITLE""));
	lbl51.setForeground(Color.WHITE);
	lbl51.setFont(FontResource.getItemFont());
	lbl51.setBounds(15, y, 350 - 30, h);
	p.add(lbl51);
	y += h;
	h = 30;
	JLabel lbl71 = new JLabel(StringResource.get(""MSG_SPEED_LIMIT""));
	lbl71.setForeground(Color.WHITE);
	lbl71.setFont(FontResource.getNormalFont());
	lbl71.setBounds(15, y, 350 - 30, h);
	p.add(lbl71);
	y += h;
	h = 25;
	txtSpeedLimit = new JTextField();
	txtSpeedLimit.setBounds(15, y, 350 - 250, h);
	txtSpeedLimit.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtSpeedLimit.setEditable(true);
	txtSpeedLimit.setCaretColor(ColorResource.getActiveTabColor());
	txtSpeedLimit.setForeground(Color.WHITE);
	txtSpeedLimit.setOpaque(false);
	p.add(txtSpeedLimit);
	y += h;
	y += 50;
	h = 30;
	JLabel lbl5 = new JLabel(StringResource.get(""DESC_NET4""));
	lbl5.setForeground(Color.WHITE);
	lbl5.setFont(FontResource.getItemFont());
	lbl5.setBounds(15, y, 350 - 30, h);
	p.add(lbl5);
	y += h;
	y += 10;
	h = 30;
	chkUsePac = createCheckBox(""DESC_NET5"");
	chkUsePac.setBounds(15, y, 350 - 30, h);
	p.add(chkUsePac);
	y += h;
	h = 25;
	txtPACUrl = new JTextField();
	txtPACUrl.setBounds(15, y, 350 - 30 - 10, h);
	txtPACUrl.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtPACUrl.setEditable(true);
	txtPACUrl.setForeground(Color.WHITE);
	txtPACUrl.setCaretColor(ColorResource.getActiveTabColor());
	txtPACUrl.setOpaque(false);
	p.add(txtPACUrl);
	y += h;
	y += 10;
	h = 30;
	chkUseProxy = createCheckBox(""DESC_NET6"");
	chkUseProxy.setBounds(15, y, 350 - 30, h);
	p.add(chkUseProxy);
	y += h;
	h = 25;
	txtProxyHostnPort = new JTextField();
	txtProxyHostnPort.setBounds(15, y, 350 - 30 - 10, h);
	txtProxyHostnPort.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtProxyHostnPort.setEditable(true);
	txtProxyHostnPort.setCaretColor(ColorResource.getActiveTabColor());
	txtProxyHostnPort.setForeground(Color.WHITE);
	txtProxyHostnPort.setOpaque(false);
	p.add(txtProxyHostnPort);
	y += h;
	y += 10;
	h = 30;
	chkUseSocks = createCheckBox(""DESC_NET9"");
	chkUseSocks.setBounds(15, y, 350 - 30, h);
	p.add(chkUseSocks);
	y += h;
	h = 25;
	txtSocksHostnPort = new JTextField();
	txtSocksHostnPort.setBounds(15, y, 350 - 30 - 10, h);
	txtSocksHostnPort.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtSocksHostnPort.setEditable(true);
	txtSocksHostnPort.setCaretColor(ColorResource.getActiveTabColor());
	txtSocksHostnPort.setForeground(Color.WHITE);
	txtSocksHostnPort.setOpaque(false);
	p.add(txtSocksHostnPort);
	y += h;
	y += 10;
	h = 30;
	JLabel lbl6 = new JLabel(StringResource.get(""DESC_NET7""));
	lbl6.setForeground(Color.WHITE);
	lbl6.setFont(FontResource.getNormalFont());
	lbl6.setBounds(15, y, 350 - 30, h);
	p.add(lbl6);
	y += h;
	h = 25;
	txtProxyUser = new JTextField();
	txtProxyUser.setBounds(15, y, 350 - 30 - 10, h);
	txtProxyUser.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtProxyUser.setCaretColor(ColorResource.getActiveTabColor());
	txtProxyUser.setEditable(true);
	txtProxyUser.setForeground(Color.WHITE);
	txtProxyUser.setOpaque(false);
	p.add(txtProxyUser);
	y += h;
	y += 10;
	h = 30;
	JLabel lbl7 = new JLabel(StringResource.get(""DESC_NET8""));
	lbl7.setForeground(Color.WHITE);
	lbl7.setFont(FontResource.getNormalFont());
	lbl7.setBounds(15, y, 350 - 30, h);
	p.add(lbl7);
	y += h;
	h = 25;
	txtProxyPass = new JPasswordField();
	txtProxyPass.setBounds(15, y, 320 - 10, h);
	txtProxyPass.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtProxyPass.setCaretColor(ColorResource.getActiveTabColor());
	txtProxyPass.setEditable(true);
	txtProxyPass.setForeground(Color.WHITE);
	txtProxyPass.setOpaque(false);
	p.add(txtProxyPass);
	y += h;
	y += 50;
	p.setPreferredSize(new Dimension(350, y));
	return p;
}",0,0,1,0
"public class JobTracker implements MRConstants, InterTrackerProtocol, JobSubmissionProtocol {
	 static long JOBINIT_SLEEP_INTERVAL = 2000;
	 static long RETIRE_JOB_INTERVAL;
	 static long RETIRE_JOB_CHECK_INTERVAL;
	 static float TASK_ALLOC_EPSILON;
	 static float PAD_FRACTION;
	 static float MIN_SLOTS_FOR_PADDING;
	 private static NumberFormat idFormat = NumberFormat.getInstance();
	 static {
		 idFormat.setMinimumIntegerDigits(4);
		 idFormat.setGroupingUsed(false);
	 }
	 static {
		 new TaskTrackerStatus();
	 }
	 private int nextJobId = 1;
	 public static final Logger LOG = LogFormatter.getLogger(""org.apache.hadoop.mapred.JobTracker"");
	 private static JobTracker tracker = null;
	 public static void startTracker(Configuration conf) throws IOException {
		 if (tracker != null) throw new IOException(""JobTracker already running."");
		 while (true) {
			 try {
				 tracker = new JobTracker(conf);
				 break;
			 }
			 catch (IOException e) {
				 LOG.log(Level.WARNING, ""Starting tracker"", e);
			 }
			 try {
				 Thread.sleep(1000);
			 }
			 catch (InterruptedException e) {
			 }
		 }
		 tracker.offerService();
	 }
	 public static JobTracker getTracker() {
		 return tracker;
	 }
	 private class ExpireLaunchingTasks implements Runnable {
		 private volatile boolean shouldRun = true;
		 private Map launchingTasks = new LinkedHashMap();
		 public void run() {
			 try {
				 while (shouldRun) {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL/3);
					 long now = System.currentTimeMillis();
					 LOG.fine(""Starting launching task sweep"");
					 synchronized (launchingTasks) {
						 Iterator itr = launchingTasks.entrySet().iterator();
						 while (itr.hasNext()) {
							 Map.Entry pair = (Map.Entry) itr.next();
							 String taskId = (String) pair.getKey();
							 long age = now - ((Long) pair.getValue()).longValue();
							 LOG.fine(taskId + "" is "" + age + "" ms old."");
							 if (age > TASKTRACKER_EXPIRY_INTERVAL) {
								 LOG.info(""Launching task "" + taskId + "" timed out."");
								 TaskInProgress tip = null;
								 synchronized (JobTracker.this) {
									 tip = (TaskInProgress) taskidToTIPMap.get(taskId);
								 }
								 if (tip != null) {
									 JobInProgress job = tip.getJob();
									 job.failedTask(tip, taskId, ""Error launching task"", ""n/a"", ""n/a"");
								 }
								 itr.remove();
							 }
							 else {
								 break;
							 }
						 }
					 }
				 }
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 public void addNewTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.put(taskName, new Long(System.currentTimeMillis()));
			 }
		 }
		 public void removeTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.remove(taskName);
			 }
		 }
		 public void stop() {
			 shouldRun = false;
		 }
	 }
	 class ExpireTrackers implements Runnable {
		 boolean shouldRun = true;
		 public ExpireTrackers() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL / 3);
				 }
				 catch (InterruptedException ie) {
				 }
				 synchronized (taskTrackers) {
					 synchronized (trackerExpiryQueue) {
						 long now = System.currentTimeMillis();
						 TaskTrackerStatus leastRecent = null;
						 while ((trackerExpiryQueue.size() > 0) && ((leastRecent = (TaskTrackerStatus) trackerExpiryQueue.first()) != null) && (now - leastRecent.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL)) {
							 trackerExpiryQueue.remove(leastRecent);
							 String trackerName = leastRecent.getTrackerName();
							 TaskTrackerStatus newProfile = (TaskTrackerStatus) taskTrackers.get(leastRecent.getTrackerName());
							 if (newProfile != null) {
								 if (now - newProfile.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL) {
									 updateTaskTrackerStatus(trackerName, null);
									 lostTaskTracker(leastRecent.getTrackerName(), leastRecent.getHost());
								 }
								 else {
									 trackerExpiryQueue.add(newProfile);
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 public void stopTracker() {
			 shouldRun = false;
		 }
	 }
	 class RetireJobs implements Runnable {
		 boolean shouldRun = true;
		 public RetireJobs() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(RETIRE_JOB_CHECK_INTERVAL);
				 }
				 catch (InterruptedException ie) {
				 }
				 synchronized (jobs) {
					 synchronized (jobInitQueue) {
						 synchronized (jobsByArrival) {
							 for (Iterator it = jobs.keySet().iterator();
							 it.hasNext();
							 ) {
								 String jobid = (String) it.next();
								 JobInProgress job = (JobInProgress) jobs.get(jobid);
								 if (job.getStatus().getRunState() != JobStatus.RUNNING && job.getStatus().getRunState() != JobStatus.PREP && (job.getFinishTime() + RETIRE_JOB_INTERVAL < System.currentTimeMillis())) {
									 it.remove();
									 jobInitQueue.remove(job);
									 jobsByArrival.remove(job);
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 public void stopRetirer() {
			 shouldRun = false;
		 }
	 }
	 class JobInitThread implements Runnable {
		 boolean shouldRun = true;
		 public JobInitThread() {
		 }
		 public void run() {
			 while (shouldRun) {
				 JobInProgress job = null;
				 synchronized (jobInitQueue) {
					 if (jobInitQueue.size() > 0) {
						 job = (JobInProgress) jobInitQueue.elementAt(0);
						 jobInitQueue.remove(job);
					 }
					 else {
						 try {
							 jobInitQueue.wait(JOBINIT_SLEEP_INTERVAL);
						 }
						 catch (InterruptedException iex) {
						 }
					 }
				 }
				 try {
					 if (job != null) {
						 job.initTasks();
					 }
				 }
				 catch (Exception e) {
					 LOG.log(Level.WARNING, ""job init failed"", e);
					 job.kill();
				 }
			 }
		 }
		 public void stopIniter() {
			 shouldRun = false;
		 }
	 }
	 int port;
	 String localMachine;
	 long startTime;
	 int totalSubmissions = 0;
	 Random r = new Random();
	 private int maxCurrentTasks;
	 TreeMap jobs = new TreeMap();
	 Vector jobsByArrival = new Vector();
	 TreeMap taskidToTIPMap = new TreeMap();
	 TreeMap taskidToTrackerMap = new TreeMap();
	 TreeMap trackerToTaskMap = new TreeMap();
	 int totalMaps = 0;
	 int totalReduces = 0;
	 private TreeMap taskTrackers = new TreeMap();
	 Vector jobInitQueue = new Vector();
	 ExpireTrackers expireTrackers = new ExpireTrackers();
	 RetireJobs retireJobs = new RetireJobs();
	 JobInitThread initJobs = new JobInitThread();
	 ExpireLaunchingTasks expireLaunchingTasks = new ExpireLaunchingTasks();
	 Thread expireLaunchingTaskThread = new Thread(expireLaunchingTasks);
	 TreeSet trackerExpiryQueue = new TreeSet(new Comparator() {
		 public int compare(Object o1, Object o2) {
			 TaskTrackerStatus p1 = (TaskTrackerStatus) o1;
			 TaskTrackerStatus p2 = (TaskTrackerStatus) o2;
			 if (p1.getLastSeen() < p2.getLastSeen()) {
				 return -1;
			 }
			 else if (p1.getLastSeen() > p2.getLastSeen()) {
				 return 1;
			 }
			 else {
				 return (p1.getTrackerName().compareTo(p2.getTrackerName()));
			 }
		 }
	 }
	);
	 JobTrackerInfoServer infoServer;
	 int infoPort;
	 Server interTrackerServer;
	 static final String SUBDIR = ""jobTracker"";
	 FileSystem fs;
	 Path systemDir;
	 private Configuration conf;
	 JobTracker(Configuration conf) throws IOException {
		 maxCurrentTasks = conf.getInt(""mapred.tasktracker.tasks.maximum"", 2);
		 RETIRE_JOB_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.interval"", 24 * 60 * 60 * 1000);
		 RETIRE_JOB_CHECK_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.check"", 60 * 1000);
		 TASK_ALLOC_EPSILON = conf.getFloat(""mapred.jobtracker.taskalloc.loadbalance.epsilon"", 0.2f);
		 PAD_FRACTION = conf.getFloat(""mapred.jobtracker.taskalloc.capacitypad"", 0.1f);
		 MIN_SLOTS_FOR_PADDING = 3 * maxCurrentTasks;
		 this.conf = conf;
		 JobConf jobConf = new JobConf(conf);
		 this.systemDir = jobConf.getSystemDir();
		 this.fs = FileSystem.get(conf);
		 fs.delete(systemDir);
		 fs.mkdirs(systemDir);
		 jobConf.deleteLocalFiles(SUBDIR);
		 InetSocketAddress addr = getAddress(conf);
		 this.localMachine = addr.getHostName();
		 this.port = addr.getPort();
		 this.interTrackerServer = RPC.getServer(this, addr.getPort(), 10, false, conf);
		 this.interTrackerServer.start();
		 Properties p = System.getProperties();
		 for (Iterator it = p.keySet().iterator();
		 it.hasNext();
		 ) {
			 String key = (String) it.next();
			 String val = (String) p.getProperty(key);
			 LOG.info(""Property '"" + key + ""' is "" + val);
		 }
		 this.infoPort = conf.getInt(""mapred.job.tracker.info.port"", 50030);
		 this.infoServer = new JobTrackerInfoServer(this, infoPort);
		 this.infoServer.start();
		 this.startTime = System.currentTimeMillis();
		 new Thread(this.expireTrackers).start();
		 new Thread(this.retireJobs).start();
		 new Thread(this.initJobs).start();
		 expireLaunchingTaskThread.start();
	 }
	 public static InetSocketAddress getAddress(Configuration conf) {
		 String jobTrackerStr = conf.get(""mapred.job.tracker"", ""localhost:8012"");
		 int colon = jobTrackerStr.indexOf("":"");
		 if (colon < 0) {
			 throw new RuntimeException(""Bad mapred.job.tracker: ""+jobTrackerStr);
		 }
		 String jobTrackerName = jobTrackerStr.substring(0, colon);
		 int jobTrackerPort = Integer.parseInt(jobTrackerStr.substring(colon+1));
		 return new InetSocketAddress(jobTrackerName, jobTrackerPort);
	 }
	 public void offerService() {
		 try {
			 this.interTrackerServer.join();
		 }
		 catch (InterruptedException ie) {
		 }
	 }
	 void createTaskEntry(String taskid, String taskTracker, TaskInProgress tip) {
		 LOG.info(""Adding task '"" + taskid + ""' to tip "" + tip.getTIPId() + "", for tracker '"" + taskTracker + ""'"");
		 taskidToTrackerMap.put(taskid, taskTracker);
		 TreeSet taskset = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskset == null) {
			 taskset = new TreeSet();
			 trackerToTaskMap.put(taskTracker, taskset);
		 }
		 taskset.add(taskid);
		 taskidToTIPMap.put(taskid, tip);
	 }
	 void removeTaskEntry(String taskid) {
		 String tracker = (String) taskidToTrackerMap.remove(taskid);
		 TreeSet trackerSet = (TreeSet) trackerToTaskMap.get(tracker);
		 if (trackerSet != null) {
			 trackerSet.remove(taskid);
		 }
		 taskidToTIPMap.remove(taskid);
	 }
	 public int getTotalSubmissions() {
		 return totalSubmissions;
	 }
	 public String getJobTrackerMachine() {
		 return localMachine;
	 }
	 public int getTrackerPort() {
		 return port;
	 }
	 public int getInfoPort() {
		 return infoPort;
	 }
	 public long getStartTime() {
		 return startTime;
	 }
	 public Vector runningJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector failedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.FAILED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector completedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.SUCCEEDED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Collection taskTrackers() {
		 synchronized (taskTrackers) {
			 return taskTrackers.values();
		 }
	 }
	 public TaskTrackerStatus getTaskTracker(String trackerID) {
		 synchronized (taskTrackers) {
			 return (TaskTrackerStatus) taskTrackers.get(trackerID);
		 }
	 }
	 private boolean updateTaskTrackerStatus(String trackerName, TaskTrackerStatus status) {
		 TaskTrackerStatus oldStatus = (TaskTrackerStatus) taskTrackers.get(trackerName);
		 if (oldStatus != null) {
			 totalMaps -= oldStatus.countMapTasks();
			 totalReduces -= oldStatus.countReduceTasks();
			 if (status == null) {
				 taskTrackers.remove(trackerName);
			 }
		 }
		 if (status != null) {
			 totalMaps += status.countMapTasks();
			 totalReduces += status.countReduceTasks();
			 taskTrackers.put(trackerName, status);
		 }
		 return oldStatus != null;
	 }
	 public synchronized int emitHeartbeat(TaskTrackerStatus trackerStatus, boolean initialContact) {
		 String trackerName = trackerStatus.getTrackerName();
		 trackerStatus.setLastSeen(System.currentTimeMillis());
		 synchronized (taskTrackers) {
			 synchronized (trackerExpiryQueue) {
				 boolean seenBefore = updateTaskTrackerStatus(trackerName, trackerStatus);
				 if (initialContact) {
					 if (seenBefore) {
						 lostTaskTracker(trackerName, trackerStatus.getHost());
					 }
				 }
				 else {
					 if (!seenBefore) {
						 return InterTrackerProtocol.UNKNOWN_TASKTRACKER;
					 }
				 }
				 if (initialContact) {
					 trackerExpiryQueue.add(trackerStatus);
				 }
			 }
		 }
		 updateTaskStatuses(trackerStatus);
		 return InterTrackerProtocol.TRACKERS_OK;
	 }
	 public synchronized Task pollForNewTask(String taskTracker) {
		 int avgMaps = 0;
		 int avgReduces = 0;
		 int numTaskTrackers;
		 TaskTrackerStatus tts;
		 synchronized (taskTrackers) {
			 numTaskTrackers = taskTrackers.size();
			 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
		 }
		 if (numTaskTrackers > 0) {
			 avgMaps = totalMaps / numTaskTrackers;
			 avgReduces = totalReduces / numTaskTrackers;
		 }
		 int totalCapacity = numTaskTrackers * maxCurrentTasks;
		 if (tts == null) {
			 LOG.warning(""Unknown task tracker polling;
			 ignoring: "" + taskTracker);
			 return null;
		 }
		 int numMaps = tts.countMapTasks();
		 int numReduces = tts.countReduceTasks();
		 synchronized (jobsByArrival) {
			 if ((numMaps < maxCurrentTasks) && (numMaps <= (avgMaps + TASK_ALLOC_EPSILON))) {
				 int totalNeededMaps = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
						 continue;
					 }
					 Task t = job.obtainNewMapTask(taskTracker, tts);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 return t;
					 }
					 totalNeededMaps += job.desiredMaps();
					 double padding = 0;
					 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, totalNeededMaps * PAD_FRACTION);
					 }
					 if (totalNeededMaps + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
			 if ((numReduces < maxCurrentTasks) && (numReduces <= (avgReduces + TASK_ALLOC_EPSILON))) {
				 int totalNeededReduces = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
						 continue;
					 }
					 Task t = job.obtainNewReduceTask(taskTracker, tts);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 return t;
					 }
					 totalNeededReduces += job.desiredReduces();
					 double padding = 0;
					 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, totalNeededReduces * PAD_FRACTION);
					 }
					 if (totalNeededReduces + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 public synchronized String[] pollForTaskWithClosedJob(String taskTracker) {
		 TreeSet taskIds = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskIds != null) {
			 ArrayList list = new ArrayList();
			 for (Iterator it = taskIds.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.shouldCloseForClosedJob(taskId)) {
					 list.add(taskId);
				 }
			 }
			 return (String[]) list.toArray(new String[list.size()]);
		 }
		 return null;
	 }
	 public synchronized MapOutputLocation[] locateMapOutputs(String taskId, String[][] mapTasksNeeded) {
		 ArrayList v = new ArrayList();
		 for (int i = 0;
		 i < mapTasksNeeded.length;
		 i++) {
			 for (int j = 0;
			 j < mapTasksNeeded[i].length;
			 j++) {
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(mapTasksNeeded[i][j]);
				 if (tip != null && tip.isComplete(mapTasksNeeded[i][j])) {
					 String trackerId = (String) taskidToTrackerMap.get(mapTasksNeeded[i][j]);
					 TaskTrackerStatus tracker;
					 synchronized (taskTrackers) {
						 tracker = (TaskTrackerStatus) taskTrackers.get(trackerId);
					 }
					 v.add(new MapOutputLocation(mapTasksNeeded[i][j], tracker.getHost(), tracker.getPort()));
					 break;
				 }
			 }
		 }
		 Collections.shuffle(v);
		 return (MapOutputLocation[]) v.toArray(new MapOutputLocation[v.size()]);
	 }
	 public synchronized String getFilesystemName() throws IOException {
		 return fs.getName();
	 }
	 public synchronized JobStatus submitJob(String jobFile) throws IOException {
		 totalSubmissions++;
		 JobInProgress job = new JobInProgress(jobFile, this, this.conf);
		 synchronized (jobs) {
			 synchronized (jobsByArrival) {
				 synchronized (jobInitQueue) {
					 jobs.put(job.getProfile().getJobId(), job);
					 jobsByArrival.add(job);
					 jobInitQueue.add(job);
					 jobInitQueue.notifyAll();
				 }
			 }
		 }
		 return job.getStatus();
	 }
	 public synchronized ClusterStatus getClusterStatus() {
		 synchronized (taskTrackers) {
			 return new ClusterStatus(taskTrackers.size(), totalMaps, totalReduces, maxCurrentTasks);
		 }
	 }
	 public synchronized void killJob(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 job.kill();
	 }
	 public synchronized JobProfile getJobProfile(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getProfile();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized JobStatus getJobStatus(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getStatus();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized TaskReport[] getMapTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeMapTasks = job.reportTasksInProgress(true, true);
			 for (Iterator it = completeMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteMapTasks = job.reportTasksInProgress(true, false);
			 for (Iterator it = incompleteMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 public synchronized TaskReport[] getReduceTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeReduceTasks = job.reportTasksInProgress(false, true);
			 for (Iterator it = completeReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteReduceTasks = job.reportTasksInProgress(false, false);
			 for (Iterator it = incompleteReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 TaskStatus[] getTaskStatuses(String jobid, String tipid){
		JobInProgress job = (JobInProgress) jobs.get(jobid);
		if (job == null){
			 return new TaskStatus[0];
		}
		TaskInProgress tip = (TaskInProgress) job.getTaskInProgress(tipid);
		if (tip == null){
			 return new TaskStatus[0];
		}
		return tip.getTaskStatuses();
	 }
	 public JobInProgress getJob(String jobid) {
		 return (JobInProgress) jobs.get(jobid);
	 }
	 String createUniqueId() {
		 return idFormat.format(nextJobId++);
	 }
	 void updateTaskStatuses(TaskTrackerStatus status) {
		 for (Iterator it = status.taskReports();
		 it.hasNext();
		 ) {
			 TaskStatus report = (TaskStatus) it.next();
			 report.setHostname(status.getHost());
			 String taskId = report.getTaskId();
			 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
			 if (tip == null) {
				 LOG.info(""Serious problem. While updating status, cannot find taskid "" + report.getTaskId());
			 }
			 else {
				 expireLaunchingTasks.removeTask(taskId);
				 JobInProgress job = tip.getJob();
				 if (report.getRunState() == TaskStatus.SUCCEEDED) {
					 job.completedTask(tip, report);
				 }
				 else if (report.getRunState() == TaskStatus.FAILED) {
					 job.failedTask(tip, report.getTaskId(), report, status.getTrackerName());
				 }
			 }
		 }
	 }
	 void lostTaskTracker(String trackerName, String hostname) {
		 LOG.info(""Lost tracker '"" + trackerName + ""'"");
		 TreeSet lostTasks = (TreeSet) trackerToTaskMap.get(trackerName);
		 trackerToTaskMap.remove(trackerName);
		 if (lostTasks != null) {
			 for (Iterator it = lostTasks.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.isMapTask() || !tip.isComplete()) {
					 JobInProgress job = tip.getJob();
					 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
						 job.failedTask(tip, taskId, ""Lost task tracker"", hostname, trackerName);
					 }
				 }
			 }
		 }
	 }
	 public static void main(String argv[]) throws IOException, InterruptedException {
		 if (argv.length != 0) {
			 System.out.println(""usage: JobTracker"");
			 System.exit(-1);
		 }
		 Configuration conf=new Configuration();
		 LogFormatter.initFileHandler( conf, ""jobtracker"" );
		 startTracker(conf);
	 }
}",1,0,0,0
"public class Header {
	 public String type;
	 public String algorithm;
	 public String contentType;
}",0,1,0,0
"public class XMLEntityManager implements XMLComponent, XMLEntityResolver {
	 public static final int DEFAULT_BUFFER_SIZE = 2048;
	 public static final int DEFAULT_XMLDECL_BUFFER_SIZE = 64;
	 public static final int DEFAULT_INTERNAL_BUFFER_SIZE = 512;
	 protected static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
	 protected static final String EXTERNAL_GENERAL_ENTITIES = Constants.SAX_FEATURE_PREFIX + Constants.EXTERNAL_GENERAL_ENTITIES_FEATURE;
	 protected static final String EXTERNAL_PARAMETER_ENTITIES = Constants.SAX_FEATURE_PREFIX + Constants.EXTERNAL_PARAMETER_ENTITIES_FEATURE;
	 protected static final String ALLOW_JAVA_ENCODINGS = Constants.XERCES_FEATURE_PREFIX + Constants.ALLOW_JAVA_ENCODINGS_FEATURE;
	 protected static final String WARN_ON_DUPLICATE_ENTITYDEF = Constants.XERCES_FEATURE_PREFIX +Constants.WARN_ON_DUPLICATE_ENTITYDEF_FEATURE;
	 protected static final String STANDARD_URI_CONFORMANT = Constants.XERCES_FEATURE_PREFIX +Constants.STANDARD_URI_CONFORMANT_FEATURE;
	protected static final String PARSER_SETTINGS = Constants.XERCES_FEATURE_PREFIX + Constants.PARSER_SETTINGS;
	 protected static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
	 protected static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
	 protected static final String ENTITY_RESOLVER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
	 protected static final String VALIDATION_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY;
	 protected static final String BUFFER_SIZE = Constants.XERCES_PROPERTY_PREFIX + Constants.BUFFER_SIZE_PROPERTY;
	 protected static final String SECURITY_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.SECURITY_MANAGER_PROPERTY;
	 private static final String[] RECOGNIZED_FEATURES = {
	 VALIDATION, EXTERNAL_GENERAL_ENTITIES, EXTERNAL_PARAMETER_ENTITIES, ALLOW_JAVA_ENCODINGS, WARN_ON_DUPLICATE_ENTITYDEF, STANDARD_URI_CONFORMANT }
	;
	 private static final Boolean[] FEATURE_DEFAULTS = {
	 null, Boolean.TRUE, Boolean.TRUE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE }
	;
	 private static final String[] RECOGNIZED_PROPERTIES = {
	 SYMBOL_TABLE, ERROR_REPORTER, ENTITY_RESOLVER, VALIDATION_MANAGER, BUFFER_SIZE, SECURITY_MANAGER, }
	;
	 private static final Object[] PROPERTY_DEFAULTS = {
	 null, null, null, null, new Integer(DEFAULT_BUFFER_SIZE), null, }
	;
	 private static final String XMLEntity = ""[xml]"".intern();
	 private static final String DTDEntity = ""[dtd]"".intern();
	 private static final boolean DEBUG_BUFFER = false;
	 private static final boolean DEBUG_ENTITIES = false;
	 private static final boolean DEBUG_ENCODINGS = false;
	 private static final boolean DEBUG_RESOLVER = false;
	 protected boolean fValidation;
	 protected boolean fExternalGeneralEntities = true;
	 protected boolean fExternalParameterEntities = true;
	 protected boolean fAllowJavaEncodings;
	 protected boolean fWarnDuplicateEntityDef;
	 protected boolean fStrictURI;
	 protected SymbolTable fSymbolTable;
	 protected XMLErrorReporter fErrorReporter;
	 protected XMLEntityResolver fEntityResolver;
	 protected ValidationManager fValidationManager;
	 protected int fBufferSize = DEFAULT_BUFFER_SIZE;
	 protected SecurityManager fSecurityManager = null;
	 protected boolean fStandalone;
	 protected boolean fHasPEReferences;
	 protected boolean fInExternalSubset = false;
	 protected XMLEntityHandler fEntityHandler;
	 protected XMLEntityScanner fEntityScanner;
	 protected XMLEntityScanner fXML10EntityScanner;
	 protected XMLEntityScanner fXML11EntityScanner;
	 protected int fEntityExpansionLimit = 0;
	 protected int fEntityExpansionCount = 0;
	 protected final Hashtable fEntities = new Hashtable();
	 protected final Stack fEntityStack = new Stack();
	 protected ScannedEntity fCurrentEntity;
	 protected Hashtable fDeclaredEntities;
	 private final XMLResourceIdentifierImpl fResourceIdentifier = new XMLResourceIdentifierImpl();
	 private final Augmentations fEntityAugs = new AugmentationsImpl();
	 private final ByteBufferPool fSmallByteBufferPool = new ByteBufferPool(fBufferSize);
	 private final ByteBufferPool fLargeByteBufferPool = new ByteBufferPool(fBufferSize << 1);
	 private byte[] fTempByteBuffer = null;
	 private final CharacterBufferPool fCharacterBufferPool = new CharacterBufferPool(fBufferSize, DEFAULT_INTERNAL_BUFFER_SIZE);
	 public XMLEntityManager() {
		 this(null);
	 }
	 public XMLEntityManager(XMLEntityManager entityManager) {
		 fDeclaredEntities = entityManager != null ? entityManager.getDeclaredEntities() : null;
		 setScannerVersion(Constants.XML_VERSION_1_0);
	 }
	 public void setStandalone(boolean standalone) {
		 fStandalone = standalone;
	 }
	 public boolean isStandalone() {
		 return fStandalone;
	 }
	 final void notifyHasPEReferences() {
		 fHasPEReferences = true;
	 }
	 final boolean hasPEReferences() {
		 return fHasPEReferences;
	 }
	 public void setEntityHandler(XMLEntityHandler entityHandler) {
		 fEntityHandler = entityHandler;
	 }
	 public XMLResourceIdentifier getCurrentResourceIdentifier() {
		 return fResourceIdentifier;
	 }
	 public ScannedEntity getCurrentEntity() {
		 return fCurrentEntity;
	 }
	 public void addInternalEntity(String name, String text) {
		 if (!fEntities.containsKey(name)) {
			 Entity entity = new InternalEntity(name, text, fInExternalSubset);
			 fEntities.put(name, entity);
		 }
		 else{
			 if(fWarnDuplicateEntityDef){
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_DUPLICATE_ENTITY_DEFINITION"", new Object[]{
				 name }
				, XMLErrorReporter.SEVERITY_WARNING );
			 }
		 }
	 }
	 public void addExternalEntity(String name, String publicId, String literalSystemId, String baseSystemId) throws IOException {
		 if (!fEntities.containsKey(name)) {
			 if (baseSystemId == null) {
				 int size = fEntityStack.size();
				 if (size == 0 && fCurrentEntity != null && fCurrentEntity.entityLocation != null) {
					 baseSystemId = fCurrentEntity.entityLocation.getExpandedSystemId();
				 }
				 for (int i = size - 1;
				 i >= 0 ;
				 i--) {
					 ScannedEntity externalEntity = (ScannedEntity)fEntityStack.elementAt(i);
					 if (externalEntity.entityLocation != null && externalEntity.entityLocation.getExpandedSystemId() != null) {
						 baseSystemId = externalEntity.entityLocation.getExpandedSystemId();
						 break;
					 }
				 }
			 }
			 Entity entity = new ExternalEntity(name, new XMLEntityDescriptionImpl(name, publicId, literalSystemId, baseSystemId, expandSystemId(literalSystemId, baseSystemId, false)), null, fInExternalSubset);
			 fEntities.put(name, entity);
		 }
		 else{
			 if(fWarnDuplicateEntityDef){
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_DUPLICATE_ENTITY_DEFINITION"", new Object[]{
				 name }
				, XMLErrorReporter.SEVERITY_WARNING );
			 }
		 }
	 }
	 public boolean isExternalEntity(String entityName) {
		 Entity entity = (Entity)fEntities.get(entityName);
		 if (entity == null) {
			 return false;
		 }
		 return entity.isExternal();
	 }
	 public boolean isEntityDeclInExternalSubset(String entityName) {
		 Entity entity = (Entity)fEntities.get(entityName);
		 if (entity == null) {
			 return false;
		 }
		 return entity.isEntityDeclInExternalSubset();
	 }
	 public void addUnparsedEntity(String name, String publicId, String systemId, String baseSystemId, String notation) {
		 if (!fEntities.containsKey(name)) {
			 Entity entity = new ExternalEntity(name, new XMLEntityDescriptionImpl(name, publicId, systemId, baseSystemId, null), notation, fInExternalSubset);
			 fEntities.put(name, entity);
		 }
		 else{
			 if(fWarnDuplicateEntityDef){
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_DUPLICATE_ENTITY_DEFINITION"", new Object[]{
				 name }
				, XMLErrorReporter.SEVERITY_WARNING );
			 }
		 }
	 }
	 public boolean isUnparsedEntity(String entityName) {
		 Entity entity = (Entity)fEntities.get(entityName);
		 if (entity == null) {
			 return false;
		 }
		 return entity.isUnparsed();
	 }
	 public boolean isDeclaredEntity(String entityName) {
		 Entity entity = (Entity)fEntities.get(entityName);
		 return entity != null;
	 }
	 public XMLInputSource resolveEntity(XMLResourceIdentifier resourceIdentifier) throws IOException, XNIException {
		 if(resourceIdentifier == null ) return null;
		 String publicId = resourceIdentifier.getPublicId();
		 String literalSystemId = resourceIdentifier.getLiteralSystemId();
		 String baseSystemId = resourceIdentifier.getBaseSystemId();
		 String expandedSystemId = resourceIdentifier.getExpandedSystemId();
		 boolean needExpand = (expandedSystemId == null);
		 if (baseSystemId == null && fCurrentEntity != null && fCurrentEntity.entityLocation != null) {
			 baseSystemId = fCurrentEntity.entityLocation.getExpandedSystemId();
			 if (baseSystemId != null) needExpand = true;
		 }
		 XMLInputSource xmlInputSource = null;
		 if (fEntityResolver != null) {
			 if (needExpand) {
				 expandedSystemId = expandSystemId(literalSystemId, baseSystemId, false);
			 }
			 resourceIdentifier.setBaseSystemId(baseSystemId);
			 resourceIdentifier.setExpandedSystemId(expandedSystemId);
			 xmlInputSource = fEntityResolver.resolveEntity(resourceIdentifier);
		 }
		 if (xmlInputSource == null) {
			 xmlInputSource = new XMLInputSource(publicId, literalSystemId, baseSystemId);
		 }
		 if (DEBUG_RESOLVER) {
			 System.err.println(""XMLEntityManager.resolveEntity("" + publicId + "")"");
			 System.err.println("" = "" + xmlInputSource);
		 }
		 return xmlInputSource;
	 }
	 public void startEntity(String entityName, boolean literal) throws IOException, XNIException {
		 Entity entity = (Entity)fEntities.get(entityName);
		 if (entity == null) {
			 if (fEntityHandler != null) {
				 String encoding = null;
				 fResourceIdentifier.clear();
				 fEntityAugs.removeAllItems();
				 fEntityAugs.putItem(Constants.ENTITY_SKIPPED, Boolean.TRUE);
				 fEntityHandler.startEntity(entityName, fResourceIdentifier, encoding, fEntityAugs);
				 fEntityAugs.removeAllItems();
				 fEntityAugs.putItem(Constants.ENTITY_SKIPPED, Boolean.TRUE);
				 fEntityHandler.endEntity(entityName, fEntityAugs);
			 }
			 return;
		 }
		 boolean external = entity.isExternal();
		 if (external && (fValidationManager == null || !fValidationManager.isCachedDTD())) {
			 boolean unparsed = entity.isUnparsed();
			 boolean parameter = entityName.startsWith(""%"");
			 boolean general = !parameter;
			 if (unparsed || (general && !fExternalGeneralEntities) || (parameter && !fExternalParameterEntities)) {
				 if (fEntityHandler != null) {
					 fResourceIdentifier.clear();
					 final String encoding = null;
					 ExternalEntity externalEntity = (ExternalEntity)entity;
					 String extLitSysId = (externalEntity.entityLocation != null ? externalEntity.entityLocation.getLiteralSystemId() : null);
					 String extBaseSysId = (externalEntity.entityLocation != null ? externalEntity.entityLocation.getBaseSystemId() : null);
					 String expandedSystemId = expandSystemId(extLitSysId, extBaseSysId, false);
					 fResourceIdentifier.setValues( (externalEntity.entityLocation != null ? externalEntity.entityLocation.getPublicId() : null), extLitSysId, extBaseSysId, expandedSystemId);
					 fEntityAugs.removeAllItems();
					 fEntityAugs.putItem(Constants.ENTITY_SKIPPED, Boolean.TRUE);
					 fEntityHandler.startEntity(entityName, fResourceIdentifier, encoding, fEntityAugs);
					 fEntityAugs.removeAllItems();
					 fEntityAugs.putItem(Constants.ENTITY_SKIPPED, Boolean.TRUE);
					 fEntityHandler.endEntity(entityName, fEntityAugs);
				 }
				 return;
			 }
		 }
		 int size = fEntityStack.size();
		 for (int i = size;
		 i >= 0;
		 i--) {
			 Entity activeEntity = i == size ? fCurrentEntity : (Entity)fEntityStack.elementAt(i);
			 if (activeEntity.name == entityName) {
				 StringBuffer path = new StringBuffer(entityName);
				 for (int j = i + 1;
				 j < size;
				 j++) {
					 activeEntity = (Entity)fEntityStack.elementAt(j);
					 path.append("" -> "");
					 path.append(activeEntity.name);
				 }
				 path.append("" -> "");
				 path.append(fCurrentEntity.name);
				 path.append("" -> "");
				 path.append(entityName);
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""RecursiveReference"", new Object[] {
				 entityName, path.toString() }
				, XMLErrorReporter.SEVERITY_FATAL_ERROR);
				 if (fEntityHandler != null) {
					 fResourceIdentifier.clear();
					 final String encoding = null;
					 if (external) {
						 ExternalEntity externalEntity = (ExternalEntity)entity;
						 String extLitSysId = (externalEntity.entityLocation != null ? externalEntity.entityLocation.getLiteralSystemId() : null);
						 String extBaseSysId = (externalEntity.entityLocation != null ? externalEntity.entityLocation.getBaseSystemId() : null);
						 String expandedSystemId = expandSystemId(extLitSysId, extBaseSysId, false);
						 fResourceIdentifier.setValues( (externalEntity.entityLocation != null ? externalEntity.entityLocation.getPublicId() : null), extLitSysId, extBaseSysId, expandedSystemId);
					 }
					 fEntityAugs.removeAllItems();
					 fEntityAugs.putItem(Constants.ENTITY_SKIPPED, Boolean.TRUE);
					 fEntityHandler.startEntity(entityName, fResourceIdentifier, encoding, fEntityAugs);
					 fEntityAugs.removeAllItems();
					 fEntityAugs.putItem(Constants.ENTITY_SKIPPED, Boolean.TRUE);
					 fEntityHandler.endEntity(entityName, fEntityAugs);
				 }
				 return;
			 }
		 }
		 XMLInputSource xmlInputSource = null;
		 if (external) {
			 ExternalEntity externalEntity = (ExternalEntity)entity;
			 xmlInputSource = resolveEntity(externalEntity.entityLocation);
		 }
		 else {
			 InternalEntity internalEntity = (InternalEntity)entity;
			 Reader reader = new StringReader(internalEntity.text);
			 xmlInputSource = new XMLInputSource(null, null, null, reader, null);
		 }
		 startEntity(entityName, xmlInputSource, literal, external);
	 }
	 public void startDocumentEntity(XMLInputSource xmlInputSource) throws IOException, XNIException {
		 startEntity(XMLEntity, xmlInputSource, false, true);
	 }
	 public void startDTDEntity(XMLInputSource xmlInputSource) throws IOException, XNIException {
		 startEntity(DTDEntity, xmlInputSource, false, true);
	 }
	 public void startExternalSubset() {
		 fInExternalSubset = true;
	 }
	 public void endExternalSubset() {
		 fInExternalSubset = false;
	 }
	 public void startEntity(String name, XMLInputSource xmlInputSource, boolean literal, boolean isExternal) throws IOException, XNIException {
		 String encoding = setupCurrentEntity(name, xmlInputSource, literal, isExternal);
		 if( fSecurityManager != null && fEntityExpansionCount++ > fEntityExpansionLimit ){
			 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""EntityExpansionLimitExceeded"", new Object[]{
			new Integer(fEntityExpansionLimit) }
			, XMLErrorReporter.SEVERITY_FATAL_ERROR );
			 fEntityExpansionCount = 0;
		 }
		 if (fEntityHandler != null) {
			 fEntityHandler.startEntity(name, fResourceIdentifier, encoding, null);
		 }
	 }
	 public String setupCurrentEntity(String name, XMLInputSource xmlInputSource, boolean literal, boolean isExternal) throws IOException, XNIException {
		 final String publicId = xmlInputSource.getPublicId();
		 String literalSystemId = xmlInputSource.getSystemId();
		 String baseSystemId = xmlInputSource.getBaseSystemId();
		 String encoding = xmlInputSource.getEncoding();
		 final boolean encodingExternallySpecified = (encoding != null);
		 Boolean isBigEndian = null;
		 fTempByteBuffer = null;
		 InputStream stream = null;
		 Reader reader = xmlInputSource.getCharacterStream();
		 String expandedSystemId = expandSystemId(literalSystemId, baseSystemId, fStrictURI);
		 if (baseSystemId == null) {
			 baseSystemId = expandedSystemId;
		 }
		 if (reader == null) {
			 stream = xmlInputSource.getByteStream();
			 if (stream == null) {
				 URL location = new URL(expandedSystemId);
				 URLConnection connect = location.openConnection();
				 if (!(connect instanceof HttpURLConnection)) {
					 stream = connect.getInputStream();
				 }
				 else {
					 boolean followRedirects = true;
					 if (xmlInputSource instanceof HTTPInputSource) {
						 final HttpURLConnection urlConnection = (HttpURLConnection) connect;
						 final HTTPInputSource httpInputSource = (HTTPInputSource) xmlInputSource;
						 Iterator propIter = httpInputSource.getHTTPRequestProperties();
						 while (propIter.hasNext()) {
							 Map.Entry entry = (Map.Entry) propIter.next();
							 urlConnection.setRequestProperty((String) entry.getKey(), (String) entry.getValue());
						 }
						 followRedirects = httpInputSource.getFollowHTTPRedirects();
						 if (!followRedirects) {
							 urlConnection.setInstanceFollowRedirects(followRedirects);
						 }
					 }
					 stream = connect.getInputStream();
					 if (followRedirects) {
						 String redirect = connect.getURL().toString();
						 if (!redirect.equals(expandedSystemId)) {
							 literalSystemId = redirect;
							 expandedSystemId = redirect;
						 }
					 }
				 }
			 }
			 RewindableInputStream rewindableStream = new RewindableInputStream(stream);
			 stream = rewindableStream;
			 if (encoding == null) {
				 final byte[] b4 = new byte[4];
				 int count = 0;
				 for (;
				 count<4;
				 count++ ) {
					 b4[count] = (byte)rewindableStream.readAndBuffer();
				 }
				 if (count == 4) {
					 EncodingInfo info = getEncodingInfo(b4, count);
					 encoding = info.encoding;
					 isBigEndian = info.isBigEndian;
					 stream.reset();
					 if (info.hasBOM) {
						 if (encoding == ""UTF-8"") {
							 stream.skip(3);
						 }
						 else if (encoding == ""UTF-16"") {
							 stream.skip(2);
						 }
					 }
					 reader = createReader(stream, encoding, isBigEndian);
				 }
				 else {
					 reader = createReader(stream, encoding, isBigEndian);
				 }
			 }
			 else {
				 encoding = encoding.toUpperCase(Locale.ENGLISH);
				 if (encoding.equals(""UTF-8"")) {
					 final int[] b3 = new int[3];
					 int count = 0;
					 for (;
					 count < 3;
					 ++count) {
						 b3[count] = rewindableStream.readAndBuffer();
						 if (b3[count] == -1) break;
					 }
					 if (count == 3) {
						 if (b3[0] != 0xEF || b3[1] != 0xBB || b3[2] != 0xBF) {
							 stream.reset();
						 }
					 }
					 else {
						 stream.reset();
					 }
					 reader = createReader(stream, ""UTF-8"", isBigEndian);
				 }
				 else if (encoding.equals(""UTF-16"")) {
					 final int[] b4 = new int[4];
					 int count = 0;
					 for (;
					 count < 4;
					 ++count) {
						 b4[count] = rewindableStream.readAndBuffer();
						 if (b4[count] == -1) break;
					 }
					 stream.reset();
					 if (count >= 2) {
						 final int b0 = b4[0];
						 final int b1 = b4[1];
						 if (b0 == 0xFE && b1 == 0xFF) {
							 isBigEndian = Boolean.TRUE;
							 stream.skip(2);
						 }
						 else if (b0 == 0xFF && b1 == 0xFE) {
							 isBigEndian = Boolean.FALSE;
							 stream.skip(2);
						 }
						 else if (count == 4) {
							 final int b2 = b4[2];
							 final int b3 = b4[3];
							 if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x3F) {
								 isBigEndian = Boolean.TRUE;
							 }
							 if (b0 == 0x3C && b1 == 0x00 && b2 == 0x3F && b3 == 0x00) {
								 isBigEndian = Boolean.FALSE;
							 }
						 }
					 }
					 reader = createReader(stream, ""UTF-16"", isBigEndian);
				 }
				 else if (encoding.equals(""ISO-10646-UCS-4"")) {
					 final int[] b4 = new int[4];
					 int count = 0;
					 for (;
					 count < 4;
					 ++count) {
						 b4[count] = rewindableStream.readAndBuffer();
						 if (b4[count] == -1) break;
					 }
					 stream.reset();
					 if (count == 4) {
						 if (b4[0] == 0x00 && b4[1] == 0x00 && b4[2] == 0x00 && b4[3] == 0x3C) {
							 isBigEndian = Boolean.TRUE;
						 }
						 else if (b4[0] == 0x3C && b4[1] == 0x00 && b4[2] == 0x00 && b4[3] == 0x00) {
							 isBigEndian = Boolean.FALSE;
						 }
					 }
					 reader = createReader(stream, encoding, isBigEndian);
				 }
				 else if (encoding.equals(""ISO-10646-UCS-2"")) {
					 final int[] b4 = new int[4];
					 int count = 0;
					 for (;
					 count < 4;
					 ++count) {
						 b4[count] = rewindableStream.readAndBuffer();
						 if (b4[count] == -1) break;
					 }
					 stream.reset();
					 if (count == 4) {
						 if (b4[0] == 0x00 && b4[1] == 0x3C && b4[2] == 0x00 && b4[3] == 0x3F) {
							 isBigEndian = Boolean.TRUE;
						 }
						 else if (b4[0] == 0x3C && b4[1] == 0x00 && b4[2] == 0x3F && b4[3] == 0x00) {
							 isBigEndian = Boolean.FALSE;
						 }
					 }
					 reader = createReader(stream, encoding, isBigEndian);
				 }
				 else {
					 reader = createReader(stream, encoding, isBigEndian);
				 }
			 }
			 if (DEBUG_ENCODINGS) {
				 System.out.println(""$$$ no longer wrapping reader in OneCharReader"");
			 }
		 }
		 fReaderStack.push(reader);
		 if (fCurrentEntity != null) {
			 fEntityStack.push(fCurrentEntity);
		 }
		 fCurrentEntity = new ScannedEntity(name, new XMLResourceIdentifierImpl(publicId, literalSystemId, baseSystemId, expandedSystemId), stream, reader, fTempByteBuffer, encoding, literal, false, isExternal);
		fCurrentEntity.setEncodingExternallySpecified(encodingExternallySpecified);
		 fEntityScanner.setCurrentEntity(fCurrentEntity);
		 fResourceIdentifier.setValues(publicId, literalSystemId, baseSystemId, expandedSystemId);
		 return encoding;
	 }
	 public void setScannerVersion(short version) {
		 if(version == Constants.XML_VERSION_1_0) {
			 if(fXML10EntityScanner == null) {
				 fXML10EntityScanner = new XMLEntityScanner();
			 }
			fXML10EntityScanner.reset(fSymbolTable, this, fErrorReporter);
			 fEntityScanner = fXML10EntityScanner;
			 fEntityScanner.setCurrentEntity(fCurrentEntity);
		 }
		 else {
			 if(fXML11EntityScanner == null) {
				 fXML11EntityScanner = new XML11EntityScanner();
			 }
			fXML11EntityScanner.reset(fSymbolTable, this, fErrorReporter);
			 fEntityScanner = fXML11EntityScanner;
			 fEntityScanner.setCurrentEntity(fCurrentEntity);
		 }
	 }
	 public XMLEntityScanner getEntityScanner() {
		 if(fEntityScanner == null) {
			 if(fXML10EntityScanner == null) {
				 fXML10EntityScanner = new XMLEntityScanner();
			 }
			 fXML10EntityScanner.reset(fSymbolTable, this, fErrorReporter);
			 fEntityScanner = fXML10EntityScanner;
		 }
		 return fEntityScanner;
	 }
	 protected Stack fReaderStack = new Stack();
	 public void closeReaders() {
		 for (int i = fReaderStack.size()-1;
		 i >= 0;
		 i--) {
			 try {
				 ((Reader)fReaderStack.pop()).close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
		boolean parser_settings;
		try {
			parser_settings = componentManager.getFeature(PARSER_SETTINGS);
		}
		 catch (XMLConfigurationException e) {
			parser_settings = true;
		}
		if (!parser_settings) {
			reset();
			return;
		}
		 try {
			 fValidation = componentManager.getFeature(VALIDATION);
		 }
		 catch (XMLConfigurationException e) {
			 fValidation = false;
		 }
		 try {
			 fExternalGeneralEntities = componentManager.getFeature(EXTERNAL_GENERAL_ENTITIES);
		 }
		 catch (XMLConfigurationException e) {
			 fExternalGeneralEntities = true;
		 }
		 try {
			 fExternalParameterEntities = componentManager.getFeature(EXTERNAL_PARAMETER_ENTITIES);
		 }
		 catch (XMLConfigurationException e) {
			 fExternalParameterEntities = true;
		 }
		 try {
			 fAllowJavaEncodings = componentManager.getFeature(ALLOW_JAVA_ENCODINGS);
		 }
		 catch (XMLConfigurationException e) {
			 fAllowJavaEncodings = false;
		 }
		 try {
			 fWarnDuplicateEntityDef = componentManager.getFeature(WARN_ON_DUPLICATE_ENTITYDEF);
		 }
		 catch (XMLConfigurationException e) {
			 fWarnDuplicateEntityDef = false;
		 }
		 try {
			 fStrictURI = componentManager.getFeature(STANDARD_URI_CONFORMANT);
		 }
		 catch (XMLConfigurationException e) {
			 fStrictURI = false;
		 }
		 fSymbolTable = (SymbolTable)componentManager.getProperty(SYMBOL_TABLE);
		 fErrorReporter = (XMLErrorReporter)componentManager.getProperty(ERROR_REPORTER);
		 try {
			 fEntityResolver = (XMLEntityResolver)componentManager.getProperty(ENTITY_RESOLVER);
		 }
		 catch (XMLConfigurationException e) {
			 fEntityResolver = null;
		 }
		 try {
			 fValidationManager = (ValidationManager)componentManager.getProperty(VALIDATION_MANAGER);
		 }
		 catch (XMLConfigurationException e) {
			 fValidationManager = null;
		 }
		 try {
			 fSecurityManager = (SecurityManager)componentManager.getProperty(SECURITY_MANAGER);
		 }
		 catch (XMLConfigurationException e) {
			 fSecurityManager = null;
		 }
		 reset();
	 }
	 public void reset() {
		 fEntityExpansionLimit = (fSecurityManager != null)?fSecurityManager.getEntityExpansionLimit():0;
		 fStandalone = false;
		 fHasPEReferences = false;
		 fEntities.clear();
		 fEntityStack.removeAllElements();
		 fEntityExpansionCount = 0;
		 fCurrentEntity = null;
		 if(fXML10EntityScanner != null){
			 fXML10EntityScanner.reset(fSymbolTable, this, fErrorReporter);
		 }
		 if(fXML11EntityScanner != null) {
			 fXML11EntityScanner.reset(fSymbolTable, this, fErrorReporter);
		 }
		 if (DEBUG_ENTITIES) {
			 addInternalEntity(""text"", ""Hello, World."");
			 addInternalEntity(""empty-element"", ""<foo/>"");
			 addInternalEntity(""balanced-element"", ""<foo></foo>"");
			 addInternalEntity(""balanced-element-with-text"", ""<foo>Hello, World</foo>"");
			 addInternalEntity(""balanced-element-with-entity"", ""<foo>&text;
			</foo>"");
			 addInternalEntity(""unbalanced-entity"", ""<foo>"");
			 addInternalEntity(""recursive-entity"", ""<foo>&recursive-entity2;
			</foo>"");
			 addInternalEntity(""recursive-entity2"", ""<bar>&recursive-entity3;
			</bar>"");
			 addInternalEntity(""recursive-entity3"", ""<baz>&recursive-entity;
			</baz>"");
			 try {
				 addExternalEntity(""external-text"", null, ""external-text.ent"", ""test/external-text.xml"");
				 addExternalEntity(""external-balanced-element"", null, ""external-balanced-element.ent"", ""test/external-balanced-element.xml"");
				 addExternalEntity(""one"", null, ""ent/one.ent"", ""test/external-entity.xml"");
				 addExternalEntity(""two"", null, ""ent/two.ent"", ""test/ent/one.xml"");
			 }
			 catch (IOException ex) {
			 }
		 }
		 if (fDeclaredEntities != null) {
			 Iterator entries = fDeclaredEntities.entrySet().iterator();
			 while (entries.hasNext()) {
				 Map.Entry entry = (Map.Entry) entries.next();
				 Object key = entry.getKey();
				 Object value = entry.getValue();
				 fEntities.put(key, value);
			 }
		 }
		 fEntityHandler = null;
	 }
	 public String[] getRecognizedFeatures() {
		 return (String[])(RECOGNIZED_FEATURES.clone());
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
		 if (featureId.startsWith(Constants.XERCES_FEATURE_PREFIX)) {
			 final int suffixLength = featureId.length() - Constants.XERCES_FEATURE_PREFIX.length();
			 if (suffixLength == Constants.ALLOW_JAVA_ENCODINGS_FEATURE.length() && featureId.endsWith(Constants.ALLOW_JAVA_ENCODINGS_FEATURE)) {
				 fAllowJavaEncodings = state;
			 }
		 }
	 }
	 public String[] getRecognizedProperties() {
		 return (String[])(RECOGNIZED_PROPERTIES.clone());
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
		 if (propertyId.startsWith(Constants.XERCES_PROPERTY_PREFIX)) {
			 final int suffixLength = propertyId.length() - Constants.XERCES_PROPERTY_PREFIX.length();
			 if (suffixLength == Constants.SYMBOL_TABLE_PROPERTY.length() && propertyId.endsWith(Constants.SYMBOL_TABLE_PROPERTY)) {
				 fSymbolTable = (SymbolTable)value;
				 return;
			 }
			 if (suffixLength == Constants.ERROR_REPORTER_PROPERTY.length() && propertyId.endsWith(Constants.ERROR_REPORTER_PROPERTY)) {
				 fErrorReporter = (XMLErrorReporter)value;
				 return;
			 }
			 if (suffixLength == Constants.ENTITY_RESOLVER_PROPERTY.length() && propertyId.endsWith(Constants.ENTITY_RESOLVER_PROPERTY)) {
				 fEntityResolver = (XMLEntityResolver)value;
				 return;
			 }
			 if (suffixLength == Constants.BUFFER_SIZE_PROPERTY.length() && propertyId.endsWith(Constants.BUFFER_SIZE_PROPERTY)) {
				 Integer bufferSize = (Integer)value;
				 if (bufferSize != null && bufferSize.intValue() > DEFAULT_XMLDECL_BUFFER_SIZE) {
					 fBufferSize = bufferSize.intValue();
					 fEntityScanner.setBufferSize(fBufferSize);
					 fSmallByteBufferPool.setBufferSize(fBufferSize);
					 fLargeByteBufferPool.setBufferSize(fBufferSize << 1);
					 fCharacterBufferPool.setExternalBufferSize(fBufferSize);
				 }
			 }
			 if (suffixLength == Constants.SECURITY_MANAGER_PROPERTY.length() && propertyId.endsWith(Constants.SECURITY_MANAGER_PROPERTY)) {
				 fSecurityManager = (SecurityManager)value;
				 fEntityExpansionLimit = (fSecurityManager != null)?fSecurityManager.getEntityExpansionLimit():0;
			 }
		 }
	 }
	 public Boolean getFeatureDefault(String featureId) {
		 for (int i = 0;
		 i < RECOGNIZED_FEATURES.length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return FEATURE_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 for (int i = 0;
		 i < RECOGNIZED_PROPERTIES.length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return PROPERTY_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 private static String gUserDir;
	 private static URI gUserDirURI;
	 private static final boolean gNeedEscaping[] = new boolean[128];
	 private static final char gAfterEscaping1[] = new char[128];
	 private static final char gAfterEscaping2[] = new char[128];
	 private static final char[] gHexChs = {
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}
	;
	 static {
		 for (int i = 0;
		 i <= 0x1f;
		 i++) {
			 gNeedEscaping[i] = true;
			 gAfterEscaping1[i] = gHexChs[i >> 4];
			 gAfterEscaping2[i] = gHexChs[i & 0xf];
		 }
		 gNeedEscaping[0x7f] = true;
		 gAfterEscaping1[0x7f] = '7';
		 gAfterEscaping2[0x7f] = 'F';
		 char[] escChs = {
			' ', '<', '>', '#', '%', '""', '{
			', '}
		', '|', '\\', '^', '~', '[', ']', '`'}
		;
		 int len = escChs.length;
		 char ch;
		 for (int i = 0;
		 i < len;
		 i++) {
			 ch = escChs[i];
			 gNeedEscaping[ch] = true;
			 gAfterEscaping1[ch] = gHexChs[ch >> 4];
			 gAfterEscaping2[ch] = gHexChs[ch & 0xf];
		 }
	 }
	 private static PrivilegedAction GET_USER_DIR_SYSTEM_PROPERTY = new PrivilegedAction() {
		 public Object run() {
			 return System.getProperty(""user.dir"");
		 }
	 }
	;
	 private static synchronized URI getUserDir() throws URI.MalformedURIException {
		 String userDir = """";
		 try {
			 userDir = (String) AccessController.doPrivileged(GET_USER_DIR_SYSTEM_PROPERTY);
		 }
		 catch (SecurityException se) {
		}
		 if (userDir.length() == 0) return new URI(""file"", """", """", null, null);
		 if (gUserDirURI != null && userDir.equals(gUserDir)) {
			 return gUserDirURI;
		 }
		 gUserDir = userDir;
		 char separator = java.io.File.separatorChar;
		 userDir = userDir.replace(separator, '/');
		 int len = userDir.length(), ch;
		 StringBuffer buffer = new StringBuffer(len*3);
		 if (len >= 2 && userDir.charAt(1) == ':') {
			 ch = Character.toUpperCase(userDir.charAt(0));
			 if (ch >= 'A' && ch <= 'Z') {
				 buffer.append('/');
			 }
		 }
		 int i = 0;
		 for (;
		 i < len;
		 i++) {
			 ch = userDir.charAt(i);
			 if (ch >= 128) break;
			 if (gNeedEscaping[ch]) {
				 buffer.append('%');
				 buffer.append(gAfterEscaping1[ch]);
				 buffer.append(gAfterEscaping2[ch]);
			 }
			 else {
				 buffer.append((char)ch);
			 }
		 }
		 if (i < len) {
			 byte[] bytes = null;
			 byte b;
			 try {
				 bytes = userDir.substring(i).getBytes(""UTF-8"");
			 }
			 catch (java.io.UnsupportedEncodingException e) {
				 return new URI(""file"", """", userDir, null, null);
			 }
			 len = bytes.length;
			 for (i = 0;
			 i < len;
			 i++) {
				 b = bytes[i];
				 if (b < 0) {
					 ch = b + 256;
					 buffer.append('%');
					 buffer.append(gHexChs[ch >> 4]);
					 buffer.append(gHexChs[ch & 0xf]);
				 }
				 else if (gNeedEscaping[b]) {
					 buffer.append('%');
					 buffer.append(gAfterEscaping1[b]);
					 buffer.append(gAfterEscaping2[b]);
				 }
				 else {
					 buffer.append((char)b);
				 }
			 }
		 }
		 if (!userDir.endsWith(""/"")) buffer.append('/');
		 gUserDirURI = new URI(""file"", """", buffer.toString(), null, null);
		 return gUserDirURI;
	 }
	 public static void absolutizeAgainstUserDir(URI uri) throws URI.MalformedURIException {
		 uri.absolutize(getUserDir());
	 }
	 public static String expandSystemId(String systemId, String baseSystemId, boolean strict) throws URI.MalformedURIException {
		 if (systemId == null) {
			 return null;
		 }
		 if (strict) {
			 return expandSystemIdStrictOn(systemId, baseSystemId);
		 }
		 try {
			 return expandSystemIdStrictOff(systemId, baseSystemId);
		 }
		 catch (URI.MalformedURIException e) {
		 }
		 if (systemId.length() == 0) {
			 return systemId;
		 }
		 String id = fixURI(systemId);
		 URI base = null;
		 URI uri = null;
		 try {
			 if (baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)) {
				 base = getUserDir();
			 }
			 else {
				 try {
					 base = new URI(fixURI(baseSystemId).trim());
				 }
				 catch (URI.MalformedURIException e) {
					 if (baseSystemId.indexOf(':') != -1) {
						 base = new URI(""file"", """", fixURI(baseSystemId).trim(), null, null);
					 }
					 else {
						 base = new URI(getUserDir(), fixURI(baseSystemId));
					 }
				 }
			 }
			 uri = new URI(base, id.trim());
		 }
		 catch (Exception e) {
		 }
		 if (uri == null) {
			 return systemId;
		 }
		 return uri.toString();
	 }
	 private static String expandSystemIdStrictOn(String systemId, String baseSystemId) throws URI.MalformedURIException {
		 URI systemURI = new URI(systemId, true);
		 if (systemURI.isAbsoluteURI()) {
			 return systemId;
		 }
		 URI baseURI = null;
		 if (baseSystemId == null || baseSystemId.length() == 0) {
			 baseURI = getUserDir();
		 }
		 else {
			 baseURI = new URI(baseSystemId, true);
			 if (!baseURI.isAbsoluteURI()) {
				 baseURI.absolutize(getUserDir());
			 }
		 }
		 systemURI.absolutize(baseURI);
		 return systemURI.toString();
	 }
	 private static String expandSystemIdStrictOff(String systemId, String baseSystemId) throws URI.MalformedURIException {
		 URI systemURI = new URI(systemId, true);
		 if (systemURI.isAbsoluteURI()) {
			 if (systemURI.getScheme().length() > 1) {
				 return systemId;
			 }
			 throw new URI.MalformedURIException();
		 }
		 URI baseURI = null;
		 if (baseSystemId == null || baseSystemId.length() == 0) {
			 baseURI = getUserDir();
		 }
		 else {
			 baseURI = new URI(baseSystemId, true);
			 if (!baseURI.isAbsoluteURI()) {
				 baseURI.absolutize(getUserDir());
			 }
		 }
		 systemURI.absolutize(baseURI);
		 return systemURI.toString();
	 }
	 public static OutputStream createOutputStream(String uri) throws IOException {
		 final String expanded = XMLEntityManager.expandSystemId(uri, null, true);
		 final URL url = new URL(expanded != null ? expanded : uri);
		 OutputStream out = null;
		 String protocol = url.getProtocol();
		 String host = url.getHost();
		 if (protocol.equals(""file"") && (host == null || host.length() == 0 || host.equals(""localhost""))) {
			 File file = new File(getPathWithoutEscapes(url.getPath()));
			 if (!file.exists()) {
				 File parent = file.getParentFile();
				 if (parent != null && !parent.exists()) {
					 parent.mkdirs();
				 }
			 }
			 out = new FileOutputStream(file);
		 }
		 else {
			 URLConnection urlCon = url.openConnection();
			 urlCon.setDoInput(false);
			 urlCon.setDoOutput(true);
			 urlCon.setUseCaches(false);
			 if (urlCon instanceof HttpURLConnection) {
				 HttpURLConnection httpCon = (HttpURLConnection) urlCon;
				 httpCon.setRequestMethod(""PUT"");
			 }
			 out = urlCon.getOutputStream();
		 }
		 return out;
	 }
	 private static String getPathWithoutEscapes(String origPath) {
		 if (origPath != null && origPath.length() != 0 && origPath.indexOf('%') != -1) {
			 StringTokenizer tokenizer = new StringTokenizer(origPath, ""%"");
			 StringBuffer result = new StringBuffer(origPath.length());
			 int size = tokenizer.countTokens();
			 result.append(tokenizer.nextToken());
			 for(int i = 1;
			 i < size;
			 ++i) {
				 String token = tokenizer.nextToken();
				 result.append((char)Integer.valueOf(token.substring(0, 2), 16).intValue());
				 result.append(token.substring(2));
			 }
			 return result.toString();
		 }
		 return origPath;
	 }
	 void endEntity() throws XNIException {
		 if (DEBUG_BUFFER) {
			 System.out.print(""(endEntity: "");
			 print(fCurrentEntity);
			 System.out.println();
		 }
		 if (fEntityHandler != null) {
			 fEntityHandler.endEntity(fCurrentEntity.name, null);
		 }
		 try {
			 fCurrentEntity.reader.close();
		 }
		 catch (IOException e) {
		 }
		 if (!fReaderStack.isEmpty()) {
			 fReaderStack.pop();
		 }
		 fCharacterBufferPool.returnBuffer(fCurrentEntity.fCharacterBuffer);
		 if (fCurrentEntity.fByteBuffer != null) {
			 if (fCurrentEntity.fByteBuffer.length == fBufferSize) {
				 fSmallByteBufferPool.returnBuffer(fCurrentEntity.fByteBuffer);
			 }
			 else {
				 fLargeByteBufferPool.returnBuffer(fCurrentEntity.fByteBuffer);
			 }
		 }
		 fCurrentEntity = fEntityStack.size() > 0 ? (ScannedEntity)fEntityStack.pop() : null;
		 fEntityScanner.setCurrentEntity(fCurrentEntity);
		 if (DEBUG_BUFFER) {
			 System.out.print("")endEntity: "");
			 print(fCurrentEntity);
			 System.out.println();
		 }
	 }
	 protected EncodingInfo getEncodingInfo(byte[] b4, int count) {
		 if (count < 2) {
			 return EncodingInfo.UTF_8;
		 }
		 int b0 = b4[0] & 0xFF;
		 int b1 = b4[1] & 0xFF;
		 if (b0 == 0xFE && b1 == 0xFF) {
			 return EncodingInfo.UTF_16_BIG_ENDIAN_WITH_BOM;
		 }
		 if (b0 == 0xFF && b1 == 0xFE) {
			 return EncodingInfo.UTF_16_LITTLE_ENDIAN_WITH_BOM;
		 }
		 if (count < 3) {
			 return EncodingInfo.UTF_8;
		 }
		 int b2 = b4[2] & 0xFF;
		 if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {
			 return EncodingInfo.UTF_8_WITH_BOM;
		 }
		 if (count < 4) {
			 return EncodingInfo.UTF_8;
		 }
		 int b3 = b4[3] & 0xFF;
		 if (b0 == 0x00 && b1 == 0x00 && b2 == 0x00 && b3 == 0x3C) {
			 return EncodingInfo.UCS_4_BIG_ENDIAN;
		 }
		 if (b0 == 0x3C && b1 == 0x00 && b2 == 0x00 && b3 == 0x00) {
			 return EncodingInfo.UCS_4_LITTLE_ENDIAN;
		 }
		 if (b0 == 0x00 && b1 == 0x00 && b2 == 0x3C && b3 == 0x00) {
			 return EncodingInfo.UCS_4_UNUSUAL_BYTE_ORDER;
		 }
		 if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x00) {
			 return EncodingInfo.UCS_4_UNUSUAL_BYTE_ORDER;
		 }
		 if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x3F) {
			 return EncodingInfo.UTF_16_BIG_ENDIAN;
		 }
		 if (b0 == 0x3C && b1 == 0x00 && b2 == 0x3F && b3 == 0x00) {
			 return EncodingInfo.UTF_16_LITTLE_ENDIAN;
		 }
		 if (b0 == 0x4C && b1 == 0x6F && b2 == 0xA7 && b3 == 0x94) {
			 return EncodingInfo.EBCDIC;
		 }
		 return EncodingInfo.UTF_8;
	 }
	 protected Reader createReader(InputStream inputStream, String encoding, Boolean isBigEndian) throws IOException {
		 if (encoding == ""UTF-8"" || encoding == null) {
			 return createUTF8Reader(inputStream);
		 }
		 if (encoding == ""UTF-16"" && isBigEndian != null) {
			 return createUTF16Reader(inputStream, isBigEndian.booleanValue());
		 }
		 String ENCODING = encoding.toUpperCase(Locale.ENGLISH);
		 if (ENCODING.equals(""UTF-8"")) {
			 return createUTF8Reader(inputStream);
		 }
		 if (ENCODING.equals(""UTF-16BE"")) {
			 return createUTF16Reader(inputStream, true);
		 }
		 if (ENCODING.equals(""UTF-16LE"")) {
			 return createUTF16Reader(inputStream, false);
		 }
		 if (ENCODING.equals(""ISO-10646-UCS-4"")) {
			 if(isBigEndian != null) {
				 boolean isBE = isBigEndian.booleanValue();
				 if(isBE) {
					 return new UCSReader(inputStream, UCSReader.UCS4BE);
				 }
				 else {
					 return new UCSReader(inputStream, UCSReader.UCS4LE);
				 }
			 }
			 else {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""EncodingByteOrderUnsupported"", new Object[] {
				 encoding }
				, XMLErrorReporter.SEVERITY_FATAL_ERROR);
			 }
		 }
		 if (ENCODING.equals(""ISO-10646-UCS-2"")) {
			 if(isBigEndian != null) {
				 boolean isBE = isBigEndian.booleanValue();
				 if(isBE) {
					 return new UCSReader(inputStream, UCSReader.UCS2BE);
				 }
				 else {
					 return new UCSReader(inputStream, UCSReader.UCS2LE);
				 }
			 }
			 else {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""EncodingByteOrderUnsupported"", new Object[] {
				 encoding }
				, XMLErrorReporter.SEVERITY_FATAL_ERROR);
			 }
		 }
		 boolean validIANA = XMLChar.isValidIANAEncoding(encoding);
		 boolean validJava = XMLChar.isValidJavaEncoding(encoding);
		 if (!validIANA || (fAllowJavaEncodings && !validJava)) {
			 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""EncodingDeclInvalid"", new Object[] {
			 encoding }
			, XMLErrorReporter.SEVERITY_FATAL_ERROR);
			 return createLatin1Reader(inputStream);
		 }
		 String javaEncoding = EncodingMap.getIANA2JavaMapping(ENCODING);
		 if (javaEncoding == null) {
			 if (fAllowJavaEncodings) {
				 javaEncoding = encoding;
			 }
			 else {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""EncodingDeclInvalid"", new Object[] {
				 encoding }
				, XMLErrorReporter.SEVERITY_FATAL_ERROR);
				 return createLatin1Reader(inputStream);
			 }
		 }
		 else if (javaEncoding.equals(""ASCII"")) {
			 return createASCIIReader(inputStream);
		 }
		 else if (javaEncoding.equals(""ISO8859_1"")) {
			 return createLatin1Reader(inputStream);
		 }
		 if (DEBUG_ENCODINGS) {
			 System.out.print(""$$$ creating Java InputStreamReader: encoding=""+javaEncoding);
			 if (javaEncoding == encoding) {
				 System.out.print("" (IANA encoding)"");
			 }
			 System.out.println();
		 }
		 return new InputStreamReader(inputStream, javaEncoding);
	 }
	 private Reader createUTF8Reader(InputStream stream) {
		 if (DEBUG_ENCODINGS) {
			 System.out.println(""$$$ creating UTF8Reader"");
		 }
		 if (fTempByteBuffer == null) {
			 fTempByteBuffer = fSmallByteBufferPool.getBuffer();
		 }
		 return new UTF8Reader(stream, fTempByteBuffer, fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN), fErrorReporter.getLocale());
	 }
	 private Reader createUTF16Reader(InputStream stream, boolean isBigEndian) {
		 if (DEBUG_ENCODINGS) {
			 System.out.println(""$$$ creating UTF16Reader"");
		 }
		 if (fTempByteBuffer == null) {
			 fTempByteBuffer = fLargeByteBufferPool.getBuffer();
		 }
		 else if (fTempByteBuffer.length == fBufferSize) {
			 fSmallByteBufferPool.returnBuffer(fTempByteBuffer);
			 fTempByteBuffer = fLargeByteBufferPool.getBuffer();
		 }
		 return new UTF16Reader(stream, fTempByteBuffer, isBigEndian, fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN), fErrorReporter.getLocale());
	 }
	 private Reader createASCIIReader(InputStream stream) {
		 if (DEBUG_ENCODINGS) {
			 System.out.println(""$$$ creating ASCIIReader"");
		 }
		 if (fTempByteBuffer == null) {
			 fTempByteBuffer = fSmallByteBufferPool.getBuffer();
		 }
		 return new ASCIIReader(stream, fTempByteBuffer, fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN), fErrorReporter.getLocale());
	 }
	 private Reader createLatin1Reader(InputStream stream) {
		 if (DEBUG_ENCODINGS) {
			 System.out.println(""$$$ creating Latin1Reader"");
		 }
		 if (fTempByteBuffer == null) {
			 fTempByteBuffer = fSmallByteBufferPool.getBuffer();
		 }
		 return new Latin1Reader(stream, fTempByteBuffer);
	 }
	 protected static String fixURI(String str) {
		 str = str.replace(java.io.File.separatorChar, '/');
		 StringBuffer sb = null;
		 if (str.length() >= 2) {
			 char ch1 = str.charAt(1);
			 if (ch1 == ':') {
				 char ch0 = Character.toUpperCase(str.charAt(0));
				 if (ch0 >= 'A' && ch0 <= 'Z') {
					 sb = new StringBuffer(str.length() + 8);
				 sb.append(""file: }
			 }
			 else if (ch1 == '/' && str.charAt(0) == '/') {
				 sb = new StringBuffer(str.length() + 5);
				 sb.append(""file:"");
			 }
		 }
		 int pos = str.indexOf(' ');
		 if (pos < 0) {
			 if (sb != null) {
				 sb.append(str);
				 str = sb.toString();
			 }
		 }
		 else {
			 if (sb == null) sb = new StringBuffer(str.length());
			 for (int i = 0;
			 i < pos;
			 i++) sb.append(str.charAt(i));
			 sb.append(""%20"");
			 for (int i = pos+1;
			 i < str.length();
			 i++) {
				 if (str.charAt(i) == ' ') sb.append(""%20"");
				 else sb.append(str.charAt(i));
			 }
			 str = sb.toString();
		 }
		 return str;
	 }
	 Hashtable getDeclaredEntities() {
		 return fEntities;
	 }
	 static final void print(ScannedEntity currentEntity) {
		 if (DEBUG_BUFFER) {
			 if (currentEntity != null) {
				 System.out.print('[');
				 System.out.print(currentEntity.count);
				 System.out.print(' ');
				 System.out.print(currentEntity.position);
				 if (currentEntity.count > 0) {
					 System.out.print("" \"""");
					 for (int i = 0;
					 i < currentEntity.count;
					 i++) {
						 if (i == currentEntity.position) {
							 System.out.print('^');
						 }
						 char c = currentEntity.ch[i];
						 switch (c) {
							 case '\n': {
								 System.out.print(""\\n"");
								 break;
							 }
							 case '\r': {
								 System.out.print(""\\r"");
								 break;
							 }
							 case '\t': {
								 System.out.print(""\\t"");
								 break;
							 }
							 case '\\': {
								 System.out.print(""\\\\"");
								 break;
							 }
							 default: {
								 System.out.print(c);
							 }
						 }
					 }
					 if (currentEntity.position == currentEntity.count) {
						 System.out.print('^');
					 }
					 System.out.print('""');
				 }
				 System.out.print(']');
				 System.out.print("" @ "");
				 System.out.print(currentEntity.lineNumber);
				 System.out.print(',');
				 System.out.print(currentEntity.columnNumber);
			 }
			 else {
				 System.out.print(""*NO CURRENT ENTITY*"");
			 }
		 }
	 }
	 public static abstract class Entity {
		 public String name;
		 public boolean inExternalSubset;
		 public Entity() {
			 clear();
		 }
		 public Entity(String name, boolean inExternalSubset) {
			 this.name = name;
			 this.inExternalSubset = inExternalSubset;
		 }
		 public boolean isEntityDeclInExternalSubset () {
			 return inExternalSubset;
		 }
		 public abstract boolean isExternal();
		 public abstract boolean isUnparsed();
		 public void clear() {
			 name = null;
			 inExternalSubset = false;
		 }
		 public void setValues(Entity entity) {
			 name = entity.name;
			 inExternalSubset = entity.inExternalSubset;
		 }
	 }
	 protected static class InternalEntity extends Entity {
		 public String text;
		 public InternalEntity() {
			 clear();
		 }
		 public InternalEntity(String name, String text, boolean inExternalSubset) {
			 super(name,inExternalSubset);
			 this.text = text;
		 }
		 public final boolean isExternal() {
			 return false;
		 }
		 public final boolean isUnparsed() {
			 return false;
		 }
		 public void clear() {
			 super.clear();
			 text = null;
		 }
		 public void setValues(Entity entity) {
			 super.setValues(entity);
			 text = null;
		 }
		 public void setValues(InternalEntity entity) {
			 super.setValues(entity);
			 text = entity.text;
		 }
	 }
	 protected static class ExternalEntity extends Entity {
		 public XMLResourceIdentifier entityLocation;
		 public String notation;
		 public ExternalEntity() {
			 clear();
		 }
		 public ExternalEntity(String name, XMLResourceIdentifier entityLocation, String notation, boolean inExternalSubset) {
			 super(name,inExternalSubset);
			 this.entityLocation = entityLocation;
			 this.notation = notation;
		 }
		 public final boolean isExternal() {
			 return true;
		 }
		 public final boolean isUnparsed() {
			 return notation != null;
		 }
		 public void clear() {
			 super.clear();
			 entityLocation = null;
			 notation = null;
		 }
		 public void setValues(Entity entity) {
			 super.setValues(entity);
			 entityLocation = null;
			 notation = null;
		 }
		 public void setValues(ExternalEntity entity) {
			 super.setValues(entity);
			 entityLocation = entity.entityLocation;
			 notation = entity.notation;
		 }
	 }
	 public class ScannedEntity extends Entity {
		 public InputStream stream;
		 public Reader reader;
		 public XMLResourceIdentifier entityLocation;
		 public int lineNumber = 1;
		 public int columnNumber = 1;
		 public String encoding;
		 boolean externallySpecifiedEncoding = false;
		 public String xmlVersion = ""1.0"";
		 public boolean literal;
		 public boolean isExternal;
		 public char[] ch = null;
		 public int position;
		 public int baseCharOffset;
		 public int startPosition;
		 public int count;
		 public boolean mayReadChunks;
		 private CharacterBuffer fCharacterBuffer;
		 private byte [] fByteBuffer;
		 public ScannedEntity(String name, XMLResourceIdentifier entityLocation, InputStream stream, Reader reader, byte [] byteBuffer, String encoding, boolean literal, boolean mayReadChunks, boolean isExternal) {
			 super(name,XMLEntityManager.this.fInExternalSubset);
			 this.entityLocation = entityLocation;
			 this.stream = stream;
			 this.reader = reader;
			 this.encoding = encoding;
			 this.literal = literal;
			 this.mayReadChunks = mayReadChunks;
			 this.isExternal = isExternal;
			 this.fCharacterBuffer = fCharacterBufferPool.getBuffer(isExternal);
			 this.ch = fCharacterBuffer.ch;
			 this.fByteBuffer = byteBuffer;
		 }
		 public final boolean isExternal() {
			 return isExternal;
		 }
		 public final boolean isUnparsed() {
			 return false;
		 }
		 public void setReader(InputStream stream, String encoding, Boolean isBigEndian) throws IOException {
			 fTempByteBuffer = fByteBuffer;
			 reader = createReader(stream, encoding, isBigEndian);
			 fByteBuffer = fTempByteBuffer;
		 }
		 public String getExpandedSystemId() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0;
			 --i) {
				 ScannedEntity externalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (externalEntity.entityLocation != null && externalEntity.entityLocation.getExpandedSystemId() != null) {
					 return externalEntity.entityLocation.getExpandedSystemId();
				 }
			 }
			 return null;
		 }
		 public String getLiteralSystemId() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0;
			 --i) {
				 ScannedEntity externalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (externalEntity.entityLocation != null && externalEntity.entityLocation.getLiteralSystemId() != null) {
					 return externalEntity.entityLocation.getLiteralSystemId();
				 }
			 }
			 return null;
		 }
		 public int getLineNumber() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0 ;
			 --i) {
				 ScannedEntity firstExternalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (firstExternalEntity.isExternal()) {
					 return firstExternalEntity.lineNumber;
				 }
			 }
			 return -1;
		 }
		 public int getColumnNumber() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0;
			 --i) {
				 ScannedEntity firstExternalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (firstExternalEntity.isExternal()) {
					 return firstExternalEntity.columnNumber;
				 }
			 }
			 return -1;
		 }
		 public int getCharacterOffset() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0;
			 --i) {
				 ScannedEntity firstExternalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (firstExternalEntity.isExternal()) {
					 return firstExternalEntity.baseCharOffset + (firstExternalEntity.position - firstExternalEntity.startPosition);
				 }
			 }
			 return -1;
		 }
		 public String getEncoding() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0;
			 --i) {
				 ScannedEntity firstExternalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (firstExternalEntity.isExternal()) {
					 return firstExternalEntity.encoding;
				 }
			 }
			 return null;
		 }
		 public String getXMLVersion() {
			 int size = fEntityStack.size();
			 for (int i = size - 1;
			 i >= 0;
			 --i) {
				 ScannedEntity firstExternalEntity = (ScannedEntity)fEntityStack.elementAt(i);
				 if (firstExternalEntity.isExternal()) {
					 return firstExternalEntity.xmlVersion;
				 }
			 }
			 return null;
		 }
		 public boolean isEncodingExternallySpecified() {
			 return externallySpecifiedEncoding;
		 }
		 public void setEncodingExternallySpecified(boolean value) {
			 externallySpecifiedEncoding = value;
		 }
		 public String toString() {
			 StringBuffer str = new StringBuffer();
			 str.append(""name=\"""").append(name).append('""');
			 str.append("",ch="");
			 str.append(ch);
			 str.append("",position="").append(position);
			 str.append("",count="").append(count);
			 str.append("",baseCharOffset="").append(baseCharOffset);
			 str.append("",startPosition="").append(startPosition);
			 return str.toString();
		 }
	 }
	 private static class EncodingInfo {
		 public static final EncodingInfo UTF_8 = new EncodingInfo(""UTF-8"", null, false);
		 public static final EncodingInfo UTF_8_WITH_BOM = new EncodingInfo(""UTF-8"", null, true);
		 public static final EncodingInfo UTF_16_BIG_ENDIAN = new EncodingInfo(""UTF-16"", Boolean.TRUE, false);
		 public static final EncodingInfo UTF_16_BIG_ENDIAN_WITH_BOM = new EncodingInfo(""UTF-16"", Boolean.TRUE, true);
		 public static final EncodingInfo UTF_16_LITTLE_ENDIAN = new EncodingInfo(""UTF-16"", Boolean.FALSE, false);
		 public static final EncodingInfo UTF_16_LITTLE_ENDIAN_WITH_BOM = new EncodingInfo(""UTF-16"", Boolean.FALSE, true);
		 public static final EncodingInfo UCS_4_BIG_ENDIAN = new EncodingInfo(""ISO-10646-UCS-4"", Boolean.TRUE, false);
		 public static final EncodingInfo UCS_4_LITTLE_ENDIAN = new EncodingInfo(""ISO-10646-UCS-4"", Boolean.FALSE, false);
		 public static final EncodingInfo UCS_4_UNUSUAL_BYTE_ORDER = new EncodingInfo(""ISO-10646-UCS-4"", null, false);
		 public static final EncodingInfo EBCDIC = new EncodingInfo(""CP037"", null, false);
		 public final String encoding;
		 public final Boolean isBigEndian;
		 public final boolean hasBOM;
		 private EncodingInfo(String encoding, Boolean isBigEndian, boolean hasBOM) {
			 this.encoding = encoding;
			 this.isBigEndian = isBigEndian;
			 this.hasBOM = hasBOM;
		 }
	 }
	 private static final class ByteBufferPool {
		 private static final int DEFAULT_POOL_SIZE = 3;
		 private int fPoolSize;
		 private int fBufferSize;
		 private byte[][] fByteBufferPool;
		 private int fDepth;
		 public ByteBufferPool(int bufferSize) {
			 this(DEFAULT_POOL_SIZE, bufferSize);
		 }
		 public ByteBufferPool(int poolSize, int bufferSize) {
			 fPoolSize = poolSize;
			 fBufferSize = bufferSize;
			 fByteBufferPool = new byte[fPoolSize][];
			 fDepth = 0;
		 }
		 public byte[] getBuffer() {
			 return (fDepth > 0) ? fByteBufferPool[--fDepth] : new byte[fBufferSize];
		 }
		 public void returnBuffer(byte[] buffer) {
			 if (fDepth < fByteBufferPool.length) {
				 fByteBufferPool[fDepth++] = buffer;
			 }
		 }
		 public void setBufferSize(int bufferSize) {
			 fBufferSize = bufferSize;
			 fByteBufferPool = new byte[fPoolSize][];
			 fDepth = 0;
		 }
	 }
	 private static final class CharacterBuffer {
		 private final char[] ch;
		 private final boolean isExternal;
		 public CharacterBuffer(boolean isExternal, int size) {
			 this.isExternal = isExternal;
			 ch = new char[size];
		 }
	 }
	 private static final class CharacterBufferPool {
		 private static final int DEFAULT_POOL_SIZE = 3;
		 private CharacterBuffer[] fInternalBufferPool;
		 private CharacterBuffer[] fExternalBufferPool;
		 private int fExternalBufferSize;
		 private int fInternalBufferSize;
		 private int fPoolSize;
		 private int fInternalTop;
		 private int fExternalTop;
		 public CharacterBufferPool(int externalBufferSize, int internalBufferSize) {
			 this(DEFAULT_POOL_SIZE, externalBufferSize, internalBufferSize);
		 }
		 public CharacterBufferPool(int poolSize, int externalBufferSize, int internalBufferSize) {
			 fExternalBufferSize = externalBufferSize;
			 fInternalBufferSize = internalBufferSize;
			 fPoolSize = poolSize;
			 init();
		 }
		 private void init() {
			 fInternalBufferPool = new CharacterBuffer[fPoolSize];
			 fExternalBufferPool = new CharacterBuffer[fPoolSize];
			 fInternalTop = -1;
			 fExternalTop = -1;
		 }
		 public CharacterBuffer getBuffer(boolean external) {
			 if (external) {
				 if (fExternalTop > -1) {
					 return (CharacterBuffer)fExternalBufferPool[fExternalTop--];
				 }
				 else {
					 return new CharacterBuffer(true, fExternalBufferSize);
				 }
			 }
			 else {
				 if (fInternalTop > -1) {
					 return (CharacterBuffer)fInternalBufferPool[fInternalTop--];
				 }
				 else {
					 return new CharacterBuffer(false, fInternalBufferSize);
				 }
			 }
		 }
		 public void returnBuffer(CharacterBuffer buffer) {
			 if (buffer.isExternal) {
				 if (fExternalTop < fExternalBufferPool.length - 1) {
					 fExternalBufferPool[++fExternalTop] = buffer;
				 }
			 }
			 else if (fInternalTop < fInternalBufferPool.length - 1) {
				 fInternalBufferPool[++fInternalTop] = buffer;
			 }
		 }
		 public void setExternalBufferSize(int bufferSize) {
			 fExternalBufferSize = bufferSize;
			 fExternalBufferPool = new CharacterBuffer[fPoolSize];
			 fExternalTop = -1;
		 }
	 }
	 protected final class RewindableInputStream extends InputStream {
		 private InputStream fInputStream;
		 private byte[] fData;
		 private int fStartOffset;
		 private int fEndOffset;
		 private int fOffset;
		 private int fLength;
		 private int fMark;
		 public RewindableInputStream(InputStream is) {
			 fData = new byte[DEFAULT_XMLDECL_BUFFER_SIZE];
			 fInputStream = is;
			 fStartOffset = 0;
			 fEndOffset = -1;
			 fOffset = 0;
			 fLength = 0;
			 fMark = 0;
		 }
		 public void setStartOffset(int offset) {
			 fStartOffset = offset;
		 }
		 public void rewind() {
			 fOffset = fStartOffset;
		 }
		 public int readAndBuffer() throws IOException {
			 if (fOffset == fData.length) {
				 byte[] newData = new byte[fOffset << 1];
				 System.arraycopy(fData, 0, newData, 0, fOffset);
				 fData = newData;
			 }
			 final int b = fInputStream.read();
			 if (b == -1) {
				 fEndOffset = fOffset;
				 return -1;
			 }
			 fData[fLength++] = (byte)b;
			 fOffset++;
			 return b & 0xff;
		 }
		 public int read() throws IOException {
			 if (fOffset < fLength) {
				 return fData[fOffset++] & 0xff;
			 }
			 if (fOffset == fEndOffset) {
				 return -1;
			 }
			 if (fCurrentEntity.mayReadChunks) {
				 return fInputStream.read();
			 }
			 return readAndBuffer();
		 }
		 public int read(byte[] b, int off, int len) throws IOException {
			 final int bytesLeft = fLength - fOffset;
			 if (bytesLeft == 0) {
				 if (fOffset == fEndOffset) {
					 return -1;
				 }
				 if (fCurrentEntity.mayReadChunks) {
					 return fInputStream.read(b, off, len);
				 }
				 int returnedVal = readAndBuffer();
				 if (returnedVal == -1) {
					 fEndOffset = fOffset;
					 return -1;
				 }
				 b[off] = (byte)returnedVal;
				 return 1;
			 }
			 if (len < bytesLeft) {
				 if (len <= 0) {
					 return 0;
				 }
			 }
			 else {
				 len = bytesLeft;
			 }
			 if (b != null) {
				 System.arraycopy(fData, fOffset, b, off, len);
			 }
			 fOffset += len;
			 return len;
		 }
		 public long skip(long n) throws IOException {
			 int bytesLeft;
			 if (n <= 0) {
				 return 0;
			 }
			 bytesLeft = fLength - fOffset;
			 if (bytesLeft == 0) {
				 if (fOffset == fEndOffset) {
					 return 0;
				 }
				 return fInputStream.skip(n);
			 }
			 if (n <= bytesLeft) {
				 fOffset += n;
				 return n;
			 }
			 fOffset += bytesLeft;
			 if (fOffset == fEndOffset) {
				 return bytesLeft;
			 }
			 n -= bytesLeft;
			 return fInputStream.skip(n) + bytesLeft;
		 }
		 public int available() throws IOException {
			 final int bytesLeft = fLength - fOffset;
			 if (bytesLeft == 0) {
				 if (fOffset == fEndOffset) {
					 return -1;
				 }
				 return fCurrentEntity.mayReadChunks ? fInputStream.available() : 0;
			 }
			 return bytesLeft;
		 }
		 public void mark(int howMuch) {
			 fMark = fOffset;
		 }
		 public void reset() {
			 fOffset = fMark;
		 }
		 public boolean markSupported() {
			 return true;
		 }
		 public void close() throws IOException {
			 if (fInputStream != null) {
				 fInputStream.close();
				 fInputStream = null;
			 }
		 }
	 }
 }",1,0,0,0
"public class HiddenRegionFormattingMerger implements IMerger<IHiddenRegionFormatting> {
	private final AbstractFormatter2 formatter;
	public HiddenRegionFormattingMerger(AbstractFormatter2 formatter) {
		super();
		this.formatter = formatter;
	}
	public IHiddenRegionFormatting merge(List<? extends IHiddenRegionFormatting> conflicting) {
		if (conflicting.size() == 2) {
			conflicting.get(1).mergeValuesFrom(conflicting.get(0));
			return conflicting.get(1);
		}
		IHiddenRegionFormatting result = formatter.createHiddenRegionFormatting();
		for (IHiddenRegionFormatting conflict : conflicting)result.mergeValuesFrom(conflict);
		return result;
	}
}",0,0,0,0
"public class TestTezLauncher {
	 private static PigContext pc;
	 private static PigServer pigServer;
	 private static MiniGenericCluster cluster;
	 private static final String INPUT_FILE = ""TestTezLauncherInput"";
	 private static final String[] INPUT_RECORDS = {
	 ""100\tapple"", ""200\torange"", ""300\tstrawberry"", ""300\tpear"", ""100\tapple"", ""300\tpear"", ""400\tapple"", }
	;
	 private static final String OUTPUT_FILE = ""TestTezLauncherOutput"";
	 private static final String[] OUTPUT_RECORDS = new String[] {
	 ""(apple)"", ""(pear)"", ""(pear)"", ""(strawberry)"", ""(orange)"" }
	;
	 public static void setUpBeforeClass() throws Exception {
		 cluster = MiniGenericCluster.buildCluster(MiniGenericCluster.EXECTYPE_TEZ);
		 pc = new PigContext(new TezExecType(), cluster.getProperties());
		 Util.createInputFile(cluster, INPUT_FILE, INPUT_RECORDS);
	 }
	 public static void tearDownAfterClass() throws Exception {
		 cluster.shutDown();
	 }
	 public void setUp() throws Exception {
		 pigServer = new PigServer(pc);
	 }
	 public void tearDown() throws Exception {
		 Util.deleteFile(cluster, OUTPUT_FILE);
	 }
	 public void testRun1() throws Exception {
		 String query = ""a = load '"" + INPUT_FILE + ""' as (x:int, y:chararray);
		"" + ""b = filter a by x > 100;
		"" + ""c = foreach b generate y;
		"" + ""d = group c all;
		"" + ""store d into '"" + OUTPUT_FILE + ""';
		"";
		 PhysicalPlan pp = Util.buildPp(pigServer, query);
		 TezLauncher launcher = new TezLauncher();
		 PigStats pigStats = launcher.launchPig(pp, ""testRun1"", pc);
		 assertTrue(pigStats.isSuccessful());
		 assertEquals(1, pigStats.getInputStats().size());
		 assertEquals(INPUT_FILE, pigStats.getInputStats().get(0).getName());
		 assertEquals(1, pigStats.getOutputStats().size());
		 assertEquals(OUTPUT_FILE, pigStats.getOutputStats().get(0).getName());
		 query = ""m = load '"" + OUTPUT_FILE + ""' as (a:chararray, b:{
		(y:chararray)}
		);
		"";
		 pigServer = new PigServer(pc);
		 pigServer.registerQuery(query);
		 Iterator<Tuple> iter = pigServer.openIterator(""m"");
		 Tuple result = iter.next();
		 assertEquals(result.get(0).toString(), ""all"");
		 Iterator<Tuple> innerIter = ((DataBag)result.get(1)).iterator();
		 int count = 0;
		 while (innerIter.hasNext()) {
			 assertTrue(Arrays.asList(OUTPUT_RECORDS).contains(innerIter.next().toString()));
			 count++;
		 }
		 assertEquals(count, OUTPUT_RECORDS.length);
	 }
	 public void testQueueName() throws Exception {
		 TezConfiguration conf = new TezConfiguration();
		 conf.set(""tez.queue.name"", ""special"");
		 MRToTezHelper.translateMRSettingsForTezAM(conf);
		 assertEquals(conf.get(""tez.queue.name""), ""special"");
	 }
}",1,0,0,0
"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint);",0,0,0,0
"public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column, int pass);",0,0,0,1
"public class AllocationManager {
	 private static final AtomicLong MANAGER_ID_GENERATOR = new AtomicLong(0);
	 private static final AtomicLong LEDGER_ID_GENERATOR = new AtomicLong(0);
	 static final PooledByteBufAllocatorL INNER_ALLOCATOR = new PooledByteBufAllocatorL(DrillMetrics.getRegistry());
	 private final RootAllocator root;
	 private final long allocatorManagerId = MANAGER_ID_GENERATOR.incrementAndGet();
	 private final int size;
	 private final UnsafeDirectLittleEndian underlying;
	 private final IdentityHashMap<BufferAllocator, BufferLedger> map = new IdentityHashMap<>();
	 private final ReadWriteLock lock = new ReentrantReadWriteLock();
	 private final AutoCloseableLock readLock = new AutoCloseableLock(lock.readLock());
	 private final AutoCloseableLock writeLock = new AutoCloseableLock(lock.writeLock());
	 private final long amCreationTime = System.nanoTime();
	 private volatile BufferLedger owningLedger;
	 private volatile long amDestructionTime = 0;
	 AllocationManager(BaseAllocator accountingAllocator, int size) {
		 Preconditions.checkNotNull(accountingAllocator);
		 accountingAllocator.assertOpen();
		 this.root = accountingAllocator.root;
		 this.underlying = INNER_ALLOCATOR.allocate(size);
		 this.owningLedger = associate(accountingAllocator, false);
		 this.size = underlying.capacity();
	 }
	 BufferLedger associate(final BaseAllocator allocator) {
		 return associate(allocator, true);
	 }
	 private BufferLedger associate(final BaseAllocator allocator, final boolean retain) {
		 allocator.assertOpen();
		 if (root != allocator.root) {
			 throw new IllegalStateException( ""A buffer can only be associated between two allocators that share the same root."");
		 }
		 try ( Closeable read = readLock.open()) {
			 final BufferLedger ledger = map.get(allocator);
			 if (ledger != null) {
				 if (retain) {
					 ledger.inc();
				 }
				 return ledger;
			 }
		 }
		 try ( Closeable write = writeLock.open()) {
			 final BufferLedger existingLedger = map.get(allocator);
			 if (existingLedger != null) {
				 if (retain) {
					 existingLedger.inc();
				 }
				 return existingLedger;
			 }
			 final BufferLedger ledger = new BufferLedger(allocator, new ReleaseListener(allocator));
			 if (retain) {
				 ledger.inc();
			 }
			 BufferLedger oldLedger = map.put(allocator, ledger);
			 Preconditions.checkArgument(oldLedger == null);
			 allocator.associateLedger(ledger);
			 return ledger;
		 }
	 }
	 public static int chunkSize() {
		 return INNER_ALLOCATOR.getChunkSize();
	 }
	 private class ReleaseListener {
		 private final BufferAllocator allocator;
		 public ReleaseListener(BufferAllocator allocator) {
			 this.allocator = allocator;
		 }
		 public void release() {
			 allocator.assertOpen();
			 final BufferLedger oldLedger = map.remove(allocator);
			 oldLedger.allocator.dissociateLedger(oldLedger);
			 if (oldLedger == owningLedger) {
				 if (map.isEmpty()) {
					 oldLedger.allocator.releaseBytes(size);
					 underlying.release();
					 amDestructionTime = System.nanoTime();
					 owningLedger = null;
				 }
				 else {
					 BufferLedger newLedger = map.values().iterator().next();
					 oldLedger.transferBalance(newLedger);
				 }
			 }
			 else {
				 if (map.isEmpty()) {
					 throw new IllegalStateException(""The final removal of a ledger should be connected to the owning ledger."");
				 }
			 }
		 }
	 }
	 public class BufferLedger {
		 private final IdentityHashMap<DrillBuf, Object> buffers = BaseAllocator.DEBUG ? new IdentityHashMap<DrillBuf, Object>() : null;
		 private final long ledgerId = LEDGER_ID_GENERATOR.incrementAndGet();
		 private final AtomicInteger bufRefCnt = new AtomicInteger(0);
		 private final long lCreationTime = System.nanoTime();
		 private volatile long lDestructionTime = 0;
		 private final BaseAllocator allocator;
		 private final ReleaseListener listener;
		 private final HistoricalLog historicalLog = BaseAllocator.DEBUG ? new HistoricalLog(BaseAllocator.DEBUG_LOG_LENGTH, ""BufferLedger[%d]"", 1) : null;
		 private BufferLedger(BaseAllocator allocator, ReleaseListener listener) {
			 this.allocator = allocator;
			 this.listener = listener;
		 }
		 public boolean transferBalance(final BufferLedger target) {
			 Preconditions.checkNotNull(target);
			 Preconditions.checkArgument(allocator.root == target.allocator.root, ""You can only transfer between two allocators that share the same root."");
			 allocator.assertOpen();
			 target.allocator.assertOpen();
			 if (target == this) {
				 return true;
			 }
			 try ( Closeable write = writeLock.open()) {
				 if (owningLedger != this) {
					 return true;
				 }
				 if (BaseAllocator.DEBUG) {
					 this.historicalLog.recordEvent(""transferBalance(%s)"", target.allocator.name);
					 target.historicalLog.recordEvent(""incoming(from %s)"", owningLedger.allocator.name);
				 }
				 boolean overlimit = target.allocator.forceAllocate(size);
				 allocator.releaseBytes(size);
				 owningLedger = target;
				 return overlimit;
			 }
		 }
		 public void print(StringBuilder sb, int indent, Verbosity verbosity) {
			 indent(sb, indent) .append(""ledger["") .append(ledgerId) .append(""] allocator: "") .append(allocator.name) .append(""), isOwning: "") .append(owningLedger == this) .append("", size: "") .append(size) .append("", references: "") .append(bufRefCnt.get()) .append("", life: "") .append(lCreationTime) .append("".."") .append(lDestructionTime) .append("", allocatorManager: ["") .append(AllocationManager.this.allocatorManagerId) .append("", life: "") .append(amCreationTime) .append("".."") .append(amDestructionTime);
			 if (!BaseAllocator.DEBUG) {
				 sb.append(""]\n"");
			 }
			 else {
				 synchronized (buffers) {
					 sb.append(""] holds "") .append(buffers.size()) .append("" buffers. \n"");
					 for (DrillBuf buf : buffers.keySet()) {
						 buf.print(sb, indent + 2, verbosity);
						 sb.append('\n');
					 }
				 }
			 }
		 }
		 private void inc() {
			 bufRefCnt.incrementAndGet();
		 }
		 public int decrement(int decrement) {
			 allocator.assertOpen();
			 final int outcome;
			 try ( Closeable write = writeLock.open()) {
				 outcome = bufRefCnt.addAndGet(-decrement);
				 if (outcome == 0) {
					 lDestructionTime = System.nanoTime();
					 listener.release();
				 }
			 }
			 return outcome;
		 }
		 public BufferLedger getLedgerForAllocator(BufferAllocator allocator) {
			 return associate((BaseAllocator) allocator);
		 }
		 public DrillBuf newDrillBuf(int offset, int length) {
			 allocator.assertOpen();
			 return newDrillBuf(offset, length, null);
		 }
		 public DrillBuf newDrillBuf(int offset, int length, BufferManager manager) {
			 allocator.assertOpen();
			 final DrillBuf buf = new DrillBuf( bufRefCnt, this, underlying, manager, allocator.getAsByteBufAllocator(), offset, length, false);
			 if (BaseAllocator.DEBUG) {
				 historicalLog.recordEvent( ""DrillBuf(BufferLedger, BufferAllocator[%s], UnsafeDirectLittleEndian[identityHashCode == "" + ""%d](%s)) => ledger hc == %d"", allocator.name, System.identityHashCode(buf), buf.toString(), System.identityHashCode(this));
				 synchronized (buffers) {
					 buffers.put(buf, null);
				 }
			 }
			 return buf;
		 }
		 public int getSize() {
			 return size;
		 }
		 public int getAccountedSize() {
			 try ( Closeable read = readLock.open()) {
				 if (owningLedger == this) {
					 return size;
				 }
				 else {
					 return 0;
				 }
			 }
		 }
		 protected UnsafeDirectLittleEndian getUnderlying() {
			 return underlying;
		 }
		 protected boolean isOwningLedger() {
			 return this == owningLedger;
		 }
	 }
}",1,0,0,0
"public void read(org.apache.thrift.protocol.TProtocol iprot, FetchRuleKeyLogsRequest struct) throws org.apache.thrift.TException {
	 org.apache.thrift.protocol.TField schemeField;
	 iprot.readStructBegin();
	 while (true) {
		 schemeField = iprot.readFieldBegin();
		 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
			 break;
		 }
		 switch (schemeField.id) {
			 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
				 {
					 org.apache.thrift.protocol.TList _list184 = iprot.readListBegin();
					 struct.ruleKeys = new java.util.ArrayList<java.lang.String>(_list184.size);
					 java.lang.String _elem185;
					 for (int _i186 = 0;
					 _i186 < _list184.size;
					 ++_i186) {
						 _elem185 = iprot.readString();
						 struct.ruleKeys.add(_elem185);
					 }
					 iprot.readListEnd();
				 }
				 struct.setRuleKeysIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.repository = iprot.readString();
				 struct.setRepositoryIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.scheduleType = iprot.readString();
				 struct.setScheduleTypeIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 4: if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
				 struct.distributedBuildModeEnabled = iprot.readBool();
				 struct.setDistributedBuildModeEnabledIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
		 }
		 iprot.readFieldEnd();
	 }
	 iprot.readStructEnd();
	 struct.validate();
 }",0,0,1,0
"public void startElement(String uri, String name, String raw, Attributes attr) throws SAXException {
	 if (namespaceURI.equals(uri) && ignoreHooksCount == 0) {
		 try {
			 startTransformingElement(uri, name, raw, attr);
		 }
		 catch (ProcessingException e) {
			 throw new SAXException(""ProcessingException: "" + e, e);
		 }
		 catch (IOException e) {
			 throw new SAXException(""IOException occured during processing: "" + e, e);
		 }
	 }
	 else {
		 if (ignoreEventsCount == 0) {
			 super.startElement(uri, name, raw, attr);
		 }
	 }
 }",0,0,0,0
"private void scrubOne(ColumnFamilyStore cfs, SSTableReader sstable) throws IOException {
	 logger.info(""Scrubbing "" + sstable);
	 CompactionController controller = new CompactionController(cfs, Collections.singletonList(sstable), getDefaultGcBefore(cfs), true);
	 boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();
	 String compactionFileLocation = cfs.table.getDataFileLocation(sstable.length());
	 if (compactionFileLocation == null) throw new IOException(""disk full"");
	 int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(), (int)(SSTableReader.getApproximateKeyCount(Arrays.asList(sstable))));
	 final BufferedRandomAccessFile dataFile = BufferedRandomAccessFile.getUncachingReader(sstable.getFilename());
	 String indexFilename = sstable.descriptor.filenameFor(Component.PRIMARY_INDEX);
	 BufferedRandomAccessFile indexFile = BufferedRandomAccessFile.getUncachingReader(indexFilename);
	 try {
		 ByteBuffer nextIndexKey = ByteBufferUtil.readWithShortLength(indexFile);
		 {
			 long firstRowPositionFromIndex = indexFile.readLong();
			 assert firstRowPositionFromIndex == 0 : firstRowPositionFromIndex;
		 }
		 SSTableWriter writer = maybeCreateWriter(cfs, compactionFileLocation, expectedBloomFilterSize, null, Collections.singletonList(sstable));
		 executor.beginCompaction(new ScrubInfo(dataFile, sstable));
		 int goodRows = 0, badRows = 0, emptyRows = 0;
		 while (!dataFile.isEOF()) {
			 long rowStart = dataFile.getFilePointer();
			 if (logger.isDebugEnabled()) logger.debug(""Reading row at "" + rowStart);
			 DecoratedKey key = null;
			 long dataSize = -1;
			 try {
				 key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, ByteBufferUtil.readWithShortLength(dataFile));
				 dataSize = sstable.descriptor.hasIntRowSize ? dataFile.readInt() : dataFile.readLong();
				 if (logger.isDebugEnabled()) logger.debug(String.format(""row %s is %s bytes"", ByteBufferUtil.bytesToHex(key.key), dataSize));
			 }
			 catch (Throwable th) {
				 throwIfFatal(th);
			 }
			 ByteBuffer currentIndexKey = nextIndexKey;
			 long nextRowPositionFromIndex;
			 try {
				 nextIndexKey = indexFile.isEOF() ? null : ByteBufferUtil.readWithShortLength(indexFile);
				 nextRowPositionFromIndex = indexFile.isEOF() ? dataFile.length() : indexFile.readLong();
			 }
			 catch (Throwable th) {
				 logger.warn(""Error reading index file"", th);
				 nextIndexKey = null;
				 nextRowPositionFromIndex = dataFile.length();
			 }
			 long dataStart = dataFile.getFilePointer();
			 long dataStartFromIndex = currentIndexKey == null ? -1 : rowStart + 2 + currentIndexKey.remaining() + (sstable.descriptor.hasIntRowSize ? 4 : 8);
			 long dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex;
			 assert currentIndexKey != null || indexFile.isEOF();
			 if (logger.isDebugEnabled() && currentIndexKey != null) logger.debug(String.format(""Index doublecheck: row %s is %s bytes"", ByteBufferUtil.bytesToHex(currentIndexKey), dataSizeFromIndex));
			 writer.mark();
			 try {
				 if (key == null) throw new IOError(new IOException(""Unable to read row key from data file""));
				 if (dataSize > dataFile.length()) throw new IOError(new IOException(""Impossible row size "" + dataSize));
				 SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStart, dataSize, true);
				 AbstractCompactedRow compactedRow = controller.getCompactedRow(row);
				 if (compactedRow.isEmpty()) {
					 emptyRows++;
				 }
				 else {
					 writer.append(compactedRow);
					 goodRows++;
				 }
				 if (!key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex) logger.warn(""Index file contained a different key or row size;
				 using key from data file"");
			 }
			 catch (Throwable th) {
				 throwIfFatal(th);
				 logger.warn(""Non-fatal error reading row (stacktrace follows)"", th);
				 writer.reset();
				 if (currentIndexKey != null && (key == null || !key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex || dataSize != dataSizeFromIndex)) {
					 logger.info(String.format(""Retrying from row index;
					 data is %s bytes starting at %s"", dataSizeFromIndex, dataStartFromIndex));
					 key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, currentIndexKey);
					 try {
						 SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStartFromIndex, dataSizeFromIndex, true);
						 AbstractCompactedRow compactedRow = controller.getCompactedRow(row);
						 if (compactedRow.isEmpty()) {
							 emptyRows++;
						 }
						 else {
							 writer.append(compactedRow);
							 goodRows++;
						 }
					 }
					 catch (Throwable th2) {
						 throwIfFatal(th2);
						 if (isCommutative) throw new IOError(th2);
						 logger.warn(""Retry failed too. Skipping to next row (retry's stacktrace follows)"", th2);
						 writer.reset();
						 dataFile.seek(nextRowPositionFromIndex);
						 badRows++;
					 }
				 }
				 else {
					 if (isCommutative) throw new IOError(th);
					 logger.warn(""Row at "" + dataStart + "" is unreadable;
					 skipping to next"");
					 if (currentIndexKey != null) dataFile.seek(nextRowPositionFromIndex);
					 badRows++;
				 }
			 }
		 }
		 if (writer.getFilePointer() > 0) {
			 SSTableReader newSstable = writer.closeAndOpenReader(sstable.maxDataAge);
			 cfs.replaceCompactedSSTables(Arrays.asList(sstable), Arrays.asList(newSstable));
			 logger.info(""Scrub of "" + sstable + "" complete: "" + goodRows + "" rows in new sstable and "" + emptyRows + "" empty (tombstoned) rows dropped"");
			 if (badRows > 0) logger.warn(""Unable to recover "" + badRows + "" rows that were skipped. You can attempt manual recovery from the pre-scrub snapshot. You can also run nodetool repair to transfer the data from a healthy replica, if any"");
		 }
		 else {
			 cfs.markCompacted(Arrays.asList(sstable));
			 if (badRows > 0) logger.warn(""No valid rows found while scrubbing "" + sstable + "";
			 it is marked for deletion now. If you want to attempt manual recovery, you can find a copy in the pre-scrub snapshot"");
			 else logger.info(""Scrub of "" + sstable + "" complete;
			 looks like all "" + emptyRows + "" rows were tombstoned"");
		 }
	 }
	 finally {
		 FileUtils.closeQuietly(dataFile);
		 FileUtils.closeQuietly(indexFile);
	 }
 }",0,0,1,0
"private void internalCheck(Object obj){
	if (obj == null){
		return;
	}
	Class<T> cls = obj.getClass();
	nameStack.add(simpleName);
	traceStack.add(new TraceSlot(obj, fieldDescription));
	if (!(obj instanceof Serializable) && (!Proxy.isProxyClass(cls))){
		throw new WicketNotSerializableException(toPrettyPrintedStack(obj.getClass().getName()), exception);
	}
	ObjectStreamClass desc;
	for (;
	;
	){
		try{
			desc = (ObjectStreamClass)LOOKUP_METHOD.invoke(null, new Object[] {
			 cls,Boolean.TRUE }
			);
			Class<T> repCl;
			if (!((Boolean)HAS_WRITE_REPLACE_METHOD_METHOD.invoke(desc, (Object[])null)).booleanValue() ||(obj = INVOKE_WRITE_REPLACE_METHOD.invoke(desc, new Object[] {
			 obj }
			)) == null ||(repCl = obj.getClass()) == cls){
				break;
			}
			cls = repCl;
		}
		catch (IllegalAccessException e){
			throw new RuntimeException(e);
		}
		catch (InvocationTargetException e){
			throw new RuntimeException(e);
		}
	}
	if (cls.isPrimitive()){
	}
	else if (cls.isArray()){
		checked.put(obj, null);
		Class<T> ccl = cls.getComponentType();
		if (!(ccl.isPrimitive())){
			Object[] objs = (Object[])obj;
			for (int i = 0;
			 i < objs.length;
			 i++){
				String arrayPos = ""["" + i + ""]"";
				simpleName = arrayPos;
				fieldDescription += arrayPos;
				check(objs[i]);
			}
		}
	}
	else if (obj instanceof Externalizable && (!Proxy.isProxyClass(cls))){
		Externalizable extObj = (Externalizable)obj;
		try{
			extObj.writeExternal(new ObjectOutputAdaptor(){
				private int count = 0;
				public void writeObject(Object streamObj) throws IOException{
					if (checked.containsKey(streamObj)){
						return;
					}
					checked.put(streamObj, null);
					String arrayPos = ""[write:"" + count++ + ""]"";
					simpleName = arrayPos;
					fieldDescription += arrayPos;
					check(streamObj);
				}
			}
			);
		}
		catch (Exception e){
			if (e instanceof WicketNotSerializableException){
				throw (WicketNotSerializableException)e;
			}
			log.warn(""error delegating to Externalizable : "" + e.getMessage() + "", path: "" +currentPath());
		}
	}
	else{
		Method writeObjectMethod = null;
		Object o = writeObjectMethodCache.get(cls);
		if (o != null){
			if (o instanceof Method){
				writeObjectMethod = (Method)o;
			}
		}
		else{
			try{
				writeObjectMethod = cls.getDeclaredMethod(""writeObject"",new Class[] {
				 java.io.ObjectOutputStream.class }
				);
				writeObjectMethodCache.put(cls, writeObjectMethod);
			}
			catch (SecurityException e){
				writeObjectMethodCache.put(cls, Boolean.FALSE);
			}
			catch (NoSuchMethodException e){
				writeObjectMethodCache.put(cls, Boolean.FALSE);
			}
		}
		final Object original = obj;
		if (writeObjectMethod != null){
			class InterceptingObjectOutputStream extends ObjectOutputStream{
				private int counter;
				InterceptingObjectOutputStream() throws IOException{
					super(DUMMY_OUTPUT_STREAM);
					enableReplaceObject(true);
				}
				protected Object replaceObject(Object streamObj) throws IOException{
					if (streamObj == original){
						return streamObj;
					}
					counter++;
					if (checked.containsKey(streamObj)){
						return null;
					}
					checked.put(original, null);
					String arrayPos = ""[write:"" + counter + ""]"";
					simpleName = arrayPos;
					fieldDescription += arrayPos;
					check(streamObj);
					return streamObj;
				}
			}
			try{
				InterceptingObjectOutputStream ioos = new InterceptingObjectOutputStream();
				ioos.writeObject(obj);
			}
			catch (Exception e){
				if (e instanceof WicketNotSerializableException){
					throw (WicketNotSerializableException)e;
				}
				log.warn(""error delegating to writeObject : "" + e.getMessage() + "", path: "" +currentPath());
			}
		}
		else{
			Object[] slots;
			try{
				slots = (Object[])GET_CLASS_DATA_LAYOUT_METHOD.invoke(desc, (Object[])null);
			}
			catch (Exception e){
				throw new RuntimeException(e);
			}
			for (int i = 0;
			 i < slots.length;
			 i++){
				ObjectStreamClass slotDesc;
				try{
					Field descField = slots[i].getClass().getDeclaredField(""desc"");
					descField.setAccessible(true);
					slotDesc = (ObjectStreamClass)descField.get(slots[i]);
				}
				catch (Exception e){
					throw new RuntimeException(e);
				}
				checked.put(obj, null);
				checkFields(obj, slotDesc);
			}
		}
	}
	traceStack.removeLast();
	nameStack.removeLast();
}",0,0,1,0
"public int executeInVM(CommandlineJava commandline) throws BuildException {
	 jdepend.textui.JDepend jdepend;
	 if (""xml"".equals(format)) {
		 jdepend = new jdepend.xmlui.JDepend();
	 }
	 else {
		 jdepend = new jdepend.textui.JDepend();
	 }
	 FileWriter fw = null;
	 PrintWriter pw = null;
	 if (getOutputFile() != null) {
		 try {
			 fw = new FileWriter(getOutputFile().getPath());
		 }
		 catch (IOException e) {
			 String msg = ""JDepend Failed when creating the output file: "" + e.getMessage();
			 log(msg);
			 throw new BuildException(msg);
		 }
		 pw = new PrintWriter(fw);
		 jdepend.setWriter(pw);
		 log(""Output to be stored in "" + getOutputFile().getPath());
	 }
	 try {
		 if (getClassespath() != null) {
			 String[] cP = getClassespath().list();
			 for (int i = 0;
			 i < cP.length;
			 i++) {
				 File f = new File(cP[i]);
				 if (!f.exists()) {
					 String msg = ""\"""" + f.getPath() + ""\"" does not represent a valid"" + "" file or directory. JDepend would fail."";
					 log(msg);
					 throw new BuildException(msg);
				 }
				 try {
					 jdepend.addDirectory(f.getPath());
				 }
				 catch (IOException e) {
					 String msg = ""JDepend Failed when adding a class directory: "" + e.getMessage();
					 log(msg);
					 throw new BuildException(msg);
				 }
			 }
		 }
		 else if (getSourcespath() != null) {
			 String[] sP = getSourcespath().list();
			 for (int i = 0;
			 i < sP.length;
			 i++) {
				 File f = new File(sP[i]);
				 if (!f.exists() || !f.isDirectory()) {
					 String msg = ""\"""" + f.getPath() + ""\"" does not represent a valid"" + "" directory. JDepend would fail."";
					 log(msg);
					 throw new BuildException(msg);
				 }
				 try {
					 jdepend.addDirectory(f.getPath());
				 }
				 catch (IOException e) {
					 String msg = ""JDepend Failed when adding a source directory: "" + e.getMessage();
					 log(msg);
					 throw new BuildException(msg);
				 }
			 }
		 }
		 String[] patterns = defaultPatterns.getExcludePatterns(getProject());
		 if (patterns != null && patterns.length > 0) {
			 if (setFilter != null) {
				 Vector v = new Vector();
				 for (int i = 0;
				 i < patterns.length;
				 i++) {
					 v.addElement(patterns[i]);
				 }
				 try {
					 Object o = packageFilterC.newInstance(new Object[] {
					v}
					);
					 setFilter.invoke(jdepend, new Object[] {
					o}
					);
				 }
				 catch (Throwable e) {
					 log(""excludes will be ignored as JDepend doesn't like me: "" + e.getMessage(), Project.MSG_WARN);
				 }
			 }
			 else {
				 log(""Sorry, your version of JDepend doesn't support excludes"", Project.MSG_WARN);
			 }
		 }
		 jdepend.analyze();
		 if (pw.checkError()) {
			 throw new IOException(""Encountered an error writing JDepend"" + "" output"");
		 }
	 }
	 catch (IOException ex) {
		 throw new BuildException(ex);
	 }
	 finally {
		 FileUtils.close(pw);
		 FileUtils.close(fw);
	 }
	 return SUCCESS;
 }",0,0,1,0
"protected void initValidator() {
	 xmlReader = createXmlReader();
	 xmlReader.setEntityResolver(getEntityResolver());
	 xmlReader.setErrorHandler(errorHandler);
	 if (!isSax1Parser()) {
		 if (!lenient) {
			 setFeature(XmlConstants.FEATURE_VALIDATION, true);
		 }
		 for (int i = 0;
		 i < attributeList.size();
		 i++) {
			 Attribute feature = (Attribute) attributeList.elementAt(i);
			 setFeature(feature.getName(), feature.getValue());
		 }
		 for (int i = 0;
		 i < propertyList.size();
		 i++) {
			 final Property prop = (Property) propertyList.elementAt(i);
			 setProperty(prop.getName(), prop.getValue());
		 }
	 }
 }",0,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 width = originalImage.getWidth();
	 height = originalImage.getHeight();
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 imageMatrix = new int[width][height];
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 imageMatrix[i][j] = new Color(originalImage.getRGB(i, j)).getRed();
		 }
	 }
	 mean = calculateMean();
	 var = calculateVariance();
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 double normalizedPixel = 0;
			 double squareError = 0;
			 if (imageMatrix[i][j] > mean) {
				 squareError = (imageMatrix[i][j] - mean)*(imageMatrix[i][j]-mean);
				 normalizedPixel = (GOAL_MEAN + Math.sqrt(((GOAL_VARIANCE * squareError / var))));
			 }
			 else {
				 squareError = (imageMatrix[i][j] - mean)*(imageMatrix[i][j]-mean);
				 normalizedPixel = (GOAL_MEAN - Math.sqrt(((GOAL_VARIANCE * squareError / var))));
			 }
			 int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 int rgb = (int)-normalizedPixel;
			 int color = ImageUtilities.colorToRGB(alpha, rgb, rgb, rgb);
			 filteredImage.setRGB(i, j, color);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public void setLocaltunnels(String tunnels) {
	 String[] specs = tunnels.split("", "");
	 for (int i = 0;
	 i < specs.length;
	 i++) {
		 if (specs[i].length() > 0) {
			 String[] spec = specs[i].split("":"", 3);
			 int lport = Integer.parseInt(spec[0]);
			 String rhost = spec[1];
			 int rport = Integer.parseInt(spec[2]);
			 LocalTunnel tunnel = createLocalTunnel();
			 tunnel.setLPort(lport);
			 tunnel.setRHost(rhost);
			 tunnel.setRPort(rport);
		 }
	 }
 }",0,0,0,0
"public class EdgeRenderer extends JComponent implements CellViewRenderer,Serializable {
	 public static boolean HIT_LABEL_EXACT = false;
	protected static transient Graphics fontGraphics;
	static {
		try {
			fontGraphics = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB).getGraphics();
		}
		 catch (Error e) {
			fontGraphics = null;
		}
	}
	public static double LABELWIDTHBUFFER = 1.1;
	public boolean simpleExtraLabels = true;
	public Font extraLabelFont = null;
	protected transient FontMetrics metrics;
	protected transient WeakReference graph;
	protected transient EdgeView view;
	protected transient int beginDeco, endDeco, beginSize, endSize, lineStyle;
	protected transient float lineWidth;
	transient protected boolean labelsEnabled;
	protected transient boolean labelBorder, beginFill, endFill, focus,selected, preview, opaque, childrenSelected, labelTransformEnabled,isMoveBelowZero;
	protected transient Color borderColor, defaultForeground,defaultBackground, fontColor;
	protected transient float[] lineDash;
	protected transient float dashOffset = 0.0f;
	protected transient Color gradientColor = null;
	protected transient Color gridColor = null;
	protected transient Color lockedHandleColor = null;
	protected transient Color highlightColor = null;
	protected transient Bezier bezier;
	protected transient Spline2D spline;
	public EdgeRenderer() {
		defaultForeground = UIManager.getColor(""Tree.textForeground"");
		defaultBackground = UIManager.getColor(""Tree.textBackground"");
	}
	void setView(CellView value) {
		if (value instanceof EdgeView) {
			view = (EdgeView) value;
			installAttributes(view);
		}
		 else {
			view = null;
		}
	}
	public Component getRendererComponent(JGraph graph, CellView view,boolean sel, boolean focus, boolean preview) {
		if (view instanceof EdgeView && graph != null) {
			this.gridColor = graph.getGridColor();
			this.lockedHandleColor = graph.getLockedHandleColor();
			this.highlightColor = graph.getHighlightColor();
			this.isMoveBelowZero = graph.isMoveBelowZero();
			this.graph = new WeakReference(graph);
			this.focus = focus;
			this.selected = sel;
			this.preview = preview;
			this.childrenSelected = graph.getSelectionModel().isChildrenSelected(view.getCell());
			setView(view);
			return this;
		}
		return null;
	}
	public boolean intersects(JGraph graph, CellView value, Rectangle rect) {
		if (value instanceof EdgeView && graph != null && value != null) {
			setView(value);
			Graphics2D g2 = (Graphics2D) graph.getGraphics();
			EdgeView edgeView = (EdgeView) value;
			if (g2 == null || edgeView.getPointCount() == 2) {
				Point2D p0 = edgeView.getPoint(0);
				Point2D p1 = edgeView.getPoint(1);
				if (rect.intersectsLine(p0.getX(), p0.getY(), p1.getX(), p1.getY()))return true;
			}
			 else if(g2 != null) {
				if (g2.hit(rect, view.getShape(), true))return true;
			}
			Rectangle2D r = getLabelBounds(graph, view);
			if (r != null && r.intersects(rect)){
				boolean hits = true;
				if (HIT_LABEL_EXACT) {
					 AffineTransform tx = g2.getTransform();
					 try {
						String lab = graph.convertValueToString(view);
						Point2D tmpPt = getLabelPosition(view);
						Dimension size = getLabelSize(view, lab);
						Rectangle2D tmp = new Rectangle((int) tmpPt.getX(), (int) tmpPt.getY(), size.width,size.height);
						double cx = tmp.getCenterX();
						double cy = tmp.getCenterY();
						g2.translate(-size.width / 2, -size.height * 0.75- metrics.getDescent());
						boolean applyTransform = isLabelTransform(lab);
						double angle = 0;
						if (applyTransform) {
							 angle = getLabelAngle(lab);
							 g2.rotate(angle, cx, cy);
						}
						hits = g2.hit(rect, tmp, false);
					 }
					 finally {
						g2.setTransform(tx);
					 }
				}
				if (hits) {
					 return true;
				}
			}
			Object[] labels = GraphConstants.getExtraLabels(view.getAllAttributes());
			if (labels != null) {
				for (int i = 0;
				 i < labels.length;
				 i++) {
					r = getExtraLabelBounds(graph, view, i);
					if (r != null && r.intersects(rect))return true;
				}
			}
		}
		return false;
	}
	public Rectangle2D getBounds(CellView value) {
		if (value instanceof EdgeView && value != null) {
			view = (EdgeView) value;
			Rectangle2D r = getPaintBounds(view);
			JGraph graph = null;
			if (this.graph != null) {
				graph = (JGraph)this.graph.get();
			}
			Rectangle2D rect = getLabelBounds(graph, view);
			if (rect != null)Rectangle2D.union(r, rect, r);
			Object[] labels = GraphConstants.getExtraLabels(view.getAllAttributes());
			if (labels != null) {
				for (int i = 0;
				 i < labels.length;
				 i++) {
					rect = getExtraLabelBounds(graph, view, i);
					if (rect != null)Rectangle2D.union(r, rect, r);
				}
			}
			int b = (int) Math.ceil(lineWidth);
			r.setFrame(r.getX() - b, r.getY() - b, r.getWidth() + 2 * b, r.getHeight()+ 2 * b);
			return r;
		}
		return null;
	}
	private boolean isLabelTransformEnabled() {
		return labelTransformEnabled;
	}
	private boolean isLabelTransform(String label) {
		if (!isLabelTransformEnabled()) {
			return false;
		}
		Point2D p = getLabelPosition(view);
		if (p != null && label != null && label.length() > 0) {
			int sw = metrics.stringWidth(label);
			Point2D p1 = view.getPoint(0);
			Point2D p2 = view.getPoint(view.getPointCount() - 1);
			double length = Math.sqrt((p2.getX() - p1.getX())if (!(length <= Double.NaN || length < sw)) {
				return true;
			}
		}
		return false;
	}
	private double getLabelAngle(String label) {
		Point2D p = getLabelPosition(view);
		double angle = 0;
		if (p != null && label != null && label.length() > 0) {
			int sw = metrics.stringWidth(label);
			Point2D p1 = view.getPoint(0);
			Point2D p2 = view.getPoint(view.getPointCount() - 1);
			double length = Math.sqrt((p2.getX() - p1.getX())if (!(length <= Double.NaN || length < sw)) {
				 double cos = (p2.getX() - p1.getX()) / length;
				double sin = (p2.getY() - p1.getY()) / length;
				angle = Math.acos(cos);
				if (sin < 0) {
					 angle = 2 * Math.PI - angle;
				}
			}
			if (angle > Math.PI / 2 && angle <= Math.PI * 3 / 2) {
				angle -= Math.PI;
			}
		}
		return angle;
	}
	public Rectangle2D getLabelBounds(JGraph paintingContext, EdgeView view) {
		if (paintingContext == null && graph != null) {
			JGraph graph = (JGraph)this.graph.get();
			paintingContext = graph;
		}
		String label = (paintingContext != null) ? paintingContext.convertValueToString(view) : String.valueOf(view.getCell());
		if (label != null) {
			Point2D p = getLabelPosition(view);
			Dimension d = getLabelSize(view, label);
			return getLabelBounds(p, d, label);
		}
		 else {
			return null;
		}
	}
	public Rectangle2D getExtraLabelBounds(JGraph paintingContext,EdgeView view, int index) {
		if (paintingContext == null && graph != null) {
			JGraph graph = (JGraph)this.graph.get();
			paintingContext = graph;
		}
		setView(view);
		Object[] labels = GraphConstants.getExtraLabels(view.getAllAttributes());
		if (labels != null && index < labels.length) {
			Point2D p = getExtraLabelPosition(this.view, index);
			Dimension d = getExtraLabelSize(paintingContext, this.view, index);
			String label = (paintingContext != null) ? paintingContext.convertValueToString(labels[index]) : String.valueOf(labels[index]);
			return getLabelBounds(p, d, label);
		}
		return new Rectangle2D.Double(getX(), getY(), 0, 0);
	}
	public Rectangle2D getLabelBounds(Point2D p, Dimension d, String label) {
		if (label != null && isLabelTransform(label)) {
			double angle = getLabelAngle(label);
			if (angle < 0)angle = -angle;
			if (angle > Math.PI / 2)angle %= Math.PI / 2;
			double yside = Math.abs(Math.cos(angle) * d.height+ Math.sin(angle) * d.width);
			double xside = Math.abs(d.width * Math.cos(angle) + d.heightif (xside > yside)yside = xside;
			if (yside > xside)xside = yside;
			angle = getLabelAngle(label);
			d.width = (int) xside + d.height;
			d.height = (int) yside + d.height;
		}
		if (p != null && d != null) {
			double x = Math.max(0, p.getX() - (d.width / 2));
			double y = Math.max(0, p.getY() - (d.height / 2));
			return new Rectangle2D.Double(x, y, d.width + 1, d.height + 1);
		}
		return null;
	}
	public Point2D getLabelPosition(EdgeView view) {
		setView(view);
		return getLabelPosition(view.getLabelPosition());
	}
	public Point2D getExtraLabelPosition(EdgeView view, int index) {
		setView(view);
		Point2D[] pts = GraphConstants.getExtraLabelPositions(view.getAllAttributes());
		if (pts != null && index < pts.length)return getLabelPosition(pts[index]);
		return null;
	}
	protected Point2D getLabelPosition(Point2D pos) {
		Rectangle2D tmp = getPaintBounds(view);
		int unit = GraphConstants.PERMILLE;
		Point2D p0 = view.getPoint(0);
		if (pos != null && tmp != null && p0 != null) {
			if (!isLabelTransformEnabled()) {
				return view.getAbsoluteLabelPositionFromRelative(pos);
			}
			 else {
				Point2D vector = view.getLabelVector();
				double dx = vector.getX();
				double dy = vector.getY();
				double len = Math.sqrt(dx * dx + dy * dy);
				if (len > 0) {
					int pointIndex = view.getFirstPointOfSegment();
					if (pointIndex >=0 && pointIndex < view.getPointCount()-1) {
						p0 = view.getPoint(pointIndex);
					}
					double x = p0.getX() + (dx * pos.getX() / unit);
					double y = p0.getY() + (dy * pos.getX() / unit);
					x += (-dy * pos.getY() / len);
					y += (dx * pos.getY() / len);
					return new Point2D.Double(x, y);
				}
				 else {
					return new Point2D.Double(p0.getX() + pos.getX(), p0.getY()+ pos.getY());
				}
			}
		}
		return null;
	}
	public Dimension getExtraLabelSize(JGraph paintingContext, EdgeView view,int index) {
		Object[] labels = GraphConstants.getExtraLabels(view.getAllAttributes());
		if (labels != null && index < labels.length) {
			String label = (paintingContext != null) ? paintingContext.convertValueToString(labels[index]) : String.valueOf(labels[index]);
			return getLabelSize(view, label);
		}
		return null;
	}
	public Dimension getLabelSize(EdgeView view, String label) {
		if (label != null && fontGraphics != null) {
			fontGraphics.setFont(GraphConstants.getFont(view.getAllAttributes()));
			metrics = fontGraphics.getFontMetrics();
			int sw = (int)(metrics.stringWidth(label) * LABELWIDTHBUFFER);
			int sh = metrics.getHeight();
			return new Dimension(sw, sh);
		}
		return null;
	}
	protected void installAttributes(CellView view) {
		Map map = view.getAllAttributes();
		beginDeco = GraphConstants.getLineBegin(map);
		beginSize = GraphConstants.getBeginSize(map);
		beginFill = GraphConstants.isBeginFill(map) && isFillable(beginDeco);
		endDeco = GraphConstants.getLineEnd(map);
		endSize = GraphConstants.getEndSize(map);
		endFill = GraphConstants.isEndFill(map) && isFillable(endDeco);
		lineWidth = GraphConstants.getLineWidth(map);
		Edge.Routing routing = GraphConstants.getRouting(map);
		lineStyle = (routing != null && view instanceof EdgeView) ? routing.getPreferredLineStyle((EdgeView) view): Edge.Routing.NO_PREFERENCE;
		if (lineStyle == Edge.Routing.NO_PREFERENCE)lineStyle = GraphConstants.getLineStyle(map);
		lineDash = GraphConstants.getDashPattern(map);
		dashOffset = GraphConstants.getDashOffset(map);
		borderColor = GraphConstants.getBorderColor(map);
		Color foreground = GraphConstants.getLineColor(map);
		setForeground((foreground != null) ? foreground : defaultForeground);
		Color background = GraphConstants.getBackground(map);
		setBackground((background != null) ? background : defaultBackground);
		Color gradientColor = GraphConstants.getGradientColor(map);
		setGradientColor(gradientColor);
		setOpaque(GraphConstants.isOpaque(map));
		setFont(GraphConstants.getFont(map));
		Color tmp = GraphConstants.getForeground(map);
		fontColor = (tmp != null) ? tmp : getForeground();
		labelTransformEnabled = GraphConstants.isLabelAlongEdge(map);
		labelsEnabled = GraphConstants.isLabelEnabled(map);
	}
	protected boolean isFillable(int decoration) {
		return !(decoration == GraphConstants.ARROW_SIMPLE|| decoration == GraphConstants.ARROW_LINE || decoration == GraphConstants.ARROW_DOUBLELINE);
	}
	public Rectangle2D getPaintBounds(EdgeView view) {
		Rectangle2D rec = null;
		setView(view);
		if (view.getShape() != null)rec = view.getShape().getBounds();
		elserec = new Rectangle2D.Double(0, 0, 0, 0);
		return rec;
	}
	public void paint(Graphics g) {
		if (view.isLeaf()) {
			Shape edgeShape = view.getShape();
			if (edgeShape != null) {
				Graphics2D g2 = (Graphics2D) g;
				g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
				setOpaque(false);
				super.paint(g);
				translateGraphics(g);
				beforeEdgePaint(g);
				paintEdge(g);
				paintSelection(g);
				paintLabels(g);
				afterEdgePaint(g);
			}
		}
		 else {
			paintSelectionBorder(g);
		}
	}
	protected void paintLabels(Graphics g){
		Graphics2D g2 = (Graphics2D) g;
		g2.setStroke(new BasicStroke(1));
		g.setFont((extraLabelFont != null) ? extraLabelFont : getFont());
		Object[] labels = GraphConstants.getExtraLabels(view.getAllAttributes());
		JGraph graph = (JGraph) this.graph.get();
		if (labels != null){
			for (int i = 0;
			 i < labels.length;
			 i++)paintLabel(g, graph.convertValueToString(labels[i]),getExtraLabelPosition(view, i),false || !simpleExtraLabels);
		}
		if (graph.getEditingCell() != view.getCell()){
			g.setFont(getFont());
			Object label = graph.convertValueToString(view);
			if (label != null){
				paintLabel(g, label.toString(), getLabelPosition(view), true);
			}
		}
	}
	protected void paintEdge(Graphics g){
		g.setColor(getForeground());
		if (lineWidth > 0) {
			Graphics2D g2 = (Graphics2D) g;
			int c = BasicStroke.CAP_BUTT;
			int j = BasicStroke.JOIN_MITER;
			g2.setStroke(new BasicStroke(lineWidth, c, j));
			if (gradientColor != null && !preview) {
				g2.setPaint(new GradientPaint(0, 0, getBackground(),getWidth(), getHeight(), gradientColor, true));
			}
			if (view.beginShape != null) {
				if (beginFill)g2.fill(view.beginShape);
				g2.draw(view.beginShape);
			}
			if (view.endShape != null) {
				if (endFill)g2.fill(view.endShape);
				g2.draw(view.endShape);
			}
			if (lineDash != null) g2.setStroke(new BasicStroke(lineWidth, c, j, 10.0f,lineDash, dashOffset));
			if (view.lineShape != null)g2.draw(view.lineShape);
		}
	}
	protected void paintSelection(Graphics g){
		if (selected) {
			 Graphics2D g2 = (Graphics2D) g;
			g2.setStroke(GraphConstants.SELECTION_STROKE);
			g2.setColor(highlightColor);
			if (view.beginShape != null)g2.draw(view.beginShape);
			if (view.lineShape != null)g2.draw(view.lineShape);
			if (view.endShape != null)g2.draw(view.endShape);
		}
	}
	protected void beforeEdgePaint(Graphics g) {
	}
	protected void afterEdgePaint(Graphics g) {
	}
	protected void paintSelectionBorder(Graphics g) {
		((Graphics2D) g).setStroke(GraphConstants.SELECTION_STROKE);
		if (childrenSelected)g.setColor(gridColor);
		else if (focus && selected)g.setColor(lockedHandleColor);
		else if (selected)g.setColor(highlightColor);
		if (childrenSelected || selected) {
			Dimension d = getSize();
			g.drawRect(0, 0, d.width - 1, d.height - 1);
		}
	}
	protected void translateGraphics(Graphics g) {
		g.translate(-getX(), -getY());
	}
	protected void paintLabel(Graphics g, String label, Point2D p,boolean mainLabel) {
		if (labelsEnabled && p != null && label != null && label.length() > 0 && metrics != null) {
			int sw = metrics.stringWidth(label);
			int sh = metrics.getHeight();
			Graphics2D g2 = (Graphics2D) g;
			boolean applyTransform = isLabelTransform(label);
			double angle = 0;
			int dx = -sw / 2;
			int offset = isMoveBelowZero || applyTransform ? 0 : Math.min(0, (int) (dx + p.getX()));
			g2.translate(p.getX() - offset, p.getY());
			if (applyTransform) {
				angle = getLabelAngle(label);
				g2.rotate(angle);
			}
			if (isOpaque() && mainLabel) {
				g.setColor(getBackground());
				g.fillRect(-sw / 2 - 1, -sh / 2 - 1, sw + 2,sh + 2);
			}
			if (borderColor != null && mainLabel) {
				g.setColor(borderColor);
				g.drawRect(-sw / 2 - 1, -sh / 2 - 1, sw + 2,sh + 2);
			}
			int dy = +sh / 4;
			g.setColor(fontColor);
			if (applyTransform && borderColor == null && !isOpaque()) {
				dy = -metrics.getDescent();
			}
			g.drawString(label, dx, dy);
			if (applyTransform) {
				g2.rotate(-angle);
			}
			g2.translate(-p.getX() + offset, -p.getY());
		}
	}
	protected Shape createShape() {
		int n = view.getPointCount();
		if (n > 1) {
			EdgeView tmp = view;
			Point2D[] p = null;
			p = new Point2D[n];
			for (int i = 0;
			 i < n;
			 i++) {
				Point2D pt = tmp.getPoint(i);
				if (pt == null)return null;
				 p[i] = new Point2D.Double(pt.getX(), pt.getY());
			}
			if (view != tmp) {
				view = tmp;
				installAttributes(view);
			}
			if (view.sharedPath == null) {
				view.sharedPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, n);
			}
			 else {
				view.sharedPath.reset();
			}
			view.beginShape = view.lineShape = view.endShape = null;
			Point2D p0 = p[0];
			Point2D pe = p[n - 1];
			Point2D p1 = p[1];
			Point2D p2 = p[n - 2];
			if (lineStyle == GraphConstants.STYLE_BEZIER && n > 2) {
				bezier = new Bezier(p);
				p2 = bezier.getPoint(bezier.getPointCount() - 1);
			}
			 else if (lineStyle == GraphConstants.STYLE_SPLINE && n > 2) {
				spline = new Spline2D(p);
				double[] point = spline.getPoint(0.9875);
				double scaledX = pe.getX() - ((pe.getX() - point[0]) * 128);
				double scaledY = pe.getY() - ((pe.getY() - point[1]) * 128);
				p2.setLocation(scaledX, scaledY);
			}
			if (beginDeco != GraphConstants.ARROW_NONE) {
				view.beginShape = createLineEnd(beginSize, beginDeco, p1, p0);
			}
			if (endDeco != GraphConstants.ARROW_NONE) {
				view.endShape = createLineEnd(endSize, endDeco, p2, pe);
			}
			view.sharedPath.moveTo((float) p0.getX(), (float) p0.getY());
			if (lineStyle == GraphConstants.STYLE_BEZIER && n > 2) {
				Point2D[] b = bezier.getPoints();
				view.sharedPath.quadTo((float) b[0].getX(),(float) b[0].getY(), (float) p1.getX(), (float) p1.getY());
				for (int i = 2;
				 i < n - 1;
				 i++) {
					Point2D b0 = b[2 * i - 3];
					Point2D b1 = b[2 * i - 2];
					view.sharedPath.curveTo((float) b0.getX(), (float) b0.getY(), (float) b1.getX(), (float) b1.getY(),(float) p[i].getX(), (float) p[i].getY());
				}
				view.sharedPath.quadTo((float) b[b.length - 1].getX(),(float) b[b.length - 1].getY(),(float) p[n - 1].getX(), (float) p[n - 1].getY());
			}
			 else if (lineStyle == GraphConstants.STYLE_SPLINE && n > 2) {
				for (double t = 0;
				 t <= 1;
				 t += 0.0125) {
					double[] xy = spline.getPoint(t);
					view.sharedPath.lineTo((float) xy[0], (float) xy[1]);
				}
			}
			else {
				for (int i = 1;
				 i < n - 1;
				 i++)view.sharedPath.lineTo((float) p[i].getX(), (float) p[i].getY());
				view.sharedPath.lineTo((float) pe.getX(), (float) pe.getY());
			}
			view.sharedPath.moveTo((float) pe.getX(), (float) pe.getY());
			if (view.endShape == null && view.beginShape == null) {
				view.lineShape = view.sharedPath;
			}
			 else {
				view.lineShape = (GeneralPath) view.sharedPath.clone();
				if (view.endShape != null)view.sharedPath.append(view.endShape, true);
				if (view.beginShape != null)view.sharedPath.append(view.beginShape, true);
			}
			return view.sharedPath;
		}
		return null;
	}
	protected Shape createLineEnd(int size, int style, Point2D src, Point2D dst) {
		if (src == null || dst == null)return null;
		int d = (int) Math.max(1, dst.distance(src));
		int ax = (int) -(size * (dst.getX() - src.getX()) / d);
		int ay = (int) -(size * (dst.getY() - src.getY()) / d);
		if (style == GraphConstants.ARROW_DIAMOND) {
			Polygon poly = new Polygon();
			poly.addPoint((int) dst.getX(), (int) dst.getY());
			poly.addPoint((int) (dst.getX() + ax / 2 + ay / 3), (int) (dst.getY()+ ay / 2 - ax / 3));
			Point2D last = (Point2D) dst.clone();
			dst.setLocation(dst.getX() + ax, dst.getY() + ay);
			poly.addPoint((int) dst.getX(), (int) dst.getY());
			poly.addPoint((int) (last.getX() + ax / 2 - ay / 3), (int) (last.getY()+ ay / 2 + ax / 3));
			return poly;
		}
		 else if (style == GraphConstants.ARROW_TECHNICAL|| style == GraphConstants.ARROW_CLASSIC) {
			Polygon poly = new Polygon();
			poly.addPoint((int) dst.getX(), (int) dst.getY());
			poly.addPoint((int) (dst.getX() + ax + ay / 2), (int) (dst.getY()+ ay - ax / 2));
			Point2D last = (Point2D) dst.clone();
			if (style == GraphConstants.ARROW_CLASSIC) {
				dst.setLocation((int) (dst.getX() + ax * 2 / 3), (int) (dst.getY() + ay * 2 / 3));
				poly.addPoint((int) dst.getX(), (int) dst.getY());
			}
			 else if (style == GraphConstants.ARROW_DIAMOND) {
				dst.setLocation(dst.getX() + 2 * ax, dst.getY() + 2 * ay);
				poly.addPoint((int) dst.getX(), (int) dst.getY());
			}
			 elsedst.setLocation((int) (dst.getX() + ax),(int) (dst.getY() + ay));
			poly.addPoint((int) (last.getX() + ax - ay / 2), (int) (last.getY()+ ay + ax / 2));
			return poly;
		}
		 else if (style == GraphConstants.ARROW_SIMPLE) {
			GeneralPath path = new GeneralPath(GeneralPath.WIND_NON_ZERO, 4);
			path.moveTo((float) (dst.getX() + ax + ay / 2), (float) (dst.getY()+ ay - ax / 2));
			path.lineTo((float) dst.getX(), (float) dst.getY());
			path.lineTo((float) (dst.getX() + ax - ay / 2), (float) (dst.getY()+ ay + ax / 2));
			return path;
		}
		 else if (style == GraphConstants.ARROW_CIRCLE) {
			Ellipse2D ellipse = new Ellipse2D.Float((float) (dst.getX() + ax/ 2 - size / 2), (float) (dst.getY() + ay / 2 - size / 2),size, size);
			dst.setLocation(dst.getX() + ax, dst.getY() + ay);
			return ellipse;
		}
		 else if (style == GraphConstants.ARROW_LINE|| style == GraphConstants.ARROW_DOUBLELINE) {
			GeneralPath path = new GeneralPath(GeneralPath.WIND_NON_ZERO, 4);
			path.moveTo((float) (dst.getX() + ax / 2 + ay / 2), (float) (dst.getY()+ ay / 2 - ax / 2));
			path.lineTo((float) (dst.getX() + ax / 2 - ay / 2), (float) (dst.getY()+ ay / 2 + ax / 2));
			if (style == GraphConstants.ARROW_DOUBLELINE) {
				path.moveTo((float) (dst.getX() + ax / 3 + ay / 2),(float) (dst.getY() + ay / 3 - ax / 2));
				path.lineTo((float) (dst.getX() + ax / 3 - ay / 2),(float) (dst.getY() + ay / 3 + ax / 2));
			}
			return path;
		}
		return null;
	}
	public Color getGradientColor() {
		return gradientColor;
	}
	public void setGradientColor(Color gradientColor) {
		this.gradientColor = gradientColor;
	}
	public void validate() {
	}
	public void revalidate() {
	}
	public void repaint(long tm, int x, int y, int width, int height) {
	}
	public void repaint(Rectangle r) {
	}
	protected void firePropertyChange(String propertyName, Object oldValue,Object newValue) {
		if (propertyName == ""text"")super.firePropertyChange(propertyName, oldValue, newValue);
	}
	public void firePropertyChange(String propertyName, byte oldValue,byte newValue) {
	}
	public void firePropertyChange(String propertyName, char oldValue,char newValue) {
	}
	public void firePropertyChange(String propertyName, short oldValue,short newValue) {
	}
	public void firePropertyChange(String propertyName, int oldValue,int newValue) {
	}
	public void firePropertyChange(String propertyName, long oldValue,long newValue) {
	}
	public void firePropertyChange(String propertyName, float oldValue,float newValue) {
	}
	public void firePropertyChange(String propertyName, double oldValue,double newValue) {
	}
	public void firePropertyChange(String propertyName, boolean oldValue,boolean newValue) {
	}
}",1,0,0,0
"private void describeKeySpace(String keySpaceName, KsDef metadata) throws TException {
	 NodeProbe probe = sessionState.getNodeProbe();
	 CompactionManagerMBean compactionManagerMBean = (probe == null) ? null : probe.getCompactionManagerProxy();
	 sessionState.out.println(""Keyspace: "" + keySpaceName + "":"");
	 try {
		 KsDef ks_def;
		 ks_def = metadata == null ? thriftClient.describe_keyspace(keySpaceName) : metadata;
		 sessionState.out.println("" Replication Strategy: "" + ks_def.strategy_class);
		 if (ks_def.strategy_class.endsWith("".NetworkTopologyStrategy"")) {
			 Map<String, String> options = ks_def.strategy_options;
			 sessionState.out.println("" Options: ["" + ((options == null) ? """" : FBUtilities.toString(options)) + ""]"");
		 }
		 else {
			 sessionState.out.println("" Replication Factor: "" + ks_def.replication_factor);
		 }
		 sessionState.out.println("" Column Families:"");
		 boolean isSuper;
		 Collections.sort(ks_def.cf_defs, new CfDefNamesComparator());
		 for (CfDef cf_def : ks_def.cf_defs) {
			 ColumnFamilyStoreMBean cfMBean = (probe == null) ? null : probe.getCfsProxy(ks_def.getName(), cf_def.getName());
			 isSuper = cf_def.column_type.equals(""Super"");
			 sessionState.out.printf("" ColumnFamily: %s%s%n"", cf_def.name, isSuper ? "" (Super)"" : """");
			 if (cf_def.comment != null && !cf_def.comment.isEmpty()) {
				 sessionState.out.printf("" \""%s\""%n"", cf_def.comment);
			 }
			 sessionState.out.printf("" Columns sorted by: %s%s%n"", cf_def.comparator_type, cf_def.column_type.equals(""Super"") ? ""/"" + cf_def.subcomparator_type : """");
			 sessionState.out.printf("" Row cache size / save period: %s/%s%n"", cf_def.row_cache_size, cf_def.row_cache_save_period_in_seconds);
			 sessionState.out.printf("" Key cache size / save period: %s/%s%n"", cf_def.key_cache_size, cf_def.key_cache_save_period_in_seconds);
			 sessionState.out.printf("" Memtable thresholds: %s/%s/%s%n"", cf_def.memtable_operations_in_millions, cf_def.memtable_throughput_in_mb, cf_def.memtable_flush_after_mins);
			 sessionState.out.printf("" GC grace seconds: %s%n"", cf_def.gc_grace_seconds);
			 sessionState.out.printf("" Compaction min/max thresholds: %s/%s%n"", cf_def.min_compaction_threshold, cf_def.max_compaction_threshold);
			 sessionState.out.printf("" Read repair chance: %s%n"", cf_def.read_repair_chance);
			 if (cfMBean != null) {
				 sessionState.out.printf("" Built indexes: %s%n"", cfMBean.getBuiltIndexes());
			 }
			 if (cf_def.getColumn_metadataSize() != 0) {
				 String leftSpace = "" "";
				 String columnLeftSpace = leftSpace + "" "";
				 AbstractType columnNameValidator = getFormatTypeForColumn(isSuper ? cf_def.subcomparator_type : cf_def.comparator_type);
				 sessionState.out.println(leftSpace + ""Column Metadata:"");
				 for (ColumnDef columnDef : cf_def.getColumn_metadata()) {
					 String columnName = columnNameValidator.getString(columnDef.name);
					 if (columnNameValidator instanceof BytesType) {
						 try {
							 String columnString = UTF8Type.instance.getString(columnDef.name);
							 columnName = columnString + "" ("" + columnName + "")"";
						 }
						 catch (MarshalException e) {
						 }
					 }
					 sessionState.out.println(leftSpace + "" Column Name: "" + columnName);
					 sessionState.out.println(columnLeftSpace + ""Validation Class: "" + columnDef.getValidation_class());
					 if (columnDef.isSetIndex_name()) {
						 sessionState.out.println(columnLeftSpace + ""Index Name: "" + columnDef.getIndex_name());
					 }
					 if (columnDef.isSetIndex_type()) {
						 sessionState.out.println(columnLeftSpace + ""Index Type: "" + columnDef.getIndex_type().name());
					 }
				 }
			 }
		 }
		 if (compactionManagerMBean != null) {
			 String compactionType = compactionManagerMBean.getCompactionType();
			 if (compactionType != null && compactionType.contains(""index build"")) {
				 String indexName = compactionManagerMBean.getColumnFamilyInProgress();
				 long bytesCompacted = compactionManagerMBean.getBytesCompacted();
				 long totalBytesToProcess = compactionManagerMBean.getBytesTotalInProgress();
				 sessionState.out.printf(""%nCurrently building index %s, completed %d of %d bytes.%n"", indexName, bytesCompacted, totalBytesToProcess);
			 }
		 }
		 if (probe != null) probe.close();
	 }
	 catch (InvalidRequestException e) {
		 sessionState.out.println(""Invalid request: "" + e);
	 }
	 catch (NotFoundException e) {
		 sessionState.out.println(""Keyspace "" + keySpaceName + "" could not be found."");
	 }
	 catch (IOException e) {
		 sessionState.out.println(""Error while closing JMX connection: "" + e.getMessage());
	 }
 }",0,0,1,0
"public static class GleSYSBooleanAdapter extends TypeAdapter<GleSYSBoolean> {
	 public void write(JsonWriter writer, GleSYSBoolean value) throws IOException {
		 writer.value(value.getValue() ? ""yes"" : ""no"");
	 }
	 public GleSYSBoolean read(JsonReader in) throws IOException {
		 if (in.peek() == JsonToken.BOOLEAN) {
			 return new GleSYSBoolean(in.nextBoolean());
		 }
		 else if (in.peek() == JsonToken.NULL) {
			 return GleSYSBoolean.FALSE;
		 }
		 else {
			 return new GleSYSBoolean(Objects.equal(in.nextString(), ""yes""));
		 }
	 }
 }",0,0,0,0
"public int columnCount() {
	 return columnCount;
 }",0,0,0,0
"public class ColumnFamilySplit extends InputSplit implements Writable, org.apache.hadoop.mapred.InputSplit{
	 private String startToken;
	 private String endToken;
	 private String[] dataNodes;
	 public ColumnFamilySplit(String startToken, String endToken, String[] dataNodes) {
		 assert startToken != null;
		 assert endToken != null;
		 this.startToken = startToken;
		 this.endToken = endToken;
		 this.dataNodes = dataNodes;
	 }
	 public String getStartToken() {
		 return startToken;
	 }
	 public String getEndToken() {
		 return endToken;
	 }
	 public long getLength() {
		 return Long.MAX_VALUE;
	 }
	 public String[] getLocations() {
		 return dataNodes;
	 }
	 protected ColumnFamilySplit() {
	}
	 public void write(DataOutput out) throws IOException {
		 out.writeUTF(startToken);
		 out.writeUTF(endToken);
		 out.writeInt(dataNodes.length);
		 for (String endpoint : dataNodes) {
			 out.writeUTF(endpoint);
		 }
	 }
	 public void readFields(DataInput in) throws IOException {
		 startToken = in.readUTF();
		 endToken = in.readUTF();
		 int numOfEndpoints = in.readInt();
		 dataNodes = new String[numOfEndpoints];
		 for(int i = 0;
		 i < numOfEndpoints;
		 i++) {
			 dataNodes[i] = in.readUTF();
		 }
	 }
	 public String toString() {
		 return ""ColumnFamilySplit("" + ""("" + startToken + "", '"" + endToken + ']' + "" @"" + (dataNodes == null ? null : Arrays.asList(dataNodes)) + ')';
	 }
	 public static ColumnFamilySplit read(DataInput in) throws IOException {
		 ColumnFamilySplit w = new ColumnFamilySplit();
		 w.readFields(in);
		 return w;
	 }
}",0,0,0,0
"protected MqttDeliveryToken restoreToken(MqttPublish message) {
	final String methodName = ""restoreToken"";
	MqttDeliveryToken token;
	synchronized(tokens) {
		String key = Integer.toString(message.getMessageId());
		if (this.tokens.containsKey(key)) {
			token = (MqttDeliveryToken)this.tokens.get(key);
			log.fine(CLASS_NAME,methodName, ""302"",new Object[]{
			key, message,token}
			);
		}
		 else {
			token = new MqttDeliveryToken(logContext);
			token.internalTok.setKey(key);
			this.tokens.put(key, token);
			log.fine(CLASS_NAME,methodName,""303"",new Object[]{
			key, message, token}
			);
		}
	}
	return token;
}",0,0,1,0
"public class Method_getParameterTypes01 extends JTTTest {
	 public static int test(int arg) throws NoSuchMethodException {
		 if (arg == 0) {
			 return Method_getParameterTypes01.class.getMethod(""method1"").getParameterTypes().length;
		 }
		 else if (arg == 1) {
			 return Method_getParameterTypes01.class.getMethod(""method2"", int.class).getParameterTypes().length;
		 }
		 else if (arg == 2) {
			 return Method_getParameterTypes01.class.getMethod(""method3"", int.class, Object.class).getParameterTypes().length;
		 }
		 return -1;
	 }
	 public int method1() {
		 return 0;
	 }
	 public void method2(int arg1) {
	 }
	 public void method3(int arg1, Object arg2) {
	 }
	 public void run0() throws Throwable {
		 runTest(""test"", 0);
	 }
	 public void run1() throws Throwable {
		 runTest(""test"", 1);
	 }
	 public void run2() throws Throwable {
		 runTest(""test"", 2);
	 }
	 public void run3() throws Throwable {
		 runTest(""test"", 3);
	 }
}",0,0,0,0
"public class _Repository4Soap_QueryPendingSetsWithLocalWorkspaces implements ElementSerializable{
	 protected String localWorkspaceName;
	 protected String localWorkspaceOwner;
	 protected String queryWorkspaceName;
	 protected String ownerName;
	 protected _ItemSpec[] itemSpecs;
	 protected boolean generateDownloadUrls;
	 protected String[] itemPropertyFilters;
	 public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces() {
		 super();
	 }
	 public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces( final String localWorkspaceName, final String localWorkspaceOwner, final String queryWorkspaceName, final String ownerName, final _ItemSpec[] itemSpecs, final boolean generateDownloadUrls, final String[] itemPropertyFilters) {
		 setLocalWorkspaceName(localWorkspaceName);
		 setLocalWorkspaceOwner(localWorkspaceOwner);
		 setQueryWorkspaceName(queryWorkspaceName);
		 setOwnerName(ownerName);
		 setItemSpecs(itemSpecs);
		 setGenerateDownloadUrls(generateDownloadUrls);
		 setItemPropertyFilters(itemPropertyFilters);
	 }
	 public String getLocalWorkspaceName() {
		 return this.localWorkspaceName;
	 }
	 public void setLocalWorkspaceName(String value) {
		 this.localWorkspaceName = value;
	 }
	 public String getLocalWorkspaceOwner() {
		 return this.localWorkspaceOwner;
	 }
	 public void setLocalWorkspaceOwner(String value) {
		 this.localWorkspaceOwner = value;
	 }
	 public String getQueryWorkspaceName() {
		 return this.queryWorkspaceName;
	 }
	 public void setQueryWorkspaceName(String value) {
		 this.queryWorkspaceName = value;
	 }
	 public String getOwnerName() {
		 return this.ownerName;
	 }
	 public void setOwnerName(String value) {
		 this.ownerName = value;
	 }
	 public _ItemSpec[] getItemSpecs() {
		 return this.itemSpecs;
	 }
	 public void setItemSpecs(_ItemSpec[] value) {
		 this.itemSpecs = value;
	 }
	 public boolean isGenerateDownloadUrls() {
		 return this.generateDownloadUrls;
	 }
	 public void setGenerateDownloadUrls(boolean value) {
		 this.generateDownloadUrls = value;
	 }
	 public String[] getItemPropertyFilters() {
		 return this.itemPropertyFilters;
	 }
	 public void setItemPropertyFilters(String[] value) {
		 this.itemPropertyFilters = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 XMLStreamWriterHelper.writeElement( writer, ""localWorkspaceName"", this.localWorkspaceName);
		 XMLStreamWriterHelper.writeElement( writer, ""localWorkspaceOwner"", this.localWorkspaceOwner);
		 XMLStreamWriterHelper.writeElement( writer, ""queryWorkspaceName"", this.queryWorkspaceName);
		 XMLStreamWriterHelper.writeElement( writer, ""ownerName"", this.ownerName);
		 if (this.itemSpecs != null) {
			 writer.writeStartElement(""itemSpecs"");
			 for (int iterator0 = 0;
			 iterator0 < this.itemSpecs.length;
			 iterator0++) {
				 this.itemSpecs[iterator0].writeAsElement( writer, ""ItemSpec"");
			 }
			 writer.writeEndElement();
		 }
		 XMLStreamWriterHelper.writeElement( writer, ""generateDownloadUrls"", this.generateDownloadUrls);
		 if (this.itemPropertyFilters != null) {
			 writer.writeStartElement(""itemPropertyFilters"");
			 for (int iterator0 = 0;
			 iterator0 < this.itemPropertyFilters.length;
			 iterator0++) {
				 XMLStreamWriterHelper.writeElement( writer, ""string"", this.itemPropertyFilters[iterator0]);
			 }
			 writer.writeEndElement();
		 }
		 writer.writeEndElement();
	 }
}",1,1,0,0
"public boolean add(Process process) {
	 synchronized (processes) {
		 if (processes.size() == 0) {
			 addShutdownHook();
		 }
		 processes.addElement(process);
		 return processes.contains(process);
	 }
 }",0,0,0,0
"private void addDataAccessNodes(UaFolderNode rootNode) {
	 UaFolderNode dataAccessFolder = new UaFolderNode( getNodeContext(), newNodeId(""HelloWorld/DataAccess""), newQualifiedName(""DataAccess""), LocalizedText.english(""DataAccess"") );
	 getNodeManager().addNode(dataAccessFolder);
	 rootNode.addOrganizes(dataAccessFolder);
	 try {
		 AnalogItemNode node = (AnalogItemNode) getNodeFactory().createNode( newNodeId(""HelloWorld/DataAccess/AnalogValue""), Identifiers.AnalogItemType, true );
		 node.setBrowseName(newQualifiedName(""AnalogValue""));
		 node.setDisplayName(LocalizedText.english(""AnalogValue""));
		 node.setDataType(Identifiers.Double);
		 node.setValue(new DataValue(new Variant(3.14d)));
		 node.setEURange(new Range(0.0, 100.0));
		 getNodeManager().addNode(node);
		 dataAccessFolder.addOrganizes(node);
	 }
	 catch (UaException e) {
		 logger.error(""Error creating AnalogItemType instance: {
		}
		"", e.getMessage(), e);
	 }
 }",0,0,1,0
"public class CommitLogSegment{
	 private static final Logger logger = LoggerFactory.getLogger(CommitLogSegment.class);
	 private static Pattern COMMIT_LOG_FILE_PATTERN = Pattern.compile(""CommitLog-(\\d+).log"");
	 public final long id;
	 private final BufferedRandomAccessFile logWriter;
	 private Map<Integer, Integer> cfLastWrite = new HashMap<Integer, Integer>();
	 public CommitLogSegment() {
		 id = System.currentTimeMillis();
		 String logFile = DatabaseDescriptor.getCommitLogLocation() + File.separator + ""CommitLog-"" + id + "".log"";
		 logger.info(""Creating new commitlog segment "" + logFile);
		 try {
			 logWriter = createWriter(logFile);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public static long idFromFilename(String filename) {
		 Matcher matcher = COMMIT_LOG_FILE_PATTERN.matcher(filename);
		 try {
			 if (matcher.matches()) return Long.valueOf(matcher.group(1));
			 else return -1L;
		 }
		 catch (NumberFormatException e) {
			 return -1L;
		 }
	 }
	 public static boolean possibleCommitLogFile(String filename) {
		 return COMMIT_LOG_FILE_PATTERN.matcher(filename).matches();
	 }
	 private static BufferedRandomAccessFile createWriter(String file) throws IOException {
		 return new BufferedRandomAccessFile(new File(file), ""rw"", 128 * 1024, true);
	 }
	 public ReplayPosition write(RowMutation rowMutation) throws IOException {
		 long currentPosition = -1L;
		 try {
			 currentPosition = logWriter.getFilePointer();
			 assert currentPosition <= Integer.MAX_VALUE;
			 ReplayPosition cLogCtx = new ReplayPosition(id, (int) currentPosition);
			 for (ColumnFamily columnFamily : rowMutation.getColumnFamilies()) {
				 CFMetaData cfm = DatabaseDescriptor.getCFMetaData(columnFamily.id());
				 if (cfm == null) {
					 logger.error(""Attempted to write commit log entry for unrecognized column family: "" + columnFamily.id());
				 }
				 else {
					 turnOn(cfm.cfId, (int) currentPosition);
				 }
			 }
			 Checksum checksum = new CRC32();
			 byte[] serializedRow = rowMutation.getSerializedBuffer(MessagingService.version_);
			 checksum.update(serializedRow.length);
			 logWriter.writeInt(serializedRow.length);
			 logWriter.writeLong(checksum.getValue());
			 logWriter.write(serializedRow);
			 checksum.update(serializedRow, 0, serializedRow.length);
			 logWriter.writeLong(checksum.getValue());
			 return cLogCtx;
		 }
		 catch (IOException e) {
			 if (currentPosition != -1) logWriter.seek(currentPosition);
			 throw e;
		 }
	 }
	 public void sync() throws IOException {
		 logWriter.sync();
	 }
	 public ReplayPosition getContext() {
		 long position = logWriter.getFilePointer();
		 assert position <= Integer.MAX_VALUE;
		 return new ReplayPosition(id, (int) position);
	 }
	 public String getPath() {
		 return logWriter.getPath();
	 }
	 public String getName() {
		 return logWriter.getPath().substring(logWriter.getPath().lastIndexOf(File.separator) + 1);
	 }
	 public long length() {
		 try {
			 return logWriter.length();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public void close() {
		 try {
			 logWriter.close();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 void turnOn(Integer cfId, Integer position) {
		 cfLastWrite.put(cfId, position);
	 }
	 void turnOffIfNotWritten(Integer cfId, Integer flushPosition) {
		 Integer lastWritten = cfLastWrite.get(cfId);
		 if (lastWritten == null || lastWritten < flushPosition) cfLastWrite.remove(cfId);
	 }
	 void turnOff(Integer cfId) {
		 cfLastWrite.remove(cfId);
	 }
	 String dirtyString() {
		 StringBuilder sb = new StringBuilder();
		 for (Integer cfId : cfLastWrite.keySet()) {
			 CFMetaData m = DatabaseDescriptor.getCFMetaData(cfId);
			 sb.append(m == null ? m.cfName : ""<deleted>"").append("" ("").append(cfId).append(""), "");
		 }
		 return sb.toString();
	 }
	 boolean isSafeToDelete() {
		 return cfLastWrite.isEmpty();
	 }
	 public String toString() {
		 return ""CommitLogSegment("" + logWriter.getPath() + ')';
	 }
}",0,0,0,0
"public class XmppEndpoint extends DefaultEndpoint implements HeaderFilterStrategyAware {
	 private volatile XMPPTCPConnection connection;
	 private XmppBinding binding;
	 private String host;
	 private int port;
	 private String participant;
	 private String user;
	 private String password;
	 private String resource = ""Camel"";
	 private boolean login = true;
	 private boolean createAccount;
	 private String room;
	 private String nickname;
	 private String serviceName;
	 private boolean pubsub;
	 private boolean doc;
	 private boolean testConnectionOnStartup = true;
	 private int connectionPollDelay = 10;
	 private HeaderFilterStrategy headerFilterStrategy = new DefaultHeaderFilterStrategy();
	 private ConnectionConfiguration connectionConfig;
	 public XmppEndpoint() {
	 }
	 public XmppEndpoint(String uri, XmppComponent component) {
		 super(uri, component);
	 }
	 public Producer createProducer() throws Exception {
		 if (room != null) {
			 return createGroupChatProducer();
		 }
		 else {
			 if (isPubsub()) {
				 return createPubSubProducer();
			 }
			 if (isDoc()) {
				 return createDirectProducer();
			 }
			 if (getParticipant() == null) {
				 throw new IllegalArgumentException(""No room or participant configured on this endpoint: "" + this);
			 }
			 return createPrivateChatProducer(getParticipant());
		 }
	 }
	 public Producer createGroupChatProducer() throws Exception {
		 return new XmppGroupChatProducer(this);
	 }
	 public Producer createPrivateChatProducer(String participant) throws Exception {
		 return new XmppPrivateChatProducer(this, participant);
	 }
	 public Producer createDirectProducer() throws Exception {
		 return new XmppDirectProducer(this);
	 }
	 public Producer createPubSubProducer() throws Exception {
		 return new XmppPubSubProducer(this);
	 }
	 public Consumer createConsumer(Processor processor) throws Exception {
		 XmppConsumer answer = new XmppConsumer(this, processor);
		 configureConsumer(answer);
		 return answer;
	 }
	 public Exchange createExchange(Stanza packet) {
		 Exchange exchange = super.createExchange();
		 exchange.setProperty(Exchange.BINDING, getBinding());
		 exchange.setIn(new XmppMessage(exchange, packet));
		 return exchange;
	 }
	 protected String createEndpointUri() {
	 return ""xmpp: }
	 public boolean isSingleton() {
		 return true;
	 }
	 public synchronized XMPPTCPConnection createConnection() throws InterruptedException, IOException, SmackException, XMPPException {
		 if (connection != null && connection.isConnected()) {
			 return connection;
		 }
		 connection = null;
		 log.trace(""Creating new connection ..."");
		 XMPPTCPConnection newConnection = createConnectionInternal();
		 newConnection.connect();
		 newConnection.addSyncStanzaListener(new XmppLogger(""INBOUND""), stanza -> true);
		 newConnection.addSyncStanzaListener(new XmppLogger(""OUTBOUND""), stanza -> true);
		 if (!newConnection.isAuthenticated()) {
			 if (user != null) {
				 if (log.isDebugEnabled()) {
					 log.debug(""Logging in to XMPP as user: {
					}
					 on connection: {
					}
					"", user, getConnectionMessage(newConnection));
				 }
				 if (password == null) {
					 log.warn(""No password configured for user: {
					}
					 on connection: {
					}
					"", user, getConnectionMessage(newConnection));
				 }
				 if (createAccount) {
					 AccountManager accountManager = AccountManager.getInstance(newConnection);
					 accountManager.createAccount(Localpart.from(user), password);
				 }
				 if (login) {
					 if (resource != null) {
						 newConnection.login(user, password, Resourcepart.from(resource));
					 }
					 else {
						 newConnection.login(user, password);
					 }
				 }
			 }
			 else {
				 if (log.isDebugEnabled()) {
					 log.debug(""Logging in anonymously to XMPP on connection: {
					}
					"", getConnectionMessage(newConnection));
				 }
				 newConnection.login();
			 }
		 }
		 log.debug(""Created new connection successfully: {
		}
		"", newConnection);
		 connection = newConnection;
		 return connection;
	 }
	 private XMPPTCPConnection createConnectionInternal() throws UnknownHostException, XmppStringprepException {
		 if (connectionConfig != null) {
			 return new XMPPTCPConnection(ObjectHelper.cast(XMPPTCPConnectionConfiguration.class, connectionConfig));
		 }
		 if (port == 0) {
			 port = 5222;
		 }
		 String sName = getServiceName() == null ? host : getServiceName();
		 XMPPTCPConnectionConfiguration conf = XMPPTCPConnectionConfiguration.builder() .setHostAddress(InetAddress.getByName(host)) .setPort(port) .setXmppDomain(sName) .build();
		 return new XMPPTCPConnection(conf);
	 }
	 public String resolveRoom(XMPPConnection connection) throws InterruptedException, SmackException, XMPPException {
		 StringHelper.notEmpty(room, ""room"");
		 if (room.indexOf('@', 0) != -1) {
			 return room;
		 }
		 MultiUserChatManager multiUserChatManager = MultiUserChatManager.getInstanceFor(connection);
		 List<DomainBareJid> xmppServiceDomains = multiUserChatManager.getXMPPServiceDomains();
		 if (xmppServiceDomains.isEmpty()) {
			 throw new XMPPErrorException(null, StanzaError.from(Condition.item_not_found, ""Cannot find any XMPPServiceDomain by MultiUserChatManager on connection: "" + getConnectionMessage(connection)).build());
		 }
		 return room + ""@"" + xmppServiceDomains.iterator().next();
	 }
	 public String getConnectionDescription() {
		 return host + "":"" + port + ""/"" + serviceName;
	 }
	 public static String getConnectionMessage(XMPPConnection connection) {
		 return connection.getHost() + "":"" + connection.getPort() + ""/"" + connection.getXMPPServiceDomain();
	 }
	 public String getChatId() {
		 return ""Chat:"" + getParticipant() + "":"" + getUser();
	 }
	 public XmppBinding getBinding() {
		 if (binding == null) {
			 binding = new XmppBinding(headerFilterStrategy);
		 }
		 return binding;
	 }
	 public void setBinding(XmppBinding binding) {
		 this.binding = binding;
	 }
	 public String getHost() {
		 return host;
	 }
	 public void setHost(String host) {
		 this.host = host;
	 }
	 public int getPort() {
		 return port;
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public String getUser() {
		 return user;
	 }
	 public void setUser(String user) {
		 this.user = user;
	 }
	 public String getPassword() {
		 return password;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public String getResource() {
		 return resource;
	 }
	 public void setResource(String resource) {
		 this.resource = resource;
	 }
	 public boolean isLogin() {
		 return login;
	 }
	 public void setLogin(boolean login) {
		 this.login = login;
	 }
	 public boolean isCreateAccount() {
		 return createAccount;
	 }
	 public void setCreateAccount(boolean createAccount) {
		 this.createAccount = createAccount;
	 }
	 public String getRoom() {
		 return room;
	 }
	 public void setRoom(String room) {
		 this.room = room;
	 }
	 public String getParticipant() {
		 return participant != null ? participant : user;
	 }
	 public void setParticipant(String participant) {
		 this.participant = participant;
	 }
	 public String getNickname() {
		 return nickname != null ? nickname : getUser();
	 }
	 public void setNickname(String nickname) {
		 this.nickname = nickname;
	 }
	 public void setServiceName(String serviceName) {
		 this.serviceName = serviceName;
	 }
	 public String getServiceName() {
		 return serviceName;
	 }
	 public HeaderFilterStrategy getHeaderFilterStrategy() {
		 return headerFilterStrategy;
	 }
	 public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
		 this.headerFilterStrategy = headerFilterStrategy;
	 }
	 public ConnectionConfiguration getConnectionConfig() {
		 return connectionConfig;
	 }
	 public void setConnectionConfig(ConnectionConfiguration connectionConfig) {
		 this.connectionConfig = connectionConfig;
	 }
	 public boolean isTestConnectionOnStartup() {
		 return testConnectionOnStartup;
	 }
	 public void setTestConnectionOnStartup(boolean testConnectionOnStartup) {
		 this.testConnectionOnStartup = testConnectionOnStartup;
	 }
	 public int getConnectionPollDelay() {
		 return connectionPollDelay;
	 }
	 public void setConnectionPollDelay(int connectionPollDelay) {
		 this.connectionPollDelay = connectionPollDelay;
	 }
	 public void setPubsub(boolean pubsub) {
		 this.pubsub = pubsub;
		 if (pubsub) {
			 setDoc(true);
		 }
	 }
	 public boolean isPubsub() {
		 return pubsub;
	 }
	 public void setDoc(boolean doc) {
		 this.doc = doc;
	 }
	 public boolean isDoc() {
		 return doc;
	 }
	 protected void doStop() throws Exception {
		 if (connection != null) {
			 connection.disconnect();
		 }
		 connection = null;
		 binding = null;
	 }
}",0,0,0,0
"public void processAdd(GenericRequest request, GenericResponse response) throws BadInputException, CreateException, DatabaseException, IOException, ForeignKeyNotFoundException, AuthenticationException, ObjectNotFoundException, InterceptorException {
	 SecurityUtil.checkHttpPostMethod(request);
	 Locale locale = I18nUtil.getLocaleInRequest(request);
	 if (MVNForumConfig.getEnableMessageAttachment() == false) {
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""java.lang.IllegalStateException.message_attachment_is_disabled"");
		 throw new IllegalStateException(localizedMessage);
	 }
	 OnlineUser onlineUser = onlineUserManager.getOnlineUser(request);
	 MVNForumPermission permission = onlineUser.getPermission();
	 permission.ensureIsAuthenticated();
	 permission.ensureCanUseMessage();
	 permission.ensureCanAddMessageAttachment();
	 MyUtil.saveVNTyperMode(request, response);
	 final int UNLIMITED = -1;
	 int sizeMax = permission.canAdminSystem() ? UNLIMITED : MVNForumConfig.getMaxMessageAttachmentSize();
	 int sizeThreshold = 100000;
	 String tempDir = MVNForumConfig.getTempDir();
	 log.debug(""PmAttachmentWebHandler : process upload with temp dir = "" + tempDir);
	 List fileItems;
	 try {
		 fileItems = fileUploadParserService.parseRequest(request, sizeMax, sizeThreshold, tempDir, ""UTF-8"");
	 }
	 catch (FileUploadException ex) {
		 log.error(""Cannot upload"", ex);
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""java.io.IOException.cannot_upload"", new Object[] {
		ex.getMessage()}
		);
		 throw new IOException(localizedMessage);
	 }
	 int messageID = 0;
	 String attachFilename = null;
	 int attachFileSize = 0;
	 String attachMimeType = null;
	 String attachDesc = null;
	 boolean attachMore = false;
	 boolean markAsQuote = false;
	 boolean addToSentFolder = false;
	 FileItem attachFileItem = null;
	 String actionParam = urlResolverService.getActionParam();
	 for (int i = 0;
	 i < fileItems.size();
	 i++ ) {
		 FileItem currentFileItem = (FileItem)fileItems.get(i);
		 String fieldName = currentFileItem.getFieldName();
		 if (fieldName.equals(""AddToSentFolder"")) {
			 String content = currentFileItem.getString(""utf-8"");
			 addToSentFolder = (content.length() > 0);
			 log.debug(""addToSentFolder = "" + addToSentFolder);
		 }
		 else if (fieldName.equals(""AttachMore"")) {
			 String content = currentFileItem.getString(""utf-8"");
			 attachMore = (content.length() > 0);
			 log.debug(""attachMore = "" + attachMore);
		 }
		 else if (fieldName.equals(""MarkAsQuote"")) {
			 String content = currentFileItem.getString(""utf-8"");
			 markAsQuote = (content.length() > 0);
			 log.debug(""markAsQuote = "" + markAsQuote);
		 }
		 else if (fieldName.equals(""MessageID"")) {
			 String content = currentFileItem.getString(""utf-8"");
			 messageID = Integer.parseInt(content);
			 log.debug(""messageID = "" + messageID);
		 }
		 else if (fieldName.equals(""AttachDesc"")) {
			 String content = currentFileItem.getString(""utf-8"");
			 attachDesc = DisableHtmlTagFilter.filter(content);
			 log.debug(""attachDesc = "" + attachDesc);
			 attachDesc = InterceptorService.getInstance().validateContent(attachDesc);
		 }
		 else if (fieldName.equals(""vnselector"")) {
		 }
		 else if (fieldName.equals(""AttachFilename"")) {
			 if (currentFileItem.isFormField()) {
				 String localizedMessage = MVNForumResourceBundle.getString(locale, ""java.lang.AssertionError.cannot_process_uploaded_attach_file_with_form_field"");
				 throw new AssertionError(localizedMessage);
			 }
			 attachMimeType = currentFileItem.getContentType();
			 attachMimeType = DisableHtmlTagFilter.filter(attachMimeType);
			 attachFileSize = (int)currentFileItem.getSize();
			 if (attachFileSize == 0) {
				 String localizedMessage = MVNForumResourceBundle.getString(locale, ""mvncore.exception.BadInputException.cannot_process_upload_with_file_size_is_zero"");
				 throw new BadInputException(localizedMessage);
			 }
			 String fullFilePath = currentFileItem.getName();
			 attachFilename = FileUtil.getFileName(fullFilePath);
			 attachFilename = DisableHtmlTagFilter.filter(attachFilename);
			 log.debug(""attachFilename = "" + attachFilename);
			 attachFileItem = currentFileItem;
		 }
		 else if (fieldName.equals(actionParam)) {
		 }
		 else {
			 String localizedMessage = MVNForumResourceBundle.getString(locale, ""java.lang.AssertionError.cannot_process_field_name"", new Object[] {
			fieldName}
			);
			 throw new AssertionError(localizedMessage);
		 }
	 }
	 Timestamp now = DateUtil.getCurrentGMTTimestamp();
	 MessageBean messageBean = null;
	 try {
		 messageBean = DAOFactory.getMessageDAO().getMessage(messageID);
	 }
	 catch (ObjectNotFoundException e) {
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""mvncore.exception.ObjectNotFoundException.messageid_not_exists"", new Object[] {
		new Integer(messageID)}
		);
		 throw new ObjectNotFoundException(localizedMessage);
	 }
	 if (messageBean.getFolderName().equalsIgnoreCase(MVNForumConstant.MESSAGE_FOLDER_DRAFT) == false) {
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""mvncore.exception.BadInputException.cannot_add_attachment.pm_does_not_in_folder_draft"");
		 throw new BadInputException(localizedMessage);
	 }
	 int logonMemberID = onlineUser.getMemberID();
	 if (messageBean.getMemberID() != logonMemberID ) {
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""mvncore.exception.BadInputException.pm_not_belongs_to_you"");
		 throw new BadInputException(localizedMessage);
	 }
	 AssertionUtil.doAssert(messageBean.getMessageSenderID() == logonMemberID, ""Assertion: The MessageSenderID must equals the current logined user."");
	 AssertionUtil.doAssert(messageBean.getMessageSenderName().equals(onlineUser.getMemberName()), ""Assertion: The MessageSenderName must equals the current logined user."");
	 String creationIP = request.getRemoteAddr();
	 Timestamp attachCreationDate= now;
	 Timestamp attachModifiedDate= now;
	 int attachDownloadCount = 0;
	 int attachOption = 0;
	 int attachStatus = 0;
	 int attachID = DAOFactory.getPmAttachmentDAO().create(logonMemberID, attachFilename, attachFileSize, attachMimeType, attachDesc, creationIP, attachCreationDate, attachModifiedDate, attachDownloadCount, attachOption, attachStatus);
	 try {
		 DAOFactory.getPmAttachMessageDAO().create(messageID, attachID, 0, 0, 0);
	 }
	 catch (DuplicateKeyException ex) {
		 AssertionUtil.doAssert(false, ""DuplicateKeyException when create PmAttachMessage"");
	 }
	 try {
		 binaryStorageService.storeData(BinaryStorageService.CATEGORY_PM_ATTACHMENT, String.valueOf(attachID), attachFilename, attachFileItem.getInputStream(), attachFileSize, 0, 0, attachMimeType, creationIP);
	 }
	 catch (Exception ex) {
		 log.error(""Cannot save the attachment file"", ex);
		 DAOFactory.getPmAttachMessageDAO().delete(messageID, attachID);
		 DAOFactory.getPmAttachmentDAO().delete(attachID);
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""java.io.IOException.cannot_save_attach_file"");
		 throw new IOException(localizedMessage);
	 }
	 int attachCount = DAOFactory.getPmAttachMessageDAO().getNumberOfBeans_inMessage(messageID);
	 try {
		 DAOFactory.getMessageDAO().updateAttachCount(messageID, attachCount);
	 }
	 catch (ObjectNotFoundException e) {
		 String localizedMessage = MVNForumResourceBundle.getString(locale, ""mvncore.exception.ObjectNotFoundException.messageid_not_exists"", new Object[] {
		new Integer(messageID)}
		);
		 throw new ObjectNotFoundException(localizedMessage);
	 }
	 int maxPrivateMessage = MVNForumConfig.getMaxPrivateMessages();
	 if (attachMore == false) {
		 String[] receivedMembers = StringUtil.getStringArrays(messageBean.getMessageToList(), messageBean.getMessageCcList(), messageBean.getMessageBccList(), "";
		"");
		 Hashtable receivers = MyUtil.checkMembers(receivedMembers, locale);
		 int messageType = messageBean.getMessageType();
		 if (markAsQuote) {
			 messageType = MessageBean.MESSAGE_TYPE_QUOTE;
		 }
		 Collection attachBeans = DAOFactory.getPmAttachmentDAO().getPmAttachments_inMessage(messageBean.getMessageID());
		 StringBuffer overQuotaReceivers = new StringBuffer(128);
		 for (Enumeration enumeration = receivers.keys();
		 enumeration.hasMoreElements();
		 ) {
			 int receivedMemberID = ((Integer)enumeration.nextElement()).intValue();
			 String receivedMemberName = (String)receivers.get(new Integer(receivedMemberID));
			 int receiverMessageCount = DAOFactory.getMessageDAO().getNumberOfNonPublicMessages_inMember(receivedMemberID);
			 if (receiverMessageCount >= maxPrivateMessage) {
				 if (overQuotaReceivers.length() > 0) {
					 overQuotaReceivers.append("", "");
				 }
				 overQuotaReceivers.append(receivedMemberName);
				 continue;
			 }
			 int eachMessageID = DAOFactory.getMessageDAO().create(MVNForumConstant.MESSAGE_FOLDER_INBOX, receivedMemberID, logonMemberID, messageBean.getMessageSenderName(), messageBean.getMessageToList(), messageBean.getMessageCcList(), messageBean.getMessageBccList(), messageBean.getMessageTopic(), messageBean.getMessageBody(), messageType, messageBean.getMessageOption(), messageBean.getMessageStatus(), MessageBean.MESSAGE_READ_STATUS_DEFAULT, messageBean.getMessageNotify(), messageBean.getMessageIcon(), attachCount, creationIP, now);
			 if (logonMemberID != receivedMemberID) {
				 DAOFactory.getMessageStatisticsDAO().create(logonMemberID, receivedMemberID, now, messageBean.getMessageAttachCount(), messageBean.getMessageType(), messageBean.getMessageOption(), messageBean.getMessageStatus());
			 }
			 for (Iterator attachIter = attachBeans.iterator();
			 attachIter.hasNext();
			 ) {
				 PmAttachmentBean pmAttachBean = (PmAttachmentBean)attachIter.next();
				 try {
					 DAOFactory.getPmAttachMessageDAO().create(eachMessageID, pmAttachBean.getPmAttachID(), 0, 0, 0);
				 }
				 catch (DuplicateKeyException ex) {
					 AssertionUtil.doAssert(false, ""DuplicateKeyException when create PmAttachMessage"");
				 }
			 }
		 }
		 request.setAttribute(""OverQuotaReceivers"", overQuotaReceivers.toString());
		 if (addToSentFolder) {
			 int senderMessageCount = DAOFactory.getMessageDAO().getNumberOfNonPublicMessages_inMember(logonMemberID);
			 if (senderMessageCount < maxPrivateMessage) {
				 messageType = MessageBean.MESSAGE_TYPE_DEFAULT;
				 int sentMessageID = DAOFactory.getMessageDAO().create(MVNForumConstant.MESSAGE_FOLDER_SENT, logonMemberID, logonMemberID, messageBean.getMessageSenderName(), messageBean.getMessageToList(), messageBean.getMessageCcList(), messageBean.getMessageBccList(), messageBean.getMessageTopic(), messageBean.getMessageBody(), messageType, messageBean.getMessageOption(), messageBean.getMessageStatus(), MessageBean.MESSAGE_READ_STATUS_DEFAULT, messageBean.getMessageNotify(), messageBean.getMessageIcon(), attachCount, creationIP, now);
				 for (Iterator attachIter = attachBeans.iterator();
				 attachIter.hasNext();
				 ) {
					 PmAttachmentBean pmAttachBean = (PmAttachmentBean)attachIter.next();
					 try {
						 DAOFactory.getPmAttachMessageDAO().create(sentMessageID, pmAttachBean.getPmAttachID(), 0, 0, 0);
					 }
					 catch (DuplicateKeyException ex) {
						 AssertionUtil.doAssert(false, ""DuplicateKeyException when create PmAttachMessage"");
					 }
				 }
			 }
			 else {
				 request.setAttribute(""AddSentFolderOverQuota"", Boolean.TRUE);
			 }
		 }
		 PrivateMessageUtil.deleteMessageInDatabase(messageID, logonMemberID);
	 }
	 request.setAttribute(""MessageID"", String.valueOf(messageID));
	 request.setAttribute(""AttachMore"", Boolean.valueOf(attachMore));
	 request.setAttribute(""AddToSentFolder"", Boolean.valueOf(addToSentFolder));
	 request.setAttribute(""MarkAsQuote"", Boolean.valueOf(markAsQuote));
 }",0,0,1,0
"void loadConfig() throws IOException {
	 File configFile = new File(bucketsDir, CONFIG_FILENAME);
	 DataInputStream dis = new DataInputStream(new FileInputStream(configFile));
	 try {
		 this.keyStartByte = dis.readInt();
		 this.keyBits = dis.readInt();
		 this.curBucket = dis.readInt();
		 this.insertsAllowed = dis.readBoolean();
	 }
	 finally {
		 dis.close();
	 }
 }",0,0,0,0
"public void addLib(ZipFileSet fs) {
	 fs.setPrefix(""WEB-INF/lib/"");
	 super.addFileset(fs);
 }",0,0,0,0
"public class CredentialServiceImpl extends AbstractKapuaConfigurableService implements CredentialService {
	 private static final Logger LOGGER = LoggerFactory.getLogger(CredentialServiceImpl.class);
	 public CredentialServiceImpl() {
		 super(CredentialService.class.getName(), AuthenticationDomains.CREDENTIAL_DOMAIN, AuthenticationEntityManagerFactory.getInstance());
	 }
	 public Credential create(CredentialCreator credentialCreator) throws KapuaException {
		 ArgumentValidator.notNull(credentialCreator, ""credentialCreator"");
		 ArgumentValidator.notNull(credentialCreator.getScopeId(), ""credentialCreator.scopeId"");
		 ArgumentValidator.notNull(credentialCreator.getUserId(), ""credentialCreator.userId"");
		 ArgumentValidator.notNull(credentialCreator.getCredentialType(), ""credentialCreator.credentialType"");
		 ArgumentValidator.notNull(credentialCreator.getCredentialStatus(), ""credentialCreator.credentialStatus"");
		 if (credentialCreator.getCredentialType() != CredentialType.API_KEY) {
			 ArgumentValidator.notEmptyOrNull(credentialCreator.getCredentialPlainKey(), ""credentialCreator.credentialKey"");
		 }
		 if (credentialCreator.getCredentialType() == CredentialType.PASSWORD) {
			 CredentialListResult existingCredentials = findByUserId(credentialCreator.getScopeId(), credentialCreator.getUserId());
			 for (Credential credential : existingCredentials.getItems()) {
				 if (credential.getCredentialType().equals(CredentialType.PASSWORD)) {
					 throw new KapuaExistingCredentialException(CredentialType.PASSWORD);
				 }
			 }
			 ArgumentValidator.match(credentialCreator.getCredentialPlainKey(), CommonsValidationRegex.PASSWORD_REGEXP, ""credentialCreator.credentialKey"");
		 }
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.write, credentialCreator.getScopeId()));
		 Credential credential = null;
		 EntityManager em = AuthenticationEntityManagerFactory.getEntityManager();
		 try {
			 em.beginTransaction();
			 String fullKey = null;
			 switch (credentialCreator.getCredentialType()) {
				 case API_KEY: SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"");
				 KapuaAuthenticationSetting setting = KapuaAuthenticationSetting.getInstance();
				 int preLength = setting.getInt(KapuaAuthenticationSettingKeys.AUTHENTICATION_CREDENTIAL_APIKEY_PRE_LENGTH);
				 int keyLength = setting.getInt(KapuaAuthenticationSettingKeys.AUTHENTICATION_CREDENTIAL_APIKEY_KEY_LENGTH);
				 byte[] bPre = new byte[preLength];
				 random.nextBytes(bPre);
				 String pre = Base64.encodeToString(bPre).substring(0, preLength);
				 byte[] bKey = new byte[keyLength];
				 random.nextBytes(bKey);
				 String key = Base64.encodeToString(bKey);
				 fullKey = pre + key;
				 credentialCreator = new CredentialCreatorImpl(credentialCreator.getScopeId(), credentialCreator.getUserId(), credentialCreator.getCredentialType(), fullKey, credentialCreator.getCredentialStatus(), credentialCreator.getExpirationDate());
				 break;
				 case PASSWORD: default: break;
			 }
			 credential = CredentialDAO.create(em, credentialCreator);
			 credential = CredentialDAO.find(em, credential.getScopeId(), credential.getId());
			 em.commit();
			 switch (credentialCreator.getCredentialType()) {
				 case API_KEY: credential.setCredentialKey(fullKey);
				 break;
				 case PASSWORD: default: credential.setCredentialKey(fullKey);
			 }
		 }
		 catch (Exception pe) {
			 em.rollback();
			 throw KapuaExceptionUtils.convertPersistenceException(pe);
		 }
		 finally {
			 em.close();
		 }
		 return credential;
	 }
	 public Credential update(Credential credential) throws KapuaException {
		 ArgumentValidator.notNull(credential, ""credential"");
		 ArgumentValidator.notNull(credential.getId(), ""credential.id"");
		 ArgumentValidator.notNull(credential.getScopeId(), ""credential.scopeId"");
		 ArgumentValidator.notNull(credential.getUserId(), ""credential.userId"");
		 ArgumentValidator.notNull(credential.getCredentialType(), ""credential.credentialType"");
		 ArgumentValidator.notEmptyOrNull(credential.getCredentialKey(), ""credential.credentialKey"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.write, credential.getScopeId()));
		 return entityManagerSession.onTransactedResult(em -> {
			 Credential currentCredential = CredentialDAO.find(em, credential.getScopeId(), credential.getId());
			 if (currentCredential == null) {
				 throw new KapuaEntityNotFoundException(Credential.TYPE, credential.getId());
			 }
			 if (currentCredential.getCredentialType() != credential.getCredentialType()) {
				 throw new KapuaIllegalArgumentException(""credentialType"", credential.getCredentialType().toString());
			 }
			 return CredentialDAO.update(em, credential);
		 }
		);
	 }
	 public Credential find(KapuaId scopeId, KapuaId credentialId) throws KapuaException {
		 ArgumentValidator.notNull(scopeId, ""scopeId"");
		 ArgumentValidator.notNull(credentialId, ""credentialId"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.read, scopeId));
		 return entityManagerSession.onResult(em -> CredentialDAO.find(em, scopeId, credentialId));
	 }
	 public CredentialListResult query(KapuaQuery<Credential> query) throws KapuaException {
		 ArgumentValidator.notNull(query, ""query"");
		 ArgumentValidator.notNull(query.getScopeId(), ""query.scopeId"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.read, query.getScopeId()));
		 return entityManagerSession.onResult(em -> CredentialDAO.query(em, query));
	 }
	 public long count(KapuaQuery<Credential> query) throws KapuaException {
		 ArgumentValidator.notNull(query, ""query"");
		 ArgumentValidator.notNull(query.getScopeId(), ""query.scopeId"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.read, query.getScopeId()));
		 return entityManagerSession.onResult(em -> CredentialDAO.count(em, query));
	 }
	 public void delete(KapuaId scopeId, KapuaId credentialId) throws KapuaException {
		 ArgumentValidator.notNull(credentialId, ""credential.id"");
		 ArgumentValidator.notNull(scopeId, ""credential.scopeId"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.delete, scopeId));
		 entityManagerSession.onTransactedAction(em -> {
			 if (CredentialDAO.find(em, scopeId, credentialId) == null) {
				 throw new KapuaEntityNotFoundException(Credential.TYPE, credentialId);
			 }
			 CredentialDAO.delete(em, scopeId, credentialId);
		 }
		);
	 }
	 public CredentialListResult findByUserId(KapuaId scopeId, KapuaId userId) throws KapuaException {
		 ArgumentValidator.notNull(scopeId, ""scopeId"");
		 ArgumentValidator.notNull(userId, ""userId"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.read, scopeId));
		 CredentialQuery query = new CredentialQueryImpl(scopeId);
		 QueryPredicate predicate = new AttributePredicateImpl<>(CredentialAttributes.USER_ID, userId);
		 query.setPredicate(predicate);
		 return query(query);
	 }
	 public Credential findByApiKey(String apiKey) throws KapuaException {
		 ArgumentValidator.notEmptyOrNull(apiKey, ""apiKey"");
		 Credential credential = null;
		 EntityManager em = AuthenticationEntityManagerFactory.getEntityManager();
		 try {
			 KapuaAuthenticationSetting setting = KapuaAuthenticationSetting.getInstance();
			 int preLength = setting.getInt(KapuaAuthenticationSettingKeys.AUTHENTICATION_CREDENTIAL_APIKEY_PRE_LENGTH);
			 String preSeparator = setting.getString(KapuaAuthenticationSettingKeys.AUTHENTICATION_CREDENTIAL_APIKEY_PRE_SEPARATOR);
			 String apiKeyPreValue = apiKey.substring(0, preLength).concat(preSeparator);
			 KapuaQuery<Credential> query = new CredentialQueryImpl();
			 AttributePredicateImpl<CredentialType> typePredicate = new AttributePredicateImpl<>(CredentialAttributes.CREDENTIAL_TYPE, CredentialType.API_KEY);
			 AttributePredicateImpl<String> keyPredicate = new AttributePredicateImpl<>(CredentialAttributes.CREDENTIAL_KEY, apiKeyPreValue, Operator.STARTS_WITH);
			 AndPredicateImpl andPredicate = new AndPredicateImpl();
			 andPredicate.and(typePredicate);
			 andPredicate.and(keyPredicate);
			 query.setPredicate(andPredicate);
			 CredentialListResult credentialListResult = CredentialDAO.query(em, query);
			 credential = credentialListResult.getFirstItem();
		 }
		 catch (Exception e) {
			 throw KapuaExceptionUtils.convertPersistenceException(e);
		 }
		 finally {
			 em.close();
		 }
		 if (credential != null) {
			 KapuaLocator locator = KapuaLocator.getInstance();
			 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
			 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
			 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.read, credential.getId()));
		 }
		 return credential;
	 }
	 public void unlock(KapuaId scopeId, KapuaId credentialId) throws KapuaException {
		 ArgumentValidator.notNull(scopeId, ""scopeId"");
		 ArgumentValidator.notNull(credentialId, ""credentialId"");
		 KapuaLocator locator = KapuaLocator.getInstance();
		 AuthorizationService authorizationService = locator.getService(AuthorizationService.class);
		 PermissionFactory permissionFactory = locator.getFactory(PermissionFactory.class);
		 authorizationService.checkPermission(permissionFactory.newPermission(AuthenticationDomains.CREDENTIAL_DOMAIN, Actions.write, scopeId));
		 Credential credential = find(scopeId, credentialId);
		 credential.setLoginFailures(0);
		 credential.setFirstLoginFailure(null);
		 credential.setLoginFailuresReset(null);
		 credential.setLockoutReset(null);
		 update(credential);
	 }
	 private long countExistingCredentials(CredentialType credentialType, KapuaId scopeId, KapuaId userId) throws KapuaException {
		 KapuaLocator locator = KapuaLocator.getInstance();
		 CredentialFactory credentialFactory = locator.getFactory(CredentialFactory.class);
		 KapuaQuery<Credential> credentialQuery = credentialFactory.newQuery(scopeId);
		 CredentialType ct = credentialType;
		 QueryPredicate credentialTypePredicate = new AttributePredicateImpl<>(CredentialAttributes.CREDENTIAL_TYPE, ct);
		 QueryPredicate userIdPredicate = new AttributePredicateImpl<>(CredentialAttributes.USER_ID, userId);
		 QueryPredicate andPredicate = new AndPredicateImpl().and(credentialTypePredicate).and(userIdPredicate);
		 credentialQuery.setPredicate(andPredicate);
		 return count(credentialQuery);
	 }
	 public void onKapuaEvent(ServiceEvent kapuaEvent) throws KapuaException {
		 if (kapuaEvent == null) {
		 }
		 LOGGER.info(""CredentialService: received kapua event from {
		}
		, operation {
		}
		"", kapuaEvent.getService(), kapuaEvent.getOperation());
		 if (""user"".equals(kapuaEvent.getService()) && ""delete"".equals(kapuaEvent.getOperation())) {
			 deleteCredentialByUserId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId());
		 }
		 else if (""account"".equals(kapuaEvent.getService()) && ""delete"".equals(kapuaEvent.getOperation())) {
			 deleteCredentialByAccountId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId());
		 }
	 }
	 private void deleteCredentialByUserId(KapuaId scopeId, KapuaId userId) throws KapuaException {
		 KapuaLocator locator = KapuaLocator.getInstance();
		 CredentialFactory credentialFactory = locator.getFactory(CredentialFactory.class);
		 CredentialQuery query = credentialFactory.newQuery(scopeId);
		 query.setPredicate(new AttributePredicateImpl<>(CredentialAttributes.USER_ID, userId));
		 CredentialListResult credentialsToDelete = query(query);
		 for (Credential c : credentialsToDelete.getItems()) {
			 delete(c.getScopeId(), c.getId());
		 }
	 }
	 private void deleteCredentialByAccountId(KapuaId scopeId, KapuaId accountId) throws KapuaException {
		 KapuaLocator locator = KapuaLocator.getInstance();
		 CredentialFactory credentialFactory = locator.getFactory(CredentialFactory.class);
		 CredentialQuery query = credentialFactory.newQuery(accountId);
		 CredentialListResult credentialsToDelete = query(query);
		 for (Credential c : credentialsToDelete.getItems()) {
			 delete(c.getScopeId(), c.getId());
		 }
	 }
}",1,0,0,0
"public void genCppCode(FileWriter hh, FileWriter cc) throws IOException {
	 String[] ns = getCppNameSpace().split(""::"");
	 for (int i = 0;
	 i < ns.length;
	 i++) {
		 hh.write(""namespace ""+ns[i]+"" {
			\n"");
		 }
		 hh.write(""class ""+getName()+"" : public ::hadoop::Record {
			\n"");
			 hh.write(""private:\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			) {
				 JField jf = (JField) i.next();
				 hh.write(jf.genCppDecl());
			 }
			 hh.write("" std::bitset<""+mFields.size()+""> bs_;
			\n"");
			 hh.write(""public:\n"");
			 hh.write("" virtual void serialize(::hadoop::OArchive& a_, const char* tag);
			\n"");
			 hh.write("" virtual void deserialize(::hadoop::IArchive& a_, const char* tag);
			\n"");
			 hh.write("" virtual const ::std::string& type() const;
			\n"");
			 hh.write("" virtual const ::std::string& signature() const;
			\n"");
			 hh.write("" virtual bool validate() const;
			\n"");
			 hh.write("" virtual bool operator<(const ""+getName()+""& peer_);
			\n"");
			 hh.write("" virtual bool operator==(const ""+getName()+""& peer_);
			\n"");
			 hh.write("" virtual ~""+getName()+""() {
			}
			;
			\n"");
			 int fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 hh.write(jf.genCppGetSet(fIdx));
			 }
		 hh.write(""}
		;
		 for (int i=ns.length-1;
		 i>=0;
		 i--) {
		 hh.write(""}
	 }
	 cc.write(""void ""+getCppFQName()+""::serialize(::hadoop::OArchive& a_, const char* tag) {
		\n"");
		 cc.write("" if (!validate()) throw new ::hadoop::IOException(\""All fields not set.\"");
		\n"");
		 cc.write("" a_.startRecord(*this,tag);
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 if (jf.getType() instanceof JBuffer) {
				 cc.write("" a_.serialize(""+name+"",""+name+"".length(),\""""+jf.getTag()+""\"");
				\n"");
			 }
			 else {
				 cc.write("" a_.serialize(""+name+"",\""""+jf.getTag()+""\"");
				\n"");
			 }
			 cc.write("" bs_.reset(""+fIdx+"");
			\n"");
		 }
		 cc.write("" a_.endRecord(*this,tag);
		\n"");
		 cc.write("" return;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""void ""+getCppFQName()+""::deserialize(::hadoop::IArchive& a_, const char* tag) {
		\n"");
		 cc.write("" a_.startRecord(*this,tag);
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 if (jf.getType() instanceof JBuffer) {
				 cc.write("" {
					 size_t len=0;
					 a_.deserialize(""+name+"",len,\""""+jf.getTag()+""\"");
				}
				\n"");
			 }
			 else {
				 cc.write("" a_.deserialize(""+name+"",\""""+jf.getTag()+""\"");
				\n"");
			 }
			 cc.write("" bs_.set(""+fIdx+"");
			\n"");
		 }
		 cc.write("" a_.endRecord(*this,tag);
		\n"");
		 cc.write("" return;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::validate() const {
		\n"");
		 cc.write("" if (bs_.size() != bs_.count()) return false;
		\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 JType type = jf.getType();
			 if (type instanceof JRecord) {
				 cc.write("" if (!""+jf.getName()+"".validate()) return false;
				\n"");
			 }
		 }
		 cc.write("" return true;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::operator< (const ""+getCppFQName()+""& peer_) {
		\n"");
		 cc.write("" return (1\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 cc.write("" && (""+name+"" < peer_.""+name+"")\n"");
		 }
		 cc.write("" );
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::operator== (const ""+getCppFQName()+""& peer_) {
		\n"");
		 cc.write("" return (1\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 cc.write("" && (""+name+"" == peer_.""+name+"")\n"");
		 }
		 cc.write("" );
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""const ::std::string&""+getCppFQName()+""::type() const {
		\n"");
		 cc.write("" static const ::std::string type_(\""""+mName+""\"");
		\n"");
		 cc.write("" return type_;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""const ::std::string&""+getCppFQName()+""::signature() const {
		\n"");
		 cc.write("" static const ::std::string sig_(\""""+getSignature()+""\"");
		\n"");
		 cc.write("" return sig_;
		\n"");
	 cc.write(""}
	\n"");
 }",0,0,1,0
"protected void fixVCalendar(boolean fromServer) {
	 if (fromServer) {
		 setPropertyValue(""X-CALENDARSERVER-ACCESS"", getCalendarServerAccess());
	 }
	 String calendarServerAccess = getPropertyValue(""X-CALENDARSERVER-ACCESS"");
	 String now = ExchangeSession.getZuluDateFormat().format(new Date());
	 if (!fromServer && getPropertyValue(""METHOD"") == null) {
		 setPropertyValue(""METHOD"", ""PUBLISH"");
	 }
	 String tzid = null;
	 if (fromServer) {
		 VObject vObject = vTimezone;
		 if (vObject != null) {
			 String currentTzid = vObject.getPropertyValue(""TZID"");
			 if (currentTzid != null && currentTzid.endsWith(""\n"")) {
				 currentTzid = currentTzid.substring(0, currentTzid.length() - 1);
				 vObject.setPropertyValue(""TZID"", currentTzid);
			 }
			 if (currentTzid != null && currentTzid.indexOf(' ') >= 0) {
				 try {
					 tzid = ResourceBundle.getBundle(""timezones"").getString(currentTzid);
					 vObject.setPropertyValue(""TZID"", tzid);
				 }
				 catch (MissingResourceException e) {
					 LOGGER.debug(""Timezone "" + currentTzid + "" not found in rename table"");
				 }
			 }
		 }
	 }
	 if (!fromServer) {
		 fixTimezone();
	 }
	 for (VObject vObject : vObjects) {
		 if (""VEVENT"".equals(vObject.type)) {
			 if (calendarServerAccess != null) {
				 vObject.setPropertyValue(""CLASS"", getEventClass(calendarServerAccess));
			 }
			 else if (vObject.getPropertyValue(""X-CALENDARSERVER-ACCESS"") != null) {
				 vObject.setPropertyValue(""CLASS"", getEventClass(vObject.getPropertyValue(""X-CALENDARSERVER-ACCESS"")));
			 }
			 if (fromServer) {
				 if (vObject.getProperty(""ATTENDEE"") == null) {
					 vObject.setPropertyValue(""ORGANIZER"", null);
				 }
				 if (isCdoAllDay(vObject)) {
					 setClientAllday(vObject.getProperty(""DTSTART""));
					 setClientAllday(vObject.getProperty(""DTEND""));
					 setClientAllday(vObject.getProperty(""RECURRENCE-ID""));
				 }
				 String cdoBusyStatus = vObject.getPropertyValue(""X-MICROSOFT-CDO-BUSYSTATUS"");
				 if (cdoBusyStatus != null) {
					 vObject.setPropertyValue(""TRANSP"", !""FREE"".equals(cdoBusyStatus) ? ""OPAQUE"" : ""TRANSPARENT"");
				 }
				 vObject.removeProperty(""X-ENTOURAGE_UUID"");
				 splitExDate(vObject);
				 if ("""".equals(vObject.getPropertyValue(""LOCATION""))) {
					 vObject.removeProperty(""LOCATION"");
				 }
				 if ("""".equals(vObject.getPropertyValue(""DESCRIPTION""))) {
					 vObject.removeProperty(""DESCRIPTION"");
				 }
				 if ("""".equals(vObject.getPropertyValue(""CLASS""))) {
					 vObject.removeProperty(""CLASS"");
				 }
				 if (tzid != null) {
					 VProperty dtStart = vObject.getProperty(""DTSTART"");
					 if (dtStart != null && dtStart.getParam(""TZID"") != null) {
						 dtStart.setParam(""TZID"", tzid);
					 }
					 VProperty dtEnd = vObject.getProperty(""DTEND"");
					 if (dtEnd != null && dtEnd.getParam(""TZID"") != null) {
						 dtEnd.setParam(""TZID"", tzid);
					 }
					 VProperty reccurrenceId = vObject.getProperty(""RECURRENCE-ID"");
					 if (reccurrenceId != null && reccurrenceId.getParam(""TZID"") != null) {
						 reccurrenceId.setParam(""TZID"", tzid);
					 }
				 }
				 if (vObject.getProperty(""ATTACH"") != null) {
					 List<String> toRemoveValues = null;
					 List<String> values = vObject.getProperty(""ATTACH"").getValues();
					 for (String value : values) {
						 if (value.contains(""CID:"")) {
							 if (toRemoveValues == null) {
								 toRemoveValues = new ArrayList<String>();
							 }
							 toRemoveValues.add(value);
						 }
					 }
					 if (toRemoveValues != null) {
						 values.removeAll(toRemoveValues);
						 if (values.size() == 0) {
							 vObject.removeProperty(""ATTACH"");
						 }
					 }
				 }
			 }
			 else {
				 String organizer = getEmailValue(vObject.getProperty(""ORGANIZER""));
				 if (organizer == null) {
					 vObject.setPropertyValue(""ORGANIZER"", ""MAILTO:"" + email);
				 }
				 else if (!email.equalsIgnoreCase(organizer) && vObject.getProperty(""X-MICROSOFT-CDO-REPLYTIME"") == null) {
					 vObject.setPropertyValue(""X-MICROSOFT-CDO-REPLYTIME"", now);
				 }
				 vObject.setPropertyValue(""X-MICROSOFT-CDO-ALLDAYEVENT"", isAllDay(vObject) ? ""TRUE"" : ""FALSE"");
				 if (vObject.getPropertyValue(""TRANSP"") != null) {
					 vObject.setPropertyValue(""X-MICROSOFT-CDO-BUSYSTATUS"", !""TRANSPARENT"".equals(vObject.getPropertyValue(""TRANSP"")) ? ""BUSY"" : ""FREE"");
				 }
				 if (isAllDay(vObject)) {
					 setServerAllday(vObject.getProperty(""DTSTART""));
					 setServerAllday(vObject.getProperty(""DTEND""));
				 }
				 else {
					 fixTzid(vObject.getProperty(""DTSTART""));
					 fixTzid(vObject.getProperty(""DTEND""));
				 }
			 }
			 fixAttendees(vObject, fromServer);
			 fixAlarm(vObject, fromServer);
		 }
	 }
 }",0,0,1,0
"private void initUI() {
	setUndecorated(true);
	try {
		if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			setOpacity(0.85f);
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	setIconImage(ImageResource.get(""icon.png"").getImage());
	setSize(500, 420);
	setLocationRelativeTo(null);
	getContentPane().setLayout(null);
	getContentPane().setBackground(ColorResource.getDarkestBgColor());
	JPanel titlePanel = new TitlePanel(null, this);
	titlePanel.setOpaque(false);
	titlePanel.setBounds(0, 0, getWidth(), 50);
	JButton closeBtn = new CustomButton();
	closeBtn.setBounds(getWidth() - 35, 5, 30, 30);
	closeBtn.setBackground(ColorResource.getDarkestBgColor());
	closeBtn.setBorderPainted(false);
	closeBtn.setFocusPainted(false);
	closeBtn.setName(""CLOSE"");
	closeBtn.setIcon(ImageResource.get(""close_btn.png""));
	closeBtn.addActionListener(this);
	titlePanel.add(closeBtn);
	JLabel titleLbl = new JLabel(StringResource.get(""TITLE_DOWN_VID""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(25, 15, 200, 30);
	titlePanel.add(titleLbl);
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, 55, getWidth(), 1);
	lineLbl.setOpaque(true);
	add(lineLbl);
	add(titlePanel);
	int y = 55;
	int h = 30;
	y += 15;
	prg = new JProgressBar();
	prg.setIndeterminate(true);
	prg.setBounds(15, y, getWidth() - 30, 5);
	prg.setBorder(null);
	prg.setVisible(false);
	add(prg);
	txtURL = new JTextField();
	PopupAdapter.registerTxtPopup(txtURL);
	txtURL.setBounds(15, y, getWidth() - 30 - 110, h);
	add(txtURL);
	btnStart = createButton(""BTN_SEARCH_VIDEO"");
	btnStart.setBounds(getWidth() - 15 - 100, y, 100, h);
	btnStart.setName(""START"");
	add(btnStart);
	VideoDownloadItem item1 = new VideoDownloadItem();
	item1.title = ""First item for text test"";
	item1.desc = ""Sample description for text tesing description"";
	h = 300;
	model = new VideoTableModel();
	table = new JTable(model);
	table.setRowHeight(70);
	table.setShowGrid(false);
	table.setOpaque(false);
	table.setBorder(new EmptyBorder(0, 0, 0, 0));
	table.setShowHorizontalLines(false);
	table.setShowVerticalLines(false);
	table.setDefaultRenderer(YdlVideo.class, new VideoItemRenderer());
	table.setDefaultEditor(YdlVideo.class, new VideoItemEditor());
	table.setTableHeader(null);
	jsp = new JScrollPane();
	jsp.setBounds(15, y, getWidth() - 30, h);
	jsp.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
	jsp.getViewport().setOpaque(false);
	jsp.setViewportView(table);
	jsp.setOpaque(false);
	DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
	jsp.setVerticalScrollBar(scrollBar);
	jsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
	add(jsp);
	jsp.setVisible(false);
	y += h;
	y += 10;
	h = 30;
	btnDwn = createButton(""BTN_DOWNLOAD_NOW"");
	btnDwn.setBounds(getWidth() - 15 - 150, y, 150, h);
	btnDwn.setName(""DOWNLOAD"");
	btnDwn.setVisible(false);
	add(btnDwn);
	btnQ = createButton(""BTN_DOWNLOAD_LATER"");
	btnQ.setBounds(getWidth() - 15 - 150 - 160, y, 150, h);
	btnQ.setName(""BTN_Q"");
	add(btnQ);
	btnQ.setVisible(false);
	btnBack = createButton(""BTN_BACK"");
	btnBack.setBounds(15, y, 130, h);
	btnBack.setName(""BACK"");
	add(btnBack);
	btnBack.setVisible(false);
	addWindowListener(new WindowAdapter() {
		public void windowActivated(WindowEvent e) {
			txtURL.requestFocus();
		}
	}
	);
}",0,0,1,0
"private Table getValidTable(String tableName) throws IOException {
	 if (!Schema.instance.getTables().contains(tableName)) {
		 throw new IOException(""Table "" + tableName + ""does not exist"");
	 }
	 return Table.open(tableName);
 }",0,0,0,0
"public class ContainersMonitorEvent extends AbstractEvent<ContainersMonitorEventType> {
	 private final ContainerId containerId;
	 public ContainersMonitorEvent(ContainerId containerId, ContainersMonitorEventType eventType) {
		 super(eventType);
		 this.containerId = containerId;
	 }
	 public ContainerId getContainerId() {
		 return this.containerId;
	 }
}",0,0,0,0
"public void setComparator(ComparatorName name) {
	 compName = name;
 }",0,0,0,0
"public void setFailOnNoReplacements(boolean b) {
	 failOnNoReplacements = b;
 }",0,0,0,0
"public class FileStorage implements Storage {
	volatile LogService log;
	 public void store(String key, Serializable data) {
		log.log(LogService.LOG_WARNING, ""FileStorage.store("" + key + "","" + data + "")"");
	}
	public Serializable get(String key) {
		return null;
	}
}",0,0,0,0
"public PlanarImage executeDrawOperation() {
	 final int size = instructions.size();
	 for (int i = 0;
	 i < size;
	 i++) {
		 ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
		 if (instr instanceof DrawOperation) {
			 PlanarImage op = ((DrawOperation) instr).executeDrawOperation();
			 op = performRotate(op);
			 return op;
		 }
	 }
	 return null;
 }",0,0,0,0
"InetAddress getPredecessor(InetAddress ep) {
	 Token token = tokenMetadata_.getToken(ep);
	 return tokenMetadata_.getEndpoint(tokenMetadata_.getPredecessor(token));
 }",0,0,0,0
"static class DynamicPackageEntry {
	 DynamicPackageEntry(String package_name, int package_id) {
		 this.package_name = package_name;
		 this.package_id = package_id;
	 }
	 String package_name;
	 int package_id = 0;
 }",0,1,0,0
"public Object getAttribute(String name, Hashtable valueSet, String defaultKey, boolean allowLiterals);",0,0,0,0
"private void exportRightPen(JRPen topPen, JRPen bottomPen, JRPen rightPen, int x, int y, int width, int height) throws IOException;",0,0,0,1
static String toString_Static(JavaClass clazz);,0,0,0,0
"private static class SetBuckDotFilePathsRequestTupleScheme extends org.apache.thrift.scheme.TupleScheme<SetBuckDotFilePathsRequest> {
	 public void write(org.apache.thrift.protocol.TProtocol prot, SetBuckDotFilePathsRequest struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
		 java.util.BitSet optionals = new java.util.BitSet();
		 if (struct.isSetStampedeId()) {
			 optionals.set(0);
		 }
		 if (struct.isSetDotFiles()) {
			 optionals.set(1);
		 }
		 oprot.writeBitSet(optionals, 2);
		 if (struct.isSetStampedeId()) {
			 struct.stampedeId.write(oprot);
		 }
		 if (struct.isSetDotFiles()) {
			 {
				 oprot.writeI32(struct.dotFiles.size());
				 for (PathInfo _iter108 : struct.dotFiles) {
					 _iter108.write(oprot);
				 }
			 }
		 }
	 }
	 public void read(org.apache.thrift.protocol.TProtocol prot, SetBuckDotFilePathsRequest struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
		 java.util.BitSet incoming = iprot.readBitSet(2);
		 if (incoming.get(0)) {
			 struct.stampedeId = new StampedeId();
			 struct.stampedeId.read(iprot);
			 struct.setStampedeIdIsSet(true);
		 }
		 if (incoming.get(1)) {
			 {
				 org.apache.thrift.protocol.TList _list109 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
				 struct.dotFiles = new java.util.ArrayList<PathInfo>(_list109.size);
				 PathInfo _elem110;
				 for (int _i111 = 0;
				 _i111 < _list109.size;
				 ++_i111) {
					 _elem110 = new PathInfo();
					 _elem110.read(iprot);
					 struct.dotFiles.add(_elem110);
				 }
			 }
			 struct.setDotFilesIsSet(true);
		 }
	 }
 }",0,0,0,0
"public String toString() {
	 if (subject == null || pubKey == null || interval == null || issuer == null || algId == null || serialNum == null) {
		 throw new NullPointerException(""X.509 cert is incomplete"");
	 }
	 StringBuilder sb = new StringBuilder();
	 sb.append(""[\n"");
	 sb.append("" "" + version.toString() + ""\n"");
	 sb.append("" Subject: "" + subject.toString() + ""\n"");
	 sb.append("" Signature Algorithm: "" + algId.toString() + ""\n"");
	 sb.append("" Key: "" + pubKey.toString() + ""\n"");
	 sb.append("" "" + interval.toString() + ""\n"");
	 sb.append("" Issuer: "" + issuer.toString() + ""\n"");
	 sb.append("" "" + serialNum.toString() + ""\n"");
	 if (issuerUniqueId != null) {
		 sb.append("" Issuer Id:\n"" + issuerUniqueId.toString() + ""\n"");
	 }
	 if (subjectUniqueId != null) {
		 sb.append("" Subject Id:\n"" + subjectUniqueId.toString() + ""\n"");
	 }
	 if (extensions != null) {
		 Collection<Extension> allExts = extensions.getAllExtensions();
		 Extension[] exts = allExts.toArray(new Extension[0]);
		 sb.append(""\nCertificate Extensions: "" + exts.length);
		 for (int i = 0;
		 i < exts.length;
		 i++) {
			 sb.append(""\n["" + (i+1) + ""]: "");
			 Extension ext = exts[i];
			 try {
				 if (OIDMap.getClass(ext.getExtensionId()) == null) {
					 sb.append(ext.toString());
					 byte[] extValue = ext.getExtensionValue();
					 if (extValue != null) {
						 DerOutputStream out = new DerOutputStream();
						 out.putOctetString(extValue);
						 extValue = out.toByteArray();
						 HexDumpEncoder enc = new HexDumpEncoder();
						 sb.append(""Extension unknown: "" + ""DER encoded OCTET string =\n"" + enc.encodeBuffer(extValue) + ""\n"");
					 }
				 }
				 else sb.append(ext.toString());
			 }
			 catch (Exception e) {
				 sb.append("", Error parsing this extension"");
			 }
		 }
		 Map<String,Extension> invalid = extensions.getUnparseableExtensions();
		 if (invalid.isEmpty() == false) {
			 sb.append(""\nUnparseable certificate extensions: "" + invalid.size());
			 int i = 1;
			 for (Extension ext : invalid.values()) {
				 sb.append(""\n["" + (i++) + ""]: "");
				 sb.append(ext);
			 }
		 }
	 }
	 sb.append(""\n]"");
	 return sb.toString();
 }",0,0,1,0
"final class NativeBoolean extends IdScriptableObject{
	 private static final Object BOOLEAN_TAG = new Object();
	 static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeBoolean obj = new NativeBoolean(false);
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeBoolean(boolean b) {
		 booleanValue = b;
	 }
	 public String getClassName() {
		 return ""Boolean"";
	 }
	 public Object getDefaultValue(Class typeHint) {
		 if (typeHint == ScriptRuntime.BooleanClass) return ScriptRuntime.wrapBoolean(booleanValue);
		 return super.getDefaultValue(typeHint);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_valueOf: arity=0;
			 s=""valueOf"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(BOOLEAN_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(BOOLEAN_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 if (id == Id_constructor) {
			 boolean b = ScriptRuntime.toBoolean(args, 0);
			 if (thisObj == null) {
				 return new NativeBoolean(b);
			 }
			 return ScriptRuntime.wrapBoolean(b);
		 }
		 if (!(thisObj instanceof NativeBoolean)) throw incompatibleCallError(f);
		 boolean value = ((NativeBoolean)thisObj).booleanValue;
		 switch (id) {
			 case Id_toString: return value ? ""true"" : ""false"";
			 case Id_toSource: return value ? ""(new Boolean(true))"" : ""(new Boolean(false))"";
			 case Id_valueOf: return ScriptRuntime.wrapBoolean(value);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==7) {
				 X=""valueOf"";
				id=Id_valueOf;
			 }
			 else if (s_length==8) {
				 c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
			 }
			 else if (s_length==11) {
				 X=""constructor"";
				id=Id_constructor;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toSource = 3, Id_valueOf = 4, MAX_PROTOTYPE_ID = 4;
	 private boolean booleanValue;
}",0,0,0,0
"public abstract class DownloadAction {
	 public abstract static class Deserializer {
		 public final String type;
		 public final int version;
		 public Deserializer(String type, int version) {
			 this.type = type;
			 this.version = version;
		 }
		 public abstract DownloadAction readFromStream(int version, DataInputStream input) throws IOException;
	 }
	 private static Deserializer[] defaultDeserializers;
	 public static synchronized Deserializer[] getDefaultDeserializers() {
		 if (defaultDeserializers != null) {
			 return defaultDeserializers;
		 }
		 Deserializer[] deserializers = new Deserializer[4];
		 int count = 0;
		 deserializers[count++] = ProgressiveDownloadAction.DESERIALIZER;
		 Class<?> clazz;
		 try {
			 clazz = Class.forName(""com.google.android.exoplayer2.source.dash.offline.DashDownloadAction"");
			 deserializers[count++] = getDeserializer(clazz);
		 }
		 catch (Exception e) {
		 }
		 try {
			 clazz = Class.forName(""com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction"");
			 deserializers[count++] = getDeserializer(clazz);
		 }
		 catch (Exception e) {
		 }
		 try {
			 clazz = Class.forName( ""com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction"");
			 deserializers[count++] = getDeserializer(clazz);
		 }
		 catch (Exception e) {
		 }
		 defaultDeserializers = Arrays.copyOf(Assertions.checkNotNull(deserializers), count);
		 return defaultDeserializers;
	 }
	 public static DownloadAction deserializeFromStream( Deserializer[] deserializers, InputStream input) throws IOException {
		 DataInputStream dataInputStream = new DataInputStream(input);
		 String type = dataInputStream.readUTF();
		 int version = dataInputStream.readInt();
		 for (Deserializer deserializer : deserializers) {
			 if (type.equals(deserializer.type) && deserializer.version >= version) {
				 return deserializer.readFromStream(version, dataInputStream);
			 }
		 }
		 throw new DownloadException(""No deserializer found for:"" + type + "", "" + version);
	 }
	 public static void serializeToStream(DownloadAction action, OutputStream output) throws IOException {
		 DataOutputStream dataOutputStream = new DataOutputStream(output);
		 dataOutputStream.writeUTF(action.type);
		 dataOutputStream.writeInt(action.version);
		 action.writeToStream(dataOutputStream);
		 dataOutputStream.flush();
	 }
	 public final String type;
	 public final int version;
	 public final Uri uri;
	 public final boolean isRemoveAction;
	 public final byte[] data;
	 protected DownloadAction( String type, int version, Uri uri, boolean isRemoveAction, byte[] data) {
		 this.type = type;
		 this.version = version;
		 this.uri = uri;
		 this.isRemoveAction = isRemoveAction;
		 this.data = data != null ? data : Util.EMPTY_BYTE_ARRAY;
	 }
	 public final byte[] toByteArray() {
		 ByteArrayOutputStream output = new ByteArrayOutputStream();
		 try {
			 serializeToStream(this, output);
		 }
		 catch (IOException e) {
			 throw new IllegalStateException();
		 }
		 return output.toByteArray();
	 }
	 public boolean isSameMedia(DownloadAction other) {
		 return uri.equals(other.uri);
	 }
	 public List<StreamKey> getKeys() {
		 return Collections.emptyList();
	 }
	 protected abstract void writeToStream(DataOutputStream output) throws IOException;
	 public abstract Downloader createDownloader( DownloaderConstructorHelper downloaderConstructorHelper);
	 public boolean equals( Object o) {
		 if (o == null || getClass() != o.getClass()) {
			 return false;
		 }
		 DownloadAction that = (DownloadAction) o;
		 return type.equals(that.type) && version == that.version && uri.equals(that.uri) && isRemoveAction == that.isRemoveAction && Arrays.equals(data, that.data);
	 }
	 public int hashCode() {
		 int result = uri.hashCode();
		 result = 31 * result + (isRemoveAction ? 1 : 0);
		 result = 31 * result + Arrays.hashCode(data);
		 return result;
	 }
	 private static Deserializer getDeserializer(Class<?> clazz) throws NoSuchFieldException, IllegalAccessException {
		 Object value = clazz.getDeclaredField(""DESERIALIZER"").get(null);
		 return (Deserializer) Assertions.checkNotNull(value);
	 }
}",1,0,0,0
"public final IConverter get(Class<T> c){
	return classToConverter.get(c.getName());
}",0,0,0,0
"public static String getOatFileInstructionSet(File oatFile) throws Throwable {
	 ShareElfFile elfFile = null;
	 String result = """";
	 try {
		 elfFile = new ShareElfFile(oatFile);
		 final ShareElfFile.SectionHeader roDataHdr = elfFile.getSectionHeaderByName("".rodata"");
		 if (roDataHdr == null) {
			 throw new IOException(""Unable to find .rodata section."");
		 }
		 final FileChannel channel = elfFile.getChannel();
		 channel.position(roDataHdr.shOffset);
		 final byte[] oatMagicAndVersion = new byte[8];
		 ShareElfFile.readUntilLimit(channel, ByteBuffer.wrap(oatMagicAndVersion), ""Failed to read oat magic and version."");
		 if (oatMagicAndVersion[0] != 'o' || oatMagicAndVersion[1] != 'a' || oatMagicAndVersion[2] != 't' || oatMagicAndVersion[3] != '\n') {
			 throw new IOException( String.format(""Bad oat magic: %x %x %x %x"", oatMagicAndVersion[0], oatMagicAndVersion[1], oatMagicAndVersion[2], oatMagicAndVersion[3]) );
		 }
		 final int versionOffsetFromOatBegin = 4;
		 final int versionBytes = 3;
		 final String oatVersion = new String(oatMagicAndVersion, versionOffsetFromOatBegin, versionBytes, Charset.forName(""ASCII""));
		 try {
			 Integer.parseInt(oatVersion);
		 }
		 catch (NumberFormatException e) {
			 throw new IOException(""Bad oat version: "" + oatVersion);
		 }
		 ByteBuffer buffer = ByteBuffer.allocate(128);
		 buffer.order(elfFile.getDataOrder());
		 final int isaNumOffsetFromOatBegin = 12;
		 channel.position(roDataHdr.shOffset + isaNumOffsetFromOatBegin);
		 buffer.limit(4);
		 ShareElfFile.readUntilLimit(channel, buffer, ""Failed to read isa num."");
		 int isaNum = buffer.getInt();
		 if (isaNum < 0 || isaNum >= InstructionSet.values().length) {
			 throw new IOException(""Bad isa num: "" + isaNum);
		 }
		 switch (InstructionSet.values()[isaNum]) {
			 case kArm: case kThumb2: result = ""arm"";
			 break;
			 case kArm64: result = ""arm64"";
			 break;
			 case kX86: result = ""x86"";
			 break;
			 case kX86_64: result = ""x86_64"";
			 break;
			 case kMips: result = ""mips"";
			 break;
			 case kMips64: result = ""mips64"";
			 break;
			 case kNone: result = ""none"";
			 break;
			 default: throw new IOException(""Should not reach here."");
		 }
	 }
	 finally {
		 if (elfFile != null) {
			 try {
				 elfFile.close();
			 }
			 catch (Exception ignored) {
			 }
		 }
	 }
	 return result;
 }",0,0,1,0
"public static class GatewayHub {
	 protected List<Gateway> gateways;
	 protected String id;
	 protected String bindAddress;
	 protected String maximumTimeBetweenPings;
	 protected String port;
	 protected String socketBufferSize;
	 protected String startupPolicy;
	 protected Boolean manualStart;
	 protected BigInteger maxConnections;
	 public List<Gateway> getGateway() {
		 if (gateways == null) {
			 gateways = new ArrayList<Gateway>();
		 }
		 return this.gateways;
	 }
	 public String getId() {
		 return id;
	 }
	 public void setId(String value) {
		 this.id = value;
	 }
	 public String getBindAddress() {
		 return bindAddress;
	 }
	 public void setBindAddress(String value) {
		 this.bindAddress = value;
	 }
	 public String getMaximumTimeBetweenPings() {
		 return maximumTimeBetweenPings;
	 }
	 public void setMaximumTimeBetweenPings(String value) {
		 this.maximumTimeBetweenPings = value;
	 }
	 public String getPort() {
		 return port;
	 }
	 public void setPort(String value) {
		 this.port = value;
	 }
	 public String getSocketBufferSize() {
		 return socketBufferSize;
	 }
	 public void setSocketBufferSize(String value) {
		 this.socketBufferSize = value;
	 }
	 public String getStartupPolicy() {
		 return startupPolicy;
	 }
	 public void setStartupPolicy(String value) {
		 this.startupPolicy = value;
	 }
	 public Boolean isManualStart() {
		 return manualStart;
	 }
	 public void setManualStart(Boolean value) {
		 this.manualStart = value;
	 }
	 public BigInteger getMaxConnections() {
		 return maxConnections;
	 }
	 public void setMaxConnections(BigInteger value) {
		 this.maxConnections = value;
	 }
	 public static class Gateway {
		 protected List<GatewayEndpoint> gatewayEndpoints;
		 protected List<DeclarableType> gatewayListeners;
		 protected CacheConfig.GatewayHub.Gateway.GatewayQueue gatewayQueue;
		 protected Boolean earlyAck;
		 protected String id;
		 protected String socketBufferSize;
		 protected String socketReadTimeout;
		 protected String concurrencyLevel;
		 protected String orderPolicy;
		 public List<GatewayEndpoint> getGatewayEndpoints() {
			 if (gatewayEndpoints == null) {
				 gatewayEndpoints = new ArrayList<GatewayEndpoint>();
			 }
			 return this.gatewayEndpoints;
		 }
		 public List<DeclarableType> getGatewayListeners() {
			 if (gatewayListeners == null) {
				 gatewayListeners = new ArrayList<DeclarableType>();
			 }
			 return this.gatewayListeners;
		 }
		 public CacheConfig.GatewayHub.Gateway.GatewayQueue getGatewayQueue() {
			 return gatewayQueue;
		 }
		 public void setGatewayQueue(CacheConfig.GatewayHub.Gateway.GatewayQueue value) {
			 this.gatewayQueue = value;
		 }
		 public Boolean isEarlyAck() {
			 return earlyAck;
		 }
		 public void setEarlyAck(Boolean value) {
			 this.earlyAck = value;
		 }
		 public String getId() {
			 return id;
		 }
		 public void setId(String value) {
			 this.id = value;
		 }
		 public String getSocketBufferSize() {
			 return socketBufferSize;
		 }
		 public void setSocketBufferSize(String value) {
			 this.socketBufferSize = value;
		 }
		 public String getSocketReadTimeout() {
			 return socketReadTimeout;
		 }
		 public void setSocketReadTimeout(String value) {
			 this.socketReadTimeout = value;
		 }
		 public String getConcurrencyLevel() {
			 return concurrencyLevel;
		 }
		 public void setConcurrencyLevel(String value) {
			 this.concurrencyLevel = value;
		 }
		 public String getOrderPolicy() {
			 return orderPolicy;
		 }
		 public void setOrderPolicy(String value) {
			 this.orderPolicy = value;
		 }
		 public static class GatewayEndpoint {
			 protected String host;
			 protected String id;
			 protected String port;
			 public String getHost() {
				 return host;
			 }
			 public void setHost(String value) {
				 this.host = value;
			 }
			 public String getId() {
				 return id;
			 }
			 public void setId(String value) {
				 this.id = value;
			 }
			 public String getPort() {
				 return port;
			 }
			 public void setPort(String value) {
				 this.port = value;
			 }
		 }
		 public static class GatewayQueue {
			 protected String alertThreshold;
			 protected Boolean batchConflation;
			 protected String batchSize;
			 protected String batchTimeInterval;
			 protected Boolean enablePersistence;
			 protected String diskStoreName;
			 protected Boolean rollOplogs;
			 protected String maximumQueueMemory;
			 protected String overflowDirectory;
			 public String getAlertThreshold() {
				 return alertThreshold;
			 }
			 public void setAlertThreshold(String value) {
				 this.alertThreshold = value;
			 }
			 public Boolean isBatchConflation() {
				 return batchConflation;
			 }
			 public void setBatchConflation(Boolean value) {
				 this.batchConflation = value;
			 }
			 public String getBatchSize() {
				 return batchSize;
			 }
			 public void setBatchSize(String value) {
				 this.batchSize = value;
			 }
			 public String getBatchTimeInterval() {
				 return batchTimeInterval;
			 }
			 public void setBatchTimeInterval(String value) {
				 this.batchTimeInterval = value;
			 }
			 public Boolean isEnablePersistence() {
				 return enablePersistence;
			 }
			 public void setEnablePersistence(Boolean value) {
				 this.enablePersistence = value;
			 }
			 public String getDiskStoreName() {
				 return diskStoreName;
			 }
			 public void setDiskStoreName(String value) {
				 this.diskStoreName = value;
			 }
			 public Boolean isRollOplogs() {
				 return rollOplogs;
			 }
			 public void setRollOplogs(Boolean value) {
				 this.rollOplogs = value;
			 }
			 public String getMaximumQueueMemory() {
				 return maximumQueueMemory;
			 }
			 public void setMaximumQueueMemory(String value) {
				 this.maximumQueueMemory = value;
			 }
			 public String getOverflowDirectory() {
				 return overflowDirectory;
			 }
			 public void setOverflowDirectory(String value) {
				 this.overflowDirectory = value;
			 }
		 }
	 }
 }",1,1,0,0
"private void resolveWeakTypes(int start, int limit, byte level, byte sor, byte eor) {
	 byte preceedingCharacterType = sor;
	 for (int i = start;
	 i < limit;
	 ++i) {
		 byte t = resultTypes[i];
		 if (t == NSM) {
			 resultTypes[i] = preceedingCharacterType;
		 }
		 else {
			 preceedingCharacterType = t;
		 }
	 }
	 for (int i = start;
	 i < limit;
	 ++i) {
		 if (resultTypes[i] == EN) {
			 for (int j = i - 1;
			 j >= start;
			 --j) {
				 byte t = resultTypes[j];
				 if (t == L || t == R || t == AL) {
					 if (t == AL) {
						 resultTypes[i] = AN;
					 }
					 break;
				 }
			 }
		 }
	 }
	 for (int i = start;
	 i < limit;
	 ++i) {
		 if (resultTypes[i] == AL) {
			 resultTypes[i] = R;
		 }
	 }
	 for (int i = start + 1;
	 i < limit - 1;
	 ++i) {
		 if (resultTypes[i] == ES || resultTypes[i] == CS) {
			 byte prevSepType = resultTypes[i-1];
			 byte succSepType = resultTypes[i+1];
			 if (prevSepType == EN && succSepType == EN) {
				 resultTypes[i] = EN;
			 }
			 else if (resultTypes[i] == CS && prevSepType == AN && succSepType == AN) {
				 resultTypes[i] = AN;
			 }
		 }
	 }
	 for (int i = start;
	 i < limit;
	 ++i) {
		 if (resultTypes[i] == ET) {
			 int runstart = i;
			 int runlimit = findRunLimit(runstart, limit, new byte[] {
			 ET }
			);
			 byte t = runstart == start ? sor : resultTypes[runstart - 1];
			 if (t != EN) {
				 t = runlimit == limit ? eor : resultTypes[runlimit];
			 }
			 if (t == EN) {
				 setTypes(runstart, runlimit, EN);
			 }
			 i = runlimit;
		 }
	 }
	 for (int i = start;
	 i < limit;
	 ++i) {
		 byte t = resultTypes[i];
		 if (t == ES || t == ET || t == CS) {
			 resultTypes[i] = ON;
		 }
	 }
	 for (int i = start;
	 i < limit;
	 ++i) {
		 if (resultTypes[i] == EN) {
			 byte prevStrongType = sor;
			 for (int j = i - 1;
			 j >= start;
			 --j) {
				 byte t = resultTypes[j];
				 if (t == L || t == R) {
					 prevStrongType = t;
					 break;
				 }
			 }
			 if (prevStrongType == L) {
				 resultTypes[i] = L;
			 }
		 }
	 }
 }",0,0,1,0
"static class VaultInitializationResponseImpl implements VaultInitializationResponse {
	private List<String> keys = new ArrayList<>();
	private String rootToken = """";
	public VaultToken getRootToken() {
		return VaultToken.of(rootToken);
	}
}",0,1,0,0
"public static class WithName extends INodeReference {
	 private final byte[] name;
	 private final int lastSnapshotId;
	 public WithName(INodeDirectory parent, WithCount referred, byte[] name, int lastSnapshotId) {
		 super(parent, referred);
		 this.name = name;
		 this.lastSnapshotId = lastSnapshotId;
		 referred.addReference(this);
	 }
	 public final byte[] getLocalNameBytes() {
		 return name;
	 }
	 public final void setLocalName(byte[] name) {
		 throw new UnsupportedOperationException(""Cannot set name: "" + getClass() + "" is immutable."");
	 }
	 public int getLastSnapshotId() {
		 return lastSnapshotId;
	 }
	 public final ContentSummaryComputationContext computeContentSummary( int snapshotId, ContentSummaryComputationContext summary) {
		 final int s = snapshotId < lastSnapshotId ? snapshotId : lastSnapshotId;
		 final QuotaCounts q = computeQuotaUsage( summary.getBlockStoragePolicySuite(), getStoragePolicyID(), false, s);
		 summary.getCounts().addContent(Content.DISKSPACE, q.getStorageSpace());
		 summary.getCounts().addTypeSpaces(q.getTypeSpaces());
		 return summary;
	 }
	 public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps, byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {
		 Preconditions.checkState(lastSnapshotId == Snapshot.CURRENT_STATE_ID || this.lastSnapshotId >= lastSnapshotId);
		 final INode referred = this.getReferredINode().asReference() .getReferredINode();
		 int id = lastSnapshotId != Snapshot.CURRENT_STATE_ID ? lastSnapshotId : this.lastSnapshotId;
		 return referred.computeQuotaUsage(bsps, blockStoragePolicyId, false, id);
	 }
	 public void cleanSubtree(ReclaimContext reclaimContext, final int snapshot, int prior) {
		 Preconditions.checkArgument(snapshot != Snapshot.CURRENT_STATE_ID);
		 if (prior == Snapshot.NO_SNAPSHOT_ID) {
			 prior = getPriorSnapshot(this);
		 }
		 if (prior != Snapshot.NO_SNAPSHOT_ID && Snapshot.ID_INTEGER_COMPARATOR.compare(snapshot, prior) <= 0) {
			 return;
		 }
		 QuotaCounts old = reclaimContext.quotaDelta().getCountsCopy();
		 getReferredINode().cleanSubtree(reclaimContext, snapshot, prior);
		 INodeReference ref = getReferredINode().getParentReference();
		 if (ref != null) {
			 QuotaCounts current = reclaimContext.quotaDelta().getCountsCopy();
			 current.subtract(old);
			 reclaimContext.quotaDelta().addUpdatePath(ref, current);
		 }
		 if (snapshot < lastSnapshotId) {
			 reclaimContext.quotaDelta().setCounts(old);
		 }
	 }
	 public void destroyAndCollectBlocks(ReclaimContext reclaimContext) {
		 int snapshot = getSelfSnapshot();
		 reclaimContext.quotaDelta().add(computeQuotaUsage(reclaimContext.bsps));
		 if (removeReference(this) <= 0) {
			 getReferredINode().destroyAndCollectBlocks(reclaimContext.getCopy());
		 }
		 else {
			 int prior = getPriorSnapshot(this);
			 INode referred = getReferredINode().asReference().getReferredINode();
			 if (snapshot != Snapshot.NO_SNAPSHOT_ID) {
				 if (prior != Snapshot.NO_SNAPSHOT_ID && snapshot <= prior) {
					 return;
				 }
				 ReclaimContext newCtx = reclaimContext.getCopy();
				 referred.cleanSubtree(newCtx, snapshot, prior);
				 INodeReference ref = getReferredINode().getParentReference();
				 if (ref != null) {
					 reclaimContext.quotaDelta().addUpdatePath(ref, newCtx.quotaDelta().getCountsCopy());
				 }
			 }
		 }
	 }
	 private int getSelfSnapshot() {
		 INode referred = getReferredINode().asReference().getReferredINode();
		 int snapshot = Snapshot.NO_SNAPSHOT_ID;
		 if (referred.isFile() && referred.asFile().isWithSnapshot()) {
			 snapshot = referred.asFile().getDiffs().getPrior(lastSnapshotId);
		 }
		 else if (referred.isDirectory()) {
			 DirectoryWithSnapshotFeature sf = referred.asDirectory() .getDirectoryWithSnapshotFeature();
			 if (sf != null) {
				 snapshot = sf.getDiffs().getPrior(lastSnapshotId);
			 }
		 }
		 return snapshot;
	 }
 }",1,1,0,0
"public class IndexSummary{
	 private ArrayList<KeyPosition> indexPositions;
	 private long keysWritten = 0;
	 public IndexSummary(long expectedKeys) {
		 long expectedEntries = expectedKeys / DatabaseDescriptor.getIndexInterval();
		 if (expectedEntries > Integer.MAX_VALUE) throw new RuntimeException(""Cannot use index_interval of "" + DatabaseDescriptor.getIndexInterval() + "" with "" + expectedKeys + "" (expected) keys."");
		 indexPositions = new ArrayList<KeyPosition>((int)expectedEntries);
	 }
	 public void incrementRowid() {
		 keysWritten++;
	 }
	 public boolean shouldAddEntry() {
		 return keysWritten % DatabaseDescriptor.getIndexInterval() == 0;
	 }
	 public void addEntry(DecoratedKey decoratedKey, long indexPosition) {
		 indexPositions.add(new KeyPosition(decoratedKey, indexPosition));
	 }
	 public void maybeAddEntry(DecoratedKey decoratedKey, long indexPosition) {
		 if (shouldAddEntry()) addEntry(decoratedKey, indexPosition);
		 incrementRowid();
	 }
	 public List<KeyPosition> getIndexPositions() {
		 return indexPositions;
	 }
	 public void complete() {
		 indexPositions.trimToSize();
	 }
	 public static final class KeyPosition implements Comparable<KeyPosition> {
		 public final DecoratedKey key;
		 public final long indexPosition;
		 public KeyPosition(DecoratedKey key, long indexPosition) {
			 this.key = key;
			 this.indexPosition = indexPosition;
		 }
		 public int compareTo(KeyPosition kp) {
			 return key.compareTo(kp.key);
		 }
		 public String toString() {
			 return key + "":"" + indexPosition;
		 }
	 }
}",0,0,0,0
"private static class FollowSets000 {
	 public static final BitSet FOLLOW_1 = new BitSet(new long[]{
	0x0000000000000000L}
	);
	 public static final BitSet FOLLOW_2 = new BitSet(new long[]{
	0x0000000000000002L}
	);
	 public static final BitSet FOLLOW_3 = new BitSet(new long[]{
	0x0000000000004000L}
	);
	 public static final BitSet FOLLOW_4 = new BitSet(new long[]{
	0x0000000000001000L}
	);
	 public static final BitSet FOLLOW_5 = new BitSet(new long[]{
	0x0000000000002002L}
	);
	 public static final BitSet FOLLOW_6 = new BitSet(new long[]{
	0x0000000000000010L}
	);
 }",0,0,0,0
"private void fillImage(int startH, int startW, int endH, int endW) {
	 int alpha = new Color(originalImage.getRGB(width / 2, height / 2)).getRed();
	 int whiteRGB = ImageUtilities.colorToRGB(alpha, 255, 255, 255);
	 for (int i = 0;
	 i < newHeight;
	 i++) {
		 for (int j = 0;
		 j < newWidth;
		 j++) {
			 filteredImage.setRGB(j, i, whiteRGB);
		 }
	 }
	 int oldCenterH = (startH + endH) / 2;
	 int oldCenterW = (startW + endW) / 2;
	 int newCenterH = newHeight / 2;
	 int newCenterW = newWidth / 2;
	 boolean[][] visited = new boolean[newHeight][newWidth];
	 LinkedList<String> queue = new LinkedList<String>();
	 String pos = newCenterH + "" "" + newCenterW + "" "" + oldCenterH + "" "" + oldCenterW;
	 queue.addLast(pos);
	 visited[newCenterH][newCenterW] = true;
	 try {
		 while (!queue.isEmpty()) {
			 String tmp = queue.removeFirst();
			 int nh = Integer.parseInt(tmp.split("" "")[0]);
			 int nw = Integer.parseInt(tmp.split("" "")[1]);
			 int oh = Integer.parseInt(tmp.split("" "")[2]);
			 int ow = Integer.parseInt(tmp.split("" "")[3]);
			 filteredImage.setRGB(nw, nh, originalImage.getRGB(ow, oh));
			 for (int i = -1;
			 i <= 1;
			 i++) {
				 for (int j = -1;
				 j <= 1;
				 j++) {
					 int n_tmpH = nh + i;
					 int n_tmpW = nw + j;
					 int o_tmpH = oh + i;
					 int o_tmpW = ow + j;
					 if (!visited[n_tmpH][n_tmpW]) {
						 visited[n_tmpH][n_tmpW] = true;
						 queue.addLast(n_tmpH + "" "" + n_tmpW + "" "" + o_tmpH + "" "" + o_tmpW);
					 }
				 }
			 }
		 }
	 }
	 catch (IndexOutOfBoundsException e) {
	 }
 }",0,0,1,0
"public FilterChain createOutputFilterChain() {
	 if (isReference()) {
		 throw noChildrenAllowed();
	 }
	 FilterChain result = new FilterChain();
	 result.setProject(getProject());
	 outputFilterChains.add(result);
	 return result;
 }",0,0,0,0
"public abstract class PlanStructuralComparer<E extends Operator, P extends OperatorPlan<E>> {
	 protected Map<OperatorKey, OperatorKey> plan1ToPlan2 = null ;
	 protected Map<OperatorKey, OperatorKey> plan2ToPlan1 = null ;
	 private NodeMatcher nodeMatcher = new IncreasingKeyMatcher();
	 public boolean structurallyEquals(P plan1, P plan2, StringBuilder messages) {
		 plan1ToPlan2 = nodeMatcher.match(plan1, plan2, messages) ;
		 if (plan1ToPlan2 == null) {
			 return false ;
		 }
		 plan2ToPlan1 = generateInverseMap(plan1ToPlan2) ;
		 int diffCount = 0 ;
		 Iterator<OperatorKey> keyIter1 = plan1.getKeys().keySet().iterator() ;
		 while(keyIter1.hasNext()) {
			 OperatorKey opKey = keyIter1.next() ;
			 E op1 = plan1.getOperator(opKey) ;
			 E op2 = plan2.getOperator(plan1ToPlan2.get(opKey)) ;
			 diffCount += diffOutgoingEdges(op1, op2, plan1, plan2, messages, ""plan1"", ""plan2"") ;
		 }
		 return diffCount==0 ;
	 }
	 public boolean structurallyEquals(P plan1, P plan2) {
		 return structurallyEquals(plan1, plan2, null) ;
	 }
	 public void setNodeMatcher(NodeMatcher matcher) {
		 nodeMatcher = matcher ;
	 }
	 private Map<OperatorKey, OperatorKey> generateInverseMap( Map<OperatorKey, OperatorKey> map) {
		 Map<OperatorKey, OperatorKey> inverseMap = new HashMap<OperatorKey, OperatorKey>() ;
		 Iterator<OperatorKey> iter = map.keySet().iterator() ;
		 while(iter.hasNext()) {
			 OperatorKey key = iter.next() ;
			 inverseMap.put(map.get(key) ,key) ;
		 }
		 return inverseMap ;
	 }
	 private int diffOutgoingEdges(E operator1, E operator2, P plan1, P plan2, StringBuilder messages, String plan1Name, String plan2Name) {
		 int diffCount = 0 ;
		 List<E> list1 = plan1.getSuccessors(operator1) ;
		 List<E> list2 = plan2.getSuccessors(operator2) ;
		 if ((list1==null) && (list2==null)) {
			 return 0 ;
		 }
		 else if ((list1!=null) && (list2==null)) {
			 for(E op: list1) {
				 if (messages != null) {
					 appendMissingEdgeMessage(operator1.getOperatorKey(), op.getOperatorKey(), messages, plan2Name);
				 }
				 diffCount++ ;
			 }
			 return diffCount ;
		 }
		 else if ((list1==null) && (list2!=null)) {
			 for(E op: list2) {
				 if (messages != null) {
					 appendMissingEdgeMessage(operator2.getOperatorKey(), op.getOperatorKey(), messages, plan1Name);
				 }
				 diffCount++ ;
			 }
			 return diffCount ;
		 }
		 Map<OperatorKey, Boolean> edgeMap2 = new HashMap<OperatorKey, Boolean>() ;
		 for(E op: list2) {
			 edgeMap2.put(op.getOperatorKey(), true) ;
		 }
		 for(E op: list1) {
			 if (edgeMap2.get(plan1ToPlan2.get(op.getOperatorKey())) == null) {
				 if (messages != null) {
					 appendMissingEdgeMessage(operator1.getOperatorKey(), op.getOperatorKey(), messages, plan2Name) ;
				 }
				 diffCount++ ;
			 }
		 }
		 Map<OperatorKey, Boolean> edgeMap1 = new HashMap<OperatorKey, Boolean>() ;
		 for(E op: list1) {
			 edgeMap1.put(op.getOperatorKey(), true) ;
		 }
		 for(E op: list2) {
			 if (edgeMap1.get(plan2ToPlan1.get(op.getOperatorKey())) == null) {
				 if (messages != null) {
					 appendMissingEdgeMessage(operator2.getOperatorKey(), op.getOperatorKey(), messages, plan1Name) ;
				 }
				 diffCount++ ;
			 }
		 }
		 return diffCount ;
	 }
	 protected void appendOpKey(OperatorKey operatorKey, StringBuilder sb) {
		 sb.append(""("") ;
		 sb.append(operatorKey.toString()) ;
		 sb.append("")"") ;
	 }
	 private void appendMissingEdgeMessage(OperatorKey fromKey, OperatorKey toKey, StringBuilder messages, String planName) {
		 messages.append(""Edge "") ;
		 appendOpKey(fromKey, messages) ;
		 messages.append("" -> "") ;
		 appendOpKey(toKey, messages) ;
		 messages.append("" doesn't exist"") ;
		 if (planName != null) {
			 messages.append("" in "") ;
			 messages.append(planName) ;
		 }
		 messages.append(""\n"") ;
	 }
}",1,0,0,0
"public boolean hasNext() {
	 return iter.hasNext();
 }",0,0,0,0
"public class CvsTagDiff extends AbstractCvsTask {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private static final DOMElementWriter DOM_WRITER = new DOMElementWriter();
	 static final String FILE_STRING = ""File "";
	 static final String TO_STRING = "" to "";
	 static final String FILE_IS_NEW = "" is new;
	"";
	 static final String REVISION = ""revision "";
	 static final String FILE_HAS_CHANGED = "" changed from revision "";
	 static final String FILE_WAS_REMOVED = "" is removed"";
	 private String mypackage;
	 private String mystartTag;
	 private String myendTag;
	 private String mystartDate;
	 private String myendDate;
	 private File mydestfile;
	 public void setPackage(String p) {
		 mypackage = p;
	 }
	 public void setStartTag(String s) {
		 mystartTag = s;
	 }
	 public void setStartDate(String s) {
		 mystartDate = s;
	 }
	 public void setEndTag(String s) {
		 myendTag = s;
	 }
	 public void setEndDate(String s) {
		 myendDate = s;
	 }
	 public void setDestFile(File f) {
		 mydestfile = f;
	 }
	 public void execute() throws BuildException {
		 validate();
		 addCommandArgument(""rdiff"");
		 addCommandArgument(""-s"");
		 if (mystartTag != null) {
			 addCommandArgument(""-r"");
			 addCommandArgument(mystartTag);
		 }
		 else {
			 addCommandArgument(""-D"");
			 addCommandArgument(mystartDate);
		 }
		 if (myendTag != null) {
			 addCommandArgument(""-r"");
			 addCommandArgument(myendTag);
		 }
		 else {
			 addCommandArgument(""-D"");
			 addCommandArgument(myendDate);
		 }
		 StringTokenizer myTokenizer = new StringTokenizer(mypackage);
		 while (myTokenizer.hasMoreTokens()) {
			 addCommandArgument(myTokenizer.nextToken());
		 }
		 setCommand("""");
		 File tmpFile = null;
		 try {
			 tmpFile = FILE_UTILS.createTempFile(""cvstagdiff"", "".log"", null, true, true);
			 setOutput(tmpFile);
			 super.execute();
			 CvsTagEntry[] entries = parseRDiff(tmpFile);
			 writeTagDiff(entries);
		 }
		 finally {
			 if (tmpFile != null) {
				 tmpFile.delete();
			 }
		 }
	 }
	 private CvsTagEntry[] parseRDiff(File tmpFile) throws BuildException {
		 BufferedReader reader = null;
		 try {
			 reader = new BufferedReader(new FileReader(tmpFile));
			 String toBeRemoved = FILE_STRING + mypackage + ""/"";
			 int headerLength = toBeRemoved.length();
			 Vector entries = new Vector();
			 String line = reader.readLine();
			 int index;
			 CvsTagEntry entry = null;
			 while (null != line) {
				 if (line.length() > headerLength) {
					 if (line.startsWith(toBeRemoved)) {
						 line = line.substring(headerLength);
					 }
					 else {
						 line = line.substring(FILE_STRING.length());
					 }
					 if ((index = line.indexOf(FILE_IS_NEW)) != -1) {
						 String filename = line.substring(0, index);
						 String rev = null;
						 int indexrev = -1;
						 if ((indexrev = line.indexOf(REVISION, index)) != -1) {
							 rev = line.substring(indexrev + REVISION.length());
						 }
						 entry = new CvsTagEntry(filename, rev);
						 entries.addElement(entry);
						 log(entry.toString(), Project.MSG_VERBOSE);
					 }
					 else if ((index = line.indexOf(FILE_HAS_CHANGED)) != -1) {
						 String filename = line.substring(0, index);
						 int revSeparator = line.indexOf("" to "", index);
						 String prevRevision = line.substring(index + FILE_HAS_CHANGED.length(), revSeparator);
						 String revision = line.substring(revSeparator + TO_STRING.length());
						 entry = new CvsTagEntry(filename, revision, prevRevision);
						 entries.addElement(entry);
						 log(entry.toString(), Project.MSG_VERBOSE);
					 }
					 else if ((index = line.indexOf(FILE_WAS_REMOVED)) != -1) {
						 String filename = line.substring(0, index);
						 String rev = null;
						 int indexrev = -1;
						 if ((indexrev = line.indexOf(REVISION, index)) != -1) {
							 rev = line.substring(indexrev + REVISION.length());
						 }
						 entry = new CvsTagEntry(filename, null, rev);
						 entries.addElement(entry);
						 log(entry.toString(), Project.MSG_VERBOSE);
					 }
				 }
				 line = reader.readLine();
			 }
			 CvsTagEntry[] array = new CvsTagEntry[entries.size()];
			 entries.copyInto(array);
			 return array;
		 }
		 catch (IOException e) {
			 throw new BuildException(""Error in parsing"", e);
		 }
		 finally {
			 if (reader != null) {
				 try {
					 reader.close();
				 }
				 catch (IOException e) {
					 log(e.toString(), Project.MSG_ERR);
				 }
			 }
		 }
	 }
	 private void writeTagDiff(CvsTagEntry[] entries) throws BuildException {
		 FileOutputStream output = null;
		 try {
			 output = new FileOutputStream(mydestfile);
			 PrintWriter writer = new PrintWriter( new OutputStreamWriter(output, ""UTF-8""));
			 writer.println(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
			 Document doc = DOMUtils.newDocument();
			 Element root = doc.createElement(""tagdiff"");
			 if (mystartTag != null) {
				 root.setAttribute(""startTag"", mystartTag);
			 }
			 else {
				 root.setAttribute(""startDate"", mystartDate);
			 }
			 if (myendTag != null) {
				 root.setAttribute(""endTag"", myendTag);
			 }
			 else {
				 root.setAttribute(""endDate"", myendDate);
			 }
			 root.setAttribute(""cvsroot"", getCvsRoot());
			 root.setAttribute(""package"", mypackage);
			 DOM_WRITER.openElement(root, writer, 0, ""\t"");
			 writer.println();
			 for (int i = 0, c = entries.length;
			 i < c;
			 i++) {
				 writeTagEntry(doc, writer, entries[i]);
			 }
			 DOM_WRITER.closeElement(root, writer, 0, ""\t"", true);
			 writer.flush();
			 writer.close();
		 }
		 catch (UnsupportedEncodingException uee) {
			 log(uee.toString(), Project.MSG_ERR);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(ioe.toString(), ioe);
		 }
		 finally {
			 if (null != output) {
				 try {
					 output.close();
				 }
				 catch (IOException ioe) {
					 log(ioe.toString(), Project.MSG_ERR);
				 }
			 }
		 }
	 }
	 private void writeTagEntry(Document doc, PrintWriter writer, CvsTagEntry entry) throws IOException {
		 Element ent = doc.createElement(""entry"");
		 Element f = DOMUtils.createChildElement(ent, ""file"");
		 DOMUtils.appendCDATAElement(f, ""name"", entry.getFile());
		 if (entry.getRevision() != null) {
			 DOMUtils.appendTextElement(f, ""revision"", entry.getRevision());
		 }
		 if (entry.getPreviousRevision() != null) {
			 DOMUtils.appendTextElement(f, ""prevrevision"", entry.getPreviousRevision());
		 }
		 DOM_WRITER.write(ent, writer, 1, ""\t"");
	 }
	 private void validate() throws BuildException {
		 if (null == mypackage) {
			 throw new BuildException(""Package/module must be set."");
		 }
		 if (null == mydestfile) {
			 throw new BuildException(""Destfile must be set."");
		 }
		 if (null == mystartTag && null == mystartDate) {
			 throw new BuildException(""Start tag or start date must be set."");
		 }
		 if (null != mystartTag && null != mystartDate) {
			 throw new BuildException(""Only one of start tag and start date "" + ""must be set."");
		 }
		 if (null == myendTag && null == myendDate) {
			 throw new BuildException(""End tag or end date must be set."");
		 }
		 if (null != myendTag && null != myendDate) {
			 throw new BuildException(""Only one of end tag and end date must "" + ""be set."");
		 }
	 }
}",0,0,0,0
"public void run(final JobConf job, final TaskUmbilicalProtocol umbilical) throws IOException {
	 final int partitions = job.getNumReduceTasks();
	 final SequenceFile.Writer[] outs = new SequenceFile.Writer[partitions];
	 try {
		 Reporter reporter = getReporter(umbilical, getProgress());
		 FileSystem localFs = FileSystem.getNamed(""local"", job);
		 CompressionCodec codec = null;
		 CompressionType compressionType = CompressionType.NONE;
		 if (job.getCompressMapOutput()) {
			 compressionType = job.getMapOutputCompressionType();
			 Class codecClass = job.getMapOutputCompressorClass(DefaultCodec.class);
			 codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, job);
		 }
		 for (int i = 0;
		 i < partitions;
		 i++) {
			 Path filename = mapOutputFile.getOutputFile(getTaskId(), i);
			 outs[i] = SequenceFile.createWriter(localFs, job, filename, job.getMapOutputKeyClass(), job.getMapOutputValueClass(), compressionType, codec, reporter);
			 LOG.info(""opened ""+this.mapOutputFile.getOutputFile(getTaskId(), i).getName());
		 }
		 final Partitioner partitioner = (Partitioner)ReflectionUtils.newInstance(job.getPartitionerClass(), job);
		 OutputCollector partCollector = new OutputCollector() {
			 public synchronized void collect(WritableComparable key, Writable value) throws IOException {
				 SequenceFile.Writer out = outs[partitioner.getPartition(key, value, partitions)];
				 long beforePos = out.getLength();
				 out.append(key, value);
				 reportProgress(umbilical);
				 myMetrics.mapOutput(out.getLength() - beforePos);
			 }
		 }
		;
		 OutputCollector collector = partCollector;
		 boolean combining = job.getCombinerClass() != null;
		 if (combining) {
			 collector = new CombiningCollector(job, partCollector, reporter);
		 }
		 final RecordReader rawIn = job.getInputFormat().getRecordReader (FileSystem.get(job), split, job, reporter);
		 RecordReader in = new RecordReader() {
			 private float perByte = 1.0f /(float)split.getLength();
			 public WritableComparable createKey() {
				 return rawIn.createKey();
			 }
			 public Writable createValue() {
				 return rawIn.createValue();
			 }
			 public synchronized boolean next(Writable key, Writable value) throws IOException {
				 float progress = (float)Math.min((rawIn.getPos()-split.getStart())*perByte, 1.0f);
				 reportProgress(umbilical, progress);
				 long beforePos = getPos();
				 boolean ret = rawIn.next(key, value);
				 myMetrics.mapInput(getPos() - beforePos);
				 return ret;
			 }
			 public long getPos() throws IOException {
				 return rawIn.getPos();
			 }
			 public void close() throws IOException {
				 rawIn.close();
			 }
		 }
		;
		 MapRunnable runner = (MapRunnable)ReflectionUtils.newInstance(job.getMapRunnerClass(), job);
		 try {
			 runner.run(in, collector, reporter);
			 if (combining) {
				 ((CombiningCollector)collector).flush();
			 }
		 }
		 finally {
			 if (combining) {
				 ((CombiningCollector)collector).close();
			 }
			 in.close();
		 }
	 }
	 finally {
		 for (int i = 0;
		 i < partitions;
		 i++) {
			 if (outs[i] != null) {
				 outs[i].close();
			 }
		 }
	 }
	 done(umbilical);
 }",0,0,1,0
"public class Context{
	 public static final int VERSION_UNKNOWN = -1;
	 public static final int VERSION_DEFAULT = 0;
	 public static final int VERSION_1_0 = 100;
	 public static final int VERSION_1_1 = 110;
	 public static final int VERSION_1_2 = 120;
	 public static final int VERSION_1_3 = 130;
	 public static final int VERSION_1_4 = 140;
	 public static final int VERSION_1_5 = 150;
	 public static final int VERSION_1_6 = 160;
	 public static final int FEATURE_NON_ECMA_GET_YEAR = 1;
	 public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;
	 public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;
	 public static final int FEATURE_TO_STRING_AS_SOURCE = 4;
	 public static final int FEATURE_PARENT_PROTO_PROPRTIES = 5;
	 public static final int FEATURE_E4X = 6;
	 public static final int FEATURE_DYNAMIC_SCOPE = 7;
	 public static final int FEATURE_STRICT_VARS = 8;
	 public static final int FEATURE_STRICT_EVAL = 9;
	 public static final String languageVersionProperty = ""language version"";
	 public static final String errorReporterProperty = ""error reporter"";
	 public static final Object[] emptyArgs = ScriptRuntime.emptyArgs;
	 public Context() {
		 setLanguageVersion(VERSION_DEFAULT);
		 optimizationLevel = codegenClass != null ? 0 : -1;
	 }
	 public static Context getCurrentContext() {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 return VMBridge.instance.getContext(helper);
	 }
	 public static Context enter() {
		 return enter(null);
	 }
	 public static Context enter(Context cx) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context old = VMBridge.instance.getContext(helper);
		 if (old != null) {
			 if (cx != null && cx != old && cx.enterCount != 0) {
				 throw new IllegalArgumentException( ""Cannot enter Context active on another thread"");
			 }
			 if (old.factory != null) {
				 return old;
			 }
			 if (old.sealed) onSealedMutation();
			 cx = old;
		 }
		 else {
			 if (cx == null) {
				 cx = ContextFactory.getGlobal().makeContext();
			 }
			 else {
				 if (cx.sealed) onSealedMutation();
			 }
			 if (cx.enterCount != 0 || cx.factory != null) {
				 throw new IllegalStateException();
			 }
			 if (!cx.creationEventWasSent) {
				 cx.creationEventWasSent = true;
				 ContextFactory.getGlobal().onContextCreated(cx);
			 }
		 }
		 if (old == null) {
			 VMBridge.instance.setContext(helper, cx);
		 }
		 ++cx.enterCount;
		 return cx;
	 }
	 public static void exit() {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx == null) {
			 throw new IllegalStateException( ""Calling Context.exit without previous Context.enter"");
		 }
		 if (cx.factory != null) {
			 return;
		 }
		 if (cx.enterCount < 1) Kit.codeBug();
		 if (cx.sealed) onSealedMutation();
		 --cx.enterCount;
		 if (cx.enterCount == 0) {
			 VMBridge.instance.setContext(helper, null);
			 ContextFactory.getGlobal().onContextReleased(cx);
		 }
	 }
	 public static Object call(ContextAction action) {
		 return call(ContextFactory.getGlobal(), action);
	 }
	 public static Object call(ContextFactory factory, Callable callable, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (factory == null) {
			 factory = ContextFactory.getGlobal();
		 }
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx != null) {
			 Object result;
			 if (cx.factory != null) {
				 result = callable.call(cx, scope, thisObj, args);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 result = callable.call(cx, scope, thisObj, args);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
			 return result;
		 }
		 cx = prepareNewContext(factory, helper);
		 try {
			 return callable.call(cx, scope, thisObj, args);
		 }
		 finally {
			 releaseContext(helper, cx);
		 }
	 }
	 static Object call(ContextFactory factory, ContextAction action) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx != null) {
			 if (cx.factory != null) {
				 return action.run(cx);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 return action.run(cx);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
		 }
		 cx = prepareNewContext(factory, helper);
		 try {
			 return action.run(cx);
		 }
		 finally {
			 releaseContext(helper, cx);
		 }
	 }
	 private static Context prepareNewContext(ContextFactory factory, Object contextHelper) {
		 Context cx = factory.makeContext();
		 if (cx.factory != null || cx.enterCount != 0) {
			 throw new IllegalStateException(""factory.makeContext() returned Context instance already associated with some thread"");
		 }
		 cx.factory = factory;
		 factory.onContextCreated(cx);
		 if (factory.isSealed() && !cx.isSealed()) {
			 cx.seal(null);
		 }
		 VMBridge.instance.setContext(contextHelper, cx);
		 return cx;
	 }
	 private static void releaseContext(Object contextHelper, Context cx) {
		 VMBridge.instance.setContext(contextHelper, null);
		 try {
			 cx.factory.onContextReleased(cx);
		 }
		 finally {
			 cx.factory = null;
		 }
	 }
	 public static void addContextListener(ContextListener listener) {
		 String DBG = ""org.mozilla.javascript.tools.debugger.Main"";
		 if (DBG.equals(listener.getClass().getName())) {
			 Class cl = listener.getClass();
			 Class factoryClass = Kit.classOrNull( ""org.mozilla.javascript.ContextFactory"");
			 Class[] sig = {
			 factoryClass }
			;
			 Object[] args = {
			 ContextFactory.getGlobal() }
			;
			 try {
				 Method m = cl.getMethod(""attachTo"", sig);
				 m.invoke(listener, args);
			 }
			 catch (Exception ex) {
				 RuntimeException rex = new RuntimeException();
				 Kit.initCause(rex, ex);
				 throw rex;
			 }
			 return;
		 }
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public static void removeContextListener(ContextListener listener) {
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public final ContextFactory getFactory() {
		 ContextFactory result = factory;
		 if (result == null) {
			 result = ContextFactory.getGlobal();
		 }
		 return result;
	 }
	 public final boolean isSealed() {
		 return sealed;
	 }
	 public final void seal(Object sealKey) {
		 if (sealed) onSealedMutation();
		 sealed = true;
		 this.sealKey = sealKey;
	 }
	 public final void unseal(Object sealKey) {
		 if (sealKey == null) throw new IllegalArgumentException();
		 if (this.sealKey != sealKey) throw new IllegalArgumentException();
		 if (!sealed) throw new IllegalStateException();
		 sealed = false;
		 this.sealKey = null;
	 }
	 static void onSealedMutation() {
		 throw new IllegalStateException();
	 }
	 public final int getLanguageVersion() {
		 return version;
	 }
	 public void setLanguageVersion(int version) {
		 if (sealed) onSealedMutation();
		 checkLanguageVersion(version);
		 Object listeners = propertyListeners;
		 if (listeners != null && version != this.version) {
			 firePropertyChangeImpl(listeners, languageVersionProperty, new Integer(this.version), new Integer(version));
		 }
		 this.version = version;
	 }
	 public static boolean isValidLanguageVersion(int version) {
		 switch (version) {
			 case VERSION_DEFAULT: case VERSION_1_0: case VERSION_1_1: case VERSION_1_2: case VERSION_1_3: case VERSION_1_4: case VERSION_1_5: case VERSION_1_6: return true;
		 }
		 return false;
	 }
	 public static void checkLanguageVersion(int version) {
		 if (isValidLanguageVersion(version)) {
			 return;
		 }
		 throw new IllegalArgumentException(""Bad language version: ""+version);
	 }
	 public final String getImplementationVersion() {
		 if (implementationVersion == null) {
			 implementationVersion = ScriptRuntime.getMessage0(""implementation.version"");
		 }
		 return implementationVersion;
	 }
	 public final ErrorReporter getErrorReporter() {
		 if (errorReporter == null) {
			 return DefaultErrorReporter.instance;
		 }
		 return errorReporter;
	 }
	 public final ErrorReporter setErrorReporter(ErrorReporter reporter) {
		 if (sealed) onSealedMutation();
		 if (reporter == null) throw new IllegalArgumentException();
		 ErrorReporter old = getErrorReporter();
		 if (reporter == old) {
			 return old;
		 }
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, errorReporterProperty, old, reporter);
		 }
		 this.errorReporter = reporter;
		 return old;
	 }
	 public final Locale getLocale() {
		 if (locale == null) locale = Locale.getDefault();
		 return locale;
	 }
	 public final Locale setLocale(Locale loc) {
		 if (sealed) onSealedMutation();
		 Locale result = locale;
		 locale = loc;
		 return result;
	 }
	 public final void addPropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.addListener(propertyListeners, l);
	 }
	 public final void removePropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.removeListener(propertyListeners, l);
	 }
	 final void firePropertyChange(String property, Object oldValue, Object newValue) {
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, property, oldValue, newValue);
		 }
	 }
	 private void firePropertyChangeImpl(Object listeners, String property, Object oldValue, Object newValue) {
		 for (int i = 0;
		 ;
		 ++i) {
			 Object l = Kit.getListener(listeners, i);
			 if (l == null) break;
			 if (l instanceof PropertyChangeListener) {
				 PropertyChangeListener pcl = (PropertyChangeListener)l;
				 pcl.propertyChange(new PropertyChangeEvent( this, property, oldValue, newValue));
			 }
		 }
	 }
	 public static void reportWarning(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = Context.getContext();
		 cx.getErrorReporter().warning(message, sourceName, lineno, lineSource, lineOffset);
	 }
	 public static void reportWarning(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportWarning(message, filename, linep[0], null, 0);
	 }
	 public static void reportError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 cx.getErrorReporter().error(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 public static void reportError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportError(message, filename, linep[0], null, 0);
	 }
	 public static EvaluatorException reportRuntimeError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 return cx.getErrorReporter(). runtimeError(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 static EvaluatorException reportRuntimeError0(String messageId) {
		 String msg = ScriptRuntime.getMessage0(messageId);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError1(String messageId, Object arg1) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg1);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError2(String messageId, Object arg1, Object arg2) {
		 String msg = ScriptRuntime.getMessage2(messageId, arg1, arg2);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError3(String messageId, Object arg1, Object arg2, Object arg3) {
		 String msg = ScriptRuntime.getMessage3(messageId, arg1, arg2, arg3);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError4(String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 String msg = ScriptRuntime.getMessage4(messageId, arg1, arg2, arg3, arg4);
		 return reportRuntimeError(msg);
	 }
	 public static EvaluatorException reportRuntimeError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 return Context.reportRuntimeError(message, filename, linep[0], null, 0);
	 }
	 public final ScriptableObject initStandardObjects() {
		 return initStandardObjects(null, false);
	 }
	 public final Scriptable initStandardObjects(ScriptableObject scope) {
		 return initStandardObjects(scope, false);
	 }
	 public ScriptableObject initStandardObjects(ScriptableObject scope, boolean sealed) {
		 return ScriptRuntime.initStandardObjects(this, scope, sealed);
	 }
	 public static Object getUndefinedValue() {
		 return Undefined.instance;
	 }
	 public final Object evaluateString(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 Script script = compileString(source, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final Object evaluateReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 Script script = compileReader(scope, in, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final boolean stringIsCompilableUnit(String source) {
		 boolean errorseen = false;
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 compilerEnv.setGeneratingSource(false);
		 Parser p = new Parser(compilerEnv, DefaultErrorReporter.instance);
		 try {
			 p.parse(source, null, 1);
		 }
		 catch (EvaluatorException ee) {
			 errorseen = true;
		 }
		 if (errorseen && p.eof()) return false;
		 else return true;
	 }
	 public final Script compileReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 return compileReader(in, sourceName, lineno, securityDomain);
	 }
	 public final Script compileReader(Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return (Script) compileImpl(null, in, null, sourceName, lineno, securityDomain, false, null, null);
	 }
	 public final Script compileString(String source, String sourceName, int lineno, Object securityDomain) {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return compileString(source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Script compileString(String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Script) compileImpl(null, null, source, sourceName, lineno, securityDomain, false, compiler, compilationErrorReporter);
		 }
		 catch (IOException ex) {
			 throw new RuntimeException();
		 }
	 }
	 public final Function compileFunction(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 return compileFunction(scope, source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Function compileFunction(Scriptable scope, String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Function) compileImpl(scope, null, source, sourceName, lineno, securityDomain, true, compiler, compilationErrorReporter);
		 }
		 catch (IOException ioe) {
			 throw new RuntimeException();
		 }
	 }
	 public final String decompileScript(Script script, int indent) {
		 NativeFunction scriptImpl = (NativeFunction) script;
		 return scriptImpl.decompile(indent, 0);
	 }
	 public final String decompileFunction(Function fun, int indent) {
		 if (fun instanceof BaseFunction) return ((BaseFunction)fun).decompile(indent, 0);
		 else return ""function "" + fun.getClassName() + ""() {
		\n\t[native code]\n}
		\n"";
	 }
	 public final String decompileFunctionBody(Function fun, int indent) {
		 if (fun instanceof BaseFunction) {
			 BaseFunction bf = (BaseFunction)fun;
			 return bf.decompile(indent, Decompiler.ONLY_BODY_FLAG);
		 }
		 return ""[native code]\n"";
	 }
	 public final Scriptable newObject(Scriptable scope) {
		 return newObject(scope, ""Object"", ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName) {
		 return newObject(scope, constructorName, ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(this, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(this, scope, args);
	 }
	 public final Scriptable newArray(Scriptable scope, int length) {
		 NativeArray result = new NativeArray(length);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Scriptable newArray(Scriptable scope, Object[] elements) {
		 if (elements.getClass().getComponentType() != ScriptRuntime.ObjectClass) throw new IllegalArgumentException();
		 NativeArray result = new NativeArray(elements);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Object[] getElements(Scriptable object) {
		 return ScriptRuntime.getArrayElements(object);
	 }
	 public static boolean toBoolean(Object value) {
		 return ScriptRuntime.toBoolean(value);
	 }
	 public static double toNumber(Object value) {
		 return ScriptRuntime.toNumber(value);
	 }
	 public static String toString(Object value) {
		 return ScriptRuntime.toString(value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope, Class staticType) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Object javaToJS(Object value, Scriptable scope) {
		 if (value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Scriptable) {
			 return value;
		 }
		 else if (value instanceof Character) {
			 return String.valueOf(((Character)value).charValue());
		 }
		 else {
			 Context cx = Context.getContext();
			 return cx.getWrapFactory().wrap(cx, scope, value, null);
		 }
	 }
	 public static Object jsToJava(Object value, Class desiredType) throws EvaluatorException {
		 return NativeJavaObject.coerceTypeImpl(desiredType, value);
	 }
	 public static Object toType(Object value, Class desiredType) throws IllegalArgumentException {
		 try {
			 return jsToJava(value, desiredType);
		 }
		 catch (EvaluatorException ex) {
			 IllegalArgumentException ex2 = new IllegalArgumentException(ex.getMessage());
			 Kit.initCause(ex2, ex);
			 throw ex2;
		 }
	 }
	 public static RuntimeException throwAsScriptRuntimeEx(Throwable e) {
		 while ((e instanceof InvocationTargetException)) {
			 e = ((InvocationTargetException) e).getTargetException();
		 }
		 if (e instanceof Error) {
			 throw (Error)e;
		 }
		 if (e instanceof RhinoException) {
			 throw (RhinoException)e;
		 }
		 throw new WrappedException(e);
	 }
	 public final boolean isGeneratingDebug() {
		 return generatingDebug;
	 }
	 public final void setGeneratingDebug(boolean generatingDebug) {
		 if (sealed) onSealedMutation();
		 generatingDebugChanged = true;
		 if (generatingDebug && getOptimizationLevel() > 0) setOptimizationLevel(0);
		 this.generatingDebug = generatingDebug;
	 }
	 public final boolean isGeneratingSource() {
		 return generatingSource;
	 }
	 public final void setGeneratingSource(boolean generatingSource) {
		 if (sealed) onSealedMutation();
		 this.generatingSource = generatingSource;
	 }
	 public final int getOptimizationLevel() {
		 return optimizationLevel;
	 }
	 public final void setOptimizationLevel(int optimizationLevel) {
		 if (sealed) onSealedMutation();
		 if (optimizationLevel == -2) {
			 optimizationLevel = -1;
		 }
		 checkOptimizationLevel(optimizationLevel);
		 if (codegenClass == null) optimizationLevel = -1;
		 this.optimizationLevel = optimizationLevel;
	 }
	 public static boolean isValidOptimizationLevel(int optimizationLevel) {
		 return -1 <= optimizationLevel && optimizationLevel <= 9;
	 }
	 public static void checkOptimizationLevel(int optimizationLevel) {
		 if (isValidOptimizationLevel(optimizationLevel)) {
			 return;
		 }
		 throw new IllegalArgumentException( ""Optimization level outside [-1..9]: ""+optimizationLevel);
	 }
	 public final void setSecurityController(SecurityController controller) {
		 if (sealed) onSealedMutation();
		 if (controller == null) throw new IllegalArgumentException();
		 if (securityController != null) {
			 throw new SecurityException(""Can not overwrite existing SecurityController object"");
		 }
		 if (SecurityController.hasGlobal()) {
			 throw new SecurityException(""Can not overwrite existing global SecurityController object"");
		 }
		 securityController = controller;
	 }
	 public final void setClassShutter(ClassShutter shutter) {
		 if (sealed) onSealedMutation();
		 if (shutter == null) throw new IllegalArgumentException();
		 if (classShutter != null) {
			 throw new SecurityException(""Cannot overwrite existing "" + ""ClassShutter object"");
		 }
		 classShutter = shutter;
	 }
	 final ClassShutter getClassShutter() {
		 return classShutter;
	 }
	 public final Object getThreadLocal(Object key) {
		 if (hashtable == null) return null;
		 return hashtable.get(key);
	 }
	 public final void putThreadLocal(Object key, Object value) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) hashtable = new Hashtable();
		 hashtable.put(key, value);
	 }
	 public final void removeThreadLocal(Object key) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) return;
		 hashtable.remove(key);
	 }
	 public final boolean hasCompileFunctionsWithDynamicScope() {
		 return compileFunctionsWithDynamicScopeFlag;
	 }
	 public final void setCompileFunctionsWithDynamicScope(boolean flag) {
		 if (sealed) onSealedMutation();
		 compileFunctionsWithDynamicScopeFlag = flag;
	 }
	 public static void setCachingEnabled(boolean cachingEnabled) {
	 }
	 public final void setWrapFactory(WrapFactory wrapFactory) {
		 if (sealed) onSealedMutation();
		 if (wrapFactory == null) throw new IllegalArgumentException();
		 this.wrapFactory = wrapFactory;
	 }
	 public final WrapFactory getWrapFactory() {
		 if (wrapFactory == null) {
			 wrapFactory = new WrapFactory();
		 }
		 return wrapFactory;
	 }
	 public final Debugger getDebugger() {
		 return debugger;
	 }
	 public final Object getDebuggerContextData() {
		 return debuggerData;
	 }
	 public final void setDebugger(Debugger debugger, Object contextData) {
		 if (sealed) onSealedMutation();
		 this.debugger = debugger;
		 debuggerData = contextData;
	 }
	 public static DebuggableScript getDebuggableView(Script script) {
		 if (script instanceof NativeFunction) {
			 return ((NativeFunction)script).getDebuggableView();
		 }
		 return null;
	 }
	 public boolean hasFeature(int featureIndex) {
		 ContextFactory f = getFactory();
		 return f.hasFeature(this, featureIndex);
	 }
	 public final int getInstructionObserverThreshold() {
		 return instructionThreshold;
	 }
	 public final void setInstructionObserverThreshold(int threshold) {
		 if (sealed) onSealedMutation();
		 if (threshold < 0) throw new IllegalArgumentException();
		 instructionThreshold = threshold;
	 }
	 protected void observeInstructionCount(int instructionCount) {
		 ContextFactory f = getFactory();
		 f.observeInstructionCount(this, instructionCount);
	 }
	 public GeneratedClassLoader createClassLoader(ClassLoader parent) {
		 ContextFactory f = getFactory();
		 return f.createClassLoader(parent);
	 }
	 public final ClassLoader getApplicationClassLoader() {
		 if (applicationClassLoader == null) {
			 ContextFactory f = getFactory();
			 ClassLoader loader = f.getApplicationClassLoader();
			 if (loader == null) {
				 ClassLoader threadLoader = VMBridge.instance.getCurrentThreadClassLoader();
				 if (threadLoader != null && Kit.testIfCanLoadRhinoClasses(threadLoader)) {
					 return threadLoader;
				 }
				 Class fClass = f.getClass();
				 if (fClass != ScriptRuntime.ContextFactoryClass) {
					 loader = fClass.getClassLoader();
				 }
				 else {
					 loader = getClass().getClassLoader();
				 }
			 }
			 applicationClassLoader = loader;
		 }
		 return applicationClassLoader;
	 }
	 public final void setApplicationClassLoader(ClassLoader loader) {
		 if (sealed) onSealedMutation();
		 if (loader == null) {
			 applicationClassLoader = null;
			 return;
		 }
		 if (!Kit.testIfCanLoadRhinoClasses(loader)) {
			 throw new IllegalArgumentException( ""Loader can not resolve Rhino classes"");
		 }
		 applicationClassLoader = loader;
	 }
	 static Context getContext() {
		 Context cx = getCurrentContext();
		 if (cx == null) {
			 throw new RuntimeException( ""No Context associated with current Thread"");
		 }
		 return cx;
	 }
	 private Object compileImpl(Scriptable scope, Reader sourceReader, String sourceString, String sourceName, int lineno, Object securityDomain, boolean returnFunction, Interpreter compiler, ErrorReporter compilationErrorReporter) throws IOException {
		 if (securityDomain != null && securityController == null) {
			 throw new IllegalArgumentException( ""securityDomain should be null if setSecurityController() was never called"");
		 }
		 if (!(sourceReader == null ^ sourceString == null)) Kit.codeBug();
		 if (!(scope == null ^ returnFunction)) Kit.codeBug();
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 if (compilationErrorReporter == null) {
			 compilationErrorReporter = compilerEnv.getErrorReporter();
		 }
		 if (debugger != null) {
			 if (sourceReader != null) {
				 sourceString = Kit.readReader(sourceReader);
				 sourceReader = null;
			 }
		 }
		 Parser p = new Parser(compilerEnv, compilationErrorReporter);
		 if (returnFunction) {
			 p.calledByCompileFunction = true;
		 }
		 ScriptOrFnNode tree;
		 if (sourceString != null) {
			 tree = p.parse(sourceString, sourceName, lineno);
		 }
		 else {
			 tree = p.parse(sourceReader, sourceName, lineno);
		 }
		 if (returnFunction) {
			 if (!(tree.getFunctionCount() == 1 && tree.getFirstChild() != null && tree.getFirstChild().getType() == Token.FUNCTION)) {
				 throw new IllegalArgumentException( ""compileFunction only accepts source with single JS function: ""+sourceString);
			 }
		 }
		 if (compiler == null) {
			 compiler = createCompiler();
		 }
		 String encodedSource = p.getEncodedSource();
		 Object bytecode = compiler.compile(compilerEnv, tree, encodedSource, returnFunction);
		 if (debugger != null) {
			 if (sourceString == null) Kit.codeBug();
			 if (bytecode instanceof DebuggableScript) {
				 DebuggableScript dscript = (DebuggableScript)bytecode;
				 notifyDebugger_r(this, dscript, sourceString);
			 }
			 else {
				 throw new RuntimeException(""NOT SUPPORTED"");
			 }
		 }
		 Object result;
		 if (returnFunction) {
			 result = compiler.createFunctionObject(this, scope, bytecode, securityDomain);
		 }
		 else {
			 result = compiler.createScriptObject(bytecode, securityDomain);
		 }
		 return result;
	 }
	 private static void notifyDebugger_r(Context cx, DebuggableScript dscript, String debugSource) {
		 cx.debugger.handleCompilationDone(cx, dscript, debugSource);
		 for (int i = 0;
		 i != dscript.getFunctionCount();
		 ++i) {
			 notifyDebugger_r(cx, dscript.getFunction(i), debugSource);
		 }
	 }
	 private static Class codegenClass = Kit.classOrNull( ""org.mozilla.javascript.optimizer.Codegen"");
	 private Interpreter createCompiler() {
		 Interpreter result = null;
		 if (optimizationLevel >= 0 && codegenClass != null) {
			 result = (Interpreter)Kit.newInstanceOrNull(codegenClass);
		 }
		 if (result == null) {
			 result = new Interpreter();
		 }
		 return result;
	 }
	 static String getSourcePositionFromStack(int[] linep) {
		 Context cx = getCurrentContext();
		 if (cx == null) return null;
		 if (cx.lastInterpreterFrame != null) {
			 return Interpreter.getSourcePositionFromStack(cx, linep);
		 }
		 CharArrayWriter writer = new CharArrayWriter();
		 RuntimeException re = new RuntimeException();
		 re.printStackTrace(new PrintWriter(writer));
		 String s = writer.toString();
		 int open = -1;
		 int close = -1;
		 int colon = -1;
		 for (int i=0;
		 i < s.length();
		 i++) {
			 char c = s.charAt(i);
			 if (c == ':') colon = i;
			 else if (c == '(') open = i;
			 else if (c == ')') close = i;
			 else if (c == '\n' && open != -1 && close != -1 && colon != -1 && open < colon && colon < close) {
				 String fileStr = s.substring(open + 1, colon);
				 if (!fileStr.endsWith("".java"")) {
					 String lineStr = s.substring(colon + 1, close);
					 try {
						 linep[0] = Integer.parseInt(lineStr);
						 if (linep[0] < 0) {
							 linep[0] = 0;
						 }
						 return fileStr;
					 }
					 catch (NumberFormatException e) {
					 }
				 }
				 open = close = colon = -1;
			 }
		 }
		 return null;
	 }
	 RegExpProxy getRegExpProxy() {
		 if (regExpProxy == null) {
			 Class cl = Kit.classOrNull( ""org.mozilla.javascript.regexp.RegExpImpl"");
			 if (cl != null) {
				 regExpProxy = (RegExpProxy)Kit.newInstanceOrNull(cl);
			 }
		 }
		 return regExpProxy;
	 }
	 final boolean isVersionECMA1() {
		 return version == VERSION_DEFAULT || version >= VERSION_1_3;
	 }
	 SecurityController getSecurityController() {
		 SecurityController global = SecurityController.global();
		 if (global != null) {
			 return global;
		 }
		 return securityController;
	 }
	 public final boolean isGeneratingDebugChanged() {
		 return generatingDebugChanged;
	 }
	 public void addActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames == null) activationNames = new Hashtable(5);
		 activationNames.put(name, name);
	 }
	 public final boolean isActivationNeeded(String name) {
		 return activationNames != null && activationNames.containsKey(name);
	 }
	 public void removeActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames != null) activationNames.remove(name);
	 }
	 private static String implementationVersion;
	 private ContextFactory factory;
	 private boolean sealed;
	 private Object sealKey;
	 Scriptable topCallScope;
	 NativeCall currentActivationCall;
	 XMLLib cachedXMLLib;
	 ObjToIntMap iterating;
	 Object interpreterSecurityDomain;
	 int version;
	 private SecurityController securityController;
	 private ClassShutter classShutter;
	 private ErrorReporter errorReporter;
	 RegExpProxy regExpProxy;
	 private Locale locale;
	 private boolean generatingDebug;
	 private boolean generatingDebugChanged;
	 private boolean generatingSource=true;
	 boolean compileFunctionsWithDynamicScopeFlag;
	 boolean useDynamicScope;
	 private int optimizationLevel;
	 private WrapFactory wrapFactory;
	 Debugger debugger;
	 private Object debuggerData;
	 private int enterCount;
	 private Object propertyListeners;
	 private Hashtable hashtable;
	 private ClassLoader applicationClassLoader;
	 private boolean creationEventWasSent;
	 Hashtable activationNames;
	 Object lastInterpreterFrame;
	 ObjArray previousInterpreterInvocations;
	 int instructionCount;
	 int instructionThreshold;
	 int scratchIndex;
	 long scratchUint32;
	 Scriptable scratchScriptable;
}",1,0,0,0
"private void handleRefresh(TreeMap<Long, String> previousImapFlagMap, TreeMap<Long, String> imapFlagMap) throws IOException {
	 int index = 1;
	 for (long previousImapUid : previousImapFlagMap.keySet()) {
		 if (!imapFlagMap.keySet().contains(previousImapUid)) {
			 sendClient(""* "" + index + "" EXPUNGE"");
		 }
		 else {
			 if (!previousImapFlagMap.get(previousImapUid).equals(imapFlagMap.get(previousImapUid))) {
				 sendClient(""* "" + index + "" FETCH (UID "" + previousImapUid + "" FLAGS ("" + imapFlagMap.get(previousImapUid) + ""))"");
			 }
			 index++;
		 }
	 }
	 sendClient(""* "" + currentFolder.count() + "" EXISTS"");
	 sendClient(""* "" + currentFolder.recent + "" RECENT"");
 }",0,0,0,0
"public class SVGConstants {
	 public final static String SVG_NAMESPACE = ""http: public final static String SVG_MIMETYPE = ""image/svg+xml"";
	 public final static Map<String,Color> SVG_COLORS;
	 static {
		 LinkedHashMap<String,Color> map = new LinkedHashMap<String,Color>();
		 map.put(""black"", new Color(0, 0, 0));
		 map.put(""green"", new Color(0, 128, 0));
		 map.put(""silver"", new Color(192, 192, 192));
		 map.put(""lime"", new Color(0, 255, 0));
		 map.put(""gray"", new Color(128, 128, 128));
		 map.put(""olive"", new Color(128, 128, 0));
		 map.put(""white"", new Color(255, 255, 255));
		 map.put(""yellow"", new Color(255, 255, 0));
		 map.put(""maroon"", new Color(128, 0, 0));
		 map.put(""navy"", new Color(0, 0, 128));
		 map.put(""red"", new Color(255, 0, 0));
		 map.put(""blue"", new Color(0, 0, 255));
		 map.put(""purple"", new Color(128, 0, 128));
		 map.put(""teal"", new Color(0, 128, 128));
		 map.put(""fuchsia"", new Color(255, 0, 255));
		 map.put(""aqua"", new Color(0, 255, 255));
		 map.put(""aliceblue"", new Color(240, 248, 255));
		 map.put(""antiquewhite"", new Color(250, 235, 215));
		 map.put(""aqua"", new Color( 0, 255, 255));
		 map.put(""aquamarine"", new Color(127, 255, 212));
		 map.put(""azure"", new Color(240, 255, 255));
		 map.put(""beige"", new Color(245, 245, 220));
		 map.put(""bisque"", new Color(255, 228, 196));
		 map.put(""black"", new Color( 0, 0, 0));
		 map.put(""blanchedalmond"", new Color(255, 235, 205));
		 map.put(""blue"", new Color( 0, 0, 255));
		 map.put(""blueviolet"", new Color(138, 43, 226));
		 map.put(""brown"", new Color(165, 42, 42));
		 map.put(""burlywood"", new Color(222, 184, 135));
		 map.put(""cadetblue"", new Color( 95, 158, 160));
		 map.put(""chartreuse"", new Color(127, 255, 0));
		 map.put(""chocolate"", new Color(210, 105, 30));
		 map.put(""coral"", new Color(255, 127, 80));
		 map.put(""cornflowerblue"", new Color(100, 149, 237));
		 map.put(""cornsilk"", new Color(255, 248, 220));
		 map.put(""crimson"", new Color(220, 20, 60));
		 map.put(""cyan"", new Color( 0, 255, 255));
		 map.put(""darkblue"", new Color( 0, 0, 139));
		 map.put(""darkcyan"", new Color( 0, 139, 139));
		 map.put(""darkgoldenrod"", new Color(184, 134, 11));
		 map.put(""darkgray"", new Color(169, 169, 169));
		 map.put(""darkgreen"", new Color( 0, 100, 0));
		 map.put(""darkgrey"", new Color(169, 169, 169));
		 map.put(""darkkhaki"", new Color(189, 183, 107));
		 map.put(""darkmagenta"", new Color(139, 0, 139));
		 map.put(""darkolivegreen"", new Color( 85, 107, 47));
		 map.put(""darkorange"", new Color(255, 140, 0));
		 map.put(""darkorchid"", new Color(153, 50, 204));
		 map.put(""darkred"", new Color(139, 0, 0));
		 map.put(""darksalmon"", new Color(233, 150, 122));
		 map.put(""darkseagreen"", new Color(143, 188, 143));
		 map.put(""darkslateblue"", new Color( 72, 61, 139));
		 map.put(""darkslategray"", new Color( 47, 79, 79));
		 map.put(""darkslategrey"", new Color( 47, 79, 79));
		 map.put(""darkturquoise"", new Color( 0, 206, 209));
		 map.put(""darkviolet"", new Color(148, 0, 211));
		 map.put(""deeppink"", new Color(255, 20, 147));
		 map.put(""deepskyblue"", new Color( 0, 191, 255));
		 map.put(""dimgray"", new Color(105, 105, 105));
		 map.put(""dimgrey"", new Color(105, 105, 105));
		 map.put(""dodgerblue"", new Color( 30, 144, 255));
		 map.put(""firebrick"", new Color(178, 34, 34));
		 map.put(""floralwhite"", new Color(255, 250, 240));
		 map.put(""forestgreen"", new Color( 34, 139, 34));
		 map.put(""fuchsia"", new Color(255, 0, 255));
		 map.put(""gainsboro"", new Color(220, 220, 220));
		 map.put(""ghostwhite"", new Color(248, 248, 255));
		 map.put(""gold"", new Color(255, 215, 0));
		 map.put(""goldenrod"", new Color(218, 165, 32));
		 map.put(""gray"", new Color(128, 128, 128));
		 map.put(""grey"", new Color(128, 128, 128));
		 map.put(""green"", new Color( 0, 128, 0));
		 map.put(""greenyellow"", new Color(173, 255, 47));
		 map.put(""honeydew"", new Color(240, 255, 240));
		 map.put(""hotpink"", new Color(255, 105, 180));
		 map.put(""indianred"", new Color(205, 92, 92));
		 map.put(""indigo"", new Color( 75, 0, 130));
		 map.put(""ivory"", new Color(255, 255, 240));
		 map.put(""khaki"", new Color(240, 230, 140));
		 map.put(""lavender"", new Color(230, 230, 250));
		 map.put(""lavenderblush"", new Color(255, 240, 245));
		 map.put(""lawngreen"", new Color(124, 252, 0));
		 map.put(""lemonchiffon"", new Color(255, 250, 205));
		 map.put(""lightblue"", new Color(173, 216, 230));
		 map.put(""lightcoral"", new Color(240, 128, 128));
		 map.put(""lightcyan"", new Color(224, 255, 255));
		 map.put(""lightgoldenrodyellow"", new Color(250, 250, 210));
		 map.put(""lightgray"", new Color(211, 211, 211));
		 map.put(""lightgreen"", new Color(144, 238, 144));
		 map.put(""lightgrey"", new Color(211, 211, 211));
		 map.put(""lightpink"", new Color(255, 182, 193));
		 map.put(""lightsalmon"", new Color(255, 160, 122));
		 map.put(""lightseagreen"", new Color( 32, 178, 170));
		 map.put(""lightskyblue"", new Color(135, 206, 250));
		 map.put(""lightslategray"", new Color(119, 136, 153));
		 map.put(""lightslategrey"", new Color(119, 136, 153));
		 map.put(""lightsteelblue"", new Color(176, 196, 222));
		 map.put(""lightyellow"", new Color(255, 255, 224));
		 map.put(""lime"", new Color( 0, 255, 0));
		 map.put(""limegreen"", new Color( 50, 205, 50));
		 map.put(""linen"", new Color(250, 240, 230));
		 map.put(""magenta"", new Color(255, 0, 255));
		 map.put(""maroon"", new Color(128, 0, 0));
		 map.put(""mediumaquamarine"", new Color(102, 205, 170));
		 map.put(""mediumblue"", new Color( 0, 0, 205));
		 map.put(""mediumorchid"", new Color(186, 85, 211));
		 map.put(""mediumpurple"", new Color(147, 112, 219));
		 map.put(""mediumseagreen"", new Color( 60, 179, 113));
		 map.put(""mediumslateblue"", new Color(123, 104, 238));
		 map.put(""mediumspringgreen"", new Color( 0, 250, 154));
		 map.put(""mediumturquoise"", new Color( 72, 209, 204));
		 map.put(""mediumvioletred"", new Color(199, 21, 133));
		 map.put(""midnightblue"", new Color( 25, 25, 112));
		 map.put(""mintcream"", new Color(245, 255, 250));
		 map.put(""mistyrose"", new Color(255, 228, 225));
		 map.put(""moccasin"", new Color(255, 228, 181));
		 map.put(""navajowhite"", new Color(255, 222, 173));
		 map.put(""navy"", new Color( 0, 0, 128));
		 map.put(""oldlace"", new Color(253, 245, 230));
		 map.put(""olive"", new Color(128, 128, 0));
		 map.put(""olivedrab"", new Color(107, 142, 35));
		 map.put(""orange"", new Color(255, 165, 0));
		 map.put(""orangered"", new Color(255, 69, 0));
		 map.put(""orchid"", new Color(218, 112, 214));
		 map.put(""palegoldenrod"", new Color(238, 232, 170));
		 map.put(""palegreen"", new Color(152, 251, 152));
		 map.put(""paleturquoise"", new Color(175, 238, 238));
		 map.put(""palevioletred"", new Color(219, 112, 147));
		 map.put(""papayawhip"", new Color(255, 239, 213));
		 map.put(""peachpuff"", new Color(255, 218, 185));
		 map.put(""peru"", new Color(205, 133, 63));
		 map.put(""pink"", new Color(255, 192, 203));
		 map.put(""plum"", new Color(221, 160, 221));
		 map.put(""powderblue"", new Color(176, 224, 230));
		 map.put(""purple"", new Color(128, 0, 128));
		 map.put(""red"", new Color(255, 0, 0));
		 map.put(""rosybrown"", new Color(188, 143, 143));
		 map.put(""royalblue"", new Color( 65, 105, 225));
		 map.put(""saddlebrown"", new Color(139, 69, 19));
		 map.put(""salmon"", new Color(250, 128, 114));
		 map.put(""sandybrown"", new Color(244, 164, 96));
		 map.put(""seagreen"", new Color( 46, 139, 87));
		 map.put(""seashell"", new Color(255, 245, 238));
		 map.put(""sienna"", new Color(160, 82, 45));
		 map.put(""silver"", new Color(192, 192, 192));
		 map.put(""skyblue"", new Color(135, 206, 235));
		 map.put(""slateblue"", new Color(106, 90, 205));
		 map.put(""slategray"", new Color(112, 128, 144));
		 map.put(""slategrey"", new Color(112, 128, 144));
		 map.put(""snow"", new Color(255, 250, 250));
		 map.put(""springgreen"", new Color( 0, 255, 127));
		 map.put(""steelblue"", new Color( 70, 130, 180));
		 map.put(""tan"", new Color(210, 180, 140));
		 map.put(""teal"", new Color( 0, 128, 128));
		 map.put(""thistle"", new Color(216, 191, 216));
		 map.put(""tomato"", new Color(255, 99, 71));
		 map.put(""turquoise"", new Color( 64, 224, 208));
		 map.put(""violet"", new Color(238, 130, 238));
		 map.put(""wheat"", new Color(245, 222, 179));
		 map.put(""white"", new Color(255, 255, 255));
		 map.put(""whitesmoke"", new Color(245, 245, 245));
		 map.put(""yellow"", new Color(255, 255, 0));
		 map.put(""yellowgreen"", new Color(154, 205, 50));
		 map.put(""activeborder"", UIManager.getColor(""activeCaptionBorder""));
		 map.put(""activecaption"", UIManager.getColor(""activeCaption""));
		 map.put(""appworkspace"", UIManager.getColor(""window""));
		 map.put(""background"", UIManager.getColor(""desktop""));
		 map.put(""buttonface"", UIManager.getColor(""control""));
		 map.put(""buttonhighlight"", UIManager.getColor(""controlHighlight""));
		 map.put(""buttonshadow"", UIManager.getColor(""controlShadow""));
		 map.put(""buttontext"", UIManager.getColor(""controlText""));
		 map.put(""captiontext"", UIManager.getColor(""activeCaptionText""));
		 map.put(""graytext"", UIManager.getColor(""textInactiveText""));
		 map.put(""highlight"", UIManager.getColor(""textHighlight""));
		 map.put(""highlighttext"", UIManager.getColor(""textHighlightText""));
		 map.put(""inactiveborder"", UIManager.getColor(""inactiveCaptionBorder""));
		 map.put(""inactivecaption"", UIManager.getColor(""inactiveCaption""));
		 map.put(""inactivecaptiontext"", UIManager.getColor(""inactiveCaptionText""));
		 map.put(""infobackground"", UIManager.getColor(""info""));
		 map.put(""infotext"", UIManager.getColor(""infoText""));
		 map.put(""menu"", UIManager.getColor(""menu""));
		 map.put(""menutext"", UIManager.getColor(""menuText""));
		 map.put(""scrollbar"", UIManager.getColor(""scrollbar""));
		 map.put(""threeddarkshadow"", UIManager.getColor(""controlDkShadow""));
		 map.put(""threedface"", UIManager.getColor(""control""));
		 map.put(""threedhighlight"", UIManager.getColor(""controlHighlight""));
		 map.put(""threedlightshadow"", UIManager.getColor(""controlLtHighlight""));
		 map.put(""threedshadow"", UIManager.getColor(""controlShadow""));
		 map.put(""window"", UIManager.getColor(""window""));
		 map.put(""windowframe"", UIManager.getColor(""windowBorder""));
		 map.put(""windowtext"", UIManager.getColor(""windowText""));
		 SVG_COLORS = Collections.unmodifiableMap(map);
	 }
	 public final static Map<String,WindingRule> SVG_FILL_RULES;
	 static {
		 HashMap<String, WindingRule> m = new HashMap<String, WindingRule>();
		 m.put(""nonzero"", WindingRule.NON_ZERO);
		 m.put(""evenodd"", WindingRule.EVEN_ODD);
		 SVG_FILL_RULES = Collections.unmodifiableMap(m);
	 }
	 public final static Map<String,Integer> SVG_STROKE_LINECAPS;
	 static {
		 HashMap<String, Integer> m = new HashMap<String, Integer>();
		 m.put(""butt"", BasicStroke.CAP_BUTT);
		 m.put(""round"", BasicStroke.CAP_ROUND);
		 m.put(""square"", BasicStroke.CAP_SQUARE);
		 SVG_STROKE_LINECAPS = Collections.unmodifiableMap(m);
	 }
	 public final static Map<String,Integer> SVG_STROKE_LINEJOINS;
	 static {
		 HashMap<String, Integer> m = new HashMap<String, Integer>();
		 m.put(""miter"", BasicStroke.JOIN_MITER);
		 m.put(""round"", BasicStroke.JOIN_ROUND);
		 m.put(""bevel"", BasicStroke.JOIN_BEVEL);
		 SVG_STROKE_LINEJOINS = Collections.unmodifiableMap(m);
	 }
	 public final static Map<String,Double> SVG_ABSOLUTE_FONT_SIZES;
	 static {
		 HashMap<String,Double> m = new HashMap<String,Double>();
		 m.put(""xx-small"",6.944444);
		 m.put(""x-small"",8.3333333);
		 m.put(""small"", 10d);
		 m.put(""medium"", 12d);
		 m.put(""large"", 14.4);
		 m.put(""x-large"", 17.28);
		 m.put(""xx-large"",20.736);
		 SVG_ABSOLUTE_FONT_SIZES = Collections.unmodifiableMap(m);
	 }
	 public final static Map<String,Double> SVG_RELATIVE_FONT_SIZES;
	 static {
		 HashMap<String,Double> m = new HashMap<String,Double>();
		 m.put(""larger"", 1.2);
		 m.put(""smaller"",0.83333333);
		 SVG_RELATIVE_FONT_SIZES = Collections.unmodifiableMap(m);
	 }
	 public final static Map<String,TextAnchor> SVG_TEXT_ANCHORS;
	 static {
		 HashMap<String, TextAnchor> m = new HashMap<String, TextAnchor>();
		 m.put(""start"", TextAnchor.START);
		 m.put(""middle"", TextAnchor.MIDDLE);
		 m.put(""end"", TextAnchor.END);
		 SVG_TEXT_ANCHORS = Collections.unmodifiableMap(m);
	 }
	 public final static Map<String,TextAlign> SVG_TEXT_ALIGNS;
	 static {
		 HashMap<String, TextAlign> m = new HashMap<String, TextAlign>();
		 m.put(""start"", TextAlign.START);
		 m.put(""center"", TextAlign.CENTER);
		 m.put(""end"", TextAlign.END);
		 SVG_TEXT_ALIGNS = Collections.unmodifiableMap(m);
	 }
	 private SVGConstants() {
	 }
}",0,0,0,0
"public void setOnetable(boolean oneTable) {
	 optionalAttrs.put(ONE_TABLE, oneTable ? Boolean.TRUE : Boolean.FALSE);
 }",0,0,0,0
"public final void setRowsPerPage(int rowsPerPage){
	if (rowsPerPage < 0){
		rowsPerPage = 0;
	}
	addStateChange(new RowsPerPageChange(this.rowsPerPage));
	this.rowsPerPage = rowsPerPage;
}",0,0,0,0
"public static class Split extends BaseFunction {
	 public void execute(TridentTuple tuple, TridentCollector collector) {
		 String sentence = tuple.getString(0);
		 for (String word : sentence.split("" "")) {
			 collector.emit(new Values(word));
		 }
	 }
 }",0,0,0,0
public int length();,0,0,0,0
"private void updateStatus() {
	try {
		long now = System.currentTimeMillis();
		if (converting) {
			progress = this.convertPrg;
		}
		 else if (assembling) {
			long len = length > 0 ? length : downloaded;
			progress = (int) ((totalAssembled * 100) / len);
		}
		 else {
			long downloaded2 = 0;
			if (length > 0) {
				if (segDet == null) {
					segDet = new SegmentDetails();
				}
				if (segDet.getCapacity() < chunks.size()) {
					segDet.extend(chunks.size() - segDet.getCapacity());
				}
				segDet.setChunkCount(chunks.size());
			}
			downloadSpeed = 0;
			for (int i = 0;
			 i < chunks.size();
			 i++) {
				Segment s = chunks.get(i);
				downloaded2 += s.getDownloaded();
				if (length > 0) {
					long off = 0;
					if (s.getTag().equals(""T2"")) {
						off = len1;
					}
					SegmentInfo info = segDet.getChunkUpdates().get(i);
					info.setDownloaded(s.getDownloaded());
					info.setStart(s.getStartOffset() + off);
					info.setLength(s.getLength());
				}
				downloadSpeed += s.getTransferRate();
			}
			this.downloaded = downloaded2;
			this.downloaded = downloaded2;
			if (length > 0) {
				progress = (int) ((downloaded * 100) / length);
				long diff = downloaded - lastDownloaded;
				long timeSpend = now - prevTime;
				if (timeSpend > 0) {
					float rate = ((float) diff / timeSpend) * 1000;
					if (rate > downloadSpeed) {
						downloadSpeed = rate;
					}
					this.eta = FormatUtilities.getETA(length - downloaded, rate);
					if (this.eta == null) {
						this.eta = ""---"";
					}
					lastDownloaded = downloaded;
					prevTime = now;
				}
			}
		}
		listener.downloadUpdated(id);
	}
	 catch (Exception e) {
		Logger.log(e);
	}
}",0,0,1,0
"public void addConfigured(ResourceCollection a) {
	 checkChildrenAllowed();
	 if (a.size() != 1) {
		 throw new BuildException(""only single argument resource collections"" + "" are supported as archives"");
	 }
	 setSrcResource((Resource) a.iterator().next());
 }",0,0,0,0
"public class DevPollSelectorProvider extends SelectorProviderImpl{
	 public AbstractSelector openSelector() throws IOException {
		 return new DevPollSelectorImpl(this);
	 }
	 public Channel inheritedChannel() throws IOException {
		 return InheritedChannel.getChannel();
	 }
}",0,0,0,0
"protected void setInternalToLabel(final String toLabel) {
	 this.toLabel = toLabel;
 }",0,0,0,0
"public class OntPropertyImpl extends OntResourceImpl implements OntProperty{
	 public static Implementation factory = new Implementation() {
		 public EnhNode wrap( Node n, EnhGraph eg ) {
			 if (canWrap( n, eg )) {
				 return new OntPropertyImpl( n, eg );
			 }
			 else {
				 throw new ConversionException( ""Cannot convert node "" + n + "" to OntProperty"");
			 }
		 }
		 public boolean canWrap( Node node, EnhGraph eg ) {
			 Profile profile = (eg instanceof OntModel) ? ((OntModel) eg).getProfile() : null;
			 return (profile != null) && profile.isSupported( node, eg, OntProperty.class );
		 }
	 }
	;
	 public OntPropertyImpl( Node n, EnhGraph g ) {
		 super( n, g );
	 }
	 public boolean isProperty() {
		 return true;
	 }
	 public int getOrdinal() {
		 return (as( Property.class )).getOrdinal();
	 }
	 public void setSuperProperty( Property prop ) {
		 setPropertyValue( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"", prop );
	 }
	 public void addSuperProperty( Property prop ) {
		 addPropertyValue( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"", prop );
	 }
	 public OntProperty getSuperProperty() {
		 return objectAsProperty( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"" );
	 }
	 public ExtendedIterator<OntProperty> listSuperProperties() {
		 return listSuperProperties( false );
	 }
	 public ExtendedIterator<OntProperty> listSuperProperties( boolean direct ) {
		 OntProperty op = this;
		 return listDirectPropertyValues( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"", OntProperty.class, getProfile().SUB_PROPERTY_OF(), direct, false ) .filterDrop(op::equals);
	 }
	 public boolean hasSuperProperty( Property prop, boolean direct ) {
		 return hasPropertyValue( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"", prop );
	 }
	 public void removeSuperProperty( Property prop ) {
		 removePropertyValue( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"", prop );
	 }
	 public void setSubProperty( Property prop ) {
		 checkProfile( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"" );
		 for (StmtIterator i = getModel().listStatements( null, getProfile().SUB_PROPERTY_OF(), this );
		 i.hasNext();
		 ) {
			 i.removeNext();
		 }
		 prop.as( OntProperty.class ).addSuperProperty( this );
	 }
	 public void addSubProperty( Property prop ) {
		 prop.as( OntProperty.class ).addSuperProperty( this );
	 }
	 public OntProperty getSubProperty() {
		 checkProfile( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"" );
		 return getModel().listStatements( null, getProfile().SUB_PROPERTY_OF(), this ) .nextStatement() .getSubject() .as( OntProperty.class );
	 }
	 public ExtendedIterator<OntProperty> listSubProperties() {
		 return listSubProperties( false );
	 }
	 public ExtendedIterator<OntProperty> listSubProperties( boolean direct ) {
		 return listDirectPropertyValues( getProfile().SUB_PROPERTY_OF(), ""SUB_PROPERTY_OF"", OntProperty.class, getProfile().SUB_PROPERTY_OF(), direct, true );
	 }
	 public boolean hasSubProperty( Property prop, boolean direct ) {
		 return prop.as( OntProperty.class ).hasSuperProperty( this, direct );
	 }
	 public void removeSubProperty( Property prop ) {
		 prop.as( OntProperty.class ).removeSuperProperty( this );
	 }
	 public void setDomain( Resource res ) {
		 setPropertyValue( getProfile().DOMAIN(), ""DOMAIN"", res );
	 }
	 public void addDomain( Resource res ) {
		 addPropertyValue( getProfile().DOMAIN(), ""DOMAIN"", res );
	 }
	 public OntResource getDomain() {
		 return objectAsResource( getProfile().DOMAIN(), ""DOMAIN"" );
	 }
	 public ExtendedIterator<OntClass> listDomain() {
		 return listAs( getProfile().DOMAIN(), ""DOMAIN"", OntClass.class );
	 }
	 public boolean hasDomain( Resource res ) {
		 return hasPropertyValue( getProfile().DOMAIN(), ""DOMAIN"", res );
	 }
	 public void removeDomain( Resource cls ) {
		 removePropertyValue( getProfile().DOMAIN(), ""DOMAIN"", cls );
	 }
	 public void setRange( Resource res ) {
		 setPropertyValue( getProfile().RANGE(), ""RANGE"", res );
	 }
	 public void addRange( Resource res ) {
		 addPropertyValue( getProfile().RANGE(), ""RANGE"", res );
	 }
	 public OntResource getRange() {
		 return objectAsResource( getProfile().RANGE(), ""RANGE"" );
	 }
	 public ExtendedIterator<OntClass> listRange() {
		 return listAs( getProfile().RANGE(), ""RANGE"", OntClass.class );
	 }
	 public boolean hasRange( Resource res ) {
		 return hasPropertyValue( getProfile().RANGE(), ""RANGE"", res );
	 }
	 public void removeRange( Resource cls ) {
		 removePropertyValue( getProfile().RANGE(), ""RANGE"", cls );
	 }
	 public void setEquivalentProperty( Property prop ) {
		 setPropertyValue( getProfile().EQUIVALENT_PROPERTY(), ""EQUIVALENT_PROPERTY"", prop );
	 }
	 public void addEquivalentProperty( Property prop ) {
		 addPropertyValue( getProfile().EQUIVALENT_PROPERTY(), ""EQUIVALENT_PROPERTY"", prop );
	 }
	 public OntProperty getEquivalentProperty() {
		 return objectAsProperty( getProfile().EQUIVALENT_PROPERTY(), ""EQUIVALENT_PROPERTY"" );
	 }
	 public ExtendedIterator<OntProperty> listEquivalentProperties() {
		 return listAs( getProfile().EQUIVALENT_PROPERTY(), ""EQUIVALENT_PROPERTY"", OntProperty.class );
	 }
	 public boolean hasEquivalentProperty( Property prop ) {
		 return hasPropertyValue( getProfile().EQUIVALENT_PROPERTY(), ""EQUIVALENT_PROPERTY"", prop );
	 }
	 public void removeEquivalentProperty( Property prop ) {
		 removePropertyValue( getProfile().EQUIVALENT_PROPERTY(), ""EQUIVALENT_PROPERTY"", prop );
	 }
	 public void setInverseOf( Property prop ) {
		 setPropertyValue( getProfile().INVERSE_OF(), ""INVERSE_OF"", prop );
	 }
	 public void addInverseOf( Property prop ) {
		 addPropertyValue( getProfile().INVERSE_OF(), ""INVERSE_OF"", prop );
	 }
	 public OntProperty getInverseOf() {
		 return objectAsProperty( getProfile().INVERSE_OF(), ""INVERSE_OF"" );
	 }
	 public ExtendedIterator<? extends OntProperty> listInverseOf() {
		 return listAs( getProfile().INVERSE_OF(), ""INVERSE_OF"", OntProperty.class );
	 }
	 public boolean isInverseOf( Property prop ) {
		 return hasPropertyValue( getProfile().INVERSE_OF(), ""INVERSE_OF"", prop );
	 }
	 public void removeInverseProperty( Property prop ) {
		 removePropertyValue( getProfile().INVERSE_OF(), ""INVERSE_OF"", prop );
	 }
	 public FunctionalProperty asFunctionalProperty() {
		 return as( FunctionalProperty.class );
	 }
	 public DatatypeProperty asDatatypeProperty() {
		 return as( DatatypeProperty.class );
	 }
	 public ObjectProperty asObjectProperty() {
		 return as( ObjectProperty.class );
	 }
	 public TransitiveProperty asTransitiveProperty() {
		 return as( TransitiveProperty.class );
	 }
	 public InverseFunctionalProperty asInverseFunctionalProperty() {
		 return as( InverseFunctionalProperty.class );
	 }
	 public SymmetricProperty asSymmetricProperty() {
		 return as( SymmetricProperty.class );
	 }
	 public FunctionalProperty convertToFunctionalProperty() {
		 return convertToType( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"", FunctionalProperty.class );
	 }
	 public DatatypeProperty convertToDatatypeProperty() {
		 return convertToType( getProfile().DATATYPE_PROPERTY(), ""DATATYPE_PROPERTY"", DatatypeProperty.class );
	 }
	 public ObjectProperty convertToObjectProperty() {
		 return convertToType( getProfile().OBJECT_PROPERTY(), ""OBJECT_PROPERTY"", ObjectProperty.class );
	 }
	 public TransitiveProperty convertToTransitiveProperty() {
		 return convertToType( getProfile().TRANSITIVE_PROPERTY(), ""TRANSITIVE_PROPERTY"", TransitiveProperty.class );
	 }
	 public InverseFunctionalProperty convertToInverseFunctionalProperty() {
		 return convertToType( getProfile().INVERSE_FUNCTIONAL_PROPERTY(), ""INVERSE_FUNCTIONAL_PROPERTY"", InverseFunctionalProperty.class );
	 }
	 public SymmetricProperty convertToSymmetricProperty() {
		 return convertToType( getProfile().SYMMETRIC_PROPERTY(), ""SYMMETRIC_PROPERTY"", SymmetricProperty.class );
	 }
	 public boolean isFunctionalProperty() {
		 return hasRDFType( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"", false );
	 }
	 public boolean isDatatypeProperty() {
		 return hasRDFType( getProfile().DATATYPE_PROPERTY(), ""DATATYPE_PROPERTY"", false );
	 }
	 public boolean isObjectProperty() {
		 return hasRDFType( getProfile().OBJECT_PROPERTY(), ""OBJECT_PROPERTY"", false );
	 }
	 public boolean isTransitiveProperty() {
		 return hasRDFType( getProfile().TRANSITIVE_PROPERTY(), ""TRANSITIVE_PROPERTY"", false );
	 }
	 public boolean isInverseFunctionalProperty() {
		 return hasRDFType( getProfile().INVERSE_FUNCTIONAL_PROPERTY(), ""INVERSE_FUNCTIONAL_PROPERTY"", false );
	 }
	 public boolean isSymmetricProperty() {
		 return hasRDFType( getProfile().SYMMETRIC_PROPERTY(), ""SYMMETRIC_PROPERTY"", false );
	 }
	 public OntProperty getInverse() {
		 ExtendedIterator<OntProperty> i = listInverse();
		 OntProperty p = i.hasNext() ? i.next() : null;
		 i.close();
		 return p;
	 }
	 public ExtendedIterator<OntProperty> listInverse() {
		 return getModel().listStatements( null, getProfile().INVERSE_OF(), this ).mapWith( s -> s.getSubject().as( OntProperty.class ) );
	 }
	 public boolean hasInverse() {
		 ExtendedIterator<OntProperty> i = listInverse();
		 boolean hasInv = i.hasNext();
		 i.close();
		 return hasInv;
	 }
	 public ExtendedIterator<OntClass> listDeclaringClasses() {
		 return listDeclaringClasses( false );
	 }
	 public ExtendedIterator<OntClass> listDeclaringClasses( boolean direct ) {
		 Set<OntClass> cands = new HashSet<>();
		 for (Iterator<OntClass> i = listDomain();
		 i.hasNext();
		 ) {
			 List<OntClass> q = new ArrayList<>();
			 q.add( i.next() );
			 while (!q.isEmpty()) {
				 OntClass c = q.remove( 0 );
				 if (!c.isOntLanguageTerm() && !cands.contains( c )) {
					 cands.add( c );
					 for (Iterator<OntClass> j = c.listSubClasses();
					 j.hasNext();
					 ) {
						 q.add( j.next() );
					 }
				 }
			 }
		 }
		 if (cands.isEmpty()) {
			 if (!direct) {
				 return ((OntModel) getModel()).listClasses() .filterDrop( OntClass::isOntLanguageTerm );
			 }
			 else {
				 return ((OntModel) getModel()).listHierarchyRootClasses();
			 }
		 }
		 else {
			 return WrappedIterator.create( cands.iterator() ) .filterKeep( new FilterDeclaringClass( this, direct ));
		 }
	 }
	 public ExtendedIterator<Restriction> listReferringRestrictions() {
		 return getModel().listStatements( null, getProfile().ON_PROPERTY(), this ) .mapWith( s -> s.getSubject().as( Restriction.class ) );
	 }
	 public Property inModel( Model m ) {
		 return (getModel() == m) ? this : m.createProperty( getURI() );
	 }
	 private class FilterDeclaringClass implements Predicate<OntClass> {
		 private boolean m_direct;
		 private Property m_prop;
		 private FilterDeclaringClass( Property prop, boolean direct ) {
			 m_prop = prop;
			 m_direct = direct;
		 }
		 public boolean test( OntClass o ) {
			 return o.hasDeclaredProperty( m_prop, m_direct );
		 }
	 }
}",1,0,0,0
"public class DoubleGroupByResultHolder implements GroupByResultHolder {
	 private final int _maxCapacity;
	 private final double _defaultValue;
	 private int _resultHolderCapacity;
	 private double[] _resultArray;
	 public DoubleGroupByResultHolder(int initialCapacity, int maxCapacity, double defaultValue) {
		 _maxCapacity = maxCapacity;
		 _defaultValue = defaultValue;
		 _resultHolderCapacity = initialCapacity;
		 _resultArray = new double[initialCapacity];
		 if (defaultValue != 0.0) {
			 Arrays.fill(_resultArray, defaultValue);
		 }
	 }
	 public void ensureCapacity(int capacity) {
		 Preconditions.checkArgument(capacity <= _maxCapacity);
		 if (capacity > _resultHolderCapacity) {
			 int copyLength = _resultHolderCapacity;
			 _resultHolderCapacity = Math.max(_resultHolderCapacity * 2, capacity);
			 _resultHolderCapacity = Math.min(_resultHolderCapacity, _maxCapacity);
			 double[] current = _resultArray;
			 _resultArray = new double[_resultHolderCapacity];
			 System.arraycopy(current, 0, _resultArray, 0, copyLength);
			 if (_defaultValue != 0.0) {
				 Arrays.fill(_resultArray, copyLength, _resultHolderCapacity, _defaultValue);
			 }
		 }
	 }
	 public double getDoubleResult(int groupKey) {
		 if (groupKey == GroupKeyGenerator.INVALID_ID) {
			 return _defaultValue;
		 }
		 else {
			 return _resultArray[groupKey];
		 }
	 }
	 public <T> T getResult(int groupKey) {
		 throw new UnsupportedOperationException();
	 }
	 public void setValueForKey(int groupKey, double newValue) {
		 if (groupKey != GroupKeyGenerator.INVALID_ID) {
			 _resultArray[groupKey] = newValue;
		 }
	 }
	 public void setValueForKey(int groupKey, Object newValue) {
		 throw new UnsupportedOperationException();
	 }
}",0,0,0,0
"public void log(final int level, final Object obj1, final Object obj2, final Object obj3, final Object obj4, final Object obj5, final Object obj6, final Throwable exception);",0,0,0,1
"public class AntStarTeamCheckOut extends org.apache.tools.ant.Task {
	 static public final String DEFAULT_FORCESETTING = ""false"";
	 static public final String DEFAULT_VERBOSESETTING = ""false"";
	 static public final String DEFAULT_RECURSIONSETTING = ""true"";
	 static public final String DEFAULT_INCLUDESETTING = ""*"";
	 static public final String DEFAULT_EXCLUDESETTING = null;
	 static public final String DEFAULT_FOLDERSETTING = null;
	 private Folder prevFolder = null;
	 private int checkedOut;
	 private String serverName = null;
	 private String serverPort = null;
	 private String projectName = null;
	 private String folderName = DEFAULT_FOLDERSETTING;
	 private String viewName = null;
	 private String username = null;
	 private String password = null;
	 private String targetFolder = null;
	 private String force = DEFAULT_FORCESETTING;
	 private String verbose = DEFAULT_VERBOSESETTING;
	 private String recursion = DEFAULT_RECURSIONSETTING;
	 private String includes = DEFAULT_INCLUDESETTING;
	 private String excludes = DEFAULT_EXCLUDESETTING;
	 private String delim = Platform.getFilePathDelim();
	 public void execute() throws BuildException {
		 if ( getServerName() == null ) {
			 project.log(""ServerName must not be null."");
			 return;
		 }
		 if ( getServerPort() == null ) {
			 project.log(""ServerPort must not be null."");
			 return;
		 }
		 if ( getProjectName() == null ) {
			 project.log(""ProjectName must not be null."");
			 return;
		 }
		 if ( getViewName() == null ) {
			 project.log(""ViewName must not be null."");
			 return;
		 }
		 if ( getUsername() == null ) {
			 project.log(""Username must not be null."");
			 return;
		 }
		 if ( getPassword() == null ) {
			 project.log(""Password must not be null."");
			 return;
		 }
		 if ( getTargetFolder() == null ) {
			 project.log(""TargetFolder must not be null."");
			 return;
		 }
		 if (null != getTargetFolder()) {
			 if ((getTargetFolder().endsWith(""/"") || getTargetFolder().endsWith(""\\"")) && getTargetFolder().length() > 1) {
				 setTargetFolder(getTargetFolder().substring(0, getTargetFolder().length() - 1));
			 }
		 }
		 if ( null != getFolderName() ) {
			 if ((getFolderName().endsWith(""/"") || getFolderName().endsWith(""\\"")) && getFolderName().length() > 1) {
				 setFolderName(getFolderName().substring(0, getFolderName().length() - 1));
			 }
		 }
		 java.io.File dirExist = new java.io.File(getTargetFolder());
		 if (dirExist.isDirectory() && !getForceAsBoolean()) {
			 project.log( ""Target directory exists. Set \""force\"" to \""true\"" "" + ""to continue anyway."" );
			 return;
		 }
		 try {
			 Server s = getServer();
			 runServer(s);
			 s.disconnect();
			 project.log(checkedOut + "" files checked out."");
		 }
		 catch (Throwable e) {
			 project.log("" "" + e.getMessage());
		 }
	 }
	 protected Server getServer() {
		 Server s = new Server(getServerName(), getServerPortAsInt());
		 s.connect();
		 s.logOn(getUsername(), getPassword());
		 return s;
	 }
	 protected void runServer(Server s) {
		 com.starbase.starteam.Project[] projects = s.getProjects();
		 for (int i = 0;
		 i < projects.length;
		 i++) {
			 com.starbase.starteam.Project p = projects[i];
			 if (p.getName().equals(getProjectName())) {
				 if (getVerboseAsBoolean()) {
					 project.log(""Found "" + getProjectName() + delim);
				 }
				 runProject(s, p);
				 break;
			 }
		 }
	 }
	 protected void runProject(Server s, com.starbase.starteam.Project p) {
		 View[] views = p.getViews();
		 for (int i = 0;
		 i < views.length;
		 i++) {
			 View v = views[i];
			 if (v.getName().equals(getViewName())) {
				 if (getVerboseAsBoolean()) {
					 project.log(""Found "" + getProjectName() + delim + getViewName() + delim);
				 }
				 runType(s, p, v, s.typeForName((String)s.getTypeNames().FILE));
				 break;
			 }
		 }
	 }
	 protected void runType(Server s, com.starbase.starteam.Project p, View v, Type t) {
		 Folder f = v.getRootFolder();
		 if (!(getFolderName()==null)) {
			 if (getFolderName().equals(""\\"") || getFolderName().equals(""/"")) {
				 setFolderName(null);
			 }
			 else {
				 f = StarTeamFinder.findFolder(v.getRootFolder(), getFolderName());
			 }
		 }
		 if (getVerboseAsBoolean() && !(getFolderName()==null)) {
			 project.log( ""Found "" + getProjectName() + delim + getViewName() + delim + getFolderName() + delim + ""\n"" );
		 }
		 int nProperties = 2;
		 Property p1 = getPrimaryDescriptor(t);
		 Property p2 = getSecondaryDescriptor(t);
		 if (p2 != null) {
			 nProperties++;
		 }
		 String[] strNames = new String[nProperties];
		 int iProperty = 0;
		 strNames[iProperty++] = s.getPropertyNames().OBJECT_ID;
		 strNames[iProperty++] = p1.getName();
		 if (p2 != null) {
			 strNames[iProperty++] = p2.getName();
		 }
		 f.populateNow(t.getName(), strNames, -1);
		 runFolder(s, p, v, t, f);
		 f.discardItems(t.getName(), -1);
	 }
	 protected void runFolder( Server s, com.starbase.starteam.Project p, View v, Type t, Folder f ) {
		 Item[] items = f.getItems(t.getName());
		 for (int i = 0;
		 i < items.length;
		 i++) {
			 runItem(s, p, v, t, f, items[i]);
		 }
		 if (getRecursionAsBoolean()) {
			 Folder[] subfolders = f.getSubFolders();
			 for (int i = 0;
			 i < subfolders.length;
			 i++) {
				 runFolder(s, p, v, t, subfolders[i]);
			 }
		 }
	 }
	 protected void runItem( Server s, com.starbase.starteam.Project p, View v, Type t, Folder f, Item item ) {
		 Property p1 = getPrimaryDescriptor(t);
		 Property p2 = getSecondaryDescriptor(t);
		 String pName = (String)item.get(p1.getName());
		 boolean includeIt = false;
		 boolean excludeIt = false;
		 if (getIncludes()!=null) {
			 StringTokenizer inStr = new StringTokenizer(getIncludes(), "" "");
			 while (inStr.hasMoreTokens()) {
				 if (match(inStr.nextToken(), pName)) {
					 includeIt = true;
				 }
			 }
		 }
		 if (getExcludes()!=null) {
			 StringTokenizer exStr = new StringTokenizer(getExcludes(), "" "");
			 while (exStr.hasMoreTokens()) {
				 if (match(exStr.nextToken(), pName)) {
					 excludeIt = true;
				 }
			 }
		 }
		 if (!includeIt | excludeIt) {
			 return;
		 }
		 if (getVerboseAsBoolean()) {
			 boolean bShowHeader = true;
			 if (f != prevFolder) {
				 String strFolder = f.getFolderHierarchy();
				 int i = strFolder.indexOf(delim);
				 if (i >= 0) {
					 strFolder = strFolder.substring(i+1);
				 }
				 System.out.println("" Folder: \"""" + strFolder + ""\"""");
				 prevFolder = f;
			 }
			 else bShowHeader = false;
			 if (bShowHeader) {
				 System.out.print("" Item"");
				 System.out.print("",\t"" + p1.getDisplayName());
				 if (p2 != null) {
					 System.out.print("",\t"" + p2.getDisplayName());
				 }
				 System.out.println("""");
			 }
			 System.out.print("" "" + item.getItemID());
			 System.out.print("",\t"" + formatForDisplay(p1, item.get(p1.getName())));
			 if (p2 != null) {
				 System.out.print("",\t"" + formatForDisplay(p2, item.get(p2.getName())));
			 }
			 int locker = item.getLocker();
			 if (locker>-1) {
				 System.out.println("",\tLocked by "" + locker);
			 }
			 else {
				 System.out.println("",\tNot locked"");
			 }
		 }
		 com.starbase.starteam.File remote = (com.starbase.starteam.File)item;
		 String dirName = v.getDefaultPath();
		 dirName = dirName.replace('\\', '/');
		 int endDirIndex = dirName.length();
		 if (dirName.endsWith(""/"")) {
			 endDirIndex--;
		 }
		 dirName = dirName.substring(dirName.lastIndexOf(""/"", dirName.length() - 2) + 1, endDirIndex);
		 StringTokenizer pathTokenizer = new StringTokenizer(item.getParentFolder().getFolderHierarchy(), delim);
		 String localName = delim;
		 String currentToken = null;
		 while (pathTokenizer.hasMoreTokens()) {
			 currentToken = pathTokenizer.nextToken();
			 if (currentToken.equals(getProjectName())) {
				 currentToken = dirName;
			 }
			 localName += currentToken + delim;
		 }
		 java.io.File local = new java.io.File( getTargetFolder() + localName + item.get(p1.getName()) );
		 try {
			 remote.checkoutTo(local, Item.LockType.UNCHANGED, false, true, true);
		 }
		 catch (Throwable e) {
			 project.log("" "" + e.getMessage());
		 }
		 checkedOut++;
	 }
	 protected Property getPrimaryDescriptor(Type t) {
		 Property[] properties = t.getProperties();
		 for (int i = 0;
		 i < properties.length;
		 i++) {
			 Property p = properties[i];
			 if (p.isPrimaryDescriptor()) {
				 return p;
			 }
		 }
		 return null;
	 }
	 protected Property getSecondaryDescriptor(Type t) {
		 Property[] properties = t.getProperties();
		 for (int i = 0;
		 i < properties.length;
		 i++) {
			 Property p = properties[i];
			 if (p.isDescriptor() && !p.isPrimaryDescriptor()) {
				 return p;
			 }
		 }
		 return null;
	 }
	 protected String formatForDisplay(Property p, Object value) {
		 if (p.getTypeCode() == Property.Types.TEXT) {
			 String str = value.toString();
			 if (str.length() > 35) {
				 str = str.substring(0, 32) + ""..."";
			 }
			 return ""\"""" + str + ""\"""";
		 }
		 else {
			 if (p.getTypeCode() == Property.Types.ENUMERATED) {
				 return ""\"""" + p.getEnumDisplayName(((Integer)value).intValue()) + ""\"""";
			 }
			 else {
				 return value.toString();
			 }
		 }
	 }
	 private static boolean match(String pattern, String str) {
		 char[] patArr = pattern.toCharArray();
		 char[] strArr = str.toCharArray();
		 int patIdxStart = 0;
		 int patIdxEnd = patArr.length-1;
		 int strIdxStart = 0;
		 int strIdxEnd = strArr.length-1;
		 char ch;
		 boolean containsStar = false;
		 for (int i = 0;
		 i < patArr.length;
		 i++) {
			 if (patArr[i] == '*') {
				 containsStar = true;
				 break;
			 }
		 }
		 if (!containsStar) {
			 if (patIdxEnd != strIdxEnd) {
				 return false;
			 }
			 for (int i = 0;
			 i <= patIdxEnd;
			 i++) {
				 ch = patArr[i];
				 if (ch != '?' && ch != strArr[i]) {
					 return false;
				 }
			 }
			 return true;
		 }
		 if (patIdxEnd == 0) {
			 return true;
		 }
		 while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {
			 if (ch != '?' && ch != strArr[strIdxStart]) {
				 return false;
			 }
			 patIdxStart++;
			 strIdxStart++;
		 }
		 if (strIdxStart > strIdxEnd) {
			 for (int i = patIdxStart;
			 i <= patIdxEnd;
			 i++) {
				 if (patArr[i] != '*') {
					 return false;
				 }
			 }
			 return true;
		 }
		 while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {
			 if (ch != '?' && ch != strArr[strIdxEnd]) {
				 return false;
			 }
			 patIdxEnd--;
			 strIdxEnd--;
		 }
		 if (strIdxStart > strIdxEnd) {
			 for (int i = patIdxStart;
			 i <= patIdxEnd;
			 i++) {
				 if (patArr[i] != '*') {
					 return false;
				 }
			 }
			 return true;
		 }
		 while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
			 int patIdxTmp = -1;
			 for (int i = patIdxStart+1;
			 i <= patIdxEnd;
			 i++) {
				 if (patArr[i] == '*') {
					 patIdxTmp = i;
					 break;
				 }
			 }
			 if (patIdxTmp == patIdxStart+1) {
				 patIdxStart++;
				 continue;
			 }
			 int patLength = (patIdxTmp-patIdxStart-1);
			 int strLength = (strIdxEnd-strIdxStart+1);
			 int foundIdx = -1;
			 strLoop: for (int i = 0;
			 i <= strLength - patLength;
			 i++) {
				 for (int j = 0;
				 j < patLength;
				 j++) {
					 ch = patArr[patIdxStart+j+1];
					 if (ch != '?' && ch != strArr[strIdxStart+i+j]) {
						 continue strLoop;
					 }
				 }
				 foundIdx = strIdxStart+i;
				 break;
			 }
			 if (foundIdx == -1) {
				 return false;
			 }
			 patIdxStart = patIdxTmp;
			 strIdxStart = foundIdx+patLength;
		 }
		 for (int i = patIdxStart;
		 i <= patIdxEnd;
		 i++) {
			 if (patArr[i] != '*') {
				 return false;
			 }
		 }
		 return true;
	 }
	 public void setServerName(String serverName) {
		 this.serverName = serverName;
	 }
	 public String getServerName() {
		 return serverName;
	 }
	 public void setServerPort(String serverPort) {
		 this.serverPort = serverPort;
	 }
	 public String getServerPort() {
		 return serverPort;
	 }
	 public int getServerPortAsInt() {
		 return Integer.parseInt(serverPort);
	 }
	 public void setProjectName(String projectName) {
		 this.projectName = projectName;
	 }
	 public String getProjectName() {
		 return projectName;
	 }
	 public void setViewName(String viewName) {
		 this.viewName = viewName;
	 }
	 public String getViewName() {
		 return viewName;
	 }
	 public void setFolderName(String folderName) {
		 this.folderName = folderName;
	 }
	 public String getFolderName() {
		 return folderName;
	 }
	 public void setUsername(String username) {
		 this.username = username;
	 }
	 public String getUsername() {
		 return username;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public String getPassword() {
		 return password;
	 }
	 public void setTargetFolder(String targetFolder) {
		 this.targetFolder = targetFolder;
	 }
	 public String getTargetFolder() {
		 return targetFolder;
	 }
	 public void setForce(String force) {
		 this.force = force;
	 }
	 public String getForce() {
		 return force;
	 }
	 public boolean getForceAsBoolean() {
		 return project.toBoolean(force);
	 }
	 public void setRecursion(String recursion) {
		 this.recursion = recursion;
	 }
	 public String getRecursion() {
		 return recursion;
	 }
	 public boolean getRecursionAsBoolean() {
		 return project.toBoolean(recursion);
	 }
	 public void setVerbose(String verbose) {
		 this.verbose = verbose;
	 }
	 public String getVerbose() {
		 return verbose;
	 }
	 public boolean getVerboseAsBoolean() {
		 return project.toBoolean(verbose);
	 }
	 public void setIncludes(String includes) {
		 this.includes = includes;
	 }
	 public String getIncludes() {
		 return includes;
	 }
	 public void setExcludes(String excludes) {
		 this.excludes = excludes;
	 }
	 public String getExcludes() {
		 return excludes;
	 }
}",1,0,0,0
"SortSettings(AbstractTranslet translet, int[] sortOrders, int[] types, Locale[] locales, Collator[] collators, String[] caseOrders);",0,0,0,1
"public class ExtendedCompletionList {
	 private boolean inComplete;
	 private List<ExtendedCompletionItem> items;
	 public ExtendedCompletionList(boolean incomplete, List<ExtendedCompletionItem> items) {
		 this.inComplete = incomplete;
		 this.items = items;
	 }
	 public ExtendedCompletionList() {
	}
	 public List<ExtendedCompletionItem> getItems() {
		 return items;
	 }
	 public void setItems(List<ExtendedCompletionItem> items) {
		 this.items = items;
	 }
	 public boolean isInComplete() {
		 return inComplete;
	 }
	 public void setInComplete(boolean inComplete) {
		 this.inComplete = inComplete;
	 }
}",0,1,0,0
"public class JakartaOroMatcher implements RegexpMatcher {
	 private String pattern;
	 protected final Perl5Compiler compiler = new Perl5Compiler();
	 protected final Perl5Matcher matcher = new Perl5Matcher();
	 public JakartaOroMatcher() {
	 }
	 public void setPattern(String pattern) {
		 this.pattern = pattern;
	 }
	 public String getPattern() {
		 return this.pattern;
	 }
	 protected Pattern getCompiledPattern(int options) throws BuildException {
		 try {
			 Pattern p = compiler.compile(pattern, getCompilerOptions(options));
			 return p;
		 }
		 catch (Exception e) {
			 throw new BuildException(e);
		 }
	 }
	 public boolean matches(String argument) throws BuildException {
		 return matches(argument, MATCH_DEFAULT);
	 }
	 public boolean matches(String input, int options) throws BuildException {
		 Pattern p = getCompiledPattern(options);
		 return matcher.contains(input, p);
	 }
	 public Vector getGroups(String argument) throws BuildException {
		 return getGroups(argument, MATCH_DEFAULT);
	 }
	 public Vector getGroups(String input, int options) throws BuildException {
		 if (!matches(input, options)) {
			 return null;
		 }
		 Vector v = new Vector();
		 MatchResult mr = matcher.getMatch();
		 int cnt = mr.groups();
		 for (int i = 0;
		 i < cnt;
		 i++) {
			 String match = mr.group(i);
			 if (match == null) {
				 match = """";
			 }
			 v.addElement(match);
		 }
		 return v;
	 }
	 protected int getCompilerOptions(int options) {
		 int cOptions = Perl5Compiler.DEFAULT_MASK;
		 if (RegexpUtil.hasFlag(options, MATCH_CASE_INSENSITIVE)) {
			 cOptions |= Perl5Compiler.CASE_INSENSITIVE_MASK;
		 }
		 if (RegexpUtil.hasFlag(options, MATCH_MULTILINE)) {
			 cOptions |= Perl5Compiler.MULTILINE_MASK;
		 }
		 if (RegexpUtil.hasFlag(options, MATCH_SINGLELINE)) {
			 cOptions |= Perl5Compiler.SINGLELINE_MASK;
		 }
		 return cOptions;
	 }
}",0,0,0,0
"public class Main {
	 static {
		 Utils.addShutdownHookWithPriority(new Runnable() {
			 public void run() {
				 FileLocalizer.deleteTempResourceFiles();
			 }
		 }
		, PigImplConstants.SHUTDOWN_HOOK_TMP_FILES_CLEANUP_PRIORITY);
	 }
	 private final static Log log = LogFactory.getLog(Main.class);
	 private static final String LOG4J_CONF = ""log4jconf"";
	 private static final String BRIEF = ""brief"";
	 private static final String DEBUG = ""debug"";
	 private static final String VERBOSE = ""verbose"";
	 private static final String version;
	 private static final String majorVersion;
	 private static final String minorVersion;
	 private static final String patchVersion;
	 private static final String svnRevision;
	 private static final String buildTime;
	 private enum ExecMode {
	STRING, FILE, SHELL, UNKNOWN}
	 protected static final String PROGRESS_NOTIFICATION_LISTENER_KEY = ""pig.notification.listener"";
	 protected static final String PROGRESS_NOTIFICATION_LISTENER_ARG_KEY = ""pig.notification.listener.arg"";
	 static {
		 Attributes attr=null;
		 try {
			 String findContainingJar = JarManager.findContainingJar(Main.class);
			 if (findContainingJar != null) {
				 JarFile jar = new JarFile(findContainingJar);
				 final Manifest manifest = jar.getManifest();
				 final Map<String,Attributes> attrs = manifest.getEntries();
				 attr = attrs.get(""org/apache/pig"");
			 }
			 else {
				 log.info(""Unable to read pigs manifest file as we are not running from a jar, version information unavailable"");
			 }
		 }
		 catch (Exception e) {
			 log.warn(""Unable to read pigs manifest file, version information unavailable"", e);
		 }
		 if (attr!=null) {
			 version = attr.getValue(""Implementation-Version"");
			 svnRevision = attr.getValue(""Svn-Revision"");
			 buildTime = attr.getValue(""Build-TimeStamp"");
			 String[] split = version.split(""\\."");
			 majorVersion=split[0];
			 minorVersion=split[1];
			 patchVersion=split[2];
		 }
		 else {
			 version=null;
			 majorVersion=null;
			 minorVersion=null;
			 patchVersion=null;
			 svnRevision=null;
			 buildTime=null;
		 }
	 }
	 public static void main(String args[]) {
		 System.exit(run(args, null));
	 }
	 static int run(String args[], PigProgressNotificationListener listener) {
		 DateTime startTime = new DateTime();
		 int rc = 1;
		 boolean verbose = false;
		 boolean gruntCalled = false;
		 boolean deleteTempFiles = true;
		 String logFileName = null;
		 boolean printScriptRunTime = true;
		 PigContext pigContext = null;
		 try {
			 Configuration conf = new Configuration(false);
			 GenericOptionsParser parser = new GenericOptionsParser(conf, args);
			 conf = parser.getConfiguration();
			 Properties properties = new Properties();
			 PropertiesUtil.loadDefaultProperties(properties);
			 properties.putAll(ConfigurationUtil.toProperties(conf));
			 if (listener == null) {
				 listener = makeListener(properties);
			 }
			 String[] pigArgs = parser.getRemainingArgs();
			 boolean userSpecifiedLog = false;
			 boolean checkScriptOnly = false;
			 BufferedReader pin = null;
			 boolean debug = false;
			 boolean dryrun = false;
			 boolean embedded = false;
			 List<String> params = new ArrayList<String>();
			 List<String> paramFiles = new ArrayList<String>();
			 HashSet<String> disabledOptimizerRules = new HashSet<String>();
			 CmdLineParser opts = new CmdLineParser(pigArgs);
			 opts.registerOpt('4', ""log4jconf"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('b', ""brief"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('c', ""check"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('d', ""debug"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('e', ""execute"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('f', ""file"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('g', ""embedded"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('h', ""help"", CmdLineParser.ValueExpected.OPTIONAL);
			 opts.registerOpt('i', ""version"", CmdLineParser.ValueExpected.OPTIONAL);
			 opts.registerOpt('l', ""logfile"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('m', ""param_file"", CmdLineParser.ValueExpected.OPTIONAL);
			 opts.registerOpt('p', ""param"", CmdLineParser.ValueExpected.OPTIONAL);
			 opts.registerOpt('r', ""dryrun"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('t', ""optimizer_off"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('v', ""verbose"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('w', ""warning"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('x', ""exectype"", CmdLineParser.ValueExpected.REQUIRED);
			 opts.registerOpt('F', ""stop_on_failure"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('M', ""no_multiquery"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('N', ""no_fetch"", CmdLineParser.ValueExpected.NOT_ACCEPTED);
			 opts.registerOpt('P', ""propertyFile"", CmdLineParser.ValueExpected.REQUIRED);
			 ExecMode mode = ExecMode.UNKNOWN;
			 String file = null;
			 String engine = null;
			 UDFContext.getUDFContext().setClientSystemProps(properties);
			 char opt;
			 while ((opt = opts.getNextOpt()) != CmdLineParser.EndOfOpts) {
				 switch (opt) {
					 case '4': String log4jconf = opts.getValStr();
					 if(log4jconf != null){
						 properties.setProperty(LOG4J_CONF, log4jconf);
					 }
					 break;
					 case 'b': properties.setProperty(BRIEF, ""true"");
					 break;
					 case 'c': checkScriptOnly = true;
					 break;
					 case 'd': String logLevel = opts.getValStr();
					 if (logLevel != null) {
						 properties.setProperty(DEBUG, logLevel);
					 }
					 debug = true;
					 break;
					 case 'e': mode = ExecMode.STRING;
					 break;
					 case 'f': mode = ExecMode.FILE;
					 file = opts.getValStr();
					 break;
					 case 'g': embedded = true;
					 engine = opts.getValStr();
					 break;
					 case 'F': properties.setProperty(""stop.on.failure"", """"+true);
					 break;
					 case 'h': String topic = opts.getValStr();
					 if (topic != null) if (topic.equalsIgnoreCase(""properties"")) printProperties();
					 else{
						 System.out.println(""Invalide help topic - "" + topic);
						 usage();
					 }
					 else usage();
					 return ReturnCode.SUCCESS;
					 case 'i': printScriptRunTime = false;
					 System.out.println(getVersionString());
					 return ReturnCode.SUCCESS;
					 case 'l': String logFileParameter = opts.getValStr();
					 if (logFileParameter != null && logFileParameter.length() > 0) {
						 logFileName = validateLogFile(logFileParameter, null);
					 }
					 else {
						 logFileName = validateLogFile(logFileName, null);
					 }
					 userSpecifiedLog = true;
					 properties.setProperty(""pig.logfile"", (logFileName == null? """": logFileName));
					 break;
					 case 'm': paramFiles.add(opts.getValStr());
					 break;
					 case 'M': properties.setProperty(PigConfiguration.PIG_OPT_MULTIQUERY,""""+false);
					 break;
					 case 'N': properties.setProperty(PigConfiguration.PIG_OPT_FETCH,""""+false);
					 break;
					 case 'p': params.add(opts.getValStr());
					 break;
					 case 'r': dryrun = true;
					 break;
					 case 't': disabledOptimizerRules.add(opts.getValStr());
					 break;
					 case 'v': properties.setProperty(VERBOSE, """"+true);
					 verbose = true;
					 break;
					 case 'w': properties.setProperty(""aggregate.warning"", """"+false);
					 break;
					 case 'x': properties.setProperty(""exectype"", opts.getValStr());
					 if (opts.getValStr().toLowerCase().contains(""local"")) {
						 UserGroupInformation.setConfiguration(new Configuration(false));
					 }
					 break;
					 case 'P': {
						 InputStream inputStream = null;
						 try {
							 FileLocalizer.FetchFileRet localFileRet = FileLocalizer.fetchFile(properties, opts.getValStr());
							 inputStream = new BufferedInputStream(new FileInputStream(localFileRet.file));
							 properties.load(inputStream) ;
						 }
						 catch (IOException e) {
							 throw new RuntimeException(""Unable to parse properties file '"" + opts.getValStr() + ""'"");
						 }
						 finally {
							 if (inputStream != null) {
								 try {
									 inputStream.close();
								 }
								 catch (IOException e) {
								 }
							 }
						 }
					 }
					 break;
					 default: {
						 Character cc = Character.valueOf(opt);
						 throw new AssertionError(""Unhandled option "" + cc.toString());
					 }
				 }
			 }
			 pigContext = new PigContext(properties);
			 ScriptState scriptState = pigContext.getExecutionEngine().instantiateScriptState();
			 String commandLine = LoadFunc.join((AbstractList<String>)Arrays.asList(args), "" "");
			 scriptState.setCommandLine(commandLine);
			 if (listener != null) {
				 scriptState.registerListener(listener);
			 }
			 ScriptState.start(scriptState);
			 pigContext.getProperties().setProperty(""pig.cmd.args"", commandLine);
			 if(logFileName == null && !userSpecifiedLog) {
				 logFileName = validateLogFile(properties.getProperty(""pig.logfile""), null);
			 }
			 pigContext.getProperties().setProperty(""pig.logfile"", (logFileName == null? """": logFileName));
			 configureLog4J(properties, pigContext);
			 log.info(getVersionString().replace(""\n"", """"));
			 if(logFileName != null) {
				 log.info(""Logging error messages to: "" + logFileName);
			 }
			 deleteTempFiles = Boolean.valueOf(properties.getProperty( PigConfiguration.PIG_DELETE_TEMP_FILE, ""true""));
			 pigContext.getProperties().setProperty(PigImplConstants.PIG_OPTIMIZER_RULES_KEY, ObjectSerializer.serialize(disabledOptimizerRules));
			 PigContext.setClassLoader(pigContext.createCl(null));
			 Grunt grunt = null;
			 BufferedReader in;
			 String substFile = null;
			 paramFiles = fetchRemoteParamFiles(paramFiles, properties);
			 pigContext.setParams(params);
			 pigContext.setParamFiles(paramFiles);
			 switch (mode) {
				 case FILE: {
					 String remainders[] = opts.getRemainingArgs();
					 if (remainders != null) {
						 pigContext.getProperties().setProperty(PigContext.PIG_CMD_ARGS_REMAINDERS, ObjectSerializer.serialize(remainders));
					 }
					 FileLocalizer.FetchFileRet localFileRet = FileLocalizer.fetchFile(properties, file);
					 if (localFileRet.didFetch) {
						 properties.setProperty(""pig.jars.relative.to.dfs"", ""true"");
					 }
					 scriptState.setFileName(file);
					 if (embedded) {
						 return runEmbeddedScript(pigContext, localFileRet.file.getPath(), engine);
					 }
					 else {
						 SupportedScriptLang type = determineScriptType(localFileRet.file.getPath());
						 if (type != null) {
							 return runEmbeddedScript(pigContext, localFileRet.file .getPath(), type.name().toLowerCase());
						 }
					 }
					 in = new BufferedReader(new InputStreamReader(Utils.getCompositeStream(new FileInputStream(localFileRet.file), properties)));
					 substFile = file + "".substituted"";
					 pin = runParamPreprocessor(pigContext, in, substFile, debug || dryrun || checkScriptOnly);
					 if (dryrun) {
						 if (dryrun(substFile, pigContext)) {
							 log.info(""Dry run completed. Substituted pig script is at "" + substFile + "". Expanded pig script is at "" + file + "".expanded"");
						 }
						 else {
							 log.info(""Dry run completed. Substituted pig script is at "" + substFile);
						 }
						 return ReturnCode.SUCCESS;
					 }
					 logFileName = validateLogFile(logFileName, localFileRet.file);
					 pigContext.getProperties().setProperty(""pig.logfile"", (logFileName == null? """": logFileName));
					 pigContext.getProperties().setProperty(PigContext.JOB_NAME, ""PigLatin:"" +new File(file).getName() );
					 if (!debug) {
						 new File(substFile).deleteOnExit();
					 }
					 scriptState.setScript(localFileRet.file);
					 grunt = new Grunt(pin, pigContext);
					 gruntCalled = true;
					 if(checkScriptOnly) {
						 grunt.checkScript(substFile);
						 System.err.println(file + "" syntax OK"");
						 rc = ReturnCode.SUCCESS;
					 }
					 else {
						 int results[] = grunt.exec();
						 rc = getReturnCodeForStats(results);
					 }
					 return rc;
				 }
				 case STRING: {
					 if(checkScriptOnly) {
						 System.err.println(""ERROR:"" + ""-c (-check) option is only valid "" + ""when executing pig with a pig script file)"");
						 return ReturnCode.ILLEGAL_ARGS;
					 }
					 StringBuffer sb = new StringBuffer();
					 String remainders[] = opts.getRemainingArgs();
					 for (int i = 0;
					 i < remainders.length;
					 i++) {
						 if (i != 0) sb.append(' ');
						 sb.append(remainders[i]);
					 }
					 sb.append('\n');
					 scriptState.setScript(sb.toString());
					 in = new BufferedReader(new StringReader(sb.toString()));
					 grunt = new Grunt(in, pigContext);
					 gruntCalled = true;
					 int results[] = grunt.exec();
					 return getReturnCodeForStats(results);
				 }
				 default: break;
			 }
			 String remainders[] = opts.getRemainingArgs();
			 if (remainders == null) {
				 if(checkScriptOnly) {
					 System.err.println(""ERROR:"" + ""-c (-check) option is only valid "" + ""when executing pig with a pig script file)"");
					 return ReturnCode.ILLEGAL_ARGS;
				 }
				 mode = ExecMode.SHELL;
				 ConsoleReader reader = new ConsoleReader(Utils.getCompositeStream(System.in, properties), System.out);
				 reader.setExpandEvents(false);
				 reader.setPrompt(""grunt> "");
				 final String HISTORYFILE = "".pig_history"";
				 String historyFile = System.getProperty(""user.home"") + File.separator + HISTORYFILE;
				 reader.setHistory(new FileHistory(new File(historyFile)));
				 ConsoleReaderInputStream inputStream = new ConsoleReaderInputStream(reader);
				 grunt = new Grunt(new BufferedReader(new InputStreamReader(inputStream)), pigContext);
				 grunt.setConsoleReader(reader);
				 gruntCalled = true;
				 grunt.run();
				 return ReturnCode.SUCCESS;
			 }
			 else {
				 pigContext.getProperties().setProperty(PigContext.PIG_CMD_ARGS_REMAINDERS, ObjectSerializer.serialize(remainders));
				 mode = ExecMode.FILE;
				 FileLocalizer.FetchFileRet localFileRet = FileLocalizer.fetchFile(properties, remainders[0]);
				 if (localFileRet.didFetch) {
					 properties.setProperty(""pig.jars.relative.to.dfs"", ""true"");
				 }
				 scriptState.setFileName(remainders[0]);
				 if (embedded) {
					 return runEmbeddedScript(pigContext, localFileRet.file.getPath(), engine);
				 }
				 else {
					 SupportedScriptLang type = determineScriptType(localFileRet.file.getPath());
					 if (type != null) {
						 return runEmbeddedScript(pigContext, localFileRet.file .getPath(), type.name().toLowerCase());
					 }
				 }
				 InputStream seqInputStream = Utils.getCompositeStream(new FileInputStream(localFileRet.file), properties);
				 in = new BufferedReader(new InputStreamReader(seqInputStream));
				 substFile = remainders[0] + "".substituted"";
				 pin = runParamPreprocessor(pigContext, in, substFile, debug || dryrun || checkScriptOnly);
				 if (dryrun) {
					 if (dryrun(substFile, pigContext)) {
						 log.info(""Dry run completed. Substituted pig script is at "" + substFile + "". Expanded pig script is at "" + remainders[0] + "".expanded"");
					 }
					 else {
						 log.info(""Dry run completed. Substituted pig script is at "" + substFile);
					 }
					 return ReturnCode.SUCCESS;
				 }
				 logFileName = validateLogFile(logFileName, localFileRet.file);
				 pigContext.getProperties().setProperty(""pig.logfile"", (logFileName == null? """": logFileName));
				 if (!debug) {
					 new File(substFile).deleteOnExit();
				 }
				 pigContext.getProperties().setProperty(PigContext.JOB_NAME, ""PigLatin:"" +new File(remainders[0]).getName() );
				 scriptState.setScript(localFileRet.file);
				 grunt = new Grunt(pin, pigContext);
				 gruntCalled = true;
				 if(checkScriptOnly) {
					 grunt.checkScript(substFile);
					 System.err.println(remainders[0] + "" syntax OK"");
					 rc = ReturnCode.SUCCESS;
				 }
				 else {
					 int results[] = grunt.exec();
					 rc = getReturnCodeForStats(results);
				 }
				 return rc;
			 }
		 }
		 catch (ParseException e) {
			 usage();
			 rc = ReturnCode.PARSE_EXCEPTION;
			 PigStatsUtil.setErrorMessage(e.getMessage());
			 PigStatsUtil.setErrorThrowable(e);
		 }
		 catch (org.apache.pig.tools.parameters.ParseException e) {
			 rc = ReturnCode.PARSE_EXCEPTION;
			 PigStatsUtil.setErrorMessage(e.getMessage());
			 PigStatsUtil.setErrorThrowable(e);
		 }
		 catch (IOException e) {
			 if (e instanceof PigException) {
				 PigException pe = (PigException)e;
				 rc = (pe.retriable()) ? ReturnCode.RETRIABLE_EXCEPTION : ReturnCode.PIG_EXCEPTION;
				 PigStatsUtil.setErrorMessage(pe.getMessage());
				 PigStatsUtil.setErrorCode(pe.getErrorCode());
			 }
			 else {
				 rc = ReturnCode.IO_EXCEPTION;
				 PigStatsUtil.setErrorMessage(e.getMessage());
			 }
			 PigStatsUtil.setErrorThrowable(e);
			 if(!gruntCalled) {
				 LogUtils.writeLog(e, logFileName, log, verbose, ""Error before Pig is launched"");
			 }
			 killRunningJobsIfInterrupted(e, pigContext);
		 }
		 catch (Throwable e) {
			 rc = ReturnCode.THROWABLE_EXCEPTION;
			 PigStatsUtil.setErrorMessage(e.getMessage());
			 PigStatsUtil.setErrorThrowable(e);
			 if(!gruntCalled) {
				 LogUtils.writeLog(e, logFileName, log, verbose, ""Error before Pig is launched"");
			 }
			 killRunningJobsIfInterrupted(e, pigContext);
		 }
		 finally {
			 if (printScriptRunTime) {
				 printScriptRunTime(startTime);
			 }
			 if (deleteTempFiles) {
				 FileLocalizer.deleteTempFiles();
			 }
			 if (pigContext != null) {
				 pigContext.getExecutionEngine().destroy();
			 }
			 PerformanceTimerFactory.getPerfTimerFactory().dumpTimers();
		 }
		 return rc;
	 }
	 private static void printScriptRunTime(DateTime startTime) {
		 DateTime endTime = new DateTime();
		 Duration duration = new Duration(startTime, endTime);
		 Period period = duration.toPeriod().normalizedStandard(PeriodType.time());
		 log.info(""Pig script completed in "" + PeriodFormat.getDefault().print(period) + "" ("" + duration.getMillis() + "" ms)"");
	 }
	 private static void killRunningJobsIfInterrupted(Throwable e, PigContext pigContext) {
		 Throwable cause = e.getCause();
		 if (e instanceof InterruptedException || (cause != null && cause instanceof InterruptedException)) {
			 try {
				 pigContext.getExecutionEngine().kill();
			 }
			 catch (BackendException be) {
				 log.error(""Error while killing running jobs"", be);
			 }
		 }
	 }
	 protected static PigProgressNotificationListener makeListener(Properties properties) {
		 try {
			 return PigContext.instantiateObjectFromParams( ConfigurationUtil.toConfiguration(properties), PROGRESS_NOTIFICATION_LISTENER_KEY, PROGRESS_NOTIFICATION_LISTENER_ARG_KEY, PigProgressNotificationListener.class);
		 }
		 catch (ExecException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 private static int getReturnCodeForStats(int[] stats) {
		 return (stats[1] == 0) ? ReturnCode.SUCCESS : (stats[0] == 0) ? ReturnCode.FAILURE : ReturnCode.PARTIAL_FAILURE;
	 }
	 public static boolean dryrun(String scriptFile, PigContext pigContext) throws RecognitionException, IOException {
		 BufferedReader rd = new BufferedReader(new FileReader(scriptFile));
		 DryRunGruntParser dryrun = new DryRunGruntParser(rd, scriptFile, pigContext);
		 boolean hasMacro = dryrun.parseStopOnError();
		 if (hasMacro) {
			 String expandedFile = scriptFile.replace("".substituted"", "".expanded"");
			 BufferedWriter fw = new BufferedWriter(new FileWriter(expandedFile));
			 fw.append(dryrun.getResult());
			 fw.close();
		 }
		 return hasMacro;
	 }
	 private static void configureLog4J(Properties properties, PigContext pigContext) {
		 String log4jconf = properties.getProperty(LOG4J_CONF);
		 String trueString = ""true"";
		 boolean brief = trueString.equalsIgnoreCase(properties.getProperty(BRIEF));
		 Level logLevel = Level.INFO;
		 String logLevelString = properties.getProperty(DEBUG);
		 if (logLevelString != null){
			 logLevel = Level.toLevel(logLevelString, Level.INFO);
		 }
		 final Properties props = log4jConfAsProperties(log4jconf);
		 if (props.size() == 0) {
			 props.setProperty(""log4j.logger.org.apache.pig"", logLevel.toString());
			 if((logLevelString = System.getProperty(""pig.logfile.level"")) == null){
				 props.setProperty(""log4j.rootLogger"", ""INFO, PIGCONSOLE"");
			 }
			 else{
				 logLevel = Level.toLevel(logLevelString, Level.INFO);
				 props.setProperty(""log4j.logger.org.apache.pig"", logLevel.toString());
				 props.setProperty(""log4j.rootLogger"", ""INFO, PIGCONSOLE, F"");
				 props.setProperty(""log4j.appender.F"",""org.apache.log4j.RollingFileAppender"");
				 props.setProperty(""log4j.appender.F.File"",properties.getProperty(""pig.logfile""));
				 props.setProperty(""log4j.appender.F.layout"",""org.apache.log4j.PatternLayout"");
				 props.setProperty(""log4j.appender.F.layout.ConversionPattern"", brief ? ""%m%n"" : ""%d [%t] %-5p %c - %m%n"");
			 }
			 props.setProperty(""log4j.appender.PIGCONSOLE"",""org.apache.log4j.ConsoleAppender"");
			 props.setProperty(""log4j.appender.PIGCONSOLE.target"", ""System.err"");
			 props.setProperty(""log4j.appender.PIGCONSOLE.layout"",""org.apache.log4j.PatternLayout"");
			 props.setProperty(""log4j.appender.PIGCONSOLE.layout.ConversionPattern"", brief ? ""%m%n"" : ""%d [%t] %-5p %c - %m%n"");
		 }
		 PropertyConfigurator.configure(props);
		 logLevel = Logger.getLogger(""org.apache.pig"").getLevel();
		 if (logLevel==null) {
			 logLevel = Logger.getLogger(""org.apache.pig"").getEffectiveLevel();
		 }
		 Properties backendProps = pigContext.getLog4jProperties();
		 backendProps.setProperty(""log4j.logger.org.apache.pig"", logLevel.toString());
		 pigContext.setLog4jProperties(backendProps);
		 pigContext.setDefaultLogLevel(logLevel);
	 }
	 static Properties log4jConfAsProperties(String log4jconf) {
		 final Properties properties = new Properties();
		 if (!Strings.isNullOrEmpty(log4jconf)) {
			 Reader propertyReader = null;
			 try {
				 final File file = new File(log4jconf);
				 if (file.exists()) {
					 propertyReader = new FileReader(file);
					 properties.load(propertyReader);
					 log.info(""Loaded log4j properties from file: "" + file);
				 }
				 else {
					 final URL resource = Main.class.getClassLoader().getResource(log4jconf);
					 if (resource != null) {
						 propertyReader = new InputStreamReader(resource.openStream(), Charset.forName(""UTF-8""));
						 properties.load(propertyReader);
						 log.info(""Loaded log4j properties from resource: "" + resource);
					 }
					 else {
						 log.warn(""No file or resource found by the name: "" + log4jconf);
					 }
				 }
			 }
			 catch (IOException e) {
				 log.warn(""Cannot open log4j properties file "" + log4jconf + "", using default"");
			 }
			 finally {
				 Closeables.closeQuietly(propertyReader);
			 }
		 }
		 return properties;
	 }
	 private static List<String> fetchRemoteParamFiles(List<String> paramFiles, Properties properties) throws IOException {
		 List<String> paramFiles2 = new ArrayList<String>();
		 for (String param: paramFiles) {
			 FileLocalizer.FetchFileRet localFileRet = FileLocalizer.fetchFile(properties, param);
			 paramFiles2.add(localFileRet.file.getAbsolutePath());
		 }
		 return paramFiles2;
	 }
	 private static BufferedReader runParamPreprocessor(PigContext context, BufferedReader origPigScript, String scriptFile, boolean createFile) throws org.apache.pig.tools.parameters.ParseException, IOException{
		 if (createFile) {
			 return context.doParamSubstitutionOutputToFile(origPigScript, scriptFile);
		 }
		 else {
			 String substituted = context.doParamSubstitution(origPigScript);
			 return new BufferedReader(new StringReader(substituted));
		 }
	 }
	 public static String getMajorVersion() {
		 return majorVersion;
	 }
	 public static String getMinorVersion() {
		 return minorVersion;
	 }
	 public static String getPatchVersion() {
		 return patchVersion;
	 }
	 public static String getSvnRevision() {
		 return svnRevision;
	 }
	 public static String getBuildTime() {
		 return buildTime;
	 }
	 public static String getVersionString() {
		 return ""Apache Pig version "" + version + "" (r"" + svnRevision + "") \ncompiled ""+buildTime;
	 }
	 public static void usage() {
		 System.out.println(""\n""+getVersionString()+""\n"");
		 System.out.println(""USAGE: Pig [options] [-] : Run interactively in grunt shell."");
		 System.out.println("" Pig [options] -e[xecute] cmd [cmd ...] : Run cmd(s)."");
		 System.out.println("" Pig [options] [-f[ile]] file : Run cmds found in file."");
		 System.out.println("" options include:"");
		 System.out.println("" -4, -log4jconf - Log4j configuration file, overrides log conf"");
		 System.out.println("" -b, -brief - Brief logging (no timestamps)"");
		 System.out.println("" -c, -check - Syntax check"");
		 System.out.println("" -d, -debug - Debug level, INFO is default"");
		 System.out.println("" -e, -execute - Commands to execute (within quotes)"");
		 System.out.println("" -f, -file - Path to the script to execute"");
		 System.out.println("" -g, -embedded - ScriptEngine classname or keyword for the ScriptEngine"");
		 System.out.println("" -h, -help - Display this message. You can specify topic to get help for that topic."");
		 System.out.println("" properties is the only topic currently supported: -h properties."");
		 System.out.println("" -i, -version - Display version information"");
		 System.out.println("" -l, -logfile - Path to client side log file;
		 default is current working directory."");
		 System.out.println("" -m, -param_file - Path to the parameter file"");
		 System.out.println("" -p, -param - Key value pair of the form param=val"");
		 System.out.println("" -r, -dryrun - Produces script with substituted parameters. Script is not executed."");
		 System.out.println("" -t, -optimizer_off - Turn optimizations off. The following values are supported:"");
		 System.out.println("" ConstantCalculator - Calculate constants at compile time"");
		 System.out.println("" SplitFilter - Split filter conditions"");
		 System.out.println("" PushUpFilter - Filter as early as possible"");
		 System.out.println("" MergeFilter - Merge filter conditions"");
		 System.out.println("" PushDownForeachFlatten - Join or explode as late as possible"");
		 System.out.println("" LimitOptimizer - Limit as early as possible"");
		 System.out.println("" ColumnMapKeyPrune - Remove unused data"");
		 System.out.println("" AddForEach - Add ForEach to remove unneeded columns"");
		 System.out.println("" MergeForEach - Merge adjacent ForEach"");
		 System.out.println("" GroupByConstParallelSetter - Force parallel 1 for \""group all\"" statement"");
		 System.out.println("" PartitionFilterOptimizer - Pushdown partition filter conditions to loader implementing LoadMetaData"");
		 System.out.println("" PredicatePushdownOptimizer - Pushdown filter predicates to loader implementing LoadPredicatePushDown"");
		 System.out.println("" All - Disable all optimizations"");
		 System.out.println("" All optimizations listed here are enabled by default. Optimization values are case insensitive."");
		 System.out.println("" -v, -verbose - Print all error messages to screen"");
		 System.out.println("" -w, -warning - Turn warning logging on;
		 also turns warning aggregation off"");
		 System.out.println("" -x, -exectype - Set execution mode: local|mapreduce|tez, default is mapreduce."");
		 System.out.println("" -F, -stop_on_failure - Aborts execution on the first failed job;
		 default is off"");
		 System.out.println("" -M, -no_multiquery - Turn multiquery optimization off;
		 default is on"");
		 System.out.println("" -N, -no_fetch - Turn fetch optimization off;
		 default is on"");
		 System.out.println("" -P, -propertyFile - Path to property file"");
		 System.out.println("" -printCmdDebug - Overrides anything else and prints the actual command used to run Pig, including"");
		 System.out.println("" any environment variables that are set by the pig command."");
	 }
	 public static void printProperties(){
		 System.out.println(""The following properties are supported:"");
		 System.out.println("" Logging:"");
		 System.out.println("" verbose=true|false;
		 default is false. This property is the same as -v switch"");
		 System.out.println("" brief=true|false;
		 default is false. This property is the same as -b switch"");
		 System.out.println("" debug=OFF|ERROR|WARN|INFO|DEBUG;
		 default is INFO. This property is the same as -d switch"");
		 System.out.println("" aggregate.warning=true|false;
		 default is true. If true, prints count of warnings"");
		 System.out.println("" of each type rather than logging each warning."");
		 System.out.println("" Performance tuning:"");
		 System.out.println("" pig.cachedbag.memusage=<mem fraction>;
		 default is 0.2 (20% of all memory)."");
		 System.out.println("" Note that this memory is shared across all large bags used by the application."");
		 System.out.println("" pig.skewedjoin.reduce.memusagea=<mem fraction>;
		 default is 0.3 (30% of all memory)."");
		 System.out.println("" Specifies the fraction of heap available for the reducer to perform the join."");
		 System.out.println("" pig.exec.nocombiner=true|false;
		 default is false. "");
		 System.out.println("" Only disable combiner as a temporary workaround for problems."");
		 System.out.println("" opt.multiquery=true|false;
		 multiquery is on by default."");
		 System.out.println("" Only disable multiquery as a temporary workaround for problems."");
		 System.out.println("" opt.fetch=true|false;
		 fetch is on by default."");
		 System.out.println("" Scripts containing Filter, Foreach, Limit, Stream, and Union can be dumped without MR jobs."");
		 System.out.println("" pig.tmpfilecompression=true|false;
		 compression is off by default."");
		 System.out.println("" Determines whether output of intermediate jobs is compressed."");
		 System.out.println("" pig.tmpfilecompression.codec=lzo|gzip;
		 default is gzip."");
		 System.out.println("" Used in conjunction with pig.tmpfilecompression. Defines compression type."");
		 System.out.println("" pig.noSplitCombination=true|false. Split combination is on by default."");
		 System.out.println("" Determines if multiple small files are combined into a single map."");
		 System.out.println("" pig.exec.mapPartAgg=true|false. Default is false."");
		 System.out.println("" Determines if partial aggregation is done within map phase, "");
		 System.out.println("" before records are sent to combiner."");
		 System.out.println("" pig.exec.mapPartAgg.minReduction=<min aggregation factor>. Default is 10."");
		 System.out.println("" If the in-map partial aggregation does not reduce the output num records"");
		 System.out.println("" by this factor, it gets disabled."");
		 System.out.println("" Miscellaneous:"");
		 System.out.println("" exectype=mapreduce|tez|local;
		 default is mapreduce. This property is the same as -x switch"");
		 System.out.println("" pig.additional.jars.uris=<comma seperated list of jars>. Used in place of register command."");
		 System.out.println("" udf.import.list=<Colon seperated list of imports>. Used to avoid package names in UDF."");
		 System.out.println("" stop.on.failure=true|false;
		 default is false. Set to true to terminate on the first error."");
		 System.out.println("" pig.datetime.default.tz=<UTC time offset>. e.g. +08:00. Default is the default timezone of the host."");
		 System.out.println("" Determines the timezone used to handle datetime datatype and UDFs. "");
		 System.out.println("" pig.artifacts.download.location=<path to download artifacts>;
		 default is ~/.groovy/grapes"");
		 System.out.println("" Determines the location to download the artifacts when registering jars using ivy coordinates."");
		 System.out.println(""Additionally, any Hadoop property can be specified."");
	 }
	 private static String validateLogFile(String logFileName, File scriptFile) {
		 String strippedDownScriptName = null;
		 if (scriptFile != null) {
			 if(!scriptFile.isDirectory()) {
				 String scriptFileAbsPath;
				 try {
					 scriptFileAbsPath = scriptFile.getCanonicalPath();
					 strippedDownScriptName = getFileFromCanonicalPath(scriptFileAbsPath);
				 }
				 catch (IOException ioe) {
					 log.warn(""Could not compute canonical path to the script file "" + ioe.getMessage());
					 strippedDownScriptName = null;
				 }
			 }
		 }
		 String defaultLogFileName = (strippedDownScriptName == null ? ""pig_"" : strippedDownScriptName) + new Date().getTime() + "".log"";
		 File logFile;
		 if(logFileName != null) {
			 logFile = new File(logFileName);
			 if(logFile.isDirectory()) {
				 if(logFile.canWrite()) {
					 try {
						 logFileName = logFile.getCanonicalPath() + File.separator + defaultLogFileName;
					 }
					 catch (IOException ioe) {
						 log.warn(""Could not compute canonical path to the log file "" + ioe.getMessage());
						 return null;
					 }
					 return logFileName;
				 }
				 else {
					 log.warn(""Need write permission in the directory: "" + logFileName + "" to create log file."");
					 return null;
				 }
			 }
			 else {
				 if (logFile.exists()) {
					 if(logFile.canWrite()) {
						 try {
							 logFileName = new File(logFileName).getCanonicalPath();
						 }
						 catch (IOException ioe) {
							 log.warn(""Could not compute canonical path to the log file "" + ioe.getMessage());
							 return null;
						 }
						 return logFileName;
					 }
					 else {
						 log.warn(""Cannot write to file: "" + logFileName + "". Need write permission."");
						 return logFileName;
					 }
				 }
				 else {
					 logFile = logFile.getParentFile();
					 if(logFile != null) {
						 if(logFile.canWrite()) {
							 try {
								 logFileName = new File(logFileName).getCanonicalPath();
							 }
							 catch (IOException ioe) {
								 log.warn(""Could not compute canonical path to the log file "" + ioe.getMessage());
								 return null;
							 }
							 return logFileName;
						 }
						 else {
							 log.warn(""Need write permission in the directory: "" + logFile + "" to create log file."");
							 return logFileName;
						 }
					 }
				 }
			 }
		 }
		 String currDir = System.getProperty(""user.dir"");
		 logFile = new File(currDir);
		 logFileName = currDir + File.separator + (logFileName == null? defaultLogFileName : logFileName);
		 if(logFile.canWrite()) {
			 return logFileName;
		 }
		 log.warn(""Cannot write to log file: "" + logFileName);
		 return null;
	 }
	 private static String getFileFromCanonicalPath(String canonicalPath) {
		 return canonicalPath.substring(canonicalPath.lastIndexOf(File.separator));
	 }
	 private static SupportedScriptLang determineScriptType(String file) throws IOException {
		 return ScriptEngine.getSupportedScriptLang(file);
	 }
	 private static int runEmbeddedScript(PigContext pigContext, String file, String engine) throws IOException {
		 log.info(""Run embedded script: "" + engine);
		 pigContext.connect();
		 ScriptEngine scriptEngine = ScriptEngine.getInstance(engine);
		 Map<String, List<PigStats>> statsMap = scriptEngine.run(pigContext, file);
		 PigStatsUtil.setStatsMap(statsMap);
		 int failCount = 0;
		 int totalCount = 0;
		 for (List<PigStats> lst : statsMap.values()) {
			 if (lst != null && !lst.isEmpty()) {
				 for (PigStats stats : lst) {
					 if (!stats.isSuccessful()) failCount++;
					 totalCount++;
				 }
			 }
		 }
		 return (totalCount > 0 && failCount == totalCount) ? ReturnCode.FAILURE : (failCount > 0) ? ReturnCode.PARTIAL_FAILURE : ReturnCode.SUCCESS;
	 }
}",1,0,0,0
"public class TestSeqMethods extends AbstractContainerMethods{
	public static TestSuite suite(){
		return new TestSuite(TestSeqMethods.class);
	}
	protected LitTestObj aLitTestObj;
	protected Literal tvLiteral;
	protected Resource tvResource;
	protected Object anObject;
	protected Bag tvBag;
	protected Alt tvAlt;
	protected Seq tvSeq;
	protected static final String lang = ""fr"";
	protected static final int num = 10;
	public TestSeqMethods( final TestingModelFactory modelFactory,final String name ){
		super(modelFactory, name);
	}
	protected boolean[] bools( final String s ){
		final boolean[] result = new boolean[s.length()];
		for (int i = 0;
		 i < s.length();
		 i += 1){
			result[i] = s.charAt(i) == 't';
		}
		return result;
	}
	protected Container createContainer(){
		return model.createSeq();
	}
	public void error( final String test, final int n ){
		Assert.fail(test + "" -- "" + n);
	}
	protected Resource getContainerType(){
		return RDF.Seq;
	}
	public void setUp(){
		super.setUp();
		aLitTestObj = new LitTestObj(12345);
		tvLiteral = model.createLiteral(""test 12 string 2"");
		tvResource = model.createResource();
		anObject = new LitTestObj(1234);
		tvBag = model.createBag();
		tvAlt = model.createAlt();
		tvSeq = model.createSeq();
	}
	public void testMoreIndexing(){
		final int num = 10;
		final Seq seq = model.createSeq();
		for (int i = 0;
		 i < num;
		 i += 1){
			seq.add(i);
		}
		try{
			seq.add(0, false);
			Assert.fail(""cannot at at position 0"");
		}
		catch (final SeqIndexBoundsException e){
			JenaTestBase.pass();
		}
		seq.add(num + 1, false);
		Assert.assertEquals(num + 1, seq.size());
		seq.remove(num + 1);
		try{
			seq.add(num + 2, false);
			Assert.fail(""cannot add past the end"");
		}
		catch (final SeqIndexBoundsException e){
			JenaTestBase.pass();
		}
		final int size = seq.size();
		for (int i = 1;
		 i <= (num - 1);
		 i += 1){
			seq.add(i, 1000 + i);
			Assert.assertEquals(1000 + i, seq.getInt(i));
			Assert.assertEquals(0, seq.getInt(i + 1));
			Assert.assertEquals(size + i, seq.size());
			Assert.assertEquals(num - i - 1, seq.getInt(size));
		}
	}
	protected void testRemove( final boolean[] retain ){
		final int num = retain.length;
		final Seq seq = model.createSeq();
		for (int i = 0;
		 i < num;
		 i += 1){
			seq.add(i);
		}
		final List<RDFNode> retained = new ArrayList<>();
		final NodeIterator nIter = seq.iterator();
		 for ( boolean aRetain : retain ) {
			 final RDFNode x = nIter.nextNode();
			 if ( aRetain ) {
				 retained.add( x );
			 }
			 else {
				 nIter.remove();
			 }
		 }
		Assert.assertFalse(nIter.hasNext());
		Assert.assertEquals(retained, seq.iterator().toList());
	}
	public void testRemoveA(){
		testRemove(bools(""tttffffftt""));
	}
	public void testRemoveB(){
		testRemove(bools(""ftftttttft""));
	}
	public void testRemoveC(){
		testRemove(bools(""ffffffffff""));
	}
	public void testSeq4(){
		final String test = ""temp"";
		int n = 58305;
		final Seq seq4 = model.createSeq();
		n = ((n / 100) * 100) + 100;
		n++;
		seq4.add(AbstractModelTestBase.tvBoolean);
		n++;
		if (!(seq4.getBoolean(1) == AbstractModelTestBase.tvBoolean)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvByte);
		n++;
		if (!(seq4.getByte(2) == AbstractModelTestBase.tvByte)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvShort);
		n++;
		if (!(seq4.getShort(3) == AbstractModelTestBase.tvShort)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvInt);
		n++;
		if (!(seq4.getInt(4) == AbstractModelTestBase.tvInt)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvLong);
		n++;
		if (!(seq4.getLong(5) == AbstractModelTestBase.tvLong)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvChar);
		n++;
		if (!(seq4.getChar(6) == AbstractModelTestBase.tvChar)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvFloat);
		n++;
		if (!(seq4.getFloat(7) == AbstractModelTestBase.tvFloat)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvDouble);
		n++;
		if (!(seq4.getDouble(8) == AbstractModelTestBase.tvDouble)){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvString);
		n++;
		if (!(seq4.getString(9).equals(AbstractModelTestBase.tvString))){
			error(test, n);
		}
		n++;
		if (!(seq4.getLanguage(9).equals(""""))){
			error(test, n);
		}
		n++;
		seq4.add(AbstractModelTestBase.tvString, TestSeqMethods.lang);
		n++;
		if (!(seq4.getString(10).equals(AbstractModelTestBase.tvString))){
			error(test, n);
		}
		n++;
		if (!(seq4.getLanguage(10).equals(TestSeqMethods.lang))){
			error(test, n);
		}
		n++;
		seq4.add(anObject);
		n++;
		n++;
		seq4.add(tvResource);
		n++;
		if (!(seq4.getResource(12).equals(tvResource))){
			error(test, n);
		}
		n++;
		seq4.add(tvLiteral);
		n++;
		if (!(seq4.getLiteral(13).equals(tvLiteral))){
			error(test, n);
		}
		n++;
		n++;
		seq4.add(tvBag);
		n++;
		if (!(seq4.getBag(14).equals(tvBag))){
			error(test, n);
		}
		n++;
		seq4.add(tvAlt);
		n++;
		if (!(seq4.getAlt(15).equals(tvAlt))){
			error(test, n);
		}
		n++;
		seq4.add(tvSeq);
		n++;
		if (!(seq4.getSeq(16).equals(tvSeq))){
			error(test, n);
		}
		n++;
		try{
			seq4.getInt(17);
			error(test, n);
		}
		catch (final SeqIndexBoundsException e){
		}
		n++;
		try{
			seq4.getInt(0);
			error(test, n);
		}
		catch (final SeqIndexBoundsException e){
		}
	}
	public void testSeq5(){
		final Seq seq5 = model.createSeq();
		final String test = ""seq5"";
		int n = 0;
		for (int i = 0;
		 i < TestSeqMethods.num;
		 i++){
			seq5.add(i);
		}
		try{
			n++;
			seq5.add(0, false);
			error(test, n);
		}
		catch (final SeqIndexBoundsException e){
		}
		seq5.add(TestSeqMethods.num + 1, false);
		if (seq5.size() != (TestSeqMethods.num + 1)){
			error(test, n);
		}
		seq5.remove(TestSeqMethods.num + 1);
		try{
			n++;
			seq5.add(TestSeqMethods.num + 2, false);
			error(test, n);
		}
		catch (final SeqIndexBoundsException e){
		}
		n = ((n / 100) * 100) + 100;
		final int size = seq5.size();
		for (int i = 1;
		 i <= (TestSeqMethods.num - 1);
		 i++){
			n++;
			seq5.add(i, 1000 + i);
			n++;
			if (!(seq5.getInt(i) == (1000 + i))){
				error(test, n);
			}
			n++;
			if (!(seq5.getInt(i + 1) == 0)){
				error(test, n);
			}
			n++;
			if (!(seq5.size() == (size + i))){
				error(test, n);
			}
			n++;
			if (!(seq5.getInt(size) == (TestSeqMethods.num - i - 1))){
				error(test, n);
			}
		}
	}
	public void testSeq6(){
		final String test = ""seq6"";
		int n = 0;
		final Seq seq6 = model.createSeq();
		seq6.add(model.createResource());
		seq6.add(1, AbstractModelTestBase.tvBoolean);
		n++;
		if (!(seq6.getBoolean(1) == AbstractModelTestBase.tvBoolean)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvByte);
		n++;
		if (!(seq6.getByte(1) == AbstractModelTestBase.tvByte)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvShort);
		n++;
		if (!(seq6.getShort(1) == AbstractModelTestBase.tvShort)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvInt);
		n++;
		if (!(seq6.getInt(1) == AbstractModelTestBase.tvInt)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvLong);
		n++;
		if (!(seq6.getLong(1) == AbstractModelTestBase.tvLong)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvChar);
		n++;
		if (!(seq6.getChar(1) == AbstractModelTestBase.tvChar)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvFloat);
		n++;
		if (!(seq6.getFloat(1) == AbstractModelTestBase.tvFloat)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvDouble);
		n++;
		if (!(seq6.getDouble(1) == AbstractModelTestBase.tvDouble)){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvString);
		n++;
		if (!(seq6.getString(1).equals(AbstractModelTestBase.tvString))){
			error(test, n);
		}
		seq6.add(1, AbstractModelTestBase.tvString, TestSeqMethods.lang);
		n++;
		if (!(seq6.getString(1).equals(AbstractModelTestBase.tvString))){
			error(test, n);
		}
		seq6.add(1, tvResource);
		n++;
		if (!(seq6.getResource(1).equals(tvResource))){
			error(test, n);
		}
		seq6.add(1, tvLiteral);
		n++;
		if (!(seq6.getLiteral(1).equals(tvLiteral))){
			error(test, n);
		}
		seq6.add(1, anObject);
		n++;
		n = ((n / 100) * 100) + 100;
		n++;
		if (!(seq6.indexOf(anObject) == 1)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(tvLiteral) == 2)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(tvResource) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvString, TestSeqMethods.lang) == 4)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvString) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvDouble) == 6)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvFloat) == 7)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvChar) == 8)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvLong) == 9)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvInt) == 10)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvShort) == 11)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvByte) == 12)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(AbstractModelTestBase.tvBoolean) == 13)){
			error(test, n);
		}
		n++;
		if (!(seq6.indexOf(1234543) == 0)){
			error(test, n);
		}
	}
	public void testSeq7(){
		final Seq seq7 = model.createSeq();
		final String test = ""seq7"";
		int n = 0;
		n = ((n / 100) * 100) + 100;
		for (int i = 0;
		 i < TestSeqMethods.num;
		 i++){
			seq7.add(i);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvBoolean);
		n++;
		if (!(seq7.getBoolean(5) == AbstractModelTestBase.tvBoolean)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvByte);
		n++;
		if (!(seq7.getByte(5) == AbstractModelTestBase.tvByte)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvShort);
		n++;
		if (!(seq7.getShort(5) == AbstractModelTestBase.tvShort)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvInt);
		n++;
		if (!(seq7.getInt(5) == AbstractModelTestBase.tvInt)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvLong);
		n++;
		if (!(seq7.getLong(5) == AbstractModelTestBase.tvLong)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvChar);
		n++;
		if (!(seq7.getChar(5) == AbstractModelTestBase.tvChar)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvFloat);
		n++;
		if (!(seq7.getFloat(5) == AbstractModelTestBase.tvFloat)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvDouble);
		n++;
		if (!(seq7.getDouble(5) == AbstractModelTestBase.tvDouble)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, AbstractModelTestBase.tvString);
		n++;
		if (!(seq7.getString(5).equals(AbstractModelTestBase.tvString))){
			error(test, n);
		}
		n++;
		if (!(seq7.getLanguage(5).equals(""""))){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		seq7.set(5, AbstractModelTestBase.tvString, TestSeqMethods.lang);
		n++;
		if (!(seq7.getString(5).equals(AbstractModelTestBase.tvString))){
			error(test, n);
		}
		n++;
		if (!(seq7.getLanguage(5).equals(TestSeqMethods.lang))){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, tvLiteral);
		n++;
		if (!(seq7.getLiteral(5).equals(tvLiteral))){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, tvResource);
		n++;
		if (!(seq7.getResource(5).equals(tvResource))){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		seq7.set(5, anObject);
		n++;
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
		n = ((n / 100) * 100) + 100;
		n++;
		if (!(seq7.getInt(4) == 3)){
			error(test, n);
		}
		n++;
		if (!(seq7.getInt(6) == 5)){
			error(test, n);
		}
		n++;
		if (!(seq7.size() == TestSeqMethods.num)){
			error(test, n);
		}
	}
	public void testSeqAccessByIndexing(){
		final Literal tvLiteral = model.createLiteral(""test 12 string 2"");
		final Resource tvResource = model.createResource();
		final Object tvLitObj = new LitTestObj(1234);
		final Bag tvBag = model.createBag();
		final Alt tvAlt = model.createAlt();
		final Seq tvSeq = model.createSeq();
		final Seq seq = model.createSeq();
		seq.add(true);
		Assert.assertEquals(true, seq.getBoolean(1));
		seq.add((byte) 1);
		Assert.assertEquals((byte) 1, seq.getByte(2));
		seq.add((short) 2);
		Assert.assertEquals((short) 2, seq.getShort(3));
		seq.add(-1);
		Assert.assertEquals(-1, seq.getInt(4));
		seq.add(-2);
		Assert.assertEquals(-2, seq.getLong(5));
		seq.add('!');
		Assert.assertEquals('!', seq.getChar(6));
		seq.add(123.456f);
		Assert.assertEquals(123.456f, seq.getFloat(7), 0.00005);
		seq.add(12345.67890);
		Assert.assertEquals(12345.67890, seq.getDouble(8), 0.00000005);
		seq.add(""some string"");
		Assert.assertEquals(""some string"", seq.getString(9));
		seq.add(tvLitObj);
		seq.add(tvResource);
		Assert.assertEquals(tvResource, seq.getResource(11));
		seq.add(tvLiteral);
		Assert.assertEquals(tvLiteral, seq.getLiteral(12));
		seq.add(tvBag);
		Assert.assertEquals(tvBag, seq.getBag(13));
		seq.add(tvAlt);
		Assert.assertEquals(tvAlt, seq.getAlt(14));
		seq.add(tvSeq);
		Assert.assertEquals(tvSeq, seq.getSeq(15));
		try{
			seq.getInt(16);
			Assert.fail(""there is no element 16"");
		}
		catch (final SeqIndexBoundsException e){
			JenaTestBase.pass();
		}
		try{
			seq.getInt(0);
			Assert.fail(""there is no element 0"");
		}
		catch (final SeqIndexBoundsException e){
			JenaTestBase.pass();
		}
	}
	public void testSeqAdd(){
		final Seq seq = model.createSeq();
		Assert.assertEquals(0, seq.size());
		Assert.assertTrue(model.contains(seq, RDF.type, RDF.Seq));
		seq.add(AbstractModelTestBase.tvBoolean);
		Assert.assertTrue(seq.contains(AbstractModelTestBase.tvBoolean));
		Assert.assertFalse(seq.contains(!AbstractModelTestBase.tvBoolean));
		seq.add(AbstractModelTestBase.tvByte);
		Assert.assertTrue(seq.contains(AbstractModelTestBase.tvByte));
		Assert.assertFalse(seq.contains((byte) 101));
		seq.add(AbstractModelTestBase.tvShort);
		Assert.assertTrue(seq.contains(AbstractModelTestBase.tvShort));
		Assert.assertFalse(seq.contains((short) 102));
		seq.add(AbstractModelTestBase.tvInt);
		Assert.assertTrue(seq.contains(AbstractModelTestBase.tvInt));
		Assert.assertFalse(seq.contains(-101));
		seq.add(AbstractModelTestBase.tvLong);
		Assert.assertTrue(seq.contains(AbstractModelTestBase.tvLong));
		Assert.assertFalse(seq.contains(-102));
		seq.add(AbstractModelTestBase.tvChar);
		Assert.assertTrue(seq.contains(AbstractModelTestBase.tvChar));
		Assert.assertFalse(seq.contains('?'));
		seq.add(123.456f);
		Assert.assertTrue(seq.contains(123.456f));
		Assert.assertFalse(seq.contains(456.123f));
		seq.add(-123.456d);
		Assert.assertTrue(seq.contains(-123.456d));
		Assert.assertFalse(seq.contains(-456.123d));
		seq.add(""a string"");
		Assert.assertTrue(seq.contains(""a string""));
		Assert.assertFalse(seq.contains(""a necklace""));
		seq.add(model.createLiteral(""another string""));
		Assert.assertTrue(seq.contains(""another string""));
		Assert.assertFalse(seq.contains(""another necklace""));
		seq.add(new LitTestObj(12345));
		Assert.assertTrue(seq.contains(new LitTestObj(12345)));
		Assert.assertFalse(seq.contains(new LitTestObj(54321)));
		Assert.assertEquals(11, seq.size());
	}
	public void testSeqAddInts(){
		final int num = 10;
		final Seq seq = model.createSeq();
		for (int i = 0;
		 i < num;
		 i += 1){
			seq.add(i);
		}
		Assert.assertEquals(num, seq.size());
		final List<RDFNode> L = seq.iterator().toList();
		Assert.assertEquals(num, L.size());
		for (int i = 0;
		 i < num;
		 i += 1){
			Assert.assertEquals(i, ((Literal) L.get(i)).getInt());
		}
	}
	public void testSeqInsertByIndexing(){
		final Literal tvLiteral = model.createLiteral(""test 12 string 2"");
		final Resource tvResource = model.createResource();
		final Object tvLitObj = new LitTestObj(1234);
		final Bag tvBag = model.createBag();
		final Alt tvAlt = model.createAlt();
		final Seq tvSeq = model.createSeq();
		final Seq seq = model.createSeq();
		seq.add(model.createResource());
		seq.add(1, true);
		Assert.assertEquals(true, seq.getBoolean(1));
		seq.add(1, (byte) 1);
		Assert.assertEquals((byte) 1, seq.getByte(1));
		seq.add(1, (short) 2);
		Assert.assertEquals((short) 2, seq.getShort(1));
		seq.add(1, -1);
		Assert.assertEquals(-1, seq.getInt(1));
		seq.add(1, -2);
		Assert.assertEquals(-2, seq.getLong(1));
		seq.add(1, '!');
		Assert.assertEquals('!', seq.getChar(1));
		seq.add(1, 123.456f);
		Assert.assertEquals(123.456f, seq.getFloat(1), 0.00005);
		seq.add(1, 12345.67890);
		Assert.assertEquals(12345.67890, seq.getDouble(1), 0.00000005);
		seq.add(1, ""some string"");
		Assert.assertEquals(""some string"", seq.getString(1));
		seq.add(1, tvLitObj);
		seq.add(1, tvResource);
		Assert.assertEquals(tvResource, seq.getResource(1));
		seq.add(1, tvLiteral);
		Assert.assertEquals(tvLiteral, seq.getLiteral(1));
		seq.add(1, tvBag);
		Assert.assertEquals(tvBag, seq.getBag(1));
		seq.add(1, tvAlt);
		Assert.assertEquals(tvAlt, seq.getAlt(1));
		seq.add(1, tvSeq);
		Assert.assertEquals(tvSeq, seq.getSeq(1));
		Assert.assertEquals(0, seq.indexOf(1234543));
		Assert.assertEquals(1, seq.indexOf(tvSeq));
		Assert.assertEquals(2, seq.indexOf(tvAlt));
		Assert.assertEquals(3, seq.indexOf(tvBag));
		Assert.assertEquals(4, seq.indexOf(tvLiteral));
		Assert.assertEquals(5, seq.indexOf(tvResource));
		Assert.assertEquals(6, seq.indexOf(tvLitObj));
		Assert.assertEquals(7, seq.indexOf(""some string""));
		Assert.assertEquals(8, seq.indexOf(12345.67890));
		Assert.assertEquals(9, seq.indexOf(123.456f));
		Assert.assertEquals(10, seq.indexOf('!'));
		Assert.assertEquals(11, seq.indexOf(-2));
		Assert.assertEquals(12, seq.indexOf(-1));
		Assert.assertEquals(13, seq.indexOf((short) 2));
		Assert.assertEquals(14, seq.indexOf((byte) 1));
		Assert.assertEquals(15, seq.indexOf(true));
	}
	public void testSet(){
		final Literal tvLiteral = model.createLiteral(""test 12 string 2"");
		final Resource tvResource = model.createResource();
		final int num = 10;
		final Seq seq = model.createSeq();
		for (int i = 0;
		 i < num;
		 i++){
			seq.add(i);
		}
		seq.set(5, AbstractModelTestBase.tvBoolean);
		Assert.assertEquals(AbstractModelTestBase.tvBoolean, seq.getBoolean(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvByte);
		Assert.assertEquals(AbstractModelTestBase.tvByte, seq.getByte(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvShort);
		Assert.assertEquals(AbstractModelTestBase.tvShort, seq.getShort(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvInt);
		Assert.assertEquals(AbstractModelTestBase.tvInt, seq.getInt(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvLong);
		Assert.assertEquals(AbstractModelTestBase.tvLong, seq.getLong(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvString);
		Assert.assertEquals(AbstractModelTestBase.tvString, seq.getString(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvBoolean);
		Assert.assertEquals(AbstractModelTestBase.tvBoolean, seq.getBoolean(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvFloat);
		Assert.assertEquals(AbstractModelTestBase.tvFloat, seq.getFloat(5),0.00005);
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvDouble);
		Assert.assertEquals(AbstractModelTestBase.tvDouble, seq.getDouble(5),0.000000005);
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, tvLiteral);
		Assert.assertEquals(tvLiteral, seq.getLiteral(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, tvResource);
		Assert.assertEquals(tvResource, seq.getResource(5));
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
		seq.set(5, AbstractModelTestBase.tvLitObj);
		Assert.assertEquals(3, seq.getInt(4));
		Assert.assertEquals(5, seq.getInt(6));
		Assert.assertEquals(num, seq.size());
	}
}",1,0,0,0
"public void setIncludeFileNames(boolean b) {
	 this.includeFileNames = b;
 }",0,0,0,0
"public class LongConverter extends AbstractIntegerConverter{
	private static final long serialVersionUID = 1L;
	public static final IConverter INSTANCE = new LongConverter();
	public Long convertToObject(final String value, Locale locale){
		final Number number = parse(value, Long.MIN_VALUE, Long.MAX_VALUE, locale);
		if (number == null){
			return null;
		}
		return new Long(number.longValue());
	}
	protected Class<Long> getTargetType(){
		return Long.class;
	}
}",0,0,0,0
"public JRGridLayout(ExporterNature nature,List elements,int width,int height,int offsetX,int offsetY,CutsInfo xCuts);",0,0,0,1
"public boolean chunkComplete(String id) {
	if (finished) {
		return true;
	}
	if (stopFlag) {
		return true;
	}
	if (id.equals(manifestSegment.getId())) {
		if (initOrUpdateSegments()) {
			listener.downloadConfirmed(this.id);
		}
		 else {
			if (!stopFlag) {
				this.errorCode = XDMConstants.ERR_INVALID_RESP;
				listener.downloadFailed(this.id);
				return true;
			}
		}
	}
	 else {
		Segment s = getById(id);
		if (s.getLength() < 0) {
			s.setLength(s.getDownloaded());
		}
		if (allFinished()) {
			finished = true;
			long len = 0L;
			for (Segment ss : chunks) {
				len += ss.getLength();
			}
			if (len > 0) {
				this.length = len;
			}
			saveState();
			updateStatus();
			try {
				assembleFinished = false;
				assemble();
				Logger.log(""********Download finished*********"");
				updateStatus();
				assembleFinished = true;
				listener.downloadFinished(this.id);
			}
			 catch (Exception e) {
				if (!stopFlag) {
					Logger.log(e);
					this.errorCode = XDMConstants.ERR_ASM_FAILED;
					listener.downloadFailed(this.id);
				}
			}
			listener = null;
			return true;
		}
	}
	processSegments();
	return true;
}",0,0,1,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 int width = originalImage.getWidth();
	 int height = originalImage.getHeight();
	 boolean[][] matrix = new boolean[width][height];
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 int[] histogram = imageHistogram(originalImage);
	 int totalNumberOfpixels = height * width;
	 int threshold = threshold(histogram, totalNumberOfpixels);
	 int black = 0;
	 int white = 255;
	 int gray;
	 int alpha;
	 int newColor;
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 gray = new Color(originalImage.getRGB(i, j)).getRed();
			 if (gray > threshold) {
				 matrix[i][j] = false;
			 }
			 else {
				 matrix[i][j] = true;
			 }
		 }
	 }
	 int blackTreshold = letterThreshold(originalImage, matrix);
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 gray = new Color(originalImage.getRGB(i, j)).getRed();
			 alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 if (gray > blackTreshold) {
				 newColor = white;
			 }
			 else {
				 newColor = black;
			 }
			 newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
			 filteredImage.setRGB(i, j, newColor);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public class BooleanType extends AbstractType<Boolean>{
	 public static final BooleanType instance = new BooleanType();
	 BooleanType() {
	}
	 public Boolean compose(ByteBuffer bytes) {
		 return JdbcBoolean.instance.compose(bytes);
	 }
	 public ByteBuffer decompose(Boolean value) {
		 return JdbcBoolean.instance.decompose(value);
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 if ((o1 == null) || (o1.remaining() != 1)) return ((o2 == null) || (o2.remaining() != 1)) ? 0 : -1;
		 if ((o2 == null) || (o2.remaining() != 1)) return 1;
		 return o1.compareTo(o2);
	 }
	 public String getString(ByteBuffer bytes) {
		 try {
			 return JdbcBoolean.instance.getString(bytes);
		 }
		 catch (org.apache.cassandra.cql.jdbc.MarshalException e) {
			 throw new MarshalException(e.getMessage());
		 }
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()|| source.equalsIgnoreCase(Boolean.FALSE.toString())) return decompose(false);
		 if (source.equalsIgnoreCase(Boolean.TRUE.toString())) return decompose(true);
		 throw new MarshalException(String.format(""unable to make boolean from '%s'"", source));
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 if (bytes.remaining() != 1 && bytes.remaining() != 0) throw new MarshalException(String.format(""Expected 1 or 0 byte value (%d)"", bytes.remaining()));
	 }
}",0,0,0,0
"public abstract class SOS extends Task implements SOSCmd {
	 private static final int ERROR_EXIT_STATUS = 255;
	 private String sosCmdDir = null;
	 private String sosUsername = null;
	 private String sosPassword = """";
	 private String projectPath = null;
	 private String vssServerPath = null;
	 private String sosServerPath = null;
	 private String sosHome = null;
	 private String localPath = null;
	 private String version = null;
	 private String label = null;
	 private String comment = null;
	 private String filename = null;
	 private boolean noCompress = false;
	 private boolean noCache = false;
	 private boolean recursive = false;
	 private boolean verbose = false;
	 protected Commandline commandLine;
	 public final void setNoCache(boolean nocache) {
		 noCache = nocache;
	 }
	 public final void setNoCompress(boolean nocompress) {
		 noCompress = nocompress;
	 }
	 public final void setSosCmd(String dir) {
		 sosCmdDir = FileUtils.translatePath(dir);
	 }
	 public final void setUsername(String username) {
		 sosUsername = username;
	 }
	 public final void setPassword(String password) {
		 sosPassword = password;
	 }
	 public final void setProjectPath(String projectpath) {
		 if (projectpath.startsWith(SOSCmd.PROJECT_PREFIX)) {
			 projectPath = projectpath;
		 }
		 else {
			 projectPath = SOSCmd.PROJECT_PREFIX + projectpath;
		 }
	 }
	 public final void setVssServerPath(String vssServerPath) {
		 this.vssServerPath = vssServerPath;
	 }
	 public final void setSosHome(String sosHome) {
		 this.sosHome = sosHome;
	 }
	 public final void setSosServerPath(String sosServerPath) {
		 this.sosServerPath = sosServerPath;
	 }
	 public final void setLocalPath(Path path) {
		 localPath = path.toString();
	 }
	 public void setVerbose(boolean verbose) {
		 this.verbose = verbose;
	 }
	 protected void setInternalFilename(String file) {
		 filename = file;
	 }
	 protected void setInternalRecursive(boolean recurse) {
		 recursive = recurse;
	 }
	 protected void setInternalComment(String text) {
		 comment = text;
	 }
	 protected void setInternalLabel(String text) {
		 label = text;
	 }
	 protected void setInternalVersion(String text) {
		 version = text;
	 }
	 protected String getSosCommand() {
		 if (sosCmdDir == null) {
			 return COMMAND_SOS_EXE;
		 }
		 else {
			 return sosCmdDir + File.separator + COMMAND_SOS_EXE;
		 }
	 }
	 protected String getComment() {
		 return comment;
	 }
	 protected String getVersion() {
		 return version;
	 }
	 protected String getLabel() {
		 return label;
	 }
	 protected String getUsername() {
		 return sosUsername;
	 }
	 protected String getPassword() {
		 return sosPassword;
	 }
	 protected String getProjectPath() {
		 return projectPath;
	 }
	 protected String getVssServerPath() {
		 return vssServerPath;
	 }
	 protected String getSosHome() {
		 return sosHome;
	 }
	 protected String getSosServerPath() {
		 return sosServerPath;
	 }
	 protected String getFilename() {
		 return filename;
	 }
	 protected String getNoCompress() {
		 return noCompress ? FLAG_NO_COMPRESSION : """";
	 }
	 protected String getNoCache() {
		 return noCache ? FLAG_NO_CACHE : """";
	 }
	 protected String getVerbose() {
		 return verbose ? FLAG_VERBOSE : """";
	 }
	 protected String getRecursive() {
		 return recursive ? FLAG_RECURSION : """";
	 }
	 protected String getLocalPath() {
		 if (localPath == null) {
			 return getProject().getBaseDir().getAbsolutePath();
		 }
		 else {
			 File dir = getProject().resolveFile(localPath);
			 if (!dir.exists()) {
				 boolean done = dir.mkdirs();
				 if (!done) {
					 String msg = ""Directory "" + localPath + "" creation was not "" + ""successful for an unknown reason"";
					 throw new BuildException(msg, getLocation());
				 }
				 getProject().log(""Created dir: "" + dir.getAbsolutePath());
			 }
			 return dir.getAbsolutePath();
		 }
	 }
	 abstract Commandline buildCmdLine();
	 public void execute() throws BuildException {
		 int result = 0;
		 buildCmdLine();
		 result = run(commandLine);
		 if (result == ERROR_EXIT_STATUS) {
			 String msg = ""Failed executing: "" + commandLine.toString();
			 throw new BuildException(msg, getLocation());
		 }
	 }
	 protected int run(Commandline cmd) {
		 try {
			 Execute exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
			 exe.setAntRun(getProject());
			 exe.setWorkingDirectory(getProject().getBaseDir());
			 exe.setCommandline(cmd.getCommandline());
			 exe.setVMLauncher(false);
			 return exe.execute();
		 }
		 catch (java.io.IOException e) {
			 throw new BuildException(e, getLocation());
		 }
	 }
	 protected void getRequiredAttributes() {
		 commandLine.setExecutable(getSosCommand());
		 if (getSosServerPath() == null) {
			 throw new BuildException(""sosserverpath attribute must be set!"", getLocation());
		 }
		 commandLine.createArgument().setValue(FLAG_SOS_SERVER);
		 commandLine.createArgument().setValue(getSosServerPath());
		 if (getUsername() == null) {
			 throw new BuildException(""username attribute must be set!"", getLocation());
		 }
		 commandLine.createArgument().setValue(FLAG_USERNAME);
		 commandLine.createArgument().setValue(getUsername());
		 commandLine.createArgument().setValue(FLAG_PASSWORD);
		 commandLine.createArgument().setValue(getPassword());
		 if (getVssServerPath() == null) {
			 throw new BuildException(""vssserverpath attribute must be set!"", getLocation());
		 }
		 commandLine.createArgument().setValue(FLAG_VSS_SERVER);
		 commandLine.createArgument().setValue(getVssServerPath());
		 if (getProjectPath() == null) {
			 throw new BuildException(""projectpath attribute must be set!"", getLocation());
		 }
		 commandLine.createArgument().setValue(FLAG_PROJECT);
		 commandLine.createArgument().setValue(getProjectPath());
	 }
	 protected void getOptionalAttributes() {
		 commandLine.createArgument().setValue(getVerbose());
		 commandLine.createArgument().setValue(getNoCompress());
		 if (getSosHome() == null) {
			 commandLine.createArgument().setValue(getNoCache());
		 }
		 else {
			 commandLine.createArgument().setValue(FLAG_SOS_HOME);
			 commandLine.createArgument().setValue(getSosHome());
		 }
		 if (getLocalPath() != null) {
			 commandLine.createArgument().setValue(FLAG_WORKING_DIR);
			 commandLine.createArgument().setValue(getLocalPath());
		 }
	 }
}",0,0,0,0
"public class Field extends DefaultMutableTreeNode implements JagBean {
	 private StrutsValidation validations = new StrutsValidation();
	 private Relation relation;
	 private Entity parentEntity;
	 private boolean previousRequiredState;
	 private String oldName;
	 private static final ArrayList jdbcTypes = new ArrayList();
	 private boolean nullable = true;
	 private final static HashSet autogeneratablePrimaryKeyClasses = new HashSet();
	 static {
		 autogeneratablePrimaryKeyClasses.add(""java.lang.Byte"");
		 autogeneratablePrimaryKeyClasses.add(""java.lang.Double"");
		 autogeneratablePrimaryKeyClasses.add(""java.lang.Integer"");
		 autogeneratablePrimaryKeyClasses.add(""java.lang.Long"");
		 autogeneratablePrimaryKeyClasses.add(""java.lang.Short"");
		 autogeneratablePrimaryKeyClasses.add(""java.lang.String"");
		 java.lang.reflect.Field[] fields = java.sql.Types.class.getDeclaredFields();
		 for (int i = 0;
		 i < fields.length;
		 i++) {
			 jdbcTypes.add(fields[i].getName());
		 }
	 }
	 public Field(Entity parent, Column column) {
		 parentEntity = parent;
		 try {
			 init();
			 String name = Utils.format(column.getName());
			 nullable = column.isNullable();
			 nameText.setText(name);
			 oldName = name;
			 typeText.setText(getType(column));
			 columnNameText.setText(column.getName());
			 sqlTypeText.setText(getSqlType(column));
			 jdbcTypeComboBox.setSelectedItem(getJdbcType(column));
			 if (column.isPrimaryKey()) {
				 setPrimaryKey(column.isPrimaryKey());
			 }
			 if (primaryKeyCheckBox.isSelected()) {
				 autoGeneratedCheckBox.setSelected(isPkClassIsAutogeneratable());
			 }
			 requiredCheckBox.setSelected(!nullable);
			 regenerateValidations();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 public Field(Entity parent, Element el) {
		 parentEntity = parent;
		 try {
			 init();
			 NodeList nl = el.getElementsByTagName(""module-data"");
			 for (int i = 0;
			 i < nl.getLength();
			 i++) {
				 Element child = (Element) nl.item(i);
				 String attName = child.getAttribute(""name"");
				 String value = null;
				 if (child.getFirstChild() != null) value = child.getFirstChild().getNodeValue();
				 if (value != null) {
					 if (attName.equalsIgnoreCase(""name"")) {
						 nameText.setText(value);
						 oldName = value;
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""type"")) {
						 typeText.setText(value);
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""column-name"")) {
						 columnNameText.setText(value);
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""required"")) {
						 boolean required = ""true"".equalsIgnoreCase(value);
						 nullable = !required;
						 requiredCheckBox.setSelected(required);
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""sql-type"")) {
						 sqlTypeText.setText(value);
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""jdbc-type"")) {
						 jdbcTypeComboBox.setSelectedItem(value);
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""primary-key"")) {
						 if (""true"".equalsIgnoreCase(value)) {
							 setPrimaryKey(true);
						 }
						 else {
							 primaryKeyCheckBox.setSelected(false);
						 }
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""auto-primary-key"")) {
						 autoGeneratedCheckBox.setSelected(""true"".equalsIgnoreCase(value) && isPkClassIsAutogeneratable());
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""foreign-key"")) {
						 setForeignKey(""true"".equalsIgnoreCase(value.trim()));
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""validation-depends"")) {
						 if (value != null) {
							 validations.setDependsList(value);
							 validationDependsText.setText(value);
						 }
						 else {
							 validationDependsText.setText("""");
						 }
						 continue;
					 }
					 if (attName.equalsIgnoreCase(""validation-xml"")) {
						 if (value != null) {
							 validations.setXml(value);
							 validationXMLTextArea.setText(value);
						 }
						 else {
							 validationXMLTextArea.setText("""");
						 }
						 continue;
					 }
				 }
			 }
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 public String toString() {
		 return nameText.getText();
	 }
	 public JPanel getPanel() {
		 return panel;
	 }
	 public void getXML(Element el) {
		 Document doc = el.getOwnerDocument();
		 Element module = doc.createElement(""module-data"");
		 module.setAttribute(""name"", ""field"");
		 Element name = doc.createElement(""module-data"");
		 name.setAttribute(""name"", ""name"");
		 if (nameText.getText() != null) {
			 if (nameText.getText() != null) {
				 name.appendChild(doc.createTextNode(nameText.getText()));
			 }
		 }
		 module.appendChild(name);
		 Element type = doc.createElement(""module-data"");
		 type.setAttribute(""name"", ""type"");
		 if (typeText.getText() != null) {
			 type.appendChild(doc.createTextNode(typeText.getText()));
		 }
		 module.appendChild(type);
		 Element columnName = doc.createElement(""module-data"");
		 columnName.setAttribute(""name"", ""column-name"");
		 if (columnNameText.getText() != null) {
			 columnName.appendChild(doc.createTextNode(columnNameText.getText()));
		 }
		 module.appendChild(columnName);
		 Element required = doc.createElement(""module-data"");
		 required.setAttribute(""name"", ""required"");
		 required.appendChild(doc.createTextNode(Boolean.toString(requiredCheckBox.isSelected())));
		 module.appendChild(required);
		 Element sqlType = doc.createElement(""module-data"");
		 sqlType.setAttribute(""name"", ""sql-type"");
		 if (sqlTypeText.getText() != null) {
			 sqlType.appendChild(doc.createTextNode(sqlTypeText.getText()));
		 }
		 module.appendChild(sqlType);
		 Element jdbcType = doc.createElement(""module-data"");
		 jdbcType.setAttribute(""name"", ""jdbc-type"");
		 jdbcType.appendChild(doc.createTextNode(jdbcTypeComboBox.getSelectedItem().toString()));
		 module.appendChild(jdbcType);
		 Element primaryKey = doc.createElement(""module-data"");
		 primaryKey.setAttribute(""name"", ""primary-key"");
		 primaryKey.appendChild(doc.createTextNode(Boolean.toString(primaryKeyCheckBox.isSelected())));
		 module.appendChild(primaryKey);
		 Element autoPrimary = doc.createElement(""module-data"");
		 autoPrimary.setAttribute(""name"", ""auto-primary-key"");
		 autoPrimary.appendChild(doc.createTextNode(Boolean.toString(autoGeneratedCheckBox.isSelected())));
		 module.appendChild(autoPrimary);
		 Element foreignKey = doc.createElement(""module-data"");
		 foreignKey.setAttribute(""name"", ""foreign-key"");
		 foreignKey.appendChild(doc.createTextNode("""" + isForeignKey()));
		 module.appendChild(foreignKey);
		 Element validationDepends = doc.createElement(""module-data"");
		 validationDepends.setAttribute(""name"", ""validation-depends"");
		 if (validationDependsText.getText() != null) {
			 validationDepends.appendChild(doc.createTextNode(validationDependsText.getText()));
		 }
		 module.appendChild(validationDepends);
		 Element validationXml = doc.createElement(""module-data"");
		 validationXml.setAttribute(""name"", ""validation-xml"");
		 if (validationXMLTextArea.getText() != null) {
			 validationXml.appendChild(doc.createTextNode(validationXMLTextArea.getText()));
		 }
		 module.appendChild(validationXml);
		 el.appendChild(module);
	 }
	 public TemplateString getSqlType() {
		 return new TemplateString(sqlTypeText.getText());
	 }
	 public void setSqlType(String text) {
		 sqlTypeText.setText(text);
	 }
	 public TemplateString getJdbcType() {
		 return new TemplateString(jdbcTypeComboBox.getSelectedItem().toString());
	 }
	 public void setJdbcType(String text) {
		 jdbcTypeComboBox.setSelectedItem(text);
	 }
	 public TemplateString getPrimaryKey() {
		 return new TemplateString(Boolean.toString(primaryKeyCheckBox.isSelected()));
	 }
	 public TemplateString getForeignKey() {
		 return new TemplateString(Boolean.toString(isForeignKey()));
	 }
	 public String getValidationDepends() {
		 if (validationDependsText.getText() == null) {
			 return """";
		 }
		 else {
			 return validationDependsText.getText();
		 }
	 }
	 public String getValidationXml() {
		 return validationXMLTextArea.getText();
	 }
	 public String isDate() {
		 if (""java.sql.Date"".equals(getType())) {
			 return ""true"";
		 }
		 if (""java.util.Date"".equals(getType())) {
			 return ""true"";
		 }
		 return ""false"";
	 }
	 public String isTime() {
		 if (""java.sql.Time"".equals(getType())) {
			 return ""true"";
		 }
		 if (""java.sql.Timestamp"".equals(getType())) {
			 return ""true"";
		 }
		 return ""false"";
	 }
	 public String getType(Column column) {
		 if (column.getSqlType() == null) {
			 return """";
		 }
		 String sqlType = column.getSqlType().toUpperCase();
		 int scale = column.getScale();
		 int precision = column.getPrecision();
		 if (sqlType == null) return """";
		 if (sqlType.equals(""DATE"")) return ""java.sql.Date"";
		 if (sqlType.equals(""BOOL"")) return ""java.lang.Boolean"";
		 if (sqlType.equals(""FLOAT"")) return ""java.lang.Float"";
		 if (sqlType.equals(""DOUBLE"")) return ""java.lang.Double"";
		 if (sqlType.equals(""FLOAT(7)"")) return ""java.lang.Float"";
		 if (sqlType.equals(""FLOAT8"")) return ""java.lang.Double"";
		 if (contains(sqlType, ""NUMERIC"") || contains(sqlType, ""NUMERIC"")) return ""java.math.BigDecimal"";
		 if (sqlType.equals(""BYTEA"")) {
			 System.out.println(""Mapping the BYTEA binary type to java.sql.Blob. JAG has no support for binary fields."");
			 return ""java.sql.Blob"";
		 }
		 if ((sqlType.indexOf(""TIMESTAMP"") != -1) || (sqlType.indexOf(""DATETIME"") != -1)) return ""java.sql.Timestamp"";
		 if (sqlType.equals(""TIME"")) return ""java.sql.Time"";
		 if (contains(sqlType, ""TINYINT"")) return ""java.lang.Byte"";
		 if (contains(sqlType, ""SMALLINT"")) return ""java.lang.Short"";
		 if (contains(sqlType, ""BIGINT"")) return ""java.lang.Long"";
		 if (contains(sqlType, ""DECIMAL"")) return ""java.math.BigDecimal"";
		 if (contains(sqlType, ""BLOB"")) return ""java.sql.Blob"";
		 if (contains(sqlType, ""SERIAL"")) return ""java.lang.Long"";
		 if (contains(sqlType, ""IDENTITY"")) return ""java.lang.Long"";
		 if (sqlType.equals(""NUMBER"") || sqlType.equals(""INT"") || sqlType.equals(""YEAR"") || sqlType.indexOf(""INT"") > -1) {
			 if (scale == 0) {
				 if (precision == 0) {
					 return ""java.lang.Integer"";
				 }
				 if (precision <= 2) {
					 return ""java.lang.Integer"";
				 }
				 if (precision <= 5) {
					 return ""java.lang.Integer"";
				 }
				 if (precision <= 9) {
					 return ""java.lang.Integer"";
				 }
				 if (precision <= 18) {
					 if (sqlType.indexOf(""INT"") != -1) {
						 return ""java.lang.Integer"";
					 }
					 return ""java.lang.Long"";
				 }
				 else {
					 return ""java.math.BigDecimal"";
				 }
			 }
			 if (precision + scale <= 12) {
				 return ""java.math.BigDecimal"";
			 }
			 if (precision + scale <= 64) {
				 return ""java.lang.Double"";
			 }
			 else {
				 return ""java.math.BigDecimal"";
			 }
		 }
		 if (sqlType.indexOf(""CHAR"") > -1) {
			 return ""java.lang.String"";
		 }
		 if (sqlType.indexOf(""TEXT"") > -1) {
			 return ""java.lang.String"";
		 }
		 System.out.println(""unknown sql type: "" + sqlType + "" Map it to a String."");
		 return ""java.lang.String"";
	 }
	 public String getJdbcType(Column column) {
		 if (column.getSqlType() == null) {
			 return """";
		 }
		 String sqlType = column.getSqlType().toUpperCase();
		 int scale = column.getScale();
		 int precision = column.getPrecision();
		 if (sqlType == null) return """";
		 if (sqlType.equals(""NUMERIC"") || sqlType.equals(""TINYINT"") || sqlType.equals(""SMALLINT"") || sqlType.equals(""DOUBLE"") || sqlType.equals(""TIMESTAMP"") || sqlType.equals(""FLOAT"") || sqlType.equals(""DATE"") || sqlType.equals(""TIME"") || contains(sqlType, ""BIGINT"") || sqlType.equals(""DECIMAL"")) return sqlType;
		 if (contains(sqlType, ""CHAR"")) {
			 return ""VARCHAR"";
		 }
		 if (contains(sqlType, ""TEXT"")) {
			 return ""VARCHAR"";
		 }
		 if (sqlType.equals(""DATETIME"")) return ""TIMESTAMP"";
		 if (sqlType.equals(""FLOAT(7)"")) return ""FLOAT"";
		 if (sqlType.equals(""FLOAT8"")) return ""DOUBLE"";
		 if (sqlType.equals(""BYTEA"")) return ""VARBINARY"";
		 if (contains(sqlType, ""BLOB"")) {
			 return ""BLOB"";
		 }
		 if (contains(sqlType, ""SERIAL"")) return ""INTEGER"";
		 if (contains(sqlType, ""IDENTITY"")) return ""INTEGER"";
		 if (sqlType.equals(""NUMBER"") || contains(sqlType, ""INT"") || sqlType.equals(""YEAR"")) {
			 if (scale == 0) {
				 if (precision == 0) {
					 return ""INTEGER"";
				 }
				 if (precision <= 5) {
					 return ""INTEGER"";
				 }
				 if (precision <= 9) {
					 return ""INTEGER"";
				 }
				 if (precision <= 18) {
					 if (sqlType.indexOf(""INT"") != -1) {
						 return ""INTEGER"";
					 }
					 return ""BIGINT"";
				 }
			 }
			 if (precision + scale <= 12) {
				 return ""DECIMAL"";
			 }
			 if (precision + scale <= 64) {
				 return ""DOUBLE"";
			 }
		 }
		 return ""JAVA_OBJECT"";
	 }
	 public String getSqlType(Column column) {
		 if (column.getSqlType() == null) {
			 return """";
		 }
		 String sqlType = column.getSqlType().toUpperCase();
		 int scale = column.getScale();
		 int precision = column.getPrecision();
		 int length = column.getLength();
		 if (sqlType == null) return """";
		 if (sqlType.equals(""NUMBER"") || sqlType.equals(""DOUBLE"") || contains(sqlType, ""INT"") || sqlType.equals(""YEAR"") || sqlType.equals(""FLOAT"") || sqlType.equals(""DECIMAL"")) {
			 if (precision > 0) {
				 sqlType = sqlType + ""("" + precision;
				 if (scale != 0) {
					 sqlType = sqlType + "", "" + scale;
				 }
				 sqlType = sqlType + "")"";
			 }
			 return sqlType;
		 }
		 if (sqlType.indexOf(""CHAR"") > -1) {
			 if (length > 0) {
				 return sqlType + ""("" + length + "")"";
			 }
		 }
		 return sqlType;
	 }
	 public int getMaxSize() {
		 String jdbcType = getJdbcType().toString();
		 int size;
		 if (""VARCHAR"".equals(jdbcType) || ""CHAR"".equals(jdbcType) || ""LONGVARCHAR"".equals(jdbcType)) {
			 size = -1;
		 }
		 else {
			 return -1;
		 }
		 String sqlType = getSqlType().toString();
		 if (sqlType == null) {
			 return size;
		 }
		 int beginIndex = sqlType.indexOf(""("");
		 int endIndex = sqlType.indexOf("","");
		 if (endIndex == -1) {
			 endIndex = sqlType.indexOf("")"");
		 }
		 if (beginIndex == -1 || endIndex == -1) {
			 return size;
		 }
		 String strSize = sqlType.substring(beginIndex + 1, endIndex);
		 try {
			 size = Integer.parseInt(strSize);
			 return size;
		 }
		 catch (Exception e) {
			 return size;
		 }
	 }
	 public String getRefName() {
		 return null;
	 }
	 public boolean isNumeric() {
		 return (""java.lang.Integer"".equals(getType())) || (""java.lang.Byte"".equals(getType())) || (""java.lang.Long"".equals(getType())) || (""java.lang.Short"".equals(getType()));
	 }
	 public boolean isSequenceField() {
		 if (isPrimaryKey() && getHasAutoGenPrimaryKey() ) {
			 Datasource d = getDatasource();
			 String mapping = d.getTypeMapping().getLower();
			 if (mapping.startsWith(""mysql"")) {
				 return false;
			 }
			 if (mapping.startsWith(""oracle"")) {
				 return true;
			 }
			 if (mapping.startsWith(""postgresql"")) {
				 if (getSqlType().getLower().startsWith(""serial"")) {
					 return false;
				 }
				 else {
					 return true;
				 }
			 }
			 if (mapping.startsWith(""hypersonic"")) {
				 if (getSqlType().getLower().startsWith(""identity"")) {
					 return false;
				 }
				 else {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 private Config getConfig() {
		 List services = JagGenerator.getObjectsFromTree(Config.class);
		 for (int i=0;
		 i<services.size();
		 i++) {
			 Config c = (Config) services.get(i);
			 return c;
		 }
		 return null;
	 }
	 private Datasource getDatasource() {
		 List services = JagGenerator.getObjectsFromTree(Datasource.class);
		 for (int i=0;
		 i<services.size();
		 i++) {
			 Datasource d = (Datasource) services.get(i);
			 return d;
		 }
		 return null;
	 }
	 public boolean isPrimaryKey() {
		 return primaryKeyCheckBox.isSelected();
	 }
	 public boolean getHasAutoGenPrimaryKey() {
		 return autoGeneratedCheckBox.isSelected();
	 }
	 public void setHasAutoGenPrimaryKey(boolean value) {
		 autoGeneratedCheckBox.setSelected(value);
	 }
	 public void setForeignKey(boolean foreignKey) {
		 foreignKeyCheckBox.setSelected(foreignKey);
	 }
	 public boolean isForeignKey() {
		 return foreignKeyCheckBox.isSelected();
	 }
	 public String getType() {
		 return typeText.getText();
	 }
	 public void setType(String text) {
		 typeText.setText(text);
	 }
	 public TemplateString getName() {
		 return new TemplateString(nameText.getText());
	 }
	 public void setName(String name) {
		 oldName = nameText.getText();
		 nameText.setText(name);
	 }
	 public String getColumnName() {
		 return columnNameText.getText();
	 }
	 public Relation getRelation() {
		 return relation;
	 }
	 public void setRelation(Relation relation) {
		 this.relation = relation;
	 }
	 public boolean isRelation() {
		 return relation != null;
	 }
	 public boolean isNullable() {
		 return nullable;
	 }
	 public boolean isRequired() {
		 return !nullable;
	 }
	 public String getSize() {
		 TemplateString theType = getSqlType();
		 if (theType == null) {
			 return null;
		 }
		 List parameters = StrutsValidation.getParams(getSqlType().toString());
		 if (getSqlType().toString().indexOf(""CHAR"") != -1 && !parameters.isEmpty()) {
			 return (String) parameters.get(0);
		 }
		 return null;
	 }
	 public void regenerateValidations() {
		 validations = new StrutsValidation(sqlTypeText.getText(), jdbcTypeComboBox.getSelectedItem().toString(), enforceRequiredValidation());
		 if (validations.getDependsList() != null) {
			 validationDependsText.setText(validations.getDependsList());
		 }
		 else {
			 validationDependsText.setText("""");
		 }
		 if (validations.getXml() != null) {
			 validationXMLTextArea.setText(validations.getXml());
		 }
		 else {
			 validationXMLTextArea.setText("""");
		 }
	 }
	 private boolean enforceRequiredValidation() {
		 return getHasAutoGenPrimaryKey() ? false : requiredCheckBox.isSelected();
	 }
	 public void setPrimaryKey(boolean value) {
		 primaryKeyCheckBox.setSelected(value);
		 autoGeneratedCheckBox.setEnabled(value);
		 requiredCheckBox.setEnabled(!value);
		 if (value) {
			 previousRequiredState = requiredCheckBox.isSelected();
			 requiredCheckBox.setSelected(true);
		 }
		 else {
			 requiredCheckBox.setSelected(previousRequiredState);
		 }
	 }
	 public boolean isPkClassIsAutogeneratable() {
		 String primaryKeyClass = typeText.getText();
		 return autogeneratablePrimaryKeyClasses.contains(primaryKeyClass);
	 }
	 private void init() {
		 initComponents();
		 Iterator types = jdbcTypes.iterator();
		 while (types.hasNext()) {
			 String jdbcType = (String) types.next();
			 jdbcTypeComboBox.addItem(jdbcType);
		 }
	 }
	 private void initComponents() {
		 panel = new javax.swing.JPanel();
		 nameLabel = new javax.swing.JLabel();
		 typeLabel = new javax.swing.JLabel();
		 columnNameLabel = new javax.swing.JLabel();
		 sqlTypeLabel = new javax.swing.JLabel();
		 jdbcTypeLabel = new javax.swing.JLabel();
		 nameText = new javax.swing.JTextField();
		 typeText = new javax.swing.JTextField();
		 columnNameText = new javax.swing.JTextField();
		 sqlTypeText = new javax.swing.JTextField();
		 jPanel1 = new javax.swing.JPanel();
		 validationDependsText = new javax.swing.JTextField();
		 validationXMLScrollPane = new javax.swing.JScrollPane();
		 validationXMLTextArea = new javax.swing.JTextArea();
		 validationXMLLabel = new javax.swing.JLabel();
		 validationDependsLabel = new javax.swing.JLabel();
		 regenerateButton = new javax.swing.JButton();
		 jdbcTypeComboBox = new javax.swing.JComboBox();
		 checkboxPanel2 = new javax.swing.JPanel();
		 autoGeneratedCheckBox = new javax.swing.JCheckBox();
		 requiredCheckBox = new javax.swing.JCheckBox();
		 checkboxPanel1 = new javax.swing.JPanel();
		 primaryKeyCheckBox = new javax.swing.JCheckBox();
		 foreignKeyCheckBox = new javax.swing.JCheckBox();
		 panel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
		 nameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 nameLabel.setText(""Name: "");
		 panel.add(nameLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 10, 90, -1));
		 typeLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 typeLabel.setText(""Type: "");
		 panel.add(typeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 40, 90, -1));
		 columnNameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 columnNameLabel.setText(""Column name: "");
		 panel.add(columnNameLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 70, 90, -1));
		 sqlTypeLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 sqlTypeLabel.setText(""SQL-type: "");
		 panel.add(sqlTypeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 100, 90, -1));
		 jdbcTypeLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 jdbcTypeLabel.setText(""JDBC-type: "");
		 panel.add(jdbcTypeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 130, 90, -1));
		 nameText.addFocusListener(new java.awt.event.FocusAdapter() {
			 public void focusLost(java.awt.event.FocusEvent evt) {
				 nameTextFocusLost(evt);
			 }
		 }
		);
		 panel.add(nameText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 10, 260, -1));
		 typeText.addFocusListener(new java.awt.event.FocusAdapter() {
			 public void focusLost(java.awt.event.FocusEvent evt) {
				 typeTextFocusLost(evt);
			 }
		 }
		);
		 panel.add(typeText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 40, 260, -1));
		 columnNameText.addFocusListener(new java.awt.event.FocusAdapter() {
			 public void focusLost(java.awt.event.FocusEvent evt) {
				 columnNameTextFocusLost(evt);
			 }
		 }
		);
		 panel.add(columnNameText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 70, 260, -1));
		 sqlTypeText.addFocusListener(new java.awt.event.FocusAdapter() {
			 public void focusLost(java.awt.event.FocusEvent evt) {
				 sqlTypeTextFocusLost(evt);
			 }
		 }
		);
		 panel.add(sqlTypeText, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 100, 260, -1));
		 jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
		 jPanel1.setBorder(new javax.swing.border.TitledBorder(""Struts validations:""));
		 validationDependsText.setColumns(46);
		 validationDependsText.addFocusListener(new java.awt.event.FocusAdapter() {
			 public void focusLost(java.awt.event.FocusEvent evt) {
				 validationDependsTextFocusLost(evt);
			 }
		 }
		);
		 jPanel1.add(validationDependsText, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 30, 290, -1));
		 validationXMLTextArea.setColumns(48);
		 validationXMLTextArea.setFont(new java.awt.Font(""Lucida Console"", 0, 10));
		 validationXMLTextArea.setRows(6);
		 validationXMLTextArea.addFocusListener(new java.awt.event.FocusAdapter() {
			 public void focusLost(java.awt.event.FocusEvent evt) {
				 validationXMLTextAreaFocusLost(evt);
			 }
		 }
		);
		 validationXMLScrollPane.setViewportView(validationXMLTextArea);
		 jPanel1.add(validationXMLScrollPane, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 59, -1, 90));
		 validationXMLLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 validationXMLLabel.setText(""Validation XML: "");
		 jPanel1.add(validationXMLLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(-20, 60, 110, 20));
		 validationDependsLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 validationDependsLabel.setText(""Validations: "");
		 jPanel1.add(validationDependsLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(-20, 30, 110, -1));
		 regenerateButton.setText(""Regenerate validations"");
		 regenerateButton.setEnabled(false);
		 regenerateButton.addActionListener(new java.awt.event.ActionListener() {
			 public void actionPerformed(java.awt.event.ActionEvent evt) {
				 regenerateButtonActionPerformed(evt);
			 }
		 }
		);
		 jPanel1.add(regenerateButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(240, 170, -1, -1));
		 panel.add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 240, 400, 200));
		 jdbcTypeComboBox.addActionListener(new java.awt.event.ActionListener() {
			 public void actionPerformed(java.awt.event.ActionEvent evt) {
				 jdbcTypeComboBoxActionPerformed(evt);
			 }
		 }
		);
		 panel.add(jdbcTypeComboBox, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 130, 260, -1));
		 checkboxPanel2.setLayout(new java.awt.BorderLayout());
		 autoGeneratedCheckBox.setText(""Auto-generated primary key:"");
		 autoGeneratedCheckBox.setEnabled(false);
		 autoGeneratedCheckBox.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 autoGeneratedCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		 autoGeneratedCheckBox.addActionListener(new java.awt.event.ActionListener() {
			 public void actionPerformed(java.awt.event.ActionEvent evt) {
				 autoGeneratedCheckBoxActionPerformed(evt);
			 }
		 }
		);
		 checkboxPanel2.add(autoGeneratedCheckBox, java.awt.BorderLayout.SOUTH);
		 requiredCheckBox.setText(""Required (not nullable):"");
		 requiredCheckBox.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
		 requiredCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		 requiredCheckBox.setMaximumSize(new java.awt.Dimension(186, 24));
		 requiredCheckBox.setMinimumSize(new java.awt.Dimension(186, 24));
		 requiredCheckBox.setPreferredSize(new java.awt.Dimension(186, 24));
		 requiredCheckBox.addActionListener(new java.awt.event.ActionListener() {
			 public void actionPerformed(java.awt.event.ActionEvent evt) {
				 requiredCheckBoxActionPerformed(evt);
			 }
		 }
		);
		 checkboxPanel2.add(requiredCheckBox, java.awt.BorderLayout.NORTH);
		 panel.add(checkboxPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 170, 190, 50));
		 checkboxPanel1.setLayout(new java.awt.BorderLayout());
		 primaryKeyCheckBox.setText(""Primary key:"");
		 primaryKeyCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		 primaryKeyCheckBox.addActionListener(new java.awt.event.ActionListener() {
			 public void actionPerformed(java.awt.event.ActionEvent evt) {
				 primaryKeyCheckBoxActionPerformed(evt);
			 }
		 }
		);
		 checkboxPanel1.add(primaryKeyCheckBox, java.awt.BorderLayout.NORTH);
		 foreignKeyCheckBox.setText(""Foreign key:"");
		 foreignKeyCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		 foreignKeyCheckBox.addActionListener(new java.awt.event.ActionListener() {
			 public void actionPerformed(java.awt.event.ActionEvent evt) {
				 foreignKeyCheckBoxActionPerformed(evt);
			 }
		 }
		);
		 checkboxPanel1.add(foreignKeyCheckBox, java.awt.BorderLayout.SOUTH);
		 panel.add(checkboxPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 170, 160, 50));
	 }
	 private void jdbcTypeComboBoxActionPerformed(java.awt.event.ActionEvent evt) {
		 JagGenerator.stateChanged(false);
		 regenerateButton.setEnabled(true);
	 }
	 private void autoGeneratedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {
		 if (autoGeneratedCheckBox.isSelected() && !isPkClassIsAutogeneratable()) {
			 JagGenerator.logToConsole(""Can't autogenerate primary keys with class type '"" + typeText.getText() + ""'!"");
			 autoGeneratedCheckBox.setSelected(false);
		 }
	 }
	 private void regenerateButtonActionPerformed(java.awt.event.ActionEvent evt) {
		 regenerateValidations();
		 regenerateButton.setEnabled(false);
	 }
	 private void requiredCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {
		 JagGenerator.stateChanged(false);
		 regenerateButton.setEnabled(true);
	 }
	 private void validationXMLTextAreaFocusLost(java.awt.event.FocusEvent evt) {
		 JagGenerator.stateChanged(false);
	 }
	 private void validationDependsTextFocusLost(java.awt.event.FocusEvent evt) {
		 JagGenerator.stateChanged(false);
	 }
	 private void foreignKeyCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {
		 JagGenerator.stateChanged(false);
		 regenerateButton.setEnabled(true);
	 }
	 private void primaryKeyCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {
		 boolean checked = primaryKeyCheckBox.isSelected();
		 setPrimaryKey(checked);
		 if (checked) {
			 parentEntity.setPrimaryKey(this);
		 }
		 else {
			 parentEntity.unsetPrimaryKey(this);
		 }
		 JagGenerator.stateChanged(false);
		 regenerateButton.setEnabled(true);
	 }
	 private void sqlTypeTextFocusLost(java.awt.event.FocusEvent evt) {
		 JagGenerator.stateChanged(false);
		 regenerateButton.setEnabled(true);
	 }
	 private void columnNameTextFocusLost(java.awt.event.FocusEvent evt) {
		 JagGenerator.stateChanged(false);
	 }
	 private void typeTextFocusLost(java.awt.event.FocusEvent evt) {
		 JagGenerator.stateChanged(false);
	 }
	 private void nameTextFocusLost(java.awt.event.FocusEvent evt) {
		 if (!nameText.getText().equals(oldName)) {
			 parentEntity.notifyRelationsThatFieldNameChanged(oldName, nameText.getText());
			 oldName = nameText.getText();
		 }
		 JagGenerator.stateChanged(true);
	 }
	 private boolean contains(String s, String sub) {
		 return s.indexOf(sub) > -1;
	 }
	 public javax.swing.JCheckBox autoGeneratedCheckBox;
	 private javax.swing.JPanel checkboxPanel1;
	 private javax.swing.JPanel checkboxPanel2;
	 private javax.swing.JLabel columnNameLabel;
	 private javax.swing.JTextField columnNameText;
	 public javax.swing.JCheckBox foreignKeyCheckBox;
	 private javax.swing.JPanel jPanel1;
	 private javax.swing.JComboBox jdbcTypeComboBox;
	 private javax.swing.JLabel jdbcTypeLabel;
	 private javax.swing.JLabel nameLabel;
	 private javax.swing.JTextField nameText;
	 private javax.swing.JPanel panel;
	 public javax.swing.JCheckBox primaryKeyCheckBox;
	 private javax.swing.JButton regenerateButton;
	 public javax.swing.JCheckBox requiredCheckBox;
	 private javax.swing.JLabel sqlTypeLabel;
	 private javax.swing.JTextField sqlTypeText;
	 private javax.swing.JLabel typeLabel;
	 private javax.swing.JTextField typeText;
	 private javax.swing.JLabel validationDependsLabel;
	 public javax.swing.JTextField validationDependsText;
	 private javax.swing.JLabel validationXMLLabel;
	 private javax.swing.JScrollPane validationXMLScrollPane;
	 private javax.swing.JTextArea validationXMLTextArea;
}",1,0,0,0
"boolean _replace(Serializable key, Serializable oldValue, Serializable newValue);",0,0,0,1
"public final class InMemoryStateStore extends AbstractStateStore {
	 private Map<String, EntityState> entityStates = new HashMap<>();
	 private SortedMap<String, InstanceState> instanceStates = Collections .synchronizedSortedMap(new TreeMap<String, InstanceState>());
	 private static final StateStore STORE = new InMemoryStateStore();
	 private InMemoryStateStore() {
	}
	 public static StateStore get() {
		 return STORE;
	 }
	 public void putEntity(EntityState entityState) throws StateStoreException {
		 String key = new EntityID(entityState.getEntity()).getKey();
		 if (entityStates.containsKey(key)) {
			 throw new StateStoreException(""Entity with key, "" + key + "" already exists."");
		 }
		 entityStates.put(key, entityState);
	 }
	 public EntityState getEntity(EntityID entityId) throws StateStoreException {
		 if (!entityStates.containsKey(entityId.getKey())) {
			 throw new StateStoreException(""Entity with key, "" + entityId + "" does not exist."");
		 }
		 return entityStates.get(entityId.getKey());
	 }
	 public boolean entityExists(EntityID entityId) {
		 return entityStates.containsKey(entityId.getKey());
	 }
	 public Collection<Entity> getEntities(EntityState.STATE state) {
		 Collection<Entity> entities = new ArrayList<>();
		 for (EntityState entityState : entityStates.values()) {
			 if (entityState.getCurrentState().equals(state)) {
				 entities.add(entityState.getEntity());
			 }
		 }
		 return entities;
	 }
	 public Collection<EntityState> getAllEntities() {
		 return entityStates.values();
	 }
	 public void updateEntity(EntityState entityState) throws StateStoreException {
		 String key = new EntityID(entityState.getEntity()).getKey();
		 if (!entityStates.containsKey(key)) {
			 throw new StateStoreException(""Entity with key, "" + key + "" does not exist."");
		 }
		 entityStates.put(key, entityState);
	 }
	 public void deleteEntity(EntityID entityId) throws StateStoreException {
		 if (!entityStates.containsKey(entityId.getKey())) {
			 throw new StateStoreException(""Entity with key, "" + entityId + "" does not exist."");
		 }
		 deleteExecutionInstances(entityId);
		 entityStates.remove(entityId.getKey());
	 }
	 public void deleteEntities() throws StateStoreException {
		 entityStates.clear();
	 }
	 public boolean isEntityCompleted(EntityID entityId) {
		 return false;
	 }
	 public void putExecutionInstance(InstanceState instanceState) throws StateStoreException {
		 String key = new InstanceID(instanceState.getInstance()).getKey();
		 if (instanceStates.containsKey(key)) {
			 throw new StateStoreException(""Instance with key, "" + key + "" already exists."");
		 }
		 instanceStates.put(key, instanceState);
	 }
	 public InstanceState getExecutionInstance(InstanceID instanceId) throws StateStoreException {
		 if (!instanceStates.containsKey(instanceId.getKey())) {
			 throw new StateStoreException(""Instance with key, "" + instanceId + "" does not exist."");
		 }
		 return instanceStates.get(instanceId.toString());
	 }
	 public InstanceState getExecutionInstance(String externalID) throws StateStoreException {
		 if (StringUtils.isEmpty(externalID)) {
			 throw new StateStoreException(""External ID for retrieving instance cannot be null"");
		 }
		 for (InstanceState instanceState : instanceStates.values()) {
			 if (externalID.equals(instanceState.getInstance().getExternalID())) {
				 return instanceState;
			 }
		 }
		 return null;
	 }
	 public void updateExecutionInstance(InstanceState instanceState) throws StateStoreException {
		 String key = new InstanceID(instanceState.getInstance()).getKey();
		 if (!instanceStates.containsKey(key)) {
			 throw new StateStoreException(""Instance with key, "" + key + "" does not exist."");
		 }
		 instanceStates.put(key, instanceState);
	 }
	 public Collection<InstanceState> getAllExecutionInstances(Entity entity, String cluster) throws StateStoreException {
		 EntityClusterID id = new EntityClusterID(entity, cluster);
		 if (!entityStates.containsKey(id.getEntityID().getKey())) {
			 throw new StateStoreException(""Entity with key, "" + id.getEntityID().getKey() + "" does not exist."");
		 }
		 Collection<InstanceState> instances = new ArrayList<>();
		 for (Map.Entry<String, InstanceState> instanceState : instanceStates.entrySet()) {
			 if (instanceState.getKey().startsWith(id.toString())) {
				 instances.add(instanceState.getValue());
			 }
		 }
		 return instances;
	 }
	 public Collection<InstanceState> getExecutionInstances(Entity entity, String cluster, Collection<InstanceState.STATE> states) throws StateStoreException {
		 EntityClusterID id = new EntityClusterID(entity, cluster);
		 return getExecutionInstances(id, states);
	 }
	 public Collection<InstanceState> getExecutionInstances(Entity entity, String cluster, Collection<InstanceState.STATE> states, DateTime start, DateTime end) throws StateStoreException {
		 List<InstanceState> instancesToReturn = new ArrayList<>();
		 EntityClusterID id = new EntityClusterID(entity, cluster);
		 for (InstanceState state : getExecutionInstances(id, states)) {
			 ExecutionInstance instance = state.getInstance();
			 DateTime instanceTime = instance.getInstanceTime();
			 if ((instanceTime.isEqual(start) || instanceTime.isAfter(start)) && instanceTime.isBefore(end)) {
				 instancesToReturn.add(state);
			 }
		 }
		 return instancesToReturn;
	 }
	 public Collection<InstanceState> getExecutionInstances(EntityClusterID entityId, Collection<InstanceState.STATE> states) throws StateStoreException {
		 Collection<InstanceState> instances = new ArrayList<>();
		 for (Map.Entry<String, InstanceState> instanceState : instanceStates.entrySet()) {
			 if (instanceState.getKey().startsWith(entityId.toString()) && states.contains(instanceState.getValue().getCurrentState())) {
				 instances.add(instanceState.getValue());
			 }
		 }
		 return instances;
	 }
	 public Map<InstanceState.STATE, Long> getExecutionInstanceSummary(Entity entity, String cluster, DateTime start, DateTime end) throws StateStoreException {
		 Map<InstanceState.STATE, Long> summary = new HashMap<>();
		 for (InstanceState state : getAllExecutionInstances(entity, cluster)) {
			 ExecutionInstance instance = state.getInstance();
			 DateTime instanceTime = instance.getInstanceTime();
			 if ((instanceTime.isEqual(start) || instanceTime.isAfter(start)) && instanceTime.isBefore(end)) {
				 if (summary.containsKey(state.getCurrentState())) {
					 summary.put(state.getCurrentState(), summary.get(state.getCurrentState()) + 1L);
				 }
				 else {
					 summary.put(state.getCurrentState(), 1L);
				 }
			 }
		 }
		 return summary;
	 }
	 public InstanceState getLastExecutionInstance(Entity entity, String cluster) throws StateStoreException {
		 EntityClusterID id = new EntityClusterID(entity, cluster);
		 if (!entityStates.containsKey(id.getEntityID().getKey())) {
			 throw new StateStoreException(""Entity with key, "" + id.getEntityID().getKey() + "" does not exist."");
		 }
		 InstanceState latestState = null;
		 for (Map.Entry<String, InstanceState> instanceState : instanceStates.entrySet()) {
			 if (instanceState.getKey().startsWith(id.toString())) {
				 latestState = instanceState.getValue();
			 }
		 }
		 return latestState;
	 }
	 public boolean executionInstanceExists(InstanceID instanceId) {
		 return instanceStates.containsKey(instanceId.toString());
	 }
	 public void deleteExecutionInstances(EntityID entityId) {
		 for (String instanceKey : Lists.newArrayList(instanceStates.keySet())) {
			 if (instanceKey.startsWith(entityId.getKey())) {
				 instanceStates.remove(instanceKey);
			 }
		 }
	 }
	 public void deleteExecutionInstances() {
		 instanceStates.clear();
	 }
	 public void deleteExecutionInstance(InstanceID instanceID) throws StateStoreException {
		 if (!instanceStates.containsKey(instanceID.toString())) {
			 throw new StateStoreException(""Instance with key, "" + instanceID.toString() + "" does not exist."");
		 }
		 instanceStates.remove(instanceID.toString());
	 }
	 public void clear() {
		 entityStates.clear();
		 instanceStates.clear();
	 }
}",1,0,0,0
"private boolean restoreState() {
	BufferedReader br = null;
	chunks = new ArrayList<Segment>();
	File file = new File(folder, ""state.txt"");
	if (!file.exists()) {
		file = getBackupFile(folder);
		if (file == null) {
			return false;
		}
	}
	try {
		br = new BufferedReader(new FileReader(file));
		this.length = Long.parseLong(br.readLine());
		this.downloaded = Long.parseLong(br.readLine());
		this.totalDuration = Long.parseLong(br.readLine());
		int urlCount = Integer.parseInt(br.readLine());
		for (int i = 0;
		 i < urlCount;
		 i++) {
			String url = br.readLine();
			urlList.add(url);
		}
		int chunkCount = Integer.parseInt(br.readLine());
		for (int i = 0;
		 i < chunkCount;
		 i++) {
			String cid = br.readLine();
			long len = Long.parseLong(br.readLine());
			long off = Long.parseLong(br.readLine());
			long dwn = Long.parseLong(br.readLine());
			Segment seg = new SegmentImpl(folder, cid, off, len, dwn);
			seg.setTag(""HLS"");
			Logger.log(""id: "" + seg.getId() + ""\nlength: "" + seg.getLength() + ""\noffset: "" + seg.getStartOffset()+ ""\ndownload: "" + seg.getDownloaded());
			chunks.add(seg);
		}
		this.lastModified = br.readLine();
		return true;
	}
	 catch (Exception e) {
		Logger.log(""Failed to load saved state"");
		Logger.log(e);
	}
	 finally {
		if (br != null) {
			try {
				br.close();
			}
			 catch (IOException e) {
			}
		}
	}
	return false;
}",0,0,0,0
"public class MultiSpinnerUI extends SpinnerUI {
	 protected Vector<ComponentUI> uis = new Vector<>();
	 public ComponentUI[] getUIs() {
		 return MultiLookAndFeel.uisToArray(uis);
	 }
	 public boolean contains(JComponent a, int b, int c) {
		 boolean returnValue = uis.elementAt(0).contains(a,b,c);
		 for (int i = 1;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).contains(a,b,c);
		 }
		 return returnValue;
	 }
	 public void update(Graphics a, JComponent b) {
		 for (int i = 0;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).update(a,b);
		 }
	 }
	 public static ComponentUI createUI(JComponent a) {
		 MultiSpinnerUI mui = new MultiSpinnerUI();
		 return MultiLookAndFeel.createUIs(mui, mui.uis, a);
	 }
	 public void installUI(JComponent a) {
		 for (int i = 0;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).installUI(a);
		 }
	 }
	 public void uninstallUI(JComponent a) {
		 for (int i = 0;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).uninstallUI(a);
		 }
	 }
	 public void paint(Graphics a, JComponent b) {
		 for (int i = 0;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).paint(a,b);
		 }
	 }
	 public Dimension getPreferredSize(JComponent a) {
		 Dimension returnValue = uis.elementAt(0).getPreferredSize(a);
		 for (int i = 1;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).getPreferredSize(a);
		 }
		 return returnValue;
	 }
	 public Dimension getMinimumSize(JComponent a) {
		 Dimension returnValue = uis.elementAt(0).getMinimumSize(a);
		 for (int i = 1;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).getMinimumSize(a);
		 }
		 return returnValue;
	 }
	 public Dimension getMaximumSize(JComponent a) {
		 Dimension returnValue = uis.elementAt(0).getMaximumSize(a);
		 for (int i = 1;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).getMaximumSize(a);
		 }
		 return returnValue;
	 }
	 public int getAccessibleChildrenCount(JComponent a) {
		 int returnValue = uis.elementAt(0).getAccessibleChildrenCount(a);
		 for (int i = 1;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).getAccessibleChildrenCount(a);
		 }
		 return returnValue;
	 }
	 public Accessible getAccessibleChild(JComponent a, int b) {
		 Accessible returnValue = uis.elementAt(0).getAccessibleChild(a,b);
		 for (int i = 1;
		 i < uis.size();
		 i++) {
			 uis.elementAt(i).getAccessibleChild(a,b);
		 }
		 return returnValue;
	 }
}",1,1,0,0
"public void runMayThrow() throws IOException {
	 cfs.addSSTable(writeSortedContents(sortedKeys, context));
	 latch.countDown();
 }",0,0,0,0
"public class CLLRM13 extends LRMWeapon {
	 private static final long serialVersionUID = -5052163720015100850L;
	 public CLLRM13() {
		 super();
		 this.techLevel = TechConstants.T_CLAN_TW;
		 this.name = ""LRM 13"";
		 this.setInternalName(""CLLRM13"");
		 this.heat = 0;
		 this.rackSize = 13;
		 this.minimumRange = WEAPON_NA;
		 this.shortRange = 7;
		 this.mediumRange = 14;
		 this.longRange = 21;
		 this.extremeRange = 28;
		 this.tonnage = 2.6f;
		 this.criticals = 0;
		 this.bv = 161;
	 }
}",0,0,0,0
"public boolean isQuirkCssPositioningOneSideOnly(){
	return quirkCssPositioningOneSideOnly;
}",0,0,0,0
"public final class DataOutputBuffer extends DataOutputStream{
	 public DataOutputBuffer() {
		 this(128);
	 }
	 public DataOutputBuffer(int size) {
		 super(new OutputBuffer(size));
	 }
	 private OutputBuffer buffer() {
		 return (OutputBuffer)out;
	 }
	 public byte[] asByteArray() {
		 return buffer().asByteArray();
	 }
	 public byte[] getData() {
		 return buffer().getData();
	 }
	 public int getLength() {
		 return buffer().getLength();
	 }
	 public DataOutputBuffer reset() {
		 this.written = 0;
		 buffer().reset();
		 return this;
	 }
}",0,0,0,0
private void readConstantPool() throws IOException;,0,0,0,0
"public interface TypeDeclaration extends EObject{
	 String getName();
	 void setName(String value);
	 TypeDeclaration getSuperType();
	 void setSuperType(TypeDeclaration value);
	 EList<Member> getMembers();
}",0,0,0,0
"public class ScriptableOutputStream extends ObjectOutputStream {
	 public ScriptableOutputStream(OutputStream out, Scriptable scope) throws IOException {
		 super(out);
		 this.scope = scope;
		 table = new Hashtable(31);
		 table.put(scope, """");
		 enableReplaceObject(true);
		 excludeStandardObjectNames();
	 }
	 public void addOptionalExcludedName(String name) {
		 Object obj = lookupQualifiedName(scope, name);
		 if(obj != null && obj != UniqueTag.NOT_FOUND) {
			 if (!(obj instanceof Scriptable)) {
				 throw new IllegalArgumentException( ""Object for excluded name "" + name + "" is not a Scriptable, it is "" + obj.getClass().getName());
			 }
			 table.put(obj, name);
		 }
	 }
	 public void addExcludedName(String name) {
		 Object obj = lookupQualifiedName(scope, name);
		 if (!(obj instanceof Scriptable)) {
			 throw new IllegalArgumentException(""Object for excluded name "" + name + "" not found."");
		 }
		 table.put(obj, name);
	 }
	 public boolean hasExcludedName(String name) {
		 return table.get(name) != null;
	 }
	 public void removeExcludedName(String name) {
		 table.remove(name);
	 }
	 public void excludeStandardObjectNames() {
		 String[] names = {
		 ""Object"", ""Object.prototype"", ""Function"", ""Function.prototype"", ""String"", ""String.prototype"", ""Math"", ""Array"", ""Array.prototype"", ""Error"", ""Error.prototype"", ""Number"", ""Number.prototype"", ""Date"", ""Date.prototype"", ""RegExp"", ""RegExp.prototype"", ""Script"", ""Script.prototype"", ""Continuation"", ""Continuation.prototype"", }
		;
		 for (int i=0;
		 i < names.length;
		 i++) {
			 addExcludedName(names[i]);
		 }
		 String[] optionalNames = {
		 ""XML"", ""XML.prototype"", ""XMLList"", ""XMLList.prototype"", }
		;
		 for (int i=0;
		 i < optionalNames.length;
		 i++) {
			 addOptionalExcludedName(optionalNames[i]);
		 }
	 }
	 static Object lookupQualifiedName(Scriptable scope, String qualifiedName) {
		 StringTokenizer st = new StringTokenizer(qualifiedName, ""."");
		 Object result = scope;
		 while (st.hasMoreTokens()) {
			 String s = st.nextToken();
			 result = ScriptableObject.getProperty((Scriptable)result, s);
			 if (result == null || !(result instanceof Scriptable)) break;
		 }
		 return result;
	 }
	 static class PendingLookup implements Serializable {
		 static final long serialVersionUID = -2692990309789917727L;
		 PendingLookup(String name) {
			 this.name = name;
		 }
		 String getName() {
			 return name;
		 }
		 private String name;
	 }
	 protected Object replaceObject(Object obj) throws IOException {
		 String name = (String) table.get(obj);
		 if (name == null) return obj;
		 return new PendingLookup(name);
	 }
	 private Scriptable scope;
	 private Hashtable table;
}",0,0,0,0
"public void offerService() throws Exception {
	 long lastHeartbeat = 0, lastBlockReport = 0;
	 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
	 try {
		 while (shouldRun) {
			 long now = System.currentTimeMillis();
			 if (now - lastHeartbeat > HEARTBEAT_INTERVAL) {
				 BlockCommand cmd = namenode.sendHeartbeat(dnRegistration, data.getCapacity(), data.getRemaining(), xmitsInProgress, xceiverCount.getValue());
				 lastHeartbeat = now;
				 if( cmd != null ) {
					 data.checkDataDir();
					 if (cmd.transferBlocks()) {
						 Block blocks[] = cmd.getBlocks();
						 DatanodeInfo xferTargets[][] = cmd.getTargets();
						 for (int i = 0;
						 i < blocks.length;
						 i++) {
							 if (!data.isValidBlock(blocks[i])) {
								 String errStr = ""Can't send invalid block "" + blocks[i];
								 LOG.info(errStr);
								 namenode.errorReport( dnRegistration, DatanodeProtocol.INVALID_BLOCK, errStr);
								 break;
							 }
							 else {
								 if (xferTargets[i].length > 0) {
									 LOG.info(""Starting thread to transfer block "" + blocks[i] + "" to "" + xferTargets[i]);
									 new Daemon(new DataTransfer(xferTargets[i], blocks[i])).start();
								 }
							 }
						 }
					 }
					 else if (cmd.invalidateBlocks()) {
						 data.invalidate(cmd.getBlocks());
					 }
					 else if( cmd.shutdownNode()) {
						 this.shutdown();
						 continue;
					 }
				 }
			 }
			 if (now - lastBlockReport > blockReportInterval) {
				 data.checkDataDir();
				 Block toDelete[] = namenode.blockReport(dnRegistration, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			 }
			 Block [] blockArray=null;
			 synchronized( receivedBlockList ) {
				 if (receivedBlockList.size() > 0) {
					 blockArray = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
					 receivedBlockList.removeAllElements();
				 }
			 }
			 if( blockArray != null ) {
				 namenode.blockReceived( dnRegistration, blockArray );
			 }
			 long waitTime = HEARTBEAT_INTERVAL - (System.currentTimeMillis() - lastHeartbeat);
			 synchronized( receivedBlockList ) {
				 if (waitTime > 0 && receivedBlockList.size() == 0) {
					 try {
						 receivedBlockList.wait(waitTime);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
	 }
	 catch(DiskErrorException e) {
		 handleDiskError(e.getLocalizedMessage());
	 }
	 catch( RemoteException re ) {
		 String reClass = re.getClassName();
		 if( UnregisteredDatanodeException.class.getName().equals( reClass )) {
			 LOG.warn( ""DataNode is shutting down: "" + StringUtils.stringifyException(re));
			 shutdown();
			 return;
		 }
		 throw re;
	 }
 }",0,0,1,0
"public void onRemove(InetAddress endpoint) {
}",0,0,0,0
"public List<T> generateSchedule(Calendar startDate,Calendar endDate, int frequencyAmount, int frequencyUnit,StubType stubType) throws ScheduleException;",0,0,0,1
"private void addNSDefinition(Element element, String uri) {
	 ArrayList al = (ArrayList) nsURIByElement.get(element);
	 if (al == null) {
		 al = new ArrayList();
		 nsURIByElement.put(element, al);
	 }
	 al.add(uri);
 }",0,0,0,0
"public void createWebGraph(Path webGraphDb, Path[] segments) throws IOException {
	 SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
	 long start = System.currentTimeMillis();
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""WebGraphDb: starting at "" + sdf.format(start));
		 LOG.info(""WebGraphDb: webgraphdb: "" + webGraphDb);
	 }
	 Configuration conf = getConf();
	 FileSystem fs = FileSystem.get(conf);
	 Path lock = new Path(webGraphDb, LOCK_NAME);
	 if (!fs.exists(webGraphDb)) {
		 fs.mkdirs(webGraphDb);
	 }
	 LockUtil.createLockFile(fs, lock, false);
	 Path outlinkDb = new Path(webGraphDb, OUTLINK_DIR);
	 if (!fs.exists(outlinkDb)) {
		 fs.mkdirs(outlinkDb);
	 }
	 Path tempOutlinkDb = new Path(outlinkDb + ""-"" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));
	 JobConf outlinkJob = new NutchJob(conf);
	 outlinkJob.setJobName(""Outlinkdb: "" + outlinkDb);
	 if (segments != null) {
		 for (int i = 0;
		 i < segments.length;
		 i++) {
			 Path parseData = new Path(segments[i], ParseData.DIR_NAME);
			 if (fs.exists(parseData)) {
				 LOG.info(""OutlinkDb: adding input: "" + parseData);
				 FileInputFormat.addInputPath(outlinkJob, parseData);
			 }
		 }
	 }
	 LOG.info(""OutlinkDb: adding input: "" + outlinkDb);
	 FileInputFormat.addInputPath(outlinkJob, outlinkDb);
	 outlinkJob.setInputFormat(SequenceFileInputFormat.class);
	 outlinkJob.setMapperClass(OutlinkDb.class);
	 outlinkJob.setReducerClass(OutlinkDb.class);
	 outlinkJob.setMapOutputKeyClass(Text.class);
	 outlinkJob.setMapOutputValueClass(LinkDatum.class);
	 outlinkJob.setOutputKeyClass(Text.class);
	 outlinkJob.setOutputValueClass(LinkDatum.class);
	 FileOutputFormat.setOutputPath(outlinkJob, tempOutlinkDb);
	 outlinkJob.setOutputFormat(MapFileOutputFormat.class);
	 try {
		 LOG.info(""OutlinkDb: running"");
		 JobClient.runJob(outlinkJob);
		 LOG.info(""OutlinkDb: installing "" + outlinkDb);
		 FSUtils.replace(fs, outlinkDb, tempOutlinkDb, true);
		 LOG.info(""OutlinkDb: finished"");
	 }
	 catch (IOException e) {
		 LockUtil.removeLockFile(fs, lock);
		 if (fs.exists(tempOutlinkDb)) {
			 fs.delete(tempOutlinkDb, true);
		 }
		 LOG.error(StringUtils.stringifyException(e));
		 throw e;
	 }
	 Path inlinkDb = new Path(webGraphDb, INLINK_DIR);
	 Path tempInlinkDb = new Path(inlinkDb + ""-"" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));
	 JobConf inlinkJob = new NutchJob(conf);
	 inlinkJob.setJobName(""Inlinkdb "" + inlinkDb);
	 LOG.info(""InlinkDb: adding input: "" + outlinkDb);
	 FileInputFormat.addInputPath(inlinkJob, outlinkDb);
	 inlinkJob.setInputFormat(SequenceFileInputFormat.class);
	 inlinkJob.setMapperClass(InlinkDb.class);
	 inlinkJob.setMapOutputKeyClass(Text.class);
	 inlinkJob.setMapOutputValueClass(LinkDatum.class);
	 inlinkJob.setOutputKeyClass(Text.class);
	 inlinkJob.setOutputValueClass(LinkDatum.class);
	 FileOutputFormat.setOutputPath(inlinkJob, tempInlinkDb);
	 inlinkJob.setOutputFormat(MapFileOutputFormat.class);
	 try {
		 LOG.info(""InlinkDb: running"");
		 JobClient.runJob(inlinkJob);
		 LOG.info(""InlinkDb: installing "" + inlinkDb);
		 FSUtils.replace(fs, inlinkDb, tempInlinkDb, true);
		 LOG.info(""InlinkDb: finished"");
	 }
	 catch (IOException e) {
		 LockUtil.removeLockFile(fs, lock);
		 if (fs.exists(tempInlinkDb)) {
			 fs.delete(tempInlinkDb, true);
		 }
		 LOG.error(StringUtils.stringifyException(e));
		 throw e;
	 }
	 Path nodeDb = new Path(webGraphDb, NODE_DIR);
	 Path tempNodeDb = new Path(nodeDb + ""-"" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));
	 JobConf nodeJob = new NutchJob(conf);
	 nodeJob.setJobName(""NodeDb "" + nodeDb);
	 LOG.info(""NodeDb: adding input: "" + outlinkDb);
	 LOG.info(""NodeDb: adding input: "" + inlinkDb);
	 FileInputFormat.addInputPath(nodeJob, outlinkDb);
	 FileInputFormat.addInputPath(nodeJob, inlinkDb);
	 nodeJob.setInputFormat(SequenceFileInputFormat.class);
	 nodeJob.setReducerClass(NodeDb.class);
	 nodeJob.setMapOutputKeyClass(Text.class);
	 nodeJob.setMapOutputValueClass(LinkDatum.class);
	 nodeJob.setOutputKeyClass(Text.class);
	 nodeJob.setOutputValueClass(Node.class);
	 FileOutputFormat.setOutputPath(nodeJob, tempNodeDb);
	 nodeJob.setOutputFormat(MapFileOutputFormat.class);
	 try {
		 LOG.info(""NodeDb: running"");
		 JobClient.runJob(nodeJob);
		 LOG.info(""NodeDb: installing "" + nodeDb);
		 FSUtils.replace(fs, nodeDb, tempNodeDb, true);
		 LOG.info(""NodeDb: finished"");
	 }
	 catch (IOException e) {
		 LockUtil.removeLockFile(fs, lock);
		 if (fs.exists(tempNodeDb)) {
			 fs.delete(tempNodeDb, true);
		 }
		 LOG.error(StringUtils.stringifyException(e));
		 throw e;
	 }
	 LockUtil.removeLockFile(fs, lock);
	 long end = System.currentTimeMillis();
	 LOG.info(""WebGraphDb: finished at "" + sdf.format(end) + "", elapsed: "" + TimingUtil.elapsedTime(start, end));
 }",0,0,1,0
"public void addOptionValues(List<OptionValue> optionValues, Map<String, Object> context, Delegator delegator) {
	 EntityCondition findCondition = null;
	 if (UtilValidate.isNotEmpty(this.constraintList)) {
		 List<EntityCondition> expandedConditionList = new LinkedList<>();
		 for (EntityFinderUtil.Condition condition : constraintList) {
			 ModelEntity modelEntity = delegator.getModelEntity(this.entityName);
			 if (modelEntity == null) {
				 throw new IllegalArgumentException(""Error in entity-options: could not find entity ["" + this.entityName + ""]"");
			 }
			 EntityCondition createdCondition = condition.createCondition(context, modelEntity, delegator.getModelFieldTypeReader(modelEntity));
			 if (createdCondition != null) {
				 expandedConditionList.add(createdCondition);
			 }
		 }
		 findCondition = EntityCondition.makeCondition(expandedConditionList);
	 }
	 try {
		 Locale locale = UtilMisc.ensureLocale(context.get(""locale""));
		 ModelEntity modelEntity = delegator.getModelEntity(this.entityName);
		 Boolean localizedOrderBy = UtilValidate.isNotEmpty(this.orderByList) && ModelUtil.isPotentialLocalizedFields(modelEntity, this.orderByList);
		 List<GenericValue> values = null;
		 if (!localizedOrderBy) {
			 values = delegator.findList(this.entityName, findCondition, null, this.orderByList, null, this.cache);
		 }
		 else {
			 values = delegator.findList(this.entityName, findCondition, null, null, null, this.cache);
			 values = EntityUtil.localizedOrderBy(values, this.orderByList, locale);
		 }
		 if (""true"".equals(this.filterByDate)) {
			 values = EntityUtil.filterByDate(values, true);
		 }
		 else if (!""false"".equals(this.filterByDate)) {
			 if (modelEntity != null && modelEntity.isField(""fromDate"") && modelEntity.isField(""thruDate"")) {
				 values = EntityUtil.filterByDate(values, true);
			 }
		 }
		 for (GenericValue value : values) {
			 MapStack<String> localContext = MapStack.create(context);
			 Map<String, Object> genericEntityClone = UtilGenerics.cast(value.clone());
			 localContext.push(genericEntityClone);
			 String optionDesc = this.description.expandString(localContext, locale);
			 Object keyFieldObject = value.get(this.getKeyFieldName());
			 if (keyFieldObject == null) {
				 throw new IllegalArgumentException( ""The entity-options identifier (from key-name attribute, or default to the field name) ["" + this.getKeyFieldName() + ""], may not be a valid key field name for the entity ["" + this.entityName + ""]."");
			 }
			 String keyFieldValue = keyFieldObject.toString();
			 optionValues.add(new OptionValue(keyFieldValue, optionDesc));
		 }
	 }
	 catch (GenericEntityException e) {
		 Debug.logError(e, ""Error getting entity options in form"", module);
	 }
 }",0,0,1,0
"public class OptionalManyTransitionImpl extends MinimalEObjectImpl.Container implements OptionalManyTransition{
	 protected static final String VAL_EDEFAULT = null;
	 protected String val = VAL_EDEFAULT;
	 protected OptionalManyTransitionImpl() {
		 super();
	 }
	 protected EClass eStaticClass() {
		 return SyntacticsequencertestPackage.Literals.OPTIONAL_MANY_TRANSITION;
	 }
	 public String getVal() {
		 return val;
	 }
	 public void setVal(String newVal) {
		 String oldVal = val;
		 val = newVal;
		 if (eNotificationRequired()) eNotify(new ENotificationImpl(this, Notification.SET, SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL, oldVal, val));
	 }
	 public Object eGet(int featureID, boolean resolve, boolean coreType) {
		 switch (featureID) {
			 case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL: return getVal();
		 }
		 return super.eGet(featureID, resolve, coreType);
	 }
	 public void eSet(int featureID, Object newValue) {
		 switch (featureID) {
			 case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL: setVal((String)newValue);
			 return;
		 }
		 super.eSet(featureID, newValue);
	 }
	 public void eUnset(int featureID) {
		 switch (featureID) {
			 case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL: setVal(VAL_EDEFAULT);
			 return;
		 }
		 super.eUnset(featureID);
	 }
	 public boolean eIsSet(int featureID) {
		 switch (featureID) {
			 case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL: return VAL_EDEFAULT == null ? val != null : !VAL_EDEFAULT.equals(val);
		 }
		 return super.eIsSet(featureID);
	 }
	 public String toString() {
		 if (eIsProxy()) return super.toString();
		 StringBuffer result = new StringBuffer(super.toString());
		 result.append("" (val: "");
		 result.append(val);
		 result.append(')');
		 return result.toString();
	 }
}",0,1,0,0
"public class TheClient {
	private String timeoutMsg;
	private String maxAuthTryMsg;
	private int maxAuthTry;
	private Socket socket;
	private Authenticator authenticator;
	private ClientAuthenticationHandler clientAuthenticationHandler;
	 private ClientEventHandler eventHandler;
	private ClientExtendedEventHandler extendedEventHandler;
	private ClientCommandHandler commandHandler;
	private ClientObjectHandler objectHandler;
	 private ClientBinaryHandler binaryHandler;
	 private QuickServer quickServer;
	private ClientData clientData;
	private boolean trusted = false;
	private boolean communicationLogging = true;
	private int socketTimeout;
	private String maxConnectionMsg;
	private ClientEvent event = ClientEvent.RUN_BLOCKING;
	private SocketChannel socketChannel;
	private ClientWriteHandler writeHandler;
	public void setServer(QuickServer server) {
		this.quickServer=server;
	}
	public QuickServer getServer() {
		return quickServer;
	}
	public void setSocket(Socket socket) {
		this.socket = socket;
	}
	public Socket getSocket() {
		return socket;
	}
	public void setAuthenticator(Authenticator authenticator) {
		this.authenticator=authenticator;
	}
	public Authenticator getAuthenticator() {
		return authenticator;
	}
	public void setClientAuthenticationHandler(ClientAuthenticationHandler clientAuthenticationHandler) {
		this.clientAuthenticationHandler = clientAuthenticationHandler;
	}
	public ClientAuthenticationHandler getClientAuthenticationHandler() {
		return clientAuthenticationHandler;
	}
	public void setClientData(ClientData data) {
		this.clientData=data;
	}
	public ClientData getClientData() {
		return clientData;
	}
	public void setMaxAuthTry(int authTry) {
		maxAuthTry = authTry;
	}
	public int getMaxAuthTry() {
		return maxAuthTry;
	}
	public void setMaxAuthTryMsg(String msg) {
		maxAuthTryMsg = msg;
	}
	public String getMaxAuthTryMsg() {
		return maxAuthTryMsg;
	}
	public void setTimeoutMsg(String msg) {
		timeoutMsg = msg;
	}
	public String getTimeoutMsg() {
		return timeoutMsg;
	}
	public void setClientEventHandler(ClientEventHandler handler) {
		this.eventHandler = handler;
	}
	public ClientEventHandler getClientEventHandler() {
		return eventHandler;
	}
	public void setClientExtendedEventHandler(ClientExtendedEventHandler handler) {
		this.extendedEventHandler = handler;
	}
	public ClientExtendedEventHandler getClientExtendedEventHandler() {
		return extendedEventHandler;
	}
	public void setClientCommandHandler(ClientCommandHandler handler) {
		this.commandHandler = handler;
	}
	public ClientCommandHandler getClientCommandHandler() {
		return commandHandler;
	}
	public void setClientObjectHandler(ClientObjectHandler handler) {
		this.objectHandler = handler;
	}
	public ClientObjectHandler getClientObjectHandler() {
		return objectHandler;
	}
	public boolean getTrusted() {
		return trusted;
	}
	public void setTrusted(boolean flag) {
		trusted = flag;
	}
	public void setCommunicationLogging(boolean communicationLogging) {
		this.communicationLogging = communicationLogging;
	}
	public boolean getCommunicationLogging() {
		return communicationLogging;
	}
	public void setClientBinaryHandler(ClientBinaryHandler handler) {
		this.binaryHandler = handler;
	}
	public ClientBinaryHandler getClientBinaryHandler() {
		return binaryHandler;
	}
	public void setTimeout(int time) {
		socketTimeout = time;
	}
	public int getTimeout() {
		return socketTimeout;
	}
	public void setClientEvent(ClientEvent event) {
		this.event = event;
	}
	public ClientEvent getClientEvent() {
		return event;
	}
	public void setMaxConnectionMsg(String msg) {
		maxConnectionMsg = msg;
	}
	public String getMaxConnectionMsg() {
		return maxConnectionMsg;
	}
	public void setSocketChannel(SocketChannel socketChannel) {
		this.socketChannel = socketChannel;
	}
	public SocketChannel getSocketChannel() {
		return socketChannel;
	}
	public void setClientWriteHandler(ClientWriteHandler handler) {
		this.writeHandler = handler;
	}
	public ClientWriteHandler getClientWriteHandler() {
		return writeHandler;
	}
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(""{
			TheClient "");
			if(socket!=null) sb.append(socket);
			elsesb.append(""no socket"");
			sb.append("", Event: ""+event);
		sb.append('}
		');
		return sb.toString();
	}
}",0,1,0,0
"public class SequenceFileReader<Key extends Writable, Value extends Writable> extends AbstractFileReader {
	 public static final String[] defaultFields = {
	 ""key"", ""value"" }
	;
	 public static final String BUFFER_SIZE = ""hdfsspout.reader.buffer.bytes"";
	 private static final Logger LOG = LoggerFactory .getLogger(SequenceFileReader.class);
	 private static final int DEFAULT_BUFF_SIZE = 4096;
	 private final SequenceFile.Reader reader;
	 private final SequenceFileReader.Offset offset;
	 private final Key key;
	 private final Value value;
	 public SequenceFileReader(FileSystem fs, Path file, Map<String, Object> conf) throws IOException {
		 super(fs, file);
		 int bufferSize = !conf.containsKey(BUFFER_SIZE) ? DEFAULT_BUFF_SIZE : Integer.parseInt(conf.get(BUFFER_SIZE).toString());
		 this.reader = new SequenceFile.Reader(fs.getConf(), SequenceFile.Reader.file(file), SequenceFile.Reader.bufferSize(bufferSize));
		 this.key = (Key) ReflectionUtils.newInstance(reader.getKeyClass(), fs.getConf());
		 this.value = (Value) ReflectionUtils.newInstance(reader.getValueClass(), fs.getConf());
		 this.offset = new SequenceFileReader.Offset(0, 0, 0);
	 }
	 public SequenceFileReader(FileSystem fs, Path file, Map<String, Object> conf, String offset) throws IOException {
		 super(fs, file);
		 int bufferSize = !conf.containsKey(BUFFER_SIZE) ? DEFAULT_BUFF_SIZE : Integer.parseInt(conf.get(BUFFER_SIZE).toString());
		 this.offset = new SequenceFileReader.Offset(offset);
		 this.reader = new SequenceFile.Reader(fs.getConf(), SequenceFile.Reader.file(file), SequenceFile.Reader.bufferSize(bufferSize));
		 this.key = (Key) ReflectionUtils.newInstance(reader.getKeyClass(), fs.getConf());
		 this.value = (Value) ReflectionUtils.newInstance(reader.getValueClass(), fs.getConf());
		 skipToOffset(this.reader, this.offset, this.key);
	 }
	 private static <K> void skipToOffset(SequenceFile.Reader reader, Offset offset, K key) throws IOException {
		 reader.sync(offset.lastSyncPoint);
		 for (int i = 0;
		 i < offset.recordsSinceLastSync;
		 ++i) {
			 reader.next(key);
		 }
	 }
	 public List<Object> next() throws IOException, ParseException {
		 if (reader.next(key, value)) {
			 ArrayList<Object> result = new ArrayList<Object>(2);
			 Collections.addAll(result, key, value);
			 offset.increment(reader.syncSeen(), reader.getPosition());
			 return result;
		 }
		 return null;
	 }
	 public void close() {
		 try {
			 reader.close();
		 }
		 catch (IOException e) {
			 LOG.warn(""Ignoring error when closing file "" + getFilePath(), e);
		 }
	 }
	 public Offset getFileOffset() {
		 return offset;
	 }
	 public static class Offset implements FileOffset {
		 public long lastSyncPoint;
		 public long recordsSinceLastSync;
		 public long currentRecord;
		 private long currRecordEndOffset;
		 private long prevRecordEndOffset;
		 public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {
			 this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0);
		 }
		 public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord , long currRecordEndOffset, long prevRecordEndOffset) {
			 this.lastSyncPoint = lastSyncPoint;
			 this.recordsSinceLastSync = recordsSinceLastSync;
			 this.currentRecord = currentRecord;
			 this.prevRecordEndOffset = prevRecordEndOffset;
			 this.currRecordEndOffset = currRecordEndOffset;
		 }
		 public Offset(String offset) {
			 try {
				 if (offset == null) {
					 throw new IllegalArgumentException(""offset cannot be null"");
				 }
				 if (offset.equalsIgnoreCase(""0"")) {
					 this.lastSyncPoint = 0;
					 this.recordsSinceLastSync = 0;
					 this.currentRecord = 0;
					 this.prevRecordEndOffset = 0;
					 this.currRecordEndOffset = 0;
				 }
				 else {
					 String[] parts = offset.split("":"");
					 this.lastSyncPoint = Long.parseLong(parts[0].split(""="")[1]);
					 this.recordsSinceLastSync = Long.parseLong(parts[1].split(""="")[1]);
					 this.currentRecord = Long.parseLong(parts[2].split(""="")[1]);
					 this.prevRecordEndOffset = 0;
					 this.currRecordEndOffset = 0;
				 }
			 }
			 catch (Exception e) {
				 throw new IllegalArgumentException(""'"" + offset + ""' cannot be interpreted. It is not in expected format for SequenceFileReader."" + "" Format e.g. {
				sync=123:afterSync=345:record=67}
				"");
			 }
		 }
		 public String toString() {
			 return '{
			' + ""sync="" + lastSyncPoint + "":afterSync="" + recordsSinceLastSync + "":record="" + currentRecord + "":}
			"";
		 }
		 public boolean isNextOffset(FileOffset rhs) {
			 if (rhs instanceof Offset) {
				 Offset other = ((Offset) rhs);
				 return other.currentRecord > currentRecord + 1;
			 }
			 return false;
		 }
		 public int compareTo(FileOffset o) {
			 Offset rhs = ((Offset) o);
			 if (currentRecord < rhs.currentRecord) {
				 return -1;
			 }
			 if (currentRecord == rhs.currentRecord) {
				 return 0;
			 }
			 return 1;
		 }
		 public boolean equals(Object o) {
			 if (this == o) {
				 return true;
			 }
			 if (!(o instanceof Offset)) {
				 return false;
			 }
			 Offset offset = (Offset) o;
			 return currentRecord == offset.currentRecord;
		 }
		 public int hashCode() {
			 return (int) (currentRecord ^ (currentRecord >>> 32));
		 }
		 void increment(boolean syncSeen, long newBytePosition) {
			 if (!syncSeen) {
				 ++recordsSinceLastSync;
			 }
			 else {
				 recordsSinceLastSync = 1;
				 lastSyncPoint = prevRecordEndOffset;
			 }
			 ++currentRecord;
			 prevRecordEndOffset = currRecordEndOffset;
			 currentRecord = newBytePosition;
		 }
		 public Offset clone() {
			 return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);
		 }
	 }
 }",1,0,0,0
"public abstract class AbstractSimpleExtractor<T> implements Extractor<T> {
	 private static final Logger LOG = LoggerFactory.getLogger(AbstractSimpleExtractor.class);
	 private static final int LOG_ERROR_LIMIT = 100;
	 private int errors;
	 private boolean errorOnLast;
	 private final T defaultValue;
	 private final TokenizerFactory scannerFactory;
	 protected AbstractSimpleExtractor(T defaultValue) {
		 this(defaultValue, TokenizerFactory.getDefaultInstance());
	 }
	 protected AbstractSimpleExtractor(T defaultValue, TokenizerFactory scannerFactory) {
		 this.defaultValue = defaultValue;
		 this.scannerFactory = scannerFactory;
	 }
	 public void initialize() {
		 this.errors = 0;
		 this.errorOnLast = false;
	 }
	 public T extract(String input) {
		 errorOnLast = false;
		 T res = defaultValue;
		 try {
			 res = doExtract(scannerFactory.create(input));
		 }
		 catch (Exception e) {
			 errorOnLast = true;
			 errors++;
			 if (errors < LOG_ERROR_LIMIT) {
				 LOG.error(""Error occurred parsing input '{
				}
				' using extractor {
				}
				"", input, this);
			 }
		 }
		 return res;
	 }
	 public boolean errorOnLastRecord() {
		 return errorOnLast;
	 }
	 public T getDefaultValue() {
		 return defaultValue;
	 }
	 public ExtractorStats getStats() {
		 return new ExtractorStats(errors);
	 }
	 protected abstract T doExtract(Tokenizer tokenizer);
}",1,1,0,0
"public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)throws IOException, ServletException{
	HttpServletRequest httpServletRequest;
	HttpServletResponse httpServletResponse;
	boolean inPortletContext = false;
	if (filterPortletContext != null){
		FilterRequestContext filterRequestContext = new FilterRequestContext((HttpServletRequest)request, (HttpServletResponse)response);
		inPortletContext = filterPortletContext.setupFilter(getFilterConfig(),filterRequestContext, getFilterPath((HttpServletRequest)request));
		httpServletRequest = filterRequestContext.getRequest();
		httpServletResponse = filterRequestContext.getResponse();
	}
	else{
		httpServletRequest = (HttpServletRequest)request;
		httpServletResponse = (HttpServletResponse)response;
	}
	httpServletRequest.setAttribute(FILTER_PATH_ATTR, getFilterPath(httpServletRequest));
	boolean passToNextFilter = portletOnlyFilter && !inPortletContext;
	if (passToNextFilter){
		chain.doFilter(request, response);
		return;
	}
	final String relativePath = getRelativePath(httpServletRequest);
	if (ignorePaths.size() > 0 && relativePath.length() > 0){
		for (String path : ignorePaths){
			if (relativePath.startsWith(path)){
				log.debug(""Ignoring request {
				}
				"", httpServletRequest.getRequestURL());
				chain.doFilter(request, response);
				return;
			}
		}
	}
	if (isWicketRequest(relativePath)){
		Application previous = null;
		if (Application.exists()){
			previous = Application.get();
		}
		try{
			Application.set(webApplication);
			long lastModified = getLastModified(httpServletRequest);
			if (lastModified == -1){
				boolean requestHandledByWicket = doGet(httpServletRequest, httpServletResponse);
				if (requestHandledByWicket == false){
					chain.doFilter(request, response);
				}
			}
			else{
				long ifModifiedSince;
				try{
					ifModifiedSince = httpServletRequest.getDateHeader(""If-Modified-Since"");
				}
				catch (IllegalArgumentException e){
					log.warn(""Invalid If-Modified-Since header"", e);
					ifModifiedSince = -1;
				}
				if (ifModifiedSince < (lastModified / 1000 * 1000)){
					maybeSetLastModified(httpServletResponse, lastModified);
					doGet(httpServletRequest, httpServletResponse);
				}
				else{
					httpServletResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
					httpServletResponse.setDateHeader(""Expires"", System.currentTimeMillis() +Duration.hours(1).getMilliseconds());
				}
			}
		}
		finally{
			if (previous == null){
				Application.unset();
				RequestContext.unset();
			}
			else{
				Application.set(previous);
			}
		}
	}
	else{
		chain.doFilter(request, response);
	}
}",0,0,1,0
"protected void collectUsedStyles(JRStyle style, Map usedStylesMap, Map allStylesMap);",0,0,0,0
"private void initComponents() {
	 jPanel1 = new javax.swing.JPanel();
	 jLabel1 = new javax.swing.JLabel();
	 jPanel3 = new javax.swing.JPanel();
	 jScrollPane1 = new javax.swing.JScrollPane();
	 m_tree = new javax.swing.JTree();
	 jPanel2 = new javax.swing.JPanel();
	 m_buttonSelect = new javax.swing.JButton();
	 jSeparator1 = new javax.swing.JSeparator();
	 m_buttonCancel = new javax.swing.JButton();
	 setTitle(""Class Selector"");
	 addWindowListener(new java.awt.event.WindowAdapter() {
		 public void windowClosing(java.awt.event.WindowEvent evt) {
			 closeDialog(evt);
		 }
	 }
	);
	 jPanel1.setLayout(new java.awt.BorderLayout());
	 jPanel1.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(10, 10, 10, 10)));
	 jPanel1.setFocusable(false);
	 jLabel1.setText(""Select a class..."");
	 jLabel1.setFocusable(false);
	 jPanel1.add(jLabel1, java.awt.BorderLayout.NORTH);
	 jPanel3.setLayout(new java.awt.BorderLayout());
	 jPanel3.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(1, 1, 1, 1)));
	 jPanel3.setFocusable(false);
	 jScrollPane1.setFocusable(false);
	 jScrollPane1.setViewportView(m_tree);
	 jPanel3.add(jScrollPane1, java.awt.BorderLayout.CENTER);
	 jPanel1.add(jPanel3, java.awt.BorderLayout.CENTER);
	 getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);
	 jPanel2.setFocusable(false);
	 m_buttonSelect.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_calc-accept-16.png"")));
	 m_buttonSelect.setText(""Select"");
	 m_buttonSelect.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 buttonSelectActionPerformed(evt);
		 }
	 }
	);
	 jPanel2.add(m_buttonSelect);
	 jPanel2.add(jSeparator1);
	 m_buttonCancel.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_calc-cancel-16.png"")));
	 m_buttonCancel.setText(""Cancel"");
	 m_buttonCancel.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 buttonCancelActionPerformed(evt);
		 }
	 }
	);
	 jPanel2.add(m_buttonCancel);
	 getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);
	 java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
	 setBounds((screenSize.width-371)/2, (screenSize.height-260)/2, 371, 260);
 }",0,0,1,0
"public long[] getEstimatedColumnCountHistogram() {
	 return data.getEstimatedRowSizeHistogram();
 }",0,0,0,0
"public synchronized Object clone() throws BuildException {
	 if (isReference()) {
		 return ((FilterSet) getRef()).clone();
	 }
	 try {
		 FilterSet fs = (FilterSet) super.clone();
		 fs.filters = (Vector) getFilters().clone();
		 fs.setProject(getProject());
		 return fs;
	 }
	 catch (CloneNotSupportedException e) {
		 throw new BuildException(e);
	 }
 }",0,0,0,0
"public void validate(ClientState state) throws InvalidRequestException {
	 if (getTimeToLive() != 0) throw new InvalidRequestException(""Global TTL on the BATCH statement is not supported."");
	 for (ModificationStatement statement : statements) {
		 if (statement.isSetConsistencyLevel()) throw new InvalidRequestException(""Consistency level must be set on the BATCH, not individual statements"");
		 if (isSetTimestamp() && statement.isSetTimestamp()) throw new InvalidRequestException(""Timestamp must be set either on BATCH or individual statements"");
		 if (statement.getTimeToLive() < 0) throw new InvalidRequestException(""A TTL must be greater or equal to 0"");
		 ThriftValidation.validateConsistencyLevel(statement.keyspace(), getConsistencyLevel(), RequestType.WRITE);
	 }
 }",0,0,0,0
"double getRemB() {
	 return finalRemB;
 }",0,0,0,0
"public void unparsedEntityDecl( String arg0, String arg1, String arg2, String arg3) throws SAXException;",0,0,0,1
"public class SCOMMetricHelper {
	 private static final String SQLSERVER_PROPERTIES_FILE = ""sqlserver_properties.json"";
	 private static final String JMX_PROPERTIES_FILE = ""jmx_properties.json"";
	 private static final Map<Resource.InternalType, Map<String, Map<String, PropertyInfo>>> JMX_PROPERTY_IDS = readPropertyProviderIds(JMX_PROPERTIES_FILE);
	 private static final Map<Resource.InternalType, Map<String, Map<String, PropertyInfo>>> SQLSERVER_PROPERTY_IDS = readPropertyProviderIds(SQLSERVER_PROPERTIES_FILE);
	 public static Map<String, Map<String, PropertyInfo>> getSqlServerPropertyIds(Resource.Type resourceType) {
		 return SQLSERVER_PROPERTY_IDS.get(resourceType.getInternalType());
	 }
	 public static Map<String, Map<String, PropertyInfo>> getJMXPropertyIds(Resource.Type resourceType) {
		 return JMX_PROPERTY_IDS.get(resourceType.getInternalType());
	 }
	 protected static class Metric {
		 private String metric;
		 private boolean pointInTime;
		 private boolean temporal;
		 private Metric() {
		 }
		 protected Metric(String metric, boolean pointInTime, boolean temporal) {
			 this.metric = metric;
			 this.pointInTime = pointInTime;
			 this.temporal = temporal;
		 }
		 public String getMetric() {
			 return metric;
		 }
		 public void setMetric(String metric) {
			 this.metric = metric;
		 }
		 public boolean isPointInTime() {
			 return pointInTime;
		 }
		 public void setPointInTime(boolean pointInTime) {
			 this.pointInTime = pointInTime;
		 }
		 public boolean isTemporal() {
			 return temporal;
		 }
		 public void setTemporal(boolean temporal) {
			 this.temporal = temporal;
		 }
	 }
	 private static Map<Resource.InternalType, Map<String, Map<String, PropertyInfo>>> readPropertyProviderIds(String filename) {
		 ObjectMapper mapper = new ObjectMapper();
		 try {
			 Map<Resource.InternalType, Map<String, Map<String, Metric>>> resourceMetricMap = mapper.readValue(ClassLoader.getSystemResourceAsStream(filename), new TypeReference<Map<Resource.InternalType, Map<String, Map<String, Metric>>>>() {
			}
			);
			 Map<Resource.InternalType, Map<String, Map<String, PropertyInfo>>> resourceMetrics = new HashMap<Resource.InternalType, Map<String, Map<String, PropertyInfo>>>();
			 for (Map.Entry<Resource.InternalType, Map<String, Map<String, Metric>>> resourceEntry : resourceMetricMap.entrySet()) {
				 Map<String, Map<String, PropertyInfo>> componentMetrics = new HashMap<String, Map<String, PropertyInfo>>();
				 for (Map.Entry<String, Map<String, Metric>> componentEntry : resourceEntry.getValue().entrySet()) {
					 Map<String, PropertyInfo> metrics = new HashMap<String, PropertyInfo>();
					 for (Map.Entry<String, Metric> metricEntry : componentEntry.getValue().entrySet()) {
						 String property = metricEntry.getKey();
						 Metric metric = metricEntry.getValue();
						 metrics.put(property, new PropertyInfo(metric.getMetric(), metric.isTemporal(), metric.isPointInTime()));
					 }
					 componentMetrics.put(componentEntry.getKey(), metrics);
				 }
				 resourceMetrics.put(resourceEntry.getKey(), componentMetrics);
			 }
			 return resourceMetrics;
		 }
		 catch (IOException e) {
			 throw new IllegalStateException(""Can't read properties file "" + filename, e);
		 }
	 }
}",1,1,0,0
"private boolean initOrUpdateSegments() {
	try {
		M3U8Manifest mf = new M3U8Manifest(new File(folder, manifestSegment.getId()).getAbsolutePath(),metadata.getUrl());
		this.totalDuration = mf.getDuration();
		Logger.log(""Total duration"");
		ArrayList<String> urls = mf.getMediaUrls();
		if (urls.size() < 1) {
			Logger.log(""Manifest contains no media"");
			return false;
		}
		if (urlList.size() > 0 && urlList.size() != urls.size()) {
			Logger.log(""Manifest media count mismatch- expected: "" + urlList.size() + "" got: "" + urls.size());
			return false;
		}
		if (urlList.size() > 0) {
			urlList.clear();
		}
		urlList.addAll(urls);
		String newExtension = null;
		if (chunks.size() < 1) {
			for (int i = 0;
			 i < urlList.size();
			 i++) {
				if (newExtension == null && outputFormat == 0) {
					newExtension = findExtension(urlList.get(i));
					Logger.log(""HLS: found new extension: "" + newExtension);
					if (newExtension != null) {
						this.newFileName = getOutputFileName(true).replace("".ts"", newExtension);
					}
					 else {
						newExtension = "".ts"";
					}
				}
				Logger.log(""HLS: Newfile name: "" + this.newFileName);
				Segment s2 = new SegmentImpl(this, folder);
				s2.setTag(""HLS"");
				s2.setLength(-1);
				Logger.log(""Adding chunk: "" + s2);
				chunks.add(s2);
			}
		}
		return true;
	}
	 catch (Exception e) {
		Logger.log(e);
		return false;
	}
}",0,0,1,0
"public class Chmod extends ExecuteOn {
	 private FileSet defaultSet = new FileSet();
	 private boolean defaultSetDefined = false;
	 private boolean havePerm = false;
	 public Chmod() {
		 super.setExecutable(""chmod"");
		 super.setParallel(true);
		 super.setSkipEmptyFilesets(true);
	 }
	 public void setProject(Project project) {
		 super.setProject(project);
		 defaultSet.setProject(project);
	 }
	 public void setFile(File src) {
		 FileSet fs = new FileSet();
		 fs.setFile(src);
		 addFileset(fs);
	 }
	 public void setDir(File src) {
		 defaultSet.setDir(src);
	 }
	 public void setPerm(String perm) {
		 createArg().setValue(perm);
		 havePerm = true;
	 }
	 public PatternSet.NameEntry createInclude() {
		 defaultSetDefined = true;
		 return defaultSet.createInclude();
	 }
	 public PatternSet.NameEntry createExclude() {
		 defaultSetDefined = true;
		 return defaultSet.createExclude();
	 }
	 public PatternSet createPatternSet() {
		 defaultSetDefined = true;
		 return defaultSet.createPatternSet();
	 }
	 public void setIncludes(String includes) {
		 defaultSetDefined = true;
		 defaultSet.setIncludes(includes);
	 }
	 public void setExcludes(String excludes) {
		 defaultSetDefined = true;
		 defaultSet.setExcludes(excludes);
	 }
	 public void setDefaultexcludes(boolean useDefaultExcludes) {
		 defaultSetDefined = true;
		 defaultSet.setDefaultexcludes(useDefaultExcludes);
	 }
	 protected void checkConfiguration() {
		 if (!havePerm) {
			 throw new BuildException(""Required attribute perm not set in chmod"", getLocation());
		 }
		 if (defaultSetDefined && defaultSet.getDir(getProject()) != null) {
			 addFileset(defaultSet);
		 }
		 super.checkConfiguration();
	 }
	 public void execute() throws BuildException {
		 if (defaultSetDefined || defaultSet.getDir(getProject()) == null) {
			 try {
				 super.execute();
			 }
			 finally {
				 if (defaultSetDefined && defaultSet.getDir(getProject()) != null) {
					 filesets.removeElement(defaultSet);
				 }
			 }
		 }
		 else if (isValidOs()) {
			 Execute execute = prepareExec();
			 Commandline cloned = (Commandline) cmdl.clone();
			 cloned.createArgument().setValue(defaultSet.getDir(getProject()) .getPath());
			 try {
				 execute.setCommandline(cloned.getCommandline());
				 runExecute(execute);
			 }
			 catch (IOException e) {
				 throw new BuildException(""Execute failed: "" + e, e, getLocation());
			 }
			 finally {
				 logFlush();
			 }
		 }
	 }
	 public void setExecutable(String e) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the executable attribute"", getLocation());
	 }
	 public void setCommand(Commandline cmdl) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the command attribute"", getLocation());
	 }
	 public void setSkipEmptyFilesets(boolean skip) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the skipemptyfileset attribute"", getLocation());
	 }
	 public void setAddsourcefile(boolean b) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the addsourcefile attribute"", getLocation());
	 }
	 protected boolean isValidOs() {
		 return getOs() == null && getOsFamily() == null ? Os.isFamily(Os.FAMILY_UNIX) : super.isValidOs();
	 }
}",0,0,0,0
"public class Applications {
	 private List<AppInfo> app;
	 public List<AppInfo> getApp() {
		 return app;
	 }
	 public void setApp(List<AppInfo> app) {
		 this.app = app;
	 }
}",0,1,0,0
"public void execute() {
	 if (name == null) {
		 throw new BuildException(""Missing 'property' attribute!"");
	 }
	 if (dir == null) {
		 throw new BuildException(""Missing 'jarfile' attribute!"");
	 }
	 if (getProject().getProperty(name) != null) {
		 throw new BuildException(""Property '"" + name + ""' already set!"");
	 }
	 if (path == null) {
		 throw new BuildException(""Missing nested <classpath>!"");
	 }
	 final FileUtils fileUtils = FileUtils.getFileUtils();
	 dir = fileUtils.normalize(dir.getAbsolutePath());
	 File currDir = dir;
	 String[] dirs = new String[maxParentLevels + 1];
	 for (int i = 0;
	 i < maxParentLevels + 1;
	 ++i) {
		 dirs[i] = currDir.getAbsolutePath() + File.separatorChar;
		 currDir = currDir.getParentFile();
		 if (currDir == null) {
			 maxParentLevels = i + 1;
			 break;
		 }
	 }
	 String[] elements = path.list();
	 StringBuffer buffer = new StringBuffer();
	 StringBuffer element = new StringBuffer();
	 for (int i = 0;
	 i < elements.length;
	 ++i) {
		 File pathEntry = new File(elements[i]);
		 pathEntry = fileUtils.normalize(pathEntry.getAbsolutePath());
		 String fullPath = pathEntry.getAbsolutePath();
		 String relPath = null;
		 for (int j = 0;
		 j <= maxParentLevels;
		 ++j) {
			 String dir = dirs[j];
			 if (!fullPath.startsWith(dir)) {
				 continue;
			 }
			 element.setLength(0);
			 for (int k = 0;
			 k < j;
			 ++k) {
				 element.append("".."");
				 element.append(File.separatorChar);
			 }
			 element.append(fullPath.substring(dir.length()));
			 relPath = element.toString();
			 break;
		 }
		 if (relPath == null) {
			 throw new BuildException( ""No suitable relative path from "" + dir + "" to "" + fullPath);
		 }
		 if (File.separatorChar != '/') {
			 relPath = relPath.replace(File.separatorChar, '/');
		 }
		 if (pathEntry.isDirectory()) {
			 relPath = relPath + '/';
		 }
		 try {
			 relPath = Locator.encodeURI(relPath);
		 }
		 catch (UnsupportedEncodingException exc) {
			 throw new BuildException(exc);
		 }
		 buffer.append(relPath);
		 buffer.append(' ');
	 }
	 getProject().setNewProperty(name, buffer.toString().trim());
 }",0,0,0,0
"static class HttpsTokenInInterceptor extends AbstractPhaseInterceptor<Message> {
	 HttpsTokenInInterceptor() {
		 super(Phase.PRE_STREAM);
		 addBefore(WSS4JStaxInInterceptor.class.getName());
	 }
	 public void handleMessage(Message message) throws Fault {
		 AssertionInfoMap aim = message.get(AssertionInfoMap.class);
		 if (aim != null) {
			 Collection<AssertionInfo> ais = PolicyUtils.getAllAssertionsByLocalname(aim, SPConstants.HTTPS_TOKEN);
			 boolean requestor = isRequestor(message);
			 if (ais.isEmpty()) {
				 if (!requestor) {
					 try {
						 assertNonHttpsTransportToken(message);
					 }
					 catch (XMLSecurityException e) {
						 LOG.fine(e.getMessage());
					 }
				 }
				 return;
			 }
			 if (!requestor) {
				 try {
					 assertHttps(aim, ais, message);
				 }
				 catch (XMLSecurityException e) {
					 LOG.fine(e.getMessage());
				 }
				 SecurityContext sc = message.get(SecurityContext.class);
				 if (sc == null || sc.getUserPrincipal() == null) {
					 TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);
					 if (tlsInfo != null && tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0 && (tlsInfo.getPeerCertificates()[0] instanceof X509Certificate) ) {
						 X509Certificate cert = (X509Certificate)tlsInfo.getPeerCertificates()[0];
						 message.put( SecurityContext.class, createSecurityContext(cert.getSubjectX500Principal()) );
					 }
				 }
			 }
			 else {
				 for (AssertionInfo ai : ais) {
					 ai.setAsserted(true);
				 }
				 PolicyUtils.assertPolicy(aim, SPConstants.HTTP_DIGEST_AUTHENTICATION);
				 PolicyUtils.assertPolicy(aim, SPConstants.HTTP_BASIC_AUTHENTICATION);
				 PolicyUtils.assertPolicy(aim, SPConstants.REQUIRE_CLIENT_CERTIFICATE);
			 }
		 }
	 }
	 private void assertHttps( AssertionInfoMap aim, Collection<AssertionInfo> ais, Message message ) throws XMLSecurityException {
		 List<SecurityEvent> securityEvents = getSecurityEventList(message);
		 AuthorizationPolicy policy = message.get(AuthorizationPolicy.class);
		 for (AssertionInfo ai : ais) {
			 boolean asserted = true;
			 HttpsToken token = (HttpsToken)ai.getAssertion();
			 HttpsTokenSecurityEvent httpsTokenSecurityEvent = new HttpsTokenSecurityEvent();
			 Map<String, List<String>> headers = getProtocolHeaders(message);
			 if (token.getAuthenticationType() == HttpsToken.AuthenticationType.HttpBasicAuthentication) {
				 List<String> auth = headers.get(""Authorization"");
				 if (auth == null || auth.isEmpty() || !auth.get(0).startsWith(""Basic"")) {
					 asserted = false;
				 }
				 else {
					 httpsTokenSecurityEvent.setAuthenticationType( HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication );
					 HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl(true, policy.getUserName());
					 httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
					 httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
					 PolicyUtils.assertPolicy(aim, new QName(token.getName().getNamespaceURI(), SPConstants.HTTP_BASIC_AUTHENTICATION));
				 }
			 }
			 if (token.getAuthenticationType() == HttpsToken.AuthenticationType.HttpDigestAuthentication) {
				 List<String> auth = headers.get(""Authorization"");
				 if (auth == null || auth.isEmpty() || !auth.get(0).startsWith(""Digest"")) {
					 asserted = false;
				 }
				 else {
					 httpsTokenSecurityEvent.setAuthenticationType( HttpsTokenSecurityEvent.AuthenticationType.HttpDigestAuthentication );
					 HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl(false, policy.getUserName());
					 httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
					 httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
					 PolicyUtils.assertPolicy(aim, new QName(token.getName().getNamespaceURI(), SPConstants.HTTP_DIGEST_AUTHENTICATION));
				 }
			 }
			 TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);
			 if (tlsInfo != null) {
				 if (token.getAuthenticationType() == HttpsToken.AuthenticationType.RequireClientCertificate) {
					 if (tlsInfo.getPeerCertificates() == null || tlsInfo.getPeerCertificates().length == 0) {
						 asserted = false;
					 }
					 else {
						 PolicyUtils.assertPolicy(aim, new QName(token.getName().getNamespaceURI(), SPConstants.REQUIRE_CLIENT_CERTIFICATE));
					 }
				 }
				 if (tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0) {
					 httpsTokenSecurityEvent.setAuthenticationType( HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication );
					 HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl((X509Certificate)tlsInfo.getPeerCertificates()[0]);
					 httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
					 httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
				 }
				 else if (httpsTokenSecurityEvent.getAuthenticationType() == null) {
					 httpsTokenSecurityEvent.setAuthenticationType( HttpsTokenSecurityEvent.AuthenticationType.HttpsNoAuthentication );
					 HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl();
					 httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
					 httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
				 }
			 }
			 else {
				 asserted = false;
			 }
			 ai.setAsserted(asserted);
			 if (asserted) {
				 securityEvents.add(httpsTokenSecurityEvent);
			 }
		 }
	 }
	 private void assertNonHttpsTransportToken(Message message) throws XMLSecurityException {
		 TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);
		 if (tlsInfo != null) {
			 HttpsTokenSecurityEvent httpsTokenSecurityEvent = new HttpsTokenSecurityEvent();
			 if (tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0) {
				 httpsTokenSecurityEvent.setAuthenticationType( HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication );
				 HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl((X509Certificate)tlsInfo.getPeerCertificates()[0]);
				 httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
				 httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
			 }
			 else if (httpsTokenSecurityEvent.getAuthenticationType() == null) {
				 httpsTokenSecurityEvent.setAuthenticationType( HttpsTokenSecurityEvent.AuthenticationType.HttpsNoAuthentication );
				 HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl();
				 httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
				 httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
			 }
			 List<SecurityEvent> securityEvents = getSecurityEventList(message);
			 securityEvents.add(httpsTokenSecurityEvent);
		 }
	 }
	 private List<SecurityEvent> getSecurityEventList(Message message) {
		 List<SecurityEvent> securityEvents = (List<SecurityEvent>) message.getExchange().get(SecurityEvent.class.getName() + "".out"");
		 if (securityEvents == null) {
			 securityEvents = new ArrayList<>();
			 message.getExchange().put(SecurityEvent.class.getName() + "".out"", securityEvents);
		 }
		 return securityEvents;
	 }
	 private SecurityContext createSecurityContext(final Principal p) {
		 return new SecurityContext() {
			 public Principal getUserPrincipal() {
				 return p;
			 }
			 public boolean isUserInRole(String role) {
				 return false;
			 }
		 }
		;
	 }
 }",1,0,0,0
"class ChangeLogParser {
	 private static final int GET_FILE = 1;
	 private static final int GET_DATE = 2;
	 private static final int GET_COMMENT = 3;
	 private static final int GET_REVISION = 4;
	 private static final int GET_PREVIOUS_REV = 5;
	 private static final SimpleDateFormat INPUT_DATE = new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss"", Locale.US);
	 private static final SimpleDateFormat CVS1129_INPUT_DATE = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss Z"", Locale.US);
	 static {
		 TimeZone utc = TimeZone.getTimeZone(""UTC"");
		 INPUT_DATE.setTimeZone(utc);
		 CVS1129_INPUT_DATE.setTimeZone(utc);
	 }
	 private String file;
	 private String date;
	 private String author;
	 private String comment;
	 private String revision;
	 private String previousRevision;
	 private int status = GET_FILE;
	 private final Hashtable entries = new Hashtable();
	 private final boolean remote;
	 private final String[] moduleNames;
	 private final int[] moduleNameLengths;
	 public ChangeLogParser() {
		 this(false, """", CollectionUtils.EMPTY_LIST);
	 }
	 public ChangeLogParser(boolean remote, String packageName, List modules) {
		 this.remote = remote;
		 ArrayList names = new ArrayList();
		 if (packageName != null) {
			 for (StringTokenizer tok = new StringTokenizer(packageName);
			 tok.hasMoreTokens();
			 ) {
				 names.add(tok.nextToken());
			 }
		 }
		 for (Iterator iter = modules.iterator();
		 iter.hasNext();
		 ) {
			 AbstractCvsTask.Module m = (AbstractCvsTask.Module) iter.next();
			 names.add(m.getName());
		 }
		 moduleNames = (String[]) names.toArray(new String[names.size()]);
		 moduleNameLengths = new int[moduleNames.length];
		 for (int i = 0;
		 i < moduleNames.length;
		 i++) {
			 moduleNameLengths[i] = moduleNames[i].length();
		 }
	 }
	 public CVSEntry[] getEntrySetAsArray() {
		 final CVSEntry[] array = new CVSEntry[ entries.size() ];
		 int i = 0;
		 for (Enumeration e = entries.elements();
		 e.hasMoreElements();
		) {
			 array[i++] = (CVSEntry) e.nextElement();
		 }
		 return array;
	 }
	 public void stdout(final String line) {
		 switch(status) {
			 case GET_FILE: reset();
			 processFile(line);
			 break;
			 case GET_REVISION: processRevision(line);
			 break;
			 case GET_DATE: processDate(line);
			 break;
			 case GET_COMMENT: processComment(line);
			 break;
			 case GET_PREVIOUS_REV: processGetPreviousRevision(line);
			 break;
			 default: break;
		 }
	 }
	 private void processComment(final String line) {
		 final String lineSeparator = System.getProperty(""line.separator"");
		 if (line.equals( ""============================================================================="")) {
			 final int end = comment.length() - lineSeparator.length();
			 comment = comment.substring(0, end);
			 saveEntry();
			 status = GET_FILE;
		 }
		 else if (line.equals(""----------------------------"")) {
			 final int end = comment.length() - lineSeparator.length();
			 comment = comment.substring(0, end);
			 status = GET_PREVIOUS_REV;
		 }
		 else {
			 comment += line + lineSeparator;
		 }
	 }
	 private void processFile(final String line) {
		 if (!remote && line.startsWith(""Working file:"")) {
			 file = line.substring(14, line.length());
			 status = GET_REVISION;
		 }
		 else if (remote && line.startsWith(""RCS file:"")) {
			 int startOfFileName = 0;
			 for (int i = 0;
			 i < moduleNames.length;
			 i++) {
				 int index = line.indexOf(moduleNames[i]);
				 if (index >= 0) {
					 startOfFileName = index + moduleNameLengths[i] + 1;
					 break;
				 }
			 }
			 int endOfFileName = line.indexOf("",v"");
			 if (endOfFileName == -1) {
				 file = line.substring(startOfFileName);
			 }
			 else {
				 file = line.substring(startOfFileName, endOfFileName);
			 }
			 status = GET_REVISION;
		 }
	 }
	 private void processRevision(final String line) {
		 if (line.startsWith(""revision"")) {
			 revision = line.substring(9);
			 status = GET_DATE;
		 }
		 else if (line.startsWith(""======"")) {
			 status = GET_FILE;
		 }
	 }
	 private void processDate(final String line) {
		 if (line.startsWith(""date:"")) {
			 int endOfDateIndex = line.indexOf(';
			');
			 date = line.substring(""date: "".length(), endOfDateIndex);
			 int startOfAuthorIndex = line.indexOf(""author: "", endOfDateIndex + 1);
			 int endOfAuthorIndex = line.indexOf(';
			', startOfAuthorIndex + 1);
			 author = line.substring(""author: "".length() + startOfAuthorIndex, endOfAuthorIndex);
			 status = GET_COMMENT;
			 comment = """";
		 }
	 }
	 private void processGetPreviousRevision(final String line) {
		 if (!line.startsWith(""revision "")) {
			 throw new IllegalStateException(""Unexpected line from CVS: "" + line);
		 }
		 previousRevision = line.substring(""revision "".length());
		 saveEntry();
		 revision = previousRevision;
		 status = GET_DATE;
	 }
	 private void saveEntry() {
		 final String entryKey = date + author + comment;
		 CVSEntry entry;
		 if (!entries.containsKey(entryKey)) {
			 Date dateObject = parseDate(date);
			 entry = new CVSEntry(dateObject, author, comment);
			 entries.put(entryKey, entry);
		 }
		 else {
			 entry = (CVSEntry) entries.get(entryKey);
		 }
		 entry.addFile(file, revision, previousRevision);
	 }
	 private Date parseDate(final String date) {
		 try {
			 return INPUT_DATE.parse(date);
		 }
		 catch (ParseException e) {
			 try {
				 return CVS1129_INPUT_DATE.parse(date);
			 }
			 catch (ParseException e2) {
				 throw new IllegalStateException(""Invalid date format: "" + date);
			 }
		 }
	 }
	 public void reset() {
		 this.file = null;
		 this.date = null;
		 this.author = null;
		 this.comment = null;
		 this.revision = null;
		 this.previousRevision = null;
	 }
}",0,0,0,0
"public class FacesProperty {
	 protected TextMap description = new TextMap();
	 protected TextMap displayName = new TextMap();
	 protected LocalCollection<Icon> icon = new LocalCollection<Icon>();
	 protected java.lang.String propertyName;
	 protected java.lang.String propertyClass;
	 protected java.lang.String defaultValue;
	 protected java.lang.String suggestedValue;
	 protected List<FacesPropertyExtension> propertyExtension;
	 protected java.lang.String id;
	 public Text[] getDescriptions() {
		 return description.toArray();
	 }
	 public void setDescriptions(Text[] text) {
		 description.set(text);
	 }
	 public String getDescription() {
		 return description.get();
	 }
	 public Text[] getDisplayNames() {
		 return displayName.toArray();
	 }
	 public void setDisplayNames(Text[] text) {
		 displayName.set(text);
	 }
	 public String getDisplayName() {
		 return displayName.get();
	 }
	 public Collection<Icon> getIcons() {
		 if (icon == null) {
			 icon = new LocalCollection<Icon>();
		 }
		 return icon;
	 }
	 public Map<String,Icon> getIconMap() {
		 if (icon == null) {
			 icon = new LocalCollection<Icon>();
		 }
		 return icon.toMap();
	 }
	 public Icon getIcon() {
		 return icon.getLocal();
	 }
	 public java.lang.String getPropertyName() {
		 return propertyName;
	 }
	 public void setPropertyName(java.lang.String value) {
		 this.propertyName = value;
	 }
	 public java.lang.String getPropertyClass() {
		 return propertyClass;
	 }
	 public void setPropertyClass(java.lang.String value) {
		 this.propertyClass = value;
	 }
	 public java.lang.String getDefaultValue() {
		 return defaultValue;
	 }
	 public void setDefaultValue(java.lang.String value) {
		 this.defaultValue = value;
	 }
	 public java.lang.String getSuggestedValue() {
		 return suggestedValue;
	 }
	 public void setSuggestedValue(java.lang.String value) {
		 this.suggestedValue = value;
	 }
	 public List<FacesPropertyExtension> getPropertyExtension() {
		 if (propertyExtension == null) {
			 propertyExtension = new ArrayList<FacesPropertyExtension>();
		 }
		 return this.propertyExtension;
	 }
	 public java.lang.String getId() {
		 return id;
	 }
	 public void setId(java.lang.String value) {
		 this.id = value;
	 }
}",1,1,0,0
"public final class JavaClassHelper {
	 private static final String LS = System.getProperty(""line.separator"");
	 public static StringBuffer getConstants(byte[] bytes) throws IOException {
		 final StringBuffer sb = new StringBuffer();
		 final ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
		 final ClassParser parser = new ClassParser(bis, """");
		 final JavaClass javaClass = parser.parse();
		 final Field[] fields = javaClass.getFields();
		 for (int i = 0;
		 i < fields.length;
		 i++) {
			 final Field field = fields[i];
			 if (field != null) {
				 final ConstantValue cv = field.getConstantValue();
				 if (cv != null) {
					 String cvs = cv.toString();
					 if (cvs.startsWith(""\"""") && cvs.endsWith(""\"""")) {
						 cvs = cvs.substring(1, cvs.length() - 1);
					 }
					 sb.append(field.getName());
					 sb.append('=');
					 sb.append(cvs);
					 sb.append(LS);
				 }
			 }
		 }
		 return sb;
	 }
}",0,0,0,0
"public class FilenetConnector extends org.apache.manifoldcf.crawler.connectors.BaseRepositoryConnector{
	 public static final String _rcsid = ""@(#)$Id: FilenetConnector.java 996524 2010-09-13 13:38:01Z kwright $"";
	 public static final String CONFIG_PARAM_USERID = ""User ID"";
	 public static final String CONFIG_PARAM_PASSWORD = ""Password"";
	 public static final String CONFIG_PARAM_FILENETDOMAIN_OLD = ""Filenet domain"";
	 public static final String CONFIG_PARAM_FILENETDOMAIN = ""FileNet domain"";
	 public static final String CONFIG_PARAM_OBJECTSTORE = ""Object store"";
	 public static final String CONFIG_PARAM_SERVERPROTOCOL = ""Server protocol"";
	 public static final String CONFIG_PARAM_SERVERHOSTNAME = ""Server hostname"";
	 public static final String CONFIG_PARAM_SERVERPORT = ""Server port"";
	 public static final String CONFIG_PARAM_SERVERWSILOCATION = ""Server WebServices location"";
	 public static final String CONFIG_PARAM_URLPROTOCOL = ""Document URL protocol"";
	 public static final String CONFIG_PARAM_URLHOSTNAME = ""Document URL hostname"";
	 public static final String CONFIG_PARAM_URLPORT = ""Document URL port"";
	 public static final String CONFIG_PARAM_URLLOCATION = ""Document URL location"";
	 public static final String SPEC_NODE_FOLDER = ""folder"";
	 public static final String SPEC_NODE_MIMETYPE = ""mimetype"";
	 public static final String SPEC_NODE_DOCUMENTCLASS = ""documentclass"";
	 public static final String SPEC_NODE_METADATAFIELD = ""metafield"";
	 public static final String SPEC_NODE_MATCH = ""match"";
	 public static final String SPEC_ATTRIBUTE_VALUE = ""value"";
	 public static final String SPEC_ATTRIBUTE_ALLMETADATA = ""allmetadata"";
	 public static final String SPEC_ATTRIBUTE_MATCHTYPE = ""matchtype"";
	 public static final String SPEC_ATTRIBUTE_FIELDNAME = ""fieldname"";
	 public static final String ACTIVITY_FETCH = ""fetch"";
	 protected static final long timeToRelease = 300000L;
	 protected IFilenet session = null;
	 protected long lastSessionFetch = -1L;
	 protected String userID = null;
	 protected String password = null;
	 protected String filenetDomain = null;
	 protected String objectStore = null;
	 protected String serverProtocol = null;
	 protected String serverHostname = null;
	 protected String serverPort = null;
	 protected String serverLocation = null;
	 protected String serverWSIURI = null;
	 protected String docUrlServerProtocol = null;
	 protected String docUrlServerName = null;
	 protected String docUrlPort = null;
	 protected String docUrlLocation = null;
	 protected String docURIPrefix = null;
	 private final static String defaultAuthorityDenyToken = GLOBAL_DENY_TOKEN;
	 protected class GetSessionThread extends Thread {
		 protected IFilenet rval = null;
		 protected Throwable exception = null;
		 public GetSessionThread() {
			 super();
			 setDaemon(true);
		 }
		 public void run() {
			 try {
				 IFilenetFactory df = (IFilenetFactory)Naming.lookup(""rmi: IFilenet newSession = df.make();
				 newSession.createSession(userID,password,filenetDomain,objectStore,serverWSIURI);
				 session = newSession;
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public void finishUp() throws java.net.MalformedURLException, NotBoundException, RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof java.net.MalformedURLException) throw (java.net.MalformedURLException)thr;
				 else if (thr instanceof NotBoundException) throw (NotBoundException)thr;
				 else if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
		 }
	 }
	 protected void getSession() throws ManifoldCFException, ServiceInterruption {
		 if (session == null) {
			 if (userID == null || userID.length() < 1) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_USERID+"" required but not set"");
			 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: UserID = '"" + userID + ""'"");
			 if (password == null || password.length() < 1) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_PASSWORD+"" required but not set"");
			 Logging.connectors.debug(""FileNet: Password exists"");
			 if (objectStore == null || objectStore.length() < 1) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_OBJECTSTORE+"" required but not set"");
			 if (serverProtocol == null || serverProtocol.length() < 1) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_SERVERPROTOCOL+"" required but not set"");
			 if (serverHostname == null || serverHostname.length() < 1) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_SERVERHOSTNAME+"" required but not set"");
			 if (serverPort != null && serverPort.length() < 1) serverPort = null;
			 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Server URI is '""+serverWSIURI+""'"");
			 if (docUrlServerProtocol == null || docUrlServerProtocol.length() == 0) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_URLPROTOCOL+"" required but not set"");
			 if (docUrlServerName == null || docUrlServerName.length() == 0) throw new ManifoldCFException(""Parameter ""+CONFIG_PARAM_URLHOSTNAME+"" required but not set"");
			 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Document base URI is '""+docURIPrefix+""'"");
			 long currentTime;
			 GetSessionThread t = new GetSessionThread();
			 t.start();
			 try {
				 t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (java.net.MalformedURLException e) {
				 throw new ManifoldCFException(e.getMessage(),e);
			 }
			 catch (NotBoundException e) {
				 Logging.connectors.warn(""FileNet: RMI server not up at the moment: ""+e.getMessage(),e);
				 currentTime = System.currentTimeMillis();
				 throw new ServiceInterruption(e.getMessage(),currentTime + 60000L);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 Logging.connectors.warn(""FileNet: Transient remote exception creating session: ""+e.getMessage(),e);
				 currentTime = System.currentTimeMillis();
				 throw new ServiceInterruption(e.getMessage(),currentTime + 60000L);
			 }
			 catch (FilenetException e) {
				 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) {
					 Logging.connectors.warn(""FileNet: Remote service interruption creating session: ""+e.getMessage(),e);
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(e.getMessage(),e,currentTime + 300000L,currentTime + 12 * 60 * 60000L,-1,true);
				 }
				 throw new ManifoldCFException(e.getMessage(),e);
			 }
		 }
		 lastSessionFetch = System.currentTimeMillis();
	 }
	 protected class DestroySessionThread extends Thread {
		 protected Throwable exception = null;
		 public DestroySessionThread() {
			 super();
			 setDaemon(true);
		 }
		 public void run() {
			 try {
				 session.destroySession();
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public void finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
		 }
	 }
	 protected void releaseCheck() throws ManifoldCFException {
		 if (lastSessionFetch == -1L) return;
		 long currentTime = System.currentTimeMillis();
		 if (currentTime >= lastSessionFetch + timeToRelease) {
			 DestroySessionThread t = new DestroySessionThread();
			 t.start();
			 try {
				 t.finishUp();
				 session = null;
				 lastSessionFetch = -1L;
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 session = null;
				 lastSessionFetch = -1L;
				 Logging.connectors.warn(""FileNet: Transient remote exception closing session: ""+e.getMessage(),e);
			 }
			 catch (FilenetException e) {
				 session = null;
				 lastSessionFetch = -1L;
				 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) {
					 Logging.connectors.warn(""FileNet: Remote service interruption closing session: ""+e.getMessage(),e);
				 }
				 else Logging.connectors.warn(""FileNet: Error closing session: ""+e.getMessage(),e);
			 }
		 }
	 }
	 public FilenetConnector() {
		 super();
	 }
	 public int getConnectorModel() {
		 return MODEL_ADD;
	 }
	 public String[] getBinNames(String documentIdentifier) {
		 return new String[]{
		serverHostname}
		;
	 }
	 public String[] getActivitiesList() {
		 return new String[]{
		ACTIVITY_FETCH}
		;
	 }
	 public void connect(ConfigParams configParams) {
		 super.connect(configParams);
		 userID = configParams.getParameter(CONFIG_PARAM_USERID);
		 password = configParams.getObfuscatedParameter(CONFIG_PARAM_PASSWORD);
		 filenetDomain = configParams.getParameter(CONFIG_PARAM_FILENETDOMAIN);
		 if (filenetDomain == null) {
			 filenetDomain = configParams.getParameter(CONFIG_PARAM_FILENETDOMAIN_OLD);
			 if (filenetDomain == null) filenetDomain = """";
		 }
		 objectStore = configParams.getParameter(CONFIG_PARAM_OBJECTSTORE);
		 serverProtocol = configParams.getParameter(CONFIG_PARAM_SERVERPROTOCOL);
		 serverHostname = configParams.getParameter(CONFIG_PARAM_SERVERHOSTNAME);
		 serverPort = configParams.getParameter(CONFIG_PARAM_SERVERPORT);
		 if (serverPort != null && serverPort.length() < 1) serverPort = null;
		 serverLocation = configParams.getParameter(CONFIG_PARAM_SERVERWSILOCATION);
		 if (serverLocation != null && serverLocation.length() < 1) serverLocation = null;
		 serverWSIURI = ((serverProtocol==null)?"""":serverProtocol) + "": if (serverPort != null) serverWSIURI += "":"" + serverPort;
		 if (serverLocation != null) serverWSIURI += ""/"" + serverLocation;
		 docUrlServerProtocol = configParams.getParameter(CONFIG_PARAM_URLPROTOCOL);
		 docUrlServerName = configParams.getParameter(CONFIG_PARAM_URLHOSTNAME);
		 docUrlPort = configParams.getParameter(CONFIG_PARAM_URLPORT);
		 if (docUrlPort != null && docUrlPort.length() < 1) docUrlPort = null;
		 docUrlLocation = configParams.getParameter(CONFIG_PARAM_URLLOCATION);
		 if (docUrlLocation != null && docUrlLocation.length() < 1) docUrlLocation = null;
		 docURIPrefix = ((docUrlServerProtocol==null)?"""":docUrlServerProtocol) + "": if (docUrlPort != null) docURIPrefix = docURIPrefix + "":"" + docUrlPort;
		 if (docUrlLocation != null) docURIPrefix = docURIPrefix + ""/"" + docUrlLocation;
		 docURIPrefix += ""/getContent?objectStoreName="" + ((objectStore==null)?"""":objectStore);
	 }
	 public String check() throws ManifoldCFException {
		 try {
			 try {
				 checkConnection();
				 return super.check();
			 }
			 catch (FilenetException e) {
				 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),0L);
				 else throw new ManifoldCFException(e.getMessage(),e);
			 }
		 }
		 catch (ServiceInterruption e) {
			 return ""Connection temporarily failed: ""+e.getMessage();
		 }
		 catch (ManifoldCFException e) {
			 return ""Connection failed: ""+e.getMessage();
		 }
	 }
	 public void poll() throws ManifoldCFException {
		 releaseCheck();
	 }
	 public boolean isConnected() {
		 return session != null;
	 }
	 public void disconnect() throws ManifoldCFException {
		 if (session != null) {
			 DestroySessionThread t = new DestroySessionThread();
			 t.start();
			 try {
				 t.finishUp();
				 session = null;
				 lastSessionFetch = -1L;
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 session = null;
				 lastSessionFetch = -1L;
				 Logging.connectors.warn(""FileNet: Transient remote exception closing session: ""+e.getMessage(),e);
			 }
			 catch (FilenetException e) {
				 session = null;
				 lastSessionFetch = -1L;
				 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) {
					 Logging.connectors.warn(""FileNet: Remote service interruption closing session: ""+e.getMessage(),e);
				 }
				 else Logging.connectors.warn(""FileNet: Error closing session: ""+e.getMessage(),e);
			 }
		 }
		 userID = null;
		 password = null;
		 objectStore = null;
		 serverWSIURI = null;
		 serverHostname = null;
		 docURIPrefix = null;
	 }
	 public boolean requestInfo(Configuration output, String command) throws ManifoldCFException {
		 if (command.startsWith(""metadatafields/"")) {
			 String documentClass = command.substring(""metadatafields/"".length());
			 try {
				 MetadataFieldDefinition[] metaFields = getDocumentClassMetadataFieldsDetails(documentClass);
				 int i = 0;
				 while (i < metaFields.length) {
					 MetadataFieldDefinition def = metaFields[i++];
					 ConfigurationNode node = new ConfigurationNode(""metadata_field"");
					 ConfigurationNode child;
					 child = new ConfigurationNode(""display_name"");
					 child.setValue(def.getDisplayName());
					 node.addChild(node.getChildCount(),child);
					 child = new ConfigurationNode(""symbolic_name"");
					 child.setValue(def.getSymbolicName());
					 node.addChild(node.getChildCount(),child);
					 output.addChild(output.getChildCount(),node);
				 }
			 }
			 catch (ServiceInterruption e) {
				 ManifoldCF.createServiceInterruptionNode(output,e);
			 }
			 catch (ManifoldCFException e) {
				 ManifoldCF.createErrorNode(output,e);
			 }
		 }
		 else if (command.equals(""documentclasses"")) {
			 try {
				 DocumentClassDefinition[] definitions = getDocumentClassesDetails();
				 int i = 0;
				 while (i < definitions.length) {
					 DocumentClassDefinition def = definitions[i++];
					 ConfigurationNode node = new ConfigurationNode(""document_class"");
					 ConfigurationNode child;
					 child = new ConfigurationNode(""display_name"");
					 child.setValue(def.getDisplayName());
					 node.addChild(node.getChildCount(),child);
					 child = new ConfigurationNode(""symbolic_name"");
					 child.setValue(def.getSymbolicName());
					 node.addChild(node.getChildCount(),child);
					 output.addChild(output.getChildCount(),node);
				 }
			 }
			 catch (ServiceInterruption e) {
				 ManifoldCF.createServiceInterruptionNode(output,e);
			 }
			 catch (ManifoldCFException e) {
				 ManifoldCF.createErrorNode(output,e);
			 }
		 }
		 else if (command.equals(""mimetypes"")) {
			 try {
				 String[] mimeTypesArray = getMimeTypes();
				 int i = 0;
				 while (i < mimeTypesArray.length) {
					 String mimeType = mimeTypesArray[i++];
					 ConfigurationNode node = new ConfigurationNode(""mime_type"");
					 node.setValue(mimeType);
					 output.addChild(output.getChildCount(),node);
				 }
			 }
			 catch (ServiceInterruption e) {
				 ManifoldCF.createServiceInterruptionNode(output,e);
			 }
			 catch (ManifoldCFException e) {
				 ManifoldCF.createErrorNode(output,e);
			 }
		 }
		 else return super.requestInfo(output,command);
		 return true;
	 }
	 public String[] getChildFolders(String folderName) throws ManifoldCFException, ServiceInterruption {
		 try {
			 if (folderName.startsWith(""/"")) folderName = folderName.substring(1);
			 String[] folderPath;
			 if (folderName.length() == 0) folderPath = new String[0];
			 else folderPath = folderName.split(""/"");
			 String[] rval = doGetChildFolders(folderPath);
			 if (rval == null) return null;
			 java.util.Arrays.sort(rval);
			 return rval;
		 }
		 catch (FilenetException e) {
			 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),0L);
			 else throw new ManifoldCFException(e.getMessage(),e);
		 }
	 }
	 public String addSeedDocuments(ISeedingActivity activities, Specification spec, String lastSeedVersion, long seedTime, int jobMode) throws ManifoldCFException, ServiceInterruption {
		 Logging.connectors.debug(""FileNet: Inside addSeedDocuments"");
		 long startTime;
		 if (lastSeedVersion == null) startTime = 0L;
		 else {
			 startTime = new Long(lastSeedVersion).longValue();
		 }
		 StringBuilder mimeTypesClause = new StringBuilder();
		 int i = 0;
		 while (i < spec.getChildCount()) {
			 SpecificationNode n = spec.getChild(i);
			 if (n.getType().equals(SPEC_NODE_MIMETYPE)) {
				 String mimeType = n.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 if (mimeType != null) {
					 if (mimeTypesClause.length() != 0) mimeTypesClause.append("" or "");
					 mimeTypesClause.append(""[MimeType] = '"").append(mimeType).append(""'"");
				 }
			 }
			 i++;
		 }
		 if (mimeTypesClause.length() == 0) {
			 String[] mimeTypes = getMimeTypes();
			 i = 0;
			 while (i < mimeTypes.length) {
				 String mimeType = mimeTypes[i++];
				 if (mimeTypesClause.length() != 0) mimeTypesClause.append("" or "");
				 mimeTypesClause.append(""[MimeType] = '"").append(mimeType).append(""'"");
			 }
		 }
		 StringBuilder sqlBuffer = new StringBuilder("" WHERE ([IsCurrentVersion] = TRUE AND ("");
		 sqlBuffer.append(mimeTypesClause);
		 sqlBuffer.append("")"");
		 Calendar c = new GregorianCalendar(TimeZone.getTimeZone(""GMT""), Locale.ROOT);
		 long biasTime = 15L * 60000L;
		 if (startTime < biasTime) startTime = 0L;
		 else startTime -= biasTime;
		 if (startTime > 0L) {
			 sqlBuffer.append("" AND [DateLastModified] >= "").append(buildTime(c,startTime));
		 }
		 sqlBuffer.append("" AND [DateLastModified] <= "").append(buildTime(c,seedTime));
		 boolean seenAny = false;
		 i = 0;
		 while (i < spec.getChildCount()) {
			 SpecificationNode n = spec.getChild(i++);
			 if (n.getType().equals(SPEC_NODE_FOLDER)) {
				 if (!seenAny) {
					 sqlBuffer.append("" AND ("");
					 seenAny = true;
				 }
				 else {
					 sqlBuffer.append("" or "");
				 }
				 String folderValue = n.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 sqlBuffer.append(""This INSUBFOLDER ""+quoteSQLString(folderValue));
			 }
		 }
		 if (seenAny) {
			 sqlBuffer.append("")"");
		 }
		 String whereClause = sqlBuffer.toString();
		 i = 0;
		 while (i < spec.getChildCount()) {
			 SpecificationNode n = spec.getChild(i);
			 if (n.getType().equals(SPEC_NODE_DOCUMENTCLASS)) {
				 String dc = n.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 DocClassSpec dcs = new DocClassSpec(n);
				 int matchCount = dcs.getMatchCount();
				 StringBuilder moreWhereClause = new StringBuilder(whereClause);
				 int q = 0;
				 while (q < matchCount) {
					 String matchType = dcs.getMatchType(q);
					 String matchField = dcs.getMatchField(q);
					 String matchValue = dcs.getMatchValue(q);
					 q++;
					 moreWhereClause.append("" AND ["").append(matchField).append(""] "").append(matchType).append("" "") .append(quoteSQLString(matchValue));
				 }
				 moreWhereClause.append("")"");
				 String fullSQL = ""SELECT Id, [VersionSeries] FROM ""+dc+"" WITH EXCLUDESUBCLASSES ""+moreWhereClause.toString()+"" OPTIONS(TIMELIMIT 180)"";
				 long currentTime;
				 try {
					 String[] objectIds = doGetMatchingObjectIds(fullSQL);
					 int j = 0;
					 while (j < objectIds.length) {
						 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Seeding with identifier '""+objectIds[j]+""'"");
						 activities.addSeedDocument(objectIds[j++]);
					 }
				 }
				 catch (FilenetException e) {
					 currentTime = System.currentTimeMillis();
					 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),e,currentTime+300000L,currentTime+12*60*60000L,-1,true);
					 else throw new ManifoldCFException(e.getMessage(),e);
				 }
			 }
			 i++;
		 }
		 return new Long(seedTime).toString();
	 }
	 protected static String quoteSQLString(String value) {
		 StringBuilder sb = new StringBuilder();
		 sb.append('\'');
		 int i = 0;
		 while (i < value.length()) {
			 char x = value.charAt(i++);
			 if (x == '\'') sb.append('\'');
			 sb.append(x);
		 }
		 sb.append('\'');
		 return sb.toString();
	 }
	 protected static String buildTime(Calendar c, long timeValue) {
		 c.setTimeInMillis(timeValue);
		 StringBuilder rval = new StringBuilder();
		 print_int(rval,c.get(Calendar.YEAR),4);
		 print_int(rval,c.get(Calendar.MONTH)+1,2);
		 print_int(rval,c.get(Calendar.DAY_OF_MONTH),2);
		 rval.append(""T"");
		 print_int(rval,c.get(Calendar.HOUR_OF_DAY),2);
		 print_int(rval,c.get(Calendar.MINUTE),2);
		 print_int(rval,c.get(Calendar.SECOND),2);
		 rval.append(""Z"");
		 return rval.toString();
	 }
	 protected static void print_int(StringBuilder sb, int value, int digits) {
		 if (digits == 4) {
			 value = print_digit(sb,value,1000);
			 digits--;
		 }
		 if (digits == 3) {
			 value = print_digit(sb,value,100);
			 digits--;
		 }
		 if (digits == 2) {
			 value = print_digit(sb,value,10);
			 digits--;
		 }
		 if (digits == 1) {
			 print_digit(sb,value,1);
		 }
	 }
	 protected static int print_digit(StringBuilder sb, int value, int divisor) {
		 int digit = value / divisor;
		 int x = '0' + digit;
		 sb.append((char)x);
		 return value - digit * divisor;
	 }
	 public void processDocuments(String[] documentIdentifiers, IExistingVersions statuses, Specification spec, IProcessActivity activities, int jobMode, boolean usesDefaultAuthority) throws ManifoldCFException, ServiceInterruption {
		 Logging.connectors.debug(""FileNet: Inside processDocuments"");
		 SpecInfo dSpec = new SpecInfo(spec);
		 String[] acls = dSpec.getAcls();
		 for (String documentIdentifier : documentIdentifiers) {
			 activities.checkJobStillActive();
			 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""Filenet: Getting version for identifier '""+documentIdentifier+""'"");
			 int cIndex = documentIdentifier.indexOf("","");
			 if (cIndex != -1) {
				 String vId = documentIdentifier.substring(0,cIndex);
				 int elementNumber;
				 try {
					 elementNumber = Integer.parseInt(documentIdentifier.substring(cIndex+1));
				 }
				 catch (NumberFormatException e) {
					 throw new ManifoldCFException(""Bad number in identifier: ""+documentIdentifier,e);
				 }
				 String versionString;
				 String[] aclValues = null;
				 String[] denyAclValues = null;
				 String docClass = null;
				 String[] metadataFieldNames = null;
				 String[] metadataFieldValues = null;
				 FileInfo fileInfo;
				 try {
					 fileInfo = doGetDocumentInformation(vId, dSpec.getMetadataFields());
					 if (fileInfo == null) {
						 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Skipping document '""+documentIdentifier+""' because not a current document"");
						 activities.deleteDocument(documentIdentifier);
						 continue;
					 }
				 }
				 catch (FilenetException e) {
					 long currentTime = System.currentTimeMillis();
					 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),e,currentTime+300000L,currentTime+12*60*60000L,-1,true);
					 else if (e.getType() == FilenetException.TYPE_NOTALLOWED) {
						 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Skipping file '""+documentIdentifier+""' because: ""+e.getMessage(),e);
						 activities.deleteDocument(documentIdentifier);
						 continue;
					 }
					 else throw new ManifoldCFException(e.getMessage(),e);
				 }
				 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""Filenet: Document '""+documentIdentifier+""' is a current document"");
				 StringBuilder versionBuffer = new StringBuilder();
				 docClass = fileInfo.getDocClass();
				 DocClassSpec docclassspec = dSpec.getDocClassSpec(docClass);
				 boolean docMatches = true;
				 for (int q = 0;
				 q < docclassspec.getMatchCount();
				 q++) {
					 String matchType = docclassspec.getMatchType(q);
					 String matchField = docclassspec.getMatchField(q);
					 String matchValue = docclassspec.getMatchValue(q);
					 String matchDocValue = fileInfo.getMetadataValue(matchField);
					 docMatches = performMatch(matchType,matchDocValue,matchValue);
					 if (docMatches == false) break;
				 }
				 if (!docMatches) {
					 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Skipping document '""+documentIdentifier+""' because doesn't match field criteria"");
					 activities.deleteDocument(documentIdentifier);
					 continue;
				 }
				 int metadataCount = 0;
				 Iterator iter = fileInfo.getMetadataIterator();
				 while (iter.hasNext()) {
					 String field = (String)iter.next();
					 if (docclassspec.checkMetadataIncluded(field)) metadataCount++;
				 }
				 metadataFieldNames = new String[metadataCount];
				 int j = 0;
				 iter = fileInfo.getMetadataIterator();
				 while (iter.hasNext()) {
					 String field = (String)iter.next();
					 if (docclassspec.checkMetadataIncluded(field)) metadataFieldNames[j++] = field;
				 }
				 java.util.Arrays.sort(metadataFieldNames);
				 packList(versionBuffer,metadataFieldNames,'+');
				 metadataFieldValues = new String[metadataFieldNames.length];
				 for (int q = 0;
				 q < metadataFieldValues.length;
				 q++) {
					 metadataFieldValues[q] = fileInfo.getMetadataValue(metadataFieldNames[q]);
					 if (metadataFieldValues[q] == null) metadataFieldValues[q] = """";
				 }
				 packList(versionBuffer,metadataFieldValues,'+');
				 if (acls != null && acls.length == 0) {
					 aclValues = new String[fileInfo.getAclCount()];
					 j = 0;
					 iter = fileInfo.getAclIterator();
					 while (iter.hasNext()) {
						 aclValues[j++] = (String)iter.next();
					 }
					 denyAclValues = new String[fileInfo.getDenyAclCount()];
					 j = 0;
					 iter = fileInfo.getDenyAclIterator();
					 while (iter.hasNext()) {
						 denyAclValues[j++] = (String)iter.next();
					 }
				 }
				 else if (acls != null && acls.length > 0) {
					 aclValues = acls;
					 denyAclValues = new String[]{
					defaultAuthorityDenyToken}
					;
				 }
				 if (aclValues != null) {
					 versionBuffer.append('+');
					 java.util.Arrays.sort(aclValues);
					 packList(versionBuffer,aclValues,'+');
					 if (denyAclValues == null) denyAclValues = new String[0];
					 java.util.Arrays.sort(denyAclValues);
					 packList(versionBuffer,denyAclValues,'+');
				 }
				 else versionBuffer.append('-');
				 pack(versionBuffer,docClass,'+');
				 pack(versionBuffer,docURIPrefix,'+');
				 versionString = versionBuffer.toString();
				 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Document identifier '""+documentIdentifier+""' is a document attachment"");
				 String errorCode = null;
				 String errorDesc = null;
				 long startTime = System.currentTimeMillis();
				 Long fileLengthLong = null;
				 try {
					 String uri = convertToURI(docURIPrefix,vId,elementNumber,docClass);
					 if (!activities.checkURLIndexable(uri)) {
						 errorCode = activities.EXCLUDED_URL;
						 errorDesc = ""Excluded because of url ('""+uri+""')"";
						 activities.noDocument(documentIdentifier,versionString);
						 continue;
					 }
					 File objFileTemp = null;
					 try {
						 objFileTemp = File.createTempFile(""_mc_fln_"", null);
					 }
					 catch (IOException e) {
						 errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);
						 errorDesc = e.getMessage();
						 handleIOException(e,documentIdentifier,""creating temporary file"");
					 }
					 try {
						 try {
							 doGetDocumentContents(vId,elementNumber,objFileTemp.getCanonicalPath());
						 }
						 catch (IOException e) {
							 errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);
							 errorDesc = e.getMessage();
							 handleIOException(e,documentIdentifier,""reading document"");
						 }
						 catch (FilenetException e) {
							 errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);
							 errorDesc = e.getMessage();
							 long currentTime = System.currentTimeMillis();
							 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) {
								 throw new ServiceInterruption(e.getMessage(),e,currentTime+300000L,currentTime+12*60*60000L,-1,true);
							 }
							 else if (e.getType() == FilenetException.TYPE_NOTALLOWED) {
								 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Removing file '""+documentIdentifier+""' because: ""+e.getMessage(),e);
								 activities.noDocument(documentIdentifier,versionString);
								 continue;
							 }
							 else {
								 throw new ManifoldCFException(e.getMessage(),e);
							 }
						 }
						 long fileLength = objFileTemp.length();
						 if (!activities.checkLengthIndexable(fileLength)) {
							 errorCode = activities.EXCLUDED_LENGTH;
							 errorDesc = ""Excluded document because of length (""+fileLength+"")"";
							 activities.noDocument(documentIdentifier,versionString);
							 continue;
						 }
						 RepositoryDocument rd = new RepositoryDocument();
						 for (int k = 0;
						 k < metadataFieldNames.length;
						 k++) {
							 String metadataName = metadataFieldNames[k];
							 String metadataValue = metadataFieldValues[k];
							 rd.addField(metadataName,metadataValue);
						 }
						 if (aclValues != null) {
							 rd.setSecurityACL(RepositoryDocument.SECURITY_TYPE_DOCUMENT,aclValues);
						 }
						 if (denyAclValues != null) {
							 rd.setSecurityDenyACL(RepositoryDocument.SECURITY_TYPE_DOCUMENT,denyAclValues);
						 }
						 InputStream is = null;
						 try {
							 is = new FileInputStream(objFileTemp);
						 }
						 catch (IOException e) {
							 errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);
							 errorDesc = e.getMessage();
							 handleIOException(e,documentIdentifier,""Opening temporary file"");
						 }
						 try {
							 rd.setBinary(is, fileLength);
							 try {
								 activities.ingestDocumentWithException(documentIdentifier,versionString,uri,rd);
								 errorCode = ""OK"";
								 fileLengthLong = new Long(fileLength);
							 }
							 catch (IOException e) {
								 errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);
								 errorDesc = e.getMessage();
								 handleIOException(e,documentIdentifier,""ingesting document"");
							 }
						 }
						 finally {
							 try {
								 is.close();
							 }
							 catch (IOException e) {
								 errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);
								 errorDesc = e.getMessage();
								 handleIOException(e,documentIdentifier,""closing input stream"");
							 }
						 }
					 }
					 finally {
						 objFileTemp.delete();
					 }
				 }
				 catch (ManifoldCFException e) {
					 if (e.getErrorCode() == ManifoldCFException.INTERRUPTED) errorCode = null;
					 throw e;
				 }
				 finally {
					 if (errorCode != null) activities.recordActivity(new Long(startTime),ACTIVITY_FETCH, fileLengthLong,documentIdentifier,errorCode,errorDesc,null);
				 }
			 }
			 else {
				 Integer count;
				 try {
					 count = doGetDocumentContentCount(documentIdentifier);
					 if (count == null) {
						 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Removing version '""+documentIdentifier+""' because it seems to no longer exist"");
						 activities.deleteDocument(documentIdentifier);
						 continue;
					 }
				 }
				 catch (FilenetException e) {
					 long currentTime = System.currentTimeMillis();
					 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),e,currentTime+300000L,currentTime+12*60*60000L,-1,true);
					 else if (e.getType() == FilenetException.TYPE_NOTALLOWED) {
						 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: Skipping file '""+documentIdentifier+""' because: ""+e.getMessage(),e);
						 activities.deleteDocument(documentIdentifier);
						 continue;
					 }
					 else throw new ManifoldCFException(e.getMessage(),e);
				 }
				 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""FileNet: There are ""+count.toString()+"" content values for '""+documentIdentifier+""'"");
				 for (int q = 0;
				 q < count.intValue();
				 q++) {
					 if (Logging.connectors.isDebugEnabled()) Logging.connectors.debug(""Filenet: Adding document identifier '""+documentIdentifier+"",""+Integer.toString(q)+""'"");
					 activities.addDocumentReference(documentIdentifier + "","" + Integer.toString(q));
				 }
				 activities.noDocument(documentIdentifier,"""");
				 continue;
			 }
		 }
	 }
	 protected static void handleIOException(IOException e, String documentIdentifier, String context) throws ManifoldCFException, ServiceInterruption {
		 if (e instanceof java.net.SocketTimeoutException) {
			 long currentTime = System.currentTimeMillis();
			 throw new ServiceInterruption(""Socket timeout ""+context+"": ""+e.getMessage(),e,currentTime+300000L,currentTime+1*60*60000L,5,true);
		 }
		 if (e instanceof InterruptedIOException) {
			 throw new ManifoldCFException(e.getMessage(),e,ManifoldCFException.INTERRUPTED);
		 }
		 Logging.connectors.error(""FileNet: IO exception on '""+documentIdentifier+""' while ""+context+"": ""+e.getMessage(),e);
		 throw new ManifoldCFException(""IO exception ""+context+"": ""+e.getMessage(),e);
	 }
	 protected static boolean performMatch(String matchType, String matchDocValue, String matchValue) {
		 if (matchType.equals(""="")) return matchDocValue.equalsIgnoreCase(matchValue);
		 else if (matchType.equals(""!="")) return !matchDocValue.equalsIgnoreCase(matchValue);
		 return likeMatch(matchDocValue,0,matchValue,0);
	 }
	 protected static boolean likeMatch(String matchDocValue, int matchDocPos, String matchValue, int matchPos) {
		 if (matchPos == matchValue.length()) {
			 return matchDocPos == matchDocValue.length();
		 }
		 if (matchDocPos == matchDocValue.length()) {
			 return matchValue.charAt(matchPos) == '%' && likeMatch(matchDocValue,matchDocPos,matchValue,matchPos+1);
		 }
		 char x = matchDocValue.charAt(matchDocPos);
		 char y = matchValue.charAt(matchPos);
		 if (y != '%') return Character.toLowerCase(x) == Character.toLowerCase(y) && likeMatch(matchDocValue,matchDocPos+1,matchValue,matchPos+1);
		 return likeMatch(matchDocValue,matchDocPos+1,matchValue,matchPos) || likeMatch(matchDocValue,matchDocPos,matchValue,matchPos+1);
	 }
	 public int getMaxDocumentRequest() {
		 return 1;
	 }
	 public void outputConfigurationHeader(IThreadContext threadContext, IHTTPOutput out, Locale locale, ConfigParams parameters, List<String> tabsArray) throws ManifoldCFException, IOException {
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.Server""));
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.ObjectStore""));
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.DocumentURL""));
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.Credentials""));
		 out.print(""<script type=\""text/javascript\"">\n""+""<!--\n""+""function checkConfig()\n""+""{
			\n""+"" if (editconnection.serverport.value != \""\"" && !isInteger(editconnection.serverport.value))\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheServerPortMustBeAnInteger"") + ""\"");
				\n""+"" editconnection.serverport.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.urlport.value != \""\"" && !isInteger(editconnection.urlport.value))\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheDocumentURLPortMustBeAnInteger"") + ""\"");
				\n""+"" editconnection.urlport.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+""\n""+"" return true;
		\n""+""}
		\n""+""\n""+""function checkConfigForSave()\n""+""{
			\n""+"" if (editconnection.serverhostname.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheConnectionRequiresAFileNetHostName"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.Server"") + ""\"");
				\n""+"" editconnection.serverhostname.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.serverport.value != \""\"" && !isInteger(editconnection.serverport.value))\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheServerPortMustBeAnInteger"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.Server"") + ""\"");
				\n""+"" editconnection.serverport.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.urlhostname.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheDocumentURLRequiresAHostName"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.DocumentURL"") + ""\"");
				\n""+"" editconnection.urlhostname.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.urlport.value != \""\"" && !isInteger(editconnection.urlport.value))\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheDocumentURLPortMustBeAnInteger"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.DocumentURL"") + ""\"");
				\n""+"" editconnection.urlport.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+""\n""+"" if (editconnection.filenetdomain.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheFileNetDomainNameCannotBeNull"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.ObjectStore"") + ""\"");
				\n""+"" editconnection.filenetdomain.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.objectstore.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheObjectStoreNameCannotBeNull"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.ObjectStore"") + ""\"");
				\n""+"" editconnection.objectstore.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.userid.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheConnectionRequiresAValidFileNetUserID"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.Credentials"") + ""\"");
				\n""+"" editconnection.userid.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" if (editconnection.password.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.TheConnectionRequiresTheFileNetUsersPassword"") + ""\"");
				\n""+"" SelectTab(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.Credentials"") + ""\"");
				\n""+"" editconnection.password.focus();
				\n""+"" return false;
			\n""+"" }
			\n""+"" return true;
		\n""+""}
		\n""+""\n""+""""</script>\n"" );
	 }
	 public void outputConfigurationBody(IThreadContext threadContext, IHTTPOutput out, Locale locale, ConfigParams parameters, String tabName) throws ManifoldCFException, IOException {
		 String userID = parameters.getParameter(CONFIG_PARAM_USERID);
		 if (userID == null) userID = """";
		 String password = parameters.getObfuscatedParameter(CONFIG_PARAM_PASSWORD);
		 if (password == null) password = """";
		 else password = out.mapPasswordToKey(password);
		 String filenetdomain = parameters.getParameter(CONFIG_PARAM_FILENETDOMAIN);
		 if (filenetdomain == null) {
			 filenetdomain = parameters.getParameter(CONFIG_PARAM_FILENETDOMAIN_OLD);
			 if (filenetdomain == null) filenetdomain = """";
		 }
		 String objectstore = parameters.getParameter(CONFIG_PARAM_OBJECTSTORE);
		 if (objectstore == null) objectstore = """";
		 String serverprotocol = parameters.getParameter(CONFIG_PARAM_SERVERPROTOCOL);
		 if (serverprotocol == null) serverprotocol = ""http"";
		 String serverhostname = parameters.getParameter(CONFIG_PARAM_SERVERHOSTNAME);
		 if (serverhostname == null) serverhostname = """";
		 String serverport = parameters.getParameter(CONFIG_PARAM_SERVERPORT);
		 if (serverport == null) serverport = """";
		 String serverwsilocation = parameters.getParameter(CONFIG_PARAM_SERVERWSILOCATION);
		 if (serverwsilocation == null) serverwsilocation = ""wsi/FNCEWS40DIME"";
		 String urlprotocol = parameters.getParameter(CONFIG_PARAM_URLPROTOCOL);
		 if (urlprotocol == null) urlprotocol = ""http"";
		 String urlhostname = parameters.getParameter(CONFIG_PARAM_URLHOSTNAME);
		 if (urlhostname == null) urlhostname = """";
		 String urlport = parameters.getParameter(CONFIG_PARAM_URLPORT);
		 if (urlport == null) urlport = """";
		 String urllocation = parameters.getParameter(CONFIG_PARAM_URLLOCATION);
		 if (urllocation == null) urllocation = ""Workplace/Browse.jsp"";
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.Server""))) {
			 out.print(""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.ServerProtocol"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n""+"" <select name=\""serverprotocol\"" size=\""2\"">\n""+"" <option value=\""http\"" ""+(serverprotocol.equals(""http"")?""selected=\""true\"""":"""")+"">http</option>\n""+"" <option value=\""https\"" ""+(serverprotocol.equals(""https"")?""selected=\""true\"""":"""")+"">https</option>\n""+"" </select>\n""+"" </td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.ServerHostName"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""serverhostname\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverhostname)+""\""/></td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.ServerPort"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""5\"" name=\""serverport\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverport)+""\""/></td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.ServerWebServiceLocation"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""serverwsilocation\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverwsilocation)+""\""/></td>\n""+"" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""serverprotocol\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverprotocol)+""\""/>\n""+""<input type=\""hidden\"" name=\""serverhostname\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverhostname)+""\""/>\n""+""<input type=\""hidden\"" name=\""serverport\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverport)+""\""/>\n""+""<input type=\""hidden\"" name=\""serverwsilocation\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(serverwsilocation)+""\""/>\n"" );
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.DocumentURL""))) {
			 out.print(""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.DocumentURLProtocol"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n""+"" <select name=\""urlprotocol\"" size=\""2\"">\n""+"" <option value=\""http\"" ""+(serverprotocol.equals(""http"")?""selected=\""true\"""":"""")+"">http</option>\n""+"" <option value=\""https\"" ""+(serverprotocol.equals(""https"")?""selected=\""true\"""":"""")+"">https</option>\n""+"" </select>\n""+"" </td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.DocumentURLHostName"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""urlhostname\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urlhostname)+""\""/></td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.DocumentURLPort"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""5\"" name=\""urlport\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urlport)+""\""/></td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.DocumentURLLocation"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""urllocation\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urllocation)+""\""/></td>\n""+"" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""urlprotocol\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urlprotocol)+""\""/>\n""+""<input type=\""hidden\"" name=\""urlhostname\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urlhostname)+""\""/>\n""+""<input type=\""hidden\"" name=\""urlport\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urlport)+""\""/>\n""+""<input type=\""hidden\"" name=\""urllocation\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(urllocation)+""\""/>\n"" );
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.ObjectStore""))) {
			 out.print(""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.FileNetDomainName"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""filenetdomain\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(filenetdomain)+""\""/></td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.ObjectStoreName"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""objectstore\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(objectstore)+""\""/></td>\n""+"" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""filenetdomain\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(filenetdomain)+""\""/>\n""+""<input type=\""hidden\"" name=\""objectstore\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(objectstore)+""\""/>\n"" );
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.Credentials""))) {
			 out.print(""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.UserID"") + ""</nobr></td><td class=\""value\""><input type=\""text\"" size=\""32\"" name=\""userid\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(userID)+""\""/></td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Password"") + ""</nobr></td><td class=\""value\""><input type=\""password\"" size=\""32\"" name=\""password\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(password)+""\""/></td>\n""+"" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""userid\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(userID)+""\""/>\n""+""<input type=\""hidden\"" name=\""password\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(password)+""\""/>\n"" );
		 }
	 }
	 public String processConfigurationPost(IThreadContext threadContext, IPostParameters variableContext, Locale locale, ConfigParams parameters) throws ManifoldCFException {
		 String serverprotocol = variableContext.getParameter(""serverprotocol"");
		 if (serverprotocol != null) parameters.setParameter(CONFIG_PARAM_SERVERPROTOCOL,serverprotocol);
		 String serverhostname = variableContext.getParameter(""serverhostname"");
		 if (serverhostname != null) parameters.setParameter(CONFIG_PARAM_SERVERHOSTNAME,serverhostname);
		 String serverport = variableContext.getParameter(""serverport"");
		 if (serverport != null && serverport.length() > 0) parameters.setParameter(CONFIG_PARAM_SERVERPORT,serverport);
		 String serverwsilocation = variableContext.getParameter(""serverwsilocation"");
		 if (serverwsilocation != null) parameters.setParameter(CONFIG_PARAM_SERVERWSILOCATION,serverwsilocation);
		 String urlprotocol = variableContext.getParameter(""urlprotocol"");
		 if (urlprotocol != null) parameters.setParameter(CONFIG_PARAM_URLPROTOCOL,urlprotocol);
		 String urlhostname = variableContext.getParameter(""urlhostname"");
		 if (urlhostname != null) parameters.setParameter(CONFIG_PARAM_URLHOSTNAME,urlhostname);
		 String urlport = variableContext.getParameter(""urlport"");
		 if (urlport != null && urlport.length() > 0) parameters.setParameter(CONFIG_PARAM_URLPORT,urlport);
		 String urllocation = variableContext.getParameter(""urllocation"");
		 if (urllocation != null) parameters.setParameter(CONFIG_PARAM_URLLOCATION,urllocation);
		 String userID = variableContext.getParameter(""userid"");
		 if (userID != null) parameters.setParameter(CONFIG_PARAM_USERID,userID);
		 String password = variableContext.getParameter(""password"");
		 if (password != null) parameters.setObfuscatedParameter(CONFIG_PARAM_PASSWORD,variableContext.mapKeyToPassword(password));
		 String filenetdomain = variableContext.getParameter(""filenetdomain"");
		 if (filenetdomain != null) parameters.setParameter(CONFIG_PARAM_FILENETDOMAIN,filenetdomain);
		 String objectstore = variableContext.getParameter(""objectstore"");
		 if (objectstore != null) parameters.setParameter(CONFIG_PARAM_OBJECTSTORE,objectstore);
		 return null;
	 }
	 public void viewConfiguration(IThreadContext threadContext, IHTTPOutput out, Locale locale, ConfigParams parameters) throws ManifoldCFException, IOException {
		 out.print(""<table class=\""displaytable\"">\n""+"" <tr>\n""+"" <td class=\""description\"" colspan=\""1\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Parameters"") + ""</nobr></td>\n""+"" <td class=\""value\"" colspan=\""3\"">\n"" );
		 Iterator iter = parameters.listParameters();
		 while (iter.hasNext()) {
			 String param = (String)iter.next();
			 String value = parameters.getParameter(param);
			 if (param.length() >= ""password"".length() && param.substring(param.length()-""password"".length()).equalsIgnoreCase(""password"")) {
				 out.print("" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(param)+""=********</nobr><br/>\n"" );
			 }
			 else if (param.length() >=""keystore"".length() && param.substring(param.length()-""keystore"".length()).equalsIgnoreCase(""keystore"")) {
				 IKeystoreManager kmanager = KeystoreManagerFactory.make("""",value);
				 out.print("" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(param)+""=&lt;
				""+Integer.toString(kmanager.getContents().length)+"" certificate(s)&gt;
				</nobr><br/>\n"" );
			 }
			 else {
				 out.print("" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(param)+""=""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(value)+""</nobr><br/>\n"" );
			 }
		 }
		 out.print("" </td>\n""+"" </tr>\n""+""</table>\n"" );
	 }
	 public void outputSpecificationHeader(IHTTPOutput out, Locale locale, Specification ds, int connectionSequenceNumber, List<String> tabsArray) throws ManifoldCFException, IOException {
		 String seqPrefix = ""s""+connectionSequenceNumber+""_"";
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.DocumentClasses""));
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.MimeTypes""));
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.Folders""));
		 tabsArray.add(Messages.getString(locale,""FilenetConnector.Security""));
		 out.print(""<script type=\""text/javascript\"">\n""+""<!--\n""+""\n""+""function ""+seqPrefix+""SpecOp(n, opValue, anchorvalue)\n""+""{
			\n""+"" eval(\""editjob.\""+n+\"".value = \\\""\""+opValue+\""\\\""\"");
			\n""+"" postFormSetAnchor(anchorvalue);
		\n""+""}
		\n""+""\n""+""function ""+seqPrefix+""SpecAddToPath(anchorvalue)\n""+""{
			\n""+"" if (editjob.""+seqPrefix+""pathaddon.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.SelectAFolderFirst"") + ""\"");
				\n""+"" editjob.""+seqPrefix+""pathaddon.focus();
				\n""+"" return;
			\n""+"" }
			\n""+"" ""+seqPrefix+""SpecOp(\""""+seqPrefix+""pathop\"",\""AddToPath\"",anchorvalue);
		\n""+""}
		\n""+""\n""+""function ""+seqPrefix+""SpecAddMatch(docclass, anchorvalue)\n""+""{
			\n""+"" if (eval(\""editjob.""+seqPrefix+""matchfield_\""+docclass+\"".value\"") == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.SelectAFieldFirst"") + ""\"");
				\n""+"" eval(\""editjob.""+seqPrefix+""matchfield_\""+docclass+\"".focus()\"");
				\n""+"" return;
			\n""+"" }
			\n""+"" if (eval(\""editjob.""+seqPrefix+""matchtype_\""+docclass+\"".value\"") == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.SelectAMatchType"") + ""\"");
				\n""+"" eval(\""editjob.""+seqPrefix+""matchtype_\""+docclass+\"".focus()\"");
				\n""+"" return;
			\n""+"" }
			\n""+""\n""+"" ""+seqPrefix+""SpecOp(\""""+seqPrefix+""matchop_\""+docclass,\""Add\"",anchorvalue);
		\n""+""}
		\n""+""\n""+""function ""+seqPrefix+""SpecAddToken(anchorvalue)\n""+""{
			\n""+"" if (editjob.""+seqPrefix+""spectoken.value == \""\"")\n""+"" {
				\n""+"" alert(\"""" + Messages.getBodyJavascriptString(locale,""FilenetConnector.NullTokensNotAllowed"") + ""\"");
				\n""+"" editjob.""+seqPrefix+""spectoken.focus();
				\n""+"" return;
			\n""+"" }
			\n""+""\n""+"" ""+seqPrefix+""SpecOp(\""""+seqPrefix+""accessop\"",\""Add\"",anchorvalue);
		\n""+""}
		\n""+""\n""+""""</script>\n"" );
	 }
	 public void outputSpecificationBody(IHTTPOutput out, Locale locale, Specification ds, int connectionSequenceNumber, int actualSequenceNumber, String tabName) throws ManifoldCFException, IOException {
		 String seqPrefix = ""s""+connectionSequenceNumber+""_"";
		 int i;
		 int k;
		 Iterator iter;
		 HashMap documentClasses = new HashMap();
		 i = 0;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(SPEC_NODE_DOCUMENTCLASS)) {
				 String value = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec spec = new org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec(sn);
				 documentClasses.put(value,spec);
			 }
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.Folders"")) && actualSequenceNumber == connectionSequenceNumber) {
			 out.print(""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n"" );
			 i = 0;
			 k = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i++);
				 if (sn.getType().equals(SPEC_NODE_FOLDER)) {
					 String pathDescription = ""_""+Integer.toString(k);
					 String pathOpName = seqPrefix+""pathop""+pathDescription;
					 String startPath = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
					 out.print("" <tr>\n""+"" <td class=\""value\"">\n""+"" <a name=\""""+seqPrefix+""path_""+Integer.toString(k)+""\"">\n""+"" <input type=\""button\"" value=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Delete"") + ""\"" alt=\""""+Messages.getAttributeString(locale,""FilenetConnector.DeletePath"")+Integer.toString(k)+""\"" onClick='Javascript:""+seqPrefix+""SpecOp(\""""+pathOpName+""\"",\""Delete\"",\""""+seqPrefix+""path_""+Integer.toString(k)+""\"")'/>\n""+"" </a>&nbsp;
					\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""specpath""+pathDescription+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(startPath)+""\""/>\n""+"" <input type=\""hidden\"" name=\""""+pathOpName+""\"" value=\""\""/>\n""+"" <nobr>""+((startPath.length() == 0)?""(root)"":org.apache.manifoldcf.ui.util.Encoder.bodyEscape(startPath))+""</nobr>\n""+"" </td>\n""+"" </tr>\n"" );
					 k++;
				 }
			 }
			 if (k == 0) {
				 out.print("" <tr>\n""+"" <td class=\""message\"" colspan=\""2\"">"" + Messages.getBodyString(locale,""FilenetConnector.NoFoldersChosen"") + ""</td>\n""+"" </tr>\n"" );
			 }
			 out.print("" <tr><td class=\""lightseparator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""value\"" colspan=\""2\"">\n""+"" <nobr>\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""pathcount\"" value=\""""+Integer.toString(k)+""\""/>\n""+"" <a name=\""""+seqPrefix+""path_""+Integer.toString(k)+""\"">\n"" );
			 String pathSoFar = (String)currentContext.get(seqPrefix+""specpath"");
			 if (pathSoFar == null) pathSoFar = ""/"";
			 try {
				 String[] childList;
				 childList = getChildFolders(pathSoFar);
				 if (childList == null) {
					 pathSoFar = ""/"";
					 childList = getChildFolders(""/"");
					 if (childList == null) throw new ManifoldCFException(""Can't find any children for root folder"");
				 }
				 out.print("" <input type=\""hidden\"" name=\""""+seqPrefix+""specpath\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(pathSoFar)+""\""/>\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""pathop\"" value=\""\""/>\n""+"" <input type=\""button\"" value=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Add"") + ""\"" alt=\"""" + Messages.getAttributeString(locale,""FilenetConnector.AddPath"") + ""\"" onClick='Javascript:""+seqPrefix+""SpecOp(\""pathop\"",\""Add\"",\""""+seqPrefix+""path_""+Integer.toString(k+1)+""\"")'/>\n""+"" &nbsp;
				""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(pathSoFar)+""\n"" );
				 if (pathSoFar.length() > 0 && !pathSoFar.equals(""/"")) {
					 out.print("" <input type=\""button\"" value=\""-\"" alt=\"""" + Messages.getAttributeString(locale,""FilenetConnector.RemoveFromPath"") + ""\"" onClick='Javascript:""+seqPrefix+""SpecOp(\""pathop\"",\""Up\"",\""path_""+Integer.toString(k)+""\"")'/>\n"" );
				 }
				 if (childList.length > 0) {
					 out.print("" <nobr>\n""+"" <input type=\""button\"" value=\""+\"" alt=\"""" + Messages.getAttributeString(locale,""FilenetConnector.AddToPath"") + ""\"" onClick='Javascript:""+seqPrefix+""SpecAddToPath(\""""+seqPrefix+""path_""+Integer.toString(k)+""\"")'/>&nbsp;
					\n""+"" <select multiple=\""false\"" name=\""""+seqPrefix+""pathaddon\"" size=\""4\"">\n""+"" <option value=\""\"" selected=\""selected\"">-- "" + Messages.getBodyString(locale,""FilenetConnector.PickAFolder"") + "" --</option>\n"" );
					 int j = 0;
					 while (j < childList.length) {
						 String attrFolder = org.apache.manifoldcf.ui.util.Encoder.attributeEscape(childList[j]);
						 String bodyFolder = org.apache.manifoldcf.ui.util.Encoder.bodyEscape(childList[j]);
						 out.print("" <option value=\""""+attrFolder+""\"">""+bodyFolder+""</option>\n"" );
						 j++;
					 }
					 out.print("" </select>\n""+"" </nobr>\n"" );
				 }
			 }
			 catch (ManifoldCFException e) {
				 e.printStackTrace();
				 out.println(org.apache.manifoldcf.ui.util.Encoder.bodyEscape(e.getMessage()));
			 }
			 catch (ServiceInterruption e) {
				 e.printStackTrace();
				 out.println(org.apache.manifoldcf.ui.util.Encoder.bodyEscape(""Transient error - ""+e.getMessage()));
			 }
			 out.print("" </a>\n""+"" </nobr>\n""+"" </td>\n""+"" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 i = 0;
			 k = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i++);
				 if (sn.getType().equals(SPEC_NODE_FOLDER)) {
					 String pathDescription = ""_""+Integer.toString(k);
					 String startPath = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
					 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""specpath""+pathDescription+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(startPath)+""\""/>\n"" );
					 k++;
				 }
			 }
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""pathcount\"" value=\""""+Integer.toString(k)+""\""/>\n"" );
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.DocumentClasses"")) && actualSequenceNumber == connectionSequenceNumber) {
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""hasdocumentclasses\"" value=\""true\""/>\n""+""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n"" );
			 org.apache.manifoldcf.crawler.common.filenet.DocumentClassDefinition[] documentClassArray = null;
			 HashMap documentClassFields = new HashMap();
			 String message = null;
			 try {
				 documentClassArray = getDocumentClassesDetails();
				 int j = 0;
				 while (j < documentClassArray.length) {
					 String documentClass = documentClassArray[j++].getSymbolicName();
					 org.apache.manifoldcf.crawler.common.filenet.MetadataFieldDefinition[] metaFields = getDocumentClassMetadataFieldsDetails(documentClass);
					 documentClassFields.put(documentClass,metaFields);
				 }
			 }
			 catch (ManifoldCFException e) {
				 message = e.getMessage();
			 }
			 catch (ServiceInterruption e) {
				 message = ""FileNet server temporarily unavailable: ""+e.getMessage();
			 }
			 if (message != null) {
				 out.print("" <tr><td class=\""message\"" colspan=\""2\"">""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(message)+""</td></tr>\n"" );
			 }
			 else {
				 i = 0;
				 while (i < documentClassArray.length) {
					 org.apache.manifoldcf.crawler.common.filenet.DocumentClassDefinition def = documentClassArray[i++];
					 String documentClass = def.getSymbolicName();
					 String displayName = def.getDisplayName();
					 org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec spec = (org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec)documentClasses.get(documentClass);
					 out.print("" <tr>\n""+"" <td class=\""description\"">\n""+"" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(documentClass+"" (""+displayName+"")"")+"":</nobr>\n""+"" </td>\n""+"" <td class=\""boxcell\"">\n""+"" <table class=\""displaytable\"">\n""+"" <tr>\n""+"" <td class=\""description\"">\n""+"" <nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Include"") + ""</nobr>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <nobr><input type=\""checkbox\"" name=\""""+seqPrefix+""documentclasses\"" ""+((spec != null)?""checked=\""true\"""":"""")+"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\""></input></nobr>\n""+"" </td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\"">\n""+"" <nobr>"" + Messages.getBodyString(locale,""FilenetConnector.DocumentCriteria"") + ""</nobr>\n""+"" </td>\n""+"" <td class=\""boxcell\"">\n""+"" <table class=\""displaytable\"">\n"" );
					 org.apache.manifoldcf.crawler.common.filenet.MetadataFieldDefinition[] fields = (org.apache.manifoldcf.crawler.common.filenet.MetadataFieldDefinition[])documentClassFields.get(documentClass);
					 String[] fieldArray = new String[fields.length];
					 HashMap fieldMap = new HashMap();
					 int j = 0;
					 while (j < fieldArray.length) {
						 org.apache.manifoldcf.crawler.common.filenet.MetadataFieldDefinition field = fields[j];
						 fieldArray[j++] = field.getSymbolicName();
						 fieldMap.put(field.getSymbolicName(),field.getDisplayName());
					 }
					 java.util.Arrays.sort(fieldArray);
					 int q = 0;
					 int matchCount = ((spec==null)?0:spec.getMatchCount());
					 while (q < matchCount) {
						 String matchType = spec.getMatchType(q);
						 String matchField = spec.getMatchField(q);
						 String matchValue = spec.getMatchValue(q);
						 String opName = seqPrefix+""matchop_"" + org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass) + ""_"" +Integer.toString(q);
						 String labelName = seqPrefix+""match_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""_""+Integer.toString(q);
						 out.print("" <tr>\n""+"" <td class=\""description\"">\n""+"" <input type=\""hidden\"" name=\""""+opName+""\"" value=\""\""/>\n""+"" <a name=\""""+labelName+""\"">\n""+"" <input type=\""button\"" value=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Delete"") + ""\"" alt=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Delete"") + documentClass+"" match # ""+Integer.toString(q)+""\"" onClick='Javascript:""+seqPrefix+""SpecOp(\""""+opName+""\"",\""Delete\"",\""""+labelName+""\"")'/>\n""+"" </a>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""matchfield_"" + org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass) + ""_"" + Integer.toString(q)+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(matchField)+""\""/>\n""+"" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(matchField)+""</nobr>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""matchtype_"" + org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass) + ""_"" + Integer.toString(q)+""\"" value=\""""+matchType+""\""/>\n""+"" <nobr>""+matchType+""</nobr>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""matchvalue_"" + org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass) + ""_"" + Integer.toString(q)+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(matchValue)+""\""/>\n""+"" <nobr>\""""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(matchValue)+""\""</nobr>\n""+"" </td>\n""+"" </tr>\n"" );
						 q++;
					 }
					 if (q == 0) {
						 out.print("" <tr><td class=\""message\"" colspan=\""4\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.NoCriteriaSpecified"") + ""</nobr></td></tr>\n"" );
					 }
					 String addLabelName = seqPrefix+""match_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""_""+Integer.toString(q);
					 String addOpName = seqPrefix+""matchop_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass);
					 out.print("" <tr><td class=\""lightseparator\"" colspan=\""4\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\"">\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""matchcount_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" value=\""""+Integer.toString(matchCount)+""\""/>\n""+"" <input type=\""hidden\"" name=\""""+addOpName+""\"" value=\""\""/>\n""+"" <a name=\""""+addLabelName+""\"">\n""+"" <input type=\""button\"" value=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Add"") + ""\"" alt=\"""" + Messages.getAttributeString(locale,""FilenetConnector.AddMatchFor"") +org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" onClick='Javascript:""+seqPrefix+""SpecAddMatch(\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"",\""""+seqPrefix+""match_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""_""+Integer.toString(q+1)+""\"")'/>\n""+"" </a>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <select name=\""""+seqPrefix+""matchfield_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" size=\""5\"">\n"" );
					 q = 0;
					 while (q < fieldArray.length) {
						 String field = fieldArray[q++];
						 String dName = (String)fieldMap.get(field);
						 out.print("" <option value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(field)+""\"">""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(field+"" (""+dName+"")"")+""</option>\n"" );
					 }
					 out.print("" </select>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <select name=\""""+seqPrefix+""matchtype_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"">\n""+"" <option value=\""=\"">"" + Messages.getBodyString(locale,""FilenetConnector.Equals"") + ""</option>\n""+"" <option value=\""!=\"">"" + Messages.getBodyString(locale,""FilenetConnector.NotEquals"") + ""</option>\n""+"" <option value=\""LIKE\"">"" + Messages.getBodyString(locale,""FilenetConnector.Like"") + ""</option>\n""+"" </select>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <input name=\""""+seqPrefix+""matchvalue_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" type=\""text\"" size=\""32\"" value=\""\""/>\n""+"" </td>\n""+"" </tr>\n""+"" </table>\n""+"" </td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\"">\n""+"" <nobr>"" + Messages.getBodyString(locale,""FilenetConnector.IngestAllMetadataFields"") + ""</nobr>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <nobr><input type=\""checkbox\"" name=\""""+seqPrefix+""allmetadata_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" value=\""true\"" ""+((spec != null && spec.getAllMetadata())?""checked=\""\"""":"""")+""></input></nobr><br/>\n""+"" </td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\"">\n""+"" <nobr>"" + Messages.getBodyString(locale,""FilenetConnector.MetadataFields"") + ""</nobr>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <nobr>\n""+"" <select name=\""""+seqPrefix+""metadatafield_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" multiple=\""true\"" size=\""5\"">\n"" );
					 j = 0;
					 while (j < fieldArray.length) {
						 String field = fieldArray[j++];
						 String dName = (String)fieldMap.get(field);
						 out.print("" <option value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(field)+""\"" ""+((spec!=null && spec.getAllMetadata() == false && spec.checkMetadataIncluded(field))?""selected=\""true\"""":"""")+"">""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(field+"" (""+dName+"")"")+""</option>\n"" );
					 }
					 out.print("" </select>\n""+"" </nobr>\n""+""\n""+"" </td>\n""+"" </tr>\n""+"" </table>\n""+"" </td>\n""+"" </tr>\n"" );
				 }
			 }
			 out.print(""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""hasdocumentclasses\"" value=\""true\""/>\n"" );
			 iter = documentClasses.keySet().iterator();
			 while (iter.hasNext()) {
				 String documentClass = (String)iter.next();
				 org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec spec = (org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec)documentClasses.get(documentClass);
				 if (spec.getAllMetadata()) {
					 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""allmetadata_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" value=\""true\""/>\n"" );
				 }
				 else {
					 String[] metadataFields = spec.getMetadataFields();
					 int q = 0;
					 while (q < metadataFields.length) {
						 String field = metadataFields[q++];
						 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""metadatafield_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(field)+""\""/>\n"" );
					 }
				 }
				 int matchCount = spec.getMatchCount();
				 int q = 0;
				 while (q < matchCount) {
					 String matchType = spec.getMatchType(q);
					 String matchField = spec.getMatchField(q);
					 String matchValue = spec.getMatchValue(q);
					 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""matchfield_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""_""+Integer.toString(q)+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(matchField)+""\""/>\n""+""<input type=\""hidden\"" name=\""""+seqPrefix+""matchtype_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""_""+Integer.toString(q)+""\"" value=\""""+matchType+""\""/>\n""+""<input type=\""hidden\"" name=\""""+seqPrefix+""matchvalue_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""_""+Integer.toString(q)+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(matchValue)+""\""/>\n"" );
					 q++;
				 }
				 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""matchcount_""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\"" value=\""""+Integer.toString(matchCount)+""\""/>\n""+""<input type=\""hidden\"" name=\""""+seqPrefix+""documentclasses\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(documentClass)+""\""/>\n"" );
			 }
		 }
		 HashMap mimeTypes = null;
		 i = 0;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(SPEC_NODE_MIMETYPE)) {
				 String value = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 if (mimeTypes == null) mimeTypes = new HashMap();
				 mimeTypes.put(value,value);
			 }
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.MimeTypes"")) && actualSequenceNumber == connectionSequenceNumber) {
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""hasmimetypes\"" value=\""true\""/>\n""+""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n"" );
			 String[] mimeTypesArray = null;
			 String message = null;
			 try {
				 mimeTypesArray = getMimeTypes();
			 }
			 catch (ManifoldCFException e) {
				 message = e.getMessage();
			 }
			 catch (ServiceInterruption e) {
				 message = ""FileNet server temporarily unavailable: ""+e.getMessage();
			 }
			 out.print("" <tr>\n"" );
			 if (message != null) {
				 out.print("" <td class=\""message\"" colspan=\""2\"">""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(message)+""</td>\n"" );
			 }
			 else {
				 out.print("" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.MimeTypesToInclude"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n""+"" <select name=\""""+seqPrefix+""mimetypes\"" size=\""10\"" multiple=\""true\"">\n"" );
				 i = 0;
				 while (i < mimeTypesArray.length) {
					 String mimeType = mimeTypesArray[i++];
					 if (mimeTypes == null || mimeTypes.get(mimeType) != null) {
						 out.print("" <option value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(mimeType)+""\"" selected=\""true\"">\n""+"" ""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(mimeType)+""\n""+"" </option>\n"" );
					 }
					 else {
						 out.print("" <option value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(mimeType)+""\"">\n""+"" ""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(mimeType)+""\n""+"" </option>\n"" );
					 }
				 }
				 out.print("" </select>\n""+"" </td>\n"" );
			 }
			 out.print("" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""hasmimetypes\"" value=\""true\""/>\n"" );
			 if (mimeTypes != null) {
				 iter = mimeTypes.keySet().iterator();
				 while (iter.hasNext()) {
					 String mimeType = (String)iter.next();
					 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""mimetypes\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(mimeType)+""\""/>\n"" );
				 }
			 }
		 }
		 i = 0;
		 boolean securityOn = true;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(""security"")) {
				 String securityValue = sn.getAttributeValue(""value"");
				 if (securityValue.equals(""off"")) securityOn = false;
				 else if (securityValue.equals(""on"")) securityOn = true;
			 }
		 }
		 if (tabName.equals(Messages.getString(locale,""FilenetConnector.Security"")) && actualSequenceNumber == connectionSequenceNumber) {
			 out.print(""<table class=\""displaytable\"">\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Security2"") + ""</nobr></td>\n""+"" <td class=\""value\"" colspan=\""1\"">\n""+"" <input type=\""radio\"" name=\""""+seqPrefix+""specsecurity\"" value=\""on\"" ""+((securityOn)?""checked=\""true\"""":"""")+"" />"" + Messages.getBodyString(locale,""FilenetConnector.Enabled"") +"" <input type=\""radio\"" name=\""""+seqPrefix+""specsecurity\"" value=\""off\"" ""+((securityOn==false)?""checked=\""true\"""":"""")+"" />"" + Messages.getBodyString(locale,""FilenetConnector.Disabled"") + "" </td>\n""+"" </tr>\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n"" );
			 i = 0;
			 k = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i++);
				 if (sn.getType().equals(""access"")) {
					 String accessDescription = ""_""+Integer.toString(k);
					 String accessOpName = seqPrefix+""accessop""+accessDescription;
					 String token = sn.getAttributeValue(""token"");
					 out.print("" <tr>\n""+"" <td class=\""description\"">\n""+"" <input type=\""hidden\"" name=\""""+accessOpName+""\"" value=\""\""/>\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""spectoken""+accessDescription+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(token)+""\""/>\n""+"" <a name=\""""+seqPrefix+""token_""+Integer.toString(k)+""\"">\n""+"" <input type=\""button\"" value=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Delete"") + ""\"" alt=\""""+ Messages.getAttributeString(locale,""FilenetConnector.DeleteAccessToken"")+Integer.toString(k)+""\"" onClick='Javascript:""+seqPrefix+""SpecOp(\""""+accessOpName+""\"",\""Delete\"",\""""+seqPrefix+""token_""+Integer.toString(k)+""\"")'/>\n""+"" </a>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" ""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(token)+""\n""+"" </td>\n""+"" </tr>\n"" );
					 k++;
				 }
			 }
			 if (k == 0) {
				 out.print("" <tr>\n""+"" <td class=\""message\"" colspan=\""2\"">"" + Messages.getBodyString(locale,""FilenetConnector.NoAccessTokensPresent"") + ""</td>\n""+"" </tr>\n"" );
			 }
			 out.print("" <tr><td class=\""lightseparator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n""+"" <td class=\""description\"">\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""tokencount\"" value=\""""+Integer.toString(k)+""\""/>\n""+"" <input type=\""hidden\"" name=\""""+seqPrefix+""accessop\"" value=\""\""/>\n""+"" <a name=\""""+seqPrefix+""token_""+Integer.toString(k)+""\"">\n""+"" <input type=\""button\"" value=\"""" + Messages.getAttributeString(locale,""FilenetConnector.Add"") + ""\"" alt=\"""" + Messages.getAttributeString(locale,""FilenetConnector.AddAccessToken"") + ""\"" onClick='Javascript:""+seqPrefix+""SpecAddToken(\""""+seqPrefix+""token_""+Integer.toString(k+1)+""\"")'/>\n""+"" </a>\n""+"" </td>\n""+"" <td class=\""value\"">\n""+"" <input type=\""text\"" size=\""30\"" name=\""""+seqPrefix+""spectoken\"" value=\""\""/>\n""+"" </td>\n""+"" </tr>\n""+""</table>\n"" );
		 }
		 else {
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""specsecurity\"" value=\""""+(securityOn?""on"":""off"")+""\""/>\n"" );
			 i = 0;
			 k = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i++);
				 if (sn.getType().equals(""access"")) {
					 String accessDescription = ""_""+Integer.toString(k);
					 String token = sn.getAttributeValue(""token"");
					 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""spectoken""+accessDescription+""\"" value=\""""+org.apache.manifoldcf.ui.util.Encoder.attributeEscape(token)+""\""/>\n"" );
					 k++;
				 }
			 }
			 out.print(""<input type=\""hidden\"" name=\""""+seqPrefix+""tokencount\"" value=\""""+Integer.toString(k)+""\""/>\n"" );
		 }
	 }
	 public String processSpecificationPost(IPostParameters variableContext, Locale locale, Specification ds, int connectionSequenceNumber) throws ManifoldCFException {
		 String seqPrefix = ""s""+connectionSequenceNumber+""_"";
		 String[] x;
		 String y;
		 int i;
		 if (variableContext.getParameter(seqPrefix+""hasdocumentclasses"") != null) {
			 i = 0;
			 while (i < ds.getChildCount()) {
				 if (ds.getChild(i).getType().equals(SPEC_NODE_DOCUMENTCLASS)) ds.removeChild(i);
				 else i++;
			 }
			 x = variableContext.getParameterValues(seqPrefix+""documentclasses"");
			 if (x != null) {
				 i = 0;
				 while (i < x.length) {
					 String value = x[i++];
					 SpecificationNode node = new SpecificationNode(SPEC_NODE_DOCUMENTCLASS);
					 node.setAttribute(SPEC_ATTRIBUTE_VALUE,value);
					 String allmetadata = variableContext.getParameter(seqPrefix+""allmetadata_""+value);
					 if (allmetadata == null) allmetadata = ""false"";
					 if (allmetadata.equals(""true"")) node.setAttribute(SPEC_ATTRIBUTE_ALLMETADATA,allmetadata);
					 else {
						 String[] fields = variableContext.getParameterValues(seqPrefix+""metadatafield_""+value);
						 if (fields != null) {
							 int j = 0;
							 while (j < fields.length) {
								 String field = fields[j++];
								 SpecificationNode sp2 = new SpecificationNode(SPEC_NODE_METADATAFIELD);
								 sp2.setAttribute(SPEC_ATTRIBUTE_VALUE,field);
								 node.addChild(node.getChildCount(),sp2);
							 }
						 }
					 }
					 String matchCountString = variableContext.getParameter(seqPrefix+""matchcount_""+value);
					 int matchCount = Integer.parseInt(matchCountString);
					 int q = 0;
					 while (q < matchCount) {
						 String matchOp = variableContext.getParameter(seqPrefix+""matchop_""+value+""_""+Integer.toString(q));
						 String matchType = variableContext.getParameter(seqPrefix+""matchtype_""+value+""_""+Integer.toString(q));
						 String matchField = variableContext.getParameter(seqPrefix+""matchfield_""+value+""_""+Integer.toString(q));
						 String matchValue = variableContext.getParameter(seqPrefix+""matchvalue_""+value+""_""+Integer.toString(q));
						 if (matchOp == null || !matchOp.equals(""Delete"")) {
							 SpecificationNode matchNode = new SpecificationNode(SPEC_NODE_MATCH);
							 matchNode.setAttribute(SPEC_ATTRIBUTE_MATCHTYPE,matchType);
							 matchNode.setAttribute(SPEC_ATTRIBUTE_FIELDNAME,matchField);
							 if (matchValue == null) matchValue = """";
							 matchNode.setAttribute(SPEC_ATTRIBUTE_VALUE,matchValue);
							 node.addChild(node.getChildCount(),matchNode);
						 }
						 q++;
					 }
					 ds.addChild(ds.getChildCount(),node);
					 String addMatchOp = variableContext.getParameter(seqPrefix+""matchop_""+value);
					 if (addMatchOp != null && addMatchOp.equals(""Add"")) {
						 String matchType = variableContext.getParameter(seqPrefix+""matchtype_""+value);
						 String matchField = variableContext.getParameter(seqPrefix+""matchfield_""+value);
						 String matchValue = variableContext.getParameter(seqPrefix+""matchvalue_""+value);
						 SpecificationNode matchNode = new SpecificationNode(SPEC_NODE_MATCH);
						 matchNode.setAttribute(SPEC_ATTRIBUTE_MATCHTYPE,matchType);
						 matchNode.setAttribute(SPEC_ATTRIBUTE_FIELDNAME,matchField);
						 if (matchValue == null) matchValue = """";
						 matchNode.setAttribute(SPEC_ATTRIBUTE_VALUE,matchValue);
						 node.addChild(node.getChildCount(),matchNode);
					 }
				 }
			 }
		 }
		 if (variableContext.getParameter(seqPrefix+""hasmimetypes"") != null) {
			 i = 0;
			 while (i < ds.getChildCount()) {
				 if (ds.getChild(i).getType().equals(SPEC_NODE_MIMETYPE)) ds.removeChild(i);
				 else i++;
			 }
			 x = variableContext.getParameterValues(seqPrefix+""mimetypes"");
			 if (x != null) {
				 i = 0;
				 while (i < x.length) {
					 String value = x[i++];
					 SpecificationNode node = new SpecificationNode(SPEC_NODE_MIMETYPE);
					 node.setAttribute(SPEC_ATTRIBUTE_VALUE,value);
					 ds.addChild(ds.getChildCount(),node);
				 }
			 }
		 }
		 y = variableContext.getParameter(seqPrefix+""pathcount"");
		 if (y != null) {
			 i = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i);
				 if (sn.getType().equals(SPEC_NODE_FOLDER)) ds.removeChild(i);
				 else i++;
			 }
			 int pathCount = Integer.parseInt(y);
			 i = 0;
			 while (i < pathCount) {
				 String pathDescription = ""_""+Integer.toString(i);
				 String pathOpName = seqPrefix+""pathop""+pathDescription;
				 y = variableContext.getParameter(pathOpName);
				 if (y != null && y.equals(""Delete"")) {
					 i++;
					 continue;
				 }
				 String path = variableContext.getParameter(seqPrefix+""specpath""+pathDescription);
				 SpecificationNode node = new SpecificationNode(SPEC_NODE_FOLDER);
				 node.setAttribute(SPEC_ATTRIBUTE_VALUE,path);
				 ds.addChild(ds.getChildCount(),node);
				 i++;
			 }
			 String op = variableContext.getParameter(seqPrefix+""pathop"");
			 if (op != null && op.equals(""Add"")) {
				 String path = variableContext.getParameter(seqPrefix+""specpath"");
				 SpecificationNode node = new SpecificationNode(SPEC_NODE_FOLDER);
				 node.setAttribute(SPEC_ATTRIBUTE_VALUE,path);
				 ds.addChild(ds.getChildCount(),node);
			 }
			 else if (op != null && op.equals(""Up"")) {
				 String path = variableContext.getParameter(seqPrefix+""specpath"");
				 int k = path.lastIndexOf(""/"");
				 if (k <= 0) path = ""/"";
				 else path = path.substring(0,k);
				 currentContext.save(seqPrefix+""specpath"",path);
			 }
			 else if (op != null && op.equals(""AddToPath"")) {
				 String path = variableContext.getParameter(seqPrefix+""specpath"");
				 String addon = variableContext.getParameter(seqPrefix+""pathaddon"");
				 if (addon != null && addon.length() > 0) {
					 if (path.length() <= 1) path = ""/"" + addon;
					 else path += ""/"" + addon;
				 }
				 currentContext.save(seqPrefix+""specpath"",path);
			 }
		 }
		 y = variableContext.getParameter(seqPrefix+""specsecurity"");
		 if (y != null) {
			 i = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i);
				 if (sn.getType().equals(""security"")) ds.removeChild(i);
				 else i++;
			 }
			 SpecificationNode node = new SpecificationNode(""security"");
			 node.setAttribute(""value"",y);
			 ds.addChild(ds.getChildCount(),node);
		 }
		 y = variableContext.getParameter(seqPrefix+""tokencount"");
		 if (y != null) {
			 i = 0;
			 while (i < ds.getChildCount()) {
				 SpecificationNode sn = ds.getChild(i);
				 if (sn.getType().equals(""access"")) ds.removeChild(i);
				 else i++;
			 }
			 int accessCount = Integer.parseInt(y);
			 i = 0;
			 while (i < accessCount) {
				 String accessDescription = ""_""+Integer.toString(i);
				 String accessOpName = seqPrefix+""accessop""+accessDescription;
				 y = variableContext.getParameter(accessOpName);
				 if (y != null && y.equals(""Delete"")) {
					 i++;
					 continue;
				 }
				 String accessSpec = variableContext.getParameter(seqPrefix+""spectoken""+accessDescription);
				 SpecificationNode node = new SpecificationNode(""access"");
				 node.setAttribute(""token"",accessSpec);
				 ds.addChild(ds.getChildCount(),node);
				 i++;
			 }
			 String op = variableContext.getParameter(seqPrefix+""accessop"");
			 if (op != null && op.equals(""Add"")) {
				 String accessspec = variableContext.getParameter(seqPrefix+""spectoken"");
				 SpecificationNode node = new SpecificationNode(""access"");
				 node.setAttribute(""token"",accessspec);
				 ds.addChild(ds.getChildCount(),node);
			 }
		 }
		 return null;
	 }
	 public void viewSpecification(IHTTPOutput out, Locale locale, Specification ds, int connectionSequenceNumber) throws ManifoldCFException, IOException {
		 int i;
		 Iterator iter;
		 out.print(""<table class=\""displaytable\"">\n""+"" <tr>\n"" );
		 HashMap documentClasses = new HashMap();
		 i = 0;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(SPEC_NODE_DOCUMENTCLASS)) {
				 String value = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec spec = new org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec(sn);
				 documentClasses.put(value,spec);
			 }
		 }
		 String[] sortedDocumentClasses = new String[documentClasses.size()];
		 i = 0;
		 iter = documentClasses.keySet().iterator();
		 while (iter.hasNext()) {
			 sortedDocumentClasses[i++] = (String)iter.next();
		 }
		 java.util.Arrays.sort(sortedDocumentClasses);
		 if (sortedDocumentClasses.length == 0) {
			 out.print("" <td class=\""message\"" colspan=\""2\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.NoIncludedDocumentClasses"") + ""</nobr></td>\n"" );
		 }
		 else {
			 out.print("" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.IncludedDocumentClasses"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n""+"" <table class=\""displaytable\"">\n"" );
			 i = 0;
			 while (i < sortedDocumentClasses.length) {
				 String docclass = sortedDocumentClasses[i++];
				 out.print("" <tr>\n""+"" <td class=\""description\""><nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(docclass)+""</nobr></td>\n""+"" <td class=\""boxcell\"">\n""+"" <table class=\""displaytable\"">\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Metadata"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n"" );
				 org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec fieldValues = (org.apache.manifoldcf.crawler.connectors.filenet.DocClassSpec)documentClasses.get(docclass);
				 if (fieldValues.getAllMetadata()) {
					 out.print("" <nobr>(all metadata values)</nobr>\n"" );
				 }
				 else {
					 String[] valuesList = fieldValues.getMetadataFields();
					 java.util.Arrays.sort(valuesList);
					 int j = 0;
					 while (j < valuesList.length) {
						 String value = valuesList[j++];
						 out.print("" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(value)+""</nobr><br/>\n"" );
					 }
				 }
				 out.print("" </td>\n""+"" </tr>\n""+"" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.DocumentsMatching"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n"" );
				 int matchCount = fieldValues.getMatchCount();
				 int q = 0;
				 while (q < matchCount) {
					 String matchType = fieldValues.getMatchType(q);
					 String matchField = fieldValues.getMatchField(q);
					 String matchValue = fieldValues.getMatchValue(q);
					 q++;
					 out.print("" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(matchField)+"" ""+matchType+"" \""""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(matchValue)+""\""</nobr><br/>\n"" );
				 }
				 if (q == 0) {
					 out.print("" <nobr>("" + Messages.getBodyString(locale,""FilenetConnector.AllDocumentsInClass"") + ""\""""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(docclass)+""\"")</nobr>\n"" );
				 }
				 out.print("" </td>\n""+"" </tr>\n""+"" </table>\n""+"" </td>\n""+"" </tr>\n"" );
			 }
			 out.print("" </table>\n""+"" </td>\n"" );
		 }
		 out.print("" </tr>\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+"" <tr>\n"" );
		 i = 0;
		 HashMap mimeTypes = null;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(SPEC_NODE_MIMETYPE)) {
				 String value = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
				 if (mimeTypes == null) mimeTypes = new HashMap();
				 mimeTypes.put(value,value);
			 }
		 }
		 if (mimeTypes != null) {
			 String[] sortedMimeTypes = new String[mimeTypes.size()];
			 i = 0;
			 iter = mimeTypes.keySet().iterator();
			 while (iter.hasNext()) {
				 sortedMimeTypes[i++] = (String)iter.next();
			 }
			 java.util.Arrays.sort(sortedMimeTypes);
			 out.print("" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.IncludedMimeTypes"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n"" );
			 i = 0;
			 while (i < sortedMimeTypes.length) {
				 String value = sortedMimeTypes[i++];
				 out.print("" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(value)+""</nobr><br/>\n"" );
			 }
			 out.print("" </td>\n"" );
		 }
		 else {
			 out.print("" <td class=\""message\"" colspan=\""2\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.NoIncludedMimeTypes"") + ""</nobr></td>\n"" );
		 }
		 out.print("" </tr>\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n"" );
		 i = 0;
		 boolean seenAny = false;
		 while (i < ds.getChildCount()) {
			 SpecificationNode spn = ds.getChild(i++);
			 if (spn.getType().equals(SPEC_NODE_FOLDER)) {
				 if (seenAny == false) {
					 seenAny = true;
				 }
				 out.print("" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Folders2"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n""+"" <nobr>""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(spn.getAttributeValue(SPEC_ATTRIBUTE_VALUE))+""</nobr>\n""+"" </td>\n""+"" </tr>\n"" );
			 }
		 }
		 if (seenAny == false) {
			 out.print("" <tr><td class=\""message\"" colspan=\""2\"">"" + Messages.getBodyString(locale,""FilenetConnector.AllFoldersSpecified"") + ""</td></tr>\n"" );
		 }
		 out.print("" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n""+""\n"" );
		 i = 0;
		 boolean securityOn = true;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(""security"")) {
				 String securityValue = sn.getAttributeValue(""value"");
				 if (securityValue.equals(""off"")) securityOn = false;
				 else if (securityValue.equals(""on"")) securityOn = true;
			 }
		 }
		 out.print("" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.Security2"") + ""</nobr></td>\n""+"" <td class=\""value\"">""+(securityOn?""Enabled"":""Disabled"")+""</td>\n""+"" </tr>\n""+"" <tr><td class=\""separator\"" colspan=\""2\""><hr/></td></tr>\n"" );
		 seenAny = false;
		 i = 0;
		 while (i < ds.getChildCount()) {
			 SpecificationNode sn = ds.getChild(i++);
			 if (sn.getType().equals(""access"")) {
				 if (seenAny == false) {
					 out.print("" <tr>\n""+"" <td class=\""description\""><nobr>"" + Messages.getBodyString(locale,""FilenetConnector.AccessTokens"") + ""</nobr></td>\n""+"" <td class=\""value\"">\n"" );
					 seenAny = true;
				 }
				 String token = sn.getAttributeValue(""token"");
				 out.print("" ""+org.apache.manifoldcf.ui.util.Encoder.bodyEscape(token)+""<br/>\n"" );
			 }
		 }
		 if (seenAny) {
			 out.print("" </td>\n""+"" </tr>\n"" );
		 }
		 else {
			 out.print("" <tr><td class=\""message\"" colspan=\""2\"">"" + Messages.getBodyString(locale,""FilenetConnector.NoAccessTokensSpecified"") + ""</td></tr>\n"" );
		 }
		 out.print(""</table>\n"" );
	 }
	 public DocumentClassDefinition[] getDocumentClassesDetails() throws ManifoldCFException, ServiceInterruption {
		 long currentTime;
		 try {
			 return getDocumentClassesInfo();
		 }
		 catch (FilenetException e) {
			 currentTime = System.currentTimeMillis();
			 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),e,currentTime+300000L,currentTime+12*60*60000L,-1,true);
			 else throw new ManifoldCFException(e.getMessage(),e);
		 }
	 }
	 public MetadataFieldDefinition[] getDocumentClassMetadataFieldsDetails(String documentClassName) throws ServiceInterruption, ManifoldCFException {
		 long currentTime;
		 try {
			 return getDocumentClassMetadataFieldsInfo(documentClassName);
		 }
		 catch (FilenetException e) {
			 currentTime = System.currentTimeMillis();
			 if (e.getType() == FilenetException.TYPE_SERVICEINTERRUPTION) throw new ServiceInterruption(e.getMessage(),e,currentTime+300000L,currentTime+12*60*60000L,-1,true);
			 else throw new ManifoldCFException(e.getMessage(),e);
		 }
	 }
	 public String[] getMimeTypes() throws ManifoldCFException, ServiceInterruption {
		 return new String[] {
		 ""application/excel"", ""application/powerpoint"", ""application/ppt"", ""application/rtf"", ""application/xls"", ""text/html"", ""text/rtf"", ""text/pdf"", ""application/x-excel"", ""application/x-msexcel"", ""application/x-mspowerpoint"", ""application/x-msword-doc"", ""application/x-msword"", ""application/x-word"", ""Application/pdf"", ""text/xml"", ""no-type"", ""text/plain"", ""application/pdf"", ""application/x-rtf"", ""application/vnd.ms-excel"", ""application/vnd.ms-pps"", ""application/vnd.ms-powerpoint"", ""application/vnd.ms-word"", ""application/msword"", ""application/msexcel"", ""application/mspowerpoint"", ""application/ms-powerpoint"", ""application/ms-word"", ""application/ms-excel"", ""Adobe"", ""application/Vnd.Ms-Excel"", ""vnd.ms-powerpoint"", ""application/x-pdf"", ""winword"", ""text/richtext"", ""Text"", ""Text/html"", ""application/MSWORD"", ""application/PDF"", ""application/MSEXCEL"", ""application/MSPOWERPOINT"", ""application/vnd.oasis.opendocument.presentation"", ""application/vnd.oasis.opendocument.spreadsheet"", ""application/vnd.oasis.opendocument.text"" }
		;
	 }
	 protected static String convertToURI(String urlBase, String documentIdentifier, int elementNumber, String documentClass) {
		 return urlBase + ""&id="" + documentIdentifier + ""&element=""+Integer.toString(elementNumber)+""&objectType=Document"";
	 }
	 protected class CheckConnectionThread extends Thread {
		 protected Throwable exception = null;
		 public CheckConnectionThread() {
			 super();
			 setDaemon(true);
		 }
		 public void run() {
			 try {
				 session.checkConnection();
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public void finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
		 }
	 }
	 protected void checkConnection() throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 CheckConnectionThread t = new CheckConnectionThread();
			 t.start();
			 try {
				 t.finishUp();
				 return;
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetDocumentClassesInfoThread extends Thread {
		 protected DocumentClassDefinition[] rval = null;
		 protected Throwable exception = null;
		 public GetDocumentClassesInfoThread() {
			 super();
			 setDaemon(true);
		 }
		 public void run() {
			 try {
				 rval = session.getDocumentClassesDetails();
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public DocumentClassDefinition[] finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
			 return rval;
		 }
	 }
	 protected DocumentClassDefinition[] getDocumentClassesInfo() throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetDocumentClassesInfoThread t = new GetDocumentClassesInfoThread();
			 t.start();
			 try {
				 return t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetDocumentClassesMetadataFieldsInfoThread extends Thread {
		 protected String documentClassName;
		 protected MetadataFieldDefinition[] rval = null;
		 protected Throwable exception = null;
		 public GetDocumentClassesMetadataFieldsInfoThread(String documentClassName) {
			 super();
			 setDaemon(true);
			 this.documentClassName = documentClassName;
		 }
		 public void run() {
			 try {
				 rval = session.getDocumentClassMetadataFieldsDetails(documentClassName);
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public MetadataFieldDefinition[] finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
			 return rval;
		 }
	 }
	 protected MetadataFieldDefinition[] getDocumentClassMetadataFieldsInfo(String documentClassName) throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetDocumentClassesMetadataFieldsInfoThread t = new GetDocumentClassesMetadataFieldsInfoThread(documentClassName);
			 t.start();
			 try {
				 return t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetChildFoldersThread extends Thread {
		 protected final String[] folderPath;
		 protected String[] rval = null;
		 protected Throwable exception = null;
		 public GetChildFoldersThread(String[] folderPath) {
			 super();
			 setDaemon(true);
			 this.folderPath = folderPath;
		 }
		 public void run() {
			 try {
				 rval = session.getChildFolders(folderPath);
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public String[] finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
			 return rval;
		 }
	 }
	 protected String[] doGetChildFolders(String[] folderPath) throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetChildFoldersThread t = new GetChildFoldersThread(folderPath);
			 t.start();
			 try {
				 return t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetMatchingObjectIdsThread extends Thread {
		 protected String sql;
		 protected String[] rval = null;
		 protected Throwable exception = null;
		 public GetMatchingObjectIdsThread(String sql) {
			 super();
			 setDaemon(true);
			 this.sql = sql;
		 }
		 public void run() {
			 try {
				 rval = session.getMatchingObjectIds(sql);
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public String[] finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
			 return rval;
		 }
	 }
	 protected String[] doGetMatchingObjectIds(String sql) throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetMatchingObjectIdsThread t = new GetMatchingObjectIdsThread(sql);
			 t.start();
			 try {
				 return t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetDocumentContentCountThread extends Thread {
		 protected String identifier;
		 protected Integer rval = null;
		 protected Throwable exception = null;
		 public GetDocumentContentCountThread(String identifier) {
			 super();
			 setDaemon(true);
			 this.identifier = identifier;
		 }
		 public void run() {
			 try {
				 rval = session.getDocumentContentCount(identifier);
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public Integer finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
			 return rval;
		 }
	 }
	 protected Integer doGetDocumentContentCount(String documentIdentifier) throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetDocumentContentCountThread t = new GetDocumentContentCountThread(documentIdentifier);
			 t.start();
			 try {
				 return t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetDocumentInformationThread extends Thread {
		 protected final String docId;
		 protected final Map<String,Object> metadataFields;
		 protected FileInfo rval = null;
		 protected Throwable exception = null;
		 public GetDocumentInformationThread(String docId, Map<String,Object> metadataFields) {
			 super();
			 setDaemon(true);
			 this.docId = docId;
			 this.metadataFields = metadataFields;
		 }
		 public void run() {
			 try {
				 rval = session.getDocumentInformation(docId,metadataFields);
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public FileInfo finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
			 return rval;
		 }
	 }
	 protected FileInfo doGetDocumentInformation(String docId, Map<String,Object> metadataFields) throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetDocumentInformationThread t = new GetDocumentInformationThread(docId,metadataFields);
			 t.start();
			 try {
				 return t.finishUp();
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected class GetDocumentContentsThread extends Thread {
		 protected final String docId;
		 protected final int elementNumber;
		 protected final String tempFileName;
		 protected Throwable exception = null;
		 public GetDocumentContentsThread(String docId, int elementNumber, String tempFileName) {
			 super();
			 setDaemon(true);
			 this.docId = docId;
			 this.elementNumber = elementNumber;
			 this.tempFileName = tempFileName;
		 }
		 public void run() {
			 try {
				 session.getDocumentContents(docId,elementNumber,tempFileName);
			 }
			 catch (Throwable e) {
				 this.exception = e;
			 }
		 }
		 public void finishUp() throws RemoteException, FilenetException, InterruptedException {
			 join();
			 Throwable thr = exception;
			 if (thr != null) {
				 if (thr instanceof RemoteException) throw (RemoteException)thr;
				 else if (thr instanceof FilenetException) throw (FilenetException)thr;
				 else if (thr instanceof RuntimeException) throw (RuntimeException)thr;
				 else if (thr instanceof Error) throw (Error)thr;
				 else throw new RuntimeException(""Unexpected exception type: ""+thr.getClass().getName()+"": ""+thr.getMessage(),thr);
			 }
		 }
	 }
	 protected void doGetDocumentContents(String docId, int elementNumber, String tempFileName) throws FilenetException, ManifoldCFException, ServiceInterruption {
		 while (true) {
			 boolean noSession = (session==null);
			 getSession();
			 long currentTime;
			 GetDocumentContentsThread t = new GetDocumentContentsThread(docId,elementNumber,tempFileName);
			 t.start();
			 try {
				 t.finishUp();
				 return;
			 }
			 catch (InterruptedException e) {
				 t.interrupt();
				 throw new ManifoldCFException(""Interrupted: ""+e.getMessage(),e,ManifoldCFException.INTERRUPTED);
			 }
			 catch (RemoteException e) {
				 Throwable e2 = e.getCause();
				 if (e2 instanceof InterruptedException || e2 instanceof InterruptedIOException) throw new ManifoldCFException(e2.getMessage(),e2,ManifoldCFException.INTERRUPTED);
				 if (noSession) {
					 currentTime = System.currentTimeMillis();
					 throw new ServiceInterruption(""Transient error connecting to filenet service: ""+e.getMessage(),currentTime+60000L);
				 }
				 session = null;
				 lastSessionFetch = -1L;
				 continue;
			 }
		 }
	 }
	 protected static class SpecInfo {
		 protected final Set<String> aclMap = new HashSet<String>();
		 protected final boolean securityOn;
		 protected final Map<String,DocClassSpec> docClassSpecs = new HashMap<String,DocClassSpec>();
		 protected final Map<String,Object> metadataFields = new HashMap<String,Object>();
		 public SpecInfo(Specification spec) {
			 boolean securityOn = true;
			 for (int i = 0;
			 i < spec.getChildCount();
			 i++) {
				 SpecificationNode sn = spec.getChild(i);
				 if (sn.getType().equals(""access"")) {
					 String token = sn.getAttributeValue(""token"");
					 aclMap.add(token);
				 }
				 else if (sn.getType().equals(""security"")) {
					 String value = sn.getAttributeValue(""value"");
					 if (value.equals(""on"")) securityOn = true;
					 else if (value.equals(""off"")) securityOn = false;
				 }
				 else if (sn.getType().equals(SPEC_NODE_DOCUMENTCLASS)) {
					 String value = sn.getAttributeValue(SPEC_ATTRIBUTE_VALUE);
					 DocClassSpec classSpec = new DocClassSpec(sn);
					 docClassSpecs.put(value,classSpec);
					 if (classSpec.getAllMetadata()) metadataFields.put(value,new Boolean(true));
					 else {
						 Set<String> sumMap = new HashSet<String>();
						 int j = 0;
						 String[] fields = classSpec.getMetadataFields();
						 for (String field : fields) {
							 sumMap.add(field);
						 }
						 for (j = 0;
						 j < classSpec.getMatchCount();
						 j++) {
							 sumMap.add(classSpec.getMatchField(j));
						 }
						 String[] fieldArray = new String[sumMap.size()];
						 j = 0;
						 for (String field : sumMap) {
							 fieldArray[j++] = field;
						 }
						 metadataFields.put(value,fieldArray);
					 }
				 }
			 }
			 this.securityOn = securityOn;
		 }
		 public String[] getAcls() {
			 if (!securityOn) return null;
			 String[] rval = new String[aclMap.size()];
			 int i = 0;
			 for (String acl : aclMap) {
				 rval[i++] = acl;
			 }
			 return rval;
		 }
		 public DocClassSpec getDocClassSpec(String docClass) {
			 return docClassSpecs.get(docClass);
		 }
		 public Map<String,Object> getMetadataFields() {
			 return metadataFields;
		 }
	 }
}",1,0,0,0
"public boolean isJoined() {
	 return ssProxy.isJoined();
 }",0,0,0,0
"public NotificationDialog(String to, String cc, String subject, String description) {
	 setModal(true);
	 setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
	 setTitle(BundleMessage.format(""UI_CALDAV_NOTIFICATION""));
	 try {
		 setIconImage(DavGatewayTray.getFrameIcon());
	 }
	 catch (NoSuchMethodError error) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
	 }
	 JPanel mainPanel = new JPanel();
	 mainPanel.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(""F1""), ""help"");
	 mainPanel.getActionMap().put(""help"", new AbstractAction() {
		 public void actionPerformed(ActionEvent e) {
		 DesktopBrowser.browse(""http: }
	 }
	);
	 mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
	 mainPanel.add(getRecipientsPanel());
	 mainPanel.add(getBodyPanel(description));
	 JPanel recipientsPanel = getRecipientsPanel();
	 if (to != null) {
		 toField.setText(to);
	 }
	 if (cc != null) {
		 ccField.setText(cc);
	 }
	 if (subject != null) {
		 subjectField.setText(subject);
	 }
	 add(BorderLayout.NORTH, recipientsPanel);
	 JPanel bodyPanel = getBodyPanel(description);
	 add(BorderLayout.CENTER, bodyPanel);
	 bodyField.setPreferredSize(recipientsPanel.getPreferredSize());
	 JPanel buttonPanel = new JPanel();
	 JButton cancel = new JButton(BundleMessage.format(""UI_BUTTON_CANCEL""));
	 JButton send = new JButton(BundleMessage.format(""UI_BUTTON_SEND""));
	 send.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent evt) {
			 sendNotification = true;
			 setVisible(false);
		 }
	 }
	);
	 cancel.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent evt) {
			 setVisible(false);
		 }
	 }
	);
	 buttonPanel.add(send);
	 buttonPanel.add(cancel);
	 add(BorderLayout.SOUTH, buttonPanel);
	 pack();
	 setResizable(true);
	 setLocation(getToolkit().getScreenSize().width / 2 - getSize().width / 2, getToolkit().getScreenSize().height / 2 - getSize().height / 2);
	setAlwaysOnTop(true);
	 setVisible(true);
 }",0,0,1,0
"public class ParsingException extends Exception {
	int offset = -1, line = -1, column = -1;
	public ParsingException(int offset, int line, int column, String msg) {
		super(msg);
		this.offset = offset;
		this.line = line;
		this.column = column;
	}
	public ParsingException(int line, int column, String msg) {
		super(msg);
		this.line = line;
		this.column = column;
	}
	public ParsingException(int offset, String msg) {
		super(msg);
		this.offset = offset;
	}
	public ParsingException(String msg, Exception e) {
		super(msg+e.getMessage(), e);
	}
	public ParsingException(String msg){
		super(msg);
	}
	public String getMessage() {
		StringBuffer buf = new StringBuffer(super.getMessage());
		if (offset != -1 || line != -1 || column != -1) {
			buf.append("" ["");
			if (offset != -1) {
				buf.append(""offset:"" + offset + "","");
			}
			if (line != -1) {
				buf.append(""line:"" + (line+1) + "","");
			}
			if (column != -1) {
				buf.append(""column:"" + (column+1));
			}
			if (buf.charAt(buf.length()-1) == ',') {
				buf.deleteCharAt(buf.length() - 1);
			}
			buf.append(']');
		}
		return buf.toString();
	}
}",0,0,0,0
"public class EnsemblExonVO extends EnsemblDBBaseVO {
	 private Integer version;
	 private String assemblyName;
	 private String seqRegionName;
	 private String strand;
	 public Integer getVersion() {
		 return version;
	 }
	 public void setVersion(Integer version) {
		 this.version = version;
	 }
	 public String getAssemblyName() {
		 return assemblyName;
	 }
	 public void setAssemblyName(String assemblyName) {
		 this.assemblyName = assemblyName;
	 }
	 public String getSeqRegionName() {
		 return seqRegionName;
	 }
	 public void setSeqRegionName(String seqRegionName) {
		 this.seqRegionName = seqRegionName;
	 }
	 public String getStrand() {
		 return strand;
	 }
	 public void setStrand(String strand) {
		 this.strand = strand;
	 }
}",0,1,0,0
"public String longestMatch(String input) {
	 TrieNode node= root;
	 String result= null;
	 for (int i= 0;
	 i < input.length();
	 i++) {
		 node= node.getChild(input.charAt(i));
		 if (node == null) break;
		 if (node.isTerminal()) result= input.substring(0, i+1);
	 }
	 return result;
 }",0,0,0,0
"protected void resetFileLists() {
	 compileList.removeAllElements();
 }",0,0,0,0
"public class UnifyBasicTypeVariableTypeRule extends LambdaTypeSystemRule {
	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable> var_v1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable>(createEClassifierType(basicPackage.getTypeVariable()));
	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.BasicType> var_b = new Variable<org.eclipse.xsemantics.example.lambda.lambda.BasicType>(createEClassifierType(basicPackage.getBasicType()));
	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.Type> var_t1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.Type>(createEClassifierType(basicPackage.getType()));
	protected TypingJudgmentEnvironment env_G = new TypingJudgmentEnvironment();
	public UnifyBasicTypeVariableTypeRule() {
		this(""UnifyBasicTypeVariable"", ""|-"", ""=="");
	}
	public UnifyBasicTypeVariableTypeRule(String ruleName,String typeJudgmentSymbol, String typeStatementRelation) {
		super(ruleName, typeJudgmentSymbol, typeStatementRelation);
	}
	public Variable<org.eclipse.xsemantics.example.lambda.lambda.BasicType> getLeft() {
		return var_b;
	}
	public Variable<org.eclipse.xsemantics.example.lambda.lambda.Type> getRight() {
		return var_t1;
	}
	public TypingJudgmentEnvironment getEnvironment() {
		return env_G;
	}
	public void setEnvironment(TypingJudgmentEnvironment environment) {
		if (environment != null)env_G = environment;
	}
	public RuntimeRule newInstance() {
		return new UnifyBasicTypeVariableTypeRule(""UnifyBasicTypeVariable"",""|-"", ""=="");
	}
	public void applyImpl() throws RuleFailedException {
		var_v1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable>(createEClassifierType(basicPackage.getTypeVariable()), castto(var_t1.getValue(),org.eclipse.xsemantics.example.lambda.lambda.TypeVariable.class));
		applyMappingRule(env_G, var_v1, var_b);
	}
}",1,1,0,0
"public final class Continuation extends IdScriptableObject implements Function{
	 static final long serialVersionUID = 1794167133757605367L;
	 private static final Object FTAG = new Object();
	 private Object implementation;
	 public static void init(Scriptable scope, boolean sealed) {
		 Continuation obj = new Continuation();
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 public Object getImplementation() {
		 return implementation;
	 }
	 public void initImplementation(Object implementation) {
		 this.implementation = implementation;
	 }
	 public String getClassName() {
		 return ""Continuation"";
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 throw Context.reportRuntimeError(""Direct call is not supported"");
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return Interpreter.restartContinuation(this, cx, scope, args);
	 }
	 public static boolean isContinuationConstructor(IdFunctionObject f) {
		 if (f.hasTag(FTAG) && f.methodId() == Id_constructor) {
			 return true;
		 }
		 return false;
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=0;
			 s=""constructor"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(FTAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(FTAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: throw Context.reportRuntimeError(""Direct call is not supported"");
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 if (s.length()==11) {
				 X=""constructor"";
				id=Id_constructor;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, MAX_PROTOTYPE_ID = 1;
}",0,0,0,0
"public boolean matchesAllInstances(SequenceType testST) {
	 Quantifier stq = sequenceType.getQuantifier();
	 ItemType it = sequenceType.getItemType();
	 if (stq.isSubQuantifier(testST.getQuantifier())) {
		 if (it instanceof AnyItemType) {
			 return true;
		 }
		 else if (it.isAtomicType() && testST.getItemType().isAtomicType()) {
			 AtomicType ait = (AtomicType) it;
			 AtomicType testIT = (AtomicType) testST.getItemType();
			 if (BuiltinTypeRegistry.INSTANCE.isBuiltinTypeId(testIT.getTypeId())) {
				 SchemaType vType = BuiltinTypeRegistry.INSTANCE.getSchemaTypeById(testIT.getTypeId());
				 while (vType != null && vType.getTypeId() != ait.getTypeId()) {
					 vType = vType.getBaseType();
				 }
				 return vType != null;
			 }
		 }
		 else if (it instanceof NodeType && testST.getItemType() instanceof NodeType) {
			 NodeType nt = (NodeType) it;
			 NodeKind kind = nt.getNodeKind();
			 NodeType testNT = (NodeType) testST.getItemType();
			 NodeKind testKind = testNT.getNodeKind();
			 if (kind == NodeKind.ANY || kind == testKind) {
				 return true;
			 }
		 }
		 return false;
	 }
	 return false;
 }",0,0,1,0
"private class NioServerListener implements Callable<ChannelFuture> {
	 public ChannelFuture call() throws Exception {
		 SERVER.set(AsyncServer.this);
		 ServerBootstrap b = new ServerBootstrap();
		 b.group(bossGroup, workerGroup) .channel(EpollServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, backlogLength) .childOption(ChannelOption.MAX_MESSAGES_PER_READ, NIO_BUFFER_LIMIT) .childOption(ChannelOption.TCP_NODELAY, tcpNoDelay) .childOption(ChannelOption.SO_KEEPALIVE, true) .childOption(ChannelOption.SO_RCVBUF, 30 * 1024 * 1024) .childOption(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(100 * 1024)) .childHandler(new ChannelInitializer<SocketChannel>() {
			 public void initChannel(SocketChannel ch) throws Exception {
				 ChannelPipeline p = ch.pipeline();
				 p.addLast(new NioFrameDecoder(100 * 1024 * 1024, 0, 4, 0, 0));
				 p.addLast(new NioServerInboundHandler());
			 }
		 }
		);
		 ChannelFuture f = b.bind(port).sync();
		 LOG.info(""AsyncServer startup"");
		 return f.channel().closeFuture();
	 }
 }",1,0,0,0
"public void logoutUser (User u) throws Exception {
	 try {
		 if (dbp.readOnly || dbp.updCols == null || dbp.updCols.length < 1) return;
		 PreparedStatement ps = getUpdate();
		 for (int i = 0;
		 i < dbp.updCols.length;
		 i++) {
			 String cname = dbp.updNames[i];
			 if (""chattime"".equalsIgnoreCase(cname)) {
				 ps.setLong(i+1, u.getChattime());
			 }
			 else if (""userrights"".equalsIgnoreCase(cname)) {
				 ps.setInt(i+1, u.getPermissionMap());
			 }
			 else if (""fadecolor"".equalsIgnoreCase(cname)) {
				 ps.setString(i+1, u.getFadeColCode());
			 }
			 else if (""bgcolor"".equalsIgnoreCase(cname)) {
				 ps.setString(i+1, u.getBgColCode());
			 }
			 else if (""color"".equalsIgnoreCase(cname)) {
				 ps.setString(i+1, u.getColCode());
			 }
			 else if (""friends"".equalsIgnoreCase(cname)) {
				 StringBuffer sb = new StringBuffer();
				 for (Enumeration<T> e = u.friends();
				 e.hasMoreElements();
				 ) {
					 String s = (String) e.nextElement();
					 sb.append (s);
					 if (e.hasMoreElements()) sb.append ("", "");
				 }
				 ps.setString(i+1, sb.toString());
			 }
			 else if (""ignorelist"".equalsIgnoreCase(cname)) {
				 StringBuffer sb = new StringBuffer();
				 for (Enumeration<String> e = u.ignoreList();
				 e.hasMoreElements();
				 ) {
					 String s = (String) e.nextElement();
					 sb.append (s);
					 if (e.hasMoreElements()) sb.append ("", "");
				 }
				 ps.setString(i+1, sb.toString());
			 }
			 else if (""notifyfriends"".equalsIgnoreCase(cname)) {
				 int idx = dbp.nameV.indexOf(""notifyfriends"");
				 switch (dbp.types[idx]) {
					 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: ps.setInt(i+1, u.notifyFriends());
					 break;
					 case Types.BOOLEAN: ps.setBoolean(i+1, u.notifyFriends()==User.FN_ALL ? true : false);
					 break;
					 default: ps.setString(i+1, u.notifyFriends()==User.FN_ALL ? ""true"" : ""false"");
				 }
			 }
			 else if (""extratitle"".equalsIgnoreCase(cname)) {
				 ps.setString(i+1, u.getCustomTitle());
			 }
			 else if (""cookie"".equalsIgnoreCase(cname)) {
				 ps.setString(i+1, ""not_logged_in"");
			 }
			 else if (""blocked"".equalsIgnoreCase(cname)) {
				 int idx = dbp.nameV.indexOf(""blocked"");
				 switch (dbp.types[idx]) {
					 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: ps.setInt(i+1, u.blocked ? 1 : 0);
					 break;
					 case Types.BOOLEAN: ps.setBoolean(i+1, u.blocked);
					 break;
					 default: ps.setString(i+1, u.blocked ? ""1"" : ""0"");
				 }
			 }
			 else if (""activated"".equalsIgnoreCase(cname)) {
				 int idx = dbp.nameV.indexOf(""activated"");
				 switch (dbp.types[idx]) {
					 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: ps.setInt(i+1, u.activated ? 1 : 0);
					 break;
					 case Types.BOOLEAN: ps.setBoolean(i+1, u.activated);
					 break;
					 default: ps.setString(i+1, u.activated ? ""1"" : ""0"");
				 }
			 }
			 else {
				 Server.log(this, ""save custom Property ""+cname, Server.MSG_AUTH, Server.LVL_VERBOSE);
				 int idx = dbp.nameV.indexOf(cname);
				 switch (dbp.types[idx]) {
					 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: case Types.BOOLEAN: default: ps.setObject(i+1,u.getProperty(cname));
				 }
			 }
		 }
		 if (dbp.idField != null) {
			 if (u.getID()==null) {
				 Server.log(u, ""Unable to store logout-data for "" + u.getName() + "" because of missing id-value"", Server.MSG_AUTH, Server.LVL_MAJOR);
				 return;
			 }
			 ps.setString(dbp.updCols.length+1, u.getID());
		 }
		 else {
			 ps.setString(dbp.updCols.length+1, u.getName().toLowerCase());
		 }
		 int rows = ps.executeUpdate();
		 sCnt++;
		 if (rows==1) {
			 con.commit();
		 }
		 else if (rows < 1) {
			 Server.log(Thread.currentThread(), this.toString() + ""LOGOUT unable to update userdata! No record for: "" + dbp.idField != null ? dbp.idField + "" = "" + u.getID() : ""username = "" + u.getName().toLowerCase(), Server.MSG_AUTH, Server.LVL_MAJOR);
			 return;
		 }
		 else if (rows > 1) {
			 Server.log(Thread.currentThread(), this.toString() + ""LOGOUT unable to update userdata! More than one value would be updated: ("" + dbp.idField != null ? dbp.idField + "" = "" + u.getID() : ""username = "" + u.getName().toLowerCase() + "")"", Server.MSG_AUTH, Server.LVL_MAJOR);
			 try {
				 con.rollback();
				 Server.log (Thread.currentThread(), this.toString() + ""LOGOUT rollback successfully"", Server.MSG_AUTH, Server.LVL_VERBOSE);
			 }
			 catch (SQLException se) {
				 Server.log (Thread.currentThread(), this.toString() + ""LOGOUT rollback failed!!!"", Server.MSG_AUTH, Server.LVL_MAJOR);
			 }
		 }
		 checkWarnings(ps, ""logoutUser"");
	 }
	 catch (Exception e) {
		 isValid=false;
		 release();
		 throw e;
	 }
 }",0,0,1,0
"GetResponse doGet(final HttpServletRequest request) {
	logger.debug(""Entering Dispatcher#doGet"");
	Context context = ThreadLocalData.getContext();
	context.logBaseParameters();
	GetResponse getResponse = null;
	if (!Command.isValidForGet(context.getCommandStr()))getResponse = GetResponse.getInvalidCommandError();
	else if (!ResourceType.isValidType(context.getTypeStr()))getResponse = GetResponse.getInvalidResourceTypeError();
	else if (!UtilsFile.isValidPath(context.getCurrentFolderStr()))getResponse = GetResponse.getInvalidCurrentFolderError();
	else {
		ResourceType type = context.getResourceType();
		Command command = context.getCommand();
		if ((command.equals(Command.GET_FOLDERS) || command.equals(Command.GET_FOLDERS_AND_FILES))&& !RequestCycleHandler.isGetResourcesEnabled(request))getResponse = GetResponse.getGetResourcesDisabledError();
		else if (command.equals(Command.CREATE_FOLDER) && !RequestCycleHandler.isCreateFolderEnabled(request))getResponse = GetResponse.getCreateFolderDisabledError();
		else {
			try {
				if (command.equals(Command.CREATE_FOLDER)) {
					String newFolderNameStr = request.getParameter(""NewFolderName"");
					logger.debug(""Parameter NewFolderName: {
					}
					"",newFolderNameStr);
					String sanitizedNewFolderNameStr = UtilsFile.sanitizeFolderName(newFolderNameStr);
					if (Utils.isEmpty(sanitizedNewFolderNameStr))getResponse = GetResponse.getInvalidNewFolderNameError();
					else {
						logger.debug(""Parameter NewFolderName (sanitized): {
						}
						"",sanitizedNewFolderNameStr);
						connector.createFolder(type, context.getCurrentFolderStr(),sanitizedNewFolderNameStr);
						getResponse = GetResponse.getOK();
					}
				}
				 else if (command.equals(Command.GET_FOLDERS)|| command.equals(Command.GET_FOLDERS_AND_FILES)) {
					String url = UtilsResponse.getUrl(RequestCycleHandler.getUserFilesPath(request), type, context.getCurrentFolderStr());
					getResponse = getFoldersAndOrFiles(command, type, context.getCurrentFolderStr(), url);
				}
			}
			 catch (InvalidCurrentFolderException e) {
				getResponse = GetResponse.getInvalidCurrentFolderError();
			}
			 catch (InvalidNewFolderNameException e) {
				getResponse = GetResponse.getInvalidNewFolderNameError();
			}
			 catch (FolderAlreadyExistsException e) {
				getResponse = GetResponse.getFolderAlreadyExistsError();
			}
			 catch (WriteException e) {
				getResponse = GetResponse.getCreateFolderWriteError();
			}
			 catch (ReadException e) {
				getResponse = GetResponse.getGetResourcesReadError();
			}
		}
	}
	logger.debug(""Exiting Dispatcher#doGet"");
	return getResponse;
}",0,0,1,0
"public class BookmarksTables{
	 private static final POILogger logger = POILogFactory .getLogger( BookmarksTables.class );
	 private PlexOfCps descriptorsFirst = new PlexOfCps( 4 );
	 private PlexOfCps descriptorsLim = new PlexOfCps( 0 );
	 private List<String> names = new ArrayList<>(0);
	 public BookmarksTables( byte[] tableStream, FileInformationBlock fib ) {
		 read( tableStream, fib );
	 }
	 public void afterDelete( int startCp, int length ) {
		 descriptorsFirst.adjust( startCp, -length );
		 descriptorsLim.adjust( startCp, -length );
		 for ( int i = 0;
		 i < descriptorsFirst.length();
		 i++ ) {
			 GenericPropertyNode startNode = descriptorsFirst.getProperty( i );
			 GenericPropertyNode endNode = descriptorsLim.getProperty( i );
			 if ( startNode.getStart() == endNode.getStart() ) {
				 logger.log( POILogger.DEBUG, ""Removing bookmark #"", Integer.valueOf( i ), ""..."" );
				 remove( i );
				 i--;
				 continue;
			 }
		 }
	 }
	 public void afterInsert( int startCp, int length ) {
		 descriptorsFirst.adjust( startCp, length );
		 descriptorsLim.adjust( startCp - 1, length );
	 }
	 public int getBookmarksCount() {
		 return descriptorsFirst.length();
	 }
	 public GenericPropertyNode getDescriptorFirst( int index ) throws IndexOutOfBoundsException {
		 return descriptorsFirst.getProperty( index );
	 }
	 public int getDescriptorFirstIndex( GenericPropertyNode descriptorFirst ) {
		 return Arrays.asList( descriptorsFirst.toPropertiesArray() ).indexOf( descriptorFirst );
	 }
	 public GenericPropertyNode getDescriptorLim( int index ) throws IndexOutOfBoundsException {
		 return descriptorsLim.getProperty( index );
	 }
	 public int getDescriptorsFirstCount() {
		 return descriptorsFirst.length();
	 }
	 public int getDescriptorsLimCount() {
		 return descriptorsLim.length();
	 }
	 public String getName( int index ) {
		 return names.get( index );
	 }
	 public int getNamesCount() {
		 return names.size();
	 }
	 private void read( byte[] tableStream, FileInformationBlock fib ) {
		 int namesStart = fib.getFcSttbfbkmk();
		 int namesLength = fib.getLcbSttbfbkmk();
		 if ( namesStart != 0 && namesLength != 0 ) this.names = new ArrayList<>(Arrays.asList(SttbUtils .readSttbfBkmk(tableStream, namesStart)));
		 int firstDescriptorsStart = fib.getFcPlcfbkf();
		 int firstDescriptorsLength = fib.getLcbPlcfbkf();
		 if ( firstDescriptorsStart != 0 && firstDescriptorsLength != 0 ) descriptorsFirst = new PlexOfCps( tableStream, firstDescriptorsStart, firstDescriptorsLength, BookmarkFirstDescriptor.getSize() );
		 int limDescriptorsStart = fib.getFcPlcfbkl();
		 int limDescriptorsLength = fib.getLcbPlcfbkl();
		 if ( limDescriptorsStart != 0 && limDescriptorsLength != 0 ) descriptorsLim = new PlexOfCps( tableStream, limDescriptorsStart, limDescriptorsLength, 0 );
	 }
	 public void remove( int index ) {
		 descriptorsFirst.remove( index );
		 descriptorsLim.remove( index );
		 names.remove( index );
	 }
	 public void setName( int index, String name ) {
		 names.set( index, name );
	 }
	 public void writePlcfBkmkf( FileInformationBlock fib, ByteArrayOutputStream tableStream ) throws IOException {
		 if ( descriptorsFirst == null || descriptorsFirst.length() == 0 ) {
			 fib.setFcPlcfbkf( 0 );
			 fib.setLcbPlcfbkf( 0 );
			 return;
		 }
		 int start = tableStream.size();
		 tableStream.write( descriptorsFirst.toByteArray() );
		 int end = tableStream.size();
		 fib.setFcPlcfbkf( start );
		 fib.setLcbPlcfbkf( end - start );
	 }
	 public void writePlcfBkmkl( FileInformationBlock fib, ByteArrayOutputStream tableStream ) throws IOException {
		 if ( descriptorsLim == null || descriptorsLim.length() == 0 ) {
			 fib.setFcPlcfbkl( 0 );
			 fib.setLcbPlcfbkl( 0 );
			 return;
		 }
		 int start = tableStream.size();
		 tableStream.write( descriptorsLim.toByteArray() );
		 int end = tableStream.size();
		 fib.setFcPlcfbkl( start );
		 fib.setLcbPlcfbkl( end - start );
	 }
	 public void writeSttbfBkmk( FileInformationBlock fib, ByteArrayOutputStream tableStream ) throws IOException {
		 if ( names == null || names.isEmpty() ) {
			 fib.setFcSttbfbkmk( 0 );
			 fib.setLcbSttbfbkmk( 0 );
			 return;
		 }
		 int start = tableStream.size();
		 SttbUtils.writeSttbfBkmk( names.toArray( new String[names.size()] ), tableStream );
		 int end = tableStream.size();
		 fib.setFcSttbfbkmk( start );
		 fib.setLcbSttbfbkmk( end - start );
	 }
}",1,0,0,0
"public class DBMsgConstants {
	 public static final int MAX_BODY_SIZE = 64 * 1024 * 1024;
 }",0,1,0,0
"public void addFileset(FileSet set) {
	 filesets.addElement(set);
 }",0,0,0,0
"protected JRFillBreak(JRBaseFiller filler,JRBreak breakElement, JRFillObjectFactory factory);",0,0,0,0
"public void buildFinished(BuildEvent event) {
	 if (event.getException() == null && fileSuccess != null) {
		 play(event.getProject(), fileSuccess, loopsSuccess, durationSuccess);
	 }
	 else if (event.getException() != null && fileFail != null) {
		 play(event.getProject(), fileFail, loopsFail, durationFail);
	 }
 }",0,0,0,0
"public int getLiveColumnCount() {
	 return cf == null ? 0 : cf.getLiveColumnCount();
 }",0,0,0,0
"public class StreamUtil {
	 public static <T> Stream<T> opt2stream(Optional<T> opt) {
		 return opt.map(Stream::of).orElseGet(Stream::empty);
	 }
}",0,0,0,0
"public abstract static class AbstractBrooklynAdjunctSerialization<T extends BrooklynObject & EntityAdjunct> extends AbstractWithManagementContextSerialization<T> {
	 public AbstractBrooklynAdjunctSerialization(Class<T> type, ManagementContext mgmt) {
		 super(type, mgmt);
	 }
	 protected String customType(T value) throws IOException {
		 return type.getCanonicalName();
	 }
	 public void customWriteBody(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
		 Optional<String> entityId = getEntityId(value);
		 jgen.writeStringField(""id"", value.getId());
		 if (entityId.isPresent()) jgen.writeStringField(""entityId"", entityId.get());
	 }
	 protected T customReadBody(String type, Map<Object, Object> values, JsonParser jp, DeserializationContext ctxt) throws IOException {
		 Optional<String> entityId = Optional.fromNullable((String) values.get(""entityId""));
		 Optional<Entity> entity = Optional.fromNullable(entityId.isPresent() ? null: mgmt.getEntityManager().getEntity(entityId.get()));
		 String id = (String) values.get(""id"");
		 return getInstanceFromId(entity, id);
	 }
	 protected Optional<String> getEntityId(T value) {
		 if (value instanceof AbstractEntityAdjunct) {
			 Entity entity = ((AbstractEntityAdjunct)value).getEntity();
			 return Optional.fromNullable(entity == null ? null : entity.getId());
		 }
		 return Optional.absent();
	 }
	 protected abstract T getInstanceFromId(Optional<Entity> entity, String id);
 }",0,0,0,0
"public class SignupController {
	private final SignupHelper signupHelper;
	public SignupController(AccountRepository accountRepository, SignedUpGateway gateway) {
		this.signupHelper = new SignupHelper(accountRepository, gateway);
	}
	public SignupForm signupForm(WebRequest request) {
		Connection<?> connection = ProviderSignInUtils.getConnection(request);
		if (connection != null) {
			request.setAttribute(""message"", new Message(MessageType.INFO, ""Your "" + StringUtils.capitalize(connection.getKey().getProviderId()) + "" account is not associated with a Greenhouse account. If you're new, please sign up.""), WebRequest.SCOPE_REQUEST);
			return SignupForm.fromProviderUser(connection.fetchUserProfile());
		}
		 else {
			return new SignupForm();
		}
	}
	public String signup( SignupForm form, BindingResult formBinding, final WebRequest request) {
		if (formBinding.hasErrors()) {
			return null;
		}
		boolean result = signupHelper.signup(form, formBinding, new SignupCallback() {
			public void postSignup(Account account) {
				ProviderSignInUtils.handlePostSignUp(account.getId().toString(), request);
			}
		}
		);
		return result ? ""redirect:/"" : null;
	}
	public ResponseEntity<Map<String, Object>> signupFromApi( SignupForm form) {
		BindingResult formBinding = validate(form);
		 if (formBinding.hasErrors()) {
			HashMap<String, Object> errorResponse = new HashMap<String, Object>();
			errorResponse.put(""message"", ""Validation error"");
			errorResponse.put(""errors"", getErrorsMap(formBinding));
			return new ResponseEntity<Map<String, Object>>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		boolean result = signupHelper.signup(form, formBinding);
		if (result) {
			HashMap<String, Object> errorResponse = new HashMap<String, Object>();
			errorResponse.put(""message"", ""Account created"");
			return new ResponseEntity<Map<String, Object>>(errorResponse, HttpStatus.CREATED);
		}
		 else {
			HashMap<String, Object> errorResponse = new HashMap<String, Object>();
			errorResponse.put(""message"", ""Account creation error"");
			errorResponse.put(""errors"", getErrorsMap(formBinding));
			return new ResponseEntity<Map<String, Object>>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}
	private BindException validate(SignupForm form) {
		BindException errors;
		errors = new BindException(form, ""signupForm"");
		LazyValidatorFactory lvf = new LazyValidatorFactory();
		Validator validator = new SpringValidatorAdapter(lvf.getValidator());
		ValidationUtils.invokeValidator(validator, form, errors);
		return errors;
	}
	private List<Map<String, String>> getErrorsMap(BindingResult formBinding) {
		List<FieldError> fieldErrors = formBinding.getFieldErrors();
		List<Map<String, String>> errors = new ArrayList<Map<String,String>>(fieldErrors.size());
		for (FieldError fieldError : fieldErrors) {
			Map<String, String> fieldErrorMap = new HashMap<String, String>();
			fieldErrorMap.put(""field"", fieldError.getField());
			fieldErrorMap.put(""code"", fieldError.getCode());
			fieldErrorMap.put(""message"", fieldError.getDefaultMessage());
			errors.add(fieldErrorMap);
		}
		return errors;
	}
}",1,0,0,0
"public String recv_registerComputeResource() throws org.apache.airavata.model.error.InvalidRequestException, org.apache.airavata.model.error.AiravataClientException, org.apache.airavata.model.error.AiravataSystemException, org.apache.airavata.model.error.AuthorizationException, org.apache.thrift.TException {
	 registerComputeResource_result result = new registerComputeResource_result();
	 receiveBase(result, ""registerComputeResource"");
	 if (result.isSetSuccess()) {
		 return result.success;
	 }
	 if (result.ire != null) {
		 throw result.ire;
	 }
	 if (result.ace != null) {
		 throw result.ace;
	 }
	 if (result.ase != null) {
		 throw result.ase;
	 }
	 if (result.ae != null) {
		 throw result.ae;
	 }
	 throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, ""registerComputeResource failed: unknown result"");
 }",0,0,1,0
"public class CustomBattleArmorDialog extends Dialog implements ActionListener, ItemListener, KeyListener, Runnable, TextListener, WindowListener {
	 private static final long serialVersionUID = -5195200950623503842L;
	 private Client m_client;
	 private ClientGUI m_clientgui;
	 private Panel m_pLeft = new Panel();
	 private Panel m_pParams = new Panel();
	 private Label m_labelBAName = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelBAName""), Label.RIGHT);
	 private TextField m_tfBAName = new TextField();
	 private Label m_labelMenPerSquad = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelMenPerSquad""), Label.RIGHT);
	 private Choice m_chMenPerSquad = new Choice();
	 private Label m_labelTechBase = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelTechBase""), Label.RIGHT);
	 private Choice m_chTechBase = new Choice();
	 private Label m_labelChassisType = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelChassisType""), Label.RIGHT);
	 private Choice m_chChassisType = new Choice();
	 private Label m_labelWeightClass = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelWeightClass""), Label.RIGHT);
	 private Choice m_chWeightClass = new Choice();
	 private Label m_labelGroundMP = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelGroundMP""), Label.RIGHT);
	 private Choice m_chGroundMP = new Choice();
	 private CheckboxGroup m_cbgJumpType = new CheckboxGroup();
	 private Checkbox m_cbJumpQuery = new Checkbox(Messages .getString(""CustomBattleArmorDialog.m_jumpQuery""), m_cbgJumpType, true);
	 private Checkbox m_cbVTOLQuery = new Checkbox(Messages .getString(""CustomBattleArmorDialog.m_VTOLQuery""), m_cbgJumpType, false);
	 private Checkbox m_cbUMUQuery = new Checkbox(Messages .getString(""CustomBattleArmorDialog.m_UMUQuery""), m_cbgJumpType, false);
	 private Label m_labelJumpValue = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelJumpValue""), Label.RIGHT);
	 private Choice m_chJumpValue = new Choice();
	 private Label m_labelArmorType = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelArmorType""), Label.RIGHT);
	 private Choice m_chArmorType = new Choice();
	 private Label m_labelArmorValue = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelArmorValue""), Label.RIGHT);
	 private Choice m_chArmorValue = new Choice();
	 private Label m_labelLeftManipulator = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelLeftManipulator""), Label.RIGHT);
	 private Choice m_chLeftManipulator = new Choice();
	 private Label m_labelRightManipulator = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelRightManipulator""), Label.RIGHT);
	 private Choice m_chRightManipulator = new Choice();
	 private Label m_labelTorsoEquipment = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelTorsoEquipment""), Label.RIGHT);
	 private Choice m_chTorsoEquipment = new Choice();
	 private Button m_buttonAddTorso = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonAdd""));
	 private Label m_labelRightArmEquipment = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelRightArmEquipment""), Label.RIGHT);
	 private Choice m_chRightArmEquipment = new Choice();
	 private Button m_buttonAddRightArm = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonAdd""));
	 private Label m_labelLeftArmEquipment = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelLeftArmEquipment""), Label.RIGHT);
	 private Choice m_chLeftArmEquipment = new Choice();
	 private Button m_buttonAddLeftArm = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonAdd""));
	 private Label m_labelTorsoCurrentEquipment = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelCurrentTorsoEquipment""), Label.RIGHT);
	 private Choice m_chTorsoCurrentEquipment = new Choice();
	 private Button m_buttonRemoveTorso = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonRemove""));
	 private Label m_labelRightArmCurrentEquipment = new Label( Messages .getString(""CustomBattleArmorDialog.m_labelCurrentRightArmEquipment""), Label.RIGHT);
	 private Choice m_chRightArmCurrentEquipment = new Choice();
	 private Button m_buttonRemoveRightArm = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonRemove""));
	 private Label m_labelLeftArmCurrentEquipment = new Label( Messages .getString(""CustomBattleArmorDialog.m_labelCurrentLeftArmEquipment""), Label.RIGHT);
	 private Choice m_chLeftArmCurrentEquipment = new Choice();
	 private Button m_buttonRemoveLeftArm = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonRemove""));
	 private Panel m_pButtons = new Panel();
	 private Button m_bPick = new Button(Messages .getString(""CustomBattleArmorDialog.m_bPick""));
	 private Button m_bPickClose = new Button(Messages .getString(""CustomBattleArmorDialog.m_bPickClose""));
	 private Button m_bCancel = new Button(Messages .getString(""CustomBattleArmorDialog.m_bClose""));
	 private Button m_bSave = new Button(Messages .getString(""CustomBattleArmorDialog.m_bSave""));
	 private Button m_buttonReset = new Button(Messages .getString(""CustomBattleArmorDialog.m_buttonReset""));
	 private Label m_labelPlayer = new Label(Messages .getString(""CustomBattleArmorDialog.m_labelPlayer""), Label.RIGHT);
	 private Choice m_chPlayer = new Choice();
	 private TextArea m_BAView = new TextArea("""", 18, 25, TextArea.SCROLLBARS_BOTH);
	 private String invalidReason = null;
	 private int stateMenPerSquad = 1;
	 private int stateTechBase = 0;
	 private int stateChassisType = 0;
	 private int stateWeightClass = 0;
	 private int stateArmorType = 0;
	 private int stateArmorValue = 0;
	 private int stateJumpType = 0;
	 private int stateJumpMP = 0;
	 private int stateGroundMP = 1;
	 private int stateCurrentWeight = 0;
	 private int stateMinWeight = 0;
	 private int stateMaxWeight = 400;
	 private int stateManipulatorTypeLeft = 0;
	 private int stateManipulatorTypeRight = 0;
	 private int stateConflictFlags = 0;
	 private Vector<BattleArmorEquipment> leftArmEquipment = null;
	 private Vector<BattleArmorEquipment> rightArmEquipment = null;
	 private Vector<BattleArmorEquipment> torsoEquipment = null;
	 static ArrayList<BattleArmorEquipment> equipmentTypes = null;
	 static ArrayList<String> equipmentNames = null;
	 private static final int TECH_BASE_IS = 0;
	 private static final int TECH_BASE_CLAN = 1;
	 private static final int TECH_BASE_BOTH = 2;
	 private static final int WEIGHT_CLASS_PAL = 0;
	 private static final int WEIGHT_CLASS_LIGHT = 1;
	 private static final int WEIGHT_CLASS_MEDIUM = 2;
	 private static final int WEIGHT_CLASS_HEAVY = 3;
	 private static final int WEIGHT_CLASS_ASSAULT = 4;
	 private static final int JUMP_TYPE_JUMP = 0;
	 private static final int JUMP_TYPE_VTOL = 1;
	 private static final int JUMP_TYPE_UMU = 2;
	 public static int EQUIPMENT_TYPE_WEAPON = 0;
	 public static int EQUIPMENT_TYPE_WEAPON_AP = 1;
	 public static int EQUIPMENT_TYPE_PREPROCESS = 2;
	 public static int EQUIPMENT_TYPE_AMMO = 3;
	 public static int EQUIPMENT_TYPE_OTHER = 4;
	 private static final int[][] ARMOR_TYPE_WEIGHT = {
		 {
		 50, 40, 100, 55, 100, 60, 60, 0, 50 }
		, {
		 25, 0, 0, 30, 0, 35, 35, 30, 0 }
	 }
	;
	 private static final int[] ARMOR_TYPE_SLOTS = {
	 0, 5, 4, 3, 4, 4, 5, 5, 5 }
	;
	 private static final int[] ARMOR_TYPE_COSTS = {
	 10000, 12500, 10000, 12000, 50000, 15000, 20000, 10000, 15000 }
	;
	 private static final String[] ARMOR_TYPE_STRINGS = {
	 ""Standard"", ""Advanced"", ""Prototype"", ""Basic Stealth"", ""Prototype Stealth"", ""Standard Stealth"", ""Improved Stealth"", ""Fire Resistant"", ""Mimetic"" }
	;
	 private static final int[] GROUND_MP_WEIGHT = {
	 25, 30, 40, 80, 160 }
	;
	 private static final int[][] JUMP_MP_LIMITS = {
		 {
		 3, 3, 3, 2, 2 }
		, {
		 7, 6, 5, 0, 0 }
		, {
		 5, 5, 4, 3, 2 }
	 }
	;
	 private static final int[][] JUMP_MP_WEIGHT = {
		 {
		 25, 25, 50, 125, 250 }
		, {
		 30, 40, 60, 0, 0 }
		, {
		 45, 45, 85, 160, 250 }
	 }
	;
	 private static final int[][] JUMP_MP_COST = {
		 {
		 50000, 50000, 75000, 150000, 300000 }
		, {
		 50000, 50000, 100000, 0, 0 }
		, {
		 50000, 50000, 75000, 100000, 150000 }
	 }
	;
	 private static final int[] MANIPULATOR_TYPE_WEIGHT = {
	 0, 0, 0, 15, 15, 35, 50, 20, 60, 30, 30, 30 }
	;
	 private static final int[] MANIPULATOR_TYPE_COSTS = {
	 0, 2500, 5000, 7500, 10000, 12500, 15000, 25000, 30000, 500, 2500 }
	;
	 public static final int[] ARM_MAX_SLOTS = {
	 2, 2, 3, 3, 4 }
	;
	 public static final int[] TORSO_MAX_SLOTS = {
	 2, 4, 4, 6, 8 }
	;
	 public static final int[] QUAD_MAX_SLOTS = {
	 0, 5, 7, 9, 11 }
	;
	 public static final int LOCATION_ALLOWED_ANY = 0;
	 public static final int LOCATION_ALLOWED_TORSO = 1;
	 public static final int LOCATION_ALLOWED_ARM = 2;
	 private static final int F_CONFLICT_JUMP_GEAR = 0x00000001;
	 public CustomBattleArmorDialog(ClientGUI cl) {
		 super(cl.frame, Messages.getString(""CustomBattleArmorDialog.title""), true);
		 m_client = cl.getClient();
		 m_clientgui = cl;
		 updatePlayerChoice();
		 GridLayout gl = new GridLayout();
		 gl.setColumns(1);
		 gl.setRows(0);
		 m_pParams.setLayout(gl);
		 GridLayout tmpGL = new GridLayout(1, 2);
		 Panel tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelBAName);
		 m_tfBAName.addTextListener(this);
		 tmpP.add(m_tfBAName);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelMenPerSquad);
		 m_chMenPerSquad.addItemListener(this);
		 tmpP.add(m_chMenPerSquad);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelTechBase);
		 m_chTechBase.addItemListener(this);
		 tmpP.add(m_chTechBase);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelChassisType);
		 m_chChassisType.addItemListener(this);
		 tmpP.add(m_chChassisType);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelWeightClass);
		 m_chWeightClass.addItemListener(this);
		 tmpP.add(m_chWeightClass);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelGroundMP);
		 m_chGroundMP.addItemListener(this);
		 tmpP.add(m_chGroundMP);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 m_cbJumpQuery.addItemListener(this);
		 tmpP.add(m_cbJumpQuery);
		 m_cbVTOLQuery.addItemListener(this);
		 tmpP.add(m_cbVTOLQuery);
		 m_cbUMUQuery.addItemListener(this);
		 tmpP.add(m_cbUMUQuery);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 2);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelJumpValue);
		 m_chJumpValue.addItemListener(this);
		 tmpP.add(m_chJumpValue);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelArmorType);
		 m_chArmorType.addItemListener(this);
		 tmpP.add(m_chArmorType);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelArmorValue);
		 m_chArmorValue.addItemListener(this);
		 tmpP.add(m_chArmorValue);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelLeftManipulator);
		 m_chLeftManipulator.addItemListener(this);
		 tmpP.add(m_chLeftManipulator);
		 m_pParams.add(tmpP);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelRightManipulator);
		 m_chRightManipulator.addItemListener(this);
		 tmpP.add(m_chRightManipulator);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelTorsoEquipment);
		 tmpP.add(m_chTorsoEquipment);
		 m_buttonAddTorso.addActionListener(this);
		 tmpP.add(m_buttonAddTorso);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelRightArmEquipment);
		 tmpP.add(m_chRightArmEquipment);
		 m_buttonAddRightArm.addActionListener(this);
		 tmpP.add(m_buttonAddRightArm);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelLeftArmEquipment);
		 tmpP.add(m_chLeftArmEquipment);
		 m_buttonAddLeftArm.addActionListener(this);
		 tmpP.add(m_buttonAddLeftArm);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelTorsoCurrentEquipment);
		 tmpP.add(m_chTorsoCurrentEquipment);
		 m_buttonRemoveTorso.addActionListener(this);
		 tmpP.add(m_buttonRemoveTorso);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelRightArmCurrentEquipment);
		 tmpP.add(m_chRightArmCurrentEquipment);
		 m_buttonRemoveRightArm.addActionListener(this);
		 tmpP.add(m_buttonRemoveRightArm);
		 m_pParams.add(tmpP);
		 tmpGL = new GridLayout(1, 3);
		 tmpP = new Panel();
		 tmpP.setLayout(tmpGL);
		 tmpP.add(m_labelLeftArmCurrentEquipment);
		 tmpP.add(m_chLeftArmCurrentEquipment);
		 m_buttonRemoveLeftArm.addActionListener(this);
		 tmpP.add(m_buttonRemoveLeftArm);
		 m_pParams.add(tmpP);
		 m_pButtons.setLayout(new FlowLayout(FlowLayout.CENTER));
		 m_pButtons.add(m_bPick);
		 m_pButtons.add(m_bPickClose);
		 m_pButtons.add(m_bSave);
		 m_pButtons.add(m_buttonReset);
		 m_pButtons.add(m_bCancel);
		 m_pButtons.add(m_labelPlayer);
		 m_pButtons.add(m_chPlayer);
		 m_pLeft.setLayout(new BorderLayout());
		 m_pLeft.add(m_pParams, BorderLayout.CENTER);
		 m_pLeft.add(m_pButtons, BorderLayout.SOUTH);
		 setLayout(new BorderLayout());
		 add(m_pLeft, BorderLayout.WEST);
		 m_BAView.setFont(new Font(""Monospaced"", Font.PLAIN, 12));
		 add(m_BAView, BorderLayout.CENTER);
		 setSize(800, 450);
		 setLocation(computeDesiredLocation());
		 new BattleArmorEquipment().initialize();
		 populateChoices();
		 m_bPick.addActionListener(this);
		 m_bPickClose.addActionListener(this);
		 m_buttonReset.addActionListener(this);
		 m_bCancel.addActionListener(this);
		 m_bSave.addActionListener(this);
		 addWindowListener(this);
		 updateWidgetEnablements();
		 previewBA();
	 }
	 private void resetState() {
		 restoreDefaultStates();
		 populateChoices();
		 previewBA();
	 }
	 private void restoreDefaultStates() {
		 m_tfBAName.setText("""");
		 invalidReason = null;
		 stateMenPerSquad = 1;
		 stateTechBase = 0;
		 stateChassisType = 0;
		 stateWeightClass = 0;
		 stateArmorType = 0;
		 stateArmorValue = 0;
		 stateJumpType = 0;
		 stateJumpMP = 0;
		 stateGroundMP = 1;
		 stateCurrentWeight = 0;
		 stateMinWeight = 0;
		 stateMaxWeight = 400;
		 stateManipulatorTypeLeft = 0;
		 stateManipulatorTypeRight = 0;
		 stateConflictFlags = 0;
		 leftArmEquipment = null;
		 rightArmEquipment = null;
		 torsoEquipment = null;
	 }
	 private void updatePlayerChoice() {
		 String lastChoice = m_chPlayer.getSelectedItem();
		 m_chPlayer.removeAll();
		 m_chPlayer.setEnabled(true);
		 m_chPlayer.addItem(m_clientgui.getClient().getName());
		 for (Iterator<Client> i = m_clientgui.getBots().values().iterator();
		 i .hasNext();
		) {
			 m_chPlayer.addItem(i.next().getName());
		 }
		 if (m_chPlayer.getItemCount() == 1) {
			 m_chPlayer.setEnabled(false);
		 }
		 else {
			 m_chPlayer.select(lastChoice);
		 }
	 }
	 public void run() {
	 }
	 private void populateChoices() {
		 m_chTechBase.add(""Inner Sphere"");
		 m_chTechBase.add(""Clan"");
		 m_chTechBase.select(0);
		 m_chMenPerSquad.add(""1"");
		 m_chMenPerSquad.add(""2"");
		 m_chMenPerSquad.add(""3"");
		 m_chMenPerSquad.add(""4"");
		 m_chMenPerSquad.add(""5"");
		 m_chMenPerSquad.add(""6"");
		 m_chMenPerSquad.select(0);
		 m_chChassisType.add(""Biped"");
		 m_chChassisType.add(""Quad"");
		 m_chChassisType.select(0);
		 m_chWeightClass.add(""PA(L)"");
		 m_chWeightClass.add(""Light"");
		 m_chWeightClass.add(""Medium"");
		 m_chWeightClass.add(""Heavy"");
		 m_chWeightClass.add(""Assault"");
		 m_chWeightClass.select(0);
		 m_chGroundMP.add(""1"");
		 m_chGroundMP.add(""2"");
		 m_chGroundMP.add(""3"");
		 m_chGroundMP.select(0);
		 m_chJumpValue.add(""0"");
		 m_chJumpValue.add(""1"");
		 m_chJumpValue.add(""2"");
		 m_chJumpValue.add(""3"");
		 m_chJumpValue.select(0);
		 m_chArmorType.add(""Standard"");
		 m_chArmorType.add(""Advanced"");
		 m_chArmorType.add(""Prototype"");
		 m_chArmorType.add(""Basic Stealth"");
		 m_chArmorType.add(""Prototype Stealth"");
		 m_chArmorType.add(""Standard Stealth"");
		 m_chArmorType.add(""Improved Stealth"");
		 m_chArmorType.add(""Fire Resistant"");
		 m_chArmorType.add(""Mimetic"");
		 m_chArmorType.select(0);
		 for (int x = 0;
		 x < BattleArmor.MANIPULATOR_TYPE_STRINGS.length;
		 x++) {
			 m_chLeftManipulator.add(BattleArmor.MANIPULATOR_TYPE_STRINGS[x]);
			 m_chRightManipulator.add(BattleArmor.MANIPULATOR_TYPE_STRINGS[x]);
		 }
		 m_chLeftManipulator.select(0);
		 m_chRightManipulator.select(0);
		 m_chArmorValue.add(""0"");
		 m_chArmorValue.add(""1"");
		 m_chArmorValue.add(""2"");
		 m_chArmorValue.select(0);
		 updateEquipmentChoices();
	 }
	 private void updateEquipmentChoices() {
		 String value = m_chTorsoEquipment.getSelectedItem();
		 m_chTorsoEquipment.removeAll();
		 Object[] tmpE = equipmentTypes.toArray();
		 for (int x = 0;
		 x < tmpE.length;
		 x++) {
			 BattleArmorEquipment tmpBAE = (BattleArmorEquipment) (tmpE[x]);
			 if (((tmpBAE.techBase == TECH_BASE_BOTH) || (tmpBAE.techBase == stateTechBase)) && !(hasConflictFlag(tmpBAE.conflictFlag)) && ((tmpBAE.allowedLocation == LOCATION_ALLOWED_ANY) || (tmpBAE.allowedLocation == LOCATION_ALLOWED_TORSO))) {
				 m_chTorsoEquipment.add(tmpBAE.name);
			 }
		 }
		 m_chTorsoEquipment.select(value);
		 value = m_chRightArmEquipment.getSelectedItem();
		 m_chRightArmEquipment.removeAll();
		 if (stateChassisType != BattleArmor.CHASSIS_TYPE_QUAD) {
			 tmpE = equipmentTypes.toArray();
			 for (int x = 0;
			 x < tmpE.length;
			 x++) {
				 BattleArmorEquipment tmpBAE = (BattleArmorEquipment) (tmpE[x]);
				 if (((tmpBAE.techBase == TECH_BASE_BOTH) || (tmpBAE.techBase == stateTechBase)) && !(hasConflictFlag(tmpBAE.conflictFlag)) && ((tmpBAE.allowedLocation == LOCATION_ALLOWED_ANY) || (tmpBAE.allowedLocation == LOCATION_ALLOWED_ARM))) {
					 m_chRightArmEquipment.add(tmpBAE.name);
				 }
			 }
		 }
		 m_chRightArmEquipment.select(value);
		 value = m_chLeftArmEquipment.getSelectedItem();
		 m_chLeftArmEquipment.removeAll();
		 if (stateChassisType != BattleArmor.CHASSIS_TYPE_QUAD) {
			 tmpE = equipmentTypes.toArray();
			 for (int x = 0;
			 x < tmpE.length;
			 x++) {
				 BattleArmorEquipment tmpBAE = (BattleArmorEquipment) (tmpE[x]);
				 if (((tmpBAE.techBase == TECH_BASE_BOTH) || (tmpBAE.techBase == stateTechBase)) && !(hasConflictFlag(tmpBAE.conflictFlag)) && ((tmpBAE.allowedLocation == LOCATION_ALLOWED_ANY) || (tmpBAE.allowedLocation == LOCATION_ALLOWED_ARM))) {
					 m_chLeftArmEquipment.add(tmpBAE.name);
				 }
			 }
		 }
		 m_chLeftArmEquipment.select(value);
		 m_chLeftArmCurrentEquipment.removeAll();
		 if (leftArmEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpEE = leftArmEquipment .elements();
			 while (tmpEE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpEE.nextElement());
				 m_chLeftArmCurrentEquipment.add(tmpBAE.name);
			 }
		 }
		 m_chRightArmCurrentEquipment.removeAll();
		 if (rightArmEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpEE = rightArmEquipment .elements();
			 while (tmpEE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpEE.nextElement());
				 m_chRightArmCurrentEquipment.add(tmpBAE.name);
			 }
		 }
		 m_chTorsoCurrentEquipment.removeAll();
		 if (torsoEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpEE = torsoEquipment.elements();
			 while (tmpEE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpEE.nextElement());
				 m_chTorsoCurrentEquipment.add(tmpBAE.name);
			 }
		 }
	 }
	 private boolean hasConflictFlag(int testFlags) {
		 return ((stateConflictFlags & testFlags) > 0);
	 }
	 private void updateGroundMPChoices() {
		 m_chGroundMP.removeAll();
		 if (stateChassisType == BattleArmor.CHASSIS_TYPE_BIPED) {
			 m_chGroundMP.add(""1"");
			 m_chGroundMP.add(""2"");
			 if ((stateWeightClass == WEIGHT_CLASS_PAL) || (stateWeightClass == WEIGHT_CLASS_LIGHT) || (stateWeightClass == WEIGHT_CLASS_MEDIUM)) {
				 m_chGroundMP.add(""3"");
			 }
		 }
		 else {
			 m_chGroundMP.add(""2"");
			 m_chGroundMP.add(""3"");
			 m_chGroundMP.add(""4"");
			 if ((stateWeightClass == WEIGHT_CLASS_LIGHT) || (stateWeightClass == WEIGHT_CLASS_MEDIUM)) {
				 m_chGroundMP.add(""5"");
			 }
		 }
		 m_chGroundMP.select(0);
		 stateGroundMP = Integer.parseInt(m_chGroundMP.getSelectedItem());
	 }
	 private void updateJumpMPChoices() {
		 int tmp = m_chJumpValue.getSelectedIndex();
		 m_chJumpValue.removeAll();
		 for (int x = 0;
		 x <= JUMP_MP_LIMITS[stateJumpType][stateWeightClass];
		 x++) {
			 m_chJumpValue.add(Integer.toString(x));
		 }
		 if (tmp >= m_chJumpValue.getItemCount()) {
			 m_chJumpValue.select(m_chJumpValue.getItemCount() - 1);
			 stateJumpMP = m_chJumpValue.getSelectedIndex();
		 }
		 else {
			 m_chJumpValue.select(tmp);
		 }
	 }
	 private void updateArmorValueChoices() {
		 int tmp = m_chArmorValue.getSelectedIndex();
		 m_chArmorValue.removeAll();
		 m_chArmorValue.add(""0"");
		 m_chArmorValue.add(""1"");
		 m_chArmorValue.add(""2"");
		 if (stateWeightClass > 0) {
			 m_chArmorValue.add(""3"");
			 m_chArmorValue.add(""4"");
			 m_chArmorValue.add(""5"");
			 m_chArmorValue.add(""6"");
			 if (stateWeightClass > 1) {
				 m_chArmorValue.add(""7"");
				 m_chArmorValue.add(""8"");
				 m_chArmorValue.add(""9"");
				 m_chArmorValue.add(""10"");
				 if (stateWeightClass > 2) {
					 m_chArmorValue.add(""11"");
					 m_chArmorValue.add(""12"");
					 m_chArmorValue.add(""13"");
					 m_chArmorValue.add(""14"");
					 if (stateWeightClass > 3) {
						 m_chArmorValue.add(""15"");
						 m_chArmorValue.add(""16"");
						 m_chArmorValue.add(""17"");
						 m_chArmorValue.add(""18"");
					 }
				 }
			 }
		 }
		 if (tmp >= m_chArmorValue.getItemCount()) {
			 m_chArmorValue.select(m_chArmorValue.getItemCount() - 1);
			 stateArmorValue = m_chArmorValue.getSelectedIndex();
		 }
		 else {
			 m_chArmorValue.select(tmp);
		 }
	 }
	 private Point computeDesiredLocation() {
		 int desiredX = m_clientgui.frame.getLocation().x + m_clientgui.frame.getSize().width / 2 - getSize().width / 2;
		 if (desiredX < 0) {
			 desiredX = 0;
		 }
		 int desiredY = m_clientgui.frame.getLocation().y + m_clientgui.frame.getSize().height / 2 - getSize().height / 2;
		 if (desiredY < 0) {
			 desiredY = 0;
		 }
		 return new Point(desiredX, desiredY);
	 }
	 public void setVisible(boolean show) {
		 super.setVisible(show);
		 if (show) {
			 updatePlayerChoice();
			 setLocation(computeDesiredLocation());
			 m_BAView.setCaretPosition(0);
		 }
	 }
	 public void actionPerformed(ActionEvent ae) {
		 if (ae.getSource() == m_buttonReset) {
			 resetState();
			 return;
		 }
		 else if (ae.getSource() == m_buttonAddTorso) {
			 BattleArmorEquipment tmpBAE = equipmentTypes.get(equipmentNames .indexOf(m_chTorsoEquipment.getSelectedItem()));
			 if (torsoEquipment == null) {
				 torsoEquipment = new Vector<BattleArmorEquipment>();
			 }
			 torsoEquipment.add(tmpBAE);
			 stateConflictFlags |= tmpBAE.conflictFlag;
			 previewBA();
			 updateEquipmentChoices();
			 return;
		 }
		 else if (ae.getSource() == m_buttonAddRightArm) {
			 BattleArmorEquipment tmpBAE = equipmentTypes.get(equipmentNames .indexOf(m_chRightArmEquipment.getSelectedItem()));
			 if (rightArmEquipment == null) {
				 rightArmEquipment = new Vector<BattleArmorEquipment>();
			 }
			 rightArmEquipment.add(tmpBAE);
			 stateConflictFlags |= tmpBAE.conflictFlag;
			 previewBA();
			 updateEquipmentChoices();
			 return;
		 }
		 else if (ae.getSource() == m_buttonAddLeftArm) {
			 BattleArmorEquipment tmpBAE = equipmentTypes.get(equipmentNames .indexOf(m_chLeftArmEquipment.getSelectedItem()));
			 if (leftArmEquipment == null) {
				 leftArmEquipment = new Vector<BattleArmorEquipment>();
			 }
			 leftArmEquipment.add(tmpBAE);
			 stateConflictFlags |= tmpBAE.conflictFlag;
			 previewBA();
			 updateEquipmentChoices();
			 return;
		 }
		 else if (ae.getSource() == m_buttonRemoveTorso) {
			 if (torsoEquipment != null) {
				 String removeItem = m_chTorsoCurrentEquipment.getSelectedItem();
				 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if (tmpBAE.name.equals(removeItem)) {
						 torsoEquipment.remove(tmpBAE);
						 break;
					 }
				 }
				 if (torsoEquipment.size() <= 0) {
					 torsoEquipment = null;
				 }
				 previewBA();
				 updateEquipmentChoices();
			 }
			 return;
		 }
		 else if (ae.getSource() == m_buttonRemoveRightArm) {
			 if (rightArmEquipment != null) {
				 String removeItem = m_chRightArmCurrentEquipment .getSelectedItem();
				 Enumeration<BattleArmorEquipment> tmpE = rightArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if (tmpBAE.name.equals(removeItem)) {
						 rightArmEquipment.remove(tmpBAE);
						 break;
					 }
				 }
				 if (rightArmEquipment.size() <= 0) {
					 rightArmEquipment = null;
				 }
				 previewBA();
				 updateEquipmentChoices();
			 }
			 return;
		 }
		 else if (ae.getSource() == m_buttonRemoveLeftArm) {
			 if (leftArmEquipment != null) {
				 String removeItem = m_chLeftArmCurrentEquipment .getSelectedItem();
				 Enumeration<BattleArmorEquipment> tmpE = leftArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if (tmpBAE.name.equals(removeItem)) {
						 leftArmEquipment.remove(tmpBAE);
						 break;
					 }
				 }
				 if (leftArmEquipment.size() <= 0) {
					 leftArmEquipment = null;
				 }
				 previewBA();
				 updateEquipmentChoices();
			 }
			 return;
		 }
		 else if ((ae.getSource() == m_bPick) || (ae.getSource() == m_bPickClose)) {
			 if (!isOK()) {
				 new megamek.client.ui.AWT.AlertDialog(m_clientgui.frame, ""Can't do that!"", ""You can't add an invalid unit."") .setVisible(true);
				 return;
			 }
			 try {
				 BattleArmor e = getEntity();
				 Client c = null;
				 if (m_chPlayer.getSelectedIndex() > 0) {
					 String name = m_chPlayer.getSelectedItem();
					 c = m_clientgui.getBots().get(name);
				 }
				 if (c == null) {
					 c = m_client;
				 }
				 e.setOwner(c.getLocalPlayer());
				 c.sendAddEntity(e);
			 }
			 catch (Exception ex) {
				 System.err.println(""Error while loading custom BattleArmor!"");
				 ex.printStackTrace();
				 return;
			 }
		 }
		 else if (ae.getSource() == m_bSave) {
			 FileDialog fd = new FileDialog( m_clientgui.frame, Messages .getString(""CustomBattleArmorDialog.FileSaveDialog""), FileDialog.SAVE);
			 fd.setDirectory(""data"" + File.separatorChar + ""mechfiles"");
			 fd.setFile(m_tfBAName.getText() + "".blk"");
			 fd.setFilenameFilter(new FilenameFilter() {
				 public boolean accept(File f, String s) {
					 return s.endsWith("".blk"");
				 }
			 }
			);
			 fd.setModal(true);
			 fd.setVisible(true);
			 String filename = fd.getDirectory() + File.separator + fd.getFile();
			 if (filename.indexOf('.') == -1) {
				 filename = filename + "".blk"";
			 }
			 File f = new File(filename);
			 try {
				 BattleArmor ba = getEntity();
				 FileWriter wr = new FileWriter(f);
				 wr.write(ba.getBLK());
				 wr.close();
			 }
			 catch (Exception ex) {
				 ex.printStackTrace();
			 }
		 }
		 if ((ae.getSource() == m_bCancel) || (ae.getSource() == m_bPickClose)) {
			 setVisible(false);
		 }
	 }
	 public void textValueChanged(TextEvent te) {
		 previewBA();
	 }
	 public void itemStateChanged(ItemEvent ie) {
		 if (ie.getSource() == m_cbJumpQuery) {
			 if (m_cbJumpQuery.getState()) {
				 stateJumpType = JUMP_TYPE_JUMP;
				 updateJumpMPChoices();
				 m_labelJumpValue.setText(Messages .getString(""CustomBattleArmorDialog.m_labelJumpValue""));
			 }
		 }
		 else if (ie.getSource() == m_cbVTOLQuery) {
			 if (m_cbVTOLQuery.getState()) {
				 stateJumpType = JUMP_TYPE_VTOL;
				 updateJumpMPChoices();
				 m_labelJumpValue.setText(Messages .getString(""CustomBattleArmorDialog.m_labelVTOLValue""));
			 }
		 }
		 else if (ie.getSource() == m_cbUMUQuery) {
			 if (m_cbUMUQuery.getState()) {
				 stateJumpType = JUMP_TYPE_UMU;
				 updateJumpMPChoices();
				 m_labelJumpValue.setText(Messages .getString(""CustomBattleArmorDialog.m_labelUMUValue""));
			 }
		 }
		 else if (ie.getSource() == m_chMenPerSquad) {
			 if (stateMenPerSquad != Integer.parseInt(m_chMenPerSquad .getSelectedItem())) {
				 stateMenPerSquad = Integer.parseInt(m_chMenPerSquad .getSelectedItem());
			 }
		 }
		 else if (ie.getSource() == m_chTechBase) {
			 if (stateTechBase != m_chTechBase.getSelectedIndex()) {
				 stateTechBase = m_chTechBase.getSelectedIndex();
				 updateEquipmentChoices();
			 }
		 }
		 else if (ie.getSource() == m_chChassisType) {
			 if (stateChassisType != m_chChassisType.getSelectedIndex()) {
				 stateChassisType = m_chChassisType.getSelectedIndex();
				 if (stateChassisType == BattleArmor.CHASSIS_TYPE_QUAD) {
					 leftArmEquipment = null;
					 rightArmEquipment = null;
				 }
				 updateGroundMPChoices();
				 updateJumpMPChoices();
				 updateEquipmentChoices();
			 }
		 }
		 else if (ie.getSource() == m_chWeightClass) {
			 if (stateWeightClass != m_chWeightClass.getSelectedIndex()) {
				 stateWeightClass = m_chWeightClass.getSelectedIndex();
				 switch (stateWeightClass) {
					 case WEIGHT_CLASS_PAL: stateMinWeight = 0;
					 stateMaxWeight = 400;
					 break;
					 case WEIGHT_CLASS_LIGHT: stateMinWeight = 401;
					 stateMaxWeight = 750;
					 break;
					 case WEIGHT_CLASS_MEDIUM: stateMinWeight = 751;
					 stateMaxWeight = 1000;
					 break;
					 case WEIGHT_CLASS_HEAVY: stateMinWeight = 1001;
					 stateMaxWeight = 1500;
					 break;
					 case WEIGHT_CLASS_ASSAULT: stateMinWeight = 1501;
					 stateMaxWeight = 2000;
					 break;
				 }
				 updateGroundMPChoices();
				 updateJumpMPChoices();
				 updateArmorValueChoices();
			 }
		 }
		 else if (ie.getSource() == m_chGroundMP) {
			 if (stateGroundMP != Integer.parseInt(m_chGroundMP .getSelectedItem())) {
				 stateGroundMP = Integer .parseInt(m_chGroundMP.getSelectedItem());
			 }
		 }
		 else if (ie.getSource() == m_chJumpValue) {
			 if (stateJumpMP != m_chJumpValue.getSelectedIndex()) {
				 stateJumpMP = m_chJumpValue.getSelectedIndex();
			 }
		 }
		 else if (ie.getSource() == m_chLeftManipulator) {
			 if (stateManipulatorTypeLeft != m_chLeftManipulator .getSelectedIndex()) {
				 stateManipulatorTypeLeft = m_chLeftManipulator .getSelectedIndex();
			 }
		 }
		 else if (ie.getSource() == m_chRightManipulator) {
			 if (stateManipulatorTypeRight != m_chRightManipulator .getSelectedIndex()) {
				 stateManipulatorTypeRight = m_chRightManipulator .getSelectedIndex();
			 }
		 }
		 else if (ie.getSource() == m_chArmorType) {
			 if (stateArmorType != m_chArmorType.getSelectedIndex()) {
				 stateArmorType = m_chArmorType.getSelectedIndex();
			 }
		 }
		 else if (ie.getSource() == m_chArmorValue) {
			 if (stateArmorValue != m_chArmorValue.getSelectedIndex()) {
				 stateArmorValue = m_chArmorValue.getSelectedIndex();
			 }
		 }
		 previewBA();
	 }
	 void clearBAPreview() {
		 m_BAView.setEditable(false);
		 m_BAView.setText("""");
	 }
	 void previewBA() {
		 String preview = generateBattleArmorPreview();
		 m_BAView.setEditable(false);
		 m_BAView.setText(preview);
	 }
	 public void keyPressed(java.awt.event.KeyEvent ke) {
		 if (ke.getKeyCode() == KeyEvent.VK_ENTER) {
			 ActionEvent event = new ActionEvent(m_bPick, ActionEvent.ACTION_PERFORMED, """");
			 actionPerformed(event);
		 }
	 }
	 public void keyReleased(java.awt.event.KeyEvent ke) {
	 }
	 public void keyTyped(java.awt.event.KeyEvent ke) {
	 }
	 public void windowActivated(java.awt.event.WindowEvent windowEvent) {
	 }
	 public void windowClosed(java.awt.event.WindowEvent windowEvent) {
	 }
	 public void windowClosing(java.awt.event.WindowEvent windowEvent) {
		 setVisible(false);
	 }
	 public void windowDeactivated(java.awt.event.WindowEvent windowEvent) {
	 }
	 public void windowDeiconified(java.awt.event.WindowEvent windowEvent) {
	 }
	 public void windowIconified(java.awt.event.WindowEvent windowEvent) {
	 }
	 public void windowOpened(java.awt.event.WindowEvent windowEvent) {
	 }
	 private void updateWidgetEnablements() {
		 m_bPick.setEnabled(true);
		 m_bPickClose.setEnabled(true);
	 }
	 public String generateBattleArmorPreview() {
		 StringBuffer retVal = new StringBuffer("""");
		 if (isOK()) {
			 retVal.append("">>>"");
			 retVal.append(Messages.getString(""CustomBattleArmorDialog.valid""));
			 retVal.append(""<<<"");
		 }
		 else {
			 retVal.append("">>>"");
			 retVal .append(Messages .getString(""CustomBattleArmorDialog.invalid""));
			 retVal.append(""<<<\n"");
			 if (invalidReason != null) {
				 retVal.append(invalidReason);
			 }
		 }
		 retVal.append(""\n\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelBAName""));
		 if (m_tfBAName.getText().trim().length() < 1) {
			 retVal.append(""<NONE>"");
		 }
		 else {
			 retVal.append(m_tfBAName.getText());
		 }
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelMenPerSquad""));
		 retVal.append(stateMenPerSquad);
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelTechBase""));
		 if (stateTechBase == TECH_BASE_IS) {
			 retVal .append(Messages .getString(""CustomBattleArmorDialog.tech_base_inner_sphere""));
		 }
		 else {
			 retVal.append(Messages .getString(""CustomBattleArmorDialog.tech_base_clan""));
		 }
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelChassisType""));
		 if (stateChassisType == BattleArmor.CHASSIS_TYPE_BIPED) {
			 retVal.append(Messages .getString(""CustomBattleArmorDialog.chassis_type_biped""));
		 }
		 else {
			 retVal.append(Messages .getString(""CustomBattleArmorDialog.chassis_type_quad""));
		 }
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelWeightClass""));
		 switch (stateWeightClass) {
			 case WEIGHT_CLASS_PAL: retVal.append(Messages .getString(""CustomBattleArmorDialog.weight_class_pal""));
			 break;
			 case WEIGHT_CLASS_LIGHT: retVal .append(Messages .getString(""CustomBattleArmorDialog.weight_class_light""));
			 break;
			 case WEIGHT_CLASS_MEDIUM: retVal .append(Messages .getString(""CustomBattleArmorDialog.weight_class_medium""));
			 break;
			 case WEIGHT_CLASS_HEAVY: retVal .append(Messages .getString(""CustomBattleArmorDialog.weight_class_heavy""));
			 break;
			 case WEIGHT_CLASS_ASSAULT: retVal .append(Messages .getString(""CustomBattleArmorDialog.weight_class_assault""));
			 break;
		 }
		 retVal.append("" ("");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.weight""));
		 retVal.append(getChassisWeight());
		 retVal.append("")"");
		 retVal.append(""\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.min_weight""));
		 retVal.append(stateMinWeight);
		 retVal.append(""\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.max_weight""));
		 retVal.append(stateMaxWeight);
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.current_weight""));
		 retVal.append(stateCurrentWeight);
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelGroundMP""));
		 retVal.append(stateGroundMP);
		 retVal.append("" ("");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.weight""));
		 retVal.append(getGroundMPWeight());
		 retVal.append("")"");
		 retVal.append(""\n"");
		 if (stateJumpType == JUMP_TYPE_JUMP) {
			 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelJumpValue""));
		 }
		 else if (stateJumpType == JUMP_TYPE_VTOL) {
			 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelVTOLValue""));
		 }
		 else if (stateJumpType == JUMP_TYPE_UMU) {
			 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelUMUValue""));
		 }
		 retVal.append(getTotalJumpMP());
		 retVal.append("" ("");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.weight""));
		 retVal.append(getJumpMPWeight());
		 retVal.append("")"");
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelArmorType""));
		 retVal.append(ARMOR_TYPE_STRINGS[stateArmorType]);
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelArmorValue""));
		 retVal.append(stateArmorValue);
		 retVal.append("" ("");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.weight""));
		 retVal.append(getArmorWeight());
		 retVal.append("")"");
		 retVal.append(""\n\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.equipment""));
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelLeftManipulator""));
		 retVal .append(BattleArmor.MANIPULATOR_TYPE_STRINGS[stateManipulatorTypeLeft]);
		 retVal.append("" ("");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.weight""));
		 retVal.append(MANIPULATOR_TYPE_WEIGHT[stateManipulatorTypeLeft]);
		 retVal.append("")"");
		 retVal.append(""\n"");
		 retVal.append(Messages .getString(""CustomBattleArmorDialog.m_labelRightManipulator""));
		 retVal .append(BattleArmor.MANIPULATOR_TYPE_STRINGS[stateManipulatorTypeRight]);
		 retVal.append("" ("");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.weight""));
		 retVal.append(MANIPULATOR_TYPE_WEIGHT[stateManipulatorTypeRight]);
		 retVal.append("")"");
		 retVal.append(""\n\n"");
		 if (torsoEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment.elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 retVal.append(tmpBAE.getDescription());
				 retVal.append(""\n"");
			 }
		 }
		 if (rightArmEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = rightArmEquipment .elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 retVal.append(tmpBAE.getDescription());
				 retVal.append(""\n"");
			 }
		 }
		 if (leftArmEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = leftArmEquipment .elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 retVal.append(tmpBAE.getDescription());
				 retVal.append(""\n"");
			 }
		 }
		 retVal.append(""\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.bvEach""));
		 retVal.append(calcSuitBV());
		 retVal.append(""\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.bvSquad""));
		 retVal.append(calcSquadBV());
		 retVal.append(""\n\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.costEach""));
		 retVal.append(calcSuitCost());
		 retVal.append(""\n"");
		 retVal.append(Messages.getString(""CustomBattleArmorDialog.costSquad""));
		 retVal.append(calcSquadCost());
		 retVal.append(""\n"");
		 return retVal.toString();
	 }
	 public void calcCurrentWeight() {
		 stateCurrentWeight = 0;
		 stateCurrentWeight += getChassisWeight();
		 stateCurrentWeight += getArmorWeight();
		 stateCurrentWeight += getGroundMPWeight();
		 stateCurrentWeight += getJumpMPWeight();
		 stateCurrentWeight += getManipulatorWeight();
		 if (leftArmEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = leftArmEquipment .elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 stateCurrentWeight += tmpBAE.weight;
			 }
		 }
		 if (rightArmEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = rightArmEquipment .elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 stateCurrentWeight += tmpBAE.weight;
			 }
		 }
		 if (torsoEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment.elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 stateCurrentWeight += tmpBAE.weight;
			 }
		 }
	 }
	 public boolean isOK() {
		 calcCurrentWeight();
		 if ((stateChassisType == BattleArmor.CHASSIS_TYPE_QUAD) && (stateWeightClass == WEIGHT_CLASS_PAL)) {
			 invalidReason = ""PA(L) suits cannot have a quad chassis."";
			 return false;
		 }
		 if (stateCurrentWeight > stateMaxWeight) {
			 invalidReason = ""Suit overweight."";
			 return false;
		 }
		 if (ARMOR_TYPE_WEIGHT[stateTechBase][stateArmorType] == 0) {
			 invalidReason = ARMOR_TYPE_STRINGS[stateArmorType] + "" Armor not legal for chosen tech base."";
			 return false;
		 }
		 if (((stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_CARGO_LIFTER) && (stateManipulatorTypeRight != BattleArmor.MANIPULATOR_CARGO_LIFTER)) || ((stateManipulatorTypeRight == BattleArmor.MANIPULATOR_CARGO_LIFTER) && (stateManipulatorTypeLeft != BattleArmor.MANIPULATOR_CARGO_LIFTER))) {
			 invalidReason = ""Cargo lifter manipulators must be mounted in pairs."";
			 return false;
		 }
		 if (((stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_BATTLE_MAGNET) && (stateManipulatorTypeRight != BattleArmor.MANIPULATOR_BATTLE_MAGNET)) || ((stateManipulatorTypeRight == BattleArmor.MANIPULATOR_BATTLE_MAGNET) && (stateManipulatorTypeLeft != BattleArmor.MANIPULATOR_BATTLE_MAGNET))) {
			 invalidReason = ""Magnetic manipulators must be mounted in pairs."";
			 return false;
		 }
		 if (((stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE) && (stateManipulatorTypeRight != BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE)) || ((stateManipulatorTypeRight == BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE) && (stateManipulatorTypeLeft != BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE))) {
			 invalidReason = ""Mine clearance manipulators must be mounted in pairs."";
			 return false;
		 }
		 if (stateChassisType == BattleArmor.CHASSIS_TYPE_QUAD) {
			 if (torsoEquipment != null) {
				 int totalSlots = 0;
				 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 totalSlots += tmpBAE.slots;
				 }
				 if (totalSlots > (QUAD_MAX_SLOTS[stateWeightClass] - ARMOR_TYPE_SLOTS[stateArmorType])) {
					 invalidReason = ""Unit is using more slots than are available."";
					 return false;
				 }
			 }
		 }
		 else {
			 int totalFreeSlots = (2 * ARM_MAX_SLOTS[stateWeightClass]) + TORSO_MAX_SLOTS[stateWeightClass];
			 if (leftArmEquipment != null) {
				 int totalSlots = 0;
				 Enumeration<BattleArmorEquipment> tmpE = leftArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 totalSlots += tmpBAE.slots;
				 }
				 if (totalSlots > ARM_MAX_SLOTS[stateWeightClass]) {
					 invalidReason = ""Left Arm is using more slots than are available."";
					 return false;
				 }
				 totalFreeSlots -= totalSlots;
			 }
			 if (rightArmEquipment != null) {
				 int totalSlots = 0;
				 Enumeration<BattleArmorEquipment> tmpE = rightArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 totalSlots += tmpBAE.slots;
				 }
				 if (totalSlots > ARM_MAX_SLOTS[stateWeightClass]) {
					 invalidReason = ""Right Arm is using more slots than are available."";
					 return false;
				 }
				 totalFreeSlots -= totalSlots;
			 }
			 if (torsoEquipment != null) {
				 int totalSlots = 0;
				 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 totalSlots += tmpBAE.slots;
				 }
				 if (totalSlots > TORSO_MAX_SLOTS[stateWeightClass]) {
					 invalidReason = ""Torso is using more slots than are available."";
					 return false;
				 }
				 totalFreeSlots -= totalSlots;
			 }
			 if (totalFreeSlots < ARMOR_TYPE_SLOTS[stateArmorType]) {
				 invalidReason = ""Unit is using more total slots than are available."";
				 return false;
			 }
		 }
		 if (stateChassisType == BattleArmor.CHASSIS_TYPE_QUAD) {
			 if (torsoEquipment != null) {
				 int totalWeapons = 0;
				 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if ((tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) || (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON_AP)) {
						 totalWeapons++;
					 }
				 }
				 if (totalWeapons > 4) {
					 invalidReason = ""Unit has more weapons than it is allowed (limit of 4)."";
					 return false;
				 }
			 }
		 }
		 else {
			 if (torsoEquipment != null) {
				 int totalAPWeapons = 0;
				 int totalAMWeapons = 0;
				 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) {
						 totalAMWeapons++;
					 }
					 else if (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON_AP) {
						 totalAPWeapons++;
					 }
				 }
				 if (totalAMWeapons > 2) {
					 invalidReason = ""Unit has more anti-'Mech weapons than it is allowed in its torso (limit of 2)."";
					 return false;
				 }
				 if (totalAPWeapons > 2) {
					 invalidReason = ""Unit has more anti-personnel weapons than it is allowed in its torso (limit of 2)."";
					 return false;
				 }
			 }
			 if (rightArmEquipment != null) {
				 int totalWeapons = 0;
				 int totalAMWeapons = 0;
				 Enumeration<BattleArmorEquipment> tmpE = rightArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) {
						 totalWeapons++;
						 totalAMWeapons++;
					 }
					 else if (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON_AP) {
						 totalWeapons++;
					 }
				 }
				 if (totalAMWeapons > 1) {
					 invalidReason = ""Unit has more anti-'Mech weapons than it is allowed in its right arm (limit of 1)."";
					 return false;
				 }
				 else if (totalWeapons > 2) {
					 invalidReason = ""Unit has more weapons than it is allowed in its right arm (limit of 2)."";
					 return false;
				 }
			 }
			 if (leftArmEquipment != null) {
				 int totalWeapons = 0;
				 int totalAMWeapons = 0;
				 Enumeration<BattleArmorEquipment> tmpE = leftArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) {
						 totalWeapons++;
						 totalAMWeapons++;
					 }
					 else if (tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON_AP) {
						 totalWeapons++;
					 }
				 }
				 if (totalAMWeapons > 1) {
					 invalidReason = ""Unit has more anti-'Mech weapons than it is allowed in its left arm (limit of 1)."";
					 return false;
				 }
				 else if (totalWeapons > 2) {
					 invalidReason = ""Unit has more weapons than it is allowed in its left arm (limit of 2)."";
					 return false;
				 }
			 }
		 }
		 return true;
	 }
	 public int getChassisWeight() {
		 return getChassisWeight(stateWeightClass, stateTechBase);
	 }
	 public static int getChassisWeight(int weightClass, int techBase) {
		 if (techBase == TECH_BASE_IS) {
			 switch (weightClass) {
				 case WEIGHT_CLASS_PAL: return 80;
				 case WEIGHT_CLASS_LIGHT: return 100;
				 case WEIGHT_CLASS_MEDIUM: return 175;
				 case WEIGHT_CLASS_HEAVY: return 300;
				 case WEIGHT_CLASS_ASSAULT: return 550;
			 }
		 }
		 else {
			 switch (weightClass) {
				 case WEIGHT_CLASS_PAL: return 130;
				 case WEIGHT_CLASS_LIGHT: return 150;
				 case WEIGHT_CLASS_MEDIUM: return 250;
				 case WEIGHT_CLASS_HEAVY: return 400;
				 case WEIGHT_CLASS_ASSAULT: return 700;
			 }
		 }
		 return 0;
	 }
	 public int getArmorWeight() {
		 return getArmorWeight(stateTechBase, stateArmorType, stateArmorValue);
	 }
	 public static int getArmorWeight(int techBase, int armorType, int armorValue) {
		 return armorValue * ARMOR_TYPE_WEIGHT[techBase][armorType];
	 }
	 public int getGroundMPWeight() {
		 return getGroundMPWeight(stateChassisType, stateWeightClass, stateGroundMP);
	 }
	 public static int getGroundMPWeight(int chassisType, int weightClass, int groundMP) {
	 return (groundMP - (chassisType == BattleArmor.CHASSIS_TYPE_BIPED ? 1 : 2)) }
	 public int getJumpMPWeight() {
		 return getJumpMPWeight(stateJumpType, stateWeightClass, stateJumpMP);
	 }
	 public static int getJumpMPWeight(int jumpStatus, int weightClass, int jumpMP) {
		 return jumpMP * JUMP_MP_WEIGHT[jumpStatus][weightClass];
	 }
	 public int getManipulatorWeight() {
		 return MANIPULATOR_TYPE_WEIGHT[stateManipulatorTypeLeft] + MANIPULATOR_TYPE_WEIGHT[stateManipulatorTypeRight];
	 }
	 public int calcSuitBV() {
		 float dBV = 1.5f;
		 dBV += (stateArmorValue * (stateArmorType == 7 ? 3 : 2));
		 int groundMod = 0;
		 if (stateGroundMP >= 5) {
			 groundMod = 2;
		 }
		 else if (stateGroundMP >= 3) {
			 groundMod = 1;
		 }
		 int jumpMod = 0;
		 if (getTotalJumpMP() >= 7) {
			 jumpMod = 3;
		 }
		 else if (getTotalJumpMP() >= 5) {
			 jumpMod = 2;
		 }
		 else if (getTotalJumpMP() >= 3) {
			 jumpMod = 1;
		 }
		 if (stateJumpType != JUMP_TYPE_UMU) {
			 jumpMod += 1;
		 }
		 float bestMod = (groundMod > jumpMod ? groundMod : jumpMod);
		 if ((stateArmorType == 8) || (stateArmorType == 6)) {
			 bestMod += 3;
		 }
		 else if ((stateArmorType == 5) || (stateArmorType == 4) || (stateArmorType == 3)) {
			 bestMod += 2;
		 }
		 bestMod /= 10;
		 bestMod += 1;
		 dBV *= bestMod;
		 float oBV = 0;
		 if (canDoAntiMech()) {
		 }
		 int speedFactor = Math.max(stateGroundMP, getTotalJumpMP());
		 float speedFactorMult = 0;
		 switch (speedFactor) {
			 case 1: speedFactorMult = 0.54f;
			 break;
			 case 2: speedFactorMult = 0.65f;
			 break;
			 case 3: speedFactorMult = 0.77f;
			 break;
			 case 4: speedFactorMult = 0.88f;
			 break;
			 case 5: speedFactorMult = 1f;
			 break;
			 case 6: speedFactorMult = 1.12f;
			 break;
			 case 7: speedFactorMult = 1.24f;
			 break;
			 case 8: speedFactorMult = 1.37f;
			 break;
			 case 9: speedFactorMult = 1.5f;
			 break;
			 case 10: speedFactorMult = 1.63f;
			 break;
			 case 11: speedFactorMult = 1.76f;
			 break;
			 case 12: speedFactorMult = 1.89f;
			 break;
		 }
		 oBV *= speedFactorMult;
		 int retVal = Math.round(dBV + oBV);
		 return retVal;
	 }
	 public int calcSquadBV() {
		 return calcSuitBV() * stateMenPerSquad;
	 }
	 public int calcSuitCost() {
		 float retVal = 0;
		 switch (stateWeightClass) {
			 case WEIGHT_CLASS_PAL: case WEIGHT_CLASS_LIGHT: retVal += 50000;
			 break;
			 case WEIGHT_CLASS_MEDIUM: retVal += 100000;
			 break;
			 case WEIGHT_CLASS_HEAVY: retVal += 200000;
			 break;
			 case WEIGHT_CLASS_ASSAULT: retVal += 400000;
			 break;
		 }
		 retVal += (stateGroundMP - (stateChassisType == BattleArmor.CHASSIS_TYPE_BIPED ? 1 : 2)) * 25000;
		 retVal += stateJumpMP * JUMP_MP_COST[stateJumpType][stateWeightClass];
		 retVal += (ARMOR_TYPE_COSTS[stateArmorType] * stateArmorValue);
		 retVal += MANIPULATOR_TYPE_COSTS[stateManipulatorTypeLeft];
		 retVal += MANIPULATOR_TYPE_COSTS[stateManipulatorTypeRight];
		 if (stateTechBase == TECH_BASE_CLAN) {
			 retVal *= 1.1;
		 }
		 if (stateTechBase == TECH_BASE_IS) {
			 retVal += 150000;
		 }
		 else {
			 retVal += 200000;
		 }
		 return Math.round(retVal);
	 }
	 public int calcSquadCost() {
		 return calcSuitCost() * stateMenPerSquad;
	 }
	 public BattleArmor getEntity() {
		 BattleArmor retVal = new BattleArmor();
		 retVal.setChassis(m_tfBAName.getText().trim());
		 retVal.setModel("""");
		 retVal.setWeightClass(stateWeightClass);
		 retVal.setChassisType(stateChassisType);
		 retVal.setTroopers(stateMenPerSquad);
		 retVal.refreshLocations();
		 retVal.autoSetInternal();
		 retVal.setArmorType(stateArmorType);
		 for (int x = 1;
		 x < retVal.locations();
		 x++) {
			 retVal.initializeArmor(stateArmorValue, x);
		 }
		 if (stateTechBase == TECH_BASE_IS) {
			 retVal.setTechLevel(TechConstants.T_IS_TW_NON_BOX);
		 }
		 else {
			 retVal.setTechLevel(TechConstants.T_CLAN_TW);
		 }
		 retVal.setOriginalWalkMP(stateGroundMP);
		 retVal.setOriginalJumpMP(getTotalJumpMP());
		 if (stateJumpType == JUMP_TYPE_VTOL) {
			 retVal.setMovementMode(EntityMovementMode.VTOL);
		 }
		 else if (stateJumpType == JUMP_TYPE_UMU) {
			 retVal.setMovementMode(EntityMovementMode.INF_UMU);
			 retVal.setOriginalWalkMP(getTotalJumpMP());
			 retVal.setOriginalJumpMP(0);
		 }
		 else if (getTotalJumpMP() > 0) {
			 retVal.setMovementMode(EntityMovementMode.INF_JUMP);
		 }
		 else {
			 retVal.setMovementMode(EntityMovementMode.INF_LEG);
		 }
		 retVal.setCost(calcSquadCost());
		 try {
			 if (stateArmorType == 7) {
				 retVal.addEquipment(EquipmentType .get(""BA-Fire Resistant Armor""), BattleArmor.LOC_SQUAD);
			 }
			 if (canDoAntiMech()) {
				 retVal.addEquipment(EquipmentType.get(Infantry.LEG_ATTACK), BattleArmor.LOC_SQUAD);
				 retVal.addEquipment(EquipmentType.get(Infantry.SWARM_MEK), BattleArmor.LOC_SQUAD);
				 retVal.addEquipment(EquipmentType.get(Infantry.STOP_SWARM), BattleArmor.LOC_SQUAD);
				 if (stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_BATTLE_MAGNET) {
					 retVal.addEquipment(EquipmentType .get(""BABattleClawMagnets""), BattleArmor.LOC_SQUAD);
				 }
			 }
			 if (((stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_BATTLE_VIBRO) || (stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_HEAVY_BATTLE_VIBRO)) && ((stateManipulatorTypeRight == BattleArmor.MANIPULATOR_BATTLE_VIBRO) || (stateManipulatorTypeRight == BattleArmor.MANIPULATOR_HEAVY_BATTLE_VIBRO))) {
				 retVal.addEquipment(EquipmentType.get(""BA-Vibro Claws (2)""), BattleArmor.LOC_SQUAD);
			 }
			 else if (((stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_BATTLE_VIBRO) || (stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_HEAVY_BATTLE_VIBRO)) || ((stateManipulatorTypeRight == BattleArmor.MANIPULATOR_BATTLE_VIBRO) || (stateManipulatorTypeRight == BattleArmor.MANIPULATOR_HEAVY_BATTLE_VIBRO))) {
				 retVal.addEquipment(EquipmentType.get(""BA-Vibro Claws (1)""), BattleArmor.LOC_SQUAD);
			 }
			 if (leftArmEquipment != null) {
				 Enumeration<BattleArmorEquipment> tmpE = leftArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if ((tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) || (tmpBAE.internalType == EQUIPMENT_TYPE_AMMO)) {
						 retVal.addEquipment(EquipmentType .get(tmpBAE.weaponTypeName), BattleArmor.LOC_SQUAD);
					 }
					 else if (tmpBAE.internalType == EQUIPMENT_TYPE_OTHER) {
					 }
				 }
			 }
			 if (rightArmEquipment != null) {
				 Enumeration<BattleArmorEquipment> tmpE = rightArmEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if ((tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) || (tmpBAE.internalType == EQUIPMENT_TYPE_AMMO)) {
						 retVal.addEquipment(EquipmentType .get(tmpBAE.weaponTypeName), BattleArmor.LOC_SQUAD);
					 }
					 else if (tmpBAE.internalType == EQUIPMENT_TYPE_OTHER) {
					 }
				 }
			 }
			 if (torsoEquipment != null) {
				 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment .elements();
				 while (tmpE.hasMoreElements()) {
					 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
					 if ((tmpBAE.internalType == EQUIPMENT_TYPE_WEAPON) || (tmpBAE.internalType == EQUIPMENT_TYPE_AMMO)) {
						 retVal.addEquipment(EquipmentType .get(tmpBAE.weaponTypeName), BattleArmor.LOC_SQUAD);
					 }
					 else if (tmpBAE.internalType == EQUIPMENT_TYPE_OTHER) {
					 }
				 }
			 }
		 }
		 catch (LocationFullException e) {
			 System.err.println(e);
			 e.printStackTrace();
		 }
		 return retVal;
	 }
	 public int getTotalJumpMP() {
		 int retVal = stateJumpMP;
		 if (torsoEquipment != null) {
			 Enumeration<BattleArmorEquipment> tmpE = torsoEquipment.elements();
			 while (tmpE.hasMoreElements()) {
				 BattleArmorEquipment tmpBAE = (tmpE.nextElement());
				 if (tmpBAE.hasConflictFlag(F_CONFLICT_JUMP_GEAR)) {
					 retVal++;
				 }
			 }
		 }
		 return retVal;
	 }
	 public boolean canDoAntiMech() {
		 if (stateChassisType == BattleArmor.CHASSIS_TYPE_QUAD) {
			 return false;
		 }
		 if (stateWeightClass >= WEIGHT_CLASS_HEAVY) {
			 return false;
		 }
		 if ((stateJumpType == JUMP_TYPE_UMU) && (stateJumpMP > 0)) {
			 return false;
		 }
		 if (((stateManipulatorTypeLeft >= BattleArmor.MANIPULATOR_BATTLE) && (stateManipulatorTypeLeft <= BattleArmor.MANIPULATOR_HEAVY_BATTLE_VIBRO)) || ((stateManipulatorTypeRight >= BattleArmor.MANIPULATOR_BATTLE) && (stateManipulatorTypeRight <= BattleArmor.MANIPULATOR_HEAVY_BATTLE_VIBRO))) {
			 return true;
		 }
		 if (((stateManipulatorTypeLeft >= BattleArmor.MANIPULATOR_BASIC) && (stateManipulatorTypeLeft <= BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE)) && ((stateManipulatorTypeRight >= BattleArmor.MANIPULATOR_BASIC) && (stateManipulatorTypeRight <= BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE))) {
			 return true;
		 }
		 if ((stateWeightClass <= WEIGHT_CLASS_LIGHT) && (stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_ARMORED_GLOVE) && (stateManipulatorTypeRight == BattleArmor.MANIPULATOR_ARMORED_GLOVE)) {
			 return true;
		 }
		 return false;
	 }
	 public boolean canMountMech() {
		 if (canDoAntiMech()) {
			 return true;
		 }
		 if (stateWeightClass == WEIGHT_CLASS_HEAVY) {
			 if (((stateManipulatorTypeLeft >= BattleArmor.MANIPULATOR_BASIC) && (stateManipulatorTypeLeft <= BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE)) && ((stateManipulatorTypeRight >= BattleArmor.MANIPULATOR_BASIC) && (stateManipulatorTypeRight <= BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE))) {
				 return true;
			 }
			 if ((stateWeightClass <= WEIGHT_CLASS_LIGHT) && (stateManipulatorTypeLeft == BattleArmor.MANIPULATOR_ARMORED_GLOVE) && (stateManipulatorTypeRight == BattleArmor.MANIPULATOR_ARMORED_GLOVE)) {
				 return true;
			 }
		 }
		 return false;
	 }
	 protected class BattleArmorEquipment implements Comparable<BattleArmorEquipment> {
		 String name;
		 String weaponTypeName;
		 int weight = 0;
		 int cost = 0;
		 double bv = 0;
		 int internalType = -1;
		 int slots = 0;
		 int techBase = -1;
		 int conflictFlag = 0;
		 int allowedLocation = 0;
		 BattleArmorEquipment() {
		 }
		 BattleArmorEquipment(String inN, String inWTN, int inW, int inC, double inBV, int inIT, int inS, int inTB, int inAL) {
			 this(inN, inWTN, inW, inC, inBV, inIT, inS, inTB, inAL, 0);
		 }
		 BattleArmorEquipment(String inN, String inWTN, int inW, int inC, double inBV, int inIT, int inS, int inTB, int inAL, int inCF) {
			 name = inN;
			 weaponTypeName = inWTN;
			 weight = inW;
			 cost = inC;
			 bv = inBV;
			 internalType = inIT;
			 slots = inS;
			 techBase = inTB;
			 allowedLocation = inAL;
			 conflictFlag = inCF;
			 CustomBattleArmorDialog.equipmentTypes.add(this);
			 CustomBattleArmorDialog.equipmentNames.add(name);
		 }
		 void initialize() {
			 CustomBattleArmorDialog.equipmentTypes = new ArrayList<BattleArmorEquipment>();
			 CustomBattleArmorDialog.equipmentNames = new ArrayList<String>();
			 new BattleArmorEquipment(""IS Support Machine Gun"", ""IS BA Machine Gun"", 100, 5000, 5, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Light Recoilless Rifle"", ""ISLight Recoilless Rifle"", 175, 1000, 12, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Medium Recoilless Rifle"", ""ISMedium Recoilless Rifle"", 250, 3000, 19, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Heavy Recoilless Rifle"", ""ISHeavy Recoilless Rifle"", 325, 5000, 22, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Heavy Flamer"", ""ISFlamer"", 150, 7500, 6, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Support Machine Gun"", ""CL BA Machine Gun"", 100, 5000, 5, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Light Recoilless Rifle"", ""CLLight Recoilless Rifle"", 175, 1000, 12, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Medium Recoilless Rifle"", ""CLMedium Recoilless Rifle"", 250, 3000, 19, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Heavy Recoilless Rifle"", ""CLHeavy Recoilless Rifle"", 325, 5000, 22, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Heavy Flamer"", ""CLFlamer"", 150, 7500, 6, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Semi-Portable Support Pulse Laser"", ""CLMicroPulseLaser"", 160, 12500, 12, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Support Laser"", ""ISSmall Laser"", 200, 11250, 9, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Support Laser"", ""CLSmall Laser"", 200, 11250, 9, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL ER Support Laser"", ""CLERSmallLaser"", 250, 11250, 31, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Bearhunter Superheavy AC"", ""CLBearhunter Superheavy AC"", 150, 11250, 4, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS David Light Gauss Rifle"", ""ISDavidLightGaussRifle"", 100, 22500, 7, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS King David Light Gauss Rifle"", ""ISKingDavidLightGaussRifle"", 275, 30000, 7, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Firedrake Support Needler"", ""ISFiredrakeIncendiaryNeedler"", 50, 1500, 2, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Man-Portable Plasma Rifle"", ""ISBAPlasma Rifle"", 300, 28000, 12, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Magshot Gauss Rifle"", ""ISBAMagshotGR"", 175, 8500, 15, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Grand Mauler Gauss Cannonr"", ""ISGrandMauler"", 125, 5500, 6, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Tsunami Heavy Gauss Rifle"", ""BA-ISTsunamiHeavyGaussRifle"", 125, 5000, 6, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Semi-Portable Autocannon"", ""ISBAHeavyMG"", 150, 7500, 6, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""IS Semi-Portable Machine Gun"", ""ISBALightMG"", 75, 5000, 5, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Semi-Portable Autocannon"", ""CLBAHeavyMG"", 150, 7500, 6, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""CL Semi-Portable Machine Gun"", ""CLBALightMG"", 75, 5000, 5, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Ultra Heavy Support Laser"", ""BACLHeavyMediumLaser"", 1000, 0, 0, EQUIPMENT_TYPE_WEAPON, 4, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Bomb Rack"", ""BAMicroBomb"", 100, 0, 0, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""ER Semi-Portable Support Laser"", ""BACLERMicroLaser"", 150, 0, 0, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Medium Pulse Laser"", ""BAISMediumPulseLaser"", 800, 0, 0, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Grenade Launcher"", ""BAAutoGL"", 75, 0, 0, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Compact NARC"", ""BACompactNARC"", 150, 0, 0, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Medium Laser"", ""BAISMediumLaser"", 500, 0, 0, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Popup Mine"", ""BAMineLauncher"", 200, 0, 0, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Medium Pulse Laser"", ""BACLMediumPulseLaser"", 800, 0, 0, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Semi-Portable Heavy Laser"", ""BACLHeavySmallLaser"", 500, 0, 0, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""ER Support Laser"", ""BAISERSmallLaser"", 350, 0, 0, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Support Particle Cannon"", ""BASupportPPC"", 240, 0, 0, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Support Particle Cannon"", ""BASupportPPC"", 250, 0, 0, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""ER Heavy Support Laser"", ""BACLERMediumLaser"", 800, 0, 0, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Support Pulse Laser"", ""BACLSmallPulseLaser"", 400, 0, 0, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Heavy Mortar"", ""BAISHeavyMortar"", 400, 0, 0, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Light Mortar"", ""BSISLightMortar"", 300, 0, 0, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_IS, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Heavy Grenade Launcher"", ""BAMicroGrenade"", 100, 0, 0, EQUIPMENT_TYPE_WEAPON, 1, TECH_BASE_BOTH, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 1 Launcher"", ""Clan Advanced SRM-1"", 60, 15000, 15, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 2 Launcher"", ""Clan Advanced SRM-2"", 90, 30000, 30, EQUIPMENT_TYPE_WEAPON, 2, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 3 Launcher"", ""Clan Advanced SRM-3"", 120, 45000, 45, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 4 Launcher"", ""Clan Advanced SRM-4"", 150, 60000, 60, EQUIPMENT_TYPE_WEAPON, 3, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 5 Launcher"", ""Clan Advanced SRM-5"", 180, 75000, 75, EQUIPMENT_TYPE_WEAPON, 4, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 6 Launcher"", ""Clan Advanced SRM-6"", 210, 90000, 90, EQUIPMENT_TYPE_WEAPON, 4, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 1 Ammo"", ""BAAdvancedSRM1 Ammo"", 10, 500, 0.02, EQUIPMENT_TYPE_AMMO, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 2 Ammo"", ""BAAdvancedSRM2 Ammo"", 20, 1000, 0.08, EQUIPMENT_TYPE_AMMO, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 3 Ammo"", ""BAAdvancedSRM3 Ammo"", 30, 1500, 0.18, EQUIPMENT_TYPE_AMMO, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 4 Ammo"", ""BAAdvancedSRM4 Ammo"", 40, 2000, 0.32, EQUIPMENT_TYPE_AMMO, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 5 Ammo"", ""BAAdvancedSRM5 Ammo"", 50, 2500, 0.5, EQUIPMENT_TYPE_AMMO, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Advanced SRM 6 Ammo"", ""BAAdvancedSRM6 Ammo"", 60, 3000, 0.72, EQUIPMENT_TYPE_AMMO, 1, TECH_BASE_CLAN, LOCATION_ALLOWED_ANY);
			 new BattleArmorEquipment(""Jump Booster"", null, 125, 75000, 0, EQUIPMENT_TYPE_PREPROCESS, 2, TECH_BASE_BOTH, LOCATION_ALLOWED_TORSO, F_CONFLICT_JUMP_GEAR);
			 new BattleArmorEquipment(""Partial Wing"", null, 200, 50000, 0, EQUIPMENT_TYPE_PREPROCESS, 1, TECH_BASE_IS, LOCATION_ALLOWED_TORSO, F_CONFLICT_JUMP_GEAR);
		 }
		 public String getDescription() {
			 StringBuffer retVal = new StringBuffer("""");
			 retVal.append(name);
			 retVal.append("" ("");
			 retVal.append(weight);
			 retVal.append("" kg, "");
			 retVal.append(slots);
			 retVal.append("" slots)"");
			 return retVal.toString();
		 }
		 public int compareTo(BattleArmorEquipment o) {
			 return name.compareTo(o.name);
		 }
		 public boolean hasConflictFlag(int testFlags) {
			 return ((conflictFlag & testFlags) > 0);
		 }
	 }
}",1,0,0,0
"protected int resolveSimpleEntity(boolean checkStd) throws XMLStreamException {
	 char[] buf = mInputBuffer;
	 int ptr = mInputPtr;
	 char c = buf[ptr++];
	 if (c == '#') {
		 c = buf[ptr++];
		 int value = 0;
		 int inputLen = mInputEnd;
		 if (c == 'x') {
			 while (ptr < inputLen) {
				 c = buf[ptr++];
				 if (c == ';
				') {
					 break;
				 }
				 value = value << 4;
				 if (c <= '9' && c >= '0') {
					 value += (c - '0');
				 }
				 else if (c >= 'a' && c <= 'f') {
					 value += (10 + (c - 'a'));
				 }
				 else if (c >= 'A' && c <= 'F') {
					 value += (10 + (c - 'A'));
				 }
				 else {
					 mInputPtr = ptr;
					 throwUnexpectedChar(c, "";
					 expected a hex digit (0-9a-fA-F)."");
				 }
				 if (value > MAX_UNICODE_CHAR) {
					 reportUnicodeOverflow();
				 }
			 }
		 }
		 else {
			 while (c != ';
			') {
				 if (c <= '9' && c >= '0') {
					 value = (value * 10) + (c - '0');
					 if (value > MAX_UNICODE_CHAR) {
						 reportUnicodeOverflow();
					 }
				 }
				 else {
					 mInputPtr = ptr;
					 throwUnexpectedChar(c, "";
					 expected a decimal number."");
				 }
				 if (ptr >= inputLen) {
					 break;
				 }
				 c = buf[ptr++];
			 }
		 }
		 if (c == ';
		') {
			 mInputPtr = ptr;
			 validateChar(value);
			 return value;
		 }
	 }
	 else if (checkStd) {
		 if (c == 'a') {
			 c = buf[ptr++];
			 if (c == 'm') {
				 if (buf[ptr++] == 'p') {
					 if (ptr < mInputEnd && buf[ptr++] == ';
					') {
						 mInputPtr = ptr;
						 return '&';
					 }
				 }
			 }
			 else if (c == 'p') {
				 if (buf[ptr++] == 'o') {
					 int len = mInputEnd;
					 if (ptr < len && buf[ptr++] == 's') {
						 if (ptr < len && buf[ptr++] == ';
						') {
							 mInputPtr = ptr;
							 return '\'';
						 }
					 }
				 }
			 }
		 }
		 else if (c == 'g') {
			 if (buf[ptr++] == 't' && buf[ptr++] == ';
			') {
				 mInputPtr = ptr;
				 return '>';
			 }
		 }
		 else if (c == 'l') {
			 if (buf[ptr++] == 't' && buf[ptr++] == ';
			') {
				 mInputPtr = ptr;
				 return '<';
			 }
		 }
		 else if (c == 'q') {
			 if (buf[ptr++] == 'u' && buf[ptr++] == 'o') {
				 int len = mInputEnd;
				 if (ptr < len && buf[ptr++] == 't') {
					 if (ptr < len && buf[ptr++] == ';
					') {
						 mInputPtr = ptr;
						 return '""';
					 }
				 }
			 }
		 }
	 }
	 return 0;
 }",0,0,1,0
"public class Lease<T> {
	 private final T resource;
	 private final long creationTime;
	 private volatile long leaseTimeout;
	 private boolean expired;
	 private List<Callable<Void>> callbacks;
	 public Lease(T resource, long timeout) {
		 this.resource = resource;
		 this.leaseTimeout = timeout;
		 this.callbacks = Collections.synchronizedList(new ArrayList<>());
		 this.creationTime = Time.monotonicNow();
		 this.expired = false;
	 }
	 public boolean hasExpired() {
		 return expired;
	 }
	 public void registerCallBack(Callable<Void> callback) throws LeaseExpiredException {
		 if(hasExpired()) {
			 throw new LeaseExpiredException(""Resource: "" + resource);
		 }
		 callbacks.add(callback);
	 }
	 public long getElapsedTime() throws LeaseExpiredException {
		 if(hasExpired()) {
			 throw new LeaseExpiredException(""Resource: "" + resource);
		 }
		 return Time.monotonicNow() - creationTime;
	 }
	 public long getRemainingTime() throws LeaseExpiredException {
		 if(hasExpired()) {
			 throw new LeaseExpiredException(""Resource: "" + resource);
		 }
		 return leaseTimeout - getElapsedTime();
	 }
	 public long getLeaseLifeTime() throws LeaseExpiredException {
		 if(hasExpired()) {
			 throw new LeaseExpiredException(""Resource: "" + resource);
		 }
		 return leaseTimeout;
	 }
	 public void renew(long timeout) throws LeaseExpiredException {
		 if(hasExpired()) {
			 throw new LeaseExpiredException(""Resource: "" + resource);
		 }
		 leaseTimeout += timeout;
	 }
	 public int hashCode() {
		 return resource.hashCode();
	 }
	 public boolean equals(Object obj) {
		 if(obj instanceof Lease) {
			 return resource.equals(((Lease) obj).resource);
		 }
		 return false;
	 }
	 public String toString() {
		 return ""Lease<"" + resource.toString() + "">"";
	 }
	 List<Callable<Void>> getCallbacks() {
		 return callbacks;
	 }
	 void invalidate() {
		 callbacks = null;
		 expired = true;
	 }
}",0,0,0,0
"private ThreadGroup createDaemonGroup() {
	 try {
		 ThreadGroup group = new ThreadGroup(""derby.daemons"");
		 group.setDaemon(true);
		 return group;
	 }
	 catch (SecurityException se) {
		 reportThread(se);
		 return null;
	 }
 }",0,0,0,0
"public class BorderBodyResolver implements IComponentResolver{
	private static final Logger log = LoggerFactory.getLogger(BorderBodyResolver.class);
	private static final long serialVersionUID = 1L;
	public boolean resolve(final MarkupContainer container, final MarkupStream markupStream,final ComponentTag tag){
		if (tag instanceof WicketTag){
			WicketTag wtag = (WicketTag)tag;
			if (wtag.isBodyTag()){
				MarkupContainer parent = container.getParent();
				while (parent != null){
					if (parent instanceof Border.BorderBodyContainer){
						break;
					}
					else if (parent instanceof Border){
						Component component = parent.get(tag.getId());
						if (component != null){
							component.render(markupStream);
							log.warn(""Please consider to change your java code to "" +""something like: "" + container.getId() +"".add(getBodyContainer());
							 for the component hierarchy to "" +""better reflect the markup hierarchy. For example, say that "" +""you have a border class in which you do: "" +""\'WebMarkupContainer div = new "" +""WebMarkupContainer(\""roundDiv\"");
							 add(div);
							\' you should "" +""now do \'add(div);
							 div.add(getBodyContainer());
							\'. "" +""Please fix this before Wicket 1.4"");
						}
						return true;
					}
					parent = parent.getParent();
				}
			}
		}
		return false;
	}
}",0,0,0,0
"public String execute( WikiContext context, Map params ) throws PluginException {
	 int since = TextUtil.parseIntParameter( (String) params.get( ""since"" ), DEFAULT_DAYS );
	 int spacing = 4;
	 boolean showAuthor = true;
	 boolean showChangenote = true;
	 int tablewidth = 4;
	 WikiEngine engine = context.getEngine();
	 if( ""compact"".equals( params.get(PARAM_FORMAT) ) ) {
		 spacing = 0;
		 showAuthor = false;
		 showChangenote = false;
		 tablewidth = 2;
	 }
	 Calendar sincedate = new GregorianCalendar();
	 sincedate.add( Calendar.DAY_OF_MONTH, -since );
	 log.debug(""Calculating recent changes from ""+sincedate.getTime());
	 Collection changes = engine.getRecentChanges();
	 super.initialize( context, params );
	 changes = super.filterCollection( changes );
	 if( changes != null ) {
		 Date olddate = new Date(0);
		 DateFormat fmt = getDateFormat( context, params );
		 DateFormat tfmt = getTimeFormat( context, params );
		 table rt = new table();
		 rt.setCellPadding(spacing).setClass(""recentchanges"");
		 for( Iterator i = changes.iterator();
		 i.hasNext();
		 ) {
			 WikiPage pageref = (WikiPage) i.next();
			 Date lastmod = pageref.getLastModified();
			 if( lastmod.before( sincedate.getTime() ) ) {
				 break;
			 }
			 if( !isSameDay( lastmod, olddate ) ) {
				 tr row = new tr();
				 td col = new td();
				 col.setColSpan(tablewidth).setClass(""date"");
				 col.addElement( new b().addElement(fmt.format(lastmod)) );
				 rt.addElement(row);
				 row.addElement(col);
				 olddate = lastmod;
			 }
			 String link = context.getURL( pageref instanceof Attachment ? WikiContext.ATTACH : WikiContext.VIEW, pageref.getName() ) ;
			 a linkel = new a(link,engine.beautifyTitle(pageref.getName()));
			 tr row = new tr();
			 td col = new td().setWidth(""30%"").addElement(linkel);
			 if( pageref instanceof Attachment ) {
				 linkel = new a().setHref(context.getURL(WikiContext.INFO,pageref.getName()));
				 linkel.setClass(""infolink"");
				 linkel.addElement( new img().setSrc(context.getURL(WikiContext.NONE, ""images/attachment_small.png"")));
				 col.addElement( linkel );
			 }
			 row.addElement(col);
			 rt.addElement(row);
			 if( pageref instanceof Attachment ) {
				 row.addElement( new td(tfmt.format(lastmod)).setClass(""lastchange"") );
			 }
			 else {
				 td infocol = (td) new td().setClass(""lastchange"");
				 infocol.addElement( new a(context.getURL(WikiContext.DIFF, pageref.getName(), ""r1=-1""),tfmt.format(lastmod)) );
				 row.addElement(infocol);
			 }
			 if( showAuthor ) {
				 String author = pageref.getAuthor();
				 td authorinfo = new td();
				 authorinfo.setClass(""author"");
				 if( author != null ) {
					 if( engine.pageExists(author) ) {
						 authorinfo.addElement( new a(context.getURL(WikiContext.VIEW, author),author) );
					 }
					 else {
						 authorinfo.addElement(author);
					 }
				 }
				 else {
					 authorinfo.addElement( context.getBundle(InternationalizationManager.CORE_BUNDLE).getString( ""common.unknownauthor"" ) );
				 }
				 row.addElement( authorinfo );
			 }
			 if( showChangenote ) {
				 String changenote = (String)pageref.getAttribute(WikiPage.CHANGENOTE);
				 row.addElement( new td(changenote != null ? changenote : """").setClass(""changenote"") );
			 }
		 }
		 rt.setPrettyPrint(true);
		 return rt.toString();
	 }
	 return """";
 }",0,0,1,0
"public boolean getDestroyOnTimeout() {
	 return _destroyOnTimeout;
 }",0,0,0,0
"public class MessageComponent extends UIOutput {
	 public MessageComponent() {
		 super();
		 setRendererType(""org.apache.struts.faces.Message"");
	 }
	 private String bundle = null;
	 private boolean filter = true;
	 private boolean filterSet = false;
	 private String key = null;
	 private String style = null;
	 private String styleClass = null;
	 public String getBundle() {
		 ValueBinding vb = getValueBinding(""bundle"");
		 if (vb != null) {
			 return (String) vb.getValue(getFacesContext());
		 }
		 else {
			 return bundle;
		 }
	 }
	 public void setBundle(String bundle) {
		 this.bundle = bundle;
	 }
	 public String getFamily() {
		 return ""org.apache.struts.faces.Message"";
	 }
	 public boolean isFilter() {
		 if (filterSet) {
			 return filter;
		 }
		 ValueBinding vb = getValueBinding(""filter"");
		 if (vb != null) {
			 Boolean value = (Boolean) vb.getValue(getFacesContext());
			 if (null == value) {
				 return filter;
			 }
			 return value.booleanValue();
		 }
		 else {
			 return filter;
		 }
	 }
	 public void setFilter(boolean filter) {
		 this.filter = filter;
		 this.filterSet = true;
	 }
	 public String getKey() {
		 ValueBinding vb = getValueBinding(""key"");
		 if (vb != null) {
			 return (String) vb.getValue(getFacesContext());
		 }
		 else {
			 return key;
		 }
	 }
	 public void setKey(String key) {
		 this.key = key;
	 }
	 public String getStyle() {
		 ValueBinding vb = getValueBinding(""style"");
		 if (vb != null) {
			 return (String) vb.getValue(getFacesContext());
		 }
		 else {
			 return style;
		 }
	 }
	 public void setStyle(String style) {
		 this.style = style;
	 }
	 public String getStyleClass() {
		 ValueBinding vb = getValueBinding(""styleClass"");
		 if (vb != null) {
			 return (String) vb.getValue(getFacesContext());
		 }
		 else {
			 return styleClass;
		 }
	 }
	 public void setStyleClass(String styleClass) {
		 this.styleClass = styleClass;
	 }
	 public void restoreState(FacesContext context, Object state) {
		 Object values[] = (Object[]) state;
		 super.restoreState(context, values[0]);
		 bundle = (String) values[1];
		 filter = ((Boolean) values[2]).booleanValue();
		 filterSet = ((Boolean) values[3]).booleanValue();
		 key = (String) values[4];
		 style = (String) values[5];
		 styleClass = (String) values[6];
	 }
	 public Object saveState(FacesContext context) {
		 Object values[] = new Object[7];
		 values[0] = super.saveState(context);
		 values[1] = bundle;
		 values[2] = filter ? Boolean.TRUE : Boolean.FALSE;
		 values[3] = filterSet ? Boolean.TRUE : Boolean.FALSE;
		 values[4] = key;
		 values[5] = style;
		 values[6] = styleClass;
		 return values;
	 }
}",1,1,0,0
"public class ElasticsearchClientFactory {
	 private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
	 private static final String ES_SETTINGS_KEY = ""es.client.settings"";
	 public static ElasticsearchClient create(Map<String, Object> globalConfig) {
		 ElasticsearchClientConfig esClientConfig = new ElasticsearchClientConfig( getEsSettings(globalConfig));
		 HttpHost[] httpHosts = getHttpHosts(globalConfig, esClientConfig.getConnectionScheme());
		 RestClientBuilder builder = RestClient.builder(httpHosts);
		 builder.setRequestConfigCallback(reqConfigBuilder -> {
			 reqConfigBuilder.setConnectTimeout(esClientConfig.getConnectTimeoutMillis());
			 reqConfigBuilder.setSocketTimeout(esClientConfig.getSocketTimeoutMillis());
			 return reqConfigBuilder;
		 }
		);
		 builder.setMaxRetryTimeoutMillis(esClientConfig.getMaxRetryTimeoutMillis());
		 builder.setHttpClientConfigCallback(clientBuilder -> {
			 clientBuilder.setDefaultIOReactorConfig(getIOReactorConfig(esClientConfig));
			 clientBuilder.setDefaultCredentialsProvider(getCredentialsProvider(esClientConfig));
			 clientBuilder.setSSLContext(getSSLContext(esClientConfig));
			 return clientBuilder;
		 }
		);
		 RestClient lowLevelClient = builder.build();
		 RestHighLevelClient client = new RestHighLevelClient(lowLevelClient);
		 return new ElasticsearchClient(lowLevelClient, client);
	 }
	 private static Map<String, Object> getEsSettings(Map<String, Object> globalConfig) {
		 return (Map<String, Object>) globalConfig.getOrDefault(ES_SETTINGS_KEY, new HashMap<>());
	 }
	 private static HttpHost[] getHttpHosts(Map<String, Object> globalConfiguration, String scheme) {
		 List<HostnamePort> hps = ElasticsearchUtils.getIps(globalConfiguration);
		 HttpHost[] httpHosts = new HttpHost[hps.size()];
		 int i = 0;
		 for (HostnamePort hp : hps) {
			 httpHosts[i++] = new HttpHost(hp.hostname, hp.port, scheme);
		 }
		 return httpHosts;
	 }
	 private static IOReactorConfig getIOReactorConfig(ElasticsearchClientConfig esClientConfig) {
		 if (esClientConfig.getNumClientConnectionThreads().isPresent()) {
			 Integer numThreads = esClientConfig.getNumClientConnectionThreads().get();
			 LOG.info(""Setting number of client connection threads: {
			}
			"", numThreads);
			 return IOReactorConfig.custom().setIoThreadCount(numThreads).build();
		 }
		 else {
			 return IOReactorConfig.DEFAULT;
		 }
	 }
	 private static CredentialsProvider getCredentialsProvider( ElasticsearchClientConfig esClientConfig) {
		 Optional<Entry<String, String>> credentials = esClientConfig.getCredentials();
		 if (credentials.isPresent()) {
			 LOG.info( ""Found auth credentials - setting up user/pass authenticated client connection for ES."");
			 final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
			 UsernamePasswordCredentials upcredentials = new UsernamePasswordCredentials( credentials.get().getKey(), credentials.get().getValue());
			 credentialsProvider.setCredentials(AuthScope.ANY, upcredentials);
			 return credentialsProvider;
		 }
		 else {
			 LOG.info( ""Elasticsearch client credentials not provided. Defaulting to non-authenticated client connection."");
			 return null;
		 }
	 }
	 private static SSLContext getSSLContext(ElasticsearchClientConfig esClientConfig) {
		 if (esClientConfig.isSSLEnabled()) {
			 LOG.info(""Configuring client for SSL connection."");
			 if (!esClientConfig.getKeyStorePath().isPresent()) {
				 throw new IllegalStateException(""KeyStore path must be provided for SSL connection."");
			 }
			 Optional<String> optKeyStorePass = esClientConfig.getKeyStorePassword();
			 char[] keyStorePass = optKeyStorePass.map(String::toCharArray).orElse(null);
			 KeyStore trustStore = getStore(esClientConfig.getKeyStoreType(), esClientConfig.getKeyStorePath().get(), keyStorePass);
			 try {
				 SSLContextBuilder sslBuilder = SSLContexts.custom().loadTrustMaterial(trustStore, null);
				 return sslBuilder.build();
			 }
			 catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
				 throw new IllegalStateException(""Unable to load truststore."", e);
			 }
		 }
		 return null;
	 }
	 private static KeyStore getStore(String type, Path path, char[] pass) {
		 KeyStore store;
		 try {
			 store = KeyStore.getInstance(type);
		 }
		 catch (KeyStoreException e) {
			 throw new IllegalStateException(""Unable to get keystore type '"" + type + ""'"", e);
		 }
		 try (InputStream is = Files.newInputStream(path)) {
			 store.load(is, pass);
		 }
		 catch (IOException | NoSuchAlgorithmException | CertificateException e) {
			 throw new IllegalStateException(""Unable to load keystore from path '"" + path + ""'"", e);
		 }
		 return store;
	 }
}",1,0,0,0
"public boolean executeSyncCmsId(NuageVspDeviceVO nuageVspDevice, SyncType syncType) {
	 NuageVspDeviceVO matchingNuageVspDevice = findMatchingNuageVspDevice(nuageVspDevice);
	 if (syncType == SyncType.REGISTER && matchingNuageVspDevice != null) {
		 String cmsId = findNuageVspCmsIdForDeviceOrHost(matchingNuageVspDevice.getId(), matchingNuageVspDevice.getHostId());
		 registerNewNuageVspDevice(nuageVspDevice.getHostId(), cmsId);
		 return true;
	 }
	 String cmsId = findNuageVspCmsIdForDeviceOrHost(nuageVspDevice.getId(), nuageVspDevice.getHostId());
	 SyncNuageVspCmsIdCommand syncCmd = new SyncNuageVspCmsIdCommand(syncType, cmsId);
	 SyncNuageVspCmsIdAnswer answer = (SyncNuageVspCmsIdAnswer) _agentMgr.easySend(nuageVspDevice.getHostId(), syncCmd);
	 if (answer != null) {
		 if (answer.getSuccess()) {
			 if (syncType == SyncType.REGISTER || answer.getSyncType() == SyncType.REGISTER) {
				 registerNewNuageVspDevice(nuageVspDevice.getHostId(), answer.getNuageVspCmsId());
			 }
			 else if (syncType == SyncType.UNREGISTER) {
				 removeLegacyNuageVspDeviceCmsId(nuageVspDevice.getId());
			 }
		 }
		 else if (syncType == SyncType.AUDIT || syncType == SyncType.AUDIT_ONLY) {
			 s_logger.fatal(""Nuage VSP Device with ID "" + nuageVspDevice.getId() + "" is configured with an unknown CMS ID!"");
		 }
	 }
	 return answer != null && answer.getSuccess();
 }",0,0,1,0
"public class DOM2DTM extends DTMDefaultBaseIterators{
	 static final boolean JJK_DEBUG=false;
	 static final boolean JJK_NEWCODE=true;
	 static final String NAMESPACE_DECL_NS=""http: transient private Node m_pos;
	 private int m_last_parent=0;
	 private int m_last_kid=NULL;
	 transient private Node m_root;
	 boolean m_processedFirstElement=false;
	 transient private boolean m_nodesAreProcessed;
	 protected Vector m_nodes = new Vector();
	 public DOM2DTM(DTMManager mgr, DOMSource domSource, int dtmIdentity, DTMWSFilter whiteSpaceFilter, XMLStringFactory xstringfactory, boolean doIndexing) {
		 super(mgr, domSource, dtmIdentity, whiteSpaceFilter, xstringfactory, doIndexing);
		 m_pos=m_root = domSource.getNode();
		 m_last_parent=m_last_kid=NULL;
		 m_last_kid=addNode(m_root, m_last_parent,m_last_kid, NULL);
		 if(ELEMENT_NODE == m_root.getNodeType()) {
			 NamedNodeMap attrs=m_root.getAttributes();
			 int attrsize=(attrs==null) ? 0 : attrs.getLength();
			 if(attrsize>0) {
				 int attrIndex=NULL;
				 for(int i=0;
				i<attrsize;
				++i) {
					 attrIndex=addNode(attrs.item(i),0,attrIndex,NULL);
					 m_firstch.setElementAt(DTM.NULL,attrIndex);
				 }
				 m_nextsib.setElementAt(DTM.NULL,attrIndex);
			 }
		 }
		 m_nodesAreProcessed = false;
	 }
	 protected int addNode(Node node, int parentIndex, int previousSibling, int forceNodeType) {
		 int nodeIndex = m_nodes.size();
		 if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS)) {
			 try {
				 if(m_mgr==null) throw new ClassCastException();
				 DTMManagerDefault mgrD=(DTMManagerDefault)m_mgr;
				 int id=mgrD.getFirstFreeDTMID();
				 mgrD.addDTM(this,id,nodeIndex);
				 m_dtmIdent.addElement(id<<DTMManager.IDENT_DTM_NODE_BITS);
			 }
			 catch(ClassCastException e) {
				 error(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_DTMIDS_AVAIL, null));
			 }
		 }
		 m_size++;
		 int type;
		 if(NULL==forceNodeType) type = node.getNodeType();
		 else type=forceNodeType;
		 if (Node.ATTRIBUTE_NODE == type) {
			 String name = node.getNodeName();
			 if (name.startsWith(""xmlns:"") || name.equals(""xmlns"")) {
				 type = DTM.NAMESPACE_NODE;
			 }
		 }
		 m_nodes.addElement(node);
		 m_firstch.setElementAt(NOTPROCESSED,nodeIndex);
		 m_nextsib.setElementAt(NOTPROCESSED,nodeIndex);
		 m_prevsib.setElementAt(previousSibling,nodeIndex);
		 m_parent.setElementAt(parentIndex,nodeIndex);
		 if(DTM.NULL != parentIndex && type != DTM.ATTRIBUTE_NODE && type != DTM.NAMESPACE_NODE) {
			 if(NOTPROCESSED == m_firstch.elementAt(parentIndex)) m_firstch.setElementAt(nodeIndex,parentIndex);
		 }
		 String nsURI = node.getNamespaceURI();
		 String localName = (type == Node.PROCESSING_INSTRUCTION_NODE) ? node.getNodeName() : node.getLocalName();
		 if(((type == Node.ELEMENT_NODE) || (type == Node.ATTRIBUTE_NODE)) && null == localName) localName = node.getNodeName();
		 ExpandedNameTable exnt = m_expandedNameTable;
		 if(node.getLocalName()==null && (type==Node.ELEMENT_NODE || type==Node.ATTRIBUTE_NODE)) {
		 }
		 int expandedNameID = (null != localName) ? exnt.getExpandedTypeID(nsURI, localName, type) : exnt.getExpandedTypeID(type);
		 m_exptype.setElementAt(expandedNameID,nodeIndex);
		 indexNode(expandedNameID, nodeIndex);
		 if (DTM.NULL != previousSibling) m_nextsib.setElementAt(nodeIndex,previousSibling);
		 if (type == DTM.NAMESPACE_NODE) declareNamespaceInContext(parentIndex,nodeIndex);
		 return nodeIndex;
	 }
	 public int getNumberOfNodes() {
		 return m_nodes.size();
	 }
	 protected boolean nextNode() {
		 if (m_nodesAreProcessed) return false;
		 Node pos=m_pos;
		 Node next=null;
		 int nexttype=NULL;
		 do {
			 if (pos.hasChildNodes()) {
				 next = pos.getFirstChild();
				 if(next!=null && DOCUMENT_TYPE_NODE==next.getNodeType()) next=next.getNextSibling();
				 if(ENTITY_REFERENCE_NODE!=pos.getNodeType()) {
					 m_last_parent=m_last_kid;
					 m_last_kid=NULL;
					 if(null != m_wsfilter) {
						 short wsv = m_wsfilter.getShouldStripSpace(makeNodeHandle(m_last_parent),this);
						 boolean shouldStrip = (DTMWSFilter.INHERIT == wsv) ? getShouldStripWhitespace() : (DTMWSFilter.STRIP == wsv);
						 pushShouldStripWhitespace(shouldStrip);
					 }
				 }
			 }
			 else {
				 if(m_last_kid!=NULL) {
					 if(m_firstch.elementAt(m_last_kid)==NOTPROCESSED) m_firstch.setElementAt(NULL,m_last_kid);
				 }
				 while(m_last_parent != NULL) {
					 next = pos.getNextSibling();
					 if(next!=null && DOCUMENT_TYPE_NODE==next.getNodeType()) next=next.getNextSibling();
					 if(next!=null) break;
					 pos=pos.getParentNode();
					 if(pos==null) {
						 if(JJK_DEBUG) {
							 System.out.println(""***** DOM2DTM Pop Control Flow problem"");
							 for(;
							;
							);
						 }
					 }
					 if(pos!=null && ENTITY_REFERENCE_NODE == pos.getNodeType()) {
						 if(JJK_DEBUG) System.out.println(""***** DOM2DTM popping EntRef"");
					 }
					 else {
						 popShouldStripWhitespace();
						 if(m_last_kid==NULL) m_firstch.setElementAt(NULL,m_last_parent);
						 else m_nextsib.setElementAt(NULL,m_last_kid);
						 m_last_parent=m_parent.elementAt(m_last_kid=m_last_parent);
					 }
				 }
				 if(m_last_parent==NULL) next=null;
			 }
			 if(next!=null) nexttype=next.getNodeType();
			 if (ENTITY_REFERENCE_NODE == nexttype) pos=next;
		 }
		 while (ENTITY_REFERENCE_NODE == nexttype);
		 if(next==null) {
			 m_nextsib.setElementAt(NULL,0);
			 m_nodesAreProcessed = true;
			 m_pos=null;
			 if(JJK_DEBUG) {
				 System.out.println(""***** DOM2DTM Crosscheck:"");
				 for(int i=0;
				i<m_nodes.size();
				++i) System.out.println(i+"":\t""+m_firstch.elementAt(i)+""\t""+m_nextsib.elementAt(i));
			 }
			 return false;
		 }
		 boolean suppressNode=false;
		 Node lastTextNode=null;
		 nexttype=next.getNodeType();
		 if(TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype) {
			 suppressNode=((null != m_wsfilter) && getShouldStripWhitespace());
			 Node n=next;
			 while(n!=null) {
				 lastTextNode=n;
				 if(TEXT_NODE == n.getNodeType()) nexttype=TEXT_NODE;
				 suppressNode &= XMLCharacterRecognizer.isWhiteSpace(n.getNodeValue());
				 n=logicalNextDOMTextNode(n);
			 }
		 }
		 else if(PROCESSING_INSTRUCTION_NODE==nexttype) {
			 suppressNode = (pos.getNodeName().toLowerCase().equals(""xml""));
		 }
		 if(!suppressNode) {
			 int nextindex=addNode(next,m_last_parent,m_last_kid, nexttype);
			 m_last_kid=nextindex;
			 if(ELEMENT_NODE == nexttype) {
				 int attrIndex=NULL;
				 NamedNodeMap attrs=next.getAttributes();
				 int attrsize=(attrs==null) ? 0 : attrs.getLength();
				 if(attrsize>0) {
					 for(int i=0;
					i<attrsize;
					++i) {
						 attrIndex=addNode(attrs.item(i), nextindex,attrIndex,NULL);
						 m_firstch.setElementAt(DTM.NULL,attrIndex);
						 if(!m_processedFirstElement && ""xmlns:xml"".equals(attrs.item(i).getNodeName())) m_processedFirstElement=true;
					 }
				 }
				 if(!m_processedFirstElement) {
					 attrIndex=addNode(new DOM2DTMdefaultNamespaceDeclarationNode((Element)next,""xml"",NAMESPACE_DECL_NS,makeNodeHandle(((attrIndex==NULL)?nextindex:attrIndex)+1)), nextindex,attrIndex,NULL);
					 m_firstch.setElementAt(DTM.NULL,attrIndex);
					 m_processedFirstElement=true;
				 }
				 if(attrIndex!=NULL) m_nextsib.setElementAt(DTM.NULL,attrIndex);
			 }
		 }
		 if(TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype) {
			 next=lastTextNode;
		 }
		 m_pos=next;
		 return true;
	 }
	 public Node getNode(int nodeHandle) {
		 int identity = makeNodeIdentity(nodeHandle);
		 return (Node) m_nodes.elementAt(identity);
	 }
	 protected Node lookupNode(int nodeIdentity) {
		 return (Node) m_nodes.elementAt(nodeIdentity);
	 }
	 protected int getNextNodeIdentity(int identity) {
		 identity += 1;
		 if (identity >= m_nodes.size()) {
			 if (!nextNode()) identity = DTM.NULL;
		 }
		 return identity;
	 }
	 private int getHandleFromNode(Node node) {
		 if (null != node) {
			 int len = m_nodes.size();
			 boolean isMore;
			 int i = 0;
			 do {
				 for (;
				 i < len;
				 i++) {
					 if (m_nodes.elementAt(i) == node) return makeNodeHandle(i);
				 }
				 isMore = nextNode();
				 len = m_nodes.size();
			 }
			 while(isMore || i < len);
		 }
		 return DTM.NULL;
	 }
	 public int getHandleOfNode(Node node) {
		 if (null != node) {
			 if((m_root==node) || (m_root.getNodeType()==DOCUMENT_NODE && m_root==node.getOwnerDocument()) || (m_root.getNodeType()!=DOCUMENT_NODE && m_root.getOwnerDocument()==node.getOwnerDocument()) ) {
				 for(Node cursor=node;
				 cursor!=null;
				 cursor= (cursor.getNodeType()!=ATTRIBUTE_NODE) ? cursor.getParentNode() : ((org.w3c.dom.Attr)cursor).getOwnerElement()) {
					 if(cursor==m_root) return getHandleFromNode(node);
				 }
			 }
		 }
		 return DTM.NULL;
	 }
	 public int getAttributeNode(int nodeHandle, String namespaceURI, String name) {
		 if (null == namespaceURI) namespaceURI = """";
		 int type = getNodeType(nodeHandle);
		 if (DTM.ELEMENT_NODE == type) {
			 int identity = makeNodeIdentity(nodeHandle);
			 while (DTM.NULL != (identity = getNextNodeIdentity(identity))) {
				 type = _type(identity);
				 if (type == DTM.ATTRIBUTE_NODE || type==DTM.NAMESPACE_NODE) {
					 Node node = lookupNode(identity);
					 String nodeuri = node.getNamespaceURI();
					 if (null == nodeuri) nodeuri = """";
					 String nodelocalname = node.getLocalName();
					 if (nodeuri.equals(namespaceURI) && name.equals(nodelocalname)) return makeNodeHandle(identity);
				 }
				 else {
					 break;
				 }
			 }
		 }
		 return DTM.NULL;
	 }
	 public XMLString getStringValue(int nodeHandle) {
		 int type = getNodeType(nodeHandle);
		 Node node = getNode(nodeHandle);
		 if(DTM.ELEMENT_NODE == type || DTM.DOCUMENT_NODE == type || DTM.DOCUMENT_FRAGMENT_NODE == type) {
			 FastStringBuffer buf = StringBufferPool.get();
			 String s;
			 try {
				 getNodeData(node, buf);
				 s = (buf.length() > 0) ? buf.toString() : """";
			 }
			 finally {
				 StringBufferPool.free(buf);
			 }
			 return m_xstrf.newstr( s );
		 }
		 else if(TEXT_NODE == type || CDATA_SECTION_NODE == type) {
			 FastStringBuffer buf = StringBufferPool.get();
			 while(node!=null) {
				 buf.append(node.getNodeValue());
				 node=logicalNextDOMTextNode(node);
			 }
			 String s=(buf.length() > 0) ? buf.toString() : """";
			 StringBufferPool.free(buf);
			 return m_xstrf.newstr( s );
		 }
		 else return m_xstrf.newstr( node.getNodeValue() );
	 }
	 public boolean isWhitespace(int nodeHandle) {
		 int type = getNodeType(nodeHandle);
		 Node node = getNode(nodeHandle);
		 if(TEXT_NODE == type || CDATA_SECTION_NODE == type) {
			 FastStringBuffer buf = StringBufferPool.get();
			 while(node!=null) {
				 buf.append(node.getNodeValue());
				 node=logicalNextDOMTextNode(node);
			 }
			 boolean b = buf.isWhitespace(0, buf.length());
			 StringBufferPool.free(buf);
			 return b;
		 }
		 return false;
	 }
	 protected static void getNodeData(Node node, FastStringBuffer buf) {
		 switch (node.getNodeType()) {
			 case Node.DOCUMENT_FRAGMENT_NODE : case Node.DOCUMENT_NODE : case Node.ELEMENT_NODE : {
				 for (Node child = node.getFirstChild();
				 null != child;
				 child = child.getNextSibling()) {
					 getNodeData(child, buf);
				 }
			 }
			 break;
			 case Node.TEXT_NODE : case Node.CDATA_SECTION_NODE : case Node.ATTRIBUTE_NODE : buf.append(node.getNodeValue());
			 break;
			 case Node.PROCESSING_INSTRUCTION_NODE : break;
			 default : break;
		 }
	 }
	 public String getNodeName(int nodeHandle) {
		 Node node = getNode(nodeHandle);
		 return node.getNodeName();
	 }
	 public String getNodeNameX(int nodeHandle) {
		 String name;
		 short type = getNodeType(nodeHandle);
		 switch (type) {
			 case DTM.NAMESPACE_NODE : {
				 Node node = getNode(nodeHandle);
				 name = node.getNodeName();
				 if(name.startsWith(""xmlns:"")) {
					 name = QName.getLocalPart(name);
				 }
				 else if(name.equals(""xmlns"")) {
					 name = """";
				 }
			 }
			 break;
			 case DTM.ATTRIBUTE_NODE : case DTM.ELEMENT_NODE : case DTM.ENTITY_REFERENCE_NODE : case DTM.PROCESSING_INSTRUCTION_NODE : {
				 Node node = getNode(nodeHandle);
				 name = node.getNodeName();
			 }
			 break;
			 default : name = """";
		 }
		 return name;
	 }
	 public String getLocalName(int nodeHandle) {
		 if(JJK_NEWCODE) {
			 int id=makeNodeIdentity(nodeHandle);
			 if(NULL==id) return null;
			 Node newnode=(Node)m_nodes.elementAt(id);
			 String newname=newnode.getLocalName();
			 if (null == newname) {
				String qname = newnode.getNodeName();
				if('#'==qname.charAt(0)){
					 newname="""";
				}
				else{
					 int index = qname.indexOf(':');
					 newname = (index < 0) ? qname : qname.substring(index + 1);
				}
			 }
			 return newname;
		 }
		 else {
			 String name;
			 short type = getNodeType(nodeHandle);
			 switch (type) {
				 case DTM.ATTRIBUTE_NODE : case DTM.ELEMENT_NODE : case DTM.ENTITY_REFERENCE_NODE : case DTM.NAMESPACE_NODE : case DTM.PROCESSING_INSTRUCTION_NODE :{
					 Node node = getNode(nodeHandle);
					 name = node.getLocalName();
					 if (null == name) {
						 String qname = node.getNodeName();
						 int index = qname.indexOf(':');
						 name = (index < 0) ? qname : qname.substring(index + 1);
					 }
				}
				break;
				 default :name = """";
			 }
			 return name;
		 }
	 }
	 public String getPrefix(int nodeHandle) {
		 String prefix;
		 short type = getNodeType(nodeHandle);
		 switch (type) {
			 case DTM.NAMESPACE_NODE : {
				 Node node = getNode(nodeHandle);
				 String qname = node.getNodeName();
				 int index = qname.indexOf(':');
				 prefix = (index < 0) ? """" : qname.substring(index + 1);
			 }
			 break;
			 case DTM.ATTRIBUTE_NODE : case DTM.ELEMENT_NODE : {
				 Node node = getNode(nodeHandle);
				 String qname = node.getNodeName();
				 int index = qname.indexOf(':');
				 prefix = (index < 0) ? """" : qname.substring(0, index);
			 }
			 break;
			 default : prefix = """";
		 }
		 return prefix;
	 }
	 public String getNamespaceURI(int nodeHandle) {
		 if(JJK_NEWCODE) {
			 int id=makeNodeIdentity(nodeHandle);
			 if(id==NULL) return null;
			 Node node=(Node)m_nodes.elementAt(id);
			 return node.getNamespaceURI();
		 }
		 else {
			 String nsuri;
			 short type = getNodeType(nodeHandle);
			 switch (type) {
				 case DTM.ATTRIBUTE_NODE : case DTM.ELEMENT_NODE : case DTM.ENTITY_REFERENCE_NODE : case DTM.NAMESPACE_NODE : case DTM.PROCESSING_INSTRUCTION_NODE :{
					 Node node = getNode(nodeHandle);
					 nsuri = node.getNamespaceURI();
				}
				break;
				 default :nsuri = null;
			 }
			 return nsuri;
		 }
	 }
	 private Node logicalNextDOMTextNode(Node n) {
		 Node p=n.getNextSibling();
		 if(p==null) {
			 for(n=n.getParentNode();
			 n!=null && ENTITY_REFERENCE_NODE == n.getNodeType();
			 n=n.getParentNode()) {
				 p=n.getNextSibling();
				 if(p!=null) break;
			 }
		 }
		 n=p;
		 while(n!=null && ENTITY_REFERENCE_NODE == n.getNodeType()) {
			 if(n.hasChildNodes()) n=n.getFirstChild();
			 else n=n.getNextSibling();
		 }
		 if(n!=null) {
			 int ntype=n.getNodeType();
			 if(TEXT_NODE != ntype && CDATA_SECTION_NODE != ntype) n=null;
		 }
		 return n;
	 }
	 public String getNodeValue(int nodeHandle) {
		 int type = _exptype(makeNodeIdentity(nodeHandle));
		 type=(NULL != type) ? getNodeType(nodeHandle) : NULL;
		 if(TEXT_NODE!=type && CDATA_SECTION_NODE!=type) return getNode(nodeHandle).getNodeValue();
		 Node node = getNode(nodeHandle);
		 Node n=logicalNextDOMTextNode(node);
		 if(n==null) return node.getNodeValue();
		 FastStringBuffer buf = StringBufferPool.get();
		 buf.append(node.getNodeValue());
		 while(n!=null) {
			 buf.append(n.getNodeValue());
			 n=logicalNextDOMTextNode(n);
		 }
		 String s = (buf.length() > 0) ? buf.toString() : """";
		 StringBufferPool.free(buf);
		 return s;
	 }
	 public String getDocumentTypeDeclarationSystemIdentifier() {
		 Document doc;
		 if (m_root.getNodeType() == Node.DOCUMENT_NODE) doc = (Document) m_root;
		 else doc = m_root.getOwnerDocument();
		 if (null != doc) {
			 DocumentType dtd = doc.getDoctype();
			 if (null != dtd) {
				 return dtd.getSystemId();
			 }
		 }
		 return null;
	 }
	 public String getDocumentTypeDeclarationPublicIdentifier() {
		 Document doc;
		 if (m_root.getNodeType() == Node.DOCUMENT_NODE) doc = (Document) m_root;
		 else doc = m_root.getOwnerDocument();
		 if (null != doc) {
			 DocumentType dtd = doc.getDoctype();
			 if (null != dtd) {
				 return dtd.getPublicId();
			 }
		 }
		 return null;
	 }
	 public int getElementById(String elementId) {
		 Document doc = (m_root.getNodeType() == Node.DOCUMENT_NODE) ? (Document) m_root : m_root.getOwnerDocument();
		 if(null != doc) {
			 Node elem = doc.getElementById(elementId);
			 if(null != elem) {
				 int elemHandle = getHandleFromNode(elem);
				 if(DTM.NULL == elemHandle) {
					 int identity = m_nodes.size()-1;
					 while (DTM.NULL != (identity = getNextNodeIdentity(identity))) {
						 Node node = getNode(identity);
						 if(node == elem) {
							 elemHandle = getHandleFromNode(elem);
							 break;
						 }
					 }
				 }
				 return elemHandle;
			 }
		 }
		 return DTM.NULL;
	 }
	 public String getUnparsedEntityURI(String name) {
		 String url = """";
		 Document doc = (m_root.getNodeType() == Node.DOCUMENT_NODE) ? (Document) m_root : m_root.getOwnerDocument();
		 if (null != doc) {
			 DocumentType doctype = doc.getDoctype();
			 if (null != doctype) {
				 NamedNodeMap entities = doctype.getEntities();
				 if(null == entities) return url;
				 Entity entity = (Entity) entities.getNamedItem(name);
				 if(null == entity) return url;
				 String notationName = entity.getNotationName();
				 if (null != notationName) {
					 url = entity.getSystemId();
					 if (null == url) {
						 url = entity.getPublicId();
					 }
					 else {
					 }
				 }
			 }
		 }
		 return url;
	 }
	 public boolean isAttributeSpecified(int attributeHandle) {
		 int type = getNodeType(attributeHandle);
		 if (DTM.ATTRIBUTE_NODE == type) {
			 Attr attr = (Attr)getNode(attributeHandle);
			 return attr.getSpecified();
		 }
		 return false;
	 }
	 public void setIncrementalSAXSource(IncrementalSAXSource source) {
	 }
	 public org.xml.sax.ContentHandler getContentHandler() {
		 return null;
	 }
	 public org.xml.sax.ext.LexicalHandler getLexicalHandler() {
		 return null;
	 }
	 public org.xml.sax.EntityResolver getEntityResolver() {
		 return null;
	 }
	 public org.xml.sax.DTDHandler getDTDHandler() {
		 return null;
	 }
	 public org.xml.sax.ErrorHandler getErrorHandler() {
		 return null;
	 }
	 public org.xml.sax.ext.DeclHandler getDeclHandler() {
		 return null;
	 }
	 public boolean needsTwoThreads() {
		 return false;
	 }
	 private static boolean isSpace(char ch) {
		 return XMLCharacterRecognizer.isWhiteSpace(ch);
	 }
	 public void dispatchCharactersEvents( int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize) throws org.xml.sax.SAXException {
		 if(normalize) {
			 XMLString str = getStringValue(nodeHandle);
			 str = str.fixWhiteSpace(true, true, false);
			 str.dispatchCharactersEvents(ch);
		 }
		 else {
			 int type = getNodeType(nodeHandle);
			 Node node = getNode(nodeHandle);
			 dispatchNodeData(node, ch, 0);
			 if(TEXT_NODE == type || CDATA_SECTION_NODE == type) {
				 while( null != (node=logicalNextDOMTextNode(node)) ) {
					 dispatchNodeData(node, ch, 0);
				 }
			 }
		 }
	 }
	 protected static void dispatchNodeData(Node node, org.xml.sax.ContentHandler ch, int depth) throws org.xml.sax.SAXException {
		 switch (node.getNodeType()) {
			 case Node.DOCUMENT_FRAGMENT_NODE : case Node.DOCUMENT_NODE : case Node.ELEMENT_NODE : {
				 for (Node child = node.getFirstChild();
				 null != child;
				 child = child.getNextSibling()) {
					 dispatchNodeData(child, ch, depth+1);
				 }
			 }
			 break;
			 case Node.PROCESSING_INSTRUCTION_NODE : case Node.COMMENT_NODE : if(0 != depth) break;
			 case Node.TEXT_NODE : case Node.CDATA_SECTION_NODE : case Node.ATTRIBUTE_NODE : String str = node.getNodeValue();
			 if(ch instanceof CharacterNodeHandler) {
				 ((CharacterNodeHandler)ch).characters(node);
			 }
			 else {
				 ch.characters(str.toCharArray(), 0, str.length());
			 }
			 break;
			 default : break;
		 }
	 }
	 TreeWalker m_walker = new TreeWalker(null);
	 public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch) throws org.xml.sax.SAXException {
		 TreeWalker treeWalker = m_walker;
		 ContentHandler prevCH = treeWalker.getContentHandler();
		 if(null != prevCH) {
			 treeWalker = new TreeWalker(null);
		 }
		 treeWalker.setContentHandler(ch);
		 try {
			 Node node = getNode(nodeHandle);
			 treeWalker.traverseFragment(node);
		 }
		 finally {
			 treeWalker.setContentHandler(null);
		 }
	 }
	 public interface CharacterNodeHandler {
		 public void characters(Node node) throws org.xml.sax.SAXException;
	 }
	 public void setProperty(String property, Object value) {
	 }
	 public SourceLocator getSourceLocatorFor(int node) {
		 return null;
	 }
}",1,0,0,0
"public StringInputDialog( final Shell parentShell, final String label, final String initialValue, final String dialogTitle, final String purpose) {
	 super(parentShell);
	 this.label = label;
	 text = initialValue;
	 this.dialogTitle = dialogTitle;
	 setOptionDialogSettingsKey(StringInputDialog.class.getName() + ""."" + purpose);
 }",0,0,0,0
"String genCppDecl(String fname) {
	 return "" ""+mCppName+"" m""+fname+"";
	\n"";
 }",0,0,0,0
"public String toString() {
	 return String.format(""%s - chunk length %d, data length %d."", getPath(), metadata.chunkLength(), metadata.dataLength);
 }",0,0,0,0
"public int compare(PropertyDescriptor d1, PropertyDescriptor d2) {
	 String g1 = group(d1);
	 String g2 = group(d2);
	 Integer go1 = groupOrder(g1);
	 Integer go2 = groupOrder(g2);
	 int result = go1.compareTo(go2);
	 if (result != 0) {
		 return result;
	 }
	 result = g1.compareTo(g2);
	 if (result != 0) {
		 return result;
	 }
	 Integer po1 = propertyOrder(d1);
	 Integer po2 = propertyOrder(d2);
	 result = po1.compareTo(po2);
	 if (result != 0) {
		 return result;
	 }
	 return d1.getName().compareTo(d2.getName());
 }",0,0,1,0
"private void finishRestore(final Timer.Context context, Map<String, List<HoodieRollbackStat>> commitToStats, List<String> commitsToRollback, final String startRestoreTime, final String restoreToInstant) throws IOException {
	 HoodieTable<T> table = HoodieTable.getHoodieTable( new HoodieTableMetaClient(jsc.hadoopConfiguration(), config.getBasePath(), true), config, jsc);
	 Optional<Long> durationInMs = Optional.empty();
	 Long numFilesDeleted = 0L;
	 for (Map.Entry<String, List<HoodieRollbackStat>> commitToStat : commitToStats.entrySet()) {
		 List<HoodieRollbackStat> stats = commitToStat.getValue();
		 numFilesDeleted = stats.stream().mapToLong(stat -> stat.getSuccessDeleteFiles().size()) .sum();
	 }
	 if (context != null) {
		 durationInMs = Optional.of(metrics.getDurationInMs(context.stop()));
		 metrics.updateRollbackMetrics(durationInMs.get(), numFilesDeleted);
	 }
	 HoodieRestoreMetadata restoreMetadata = AvroUtils .convertRestoreMetadata(startRestoreTime, durationInMs, commitsToRollback, commitToStats);
	 table.getActiveTimeline().saveAsComplete( new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, startRestoreTime), AvroUtils.serializeRestoreMetadata(restoreMetadata));
	 logger.info(""Commits "" + commitsToRollback + "" rollback is complete. Restored dataset to "" + restoreToInstant);
	 if (!table.getActiveTimeline().getCleanerTimeline().empty()) {
		 logger.info(""Cleaning up older restore meta files"");
		 FSUtils.deleteOlderRollbackMetaFiles(fs, table.getMetaClient().getMetaPath(), table.getActiveTimeline().getRestoreTimeline().getInstants());
	 }
 }",0,0,1,0
"public class ConsoleResponse extends Response{
	private static final ConsoleResponse instance = new ConsoleResponse();
	public static final ConsoleResponse getInstance(){
		return instance;
	}
	private ConsoleResponse(){
	}
	public void write(CharSequence string){
		System.out.print(string);
	}
	public OutputStream getOutputStream(){
		return System.out;
	}
}",0,0,0,0
"protected void adjustLearningRate() {
	 double errorChange = this.previousEpochError - getErrorFunction().getTotalError();
	 this.learningRate = this.learningRate + (errorChange*learningRateChange);
	 if (this.learningRate > this.maxLearningRate) this.learningRate = this.maxLearningRate;
	 if (this.learningRate < this.minLearningRate) this.learningRate = this.minLearningRate;
 }",0,0,1,0
