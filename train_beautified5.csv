code,godclass,dataclass,longmethod,longparamlist
"public void set(float progress) {
	 this.progress = progress;
 }",0,0,0,0
"private TtmlRegion parseRegionAttributes( XmlPullParser xmlParser, CellResolution cellResolution, TtsExtent ttsExtent) {
	 String regionId = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_ID);
	 if (regionId == null) {
		 return null;
	 }
	 float position;
	 float line;
	 String regionOrigin = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_ORIGIN);
	 if (regionOrigin != null) {
		 Matcher originPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);
		 Matcher originPixelMatcher = PIXEL_COORDINATES.matcher(regionOrigin);
		 if (originPercentageMatcher.matches()) {
			 try {
				 position = Float.parseFloat(originPercentageMatcher.group(1)) / 100f;
				 line = Float.parseFloat(originPercentageMatcher.group(2)) / 100f;
			 }
			 catch (NumberFormatException e) {
				 Log.w(TAG, ""Ignoring region with malformed origin: "" + regionOrigin);
				 return null;
			 }
		 }
		 else if (originPixelMatcher.matches()) {
			 if (ttsExtent == null) {
				 Log.w(TAG, ""Ignoring region with missing tts:extent: "" + regionOrigin);
				 return null;
			 }
			 try {
				 int width = Integer.parseInt(originPixelMatcher.group(1));
				 int height = Integer.parseInt(originPixelMatcher.group(2));
				 position = width / (float) ttsExtent.width;
				 line = height / (float) ttsExtent.height;
			 }
			 catch (NumberFormatException e) {
				 Log.w(TAG, ""Ignoring region with malformed origin: "" + regionOrigin);
				 return null;
			 }
		 }
		 else {
			 Log.w(TAG, ""Ignoring region with unsupported origin: "" + regionOrigin);
			 return null;
		 }
	 }
	 else {
		 Log.w(TAG, ""Ignoring region without an origin"");
		 return null;
	 }
	 float width;
	 float height;
	 String regionExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);
	 if (regionExtent != null) {
		 Matcher extentPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);
		 Matcher extentPixelMatcher = PIXEL_COORDINATES.matcher(regionExtent);
		 if (extentPercentageMatcher.matches()) {
			 try {
				 width = Float.parseFloat(extentPercentageMatcher.group(1)) / 100f;
				 height = Float.parseFloat(extentPercentageMatcher.group(2)) / 100f;
			 }
			 catch (NumberFormatException e) {
				 Log.w(TAG, ""Ignoring region with malformed extent: "" + regionOrigin);
				 return null;
			 }
		 }
		 else if (extentPixelMatcher.matches()) {
			 if (ttsExtent == null) {
				 Log.w(TAG, ""Ignoring region with missing tts:extent: "" + regionOrigin);
				 return null;
			 }
			 try {
				 int extentWidth = Integer.parseInt(extentPixelMatcher.group(1));
				 int extentHeight = Integer.parseInt(extentPixelMatcher.group(2));
				 width = extentWidth / (float) ttsExtent.width;
				 height = extentHeight / (float) ttsExtent.height;
			 }
			 catch (NumberFormatException e) {
				 Log.w(TAG, ""Ignoring region with malformed extent: "" + regionOrigin);
				 return null;
			 }
		 }
		 else {
			 Log.w(TAG, ""Ignoring region with unsupported extent: "" + regionOrigin);
			 return null;
		 }
	 }
	 else {
		 Log.w(TAG, ""Ignoring region without an extent"");
		 return null;
	 }
	 int lineAnchor = Cue.ANCHOR_TYPE_START;
	 String displayAlign = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_DISPLAY_ALIGN);
	 if (displayAlign != null) {
		 switch (Util.toLowerInvariant(displayAlign)) {
			 case ""center"": lineAnchor = Cue.ANCHOR_TYPE_MIDDLE;
			 line += height / 2;
			 break;
			 case ""after"": lineAnchor = Cue.ANCHOR_TYPE_END;
			 line += height;
			 break;
			 default: break;
		 }
	 }
	 float regionTextHeight = 1.0f / cellResolution.rows;
	 return new TtmlRegion( regionId, position, line, Cue.LINE_TYPE_FRACTION, lineAnchor, width, Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING, regionTextHeight);
 }",0,0,1,0
"public final class FactoryCreateHandler implements AnnotationHandler<FactoryCreate, Class<?>>{
	 public void handle( FactoryCreate annotation, Class<?> element, RulesBinder rulesBinder ) {
		 FactoryCreateBuilder builder = rulesBinder.forPattern( annotation.pattern() ) .withNamespaceURI( annotation.namespaceURI() ) .factoryCreate() .overriddenByAttribute( annotation.attributeName().length() > 0 ? annotation.attributeName() : null ) .ignoreCreateExceptions( annotation.ignoreCreateExceptions() );
		 if ( FactoryCreate.DefaultObjectCreationFactory.class != annotation.factoryClass() ) {
			 builder.ofType( annotation.factoryClass() );
		 }
	 }
}",0,0,0,0
"public int getPrecision(ByteBuffer obj) {
	 return -1;
 }",0,0,0,0
"final class TraceableHttpServletResponse implements TraceableResponse {
	private final HttpServletResponse delegate;
	TraceableHttpServletResponse(HttpServletResponse response) {
		this.delegate = response;
	}
	public int getStatus() {
		return this.delegate.getStatus();
	}
	public Map<String, List<String>> getHeaders() {
		return extractHeaders();
	}
	private Map<String, List<String>> extractHeaders() {
		Map<String, List<String>> headers = new LinkedHashMap<>();
		for (String name : this.delegate.getHeaderNames()) {
			headers.put(name, new ArrayList<>(this.delegate.getHeaders(name)));
		}
		return headers;
	}
}",0,1,0,0
"public class SSLConfigClient extends SSLConfig {
	 private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);
	 private final Properties properties;
	 private final boolean userSslEnabled;
	 private final String trustStoreType;
	 private final String trustStorePath;
	 private final String trustStorePassword;
	 private final boolean disableHostVerification;
	 private final boolean disableCertificateVerification;
	 private final boolean useSystemTrustStore;
	 private final String protocol;
	 private final int handshakeTimeout;
	 private final String provider;
	 private final String emptyString = new String();
	 public SSLConfigClient(Properties properties) throws DrillException {
		 this.properties = properties;
		 userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);
		 trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, ""JKS"");
		 trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, """");
		 trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, """");
		 disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);
		 disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);
		 useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);
		 protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);
		 int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);
		 if (hsTimeout <= 0) {
			 hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;
		 }
		 handshakeTimeout = hsTimeout;
		 provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);
	 }
	 private boolean getBooleanProperty(String propName) {
		 return (properties != null) && (properties.containsKey(propName)) && (properties.getProperty(propName).compareToIgnoreCase(""true"") == 0);
	 }
	 private String getStringProperty(String name, String defaultValue) {
		 String value = """";
		 if ( (properties != null) && (properties.containsKey(name))) {
			 value = properties.getProperty(name);
		 }
		 if (value.isEmpty()) {
			 value = defaultValue;
		 }
		 value = value.trim();
		 return value;
	 }
	 private int getIntProperty(String name, int defaultValue) {
		 int value = defaultValue;
		 if (properties != null) {
			 String property = properties.getProperty(name);
			 if (property != null && property.length() > 0) {
				 value = Integer.decode(property);
			 }
		 }
		 return value;
	 }
	 public void validateKeyStore() throws DrillException {
	 }
	 public SslContext initNettySslContext() throws DrillException {
		 final SslContext sslCtx;
		 if (!userSslEnabled) {
			 return null;
		 }
		 TrustManagerFactory tmf;
		 try {
			 tmf = initializeTrustManagerFactory();
			 sslCtx = SslContextBuilder.forClient() .sslProvider(getProvider()) .trustManager(tmf) .protocols(protocol) .build();
		 }
		 catch (Exception e) {
			 throw new DrillException(new StringBuilder() .append(""SSL is enabled but cannot be initialized due to the following exception: "") .append(""[ "") .append(e.getMessage()) .append(""]. "") .toString());
		 }
		 this.nettySslContext = sslCtx;
		 return sslCtx;
	 }
	 public SSLContext initJDKSSLContext() throws DrillException {
		 final SSLContext sslCtx;
		 if (!userSslEnabled) {
			 return null;
		 }
		 TrustManagerFactory tmf;
		 try {
			 tmf = initializeTrustManagerFactory();
			 sslCtx = SSLContext.getInstance(protocol);
			 sslCtx.init(null, tmf.getTrustManagers(), null);
		 }
		 catch (Exception e) {
			 throw new DrillException(new StringBuilder() .append(""SSL is enabled but cannot be initialized due to the following exception: "") .append(""[ "") .append(e.getMessage()) .append(""]. "") .toString());
		 }
		 this.jdkSSlContext = sslCtx;
		 return sslCtx;
	 }
	 public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {
		 SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);
		 if (!this.disableHostVerification()) {
			 SSLParameters sslParameters = engine.getSSLParameters();
			 sslParameters.setEndpointIdentificationAlgorithm(""HTTPS"");
			 engine.setSSLParameters(sslParameters);
		 }
		 engine.setUseClientMode(true);
		 try {
			 engine.setEnableSessionCreation(true);
		 }
		 catch (Exception e) {
			 logger.debug(""Session creation not enabled. Exception: {
			}
			"", e.getMessage());
		 }
		 return engine;
	 }
	 public boolean isUserSslEnabled() {
		 return userSslEnabled;
	 }
	 public boolean isHttpsEnabled() {
		 return false;
	 }
	 public String getKeyStoreType() {
		 return emptyString;
	 }
	 public String getKeyStorePath() {
		 return emptyString;
	 }
	 public String getKeyStorePassword() {
		 return emptyString;
	 }
	 public String getKeyPassword() {
		 return emptyString;
	 }
	 public String getTrustStoreType() {
		 return trustStoreType;
	 }
	 public boolean hasTrustStorePath() {
		 return !trustStorePath.isEmpty();
	 }
	 public String getTrustStorePath() {
		 return trustStorePath;
	 }
	 public boolean hasTrustStorePassword() {
		 return !trustStorePassword.isEmpty();
	 }
	 public String getTrustStorePassword() {
		 return trustStorePassword;
	 }
	 public String getProtocol() {
		 return protocol;
	 }
	 public SslProvider getProvider() {
		 return provider.equalsIgnoreCase(""JDK"") ? SslProvider.JDK : SslProvider.OPENSSL;
	 }
	 public int getHandshakeTimeout() {
		 return handshakeTimeout;
	 }
	 public Mode getMode() {
		 return Mode.CLIENT;
	 }
	 public boolean disableHostVerification() {
		 return disableHostVerification;
	 }
	 public boolean disableCertificateVerification() {
		 return disableCertificateVerification;
	 }
	 public boolean useSystemTrustStore() {
		 return useSystemTrustStore;
	 }
	 public boolean isSslValid() {
		 return true;
	 }
}",1,1,0,0
"private void lostFoundMove(DFSFileInfo file, LocatedBlock[] blocks) throws IOException {
	 DFSClient dfs = new DFSClient(DataNode.createSocketAddr( conf.get(""fs.default.name"", ""local"")), conf);
	 if (!lfInited) {
		 lostFoundInit(dfs);
	 }
	 if (!lfInitedOk) {
		 return;
	 }
	 String target = lostFound.toString() + file.getPath();
	 String errmsg = ""Failed to move "" + file.getPath() + "" to /lost+found"";
	 try {
		 if (!nn.mkdirs(target)) {
			 LOG.warn(errmsg);
			 return;
		 }
		 int chain = 0;
		 FSOutputStream fos = null;
		 for (int i = 0;
		 i < blocks.length;
		 i++) {
			 LocatedBlock lblock = blocks[i];
			 DatanodeInfo[] locs = lblock.getLocations();
			 if (locs == null || locs.length == 0) {
				 if (fos != null) {
					 fos.flush();
					 fos.close();
					 fos = null;
				 }
				 continue;
			 }
			 if (fos == null) {
				 fos = dfs.create(new UTF8(target.toString() + ""/"" + chain), true);
				 if (fos != null) chain++;
			 }
			 if (fos == null) {
				 LOG.warn(errmsg + "": could not store chain "" + chain);
				 continue;
			 }
			 try {
				 copyBlock(dfs, lblock, fos);
			 }
			 catch (Exception e) {
				 e.printStackTrace();
				 LOG.warn("" - could not copy block "" + lblock.getBlock().getBlockName() + "" to "" + target);
				 fos.flush();
				 fos.close();
				 fos = null;
			 }
		 }
		 if (fos != null) fos.close();
		 LOG.warn(""\n - moved corrupted file "" + file.getPath() + "" to /lost+found"");
		 dfs.delete(new UTF8(file.getPath()));
	 }
	 catch (Exception e) {
		 e.printStackTrace();
		 LOG.warn(errmsg + "": "" + e.getMessage());
	 }
 }",0,0,0,0
"class MapOutputLocation implements Writable {
	 static {
		 WritableFactories.setFactory (MapOutputLocation.class, new WritableFactory() {
			 public Writable newInstance() {
				 return new MapOutputLocation();
			 }
		 }
		);
	 }
	 private String mapTaskId;
	 private int mapId;
	 private String host;
	 private int port;
	 public MapOutputLocation() {
	 }
	 public MapOutputLocation(String mapTaskId, int mapId, String host, int port) {
		 this.mapTaskId = mapTaskId;
		 this.mapId = mapId;
		 this.host = host;
		 this.port = port;
	 }
	 public String getMapTaskId() {
		 return mapTaskId;
	 }
	 public int getMapId() {
		 return mapId;
	 }
	 public String getHost() {
		 return host;
	 }
	 public int getPort() {
		 return port;
	 }
	 public void write(DataOutput out) throws IOException {
		 UTF8.writeString(out, mapTaskId);
		 out.writeInt(mapId);
		 UTF8.writeString(out, host);
		 out.writeInt(port);
	 }
	 public void readFields(DataInput in) throws IOException {
		 this.mapTaskId = UTF8.readString(in);
		 this.mapId = in.readInt();
		 this.host = UTF8.readString(in);
		 this.port = in.readInt();
	 }
	 public String toString() {
		 return ""http: mapTaskId;
	 }
	 public long getFile(FileSystem fileSys, Path localFilename, int reduce, Progressable pingee) throws IOException {
		 URL path = new URL(toString() + ""&reduce="" + reduce);
		 InputStream input = path.openConnection().getInputStream();
		 OutputStream output = fileSys.create(localFilename);
		 long totalBytes = 0;
		 try {
			 byte[] buffer = new byte[64 * 1024];
			 int len = input.read(buffer);
			 while (len > 0) {
				 totalBytes += len;
				 output.write(buffer, 0 ,len);
				 if (pingee != null) {
					 pingee.progress();
				 }
				 len = input.read(buffer);
			 }
		 }
		 finally {
			 input.close();
			 output.close();
		 }
		 return totalBytes;
	 }
}",0,0,0,0
"public class AvroWrapper<T> {
	 private T datum;
	 public AvroWrapper() {
		 this(null);
	 }
	 public AvroWrapper(T datum) {
		 this.datum = datum;
	 }
	 public T datum() {
		 return datum;
	 }
	 public void datum(T datum) {
		 this.datum = datum;
	 }
	 public int hashCode() {
		 return (datum == null) ? 0 : datum.hashCode();
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (obj == null) return false;
		 if (getClass() != obj.getClass()) return false;
		 AvroWrapper that = (AvroWrapper)obj;
		 if (this.datum == null) {
			 return that.datum == null;
		 }
		 else return datum.equals(that.datum);
	 }
	 public String toString() {
		 return datum.toString();
	 }
}",0,1,0,0
"public final boolean synpred9_PsiInternalSimpleBeeLangTestLanguage() {
	 state.backtracking++;
	 int start = input.mark();
	 try {
		 synpred9_PsiInternalSimpleBeeLangTestLanguage_fragment();
	 }
	 catch (RecognitionException re) {
		 System.err.println(""impossible: ""+re);
	 }
	 boolean success = !state.failed;
	 input.rewind(start);
	 state.backtracking--;
	 state.failed=false;
	 return success;
 }",0,0,0,0
"class LexerUserinfo extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {
	 private static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 2048;
	 public static final int YYINITIAL = 0;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 1 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\11\13\1\12\1\12\2\13\1\12\22\13\1\11\1\3\1\16\1\0""+ ""\1\3\1\4\7\3\2\2\1\0\1\6\1\7\1\5\7\7\1\1""+ ""\1\3\1\16\1\3\1\16\2\0\6\7\24\2\1\0\1\16\1\0""+ ""\1\16\1\2\1\16\1\10\5\10\24\2\3\16\1\2\6\15\1\14""+ ""\32\15\ud760\21\u0400\17\u0400\20\u2000\21"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7""+ ""\1\10\1\11\1\12\1\13\2\14\1\15\1\16\3\0""+ ""\1\17\1\20\1\21\1\22\1\23"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[25];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\22\0\44\0\44\0\44\0\44\0\66\0\110""+ ""\0\44\0\44\0\44\0\44\0\44\0\132\0\44\0\44""+ ""\0\110\0\154\0\176\0\220\0\44\0\44\0\44\0\44""+ ""\0\44"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[25];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\3\1\4\1\5\1\6\1\7\4\5\1\10\1\11""+ ""\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\3""+ ""\1\4\1\5\1\6\1\7\4\5\1\21\1\11\1\12""+ ""\1\13\1\14\1\15\1\16\1\17\1\20\27\0\1\22""+ ""\2\23\1\24\22\0\1\25\30\0\1\26\6\0\1\27""+ ""\1\30\1\27\1\31\16\0\3\27\1\31\16\0\4\31""+ ""\11\0"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[162];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\2\0\4\11\2\1\5\11\1\1\2\11\1\1\3\0""+ ""\5\11"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[25];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 private int lastChar;
	 char[] zzBuffer() {
		 yyreset(null);
		 this.zzAtEOF = true;
		 int length = parser.end(range)-parser.start(range);
		 lastChar = length - 1;
		 zzEndRead = length;
		 while (length > zzBuffer.length) zzBuffer = new char[zzBuffer.length*2];
		 return zzBuffer;
	 }
	 LexerUserinfo(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 LexerUserinfo(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 90) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead > 0) {
			 zzEndRead+= numRead;
			 return false;
		 }
		 if (numRead == 0) {
			 int c = zzReader.read();
			 if (c == -1) {
				 return true;
			 }
			 else {
				 zzBuffer[zzEndRead++] = (char) c;
				 return false;
			 }
		 }
		 return true;
	 }
	 private final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 private final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEOFDone = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 private final int yystate() {
		 return zzLexicalState;
	 }
	 private final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 private final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 private final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 public void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	public int yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 yychar+= zzMarkedPosL-zzStartRead;
			 if (zzMarkedPosL > zzStartRead) {
				 switch (zzBufferL[zzMarkedPosL-1]) {
					 case '\n': case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': zzAtBOL = true;
					 break;
					 case '\r': if (zzMarkedPosL < zzEndReadL) zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 else if (zzAtEOF) zzAtBOL = false;
					 else {
						 boolean eof = zzRefill();
						 zzMarkedPosL = zzMarkedPos;
						 zzEndReadL = zzEndRead;
						 zzBufferL = zzBuffer;
						 if (eof) zzAtBOL = false;
						 else zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 }
					 break;
					 default: zzAtBOL = false;
				 }
			 }
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 if (zzAtBOL) zzState = ZZ_LEXSTATE[zzLexicalState+1];
			 else zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 15: {
					 rule(-70);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 20: break;
				 case 10: {
					 rule(-115);
					 error(DISCOURAGED_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 21: break;
				 case 13: {
					 rule(-150);
					 difficultChar();
				 }
				 case 22: break;
				 case 16: {
					 rule(-130);
					 surrogatePair();
				 }
				 case 23: break;
				 case 17: {
					 rule(-40);
					 error(PERCENT);
				 }
				 case 24: break;
				 case 12: {
					 rule(-140);
					 error(LONE_SURROGATE);
					 difficultChar();
				 }
				 case 25: break;
				 case 14: {
					 rule(-80);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 26: break;
				 case 19: {
					 rule(-50);
					 error(PERCENT);
					 error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
				 }
				 case 27: break;
				 case 6: {
					 rule(-90);
					 if (yychar==lastChar) error(DOUBLE_WHITESPACE);
					 else error(WHITESPACE);
				 }
				 case 28: break;
				 case 11: {
					 rule(-120);
					 error(UNWISE_CHARACTER);
				 }
				 case 29: break;
				 case 9: {
					 rule(-113);
					 error(CONTROL_CHARACTER);
				 }
				 case 30: break;
				 case 3: {
					 rule(-10);
				 }
				 case 31: break;
				 case 18: {
					 rule(-30);
					 error(PERCENT_20);
				 }
				 case 32: break;
				 case 5: {
					 rule(-60);
					 error(ILLEGAL_PERCENT_ENCODING);
				 }
				 case 33: break;
				 case 4: {
					 rule(-20);
				 }
				 case 34: break;
				 case 7: {
					 rule(-100);
					 error(CONTROL_CHARACTER);
					 error(NOT_XML_SCHEMA_WHITESPACE);
				 }
				 case 35: break;
				 case 1: {
					 rule(-160);
					 error(ILLEGAL_CHARACTER);
				 }
				 case 36: break;
				 case 2: {
					 rule(1);
					 error(HAS_PASSWORD);
				 }
				 case 37: break;
				 case 8: {
					 rule(-110);
					 error(NON_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 38: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 return YYEOF;
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class MultiDexConfig {
	 private String name;
	 public MultiDexConfig(String name) {
		 this.name = name;
	 }
	 private boolean fastMultiDex = false;
	 private Set<String> firstDexClasses = Sets.newHashSet();
	 private int dexCount;
	 public int getMainDexListCount() {
		 return mainDexListCount;
	 }
	 public void setMainDexListCount(int mainDexListCount) {
		 this.mainDexListCount = mainDexListCount;
	 }
	 private int mainDexListCount;
	 private String dexSplitRules;
	 private Set<String> mainDexBlackList = Sets.newHashSet();
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public boolean isFastMultiDex() {
		 return fastMultiDex;
	 }
	 public void setFastMultiDex(boolean fastMultiDex) {
		 this.fastMultiDex = fastMultiDex;
	 }
	 public Set<String> getMainDexBlackList() {
		 return mainDexBlackList;
	 }
	 public void setMainDexBlackList(Set<String> mainDexBlackList) {
		 this.mainDexBlackList = mainDexBlackList;
	 }
	 public Set<String> getFirstDexClasses() {
		 return firstDexClasses;
	 }
	 public void setFirstDexClasses(Set<String> firstDexClasses) {
		 this.firstDexClasses = firstDexClasses;
	 }
	 public int getDexCount() {
		 return dexCount;
	 }
	 public void setDexCount(int dexCount) {
		 this.dexCount = dexCount;
	 }
	 public String getDexSplitRules() {
		 return dexSplitRules;
	 }
	 public void setDexSplitRules(String dexSplitRules) {
		 this.dexSplitRules = dexSplitRules;
	 }
}",1,1,0,0
"public abstract class LayoutEvent implements Event {
	 protected Layout target;
	 public LayoutEvent(Layout target) {
		 this.target = target;
	 }
	 public Layout getTarget() {
		 return this.target;
	 }
}",0,0,0,0
"private void expandEntity(EntityDecl ed, boolean allowExt) throws XMLStreamException {
	 String id = ed.getName();
	 if (mInput.isOrIsExpandedFrom(id)) {
		 throwRecursionError(id);
	 }
	 if (!ed.isParsed()) {
		 throwParseError(""Illegal reference to unparsed external entity \""{
		0}
		\"""", id, null);
	 }
	 boolean isExt = ed.isExternal();
	 if (isExt) {
		 if (!allowExt) {
			 throwParseError(""Encountered a reference to external parsed entity \""{
			0}
			\"" when expanding attribute value: not legal as per XML 1.0/1.1 #3.1"", id, null);
		 }
		 if (!mConfig.willSupportExternalEntities()) {
			 throwParseError(""Encountered a reference to external entity \""{
			0}
			\"", but stream reader has feature \""{
			1}
			\"" disabled"", id, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES);
		 }
	 }
	 WstxInputSource oldInput = mInput;
	 oldInput.saveContext(this);
	 WstxInputSource newInput = null;
	 try {
		 newInput = ed.expand(oldInput, mEntityResolver, mConfig, mDocXmlVersion);
	 }
	 catch (FileNotFoundException fex) {
		 throwParseError(""(was {
		0}
		) {
		1}
		"", fex.getClass().getName(), fex.getMessage());
	 }
	 catch (IOException ioe) {
		 throw constructFromIOE(ioe);
	 }
	 initInputSource(newInput, isExt, id);
 }",0,0,1,0
"public void execute() {
	 if (length != null && adjust != null) {
		 throw new BuildException( ""length and adjust are mutually exclusive options"");
	 }
	 if (length == null && adjust == null) {
		 length = ZERO;
	 }
	 if (path == null) {
		 throw new BuildException(NO_CHILD);
	 }
	 for (Iterator it = path.iterator();
	 it.hasNext();
	) {
		 Resource r = (Resource) it.next();
		 File f = ((FileProvider) r.as(FileProvider.class)).getFile();
		 if (shouldProcess(f)) {
			 process(f);
		 }
	 }
 }",0,0,0,0
"protected class UnifyRuleCall {
	 protected final UnifyRule rule;
	 public final MutableRel query;
	 public final MutableRel target;
	 protected final ImmutableList<MutableRel> slots;
	 public UnifyRuleCall(UnifyRule rule, MutableRel query, MutableRel target, ImmutableList<MutableRel> slots) {
		 this.rule = Objects.requireNonNull(rule);
		 this.query = Objects.requireNonNull(query);
		 this.target = Objects.requireNonNull(target);
		 this.slots = Objects.requireNonNull(slots);
	 }
	 public UnifyResult result(MutableRel result) {
		 assert MutableRels.contains(result, target);
		 assert equalType(""result"", result, ""query"", query, Litmus.THROW);
		 MutableRel replace = replacementMap.get(target);
		 if (replace != null) {
			 assert false;
			 replace(result, target, replace);
		 }
		 register(result, query);
		 return new UnifyResult(this, result);
	 }
	 public UnifyRuleCall create(MutableRel query) {
		 return new UnifyRuleCall(rule, query, target, slots);
	 }
	 public RelOptCluster getCluster() {
		 return cluster;
	 }
	 public RexSimplify getSimplify() {
		 return simplify;
	 }
 }",0,1,0,0
"protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
	 boolean rebuild = false;
	 JarFile genericJar = null;
	 JarFile wasJar = null;
	 File newwasJarFile = null;
	 JarOutputStream newJarStream = null;
	 try {
		 log(""Checking if websphere Jar needs to be rebuilt for jar "" + websphereJarFile.getName(), Project.MSG_VERBOSE);
		 if (genericJarFile.exists() && genericJarFile.isFile() && websphereJarFile.exists() && websphereJarFile.isFile()) {
			 genericJar = new JarFile(genericJarFile);
			 wasJar = new JarFile(websphereJarFile);
			 Hashtable genericEntries = new Hashtable();
			 Hashtable wasEntries = new Hashtable();
			 Hashtable replaceEntries = new Hashtable();
			 for (Enumeration e = genericJar.entries();
			 e.hasMoreElements();
			) {
				 JarEntry je = (JarEntry) e.nextElement();
				 genericEntries.put(je.getName().replace('\\', '/'), je);
			 }
			 for (Enumeration e = wasJar.entries();
			 e.hasMoreElements();
			) {
				 JarEntry je = (JarEntry) e.nextElement();
				 wasEntries.put(je.getName(), je);
			 }
			 ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);
			 for (Enumeration e = genericEntries.keys();
			 e.hasMoreElements();
			) {
				 String filepath = (String) e.nextElement();
				 if (wasEntries.containsKey(filepath)) {
					 JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
					 JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);
					 if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {
						 if (genericEntry.getName().endsWith("".class"")) {
							 String classname = genericEntry.getName().replace(File.separatorChar, '.');
							 classname = classname.substring(0, classname.lastIndexOf("".class""));
							 Class genclass = genericLoader.loadClass(classname);
							 if (genclass.isInterface()) {
								 log(""Interface "" + genclass.getName() + "" has changed"", Project.MSG_VERBOSE);
								 rebuild = true;
								 break;
							 }
							 else {
								 replaceEntries.put(filepath, genericEntry);
							 }
						 }
						 else {
							 if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
								 log(""Non class file "" + genericEntry.getName() + "" has changed"", Project.MSG_VERBOSE);
								 rebuild = true;
							 }
							 break;
						 }
					 }
				 }
				 else {
					 log(""File "" + filepath + "" not present in websphere jar"", Project.MSG_VERBOSE);
					 rebuild = true;
					 break;
				 }
			 }
			 if (!rebuild) {
				 log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
				 newwasJarFile = new File(websphereJarFile.getAbsolutePath() + "".temp"");
				 if (newwasJarFile.exists()) {
					 newwasJarFile.delete();
				 }
				 newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
				 newJarStream.setLevel(0);
				 for (Enumeration e = wasEntries.elements();
				 e.hasMoreElements();
				) {
					 byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
					 int bytesRead;
					 InputStream is;
					 JarEntry je = (JarEntry) e.nextElement();
					 if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) {
						 newJarStream.setLevel(0);
					 }
					 else {
						 newJarStream.setLevel(JAR_COMPRESS_LEVEL);
					 }
					 if (replaceEntries.containsKey(je.getName())) {
						 log(""Updating Bean class from generic Jar "" + je.getName(), Project.MSG_VERBOSE);
						 je = (JarEntry) replaceEntries.get(je.getName());
						 is = genericJar.getInputStream(je);
					 }
					 else {
						 is = wasJar.getInputStream(je);
					 }
					 newJarStream.putNextEntry(new JarEntry(je.getName()));
					 while ((bytesRead = is.read(buffer)) != -1) {
						 newJarStream.write(buffer, 0, bytesRead);
					 }
					 is.close();
				 }
			 }
			 else {
				 log(""websphere Jar rebuild needed due to changed "" + ""interface or XML"", Project.MSG_VERBOSE);
			 }
		 }
		 else {
			 rebuild = true;
		 }
	 }
	 catch (ClassNotFoundException cnfe) {
		 String cnfmsg = ""ClassNotFoundException while processing ejb-jar file"" + "". Details: "" + cnfe.getMessage();
		 throw new BuildException(cnfmsg, cnfe);
	 }
	 catch (IOException ioe) {
		 String msg = ""IOException while processing ejb-jar file "" + "". Details: "" + ioe.getMessage();
		 throw new BuildException(msg, ioe);
	 }
	 finally {
		 if (genericJar != null) {
			 try {
				 genericJar.close();
			 }
			 catch (IOException closeException) {
			 }
		 }
		 if (wasJar != null) {
			 try {
				 wasJar.close();
			 }
			 catch (IOException closeException) {
			 }
		 }
		 if (newJarStream != null) {
			 try {
				 newJarStream.close();
			 }
			 catch (IOException closeException) {
			 }
			 try {
				 FILE_UTILS.rename(newwasJarFile, websphereJarFile);
			 }
			 catch (IOException renameException) {
				 log(renameException.getMessage(), Project.MSG_WARN);
				 rebuild = true;
			 }
		 }
	 }
	 return rebuild;
 }",0,0,1,0
"public class AsyncRcvdMsgCheckpointImpl<M extends Writable> implements BSPFaultTolerantService<M> {
	 private static final Log LOG = LogFactory .getLog(AsyncRcvdMsgCheckpointImpl.class);
	 private static class CheckpointMasterService implements FaultTolerantMasterService {
		 private Configuration conf;
		 private TaskInProgress tasks[];
		 private BSPJobID jobId;
		 private int maxTaskAttempts;
		 private int currentAttemptId;
		 private MasterSyncClient masterSyncClient;
		 private TaskAllocationStrategy allocationStrategy;
		 public void initialize(BSPJobID jobId, int maxTaskAttempts, TaskInProgress[] tasks, Configuration conf, MasterSyncClient masterClient, TaskAllocationStrategy allocationStrategy) {
			 this.tasks = tasks;
			 this.jobId = jobId;
			 this.conf = conf;
			 this.maxTaskAttempts = maxTaskAttempts;
			 this.currentAttemptId = 0;
			 this.masterSyncClient = masterClient;
			 this.allocationStrategy = allocationStrategy;
		 }
		 public boolean isRecoveryPossible(TaskInProgress tip) {
			 return currentAttemptId < maxTaskAttempts;
		 }
		 public boolean isAlreadyRecovered(TaskInProgress tip) {
			 return currentAttemptId < tip.getCurrentTaskAttemptId().getId();
		 }
		 public void recoverTasks(JobInProgress jip, Map<String, GroomServerStatus> groomStatuses, TaskInProgress[] failedTasksInProgress, TaskInProgress[] allTasksInProgress, Map<GroomServerStatus, Integer> taskCountInGroomMap, Map<GroomServerStatus, List<GroomServerAction>> actionMap) throws IOException {
			 Map<TaskID, TaskInProgress> recoverySet = new HashMap<TaskID, TaskInProgress>( 2 * failedTasksInProgress.length);
			 for (TaskInProgress failedTasksInProgres : failedTasksInProgress) {
				 recoverySet.put(failedTasksInProgres.getTaskId(), failedTasksInProgres);
			 }
			 long lowestSuperstepNumber = Long.MAX_VALUE;
			 String[] taskProgress = this.masterSyncClient.getChildKeySet( this.masterSyncClient.constructKey(jobId, ""checkpoint""), null);
			 if (LOG.isDebugEnabled()) {
				 StringBuffer list = new StringBuffer(25 * taskProgress.length);
				 list.append(""got child key set"").append(taskProgress.length) .append(""/"").append(tasks.length).append("" "");
				 for (String entry : taskProgress) {
					 list.append(entry).append("","");
				 }
				 LOG.debug(list);
			 }
			 if (taskProgress.length == this.tasks.length) {
				 for (String taskProgres : taskProgress) {
					 ArrayWritable progressInformation = new ArrayWritable( LongWritable.class);
					 boolean result = this.masterSyncClient.getInformation( this.masterSyncClient.constructKey(jobId, ""checkpoint"", taskProgres), progressInformation);
					 if (!result) {
						 lowestSuperstepNumber = -1L;
						 break;
					 }
					 Writable[] progressArr = progressInformation.get();
					 LongWritable superstepProgress = (LongWritable) progressArr[0];
					 if (superstepProgress != null) {
						 if (superstepProgress.get() < lowestSuperstepNumber) {
							 lowestSuperstepNumber = superstepProgress.get();
							 if (LOG.isDebugEnabled()) {
								 LOG.debug(""Got superstep number "" + lowestSuperstepNumber + "" from "" + taskProgres);
							 }
						 }
					 }
				 }
				 clearClientForSuperstep(lowestSuperstepNumber);
				 restartJob(lowestSuperstepNumber, groomStatuses, recoverySet, allTasksInProgress, taskCountInGroomMap, actionMap);
			 }
			 else {
				 restartJob(-1, groomStatuses, recoverySet, allTasksInProgress, taskCountInGroomMap, actionMap);
			 }
			 ++currentAttemptId;
		 }
		 private void clearClientForSuperstep(long superstep) {
			 this.masterSyncClient.remove( masterSyncClient.constructKey(jobId, ""sync""), null);
		 }
		 private void populateAction(Task task, long superstep, GroomServerStatus groomStatus, Map<GroomServerStatus, List<GroomServerAction>> actionMap) {
			 List<GroomServerAction> list = actionMap.get(groomStatus);
			 if (!actionMap.containsKey(groomStatus)) {
				 list = new ArrayList<GroomServerAction>();
				 actionMap.put(groomStatus, list);
			 }
			 list.add(new RecoverTaskAction(task, superstep));
		 }
		 private void restartTask(TaskInProgress tip, long superstep, Map<String, GroomServerStatus> groomStatuses, Map<GroomServerStatus, List<GroomServerAction>> actionMap) {
			 GroomServerStatus serverStatus = tip.getGroomServerStatus();
			 Task task = tip.constructTask(serverStatus);
			 populateAction(task, superstep, serverStatus, actionMap);
		 }
		 private void restartJob(long superstep, Map<String, GroomServerStatus> groomStatuses, Map<TaskID, TaskInProgress> recoveryMap, TaskInProgress[] allTasks, Map<GroomServerStatus, Integer> taskCountInGroomMap, Map<GroomServerStatus, List<GroomServerAction>> actionMap) throws IOException {
			 String path = conf.get(""bsp.checkpoint.prefix_path"", ""/checkpoint/"");
			 if (superstep >= 0) {
				 FileSystem fileSystem = FileSystem.get(conf);
				 for (TaskInProgress allTask : allTasks) {
					 String[] hosts = null;
					 if (recoveryMap.containsKey(allTask.getTaskId())) {
						 Integer count = taskCountInGroomMap.get(allTask .getGroomServerStatus());
						 if (count != null) {
							 count = count.intValue() - 1;
							 taskCountInGroomMap.put(allTask.getGroomServerStatus(), count);
						 }
						 StringBuffer ckptPath = new StringBuffer(path);
						 ckptPath.append(this.jobId.toString());
						 ckptPath.append(""/"").append(superstep).append(""/"") .append(allTask.getTaskId().getId());
						 Path checkpointPath = new Path(ckptPath.toString());
						 if (fileSystem.exists(checkpointPath)) {
							 FileStatus fileStatus = fileSystem.getFileStatus(checkpointPath);
							 BlockLocation[] blocks = fileSystem.getFileBlockLocations( fileStatus, 0, fileStatus.getLen());
							 hosts = blocks[0].getHosts();
						 }
						 else {
							 hosts = new String[groomStatuses.keySet().size()];
							 groomStatuses.keySet().toArray(hosts);
						 }
						 GroomServerStatus serverStatus = this.allocationStrategy .getGroomToAllocate(groomStatuses, hosts, taskCountInGroomMap, new BSPResource[0], allTask);
						 Task task = allTask.constructTask(serverStatus);
						 populateAction(task, superstep, serverStatus, actionMap);
					 }
					 else {
						 restartTask(allTask, superstep, groomStatuses, actionMap);
					 }
				 }
			 }
			 else {
				 for (TaskInProgress allTask : allTasks) {
					 if (recoveryMap.containsKey(allTask.getTaskId())) {
						 this.allocationStrategy.getGroomToAllocate(groomStatuses, this.allocationStrategy.selectGrooms(groomStatuses, taskCountInGroomMap, new BSPResource[0], allTask), taskCountInGroomMap, new BSPResource[0], allTask);
					 }
					 else {
						 restartTask(allTask, superstep, groomStatuses, actionMap);
					 }
				 }
			 }
		 }
	 }
	 public FaultTolerantPeerService<M> constructPeerFaultTolerance(BSPJob job, BSPPeer bspPeer, PeerSyncClient syncClient, InetSocketAddress peerAddress, TaskAttemptID taskAttemptId, long superstep, Configuration conf, MessageManager<M> messenger) throws Exception {
		 CheckpointPeerService<M> service = new CheckpointPeerService<M>();
		 service.initialize(job, bspPeer, syncClient, peerAddress, taskAttemptId, superstep, conf, messenger);
		 return service;
	 }
	 public FaultTolerantMasterService constructMasterFaultTolerance( BSPJobID jobId, int maxTaskAttempts, TaskInProgress[] tasks, Configuration conf, MasterSyncClient masterClient, TaskAllocationStrategy allocationStrategy) throws Exception {
		 CheckpointMasterService service = new CheckpointMasterService();
		 service.initialize(jobId, maxTaskAttempts, tasks, conf, masterClient, allocationStrategy);
		 return service;
	 }
	 public static class CheckpointPeerService<M extends Writable> implements FaultTolerantPeerService<M>, MessageEventListener<M> {
		 private BSPJob job;
		 private BSPPeer peer;
		 private PeerSyncClient syncClient;
		 private long superstep;
		 private Configuration conf;
		 private MessageManager<M> messenger;
		 private FileSystem fs;
		 private int checkPointInterval;
		 volatile private long lastCheckPointStep;
		 volatile private boolean checkpointState;
		 volatile private FSDataOutputStream checkpointStream;
		 volatile private long checkpointMessageCount;
		 public void initialize(BSPJob job, BSPPeer bspPeer, PeerSyncClient syncClient, InetSocketAddress peerAddress, TaskAttemptID taskAttemptId, long superstep, Configuration conf, MessageManager<M> messenger) throws IOException {
			 this.job = job;
			 this.peer = bspPeer;
			 this.syncClient = syncClient;
			 this.superstep = superstep;
			 this.conf = conf;
			 this.messenger = messenger;
			 this.fs = FileSystem.get(conf);
			 this.checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL, Constants.DEFAULT_CHECKPOINT_INTERVAL);
			 this.checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL, Constants.DEFAULT_CHECKPOINT_INTERVAL);
			 this.checkpointState = conf.getBoolean(Constants.CHECKPOINT_ENABLED, false);
			 if (superstep > 0) {
				 this.lastCheckPointStep = this.superstep;
			 }
			 else {
				 this.lastCheckPointStep = 1;
			 }
			 this.checkpointMessageCount = 0L;
		 }
		 private String checkpointPath(long step) {
			 String backup = conf.get(""bsp.checkpoint.prefix_path"", ""checkpoint/"");
			 String ckptPath = backup + job.getJobID().toString() + ""/"" + (step) + ""/"" + peer.getPeerIndex();
			 if (LOG.isDebugEnabled()) LOG.debug(""Received Messages are to be saved to "" + ckptPath);
			 return ckptPath;
		 }
		 public TaskStatus.State onPeerInitialized(TaskStatus.State state) throws Exception {
			 if (this.superstep >= 0 && state.equals(TaskStatus.State.RECOVERING)) {
				 ArrayWritable progressArr = new ArrayWritable(LongWritable.class);
				 boolean result = this.syncClient.getInformation( this.syncClient.constructKey(job.getJobID(), ""checkpoint"", String.valueOf(peer.getPeerIndex())), progressArr);
				 if (!result) {
					 throw new IOException(""No data found to restore peer state."");
				 }
				 Writable[] progressInfo = progressArr.get();
				 long superstepProgress = ((LongWritable) progressInfo[0]).get();
				 long numMessages = ((LongWritable) progressInfo[1]).get();
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Got sstep ="" + superstepProgress + "" numMessages = "" + numMessages + "" this.superstep = "" + this.superstep);
				 }
				 if (numMessages > 0) {
					 Path path = new Path(checkpointPath(superstepProgress));
					 FSDataInputStream in = this.fs.open(path);
					 BSPMessageBundle<M> bundle = new BSPMessageBundle<M>();
					 try {
						 for (int i = 0;
						 i < numMessages;
						 ++i) {
							 String className = in.readUTF();
							 if (className.equals(BSPMessageBundle.class.getCanonicalName())) {
								 BSPMessageBundle<M> tmp = new BSPMessageBundle<M>();
								 tmp.readFields(in);
								 messenger.loopBackBundle(tmp);
							 }
							 else {
								 M message = (M) ReflectionUtils.newInstance( Class.forName(className), conf);
								 message.readFields(in);
								 bundle.addMessage(message);
							 }
						 }
						 if (bundle.size() > 0) {
							 messenger.loopBackBundle(bundle);
						 }
					 }
					 catch (EOFException e) {
						 LOG.error(""Error recovering from checkpointing"", e);
						 throw new IOException(e);
					 }
					 finally {
						 this.fs.close();
					 }
				 }
			 }
			 this.messenger.registerListener(this);
			 return TaskStatus.State.RUNNING;
		 }
		 public final boolean isReadyToCheckpoint() {
			 checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL, 1);
			 LOG.info(new StringBuffer(1000).append(""Enabled = "") .append(conf.getBoolean(Constants.CHECKPOINT_ENABLED, false)) .append("" checkPointInterval = "").append(checkPointInterval) .append("" lastCheckPointStep = "").append(lastCheckPointStep) .append("" getSuperstepCount() = "").append(peer.getSuperstepCount()) .toString());
			 if (LOG.isDebugEnabled()) LOG.debug(new StringBuffer(1000).append(""Enabled = "") .append(conf.getBoolean(Constants.CHECKPOINT_ENABLED, false)) .append("" checkPointInterval = "").append(checkPointInterval) .append("" lastCheckPointStep = "").append(lastCheckPointStep) .append("" getSuperstepCount() = "").append(peer.getSuperstepCount()) .toString());
			 return (conf.getBoolean(Constants.CHECKPOINT_ENABLED, false) && (checkPointInterval != 0) && (((int) ((peer.getSuperstepCount() + 1) - lastCheckPointStep)) >= checkPointInterval));
		 }
		 public void beforeBarrier() throws Exception {
		 }
		 public void duringBarrier() throws Exception {
		 }
		 public void afterBarrier() throws Exception {
			 synchronized (this) {
				 if (checkpointState) {
					 if (checkpointStream != null) {
						 this.checkpointStream.close();
						 this.checkpointStream = null;
					 }
					 lastCheckPointStep = peer.getSuperstepCount();
					 ArrayWritable writableArray = new ArrayWritable(LongWritable.class);
					 Writable[] writeArr = new Writable[2];
					 writeArr[0] = new LongWritable(lastCheckPointStep);
					 writeArr[1] = new LongWritable(checkpointMessageCount);
					 writableArray.set(writeArr);
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""Storing lastCheckPointStep = "" + lastCheckPointStep + "" checkpointMessageCount = "" + checkpointMessageCount + "" for peer = "" + String.valueOf(peer.getPeerIndex()));
					 }
					 this.syncClient.storeInformation(this.syncClient.constructKey( this.job.getJobID(), ""checkpoint"", String.valueOf(peer.getPeerIndex())), writableArray, true, null);
				 }
				 checkpointState = isReadyToCheckpoint();
				 checkpointMessageCount = 0;
			 }
			 LOG.info(""checkpointNext = "" + checkpointState + "" checkpointMessageCount = "" + checkpointMessageCount);
		 }
		 public void onInitialized() {
		 }
		 public void onMessageSent(String peerName, M message) {
		 }
		 public void onMessageReceived(M message) {
			 String checkpointedPath = null;
			 if (message == null) {
				 LOG.error(""Message M is found to be null"");
			 }
			 synchronized (this) {
				 if (checkpointState) {
					 if (this.checkpointStream == null) {
						 checkpointedPath = checkpointPath(peer.getSuperstepCount() + 1);
						 try {
							 LOG.info(""Creating path "" + checkpointedPath);
							 if (LOG.isDebugEnabled()) {
								 LOG.debug(""Creating path "" + checkpointedPath);
							 }
							 checkpointStream = this.fs.create(new Path(checkpointedPath));
						 }
						 catch (IOException ioe) {
							 LOG.error(""Fail checkpointing messages to "" + checkpointedPath, ioe);
							 throw new RuntimeException(""Failed opening HDFS file "" + checkpointedPath, ioe);
						 }
					 }
					 try {
						 ++checkpointMessageCount;
						 checkpointStream.writeUTF(message.getClass().getCanonicalName());
						 message.write(checkpointStream);
					 }
					 catch (IOException ioe) {
						 LOG.error(""Fail checkpointing messages to "" + checkpointedPath, ioe);
						 throw new RuntimeException(""Failed writing to HDFS file "" + checkpointedPath, ioe);
					 }
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""message count = "" + checkpointMessageCount);
					 }
				 }
			 }
		 }
		 public void onClose() {
		 }
		 public void onBundleReceived(BSPMessageBundle<M> bundle) {
			 String checkpointedPath = null;
			 if (bundle == null) {
				 LOG.error(""bundle is found to be null"");
			 }
			 synchronized (this) {
				 if (checkpointState) {
					 if (this.checkpointStream == null) {
						 checkpointedPath = checkpointPath(peer.getSuperstepCount() + 1);
						 try {
							 LOG.info(""Creating path "" + checkpointedPath);
							 if (LOG.isDebugEnabled()) {
								 LOG.debug(""Creating path "" + checkpointedPath);
							 }
							 checkpointStream = this.fs.create(new Path(checkpointedPath));
						 }
						 catch (IOException ioe) {
							 LOG.error(""Fail checkpointing messages to "" + checkpointedPath, ioe);
							 throw new RuntimeException(""Failed opening HDFS file "" + checkpointedPath, ioe);
						 }
					 }
					 try {
						 ++checkpointMessageCount;
						 checkpointStream.writeUTF(bundle.getClass().getCanonicalName());
						 bundle.write(checkpointStream);
					 }
					 catch (IOException ioe) {
						 LOG.error(""Fail checkpointing messages to "" + checkpointedPath, ioe);
						 throw new RuntimeException(""Failed writing to HDFS file "" + checkpointedPath, ioe);
					 }
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""message count = "" + checkpointMessageCount);
					 }
				 }
			 }
		 }
	 }
}",1,0,0,0
"public abstract class ModificationStatement extends CFStatement implements CQLStatement{
	 public static final ConsistencyLevel defaultConsistency = ConsistencyLevel.ONE;
	 protected final ConsistencyLevel cLevel;
	 protected Long timestamp;
	 protected final int timeToLive;
	 public ModificationStatement(CFName name, Attributes attrs) {
		 this(name, attrs.cLevel, attrs.timestamp, attrs.timeToLive);
	 }
	 public ModificationStatement(CFName name, ConsistencyLevel cLevel, Long timestamp, int timeToLive) {
		 super(name);
		 this.cLevel = cLevel;
		 this.timestamp = timestamp;
		 this.timeToLive = timeToLive;
	 }
	 public void checkAccess(ClientState state) throws InvalidRequestException {
		 state.hasColumnFamilyAccess(keyspace(), columnFamily(), Permission.WRITE);
	 }
	 public void validate(ClientState state) throws InvalidRequestException {
		 if (timeToLive < 0) throw new InvalidRequestException(""A TTL must be greater or equal to 0"");
		 ThriftValidation.validateConsistencyLevel(keyspace(), getConsistencyLevel(), RequestType.WRITE);
	 }
	 public CqlResult execute(ClientState state, List<ByteBuffer> variables) throws InvalidRequestException, UnavailableException, TimedOutException {
		 try {
			 StorageProxy.mutate(getMutations(state, variables), getConsistencyLevel());
		 }
		 catch (TimeoutException e) {
			 throw new TimedOutException();
		 }
		 return null;
	 }
	 public ConsistencyLevel getConsistencyLevel() {
		 return (cLevel != null) ? cLevel : defaultConsistency;
	 }
	 public boolean isSetConsistencyLevel() {
		 return cLevel != null;
	 }
	 public long getTimestamp(ClientState clientState) {
		 return timestamp == null ? clientState.getTimestamp() : timestamp;
	 }
	 public boolean isSetTimestamp() {
		 return timestamp != null;
	 }
	 public int getTimeToLive() {
		 return timeToLive;
	 }
	 public abstract List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables) throws InvalidRequestException;
}",0,0,0,0
"public ByteBuffer name() {
	 return name_;
 }",0,0,0,0
"private class ConfigFilePropertySource extends FilePropertySource {
	private IFile file;
	public ConfigFilePropertySource(IFile file) {
		super(file);
		this.file = file;
	}
	public String toString() {
		return file.getFullPath().toString();
	}
}",0,1,0,0
"public class Interpreter{
	 private static final int Icode_DUP = -1, Icode_DUP2 = -2, Icode_SWAP = -3, Icode_POP = -4, Icode_POP_RESULT = -5, Icode_IFEQ_POP = -6, Icode_VAR_INC_DEC = -7, Icode_NAME_INC_DEC = -8, Icode_PROP_INC_DEC = -9, Icode_ELEM_INC_DEC = -10, Icode_REF_INC_DEC = -11, Icode_SCOPE_LOAD = -12, Icode_SCOPE_SAVE = -13, Icode_TYPEOFNAME = -14, Icode_NAME_AND_THIS = -15, Icode_PROP_AND_THIS = -16, Icode_ELEM_AND_THIS = -17, Icode_VALUE_AND_THIS = -18, Icode_CLOSURE_EXPR = -19, Icode_CLOSURE_STMT = -20, Icode_CALLSPECIAL = -21, Icode_RETUNDEF = -22, Icode_GOSUB = -23, Icode_STARTSUB = -24, Icode_RETSUB = -25, Icode_LINE = -26, Icode_SHORTNUMBER = -27, Icode_INTNUMBER = -28, Icode_LITERAL_NEW = -29, Icode_LITERAL_SET = -30, Icode_SPARE_ARRAYLIT = -31, Icode_REG_IND_C0 = -32, Icode_REG_IND_C1 = -33, Icode_REG_IND_C2 = -34, Icode_REG_IND_C3 = -35, Icode_REG_IND_C4 = -36, Icode_REG_IND_C5 = -37, Icode_REG_IND1 = -38, Icode_REG_IND2 = -39, Icode_REG_IND4 = -40, Icode_REG_STR_C0 = -41, Icode_REG_STR_C1 = -42, Icode_REG_STR_C2 = -43, Icode_REG_STR_C3 = -44, Icode_REG_STR1 = -45, Icode_REG_STR2 = -46, Icode_REG_STR4 = -47, Icode_GETVAR1 = -48, Icode_SETVAR1 = -49, Icode_UNDEF = -50, Icode_ZERO = -51, Icode_ONE = -52, Icode_ENTERDQ = -53, Icode_LEAVEDQ = -54, Icode_TAIL_CALL = -55, Icode_LOCAL_CLEAR = -56, MIN_ICODE = -56;
	 private CompilerEnvirons compilerEnv;
	 private boolean itsInFunctionFlag;
	 private InterpreterData itsData;
	 private ScriptOrFnNode scriptOrFn;
	 private int itsICodeTop;
	 private int itsStackDepth;
	 private int itsLineNumber;
	 private int itsDoubleTableTop;
	 private ObjToIntMap itsStrings = new ObjToIntMap(20);
	 private int itsLocalTop;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsLiteralIds = new ObjArray();
	 private int itsExceptionTableTop;
	 private static final int EXCEPTION_TRY_START_SLOT = 0;
	 private static final int EXCEPTION_TRY_END_SLOT = 1;
	 private static final int EXCEPTION_HANDLER_SLOT = 2;
	 private static final int EXCEPTION_TYPE_SLOT = 3;
	 private static final int EXCEPTION_LOCAL_SLOT = 4;
	 private static final int EXCEPTION_SCOPE_SLOT = 5;
	 private static final int EXCEPTION_SLOT_SIZE = 6;
	 private static final int ECF_TAIL = 1 << 0;
	 private static class CallFrame implements Cloneable, Serializable {
		 static final long serialVersionUID = -2843792508994958978L;
		 CallFrame parentFrame;
		 int frameIndex;
		 boolean frozen;
		 InterpretedFunction fnOrScript;
		 InterpreterData idata;
		 Object[] stack;
		 double[] sDbl;
		 CallFrame varSource;
		 int localShift;
		 int emptyStackTop;
		 DebugFrame debuggerFrame;
		 boolean useActivation;
		 Scriptable thisObj;
		 Scriptable[] scriptRegExps;
		 Object result;
		 double resultDbl;
		 int pc;
		 int pcPrevBranch;
		 int pcSourceLineStart;
		 Scriptable scope;
		 int savedStackTop;
		 int savedCallOp;
		 CallFrame cloneFrozen() {
			 if (!frozen) Kit.codeBug();
			 CallFrame copy;
			 try {
				 copy = (CallFrame)clone();
			 }
			 catch (CloneNotSupportedException ex) {
				 throw new IllegalStateException();
			 }
			 copy.stack = (Object[])stack.clone();
			 copy.sDbl = (double[])sDbl.clone();
			 copy.frozen = false;
			 return copy;
		 }
	 }
	 private static final class ContinuationJump implements Serializable {
		 static final long serialVersionUID = 7687739156004308247L;
		 CallFrame capturedFrame;
		 CallFrame branchFrame;
		 Object result;
		 double resultDbl;
		 ContinuationJump(Continuation c, CallFrame current) {
			 this.capturedFrame = (CallFrame)c.getImplementation();
			 if (this.capturedFrame == null || current == null) {
				 this.branchFrame = null;
			 }
			 else {
				 CallFrame chain1 = this.capturedFrame;
				 CallFrame chain2 = current;
				 int diff = chain1.frameIndex - chain2.frameIndex;
				 if (diff != 0) {
					 if (diff < 0) {
						 chain1 = current;
						 chain2 = this.capturedFrame;
						 diff = -diff;
					 }
					 do {
						 chain1 = chain1.parentFrame;
					 }
					 while (--diff != 0);
					 if (chain1.frameIndex != chain2.frameIndex) Kit.codeBug();
				 }
				 while (chain1 != chain2 && chain1 != null) {
					 chain1 = chain1.parentFrame;
					 chain2 = chain2.parentFrame;
				 }
				 this.branchFrame = chain1;
				 if (this.branchFrame != null && !this.branchFrame.frozen) Kit.codeBug();
			 }
		 }
	 }
	 static {
		 if (Token.LAST_BYTECODE_TOKEN > 127) {
			 String str = ""Violation of Token.LAST_BYTECODE_TOKEN <= 127"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
		 if (MIN_ICODE < -128) {
			 String str = ""Violation of Interpreter.MIN_ICODE >= -128"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
	 }
	 private static String bytecodeName(int bytecode) {
		 if (!validBytecode(bytecode)) {
			 throw new IllegalArgumentException(String.valueOf(bytecode));
		 }
		 if (!Token.printICode) {
			 return String.valueOf(bytecode);
		 }
		 if (validTokenCode(bytecode)) {
			 return Token.name(bytecode);
		 }
		 switch (bytecode) {
			 case Icode_DUP: return ""DUP"";
			 case Icode_DUP2: return ""DUP2"";
			 case Icode_SWAP: return ""SWAP"";
			 case Icode_POP: return ""POP"";
			 case Icode_POP_RESULT: return ""POP_RESULT"";
			 case Icode_IFEQ_POP: return ""IFEQ_POP"";
			 case Icode_VAR_INC_DEC: return ""VAR_INC_DEC"";
			 case Icode_NAME_INC_DEC: return ""NAME_INC_DEC"";
			 case Icode_PROP_INC_DEC: return ""PROP_INC_DEC"";
			 case Icode_ELEM_INC_DEC: return ""ELEM_INC_DEC"";
			 case Icode_REF_INC_DEC: return ""REF_INC_DEC"";
			 case Icode_SCOPE_LOAD: return ""SCOPE_LOAD"";
			 case Icode_SCOPE_SAVE: return ""SCOPE_SAVE"";
			 case Icode_TYPEOFNAME: return ""TYPEOFNAME"";
			 case Icode_NAME_AND_THIS: return ""NAME_AND_THIS"";
			 case Icode_PROP_AND_THIS: return ""PROP_AND_THIS"";
			 case Icode_ELEM_AND_THIS: return ""ELEM_AND_THIS"";
			 case Icode_VALUE_AND_THIS: return ""VALUE_AND_THIS"";
			 case Icode_CLOSURE_EXPR: return ""CLOSURE_EXPR"";
			 case Icode_CLOSURE_STMT: return ""CLOSURE_STMT"";
			 case Icode_CALLSPECIAL: return ""CALLSPECIAL"";
			 case Icode_RETUNDEF: return ""RETUNDEF"";
			 case Icode_GOSUB: return ""GOSUB"";
			 case Icode_STARTSUB: return ""STARTSUB"";
			 case Icode_RETSUB: return ""RETSUB"";
			 case Icode_LINE: return ""LINE"";
			 case Icode_SHORTNUMBER: return ""SHORTNUMBER"";
			 case Icode_INTNUMBER: return ""INTNUMBER"";
			 case Icode_LITERAL_NEW: return ""LITERAL_NEW"";
			 case Icode_LITERAL_SET: return ""LITERAL_SET"";
			 case Icode_SPARE_ARRAYLIT: return ""SPARE_ARRAYLIT"";
			 case Icode_REG_IND_C0: return ""REG_IND_C0"";
			 case Icode_REG_IND_C1: return ""REG_IND_C1"";
			 case Icode_REG_IND_C2: return ""REG_IND_C2"";
			 case Icode_REG_IND_C3: return ""REG_IND_C3"";
			 case Icode_REG_IND_C4: return ""REG_IND_C4"";
			 case Icode_REG_IND_C5: return ""REG_IND_C5"";
			 case Icode_REG_IND1: return ""LOAD_IND1"";
			 case Icode_REG_IND2: return ""LOAD_IND2"";
			 case Icode_REG_IND4: return ""LOAD_IND4"";
			 case Icode_REG_STR_C0: return ""REG_STR_C0"";
			 case Icode_REG_STR_C1: return ""REG_STR_C1"";
			 case Icode_REG_STR_C2: return ""REG_STR_C2"";
			 case Icode_REG_STR_C3: return ""REG_STR_C3"";
			 case Icode_REG_STR1: return ""LOAD_STR1"";
			 case Icode_REG_STR2: return ""LOAD_STR2"";
			 case Icode_REG_STR4: return ""LOAD_STR4"";
			 case Icode_GETVAR1: return ""GETVAR1"";
			 case Icode_SETVAR1: return ""SETVAR1"";
			 case Icode_UNDEF: return ""UNDEF"";
			 case Icode_ZERO: return ""ZERO"";
			 case Icode_ONE: return ""ONE"";
			 case Icode_ENTERDQ: return ""ENTERDQ"";
			 case Icode_LEAVEDQ: return ""LEAVEDQ"";
			 case Icode_TAIL_CALL: return ""TAIL_CALL"";
			 case Icode_LOCAL_CLEAR: return ""LOCAL_CLEAR"";
		 }
		 throw new IllegalStateException(String.valueOf(bytecode));
	 }
	 private static boolean validIcode(int icode) {
		 return MIN_ICODE <= icode && icode <= -1;
	 }
	 private static boolean validTokenCode(int token) {
		 return Token.FIRST_BYTECODE_TOKEN <= token && token <= Token.LAST_BYTECODE_TOKEN;
	 }
	 private static boolean validBytecode(int bytecode) {
		 return validIcode(bytecode) || validTokenCode(bytecode);
	 }
	 public Object compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, String encodedSource, boolean returnFunction) {
		 this.compilerEnv = compilerEnv;
		 new NodeTransformer().transform(tree);
		 if (Token.printTrees) {
			 System.out.println(tree.toStringTree(tree));
		 }
		 if (returnFunction) {
			 tree = tree.getFunctionNode(0);
		 }
		 scriptOrFn = tree;
		 itsData = new InterpreterData(compilerEnv.getLanguageVersion(), scriptOrFn.getSourceName(), encodedSource);
		 itsData.topLevel = true;
		 if (returnFunction) {
			 generateFunctionICode();
		 }
		 else {
			 generateICodeFromTree(scriptOrFn);
		 }
		 return itsData;
	 }
	 public Script createScriptObject(Object bytecode, Object staticSecurityDomain) {
		 InterpreterData idata = (InterpreterData)bytecode;
		 return InterpretedFunction.createScript(itsData, staticSecurityDomain);
	 }
	 public Function createFunctionObject(Context cx, Scriptable scope, Object bytecode, Object staticSecurityDomain) {
		 InterpreterData idata = (InterpreterData)bytecode;
		 return InterpretedFunction.createFunction(cx, scope, itsData, staticSecurityDomain);
	 }
	 private void generateFunctionICode() {
		 itsInFunctionFlag = true;
		 FunctionNode theFunction = (FunctionNode)scriptOrFn;
		 itsData.itsFunctionType = theFunction.getFunctionType();
		 itsData.itsNeedsActivation = theFunction.requiresActivation();
		 itsData.itsName = theFunction.getFunctionName();
		 if (!theFunction.getIgnoreDynamicScope()) {
			 if (compilerEnv.isUseDynamicScope()) {
				 itsData.useDynamicScope = true;
			 }
		 }
		 generateICodeFromTree(theFunction.getLastChild());
	 }
	 private void generateICodeFromTree(Node tree) {
		 generateNestedFunctions();
		 generateRegExpLiterals();
		 visitStatement(tree);
		 fixLabelGotos();
		 if (itsData.itsFunctionType == 0) {
			 addToken(Token.RETURN_RESULT);
		 }
		 if (itsData.itsICode.length != itsICodeTop) {
			 byte[] tmp = new byte[itsICodeTop];
			 System.arraycopy(itsData.itsICode, 0, tmp, 0, itsICodeTop);
			 itsData.itsICode = tmp;
		 }
		 if (itsStrings.size() == 0) {
			 itsData.itsStringTable = null;
		 }
		 else {
			 itsData.itsStringTable = new String[itsStrings.size()];
			 ObjToIntMap.Iterator iter = itsStrings.newIterator();
			 for (iter.start();
			 !iter.done();
			 iter.next()) {
				 String str = (String)iter.getKey();
				 int index = iter.getValue();
				 if (itsData.itsStringTable[index] != null) Kit.codeBug();
				 itsData.itsStringTable[index] = str;
			 }
		 }
		 if (itsDoubleTableTop == 0) {
			 itsData.itsDoubleTable = null;
		 }
		 else if (itsData.itsDoubleTable.length != itsDoubleTableTop) {
			 double[] tmp = new double[itsDoubleTableTop];
			 System.arraycopy(itsData.itsDoubleTable, 0, tmp, 0, itsDoubleTableTop);
			 itsData.itsDoubleTable = tmp;
		 }
		 if (itsExceptionTableTop != 0 && itsData.itsExceptionTable.length != itsExceptionTableTop) {
			 int[] tmp = new int[itsExceptionTableTop];
			 System.arraycopy(itsData.itsExceptionTable, 0, tmp, 0, itsExceptionTableTop);
			 itsData.itsExceptionTable = tmp;
		 }
		 itsData.itsMaxVars = scriptOrFn.getParamAndVarCount();
		 itsData.itsMaxFrameArray = itsData.itsMaxVars + itsData.itsMaxLocals + itsData.itsMaxStack;
		 itsData.argNames = scriptOrFn.getParamAndVarNames();
		 itsData.argCount = scriptOrFn.getParamCount();
		 itsData.encodedSourceStart = scriptOrFn.getEncodedSourceStart();
		 itsData.encodedSourceEnd = scriptOrFn.getEncodedSourceEnd();
		 if (itsLiteralIds.size() != 0) {
			 itsData.literalIds = itsLiteralIds.toArray();
		 }
		 if (Token.printICode) dumpICode(itsData);
	 }
	 private void generateNestedFunctions() {
		 int functionCount = scriptOrFn.getFunctionCount();
		 if (functionCount == 0) return;
		 InterpreterData[] array = new InterpreterData[functionCount];
		 for (int i = 0;
		 i != functionCount;
		 i++) {
			 FunctionNode def = scriptOrFn.getFunctionNode(i);
			 Interpreter jsi = new Interpreter();
			 jsi.compilerEnv = compilerEnv;
			 jsi.scriptOrFn = def;
			 jsi.itsData = new InterpreterData(itsData);
			 jsi.generateFunctionICode();
			 array[i] = jsi.itsData;
		 }
		 itsData.itsNestedFunctions = array;
	 }
	 private void generateRegExpLiterals() {
		 int N = scriptOrFn.getRegexpCount();
		 if (N == 0) return;
		 Context cx = Context.getContext();
		 RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);
		 Object[] array = new Object[N];
		 for (int i = 0;
		 i != N;
		 i++) {
			 String string = scriptOrFn.getRegexpString(i);
			 String flags = scriptOrFn.getRegexpFlags(i);
			 array[i] = rep.compileRegExp(cx, string, flags);
		 }
		 itsData.itsRegExpLiterals = array;
	 }
	 private void updateLineNumber(Node node) {
		 int lineno = node.getLineno();
		 if (lineno != itsLineNumber && lineno >= 0) {
			 if (itsData.firstLinePC < 0) {
				 itsData.firstLinePC = lineno;
			 }
			 itsLineNumber = lineno;
			 addIcode(Icode_LINE);
			 addUint16(lineno & 0xFFFF);
		 }
	 }
	 private RuntimeException badTree(Node node) {
		 throw new RuntimeException(node.toString());
	 }
	 private void visitStatement(Node node) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 int fnType = scriptOrFn.getFunctionNode(fnIndex). getFunctionType();
				 if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 addIndexOp(Icode_CLOSURE_STMT, fnIndex);
				 }
				 else {
					 if (fnType != FunctionNode.FUNCTION_STATEMENT) {
						 throw Kit.codeBug();
					 }
				 }
			 }
			 break;
			 case Token.SCRIPT: case Token.LABEL: case Token.LOOP: case Token.BLOCK: case Token.EMPTY: case Token.WITH: updateLineNumber(node);
			 while (child != null) {
				 visitStatement(child);
				 child = child.getNext();
			 }
			 break;
			 case Token.ENTERWITH: visitExpression(child, 0);
			 addToken(Token.ENTERWITH);
			 stackChange(-1);
			 break;
			 case Token.LEAVEWITH: addToken(Token.LEAVEWITH);
			 break;
			 case Token.LOCAL_BLOCK: {
				 int local = allocLocal();
				 node.putIntProp(Node.LOCAL_PROP, local);
				 updateLineNumber(node);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, local);
				 releaseLocal(local);
			 }
			 break;
			 case Token.SWITCH: updateLineNumber(node);
			 {
				 Node switchNode = (Node.Jump)node;
				 visitExpression(child, 0);
				 for (Node.Jump caseNode = (Node.Jump)child.getNext();
				 caseNode != null;
				 caseNode = (Node.Jump)caseNode.getNext()) {
					 if (caseNode.getType() != Token.CASE) throw badTree(caseNode);
					 Node test = caseNode.getFirstChild();
					 addIcode(Icode_DUP);
					 stackChange(1);
					 visitExpression(test, 0);
					 addToken(Token.SHEQ);
					 stackChange(-1);
					 addGoto(caseNode.target, Icode_IFEQ_POP);
					 stackChange(-1);
				 }
				 addIcode(Icode_POP);
				 stackChange(-1);
			 }
			 break;
			 case Token.TARGET: markTargetLabel(node);
			 break;
			 case Token.IFEQ : case Token.IFNE : {
				 Node target = ((Node.Jump)node).target;
				 visitExpression(child, 0);
				 addGoto(target, type);
				 stackChange(-1);
			 }
			 break;
			 case Token.GOTO: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, type);
			 }
			 break;
			 case Token.JSR: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, Icode_GOSUB);
			 }
			 break;
			 case Token.FINALLY: {
				 stackChange(1);
				 int finallyRegister = getLocalBlockRef(node);
				 addIndexOp(Icode_STARTSUB, finallyRegister);
				 stackChange(-1);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_RETSUB, finallyRegister);
			 }
			 break;
			 case Token.EXPR_VOID: case Token.EXPR_RESULT: updateLineNumber(node);
			 visitExpression(child, 0);
			 addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);
			 stackChange(-1);
			 break;
			 case Token.TRY: {
				 Node.Jump tryNode = (Node.Jump)node;
				 int exceptionObjectLocal = getLocalBlockRef(tryNode);
				 int scopeLocal = allocLocal();
				 addIndexOp(Icode_SCOPE_SAVE, scopeLocal);
				 int tryStart = itsICodeTop;
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 Node catchTarget = tryNode.target;
				 if (catchTarget != null) {
					 int catchStartPC = itsLabelTable[getTargetLabel(catchTarget)];
					 addExceptionHandler( tryStart, catchStartPC, catchStartPC, false, exceptionObjectLocal, scopeLocal);
				 }
				 Node finallyTarget = tryNode.getFinally();
				 if (finallyTarget != null) {
					 int finallyStartPC = itsLabelTable[getTargetLabel(finallyTarget)];
					 addExceptionHandler( tryStart, finallyStartPC, finallyStartPC, true, exceptionObjectLocal, scopeLocal);
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);
				 releaseLocal(scopeLocal);
			 }
			 break;
			 case Token.CATCH_SCOPE: {
				 int localIndex = getLocalBlockRef(node);
				 int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringPrefix(name);
				 addIndexPrefix(localIndex);
				 addToken(Token.CATCH_SCOPE);
				 addUint8(scopeIndex != 0 ? 1 : 0);
				 stackChange(-1);
			 }
			 break;
			 case Token.THROW: updateLineNumber(node);
			 visitExpression(child, 0);
			 addToken(Token.THROW);
			 addUint16(itsLineNumber & 0xFFFF);
			 stackChange(-1);
			 break;
			 case Token.RETHROW: updateLineNumber(node);
			 addIndexOp(Token.RETHROW, getLocalBlockRef(node));
			 break;
			 case Token.RETURN: updateLineNumber(node);
			 if (child != null) {
				 visitExpression(child, ECF_TAIL);
				 addToken(Token.RETURN);
				 stackChange(-1);
			 }
			 else {
				 addIcode(Icode_RETUNDEF);
			 }
			 break;
			 case Token.RETURN_RESULT: updateLineNumber(node);
			 addToken(Token.RETURN_RESULT);
			 break;
			 case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES : visitExpression(child, 0);
			 addIndexOp(type, getLocalBlockRef(node));
			 stackChange(-1);
			 break;
			 default: throw badTree(node);
		 }
		 if (itsStackDepth != 0) {
			 throw Kit.codeBug();
		 }
	 }
	 private void visitExpression(Node node, int contextFlags) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 int savedStackDepth = itsStackDepth;
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);
				 if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {
					 throw Kit.codeBug();
				 }
				 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.LOCAL_LOAD: {
				 int localIndex = getLocalBlockRef(node);
				 addIndexOp(Token.LOCAL_LOAD, localIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.COMMA: {
				 Node lastChild = node.getLastChild();
				 while (child != lastChild) {
					 visitExpression(child, 0);
					 addIcode(Icode_POP);
					 stackChange(-1);
					 child = child.getNext();
				 }
				 visitExpression(child, contextFlags & ECF_TAIL);
			 }
			 break;
			 case Token.USE_STACK: stackChange(1);
			 break;
			 case Token.REF_CALL: case Token.CALL: case Token.NEW: {
				 if (type == Token.NEW) {
					 visitExpression(child, 0);
				 }
				 else {
					 generateCallFunAndThis(child);
				 }
				 int argCount = 0;
				 while ((child = child.getNext()) != null) {
					 visitExpression(child, 0);
					 ++argCount;
				 }
				 int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL);
				 if (callType != Node.NON_SPECIALCALL) {
					 addIndexOp(Icode_CALLSPECIAL, argCount);
					 addUint8(callType);
					 addUint8(type == Token.NEW ? 1 : 0);
					 addUint16(itsLineNumber & 0xFFFF);
				 }
				 else {
					 if (type == Token.CALL) {
						 if ((contextFlags & ECF_TAIL) != 0) {
							 type = Icode_TAIL_CALL;
						 }
					 }
					 addIndexOp(type, argCount);
				 }
				 if (type == Token.NEW) {
					 stackChange(-argCount);
				 }
				 else {
					 stackChange(-1 - argCount);
				 }
				 if (argCount > itsData.itsMaxCalleeArgs) {
					 itsData.itsMaxCalleeArgs = argCount;
				 }
			 }
			 break;
			 case Token.AND: case Token.OR: {
				 visitExpression(child, 0);
				 addIcode(Icode_DUP);
				 stackChange(1);
				 int afterSecondJumpStart = itsICodeTop;
				 int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;
				 addGotoOp(jump);
				 stackChange(-1);
				 addIcode(Icode_POP);
				 stackChange(-1);
				 child = child.getNext();
				 visitExpression(child, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterSecondJumpStart);
			 }
			 break;
			 case Token.HOOK: {
				 Node ifThen = child.getNext();
				 Node ifElse = ifThen.getNext();
				 visitExpression(child, 0);
				 int elseJumpStart = itsICodeTop;
				 addGotoOp(Token.IFNE);
				 stackChange(-1);
				 visitExpression(ifThen, contextFlags & ECF_TAIL);
				 int afterElseJumpStart = itsICodeTop;
				 addGotoOp(Token.GOTO);
				 resolveForwardGoto(elseJumpStart);
				 itsStackDepth = savedStackDepth;
				 visitExpression(ifElse, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterElseJumpStart);
			 }
			 break;
			 case Token.GETPROP: visitExpression(child, 0);
			 child = child.getNext();
			 addStringOp(Token.GETPROP, child.getString());
			 break;
			 case Token.GETELEM: case Token.DELPROP: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 addToken(type);
			 stackChange(-1);
			 break;
			 case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0);
			 if (type == Token.VOID) {
				 addIcode(Icode_POP);
				 addIcode(Icode_UNDEF);
			 }
			 else {
				 addToken(type);
			 }
			 break;
			 case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0);
			 addToken(type);
			 break;
			 case Token.SETPROP: case Token.SETPROP_OP: {
				 visitExpression(child, 0);
				 child = child.getNext();
				 String property = child.getString();
				 child = child.getNext();
				 if (type == Token.SETPROP_OP) {
					 addIcode(Icode_DUP);
					 stackChange(1);
					 addStringOp(Token.GETPROP, property);
					 stackChange(-1);
				 }
				 visitExpression(child, 0);
				 addStringOp(Token.SETPROP, property);
				 stackChange(-1);
			 }
			 break;
			 case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SETELEM_OP) {
				 addIcode(Icode_DUP2);
				 stackChange(2);
				 addToken(Token.GETELEM);
				 stackChange(-1);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SETELEM);
			 stackChange(-2);
			 break;
			 case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SET_REF_OP) {
				 addIcode(Icode_DUP);
				 stackChange(1);
				 addToken(Token.GET_REF);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SET_REF);
			 stackChange(-1);
			 break;
			 case Token.SETNAME: {
				 String name = child.getString();
				 visitExpression(child, 0);
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringOp(Token.SETNAME, name);
				 stackChange(-1);
			 }
			 break;
			 case Token.TYPEOFNAME: {
				 String name = node.getString();
				 int index = -1;
				 if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getParamOrVarIndex(name);
				 if (index == -1) {
					 addStringOp(Icode_TYPEOFNAME, name);
					 stackChange(1);
				 }
				 else {
					 addVarOp(Token.GETVAR, index);
					 stackChange(1);
					 addToken(Token.TYPEOF);
				 }
			 }
			 break;
			 case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString());
			 stackChange(1);
			 break;
			 case Token.INC: case Token.DEC: visitIncDec(node, child);
			 break;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 int inum = (int)num;
				 if (inum == num) {
					 if (inum == 0) {
						 addIcode(Icode_ZERO);
						 if (1.0 / num < 0.0) {
							 addToken(Token.NEG);
						 }
					 }
					 else if (inum == 1) {
						 addIcode(Icode_ONE);
					 }
					 else if ((short)inum == inum) {
						 addIcode(Icode_SHORTNUMBER);
						 addUint16(inum & 0xFFFF);
					 }
					 else {
						 addIcode(Icode_INTNUMBER);
						 addInt(inum);
					 }
				 }
				 else {
					 int index = getDoubleIndex(num);
					 addIndexOp(Token.NUMBER, index);
				 }
				 stackChange(1);
			 }
			 break;
			 case Token.GETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = node.getString();
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.GETVAR, index);
				 stackChange(1);
			 }
			 break;
			 case Token.SETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.SETVAR, index);
			 }
			 break;
			 case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type);
			 stackChange(1);
			 break;
			 case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node));
			 stackChange(1);
			 break;
			 case Token.REGEXP: {
				 int index = node.getExistingIntProp(Node.REGEXP_PROP);
				 addIndexOp(Token.REGEXP, index);
				 stackChange(1);
			 }
			 break;
			 case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child);
			 break;
			 case Token.REF_SPECIAL: visitExpression(child, 0);
			 addStringOp(type, (String)node.getProp(Node.NAME_PROP));
			 break;
			 case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: {
				 int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);
				 int childCount = 0;
				 do {
					 visitExpression(child, 0);
					 ++childCount;
					 child = child.getNext();
				 }
				 while (child != null);
				 addIndexOp(type, memberTypeFlags);
				 stackChange(1 - childCount);
			 }
			 break;
			 case Token.DOTQUERY: {
				 int queryPC;
				 updateLineNumber(node);
				 visitExpression(child, 0);
				 addIcode(Icode_ENTERDQ);
				 stackChange(-1);
				 queryPC = itsICodeTop;
				 visitExpression(child.getNext(), 0);
				 addBackwardGoto(Icode_LEAVEDQ, queryPC);
			 }
			 break;
			 case Token.DEFAULTNAMESPACE : case Token.ESCXMLATTR : case Token.ESCXMLTEXT : visitExpression(child, 0);
			 addToken(type);
			 break;
			 default: throw badTree(node);
		 }
		 if (savedStackDepth + 1 != itsStackDepth) {
			 Kit.codeBug();
		 }
	 }
	 private void generateCallFunAndThis(Node left) {
		 int type = left.getType();
		 switch (type) {
			 case Token.NAME: {
				 String name = left.getString();
				 addStringOp(Icode_NAME_AND_THIS, name);
				 stackChange(2);
				 break;
			 }
			 case Token.GETPROP: case Token.GETELEM: {
				 Node target = left.getFirstChild();
				 visitExpression(target, 0);
				 Node id = target.getNext();
				 if (type == Token.GETPROP) {
					 String property = id.getString();
					 addStringOp(Icode_PROP_AND_THIS, property);
					 stackChange(1);
				 }
				 else {
					 visitExpression(id, 0);
					 addIcode(Icode_ELEM_AND_THIS);
				 }
				 break;
			 }
			 default: visitExpression(left, 0);
			 addIcode(Icode_VALUE_AND_THIS);
			 stackChange(1);
			 break;
		 }
	 }
	 private void visitIncDec(Node node, Node child) {
		 int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);
		 int childType = child.getType();
		 switch (childType) {
			 case Token.GETVAR : {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 int i = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Icode_VAR_INC_DEC, i);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.NAME : {
				 String name = child.getString();
				 addStringOp(Icode_NAME_INC_DEC, name);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.GETPROP : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 String property = object.getNext().getString();
				 addStringOp(Icode_PROP_INC_DEC, property);
				 addUint8(incrDecrMask);
				 break;
			 }
			 case Token.GETELEM : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 Node index = object.getNext();
				 visitExpression(index, 0);
				 addIcode(Icode_ELEM_INC_DEC);
				 addUint8(incrDecrMask);
				 stackChange(-1);
				 break;
			 }
			 case Token.GET_REF : {
				 Node ref = child.getFirstChild();
				 visitExpression(ref, 0);
				 addIcode(Icode_REF_INC_DEC);
				 addUint8(incrDecrMask);
				 break;
			 }
			 default : {
				 throw badTree(node);
			 }
		 }
	 }
	 private void visitLiteral(Node node, Node child) {
		 int type = node.getType();
		 int count;
		 Object[] propertyIds = null;
		 if (type == Token.ARRAYLIT) {
			 count = 0;
			 for (Node n = child;
			 n != null;
			 n = n.getNext()) {
				 ++count;
			 }
		 }
		 else if (type == Token.OBJECTLIT) {
			 propertyIds = (Object[])node.getProp(Node.OBJECT_IDS_PROP);
			 count = propertyIds.length;
		 }
		 else {
			 throw badTree(node);
		 }
		 addIndexOp(Icode_LITERAL_NEW, count);
		 stackChange(1);
		 while (child != null) {
			 visitExpression(child, 0);
			 addIcode(Icode_LITERAL_SET);
			 stackChange(-1);
			 child = child.getNext();
		 }
		 if (type == Token.ARRAYLIT) {
			 int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);
			 if (skipIndexes == null) {
				 addToken(Token.ARRAYLIT);
			 }
			 else {
				 int index = itsLiteralIds.size();
				 itsLiteralIds.add(skipIndexes);
				 addIndexOp(Icode_SPARE_ARRAYLIT, index);
			 }
		 }
		 else {
			 int index = itsLiteralIds.size();
			 itsLiteralIds.add(propertyIds);
			 addIndexOp(Token.OBJECTLIT, index);
		 }
	 }
	 private int getLocalBlockRef(Node node) {
		 Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
		 return localBlock.getExistingIntProp(Node.LOCAL_PROP);
	 }
	 private int getTargetLabel(Node target) {
		 int label = target.labelId();
		 if (label != -1) {
			 return label;
		 }
		 label = itsLabelTableTop;
		 if (itsLabelTable == null || label == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, label);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = label + 1;
		 itsLabelTable[label] = -1;
		 target.labelId(label);
		 return label;
	 }
	 private void markTargetLabel(Node target) {
		 int label = getTargetLabel(target);
		 if (itsLabelTable[label] != -1) {
			 Kit.codeBug();
		 }
		 itsLabelTable[label] = itsICodeTop;
	 }
	 private void addGoto(Node target, int gotoOp) {
		 int label = getTargetLabel(target);
		 if (!(label < itsLabelTableTop)) Kit.codeBug();
		 int targetPC = itsLabelTable[label];
		 if (targetPC != -1) {
			 addBackwardGoto(gotoOp, targetPC);
		 }
		 else {
			 int gotoPC = itsICodeTop;
			 addGotoOp(gotoOp);
			 int top = itsFixupTableTop;
			 if (itsFixupTable == null || top == itsFixupTable.length) {
				 if (itsFixupTable == null) {
					 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
				 }
				 else {
					 long[] tmp = new long[itsFixupTable.length * 2];
					 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
					 itsFixupTable = tmp;
				 }
			 }
			 itsFixupTableTop = top + 1;
			 itsFixupTable[top] = ((long)label << 32) | gotoPC;
		 }
	 }
	 private void fixLabelGotos() {
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int jumpSource = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw Kit.codeBug();
			 }
			 resolveGoto(jumpSource, pc);
		 }
		 itsFixupTableTop = 0;
	 }
	 private void addBackwardGoto(int gotoOp, int jumpPC) {
		 int fromPC = itsICodeTop;
		 if (fromPC <= jumpPC) throw Kit.codeBug();
		 addGotoOp(gotoOp);
		 resolveGoto(fromPC, jumpPC);
	 }
	 private void resolveForwardGoto(int fromPC) {
		 if (itsICodeTop < fromPC + 3) throw Kit.codeBug();
		 resolveGoto(fromPC, itsICodeTop);
	 }
	 private void resolveGoto(int fromPC, int jumpPC) {
		 int offset = jumpPC - fromPC;
		 if (0 <= offset && offset <= 2) throw Kit.codeBug();
		 int offsetSite = fromPC + 1;
		 if (offset != (short)offset) {
			 if (itsData.longJumps == null) {
				 itsData.longJumps = new UintMap();
			 }
			 itsData.longJumps.put(offsetSite, jumpPC);
			 offset = 0;
		 }
		 byte[] array = itsData.itsICode;
		 array[offsetSite] = (byte)(offset >> 8);
		 array[offsetSite + 1] = (byte)offset;
	 }
	 private void addToken(int token) {
		 if (!validTokenCode(token)) throw Kit.codeBug();
		 addUint8(token);
	 }
	 private void addIcode(int icode) {
		 if (!validIcode(icode)) throw Kit.codeBug();
		 addUint8(icode & 0xFF);
	 }
	 private void addUint8(int value) {
		 if ((value & ~0xFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top == array.length) {
			 array = increaseICodeCapasity(1);
		 }
		 array[top] = (byte)value;
		 itsICodeTop = top + 1;
	 }
	 private void addUint16(int value) {
		 if ((value & ~0xFFFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 2 > array.length) {
			 array = increaseICodeCapasity(2);
		 }
		 array[top] = (byte)(value >>> 8);
		 array[top + 1] = (byte)value;
		 itsICodeTop = top + 2;
	 }
	 private void addInt(int i) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 4 > array.length) {
			 array = increaseICodeCapasity(4);
		 }
		 array[top] = (byte)(i >>> 24);
		 array[top + 1] = (byte)(i >>> 16);
		 array[top + 2] = (byte)(i >>> 8);
		 array[top + 3] = (byte)i;
		 itsICodeTop = top + 4;
	 }
	 private int getDoubleIndex(double num) {
		 int index = itsDoubleTableTop;
		 if (index == 0) {
			 itsData.itsDoubleTable = new double[64];
		 }
		 else if (itsData.itsDoubleTable.length == index) {
			 double[] na = new double[index * 2];
			 System.arraycopy(itsData.itsDoubleTable, 0, na, 0, index);
			 itsData.itsDoubleTable = na;
		 }
		 itsData.itsDoubleTable[index] = num;
		 itsDoubleTableTop = index + 1;
		 return index;
	 }
	 private void addGotoOp(int gotoOp) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 3 > array.length) {
			 array = increaseICodeCapasity(3);
		 }
		 array[top] = (byte)gotoOp;
		 itsICodeTop = top + 1 + 2;
	 }
	 private void addVarOp(int op, int varIndex) {
		 switch (op) {
			 case Token.GETVAR: case Token.SETVAR: if (varIndex < 128) {
				 addIcode(op == Token.GETVAR ? Icode_GETVAR1 : Icode_SETVAR1);
				 addUint8(varIndex);
				 return;
			 }
			 case Icode_VAR_INC_DEC: addIndexOp(op, varIndex);
			 return;
		 }
		 throw Kit.codeBug();
	 }
	 private void addStringOp(int op, String str) {
		 addStringPrefix(str);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addIndexOp(int op, int index) {
		 addIndexPrefix(index);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addStringPrefix(String str) {
		 int index = itsStrings.get(str, -1);
		 if (index == -1) {
			 index = itsStrings.size();
			 itsStrings.put(str, index);
		 }
		 if (index < 4) {
			 addIcode(Icode_REG_STR_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_STR1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_STR2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_STR4);
			 addInt(index);
		 }
	 }
	 private void addIndexPrefix(int index) {
		 if (index < 0) Kit.codeBug();
		 if (index < 6) {
			 addIcode(Icode_REG_IND_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_IND1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_IND2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_IND4);
			 addInt(index);
		 }
	 }
	 private void addExceptionHandler(int icodeStart, int icodeEnd, int handlerStart, boolean isFinally, int exceptionObjectLocal, int scopeLocal) {
		 int top = itsExceptionTableTop;
		 int[] table = itsData.itsExceptionTable;
		 if (table == null) {
			 if (top != 0) Kit.codeBug();
			 table = new int[EXCEPTION_SLOT_SIZE * 2];
			 itsData.itsExceptionTable = table;
		 }
		 else if (table.length == top) {
			 table = new int[table.length * 2];
			 System.arraycopy(itsData.itsExceptionTable, 0, table, 0, top);
			 itsData.itsExceptionTable = table;
		 }
		 table[top + EXCEPTION_TRY_START_SLOT] = icodeStart;
		 table[top + EXCEPTION_TRY_END_SLOT] = icodeEnd;
		 table[top + EXCEPTION_HANDLER_SLOT] = handlerStart;
		 table[top + EXCEPTION_TYPE_SLOT] = isFinally ? 1 : 0;
		 table[top + EXCEPTION_LOCAL_SLOT] = exceptionObjectLocal;
		 table[top + EXCEPTION_SCOPE_SLOT] = scopeLocal;
		 itsExceptionTableTop = top + EXCEPTION_SLOT_SIZE;
	 }
	 private byte[] increaseICodeCapasity(int extraSize) {
		 int capacity = itsData.itsICode.length;
		 int top = itsICodeTop;
		 if (top + extraSize <= capacity) throw Kit.codeBug();
		 capacity *= 2;
		 if (top + extraSize > capacity) {
			 capacity = top + extraSize;
		 }
		 byte[] array = new byte[capacity];
		 System.arraycopy(itsData.itsICode, 0, array, 0, top);
		 itsData.itsICode = array;
		 return array;
	 }
	 private void stackChange(int change) {
		 if (change <= 0) {
			 itsStackDepth += change;
		 }
		 else {
			 int newDepth = itsStackDepth + change;
			 if (newDepth > itsData.itsMaxStack) {
				 itsData.itsMaxStack = newDepth;
			 }
			 itsStackDepth = newDepth;
		 }
	 }
	 private int allocLocal() {
		 int localSlot = itsLocalTop;
		 ++itsLocalTop;
		 if (itsLocalTop > itsData.itsMaxLocals) {
			 itsData.itsMaxLocals = itsLocalTop;
		 }
		 return localSlot;
	 }
	 private void releaseLocal(int localSlot) {
		 --itsLocalTop;
		 if (localSlot != itsLocalTop) Kit.codeBug();
	 }
	 private static int getShort(byte[] iCode, int pc) {
		 return (iCode[pc] << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getIndex(byte[] iCode, int pc) {
		 return ((iCode[pc] & 0xFF) << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getInt(byte[] iCode, int pc) {
		 return (iCode[pc] << 24) | ((iCode[pc + 1] & 0xFF) << 16) | ((iCode[pc + 2] & 0xFF) << 8) | (iCode[pc + 3] & 0xFF);
	 }
	 private static int getExceptionHandler(CallFrame frame, boolean onlyFinally) {
		 int[] exceptionTable = frame.idata.itsExceptionTable;
		 if (exceptionTable == null) {
			 return -1;
		 }
		 int pc = frame.pc - 1;
		 int best = -1, bestStart = 0, bestEnd = 0;
		 for (int i = 0;
		 i != exceptionTable.length;
		 i += EXCEPTION_SLOT_SIZE) {
			 int start = exceptionTable[i + EXCEPTION_TRY_START_SLOT];
			 int end = exceptionTable[i + EXCEPTION_TRY_END_SLOT];
			 if (!(start <= pc && pc < end)) {
				 continue;
			 }
			 if (onlyFinally && exceptionTable[i + EXCEPTION_TYPE_SLOT] != 1) {
				 continue;
			 }
			 if (best >= 0) {
				 if (bestEnd < end) {
					 continue;
				 }
				 if (bestStart > start) Kit.codeBug();
				 if (bestEnd == end) Kit.codeBug();
			 }
			 best = i;
			 bestStart = start;
			 bestEnd = end;
		 }
		 return best;
	 }
	 private static void dumpICode(InterpreterData idata) {
		 if (!Token.printICode) {
			 return;
		 }
		 byte iCode[] = idata.itsICode;
		 int iCodeLength = iCode.length;
		 String[] strings = idata.itsStringTable;
		 PrintStream out = System.out;
		 out.println(""ICode dump, for "" + idata.itsName + "", length = "" + iCodeLength);
		 out.println(""MaxStack = "" + idata.itsMaxStack);
		 int indexReg = 0;
		 for (int pc = 0;
		 pc < iCodeLength;
		 ) {
			 out.flush();
			 out.print("" ["" + pc + ""] "");
			 int token = iCode[pc];
			 int icodeLength = bytecodeSpan(token);
			 String tname = bytecodeName(token);
			 int old_pc = pc;
			 ++pc;
			 switch (token) {
				 default: if (icodeLength != 1) Kit.codeBug();
				 out.println(tname);
				 break;
				 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : {
					 int newPC = pc + getShort(iCode, pc) - 1;
					 out.println(tname + "" "" + newPC);
					 pc += 2;
					 break;
				 }
				 case Icode_VAR_INC_DEC : case Icode_NAME_INC_DEC : case Icode_PROP_INC_DEC : case Icode_ELEM_INC_DEC : case Icode_REF_INC_DEC: {
					 int incrDecrType = iCode[pc];
					 out.println(tname + "" "" + incrDecrType);
					 ++pc;
					 break;
				 }
				 case Icode_CALLSPECIAL : {
					 int callType = iCode[pc] & 0xFF;
					 boolean isNew = (iCode[pc + 1] != 0);
					 int line = getIndex(iCode, pc+2);
					 out.println(tname+"" ""+callType+"" ""+isNew+"" ""+indexReg+"" ""+line);
					 pc += 4;
					 break;
				 }
				 case Token.CATCH_SCOPE: {
					 boolean afterFisrtFlag = (iCode[pc] != 0);
					 out.println(tname+"" ""+afterFisrtFlag);
					 ++pc;
				 }
				 break;
				 case Token.REGEXP : out.println(tname+"" ""+idata.itsRegExpLiterals[indexReg]);
				 break;
				 case Token.OBJECTLIT : case Icode_SPARE_ARRAYLIT : out.println(tname+"" ""+idata.literalIds[indexReg]);
				 break;
				 case Icode_CLOSURE_EXPR : case Icode_CLOSURE_STMT : out.println(tname+"" ""+idata.itsNestedFunctions[indexReg]);
				 break;
				 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : case Token.NEW : out.println(tname+' '+indexReg);
				 break;
				 case Token.THROW : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_SHORTNUMBER : {
					 int value = getShort(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_INTNUMBER : {
					 int value = getInt(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 4;
					 break;
				 }
				 case Token.NUMBER : {
					 double value = idata.itsDoubleTable[indexReg];
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_LINE : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR1: {
					 String str = strings[0xFF & iCode[pc]];
					 out.println(tname + "" \"""" + str + '""');
					 ++pc;
					 break;
				 }
				 case Icode_REG_STR2: {
					 String str = strings[getIndex(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR4: {
					 String str = strings[getInt(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 4;
					 break;
				 }
				 case Icode_REG_IND1: {
					 indexReg = 0xFF & iCode[pc];
					 out.println(tname+"" ""+indexReg);
					 ++pc;
					 break;
				 }
				 case Icode_REG_IND2: {
					 indexReg = getIndex(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_IND4: {
					 indexReg = getInt(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 4;
					 break;
				 }
				 case Icode_GETVAR1: case Icode_SETVAR1: indexReg = iCode[pc];
				 out.println(tname+"" ""+indexReg);
				 ++pc;
				 break;
			 }
			 if (old_pc + icodeLength != pc) Kit.codeBug();
		 }
		 int[] table = idata.itsExceptionTable;
		 if (table != null) {
			 out.println(""Exception handlers: "" +table.length / EXCEPTION_SLOT_SIZE);
			 for (int i = 0;
			 i != table.length;
			 i += EXCEPTION_SLOT_SIZE) {
				 int tryStart = table[i + EXCEPTION_TRY_START_SLOT];
				 int tryEnd = table[i + EXCEPTION_TRY_END_SLOT];
				 int handlerStart = table[i + EXCEPTION_HANDLER_SLOT];
				 int type = table[i + EXCEPTION_TYPE_SLOT];
				 int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];
				 int scopeLocal = table[i + EXCEPTION_SCOPE_SLOT];
				 out.println("" tryStart=""+tryStart+"" tryEnd=""+tryEnd +"" handlerStart=""+handlerStart +"" type=""+(type == 0 ? ""catch"" : ""finally"") +"" exceptionLocal=""+exceptionLocal);
			 }
		 }
		 out.flush();
	 }
	 private static int bytecodeSpan(int bytecode) {
		 switch (bytecode) {
			 case Token.THROW : return 1 + 2;
			 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : return 1 + 2;
			 case Icode_CALLSPECIAL : return 1 + 1 + 1 + 2;
			 case Token.CATCH_SCOPE: return 1 + 1;
			 case Icode_VAR_INC_DEC: case Icode_NAME_INC_DEC: case Icode_PROP_INC_DEC: case Icode_ELEM_INC_DEC: case Icode_REF_INC_DEC: return 1 + 1;
			 case Icode_SHORTNUMBER : return 1 + 2;
			 case Icode_INTNUMBER : return 1 + 4;
			 case Icode_REG_IND1: return 1 + 1;
			 case Icode_REG_IND2: return 1 + 2;
			 case Icode_REG_IND4: return 1 + 4;
			 case Icode_REG_STR1: return 1 + 1;
			 case Icode_REG_STR2: return 1 + 2;
			 case Icode_REG_STR4: return 1 + 4;
			 case Icode_GETVAR1: case Icode_SETVAR1: return 1 + 1;
			 case Icode_LINE : return 1 + 2;
		 }
		 if (!validBytecode(bytecode)) throw Kit.codeBug();
		 return 1;
	 }
	 static int[] getLineNumbers(InterpreterData data) {
		 UintMap presentLines = new UintMap();
		 byte[] iCode = data.itsICode;
		 int iCodeLength = iCode.length;
		 for (int pc = 0;
		 pc != iCodeLength;
		) {
			 int bytecode = iCode[pc];
			 int span = bytecodeSpan(bytecode);
			 if (bytecode == Icode_LINE) {
				 if (span != 3) Kit.codeBug();
				 int line = getIndex(iCode, pc + 1);
				 presentLines.put(line, 0);
			 }
			 pc += span;
		 }
		 return presentLines.getKeys();
	 }
	 static void captureInterpreterStackInfo(RhinoException ex) {
		 Context cx = Context.getCurrentContext();
		 if (cx == null || cx.lastInterpreterFrame == null) {
			 ex.interpreterStackInfo = null;
			 ex.interpreterLineData = null;
			 return;
		 }
		 CallFrame[] array;
		 if (cx.previousInterpreterInvocations == null || cx.previousInterpreterInvocations.size() == 0) {
			 array = new CallFrame[1];
		 }
		 else {
			 int previousCount = cx.previousInterpreterInvocations.size();
			 if (cx.previousInterpreterInvocations.peek() == cx.lastInterpreterFrame) {
				 --previousCount;
			 }
			 array = new CallFrame[previousCount + 1];
			 cx.previousInterpreterInvocations.toArray(array);
		 }
		 array[array.length - 1] = (CallFrame)cx.lastInterpreterFrame;
		 int interpreterFrameCount = 0;
		 for (int i = 0;
		 i != array.length;
		 ++i) {
			 interpreterFrameCount += 1 + array[i].frameIndex;
		 }
		 int[] linePC = new int[interpreterFrameCount];
		 int linePCIndex = interpreterFrameCount;
		 for (int i = array.length;
		 i != 0;
		) {
			 --i;
			 CallFrame frame = array[i];
			 while (frame != null) {
				 --linePCIndex;
				 linePC[linePCIndex] = frame.pcSourceLineStart;
				 frame = frame.parentFrame;
			 }
		 }
		 if (linePCIndex != 0) Kit.codeBug();
		 ex.interpreterStackInfo = array;
		 ex.interpreterLineData = linePC;
	 }
	 static String getSourcePositionFromStack(Context cx, int[] linep) {
		 CallFrame frame = (CallFrame)cx.lastInterpreterFrame;
		 InterpreterData idata = frame.idata;
		 if (frame.pcSourceLineStart >= 0) {
			 linep[0] = getIndex(idata.itsICode, frame.pcSourceLineStart);
		 }
		 else {
			 linep[0] = 0;
		 }
		 return idata.itsSourceFile;
	 }
	 static String getPatchedStack(RhinoException ex, String nativeStackTrace) {
		 String tag = ""org.mozilla.javascript.Interpreter.interpretLoop"";
		 StringBuffer sb = new StringBuffer(nativeStackTrace.length() + 1000);
		 String lineSeparator = System.getProperty(""line.separator"");
		 CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;
		 int[] linePC = ex.interpreterLineData;
		 int arrayIndex = array.length;
		 int linePCIndex = linePC.length;
		 int offset = 0;
		 while (arrayIndex != 0) {
			 --arrayIndex;
			 int pos = nativeStackTrace.indexOf(tag, offset);
			 if (pos < 0) {
				 break;
			 }
			 pos += tag.length();
			 for (;
			 pos != nativeStackTrace.length();
			 ++pos) {
				 char c = nativeStackTrace.charAt(pos);
				 if (c == '\n' || c == '\r') {
					 break;
				 }
			 }
			 sb.append(nativeStackTrace.substring(offset, pos));
			 offset = pos;
			 CallFrame frame = array[arrayIndex];
			 while (frame != null) {
				 if (linePCIndex == 0) Kit.codeBug();
				 --linePCIndex;
				 InterpreterData idata = frame.idata;
				 sb.append(lineSeparator);
				 sb.append(""\tat script"");
				 if (idata.itsName != null && idata.itsName.length() != 0) {
					 sb.append('.');
					 sb.append(idata.itsName);
				 }
				 sb.append('(');
				 sb.append(idata.itsSourceFile);
				 int pc = linePC[linePCIndex];
				 if (pc >= 0) {
					 sb.append(':');
					 sb.append(getIndex(idata.itsICode, pc));
				 }
				 sb.append(')');
				 frame = frame.parentFrame;
			 }
		 }
		 sb.append(nativeStackTrace.substring(offset));
		 return sb.toString();
	 }
	 static String getEncodedSource(InterpreterData idata) {
		 if (idata.encodedSource == null) {
			 return null;
		 }
		 return idata.encodedSource.substring(idata.encodedSourceStart, idata.encodedSourceEnd);
	 }
	 private static void initFunction(Context cx, Scriptable scope, InterpretedFunction parent, int index) {
		 InterpretedFunction fn;
		 fn = InterpretedFunction.createFunction(cx, scope, parent, index);
		 ScriptRuntime.initFunction(cx, scope, fn, fn.idata.itsFunctionType, parent.idata.evalScriptFlag);
	 }
	 static Object interpret(InterpretedFunction ifun, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) Kit.codeBug();
		 if (cx.interpreterSecurityDomain != ifun.securityDomain) {
			 Object savedDomain = cx.interpreterSecurityDomain;
			 cx.interpreterSecurityDomain = ifun.securityDomain;
			 try {
				 return ifun.securityController.callWithDomain( ifun.securityDomain, cx, ifun, scope, thisObj, args);
			 }
			 finally {
				 cx.interpreterSecurityDomain = savedDomain;
			 }
		 }
		 CallFrame frame = new CallFrame();
		 initFrame(cx, scope, thisObj, args, null, 0, args.length, ifun, null, frame);
		 return interpretLoop(cx, frame, null);
	 }
	 public static Object restartContinuation(Continuation c, Context cx, Scriptable scope, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) {
			 return ScriptRuntime.doTopCall(c, cx, scope, null, args);
		 }
		 Object arg;
		 if (args.length == 0) {
			 arg = Undefined.instance;
		 }
		 else {
			 arg = args[0];
		 }
		 CallFrame capturedFrame = (CallFrame)c.getImplementation();
		 if (capturedFrame == null) {
			 return arg;
		 }
		 ContinuationJump cjump = new ContinuationJump(c, null);
		 cjump.result = arg;
		 return interpretLoop(cx, null, cjump);
	 }
	 private static Object interpretLoop(Context cx, CallFrame frame, Object throwable) {
		 final Object DBL_MRK = UniqueTag.DOUBLE_MARK;
		 final Object undefined = Undefined.instance;
		 final boolean instructionCounting = (cx.instructionThreshold != 0);
		 final int INVOCATION_COST = 100;
		 final int EXCEPTION_COST = 100;
		 String stringReg = null;
		 int indexReg = -1;
		 if (cx.lastInterpreterFrame != null) {
			 if (cx.previousInterpreterInvocations == null) {
				 cx.previousInterpreterInvocations = new ObjArray();
			 }
			 cx.previousInterpreterInvocations.push(cx.lastInterpreterFrame);
		 }
		 if (throwable != null) {
			 if (!(throwable instanceof ContinuationJump)) {
				 Kit.codeBug();
			 }
		 }
		 Object interpreterResult = null;
		 double interpreterResultDbl = 0.0;
		 StateLoop: for (;
		;
		) {
			 withoutExceptions: try {
				 if (throwable != null) {
					 if (indexReg >= 0) {
						 if (frame.frozen) {
							 frame = frame.cloneFrozen();
						 }
						 int[] table = frame.idata.itsExceptionTable;
						 frame.pc = table[indexReg + EXCEPTION_HANDLER_SLOT];
						 if (instructionCounting) {
							 frame.pcPrevBranch = frame.pc;
						 }
						 frame.savedStackTop = frame.emptyStackTop;
						 int scopeLocal = frame.localShift + table[indexReg + EXCEPTION_SCOPE_SLOT];
						 int exLocal = frame.localShift + table[indexReg + EXCEPTION_LOCAL_SLOT];
						 frame.scope = (Scriptable)frame.stack[scopeLocal];
						 frame.stack[exLocal] = throwable;
						 throwable = null;
					 }
					 else {
						 ContinuationJump cjump = (ContinuationJump)throwable;
						 throwable = null;
						 if (cjump.branchFrame != frame) Kit.codeBug();
						 if (cjump.capturedFrame == null) Kit.codeBug();
						 int rewindCount = cjump.capturedFrame.frameIndex + 1;
						 if (cjump.branchFrame != null) {
							 rewindCount -= cjump.branchFrame.frameIndex;
						 }
						 int enterCount = 0;
						 CallFrame[] enterFrames = null;
						 CallFrame x = cjump.capturedFrame;
						 for (int i = 0;
						 i != rewindCount;
						 ++i) {
							 if (!x.frozen) Kit.codeBug();
							 if (isFrameEnterExitRequired(x)) {
								 if (enterFrames == null) {
									 enterFrames = new CallFrame[rewindCount - i];
								 }
								 enterFrames[enterCount] = x;
								 ++enterCount;
							 }
							 x = x.parentFrame;
						 }
						 while (enterCount != 0) {
							 --enterCount;
							 x = enterFrames[enterCount];
							 enterFrame(cx, x, ScriptRuntime.emptyArgs);
						 }
						 frame = cjump.capturedFrame.cloneFrozen();
						 setCallResult(frame, cjump.result, cjump.resultDbl);
					 }
					 if (throwable != null) Kit.codeBug();
				 }
				 else {
					 if (frame.frozen) Kit.codeBug();
				 }
				 Object[] stack = frame.stack;
				 double[] sDbl = frame.sDbl;
				 Object[] vars = frame.varSource.stack;
				 double[] varDbls = frame.varSource.sDbl;
				 byte[] iCode = frame.idata.itsICode;
				 String[] strings = frame.idata.itsStringTable;
				 int stackTop = frame.savedStackTop;
				 cx.lastInterpreterFrame = frame;
				 Loop: for (;
				;
				) {
					 int op = iCode[frame.pc++];
					 jumplessRun: {
						switch (op) {
							 case Token.THROW: {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int sourceLine = getIndex(iCode, frame.pc);
								 throwable = new JavaScriptException(value, frame.idata.itsSourceFile, sourceLine);
								 break withoutExceptions;
							 }
							 case Token.RETHROW: {
								 indexReg += frame.localShift;
								 throwable = stack[indexReg];
								 break withoutExceptions;
							 }
							 case Token.GE : case Token.LE : case Token.GT : case Token.LT : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 object_compare: {
									 number_compare: {
										 double rDbl, lDbl;
										 if (rhs == DBL_MRK) {
											 rDbl = sDbl[stackTop + 1];
											 lDbl = stack_double(frame, stackTop);
										 }
										 else if (lhs == DBL_MRK) {
											 rDbl = ScriptRuntime.toNumber(rhs);
											 lDbl = sDbl[stackTop];
										 }
										 else {
											 break number_compare;
										 }
										 switch (op) {
											 case Token.GE: valBln = (lDbl >= rDbl);
											 break object_compare;
											 case Token.LE: valBln = (lDbl <= rDbl);
											 break object_compare;
											 case Token.GT: valBln = (lDbl > rDbl);
											 break object_compare;
											 case Token.LT: valBln = (lDbl < rDbl);
											 break object_compare;
											 default: throw Kit.codeBug();
										 }
									 }
									 switch (op) {
										 case Token.GE: valBln = ScriptRuntime.cmp_LE(rhs, lhs);
										 break;
										 case Token.LE: valBln = ScriptRuntime.cmp_LE(lhs, rhs);
										 break;
										 case Token.GT: valBln = ScriptRuntime.cmp_LT(rhs, lhs);
										 break;
										 case Token.LT: valBln = ScriptRuntime.cmp_LT(lhs, rhs);
										 break;
										 default: throw Kit.codeBug();
									 }
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IN : case Token.INSTANCEOF : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 boolean valBln;
								 if (op == Token.IN) {
									 valBln = ScriptRuntime.in(lhs, rhs, cx);
								 }
								 else {
									 valBln = ScriptRuntime.instanceOf(lhs, rhs, cx);
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.EQ : case Token.NE : {
								 --stackTop;
								 boolean valBln;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 if (rhs == DBL_MRK) {
									 if (lhs == DBL_MRK) {
										 valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
									 }
									 else {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
									 }
								 }
								 else {
									 if (lhs == DBL_MRK) {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
									 }
									 else {
										 valBln = ScriptRuntime.eq(lhs, rhs);
									 }
								 }
								 valBln ^= (op == Token.NE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.SHEQ : case Token.SHNE : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 shallow_compare: {
									 double rdbl, ldbl;
									 if (rhs == DBL_MRK) {
										 rdbl = sDbl[stackTop + 1];
										 if (lhs == DBL_MRK) {
											 ldbl = sDbl[stackTop];
										 }
										 else if (lhs instanceof Number) {
											 ldbl = ((Number)lhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else if (lhs == DBL_MRK) {
										 ldbl = sDbl[stackTop];
										 if (rhs == DBL_MRK) {
											 rdbl = sDbl[stackTop + 1];
										 }
										 else if (rhs instanceof Number) {
											 rdbl = ((Number)rhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else {
										 valBln = ScriptRuntime.shallowEq(lhs, rhs);
										 break shallow_compare;
									 }
									 valBln = (ldbl == rdbl);
								 }
								 valBln ^= (op == Token.SHNE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IFNE : if (stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Token.IFEQ : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Icode_IFEQ_POP : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 stack[stackTop--] = null;
							 break jumplessRun;
							 case Token.GOTO : break jumplessRun;
							 case Icode_GOSUB : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.pc + 2;
							 break jumplessRun;
							 case Icode_STARTSUB : if (stackTop == frame.emptyStackTop + 1) {
								 indexReg += frame.localShift;
								 stack[indexReg] = stack[stackTop];
								 sDbl[indexReg] = sDbl[stackTop];
								 --stackTop;
							 }
							 else {
								 if (stackTop != frame.emptyStackTop) Kit.codeBug();
							 }
							 continue Loop;
							 case Icode_RETSUB : {
								 if (instructionCounting) {
									 addInstructionCount(cx, frame, 0);
								 }
								 indexReg += frame.localShift;
								 Object value = stack[indexReg];
								 if (value != DBL_MRK) {
									 throwable = value;
									 break withoutExceptions;
								 }
								 frame.pc = (int)sDbl[indexReg];
								 if (instructionCounting) {
									 frame.pcPrevBranch = frame.pc;
								 }
								 continue Loop;
							 }
							 case Icode_POP : stack[stackTop] = null;
							 stackTop--;
							 continue Loop;
							 case Icode_POP_RESULT : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 stack[stackTop] = null;
							 --stackTop;
							 continue Loop;
							 case Icode_DUP : stack[stackTop + 1] = stack[stackTop];
							 sDbl[stackTop + 1] = sDbl[stackTop];
							 stackTop++;
							 continue Loop;
							 case Icode_DUP2 : stack[stackTop + 1] = stack[stackTop - 1];
							 sDbl[stackTop + 1] = sDbl[stackTop - 1];
							 stack[stackTop + 2] = stack[stackTop];
							 sDbl[stackTop + 2] = sDbl[stackTop];
							 stackTop += 2;
							 continue Loop;
							 case Icode_SWAP : {
								 Object o = stack[stackTop];
								 stack[stackTop] = stack[stackTop - 1];
								 stack[stackTop - 1] = o;
								 double d = sDbl[stackTop];
								 sDbl[stackTop] = sDbl[stackTop - 1];
								 sDbl[stackTop - 1] = d;
								 continue Loop;
							 }
							 case Token.RETURN : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 --stackTop;
							 break Loop;
							 case Token.RETURN_RESULT : break Loop;
							 case Icode_RETUNDEF : frame.result = undefined;
							 break Loop;
							 case Token.BITNOT : {
								 int rIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ~rIntValue;
								 continue Loop;
							 }
							 case Token.BITAND : case Token.BITOR : case Token.BITXOR : case Token.LSH : case Token.RSH : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.BITAND: lIntValue &= rIntValue;
									 break;
									 case Token.BITOR: lIntValue |= rIntValue;
									 break;
									 case Token.BITXOR: lIntValue ^= rIntValue;
									 break;
									 case Token.LSH: lIntValue <<= rIntValue;
									 break;
									 case Token.RSH: lIntValue >>= rIntValue;
									 break;
								 }
								 sDbl[stackTop] = lIntValue;
								 continue Loop;
							 }
							 case Token.URSH : {
								 int rIntValue = stack_int32(frame, stackTop) & 0x1F;
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;
								 continue Loop;
							 }
							 case Token.NEG : case Token.POS : {
								 double rDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 if (op == Token.NEG) {
									 rDbl = -rDbl;
								 }
								 sDbl[stackTop] = rDbl;
								 continue Loop;
							 }
							 case Token.ADD : --stackTop;
							 do_add(stack, sDbl, stackTop, cx);
							 continue Loop;
							 case Token.SUB : case Token.MUL : case Token.DIV : case Token.MOD : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.SUB: lDbl -= rDbl;
									 break;
									 case Token.MUL: lDbl *= rDbl;
									 break;
									 case Token.DIV: lDbl /= rDbl;
									 break;
									 case Token.MOD: lDbl %= rDbl;
									 break;
								 }
								 sDbl[stackTop] = lDbl;
								 continue Loop;
							 }
							 case Token.NOT : stack[stackTop] = ScriptRuntime.wrapBoolean( !stack_boolean(frame, stackTop));
							 continue Loop;
							 case Token.BINDNAME : stack[++stackTop] = ScriptRuntime.bind(cx, frame.scope, stringReg);
							 continue Loop;
							 case Token.SETNAME : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable lhs = (Scriptable)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx, frame.scope, stringReg);
								 continue Loop;
							 }
							 case Token.DELPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.delete(lhs, rhs, cx);
								 continue Loop;
							 }
							 case Token.GETPROP : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getObjectProp(lhs, stringReg, cx);
								 continue Loop;
							 }
							 case Token.SETPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setObjectProp(lhs, stringReg, rhs, cx);
								 continue Loop;
							 }
							 case Icode_PROP_INC_DEC : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.propIncrDecr(lhs, stringReg, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GETELEM : {
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.getObjectElem(lhs, id, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.getObjectIndex(lhs, d, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Token.SETELEM : {
								 stackTop -= 2;
								 Object rhs = stack[stackTop + 2];
								 if (rhs == DBL_MRK) {
									 rhs = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);
								 }
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.setObjectElem(lhs, id, rhs, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.setObjectIndex(lhs, d, rhs, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Icode_ELEM_INC_DEC: {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.elemIncrDecr(lhs, rhs, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GET_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refGet(ref, cx);
								 continue Loop;
							 }
							 case Token.SET_REF : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refSet(ref, value, cx);
								 continue Loop;
							 }
							 case Token.DEL_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refDel(ref, cx);
								 continue Loop;
							 }
							 case Icode_REF_INC_DEC : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refIncrDecr(ref, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.LOCAL_LOAD : ++stackTop;
							 indexReg += frame.localShift;
							 stack[stackTop] = stack[indexReg];
							 sDbl[stackTop] = sDbl[indexReg];
							 continue Loop;
							 case Icode_LOCAL_CLEAR : indexReg += frame.localShift;
							 stack[indexReg] = null;
							 continue Loop;
							 case Icode_NAME_AND_THIS : ++stackTop;
							 stack[stackTop] = ScriptRuntime.getNameFunctionAndThis(stringReg, cx, frame.scope);
							 ++stackTop;
							 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
							 continue Loop;
							 case Icode_PROP_AND_THIS: {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getPropFunctionAndThis(obj, stringReg, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_ELEM_AND_THIS: {
								 Object obj = stack[stackTop - 1];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop - 1]);
								 Object id = stack[stackTop];
								 if (id == DBL_MRK) id = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop - 1] = ScriptRuntime.getElemFunctionAndThis(obj, id, cx);
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_VALUE_AND_THIS : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getValueFunctionAndThis(value, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_CALLSPECIAL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 int callType = iCode[frame.pc] & 0xFF;
								 boolean isNew = (iCode[frame.pc + 1] != 0);
								 int sourceLine = getIndex(iCode, frame.pc + 2);
								 if (isNew) {
									 stackTop -= indexReg;
									 Object function = stack[stackTop];
									 if (function == DBL_MRK) function = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 1, indexReg);
									 stack[stackTop] = ScriptRuntime.newSpecial( cx, function, outArgs, frame.scope, callType);
								 }
								 else {
									 stackTop -= 1 + indexReg;
									 Scriptable functionThis = (Scriptable)stack[stackTop + 1];
									 Callable function = (Callable)stack[stackTop];
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callSpecial( cx, function, functionThis, outArgs, frame.scope, frame.thisObj, callType, frame.idata.itsSourceFile, sourceLine);
								 }
								 frame.pc += 4;
								 continue Loop;
							 }
							 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= 1 + indexReg;
								 Callable fun = (Callable)stack[stackTop];
								 Scriptable funThisObj = (Scriptable)stack[stackTop + 1];
								 if (op == Token.REF_CALL) {
									 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callRef(fun, funThisObj, outArgs, cx);
									 continue Loop;
								 }
								 Scriptable calleeScope = frame.scope;
								 if (frame.useActivation) {
									 calleeScope = ScriptableObject.getTopLevelScope(frame.scope);
								 }
								 if (fun instanceof InterpretedFunction) {
									 InterpretedFunction ifun = (InterpretedFunction)fun;
									 if (frame.fnOrScript.securityDomain == ifun.securityDomain) {
										 CallFrame callParentFrame = frame;
										 CallFrame calleeFrame = new CallFrame();
										 if (op == Icode_TAIL_CALL) {
											 callParentFrame = frame.parentFrame;
										 }
										 initFrame(cx, calleeScope, funThisObj, stack, sDbl, stackTop + 2, indexReg, ifun, callParentFrame, calleeFrame);
										 if (op == Icode_TAIL_CALL) {
											 exitFrame(cx, frame, null);
										 }
										 else {
											 frame.savedStackTop = stackTop;
											 frame.savedCallOp = op;
										 }
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (fun instanceof Continuation) {
									 ContinuationJump cjump;
									 cjump = new ContinuationJump((Continuation)fun, frame);
									 if (indexReg == 0) {
										 cjump.result = undefined;
									 }
									 else {
										 cjump.result = stack[stackTop + 2];
										 cjump.resultDbl = sDbl[stackTop + 2];
									 }
									 throwable = cjump;
									 break withoutExceptions;
								 }
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
								 stack[stackTop] = fun.call(cx, calleeScope, funThisObj, outArgs);
								 continue Loop;
							 }
							 case Token.NEW : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= indexReg;
								 Object lhs = stack[stackTop];
								 if (lhs instanceof InterpretedFunction) {
									 InterpretedFunction f = (InterpretedFunction)lhs;
									 if (frame.fnOrScript.securityDomain == f.securityDomain) {
										 Scriptable newInstance = f.createObject(cx, frame.scope);
										 CallFrame calleeFrame = new CallFrame();
										 initFrame(cx, frame.scope, newInstance, stack, sDbl, stackTop + 1, indexReg, f, frame, calleeFrame);
										 stack[stackTop] = newInstance;
										 frame.savedStackTop = stackTop;
										 frame.savedCallOp = op;
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (!(lhs instanceof Function)) {
									 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 throw ScriptRuntime.notFunctionError(lhs);
								 }
								 Function fun = (Function)lhs;
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 1, indexReg);
								 stack[stackTop] = fun.construct(cx, frame.scope, outArgs);
								 continue Loop;
							 }
							 case Token.TYPEOF : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.typeof(lhs);
								 continue Loop;
							 }
							 case Icode_TYPEOFNAME : stack[++stackTop] = ScriptRuntime.typeofName(frame.scope, stringReg);
							 continue Loop;
							 case Token.STRING : stack[++stackTop] = stringReg;
							 continue Loop;
							 case Icode_SHORTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getShort(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_INTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Token.NUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.idata.itsDoubleTable[indexReg];
							 continue Loop;
							 case Token.NAME : stack[++stackTop] = ScriptRuntime.name(cx, frame.scope, stringReg);
							 continue Loop;
							 case Icode_NAME_INC_DEC : stack[++stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, stringReg, iCode[frame.pc]);
							 ++frame.pc;
							 continue Loop;
							 case Icode_SETVAR1: indexReg = iCode[frame.pc++];
							 case Token.SETVAR : if (!frame.useActivation) {
								 vars[indexReg] = stack[stackTop];
								 varDbls[indexReg] = sDbl[stackTop];
							 }
							 else {
								 Object val = stack[stackTop];
								 if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stringReg = frame.idata.argNames[indexReg];
								 frame.scope.put(stringReg, frame.scope, val);
							 }
							 continue Loop;
							 case Icode_GETVAR1: indexReg = iCode[frame.pc++];
							 case Token.GETVAR : ++stackTop;
							 if (!frame.useActivation) {
								 stack[stackTop] = vars[indexReg];
								 sDbl[stackTop] = varDbls[indexReg];
							 }
							 else {
								 stringReg = frame.idata.argNames[indexReg];
								 stack[stackTop] = frame.scope.get(stringReg, frame.scope);
							 }
							 continue Loop;
							 case Icode_VAR_INC_DEC : {
								 ++stackTop;
								 int incrDecrMask = iCode[frame.pc];
								 if (!frame.useActivation) {
									 stack[stackTop] = DBL_MRK;
									 Object varValue = vars[indexReg];
									 double d;
									 if (varValue == DBL_MRK) {
										 d = varDbls[indexReg];
									 }
									 else {
										 d = ScriptRuntime.toNumber(varValue);
										 vars[indexReg] = DBL_MRK;
									 }
									 double d2 = ((incrDecrMask & Node.DECR_FLAG) == 0) ? d + 1.0 : d - 1.0;
									 varDbls[indexReg] = d2;
									 sDbl[stackTop] = ((incrDecrMask & Node.POST_FLAG) == 0) ? d2 : d;
								 }
								 else {
									 String varName = frame.idata.argNames[indexReg];
									 stack[stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, varName, incrDecrMask);
								 }
								 ++frame.pc;
								 continue Loop;
							 }
							 case Icode_ZERO : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_ONE : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 1;
							 continue Loop;
							 case Token.NULL : stack[++stackTop] = null;
							 continue Loop;
							 case Token.THIS : stack[++stackTop] = frame.thisObj;
							 continue Loop;
							 case Token.THISFN : stack[++stackTop] = frame.fnOrScript;
							 continue Loop;
							 case Token.FALSE : stack[++stackTop] = Boolean.FALSE;
							 continue Loop;
							 case Token.TRUE : stack[++stackTop] = Boolean.TRUE;
							 continue Loop;
							 case Icode_UNDEF : stack[++stackTop] = undefined;
							 continue Loop;
							 case Token.ENTERWITH : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterWith(lhs, cx, frame.scope);
								 continue Loop;
							 }
							 case Token.LEAVEWITH : frame.scope = ScriptRuntime.leaveWith(frame.scope);
							 continue Loop;
							 case Token.CATCH_SCOPE : {
								 --stackTop;
								 indexReg += frame.localShift;
								 boolean afterFirstScope = (frame.idata.itsICode[frame.pc] != 0);
								 Throwable caughtException = (Throwable)stack[stackTop + 1];
								 Scriptable lastCatchScope;
								 if (!afterFirstScope) {
									 lastCatchScope = null;
								 }
								 else {
									 lastCatchScope = (Scriptable)stack[indexReg];
								 }
								 stack[indexReg] = ScriptRuntime.newCatchScope(caughtException, lastCatchScope, stringReg, cx, frame.scope);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.ENUM_INIT_KEYS : case Token.ENUM_INIT_VALUES : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 indexReg += frame.localShift;
								 stack[indexReg] = ScriptRuntime.enumInit( lhs, cx, (op == Token.ENUM_INIT_VALUES));
								 continue Loop;
							 }
							 case Token.ENUM_NEXT : case Token.ENUM_ID : {
								 indexReg += frame.localShift;
								 Object val = stack[indexReg];
								 ++stackTop;
								 stack[stackTop] = (op == Token.ENUM_NEXT) ? (Object)ScriptRuntime.enumNext(val) : (Object)ScriptRuntime.enumId(val, cx);
								 continue Loop;
							 }
							 case Token.REF_SPECIAL : {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.specialRef(obj, stringReg, cx);
								 continue Loop;
							 }
							 case Token.REF_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, ns, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(ns, name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Icode_SCOPE_LOAD : indexReg += frame.localShift;
							 frame.scope = (Scriptable)stack[indexReg];
							 continue Loop;
							 case Icode_SCOPE_SAVE : indexReg += frame.localShift;
							 stack[indexReg] = frame.scope;
							 continue Loop;
							 case Icode_CLOSURE_EXPR : stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Icode_CLOSURE_STMT : initFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Token.REGEXP : stack[++stackTop] = frame.scriptRegExps[indexReg];
							 continue Loop;
							 case Icode_LITERAL_NEW : ++stackTop;
							 stack[stackTop] = new Object[indexReg];
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_LITERAL_SET : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Token.ARRAYLIT : case Icode_SPARE_ARRAYLIT : case Token.OBJECTLIT : {
								 Object[] data = (Object[])stack[stackTop];
								 Object val;
								 if (op == Token.OBJECTLIT) {
									 Object[] ids = (Object[])frame.idata.literalIds[indexReg];
									 val = ScriptRuntime.newObjectLiteral(ids, data, cx, frame.scope);
								 }
								 else {
									 int[] skipIndexces = null;
									 if (op == Icode_SPARE_ARRAYLIT) {
										 skipIndexces = (int[])frame.idata.literalIds[indexReg];
									 }
									 val = ScriptRuntime.newArrayLiteral(data, skipIndexces, cx, frame.scope);
								 }
								 stack[stackTop] = val;
								 continue Loop;
							 }
							 case Icode_ENTERDQ : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterDotQuery(lhs, frame.scope);
								 continue Loop;
							 }
							 case Icode_LEAVEDQ : {
								 boolean valBln = stack_boolean(frame, stackTop);
								 Object x = ScriptRuntime.updateDotQuery(valBln, frame.scope);
								 if (x != null) {
									 stack[stackTop] = x;
									 frame.scope = ScriptRuntime.leaveDotQuery(frame.scope);
									 frame.pc += 2;
									 continue Loop;
								 }
								 --stackTop;
								 break jumplessRun;
							 }
							 case Token.DEFAULTNAMESPACE : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setDefaultNamespace(value, cx);
								 continue Loop;
							 }
							 case Token.ESCXMLATTR : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeAttributeValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Token.ESCXMLTEXT : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeTextValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Icode_LINE : frame.pcSourceLineStart = frame.pc;
							 if (frame.debuggerFrame != null) {
								 int line = getIndex(iCode, frame.pc);
								 frame.debuggerFrame.onLineChange(cx, line);
							 }
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND_C0: indexReg = 0;
							 continue Loop;
							 case Icode_REG_IND_C1: indexReg = 1;
							 continue Loop;
							 case Icode_REG_IND_C2: indexReg = 2;
							 continue Loop;
							 case Icode_REG_IND_C3: indexReg = 3;
							 continue Loop;
							 case Icode_REG_IND_C4: indexReg = 4;
							 continue Loop;
							 case Icode_REG_IND_C5: indexReg = 5;
							 continue Loop;
							 case Icode_REG_IND1: indexReg = 0xFF & iCode[frame.pc];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_IND2: indexReg = getIndex(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND4: indexReg = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Icode_REG_STR_C0: stringReg = strings[0];
							 continue Loop;
							 case Icode_REG_STR_C1: stringReg = strings[1];
							 continue Loop;
							 case Icode_REG_STR_C2: stringReg = strings[2];
							 continue Loop;
							 case Icode_REG_STR_C3: stringReg = strings[3];
							 continue Loop;
							 case Icode_REG_STR1: stringReg = strings[0xFF & iCode[frame.pc]];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_STR2: stringReg = strings[getIndex(iCode, frame.pc)];
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_STR4: stringReg = strings[getInt(iCode, frame.pc)];
							 frame.pc += 4;
							 continue Loop;
							 default : dumpICode(frame.idata);
							 throw new RuntimeException( ""Unknown icode : ""+op+"" @ pc : ""+(frame.pc-1));
						}
					 }
					 if (instructionCounting) {
						 addInstructionCount(cx, frame, 2);
					 }
					 int offset = getShort(iCode, frame.pc);
					 if (offset != 0) {
						 frame.pc += offset - 1;
					 }
					 else {
						 frame.pc = frame.idata.longJumps. getExistingInt(frame.pc);
					 }
					 if (instructionCounting) {
						 frame.pcPrevBranch = frame.pc;
					 }
					 continue Loop;
				 }
				 exitFrame(cx, frame, null);
				 interpreterResult = frame.result;
				 interpreterResultDbl = frame.resultDbl;
				 if (frame.parentFrame != null) {
					 frame = frame.parentFrame;
					 if (frame.frozen) {
						 frame = frame.cloneFrozen();
					 }
					 setCallResult( frame, interpreterResult, interpreterResultDbl);
					 interpreterResult = null;
					 continue StateLoop;
				 }
				 break StateLoop;
			 }
			 catch (Throwable ex) {
				 if (throwable != null) {
					 ex.printStackTrace(System.err);
					 throw new IllegalStateException();
				 }
				 throwable = ex;
			 }
			 if (throwable == null) Kit.codeBug();
			 final int EX_CATCH_STATE = 2;
			 final int EX_FINALLY_STATE = 1;
			 final int EX_NO_JS_STATE = 0;
			 int exState;
			 ContinuationJump cjump = null;
			 if (throwable instanceof JavaScriptException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EcmaError) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EvaluatorException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof RuntimeException) {
				 exState = EX_FINALLY_STATE;
			 }
			 else if (throwable instanceof Error) {
				 exState = EX_NO_JS_STATE;
			 }
			 else {
				 exState = EX_FINALLY_STATE;
				 cjump = (ContinuationJump)throwable;
			 }
			 if (instructionCounting) {
				 try {
					 addInstructionCount(cx, frame, EXCEPTION_COST);
				 }
				 catch (RuntimeException ex) {
					 throwable = ex;
					 exState = EX_FINALLY_STATE;
				 }
				 catch (Error ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 if (frame.debuggerFrame != null && throwable instanceof RuntimeException) {
				 RuntimeException rex = (RuntimeException)throwable;
				 try {
					 frame.debuggerFrame.onExceptionThrown(cx, rex);
				 }
				 catch (Throwable ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 for (;
			;
			) {
				 if (exState != EX_NO_JS_STATE) {
					 boolean onlyFinally = (exState != EX_CATCH_STATE);
					 indexReg = getExceptionHandler(frame, onlyFinally);
					 if (indexReg >= 0) {
						 continue StateLoop;
					 }
				 }
				 exitFrame(cx, frame, throwable);
				 frame = frame.parentFrame;
				 if (frame == null) {
					 break;
				 }
				 if (cjump != null && cjump.branchFrame == frame) {
					 indexReg = -1;
					 continue StateLoop;
				 }
			 }
			 if (cjump != null) {
				 if (cjump.branchFrame != null) {
					 Kit.codeBug();
				 }
				 if (cjump.capturedFrame != null) {
					 indexReg = -1;
					 continue StateLoop;
				 }
				 interpreterResult = cjump.result;
				 interpreterResultDbl = cjump.resultDbl;
				 throwable = null;
			 }
			 break StateLoop;
		 }
		 if (cx.previousInterpreterInvocations != null && cx.previousInterpreterInvocations.size() != 0) {
			 cx.lastInterpreterFrame = cx.previousInterpreterInvocations.pop();
		 }
		 else {
			 cx.lastInterpreterFrame = null;
			 cx.previousInterpreterInvocations = null;
		 }
		 if (throwable != null) {
			 if (throwable instanceof RuntimeException) {
				 throw (RuntimeException)throwable;
			 }
			 else {
				 throw (Error)throwable;
			 }
		 }
		 return (interpreterResult != DBL_MRK) ? interpreterResult : ScriptRuntime.wrapNumber(interpreterResultDbl);
	 }
	 private static void initFrame(Context cx, Scriptable callerScope, Scriptable thisObj, Object[] args, double[] argsDbl, int argShift, int argCount, InterpretedFunction fnOrScript, CallFrame parentFrame, CallFrame frame) {
		 InterpreterData idata = fnOrScript.idata;
		 boolean useActivation = idata.itsNeedsActivation;
		 DebugFrame debuggerFrame = null;
		 if (cx.debugger != null) {
			 debuggerFrame = cx.debugger.getFrame(cx, idata);
			 if (debuggerFrame != null) {
				 useActivation = true;
			 }
		 }
		 if (useActivation) {
			 if (argsDbl != null) {
				 args = getArgsArray(args, argsDbl, argShift, argCount);
			 }
			 argShift = 0;
			 argsDbl = null;
		 }
		 Scriptable scope;
		 if (idata.itsFunctionType != 0) {
			 if (!idata.useDynamicScope) {
				 scope = fnOrScript.getParentScope();
			 }
			 else {
				 scope = callerScope;
			 }
			 if (useActivation) {
				 scope = ScriptRuntime.createFunctionActivation( fnOrScript, scope, args);
			 }
		 }
		 else {
			 scope = callerScope;
			 ScriptRuntime.initScript(fnOrScript, thisObj, cx, scope, fnOrScript.idata.evalScriptFlag);
		 }
		 if (idata.itsNestedFunctions != null) {
			 if (idata.itsFunctionType != 0 && !idata.itsNeedsActivation) Kit.codeBug();
			 for (int i = 0;
			 i < idata.itsNestedFunctions.length;
			 i++) {
				 InterpreterData fdata = idata.itsNestedFunctions[i];
				 if (fdata.itsFunctionType == FunctionNode.FUNCTION_STATEMENT) {
					 initFunction(cx, scope, fnOrScript, i);
				 }
			 }
		 }
		 Scriptable[] scriptRegExps = null;
		 if (idata.itsRegExpLiterals != null) {
			 if (idata.itsFunctionType != 0) {
				 scriptRegExps = fnOrScript.functionRegExps;
			 }
			 else {
				 scriptRegExps = fnOrScript.createRegExpWraps(cx, scope);
			 }
		 }
		 int emptyStackTop = idata.itsMaxVars + idata.itsMaxLocals - 1;
		 int maxFrameArray = idata.itsMaxFrameArray;
		 if (maxFrameArray != emptyStackTop + idata.itsMaxStack + 1) Kit.codeBug();
		 Object[] stack;
		 double[] sDbl;
		 boolean stackReuse;
		 if (frame.stack != null && maxFrameArray <= frame.stack.length) {
			 stackReuse = true;
			 stack = frame.stack;
			 sDbl = frame.sDbl;
		 }
		 else {
			 stackReuse = false;
			 stack = new Object[maxFrameArray];
			 sDbl = new double[maxFrameArray];
		 }
		 int definedArgs = idata.argCount;
		 if (definedArgs > argCount) {
			 definedArgs = argCount;
		 }
		 frame.parentFrame = parentFrame;
		 frame.frameIndex = (parentFrame == null) ? 0 : parentFrame.frameIndex + 1;
		 if(frame.frameIndex > cx.getMaximumInterpreterStackDepth()) {
			 throw Context.reportRuntimeError(""Exceeded maximum stack depth"");
		 }
		 frame.frozen = false;
		 frame.fnOrScript = fnOrScript;
		 frame.idata = idata;
		 frame.stack = stack;
		 frame.sDbl = sDbl;
		 frame.varSource = frame;
		 frame.localShift = idata.itsMaxVars;
		 frame.emptyStackTop = emptyStackTop;
		 frame.debuggerFrame = debuggerFrame;
		 frame.useActivation = useActivation;
		 frame.thisObj = thisObj;
		 frame.scriptRegExps = scriptRegExps;
		 frame.result = Undefined.instance;
		 frame.pc = 0;
		 frame.pcPrevBranch = 0;
		 frame.pcSourceLineStart = idata.firstLinePC;
		 frame.scope = scope;
		 frame.savedStackTop = emptyStackTop;
		 frame.savedCallOp = 0;
		 System.arraycopy(args, argShift, stack, 0, definedArgs);
		 if (argsDbl != null) {
			 System.arraycopy(argsDbl, argShift, sDbl, 0, definedArgs);
		 }
		 for (int i = definedArgs;
		 i != idata.itsMaxVars;
		 ++i) {
			 stack[i] = Undefined.instance;
		 }
		 if (stackReuse) {
			 for (int i = emptyStackTop + 1;
			 i != stack.length;
			 ++i) {
				 stack[i] = null;
			 }
		 }
		 enterFrame(cx, frame, args);
	 }
	 private static boolean isFrameEnterExitRequired(CallFrame frame) {
		 return frame.debuggerFrame != null || frame.idata.itsNeedsActivation;
	 }
	 private static void enterFrame(Context cx, CallFrame frame, Object[] args) {
		 if (frame.debuggerFrame != null) {
			 frame.debuggerFrame.onEnter(cx, frame.scope, frame.thisObj, args);
		 }
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.enterActivationFunction(cx, frame.scope);
		 }
	 }
	 private static void exitFrame(Context cx, CallFrame frame, Object throwable) {
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.exitActivationFunction(cx);
		 }
		 if (frame.debuggerFrame != null) {
			 try {
				 if (throwable instanceof Throwable) {
					 frame.debuggerFrame.onExit(cx, true, throwable);
				 }
				 else {
					 Object result;
					 ContinuationJump cjump = (ContinuationJump)throwable;
					 if (cjump == null) {
						 result = frame.result;
					 }
					 else {
						 result = cjump.result;
					 }
					 if (result == UniqueTag.DOUBLE_MARK) {
						 double resultDbl;
						 if (cjump == null) {
							 resultDbl = frame.resultDbl;
						 }
						 else {
							 resultDbl = cjump.resultDbl;
						 }
						 result = ScriptRuntime.wrapNumber(resultDbl);
					 }
					 frame.debuggerFrame.onExit(cx, false, result);
				 }
			 }
			 catch (Throwable ex) {
				 System.err.println(""RHINO USAGE WARNING: onExit terminated with exception"");
				 ex.printStackTrace(System.err);
			 }
		 }
	 }
	 private static void setCallResult(CallFrame frame, Object callResult, double callResultDbl) {
		 if (frame.savedCallOp == Token.CALL) {
			 frame.stack[frame.savedStackTop] = callResult;
			 frame.sDbl[frame.savedStackTop] = callResultDbl;
		 }
		 else if (frame.savedCallOp == Token.NEW) {
			 if (callResult instanceof Scriptable) {
				 frame.stack[frame.savedStackTop] = callResult;
			 }
		 }
		 else {
			 Kit.codeBug();
		 }
		 frame.savedCallOp = 0;
	 }
	 private static void captureContinuation(Context cx, CallFrame frame, int stackTop) {
		 Continuation c = new Continuation();
		 ScriptRuntime.setObjectProtoAndParent( c, ScriptRuntime.getTopCallScope(cx));
		 CallFrame x = frame.parentFrame;
		 while (x != null && !x.frozen) {
			 x.frozen = true;
			 for (int i = x.savedStackTop + 1;
			 i != x.stack.length;
			 ++i) {
				 x.stack[i] = null;
			 }
			 if (x.savedCallOp == Token.CALL) {
				 x.stack[x.savedStackTop] = null;
			 }
			 else {
				 if (x.savedCallOp != Token.NEW) Kit.codeBug();
			 }
			 x = x.parentFrame;
		 }
		 c.initImplementation(frame.parentFrame);
		 frame.stack[stackTop] = c;
	 }
	 private static int stack_int32(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 double value;
		 if (x == UniqueTag.DOUBLE_MARK) {
			 value = frame.sDbl[i];
		 }
		 else {
			 value = ScriptRuntime.toNumber(x);
		 }
		 return ScriptRuntime.toInt32(value);
	 }
	 private static double stack_double(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x != UniqueTag.DOUBLE_MARK) {
			 return ScriptRuntime.toNumber(x);
		 }
		 else {
			 return frame.sDbl[i];
		 }
	 }
	 private static boolean stack_boolean(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x == Boolean.TRUE) {
			 return true;
		 }
		 else if (x == Boolean.FALSE) {
			 return false;
		 }
		 else if (x == UniqueTag.DOUBLE_MARK) {
			 double d = frame.sDbl[i];
			 return d == d && d != 0.0;
		 }
		 else if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 double d = ((Number)x).doubleValue();
			 return (d == d && d != 0.0);
		 }
		 else if (x instanceof Boolean) {
			 return ((Boolean)x).booleanValue();
		 }
		 else {
			 return ScriptRuntime.toBoolean(x);
		 }
	 }
	 private static void do_add(Object[] stack, double[] sDbl, int stackTop, Context cx) {
		 Object rhs = stack[stackTop + 1];
		 Object lhs = stack[stackTop];
		 double d;
		 boolean leftRightOrder;
		 if (rhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop + 1];
			 if (lhs == UniqueTag.DOUBLE_MARK) {
				 sDbl[stackTop] += d;
				 return;
			 }
			 leftRightOrder = true;
		 }
		 else if (lhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop];
			 lhs = rhs;
			 leftRightOrder = false;
		 }
		 else {
			 if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
				 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
			 }
			 else if (lhs instanceof String) {
				 String lstr = (String)lhs;
				 String rstr = ScriptRuntime.toString(rhs);
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else if (rhs instanceof String) {
				 String lstr = ScriptRuntime.toString(lhs);
				 String rstr = (String)rhs;
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
				 double rDbl = (rhs instanceof Number) ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
				 stack[stackTop] = UniqueTag.DOUBLE_MARK;
				 sDbl[stackTop] = lDbl + rDbl;
			 }
			 return;
		 }
		 if (lhs instanceof Scriptable) {
			 rhs = ScriptRuntime.wrapNumber(d);
			 if (!leftRightOrder) {
				 Object tmp = lhs;
				 lhs = rhs;
				 rhs = tmp;
			 }
			 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
		 }
		 else if (lhs instanceof String) {
			 String lstr = (String)lhs;
			 String rstr = ScriptRuntime.toString(d);
			 if (leftRightOrder) {
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 stack[stackTop] = rstr.concat(lstr);
			 }
		 }
		 else {
			 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
			 stack[stackTop] = UniqueTag.DOUBLE_MARK;
			 sDbl[stackTop] = lDbl + d;
		 }
	 }
	 private static Object[] getArgsArray(Object[] stack, double[] sDbl, int shift, int count) {
		 if (count == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] args = new Object[count];
		 for (int i = 0;
		 i != count;
		 ++i, ++shift) {
			 Object val = stack[shift];
			 if (val == UniqueTag.DOUBLE_MARK) {
				 val = ScriptRuntime.wrapNumber(sDbl[shift]);
			 }
			 args[i] = val;
		 }
		 return args;
	 }
	 private static void addInstructionCount(Context cx, CallFrame frame, int extra) {
		 cx.instructionCount += frame.pc - frame.pcPrevBranch + extra;
		 if (cx.instructionCount > cx.instructionThreshold) {
			 cx.observeInstructionCount(cx.instructionCount);
			 cx.instructionCount = 0;
		 }
	 }
}",1,0,0,0
"public class IteratorVariableElements extends AbstractParserRuleElementFinder {
	private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.xtext.ui.tests.editor.contentassist.BacktrackingContentAssistTestLanguage.iteratorVariable"");
	private final Group cGroup = (Group)rule.eContents().get(1);
	private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
	private final RuleCall cNameIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
	private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
	private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
	private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
	private final RuleCall cTypeTypeExpParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
	 public ParserRule getRule() {
		 return rule;
	 }
	public Group getGroup() {
		 return cGroup;
	 }
	public Assignment getNameAssignment_0() {
		 return cNameAssignment_0;
	 }
	public RuleCall getNameIdentifierParserRuleCall_0_0() {
		 return cNameIdentifierParserRuleCall_0_0;
	 }
	public Group getGroup_1() {
		 return cGroup_1;
	 }
	public Keyword getColonKeyword_1_0() {
		 return cColonKeyword_1_0;
	 }
	public Assignment getTypeAssignment_1_1() {
		 return cTypeAssignment_1_1;
	 }
	public RuleCall getTypeTypeExpParserRuleCall_1_1_0() {
		 return cTypeTypeExpParserRuleCall_1_1_0;
	 }
}",0,1,0,0
"public final boolean isDefault(){
	return name == PageMap.DEFAULT_NAME;
}",0,0,0,0
"public static class MaybeSupplier<T> extends AbstractPresent<T> {
	 private static final long serialVersionUID = -823731500051341455L;
	 private final Supplier<T> supplier;
	 public MaybeSupplier(Supplier<T> value) {
		 this.supplier = value;
	 }
	 public T get() {
		 return supplier.get();
	 }
	 public Supplier<T> getSupplier() {
		 return supplier;
	 }
 }",0,0,0,0
"WalkingIteratorSorted( Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers) throws javax.xml.transform.TransformerException;",0,0,0,0
"private void changeInclination( int deltaX, int deltaY, NodeView linkedNodeView, Point changedInclination);",0,0,0,0
"abstract class LocksFeatureUI extends FeatureUI {
	 private ProfilerToolbar toolbar;
	 private LockContentionPanel locksView;
	 abstract ProfilerClient getProfilerClient();
	 abstract void refreshResults();
	 ProfilerToolbar getToolbar() {
		 if (toolbar == null) initUI();
		 return toolbar;
	 }
	 JPanel getResultsUI() {
		 if (locksView == null) initUI();
		 return locksView;
	 }
	 void sessionStateChanged(int sessionState) {
		 refreshToolbar(sessionState);
		 if (sessionState == Profiler.PROFILING_INACTIVE || sessionState == Profiler.PROFILING_IN_TRANSITION) {
			 if (locksView != null) locksView.profilingSessionFinished();
		 }
		 else if (sessionState == Profiler.PROFILING_RUNNING) {
			 if (locksView != null) locksView.profilingSessionStarted();
		 }
	 }
	 void resetPause() {
	 }
	 void setForceRefresh() {
		 if (locksView != null) locksView.setForceRefresh(true);
	 }
	 void refreshData() throws ClientUtils.TargetAppOrVMTerminated {
		 if (locksView != null) locksView.refreshData();
	 }
	 void resetData() {
		 if (locksView != null) locksView.resetData();
	 }
	 private JLabel shLabel;
	 private ActionPopupButton shAggregation;
	 private void initUI() {
		 assert SwingUtilities.isEventDispatchThread();
		 locksView = new LockContentionPanel() {
			 protected ProfilerClient getProfilerClient() {
				 return LocksFeatureUI.this.getProfilerClient();
			 }
		 }
		;
		 locksView.lockContentionEnabled();
		 locksView.putClientProperty(""HelpCtx.Key"", ""ProfileLocks.HelpCtx"");
		 shLabel = new GrayLabel(Bundle.LocksFeatureUI_show());
		 Action aThreads = new AbstractAction() {
			 {
				 putValue(NAME, Bundle.LocksFeatureUI_aggregationByThreads());
			 }
			 public void actionPerformed(ActionEvent e) {
				 setAggregation(LockContentionPanel.Aggregation.BY_THREADS);
			 }
		 }
		;
		 Action aMonitors = new AbstractAction() {
			 {
				 putValue(NAME, Bundle.LocksFeatureUI_aggregationByMonitors());
			 }
			 public void actionPerformed(ActionEvent e) {
				 setAggregation(LockContentionPanel.Aggregation.BY_MONITORS);
			 }
		 }
		;
		 shAggregation = new ActionPopupButton(aThreads, aMonitors);
		 shAggregation.setToolTipText(Bundle.LocksFeatureUI_aggregationHint());
		 toolbar = ProfilerToolbar.create(true);
		 toolbar.addSpace(2);
		 toolbar.addSeparator();
		 toolbar.addSpace(5);
		 toolbar.add(shLabel);
		 toolbar.addSpace(2);
		 toolbar.add(shAggregation);
		 setAggregation(LockContentionPanel.Aggregation.BY_THREADS);
		 sessionStateChanged(getSessionState());
	 }
	 private void refreshToolbar(final int state) {
	 }
	 private void setAggregation(LockContentionPanel.Aggregation aggregation) {
		 locksView.setAggregation(aggregation);
		 shAggregation.selectAction(aggregation.ordinal());
	 }
}",1,0,0,0
"public interface TreeStringRenderer {
	 public void renderNodeBegin(Appendable writer, Map<String, Object> context, ModelTree.ModelNode node, int depth) throws IOException;
	 public void renderNodeEnd(Appendable writer, Map<String, Object> context, ModelTree.ModelNode node) throws IOException;
	 public void renderLabel(Appendable writer, Map<String, Object> context, ModelTree.ModelNode.Label label) throws IOException;
	 public void renderLink(Appendable writer, Map<String, Object> context, ModelTree.ModelNode.Link link) throws IOException;
	 public void renderImage(Appendable writer, Map<String, Object> context, ModelTree.ModelNode.Image image) throws IOException;
	 public void renderLastElement(Appendable writer, Map<String, Object> context, ModelTree.ModelNode node) throws IOException;
	 public ScreenStringRenderer getScreenStringRenderer(Map<String, Object> context);
}",0,0,0,0
"public static class DeleteBySearchProcessor extends AbstractProcessor<DeleteBySearch> {
	 public DeleteBySearchProcessor() {
		 this( DeleteBySearch.class );
	 }
	 public DeleteBySearchProcessor( Class<? extends DeleteBySearch> realType ) {
		 super( realType );
	 }
	 protected void doProcess( SQLProcessorAggregator processor, DeleteBySearch object, StringBuilder builder ) {
		 builder.append( ""DELETE FROM"" ).append( SQLConstants.TOKEN_SEPARATOR );
		 processor.process( object.getTargetTable(), builder );
		 QueryProcessing.processOptionalBooleanExpression( processor, builder, object.getWhere(), SQLConstants.NEWLINE, SQLConstants.WHERE );
	 }
 }",0,0,0,0
"public class NetworkBridgeStatistics extends StatsImpl {
	 protected CountStatisticImpl enqueues;
	 protected CountStatisticImpl dequeues;
	 protected CountStatisticImpl receivedCount;
	 public NetworkBridgeStatistics() {
		 enqueues = new CountStatisticImpl(""enqueues"", ""The current number of enqueues this bridge has, which is the number of potential messages to be forwarded."");
		 dequeues = new CountStatisticImpl(""dequeues"", ""The current number of dequeues this bridge has, which is the number of messages received by the remote broker."");
		 receivedCount = new CountStatisticImpl(""receivedCount"", ""The number of messages that have been received by the NetworkBridge from the remote broker. Only applies for Duplex bridges."");
		 addStatistic(""enqueues"", enqueues);
		 addStatistic(""dequeues"", dequeues);
		 addStatistic(""receivedCount"", receivedCount);
	 }
	 public CountStatisticImpl getEnqueues() {
		 return enqueues;
	 }
	 public CountStatisticImpl getDequeues() {
		 return dequeues;
	 }
	 public CountStatisticImpl getReceivedCount() {
		 return receivedCount;
	 }
	 public void reset() {
		 if (this.isDoReset()) {
			 super.reset();
			 enqueues.reset();
			 dequeues.reset();
			 receivedCount.reset();
		 }
	 }
	 public void setEnabled(boolean enabled) {
		 super.setEnabled(enabled);
		 enqueues.setEnabled(enabled);
		 dequeues.setEnabled(enabled);
		 receivedCount.setEnabled(enabled);
	 }
	 public void setParent(NetworkBridgeStatistics parent) {
		 if (parent != null) {
			 enqueues.setParent(parent.enqueues);
			 dequeues.setParent(parent.dequeues);
			 receivedCount.setParent(parent.receivedCount);
		 }
		 else {
			 enqueues.setParent(null);
			 dequeues.setParent(null);
			 receivedCount.setParent(null);
		 }
	 }
}",0,1,0,0
"public class MorphShape extends Symbol {
	 protected Shape shape1;
	 protected Shape shape2;
	 public MorphShape( Shape shape1, Shape shape2 ) {
		 this.shape1 = shape1;
		 this.shape2 = shape2;
	 }
	 public Shape getShape1() {
		 return shape1;
	 }
	 public Shape getShape2() {
		 return shape2;
	 }
	 public void setShape1( Shape s ) {
		 shape1 = s;
	 }
	 public void setShape2( Shape s ) {
		 shape2 = s;
	 }
	 protected int defineSymbol( Movie movie, SWFTagTypes timelineWriter, SWFTagTypes definitionWriter ) throws IOException {
		 int id = getNextId( movie );
		 SWFShape shape = definitionWriter.tagDefineMorphShape( id, shape1.getRect(), shape2.getRect() );
		 shape1.hasAlpha = true;
		 shape2.hasAlpha = true;
		 shape1.writeShape( shape );
		 shape2.writeShape( shape );
		 return id;
	 }
}",0,1,0,0
"public class CheckHealthAnswer extends Answer {
	 public CheckHealthAnswer() {
	 }
	 public CheckHealthAnswer(CheckHealthCommand cmd, boolean alive) {
		 super(cmd, alive, ""resource is "" + (alive ? ""alive"" : ""not alive""));
	 }
}",0,0,0,0
"abstract class AbstractDirectoryCleanerArgs {
	 public abstract DirectoryCleaner.PathSelector getPathSelector();
	 public long getMaxTotalSizeBytes() {
		 return Long.MAX_VALUE;
	 }
	 public int getMaxPathCount() {
		 return Integer.MAX_VALUE;
	 }
	 public int getMinAmountOfEntriesToKeep() {
		 return 0;
	 }
	 public abstract Optional<Long> getMaxBytesAfterDeletion();
}",0,0,0,0
"private static String normalizePath(String path) {
	 int index = -1;
	 int pathlen = path.length();
	 int size = 0;
	 if (pathlen > 0 && path.charAt(0) != '/') {
		 size++;
	 }
	 while ((index = path.indexOf('/', index + 1)) != -1) {
		 if (index + 1 < pathlen && path.charAt(index + 1) != '/') {
			 size++;
		 }
	 }
	 String[] seglist = new String[size];
	 boolean[] include = new boolean[size];
	 int current = 0;
	 int index2 = 0;
	 index = (pathlen > 0 && path.charAt(0) == '/') ? 1 : 0;
	 while ((index2 = path.indexOf('/', index + 1)) != -1) {
		 seglist[current++] = path.substring(index, index2);
		 index = index2 + 1;
	 }
	 if (current < size) {
		 seglist[current] = path.substring(index);
	 }
	 for (int i = 0;
	 i < size;
	 i++) {
		 include[i] = true;
		 if (seglist[i].equals("".."")) {
			 int remove = i - 1;
			 while (remove > -1 && !include[remove]) {
				 remove--;
			 }
			 if (remove > -1 && !seglist[remove].equals("".."")) {
				 include[remove] = false;
				 include[i] = false;
			 }
		 }
		 else if (seglist[i].equals(""."")) {
			 include[i] = false;
		 }
	 }
	 StringBuilder newpath = new StringBuilder();
	 if (path.startsWith(""/"")) {
		 newpath.append('/');
	 }
	 for (int i = 0;
	 i < seglist.length;
	 i++) {
		 if (include[i]) {
			 newpath.append(seglist[i]);
			 newpath.append('/');
		 }
	 }
	 if (!path.endsWith(""/"") && seglist.length > 0 && include[seglist.length - 1]) {
		 newpath.deleteCharAt(newpath.length() - 1);
	 }
	 String result = newpath.toString();
	 index = result.indexOf(':');
	 index2 = result.indexOf('/');
	 if (index != -1 && (index < index2 || index2 == -1)) {
		 newpath.insert(0, ""./"");
		 result = newpath.toString();
	 }
	 return result;
 }",0,0,1,0
"public boolean accept(File dir, String name) {
	 Pair<Descriptor,Component> component = tryComponentFromFilename(dir, name);
	 if (component != null && component.left.equals(desc)) components.add(component.right);
	 return false;
 }",0,0,0,0
"public IResourceFactory getResourceFactory(final String name){
	return nameToResourceFactory.get(name);
}",0,0,0,0
"public class AnnotationSubstitutionType extends CustomSubstitutionType<AnnotationSubstitutionField, AnnotationSubstitutionMethod> {
	 private final String name;
	 public AnnotationSubstitutionType(MetaAccessProvider metaAccess, ResolvedJavaType original) {
		 super(original);
		 assert original.getSuperclass().equals(metaAccess.lookupJavaType(Proxy.class));
		 assert metaAccess.lookupJavaType(Annotation.class).isAssignableFrom(original);
		 ResolvedJavaType annotationInterfaceType = AnnotationSupport.findAnnotationInterfaceType(original);
		 assert annotationInterfaceType.isAssignableFrom(original);
		 assert metaAccess.lookupJavaType(Annotation.class).isAssignableFrom(annotationInterfaceType);
		 String n = annotationInterfaceType.getName();
		 assert n.endsWith("";
		"");
		 name = n.substring(0, n.length() - 1) + ""$$ProxyImpl;
		"";
	 }
	 public String getName() {
		 return name;
	 }
	 public String toString() {
		 return ""AnnotationType<"" + toJavaName(true) + "" -> "" + original + "">"";
	 }
}",0,1,0,0
"abstract class CondList {
	 protected final Node thenPart;
	 protected final java.util.List<Tree.Condition> conditions;
	 public CondList(java.util.List<Tree.Condition> conditions, Tree.Block thenPart) {
		 this.conditions = conditions;
		 this.thenPart = thenPart;
	 }
	 public CondList(java.util.List<Tree.Condition> conditions, Tree.Expression thenPart) {
		 this.conditions = conditions;
		 this.thenPart = thenPart;
	 }
	 protected Cond getConditionTransformer(Tree.Condition cond) {
		 return getConditionTransformer(cond, null);
	 }
	 protected Cond getConditionTransformer(Tree.Condition cond, Tree.Variable elseVariable) {
		 if (cond instanceof Tree.IsCondition) {
			 Tree.IsCondition is = (Tree.IsCondition)cond;
			 IsVarTrans var = new IsVarTrans(is.getVariable());
			 IsVarTrans elseVar = (elseVariable != null) ? new IsVarTrans(elseVariable, var.getTestVariableName()) : null;
			 return new IsCond(is, var, elseVar);
		 }
		 else if (cond instanceof Tree.ExistsCondition) {
			 Tree.ExistsCondition exists = (Tree.ExistsCondition)cond;
			 ExistsVarTrans var = new ExistsVarTrans(exists.getVariable());
			 ExistsVarTrans elseVar = (elseVariable != null) ? new ExistsVarTrans(elseVariable, var.getTestVariableName()) : null;
			 return new ExistsCond(exists, var, elseVar);
		 }
		 else if (cond instanceof Tree.NonemptyCondition) {
			 Tree.NonemptyCondition nonempty = (Tree.NonemptyCondition)cond;
			 NonemptyVarTrans var = new NonemptyVarTrans(nonempty.getVariable());
			 NonemptyVarTrans elseVar = (elseVariable != null) ? new NonemptyVarTrans(elseVariable, var.getTestVariableName()) : null;
			 return new NonemptyCond(nonempty, var, elseVar);
		 }
		 else if (cond instanceof Tree.BooleanCondition) {
			 if (this instanceof AssertCondList) {
				 Tree.Term booleanExpr = TreeUtil.unwrapExpressionUntilTerm(((Tree.BooleanCondition)cond).getExpression());
				 boolean negated;
				 if (booleanExpr instanceof Tree.NotOp) {
					 negated = true;
					 booleanExpr = TreeUtil.unwrapExpressionUntilTerm(((Tree.NotOp)booleanExpr).getTerm());
				 }
				 else {
					 negated = false;
				 }
				 if (booleanExpr instanceof Tree.IsOp) {
					 return new IsOpBooleanCond((Tree.BooleanCondition)cond, negated, (Tree.IsOp)booleanExpr);
				 }
				 else if (booleanExpr instanceof Tree.EqualityOp ||booleanExpr instanceof Tree.ComparisonOp) {
					 return new EqualityOpBooleanCond((Tree.BooleanCondition)cond, negated, (Tree.BinaryOperatorExpression)booleanExpr);
				 }
				 else if (booleanExpr instanceof Tree.WithinOp) {
					 return new WithinOpBooleanCond((Tree.BooleanCondition)cond, negated, (Tree.WithinOp)booleanExpr);
				 }
			 }
			 return new BooleanCond((Tree.BooleanCondition)cond);
		 }
		 throw BugException.unhandledNodeCase(cond);
	 }
	 protected List<JCStatement> transformList(java.util.List<Tree.Condition> conditions) {
		 Tree.Condition condition = conditions.get(0);
		 at(condition);
		 if (conditions.size() == 1) {
			 return transformInnermost(condition);
		 }
		 else {
			 return transformIntermediate(condition, conditions.subList(1, conditions.size()));
		 }
	 }
	 protected abstract List<JCStatement> transformInnermost(Tree.Condition condition);
	 protected List<JCStatement> transformIntermediate(Tree.Condition condition, java.util.List<Tree.Condition> rest) {
		 return transformList(rest);
	 }
	 public abstract List<JCStatement> getResult();
 }",0,0,0,0
"public class MacroInstance extends Task implements DynamicAttribute, TaskContainer {
	 private MacroDef macroDef;
	 private Map map = new HashMap();
	 private Map nsElements = null;
	 private Map presentElements;
	 private Hashtable localAttributes;
	 private String text = null;
	 private String implicitTag = null;
	 private List unknownElements = new ArrayList();
	 public void setMacroDef(MacroDef macroDef) {
		 this.macroDef = macroDef;
	 }
	 public MacroDef getMacroDef() {
		 return macroDef;
	 }
	 public void setDynamicAttribute(String name, String value) {
		 map.put(name, value);
	 }
	 public Object createDynamicElement(String name) throws BuildException {
		 throw new BuildException(""Not implemented any more"");
	 }
	 private Map getNsElements() {
		 if (nsElements == null) {
			 nsElements = new HashMap();
			 for (Iterator i = macroDef.getElements().entrySet().iterator();
			 i.hasNext();
			) {
				 Map.Entry entry = (Map.Entry) i.next();
				 nsElements.put((String) entry.getKey(), entry.getValue());
				 MacroDef.TemplateElement te = (MacroDef.TemplateElement) entry.getValue();
				 if (te.isImplicit()) {
					 implicitTag = te.getName();
				 }
			 }
		 }
		 return nsElements;
	 }
	 public void addTask(Task nestedTask) {
		 unknownElements.add(nestedTask);
	 }
	 private void processTasks() {
		 if (implicitTag != null) {
			 return;
		 }
		 for (Iterator i = unknownElements.iterator();
		 i.hasNext();
		) {
			 UnknownElement ue = (UnknownElement) i.next();
			 String name = ProjectHelper.extractNameFromComponentName( ue.getTag()).toLowerCase(Locale.ENGLISH);
			 if (getNsElements().get(name) == null) {
				 throw new BuildException(""unsupported element "" + name);
			 }
			 if (presentElements.get(name) != null) {
				 throw new BuildException(""Element "" + name + "" already present"");
			 }
			 presentElements.put(name, ue);
		 }
	 }
	 public static class Element implements TaskContainer {
		 private List unknownElements = new ArrayList();
		 public void addTask(Task nestedTask) {
			 unknownElements.add(nestedTask);
		 }
		 public List getUnknownElements() {
			 return unknownElements;
		 }
	 }
	 private static final int STATE_NORMAL = 0;
	 private static final int STATE_EXPECT_BRACKET = 1;
	 private static final int STATE_EXPECT_NAME = 2;
	 private String macroSubs(String s, Map macroMapping) {
		 if (s == null) {
			 return null;
		 }
		 StringBuffer ret = new StringBuffer();
		 StringBuffer macroName = null;
		 int state = STATE_NORMAL;
		 for (int i = 0;
		 i < s.length();
		 ++i) {
			 char ch = s.charAt(i);
			 switch (state) {
				 case STATE_NORMAL: if (ch == '@') {
					 state = STATE_EXPECT_BRACKET;
				 }
				 else {
					 ret.append(ch);
				 }
				 break;
				 case STATE_EXPECT_BRACKET: if (ch == '{
					') {
						 state = STATE_EXPECT_NAME;
						 macroName = new StringBuffer();
					 }
					 else if (ch == '@') {
						 state = STATE_NORMAL;
						 ret.append('@');
					 }
					 else {
						 state = STATE_NORMAL;
						 ret.append('@');
						 ret.append(ch);
					 }
					 break;
				 case STATE_EXPECT_NAME: if (ch == '}
				') {
					 state = STATE_NORMAL;
					 String name = macroName.toString().toLowerCase(Locale.ENGLISH);
					 String value = (String) macroMapping.get(name);
					 if (value == null) {
						 ret.append(""@{
							"");
							 ret.append(name);
						 ret.append(""}
						"");
					 }
					 else {
						 ret.append(value);
					 }
					 macroName = null;
				 }
				 else {
					 macroName.append(ch);
				 }
				 break;
				 default: break;
			 }
		 }
		 switch (state) {
			 case STATE_NORMAL: break;
			 case STATE_EXPECT_BRACKET: ret.append('@');
			 break;
			 case STATE_EXPECT_NAME: ret.append(""@{
				"");
				 ret.append(macroName.toString());
				 break;
				 default: break;
			 }
			 return ret.toString();
		 }
		 public void addText(String text) {
			 this.text = text;
		 }
		 private UnknownElement copy(UnknownElement ue, boolean nested) {
			 UnknownElement ret = new UnknownElement(ue.getTag());
			 ret.setNamespace(ue.getNamespace());
			 ret.setProject(getProject());
			 ret.setQName(ue.getQName());
			 ret.setTaskType(ue.getTaskType());
			 ret.setTaskName(ue.getTaskName());
			 ret.setLocation( macroDef.getBackTrace() ? ue.getLocation() : getLocation());
			 if (getOwningTarget() == null) {
				 Target t = new Target();
				 t.setProject(getProject());
				 ret.setOwningTarget(t);
			 }
			 else {
				 ret.setOwningTarget(getOwningTarget());
			 }
			 RuntimeConfigurable rc = new RuntimeConfigurable( ret, ue.getTaskName());
			 rc.setPolyType(ue.getWrapper().getPolyType());
			 Map m = ue.getWrapper().getAttributeMap();
			 for (Iterator i = m.entrySet().iterator();
			 i.hasNext();
			) {
				 Map.Entry entry = (Map.Entry) i.next();
				 rc.setAttribute( (String) entry.getKey(), macroSubs((String) entry.getValue(), localAttributes));
			 }
			 rc.addText(macroSubs(ue.getWrapper().getText().toString(), localAttributes));
			 Enumeration e = ue.getWrapper().getChildren();
			 while (e.hasMoreElements()) {
				 RuntimeConfigurable r = (RuntimeConfigurable) e.nextElement();
				 UnknownElement unknownElement = (UnknownElement) r.getProxy();
				 String tag = unknownElement.getTaskType();
				 if (tag != null) {
					 tag = tag.toLowerCase(Locale.ENGLISH);
				 }
				 MacroDef.TemplateElement templateElement = (MacroDef.TemplateElement) getNsElements().get(tag);
				 if (templateElement == null || nested) {
					 UnknownElement child = copy(unknownElement, nested);
					 rc.addChild(child.getWrapper());
					 ret.addChild(child);
				 }
				 else if (templateElement.isImplicit()) {
					 if (unknownElements.size() == 0 && !templateElement.isOptional()) {
						 throw new BuildException( ""Missing nested elements for implicit element "" + templateElement.getName());
					 }
					 for (Iterator i = unknownElements.iterator();
					 i.hasNext();
					) {
						 UnknownElement child = copy((UnknownElement) i.next(), true);
						 rc.addChild(child.getWrapper());
						 ret.addChild(child);
					 }
				 }
				 else {
					 UnknownElement presentElement = (UnknownElement) presentElements.get(tag);
					 if (presentElement == null) {
						 if (!templateElement.isOptional()) {
							 throw new BuildException( ""Required nested element "" + templateElement.getName() + "" missing"");
						 }
						 continue;
					 }
					 String presentText = presentElement.getWrapper().getText().toString();
					 if (!"""".equals(presentText)) {
						 rc.addText(macroSubs(presentText, localAttributes));
					 }
					 List list = presentElement.getChildren();
					 if (list != null) {
						 for (Iterator i = list.iterator();
						 i.hasNext();
						) {
							 UnknownElement child = copy((UnknownElement) i.next(), true);
							 rc.addChild(child.getWrapper());
							 ret.addChild(child);
						 }
					 }
				 }
			 }
			 return ret;
		 }
		 public void execute() {
			 presentElements = new HashMap();
			 getNsElements();
			 processTasks();
			 localAttributes = new Hashtable();
			 Set copyKeys = new HashSet(map.keySet());
			 for (Iterator i = macroDef.getAttributes().iterator();
			 i.hasNext();
			) {
				 MacroDef.Attribute attribute = (MacroDef.Attribute) i.next();
				 String value = (String) map.get(attribute.getName());
				 if (value == null && ""description"".equals(attribute.getName())) {
					 value = getDescription();
				 }
				 if (value == null) {
					 value = attribute.getDefault();
					 value = macroSubs(value, localAttributes);
				 }
				 if (value == null) {
					 throw new BuildException( ""required attribute "" + attribute.getName() + "" not set"");
				 }
				 localAttributes.put(attribute.getName(), value);
				 copyKeys.remove(attribute.getName());
			 }
			 if (copyKeys.contains(""id"")) {
				 copyKeys.remove(""id"");
			 }
			 if (macroDef.getText() != null) {
				 if (text == null) {
					 String defaultText = macroDef.getText().getDefault();
					 if (!macroDef.getText().getOptional() && defaultText == null) {
						 throw new BuildException( ""required text missing"");
					 }
					 text = defaultText == null ? """" : defaultText;
				 }
				 if (macroDef.getText().getTrim()) {
					 text = text.trim();
				 }
				 localAttributes.put(macroDef.getText().getName(), text);
			 }
			 else {
				 if (text != null && !text.trim().equals("""")) {
					 throw new BuildException( ""The \"""" + getTaskName() + ""\"" macro does not support"" + "" nested text data."");
				 }
			 }
			 if (copyKeys.size() != 0) {
				 throw new BuildException( ""Unknown attribute"" + (copyKeys.size() > 1 ? ""s "" : "" "") + copyKeys);
			 }
			 UnknownElement c = copy(macroDef.getNestedTask(), false);
			 c.init();
			 LocalProperties localProperties = LocalProperties.get(getProject());
			 localProperties.enterScope();
			 try {
				 c.perform();
			 }
			 catch (BuildException ex) {
				 if (macroDef.getBackTrace()) {
					 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
				 }
				 else {
					 ex.setLocation(getLocation());
					 throw ex;
				 }
			 }
			 finally {
				 presentElements = null;
				 localAttributes = null;
				 localProperties.exitScope();
			 }
		 }
	}",0,0,0,0
"public class JpaMigrateException extends Exception {
	 private static final long serialVersionUID = 1L;
	 public JpaMigrateException() {
	 }
	 public JpaMigrateException(String message) {
		 super(message);
	 }
	 public JpaMigrateException(Throwable cause) {
		 super(cause);
	 }
	 public JpaMigrateException(String message, Throwable cause) {
		 super(message, cause);
	 }
}",0,0,0,0
"public byte[] getCentralDirectoryData() {
	 if (data == null) {
		 this.assembleData();
	 }
	 return data;
 }",0,0,0,0
"private LabeledInstructions parseMethodInstructions(Method method) throws ParsingException, GrammerException {
	Hashtable labelMap = new Hashtable();
	ArrayList toUpdate = new ArrayList();
	ArrayList codes = new ArrayList(), info;
	Attribute_Code.Opcode op = null;
	OpcodeInfo opinfo;
	String temp, retType, type, label = null;
	StringBuffer paras = new StringBuffer();
	int t = 0, i = 0, j = 0, high, low, npairs, counter, tokenType, offset = 0, codeLength = 0;
	byte[][] operands = null;
	boolean isWide = false, record = false;
	while (scanner.tokenType() != EOF && scanner.tokenType() != Attribute && scanner.tokenType() != Bracket_Right) {
		switch (scanner.tokenType()) {
			case JavaName:record = true;
			label = scanner.token();
			if (scanner.nextToken() != Colon) {
				exception(scanner, ""expecting.':'.after.label.name"");
			}
			if (scanner.nextToken() != Instruction) {
				exception(scanner, ""expecting.instruction.after.label"");
			}
			case Instruction: {
				opinfo = OpcodeHelper.getOpcodeInfo(scanner.token());
				switch (opinfo.opcode) {
					case Constants.TABLESWITCH:scanner.nextToken();
					info = new ArrayList();
					if (scanner.token().equals(""default"") == false) {
						exception(scanner, ""'default'.expected.here"");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					scanner.nextToken();
					info.add(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""low"") == false) {
						exception(scanner, ""'low'.expected.here."");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here."");
					}
					low = parseInteger(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""high"") == false) {
						exception(scanner, ""'high'.expected.here."");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here."");
					}
					high = parseInteger(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""jump_table"") == false) {
						exception(scanner, ""'jump_table'.expected.here."");
					}
					if (scanner.nextToken() != Colon) {
						exception(scanner, ""':'.expected.here."");
					}
					scanner.nextToken();
					counter = 0;
					while (scanner.tokenType() != EOF) {
						if (scanner.tokenType() != JavaName) {
							exception(scanner, ""label.name.expected.here"");
						}
						info.add(scanner.token());
						if (scanner.nextToken() != Comma) {
							break;
						}
						scanner.nextToken();
					}
					operands = new byte[high - low + 5][];
					operands[0] = new byte[3 - offset % 4];
					for (i = 0;
					 i < operands[0].length;
					 i++) {
						operands[0][i] = (byte) 0;
					}
					operands[2] = Util.getBytes(low, 4);
					operands[3] = Util.getBytes(high, 4);
					op = new OpcodeWrapper(offset, opinfo.opcode, operands, info);
					toUpdate.add(op);
					codeLength = 1 + operands[0].length + operands.length * 4 - 4;
					info = null;
					break;
					case Constants.LOOKUPSWITCH:scanner.nextToken();
					info = new ArrayList();
					if (scanner.token().equals(""default"") == false) {
						exception(scanner, ""'default'.expected.here"");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					scanner.nextToken();
					info.add(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""npairs"") == false) {
						exception(scanner, ""'npairs'.expected.here."");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here."");
					}
					npairs = parseInteger(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""jump_table"") == false) {
						exception(scanner, ""'jump_table'.expected.here."");
					}
					if (scanner.nextToken() != Colon) {
						exception(scanner, ""':'.expected.here."");
					}
					scanner.nextToken();
					operands = new byte[npairs * 2 + 3][];
					operands[0] = new byte[3 - offset % 4];
					for (i = 0;
					 i < operands[0].length;
					 i++) {
						operands[0][i] = (byte) 0;
					}
					operands[2] = Util.getBytes(npairs, 4);
					counter = 3;
					while (scanner.tokenType() != EOF) {
						if (scanner.tokenType() != Number_Integer) {
							exception(scanner, ""number.expected.here"");
						}
						operands[counter] = Util.getBytes(parseInteger(scanner.token()), 4);
						counter = counter + 2;
						if (scanner.nextToken() != Pointer) {
							exception(scanner, ""->.expected.here"");
						}
						scanner.nextToken();
						info.add(scanner.token());
						if (scanner.nextToken() != Comma) {
							break;
						}
						scanner.nextToken();
					}
					op = new OpcodeWrapper(offset, opinfo.opcode, operands, info);
					codeLength = 1 + operands[0].length + operands.length * 4 - 4;
					toUpdate.add(op);
					info = null;
					break;
					case Constants.GETFIELD:case Constants.GETSTATIC:case Constants.PUTFIELD:case Constants.PUTSTATIC:scanner.nextToken();
					operands = new byte[1][];
					type = scanner.token();
					scanner.nextToken();
					temp = scanner.token();
					i = temp.lastIndexOf('.');
					i = cpl.addFieldref(temp.substring(i + 1), temp.substring(0, i), type);
					operands[0] = Util.getBytes(i, 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.INVOKESPECIAL:case Constants.INVOKESTATIC:case Constants.INVOKEVIRTUAL:operands = new byte[1][];
					scanner.nextToken();
					retType = scanner.token();
					scanner.nextToken();
					temp = scanner.token();
					i = temp.lastIndexOf('.');
					if ((scanner.nextToken() == SBracket_Left) == false) {
						exception(scanner, ""'('.expected.here"");
					}
					if (scanner.nextToken() != SBracket_Right) {
						while (scanner.tokenType() != SBracket_Right && scanner.tokenType() != EOF) {
							paras.append(scanner.token());
							if (scanner.nextToken() == Comma) {
								paras.append(',');
								scanner.nextToken();
							}
						}
						if (scanner.tokenType() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					 else {
						paras.append("""");
					}
					operands[0] = Util.getBytes(cpl.addMethodref(temp.substring(i + 1), temp.substring(0, i), retType, paras.toString()), 2);
					paras.delete(0, paras.length());
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.INVOKEINTERFACE:scanner.nextToken();
					operands = new byte[3][];
					retType = scanner.token();
					scanner.nextToken();
					temp = scanner.token();
					i = temp.lastIndexOf('.');
					if (scanner.nextToken() == SBracket_Left == false) {
						exception(scanner, ""'('.expected.here"");
					}
					if (scanner.nextToken() != SBracket_Right) {
						while (scanner.tokenType() != SBracket_Right && scanner.tokenType() != EOF) {
							paras.append(scanner.token());
							if (scanner.nextToken() == Comma) {
								paras.append(',');
								scanner.nextToken();
							}
						}
						if (scanner.tokenType() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					 else {
						paras.append("""");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here"");
					}
					t = parseInteger(scanner.token());
					operands[0] = Util.getBytes(cpl.addInterfaceMethodref(temp.substring(i + 1), temp.substring(0, i), retType, paras.toString()), 2);
					operands[1] = Util.getBytes(t, 1);
					operands[2] = Util.getBytes(0, 1);
					 codeLength = 5;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					paras.delete(0, paras.length());
					break;
					case Constants.NEW:case Constants.CHECKCAST:case Constants.INSTANCEOF:scanner.nextToken();
					operands = new byte[1][];
					operands[0] = Util.getBytes(cpl.addClass(scanner.token()), 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.LDC:scanner.nextToken();
					operands = new byte[1][];
					temp = scanner.token();
					tokenType = scanner.tokenType();
					if (tokenType == String) {
						i = cpl.addString(Util.parseViewableString(temp.substring(1, temp.length() - 1)));
					}
					 else if (tokenType == Number_Float || tokenType == Number_Float_Positive_Infinity || tokenType == Number_Float_Negativ_Infinity|| tokenType == Number_Float_NaN) {
						i = cpl.addFloat(parseFloat(temp));
					}
					 else if (tokenType == Number_Integer) {
						i = cpl.addInteger(parseInteger(temp));
					}
					 else {
						exception(scanner, ""expecting.integer.or.string.or.float.here"");
					}
					if (i < 255) {
						operands[0] = Util.getBytes(i, 1);
						codeLength = 2;
						op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					}
					 else {
						operands[0] = Util.getBytes(i, 2);
						op = new Attribute_Code.Opcode(offset, Constants.LDC_W, operands);
						codeLength = 3;
					}
					scanner.nextToken();
					break;
					case Constants.LDC_W:scanner.nextToken();
					operands = new byte[1][];
					temp = scanner.token();
					tokenType = scanner.tokenType();
					if (tokenType == String) {
						i = cpl.addString(Util.parseViewableString(temp.substring(1, temp.length() - 1)));
					}
					 else if (tokenType == Number_Float || tokenType == Number_Float_NaN || tokenType == Number_Float_Negativ_Infinity|| tokenType == Number_Float_Positive_Infinity) {
						i = cpl.addFloat(parseFloat(temp));
					}
					 else if (tokenType == Number_Integer) {
						i = cpl.addInteger(parseInteger(temp));
					}
					 else {
						exception(scanner, ""expecting.integer.or.string.or.float.here"");
					}
					operands[0] = Util.getBytes(i, 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.LDC2_W:scanner.nextToken();
					operands = new byte[1][];
					temp = scanner.token();
					tokenType = scanner.tokenType();
					if (tokenType == Number_Long) {
						i = cpl.addLong(parseLong(temp));
					}
					 else if (tokenType == Number_Double || tokenType == Number_Double_NaN || tokenType == Number_Double_Negativ_Infinity|| tokenType == Number_Double_Positive_Infinity) {
						i = cpl.addDouble(parseDouble(temp));
					}
					 else {
						exception(scanner, ""expecting.long.or.double.here"");
					}
					operands[0] = Util.getBytes(i, 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.NEWARRAY:scanner.nextToken();
					operands = new byte[1][1];
					operands[0][0] = Util.getPrimitiveTypeCode(scanner.token());
					codeLength = 2;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.ANEWARRAY:scanner.nextToken();
					operands = new byte[1][];
					operands[0] = Util.getBytes(cpl.addClass(scanner.token()), 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.MULTIANEWARRAY:scanner.nextToken();
					operands = new byte[2][];
					type = scanner.token();
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""dimesion.number.expected.here"");
					}
					i = parseInteger(scanner.token());
					operands[1] = Util.getBytes(i, 1);
					 operands[0] = Util.getBytes(cpl.addClass(type), 2);
					codeLength = 4;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.WIDE:isWide = true;
					codeLength = 1;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.IINC:operands = new byte[2][];
					scanner.nextToken();
					if (scanner.tokenType() == Number_Integer) {
						i = parseInteger(scanner.token());
					}
					 else {
						if (scanner.nextToken() != SBracket_Left) {
							exception(scanner, ""'('.expected.here"");
						}
						if (scanner.nextToken() != Number_Integer) {
							exception(scanner, ""local.variable.index.expected.here"");
						}
						i = parseInteger(scanner.token());
						if (scanner.nextToken() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					scanner.nextToken();
					if (scanner.tokenType() != Number_Integer) {
						exception(scanner, ""increment.amount.expected.here"");
					}
					j = parseInteger(scanner.token());
					if (isWide == true) {
						operands[0] = Util.getBytes(i, 2);
						operands[1] = Util.getBytes(j, 2);
						codeLength = 5;
					}
					 else {
						operands[0] = Util.getBytes(i, 1);
						operands[1] = Util.getBytes(j, 1);
						codeLength = 3;
					}
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.ALOAD:case Constants.ASTORE:case Constants.DLOAD:case Constants.DSTORE:case Constants.FLOAD:case Constants.FSTORE:case Constants.ILOAD:case Constants.ISTORE:case Constants.LLOAD:case Constants.LSTORE:case Constants.RET:operands = new byte[1][];
					scanner.nextToken();
					if (scanner.tokenType() == Number_Integer) {
						i = parseInteger(scanner.token());
					}
					 else {
						if (scanner.nextToken() != SBracket_Left) {
							exception(scanner, ""'('.expected.here"");
						}
						if (scanner.nextToken() != Number_Integer) {
							exception(scanner, ""local.variable.index.expected.here"");
						}
						i = parseInteger(scanner.token());
						if (scanner.nextToken() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					if (isWide == true) {
						operands[0] = Util.getBytes(i, 2);
						codeLength = 2;
						isWide = false;
					}
					 else {
						operands[0] = Util.getBytes(i, 1);
						codeLength = 2;
					}
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.GOTO:case Constants.IFEQ:case Constants.IFGE:case Constants.IFGT:case Constants.IFLE:case Constants.IFLT:case Constants.JSR:case Constants.IFNE:case Constants.IFNONNULL:case Constants.IFNULL:case Constants.IF_ACMPEQ:case Constants.IF_ACMPNE:case Constants.IF_ICMPEQ:case Constants.IF_ICMPGE:case Constants.IF_ICMPGT:case Constants.IF_ICMPLE:case Constants.IF_ICMPLT:case Constants.IF_ICMPNE:case Constants.GOTO_W:case Constants.JSR_W:scanner.nextToken();
					operands = new byte[1][];
					codeLength = 3;
					op = new OpcodeWrapper(offset, opinfo.opcode, operands, scanner.token());
					toUpdate.add(op);
					scanner.nextToken();
					break;
					case Constants.BIPUSH:default:operands = new byte[opinfo.operandsCount][];
					for (i = 0;
					 i < opinfo.operandsCount;
					 i++) {
						if (scanner.nextToken() != Number_Integer) {
							exception(scanner, ""number.expected.here"");
						}
						operands[i] = Util.getBytes(parseInteger(scanner.token()), opinfo.operandsLength[i]);
						codeLength = codeLength + opinfo.operandsLength[i];
					}
					scanner.nextToken();
					codeLength++;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
				}
				break;
			}
			case Attribute:break;
			default:exception(scanner, ""label.name.or.instructions.expected.here"");
		}
		offset = offset + codeLength;
		codes.add(op);
		if (record) {
			labelMap.put(label, op);
			label = null;
		}
		record = false;
		operands = null;
		codeLength = 0;
	}
	updateLabelLinks(labelMap, toUpdate);
	return new LabeledInstructions((Attribute_Code.Opcode[]) codes.toArray(new Attribute_Code.Opcode[codes.size()]), labelMap, offset);
}",0,0,1,0
"public boolean split(Token t) {
	 if (!(size < maxsize)) return false;
	 try {
		 root = splitHelper(root, fullRange.left, fullRange.right, (byte)0, t);
	 }
	 catch (StopRecursion.TooDeep e) {
		 return false;
	 }
	 return true;
 }",0,0,0,0
"static class DumpConfigCommand {
	 boolean allConfiguration = false;
	 String directory = null;
	 boolean systemConfiguration = false;
	 boolean namespaceConfiguration = false;
	 List<String> tables = new ArrayList<>();
	 boolean users = false;
 }",0,0,0,0
"final class FileIterator implements BytesRefIterator {
	 private boolean done = false;
	 private final BytesRefBuilder spare = new BytesRefBuilder();
	 public BytesRef next() throws IOException {
		 if (done) {
			 return null;
		 }
		 boolean success = false;
		 BytesRef result;
		 try {
			 String line;
			 if ((line = in.readLine()) != null) {
				 spare.copyChars(line);
				 result = spare.get();
			 }
			 else {
				 done = true;
				 IOUtils.close(in);
				 result = null;
			 }
			 success = true;
		 }
		 finally {
			 if (!success) {
				 IOUtils.closeWhileHandlingException(in);
			 }
		 }
		 return result;
	 }
 }",0,0,0,0
"public class MarkupResourceData{
	private static final Logger log = LoggerFactory.getLogger(MarkupResourceData.class);
	public static final MarkupResourceData NO_MARKUP_RESOURCE_DATA = new MarkupResourceData();
	private MarkupResourceStream resource;
	private Markup baseMarkup;
	private String xmlDeclaration;
	private String encoding;
	private String wicketNamespace;
	private String wicketId;
	MarkupResourceData(){
		setWicketNamespace(ComponentTag.DEFAULT_WICKET_NAMESPACE);
	}
	public String toString(){
		if (resource != null){
			return resource.toString();
		}
		else{
			return ""(unknown resource)"";
		}
	}
	public MarkupResourceStream getResource(){
		return resource;
	}
	public String getXmlDeclaration(){
		return xmlDeclaration;
	}
	public String getEncoding(){
		return encoding;
	}
	public String getWicketNamespace(){
		return wicketNamespace;
	}
	final public String getWicketId(){
		return wicketId;
	}
	final void setEncoding(final String encoding){
		this.encoding = encoding;
	}
	public final void setWicketNamespace(final String wicketNamespace){
		this.wicketNamespace = wicketNamespace;
		wicketId = wicketNamespace + "":id"";
		if (!ComponentTag.DEFAULT_WICKET_NAMESPACE.equals(wicketNamespace)){
			log.info(""You are using a non-standard component name: "" + wicketNamespace);
		}
	}
	final void setXmlDeclaration(final String xmlDeclaration){
		this.xmlDeclaration = xmlDeclaration;
	}
	final void setResource(final MarkupResourceStream resource){
		this.resource = resource;
	}
	public MarkupResourceData getBaseMarkupResourceData(){
		if (baseMarkup == null){
			return null;
		}
		return baseMarkup.getMarkupResourceData();
	}
	public void setBaseMarkup(Markup baseMarkup){
		this.baseMarkup = baseMarkup;
	}
	public Markup getBaseMarkup(){
		return baseMarkup;
	}
}",0,0,0,0
"public abstract class FileUploadBase{
	public static final boolean isMultipartContent(RequestContext ctx){
		String contentType = ctx.getContentType();
		if (contentType == null){
			return false;
		}
		if (contentType.toLowerCase().startsWith(MULTIPART)){
			return true;
		}
		return false;
	}
	public static boolean isMultipartContent(HttpServletRequest req){
		return ServletFileUpload.isMultipartContent(req);
	}
	public static final String CONTENT_TYPE = ""Content-type"";
	public static final String CONTENT_DISPOSITION = ""Content-disposition"";
	public static final String CONTENT_LENGTH = ""Content-length"";
	public static final String FORM_DATA = ""form-data"";
	public static final String ATTACHMENT = ""attachment"";
	public static final String MULTIPART = ""multipart/"";
	public static final String MULTIPART_FORM_DATA = ""multipart/form-data"";
	public static final String MULTIPART_MIXED = ""multipart/mixed"";
	public static final int MAX_HEADER_SIZE = 1024;
	private long sizeMax = -1;
	private long fileSizeMax = -1;
	private String headerEncoding;
	private ProgressListener listener;
	public abstract FileItemFactory getFileItemFactory();
	public abstract void setFileItemFactory(FileItemFactory factory);
	public long getSizeMax(){
		return sizeMax;
	}
	public void setSizeMax(long sizeMax){
		this.sizeMax = sizeMax;
	}
	public long getFileSizeMax(){
		return fileSizeMax;
	}
	public void setFileSizeMax(long fileSizeMax){
		this.fileSizeMax = fileSizeMax;
	}
	public String getHeaderEncoding(){
		return headerEncoding;
	}
	public void setHeaderEncoding(String encoding){
		headerEncoding = encoding;
	}
	public List<FileItem> parseRequest(HttpServletRequest req) throws FileUploadException{
		return parseRequest(new ServletRequestContext(req));
	}
	public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException,IOException{
		return new FileItemIteratorImpl(ctx);
	}
	public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException{
		try{
			FileItemIterator iter = getItemIterator(ctx);
			List<FileItem> items = new ArrayList<FileItem>();
			FileItemFactory fac = getFileItemFactory();
			if (fac == null){
				throw new NullPointerException(""No FileItemFactory has been set."");
			}
			while (iter.hasNext()){
				FileItemStream item = iter.next();
				FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),item.isFormField(), item.getName());
				try{
					Streams.copyAndClose(item.openStream(), fileItem.getOutputStream());
				}
				catch (FileUploadIOException e){
					throw (FileUploadException)e.getCause();
				}
				catch (IOException e){
					throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA +"" request failed. "" + e.getMessage(), e);
				}
				if (fileItem instanceof FileItemHeadersSupport){
					final FileItemHeaders fih = item.getHeaders();
					((FileItemHeadersSupport)fileItem).setHeaders(fih);
				}
				items.add(fileItem);
			}
			return items;
		}
		catch (FileUploadIOException e){
			throw (FileUploadException)e.getCause();
		}
		catch (IOException e){
			throw new FileUploadException(e.getMessage(), e);
		}
	}
	protected byte[] getBoundary(String contentType){
		ParameterParser parser = new ParameterParser();
		parser.setLowerCaseNames(true);
		Map params = parser.parse(contentType, new char[] {
			 ';
		', ',' }
		);
		String boundaryStr = (String)params.get(""boundary"");
		if (boundaryStr == null){
			return null;
		}
		byte[] boundary;
		try{
			boundary = boundaryStr.getBytes(""ISO-8859-1"");
		}
		catch (UnsupportedEncodingException e){
			boundary = boundaryStr.getBytes();
		}
		return boundary;
	}
	protected String getFileName(Map<String, String> headers){
		return getFileName(getHeader(headers, CONTENT_DISPOSITION));
	}
	protected String getFileName(FileItemHeaders headers){
		return getFileName(headers.getHeader(CONTENT_DISPOSITION));
	}
	private String getFileName(String pContentDisposition){
		String fileName = null;
		if (pContentDisposition != null){
			String cdl = pContentDisposition.toLowerCase();
			if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)){
				ParameterParser parser = new ParameterParser();
				parser.setLowerCaseNames(true);
				Map params = parser.parse(pContentDisposition, ';
				');
				if (params.containsKey(""filename"")){
					fileName = (String)params.get(""filename"");
					if (fileName != null){
						fileName = fileName.trim();
					}
					else{
						fileName = """";
					}
				}
			}
		}
		return fileName;
	}
	protected String getFieldName(FileItemHeaders headers){
		return getFieldName(headers.getHeader(CONTENT_DISPOSITION));
	}
	private String getFieldName(String pContentDisposition){
		String fieldName = null;
		if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)){
			ParameterParser parser = new ParameterParser();
			parser.setLowerCaseNames(true);
			Map params = parser.parse(pContentDisposition, ';
			');
			fieldName = (String)params.get(""name"");
			if (fieldName != null){
				fieldName = fieldName.trim();
			}
		}
		return fieldName;
	}
	protected String getFieldName(Map<String, String> headers){
		return getFieldName(getHeader(headers, CONTENT_DISPOSITION));
	}
	protected FileItem createItem(Map <String, String> headers, boolean isFormField)throws FileUploadException{
		return getFileItemFactory().createItem(getFieldName(headers),getHeader(headers, CONTENT_TYPE), isFormField, getFileName(headers));
	}
	protected FileItemHeaders getParsedHeaders(String headerPart){
		final int len = headerPart.length();
		FileItemHeadersImpl headers = newFileItemHeaders();
		int start = 0;
		for (;
		;
		){
			int end = parseEndOfLine(headerPart, start);
			if (start == end){
				break;
			}
			String header = headerPart.substring(start, end);
			start = end + 2;
			while (start < len){
				int nonWs = start;
				while (nonWs < len){
					char c = headerPart.charAt(nonWs);
					if (c != ' ' && c != '\t'){
						break;
					}
					++nonWs;
				}
				if (nonWs == start){
					break;
				}
				end = parseEndOfLine(headerPart, nonWs);
				header += "" "" + headerPart.substring(nonWs, end);
				start = end + 2;
			}
			parseHeaderLine(headers, header);
		}
		return headers;
	}
	protected FileItemHeadersImpl newFileItemHeaders(){
		return new FileItemHeadersImpl();
	}
	protected Map parseHeaders(String headerPart){
		FileItemHeaders headers = getParsedHeaders(headerPart);
		Map result = new HashMap();
		for (Iterator iter = headers.getHeaderNames();
		 iter.hasNext();
		){
			String headerName = (String)iter.next();
			Iterator iter2 = headers.getHeaders(headerName);
			String headerValue = (String)iter2.next();
			while (iter2.hasNext()){
				headerValue += "","" + iter2.next();
			}
			result.put(headerName, headerValue);
		}
		return result;
	}
	private int parseEndOfLine(String headerPart, int end){
		int index = end;
		for (;
		;
		){
			int offset = headerPart.indexOf('\r', index);
			if (offset == -1 || offset + 1 >= headerPart.length()){
				throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
			}
			if (headerPart.charAt(offset + 1) == '\n'){
				return offset;
			}
			index = offset + 1;
		}
	}
	private void parseHeaderLine(FileItemHeadersImpl headers, String header){
		final int colonOffset = header.indexOf(':');
		if (colonOffset == -1){
			return;
		}
		String headerName = header.substring(0, colonOffset).trim();
		String headerValue = header.substring(header.indexOf(':') + 1).trim();
		headers.addHeader(headerName, headerValue);
	}
	protected final String getHeader(Map<String, String> headers, String name){
		return (String)headers.get(name.toLowerCase());
	}
	private class FileItemIteratorImpl implements FileItemIterator{
		private class FileItemStreamImpl implements FileItemStream{
			private final String contentType;
			private final String fieldName;
			private final String name;
			private final boolean formField;
			private final InputStream stream;
			private boolean opened;
			private FileItemHeaders headers;
			FileItemStreamImpl(String pName, String pFieldName, String pContentType,boolean pFormField, long pContentLength) throws IOException{
				name = pName;
				fieldName = pFieldName;
				contentType = pContentType;
				formField = pFormField;
				final ItemInputStream itemStream = multi.newInputStream();
				InputStream istream = itemStream;
				if (fileSizeMax != -1){
					if (pContentLength != -1 && pContentLength > fileSizeMax){
						FileUploadException e = new FileSizeLimitExceededException(""The field "" +fieldName + "" exceeds its maximum permitted "" + "" size of "" +fileSizeMax + "" characters."", pContentLength, fileSizeMax);
						throw new FileUploadIOException(e);
					}
					istream = new LimitedInputStream(istream, fileSizeMax){
						protected void raiseError(long pSizeMax, long pCount) throws IOException{
							itemStream.close(true);
							FileUploadException e = new FileSizeLimitExceededException(""The field "" + fieldName + "" exceeds its maximum permitted "" +"" size of "" + pSizeMax + "" characters."", pCount, pSizeMax);
							throw new FileUploadIOException(e);
						}
					}
					;
				}
				stream = istream;
			}
			public String getContentType(){
				return contentType;
			}
			public String getFieldName(){
				return fieldName;
			}
			public String getName(){
				return name;
			}
			public boolean isFormField(){
				return formField;
			}
			public InputStream openStream() throws IOException{
				if (opened){
					throw new IllegalStateException(""The stream was already opened."");
				}
				if (((Closeable)stream).isClosed()){
					throw new FileItemStream.ItemSkippedException();
				}
				return stream;
			}
			void close() throws IOException{
				stream.close();
			}
			public FileItemHeaders getHeaders(){
				return headers;
			}
			public void setHeaders(FileItemHeaders pHeaders){
				headers = pHeaders;
			}
		}
		private final MultipartFormInputStream multi;
		private final MultipartFormInputStream.ProgressNotifier notifier;
		private final byte[] boundary;
		private FileItemStreamImpl currentItem;
		private String currentFieldName;
		private boolean skipPreamble;
		private boolean itemValid;
		private boolean eof;
		FileItemIteratorImpl(RequestContext ctx) throws FileUploadException, IOException{
			if (ctx == null){
				throw new NullPointerException(""ctx parameter"");
			}
			String contentType = ctx.getContentType();
			if ((null == contentType) || (!contentType.toLowerCase().startsWith(MULTIPART))){
				throw new InvalidContentTypeException(""the request doesn't contain a "" +MULTIPART_FORM_DATA + "" or "" + MULTIPART_MIXED +"" stream, content type header is "" + contentType);
			}
			InputStream input = ctx.getInputStream();
			if (sizeMax >= 0){
				int requestSize = ctx.getContentLength();
				if (requestSize == -1){
					input = new LimitedInputStream(input, sizeMax){
						protected void raiseError(long pSizeMax, long pCount) throws IOException{
							FileUploadException ex = new SizeLimitExceededException(""the request was rejected because"" + "" its size ("" + pCount +"") exceeds the configured maximum"" + "" ("" + pSizeMax + "")"",pCount, pSizeMax);
							throw new FileUploadIOException(ex);
						}
					}
					;
				}
				else{
					if (sizeMax >= 0 && requestSize > sizeMax){
						throw new SizeLimitExceededException(""the request was rejected because its size ("" + requestSize +"") exceeds the configured maximum ("" + sizeMax + "")"", requestSize,sizeMax);
					}
				}
			}
			String charEncoding = headerEncoding;
			if (charEncoding == null){
				charEncoding = ctx.getCharacterEncoding();
			}
			boundary = getBoundary(contentType);
			if (boundary == null){
				throw new FileUploadException(""the request was rejected because ""+ ""no multipart boundary was found"");
			}
			notifier = new MultipartFormInputStream.ProgressNotifier(listener,ctx.getContentLength());
			multi = new MultipartFormInputStream(input, boundary, notifier);
			multi.setHeaderEncoding(charEncoding);
			skipPreamble = true;
			findNextItem();
		}
		private boolean findNextItem() throws IOException{
			if (eof){
				return false;
			}
			if (currentItem != null){
				currentItem.close();
				currentItem = null;
			}
			for (;
			;
			){
				boolean nextPart;
				if (skipPreamble){
					nextPart = multi.skipPreamble();
				}
				else{
					nextPart = multi.readBoundary();
				}
				if (!nextPart){
					if (currentFieldName == null){
						eof = true;
						return false;
					}
					multi.setBoundary(boundary);
					currentFieldName = null;
					continue;
				}
				FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
				if (currentFieldName == null){
					String fieldName = getFieldName(headers);
					if (fieldName != null){
						String subContentType = headers.getHeader(CONTENT_TYPE);
						if (subContentType != null &&subContentType.toLowerCase().startsWith(MULTIPART_MIXED)){
							currentFieldName = fieldName;
							byte[] subBoundary = getBoundary(subContentType);
							multi.setBoundary(subBoundary);
							skipPreamble = true;
							continue;
						}
						String fileName = getFileName(headers);
						currentItem = new FileItemStreamImpl(fileName, fieldName,headers.getHeader(CONTENT_TYPE), fileName == null,getContentLength(headers));
						notifier.noteItem();
						itemValid = true;
						return true;
					}
				}
				else{
					String fileName = getFileName(headers);
					if (fileName != null){
						currentItem = new FileItemStreamImpl(fileName, currentFieldName,headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
						notifier.noteItem();
						itemValid = true;
						return true;
					}
				}
				multi.discardBodyData();
			}
		}
		private long getContentLength(FileItemHeaders pHeaders){
			try{
				return Long.parseLong(pHeaders.getHeader(CONTENT_LENGTH));
			}
			catch (Exception e){
				return -1;
			}
		}
		public boolean hasNext() throws FileUploadException, IOException{
			if (eof){
				return false;
			}
			if (itemValid){
				return true;
			}
			return findNextItem();
		}
		public FileItemStream next() throws FileUploadException, IOException{
			if (eof || (!itemValid && !hasNext())){
				throw new NoSuchElementException();
			}
			itemValid = false;
			return currentItem;
		}
	}
	public static class FileUploadIOException extends IOException{
		private static final long serialVersionUID = -7047616958165584154L;
		private final FileUploadException cause;
		public FileUploadIOException(FileUploadException pCause){
			cause = pCause;
		}
		public Throwable getCause(){
			return cause;
		}
	}
	public static class InvalidContentTypeException extends FileUploadException{
		private static final long serialVersionUID = -9073026332015646668L;
		public InvalidContentTypeException(){
		}
		public InvalidContentTypeException(String message){
			super(message);
		}
	}
	public static class IOFileUploadException extends FileUploadException{
		private static final long serialVersionUID = 1749796615868477269L;
		private final IOException cause;
		public IOFileUploadException(String pMsg, IOException pException){
			super(pMsg);
			cause = pException;
		}
		public Throwable getCause(){
			return cause;
		}
	}
	protected abstract static class SizeException extends FileUploadException{
		private final long actual;
		private final long permitted;
		protected SizeException(String message, long actual, long permitted){
			super(message);
			this.actual = actual;
			this.permitted = permitted;
		}
		public long getActualSize(){
			return actual;
		}
		public long getPermittedSize(){
			return permitted;
		}
	}
	public static class UnknownSizeException extends FileUploadException{
		private static final long serialVersionUID = 7062279004812015273L;
		public UnknownSizeException(){
			super();
		}
		public UnknownSizeException(String message){
			super(message);
		}
	}
	public static class SizeLimitExceededException extends SizeException{
		private static final long serialVersionUID = -2474893167098052828L;
		public SizeLimitExceededException(){
			this(null, 0, 0);
		}
		public SizeLimitExceededException(String message){
			this(message, 0, 0);
		}
		public SizeLimitExceededException(String message, long actual, long permitted){
			super(message, actual, permitted);
		}
	}
	public static class FileSizeLimitExceededException extends SizeException{
		private static final long serialVersionUID = 8150776562029630058L;
		public FileSizeLimitExceededException(String message, long actual, long permitted){
			super(message, actual, permitted);
		}
	}
	public ProgressListener getProgressListener(){
		return listener;
	}
	public void setProgressListener(ProgressListener pListener){
		listener = pListener;
	}
}",0,0,0,0
"public void setCompressionParameters(Map<String,String> opts) throws ConfigurationException {
	 metadata.compressionParameters = CompressionParameters.create(opts);
 }",0,0,0,0
"private void logHeadless(Throwable e) {
	 log(""failed to display SplashScreen, caught "" + e.getClass().getName() + "" with message: "" + e.getMessage(), Project.MSG_WARN);
 }",0,0,0,0
"public class FunctionCustom extends FunctionSQL {
	 public static final String[] openGroupNumericFunctions = {
	 ""ABS"", ""ACOS"", ""ASIN"", ""ATAN"", ""ATAN2"", ""BITAND"", ""BITOR"", ""BITXOR"", ""CEILING"", ""COS"", ""COT"", ""DEGREES"", ""EXP"", ""FLOOR"", ""LOG"", ""LOG10"", ""MOD"", ""PI"", ""POWER"", ""RADIANS"", ""RAND"", ""ROUND"", ""ROUNDMAGIC"", ""SIGN"", ""SIN"", ""SQRT"", ""TAN"", ""TRUNCATE"" }
	;
	 public static final String[] openGroupStringFunctions = {
	 ""ASCII"", ""CHAR"", ""CONCAT"", ""DIFFERENCE"", ""HEXTORAW"", ""INSERT"", ""LCASE"", ""LEFT"", ""LENGTH"", ""LOCATE"", ""LTRIM"", ""RAWTOHEX"", ""REPEAT"", ""REPLACE"", ""RIGHT"", ""RTRIM"", ""SOUNDEX"", ""SPACE"", ""SUBSTR"", ""UCASE"", }
	;
	 public static final String[] openGroupDateTimeFunctions = {
	 ""CURDATE"", ""CURTIME"", ""DATEDIFF"", ""DAYNAME"", ""DAYOFMONTH"", ""DAYOFWEEK"", ""DAYOFYEAR"", ""HOUR"", ""MINUTE"", ""MONTH"", ""MONTHNAME"", ""NOW"", ""QUARTER"", ""SECOND"", ""SECONDS_SINCE_MIDNIGHT"", ""TIMESTAMPADD"", ""TIMESTAMPDIFF"", ""TO_CHAR"", ""WEEK"", ""YEAR"" }
	;
	 public static final String[] openGroupSystemFunctions = {
	 ""DATABASE"", ""IFNULL"", ""USER"" }
	;
	 private final static int FUNC_ISAUTOCOMMIT = 71;
	 private final static int FUNC_ISREADONLYSESSION = 72;
	 private final static int FUNC_ISREADONLYDATABASE = 73;
	 private final static int FUNC_ISREADONLYDATABASEFILES = 74;
	 private final static int FUNC_DATABASE = 75;
	 private final static int FUNC_IDENTITY = 76;
	 private final static int FUNC_SYSDATE = 77;
	 private final static int FUNC_TIMESTAMPADD = 78;
	 private final static int FUNC_TIMESTAMPDIFF = 79;
	 private final static int FUNC_TRUNCATE = 80;
	 private final static int FUNC_TO_CHAR = 81;
	 private final static int FUNC_TIMESTAMP = 82;
	 private final static int FUNC_CRYPT_KEY = 83;
	 private final static int FUNC_ISOLATION_LEVEL = 85;
	 private final static int FUNC_SESSION_ISOLATION_LEVEL = 86;
	 private final static int FUNC_DATABASE_ISOLATION_LEVEL = 87;
	 private final static int FUNC_TRANSACTION_CONTROL = 88;
	 private final static int FUNC_TIMEZONE = 89;
	 private final static int FUNC_SESSION_TIMEZONE = 90;
	 private final static int FUNC_DATABASE_TIMEZONE = 91;
	 private final static int FUNC_DATABASE_VERSION = 92;
	 private static final int FUNC_ACOS = 101;
	 private static final int FUNC_ASIN = 102;
	 private static final int FUNC_ATAN = 103;
	 private static final int FUNC_ATAN2 = 104;
	 private static final int FUNC_COS = 105;
	 private static final int FUNC_COT = 106;
	 private static final int FUNC_DEGREES = 107;
	 private static final int FUNC_LOG10 = 110;
	 private static final int FUNC_PI = 111;
	 private static final int FUNC_RADIANS = 112;
	 private static final int FUNC_RAND = 113;
	 private static final int FUNC_ROUND = 114;
	 private static final int FUNC_SIGN = 115;
	 private static final int FUNC_SIN = 116;
	 private static final int FUNC_TAN = 117;
	 private static final int FUNC_BITAND = 118;
	 private static final int FUNC_BITOR = 119;
	 private static final int FUNC_BITXOR = 120;
	 private static final int FUNC_ROUNDMAGIC = 121;
	 private static final int FUNC_ASCII = 122;
	 private static final int FUNC_CHAR = 123;
	 private static final int FUNC_CONCAT = 124;
	 private static final int FUNC_DIFFERENCE = 125;
	 private static final int FUNC_HEXTORAW = 126;
	 private static final int FUNC_LEFT = 128;
	 private static final int FUNC_LOCATE = 130;
	 private static final int FUNC_LTRIM = 131;
	 private static final int FUNC_RAWTOHEX = 132;
	 private static final int FUNC_REPEAT = 133;
	 private static final int FUNC_REPLACE = 134;
	 private static final int FUNC_REVERSE = 135;
	 private static final int FUNC_RIGHT = 136;
	 private static final int FUNC_RTRIM = 137;
	 private static final int FUNC_SOUNDEX = 138;
	 private static final int FUNC_SPACE = 139;
	 private static final int FUNC_SUBSTR = 140;
	 private static final int FUNC_DATEADD = 141;
	 private static final int FUNC_DATEDIFF = 142;
	 private static final int FUNC_SECONDS_MIDNIGHT = 143;
	 private static final int FUNC_REGEXP_MATCHES = 144;
	 static final IntKeyIntValueHashMap customRegularFuncMap = new IntKeyIntValueHashMap();
	 static {
		 customRegularFuncMap.put(Tokens.LENGTH, FUNC_CHAR_LENGTH);
		 customRegularFuncMap.put(Tokens.BITLENGTH, FUNC_BIT_LENGTH);
		 customRegularFuncMap.put(Tokens.OCTETLENGTH, FUNC_OCTET_LENGTH);
		 customRegularFuncMap.put(Tokens.LCASE, FUNC_FOLD_LOWER);
		 customRegularFuncMap.put(Tokens.UCASE, FUNC_FOLD_UPPER);
		 customRegularFuncMap.put(Tokens.LOG, FUNC_LN);
		 customRegularFuncMap.put(Tokens.CURDATE, FUNC_CURRENT_DATE);
		 customRegularFuncMap.put(Tokens.CURTIME, FUNC_LOCALTIME);
		 customRegularFuncMap.put(Tokens.SUBSTR, FUNC_SUBSTRING_CHAR);
		 customRegularFuncMap.put(Tokens.CRYPT_KEY, FUNC_CRYPT_KEY);
		 customRegularFuncMap.put(Tokens.YEAR, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.MONTH, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.DAY, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.HOUR, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.MINUTE, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.SECOND, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.DAYNAME, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.MONTHNAME, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.DAYOFMONTH, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.DAYOFWEEK, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.DAYOFYEAR, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.QUARTER, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.WEEK, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.SECONDS_MIDNIGHT, FUNC_EXTRACT);
		 customRegularFuncMap.put(Tokens.LTRIM, FUNC_TRIM_CHAR);
		 customRegularFuncMap.put(Tokens.RTRIM, FUNC_TRIM_CHAR);
		 customRegularFuncMap.put(Tokens.LEFT, FUNC_LEFT);
		 customRegularFuncMap.put(Tokens.IDENTITY, FUNC_IDENTITY);
		 customRegularFuncMap.put(Tokens.TIMESTAMPADD, FUNC_TIMESTAMPADD);
		 customRegularFuncMap.put(Tokens.TIMESTAMPDIFF, FUNC_TIMESTAMPDIFF);
		 customRegularFuncMap.put(Tokens.TRUNCATE, FUNC_TRUNCATE);
		 customRegularFuncMap.put(Tokens.TO_CHAR, FUNC_TO_CHAR);
		 customRegularFuncMap.put(Tokens.TIMESTAMP, FUNC_TIMESTAMP);
		 nonDeterministicFuncSet.add(FUNC_IDENTITY);
		 nonDeterministicFuncSet.add(FUNC_TIMESTAMPADD);
		 nonDeterministicFuncSet.add(FUNC_TIMESTAMP);
		 customRegularFuncMap.put(Tokens.LOCATE, FUNC_POSITION_CHAR);
		 customRegularFuncMap.put(Tokens.INSERT, FUNC_OVERLAY_CHAR);
		 customRegularFuncMap.put(Tokens.REVERSE, FUNC_REVERSE);
		 customRegularFuncMap.put(Tokens.DATABASE, FUNC_DATABASE);
		 customRegularFuncMap.put(Tokens.ISAUTOCOMMIT, FUNC_ISAUTOCOMMIT);
		 customRegularFuncMap.put(Tokens.ISREADONLYSESSION, FUNC_ISREADONLYSESSION);
		 customRegularFuncMap.put(Tokens.ISREADONLYDATABASE, FUNC_ISREADONLYDATABASE);
		 customRegularFuncMap.put(Tokens.ISREADONLYDATABASEFILES, FUNC_ISREADONLYDATABASEFILES);
		 customRegularFuncMap.put(Tokens.ISOLATION_LEVEL, FUNC_ISOLATION_LEVEL);
		 customRegularFuncMap.put(Tokens.SESSION_ISOLATION_LEVEL, FUNC_SESSION_ISOLATION_LEVEL);
		 customRegularFuncMap.put(Tokens.DATABASE_ISOLATION_LEVEL, FUNC_DATABASE_ISOLATION_LEVEL);
		 customRegularFuncMap.put(Tokens.TRANSACTION_CONTROL, FUNC_TRANSACTION_CONTROL);
		 customRegularFuncMap.put(Tokens.TIMEZONE, FUNC_TIMEZONE);
		 customRegularFuncMap.put(Tokens.SESSION_TIMEZONE, FUNC_SESSION_TIMEZONE);
		 customRegularFuncMap.put(Tokens.DATABASE_TIMEZONE, FUNC_DATABASE_TIMEZONE);
		 customRegularFuncMap.put(Tokens.DATABASE_VERSION, FUNC_DATABASE_VERSION);
		 nonDeterministicFuncSet.add(FUNC_DATABASE);
		 nonDeterministicFuncSet.add(FUNC_ISAUTOCOMMIT);
		 nonDeterministicFuncSet.add(FUNC_ISREADONLYSESSION);
		 nonDeterministicFuncSet.add(FUNC_ISREADONLYDATABASE);
		 nonDeterministicFuncSet.add(FUNC_ISREADONLYDATABASEFILES);
		 nonDeterministicFuncSet.add(FUNC_ISOLATION_LEVEL);
		 nonDeterministicFuncSet.add(FUNC_SESSION_ISOLATION_LEVEL);
		 nonDeterministicFuncSet.add(FUNC_DATABASE_ISOLATION_LEVEL);
		 nonDeterministicFuncSet.add(FUNC_TRANSACTION_CONTROL);
		 nonDeterministicFuncSet.add(FUNC_TIMEZONE);
		 nonDeterministicFuncSet.add(FUNC_SESSION_TIMEZONE);
		 nonDeterministicFuncSet.add(FUNC_DATABASE_TIMEZONE);
		 customRegularFuncMap.put(Tokens.ACOS, FUNC_ACOS);
		 customRegularFuncMap.put(Tokens.ASIN, FUNC_ASIN);
		 customRegularFuncMap.put(Tokens.ATAN, FUNC_ATAN);
		 customRegularFuncMap.put(Tokens.ATAN2, FUNC_ATAN2);
		 customRegularFuncMap.put(Tokens.COS, FUNC_COS);
		 customRegularFuncMap.put(Tokens.COT, FUNC_COT);
		 customRegularFuncMap.put(Tokens.DEGREES, FUNC_DEGREES);
		 customRegularFuncMap.put(Tokens.LOG10, FUNC_LOG10);
		 customRegularFuncMap.put(Tokens.PI, FUNC_PI);
		 customRegularFuncMap.put(Tokens.RADIANS, FUNC_RADIANS);
		 customRegularFuncMap.put(Tokens.RAND, FUNC_RAND);
		 customRegularFuncMap.put(Tokens.ROUND, FUNC_ROUND);
		 customRegularFuncMap.put(Tokens.REGEXP_MATCHES, FUNC_REGEXP_MATCHES);
		 customRegularFuncMap.put(Tokens.SIGN, FUNC_SIGN);
		 customRegularFuncMap.put(Tokens.SIN, FUNC_SIN);
		 customRegularFuncMap.put(Tokens.TAN, FUNC_TAN);
		 customRegularFuncMap.put(Tokens.BITAND, FUNC_BITAND);
		 customRegularFuncMap.put(Tokens.BITOR, FUNC_BITOR);
		 customRegularFuncMap.put(Tokens.BITXOR, FUNC_BITXOR);
		 customRegularFuncMap.put(Tokens.ROUNDMAGIC, FUNC_ROUNDMAGIC);
		 customRegularFuncMap.put(Tokens.ASCII, FUNC_ASCII);
		 customRegularFuncMap.put(Tokens.CHAR, FUNC_CHAR);
		 customRegularFuncMap.put(Tokens.CONCAT_WORD, FUNC_CONCAT);
		 customRegularFuncMap.put(Tokens.DIFFERENCE, FUNC_DIFFERENCE);
		 customRegularFuncMap.put(Tokens.HEXTORAW, FUNC_HEXTORAW);
		 customRegularFuncMap.put(Tokens.RAWTOHEX, FUNC_RAWTOHEX);
		 customRegularFuncMap.put(Tokens.REPEAT, FUNC_REPEAT);
		 customRegularFuncMap.put(Tokens.REPLACE, FUNC_REPLACE);
		 customRegularFuncMap.put(Tokens.RIGHT, FUNC_RIGHT);
		 customRegularFuncMap.put(Tokens.SOUNDEX, FUNC_SOUNDEX);
		 customRegularFuncMap.put(Tokens.SPACE, FUNC_SPACE);
		 customRegularFuncMap.put(Tokens.DATEADD, FUNC_DATEADD);
		 customRegularFuncMap.put(Tokens.DATEDIFF, FUNC_DATEDIFF);
	 }
	 static final IntKeyIntValueHashMap customValueFuncMap = new IntKeyIntValueHashMap();
	 static {
		 customValueFuncMap.put(Tokens.SYSDATE, FUNC_LOCALTIMESTAMP);
		 customValueFuncMap.put(Tokens.TODAY, FUNC_CURRENT_DATE);
		 customValueFuncMap.put(Tokens.NOW, FUNC_LOCALTIMESTAMP);
	 }
	 private int extractSpec;
	 private String matchPattern;
	 private Pattern pattern;
	 public static FunctionSQL newCustomFunction(String token, int tokenType) {
		 int id = customRegularFuncMap.get(tokenType, -1);
		 if (id == -1) {
			 id = customValueFuncMap.get(tokenType, -1);
		 }
		 if (id == -1) {
			 return null;
		 }
		 switch (tokenType) {
			 case Tokens.BITLENGTH : case Tokens.LCASE : case Tokens.LENGTH : case Tokens.LOG : case Tokens.OCTETLENGTH : case Tokens.TODAY : case Tokens.SYSDATE : case Tokens.UCASE : return new FunctionSQL(id);
			 case Tokens.NOW : {
				 FunctionSQL function = new FunctionSQL(id);
				 function.parseList = optionalNoParamList;
				 return function;
			 }
			 case Tokens.CURDATE : case Tokens.CURTIME : {
				 FunctionSQL function = new FunctionSQL(id);
				 function.parseList = emptyParamList;
				 return function;
			 }
			 case Tokens.SUBSTR : {
				 FunctionSQL function = new FunctionSQL(id);
				 function.parseList = tripleParamList;
				 return function;
			 }
			 case Tokens.LOCATE : FunctionSQL function = new FunctionSQL(id);
			 function.parseList = new short[] {
			 Tokens.OPENBRACKET, Tokens.QUESTION, Tokens.COMMA, Tokens.QUESTION, Tokens.X_OPTION, 2, Tokens.COMMA, Tokens.QUESTION, Tokens.CLOSEBRACKET }
			;
			 return function;
		 }
		 FunctionCustom function = new FunctionCustom(id);
		 if (id == FUNC_TRIM_CHAR) {
			 switch (tokenType) {
				 case Tokens.LTRIM : function.extractSpec = Tokens.LEADING;
				 break;
				 case Tokens.RTRIM : function.extractSpec = Tokens.TRAILING;
				 break;
			 }
		 }
		 if (id == FUNC_EXTRACT) {
			 switch (tokenType) {
				 case Tokens.DAYNAME : function.extractSpec = Tokens.DAY_NAME;
				 break;
				 case Tokens.MONTHNAME : function.extractSpec = Tokens.MONTH_NAME;
				 break;
				 case Tokens.DAYOFMONTH : function.extractSpec = Tokens.DAY_OF_MONTH;
				 break;
				 case Tokens.DAYOFWEEK : function.extractSpec = Tokens.DAY_OF_WEEK;
				 break;
				 case Tokens.DAYOFYEAR : function.extractSpec = Tokens.DAY_OF_YEAR;
				 break;
				 default : function.extractSpec = tokenType;
			 }
		 }
		 if (function.name == null) {
			 function.name = token;
		 }
		 return function;
	 }
	 public static boolean isRegularFunction(int tokenType) {
		 return customRegularFuncMap.get(tokenType, -1) != -1;
	 }
	 public static boolean isValueFunction(int tokenType) {
		 return customValueFuncMap.get(tokenType, -1) != -1;
	 }
	 private FunctionCustom(int id) {
		 super();
		 this.funcType = id;
		 isDeterministic = !nonDeterministicFuncSet.contains(id);
		 switch (id) {
			 case FUNC_CONCAT : case FUNC_LEFT : parseList = doubleParamList;
			 break;
			 case FUNC_DATABASE : parseList = emptyParamList;
			 break;
			 case FUNC_ISAUTOCOMMIT : case FUNC_ISREADONLYSESSION : case FUNC_ISREADONLYDATABASE : case FUNC_ISREADONLYDATABASEFILES : case FUNC_ISOLATION_LEVEL : case FUNC_SESSION_ISOLATION_LEVEL : case FUNC_DATABASE_ISOLATION_LEVEL : case FUNC_TRANSACTION_CONTROL : case FUNC_TIMEZONE : case FUNC_SESSION_TIMEZONE : case FUNC_DATABASE_TIMEZONE : case FUNC_DATABASE_VERSION : parseList = emptyParamList;
			 break;
			 case FUNC_EXTRACT : name = Tokens.T_EXTRACT;
			 parseList = singleParamList;
			 break;
			 case FUNC_TRIM_CHAR : name = Tokens.T_TRIM;
			 parseList = singleParamList;
			 break;
			 case FUNC_OVERLAY_CHAR : name = Tokens.T_OVERLAY;
			 parseList = quadParamList;
			 break;
			 case FUNC_IDENTITY : name = Tokens.T_IDENTITY;
			 parseList = emptyParamList;
			 break;
			 case FUNC_TIMESTAMPADD : name = Tokens.T_TIMESTAMPADD;
			 parseList = new short[] {
			 Tokens.OPENBRACKET, Tokens.X_KEYSET, 9, Tokens.SQL_TSI_FRAC_SECOND, Tokens.SQL_TSI_SECOND, Tokens.SQL_TSI_MINUTE, Tokens.SQL_TSI_HOUR, Tokens.SQL_TSI_DAY, Tokens.SQL_TSI_WEEK, Tokens.SQL_TSI_MONTH, Tokens.SQL_TSI_QUARTER, Tokens.SQL_TSI_YEAR, Tokens.COMMA, Tokens.QUESTION, Tokens.COMMA, Tokens.QUESTION, Tokens.CLOSEBRACKET }
			;
			 break;
			 case FUNC_TIMESTAMPDIFF : name = Tokens.T_TIMESTAMPDIFF;
			 parseList = new short[] {
			 Tokens.OPENBRACKET, Tokens.X_KEYSET, 9, Tokens.SQL_TSI_FRAC_SECOND, Tokens.SQL_TSI_SECOND, Tokens.SQL_TSI_MINUTE, Tokens.SQL_TSI_HOUR, Tokens.SQL_TSI_DAY, Tokens.SQL_TSI_WEEK, Tokens.SQL_TSI_MONTH, Tokens.SQL_TSI_QUARTER, Tokens.SQL_TSI_YEAR, Tokens.COMMA, Tokens.QUESTION, Tokens.COMMA, Tokens.QUESTION, Tokens.CLOSEBRACKET }
			;
			 break;
			 case FUNC_TRUNCATE : parseList = doubleParamList;
			 break;
			 case FUNC_TO_CHAR : parseList = doubleParamList;
			 break;
			 case FUNC_TIMESTAMP : name = Tokens.T_TIMESTAMP;
			 parseList = new short[] {
			 Tokens.OPENBRACKET, Tokens.QUESTION, Tokens.X_OPTION, 2, Tokens.COMMA, Tokens.QUESTION, Tokens.CLOSEBRACKET }
			;
			 break;
			 case FUNC_PI : parseList = emptyParamList;
			 break;
			 case FUNC_RAND : parseList = optionalSingleParamList;
			 break;
			 case FUNC_ACOS : case FUNC_ASIN : case FUNC_ATAN : case FUNC_COS : case FUNC_COT : case FUNC_DEGREES : case FUNC_SIN : case FUNC_TAN : case FUNC_LOG10 : case FUNC_RADIANS : case FUNC_ROUNDMAGIC : case FUNC_SIGN : case FUNC_SOUNDEX : case FUNC_ASCII : case FUNC_CHAR : case FUNC_HEXTORAW : case FUNC_RAWTOHEX : case FUNC_REVERSE : case FUNC_SPACE : parseList = singleParamList;
			 break;
			 case FUNC_ATAN2 : case FUNC_ROUND : case FUNC_BITAND : case FUNC_BITOR : case FUNC_BITXOR : case FUNC_DIFFERENCE : case FUNC_REPEAT : case FUNC_RIGHT : case FUNC_REGEXP_MATCHES : parseList = doubleParamList;
			 break;
			 case FUNC_CRYPT_KEY : parseList = doubleParamList;
			 break;
			 case FUNC_DATEADD : case FUNC_DATEDIFF : case FUNC_REPLACE : parseList = tripleParamList;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""FunctionCustom"");
		 }
	 }
	 public void setArguments(Expression[] nodes) {
		 switch (funcType) {
			 case FUNC_OVERLAY_CHAR : {
				 Expression start = nodes[1];
				 Expression length = nodes[2];
				 nodes[1] = nodes[3];
				 nodes[2] = start;
				 nodes[3] = length;
				 break;
			 }
			 case FUNC_EXTRACT : {
				 Expression[] newNodes = new Expression[2];
				 newNodes[0] = new ExpressionValue(ValuePool.getInt(extractSpec), Type.SQL_INTEGER);
				 newNodes[1] = nodes[0];
				 nodes = newNodes;
				 break;
			 }
			 case FUNC_TRIM_CHAR : {
				 Expression[] newNodes = new Expression[3];
				 newNodes[0] = new ExpressionValue(ValuePool.getInt(extractSpec), Type.SQL_INTEGER);
				 newNodes[1] = new ExpressionValue("" "", Type.SQL_CHAR);
				 newNodes[2] = nodes[0];
				 nodes = newNodes;
			 }
		 }
		 super.setArguments(nodes);
	 }
	 public Expression getFunctionExpression() {
		 switch (funcType) {
			 case FUNC_CONCAT : return new ExpressionArithmetic(OpTypes.CONCAT, nodes[Expression.LEFT], nodes[Expression.RIGHT]);
		 }
		 return super.getFunctionExpression();
	 }
	 Object getValue(Session session, Object[] data) {
		 switch (funcType) {
			 case FUNC_EXTRACT : case FUNC_TRIM_CHAR : case FUNC_OVERLAY_CHAR : return super.getValue(session, data);
			 case FUNC_DATABASE : return session.getDatabase().getPath();
			 case FUNC_ISAUTOCOMMIT : return session.isAutoCommit() ? Boolean.TRUE : Boolean.FALSE;
			 case FUNC_ISREADONLYSESSION : return session.isReadOnlyDefault() ? Boolean.TRUE : Boolean.FALSE;
			 case FUNC_ISREADONLYDATABASE : return session.getDatabase().databaseReadOnly ? Boolean.TRUE : Boolean.FALSE;
			 case FUNC_ISREADONLYDATABASEFILES : return session.getDatabase().isFilesReadOnly() ? Boolean.TRUE : Boolean.FALSE;
			 case FUNC_ISOLATION_LEVEL : {
				 return Session.getIsolationString(session.isolationLevel);
			 }
			 case FUNC_SESSION_ISOLATION_LEVEL : return Session.getIsolationString( session.isolationLevelDefault);
			 case FUNC_DATABASE_ISOLATION_LEVEL : return Session.getIsolationString( session.database.getDefaultIsolationLevel());
			 case FUNC_TRANSACTION_CONTROL : switch (session.database.txManager.getTransactionControl()) {
				 case TransactionManager.MVCC : return Tokens.T_MVCC;
				 case TransactionManager.MVLOCKS : return Tokens.T_MVLOCKS;
				 case TransactionManager.LOCKS : default : return Tokens.T_LOCKS;
			 }
			 case FUNC_TIMEZONE : return new IntervalSecondData(session.getZoneSeconds(), 0);
			 case FUNC_SESSION_TIMEZONE : return new IntervalSecondData(session.sessionTimeZoneSeconds, 0);
			 case FUNC_DATABASE_TIMEZONE : int sec = HsqlDateTime.getZoneSeconds(HsqlDateTime.tempCalDefault);
			 return new IntervalSecondData(sec, 0);
			 case FUNC_DATABASE_VERSION : return HsqlDatabaseProperties.THIS_FULL_VERSION;
			 case FUNC_IDENTITY : {
				 Number id = session.getLastIdentity();
				 if (id instanceof Long) {
					 return id;
				 }
				 else {
					 return ValuePool.getLong(id.longValue());
				 }
			 }
			 case FUNC_TIMESTAMPADD : {
				 if (data[1] == null || data[2] == null) {
					 return null;
				 }
				 data[1] = Type.SQL_BIGINT.convertToType(session, data[1], nodes[1].getDataType());
				 int part = ((Number) nodes[0].valueData).intValue();
				 long units = ((Number) data[1]).longValue();
				 TimestampData source = (TimestampData) data[2];
				 IntervalType t;
				 Object o;
				 switch (part) {
					 case Tokens.SQL_TSI_FRAC_SECOND : {
						 long seconds = units / DTIType.limitNanoseconds;
						 int nanos = (int) (units % DTIType.limitNanoseconds);
						 t = Type.SQL_INTERVAL_SECOND_MAX_FRACTION;
						 o = new IntervalSecondData(seconds, nanos, t);
						 return dataType.add(source, o, t);
					 }
					 case Tokens.SQL_TSI_SECOND : t = Type.SQL_INTERVAL_SECOND_MAX_PRECISION;
					 o = IntervalSecondData.newIntervalSeconds(units, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_MINUTE : t = Type.SQL_INTERVAL_MINUTE_MAX_PRECISION;
					 o = IntervalSecondData.newIntervalMinute(units, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_HOUR : t = Type.SQL_INTERVAL_HOUR_MAX_PRECISION;
					 o = IntervalSecondData.newIntervalHour(units, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_DAY : t = Type.SQL_INTERVAL_DAY_MAX_PRECISION;
					 o = IntervalSecondData.newIntervalDay(units, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_WEEK : t = Type.SQL_INTERVAL_DAY_MAX_PRECISION;
					 o = IntervalSecondData.newIntervalDay(units * 7, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_MONTH : t = Type.SQL_INTERVAL_MONTH_MAX_PRECISION;
					 o = IntervalMonthData.newIntervalMonth(units, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_QUARTER : t = Type.SQL_INTERVAL_MONTH_MAX_PRECISION;
					 o = IntervalMonthData.newIntervalMonth(units * 3, t);
					 return dataType.add(source, o, t);
					 case Tokens.SQL_TSI_YEAR : t = Type.SQL_INTERVAL_YEAR_MAX_PRECISION;
					 o = IntervalMonthData.newIntervalMonth(units * 12, t);
					 return dataType.add(source, o, t);
					 default : throw Error.runtimeError(ErrorCode.U_S0500, ""FunctionCustom"");
				 }
			 }
			 case FUNC_TIMESTAMPDIFF : {
				 if (data[1] == null || data[2] == null) {
					 return null;
				 }
				 int part = ((Number) nodes[0].valueData).intValue();
				 TimestampData a = (TimestampData) data[2];
				 TimestampData b = (TimestampData) data[1];
				 if (nodes[2].dataType.isDateTimeTypeWithZone()) {
					 a = (TimestampData) Type.SQL_TIMESTAMP.convertToType( session, a, Type.SQL_TIMESTAMP_WITH_TIME_ZONE);
				 }
				 if (nodes[1].dataType.isDateTimeTypeWithZone()) {
					 b = (TimestampData) Type.SQL_TIMESTAMP.convertToType( session, b, Type.SQL_TIMESTAMP_WITH_TIME_ZONE);
				 }
				 IntervalType t;
				 switch (part) {
					 case Tokens.SQL_TSI_FRAC_SECOND : t = Type.SQL_INTERVAL_SECOND_MAX_PRECISION;
					 IntervalSecondData interval = (IntervalSecondData) t.subtract(a, b, null);
					 return new Long( DTIType.limitNanoseconds * interval.getSeconds() + interval.getNanos());
					 case Tokens.SQL_TSI_SECOND : t = Type.SQL_INTERVAL_SECOND_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)));
					 case Tokens.SQL_TSI_MINUTE : t = Type.SQL_INTERVAL_MINUTE_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)));
					 case Tokens.SQL_TSI_HOUR : t = Type.SQL_INTERVAL_HOUR_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)));
					 case Tokens.SQL_TSI_DAY : t = Type.SQL_INTERVAL_DAY_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)));
					 case Tokens.SQL_TSI_WEEK : t = Type.SQL_INTERVAL_DAY_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)) / 7);
					 case Tokens.SQL_TSI_MONTH : t = Type.SQL_INTERVAL_MONTH_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)));
					 case Tokens.SQL_TSI_QUARTER : t = Type.SQL_INTERVAL_MONTH_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)) / 3);
					 case Tokens.SQL_TSI_YEAR : t = Type.SQL_INTERVAL_YEAR_MAX_PRECISION;
					 return new Long(t.convertToLong(t.subtract(a, b, null)));
					 default : throw Error.runtimeError(ErrorCode.U_S0500, ""FunctionCustom"");
				 }
			 }
			 case FUNC_SECONDS_MIDNIGHT : {
				 if (data[0] == null) {
					 return null;
				 }
			 }
			 case FUNC_TRUNCATE : {
				 if (data[0] == null || data[1] == null) {
					 return null;
				 }
				 data[1] = Type.SQL_INTEGER.convertToType(session, data[1], nodes[1].getDataType());
				 return ((NumberType) dataType).truncate(data[0], ((Number) data[1]).intValue());
			 }
			 case FUNC_TO_CHAR : {
				 if (data[0] == null || data[1] == null) {
					 return null;
				 }
				 SimpleDateFormat format = session.getSimpleDateFormatGMT();
				 String javaPattern = HsqlDateTime.toJavaDatePattern((String) data[1]);
				 try {
					 format.applyPattern(javaPattern);
				 }
				 catch (Exception e) {
					 throw Error.error(ErrorCode.X_22511);
				 }
				 Date date = (Date) ((DateTimeType) nodes[0].dataType) .convertSQLToJavaGMT(session, data[0]);
				 return format.format(date);
			 }
			 case FUNC_TIMESTAMP : {
				 boolean unary = nodes[1] == null;
				 if (data[0] == null) {
					 return null;
				 }
				 if (unary) {
					 return Type.SQL_TIMESTAMP.convertToType(session, data[0], nodes[0].dataType);
				 }
				 if (data[1] == null) {
					 return null;
				 }
				 TimestampData date = (TimestampData) Type.SQL_DATE.convertToType(session, data[0], nodes[0].dataType);
				 TimeData time = (TimeData) Type.SQL_TIME.convertToType(session, data[1], nodes[1].dataType);
				 return new TimestampData(date.getSeconds() + time.getSeconds(), time.getNanos());
			 }
			 case FUNC_PI : return new Double(Math.PI);
			 case FUNC_RAND : {
				 if (nodes[0] == null) {
					 return new Double(session.random());
				 }
				 else {
					 data[0] = Type.SQL_BIGINT.convertToType(session, data[0], nodes[0].getDataType());
					 long seed = ((Number) data[0]).longValue();
					 return new Double(session.random(seed));
				 }
			 }
			 case FUNC_ACOS : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.acos(d));
			 }
			 case FUNC_ASIN : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.asin(d));
			 }
			 case FUNC_ATAN : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.atan(d));
			 }
			 case FUNC_COS : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.cos(d));
			 }
			 case FUNC_COT : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 double c = 1.0 / java.lang.Math.tan(d);
				 return new Double(c);
			 }
			 case FUNC_DEGREES : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.toDegrees(d));
			 }
			 case FUNC_SIN : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.sin(d));
			 }
			 case FUNC_TAN : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.tan(d));
			 }
			 case FUNC_LOG10 : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.log10(d));
			 }
			 case FUNC_RADIANS : {
				 if (data[0] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 return new Double(java.lang.Math.toRadians(d));
			 }
			 case FUNC_SIGN : {
				 if (data[0] == null) {
					 return null;
				 }
				 int val = ((NumberType) nodes[0].dataType).compareToZero(data[0]);
				 return ValuePool.getInt(val);
			 }
			 case FUNC_ATAN2 : {
				 if (data[0] == null) {
					 return null;
				 }
				 double a = NumberType.toDouble(data[0]);
				 double b = NumberType.toDouble(data[1]);
				 return new Double(java.lang.Math.atan2(a, b));
			 }
			 case FUNC_ASCII : {
				 String arg;
				 if (data[0] == null) {
					 return null;
				 }
				 if (nodes[0].dataType.isLobType()) {
					 arg = ((ClobData) data[0]).getSubString(session, 0, 1);
				 }
				 else {
					 arg = (String) data[0];
				 }
				 if (arg.length() == 0) {
					 return null;
				 }
				 return ValuePool.getInt(arg.charAt(0));
			 }
			 case FUNC_CHAR : if (data[0] == null) {
				 return null;
			 }
			 data[0] = Type.SQL_INTEGER.convertToType(session, data[0], nodes[0].getDataType());
			 int arg = ((Number) data[0]).intValue();
			 if (Character.isValidCodePoint(arg) && Character.isValidCodePoint((char) arg)) {
				 return String.valueOf((char) arg);
			 }
			 throw Error.error(ErrorCode.X_22511);
			 case FUNC_ROUNDMAGIC : case FUNC_ROUND : {
				 if (data[0] == null || data[1] == null) {
					 return null;
				 }
				 double d = NumberType.toDouble(data[0]);
				 int e = ((Number) data[1]).intValue();
				 double f = Math.pow(10., e);
				 return new Double(Math.round(d * f) / f);
			 }
			 case FUNC_SOUNDEX : {
				 if (data[0] == null) {
					 return null;
				 }
				 String s = (String) data[0];
				 return new String(soundex(s), 0, 4);
			 }
			 case FUNC_BITAND : case FUNC_BITOR : case FUNC_BITXOR : {
				 for (int i = 0;
				 i < data.length;
				 i++) {
					 if (data[i] == null) {
						 return null;
					 }
				 }
				 if (nodes[0].dataType.isIntegralType()) {
					 data[0] = Type.SQL_BIGINT.convertToType(session, data[0], nodes[0].getDataType());
					 data[1] = Type.SQL_BIGINT.convertToType(session, data[1], nodes[1].getDataType());
					 long v = 0;
					 long a = ((Number) data[0]).longValue();
					 long b = ((Number) data[1]).longValue();
					 switch (funcType) {
						 case FUNC_BITAND : v = a & b;
						 break;
						 case FUNC_BITOR : v = a | b;
						 break;
						 case FUNC_BITXOR : v = a ^ b;
						 break;
					 }
					 switch (dataType.typeCode) {
						 case Types.SQL_NUMERIC : case Types.SQL_DECIMAL : return BigDecimal.valueOf(v);
						 case Types.SQL_BIGINT : return ValuePool.getLong(v);
						 case Types.SQL_INTEGER : return ValuePool.getInt((int) v);
						 case Types.SQL_SMALLINT : return ValuePool.getInt((int) v & 0xffff);
						 case Types.TINYINT : return ValuePool.getInt((int) v & 0xff);
						 default : throw Error.error(ErrorCode.X_42561);
					 }
				 }
				 else {
					 byte[] a = ((BinaryData) data[0]).getBytes();
					 byte[] b = ((BinaryData) data[1]).getBytes();
					 byte[] v;
					 switch (funcType) {
						 case FUNC_BITAND : v = BitMap.and(a, b);
						 break;
						 case FUNC_BITOR : v = BitMap.or(a, b);
						 break;
						 case FUNC_BITXOR : v = BitMap.xor(a, b);
						 break;
						 default : throw Error.error(ErrorCode.X_42561);
					 }
					 return new BinaryData(v, dataType.precision);
				 }
			 }
			 case FUNC_DIFFERENCE : {
				 for (int i = 0;
				 i < data.length;
				 i++) {
					 if (data[i] == null) {
						 return null;
					 }
				 }
				 char[] s1 = soundex((String) data[0]);
				 char[] s2 = soundex((String) data[1]);
				 int e = 0;
				 if (s1[0] == s2[0]) {
					 e++;
				 }
				 if (e == 4) {
					 return ValuePool.getInt(e);
				 }
				 int js = 1;
				 for (int i = 1;
				 i < 4;
				 i++) {
					 for (int j = js;
					 j < 4;
					 j++) {
						 if (s1[j] == s2[i]) {
							 e++;
							 i++;
							 js++;
						 }
					 }
				 }
				 e = 0;
				 return ValuePool.getInt(e);
			 }
			 case FUNC_HEXTORAW : {
				 if (data[0] == null) {
					 return null;
				 }
				 return dataType.convertToType(session, data[0], nodes[0].dataType);
			 }
			 case FUNC_RAWTOHEX : {
				 if (data[0] == null) {
					 return null;
				 }
				 return nodes[0].dataType.convertToString(data[0]);
			 }
			 case FUNC_REPEAT : {
				 for (int i = 0;
				 i < data.length;
				 i++) {
					 if (data[i] == null) {
						 return null;
					 }
				 }
				 data[1] = Type.SQL_INTEGER.convertToType(session, data[1], nodes[1].getDataType());
				 String string = (String) data[0];
				 int i = ((Number) data[1]).intValue();
				 StringBuffer sb = new StringBuffer(string.length() * i);
				 while (i-- > 0) {
					 sb.append(string);
				 }
				 return sb.toString();
			 }
			 case FUNC_REPLACE : {
				 for (int i = 0;
				 i < data.length;
				 i++) {
					 if (data[i] == null) {
						 return null;
					 }
				 }
				 String string = (String) data[0];
				 String find = (String) data[1];
				 String replace = (String) data[2];
				 StringBuffer sb = new StringBuffer();
				 int start = 0;
				 while (true) {
					 int i = string.indexOf(find, start);
					 if (i == -1) {
						 sb.append(string.substring(start));
						 break;
					 }
					 sb.append(string.substring(start, i));
					 sb.append(replace);
					 start = i + find.length();
				 }
				 return sb.toString();
			 }
			 case FUNC_LEFT : case FUNC_RIGHT : {
				 for (int i = 0;
				 i < data.length;
				 i++) {
					 if (data[i] == null) {
						 return null;
					 }
				 }
				 int count = ((Number) data[1]).intValue();
				 return ((CharacterType) dataType).substring(session, data[0], 0, count, true, funcType == FUNC_RIGHT);
			 }
			 case FUNC_SPACE : {
				 if (data[0] == null) {
					 return null;
				 }
				 data[0] = Type.SQL_INTEGER.convertToType(session, data[0], nodes[0].getDataType());
				 int count = ((Number) data[0]).intValue();
				 char[] array = new char[count];
				 ArrayUtil.fillArray(array, 0, ' ');
				 return String.valueOf(array);
			 }
			 case FUNC_REVERSE : {
				 if (data[0] == null) {
					 return null;
				 }
				 StringBuffer sb = new StringBuffer((String) data[0]);
				 sb = sb.reverse();
				 return sb.toString();
			 }
			 case FUNC_REGEXP_MATCHES : {
				 for (int i = 0;
				 i < data.length;
				 i++) {
					 if (data[i] == null) {
						 return null;
					 }
				 }
				 if (!data[1].equals(matchPattern)) {
					 matchPattern = (String) data[1];
					 pattern = Pattern.compile(matchPattern);
				 }
				 Matcher matcher = pattern.matcher((String) data[0]);
				 return matcher.matches() ? Boolean.TRUE : Boolean.FALSE;
			 }
			 case FUNC_CRYPT_KEY : {
				 byte[] bytes = Crypto.getNewKey((String) data[0], (String) data[1]);
				 return StringConverter.byteArrayToHexString(bytes);
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""FunctionCustom"");
		 }
	 }
	 public void resolveTypes(Session session, Expression parent) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 nodes[i].resolveTypes(session, this);
			 }
		 }
		 switch (funcType) {
			 case FUNC_EXTRACT : case FUNC_TRIM_CHAR : case FUNC_OVERLAY_CHAR : super.resolveTypes(session, parent);
			 return;
			 case FUNC_DATABASE : dataType = Type.SQL_VARCHAR_DEFAULT;
			 return;
			 case FUNC_ISAUTOCOMMIT : case FUNC_ISREADONLYSESSION : case FUNC_ISREADONLYDATABASE : case FUNC_ISREADONLYDATABASEFILES : dataType = Type.SQL_BOOLEAN;
			 return;
			 case FUNC_ISOLATION_LEVEL : case FUNC_SESSION_ISOLATION_LEVEL : case FUNC_DATABASE_ISOLATION_LEVEL : case FUNC_TRANSACTION_CONTROL : case FUNC_DATABASE_VERSION : dataType = Type.SQL_VARCHAR_DEFAULT;
			 return;
			 case FUNC_TIMEZONE : case FUNC_SESSION_TIMEZONE : case FUNC_DATABASE_TIMEZONE : dataType = Type.SQL_INTERVAL_HOUR_TO_MINUTE;
			 return;
			 case FUNC_IDENTITY : dataType = Type.SQL_BIGINT;
			 return;
			 case FUNC_DATEADD : {
				 int part;
				 if (!nodes[0].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 if (""yy"".equalsIgnoreCase((String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_YEAR;
				 }
				 else if (""mm"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_MONTH;
				 }
				 else if (""dd"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_DAY;
				 }
				 else if (""hh"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_HOUR;
				 }
				 else if (""mi"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_MINUTE;
				 }
				 else if (""ss"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_SECOND;
				 }
				 else if (""ms"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_FRAC_SECOND;
				 }
				 else {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 nodes[0].valueData = ValuePool.getInt(part);
				 nodes[0].dataType = Type.SQL_INTEGER;
				 funcType = FUNC_TIMESTAMPADD;
			 }
			 case FUNC_TIMESTAMPADD : if (nodes[1].dataType == null) {
				 nodes[1].dataType = Type.SQL_BIGINT;
			 }
			 if (nodes[2].dataType == null) {
				 nodes[2].dataType = Type.SQL_TIMESTAMP;
			 }
			 if (!nodes[1].dataType.isIntegralType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 if (nodes[2].dataType.typeCode != Types.SQL_DATE && nodes[2].dataType.typeCode != Types.SQL_TIMESTAMP && nodes[2].dataType.typeCode != Types.SQL_TIMESTAMP_WITH_TIME_ZONE) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 dataType = nodes[2].dataType;
			 return;
			 case FUNC_DATEDIFF : {
				 int part;
				 if (!nodes[0].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42563);
				 }
				 if (""yy"".equalsIgnoreCase((String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_YEAR;
				 }
				 else if (""mm"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_MONTH;
				 }
				 else if (""dd"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_DAY;
				 }
				 else if (""hh"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_HOUR;
				 }
				 else if (""mi"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_MINUTE;
				 }
				 else if (""ss"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_SECOND;
				 }
				 else if (""ms"".equalsIgnoreCase( (String) nodes[0].valueData)) {
					 part = Tokens.SQL_TSI_FRAC_SECOND;
				 }
				 else {
					 throw Error.error(ErrorCode.X_22511, (String) nodes[0].valueData);
				 }
				 nodes[0].valueData = ValuePool.getInt(part);
				 nodes[0].dataType = Type.SQL_INTEGER;
				 funcType = FUNC_TIMESTAMPDIFF;
			 }
			 case FUNC_TIMESTAMPDIFF : {
				 if (nodes[1].dataType == null) {
					 nodes[1].dataType = nodes[2].dataType;
				 }
				 if (nodes[2].dataType == null) {
					 nodes[2].dataType = nodes[1].dataType;
				 }
				 if (nodes[1].dataType == null) {
					 nodes[1].dataType = Type.SQL_TIMESTAMP;
					 nodes[2].dataType = Type.SQL_TIMESTAMP;
				 }
				 switch (nodes[1].dataType.typeCode) {
					 case Types.SQL_DATE : if (nodes[2].dataType.typeCode != Types.SQL_DATE) {
						 throw Error.error(ErrorCode.X_42563);
					 }
					 switch (((Integer) nodes[0].valueData).intValue()) {
						 case Tokens.SQL_TSI_DAY : case Tokens.SQL_TSI_WEEK : case Tokens.SQL_TSI_MONTH : case Tokens.SQL_TSI_QUARTER : case Tokens.SQL_TSI_YEAR : break;
						 default : throw Error.error(ErrorCode.X_42563);
					 }
					 break;
					 case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : if (nodes[2].dataType.typeCode != Types.SQL_TIMESTAMP && nodes[2].dataType.typeCode != Types.SQL_TIMESTAMP_WITH_TIME_ZONE) {
						 throw Error.error(ErrorCode.X_42563);
					 }
					 break;
					 default : throw Error.error(ErrorCode.X_42563);
				 }
				 dataType = Type.SQL_BIGINT;
				 return;
			 }
			 case FUNC_TRUNCATE : {
				 if (nodes[0].dataType == null) {
					 throw Error.error(ErrorCode.X_42567);
				 }
				 if (nodes[1].dataType == null) {
					 nodes[1].dataType = Type.SQL_INTEGER;
				 }
				 else if (!nodes[1].dataType.isIntegralType()) {
					 throw Error.error(ErrorCode.X_42563);
				 }
				 if (!nodes[0].dataType.isNumberType()) {
					 throw Error.error(ErrorCode.X_42563);
				 }
				 dataType = nodes[0].dataType;
				 return;
			 }
			 case FUNC_TO_CHAR : {
				 if (nodes[0].dataType == null) {
					 throw Error.error(ErrorCode.X_42567);
				 }
				 if (nodes[1].dataType == null || !nodes[1].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42567);
				 }
				 if (!nodes[0].dataType.isExactNumberType() && !nodes[0].dataType.isDateTimeType()) {
					 throw Error.error(ErrorCode.X_42563);
				 }
				 dataType = CharacterType.getCharacterType(Types.SQL_VARCHAR, 40);
				 if (nodes[1].opType == OpTypes.VALUE) {
					 nodes[1].setAsConstantValue(session);
				 }
				 return;
			 }
			 case FUNC_TIMESTAMP : {
				 Type argType = nodes[0].dataType;
				 if (nodes[1] == null) {
					 if (argType == null) {
						 argType = nodes[0].dataType = Type.SQL_VARCHAR_DEFAULT;
					 }
					 if (argType.isCharacterType() || argType.typeCode == Types.SQL_TIMESTAMP || argType.typeCode == Types.SQL_TIMESTAMP_WITH_TIME_ZONE) {
					}
					 else {
						 throw Error.error(ErrorCode.X_42561);
					 }
				 }
				 else {
					 if (argType == null) {
						 if (nodes[1].dataType == null) {
							 argType = nodes[0].dataType = nodes[1].dataType = Type.SQL_VARCHAR_DEFAULT;
						 }
						 else {
							 if (nodes[1].dataType.isCharacterType()) {
								 argType = nodes[0].dataType = Type.SQL_VARCHAR_DEFAULT;
							 }
							 else {
								 argType = nodes[0].dataType = Type.SQL_DATE;
							 }
						 }
					 }
					 if (nodes[1].dataType == null) {
						 if (argType.isCharacterType()) {
							 nodes[1].dataType = Type.SQL_VARCHAR_DEFAULT;
						 }
						 else if (argType.typeCode == Types.SQL_DATE) {
							 nodes[1].dataType = Type.SQL_TIME;
						 }
					 }
					 if ((argType.typeCode == Types.SQL_DATE && nodes[1] .dataType.typeCode == Types.SQL_TIME) || argType .isCharacterType() && nodes[1].dataType .isCharacterType()) {
					}
					 else {
						 throw Error.error(ErrorCode.X_42561);
					 }
				 }
				 dataType = Type.SQL_TIMESTAMP;
				 return;
			 }
			 case FUNC_PI : dataType = Type.SQL_DOUBLE;
			 break;
			 case FUNC_RAND : {
				 if (nodes[0] != null) {
					 if (nodes[0].dataType == null) {
						 nodes[0].dataType = Type.SQL_BIGINT;
					 }
					 else if (!nodes[0].dataType.isExactNumberType()) {
						 throw Error.error(ErrorCode.X_42563);
					 }
				 }
				 dataType = Type.SQL_DOUBLE;
				 break;
			 }
			 case FUNC_ROUND : if (nodes[1].dataType == null) {
				 nodes[1].dataType = Type.SQL_INTEGER;
			 }
			 if (!nodes[1].dataType.isExactNumberType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 case FUNC_ACOS : case FUNC_ASIN : case FUNC_ATAN : case FUNC_COS : case FUNC_COT : case FUNC_DEGREES : case FUNC_SIN : case FUNC_TAN : case FUNC_LOG10 : case FUNC_RADIANS : case FUNC_ROUNDMAGIC : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_DOUBLE;
				 }
				 if (!nodes[0].dataType.isNumberType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = Type.SQL_DOUBLE;
				 break;
			 }
			 case FUNC_SIGN : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_DOUBLE;
				 }
				 if (!nodes[0].dataType.isNumberType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = Type.SQL_INTEGER;
				 break;
			 }
			 case FUNC_ATAN2 : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_DOUBLE;
				 }
				 if (nodes[1].dataType == null) {
					 nodes[1].dataType = Type.SQL_DOUBLE;
				 }
				 if (!nodes[0].dataType.isNumberType() || !nodes[1].dataType.isNumberType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = Type.SQL_DOUBLE;
				 break;
			 }
			 case FUNC_SOUNDEX : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_VARCHAR;
				 }
				 if (!nodes[0].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = Type.getType(Types.SQL_VARCHAR, 0, 4, 0);
				 break;
			 }
			 case FUNC_BITAND : case FUNC_BITOR : case FUNC_BITXOR : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = nodes[1].dataType;
				 }
				 if (nodes[1].dataType == null) {
					 nodes[1].dataType = nodes[0].dataType;
				 }
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 if (nodes[i].dataType == null) {
						 nodes[i].dataType = Type.SQL_INTEGER;
					 }
				 }
				 dataType = nodes[0].dataType.getAggregateType(nodes[1].dataType);
				 switch (dataType.typeCode) {
					 case Types.SQL_BIGINT : case Types.SQL_INTEGER : case Types.SQL_SMALLINT : case Types.TINYINT : break;
					 case Types.SQL_BIT : case Types.SQL_BIT_VARYING : break;
					 default : throw Error.error(ErrorCode.X_42561);
				 }
				 break;
			 }
			 case FUNC_ASCII : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_VARCHAR;
				 }
				 if (!nodes[0].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = Type.SQL_INTEGER;
				 break;
			 }
			 case FUNC_CHAR : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_INTEGER;
				 }
				 if (!nodes[0].dataType.isExactNumberType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = Type.getType(Types.SQL_VARCHAR, 0, 1, 0);
				 break;
			 }
			 case FUNC_DIFFERENCE : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_VARCHAR;
				 }
				 if (nodes[1].dataType == null) {
					 nodes[1].dataType = Type.SQL_VARCHAR;
				 }
				 dataType = Type.SQL_INTEGER;
				 break;
			 }
			 case FUNC_HEXTORAW : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_VARCHAR;
				 }
				 if (!nodes[0].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = nodes[0].dataType.precision == 0 ? Type.SQL_VARBINARY_DEFAULT : Type.getType(Types.SQL_VARBINARY, 0, nodes[0].dataType.precision / 2, 0);
				 break;
			 }
			 case FUNC_RAWTOHEX : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_VARBINARY;
				 }
				 if (!nodes[0].dataType.isBinaryType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = nodes[0].dataType.precision == 0 ? Type.SQL_VARCHAR_DEFAULT : Type.getType(Types.SQL_VARCHAR, 0, nodes[0].dataType.precision * 2, 0);
				 break;
			 }
			 case FUNC_REPEAT : {
				 if (nodes[0].dataType == null) {
					 nodes[0].dataType = Type.SQL_VARCHAR;
				 }
				 boolean isChar = nodes[0].dataType.isCharacterType();
				 if (!isChar && !nodes[0].dataType.isBinaryType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 if (!nodes[1].dataType.isExactNumberType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
				 dataType = isChar ? (Type) Type.SQL_VARCHAR_DEFAULT : (Type) Type.SQL_VARBINARY_DEFAULT;
				 break;
			 }
			 case FUNC_REPLACE : {
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 if (nodes[i].dataType == null) {
						 nodes[i].dataType = Type.SQL_VARCHAR;
					 }
					 else if (!nodes[i].dataType.isCharacterType()) {
						 throw Error.error(ErrorCode.X_42561);
					 }
				 }
				 dataType = Type.SQL_VARCHAR_DEFAULT;
				 break;
			 }
			 case FUNC_LEFT : case FUNC_RIGHT : if (nodes[0].dataType == null) {
				 nodes[0].dataType = Type.SQL_VARCHAR;
			 }
			 if (!nodes[0].dataType.isCharacterType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 if (nodes[1].dataType == null) {
				 nodes[1].dataType = Type.SQL_INTEGER;
			 }
			 if (!nodes[1].dataType.isExactNumberType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 dataType = nodes[0].dataType.precision == 0 ? Type.SQL_VARCHAR_DEFAULT : Type.getType(Types.SQL_VARCHAR, 0, nodes[0].dataType.precision, 0);
			 break;
			 case FUNC_SPACE : if (nodes[0].dataType == null) {
				 nodes[0].dataType = Type.SQL_INTEGER;
			 }
			 if (!nodes[0].dataType.isIntegralType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 dataType = Type.SQL_VARCHAR_DEFAULT;
			 break;
			 case FUNC_REVERSE : if (nodes[0].dataType == null) {
				 nodes[0].dataType = Type.SQL_VARCHAR_DEFAULT;
			 }
			 dataType = nodes[0].dataType;
			 if (!dataType.isCharacterType() || dataType.isLobType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 break;
			 case FUNC_REGEXP_MATCHES : if (nodes[0].dataType == null) {
				 nodes[0].dataType = Type.SQL_VARCHAR_DEFAULT;
			 }
			 if (nodes[1].dataType == null) {
				 nodes[1].dataType = Type.SQL_VARCHAR_DEFAULT;
			 }
			 if (!nodes[0].dataType.isCharacterType() || !nodes[1].dataType.isCharacterType() || nodes[1].dataType.isLobType()) {
				 throw Error.error(ErrorCode.X_42561);
			 }
			 dataType = Type.SQL_BOOLEAN;
			 break;
			 case FUNC_CRYPT_KEY : for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (nodes[i].dataType == null) {
					 nodes[i].dataType = Type.SQL_VARCHAR;
				 }
				 else if (!nodes[i].dataType.isCharacterType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
			 }
			 dataType = Type.SQL_VARCHAR_DEFAULT;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""FunctionCustom"");
		 }
	 }
	 public String getSQL() {
		 switch (funcType) {
			 case FUNC_EXTRACT : case FUNC_TRIM_CHAR : case FUNC_OVERLAY_CHAR : return super.getSQL();
			 case FUNC_DATABASE : case FUNC_ISAUTOCOMMIT : case FUNC_ISREADONLYSESSION : case FUNC_ISREADONLYDATABASE : case FUNC_ISREADONLYDATABASEFILES : case FUNC_ISOLATION_LEVEL : case FUNC_SESSION_ISOLATION_LEVEL : case FUNC_DATABASE_ISOLATION_LEVEL : case FUNC_TRANSACTION_CONTROL : case FUNC_TIMEZONE : case FUNC_SESSION_TIMEZONE : case FUNC_DATABASE_TIMEZONE : case FUNC_DATABASE_VERSION : case FUNC_PI : case FUNC_IDENTITY : return new StringBuffer(name).append( Tokens.T_OPENBRACKET).append( Tokens.T_CLOSEBRACKET).toString();
			 case FUNC_TIMESTAMPADD : {
				 String token = Tokens.getSQLTSIString( ((Number) nodes[0].getValue(null)).intValue());
				 return new StringBuffer(Tokens.T_TIMESTAMPADD).append( Tokens.T_OPENBRACKET).append(token) .append(Tokens.T_COMMA).append(nodes[1].getSQL()) .append(Tokens.T_COMMA).append(nodes[2].getSQL()) .append(Tokens.T_CLOSEBRACKET).toString();
			 }
			 case FUNC_TIMESTAMPDIFF : {
				 String token = Tokens.getSQLTSIString( ((Number) nodes[0].getValue(null)).intValue());
				 return new StringBuffer(Tokens.T_TIMESTAMPDIFF).append( Tokens.T_OPENBRACKET).append(token) .append(Tokens.T_COMMA).append(nodes[1].getSQL()) .append(Tokens.T_COMMA).append(nodes[2].getSQL()) .append(Tokens.T_CLOSEBRACKET).toString();
			 }
			 case FUNC_RAND : {
				 StringBuffer sb = new StringBuffer(name).append('(');
				 if (nodes[0] != null) {
					 sb.append(nodes[0].getSQL());
				 }
				 sb.append(')');
				 return sb.toString();
			 }
			 case FUNC_ASCII : case FUNC_ACOS : case FUNC_ASIN : case FUNC_ATAN : case FUNC_CHAR : case FUNC_COS : case FUNC_COT : case FUNC_DEGREES : case FUNC_SIN : case FUNC_TAN : case FUNC_LOG10 : case FUNC_RADIANS : case FUNC_ROUNDMAGIC : case FUNC_SIGN : case FUNC_SOUNDEX : case FUNC_SPACE : case FUNC_REVERSE : case FUNC_HEXTORAW : case FUNC_RAWTOHEX : {
				 return new StringBuffer(name).append('(') .append(nodes[0].getSQL()).append(')').toString();
			 }
			 case FUNC_ATAN2 : case FUNC_BITAND : case FUNC_BITOR : case FUNC_BITXOR : case FUNC_DIFFERENCE : case FUNC_REPEAT : case FUNC_LEFT : case FUNC_RIGHT : case FUNC_ROUND : case FUNC_CRYPT_KEY : case FUNC_TRUNCATE : case FUNC_TIMESTAMP : case FUNC_TO_CHAR : case FUNC_REGEXP_MATCHES : {
				 return new StringBuffer(name).append('(') .append(nodes[0].getSQL()).append(Tokens.T_COMMA) .append(nodes[1].getSQL()).append(')').toString();
			 }
			 case FUNC_REPLACE : {
				 return new StringBuffer(name).append('(') .append(nodes[0].getSQL()).append(Tokens.T_COMMA) .append(nodes[1].getSQL()).append(Tokens.T_COMMA) .append(nodes[2].getSQL()).append(')').toString();
			 }
			 default : return super.getSQL();
		 }
	 }
	 public static char[] soundex(String s) {
		 if (s == null) {
			 return null;
		 }
		 s = s.toUpperCase(Locale.ENGLISH);
		 int len = s.length();
		 char[] b = new char[] {
		 '0', '0', '0', '0' }
		;
		 char lastdigit = '0';
		 for (int i = 0, j = 0;
		 i < len && j < 4;
		 i++) {
			 char c = s.charAt(i);
			 char newdigit;
			 if (""AEIOUY"".indexOf(c) != -1) {
				 newdigit = '7';
			 }
			 else if (c == 'H' || c == 'W') {
				 newdigit = '8';
			 }
			 else if (""BFPV"".indexOf(c) != -1) {
				 newdigit = '1';
			 }
			 else if (""CGJKQSXZ"".indexOf(c) != -1) {
				 newdigit = '2';
			 }
			 else if (c == 'D' || c == 'T') {
				 newdigit = '3';
			 }
			 else if (c == 'L') {
				 newdigit = '4';
			 }
			 else if (c == 'M' || c == 'N') {
				 newdigit = '5';
			 }
			 else if (c == 'R') {
				 newdigit = '6';
			 }
			 else {
				 continue;
			 }
			 if (j == 0) {
				 b[j++] = c;
				 lastdigit = newdigit;
			 }
			 else if (newdigit <= '6') {
				 if (newdigit != lastdigit) {
					 b[j++] = newdigit;
					 lastdigit = newdigit;
				 }
			 }
			 else if (newdigit == '7') {
				 lastdigit = newdigit;
			 }
		 }
		 return b;
	 }
}",1,0,0,0
"public static class CounterMark {
	 private final Row row;
	 private final ColumnMetadata column;
	 private final CellPath path;
	 private CounterMark(Row row, ColumnMetadata column, CellPath path) {
		 this.row = row;
		 this.column = column;
		 this.path = path;
	 }
	 public Clustering clustering() {
		 return row.clustering();
	 }
	 public ColumnMetadata column() {
		 return column;
	 }
	 public CellPath path() {
		 return path;
	 }
	 public ByteBuffer value() {
		 return path == null ? row.getCell(column).value() : row.getCell(column, path).value();
	 }
	 public void setValue(ByteBuffer value) {
		 assert row instanceof BTreeRow;
		 ((BTreeRow)row).setValue(column, path, value);
	 }
 }",0,1,0,0
"public class FilteredLogTableModel extends AbstractTableModel {
	 protected LogRecordFilter _filter = new PassingLogRecordFilter();
	 protected List _allRecords = new ArrayList();
	 protected List _filteredRecords;
	 protected int _maxNumberOfLogRecords = 5000;
	 protected String[] _colNames = {
	""Date"", ""Thread"", ""Message #"", ""Level"", ""NDC"", ""Category"", ""Message"", ""Location"", ""Thrown""}
	;
	 public FilteredLogTableModel() {
		 super();
	 }
	 public void setLogRecordFilter(LogRecordFilter filter) {
		 _filter = filter;
	 }
	 public LogRecordFilter getLogRecordFilter() {
		 return _filter;
	 }
	 public String getColumnName(int i) {
		 return _colNames[i];
	 }
	 public int getColumnCount() {
		 return _colNames.length;
	 }
	 public int getRowCount() {
		 return getFilteredRecords().size();
	 }
	 public int getTotalRowCount() {
		 return _allRecords.size();
	 }
	 public Object getValueAt(int row, int col) {
		 LogRecord record = getFilteredRecord(row);
		 return getColumn(col, record);
	 }
	 public void setMaxNumberOfLogRecords(int maxNumRecords) {
		 if (maxNumRecords > 0) {
			 _maxNumberOfLogRecords = maxNumRecords;
		 }
	 }
	 public synchronized boolean addLogRecord(LogRecord record) {
		 _allRecords.add(record);
		 if (_filter.passes(record) == false) {
			 return false;
		 }
		 getFilteredRecords().add(record);
		 fireTableRowsInserted(getRowCount(), getRowCount());
		 trimRecords();
		 return true;
	 }
	 public synchronized void refresh() {
		 _filteredRecords = createFilteredRecordsList();
		 fireTableDataChanged();
	 }
	 public synchronized void fastRefresh() {
		 _filteredRecords.remove(0);
		 fireTableRowsDeleted(0, 0);
	 }
	 public synchronized void clear() {
		 _allRecords.clear();
		 _filteredRecords.clear();
		 fireTableDataChanged();
	 }
	 protected List getFilteredRecords() {
		 if (_filteredRecords == null) {
			 refresh();
		 }
		 return _filteredRecords;
	 }
	 protected List createFilteredRecordsList() {
		 List result = new ArrayList();
		 Iterator records = _allRecords.iterator();
		 LogRecord current;
		 while (records.hasNext()) {
			 current = (LogRecord) records.next();
			 if (_filter.passes(current)) {
				 result.add(current);
			 }
		 }
		 return result;
	 }
	 protected LogRecord getFilteredRecord(int row) {
		 List records = getFilteredRecords();
		 int size = records.size();
		 if (row < size) {
			 return (LogRecord) records.get(row);
		 }
		 return (LogRecord) records.get(size - 1);
	 }
	 protected Object getColumn(int col, LogRecord lr) {
		 if (lr == null) {
			 return ""NULL Column"";
		 }
		 String date = new Date(lr.getMillis()).toString();
		 switch (col) {
			 case 0: return date + "" ("" + lr.getMillis() + "")"";
			 case 1: return lr.getThreadDescription();
			 case 2: return new Long(lr.getSequenceNumber());
			 case 3: return lr.getLevel();
			 case 4: return lr.getNDC();
			 case 5: return lr.getCategory();
			 case 6: return lr.getMessage();
			 case 7: return lr.getLocation();
			 case 8: return lr.getThrownStackTrace();
			 default: String message = ""The column number "" + col + ""must be between 0 and 8"";
			 throw new IllegalArgumentException(message);
		 }
	 }
	 protected void trimRecords() {
		 if (needsTrimming()) {
			 trimOldestRecords();
		 }
	 }
	 protected boolean needsTrimming() {
		 return (_allRecords.size() > _maxNumberOfLogRecords);
	 }
	 protected void trimOldestRecords() {
		 synchronized (_allRecords) {
			 int trim = numberOfRecordsToTrim();
			 if (trim > 1) {
				 List oldRecords = _allRecords.subList(0, trim);
				 oldRecords.clear();
				 refresh();
			 }
			 else {
				 _allRecords.remove(0);
				 fastRefresh();
			 }
		 }
	 }
	 private int numberOfRecordsToTrim() {
		 return _allRecords.size() - _maxNumberOfLogRecords;
	 }
}",0,0,0,0
"public class JobSchedulerService extends AbstractScheduledService {
	 protected static final long DEFAULT_DELAY = 1000;
	 private static final Logger logger = LoggerFactory.getLogger( JobSchedulerService.class );
	 private long interval = DEFAULT_DELAY;
	 private int workerSize = 1;
	 private int maxFailCount = 10;
	 private JobAccessor jobAccessor;
	 private JobFactory jobFactory;
	 private Semaphore capacitySemaphore;
	 private ListeningScheduledExecutorService service;
	 private JobListener jobListener;
	 private Timer jobTimer;
	 private Counter runCounter;
	 private Counter successCounter;
	 private Counter failCounter;
	 private Injector injector;
	 public JobSchedulerService() {
	 }
	 protected void runOneIteration() throws Exception {
		 MetricsFactory metricsFactory = injector.getInstance( MetricsFactory.class );
		 jobTimer = metricsFactory.getTimer( JobSchedulerService.class, ""scheduler.job_execution_timer"" );
		 runCounter = metricsFactory.getCounter( JobSchedulerService.class, ""scheduler.running_workers"" );
		 successCounter = metricsFactory.getCounter( JobSchedulerService.class, ""scheduler.successful_jobs"" );
		 failCounter = metricsFactory.getCounter( JobSchedulerService.class, ""scheduler.failed_jobs"" );
		 try {
			 if ( logger.isDebugEnabled() ) {
				 logger.debug( ""Running one check iteration ..."" );
			 }
			 List<JobDescriptor> activeJobs;
			 while ( true ) {
				 if ( logger.isDebugEnabled() ) {
					 logger.debug( ""About to acquire semaphore. Capacity is {
					}
					"", capacitySemaphore.availablePermits() );
				 }
				 capacitySemaphore.acquire();
				 capacitySemaphore.release();
				 int capacity = capacitySemaphore.availablePermits();
				 if (logger.isDebugEnabled()) {
					 logger.debug(""Capacity is {
					}
					"", capacity);
				 }
				 activeJobs = jobAccessor.getJobs( capacity );
				 if ( activeJobs.size() == 0 ) {
					 if (logger.isDebugEnabled()) {
						 logger.debug(""No jobs returned. Exiting run loop"");
					 }
					 return;
				 }
				 for ( JobDescriptor jd : activeJobs ) {
					 logger.debug( ""Submitting work for {
					}
					"", jd );
					 submitWork( jd );
					 logger.debug( ""Work submitted for {
					}
					"", jd );
				 }
			 }
		 }
		 catch ( Throwable t ) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(""Scheduler run failed, error is"", t);
			 }
		 }
	 }
	 protected Scheduler scheduler() {
		 return Scheduler.newFixedDelaySchedule( 0, interval, TimeUnit.MILLISECONDS );
	 }
	 private void submitWork( final JobDescriptor jobDescriptor ) {
		 final Job job;
		 try {
			 job = jobFactory.jobsFrom( jobDescriptor );
		 }
		 catch ( JobNotFoundException e ) {
			 logger.error( ""Could not create jobs"", e );
			 return;
		 }
		 final JobExecution execution = new JobExecutionImpl( jobDescriptor );
		 final JobListener currentListener = this.jobListener;
		 try {
			 capacitySemaphore.acquire();
		 }
		 catch ( InterruptedException e ) {
			 logger.error( ""Unable to acquire semaphore capacity before submitting job"", e );
			 return;
		 }
		 final Timer.Context timer = jobTimer.time();
		 ListenableFuture<Void> future = service.submit( new Callable<Void>() {
			 public Void call() throws Exception {
				 if (logger.isDebugEnabled()) {
					 logger.debug(""Starting the job with job id {
					}
					"", execution.getJobId());
				 }
				 runCounter.inc();
				 execution.start( maxFailCount );
				 if ( execution.getStatus() == Status.DEAD ) {
					 try {
						 job.dead( execution );
						 jobAccessor.save( execution );
					 }
					 catch ( Exception t ) {
						 logger.error( ""Unable to invoke dead event on job"", t );
					 }
					 return null;
				 }
				 jobAccessor.save( execution );
				 logger.debug( ""Starting job {
				}
				 with execution data {
				}
				"", job, execution );
				 job.execute( execution );
				 if ( currentListener != null ) {
					 currentListener.onSubmit( execution );
				 }
				 return null;
			 }
		 }
		 );
		 Futures.addCallback( future, new FutureCallback<Void>() {
			 public void onSuccess( Void param ) {
				 if (logger.isDebugEnabled()) {
					 logger.debug(""Job succeeded with the job id {
					}
					"", execution.getJobId());
				 }
				 capacitySemaphore.release();
				 timer.stop();
				 runCounter.dec();
				 successCounter.inc();
				 if ( execution.getStatus() == Status.IN_PROGRESS ) {
					 logger.debug( ""Successful completion of bulkJob {
					}
					"", execution );
					 execution.completed();
				 }
				 jobAccessor.save( execution );
				 if ( currentListener != null ) {
					 currentListener.onSuccess( execution );
				 }
			 }
			 public void onFailure( Throwable throwable ) {
				 logger.error( ""Job failed with the job id {
				}
				"", execution.getJobId() );
				 capacitySemaphore.release();
				 timer.stop();
				 runCounter.dec();
				 failCounter.inc();
				 logger.error( ""Failed execution for bulkJob"", throwable );
				 if ( execution.getStatus() == Status.IN_PROGRESS ) {
					 execution.failed();
				 }
				 jobAccessor.save( execution );
				 if ( currentListener != null ) {
					 currentListener.onFailure( execution );
				 }
			 }
		 }
		 );
	 }
	 public void setInterval( long milliseconds ) {
		 this.interval = milliseconds;
	 }
	 public long getInterval() {
		 return interval;
	 }
	 public void setWorkerSize( int listeners ) {
		 this.workerSize = listeners;
	 }
	 public int getWorkerSize() {
		 return workerSize;
	 }
	 public void setJobAccessor( JobAccessor jobAccessor ) {
		 this.jobAccessor = jobAccessor;
	 }
	 public void setJobFactory( JobFactory jobFactory ) {
		 this.jobFactory = jobFactory;
	 }
	 public void setMaxFailCount( int maxFailCount ) {
		 this.maxFailCount = maxFailCount;
	 }
	 protected void startUp() throws Exception {
		 service = MoreExecutors .listeningDecorator( Executors.newScheduledThreadPool( workerSize, JobThreadFactory.INSTANCE ) );
		 capacitySemaphore = new Semaphore( workerSize );
		 logger.info( ""Starting executor pool. Capacity is {
		}
		"", workerSize );
		 super.startUp();
		 logger.info( ""Job Scheduler started"" );
	 }
	 protected void shutDown() throws Exception {
		 logger.info( ""Shutting down job scheduler"" );
		 service.shutdown();
		 logger.info( ""Job scheduler shut down"" );
		 super.shutDown();
	 }
	 public JobListener setJobListener( JobListener jobListener ) {
		 JobListener old = this.jobListener;
		 this.jobListener = jobListener;
		 return old;
	 }
	 public JobListener getJobListener() {
		 return jobListener;
	 }
	 public void setInjector(Injector injector) {
		 this.injector = injector;
	 }
	 private static final class JobThreadFactory implements ThreadFactory {
		 public static final JobThreadFactory INSTANCE = new JobThreadFactory();
		 private static final String NAME = ""JobWorker-"";
		 private final AtomicLong counter = new AtomicLong();
		 public Thread newThread( final Runnable r ) {
			 Thread newThread = new Thread( r, NAME + counter.incrementAndGet() );
			 newThread.setDaemon( true );
			 return newThread;
		 }
	 }
}",1,1,0,0
"private <T extends ResourceBase> boolean mergeResourceMap( Map<String, T> fragmentResources, Map<String, T> mainResources, Map<String, T> tempResources, WebXml fragment) {
	 for (T resource : fragmentResources.values()) {
		 String resourceName = resource.getName();
		 if (mainResources.containsKey(resourceName)) {
			 mainResources.get(resourceName).getInjectionTargets().addAll( resource.getInjectionTargets());
		 }
		 else {
			 T existingResource = tempResources.get(resourceName);
			 if (existingResource != null) {
				 if (!existingResource.equals(resource)) {
					 log.error(sm.getString( ""webXml.mergeConflictResource"", resourceName, fragment.getName(), fragment.getURL()));
					 return false;
				 }
			 }
			 else {
				 tempResources.put(resourceName, resource);
			 }
		 }
	 }
	 return true;
 }",0,0,1,0
"private ArrayList<String> parseManifest(String file) throws IOException {
	ArrayList<String> urlList = new ArrayList<String>();
	BufferedReader r = null;
	try {
		r = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
		boolean expect = false;
		while (true) {
			String line = r.readLine();
			if (line == null)break;
			String highline = line.toUpperCase().trim();
			if (highline.length() < 1)continue;
			if (highline.startsWith(""#EXT-X-KEY"")) {
				encrypted = true;
				break;
			}
			if (expect) {
				urlList.add(line.trim());
				expect = false;
			}
			if (highline.startsWith(""#EXT-X-STREAM-INF"")) {
				masterPlaylist = true;
				expect = true;
				String[] arr = highline.split("":"");
				if (arr.length > 1) {
					mediaProperties.add(M3U8MediaInfo.parse(arr[1].trim()));
				}
			}
			if (highline.startsWith(""#EXTINF"")) {
				masterPlaylist = false;
				expect = true;
				try {
					String[] arr = highline.split("":"");
					if (arr.length > 1) {
						mediaProperties.add(M3U8MediaInfo.parse(arr[1].trim()));
						String str = arr[1].trim().split("","")[0];
						duration += Float.parseFloat(str);
					}
				}
				 catch (Exception e) {
					Logger.log(e);
				}
			}
		}
	}
	 catch (Exception e) {
		Logger.log(e);
		throw new IOException(""Unable to parse menifest"");
	}
	 finally {
		try {
			if (r != null)r.close();
		}
		 catch (Exception e) {
		}
	}
	return urlList;
}",0,0,1,0
"public class JSPWikiMarkupParser extends MarkupParser{
	 private static final String OUTLINK_IMAGE = ""images/out.png"";
	 public static final String CLASS_WIKIPAGE = ""wikipage"";
	 public static final String CLASS_EDITPAGE = ""createpage"";
	 public static final String CLASS_INTERWIKI = ""interwiki"";
	 protected static final int READ = 0;
	 protected static final int EDIT = 1;
	 protected static final int EMPTY = 2;
	 protected static final int LOCAL = 3;
	 protected static final int LOCALREF = 4;
	 protected static final int IMAGE = 5;
	 protected static final int EXTERNAL = 6;
	 protected static final int INTERWIKI = 7;
	 protected static final int IMAGELINK = 8;
	 protected static final int IMAGEWIKILINK = 9;
	 protected static final int ATTACHMENT = 10;
	 private static Logger log = Logger.getLogger( JSPWikiMarkupParser.class );
	 private boolean m_isbold = false;
	 private boolean m_isitalic = false;
	 private boolean m_istable = false;
	 private boolean m_isPre = false;
	 private boolean m_isEscaping = false;
	 private boolean m_isdefinition = false;
	 private boolean m_isPreBlock = false;
	 private Stack<Boolean> m_styleStack = new Stack<Boolean>();
	 private int m_genlistlevel = 0;
	 private StringBuilder m_genlistBulletBuffer = new StringBuilder(10);
	 private boolean m_allowPHPWikiStyleLists = true;
	 private boolean m_isOpenParagraph = false;
	 private List<Pattern> m_inlineImagePatterns;
	 private LinkParser m_linkParser = new LinkParser();
	 private PatternMatcher m_inlineMatcher = new Perl5Matcher();
	 private StringBuilder m_plainTextBuf = new StringBuilder(20);
	 private Element m_currentElement;
	 private Map<String, Integer> m_titleSectionCounter = new HashMap<String, Integer>();
	 public static final String PROP_INLINEIMAGEPTRN = ""jspwiki.translatorReader.inlinePattern"";
	 public static final String PROP_CAMELCASELINKS = ""jspwiki.translatorReader.camelCaseLinks"";
	 public static final String PROP_PLAINURIS = ""jspwiki.translatorReader.plainUris"";
	 public static final String PROP_USEOUTLINKIMAGE = ""jspwiki.translatorReader.useOutlinkImage"";
	 public static final String PROP_USEATTACHMENTIMAGE = ""jspwiki.translatorReader.useAttachmentImage"";
	 public static final String PROP_USERELNOFOLLOW = ""jspwiki.translatorReader.useRelNofollow"";
	 private boolean m_camelCaseLinks = false;
	 private boolean m_wysiwygEditorMode = false;
	 private boolean m_plainUris = false;
	 private boolean m_useOutlinkImage = true;
	 private boolean m_useAttachmentImage = true;
	 private boolean m_allowHTML = false;
	 private boolean m_useRelNofollow = false;
	 private PatternCompiler m_compiler = new Perl5Compiler();
	 static final String WIKIWORD_REGEX = ""(^|[[:^alnum:]]+)([[:upper:]]+[[:lower:]]+[[:upper:]]+[[:alnum:]]*|(http: private PatternMatcher m_camelCaseMatcher = new Perl5Matcher();
	 private Pattern m_camelCasePattern;
	 private int m_rowNum = 1;
	 private Heading m_lastHeading = null;
	 public static final String DEFAULT_INLINEPATTERN = ""*.png"";
	 static final String[] EXTERNAL_LINKS = {
	 ""http:"", ""ftp:"", ""https:"", ""mailto:"", ""news:"", ""file:"", ""rtsp:"", ""mms:"", ""ldap:"", ""gopher:"", ""nntp:"", ""telnet:"", ""wais:"", ""prospero:"", ""z39.50s"", ""z39.50r"", ""vemmi:"", ""imap:"", ""nfs:"", ""acap:"", ""tip:"", ""pop:"", ""dav:"", ""opaquelocktoken:"", ""sip:"", ""sips:"", ""tel:"", ""fax:"", ""modem:"", ""soap.beep:"", ""soap.beeps"", ""xmlrpc.beep"", ""xmlrpc.beeps"", ""urn:"", ""go:"", ""h323:"", ""ipp:"", ""tftp:"", ""mupdate:"", ""pres:"", ""im:"", ""mtqp"", ""smb:"" }
	;
	 private static final String INLINE_IMAGE_PATTERNS = ""JSPWikiMarkupParser.inlineImagePatterns"";
	 private static final String CAMELCASE_PATTERN = ""JSPWikiMarkupParser.camelCasePattern"";
	 private static final String[] CLASS_TYPES = {
	 CLASS_WIKIPAGE, CLASS_EDITPAGE, """", ""footnote"", ""footnoteref"", """", ""external"", CLASS_INTERWIKI, ""external"", CLASS_WIKIPAGE, ""attachment"" }
	;
	 private static Comparator<String> c_startingComparator = new StartingComparator();
	 static {
		 Arrays.sort( EXTERNAL_LINKS );
	 }
	 public JSPWikiMarkupParser( WikiContext context, Reader in ) {
		 super( context, in );
		 initialize();
	 }
	 private void initialize() {
		 PatternCompiler compiler = new GlobCompiler();
		 List<Pattern> compiledpatterns;
		 compiledpatterns = (List<Pattern>)m_engine.getAttribute( INLINE_IMAGE_PATTERNS );
		 if( compiledpatterns == null ) {
			 compiledpatterns = new ArrayList<Pattern>(20);
			 Collection ptrns = getImagePatterns( m_engine );
			 for( Iterator i = ptrns.iterator();
			 i.hasNext();
			 ) {
				 try {
					 compiledpatterns.add( compiler.compile( (String)i.next(), GlobCompiler.DEFAULT_MASK|GlobCompiler.READ_ONLY_MASK ) );
				 }
				 catch( MalformedPatternException e ) {
					 log.error(""Malformed pattern in properties: "", e );
				 }
			 }
			 m_engine.setAttribute( INLINE_IMAGE_PATTERNS, compiledpatterns );
		 }
		 m_inlineImagePatterns = Collections.unmodifiableList(compiledpatterns);
		 m_camelCasePattern = (Pattern) m_engine.getAttribute( CAMELCASE_PATTERN );
		 if( m_camelCasePattern == null ) {
			 try {
				 m_camelCasePattern = m_compiler.compile( WIKIWORD_REGEX, Perl5Compiler.DEFAULT_MASK|Perl5Compiler.READ_ONLY_MASK );
			 }
			 catch( MalformedPatternException e ) {
				 log.fatal(""Internal error: Someone put in a faulty pattern."",e);
				 throw new InternalWikiException(""Faulty camelcasepattern in TranslatorReader"");
			 }
			 m_engine.setAttribute( CAMELCASE_PATTERN, m_camelCasePattern );
		 }
		 Properties props = m_engine.getWikiProperties();
		 String cclinks = (String)m_context.getPage().getAttribute( PROP_CAMELCASELINKS );
		 if( cclinks != null ) {
			 m_camelCaseLinks = TextUtil.isPositive( cclinks );
		 }
		 else {
			 m_camelCaseLinks = TextUtil.getBooleanProperty( props, PROP_CAMELCASELINKS, m_camelCaseLinks );
		 }
		 Boolean wysiwygVariable = (Boolean)m_context.getVariable( RenderingManager.WYSIWYG_EDITOR_MODE );
		 if( wysiwygVariable != null ) {
			 m_wysiwygEditorMode = wysiwygVariable.booleanValue();
		 }
		 m_plainUris = getLocalBooleanProperty( m_context, props, PROP_PLAINURIS, m_plainUris );
		 m_useOutlinkImage = getLocalBooleanProperty( m_context, props, PROP_USEOUTLINKIMAGE, m_useOutlinkImage );
		 m_useAttachmentImage = getLocalBooleanProperty( m_context, props, PROP_USEATTACHMENTIMAGE, m_useAttachmentImage );
		 m_allowHTML = getLocalBooleanProperty( m_context, props, MarkupParser.PROP_ALLOWHTML, m_allowHTML );
		 m_useRelNofollow = getLocalBooleanProperty( m_context, props, PROP_USERELNOFOLLOW, m_useRelNofollow );
		 if( m_engine.getUserManager().getUserDatabase() == null || m_engine.getAuthorizationManager() == null ) {
			 disableAccessRules();
		 }
		 m_context.getPage().setHasMetadata();
	 }
	 private static boolean getLocalBooleanProperty( WikiContext context, Properties props, String key, boolean defValue ) {
		 Object bool = context.getVariable(key);
		 if( bool != null ) {
			 return TextUtil.isPositive( (String) bool );
		 }
		 return TextUtil.getBooleanProperty( props, key, defValue );
	 }
	 public static Collection getImagePatterns( WikiEngine engine ) {
		 Properties props = engine.getWikiProperties();
		 ArrayList<String> ptrnlist = new ArrayList<String>();
		 for( Enumeration e = props.propertyNames();
		 e.hasMoreElements();
		 ) {
			 String name = (String) e.nextElement();
			 if( name.startsWith( PROP_INLINEIMAGEPTRN ) ) {
				 String ptrn = TextUtil.getStringProperty( props, name, null );
				 ptrnlist.add( ptrn );
			 }
		 }
		 if( ptrnlist.size() == 0 ) {
			 ptrnlist.add( DEFAULT_INLINEPATTERN );
		 }
		 return ptrnlist;
	 }
	 private String linkExists( String page ) {
		 try {
			 if( page == null || page.length() == 0 ) return null;
			 return m_engine.getFinalPageName( page );
		 }
		 catch( ProviderException e ) {
			 log.warn(""TranslatorReader got a faulty page name!"",e);
			 return page;
		 }
	 }
	 protected String callMutatorChain( Collection list, String text ) {
		 if( list == null || list.size() == 0 ) {
			 return text;
		 }
		 for( Iterator i = list.iterator();
		 i.hasNext();
		 ) {
			 StringTransmutator m = (StringTransmutator) i.next();
			 text = m.mutate( m_context, text );
		 }
		 return text;
	 }
	 protected void callHeadingListenerChain( Heading param ) {
		 List list = m_headingListenerChain;
		 for( Iterator i = list.iterator();
		 i.hasNext();
		 ) {
			 HeadingListener h = (HeadingListener) i.next();
			 h.headingAdded( m_context, param );
		 }
	 }
	 protected Element createAnchor(int type, String link, String text, String section) {
		 text = escapeHTMLEntities( text );
		 section = escapeHTMLEntities( section );
		 Element el = new Element(""a"");
		 el.setAttribute(""class"",CLASS_TYPES[type]);
		 el.setAttribute(""href"",link+section);
		 el.addContent(text);
		 return el;
	 }
	 private Element makeLink( int type, String link, String text, String section, Iterator attributes ) {
		 Element el = null;
		 if( text == null ) text = link;
		 text = callMutatorChain( m_linkMutators, text );
		 section = (section != null) ? (""#""+section) : """";
		 if( link.length() == 0 ) {
			 type = EMPTY;
		 }
		 ResourceBundle rb = m_context.getBundle(InternationalizationManager.CORE_BUNDLE);
		 Object[] args = {
		 link }
		;
		 switch(type) {
			 case READ: el = createAnchor( READ, m_context.getURL(WikiContext.VIEW, link), text, section );
			 break;
			 case EDIT: el = createAnchor( EDIT, m_context.getURL(WikiContext.EDIT,link), text, """" );
			 el.setAttribute(""title"", MessageFormat.format( rb.getString( ""markupparser.link.create"" ), args ) );
			 break;
			 case EMPTY: el = new Element(""u"").addContent(text);
			 break;
			 case LOCALREF: el = createAnchor( LOCALREF, ""#ref-""+m_context.getName()+""-""+link, ""[""+text+""]"", """" );
			 break;
			 case LOCAL: el = new Element(""a"").setAttribute(""class"",""footnote"");
			 el.setAttribute(""name"", ""ref-""+m_context.getName()+""-""+link.substring(1));
			 el.addContent(""[""+text+""]"");
			 break;
			 case IMAGE: el = new Element(""img"").setAttribute(""class"",""inline"");
			 el.setAttribute(""src"",link);
			 el.setAttribute(""alt"",text);
			 break;
			 case IMAGELINK: el = new Element(""img"").setAttribute(""class"",""inline"");
			 el.setAttribute(""src"",link);
			 el.setAttribute(""alt"",text);
			 el = createAnchor(IMAGELINK,text,"""","""").addContent(el);
			 break;
			 case IMAGEWIKILINK: String pagelink = m_context.getURL(WikiContext.VIEW,text);
			 el = new Element(""img"").setAttribute(""class"",""inline"");
			 el.setAttribute(""src"",link);
			 el.setAttribute(""alt"",text);
			 el = createAnchor(IMAGEWIKILINK,pagelink,"""","""").addContent(el);
			 break;
			 case EXTERNAL: el = createAnchor( EXTERNAL, link, text, section );
			 if( m_useRelNofollow ) el.setAttribute(""rel"",""nofollow"");
			 break;
			 case INTERWIKI: el = createAnchor( INTERWIKI, link, text, section );
			 break;
			 case ATTACHMENT: String attlink = m_context.getURL( WikiContext.ATTACH, link );
			 String infolink = m_context.getURL( WikiContext.INFO, link );
			 String imglink = m_context.getURL( WikiContext.NONE, ""images/attachment_small.png"" );
			 el = createAnchor( ATTACHMENT, attlink, text, """" );
			 pushElement(el);
			 popElement(el.getName());
			 if( m_useAttachmentImage ) {
				 el = new Element(""img"").setAttribute(""src"",imglink);
				 el.setAttribute(""border"",""0"");
				 el.setAttribute(""alt"",""(info)"");
				 el = new Element(""a"").setAttribute(""href"",infolink).addContent(el);
				 el.setAttribute(""class"",""infolink"");
			 }
			 else {
				 el = null;
			 }
			 break;
			 default: break;
		 }
		 if( el != null && attributes != null ) {
			 while( attributes.hasNext() ) {
				 Attribute attr = (Attribute)attributes.next();
				 if( attr != null ) {
					 el.setAttribute(attr);
				 }
			 }
		 }
		 if( el != null ) {
			 flushPlainText();
			 m_currentElement.addContent( el );
		 }
		 return el;
	 }
	 public static boolean isExternalLink( String link ) {
		 int idx = Arrays.binarySearch( EXTERNAL_LINKS, link, c_startingComparator );
		 if( idx >= 0 && link.startsWith(EXTERNAL_LINKS[idx]) ) return true;
		 return false;
	 }
	 private static boolean isAccessRule( String link ) {
		 return link.startsWith(""{
			ALLOW"") || link.startsWith(""{
				DENY"");
			 }
			 private boolean isImageLink( String link ) {
				 if( m_inlineImages ) {
					 link = link.toLowerCase();
					 for( Iterator i = m_inlineImagePatterns.iterator();
					 i.hasNext();
					 ) {
						 if( m_inlineMatcher.matches( link, (Pattern) i.next() ) ) return true;
					 }
				 }
				 return false;
			 }
			 private static boolean isMetadata( String link ) {
				 return link.startsWith(""{
					SET"");
				 }
				 private static final String[] BLOCK_ELEMENTS = {
				 ""address"", ""blockquote"", ""div"", ""dl"", ""fieldset"", ""form"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""hr"", ""noscript"", ""ol"", ""p"", ""pre"", ""table"", ""ul"" }
				;
				 private static final boolean isBlockLevel( String name ) {
					 return Arrays.binarySearch( BLOCK_ELEMENTS, name ) >= 0;
				 }
				 private String peekAheadLine() throws IOException {
					 String s = readUntilEOL().toString();
					 if( s.length() > PUSHBACK_BUFFER_SIZE ) {
						 log.warn(""Line is longer than maximum allowed size (""+PUSHBACK_BUFFER_SIZE+"" characters. Attempting to recover..."");
						 pushBack( s.substring(0,PUSHBACK_BUFFER_SIZE-1) );
					 }
					 else {
						 try {
							 pushBack( s );
						 }
						 catch( IOException e ) {
							 log.warn(""Pushback failed: the line is probably too long. Attempting to recover."");
						 }
					 }
					 return s;
				 }
				 public static Element makeError( String error ) {
					 return new Element(""span"").setAttribute(""class"",""error"").addContent(error);
				 }
				 private int flushPlainText() {
					 int numChars = m_plainTextBuf.length();
					 if( numChars > 0 ) {
						 String buf;
						 if( !m_allowHTML ) {
							 buf = escapeHTMLEntities(m_plainTextBuf.toString());
						 }
						 else {
							 buf = m_plainTextBuf.toString();
						 }
						 m_plainTextBuf = new StringBuilder(20);
						 try {
							 if( m_camelCaseLinks && !m_isEscaping && buf.length() > 3 ) {
								 while( m_camelCaseMatcher.contains( buf, m_camelCasePattern ) ) {
									 MatchResult result = m_camelCaseMatcher.getMatch();
									 String firstPart = buf.substring(0,result.beginOffset(0));
									 String prefix = result.group(1);
									 if( prefix == null ) prefix = """";
									 String camelCase = result.group(2);
									 String protocol = result.group(3);
									 String uri = protocol+result.group(4);
									 buf = buf.substring(result.endOffset(0));
									 m_currentElement.addContent( firstPart );
									 if( prefix.endsWith(""~"") || prefix.indexOf('[') != -1 ) {
										 if( prefix.endsWith(""~"") ) {
											 if( m_wysiwygEditorMode ) {
												 m_currentElement.addContent( ""~"" );
											 }
											 prefix = prefix.substring(0,prefix.length()-1);
										 }
										 if( camelCase != null ) {
											 m_currentElement.addContent( prefix+camelCase );
										 }
										 else if( protocol != null ) {
											 m_currentElement.addContent( prefix+uri );
										 }
										 continue;
									 }
									 if( protocol != null ) {
										 char c = uri.charAt(uri.length()-1);
										 if( c == '.' || c == ',' ) {
											 uri = uri.substring(0,uri.length()-1);
											 buf = c + buf;
										 }
										 m_currentElement.addContent( prefix );
										 makeDirectURILink( uri );
									 }
									 else {
										 m_currentElement.addContent( prefix );
										 makeCamelCaseLink( camelCase );
									 }
								 }
								 m_currentElement.addContent( buf );
							 }
							 else {
								 m_currentElement.addContent( buf );
							 }
						 }
						 catch( IllegalDataException e ) {
							 m_currentElement.addContent( makeError(cleanupSuspectData( e.getMessage() )) );
						 }
					 }
					 return numChars;
				 }
				 private String escapeHTMLEntities(String buf) {
					 StringBuilder tmpBuf = new StringBuilder( buf.length() + 20 );
					 for( int i = 0;
					 i < buf.length();
					 i++ ) {
						 char ch = buf.charAt(i);
						 if( ch == '<' ) {
							 tmpBuf.append(""&lt;
							"");
						 }
						 else if( ch == '>' ) {
							 tmpBuf.append(""&gt;
							"");
						 }
						 else if( ch == '\""' ) {
							 tmpBuf.append(""&quot;
							"");
						 }
						 else if( ch == '&' ) {
							 boolean isEntity = false;
							 StringBuilder entityBuf = new StringBuilder();
							 if( i < buf.length() -1 ) {
								 for( int j = i;
								 j < buf.length();
								 j++ ) {
									 char ch2 = buf.charAt(j);
									 if( Character.isLetterOrDigit( ch2 ) || (ch2 == '#' && j == i+1) || ch2 == ';
									' || ch2 == '&' ) {
										 entityBuf.append(ch2);
										 if( ch2 == ';
										' ) {
											 isEntity = true;
											 break;
										 }
									 }
									 else {
										 break;
									 }
								 }
							 }
							 if( isEntity ) {
								 tmpBuf.append( entityBuf );
								 i = i + entityBuf.length() - 1;
							 }
							 else {
								 tmpBuf.append(""&amp;
								"");
							 }
						 }
						 else {
							 tmpBuf.append( ch );
						 }
					 }
					 return tmpBuf.toString();
				 }
				 private Element pushElement( Element e ) {
					 flushPlainText();
					 m_currentElement.addContent( e );
					 m_currentElement = e;
					 return e;
				 }
				 private Element addElement( Content e ) {
					 if( e != null ) {
						 flushPlainText();
						 m_currentElement.addContent( e );
					 }
					 return m_currentElement;
				 }
				 private static final String[] EMPTY_ELEMENTS = {
				 ""area"", ""base"", ""br"", ""col"", ""hr"", ""img"", ""input"", ""link"", ""meta"", ""p"", ""param"" }
				;
				 private Element popElement( String s ) {
					 int flushedBytes = flushPlainText();
					 Element currEl = m_currentElement;
					 while( currEl.getParentElement() != null ) {
						 if( currEl.getName().equals(s) && !currEl.isRootElement() ) {
							 m_currentElement = currEl.getParentElement();
							 if( flushedBytes == 0 && Arrays.binarySearch( EMPTY_ELEMENTS, s ) < 0 ) {
								 currEl.addContent("""");
							 }
							 return m_currentElement;
						 }
						 currEl = currEl.getParentElement();
					 }
					 return null;
				 }
				 private String readUntil( String endChars ) throws IOException {
					 StringBuilder sb = new StringBuilder( 80 );
					 int ch = nextToken();
					 while( ch != -1 ) {
						 if( ch == '\\' ) {
							 ch = nextToken();
							 if( ch == -1 ) {
								 break;
							 }
						 }
						 else {
							 if( endChars.indexOf((char)ch) != -1 ) {
								 pushBack( ch );
								 break;
							 }
						 }
						 sb.append( (char) ch );
						 ch = nextToken();
					 }
					 return sb.toString();
				 }
				 private String readWhile( String endChars ) throws IOException {
					 StringBuilder sb = new StringBuilder( 80 );
					 int ch = nextToken();
					 while( ch != -1 ) {
						 if( endChars.indexOf((char)ch) == -1 ) {
							 pushBack( ch );
							 break;
						 }
						 sb.append( (char) ch );
						 ch = nextToken();
					 }
					 return sb.toString();
				 }
				 private JSPWikiMarkupParser m_cleanTranslator;
				 private JSPWikiMarkupParser getCleanTranslator() {
					 if( m_cleanTranslator == null ) {
						 WikiContext dummyContext = new WikiContext( m_engine, m_context.getHttpRequest(), m_context.getPage() );
						 m_cleanTranslator = new JSPWikiMarkupParser( dummyContext, null );
						 m_cleanTranslator.m_allowHTML = true;
					 }
					 return m_cleanTranslator;
				 }
				 private String makeHeadingAnchor( String baseName, String title, Heading hd ) {
					 hd.m_titleText = title;
					 title = MarkupParser.wikifyLink( title );
					 hd.m_titleSection = m_engine.encodeName(title);
					 if( m_titleSectionCounter.containsKey( hd.m_titleSection ) ) {
						 Integer count = m_titleSectionCounter.get( hd.m_titleSection );
						 count = count + 1;
						 m_titleSectionCounter.put( hd.m_titleSection, count );
						 hd.m_titleSection += ""-"" + count;
					 }
					 else {
						 m_titleSectionCounter.put( hd.m_titleSection, 1 );
					 }
					 hd.m_titleAnchor = ""section-""+m_engine.encodeName(baseName)+ ""-""+hd.m_titleSection;
					 hd.m_titleAnchor = hd.m_titleAnchor.replace( '%', '_' );
					 hd.m_titleAnchor = hd.m_titleAnchor.replace( '/', '_' );
					 return hd.m_titleAnchor;
				 }
				 private String makeSectionTitle( String title ) {
					 title = title.trim();
					 String outTitle;
					 try {
						 JSPWikiMarkupParser dtr = getCleanTranslator();
						 dtr.setInputReader( new StringReader(title) );
						 CleanTextRenderer ctt = new CleanTextRenderer(m_context, dtr.parse());
						 outTitle = ctt.getString();
					 }
					 catch( IOException e ) {
						 log.fatal(""CleanTranslator not working"", e);
						 throw new InternalWikiException(""CleanTranslator not working as expected, when cleaning title""+ e.getMessage() );
					 }
					 return outTitle;
				 }
				 public Element makeHeading( int level, String title, Heading hd ) {
					 Element el = null;
					 String pageName = m_context.getPage().getName();
					 String outTitle = makeSectionTitle( title );
					 hd.m_level = level;
					 switch( level ) {
						 case Heading.HEADING_SMALL: el = new Element(""h4"").setAttribute(""id"",makeHeadingAnchor( pageName, outTitle, hd ));
						 break;
						 case Heading.HEADING_MEDIUM: el = new Element(""h3"").setAttribute(""id"",makeHeadingAnchor( pageName, outTitle, hd ));
						 break;
						 case Heading.HEADING_LARGE: el = new Element(""h2"").setAttribute(""id"",makeHeadingAnchor( pageName, outTitle, hd ));
						 break;
						 default: throw new InternalWikiException(""Illegal heading type ""+level);
					 }
					 return el;
				 }
				 private Element makeCamelCaseLink( String wikiname ) {
					 String matchedLink;
					 callMutatorChain( m_localLinkMutatorChain, wikiname );
					 if( (matchedLink = linkExists( wikiname )) != null ) {
						 makeLink( READ, matchedLink, wikiname, null, null );
					 }
					 else {
						 makeLink( EDIT, wikiname, wikiname, null, null );
					 }
					 return m_currentElement;
				 }
				 private String m_outlinkImageURL = null;
				 private Element outlinkImage() {
					 Element el = null;
					 if( m_useOutlinkImage ) {
						 if( m_outlinkImageURL == null ) {
							 m_outlinkImageURL = m_context.getURL( WikiContext.NONE, OUTLINK_IMAGE );
						 }
						 el = new Element(""img"").setAttribute(""class"", ""outlink"");
						 el.setAttribute( ""src"", m_outlinkImageURL );
						 el.setAttribute(""alt"","""");
					 }
					 return el;
				 }
				 private Element makeDirectURILink( String url ) {
					 Element result;
					 String last = null;
					 if( url.endsWith("","") || url.endsWith(""."") ) {
						 last = url.substring( url.length()-1 );
						 url = url.substring( 0, url.length()-1 );
					 }
					 callMutatorChain( m_externalLinkMutatorChain, url );
					 if( isImageLink( url ) ) {
						 result = handleImageLink( StringUtils.replace(url,""&amp;
						"",""&""), url, false );
					 }
					 else {
						 result = makeLink( EXTERNAL, StringUtils.replace(url,""&amp;
						"",""&""), url, null, null );
						 addElement( outlinkImage() );
					 }
					 if( last != null ) {
						 m_plainTextBuf.append(last);
					 }
					 return result;
				 }
				 private Element handleImageLink( String reallink, String link, boolean hasLinkText ) {
					 String possiblePage = MarkupParser.cleanLink( link );
					 if( isExternalLink( link ) && hasLinkText ) {
						 return makeLink( IMAGELINK, reallink, link, null, null );
					 }
					 else if( ( linkExists( possiblePage ) ) != null && hasLinkText ) {
						 callMutatorChain( m_localLinkMutatorChain, possiblePage );
						 return makeLink( IMAGEWIKILINK, reallink, link, null, null );
					 }
					 else {
						 return makeLink( IMAGE, reallink, link, null, null );
					 }
				 }
				 private Element handleAccessRule( String ruleLine ) {
					 if( m_wysiwygEditorMode ) {
						 m_currentElement.addContent( ""["" + ruleLine + ""]"" );
					 }
					 if( !m_parseAccessRules ) return m_currentElement;
					 Acl acl;
					 WikiPage page = m_context.getRealPage();
					 if( ruleLine.startsWith( ""{
						"" ) ) ruleLine = ruleLine.substring( 1 );
					 if( ruleLine.endsWith( ""}
					"" ) ) ruleLine = ruleLine.substring( 0, ruleLine.length() - 1 );
					 if( log.isDebugEnabled() ) log.debug(""page=""+page.getName()+"", ACL = ""+ruleLine);
					 try {
						 acl = m_engine.getAclManager().parseAcl( page, ruleLine );
						 page.setAcl( acl );
						 if( log.isDebugEnabled() ) log.debug( acl.toString() );
					 }
					 catch( WikiSecurityException wse ) {
						 return makeError( wse.getMessage() );
					 }
					 return m_currentElement;
				 }
				 private Element handleMetadata( String link ) {
					 if( m_wysiwygEditorMode ) {
						 m_currentElement.addContent( ""["" + link + ""]"" );
					 }
					 try {
						 String args = link.substring( link.indexOf(' '), link.length()-1 );
						 String name = args.substring( 0, args.indexOf('=') );
						 String val = args.substring( args.indexOf('=')+1, args.length() );
						 name = name.trim();
						 val = val.trim();
						 if( val.startsWith(""'"") ) val = val.substring( 1 );
						 if( val.endsWith(""'"") ) val = val.substring( 0, val.length()-1 );
						 if( name.length() > 0 && val.length() > 0 ) {
							 val = m_engine.getVariableManager().expandVariables( m_context, val );
							 m_context.getPage().setAttribute( name, val );
						 }
					 }
					 catch( Exception e ) {
						 ResourceBundle rb = m_context.getBundle(InternationalizationManager.CORE_BUNDLE);
						 Object[] args = {
						 link }
						;
						 return makeError( MessageFormat.format( rb.getString( ""markupparser.error.invalidset"" ), args ) );
					 }
					 return m_currentElement;
				 }
				 private void disableOutputEscaping() {
					 addElement( new ProcessingInstruction(Result.PI_DISABLE_OUTPUT_ESCAPING, """") );
				 }
				 private Element handleHyperlinks( String linktext, int pos ) {
					 ResourceBundle rb = m_context.getBundle(InternationalizationManager.CORE_BUNDLE);
					 StringBuilder sb = new StringBuilder(linktext.length()+80);
					 if( isAccessRule( linktext ) ) {
						 return handleAccessRule( linktext );
					 }
					 if( isMetadata( linktext ) ) {
						 return handleMetadata( linktext );
					 }
					 if( PluginManager.isPluginLink( linktext ) ) {
						 try {
							 PluginContent pluginContent = m_engine.getPluginManager().parsePluginLine( m_context, linktext, pos );
							 if( pluginContent != null ) {
								 addElement( pluginContent );
								 pluginContent.executeParse( m_context );
							 }
						 }
						 catch( PluginException e ) {
							 log.info( ""Failed to insert plugin: ""+e.getMessage() );
							 if( !m_wysiwygEditorMode ) {
								 ResourceBundle rbPlugin = m_context.getBundle(WikiPlugin.CORE_PLUGINS_RESOURCEBUNDLE);
								 Object[] args = {
								 e.getMessage() }
								;
								 return addElement( makeError( MessageFormat.format( rbPlugin.getString( ""plugin.error.insertionfailed"" ), args ) ) );
							 }
						 }
						 return m_currentElement;
					 }
					 try {
						 LinkParser.Link link = m_linkParser.parse(linktext);
						 linktext = link.getText();
						 String linkref = link.getReference();
						 if( VariableManager.isVariableLink( linktext ) ) {
							 Content el = new VariableContent(linktext);
							 addElement( el );
						 }
						 else if( isExternalLink( linkref ) ) {
							 callMutatorChain( m_externalLinkMutatorChain, linkref );
							 if( isImageLink( linkref ) ) {
								 handleImageLink( linkref, linktext, link.hasReference() );
							 }
							 else {
								 makeLink( EXTERNAL, linkref, linktext, null, link.getAttributes() );
								 addElement( outlinkImage() );
							 }
						 }
						 else if( link.isInterwikiLink() ) {
							 String extWiki = link.getExternalWiki();
							 String wikiPage = link.getExternalWikiPage();
							 if( m_wysiwygEditorMode ) {
								 makeLink( INTERWIKI, extWiki + "":"" + wikiPage, linktext, null, link.getAttributes() );
							 }
							 else {
								 String urlReference = m_engine.getInterWikiURL( extWiki );
								 if( urlReference != null ) {
									 urlReference = TextUtil.replaceString( urlReference, ""%s"", wikiPage );
									 urlReference = callMutatorChain( m_externalLinkMutatorChain, urlReference );
									 if( isImageLink(urlReference) ) {
										 handleImageLink( urlReference, linktext, link.hasReference() );
									 }
									 else {
										 makeLink( INTERWIKI, urlReference, linktext, null, link.getAttributes() );
									 }
									 if( isExternalLink(urlReference) ) {
										 addElement( outlinkImage() );
									 }
								 }
								 else {
									 Object[] args = {
									 extWiki }
									;
									 addElement( makeError( MessageFormat.format( rb.getString( ""markupparser.error.nointerwikiref"" ), args ) ) );
								 }
							 }
						 }
						 else if( linkref.startsWith(""#"") ) {
							 makeLink( LOCAL, linkref, linktext, null, link.getAttributes() );
						 }
						 else if( TextUtil.isNumber( linkref ) ) {
							 makeLink( LOCALREF, linkref, linktext, null, link.getAttributes() );
						 }
						 else {
							 int hashMark = -1;
							 String attachment = findAttachment( linkref );
							 if( attachment != null ) {
								 callMutatorChain( m_attachmentLinkMutatorChain, attachment );
								 if( isImageLink( linkref ) ) {
									 attachment = m_context.getURL( WikiContext.ATTACH, attachment );
									 sb.append( handleImageLink( attachment, linktext, link.hasReference() ) );
								 }
								 else {
									 makeLink( ATTACHMENT, attachment, linktext, null, link.getAttributes() );
								 }
							 }
							 else if( (hashMark = linkref.indexOf('#')) != -1 ) {
								 String namedSection = linkref.substring( hashMark+1 );
								 linkref = linkref.substring( 0, hashMark );
								 linkref = MarkupParser.cleanLink( linkref );
								 callMutatorChain( m_localLinkMutatorChain, linkref );
								 String matchedLink;
								 if( (matchedLink = linkExists( linkref )) != null ) {
									 String sectref = ""section-""+m_engine.encodeName(matchedLink)+""-""+wikifyLink(namedSection);
									 sectref = sectref.replace('%', '_');
									 makeLink( READ, matchedLink, linktext, sectref, link.getAttributes() );
								 }
								 else {
									 makeLink( EDIT, linkref, linktext, null, link.getAttributes() );
								 }
							 }
							 else {
								 linkref = MarkupParser.cleanLink( linkref );
								 callMutatorChain( m_localLinkMutatorChain, linkref );
								 String matchedLink = linkExists( linkref );
								 if( matchedLink != null ) {
									 makeLink( READ, matchedLink, linktext, null, link.getAttributes() );
								 }
								 else {
									 makeLink( EDIT, linkref, linktext, null, link.getAttributes() );
								 }
							 }
						 }
					 }
					 catch( ParseException e ) {
						 log.info(""Parser failure: "",e);
						 Object[] args = {
						 e.getMessage() }
						;
						 addElement( makeError( MessageFormat.format( rb.getString( ""markupparser.error.parserfailure"" ), args ) ) );
					 }
					 return m_currentElement;
				 }
				 private String findAttachment( String linktext ) {
					 AttachmentManager mgr = m_engine.getAttachmentManager();
					 Attachment att = null;
					 try {
						 att = mgr.getAttachmentInfo( m_context, linktext );
					 }
					 catch( ProviderException e ) {
						 log.warn(""Finding attachments failed: "",e);
						 return null;
					 }
					 if( att != null ) {
						 return att.getName();
					 }
					 else if( linktext.indexOf('/') != -1 ) {
						 return linktext;
					 }
					 return null;
				 }
				 private void pushBack( String s ) throws IOException {
					 for( int i = s.length()-1;
					 i >= 0;
					 i-- ) {
						 pushBack( s.charAt(i) );
					 }
				 }
				 private Element handleBackslash() throws IOException {
					 int ch = nextToken();
					 if( ch == '\\' ) {
						 int ch2 = nextToken();
						 if( ch2 == '\\' ) {
							 pushElement( new Element(""br"").setAttribute(""clear"",""all""));
							 return popElement(""br"");
						 }
						 pushBack( ch2 );
						 pushElement( new Element(""br"") );
						 return popElement(""br"");
					 }
					 pushBack( ch );
					 return null;
				 }
				 private Element handleUnderscore() throws IOException {
					 int ch = nextToken();
					 Element el = null;
					 if( ch == '_' ) {
						 if( m_isbold ) {
							 el = popElement(""b"");
						 }
						 else {
							 el = pushElement( new Element(""b"") );
						 }
						 m_isbold = !m_isbold;
					 }
					 else {
						 pushBack( ch );
					 }
					 return el;
				 }
				 private Element handleApostrophe() throws IOException {
					 int ch = nextToken();
					 Element el = null;
					 if( ch == '\'' ) {
						 if( m_isitalic ) {
							 el = popElement(""i"");
						 }
						 else {
							 el = pushElement( new Element(""i"") );
						 }
						 m_isitalic = !m_isitalic;
					 }
					 else {
						 pushBack( ch );
					 }
					 return el;
				 }
				 private Element handleOpenbrace( boolean isBlock ) throws IOException {
					 int ch = nextToken();
					 if( ch == '{
						' ) {
							 int ch2 = nextToken();
							 if( ch2 == '{
								' ) {
									 m_isPre = true;
									 m_isEscaping = true;
									 m_isPreBlock = isBlock;
									 if( isBlock ) {
										 startBlockLevel();
										 return pushElement( new Element(""pre"") );
									 }
									 return pushElement( new Element(""span"").setAttribute(""style"",""font-family:monospace;
									 white-space:pre;
									"") );
								 }
								 pushBack( ch2 );
								 return pushElement( new Element(""tt"") );
							 }
							 pushBack( ch );
							 return null;
						 }
						 private Element handleClosebrace() throws IOException {
							 int ch2 = nextToken();
						 if( ch2 == '}
						' ) {
							 int ch3 = nextToken();
						 if( ch3 == '}
						' ) {
							 if( m_isPre ) {
								 if( m_isPreBlock ) {
									 popElement( ""pre"" );
								 }
								 else {
									 popElement( ""span"" );
								 }
								 m_isPre = false;
								 m_isEscaping = false;
								 return m_currentElement;
							 }
						 m_plainTextBuf.append(""}
					}
				}
				"");
				 return m_currentElement;
			 }
			 pushBack( ch3 );
			 if( !m_isEscaping ) {
				 return popElement(""tt"");
			 }
		 }
		 pushBack( ch2 );
		 return null;
	 }
	 private Element handleDash() throws IOException {
		 int ch = nextToken();
		 if( ch == '-' ) {
			 int ch2 = nextToken();
			 if( ch2 == '-' ) {
				 int ch3 = nextToken();
				 if( ch3 == '-' ) {
					 while( (ch = nextToken()) == '-' );
					 pushBack(ch);
					 startBlockLevel();
					 pushElement( new Element(""hr"") );
					 return popElement( ""hr"" );
				 }
				 pushBack( ch3 );
			 }
			 pushBack( ch2 );
		 }
		 pushBack( ch );
		 return null;
	 }
	 private Element handleHeading() throws IOException {
		 Element el = null;
		 int ch = nextToken();
		 Heading hd = new Heading();
		 if( ch == '!' ) {
			 int ch2 = nextToken();
			 if( ch2 == '!' ) {
				 String title = peekAheadLine();
				 el = makeHeading( Heading.HEADING_LARGE, title, hd);
			 }
			 else {
				 pushBack( ch2 );
				 String title = peekAheadLine();
				 el = makeHeading( Heading.HEADING_MEDIUM, title, hd );
			 }
		 }
		 else {
			 pushBack( ch );
			 String title = peekAheadLine();
			 el = makeHeading( Heading.HEADING_SMALL, title, hd );
		 }
		 callHeadingListenerChain( hd );
		 m_lastHeading = hd;
		 if( el != null ) pushElement(el);
		 return el;
	 }
	 private StringBuilder readUntilEOL() throws IOException {
		 int ch;
		 StringBuilder buf = new StringBuilder( 256 );
		 while( true ) {
			 ch = nextToken();
			 if( ch == -1 ) break;
			 buf.append( (char) ch );
			 if( ch == '\n' ) break;
		 }
		 return buf;
	 }
	 private boolean m_restartitalic = false;
	 private boolean m_restartbold = false;
	 private boolean m_newLine;
	 private void startBlockLevel() {
		 popElement(""i"");
		 popElement(""b"");
		 popElement(""tt"");
		 if( m_isOpenParagraph ) {
			 m_isOpenParagraph = false;
			 popElement(""p"");
			 m_plainTextBuf.append(""\n"");
		 }
		 m_restartitalic = m_isitalic;
		 m_restartbold = m_isbold;
		 m_isitalic = false;
		 m_isbold = false;
	 }
	 private static String getListType( char c ) {
		 if( c == '*' ) {
			 return ""ul"";
		 }
		 else if( c == '#' ) {
			 return ""ol"";
		 }
		 throw new InternalWikiException(""Parser got faulty list type: ""+c);
	 }
	 private Element handleGeneralList() throws IOException {
		 startBlockLevel();
		 String strBullets = readWhile( ""*#"" );
		 int numBullets = strBullets.length();
		 if(m_allowPHPWikiStyleLists) {
			 if(!( strBullets.substring(0,Math.min(numBullets,m_genlistlevel)).equals (m_genlistBulletBuffer.substring(0,Math.min(numBullets,m_genlistlevel)) ) ) ) {
				 if(numBullets <= m_genlistlevel) {
					 strBullets = (numBullets > 1 ? m_genlistBulletBuffer.substring(0, numBullets-1) : """") + strBullets.substring(numBullets-1, numBullets);
				 }
				 else {
					 strBullets = m_genlistBulletBuffer + strBullets.substring(m_genlistlevel, numBullets);
				 }
			 }
		 }
		 if( strBullets.substring(0,Math.min(numBullets,m_genlistlevel)).equals (m_genlistBulletBuffer.substring(0,Math.min(numBullets,m_genlistlevel)) ) ) {
			 if( numBullets > m_genlistlevel ) {
				 pushElement( new Element( getListType(strBullets.charAt(m_genlistlevel++) ) ) );
				 for( ;
				 m_genlistlevel < numBullets;
				 m_genlistlevel++ ) {
					 pushElement( new Element(""li"") );
					 pushElement( new Element( getListType(strBullets.charAt(m_genlistlevel)) ));
				 }
			 }
			 else if( numBullets < m_genlistlevel ) {
				 popElement( ""li"" );
				 for( ;
				 m_genlistlevel > numBullets;
				 m_genlistlevel-- ) {
					 popElement( getListType(m_genlistBulletBuffer.charAt(m_genlistlevel-1)) );
					 if( m_genlistlevel > 0 ) {
						 popElement( ""li"" );
					 }
				 }
			 }
			 else {
				 if( m_genlistlevel > 0 ) {
					 popElement( ""li"" );
				 }
			 }
		 }
		 else {
			 int numEqualBullets;
			 int numCheckBullets;
			 numEqualBullets = 0;
			 numCheckBullets = Math.min(numBullets,m_genlistlevel);
			 while( numEqualBullets < numCheckBullets ) {
				 if( strBullets.charAt(numEqualBullets) == m_genlistBulletBuffer.charAt(numEqualBullets)) numEqualBullets++;
				 else break;
			 }
			 for( ;
			 m_genlistlevel > numEqualBullets;
			 m_genlistlevel-- ) {
				 popElement( getListType( m_genlistBulletBuffer.charAt(m_genlistlevel-1) ) );
				 if( m_genlistlevel > numBullets ) {
					 popElement(""li"");
				 }
			 }
			 pushElement( new Element(getListType( strBullets.charAt(numEqualBullets++) ) ) );
			 for(int i = numEqualBullets;
			 i < numBullets;
			 i++) {
				 pushElement( new Element(""li"") );
				 pushElement( new Element( getListType( strBullets.charAt(i) ) ) );
			 }
			 m_genlistlevel = numBullets;
		 }
		 pushElement( new Element(""li"") );
		 readWhile("" "");
		 m_genlistBulletBuffer.setLength(0);
		 m_genlistBulletBuffer.append(strBullets);
		 return m_currentElement;
	 }
	 private Element unwindGeneralList() {
		 for( ;
		 m_genlistlevel > 0;
		 m_genlistlevel-- ) {
			 popElement( ""li"" );
			 popElement( getListType(m_genlistBulletBuffer.charAt(m_genlistlevel-1)) );
		 }
		 m_genlistBulletBuffer.setLength(0);
		 return null;
	 }
	 private Element handleDefinitionList() throws IOException {
		 if( !m_isdefinition ) {
			 m_isdefinition = true;
			 startBlockLevel();
			 pushElement( new Element(""dl"") );
			 return pushElement( new Element(""dt"") );
		 }
		 return null;
	 }
	 private Element handleOpenbracket() throws IOException {
		 StringBuilder sb = new StringBuilder(40);
		 int pos = getPosition();
		 int ch = nextToken();
		 boolean isPlugin = false;
		 if( ch == '[' ) {
			 if( m_wysiwygEditorMode ) {
				 sb.append( '[' );
			 }
			 sb.append( (char)ch );
			 while( (ch = nextToken()) == '[' ) {
				 sb.append( (char)ch );
			 }
		 }
		 if( ch == '{
			' ) {
				 isPlugin = true;
			 }
			 pushBack( ch );
			 if( sb.length() > 0 ) {
				 m_plainTextBuf.append( sb );
				 return m_currentElement;
			 }
			 ch = nextToken();
			 int nesting = 1;
			 while( ch != -1 ) {
				 int ch2 = nextToken();
				 pushBack(ch2);
				 if( isPlugin ) {
					 if( ch == '[' && ch2 == '{
						' ) {
							 nesting++;
						 }
					 else if( nesting == 0 && ch == ']' && sb.charAt(sb.length()-1) == '}
					' ) {
						 break;
					 }
				 else if( ch == '}
				' && ch2 == ']' ) {
					 nesting--;
				 }
			 }
			 else {
				 if( ch == ']' ) {
					 break;
				 }
			 }
			 sb.append( (char) ch );
			 ch = nextToken();
		 }
		 if( ch == -1 ) {
			 log.debug(""Warning: unterminated link detected!"");
			 m_isEscaping = true;
			 m_plainTextBuf.append( sb );
			 flushPlainText();
			 m_isEscaping = false;
			 return m_currentElement;
		 }
		 return handleHyperlinks( sb.toString(), pos );
	 }
	 private String readBraceContent( char opening, char closing ) throws IOException {
		 StringBuilder sb = new StringBuilder(40);
		 int braceLevel = 1;
		 int ch;
		 while(( ch = nextToken() ) != -1 ) {
			 if( ch == '\\' ) {
				 continue;
			 }
			 else if ( ch == opening ) {
				 braceLevel++;
			 }
			 else if ( ch == closing ) {
				 braceLevel--;
				 if (braceLevel==0) {
					 break;
				 }
			 }
			 sb.append( (char)ch );
		 }
		 return sb.toString();
	 }
	 private Element handleDiv( boolean newLine ) throws IOException {
		 int ch = nextToken();
		 Element el = null;
		 if( ch == '%' ) {
			 String style = null;
			 String clazz = null;
			 ch = nextToken();
			 if( ch == '(' ) {
				 style = readBraceContent('(',')');
			 }
			 else if( Character.isLetter( (char) ch ) ) {
				 pushBack( ch );
				 clazz = readUntil( "" \t\n\r"" );
				 ch = nextToken();
				 if( ch == '\n' || ch == '\r' ) {
					 pushBack(ch);
				 }
			 }
			 else {
				 pushBack(ch);
				 try {
					 Boolean isSpan = m_styleStack.pop();
					 if( isSpan == null ) {
					 }
					 else if( isSpan.booleanValue() ) {
						 el = popElement( ""span"" );
					 }
					 else {
						 el = popElement( ""div"" );
					 }
				 }
				 catch( EmptyStackException e ) {
					 log.debug(""Page '""+m_context.getName()+""' closes a %%-block that has not been opened."");
					 return m_currentElement;
				 }
				 return el;
			 }
			 try {
				 style = StringEscapeUtils.unescapeHtml(style);
				 if( style != null && style.indexOf(""javascript:"") != -1 ) {
					 log.debug(""Attempt to output javascript within CSS:""+style);
					 ResourceBundle rb = m_context.getBundle(InternationalizationManager.CORE_BUNDLE);
					 return addElement( makeError( rb.getString( ""markupparser.error.javascriptattempt"" ) ) );
				 }
			 }
			 catch( NumberFormatException e ) {
				 ResourceBundle rb = m_context.getBundle(InternationalizationManager.CORE_BUNDLE);
				 Object[] args = {
				 e.getMessage() }
				;
				 String msg = MessageFormat.format( rb.getString( ""markupparser.error.parserfailure""), args );
				 return addElement( makeError( msg ) );
			 }
			 String eol = peekAheadLine();
			 if( eol.trim().length() > 0 ) {
				 el = new Element(""span"");
				 m_styleStack.push( Boolean.TRUE );
			 }
			 else {
				 startBlockLevel();
				 el = new Element(""div"");
				 m_styleStack.push( Boolean.FALSE );
			 }
			 if( style != null ) el.setAttribute(""style"", style);
			 if( clazz != null ) el.setAttribute(""class"", clazz );
			 el = pushElement( el );
			 return el;
		 }
		 pushBack(ch);
		 return el;
	 }
	 private Element handleSlash( boolean newLine ) throws IOException {
		 int ch = nextToken();
		 pushBack(ch);
		 if( ch == '%' && !m_styleStack.isEmpty() ) {
			 return handleDiv( newLine );
		 }
		 return null;
	 }
	 private Element handleBar( boolean newLine ) throws IOException {
		 Element el = null;
		 if( !m_istable && !newLine ) {
			 return null;
		 }
		 if( newLine ) {
			 if( !m_istable ) {
				 startBlockLevel();
				 el = pushElement( new Element(""table"").setAttribute(""class"",""wikitable"").setAttribute(""border"",""1"") );
				 m_istable = true;
				 m_rowNum = 0;
			 }
			 m_rowNum++;
			 Element tr = ( m_rowNum % 2 != 0 ) ? new Element(""tr"").setAttribute(""class"", ""odd"") : new Element(""tr"");
			 el = pushElement( tr );
		 }
		 int ch = nextToken();
		 if( ch == '|' ) {
			 if( !newLine ) {
				 el = popElement(""th"");
				 if( el == null ) popElement(""td"");
			 }
			 el = pushElement( new Element(""th"") );
		 }
		 else {
			 if( !newLine ) {
				 el = popElement(""td"");
				 if( el == null ) popElement(""th"");
			 }
			 el = pushElement( new Element(""td"") );
			 pushBack( ch );
		 }
		 return el;
	 }
	 private Element handleTilde() throws IOException {
		 int ch = nextToken();
		 if( ch == ' ' ) {
			 if( m_wysiwygEditorMode ) {
				 m_plainTextBuf.append( ""~ "" );
			 }
			 return m_currentElement;
		 }
		 if( ch == '|' || ch == '~' || ch == '\\' || ch == '*' || ch == '#' || ch == '-' || ch == '!' || ch == '\'' || ch == '_' || ch == '[' || ch == '{
		' || ch == ']' || ch == '}
		' || ch == '%' ) {
			 if( m_wysiwygEditorMode ) {
				 m_plainTextBuf.append( '~' );
			 }
			 m_plainTextBuf.append( (char)ch );
			 m_plainTextBuf.append(readWhile( """"+(char)ch ));
			 return m_currentElement;
		 }
		 pushBack( ch );
		 return null;
	 }
	 private void fillBuffer( Element startElement ) throws IOException {
		 m_currentElement = startElement;
		 boolean quitReading = false;
		 m_newLine = true;
		 disableOutputEscaping();
		 while(!quitReading) {
			 int ch = nextToken();
			 if( ch == -1 ) break;
			 if( m_isEscaping ) {
			 if( ch == '}
			' ) {
				 if( handleClosebrace() == null ) m_plainTextBuf.append( (char) ch );
			 }
			 else if( ch == -1 ) {
				 quitReading = true;
			 }
			 else if( ch == '\r' ) {
			 }
			 else if( ch == '<' ) {
				 m_plainTextBuf.append( ""&lt;
				"" );
			 }
			 else if( ch == '>' ) {
				 m_plainTextBuf.append( ""&gt;
				"" );
			 }
			 else if( ch == '&' ) {
				 m_plainTextBuf.append( ""&amp;
				"" );
			 }
			 else if( ch == '~' ) {
			 String braces = readWhile(""}
			"");
			 if( braces.length() >= 3 ) {
			 m_plainTextBuf.append(""}
		}
	}
	"");
	 braces = braces.substring(3);
 }
 else {
	 m_plainTextBuf.append( (char) ch );
 }
 for( int i = braces.length()-1;
 i >= 0;
 i-- ) {
	 pushBack(braces.charAt(i));
 }
 }
 else {
 m_plainTextBuf.append( (char) ch );
 }
 continue;
 }
 if( m_newLine && ch != '*' && ch != '#' && ch != ' ' && m_genlistlevel > 0 ) {
 m_plainTextBuf.append(unwindGeneralList());
 }
 if( m_newLine && ch != '|' && m_istable ) {
 popElement(""table"");
 m_istable = false;
 }
 int skip = IGNORE;
 try {
 skip = parseToken( ch );
 }
 catch( IllegalDataException e ) {
 log.info(""Page ""+m_context.getPage().getName()+"" contains data which cannot be added to DOM tree: ""+e.getMessage());
 makeError(""Error: ""+cleanupSuspectData(e.getMessage()) );
 }
 switch( skip ) {
 case ELEMENT: m_newLine = false;
 break;
 case CHARACTER: m_plainTextBuf.append( (char) ch );
 m_newLine = false;
 break;
 case IGNORE: default: break;
 }
 }
 closeHeadings();
 popElement(""domroot"");
 }
 private String cleanupSuspectData( String s ) {
 StringBuilder sb = new StringBuilder( s.length() );
 for( int i = 0;
 i < s.length();
 i++ ) {
 char c = s.charAt(i);
 if( Verifier.isXMLCharacter( c ) ) sb.append( c );
 else sb.append( ""0x""+Integer.toString(c,16).toUpperCase() );
 }
 return sb.toString();
 }
 protected static final int CHARACTER = 0;
 protected static final int ELEMENT = 1;
 protected static final int IGNORE = 2;
 protected int parseToken( int ch ) throws IOException {
 Element el = null;
 switch( ch ) {
 case '\r': return IGNORE;
 case '\n': closeHeadings();
 popElement(""dl"");
 if( m_istable ) {
 popElement(""tr"");
 }
 m_isdefinition = false;
 if( m_newLine ) {
 startBlockLevel();
 String nextLine = peekAheadLine();
 if( nextLine.length() == 0 || (nextLine.length() > 0 && !nextLine.startsWith(""{
{
	{
		"") && !nextLine.startsWith(""----"") && !nextLine.startsWith(""%%"") && ""*#!;
		"".indexOf( nextLine.charAt(0) ) == -1) ) {
			 pushElement( new Element(""p"") );
			 m_isOpenParagraph = true;
			 if( m_restartitalic ) {
				 pushElement( new Element(""i"") );
				 m_isitalic = true;
				 m_restartitalic = false;
			 }
			 if( m_restartbold ) {
				 pushElement( new Element(""b"") );
				 m_isbold = true;
				 m_restartbold = false;
			 }
		 }
	 }
	 else {
		 m_plainTextBuf.append(""\n"");
		 m_newLine = true;
	 }
	 return IGNORE;
	 case '\\': el = handleBackslash();
	 break;
	 case '_': el = handleUnderscore();
	 break;
	 case '\'': el = handleApostrophe();
	 break;
	 case '{
		': el = handleOpenbrace( m_newLine );
		 break;
	 case '}
	': el = handleClosebrace();
	 break;
	 case '-': if( m_newLine ) el = handleDash();
	 break;
	 case '!': if( m_newLine ) {
		 el = handleHeading();
	 }
	 break;
	 case ';
	': if( m_newLine ) {
		 el = handleDefinitionList();
	 }
	 break;
	 case ':': if( m_isdefinition ) {
		 popElement(""dt"");
		 el = pushElement( new Element(""dd"") );
		 m_isdefinition = false;
	 }
	 break;
	 case '[': el = handleOpenbracket();
	 break;
	 case '*': if( m_newLine ) {
		 pushBack('*');
		 el = handleGeneralList();
	 }
	 break;
	 case '#': if( m_newLine ) {
		 pushBack('#');
		 el = handleGeneralList();
	 }
	 break;
	 case '|': el = handleBar( m_newLine );
	 break;
	 case '~': el = handleTilde();
	 break;
	 case '%': el = handleDiv( m_newLine );
	 break;
	 case '/': el = handleSlash( m_newLine );
	 break;
	 default: break;
 }
 return el != null ? ELEMENT : CHARACTER;
 }
 private void closeHeadings() {
 if( m_lastHeading != null && !m_wysiwygEditorMode ) {
	 addElement( new Element(""a"").setAttribute( ""class"",""hashlink"" ).setAttribute( ""href"",""#""+m_lastHeading.m_titleAnchor ).setText( ""#"" ) );
	 m_lastHeading = null;
 }
 popElement(""h2"");
 popElement(""h3"");
 popElement(""h4"");
 }
 public WikiDocument parse() throws IOException {
 WikiDocument d = new WikiDocument( m_context.getPage() );
 d.setContext( m_context );
 Element rootElement = new Element(""domroot"");
 d.setRootElement( rootElement );
 fillBuffer( rootElement );
 paragraphify(rootElement);
 return d;
 }
 private void paragraphify(Element rootElement) {
 List kids = rootElement.getContent();
 if( rootElement.getChild(""p"") != null ) {
	 ArrayList<Content> ls = new ArrayList<Content>();
	 int idxOfFirstContent = 0;
	 int count = 0;
	 for( Iterator i = kids.iterator();
	 i.hasNext();
	 count++ ) {
		 Content c = (Content) i.next();
		 if( c instanceof Element ) {
			 String name = ((Element)c).getName();
			 if( isBlockLevel(name) ) break;
		 }
		 if( !(c instanceof ProcessingInstruction) ) {
			 ls.add( c );
			 if( idxOfFirstContent == 0 ) idxOfFirstContent = count;
		 }
	 }
	 if( ls.size() > 0 ) {
		 Element newel = new Element(""p"");
		 for( Iterator i = ls.iterator();
		 i.hasNext();
		 ) {
			 Content c = (Content) i.next();
			 c.detach();
			 newel.addContent(c);
		 }
		 if( newel.getTextTrim().length() > 0 || !newel.getChildren().isEmpty() ) rootElement.addContent(idxOfFirstContent, newel);
	 }
 }
 }
 private static class StartingComparator implements Comparator<String> {
 public int compare( String s1, String s2 ) {
	 if( s1.length() > s2.length() ) {
		 if( s1.startsWith(s2) && s2.length() > 1 ) return 0;
	 }
	 else {
		 if( s2.startsWith(s1) && s1.length() > 1 ) return 0;
	 }
	 return s1.compareTo( s2 );
 }
 }
}",1,0,0,0
"protected String parseFullName(char c) throws XMLStreamException {
	 if (!isNameStartChar(c)) {
		 if (c == ':') {
			 if (mCfgNsEnabled) {
				 throwNsColonException(parseFNameForError());
			 }
		 }
		 else {
			 if (c <= CHAR_SPACE) {
				 throwUnexpectedChar(c, "" (missing name?)"");
			 }
			 throwUnexpectedChar(c, "" (expected a name start character)"");
		 }
	 }
	 int ptr = mInputPtr;
	 int hash = (int) c;
	 int inputLen = mInputEnd;
	 int startPtr = ptr-1;
	 while (true) {
		 if (ptr >= inputLen) {
			 mInputPtr = ptr;
			 return parseFullName2(startPtr, hash);
		 }
		 c = mInputBuffer[ptr];
		 if (c == ':') {
			 if (mCfgNsEnabled) {
				 mInputPtr = ptr;
				 throwNsColonException(new String(mInputBuffer, startPtr, ptr - startPtr) + parseFNameForError());
			 }
		 }
		 else {
			 if (c < CHAR_LOWEST_LEGAL_LOCALNAME_CHAR) {
				 break;
			 }
			 if (!isNameChar(c)) {
				 break;
			 }
		 }
		 hash = (hash * 31) + (int) c;
		 ++ptr;
	 }
	 mInputPtr = ptr;
	 return mSymbols.findSymbol(mInputBuffer, startPtr, ptr - startPtr, hash);
 }",0,0,1,0
"public static void main(String[] args) throws IOException, InterruptedException, ParseException {
	 CommandLineParser parser = new PosixParser();
	 CommandLine cmd = null;
	 try {
		 cmd = parser.parse(options, args);
	 }
	 catch (ParseException parseExcep) {
		 badUse(parseExcep.toString());
	 }
	 String host = cmd.getOptionValue(HOST_OPT_LONG);
	 int port = defaultPort;
	 String portNum = cmd.getOptionValue(PORT_OPT_LONG);
	 if (portNum != null) {
		 try {
			 port = Integer.parseInt(portNum);
		 }
		 catch (NumberFormatException e) {
			 throw new ParseException(""Port must be a number"");
		 }
	 }
	 String username = cmd.getOptionValue(USERNAME_OPT_LONG);
	 String password = cmd.getOptionValue(PASSWORD_OPT_LONG);
	 NodeProbe probe = null;
	 try {
		 probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);
	 }
	 catch (IOException ioe) {
		 err(ioe, ""Error connection to remote JMX agent!"");
	 }
	 if (cmd.getArgs().length < 1) badUse(""Missing argument for command."");
	 NodeCmd nodeCmd = new NodeCmd(probe);
	 String[] arguments = cmd.getArgs();
	 String cmdName = arguments[0];
	 boolean validCommand = false;
	 for (NodeCommand n : NodeCommand.values()) {
		 if (cmdName.toUpperCase().equals(n.name())) validCommand = true;
	 }
	 if (!validCommand) badUse(""Unrecognized command: "" + cmdName);
	 NodeCommand nc = NodeCommand.valueOf(cmdName.toUpperCase());
	 switch (nc) {
		 case RING : nodeCmd.printRing(System.out);
		 break;
		 case INFO : nodeCmd.printInfo(System.out);
		 break;
		 case CFSTATS : nodeCmd.printColumnFamilyStats(System.out);
		 break;
		 case DECOMMISSION : probe.decommission();
		 break;
		 case LOADBALANCE : probe.loadBalance();
		 break;
		 case CLEARSNAPSHOT : probe.clearSnapshot();
		 break;
		 case TPSTATS : nodeCmd.printThreadPoolStats(System.out);
		 break;
		 case VERSION : nodeCmd.printReleaseVersion(System.out);
		 break;
		 case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out);
		 break;
		 case DISABLEGOSSIP : probe.stopGossiping();
		 break;
		 case ENABLEGOSSIP : probe.startGossiping();
		 break;
		 case DISABLETHRIFT : probe.stopThriftServer();
		 break;
		 case ENABLETHRIFT : probe.startThriftServer();
		 break;
		 case DRAIN : try {
			 probe.drain();
		 }
		 catch (ExecutionException ee) {
			 err(ee, ""Error occured during flushing"");
		 }
		 break;
		 case NETSTATS : if (arguments.length > 1) {
			 nodeCmd.printNetworkStats(InetAddress.getByName(arguments[1]), System.out);
		 }
		 else {
			 nodeCmd.printNetworkStats(null, System.out);
		 }
		 break;
		 case SNAPSHOT : if (arguments.length > 1) {
			 probe.takeSnapshot(arguments[1]);
		 }
		 else {
			 probe.takeSnapshot("""");
		 }
		 break;
		 case MOVE : if (arguments.length != 2) {
			 badUse(""Missing token argument for move."");
		 }
		 probe.move(arguments[1]);
		 break;
		 case REMOVETOKEN : if (arguments.length != 2) {
			 badUse(""Missing an argument for removetoken (either status, force, or a token)"");
		 }
		 else if (arguments[1].equals(""status"")) {
			 nodeCmd.printRemovalStatus(System.out);
		 }
		 else if (arguments[1].equals(""force"")) {
			 nodeCmd.printRemovalStatus(System.out);
			 probe.forceRemoveCompletion();
		 }
		 else {
			 probe.removeToken(arguments[1]);
		 }
		 break;
		 case CLEANUP : case COMPACT : case REPAIR : case FLUSH : case SCRUB : case INVALIDATEKEYCACHE : case INVALIDATEROWCACHE : optionalKSandCFs(nc, arguments, probe);
		 break;
		 case GETCOMPACTIONTHRESHOLD : if (arguments.length != 3) {
			 badUse(""getcompactionthreshold requires ks and cf args."");
		 }
		 probe.getCompactionThreshold(System.out, arguments[1], arguments[2]);
		 break;
		 case CFHISTOGRAMS : if (arguments.length != 3) {
			 badUse(""cfhistograms requires ks and cf args"");
		 }
		 nodeCmd.printCfHistograms(arguments[1], arguments[2], System.out);
		 break;
		 case SETCACHECAPACITY : if (arguments.length != 5) {
			 badUse(""setcachecapacity requires ks, cf, keycachecap, and rowcachecap args."");
		 }
		 probe.setCacheCapacities(arguments[1], arguments[2], Integer.parseInt(arguments[3]), Integer.parseInt(arguments[4]));
		 break;
		 case SETCOMPACTIONTHRESHOLD : if (arguments.length != 5) {
			 badUse(""setcompactionthreshold requires ks, cf, min, and max threshold args."");
		 }
		 int minthreshold = Integer.parseInt(arguments[3]);
		 int maxthreshold = Integer.parseInt(arguments[4]);
		 if ((minthreshold < 0) || (maxthreshold < 0)) {
			 badUse(""Thresholds must be positive integers"");
		 }
		 if (minthreshold > maxthreshold) {
			 badUse(""Min threshold cannot be greater than max."");
		 }
		 if (minthreshold < 2 && maxthreshold != 0) {
			 badUse(""Min threshold must be at least 2"");
		 }
		 probe.setCompactionThreshold(arguments[1], arguments[2], minthreshold, maxthreshold);
		 break;
		 default : throw new RuntimeException(""Unreachable code."");
	 }
	 System.exit(0);
 }",0,0,1,0
"public class BagCount extends EvalFunc<Integer> {
	 public BagCount() {
	 }
	 public Integer exec(Tuple tuple) throws IOException {
		 DataBag databag = (DataBag)tuple.get(0);
		 if(databag == null) {
			 return new Integer(0);
		 }
		 int count = 0;
		 Iterator<Tuple> iterator = databag.iterator();
		 while(iterator.hasNext()) {
			 iterator.next();
			 count++;
		 }
		 return new Integer(count);
	 }
}",1,0,0,0
"public static void validateColumnName(ByteBuffer column) throws InvalidRequestException {
	 validateColumnNames(Collections.singletonList(column));
 }",0,0,0,0
"public void writeHyperlink( JRHyperlink hyperlink, String parentName, String hyperlinkSuffix);",0,0,0,0
"private void processArgs(String[] args) {
	 String searchForThis = null;
	 PrintStream logTo = null;
	 for (int i = 0;
	 i < args.length;
	 i++) {
		 String arg = args[i];
		 if (arg.equals(""-help"") || arg.equals(""-h"")) {
			 printUsage();
			 return;
		 }
		 else if (arg.equals(""-version"")) {
			 printVersion();
			 return;
		 }
		 else if (arg.equals(""-diagnostics"")) {
			 Diagnostics.doReport(System.out);
			 return;
		 }
		 else if (arg.equals(""-quiet"") || arg.equals(""-q"")) {
			 msgOutputLevel = Project.MSG_WARN;
		 }
		 else if (arg.equals(""-verbose"") || arg.equals(""-v"")) {
			 printVersion();
			 msgOutputLevel = Project.MSG_VERBOSE;
		 }
		 else if (arg.equals(""-debug"") || arg.equals(""-d"")) {
			 printVersion();
			 msgOutputLevel = Project.MSG_DEBUG;
		 }
		 else if (arg.equals(""-noinput"")) {
			 allowInput = false;
		 }
		 else if (arg.equals(""-logfile"") || arg.equals(""-l"")) {
			 try {
				 File logFile = new File(args[i + 1]);
				 i++;
				 logTo = new PrintStream(new FileOutputStream(logFile));
				 isLogFileUsed = true;
			 }
			 catch (IOException ioe) {
				 String msg = ""Cannot write on the specified log file. "" + ""Make sure the path exists and you have write "" + ""permissions."";
				 throw new BuildException(msg);
			 }
			 catch (ArrayIndexOutOfBoundsException aioobe) {
				 String msg = ""You must specify a log file when "" + ""using the -log argument"";
				 throw new BuildException(msg);
			 }
		 }
		 else if (arg.equals(""-buildfile"") || arg.equals(""-file"") || arg.equals(""-f"")) {
			 i = handleArgBuildFile(args, i);
		 }
		 else if (arg.equals(""-listener"")) {
			 i = handleArgListener(args, i);
		 }
		 else if (arg.startsWith(""-D"")) {
			 i = handleArgDefine(args, i);
		 }
		 else if (arg.equals(""-logger"")) {
			 i = handleArgLogger(args, i);
		 }
		 else if (arg.equals(""-inputhandler"")) {
			 i = handleArgInputHandler(args, i);
		 }
		 else if (arg.equals(""-emacs"") || arg.equals(""-e"")) {
			 emacsMode = true;
		 }
		 else if (arg.equals(""-projecthelp"") || arg.equals(""-p"")) {
			 projectHelp = true;
		 }
		 else if (arg.equals(""-find"") || arg.equals(""-s"")) {
			 if (i < args.length - 1) {
				 searchForThis = args[++i];
			 }
			 else {
				 searchForThis = DEFAULT_BUILD_FILENAME;
			 }
		 }
		 else if (arg.startsWith(""-propertyfile"")) {
			 i = handleArgPropertyFile(args, i);
		 }
		 else if (arg.equals(""-k"") || arg.equals(""-keep-going"")) {
			 keepGoingMode = true;
		 }
		 else if (arg.equals(""-nice"")) {
			 i = handleArgNice(args, i);
		 }
		 else if (LAUNCH_COMMANDS.contains(arg)) {
			 String msg = ""Ant's Main method is being handed "" + ""an option "" + arg + "" that is only for the launcher class."" + ""\nThis can be caused by a version mismatch between "" + ""the ant script/.bat file and Ant itself."";
			 throw new BuildException(msg);
		 }
		 else if (arg.equals(""-autoproxy"")) {
			 proxy = true;
		 }
		 else if (arg.startsWith(""-"")) {
			 String msg = ""Unknown argument: "" + arg;
			 System.err.println(msg);
			 printUsage();
			 throw new BuildException("""");
		 }
		 else {
			 targets.addElement(arg);
		 }
	 }
	 if (buildFile == null) {
		 if (searchForThis != null) {
			 buildFile = findBuildFile(System.getProperty(""user.dir""), searchForThis);
		 }
		 else {
			 buildFile = new File(DEFAULT_BUILD_FILENAME);
		 }
	 }
	 if (!buildFile.exists()) {
		 System.out.println(""Buildfile: "" + buildFile + "" does not exist!"");
		 throw new BuildException(""Build failed"");
	 }
	 if (buildFile.isDirectory()) {
		 System.out.println(""What? Buildfile: "" + buildFile + "" is a dir!"");
		 throw new BuildException(""Build failed"");
	 }
	 loadPropertyFiles();
	 if (msgOutputLevel >= Project.MSG_INFO) {
		 System.out.println(""Buildfile: "" + buildFile);
	 }
	 if (logTo != null) {
		 out = logTo;
		 err = logTo;
		 System.setOut(out);
		 System.setErr(err);
	 }
	 readyToRun = true;
 }",0,0,1,0
"public class PartitionCollapsingSchemas implements Serializable{
	 private static String DATED_INTERMEDIATE_VALUE_SCHEMA_NAME = ""DatedMapValue"";
	 private static String KEY_SCHEMA = ""key.schema"";
	 private static String INTERMEDIATE_VALUE_SCHEMA = ""intermediate.value.schema"";
	 private static String OUTPUT_VALUE_SCHEMA = ""output.value.schema"";
	 private final String _outputSchemaName;
	 private final String _outputSchemaNamespace;
	 private transient Schema _keySchema;
	 private transient Schema _intermediateValueSchema;
	 private transient Schema _outputValueSchema;
	 private transient Schema _mapOutputSchema;
	 private transient Schema _dateIntermediateValueSchema;
	 private transient Schema _mapOutputValueSchema;
	 private transient Schema _reduceOutputSchema;
	 private transient Map<String,Schema> _mapInputSchemas;
	 private Map<String,String> conf;
	 private Map<String,String> _inputSchemas;
	 public PartitionCollapsingSchemas(TaskSchemas schemas, Map<String,Schema> inputSchemas, String outputSchemaName, String outputSchemaNamespace) {
		 if (schemas == null) {
			 throw new NullArgumentException(""schemas"");
		 }
		 if (inputSchemas == null) {
			 throw new NullArgumentException(""inputSchema"");
		 }
		 if (outputSchemaName == null) {
			 throw new NullArgumentException(""outputSchemaName"");
		 }
		 if (outputSchemaName == outputSchemaNamespace) {
			 throw new NullArgumentException(""outputSchemaNamespace"");
		 }
		 _outputSchemaName = outputSchemaName;
		 _outputSchemaNamespace = outputSchemaNamespace;
		 conf = new HashMap<String,String>();
		 conf.put(KEY_SCHEMA, schemas.getKeySchema().toString());
		 conf.put(INTERMEDIATE_VALUE_SCHEMA, schemas.getIntermediateValueSchema().toString());
		 conf.put(OUTPUT_VALUE_SCHEMA, schemas.getOutputValueSchema().toString());
		 _inputSchemas = new HashMap<String,String>();
		 for (Entry<String,Schema> schema : inputSchemas.entrySet()) {
			 _inputSchemas.put(schema.getKey(), schema.getValue().toString());
		 }
	 }
	 public Map<String,Schema> getMapInputSchemas() {
		 if (_mapInputSchemas == null) {
			 _mapInputSchemas = new HashMap<String,Schema>();
			 for (Entry<String,String> schemaPair : _inputSchemas.entrySet()) {
				 Schema schema = new Schema.Parser().parse(schemaPair.getValue());
				 List<Schema> mapInputSchemas = new ArrayList<Schema>();
				 if (schema.getType() == Type.UNION) {
					 mapInputSchemas.addAll(schema.getTypes());
				 }
				 else {
					 mapInputSchemas.add(schema);
				 }
				 mapInputSchemas.add(getReduceOutputSchema());
				 _mapInputSchemas.put(schemaPair.getKey(), Schema.createUnion(mapInputSchemas));
			 }
		 }
		 return Collections.unmodifiableMap(_mapInputSchemas);
	 }
	 public Schema getMapOutputSchema() {
		 if (_mapOutputSchema == null) {
			 _mapOutputSchema = Pair.getPairSchema(getMapOutputKeySchema(), getMapOutputValueSchema());
		 }
		 return _mapOutputSchema;
	 }
	 public Schema getKeySchema() {
		 if (_keySchema == null) {
			 _keySchema = new Schema.Parser().parse(conf.get(KEY_SCHEMA));
		 }
		 return _keySchema;
	 }
	 public Schema getMapOutputKeySchema() {
		 return getKeySchema();
	 }
	 public Schema getReduceOutputSchema() {
		 if (_reduceOutputSchema == null) {
			 _reduceOutputSchema = Schema.createRecord(_outputSchemaName, null, _outputSchemaNamespace, false);
			 List<Field> fields = Arrays.asList(new Field(""key"",getKeySchema(), null, null), new Field(""value"", getOutputValueSchema(), null, null));
			 _reduceOutputSchema.setFields(fields);
		 }
		 return _reduceOutputSchema;
	 }
	 public Schema getDatedIntermediateValueSchema() {
		 if (_dateIntermediateValueSchema == null) {
			 _dateIntermediateValueSchema = Schema.createRecord(DATED_INTERMEDIATE_VALUE_SCHEMA_NAME, null, _outputSchemaNamespace, false);
			 List<Field> intermediateValueFields = Arrays.asList(new Field(""value"", getIntermediateValueSchema(), null, null), new Field(""time"", Schema.create(Type.LONG), null, null));
			 _dateIntermediateValueSchema.setFields(intermediateValueFields);
		 }
		 return _dateIntermediateValueSchema;
	 }
	 public Schema getOutputValueSchema() {
		 if (_outputValueSchema == null) {
			 _outputValueSchema = new Schema.Parser().parse(conf.get(OUTPUT_VALUE_SCHEMA));
		 }
		 return _outputValueSchema;
	 }
	 public Schema getIntermediateValueSchema() {
		 if (_intermediateValueSchema == null) {
			 _intermediateValueSchema = new Schema.Parser().parse(conf.get(INTERMEDIATE_VALUE_SCHEMA));
		 }
		 return _intermediateValueSchema;
	 }
	 public Schema getMapOutputValueSchema() {
		 if (_mapOutputValueSchema == null) {
			 List<Schema> unionSchemas = new ArrayList<Schema>();
			 unionSchemas.add(getIntermediateValueSchema());
			 unionSchemas.add(getDatedIntermediateValueSchema());
			 if (!unionSchemas.contains(getOutputValueSchema())) {
				 unionSchemas.add(getOutputValueSchema());
			 }
			 _mapOutputValueSchema = Schema.createUnion(unionSchemas);
		 }
		 return _mapOutputValueSchema;
	 }
}",1,1,0,0
"private void setTransformationParameters() {
	 for (final Enumeration enumeration = params.keys();
	 enumeration.hasMoreElements();
	) {
		 final String name = (String) enumeration.nextElement();
		 final String value = (String) params.get(name);
		 transformer.setParameter(name, value);
	 }
 }",0,0,0,0
"public class TokenMetadata{
	 private static Logger logger = LoggerFactory.getLogger(TokenMetadata.class);
	 private BiMap<Token, InetAddress> tokenToEndpointMap;
	 private BiMap<Token, InetAddress> bootstrapTokens = Maps.synchronizedBiMap(HashBiMap.<Token, InetAddress>create());
	 private Set<InetAddress> leavingEndpoints = new HashSet<InetAddress>();
	 private ConcurrentMap<String, Multimap<Range<Token>, InetAddress>> pendingRanges = new ConcurrentHashMap<String, Multimap<Range<Token>, InetAddress>>();
	 private Set<Pair<Token, InetAddress>> movingEndpoints = new HashSet<Pair<Token, InetAddress>>();
	 private final ReadWriteLock lock = new ReentrantReadWriteLock(true);
	 private ArrayList<Token> sortedTokens;
	 private final CopyOnWriteArrayList<AbstractReplicationStrategy> subscribers = new CopyOnWriteArrayList<AbstractReplicationStrategy>();
	 public TokenMetadata() {
		 this(null);
	 }
	 public TokenMetadata(BiMap<Token, InetAddress> tokenToEndpointMap) {
		 if (tokenToEndpointMap == null) tokenToEndpointMap = HashBiMap.create();
		 this.tokenToEndpointMap = tokenToEndpointMap;
		 sortedTokens = sortTokens();
	 }
	 private ArrayList<Token> sortTokens() {
		 ArrayList<Token> tokens = new ArrayList<Token>(tokenToEndpointMap.keySet());
		 Collections.sort(tokens);
		 return tokens;
	 }
	 public int pendingRangeChanges(InetAddress source) {
		 int n = 0;
		 Range<Token> sourceRange = getPrimaryRangeFor(getToken(source));
		 synchronized (bootstrapTokens) {
			 for (Token token : bootstrapTokens.keySet()) if (sourceRange.contains(token)) n++;
		 }
		 return n;
	 }
	 public void updateNormalToken(Token token, InetAddress endpoint) {
		 updateNormalTokens(Collections.singleton(Pair.create(token, endpoint)));
	 }
	 public void updateNormalTokens(Set<Pair<Token, InetAddress>> tokenPairs) {
		 if (tokenPairs.isEmpty()) return;
		 lock.writeLock().lock();
		 try {
			 boolean shouldSortTokens = false;
			 for (Pair<Token, InetAddress> tokenEndpointPair : tokenPairs) {
				 Token token = tokenEndpointPair.left;
				 InetAddress endpoint = tokenEndpointPair.right;
				 assert token != null;
				 assert endpoint != null;
				 bootstrapTokens.inverse().remove(endpoint);
				 tokenToEndpointMap.inverse().remove(endpoint);
				 InetAddress prev = tokenToEndpointMap.put(token, endpoint);
				 if (!endpoint.equals(prev)) {
					 if (prev != null) logger.warn(""Token "" + token + "" changing ownership from "" + prev + "" to "" + endpoint);
					 shouldSortTokens = true;
				 }
				 leavingEndpoints.remove(endpoint);
				 removeFromMoving(endpoint);
			 }
			 if (shouldSortTokens) sortedTokens = sortTokens();
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public void addBootstrapToken(Token token, InetAddress endpoint) {
		 assert token != null;
		 assert endpoint != null;
		 lock.writeLock().lock();
		 try {
			 InetAddress oldEndpoint;
			 oldEndpoint = bootstrapTokens.get(token);
			 if (oldEndpoint != null && !oldEndpoint.equals(endpoint)) throw new RuntimeException(""Bootstrap Token collision between "" + oldEndpoint + "" and "" + endpoint + "" (token "" + token);
			 oldEndpoint = tokenToEndpointMap.get(token);
			 if (oldEndpoint != null && !oldEndpoint.equals(endpoint)) throw new RuntimeException(""Bootstrap Token collision between "" + oldEndpoint + "" and "" + endpoint + "" (token "" + token);
			 bootstrapTokens.inverse().remove(endpoint);
			 bootstrapTokens.put(token, endpoint);
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public void removeBootstrapToken(Token token) {
		 assert token != null;
		 lock.writeLock().lock();
		 try {
			 bootstrapTokens.remove(token);
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public void addLeavingEndpoint(InetAddress endpoint) {
		 assert endpoint != null;
		 lock.writeLock().lock();
		 try {
			 leavingEndpoints.add(endpoint);
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public void addMovingEndpoint(Token token, InetAddress endpoint) {
		 assert endpoint != null;
		 lock.writeLock().lock();
		 try {
			 movingEndpoints.add(new Pair<Token, InetAddress>(token, endpoint));
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public void removeEndpoint(InetAddress endpoint) {
		 assert endpoint != null;
		 lock.writeLock().lock();
		 try {
			 bootstrapTokens.inverse().remove(endpoint);
			 tokenToEndpointMap.inverse().remove(endpoint);
			 leavingEndpoints.remove(endpoint);
			 sortedTokens = sortTokens();
			 invalidateCaches();
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public void removeFromMoving(InetAddress endpoint) {
		 assert endpoint != null;
		 lock.writeLock().lock();
		 try {
			 for (Pair<Token, InetAddress> pair : movingEndpoints) {
				 if (pair.right.equals(endpoint)) {
					 movingEndpoints.remove(pair);
					 break;
				 }
			 }
			 invalidateCaches();
		 }
		 finally {
			 lock.writeLock().unlock();
		 }
	 }
	 public Token getToken(InetAddress endpoint) {
		 assert endpoint != null;
		 assert isMember(endpoint);
		 lock.readLock().lock();
		 try {
			 return tokenToEndpointMap.inverse().get(endpoint);
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public boolean isMember(InetAddress endpoint) {
		 assert endpoint != null;
		 lock.readLock().lock();
		 try {
			 return tokenToEndpointMap.inverse().containsKey(endpoint);
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public boolean isLeaving(InetAddress endpoint) {
		 assert endpoint != null;
		 lock.readLock().lock();
		 try {
			 return leavingEndpoints.contains(endpoint);
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public boolean isMoving(InetAddress endpoint) {
		 assert endpoint != null;
		 lock.readLock().lock();
		 try {
			 for (Pair<Token, InetAddress> pair : movingEndpoints) {
				 if (pair.right.equals(endpoint)) return true;
			 }
			 return false;
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public TokenMetadata cloneOnlyTokenMap() {
		 lock.readLock().lock();
		 try {
			 return new TokenMetadata(HashBiMap.create(tokenToEndpointMap));
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public TokenMetadata cloneAfterAllLeft() {
		 lock.readLock().lock();
		 try {
			 TokenMetadata allLeftMetadata = cloneOnlyTokenMap();
			 for (InetAddress endpoint : leavingEndpoints) allLeftMetadata.removeEndpoint(endpoint);
			 return allLeftMetadata;
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public TokenMetadata cloneAfterAllSettled() {
		 lock.readLock().lock();
		 try {
			 TokenMetadata metadata = cloneOnlyTokenMap();
			 for (InetAddress endpoint : leavingEndpoints) metadata.removeEndpoint(endpoint);
			 for (Pair<Token, InetAddress> pair : movingEndpoints) metadata.updateNormalToken(pair.left, pair.right);
			 return metadata;
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public InetAddress getEndpoint(Token token) {
		 lock.readLock().lock();
		 try {
			 return tokenToEndpointMap.get(token);
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public Range<Token> getPrimaryRangeFor(Token right) {
		 return new Range<Token>(getPredecessor(right), right);
	 }
	 public ArrayList<Token> sortedTokens() {
		 lock.readLock().lock();
		 try {
			 return sortedTokens;
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 private Multimap<Range<Token>, InetAddress> getPendingRangesMM(String table) {
		 Multimap<Range<Token>, InetAddress> map = pendingRanges.get(table);
		 if (map == null) {
			 map = HashMultimap.create();
			 Multimap<Range<Token>, InetAddress> priorMap = pendingRanges.putIfAbsent(table, map);
			 if (priorMap != null) map = priorMap;
		 }
		 return map;
	 }
	 public Map<Range<Token>, Collection<InetAddress>> getPendingRanges(String table) {
		 return getPendingRangesMM(table).asMap();
	 }
	 public List<Range<Token>> getPendingRanges(String table, InetAddress endpoint) {
		 List<Range<Token>> ranges = new ArrayList<Range<Token>>();
		 for (Map.Entry<Range<Token>, InetAddress> entry : getPendingRangesMM(table).entries()) {
			 if (entry.getValue().equals(endpoint)) {
				 ranges.add(entry.getKey());
			 }
		 }
		 return ranges;
	 }
	 public void setPendingRanges(String table, Multimap<Range<Token>, InetAddress> rangeMap) {
		 pendingRanges.put(table, rangeMap);
	 }
	 public Token getPredecessor(Token token) {
		 List tokens = sortedTokens();
		 int index = Collections.binarySearch(tokens, token);
		 assert index >= 0 : token + "" not found in "" + StringUtils.join(tokenToEndpointMap.keySet(), "", "");
		 return (Token) (index == 0 ? tokens.get(tokens.size() - 1) : tokens.get(index - 1));
	 }
	 public Token getSuccessor(Token token) {
		 List tokens = sortedTokens();
		 int index = Collections.binarySearch(tokens, token);
		 assert index >= 0 : token + "" not found in "" + StringUtils.join(tokenToEndpointMap.keySet(), "", "");
		 return (Token) ((index == (tokens.size() - 1)) ? tokens.get(0) : tokens.get(index + 1));
	 }
	 public Map<Token, InetAddress> getBootstrapTokens() {
		 return bootstrapTokens;
	 }
	 public Set<InetAddress> getLeavingEndpoints() {
		 return leavingEndpoints;
	 }
	 public Set<Pair<Token, InetAddress>> getMovingEndpoints() {
		 return movingEndpoints;
	 }
	 public static int firstTokenIndex(final ArrayList ring, Token start, boolean insertMin) {
		 assert ring.size() > 0;
		 int i = Collections.binarySearch(ring, start);
		 if (i < 0) {
			 i = (i + 1) * (-1);
			 if (i >= ring.size()) i = insertMin ? -1 : 0;
		 }
		 return i;
	 }
	 public static Token firstToken(final ArrayList<Token> ring, Token start) {
		 return ring.get(firstTokenIndex(ring, start, false));
	 }
	 public static Iterator<Token> ringIterator(final ArrayList<Token> ring, Token start, boolean includeMin) {
		 if (ring.isEmpty()) return includeMin ? Iterators.singletonIterator(StorageService.getPartitioner().getMinimumToken()) : Iterators.<Token>emptyIterator();
		 final boolean insertMin = (includeMin && !ring.get(0).isMinimum()) ? true : false;
		 final int startIndex = firstTokenIndex(ring, start, insertMin);
		 return new AbstractIterator<Token>() {
			 int j = startIndex;
			 protected Token computeNext() {
				 if (j < -1) return endOfData();
				 try {
					 if (j == -1) return StorageService.getPartitioner().getMinimumToken();
					 return ring.get(j);
				 }
				 finally {
					 j++;
					 if (j == ring.size()) j = insertMin ? -1 : 0;
					 if (j == startIndex) j = -2;
				 }
			 }
		 }
		;
	 }
	 public void clearUnsafe() {
		 bootstrapTokens.clear();
		 tokenToEndpointMap.clear();
		 leavingEndpoints.clear();
		 pendingRanges.clear();
		 invalidateCaches();
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 lock.readLock().lock();
		 try {
			 Set<InetAddress> eps = tokenToEndpointMap.inverse().keySet();
			 if (!eps.isEmpty()) {
				 sb.append(""Normal Tokens:"");
				 sb.append(System.getProperty(""line.separator""));
				 for (InetAddress ep : eps) {
					 sb.append(ep);
					 sb.append("":"");
					 sb.append(tokenToEndpointMap.inverse().get(ep));
					 sb.append(System.getProperty(""line.separator""));
				 }
			 }
			 synchronized (bootstrapTokens) {
				 if (!bootstrapTokens.isEmpty()) {
					 sb.append(""Bootstrapping Tokens:"" );
					 sb.append(System.getProperty(""line.separator""));
					 for (Map.Entry<Token, InetAddress> entry : bootstrapTokens.entrySet()) {
						 sb.append(entry.getValue() + "":"" + entry.getKey());
						 sb.append(System.getProperty(""line.separator""));
					 }
				 }
			 }
			 if (!leavingEndpoints.isEmpty()) {
				 sb.append(""Leaving Endpoints:"");
				 sb.append(System.getProperty(""line.separator""));
				 for (InetAddress ep : leavingEndpoints) {
					 sb.append(ep);
					 sb.append(System.getProperty(""line.separator""));
				 }
			 }
			 if (!pendingRanges.isEmpty()) {
				 sb.append(""Pending Ranges:"");
				 sb.append(System.getProperty(""line.separator""));
				 sb.append(printPendingRanges());
			 }
		 }
		 finally {
			 lock.readLock().unlock();
		 }
		 return sb.toString();
	 }
	 public String printPendingRanges() {
		 StringBuilder sb = new StringBuilder();
		 for (Map.Entry<String, Multimap<Range<Token>, InetAddress>> entry : pendingRanges.entrySet()) {
			 for (Map.Entry<Range<Token>, InetAddress> rmap : entry.getValue().entries()) {
				 sb.append(rmap.getValue() + "":"" + rmap.getKey());
				 sb.append(System.getProperty(""line.separator""));
			 }
		 }
		 return sb.toString();
	 }
	 public void invalidateCaches() {
		 for (AbstractReplicationStrategy subscriber : subscribers) {
			 subscriber.invalidateCachedTokenEndpointValues();
		 }
	 }
	 public void register(AbstractReplicationStrategy subscriber) {
		 subscribers.add(subscriber);
	 }
	 public void unregister(AbstractReplicationStrategy subscriber) {
		 subscribers.remove(subscriber);
	 }
	 public Collection<InetAddress> getWriteEndpoints(Token token, String table, Collection<InetAddress> naturalEndpoints) {
		 Map<Range<Token>, Collection<InetAddress>> ranges = getPendingRanges(table);
		 if (ranges.isEmpty()) return naturalEndpoints;
		 Set<InetAddress> endpoints = new HashSet<InetAddress>(naturalEndpoints);
		 for (Map.Entry<Range<Token>, Collection<InetAddress>> entry : ranges.entrySet()) {
			 if (entry.getKey().contains(token)) {
				 endpoints.addAll(entry.getValue());
			 }
		 }
		 return endpoints;
	 }
	 public Map<Token, InetAddress> getTokenToEndpointMapForReading() {
		 lock.readLock().lock();
		 try {
			 Map<Token, InetAddress> map = new HashMap<Token, InetAddress>(tokenToEndpointMap.size());
			 map.putAll(tokenToEndpointMap);
			 return map;
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
	 public Map<Token, InetAddress> getNormalAndBootstrappingTokenToEndpointMap() {
		 lock.readLock().lock();
		 try {
			 Map<Token, InetAddress> map = new HashMap<Token, InetAddress>(tokenToEndpointMap.size() + bootstrapTokens.size());
			 map.putAll(tokenToEndpointMap);
			 synchronized (bootstrapTokens) {
				 map.putAll(bootstrapTokens);
			 }
			 return map;
		 }
		 finally {
			 lock.readLock().unlock();
		 }
	 }
}",0,0,0,0
"private abstract static class GridifyMethodMatcher implements MethodMatcher {
	 public abstract boolean matches(Method method, Class cls);
	 public boolean isRuntime() {
		 return false;
	 }
	 public boolean matches(Method method, Class aClass, Object[] objs) {
		 return false;
	 }
 }",0,0,0,0
"public final class DirContextType {
	 private String name;
	 private DirContextType(String name) {
		 this.name = name;
	 }
	 public String toString() {
		 return name;
	 }
	 public static final DirContextType READ_ONLY = new DirContextType(""READ_ONLY"");
	 public static final DirContextType READ_WRITE = new DirContextType(""READ_WRITE"");
}",0,1,0,0
"public class EscherBitmapBlip extends EscherBlipRecord {
	 public static final short RECORD_ID_JPEG = (short) 0xF018 + 5;
	 public static final short RECORD_ID_PNG = (short) 0xF018 + 6;
	 public static final short RECORD_ID_DIB = (short) 0xF018 + 7;
	 private static final int HEADER_SIZE = 8;
	 private final byte[] field_1_UID = new byte[16];
	 private byte field_2_marker = (byte) 0xFF;
	 public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
		 int bytesAfterHeader = readHeader( data, offset );
		 int pos = offset + HEADER_SIZE;
		 System.arraycopy( data, pos, field_1_UID, 0, 16 );
		 pos += 16;
		 field_2_marker = data[pos];
		 pos++;
		 setPictureData(data, pos, bytesAfterHeader - 17);
		 return bytesAfterHeader + HEADER_SIZE;
	 }
	 public int serialize( int offset, byte[] data, EscherSerializationListener listener ) {
		 listener.beforeRecordSerialize(offset, getRecordId(), this);
		 LittleEndian.putShort( data, offset, getOptions() );
		 LittleEndian.putShort( data, offset + 2, getRecordId() );
		 LittleEndian.putInt( data, offset + 4, getRecordSize() - HEADER_SIZE );
		 int pos = offset + HEADER_SIZE;
		 System.arraycopy( field_1_UID, 0, data, pos, 16 );
		 data[pos + 16] = field_2_marker;
		 byte[] pd = getPicturedata();
		 System.arraycopy( pd, 0, data, pos + 17, pd.length );
		 listener.afterRecordSerialize(offset + getRecordSize(), getRecordId(), getRecordSize(), this);
		 return HEADER_SIZE + 16 + 1 + pd.length;
	 }
	 public int getRecordSize() {
		 return 8 + 16 + 1 + getPicturedata().length;
	 }
	 public byte[] getUID() {
		 return field_1_UID;
	 }
	 public void setUID( byte[] field_1_UID ) {
		 if (field_1_UID == null || field_1_UID.length != 16) {
			 throw new IllegalArgumentException(""field_1_UID must be byte[16]"");
		 }
		 System.arraycopy(field_1_UID, 0, this.field_1_UID , 0, 16);
	 }
	 public byte getMarker() {
		 return field_2_marker;
	 }
	 public void setMarker( byte field_2_marker ) {
		 this.field_2_marker = field_2_marker;
	 }
	 protected Object[][] getAttributeMap() {
		 return new Object[][] {
			 {
			 ""Marker"", field_2_marker }
			, {
			 ""Extra Data"", getPicturedata() }
		 }
		;
	 }
}",0,0,0,0
"public class Rectangle extends BasicShape implements DrawOperation {
	 protected int width = 0;
	 protected int height = 0;
	 protected int arcwidth = 0;
	 protected int archeight = 0;
	 public void setWidth(int w) {
		 width = w;
	 }
	 public void setHeight(int h) {
		 height = h;
	 }
	 public void setArcwidth(int w) {
		 arcwidth = w;
	 }
	 public void setArcheight(int h) {
		 archeight = h;
	 }
	 public PlanarImage executeDrawOperation() {
		 log(""\tCreating Rectangle w="" + width + "" h="" + height + "" arcw="" + arcwidth + "" arch="" + archeight);
		 BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR_PRE);
		 Graphics2D graphics = (Graphics2D) bi.getGraphics();
		 if (!stroke.equals(""transparent"")) {
			 BasicStroke bStroke = new BasicStroke(stroke_width);
			 graphics.setColor(ColorMapper.getColorByName(stroke));
			 graphics.setStroke(bStroke);
			 if ((arcwidth != 0) || (archeight != 0)) {
				 graphics.drawRoundRect(0, 0, width, height, arcwidth, archeight);
			 }
			 else {
				 graphics.drawRect(0, 0, width, height);
			 }
		 }
		 if (!fill.equals(""transparent"")) {
			 graphics.setColor(ColorMapper.getColorByName(fill));
			 if ((arcwidth != 0) || (archeight != 0)) {
				 graphics.fillRoundRect(stroke_width, stroke_width, width - (stroke_width * 2), height - (stroke_width * 2), arcwidth, archeight);
			 }
			 else {
				 graphics.fillRect(stroke_width, stroke_width, width - (stroke_width * 2), height - (stroke_width * 2));
			 }
		 }
		 for (int i = 0;
		 i < instructions.size();
		 i++) {
			 ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
			 if (instr instanceof DrawOperation) {
				 PlanarImage img = ((DrawOperation) instr).executeDrawOperation();
				 graphics.drawImage(img.getAsBufferedImage(), null, 0, 0);
			 }
			 else if (instr instanceof TransformOperation) {
				 graphics = (Graphics2D) bi.getGraphics();
				 PlanarImage image = ((TransformOperation) instr) .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
				 bi = image.getAsBufferedImage();
			 }
		 }
		 return PlanarImage.wrapRenderedImage(bi);
	 }
}",0,0,0,0
"public class FieldSignatureVisitor extends BaseSignatureVisitor{
	 private Type fieldType;
	 public SignatureVisitor visitExceptionType() {
		 throw new UnsupportedOperationException();
	 }
	 public SignatureVisitor visitParameterType() {
		 throw new UnsupportedOperationException();
	 }
	 public SignatureVisitor visitReturnType() {
		 throw new UnsupportedOperationException();
	 }
	 public Type getFieldType() {
		 if (!visitingStack.isEmpty()) {
			 fieldType = visitingStack.pop();
			 visitingStack.push(fieldType);
			 return fieldType;
		 }
		 else {
			 return null;
		 }
	 }
}",0,0,0,0
"public class MimeMail extends EmailTask {
	 public void execute() throws BuildException {
		 log(""DEPRECATED - The "" + getTaskName() + "" task is deprecated. "" + ""Use the mail task instead."");
		 super.execute();
	 }
}",0,0,0,0
"final private boolean jj_3R_8() {
	 if (jj_3R_14()) return true;
	 return false;
 }",0,0,0,0
"public abstract class OperatorPlanLoader<E extends Operator, P extends OperatorPlan<E>> {
	 public P load(String dotContent, Class<P> clazz) {
		 DotGraphReader dotReader = new DotGraphReader() ;
		 DotGraph graph = dotReader.load(dotContent) ;
		 return constructPlan(graph, clazz) ;
	 }
	 public P loadFromFile(String file, Class<P> clazz) {
		 DotGraphReader dotReader = new DotGraphReader() ;
		 DotGraph graph = dotReader.loadFromFile(file) ;
		 return constructPlan(graph, clazz) ;
	 }
	 public PlanAndGraphEntry loadFromFileWithGraph(String file, Class<P> clazz) {
		 DotGraphReader dotReader = new DotGraphReader() ;
		 DotGraph graph = dotReader.loadFromFile(file) ;
		 P plan = constructPlan(graph, clazz) ;
		 return new PlanAndGraphEntry(plan, graph) ;
	 }
	 public class PlanAndGraphEntry {
		 public PlanAndGraphEntry(P plan, DotGraph dotGraph) {
			 this.plan = plan ;
			 this.dotGraph = dotGraph ;
		 }
		 public P plan ;
		 public DotGraph dotGraph ;
	 }
	 protected abstract E createOperator(DotNode node, P plan) ;
	 P constructPlan(DotGraph graph, Class<P> clazz) {
		 P plan ;
		 Map<String, E> nameMap = new HashMap<String, E>() ;
		 try {
			 plan = clazz.newInstance() ;
		 }
		 catch (IllegalAccessException iae) {
			 throw new AssertionError(""Cannot instantiate a plan"") ;
		 }
		 catch (InstantiationException ie) {
			 throw new AssertionError(""Cannot instantiate a plan"") ;
		 }
		 for(DotNode node: graph.nodes) {
			 E op = createOperator(node, plan) ;
			 nameMap.put(node.name, op) ;
			 plan.add(op);
		 }
		 for(DotEdge edge: graph.edges) {
			 E fromOp = nameMap.get(edge.fromNode) ;
			 E toOp = nameMap.get(edge.toNode) ;
			 try {
				 plan.connect(fromOp, toOp);
			 }
			 catch (PlanException pe) {
				 throw new RuntimeException(""Invalid Dot file"") ;
			 }
		 }
		 return plan ;
	 }
	 protected OperatorKey getKey(Map<String,String> attributes) {
		 String key = attributes.get(""key"") ;
		 if (key != null) {
			 return new OperatorKey(""scope"", Long.parseLong(key)) ;
		 }
		 else {
			 long newId = NodeIdGenerator.getGenerator().getNextNodeId(""scope"") ;
			 return new OperatorKey(""scope"", newId) ;
		 }
	 }
}",1,0,0,0
"public final class CompactCharArray implements Cloneable {
	 public static final int UNICODECOUNT = 65536;
	 public CompactCharArray() {
		 this((char)0);
	 }
	 public CompactCharArray(char defaultValue) {
		 int i;
		 values = new char[UNICODECOUNT];
		 indices = new char[INDEXCOUNT];
		 hashes = new int[INDEXCOUNT];
		 for (i = 0;
		 i < UNICODECOUNT;
		 ++i) {
			 values[i] = defaultValue;
		 }
		 for (i = 0;
		 i < INDEXCOUNT;
		 ++i) {
			 indices[i] = (char)(i<<BLOCKSHIFT);
			 hashes[i] = 0;
		 }
		 isCompact = false;
		 this.defaultValue = defaultValue;
	 }
	 public CompactCharArray(char indexArray[], char newValues[]) {
		 int i;
		 if (indexArray.length != INDEXCOUNT) throw new IllegalArgumentException(""Index out of bounds."");
		 for (i = 0;
		 i < INDEXCOUNT;
		 ++i) {
			 char index = indexArray[i];
			 if (index >= newValues.length+BLOCKCOUNT) throw new IllegalArgumentException(""Index out of bounds."");
		 }
		 indices = indexArray;
		 values = newValues;
		 isCompact = true;
	 }
	 public CompactCharArray(String indexArray, String valueArray) {
		 this( Utility.RLEStringToCharArray(indexArray), Utility.RLEStringToCharArray(valueArray));
	 }
	 public char elementAt(char index) {
		 int ix = (indices[index >> BLOCKSHIFT] & 0xFFFF) + (index & BLOCKMASK);
		 return ix >= values.length ? defaultValue : values[ix];
	 }
	 public void setElementAt(char index, char value) {
		 if (isCompact) expand();
		 values[index] = value;
		 touchBlock(index >> BLOCKSHIFT, value);
	 }
	 public void setElementAt(char start, char end, char value) {
		 int i;
		 if (isCompact) {
			 expand();
		 }
		 for (i = start;
		 i <= end;
		 ++i) {
			 values[i] = value;
			 touchBlock(i >> BLOCKSHIFT, value);
		 }
	 }
	 public void compact() {
		 compact(true);
	 }
	 public void compact(boolean exhaustive) {
		 if (!isCompact) {
			 int iBlockStart = 0;
			 char iUntouched = 0xFFFF;
			 int newSize = 0;
			 char[] target = exhaustive ? new char[UNICODECOUNT] : values;
			 for (int i = 0;
			 i < indices.length;
			 ++i, iBlockStart += BLOCKCOUNT) {
				 indices[i] = 0xFFFF;
				 boolean touched = blockTouched(i);
				 if (!touched && iUntouched != 0xFFFF) {
					 indices[i] = iUntouched;
				 }
				 else {
					 int jBlockStart = 0;
					 for (int j = 0;
					 j < i;
					 ++j, jBlockStart += BLOCKCOUNT) {
						 if (hashes[i] == hashes[j] && arrayRegionMatches(values, iBlockStart, values, jBlockStart, BLOCKCOUNT)) {
							 indices[i] = indices[j];
						 }
					 }
					 if (indices[i] == 0xFFFF) {
						 int dest;
						 if (exhaustive) {
							 dest = FindOverlappingPosition(iBlockStart, target, newSize);
						 }
						 else {
							 dest = newSize;
						 }
						 int limit = dest + BLOCKCOUNT;
						 if (limit > newSize) {
							 for (int j = newSize;
							 j < limit;
							 ++j) {
								 target[j] = values[iBlockStart + j - dest];
							 }
							 newSize = limit;
						 }
						 indices[i] = (char)dest;
						 if (!touched) {
							 iUntouched = (char)jBlockStart;
						 }
					 }
				 }
			 }
			 char[] result = new char[newSize];
			 System.arraycopy(target, 0, result, 0, newSize);
			 values = result;
			 isCompact = true;
			 hashes = null;
		 }
	 }
	 private int FindOverlappingPosition(int start, char[] tempValues, int tempCount) {
		 for (int i = 0;
		 i < tempCount;
		 i += 1) {
			 int currentCount = BLOCKCOUNT;
			 if (i + BLOCKCOUNT > tempCount) {
				 currentCount = tempCount - i;
			 }
			 if (arrayRegionMatches(values, start, tempValues, i, currentCount)) return i;
		 }
		 return tempCount;
	 }
	 final static boolean arrayRegionMatches(char[] source, int sourceStart, char[] target, int targetStart, int len) {
		 int sourceEnd = sourceStart + len;
		 int delta = targetStart - sourceStart;
		 for (int i = sourceStart;
		 i < sourceEnd;
		 i++) {
			 if (source[i] != target[i + delta]) return false;
		 }
		 return true;
	 }
	 private final void touchBlock(int i, int value) {
		 hashes[i] = (hashes[i] + (value<<1)) | 1;
	 }
	 private final boolean blockTouched(int i) {
		 return hashes[i] != 0;
	 }
	 public char[] getIndexArray() {
		 return indices;
	 }
	 public char[] getValueArray() {
		 return values;
	 }
	 public Object clone() {
		 try {
			 CompactCharArray other = (CompactCharArray) super.clone();
			 other.values = values.clone();
			 other.indices = indices.clone();
			 if (hashes != null) other.hashes = hashes.clone();
			 return other;
		 }
		 catch (CloneNotSupportedException e) {
			 throw new ICUCloneNotSupportedException(e);
		 }
	 }
	 public boolean equals(Object obj) {
		 if (obj == null) return false;
		 if (this == obj) return true;
		 if (getClass() != obj.getClass()) return false;
		 CompactCharArray other = (CompactCharArray) obj;
		 for (int i = 0;
		 i < UNICODECOUNT;
		 i++) {
			 if (elementAt((char)i) != other.elementAt((char)i)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 int result = 0;
		 int increment = Math.min(3, values.length/16);
		 for (int i = 0;
		 i < values.length;
		 i+= increment) {
			 result = result * 37 + values[i];
		 }
		 return result;
	 }
	 private void expand() {
		 int i;
		 if (isCompact) {
			 char[] tempArray;
			 hashes = new int[INDEXCOUNT];
			 tempArray = new char[UNICODECOUNT];
			 for (i = 0;
			 i < UNICODECOUNT;
			 ++i) {
				 tempArray[i] = elementAt((char)i);
			 }
			 for (i = 0;
			 i < INDEXCOUNT;
			 ++i) {
				 indices[i] = (char)(i<<BLOCKSHIFT);
			 }
			 values = null;
			 values = tempArray;
			 isCompact = false;
		 }
	 }
	 public static final int BLOCKSHIFT = 5;
	 static final int BLOCKCOUNT =(1<<BLOCKSHIFT);
	 static final int INDEXSHIFT =(16-BLOCKSHIFT);
	 static final int INDEXCOUNT =(1<<INDEXSHIFT);
	 static final int BLOCKMASK = BLOCKCOUNT - 1;
	 private char values[];
	 private char indices[];
	 private int[] hashes;
	 private boolean isCompact;
	 char defaultValue;
}",1,0,0,0
"public class ListElement extends Canvas{
	private Tab tab;
	private int index;
	private boolean selected;
	private boolean hover;
	public ListElement( Composite parent, final Tab tab, int index ){
		super( parent, SWT.NO_FOCUS );
		this.tab = tab;
		hover = false;
		selected = false;
		this.index = index;
		addPaintListener( new PaintListener( ) {
			public void paintControl( PaintEvent e ){
				paint( e );
			}
		}
		 );
		addMouseListener( new MouseAdapter( ) {
			public void mouseDown( MouseEvent e ){
				if ( !selected ){
					select( getIndex( ListElement.this ), true );
				}
				Composite tabbedPropertyComposite = getParent( );
				Control[] children = tabbedPropertyComposite.getParent( ).getTabList( );
				if ( children != null && children.length > 0 ){
					for ( int i = 0;
					 i < children.length;
					 i++ ){
						if ( children[i] == TabbedPropertyList.this ){
							continue;
						}
						else if ( children[i].setFocus( ) ){
							focus = false;
							return;
						}
					}
				}
			}
		}
		 );
		addMouseMoveListener( new MouseMoveListener( ) {
			public void mouseMove( MouseEvent e ){
				if ( !hover ){
					hover = true;
					redraw( );
				}
			}
		}
		 );
		addMouseTrackListener( new MouseTrackAdapter( ) {
			public void mouseExit( MouseEvent e ){
				hover = false;
				redraw( );
			}
		}
		 );
	}
	public void setSelected( boolean selected ){
		this.selected = selected;
		redraw( );
	}
	private void paint( PaintEvent e ){
		Rectangle bounds = getBounds( );
		e.gc.setForeground( widgetNormalShadow );
		e.gc.drawLine( 0, 0, bounds.width - 1, 0 );
		e.gc.setForeground( listBackground );
		e.gc.drawLine( 0, 1, bounds.width - 1, 1 );
		if ( selected ){
			e.gc.setBackground( listBackground );
			e.gc.fillRectangle( 0, 2, bounds.width, bounds.height - 1 );
		}
		else if ( hover && tab.isIndented( ) ){
			e.gc.setBackground( indentedHoverBackground );
			e.gc.fillRectangle( 0, 2, bounds.width - 1, bounds.height - 1 );
		}
		else if ( hover ){
			e.gc.setForeground( hoverGradientStart );
			e.gc.setBackground( hoverGradientEnd );
			e.gc.fillGradientRectangle( 0,2,bounds.width - 1,bounds.height - 1,true );
		}
		else if ( tab.isIndented( ) ){
			e.gc.setBackground( indentedDefaultBackground );
			e.gc.fillRectangle( 0, 2, bounds.width - 1, bounds.height - 1 );
		}
		else{
			e.gc.setForeground( defaultGradientStart );
			e.gc.setBackground( defaultGradientEnd );
			e.gc.fillGradientRectangle( 0,2,bounds.width - 1,bounds.height - 1,true );
		}
		if ( !selected ){
			e.gc.setForeground( widgetNormalShadow );
			e.gc.drawLine( bounds.width - 1,1,bounds.width - 1,bounds.height + 1 );
		}
		int textIndent = INDENT;
		FontMetrics fm = e.gc.getFontMetrics( );
		int height = fm.getHeight( );
		int textMiddle = ( bounds.height - height ) / 2;
		if ( selected&& tab.getImage( ) != null&& !tab.getImage( ).isDisposed( ) ){
			if ( tab.isIndented( ) ){
				textIndent = textIndent + INDENT;
			}
			else{
				textIndent = textIndent - 3;
			}
			e.gc.drawImage( tab.getImage( ), textIndent, textMiddle - 1 );
			textIndent = textIndent + 16 + 5;
		}
		else if ( tab.isIndented( ) ){
			textIndent = textIndent + INDENT;
		}
		e.gc.setForeground( widgetForeground );
		if ( selected ){
			e.gc.setFont( JFaceResources.getFontRegistry( ).getBold( JFaceResources.DEFAULT_FONT ) );
		}
		e.gc.drawText( tab.getText( ), textIndent, textMiddle, true );
		if ( ( (TabbedPropertyList) getParent( ) ).focus&& selected&& focus ){
			Point point = e.gc.textExtent( tab.getText( ) );
			e.gc.drawLine( textIndent, bounds.height - 4, textIndent+ point.x, bounds.height - 4 );
		}
		if ( !hover ){
			e.gc.setForeground( listBackground );
			e.gc.drawLine( 0,bounds.height - 1,bounds.width - 2,bounds.height - 1 );
		}
	}
	public String getText( ){
		return tab.getText( );
	}
	public String toString( ){
		return tab.getText( );
	}
}",1,1,0,0
"public static Protocol getProtocol(String urlString) throws ProtocolNotFound {
	 try {
		 URL url = new URL(urlString);
		 String protocolName = url.getProtocol();
		 if (protocolName == null) throw new ProtocolNotFound(urlString);
		 Extension extension = getExtension(protocolName);
		 if (extension == null) throw new ProtocolNotFound(protocolName);
		 return (Protocol)extension.getExtensionInstance();
	 }
	 catch (MalformedURLException e) {
		 throw new ProtocolNotFound(urlString, e.toString());
	 }
	 catch (PluginRuntimeException e) {
		 throw new ProtocolNotFound(urlString, e.toString());
	 }
 }",0,0,0,0
"class WafFolderContent {
	 private final WafFolder rootFolder;
	 private final List<WafFolder> subFolders;
	 private final List<WafFile> files;
	 public WafFolderContent(WafFolder rootFolder, List<WafFolder> subFolders, List<WafFile> files) {
		 this.rootFolder = rootFolder;
		 this.subFolders = subFolders;
		 this.files = files;
	 }
	 public WafFolder getRootFolder() {
		 return rootFolder;
	 }
	 public List<WafFolder> getSubFolders() {
		 return subFolders;
	 }
	 public List<WafFile> getFiles() {
		 return files;
	 }
}",0,1,0,0
"public static DataSet createTrainingSet (String trainingSetName, BufferedImage imageWithChars, String chars, Dimension scaleToDim, List<String> imageLabels){
	 List<String> charList = Arrays.asList(chars.split("" ""));
	 CharExtractor charExtractor = new CharExtractor(imageWithChars);
	 HashMap <String, BufferedImage> charImageMap = charExtractor.extractCharImagesToLearn(imageWithChars, charList, scaleToDim);
	 for (String imgName : charImageMap.keySet()) {
		 StringTokenizer st = new StringTokenizer(imgName, ""._"");
		 String imgLabel = st.nextToken();
		 if (!imageLabels.contains(imgLabel)) {
			 imageLabels.add(imgLabel);
		 }
	 }
	 Collections.sort(imageLabels);
	 Map<String, FractionRgbData> imageRgbData = ImageUtilities.getFractionRgbDataForImages(charImageMap);
	 BufferedImage allWhite = new BufferedImage(scaleToDim.getWidth(), scaleToDim.getHeight(), BufferedImage.TYPE_INT_RGB);
	 Graphics g = allWhite.getGraphics();
	 g.setColor(Color.WHITE);
	 g.fillRect(0, 0, allWhite.getWidth(), allWhite.getHeight());
	 imageRgbData.put(""allWhite"", new FractionRgbData(allWhite));
	 DataSet dataSet = ImageRecognitionHelper.createBlackAndWhiteTrainingSet(imageLabels, imageRgbData);
	 dataSet.setLabel(trainingSetName);
	 return dataSet;
 }",0,0,1,0
"public class FileUtil {
	 public static boolean fullyDelete(File dir, Configuration conf) throws IOException {
		 return fullyDelete(dir);
	 }
	 public static boolean fullyDelete(File dir) throws IOException {
		 File contents[] = dir.listFiles();
		 if (contents != null) {
			 for (int i = 0;
			 i < contents.length;
			 i++) {
				 if (contents[i].isFile()) {
					 if (! contents[i].delete()) {
						 return false;
					 }
				 }
				 else {
					 if (! fullyDelete(contents[i])) {
						 return false;
					 }
				 }
			 }
		 }
		 return dir.delete();
	 }
	 public static boolean copy(FileSystem srcFS, Path src, FileSystem dstFS, Path dst, boolean deleteSource, Configuration conf ) throws IOException {
		 dst = checkDest(src.getName(), dstFS, dst);
		 if (srcFS.isDirectory(src)) {
			 dstFS.mkdirs(dst);
			 Path contents[] = srcFS.listPaths(src);
			 for (int i = 0;
			 i < contents.length;
			 i++) {
				 copy(srcFS, contents[i], dstFS, new Path(dst, contents[i].getName()), deleteSource, conf);
			 }
		 }
		 else if (srcFS.isFile(src)) {
			 InputStream in = srcFS.open(src);
			 try {
				 copyContent(in, dstFS.create(dst), conf);
			 }
			 finally {
				 in.close();
			 }
		 }
		 if (deleteSource) {
			 return srcFS.delete(src);
		 }
		 else {
			 return true;
		 }
	 }
	 public static boolean copyMerge(FileSystem srcFS, Path srcDir, FileSystem dstFS, Path dstFile, boolean deleteSource, Configuration conf, String addString) throws IOException {
		 dstFile = checkDest(srcDir.getName(), dstFS, dstFile);
		 if (!srcFS.isDirectory(srcDir)) return false;
		 OutputStream out = dstFS.create(dstFile);
		 try {
			 Path contents[] = srcFS.listPaths(srcDir);
			 for (int i = 0;
			 i < contents.length;
			 i++) {
				 if (srcFS.isFile(contents[i])) {
					 InputStream in = srcFS.open(contents[i]);
					 try {
						 copyContent(in, out, conf, false);
						 if(addString!=null) out.write(addString.getBytes(""UTF-8""));
					 }
					 finally {
						 in.close();
					 }
				 }
			 }
		 }
		 finally {
			 out.close();
		 }
		 if (deleteSource) {
			 return srcFS.delete(srcDir);
		 }
		 else {
			 return true;
		 }
	 }
	 public static boolean copy(File src, FileSystem dstFS, Path dst, boolean deleteSource, Configuration conf ) throws IOException {
		 dst = checkDest(src.getName(), dstFS, dst);
		 if (src.isDirectory()) {
			 dstFS.mkdirs(dst);
			 File contents[] = src.listFiles();
			 for (int i = 0;
			 i < contents.length;
			 i++) {
				 copy(contents[i], dstFS, new Path(dst, contents[i].getName()), deleteSource, conf);
			 }
		 }
		 else if (src.isFile()) {
			 InputStream in = new FileInputStream(src);
			 try {
				 copyContent(in, dstFS.create(dst), conf);
			 }
			 finally {
				 in.close();
			 }
		 }
		 if (deleteSource) {
			 return FileUtil.fullyDelete(src);
		 }
		 else {
			 return true;
		 }
	 }
	 public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf ) throws IOException {
		 dst = checkDest(src.getName(), dst);
		 if (srcFS.isDirectory(src)) {
			 dst.mkdirs();
			 Path contents[] = srcFS.listPaths(src);
			 for (int i = 0;
			 i < contents.length;
			 i++) {
				 copy(srcFS, contents[i], new File(dst, contents[i].getName()), deleteSource, conf);
			 }
		 }
		 else if (srcFS.isFile(src)) {
			 InputStream in = srcFS.open(src);
			 try {
				 copyContent(in, new FileOutputStream(dst), conf);
			 }
			 finally {
				 in.close();
			 }
		 }
		 if (deleteSource) {
			 return srcFS.delete(src);
		 }
		 else {
			 return true;
		 }
	 }
	 private static void copyContent(InputStream in, OutputStream out, Configuration conf) throws IOException {
		 copyContent(in, out, conf, true);
	 }
	 private static void copyContent(InputStream in, OutputStream out, Configuration conf, boolean close) throws IOException {
		 byte buf[] = new byte[conf.getInt(""io.file.buffer.size"", 4096)];
		 try {
			 int bytesRead = in.read(buf);
			 while (bytesRead >= 0) {
				 out.write(buf, 0, bytesRead);
				 bytesRead = in.read(buf);
			 }
		 }
		 finally {
			 if(close) out.close();
		 }
	 }
	 private static Path checkDest(String srcName, FileSystem dstFS, Path dst) throws IOException {
		 if (dstFS.exists(dst)) {
			 if (!dstFS.isDirectory(dst)) {
				 throw new IOException(""Target "" + dst + "" already exists"");
			 }
			 else {
				 dst = new Path(dst, srcName);
				 if (dstFS.exists(dst)) {
					 throw new IOException(""Target "" + dst + "" already exists"");
				 }
			 }
		 }
		 return dst;
	 }
	 private static File checkDest(String srcName, File dst) throws IOException {
		 if (dst.exists()) {
			 if (!dst.isDirectory()) {
				 throw new IOException(""Target "" + dst + "" already exists"");
			 }
			 else {
				 dst = new File(dst, srcName);
				 if (dst.exists()) {
					 throw new IOException(""Target "" + dst + "" already exists"");
				 }
			 }
		 }
		 return dst;
	 }
	 public static long getDU(File dir) {
		 long size = 0;
		 if (!dir.exists()) return 0;
		 if (!dir.isDirectory()) {
			 return dir.length();
		 }
		 else {
			 size = dir.length();
			 File[] allFiles = dir.listFiles();
			 for (int i = 0;
			 i < allFiles.length;
			 i++) {
				 size = size + getDU(allFiles[i]);
			 }
			 return size;
		 }
	 }
	 public static void unZip(File inFile, File unzipDir) throws IOException {
		 Enumeration entries;
		 ZipFile zipFile = new ZipFile(inFile);
		 ;
		 try {
			 entries = zipFile.entries();
			 while (entries.hasMoreElements()) {
				 ZipEntry entry = (ZipEntry) entries.nextElement();
				 if (!entry.isDirectory()) {
					 InputStream in = zipFile.getInputStream(entry);
					 try {
						 File file = new File(unzipDir, entry.getName());
						 file.getParentFile().mkdirs();
						 OutputStream out = new FileOutputStream(file);
						 try {
							 byte[] buffer = new byte[8192];
							 int i;
							 while ((i = in.read(buffer)) != -1) {
								 out.write(buffer, 0, i);
							 }
						 }
						 finally {
							 out.close();
						 }
					 }
					 finally {
						 in.close();
					 }
				 }
			 }
		 }
		 finally {
			 zipFile.close();
		 }
	 }
}",0,0,0,0
"public class FBRuleInfGraph extends BasicForwardRuleInfGraph implements BackwardRuleInfGraphI {
	 protected BBRuleContext context;
	 protected Finder dataFind;
	 protected LPBRuleEngine bEngine;
	 protected List<Rule> rawRules;
	 protected List<Rule> rules;
	 public static boolean useRETE = true;
	 protected boolean useTGCCaching = false;
	 protected TransitiveEngine transitiveEngine;
	 protected List<RulePreprocessHook> preprocessorHooks;
	 protected TempNodeCache tempNodecache;
	 protected Set<Node> hiddenNodes;
	 protected HashMap<Node, List<RDFDatatype>> dtRange = null;
	 protected boolean requestDatatypeRangeValidation = false;
	 static Logger logger = LoggerFactory.getLogger(FBRuleInfGraph.class);
	 public FBRuleInfGraph(Reasoner reasoner, Graph schema) {
		 super(reasoner, schema);
		 constructorInit(schema);
	 }
	 public FBRuleInfGraph(Reasoner reasoner, List<Rule> rules, Graph schema) {
		 super( reasoner, rules, schema );
		 this.rawRules = rules;
		 constructorInit( schema );
	 }
	 public FBRuleInfGraph( Reasoner reasoner, List<Rule> rules, Graph schema, Graph data ) {
		 super(reasoner, rules, schema, data);
		 this.rawRules = rules;
		 constructorInit(schema);
	 }
	 private void constructorInit(Graph schema) {
		 initLP(schema);
		 tempNodecache = new TempNodeCache(this);
		 if (JenaParameters.enableFilteringOfHiddenInfNodes) {
			 hiddenNodes = new HashSet<>();
			 if (schema != null && schema instanceof FBRuleInfGraph) {
				 hiddenNodes.addAll(((FBRuleInfGraph)schema).hiddenNodes);
			 }
		 }
	 }
	 protected void instantiateRuleEngine(List<Rule> rules) {
		 engine = FRuleEngineIFactory.getInstance().createFRuleEngineI(this, rules, useRETE);
	 }
	 private void initLP(Graph schema) {
		 if (schema != null && schema instanceof FBRuleInfGraph) {
			 LPRuleStore newStore = new LPRuleStore();
			 newStore.addAll(((FBRuleInfGraph)schema).bEngine.getRuleStore());
			 bEngine = new LPBRuleEngine(this, newStore);
		 }
		 else {
			 bEngine = new LPBRuleEngine(this);
		 }
	 }
	 public void setUseTGCCache() {
		 useTGCCaching = true;
		 resetTGCCache();
	 }
	 private void resetTGCCache() {
		 if (schemaGraph != null) {
			 transitiveEngine = new TransitiveEngine(((FBRuleInfGraph)schemaGraph).transitiveEngine);
		 }
		 else {
			 transitiveEngine = new TransitiveEngine( new TransitiveGraphCache(ReasonerVocabulary.directSubClassOf.asNode(), RDFS.subClassOf.asNode()), new TransitiveGraphCache(ReasonerVocabulary.directSubPropertyOf.asNode(), RDFS.subPropertyOf.asNode()));
		 }
	 }
	 public ExtendedIterator<Triple> findDataMatches(Node subject, Node predicate, Node object) {
		 return dataFind.find(new TriplePattern(subject, predicate, object));
	 }
	 public ExtendedIterator<Triple> findDataMatches(TriplePattern pattern) {
		 return dataFind.find(pattern);
	 }
	 public boolean processBuiltin(ClauseEntry clause, Rule rule, BindingEnvironment env) {
		 throw new ReasonerException(""Internal error in FBLP rule engine, incorrect invocation of builtin in rule "" + rule);
	 }
	 public void addBRule(Rule brule) {
		 if (logger.isDebugEnabled()) {
			 logger.debug(""Adding rule "" + brule);
		 }
		 bEngine.addRule(brule);
		 bEngine.reset();
	 }
	 public void deleteBRule(Rule brule) {
		 if (logger.isDebugEnabled()) {
			 logger.debug(""Deleting rule "" + brule);
		 }
		 bEngine.deleteRule(brule);
		 bEngine.reset();
	 }
	 public void addBRules(List<Rule> rules) {
		 for ( Rule rule : rules ) {
			 bEngine.addRule( rule );
		 }
		 bEngine.reset();
	 }
	 public List<Rule> getBRules() {
		 return bEngine.getAllRules();
	 }
	 public List<Rule> getRules() {
		 return rules;
	 }
	 public void setTabled(Node predicate) {
		 bEngine.tablePredicate(predicate);
		 if (traceOn) {
			 logger.info(""LP TABLE "" + predicate);
		 }
	 }
	 private Object getForwardRuleStore() {
		 return engine.getRuleStore();
	 }
	 public void addDeduction(Triple t) {
		 getCurrentDeductionsGraph().add(t);
		 if (useTGCCaching) {
			 transitiveEngine.add(t);
		 }
	 }
	 public Node getTemp(Node instance, Node prop, Node pclass) {
		 return tempNodecache.getTemp(instance, prop, pclass);
	 }
	 public void addRuleDuringPrepare(Rule rule) {
		 if (rules == rawRules) {
			 rules = new ArrayList<>( rawRules );
			 instantiateRuleEngine(rules);
		 }
		 rules.add(rule);
	 }
	 public void addPreprocessingHook(RulePreprocessHook hook) {
		 if (preprocessorHooks == null) {
			 preprocessorHooks = new ArrayList<>();
		 }
		 preprocessorHooks.add(hook);
	 }
	 public synchronized void prepare() {
		 if (this.isPrepared()) return;
		 this.setPreparedState(true);
		 rules = rawRules;
		 Graph data = null;
		 if (fdata != null) data = fdata.getGraph();
		 if (fdeductions != null) {
			 Graph oldDeductions = (fdeductions).getGraph();
			 oldDeductions.clear();
		 }
		 else {
			 fdeductions = new FGraph( createDeductionsGraph() );
		 }
		 dataFind = (data == null) ? fdeductions : FinderUtil.cascade(fdeductions, fdata);
		 Finder dataSource = fdata;
		 if (useTGCCaching) {
			 resetTGCCache();
			 if (schemaGraph != null) {
				 if ( (transitiveEngine.checkOccurance(TransitiveReasoner.subPropertyOf, data) || transitiveEngine.checkOccurance(TransitiveReasoner.subClassOf, data) || transitiveEngine.checkOccurance(RDFS.domain.asNode(), data) || transitiveEngine.checkOccurance(RDFS.range.asNode(), data) )) {
					 transitiveEngine.insert(((FBRuleInfGraph)schemaGraph).fdata, fdata);
				 }
			 }
			 else {
				 if (data != null) {
					 transitiveEngine.insert(null, fdata);
				 }
			 }
			 for ( Rule r : rules ) {
				 if ( r.bodyLength() == 0 ) {
					 for ( int j = 0;
					 j < r.headLength();
					 j++ ) {
						 ClauseEntry head = r.getHeadElement( j );
						 if ( head instanceof TriplePattern ) {
							 TriplePattern h = (TriplePattern) head;
							 transitiveEngine.add( h.asTriple() );
						 }
					 }
				 }
			 }
			 transitiveEngine.setCaching(true, true);
			 dataFind = FinderUtil.cascade(dataFind, transitiveEngine.getSubClassCache(), transitiveEngine.getSubPropertyCache());
			 dataSource = FinderUtil.cascade(dataSource, transitiveEngine.getSubClassCache(), transitiveEngine.getSubPropertyCache());
		 }
		 bEngine.deleteAllRules();
		 if (preprocessorHooks != null && preprocessorHooks.size() > 0) {
			 Graph inserts = GraphMemFactory.createGraphMem();
			 for ( RulePreprocessHook hook : preprocessorHooks ) {
				 hook.run( this, dataFind, inserts );
			 }
			 if (inserts.size() > 0) {
				 FGraph finserts = new FGraph(inserts);
				 dataSource = FinderUtil.cascade(fdata, finserts);
				 dataFind = FinderUtil.cascade(dataFind, finserts);
			 }
		 }
		 boolean rulesLoaded = false;
		 if (schemaGraph != null) {
			 Graph rawPreload = ((InfGraph)schemaGraph).getRawGraph();
			 if (rawPreload != null) {
				 dataFind = FinderUtil.cascade(dataFind, new FGraph(rawPreload));
			 }
			 rulesLoaded = preloadDeductions(schemaGraph);
		 }
		 if (rulesLoaded) {
			 engine.fastInit(dataSource);
		 }
		 else {
			 addBRules(extractPureBackwardRules(rules));
			 engine.init(true, dataSource);
		 }
		 context = new BBRuleContext(this);
	 }
	 public void rebind() {
		 version++;
		 if (bEngine != null) bEngine.reset();
		 this.setPreparedState(false);
	 }
	 public void rebindAll() {
		 rawRules = ((FBRuleReasoner)reasoner).getRules();
		 instantiateRuleEngine( rawRules );
		 rebind();
	 }
	 public void setTraceOn(boolean state) {
		 super.setTraceOn(state);
		 bEngine.setTraceOn(state);
	 }
	 public void setDerivationLogging(boolean recordDerivations) {
		 this.recordDerivations = recordDerivations;
		 engine.setDerivationLogging(recordDerivations);
		 bEngine.setDerivationLogging(recordDerivations);
		 if (recordDerivations) {
			 derivations = new OneToManyMap<>();
		 }
		 else {
			 derivations = null;
		 }
	 }
	 public long getNRulesFired() {
		 return engine.getNRulesFired();
	 }
	 public ExtendedIterator<Triple> findWithContinuation(TriplePattern pattern, Finder continuation) {
		 checkOpen();
		 this.requirePrepared();
		 ExtendedIterator<Triple> result =bEngine.find(pattern).filterKeep( new UniqueFilter<Triple>());
		 if (continuation != null) {
			 result = result.andThen(continuation.find(pattern));
		 }
		 if (filterFunctors) {
			 return result.filterDrop( t -> FBRuleInfGraph.this.accept( t ) );
		 }
		 else {
			 return result;
		 }
	 }
	 public ExtendedIterator<Triple> findFull(TriplePattern pattern) {
		 checkOpen();
		 this.requirePrepared();
		 return bEngine.find(pattern).filterKeep( new UniqueFilter<Triple>());
	 }
	 public ExtendedIterator<Triple> graphBaseFind(Node subject, Node property, Node object) {
		 return findWithContinuation(new TriplePattern(subject, property, object), null);
	 }
	 public ExtendedIterator<Triple> find(TriplePattern pattern) {
		 return findWithContinuation(pattern, null);
	 }
	 public synchronized void reset() {
		 version++;
		 bEngine.reset();
		 this.setPreparedState(false);
	 }
	 public synchronized void performAdd(Triple t) {
		 version++;
		 fdata.getGraph().add(t);
		 if (useTGCCaching) {
			 if (transitiveEngine.add(t)) this.setPreparedState(false);
		 }
		 if (this.isPrepared()) {
			 boolean needReset = false;
			 if (preprocessorHooks != null && preprocessorHooks.size() > 0) {
				 if (preprocessorHooks.size() > 1) {
					 for ( RulePreprocessHook preprocessorHook : preprocessorHooks ) {
						 if ( preprocessorHook.needsRerun( this, t ) ) {
							 needReset = true;
							 break;
						 }
					 }
				 }
				 else {
					 needReset = preprocessorHooks.get(0).needsRerun(this, t);
				 }
			 }
			 if (needReset) {
				 this.setPreparedState(false);
			 }
			 else {
				 engine.add(t);
			 }
		 }
		 bEngine.reset();
	 }
	 public void performDelete(Triple t) {
		 version++;
		 fdata.getGraph().delete(t);
		 if (useTGCCaching) {
			 if (transitiveEngine.delete(t)) {
				 if (this.isPrepared()) {
					 bEngine.deleteAllRules();
				 }
				 this.setPreparedState(false);
			 }
		 }
		 if (this.isPrepared()) {
			 bEngine.deleteAllRules();
			 this.setPreparedState(false);
		 }
		 bEngine.reset();
	 }
	 public void close() {
		 if (!closed) {
			 bEngine.halt();
			 bEngine = null;
			 transitiveEngine = null;
			 super.close();
		 }
	 }
	 public ValidityReport validate() {
		 checkOpen();
		 StandardValidityReport report = new StandardValidityReport();
		 Triple validateOn = Triple.create(NodeFactory.createBlankNode(), ReasonerVocabulary.RB_VALIDATION.asNode(), Functor.makeFunctorNode(""on"", new Node[] {
		}
		));
		 this.requirePrepared();
		 engine.add(validateOn);
		 TriplePattern pattern = new TriplePattern(null, ReasonerVocabulary.RB_VALIDATION_REPORT.asNode(), null);
		 final Model forConversion = ModelFactory.createDefaultModel();
		 for (Iterator<Triple> i = findFull(pattern);
		 i.hasNext();
		 ) {
			 Triple t = i.next();
			 Node rNode = t.getObject();
			 if (rNode.isLiteral()) {
				 Object rVal = rNode.getLiteralValue();
				 if (rVal instanceof Functor) {
					 Functor rFunc = (Functor)rVal;
					 StringBuffer description = new StringBuffer();
					 String nature = rFunc.getName();
					 String type = rFunc.getArgs()[0].toString();
					 String text = rFunc.getArgs()[1].toString();
					 description.append( text + ""\n"");
					 description.append( ""Culprit = "" + PrintUtil.print(t.getSubject()) +""\n"");
					 for (int j = 2;
					 j < rFunc.getArgLength();
					 j++) {
						 description.append( ""Implicated node: "" + PrintUtil.print(rFunc.getArgs()[j]) + ""\n"");
					 }
					 RDFNode culprit = forConversion.asRDFNode( t.getSubject() );
					 report.add(nature.equalsIgnoreCase(""error""), type, description.toString(), culprit);
				 }
			 }
		 }
		 if (requestDatatypeRangeValidation) {
			 performDatatypeRangeValidation( report );
		 }
		 return report;
	 }
	 public void setDatatypeRangeValidation(boolean on) {
		 requestDatatypeRangeValidation = on;
	 }
	 protected void performDatatypeRangeValidation(StandardValidityReport report) {
		 HashMap<Node, List<RDFDatatype>> dtRange = getDTRange();
		 for ( Node prop : dtRange.keySet() ) {
			 for ( Iterator<Triple> i = find( null, prop, null );
			 i.hasNext();
			 ) {
				 Triple triple = i.next();
				 report.add( checkLiteral( prop, triple ) );
			 }
		 }
	 }
	 public ValidityReport.Report checkLiteral(Node prop, Triple triple) {
		 Node value = triple.getObject();
		 List<RDFDatatype> range = getDTRange().get(prop);
		 if (range != null) {
			 if (value.isBlank()) return null;
			 if (!value.isLiteral()) {
				 return new ValidityReport.Report(true, ""dtRange"", ""Property "" + prop + "" has a typed range but was given a non literal value "" + value);
			 }
			 LiteralLabel ll = value.getLiteral();
			 for ( RDFDatatype dt : range ) {
				 if ( !dt.isValidLiteral( ll ) ) {
					 return new ValidityReport.Report( true, ""dtRange"", ""Property "" + prop + "" has a typed range "" + dt + ""that is not compatible with "" + value, triple );
				 }
			 }
		 }
		 return null;
	 }
	 protected HashMap<Node, List<RDFDatatype>> getDTRange() {
		 if (dtRange == null) {
			 dtRange = new HashMap<>();
			 for (Iterator<Triple> i = find(null, RDFS.range.asNode(), null);
			 i.hasNext();
			 ) {
				 Triple triple = i.next();
				 Node prop = triple.getSubject();
				 Node rangeValue = triple.getObject();
				 if (rangeValue.isURI()) {
					 RDFDatatype dt = TypeMapper.getInstance().getTypeByName(rangeValue.getURI());
					 if (dt != null) {
						 List<RDFDatatype> range = dtRange.get(prop);
						 if (range == null) {
							 range = new ArrayList<>();
							 dtRange.put(prop, range);
						 }
						 range.add(dt);
					 }
				 }
			 }
		 }
		 return dtRange;
	 }
	 private static List<Rule> extractPureBackwardRules(List<Rule> rules) {
		 List<Rule> bRules = new ArrayList<>();
		 for ( Rule r : rules ) {
			 if ( r.isBackward() && r.bodyLength() > 0 ) {
				 bRules.add( r );
			 }
		 }
		 return bRules;
	 }
	 protected boolean preloadDeductions(Graph preloadIn) {
		 Graph d = fdeductions.getGraph();
		 FBRuleInfGraph preload = (FBRuleInfGraph)preloadIn;
		 if (preload.rules == rules) {
			 for (Iterator<Triple> i = preload.getDeductionsGraph().find(null, null, null);
			 i.hasNext();
			 ) {
				 d.add( i.next() );
			 }
			 addBRules(preload.getBRules());
			 engine.setRuleStore(preload.getForwardRuleStore());
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public void hideNode(Node n) {
		 if (! JenaParameters.enableFilteringOfHiddenInfNodes) return;
		 if (hiddenNodes == null) {
			 hiddenNodes = new HashSet<>();
		 }
		 synchronized (hiddenNodes) {
			 hiddenNodes.add(n);
		 }
	 }
	 public void resetLPProfile(boolean enable) {
		 bEngine.resetProfile(enable);
	 }
	 public void printLPProfile() {
		 bEngine.printProfile();
	 }
	 public boolean accept(Object tin) {
		 Triple t = (Triple)tin;
		 if ((t).getSubject().isLiteral()) return true;
		 if (JenaParameters.enableFilteringOfHiddenInfNodes && hiddenNodes != null) {
			 if (hiddenNodes.contains(t.getSubject()) || hiddenNodes.contains(t.getObject()) || hiddenNodes.contains(t.getPredicate())) {
				 return true;
			 }
		 }
		 if (filterFunctors) {
			 if (Functor.isFunctor(t.getObject())) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public static class RuleStore {
		 protected List<Rule> rawRules;
		 protected Object fRuleStore;
		 protected List<Rule> bRules;
		 public RuleStore(List<Rule> rawRules, Object fRuleStore, List<Rule> bRules) {
			 this.rawRules = rawRules;
			 this.fRuleStore = fRuleStore;
			 this.bRules = bRules;
		 }
	 }
}",1,0,0,0
"protected final void parseUntil(TextBuffer tb, char endChar, boolean convertLFs, String errorMsg) throws XMLStreamException {
	 if (mInputPtr >= mInputEnd) {
		 loadMore(errorMsg);
	 }
	 while (true) {
		 char[] inputBuf = mInputBuffer;
		 int inputLen = mInputEnd;
		 int ptr = mInputPtr;
		 int startPtr = ptr;
		 while (ptr < inputLen) {
			 char c = inputBuf[ptr++];
			 if (c == endChar) {
				 int thisLen = ptr - startPtr - 1;
				 if (thisLen > 0) {
					 tb.append(inputBuf, startPtr, thisLen);
				 }
				 mInputPtr = ptr;
				 return;
			 }
			 if (c == '\n') {
				 mInputPtr = ptr;
				 markLF();
			 }
			 else if (c == '\r') {
				 if (!convertLFs && ptr < inputLen) {
					 if (inputBuf[ptr] == '\n') {
						 ++ptr;
					 }
					 mInputPtr = ptr;
					 markLF();
				 }
				 else {
					 int thisLen = ptr - startPtr - 1;
					 if (thisLen > 0) {
						 tb.append(inputBuf, startPtr, thisLen);
					 }
					 mInputPtr = ptr;
					 c = getNextChar(errorMsg);
					 if (c != '\n') {
						 --mInputPtr;
						 tb.append(convertLFs ? '\n' : '\r');
					 }
					 else {
						 if (convertLFs) {
							 tb.append('\n');
						 }
						 else {
							 tb.append('\r');
							 tb.append('\n');
						 }
					 }
					 startPtr = ptr = mInputPtr;
					 markLF();
				 }
			 }
		 }
		 int thisLen = ptr - startPtr;
		 if (thisLen > 0) {
			 tb.append(inputBuf, startPtr, thisLen);
		 }
		 loadMore(errorMsg);
		 startPtr = ptr = mInputPtr;
		 inputBuf = mInputBuffer;
		 inputLen = mInputEnd;
	 }
 }",0,0,1,0
"void updateTimestamp() {
	 updateTimestamp_ = System.currentTimeMillis();
 }",0,0,0,0
"public class PropertyValueVetoException extends Exception {
	 String propertyName;
	 String rejectedValue;
	 String reason;
	 PropertyEditorListener listener;
	 String message = null;
	 public PropertyValueVetoException(String pProperty, String pRejectedValue, String pReason, PropertyEditorListener pListener) {
		 propertyName = pProperty;
		 rejectedValue = pRejectedValue;
		 reason = pReason;
		 listener = pListener;
	 }
	 public PropertyValueVetoException(String pMessage) {
		 message = pMessage;
	 }
	 public String getProperty() {
		 return propertyName;
	 }
	 public String getRejectedValue() {
		 return rejectedValue;
	 }
	 public String getReason() {
		 return reason;
	 }
	 public PropertyEditorListener getListener() {
		 return listener;
	 }
	 public String getMessage() {
		 if (message == null) return ""Error changing value "" + getProperty() + "" to '"" + getRejectedValue() + ""': "" + getReason();
		 else return message;
	 }
}",0,1,0,0
"public void registerDTD(String publicId, String location) {
	 if (location == null) {
		 return;
	 }
	 File fileDTD = new File(location);
	 if (!fileDTD.exists()) {
		 fileDTD = owningTask.getProject().resolveFile(location);
	 }
	 if (fileDTD.exists()) {
		 if (publicId != null) {
			 fileDTDs.put(publicId, fileDTD);
			 owningTask.log(""Mapped publicId "" + publicId + "" to file "" + fileDTD, Project.MSG_VERBOSE);
		 }
		 return;
	 }
	 if (getClass().getResource(location) != null) {
		 if (publicId != null) {
			 resourceDTDs.put(publicId, location);
			 owningTask.log(""Mapped publicId "" + publicId + "" to resource "" + location, Project.MSG_VERBOSE);
		 }
	 }
	 try {
		 if (publicId != null) {
			 URL urldtd = new URL(location);
			 urlDTDs.put(publicId, urldtd);
		 }
	 }
	 catch (java.net.MalformedURLException e) {
	 }
 }",0,0,0,0
"public static class Build {
	 private String version = """";
	 public String getVersion() {
		 return version;
	 }
	 public void setVersion(final String version) {
		 this.version = version;
	 }
 }",0,1,0,0
"static void putByte(byte[] data, int offset, int value);",0,0,0,0
"public final class InstanceToNodeMetadata implements Function<Instance, NodeMetadata> {
	 private final Map<Instance.Status, NodeMetadata.Status> toPortableNodeStatus;
	 private final GroupNamingConvention nodeNamingConvention;
	 private final LoadingCache<URI, Optional<Image>> diskURIToImage;
	 private final Supplier<Map<URI, Hardware>> hardwares;
	 private final Supplier<Map<URI, Location>> locationsByUri;
	 InstanceToNodeMetadata(Map<Instance.Status, NodeMetadata.Status> toPortableNodeStatus, GroupNamingConvention.Factory namingConvention, LoadingCache<URI, Optional<Image>> diskURIToImage, Supplier<Map<URI, Hardware>> hardwares, Supplier<Map<URI, Location>> locationsByUri) {
		 this.toPortableNodeStatus = toPortableNodeStatus;
		 this.nodeNamingConvention = namingConvention.createWithoutPrefix();
		 this.diskURIToImage = diskURIToImage;
		 this.hardwares = hardwares;
		 this.locationsByUri = locationsByUri;
	 }
	 public NodeMetadata apply(Instance input) {
		 String group = groupFromMapOrName(input.metadata().asMap(), input.name(), nodeNamingConvention);
		 NodeMetadataBuilder builder = new NodeMetadataBuilder();
		 Location zone = locationsByUri.get().get(input.zone());
		 if (zone == null) {
			 throw new IllegalStateException( String.format(""zone %s not present in %s"", input.zone(), locationsByUri.get().keySet()));
		 }
		 URI diskSource = input.disks().get(0).source();
		 Optional<Image> image = diskURIToImage.getUnchecked(diskSource);
		 Hardware hardware;
		 if (isCustomMachineTypeURI(input.machineType())) {
			 hardware = machineTypeURIToCustomHardware(input.machineType());
		 }
		 else {
			 hardware = hardwares.get().get(input.machineType());
		 }
		 builder.id(input.selfLink().toString()) .name(input.name()) .providerId(input.id()) .hostname(input.name()) .location(zone) .imageId(image.isPresent() ? image.get().selfLink().toString() : null) .hardware(hardware) .status(input.status() != null ? toPortableNodeStatus.get(input.status()) : Status.UNRECOGNIZED) .tags(input.tags().items()) .uri(input.selfLink()) .userMetadata(input.metadata().asMap()) .group(group) .privateAddresses(collectPrivateAddresses(input)) .publicAddresses(collectPublicAddresses(input));
		 return builder.build();
	 }
	 private List<String> collectPrivateAddresses(Instance input) {
		 ImmutableList.Builder<String> privateAddressesBuilder = ImmutableList.builder();
		 for (Instance.NetworkInterface networkInterface : input.networkInterfaces()) {
			 if (networkInterface.networkIP() != null) {
				 privateAddressesBuilder.add(networkInterface.networkIP());
			 }
		 }
		 return privateAddressesBuilder.build();
	 }
	 private List<String> collectPublicAddresses(Instance input) {
		 ImmutableList.Builder<String> publicAddressesBuilder = ImmutableList.builder();
		 for (Instance.NetworkInterface networkInterface : input.networkInterfaces()) {
			 for (Instance.NetworkInterface.AccessConfig accessConfig : networkInterface.accessConfigs()) {
				 if (accessConfig.natIP() != null) {
					 publicAddressesBuilder.add(accessConfig.natIP());
				 }
			 }
		 }
		 return publicAddressesBuilder.build();
	 }
	 public static boolean isCustomMachineTypeURI(URI machineType) {
		 return machineType.toString().contains(""machineTypes/custom"");
	 }
	 public static Hardware machineTypeURIToCustomHardware(URI machineType) {
		 String uri = machineType.toString();
		 String values = uri.substring(uri.lastIndexOf('/') + 8);
		 List<String> hardwareValues = Splitter.on('-') .trimResults() .splitToList(values);
		 return new HardwareBuilder() .id(uri) .providerId(uri) .processor(new Processor(Double.parseDouble(hardwareValues.get(0)), 1.0)) .ram(Integer.parseInt(hardwareValues.get(1))) .uri(machineType) .build();
	 }
}",0,0,0,0
"protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint);",0,0,0,1
"public void write(DataOutput out) throws IOException {
	 UTF8.writeString(out, fromUrl);
	 UTF8.writeString(out, anchor);
 }",0,0,0,0
"protected boolean assumeJava16() {
	 return ""javac1.6"".equals(attributes.getCompilerVersion()) || (""classic"".equals(attributes.getCompilerVersion()) && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6)) || (""modern"".equals(attributes.getCompilerVersion()) && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6)) || (""extJavac"".equals(attributes.getCompilerVersion()) && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6));
 }",0,0,0,0
"public boolean doGet(int logLevel, DownloadProgress progress) throws IOException {
	 checkAttributes();
	 if (progress == null) {
		 progress = new NullProgress();
	 }
	 log(""Getting: "" + source, logLevel);
	 log(""To: "" + dest.getAbsolutePath(), logLevel);
	 long timestamp = 0;
	 boolean hasTimestamp = false;
	 if (useTimestamp && dest.exists()) {
		 timestamp = dest.lastModified();
		 if (verbose) {
			 Date t = new Date(timestamp);
			 log(""local file date : "" + t.toString(), logLevel);
		 }
		 hasTimestamp = true;
	 }
	 URLConnection connection = source.openConnection();
	 if (hasTimestamp) {
		 connection.setIfModifiedSince(timestamp);
	 }
	 if (uname != null || pword != null) {
		 String up = uname + "":"" + pword;
		 String encoding;
		 Base64Converter encoder = new Base64Converter();
		 encoding = encoder.encode(up.getBytes());
		 connection.setRequestProperty (""Authorization"", ""Basic "" + encoding);
	 }
	 connection.connect();
	 if (connection instanceof HttpURLConnection) {
		 HttpURLConnection httpConnection = (HttpURLConnection) connection;
		 long lastModified = httpConnection.getLastModified();
		 if (httpConnection.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED || (lastModified != 0 && hasTimestamp && timestamp >= lastModified)) {
			 log(""Not modified - so not downloaded"", logLevel);
			 return false;
		 }
		 if (httpConnection.getResponseCode() == HttpURLConnection.HTTP_UNAUTHORIZED) {
			 String message = ""HTTP Authorization failure"";
			 if (ignoreErrors) {
				 log(message, logLevel);
				 return false;
			 }
			 else {
				 throw new BuildException(message);
			 }
		 }
	 }
	 InputStream is = null;
	 for (int i = 0;
	 i < NUMBER_RETRIES;
	 i++) {
		 try {
			 is = connection.getInputStream();
			 break;
		 }
		 catch (IOException ex) {
			 log(""Error opening connection "" + ex, logLevel);
		 }
	 }
	 if (is == null) {
		 log(""Can't get "" + source + "" to "" + dest, logLevel);
		 if (ignoreErrors) {
			 return false;
		 }
		 throw new BuildException(""Can't get "" + source + "" to "" + dest, getLocation());
	 }
	 FileOutputStream fos = new FileOutputStream(dest);
	 progress.beginDownload();
	 boolean finished = false;
	 try {
		 byte[] buffer = new byte[BIG_BUFFER_SIZE];
		 int length;
		 while ((length = is.read(buffer)) >= 0) {
			 fos.write(buffer, 0, length);
			 progress.onTick();
		 }
		 finished = true;
	 }
	 finally {
		 FileUtils.close(fos);
		 FileUtils.close(is);
		 if (!finished) {
			 dest.delete();
		 }
	 }
	 progress.endDownload();
	 if (useTimestamp) {
		 long remoteTimestamp = connection.getLastModified();
		 if (verbose) {
			 Date t = new Date(remoteTimestamp);
			 log(""last modified = "" + t.toString() + ((remoteTimestamp == 0) ? "" - using current time instead"" : """"), logLevel);
		 }
		 if (remoteTimestamp != 0) {
			 FILE_UTILS.setFileLastModified(dest, remoteTimestamp);
		 }
	 }
	 return true;
 }",0,0,1,0
"private int encode0(byte[] src, int off, int end, byte[] dst) {
	 char[] base64 = isURL ? toBase64URL : toBase64;
	 int sp = off;
	 int slen = (end - off) / 3 * 3;
	 int sl = off + slen;
	 if (linemax > 0 && slen > linemax / 4 * 3) slen = linemax / 4 * 3;
	 int dp = 0;
	 while (sp < sl) {
		 int sl0 = Math.min(sp + slen, sl);
		 for (int sp0 = sp, dp0 = dp ;
		 sp0 < sl0;
		 ) {
			 int bits = (src[sp0++] & 0xff) << 16 | (src[sp0++] & 0xff) << 8 | (src[sp0++] & 0xff);
			 dst[dp0++] = (byte)base64[(bits >>> 18) & 0x3f];
			 dst[dp0++] = (byte)base64[(bits >>> 12) & 0x3f];
			 dst[dp0++] = (byte)base64[(bits >>> 6) & 0x3f];
			 dst[dp0++] = (byte)base64[bits & 0x3f];
		 }
		 int dlen = (sl0 - sp) / 3 * 4;
		 dp += dlen;
		 sp = sl0;
		 if (dlen == linemax && sp < end) {
			 for (byte b : newline){
				 dst[dp++] = b;
			 }
		 }
	 }
	 if (sp < end) {
		 int b0 = src[sp++] & 0xff;
		 dst[dp++] = (byte)base64[b0 >> 2];
		 if (sp == end) {
			 dst[dp++] = (byte)base64[(b0 << 4) & 0x3f];
			 if (doPadding) {
				 dst[dp++] = '=';
				 dst[dp++] = '=';
			 }
		 }
		 else {
			 int b1 = src[sp++] & 0xff;
			 dst[dp++] = (byte)base64[(b0 << 4) & 0x3f | (b1 >> 4)];
			 dst[dp++] = (byte)base64[(b1 << 2) & 0x3f];
			 if (doPadding) {
				 dst[dp++] = '=';
			 }
		 }
	 }
	 return dp;
 }",0,0,1,0
"public class FormComponentLabel extends WebMarkupContainer{
	private static final long serialVersionUID = 1L;
	private final LabeledWebMarkupContainer component;
	public FormComponentLabel(String id, LabeledWebMarkupContainer component){
		super(id);
		if (component == null){
			throw new IllegalArgumentException(""Component argument cannot be null"");
		}
		this.component = component;
		component.setOutputMarkupId(true);
	}
	protected void onComponentTag(ComponentTag tag){
		super.onComponentTag(tag);
		checkComponentTag(tag, ""label"");
		tag.put(""for"", component.getMarkupId());
		tag.setType(XmlTag.OPEN);
	}
	public LabeledWebMarkupContainer getFormComponent(){
		return component;
	}
}",0,0,0,0
"public IRequestTarget resolve(final RequestCycle requestCycle,final RequestParameters requestParameters){
	try{
		IRequestCodingStrategy requestCodingStrategy = requestCycle.getProcessor().getRequestCodingStrategy();
		final String path = requestParameters.getPath();
		IRequestTarget target = null;
		if (requestParameters.getBookmarkablePageClass() != null){
			target = resolveBookmarkablePage(requestCycle, requestParameters);
		}
		else if (requestParameters.getComponentPath() != null){
			int processRequest = 0;
			 synchronized (requestCycle.getSession()){
				if (requestParameters.isOnlyProcessIfPathActive()){
					Session session = Session.get();
					IPageMap pageMap = session.pageMapForName(requestParameters.getPageMapName(), false);
					if (pageMap == null){
						processRequest = 1;
					}
					else if (pageMap instanceof AccessStackPageMap){
						AccessStackPageMap accessStackPageMap = (AccessStackPageMap)pageMap;
						if (accessStackPageMap.getAccessStack().size() > 0){
							final Access access = accessStackPageMap.getAccessStack().peek();
							final int pageId = Integer.parseInt(Strings.firstPathComponent(requestParameters.getComponentPath(), Component.PATH_SEPARATOR));
							if (pageId != access.getId()){
								processRequest = 2;
							}
							else{
								final int version = requestParameters.getVersionNumber();
								if (version != Page.LATEST_VERSION &&version != access.getVersion()){
									processRequest = 2;
								}
							}
						}
					}
					else{
					}
				}
			}
			if (processRequest == 0){
				try{
					target = resolveRenderedPage(requestCycle, requestParameters);
				}
				catch (IgnoreAjaxRequestException e){
					target = EmptyAjaxRequestTarget.getInstance();
				}
			}
			else{
				Request request = requestCycle.getRequest();
				if (request instanceof WebRequest && ((WebRequest)request).isAjax() &&processRequest == 2){
					target = EmptyAjaxRequestTarget.getInstance();
				}
				else{
					throw new PageExpiredException(""Request cannot be processed"");
				}
			}
		}
		else if (requestParameters.getResourceKey() != null){
			target = resolveSharedResource(requestCycle, requestParameters);
		}
		else if (Strings.isEmpty(path) || (""/"".equals(path))){
			target = resolveHomePageTarget(requestCycle, requestParameters);
		}
		if (target == null){
			target = requestCodingStrategy.targetForRequest(requestParameters);
			if (target == null && requestParameters.getComponentPath() != null){
				throw new PageExpiredException(""Cannot find the rendered page in session [pagemap="" +requestParameters.getPageMapName() + "",componentPath="" +requestParameters.getComponentPath() + "",versionNumber="" +requestParameters.getVersionNumber() + ""]"");
			}
		}
		else{
			if (Application.get().getSecuritySettings().getEnforceMounts() &&requestCodingStrategy.pathForTarget(target) != null){
				boolean homepage = false;
				if (target instanceof BookmarkablePageRequestTarget){
					final BookmarkablePageRequestTarget bt = (BookmarkablePageRequestTarget)target;
					if (bt.getPageClass().equals(Application.get().getHomePage())){
						homepage = true;
					}
				}
				if (!homepage){
					String msg = ""Direct access not allowed for mounted targets"";
					log.error(msg + "" [request="" + requestCycle.getRequest() + "",target="" +target + "",session="" + Session.get() + ""]"");
					throw new AbortWithWebErrorCodeException(HttpServletResponse.SC_FORBIDDEN,msg);
				}
			}
		}
		return target;
	}
	catch (WicketRuntimeException e){
		if (e instanceof PageExpiredException){
			throw e;
		}
		else if (e.getCause() instanceof PageExpiredException){
			throw e;
		}
		else{
			throw new InvalidUrlException(e);
		}
	}
}",0,0,1,0
"protected void runProject(Server s, com.starbase.starteam.Project p) {
	 View[] views = p.getViews();
	 for (int i = 0;
	 i < views.length;
	 i++) {
		 View v = views[i];
		 if (v.getName().equals(getViewName())) {
			 if (getVerbose()) {
				 log(""Found "" + getProjectName() + delim + getViewName() + delim);
			 }
			 runType(s, p, v, s.typeForName(s.getTypeNames().FILE));
			 break;
		 }
	 }
 }",0,0,0,0
"public void sendRoot(CaldavRequest request) throws IOException {
	 CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
	 response.startMultistatus();
	 response.startResponse(""/"");
	 response.startPropstat();
	 if (request.hasProperty(""principal-collection-set"")) {
		 response.appendHrefProperty(""D:principal-collection-set"", ""/principals/users/"");
	 }
	 if (request.hasProperty(""displayname"")) {
		 response.appendProperty(""D:displayname"", ""ROOT"");
	 }
	 if (request.hasProperty(""resourcetype"")) {
		 response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
	 }
	 if (request.hasProperty(""current-user-principal"")) {
		 response.appendHrefProperty(""D:current-user-principal"", encodePath(request, ""/principals/users/"" + session.getEmail()));
	 }
	 response.endPropStatOK();
	 response.endResponse();
	 if (request.depth == 1) {
		 response.startResponse(""/users/"" + session.getEmail() + ""/calendar"");
		 response.startPropstat();
		 if (request.hasProperty(""resourcetype"")) {
			 response.appendProperty(""D:resourcetype"", ""<D:collection/>"" + ""<C:calendar xmlns:C=\""urn:ietf:params:xml:ns:caldav\""/>"");
		 }
		 if (request.hasProperty(""displayname"")) {
			 response.appendProperty(""D:displayname"", session.getEmail());
		 }
		 if (request.hasProperty(""supported-calendar-component-set"")) {
			 response.appendProperty(""C:supported-calendar-component-set"", ""<C:comp name=\""VEVENT\""/>"");
		 }
		 response.endPropStatOK();
		 response.endResponse();
		 response.startResponse(""/users"");
		 response.startPropstat();
		 if (request.hasProperty(""displayname"")) {
			 response.appendProperty(""D:displayname"", ""users"");
		 }
		 if (request.hasProperty(""resourcetype"")) {
			 response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
		 }
		 response.endPropStatOK();
		 response.endResponse();
		 response.startResponse(""/principals"");
		 response.startPropstat();
		 if (request.hasProperty(""displayname"")) {
			 response.appendProperty(""D:displayname"", ""principals"");
		 }
		 if (request.hasProperty(""resourcetype"")) {
			 response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
		 }
		 response.endPropStatOK();
		 response.endResponse();
	 }
	 response.endMultistatus();
	 response.close();
 }",0,0,1,0
"private final int jjMoveStringLiteralDfa0_1(){
	 return jjMoveNfa_1(0, 0);
}",0,0,0,0
"public String getDeviceDisplayName() {
	 String displayName = """";
	 if (this.properties == null) {
		 return displayName;
	 }
	 String deviceDisplayNameOption = (String) this.properties.get(DEVICE_DISPLAY_NAME);
	 if (""device-name"".equals(deviceDisplayNameOption)) {
		 displayName = this.systemService.getDeviceName();
	 }
	 else if (""hostname"".equals(deviceDisplayNameOption)) {
		 displayName = this.systemService.getHostname();
	 }
	 else if (""custom"".equals(deviceDisplayNameOption) && this.properties.get(DEVICE_CUSTOM_NAME) instanceof String) {
		 displayName = (String) this.properties.get(DEVICE_CUSTOM_NAME);
	 }
	 else if (""server"".equals(deviceDisplayNameOption)) {
		 displayName = """";
	 }
	 return displayName;
 }",0,0,1,0
"public final class EclipseTeamProjectWizard extends EclipseConnectWizard implements ITeamProjectWizard {
	 public static final CodeMarker CODEMARKER_NOTIFICATION_WIZARD_FINISH = new CodeMarker(""com.microsoft.tfs.client.eclipse.ui.wizard.teamprojectwizard.EclipseTeamProjectWizard#finsh"");
	 private static final Log log = LogFactory.getLog(EclipseTeamProjectWizard.class);
	 private final static ImageHelper imageHelper = new ImageHelper(TFSCommonUIClientPlugin.PLUGIN_ID);
	 public EclipseTeamProjectWizard() {
		 super( Messages.getString(""EclipseTeamProjectWizard.WizardTitle""), Messages.getString(""EclipseTeamProjectWizard.WizardDescription""), imageHelper.getImageDescriptor(""images/wizard/pageheader.png""), SourceControlCapabilityFlags.GIT_TFS, ConnectWizard.PROJECT_SELECTION);
		 addConnectionPages();
		 initConnectionPages();
		 if (hasPageData(Workspace.class)) {
			 removePageData(Workspace.class);
		 }
	 }
	 public void setServerURI(final URI serverURI) {
		 setPageData(URI.class, serverURI);
	 }
	 public boolean enableNext(final IWizardPage currentPage) {
		 if (!enableNextConnectionPage(currentPage)) {
			 return false;
		 }
		 if (getSelectionPageName().equals(currentPage.getName())) {
			 return false;
		 }
		 return true;
	 }
	 public IWizardPage getNextPage(final IWizardPage page) {
		 final IWizardPage nextConnectionPage = getNextConnectionPage();
		 if (nextConnectionPage != null) {
			 return nextConnectionPage;
		 }
		 return getPage(getSelectionPageName());
	 }
	 protected boolean enableFinish(final IWizardPage currentPage) {
		 if (getSelectionPageName().equals(currentPage.getName())) {
			 return true;
		 }
		 return false;
	 }
	 protected boolean doPerformFinish() {
		 final IBackgroundTask backgroundTask = new BackgroundTask(Messages.getString(""EclipseTeamProjectWizard.InitializingConnectionMessage""));
		 TFSEclipseClientPlugin.getDefault().getServerManager().backgroundConnectionTaskStarted(backgroundTask);
		 try {
			 final TFSTeamProjectCollection connection = (TFSTeamProjectCollection) getPageData(TFSTeamProjectCollection.class);
			 final TFSServer existingServer = TFSEclipseClientPlugin.getDefault().getServerManager().getDefaultServer();
			 final TFSRepository existingRepository = TFSEclipseClientPlugin.getDefault().getRepositoryManager().getDefaultRepository();
			 final Workspace[] workspaces = getCurrentWorkspaces(connection);
			 if ((existingServer != null && !existingServer.connectionsEquivalent(connection))) {
				 if (!TFSEclipseClientUIPlugin.getDefault().getConnectionConflictHandler().resolveServerConflict()) {
					 CodeMarkerDispatch.dispatch(CODEMARKER_NOTIFICATION_WIZARD_FINISH);
					 return false;
				 }
				 if (TFSEclipseClientUIPlugin.getDefault().getServerManager().getDefaultServer() != null) {
					 TFSEclipseClientUIPlugin.getDefault().getConnectionConflictHandler().notifyServerConflict();
					 CodeMarkerDispatch.dispatch(CODEMARKER_NOTIFICATION_WIZARD_FINISH);
					 return false;
				 }
			 }
			 else if (workspaces != null && existingRepository != null) {
				 boolean containsCurrentWorkspace = false;
				 final Workspace currentWorkspace = existingRepository.getWorkspace();
				 for (final Workspace ws : workspaces) {
					 if (currentWorkspace.equals(ws)) {
						 containsCurrentWorkspace = true;
					 }
				 }
				 if (!containsCurrentWorkspace) {
					 if (!TFSEclipseClientUIPlugin.getDefault().getConnectionConflictHandler().resolveRepositoryConflict() || TFSEclipseClientUIPlugin.getDefault().getRepositoryManager().getDefaultRepository() != null) {
						 TFSEclipseClientUIPlugin.getDefault().getConnectionConflictHandler().notifyRepositoryConflict();
						 CodeMarkerDispatch.dispatch(CODEMARKER_NOTIFICATION_WIZARD_FINISH);
						 return false;
					 }
				 }
			 }
			 finishConnection();
			 final Workspace workspace = getDefaultWorkspace(connection);
			 finishWorkspace(workspace);
		 }
		 finally {
			 TFSEclipseClientPlugin.getDefault().getServerManager().backgroundConnectionTaskFinished(backgroundTask);
		 }
		 CodeMarkerDispatch.dispatch(CODEMARKER_NOTIFICATION_WIZARD_FINISH);
		 return true;
	 }
	 public TFSServer getServer() {
		 return (TFSServer) getPageData(TFSServer.class);
	 }
	 public ProjectInfo[] getSelectedProjects() {
		 return (ProjectInfo[]) getPageData(ConnectWizard.SELECTED_TEAM_PROJECTS);
	 }
}",1,0,0,0
"private void handleHeaderFooter(Range[] ranges, String type, HWPFDocument document, PicturesSource pictures, PicturesTable pictureTable, XHTMLContentHandler xhtml) throws SAXException, IOException, TikaException {
	 if (countParagraphs(ranges) > 0) {
		 xhtml.startElement(""div"", ""class"", type);
		 ListManager listManager = new ListManager(document);
		 for (Range r : ranges) {
			 if (r != null) {
				 for (int i = 0;
				 i < r.numParagraphs();
				 i++) {
					 Paragraph p = r.getParagraph(i);
					 i += handleParagraph(p, 0, r, document, FieldsDocumentPart.HEADER, pictures, pictureTable, listManager, xhtml);
				 }
			 }
		 }
		 xhtml.endElement(""div"");
	 }
 }",0,0,1,0
"public void configureInputJobProperties(TableDesc tableDesc, Map<String, String> jobProperties) {
	 try {
		 Map<String, String> tableProperties = tableDesc.getJobProperties();
		 String jobInfoProperty = tableProperties.get(HCatConstants.HCAT_KEY_JOB_INFO);
		 if (jobInfoProperty != null) {
			 LinkedList<InputJobInfo> inputJobInfos = (LinkedList<InputJobInfo>) HCatUtil.deserialize( jobInfoProperty);
			 if (inputJobInfos == null || inputJobInfos.isEmpty()) {
				 throw new IOException(""No InputJobInfo was set in job config"");
			 }
			 InputJobInfo inputJobInfo = inputJobInfos.getLast();
			 HCatTableInfo tableInfo = inputJobInfo.getTableInfo();
			 HCatSchema dataColumns = tableInfo.getDataColumns();
			 List<HCatFieldSchema> dataFields = dataColumns.getFields();
			 StringBuilder columnNamesSb = new StringBuilder();
			 StringBuilder typeNamesSb = new StringBuilder();
			 for (HCatFieldSchema dataField : dataFields) {
				 if (columnNamesSb.length() > 0) {
					 columnNamesSb.append("","");
					 typeNamesSb.append("":"");
				 }
				 columnNamesSb.append(dataField.getName());
				 typeNamesSb.append(dataField.getTypeString());
			 }
			 jobProperties.put(IOConstants.SCHEMA_EVOLUTION_COLUMNS, columnNamesSb.toString());
			 jobProperties.put(IOConstants.SCHEMA_EVOLUTION_COLUMNS_TYPES, typeNamesSb.toString());
			 boolean isTransactionalTable = AcidUtils.isTablePropertyTransactional(tableProperties);
			 AcidUtils.AcidOperationalProperties acidOperationalProperties = AcidUtils.getAcidOperationalProperties(tableProperties);
			 AcidUtils.setAcidOperationalProperties( jobProperties, isTransactionalTable, acidOperationalProperties);
		 }
	 }
	 catch (IOException e) {
		 throw new IllegalStateException(""Failed to set output path"", e);
	 }
 }",0,0,1,0
"final class NativeNumber extends IdScriptableObject{
	 private static final Object NUMBER_TAG = new Object();
	 private static final int MAX_PRECISION = 100;
	 static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeNumber obj = new NativeNumber(0.0);
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeNumber(double number) {
		 doubleValue = number;
	 }
	 public String getClassName() {
		 return ""Number"";
	 }
	 protected void fillConstructorProperties(IdFunctionObject ctor) {
		 final int attr = ScriptableObject.DONTENUM | ScriptableObject.PERMANENT | ScriptableObject.READONLY;
		 ctor.defineProperty(""NaN"", ScriptRuntime.NaNobj, attr);
		 ctor.defineProperty(""POSITIVE_INFINITY"", ScriptRuntime.wrapNumber(Double.POSITIVE_INFINITY), attr);
		 ctor.defineProperty(""NEGATIVE_INFINITY"", ScriptRuntime.wrapNumber(Double.NEGATIVE_INFINITY), attr);
		 ctor.defineProperty(""MAX_VALUE"", ScriptRuntime.wrapNumber(Double.MAX_VALUE), attr);
		 ctor.defineProperty(""MIN_VALUE"", ScriptRuntime.wrapNumber(Double.MIN_VALUE), attr);
		 super.fillConstructorProperties(ctor);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=1;
			 s=""toString"";
			 break;
			 case Id_toLocaleString: arity=1;
			 s=""toLocaleString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_valueOf: arity=0;
			 s=""valueOf"";
			 break;
			 case Id_toFixed: arity=1;
			 s=""toFixed"";
			 break;
			 case Id_toExponential: arity=1;
			 s=""toExponential"";
			 break;
			 case Id_toPrecision: arity=1;
			 s=""toPrecision"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(NUMBER_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(NUMBER_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 if (id == Id_constructor) {
			 double val = (args.length >= 1) ? ScriptRuntime.toNumber(args[0]) : 0.0;
			 if (thisObj == null) {
				 return new NativeNumber(val);
			 }
			 return ScriptRuntime.wrapNumber(val);
		 }
		 if (!(thisObj instanceof NativeNumber)) throw incompatibleCallError(f);
		 double value = ((NativeNumber)thisObj).doubleValue;
		 switch (id) {
			 case Id_toString: case Id_toLocaleString: {
				 int base = (args.length == 0) ? 10 : ScriptRuntime.toInt32(args[0]);
				 return ScriptRuntime.numberToString(value, base);
			 }
			 case Id_toSource: return ""(new Number(""+ScriptRuntime.toString(value)+""))"";
			 case Id_valueOf: return ScriptRuntime.wrapNumber(value);
			 case Id_toFixed: return num_to(value, args, DToA.DTOSTR_FIXED, DToA.DTOSTR_FIXED, -20, 0);
			 case Id_toExponential: return num_to(value, args, DToA.DTOSTR_STANDARD_EXPONENTIAL, DToA.DTOSTR_EXPONENTIAL, 0, 1);
			 case Id_toPrecision: return num_to(value, args, DToA.DTOSTR_STANDARD, DToA.DTOSTR_PRECISION, 1, 0);
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
	 }
	 public String toString() {
		 return ScriptRuntime.numberToString(doubleValue, 10);
	 }
	 private static String num_to(double val, Object[] args, int zeroArgMode, int oneArgMode, int precisionMin, int precisionOffset) {
		 int precision;
		 if (args.length == 0) {
			 precision = 0;
			 oneArgMode = zeroArgMode;
		 }
		 else {
			 precision = ScriptRuntime.toInt32(args[0]);
			 if (precision < precisionMin || precision > MAX_PRECISION) {
				 String msg = ScriptRuntime.getMessage1( ""msg.bad.precision"", ScriptRuntime.toString(args[0]));
				 throw ScriptRuntime.constructError(""RangeError"", msg);
			 }
		 }
		 StringBuffer sb = new StringBuffer();
		 DToA.JS_dtostr(sb, oneArgMode, precision + precisionOffset, val);
		 return sb.toString();
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 7: c=s.charAt(0);
				 if (c=='t') {
					 X=""toFixed"";
					id=Id_toFixed;
				 }
				 else if (c=='v') {
					 X=""valueOf"";
					id=Id_valueOf;
				 }
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
				 case 11: c=s.charAt(0);
				 if (c=='c') {
					 X=""constructor"";
					id=Id_constructor;
				 }
				 else if (c=='t') {
					 X=""toPrecision"";
					id=Id_toPrecision;
				 }
				 break L;
				 case 13: X=""toExponential"";
				id=Id_toExponential;
				 break L;
				 case 14: X=""toLocaleString"";
				id=Id_toLocaleString;
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toLocaleString = 3, Id_toSource = 4, Id_valueOf = 5, Id_toFixed = 6, Id_toExponential = 7, Id_toPrecision = 8, MAX_PROTOTYPE_ID = 8;
	 private double doubleValue;
}",0,0,0,0
"public class Native2Ascii extends MatchingTask {
	 private boolean reverse = false;
	 private String encoding = null;
	 private File srcDir = null;
	 private File destDir = null;
	 private String extension = null;
	 private Mapper mapper;
	 private FacadeTaskHelper facade = null;
	 public Native2Ascii() {
		 facade = new FacadeTaskHelper(Native2AsciiAdapterFactory.getDefault());
	 }
	 public void setReverse(boolean reverse) {
		 this.reverse = reverse;
	 }
	 public boolean getReverse() {
		 return reverse;
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public String getEncoding() {
		 return encoding;
	 }
	 public void setSrc(File srcDir) {
		 this.srcDir = srcDir;
	 }
	 public void setDest(File destDir) {
		 this.destDir = destDir;
	 }
	 public void setExt(String ext) {
		 this.extension = ext;
	 }
	 public void setImplementation(String impl) {
		 if (""default"".equals(impl)) {
			 facade.setImplementation(Native2AsciiAdapterFactory.getDefault());
		 }
		 else {
			 facade.setImplementation(impl);
		 }
	 }
	 public Mapper createMapper() throws BuildException {
		 if (mapper != null) {
			 throw new BuildException(""Cannot define more than one mapper"", getLocation());
		 }
		 mapper = new Mapper(getProject());
		 return mapper;
	 }
	 public void add(FileNameMapper fileNameMapper) {
		 createMapper().add(fileNameMapper);
	 }
	 public ImplementationSpecificArgument createArg() {
		 ImplementationSpecificArgument arg = new ImplementationSpecificArgument();
		 facade.addImplementationArgument(arg);
		 return arg;
	 }
	 public void execute() throws BuildException {
		 DirectoryScanner scanner = null;
		 String[] files;
		 if (srcDir == null) {
			 srcDir = getProject().resolveFile(""."");
		 }
		 if (destDir == null) {
			 throw new BuildException(""The dest attribute must be set."");
		 }
		 if (srcDir.equals(destDir) && extension == null && mapper == null) {
			 throw new BuildException(""The ext attribute or a mapper must be set if"" + "" src and dest dirs are the same."");
		 }
		 FileNameMapper m = null;
		 if (mapper == null) {
			 if (extension == null) {
				 m = new IdentityMapper();
			 }
			 else {
				 m = new ExtMapper();
			 }
		 }
		 else {
			 m = mapper.getImplementation();
		 }
		 scanner = getDirectoryScanner(srcDir);
		 files = scanner.getIncludedFiles();
		 SourceFileScanner sfs = new SourceFileScanner(this);
		 files = sfs.restrict(files, srcDir, destDir, m);
		 int count = files.length;
		 if (count == 0) {
			 return;
		 }
		 String message = ""Converting "" + count + "" file"" + (count != 1 ? ""s"" : """") + "" from "";
		 log(message + srcDir + "" to "" + destDir);
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 convert(files[i], m.mapFileName(files[i])[0]);
		 }
	 }
	 private void convert(String srcName, String destName) throws BuildException {
		 File srcFile;
		 File destFile;
		 srcFile = new File(srcDir, srcName);
		 destFile = new File(destDir, destName);
		 if (srcFile.equals(destFile)) {
			 throw new BuildException(""file "" + srcFile + "" would overwrite its self"");
		 }
		 String parentName = destFile.getParent();
		 if (parentName != null) {
			 File parentFile = new File(parentName);
			 if ((!parentFile.exists()) && (!parentFile.mkdirs())) {
				 throw new BuildException(""cannot create parent directory "" + parentName);
			 }
		 }
		 log(""converting "" + srcName, Project.MSG_VERBOSE);
		 Native2AsciiAdapter ad = Native2AsciiAdapterFactory.getAdapter(facade.getImplementation(), this);
		 if (!ad.convert(this, srcFile, destFile)) {
			 throw new BuildException(""conversion failed"");
		 }
	 }
	 public String[] getCurrentArgs() {
		 return facade.getArgs();
	 }
	 private class ExtMapper implements FileNameMapper {
		 public void setFrom(String s) {
		 }
		 public void setTo(String s) {
		 }
		 public String[] mapFileName(String fileName) {
			 int lastDot = fileName.lastIndexOf('.');
			 if (lastDot >= 0) {
				 return new String[] {
				fileName.substring(0, lastDot) + extension}
				;
			 }
			 else {
				 return new String[] {
				fileName + extension}
				;
			 }
		 }
	 }
}",0,0,0,0
"public class IRIFactory extends IRIFactoryImpl implements IRIFactoryI {
	 static {
		 new ViolationCodes.Initialize();
	 }
	 static private IRIFactory jenaFactory;
	 static private IRIFactory theSemWebFactory;
	 static private IRIFactory theURIFactory;
	 static private IRIFactory theIRIFactory;
	 static public IRIFactory iriImplementation() {
		 return theIRIFactory;
	 }
	 static public IRIFactory uriImplementation() {
		 return theURIFactory;
	 }
	 static public IRIFactory semanticWebImplementation() {
		 return theSemWebFactory;
	 }
	 static public IRIFactory jenaImplementation() {
		 return jenaFactory;
	 }
	 private boolean usingSpecXMLSchema = false;
	 public IRIFactory() {
	 }
	 public IRIFactory(IRIFactory template) {
		 super(template);
		 this.usingSpecXMLSchema = template.usingSpecXMLSchema;
	 }
	 public void setSameSchemeRelativeReferences(String scheme) {
		 super.setSameSchemeRelativeReferences(scheme);
	 }
	 public void allowUnwiseCharacters() {
		 boolean warning = getAsErrors(MINTING)||getAsWarnings(MINTING);
		 setIsError(UNWISE_CHARACTER,false);
		 setIsError(WHITESPACE,false);
		 setIsWarning(UNWISE_CHARACTER,warning);
		 setIsWarning(WHITESPACE,warning);
		 if (!usingSpecXMLSchema ) {
			 setIsError(DOUBLE_WHITESPACE,false);
			 setIsWarning(DOUBLE_WHITESPACE,warning);
		 }
	 }
	 public void setQueryCharacterRestrictions(boolean restrict){
		 throw new UnsupportedOperationException(""unimplemented"");
	 }
	 public void setEncoding(String enc) throws UnsupportedEncodingException {
		 super.setEncoding(enc);
	 }
	 public IRI create( String scheme, String userInfo, String host, int port, String path, String query, String fragment ) {
		 return null;
	 }
	 public IRI create( String scheme, String authority, String path, String query, String fragment ) {
		 return null;
	 }
	 public IRI construct( String scheme, String userInfo, String host, int port, String path, String query, String fragment ) throws IRIException {
		 return throwAnyErrors(create( scheme, userInfo, host, port, path, query, fragment ));
	 }
	 public IRI construct( String scheme, String authority, String path, String query, String fragment ) throws IRIException {
		 return throwAnyErrors(create( scheme, authority, path, query, fragment ));
	 }
	 public boolean isError(int code) {
		 return (errors & (1l<<code))!=0;
	 }
	 public boolean isWarning(int code) {
		 return (warnings & (1l<<code))!=0;
	 }
	 public void setIsError(int code, boolean set) {
		 initializing();
		 if (set) {
			 errors |= (1l<<code);
			 setIsWarning(code,false);
		 }
		 else errors &= ~(1l<<code);
	 }
	 public void setIsWarning(int code, boolean set) {
		 initializing();
		 if (set) {
			 warnings |= (1l<<code);
			 setIsError(code,false);
		 }
		 else warnings &= ~(1l<<code);
	 }
	 public boolean ignoring(int code) {
		 return !(isError(code)||isWarning(code));
	 }
	 public void useSpecificationURI(boolean asErrors){
		 useSpec(""URI"",asErrors);
	 }
	 public void useSpecificationIRI(boolean asErrors){
		 useSpec(""IRI"",asErrors);
	 }
	 public void useSpecificationRDF(boolean asErrors){
		 useSpec(""RDF"",asErrors);
	 }
	 public void useSpecificationXMLSchema(boolean asErrors){
		 usingSpecXMLSchema = true;
		 useSpec(""Schema"",asErrors);
	 }
	 public void useSpecificationXMLSystemID(boolean asErrors){
		 useSpec(""XML"",asErrors);
	 }
	 public void useSpecificationXLink(boolean asErrors){
		 useSpec(""XLink"",asErrors);
	 }
	 public void shouldViolation(boolean isError,boolean isWarning){
		 setViolation(SHOULD,isError,isWarning);
	 }
	 public void securityViolation(boolean isError,boolean isWarning){
		 setViolation(SECURITY,isError,isWarning);
	 }
	 public void dnsViolation(boolean isError,boolean isWarning){
		 setViolation(DNS,isError,isWarning);
	 }
	 public void mintingViolation(boolean isError,boolean isWarning){
		 setViolation(MINTING,isError,isWarning);
	 }
	 public void useSchemeSpecificRules(String scheme, boolean asErrors){
		 super.useSchemeSpecificRules(scheme,asErrors);
	 }
	 static {
		 theIRIFactory = new IRIFactory();
		 theIRIFactory.useSpecificationIRI(true);
		 theIRIFactory.useSchemeSpecificRules(""*"",true);
		 theIRIFactory.create("""");
		 jenaFactory = new IRIFactory();
		 jenaFactory.shouldViolation(false,false);
		 jenaFactory.securityViolation(false,false);
		 jenaFactory.useSpecificationRDF(false);
		 jenaFactory.setIsError(UNREGISTERED_IANA_SCHEME,false);
		 jenaFactory.setIsWarning(UNREGISTERED_IANA_SCHEME,false);
		 jenaFactory.setIsError(CONTROL_CHARACTER,false);
		 jenaFactory.setIsWarning(CONTROL_CHARACTER,false);
		 jenaFactory.useSchemeSpecificRules(""http"",true);
		 jenaFactory.create("""");
		 theURIFactory = new IRIFactory();
		 theURIFactory.useSpecificationURI(true);
		 theURIFactory.useSchemeSpecificRules(""*"",true);
		 theURIFactory.create("""");
		 theSemWebFactory = new IRIFactory();
		 theSemWebFactory.useSpecificationRDF(true);
		 theSemWebFactory.useSpecificationIRI(true);
		 theSemWebFactory.useSpecificationXLink(true);
		 theSemWebFactory.useSchemeSpecificRules(""*"",true);
		 theSemWebFactory.setIsError(NON_INITIAL_DOT_SEGMENT,true);
		 theSemWebFactory.create("""");
	 }
	public static void setJenaImplementation(IRIFactory jf) {
		jenaFactory = jf;
	}
	public static void setIriImplementation(IRIFactory iriF) {
		theIRIFactory = iriF;
	}
	public static void setUriImplementation(IRIFactory uriF) {
		theURIFactory = uriF;
	}
	public static void setSemanticWebImplementation(IRIFactory sw) {
		theSemWebFactory = sw;
	}
}",1,0,0,0
"public CreateBudgetDetails build() {
	 CreateBudgetDetails __instance__ = new CreateBudgetDetails( compartmentId, targetCompartmentId, displayName, description, amount, resetPeriod, freeformTags, definedTags);
	 __instance__.__explicitlySet__.addAll(__explicitlySet__);
	 return __instance__;
 }",0,0,1,0
"public class TestNewPlanPushDownForeachFlatten {
	 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
	 public static void oneTimeSetup() throws Exception {
		 new File(""dummy"").delete();
	 }
	 static public class MyFilterFunc extends FilterFunc {
		 public Boolean exec(Tuple input) {
			 return false;
		 }
	 }
	 public void testErrorEmptyInput() throws Exception {
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( """" );
		 Assert.assertTrue( newLogicalPlan.getOperators().hasNext() == false );
	 }
	 public void testErrorNonForeachInput() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""store A into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 List<Operator> nexts = newLogicalPlan.getSuccessors( load );
		 Assert.assertTrue( nexts != null && nexts.size() == 1 );
	}
	 public void testForeachNoFlatten() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, $2;
		"" + ""C = order B by $0, $1;
		"" + ""D = store C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachNoSuccessors() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate flatten($1);
		"" + ""Store B into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
	 }
	 public void testForeachStreaming() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate flatten($1);
		"" + ""C = stream B through `"" + ""pc -l"" + ""`;
		"" + ""Store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
	 }
	 public void testForeachDistinct() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate flatten($1);
		"" + ""C = distinct B;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
	 }
	 public void testForeachForeach() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten(1);
		"" + ""C = foreach B generate $0;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachFilter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = filter B by $1 < 18;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachSplitOutput() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""split B into C if $1 < 18, D if $1 >= 18;
		"" + ""store C into 'output1';
		"" + ""store D into 'output2';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachLimit() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = limit B 10;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachUnion() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference);
		"" + ""D = union B, C;
		"" + ""store D into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator load = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) load = loads.get( 0 );
		 else load = loads.get( 1 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachCogroup() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference);
		"" + ""D = cogroup B by $0, C by $0;
		"" + ""store D into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator load = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) load = loads.get( 0 );
		 else load = loads.get( 1 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachGroupBy() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = group B by $0;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = order B by $0, $1;
		"" + ""D = store C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
		 foreach = newLogicalPlan.getSuccessors( sort ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)foreach ) );
	 }
	 public void testForeachSortNegative1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0 + 5, $1, flatten($2);
		"" + ""C = order B by $0, $1;
		"" + ""D = store C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachSortNegative2() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:tuple(x,y));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = order B by $0, $3;
		"" + ""D = store C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator foreach1 = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach1 instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach1 ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachFlattenAddedColumnSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, flatten(1);
		"" + ""C = order B by $0, $1;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachUDFSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, $1, "" + Identity.class.getName() + ""($2) ;
		"" + ""C = order B by $0, $1;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachCastSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate (chararray)$0, $1, flatten($2);
		"" + ""C = order B by $0, $1;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference);
		"" + ""D = cross B, C;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachCross1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""C = foreach B generate $0, $1, flatten($2);
		"" + ""D = cross A, C;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""B"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachCross2() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = foreach C generate $0, $1, flatten($2);
		"" + ""E = cross B, D;
		"" + ""F = limit E 10;
		"" + ""store F into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 Operator limit = newLogicalPlan.getPredecessors(store).get(0);
		 Operator cross = newLogicalPlan.getPredecessors(limit).get(0);
		 Assert.assertTrue( cross instanceof LOCross );
	 }
	 public void testForeachFlattenAddedColumnCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten(1);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = cross B, C;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachUDFCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, flatten($1), "" + Identity.class.getName() + ""($2) ;
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = cross B, C;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachCastCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, (int)$1, flatten( $2 );
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = cross B, C;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference);
		"" + ""D = join B by $0, C by $0 using 'replicated';
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachFRJoin1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""C = foreach B generate $0, $1, flatten($2);
		"" + ""D = join A by $0, C by $0 using 'replicated';
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""B"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachFRJoin2() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = foreach C generate $0, $1, flatten($2);
		"" + ""E = join B by $0, D by $0 using 'replicated';
		"" + ""F = limit E 10;
		"" + ""store F into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 Operator limit = newLogicalPlan.getPredecessors( store ).get( 0 );
		 Operator join = newLogicalPlan.getPredecessors( limit ).get( 0 );
		 Assert.assertTrue( join instanceof LOJoin );
	 }
	 public void testForeachFlattenAddedColumnFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten(1);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0 using 'replicated';
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachUDFFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, flatten($1), "" + Identity.class.getName() + ""($2) ;
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0 using 'replicated';
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachCastFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, (int)$1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0 using 'replicated';
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachInnerJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachInnerJoin1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""C = foreach B generate $0, $1, flatten($2);
		"" + ""D = join A by $0, C by $0;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""B"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachInnerJoin2() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = foreach C generate $0, $1, flatten($2);
		"" + ""E = join B by $0, D by $0;
		"" + ""F = limit E 10;
		"" + ""store F into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 Operator limit = newLogicalPlan.getPredecessors( store ).get( 0 );
		 Operator join = newLogicalPlan.getPredecessors( limit ).get( 0 );
		 Assert.assertTrue( join instanceof LOJoin );
	 }
	 public void testForeachFlattenAddedColumnInnerJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, $1, flatten(1);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachUDFInnerJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, flatten($1), "" + Identity.class.getName() + ""($2) ;
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachCastInnerJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa:(letter_grade, point_score));
		"" + ""B = foreach A generate $0, (int)$1, flatten($2);
		"" + ""C = load 'anotherfile' as (name, age, preference:(course_name, instructor));
		"" + ""D = join B by $0, C by $0;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( !OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 Assert.assertTrue( OptimizerUtils.hasFlatten( (LOForEach)op ) );
		 op = newLogicalPlan.getSuccessors( op ).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testForeachJoinRequiredField() throws Exception {
		 String query = ""A = load 'myfile' as (bg:bag{
		t:tuple(a0,a1)}
		);
		"" + ""B = FOREACH A generate flatten($0);
		"" + ""C = load '3.txt' AS (c0, c1);
		"" + ""D = JOIN B by a1, C by c1;
		"" + ""E = limit D 10;
		"" + ""store E into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 Operator limit = newLogicalPlan.getPredecessors( store ).get( 0 );
		 Operator join = newLogicalPlan.getPredecessors( limit ).get( 0 );
		 Assert.assertTrue( join instanceof LOJoin );
	 }
	 public void testForeachRequiredField() throws Exception {
		 String query = ""A = load 'myfile' as (b:bag{
		t:tuple(a0:chararray,a1:int)}
		);
		"" + ""B = foreach A generate flatten($0);
		"" + ""C = order B by $1 desc;
		"" + ""store C into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator foreach1 = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach1 instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach1 ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testForeachWithUserDefinedSchema() throws Exception {
		 String query = ""a = load '1.txt' as (a0:int, a1, a2:bag{
		t:(i1:int, i2:int)}
		);
		"" + ""b = load '2.txt' as (b0:int, b1);
		"" + ""c = foreach a generate a0, flatten(a2) as (q1, q2);
		"" + ""d = join c by a0, b by b0;
		"" + ""store d into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 LOForEach foreach = (LOForEach)newLogicalPlan.getPredecessors(store).get(0);
		 Assert.assertTrue(foreach.getSchema().getField(1).alias.equals(""q1""));
		 Assert.assertTrue(foreach.getSchema().getField(2).alias.equals(""q2""));
	 }
	 public void testForeachWithUserDefinedSchema2() throws Exception {
		 String query = ""a = load '1.txt' as (a0:chararray);
		"" + ""b = load '2.txt' as (b0:chararray);
		"" + ""c = foreach b generate flatten(STRSPLIT(b0)) as c0;
		"" + ""d = join c by (chararray)c0, a by a0;
		"" + ""store d into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 Operator op = newLogicalPlan.getPredecessors(store).get(0);
		 Assert.assertTrue(op instanceof LOJoin);
	 }
	 public void testForeachSortWithUserDefinedSchema() throws Exception {
		 String query = ""a = load '1.txt' as (a0:int, a1:bag{
		t:(i1:int, i2:int)}
		);
		"" + ""b = foreach a generate a0, flatten(a1) as (q1, q2);
		"" + ""c = order b by a0;
		"" + ""store c into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlanWithPruning( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Assert.assertTrue( ""Field \""a1\"" is dropped by ColumnMapKeyPrune"" + ""even though it should be stored"", ((LOLoad)load).getSchema().getField(""a1"") != null );
	 }
	 public void testForeachJoinWithUserDefinedSchemaAndPruning() throws Exception {
		 String query = ""a = load '1.txt' as (a0:int, a1, a2:bag{
		}
		);
		"" + ""b = load '2.txt' as (b0:int, b1);
		"" + ""c = foreach a generate a0, flatten(a2) as (q1, q2);
		"" + ""d = join c by a0, b by b0;
		"" + ""e = foreach d generate a0, q1, q2;
		"" + ""f = foreach e generate a0, (int)q1, (int)q2;
		"" + ""store f into 'output';
		"" ;
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlanWithPruning( query );
	 }
	 public class MyPlanOptimizerWithPruning extends LogicalPlanOptimizer {
		 protected MyPlanOptimizerWithPruning (OperatorPlan p, int iterations) {
			 super(p, iterations, new HashSet<String>());
			 addPlanTransformListener(new SchemaPatcher());
			 addPlanTransformListener(new ProjectionPatcher());
		 }
		 protected List<Set<Rule>> buildRuleSets() {
			 List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
			 Set<Rule> s = new HashSet<Rule>();
			 Rule r = new LoadTypeCastInserter( ""TypeCastInserter"" );
			 s.add(r);
			 ls.add(s);
			 s = new HashSet<Rule>();
			 r = new PushDownForEachFlatten( ""PushDownForEachFlatten"" );
			 s.add(r);
			 ls.add(s);
			 s = new HashSet<Rule>();
			 r = new ColumnMapKeyPrune( ""ColumnMapKeyPrune"" );
			 s.add(r);
			 ls.add(s);
			 return ls;
		 }
	 }
	 private LogicalPlan migrateAndOptimizePlanWithPruning(String query) throws Exception {
		 PigServer pigServer = new PigServer( pc );
		 LogicalPlan newLogicalPlan = Util.buildLp(pigServer, query);
		 PlanOptimizer optimizer = new MyPlanOptimizerWithPruning( newLogicalPlan, 3 );
		 optimizer.optimize();
		 return newLogicalPlan;
	 }
	 public class MyPlanOptimizer extends LogicalPlanOptimizer {
		 protected MyPlanOptimizer(OperatorPlan p, int iterations) {
			 super(p, iterations, new HashSet<String>());
		 }
		 protected List<Set<Rule>> buildRuleSets() {
			 List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
			 Set<Rule> s = new HashSet<Rule>();
			 Rule r = new LoadTypeCastInserter( ""TypeCastInserter"" );
			 s.add(r);
			 ls.add(s);
			 s = new HashSet<Rule>();
			 r = new PushDownForEachFlatten( ""PushDownForEachFlatten"" );
			 s.add(r);
			 ls.add(s);
			 return ls;
		 }
	 }
	 private LogicalPlan migrateAndOptimizePlan(String query) throws Exception {
		 PigServer pigServer = new PigServer( pc );
		 LogicalPlan newLogicalPlan = Util.buildLp(pigServer, query);
		 PlanOptimizer optimizer = new MyPlanOptimizer( newLogicalPlan, 3 );
		 optimizer.optimize();
		 return newLogicalPlan;
	 }
	 public void testNonDeterministicUdf() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = foreach A generate $0, RANDOM(), flatten($2);
		"" + ""C = order B by $0, $1;
		"" + ""D = store C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator load = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( load instanceof LOLoad );
		 Operator foreach = newLogicalPlan.getSuccessors( load ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 foreach = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( foreach instanceof LOForEach );
		 Operator sort = newLogicalPlan.getSuccessors( foreach ).get( 0 );
		 Assert.assertTrue( sort instanceof LOSort );
	 }
	 public void testOuterJoin() throws Exception {
		 String query = ""A = load 'A.txt' as (id:chararray, value:double);
		"" + ""B = load 'B.txt' as (id:chararray, name:chararray);
		"" + ""t1 = group A by id;
		"" + ""t2 = foreach t1 {
			 r1 = filter $1 by (value>1);
			 r2 = limit r1 1;
			 generate group as id, FLATTEN(r2.value) as value;
		 }
		"" + ""t3 = join B by id LEFT OUTER, t2 by id;
		"" + ""store t3 into 'output';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator store = newLogicalPlan.getSinks().get( 0 );
		 Operator join = newLogicalPlan.getPredecessors(store).get(0);
		 Assert.assertTrue( join instanceof LOJoin );
	 }
}",1,0,0,0
"public static String createFormat(String ext, String fmt1, String fmt2, String acodec, String vcodec, int width,int height) {
	StringBuffer sb = new StringBuffer();
	ext = nvl(ext);
	if (ext.length() > 0) {
		sb.append(ext.toUpperCase());
	}
	if (width > 0 && height > 0) {
		if (sb.length() > 0)sb.append("" "");
		sb.append(width + ""x"" + height);
	}
	acodec = nvl(acodec);
	if (acodec.contains(""none"")) {
		acodec = """";
	}
	vcodec = nvl(vcodec);
	if (vcodec.contains(""none"")) {
		vcodec = """";
	}
	if (acodec.length() > 0) {
		if (sb.length() > 0)sb.append("" "");
		sb.append(acodec);
	}
	if (vcodec.length() > 0) {
		if (sb.length() > 0) {
			if (acodec.length() > 0) {
				sb.append(""+"");
			}
			 else {
				sb.append("" "");
			}
		}
		sb.append(vcodec);
	}
	return sb.toString();
}",0,0,1,0
"public interface Channelizer extends ChannelHandler {
	 public void init(final ServerGremlinExecutor serverGremlinExecutor);
	 public default Object createIdleDetectionMessage() {
		 return null;
	 }
	 public default boolean supportsIdleMonitor() {
		 return false;
	 }
}",0,0,0,0
"public boolean equals(Object obj) {
	 if (obj == this) {
		 return true;
	 }
	 else if (obj == null || obj.getClass() != getClass()) {
		 return false;
	 }
	 CFMetaData rhs = (CFMetaData) obj;
	 return new EqualsBuilder() .append(tableName, rhs.tableName) .append(cfName, rhs.cfName) .append(cfType, rhs.cfType) .append(comparator, rhs.comparator) .append(subcolumnComparator, rhs.subcolumnComparator) .append(comment, rhs.comment) .append(rowCacheSize, rhs.rowCacheSize) .append(keyCacheSize, rhs.keyCacheSize) .append(readRepairChance, rhs.readRepairChance) .append(gcGraceSeconds, rhs.gcGraceSeconds) .append(minCompactionThreshold, rhs.minCompactionThreshold) .append(maxCompactionThreshold, rhs.maxCompactionThreshold) .append(cfId.intValue(), rhs.cfId.intValue()) .append(column_metadata, rhs.column_metadata) .append(rowCacheSavePeriodInSeconds, rhs.rowCacheSavePeriodInSeconds) .append(keyCacheSavePeriodInSeconds, rhs.keyCacheSavePeriodInSeconds) .append(memtableFlushAfterMins, rhs.memtableFlushAfterMins) .append(memtableThroughputInMb, rhs.memtableThroughputInMb) .append(memtableOperationsInMillions, rhs.memtableOperationsInMillions) .isEquals();
 }",0,0,0,0
"public abstract class NexmarkQueryTransform<T extends KnownSize> extends PTransform<PCollection<Event>, PCollection<T>> {
	 private transient PCollection<KV<Long, String>> sideInput = null;
	 protected NexmarkQueryTransform(String name) {
		 super(name);
	 }
	 public boolean needsSideInput() {
		 return false;
	 }
	 public void setSideInput(PCollection<KV<Long, String>> sideInput) {
		 this.sideInput = sideInput;
	 }
	 public PCollection<KV<Long, String>> getSideInput() {
		 return sideInput;
	 }
}",0,1,0,0
"public int showDialog(Vector accounts,String instruction,boolean showNewButton);",0,0,0,0
"public static DataSet convertWekaToNeurophDataset(Instances wekaDataset, int numInputs, int numOutputs) {
	 if (numInputs <= 0) {
		 throw new IllegalArgumentException(""Number of inputs in DataSet cannot be zero or negative!"");
	 }
	 if (numOutputs < 0) {
		 throw new IllegalArgumentException(""Number of outputs in DataSet cannot be negative!"");
	 }
	 if (numOutputs + numInputs < wekaDataset.numAttributes()) {
		 throw new IllegalArgumentException(""Number of outputs and inputs should be equal to number of attributes from data set!"");
	 }
	 DataSet neurophDataset=null;
	 if(numOutputs > 0){
		 neurophDataset = new DataSet(numInputs,numOutputs);
	 }
	else{
		 neurophDataset = new DataSet(numInputs);
	 }
	 List<Double> classValues = new ArrayList<Double>();
	 for(Instance inst: wekaDataset){
		 Double classDouble = inst.classValue();
		 if(!classValues.contains(classDouble)){
			 classValues.add(classDouble);
		 }
	 }
	 Enumeration en = wekaDataset.enumerateInstances();
	 while(en.hasMoreElements()) {
		 Instance instance = (Instance) en.nextElement();
		 double[] values = instance.toDoubleArray();
		 if(numOutputs == 0){
			 neurophDataset.addRow(values);
		 }
		 else {
			 double[] inputs = new double[numInputs];
			 double[] outputs = new double[numOutputs];
			 for(int k = 0;
			 k < values.length;
			 k++){
				 if(k < numInputs){
					 inputs[k] = values[k];
				 }
			 }
			 int k = 0;
			 for(Double entry : classValues){
				 if(entry.doubleValue() == instance.classValue()){
					 outputs[k] = 1;
				 }
				else{
					 outputs[k] = 0;
				 }
				 k++;
			 }
			 DataSetRow row = new DataSetRow(inputs, outputs);
			 row.setLabel(instance.stringValue(instance.classIndex()));
			 neurophDataset.addRow(row);
		 }
	 }
	 return neurophDataset;
 }",0,0,1,0
"private void rSerializeNode(Writer writer, Node node, String encoding, String currentIndent, int line, int column, int offset) throws DOMSerializerException {
	 boolean formatting = config.getFeature(DOMSerializerConfiguration.FORMAT_XML);
	 String str = """";
	 if (m_filter == null || m_filter.acceptNode(node) == 1) {
		 switch (node.getNodeType()) {
			 case Node.DOCUMENT_NODE: if (config.getFeature(DOMSerializerConfiguration.XML_DECLARATION)) {
				 String header = ""<?xml version=\""1.0\"""";
				 String realEncoding = (String)config.getParameter(DOMSerializerConfiguration.XML_ENCODING);
				 if (realEncoding == null) {
					 realEncoding = encoding;
				 }
				 if (realEncoding != null) header += "" encoding=\""""+realEncoding+""\"""";
				 header +=""?>"";
				 doWrite(writer, header, node, line, column, offset);
				 offset += header.length();
				 column += header.length();
				 if (!formatting) {
					 column = 0;
					 line += 1;
					 doWrite(writer, m_newLine, node, line, column, offset);
					 offset += m_newLine.length();
				 }
			 }
			 NodeList nodes = node.getChildNodes();
			 if (nodes != null) {
				 for (int i=0;
				 i<nodes.getLength();
				 i++) {
					 rSerializeNode(writer, nodes.item(i), encoding, currentIndent, line, column, offset);
				 }
			 }
			 break;
			 case Node.ELEMENT_NODE: String nodeName = node.getLocalName();
			 String nodePrefix = node.getPrefix();
			 if (nodeName == null) {
				 nodeName = node.getNodeName();
			 }
			 if (formatting) {
				 column = 0;
				 str = m_newLine + currentIndent;
				 doWrite(writer, str, node, line, column, offset);
				 column += currentIndent.length();
				 offset += str.length();
			 }
			 if (config.getFeature(DOMSerializerConfiguration.NAMESPACES) && nodePrefix != null) {
				 str = ""<"" + nodePrefix + "":"" + nodeName;
			 }
			 else {
				 str = ""<"" + nodeName;
			 }
			 doWrite(writer, str, node, line, column, offset);
			 column += str.length();
			 offset += str.length();
			 NamedNodeMap attr = node.getAttributes();
			 for (int i=0;
			 i<attr.getLength();
			 i++) {
				 Attr currentAttr = (Attr)attr.item(i);
				 boolean writeAttr = false;
				 if (config.getFeature(DOMSerializerConfiguration.DISCARD_DEFAULT_CONTENT)) {
					 if (currentAttr.getSpecified()) {
						 writeAttr = true;
					 }
				 }
				 else {
					 writeAttr = true;
				 }
				 if (writeAttr) {
					 str = "" "" + currentAttr.getNodeName() + ""=\"""" + normalizeCharacters(currentAttr.getNodeValue()) + ""\"""";
					 doWrite(writer, str, node, line, column, offset);
					 column += str.length();
					 offset += str.length();
				 }
			 }
			 NodeList children = node.getChildNodes();
			 if (children != null) {
				 boolean elementEmpty = false;
				 if (children.getLength() <= 0) {
					 elementEmpty = true;
				 }
				 else {
					 if (!config.getFeature(DOMSerializerConfiguration.WS_IN_ELEMENT_CONTENT)) {
						 boolean hasWSOnlyElements = true;
						 for(int i=0;
						 i<children.getLength();
						i++) {
							 hasWSOnlyElements = hasWSOnlyElements && children.item(i).getNodeType()==Node.TEXT_NODE && children.item(i).getNodeValue().trim().equals("""");
						 }
						 elementEmpty = formatting && hasWSOnlyElements;
					 }
				 }
				 if (!elementEmpty) {
					 str = "">"";
					 doWrite(writer, str, node, line, column, offset);
					 column += str.length();
					 offset += str.length();
					 String indentUnit = """";
					 if (formatting) {
						 if (config.getFeature(DOMSerializerConfiguration.SOFT_TABS)) {
							 Integer indentSize = (Integer)config.getParameter(""indent"");
							 if (indentSize != null) {
								 int size = indentSize.intValue();
								 StringBuffer buf = new StringBuffer();
								 for (int i=0;
								 i < size;
								 i++) {
									 buf.append("" "");
								 }
								 indentUnit = buf.toString();
							 }
						 }
						 else {
							 indentUnit = ""\t"";
						 }
					 }
					 for(int i=0;
					 i<children.getLength();
					i++) {
						 rSerializeNode(writer, children.item(i), encoding, currentIndent + indentUnit, line, column, offset);
					 }
					 if (formatting) {
						 boolean allText = true;
						 for(int i=0;
						 i<children.getLength();
						i++) {
							 if (!(children.item(i).getNodeType()==Node.TEXT_NODE) && !(children.item(i).getNodeType()==Node.CDATA_SECTION_NODE)) {
								 allText = false;
								 break;
							 }
						 }
						 if (!allText) {
							 column = 0;
							 str = m_newLine + currentIndent;
							 doWrite(writer, str, node, line, column, offset);
							 column += currentIndent.length();
							 offset += str.length();
						 }
					 }
					 if (config.getFeature(DOMSerializerConfiguration.NAMESPACES) && nodePrefix != null) {
						 str = ""</"" + nodePrefix + "":"" +nodeName + "">"";
					 }
					 else {
						 str = ""</"" + nodeName + "">"";
					 }
					 doWrite(writer, str, node, line, column, offset);
					 column += str.length();
					 offset += str.length();
				 }
				 else {
					 str = ""/>"";
					 doWrite(writer, str, node, line, column, offset);
					 column += str.length();
					 offset += str.length();
				 }
			 }
			 break;
			 case Node.TEXT_NODE: String text = node.getNodeValue();
			 if (!text.equals("""")) {
				 if (formatting) {
					 if (text.trim().equals("""")) {
						 return;
					 }
				 }
				 for (int i=0;
				 i<text.length();
				i++) {
					 str = text.substring(i, i+1);
					 if (str.equals(""&"")) {
						 str = ""&amp;
						"";
					 }
					 if (str.equals("">"")) {
						 str = ""&gt;
						"";
					 }
					 if (str.equals(""<"")) {
						 str = ""&lt;
						"";
					 }
					 if (str.equals(""\'"")) {
						 str = ""&apos;
						"";
					 }
					 if (str.equals(""\"""")) {
						 str = ""&quot;
						"";
					 }
					 if (str.equals(m_newLine)) {
						 line++;
						 column=0;
						 doWrite(writer, m_newLine, node, line, column, offset);
						 offset += m_newLine.length();
					 }
					 else {
						 doWrite(writer, str, node, line, column, offset);
						 column += str.length();
						 offset += str.length();
					 }
				 }
			 }
			 break;
			 case Node.CDATA_SECTION_NODE: if (config.getFeature(DOMSerializerConfiguration.CDATA_SECTIONS)) {
				 str = ""<![CDATA["";
				 doWrite(writer, str, node, line, column, offset);
				 column += str.length();
				 offset += str.length();
				 String cdata = node.getNodeValue();
				 for (int i=0;
				 i<cdata.length();
				 i++) {
					 str = cdata.substring(i, i+1);
					 if (str.equals(""]"") && i+3 < cdata.length() && cdata.substring(i, i+3).equals(""]]>"")) {
						 DefaultDOMLocator loc = new DefaultDOMLocator(node, line, column, offset, null);
						 if (config.getFeature(DOMSerializerConfiguration.SPLIT_CDATA)) {
							 i+=2;
							 str = ""]]]]>"";
							 str += ""<![CDATA[>"";
							 throwError(loc, ""cdata-sections-splitted"", DOMError.SEVERITY_WARNING, null);
						 }
						 else {
							 throwError(loc, ""invalid-data-in-cdata-section"", DOMError.SEVERITY_FATAL_ERROR, null);
						 }
					 }
					 if (str.equals(m_newLine)) {
						 line++;
						 column=0;
						 doWrite(writer, m_newLine, node, line, column, offset);
						 offset += m_newLine.length();
					 }
					 else {
						 doWrite(writer, str, node, line, column, offset);
						 column += str.length();
						 offset += str.length();
					 }
				 }
				 str = ""]]>"";
				 doWrite(writer, str, node, line, column, offset);
				 column += str.length();
				 offset += str.length();
			 }
			 else {
				 Node textNode = node.getOwnerDocument().createTextNode(node.getNodeValue());
				 rSerializeNode(writer, textNode, encoding, currentIndent, line, column, offset);
			 }
			 break;
			 case Node.COMMENT_NODE: if (config.getFeature(""comments"")) {
				 if (formatting) {
					 column = 0;
					 str = m_newLine + currentIndent;
					 doWrite(writer, str, node, line, column, offset);
					 column += currentIndent.length();
					 offset += str.length();
				 }
				 str = ""<!--""+node.getNodeValue()+""-->"";
				 doWrite(writer, str, node, line, column, offset);
				 column += str.length();
				 offset += str.length();
			 }
			 break;
			 case Node.PROCESSING_INSTRUCTION_NODE: if (formatting) {
				 column = 0;
				 str = m_newLine + currentIndent;
				 doWrite(writer, str, node, line, column, offset);
				 column += currentIndent.length();
				 offset += str.length();
			 }
			 str = ""<?"" + node.getNodeName() + "" "" + node.getNodeValue() + ""?>"";
			 doWrite(writer, str, node, line, column, offset);
			 column += str.length();
			 offset += str.length();
			 break;
			 case Node.ENTITY_REFERENCE_NODE: str = ""&"" + node.getNodeName() + "";
			"";
			 doWrite(writer, str, node, line, column, offset);
			 column += str.length();
			 offset += str.length();
			 break;
			 case Node.DOCUMENT_TYPE_NODE: DocumentType docType = (DocumentType)node;
			 if (formatting) {
				 column = 0;
				 str = m_newLine + currentIndent;
				 doWrite(writer, str, node, line, column, offset);
				 column += currentIndent.length();
				 offset += str.length();
			 }
			 str = ""<!DOCTYPE "" + docType.getName();
			 doWrite(writer, str, node, line, column, offset);
			 column += str.length();
			 offset += str.length();
			 if (docType.getPublicId() != null) {
				 str = "" PUBLIC \"""" + docType.getPublicId() + ""\"" "";
				 doWrite(writer, str, node, line, column, offset);
				 column += str.length();
				 offset += str.length();
			 }
			 if (docType.getSystemId() != null) {
				 if (docType.getPublicId() == null) {
					 str = "" SYSTEM "";
				 }
				 else {
					 str = """";
				 }
				 str += ""\"""" + docType.getSystemId() + ""\"""";
				 doWrite(writer, str, node, line, column, offset);
				 column += str.length();
				 offset += str.length();
			 }
			 String internalSubset = docType.getInternalSubset();
			 if (internalSubset != null && !internalSubset.equals("""")) {
				 str = "" [ ""+internalSubset+"" ]"";
				 doWrite(writer, str, node, line, column, offset);
				 column += str.length();
				 offset += str.length();
			 }
			 str = "">"";
			 doWrite(writer, str, node, line, column, offset);
			 column += str.length();
			 offset += str.length();
			 if (!formatting) {
				 column = 0;
				 str = m_newLine + currentIndent;
				 doWrite(writer, str, node, line, column, offset);
				 column += currentIndent.length();
				 offset += str.length();
			 }
			 break;
		 }
	 }
 }",0,0,1,0
"public class EndSelectionEvent extends SelectionEvent{
	 public EndSelectionEvent(TransformerImpl processor, Node sourceNode, ElemTemplateElement styleNode, String attributeName, XPath xpath, XObject selection) {
		 super(processor, sourceNode, styleNode, attributeName, xpath, selection);
	 }
}",0,0,0,0
"public class Token{
	 public static final boolean printTrees = false;
	 static final boolean printICode = false;
	 static final boolean printNames = printTrees || printICode;
	 public final static int ERROR = -1, EOF = 0, EOL = 1, FIRST_BYTECODE_TOKEN = 2, ENTERWITH = 2, LEAVEWITH = 3, RETURN = 4, GOTO = 5, IFEQ = 6, IFNE = 7, SETNAME = 8, BITOR = 9, BITXOR = 10, BITAND = 11, EQ = 12, NE = 13, LT = 14, LE = 15, GT = 16, GE = 17, LSH = 18, RSH = 19, URSH = 20, ADD = 21, SUB = 22, MUL = 23, DIV = 24, MOD = 25, NOT = 26, BITNOT = 27, POS = 28, NEG = 29, NEW = 30, DELPROP = 31, TYPEOF = 32, GETPROP = 33, SETPROP = 34, GETELEM = 35, SETELEM = 36, CALL = 37, NAME = 38, NUMBER = 39, STRING = 40, NULL = 41, THIS = 42, FALSE = 43, TRUE = 44, SHEQ = 45, SHNE = 46, REGEXP = 47, BINDNAME = 48, THROW = 49, RETHROW = 50, IN = 51, INSTANCEOF = 52, LOCAL_LOAD = 53, GETVAR = 54, SETVAR = 55, CATCH_SCOPE = 56, ENUM_INIT_KEYS = 57, ENUM_INIT_VALUES = 58, ENUM_NEXT = 59, ENUM_ID = 60, THISFN = 61, RETURN_RESULT = 62, ARRAYLIT = 63, OBJECTLIT = 64, GET_REF = 65, SET_REF = 66, DEL_REF = 67, REF_CALL = 68, REF_SPECIAL = 69, DEFAULTNAMESPACE = 70, ESCXMLATTR = 71, ESCXMLTEXT = 72, REF_MEMBER = 73, REF_NS_MEMBER = 74, REF_NAME = 75, REF_NS_NAME = 76;
	 public final static int LAST_BYTECODE_TOKEN = REF_NS_NAME, TRY = 77, SEMI = 78, LB = 79, RB = 80, LC = 81, RC = 82, LP = 83, RP = 84, COMMA = 85, ASSIGN = 86, ASSIGN_BITOR = 87, ASSIGN_BITXOR = 88, ASSIGN_BITAND = 89, ASSIGN_LSH = 90, ASSIGN_RSH = 91, ASSIGN_URSH = 92, ASSIGN_ADD = 93, ASSIGN_SUB = 94, ASSIGN_MUL = 95, ASSIGN_DIV = 96, ASSIGN_MOD = 97;
	 public final static int FIRST_ASSIGN = ASSIGN, LAST_ASSIGN = ASSIGN_MOD, HOOK = 98, COLON = 99, OR = 100, AND = 101, INC = 102, DEC = 103, DOT = 104, FUNCTION = 105, EXPORT = 106, IMPORT = 107, IF = 108, ELSE = 109, SWITCH = 110, CASE = 111, DEFAULT = 112, WHILE = 113, DO = 114, FOR = 115, BREAK = 116, CONTINUE = 117, VAR = 118, WITH = 119, CATCH = 120, FINALLY = 121, VOID = 122, RESERVED = 123, EMPTY = 124, BLOCK = 125, LABEL = 126, TARGET = 127, LOOP = 128, EXPR_VOID = 129, EXPR_RESULT = 130, JSR = 131, SCRIPT = 132, TYPEOFNAME = 133, USE_STACK = 134, SETPROP_OP = 135, SETELEM_OP = 136, LOCAL_BLOCK = 137, SET_REF_OP = 138, DOTDOT = 139, COLONCOLON = 140, XML = 141, DOTQUERY = 142, XMLATTR = 143, XMLEND = 144, TO_OBJECT = 145, TO_DOUBLE = 146, GET = 147, SET = 148, CONST = 149, SETCONST = 150, SETCONSTVAR = 151, LAST_TOKEN = 152;
	 public static String name(int token) {
		 if (!printNames) {
			 return String.valueOf(token);
		 }
		 switch (token) {
			 case ERROR: return ""ERROR"";
			 case EOF: return ""EOF"";
			 case EOL: return ""EOL"";
			 case ENTERWITH: return ""ENTERWITH"";
			 case LEAVEWITH: return ""LEAVEWITH"";
			 case RETURN: return ""RETURN"";
			 case GOTO: return ""GOTO"";
			 case IFEQ: return ""IFEQ"";
			 case IFNE: return ""IFNE"";
			 case SETNAME: return ""SETNAME"";
			 case BITOR: return ""BITOR"";
			 case BITXOR: return ""BITXOR"";
			 case BITAND: return ""BITAND"";
			 case EQ: return ""EQ"";
			 case NE: return ""NE"";
			 case LT: return ""LT"";
			 case LE: return ""LE"";
			 case GT: return ""GT"";
			 case GE: return ""GE"";
			 case LSH: return ""LSH"";
			 case RSH: return ""RSH"";
			 case URSH: return ""URSH"";
			 case ADD: return ""ADD"";
			 case SUB: return ""SUB"";
			 case MUL: return ""MUL"";
			 case DIV: return ""DIV"";
			 case MOD: return ""MOD"";
			 case NOT: return ""NOT"";
			 case BITNOT: return ""BITNOT"";
			 case POS: return ""POS"";
			 case NEG: return ""NEG"";
			 case NEW: return ""NEW"";
			 case DELPROP: return ""DELPROP"";
			 case TYPEOF: return ""TYPEOF"";
			 case GETPROP: return ""GETPROP"";
			 case SETPROP: return ""SETPROP"";
			 case GETELEM: return ""GETELEM"";
			 case SETELEM: return ""SETELEM"";
			 case CALL: return ""CALL"";
			 case NAME: return ""NAME"";
			 case NUMBER: return ""NUMBER"";
			 case STRING: return ""STRING"";
			 case NULL: return ""NULL"";
			 case THIS: return ""THIS"";
			 case FALSE: return ""FALSE"";
			 case TRUE: return ""TRUE"";
			 case SHEQ: return ""SHEQ"";
			 case SHNE: return ""SHNE"";
			 case REGEXP: return ""OBJECT"";
			 case BINDNAME: return ""BINDNAME"";
			 case THROW: return ""THROW"";
			 case RETHROW: return ""RETHROW"";
			 case IN: return ""IN"";
			 case INSTANCEOF: return ""INSTANCEOF"";
			 case LOCAL_LOAD: return ""LOCAL_LOAD"";
			 case GETVAR: return ""GETVAR"";
			 case SETVAR: return ""SETVAR"";
			 case CATCH_SCOPE: return ""CATCH_SCOPE"";
			 case ENUM_INIT_KEYS: return ""ENUM_INIT_KEYS"";
			 case ENUM_INIT_VALUES: return ""ENUM_INIT_VALUES"";
			 case ENUM_NEXT: return ""ENUM_NEXT"";
			 case ENUM_ID: return ""ENUM_ID"";
			 case THISFN: return ""THISFN"";
			 case RETURN_RESULT: return ""RETURN_RESULT"";
			 case ARRAYLIT: return ""ARRAYLIT"";
			 case OBJECTLIT: return ""OBJECTLIT"";
			 case GET_REF: return ""GET_REF"";
			 case SET_REF: return ""SET_REF"";
			 case DEL_REF: return ""DEL_REF"";
			 case REF_CALL: return ""REF_CALL"";
			 case REF_SPECIAL: return ""REF_SPECIAL"";
			 case DEFAULTNAMESPACE:return ""DEFAULTNAMESPACE"";
			 case ESCXMLTEXT: return ""ESCXMLTEXT"";
			 case ESCXMLATTR: return ""ESCXMLATTR"";
			 case REF_MEMBER: return ""REF_MEMBER"";
			 case REF_NS_MEMBER: return ""REF_NS_MEMBER"";
			 case REF_NAME: return ""REF_NAME"";
			 case REF_NS_NAME: return ""REF_NS_NAME"";
			 case TRY: return ""TRY"";
			 case SEMI: return ""SEMI"";
			 case LB: return ""LB"";
			 case RB: return ""RB"";
			 case LC: return ""LC"";
			 case RC: return ""RC"";
			 case LP: return ""LP"";
			 case RP: return ""RP"";
			 case COMMA: return ""COMMA"";
			 case ASSIGN: return ""ASSIGN"";
			 case ASSIGN_BITOR: return ""ASSIGN_BITOR"";
			 case ASSIGN_BITXOR: return ""ASSIGN_BITXOR"";
			 case ASSIGN_BITAND: return ""ASSIGN_BITAND"";
			 case ASSIGN_LSH: return ""ASSIGN_LSH"";
			 case ASSIGN_RSH: return ""ASSIGN_RSH"";
			 case ASSIGN_URSH: return ""ASSIGN_URSH"";
			 case ASSIGN_ADD: return ""ASSIGN_ADD"";
			 case ASSIGN_SUB: return ""ASSIGN_SUB"";
			 case ASSIGN_MUL: return ""ASSIGN_MUL"";
			 case ASSIGN_DIV: return ""ASSIGN_DIV"";
			 case ASSIGN_MOD: return ""ASSIGN_MOD"";
			 case HOOK: return ""HOOK"";
			 case COLON: return ""COLON"";
			 case OR: return ""OR"";
			 case AND: return ""AND"";
			 case INC: return ""INC"";
			 case DEC: return ""DEC"";
			 case DOT: return ""DOT"";
			 case FUNCTION: return ""FUNCTION"";
			 case EXPORT: return ""EXPORT"";
			 case IMPORT: return ""IMPORT"";
			 case IF: return ""IF"";
			 case ELSE: return ""ELSE"";
			 case SWITCH: return ""SWITCH"";
			 case CASE: return ""CASE"";
			 case DEFAULT: return ""DEFAULT"";
			 case WHILE: return ""WHILE"";
			 case DO: return ""DO"";
			 case FOR: return ""FOR"";
			 case BREAK: return ""BREAK"";
			 case CONTINUE: return ""CONTINUE"";
			 case VAR: return ""VAR"";
			 case WITH: return ""WITH"";
			 case CATCH: return ""CATCH"";
			 case FINALLY: return ""FINALLY"";
			 case RESERVED: return ""RESERVED"";
			 case EMPTY: return ""EMPTY"";
			 case BLOCK: return ""BLOCK"";
			 case LABEL: return ""LABEL"";
			 case TARGET: return ""TARGET"";
			 case LOOP: return ""LOOP"";
			 case EXPR_VOID: return ""EXPR_VOID"";
			 case EXPR_RESULT: return ""EXPR_RESULT"";
			 case JSR: return ""JSR"";
			 case SCRIPT: return ""SCRIPT"";
			 case TYPEOFNAME: return ""TYPEOFNAME"";
			 case USE_STACK: return ""USE_STACK"";
			 case SETPROP_OP: return ""SETPROP_OP"";
			 case SETELEM_OP: return ""SETELEM_OP"";
			 case LOCAL_BLOCK: return ""LOCAL_BLOCK"";
			 case SET_REF_OP: return ""SET_REF_OP"";
			 case DOTDOT: return ""DOTDOT"";
			 case COLONCOLON: return ""COLONCOLON"";
			 case XML: return ""XML"";
			 case DOTQUERY: return ""DOTQUERY"";
			 case XMLATTR: return ""XMLATTR"";
			 case XMLEND: return ""XMLEND"";
			 case TO_OBJECT: return ""TO_OBJECT"";
			 case TO_DOUBLE: return ""TO_DOUBLE"";
			 case GET: return ""GET"";
			 case SET: return ""SET"";
			 case CONST: return ""CONST"";
			 case SETCONST: return ""SETCONST"";
		 }
		 throw new IllegalStateException(String.valueOf(token));
	 }
}",1,0,0,0
"claimer.public class SelectCommand extends BaseAxionCommand {
	 public SelectCommand() {
	 }
	 public void setSelect(List columns) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _select = columns;
	 }
	 public void addSelect(Selectable column) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _select.add(column);
	 }
	 public Selectable getSelect(int i) {
		 return (Selectable)(_select.get(i));
	 }
	 public void setSelect(int i, Selectable sel) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _select.set(i,sel);
	 }
	 public int getSelectCount() {
		 return _select.size();
	 }
	 public void setFrom(FromNode from) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _from = from;
	 }
	 public void addFrom(TableIdentifier table) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 if (_from == null) {
			 _from = new FromNode();
			 _from.setType(FromNode.TYPE_SINGLE);
		 }
		 if (_from.getLeft() == null) {
			 _from.setLeft(table);
		 }
		 else if (_from.getRight() == null) {
			 _from.setRight(table);
			 _from.setType(FromNode.TYPE_INNER);
		 }
		 else {
			 FromNode from = new FromNode();
			 from.setLeft(_from);
			 from.setRight(table);
			 from.setType(FromNode.TYPE_INNER);
			 _from = from;
		 }
	 }
	 public FromNode getFrom() {
		 return _from;
	 }
	 public TableIdentifier getFrom(int i) {
		 TableIdentifier[] tableIDs = _from.toTableArray();
		 return (tableIDs[i]);
	 }
	 public int getFromCount() {
		 return _from.getTableCount();
	 }
	 public void setWhere(WhereNode where) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _where = where;
	 }
	 public WhereNode getWhere() {
		 return _where;
	 }
	 public void setOrderBy(List orderby) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _orderBy = orderby;
	 }
	 public void addOrderBy(OrderNode orderby) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _orderBy.add(orderby);
	 }
	 public OrderNode getOrderBy(int i) {
		 return (OrderNode)(_orderBy.get(i));
	 }
	 public int getOrderByCount() {
		 return (null == _orderBy ? 0 : _orderBy.size());
	 }
	 public void setDistinct(boolean distinct) {
		 if(_resolved) {
			 throw new IllegalStateException(""Already resolved."");
		 }
		 _distinct = distinct;
	 }
	 public boolean getDistinct() {
		 return _distinct;
	 }
	 public void setLimit(Literal limit) {
		 _limit = limit;
	 }
	 public Literal getLimit() {
		 return _limit;
	 }
	 public void setOffset(Literal offset) {
		 _offset = offset;
	 }
	 public Literal getOffset() {
		 return _offset;
	 }
	 private TableIdentifier[] getFromArray() {
		 if (_from != null) {
			 return (_from.toTableArray());
		 }
		 return (null);
	 }
	 public AxionResultSet executeQuery(Database db) throws AxionException {
		 resolve(db);
		 if(_currentDatabase != db) {
			 processQuery(db);
		 }
		 else {
			 _rows.reset();
		 }
		 RowIterator rows = _rows;
		 if(_foundAggregateFunction) {
			 AggregateFunction vfn = (AggregateFunction)(getSelect(0));
			 SimpleRow row = new SimpleRow(1);
			 row.set(0,vfn.evaluate(new RowIteratorRowDecoratorIterator(rows,new RowDecorator(_colIdToFieldMap))));
			 SingleRowIterator fniter = new SingleRowIterator(row);
			 Selectable[] selarray = new Selectable[] {
			 new ColumnIdentifier(new TableIdentifier(),vfn.getName(),null,vfn.getDataType()) }
			;
			 HashMap fieldmap = new HashMap();
			 fieldmap.put(selarray[0],new Integer(0));
			 return new AxionResultSet(new RowIteratorRowDecoratorIterator(fniter,new RowDecorator(fieldmap)),selarray);
		 }
		 else {
			 return new AxionResultSet(new RowIteratorRowDecoratorIterator(rows,new RowDecorator(_colIdToFieldMap)),_selected);
		 }
	 }
	 protected Iterator getBindVariableIterator() {
		 List list = new ArrayList();
		 for(int i=0;
		i<_select.size();
		i++) {
			 appendBindVariables(getSelect(i),list);
		 }
		 appendBindVariables(getWhere(),list);
		 appendBindVariables(getLimit(),list);
		 appendBindVariables(getOffset(),list);
		 return list.iterator();
	 }
	 private void processQuery(Database db) throws AxionException {
		 _currentDatabase = db;
		 _colIdToFieldMap = new HashMap();
		 _indexOffset = 0;
		 _literals = createLiteralList();
		 RowIterator rows = null;
		 _unappliedWhereNodes = processWhereTree(getWhere());
		 rows = processFromTree(_from, db);
		 Iterator unappliedWhereNodeIter = _unappliedWhereNodes.iterator();
		 while(unappliedWhereNodeIter.hasNext()) {
			 WhereNode node = (WhereNode)(unappliedWhereNodeIter.next());
			 rows = new FilteringRowIterator(rows, new RowDecorator(_colIdToFieldMap), node);
		 }
		 _selected = generateSelectArrayForResultSet(db);
		 if(_distinct) {
			 rows = new DistinctRowIterator(rows,_colIdToFieldMap, _selected);
		 }
		 if(getOrderByCount() > 0) {
			 ComparatorChain orderChain = generateOrderChain(_colIdToFieldMap);
			 ArrayList list = new ArrayList();
			 while(rows.hasNext()) {
				 list.add(rows.next());
			 }
			 Collections.sort(list, orderChain);
			 rows = new ListIteratorRowIterator(list.listIterator());
		 }
		 if(null != getLimit() || null != getOffset()) {
			 rows = new LimitingRowIterator(rows,getLimit(),getOffset());
		 }
		 _rows = rows;
	 }
	 private RowIterator processFromTree(FromNode from, Database db) throws AxionException {
		 TableIdentifier temp = null;
		 RowIterator leftiter = null;
		 RowIterator rightiter = null;
		 RowIterator literaliter = null;
		 RowIterator row = null;
		 int iterCount = 0;
		 int lcolpos = -1;
		 int rcolcount = -1;
		 ColumnIdentifier rcol = null;
		 ColumnIdentifier lcol = null;
		 if (from != null) {
			 WhereNode condition = from.getCondition();
			 if (from.getTableCount() > 1 && (from.getType() == FromNode.TYPE_INNER || from.getType() == FromNode.TYPE_LEFT)) {
				 if (from.getRight() instanceof TableIdentifier && condition != null && condition instanceof LeafWhereNode) {
					 TableIdentifier tid = (TableIdentifier) from.getRight();
					 lcol = (ColumnIdentifier) ((LeafWhereNode) condition).getLeft();
					 rcol = (ColumnIdentifier) ((LeafWhereNode) condition).getRight();
					 if (lcol.equals(rcol) == false) {
						 if (tid.equals(lcol.getTableIdentifier())) {
							 ColumnIdentifier tempcid = lcol;
							 lcol = rcol;
							 rcol = tempcid;
						 }
					 }
					 Table table = db.getTable(tid);
					 if (table.getIndexForColumn(table.getColumn(rcol.getName())) == null) {
						 lcol = null;
						 rcol = null;
					 }
				 }
			 }
			 if (condition != null) {
				 _applyWhereNodesAfterJoin = true;
			 }
		 }
		 if (from != null && from.getLeft() != null) {
			 Object leftChild = from.getLeft();
			 if (leftChild instanceof FromNode) {
				 leftiter = processFromTree((FromNode) leftChild, db);
				 if (lcol != null) {
					 lcolpos = ((Integer)_colIdToFieldMap.get(lcol)).intValue();
				 }
			 }
			 else if (leftChild instanceof TableIdentifier) {
				 temp = (TableIdentifier) from.getLeft();
				 Table left = db.getTable(temp);
				 if (left == null) {
					 throw new AxionException(""Table "" + temp + "" not found."");
				 }
				 if (lcol != null) {
					 lcolpos = left.getColumnIndex(lcol.getName());
				 }
				 leftiter = processTable(temp, db, lcol, 0);
			 }
			 else {
				 throw new AxionException(""From clause is badly formed"");
			 }
			 iterCount++;
		 }
		 if (from != null && from.getRight() != null) {
			 Object rightChild = from.getRight();
			 if (rightChild instanceof FromNode) {
				 rightiter = processFromTree((FromNode) rightChild, db);
			 }
			 else if (rightChild instanceof TableIdentifier) {
				 temp = (TableIdentifier) from.getRight();
				 Table right = db.getTable(temp);
				 if (right == null) {
					 throw new AxionException(""Table "" + temp + "" not found."");
				 }
				 rightiter = processTable(temp, db, rcol, 1);
				 rcolcount = right.getColumnCount();
			 }
			 else {
				 throw new AxionException(""From clause is badly formed"");
			 }
			 iterCount++;
		 }
		 if(null != _literals) {
			 Row litrow = new SimpleRow(_literals.size());
			 Iterator iter = _literals.iterator();
			 for(int i=0;
			iter.hasNext();
			i++) {
				 Literal literal = (Literal)iter.next();
				 _colIdToFieldMap.put(literal,new Integer(_indexOffset+i));
			 }
			 _indexOffset += _literals.size();
			 literaliter = new SingleRowIterator(litrow);
			 iterCount++;
			 _literals = null;
		 }
		 if (iterCount > 1) {
			 if (literaliter == null && rightiter instanceof ChangingIndexedRowIterator && from.getType() != FromNode.TYPE_RIGHT) {
				 IndexJoinedRowIterator joinedrow = new IndexJoinedRowIterator(lcolpos, rcolcount);
				 joinedrow.addRowIterator(leftiter);
				 joinedrow.addRowIterator(rightiter);
				 joinedrow.setJoinType(from.getType());
				 joinedrow.setJoinCondition(new RowDecorator(_colIdToFieldMap), from.getCondition());
				 row = joinedrow;
			 }
			 else {
				 SimpleJoinedRowIterator joinedrow = new SimpleJoinedRowIterator();
				 if (from.getType() == FromNode.TYPE_RIGHT) {
					 joinedrow.addRowIterator(rightiter);
					 joinedrow.addRowIterator(leftiter);
				 }
				 else {
					 if (leftiter != null) {
						 joinedrow.addRowIterator(leftiter);
					 }
					 if (rightiter != null) {
						 joinedrow.addRowIterator(rightiter);
					 }
				 }
				 if (literaliter != null) {
					 joinedrow.addRowIterator(literaliter);
				 }
				 joinedrow.setJoinType(from.getType());
				 if (rightiter != null && leftiter != null && from.getCondition() != null) {
					 joinedrow.setJoinCondition(new RowDecorator(_colIdToFieldMap), from.getCondition());
				 }
				 row = joinedrow;
			 }
		 }
		 else {
			 if (leftiter != null) {
				 row = leftiter;
			 }
			 if (literaliter != null) {
				 row = literaliter;
			 }
		 }
		 return (row);
	 }
	 private RowIterator processTable(TableIdentifier tableident, Database db, ColumnIdentifier col, int pos) throws AxionException {
		 Table table = db.getTable(tableident);
		 RowIterator tableiter = null;
		 Set whereNodesForTable = null;
		 if (col != null && pos == 1) {
			 Index index = table.getIndexForColumn(table.getColumn(col.getName()));
			 if (index != null) {
				 tableiter = new ChangingIndexedRowIterator(index, table, ComparisonOperator.EQUAL);
			 }
		 }
		 if (_applyWhereNodesAfterJoin == false) {
			 for (Iterator whereNodeIter = _unappliedWhereNodes.iterator();
			whereNodeIter.hasNext();
			) {
				 WhereNode node = (WhereNode) (whereNodeIter.next());
				 if (onlyReferencesTable(tableident,node)) {
					 if (null == tableiter) {
						 tableiter = table.getIndexedRows(node,true);
						 if(null == tableiter) {
							 if(null == whereNodesForTable) {
								 whereNodesForTable = new HashSet();
							 }
							 whereNodesForTable.add(node);
						 }
					 }
					 else {
						 if(null == whereNodesForTable) {
							 whereNodesForTable = new HashSet();
						 }
						 whereNodesForTable.add(node);
					 }
					 whereNodeIter.remove();
				 }
			 }
		 }
		 if(null == tableiter) {
			 tableiter = table.getRowIterator(true);
		 }
		 if(null != whereNodesForTable && !whereNodesForTable.isEmpty()) {
			 Map localmap = new HashMap();
			 populateColumnIdToFieldMap(localmap,tableident,0,db);
			 Iterator whereNodesForTableIter = whereNodesForTable.iterator();
			 while(whereNodesForTableIter.hasNext()) {
				 WhereNode node = (WhereNode)(whereNodesForTableIter.next());
				 tableiter = new FilteringRowIterator(tableiter, new RowDecorator(localmap), node);
			 }
		 }
		 populateColumnIdToFieldMap(_colIdToFieldMap, tableident, _indexOffset, db);
		 _indexOffset += table.getColumnCount();
		 return (tableiter);
	 }
	 private Selectable[] generateSelectArrayForResultSet(Database db) throws AxionException {
		 List list = new ArrayList(getSelectCount());
		 TableIdentifier[] tables = getFromArray();
		 for(int i=0;
		i<getSelectCount();
		i++) {
			 Selectable sel = getSelect(i);
			 if(sel instanceof ColumnIdentifier) {
				 ColumnIdentifier colid = (ColumnIdentifier)sel;
				 if(""*"".equals(colid.getName())) {
					 if(null == colid.getTableName()) {
						 for(int j=0;
						j<getFromCount();
						j++) {
							 TableIdentifier tableID = tables[j];
							 Table table = db.getTable(tableID);
							 for(Iterator iter = table.getColumnIdentifiers();
							 iter.hasNext();
							) {
								 ColumnIdentifier colId = (ColumnIdentifier)iter.next();
								 colId.setTableIdentifier(tableID);
								 list.add(colId);
							 }
						 }
					 }
					 else {
						 Table table = db.getTable(colid.getTableIdentifier());
						 for(Iterator iter = table.getColumnIdentifiers();
						iter.hasNext();
						) {
							 list.add(iter.next());
						 }
					 }
				 }
				 else {
					 list.add(colid);
				 }
			 }
			 else {
				 list.add(sel);
			 }
		 }
		 return(Selectable[])(list.toArray(new Selectable[list.size()]));
	 }
	 public int executeUpdate(Database database) throws AxionException {
		 throw new UnsupportedOperationException(""Use executeQuery, not executeUpdate."");
	 }
	 public boolean execute(Database database) throws AxionException {
		 setResultSet(executeQuery(database));
		 return (getResultSet() != null);
	 }
	 private void resolve(Database db) throws AxionException {
		 if(!_resolved) {
			 TableIdentifier[] tables = getFromArray();
			 for(int i=0;
			i<getSelectCount();
			i++) {
				 setSelect(i,db.resolveSelectable(getSelect(i),tables));
			 }
			 db.resolveFromNode(getFrom(), tables);
			 db.resolveWhereNode(getWhere(),tables);
			 if(null != _orderBy) {
				 for(int i=0;
				i<_orderBy.size();
				i++) {
					 OrderNode ob = (OrderNode)(_orderBy.get(i));
					 ob.setSelectable(db.resolveSelectable(ob.getSelectable(),tables));
				 }
			 }
			 _resolved = true;
			 boolean foundScalar = false;
			 for(int i=0;
			i<getSelectCount();
			i++) {
				 if(getSelect(i) instanceof AggregateFunction) {
					 if(foundScalar) {
						 throw new AxionException(""Can't select both scalar values and aggregate functions."");
					 }
					 else if(_foundAggregateFunction) {
						 throw new AxionException(""Currently can't select more than one aggregate function at a time."");
					 }
					 else {
						 _foundAggregateFunction = true;
					 }
				 }
				 else {
					 if(_foundAggregateFunction) {
						 throw new AxionException(""Can't select both scalar values and aggregate functions."");
					 }
					 foundScalar = true;
				 }
			 }
		 }
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 buf.append(""SELECT "");
		 if(_distinct) {
			 buf.append(""DISTINCT "");
		 }
		 {
			 Iterator iter = _select.iterator();
			 while(iter.hasNext()) {
				 buf.append(iter.next());
				 if(iter.hasNext()) {
					 buf.append("", "");
				 }
			 }
		 }
		 if (null != _from) {
			 buf.append("" FROM "");
			 buf.append(_from);
		 }
		 if(null != _where) {
			 buf.append("" WHERE "");
			 buf.append(_where);
		 }
		 if(null != _orderBy && !_orderBy.isEmpty()) {
			 buf.append("" ORDER BY "");
			 {
				 Iterator iter = _orderBy.iterator();
				 while(iter.hasNext()) {
					 buf.append(iter.next());
					 if(iter.hasNext()) {
						 buf.append("", "");
					 }
				 }
			 }
		 }
		 return buf.toString();
	 }
	 private List createLiteralList() throws AxionException{
		 List literals = null;
		 for(int i=0;
		i<this.getSelectCount();
		i++) {
			 if(getSelect(i) instanceof Literal) {
				 if(null == literals) {
					 literals = new ArrayList();
				 }
				 literals.add(this.getSelect(i));
			 }
		 }
		 return literals;
	 }
	 private boolean onlyReferencesTable(TableIdentifier table, WhereNode node) {
		 ReferencesOtherTablesWhereNodeVisitor v = new ReferencesOtherTablesWhereNodeVisitor(table);
		 v.visit(node);
		 return v.getResult();
	 }
	 private ComparatorChain generateOrderChain(Map indexMap) {
		 ComparatorChain chain = new ComparatorChain();
		 for(int i=0;
		i<getOrderByCount();
		i++) {
			 if(getOrderBy(i).isDescending()) {
				 chain.setReverseSort(i);
			 }
			 chain.addComparator(new RowComparator(getOrderBy(i).getSelectable(),new RowDecorator(indexMap)));
		 }
		 return chain;
	 }
	 private void populateColumnIdToFieldMap(Map indexMap, TableIdentifier tableIdent, int offset, Database db) throws AxionException {
		 Table table = db.getTable(tableIdent);
		 if(null == table) {
			 throw new AxionException(""Table "" + tableIdent + "" not found."");
		 }
		 for(int j=0,J=table.getColumnCount();
		j<J;
		j++) {
			 ColumnIdentifier id = null;
			 for(int k=0,K=getSelectCount();
			k<K;
			k++) {
				 Selectable sel = getSelect(k);
				 if(sel instanceof ColumnIdentifier) {
					 ColumnIdentifier cSel = (ColumnIdentifier)sel;
					 if(tableIdent.equals(cSel.getTableIdentifier()) && cSel.getName().equals(table.getColumn(j).getName())) {
						 id = cSel;
						 break;
					 }
				 }
			 }
			 if(null == id) {
				 id = new ColumnIdentifier(tableIdent, table.getColumn(j).getName());
			 }
			 indexMap.put(id, new Integer(offset + j));
		 }
	 }
	 private List _select = new ArrayList();
	 private FromNode _from = null;
	 private WhereNode _where = null;
	 private List _orderBy = new ArrayList();
	 private boolean _distinct = false;
	 private boolean _resolved = false;
	 private boolean _foundAggregateFunction = false;
	 private Literal _limit = null;
	 private Literal _offset = null;
	 private Database _currentDatabase = null;
	 private Map _colIdToFieldMap = null;
	 private int _indexOffset = 0;
	 private Set _unappliedWhereNodes = null;
	 private List _literals = null;
	 private RowIterator _rows = null;
	 private Selectable[] _selected = null;
	 private boolean _applyWhereNodesAfterJoin = false;
}",1,0,0,0
"public Set<String> getTables() {
	 return tables.keySet();
 }",0,0,0,0
"public class CliSessionState{
	 public String hostName;
	 public int thriftPort;
	 public boolean framed = true;
	 public boolean debug = false;
	 public String username;
	 public String password;
	 public String keyspace;
	 public boolean batch = false;
	 public String filename = """";
	 public int jmxPort = 7199;
	 public boolean verbose = false;
	 public int schema_mwt;
	 public InputStream in;
	 public PrintStream out;
	 public PrintStream err;
	 public CliSessionState() {
		 in = System.in;
		 out = System.out;
		 err = System.err;
	 }
	 public void setOut(PrintStream newOut) {
		 this.out = newOut;
	 }
	 public void setErr(PrintStream newErr) {
		 this.err = newErr;
	 }
	 public boolean inFileMode() {
		 return !this.filename.isEmpty();
	 }
	 public NodeProbe getNodeProbe() {
		 try {
			 return new NodeProbe(hostName, jmxPort);
		 }
		 catch (Exception e) {
			 err.printf(""WARNING: Could not connect to the JMX on %s:%d, information won't be shown.%n%n"", hostName, jmxPort);
		 }
		 return null;
	 }
}",0,0,0,0
"public void setEndTag(String s) {
	 myendTag = s;
 }",0,0,0,0
"InitializeParams get(String id) throws LanguageServerException {
	 InitializeParams initializeParams = new InitializeParams();
	 LOG.debug(""Initialize params constructing: started"");
	 Boolean locality = localityRegistry.get(id);
	 LOG.debug(""Locality: {
	}
	"", locality);
	 Integer processId = locality ? ProcessIdProvider.get() : null;
	 initializeParams.setProcessId(processId);
	 LOG.debug(""Process id: {
	}
	"", processId);
	 String projectsRoot = projectsRootRegistry.getOrNull(id);
	 String rootPath;
	 if (projectsRoot != null) {
		 rootPath = projectsRoot;
	 }
	 else {
		 rootPath = Paths.get(rootUri).toAbsolutePath().toString();
	 }
	 initializeParams.setRootPath(rootPath);
	 LOG.debug(""Root path: {
	}
	"", rootPath);
	 String rootUri;
	 if (projectsRoot != null) {
		 rootUri = Paths.get(projectsRoot).toUri().toString();
	 }
	 else {
		 rootUri = this.rootUri.toString();
	 }
	 initializeParams.setRootUri(rootUri);
	 LOG.debug(""Root URI: {
	}
	"", rootUri);
	 ClientCapabilities capabilities = ClientCapabilitiesProvider.get();
	 initializeParams.setCapabilities(capabilities);
	 LOG.debug(""Client capabilities: {
	}
	"", capabilities);
	 String clientName = ClientCapabilitiesProvider.CLIENT_NAME;
	 initializeParams.setClientName(clientName);
	 LOG.debug(""Client name: {
	}
	"", clientName);
	 LOG.debug(""Initialize params constructing: finished"");
	 return initializeParams;
 }",0,0,1,0
"public class WicketTreeModel extends GenericBaseModel<TreeModel>{
	protected TreeModel createSerializableVersionOf(TreeModel object){
		return object;
	}
}",0,0,0,0
"public class RandomForestClassifierTrainer extends RandomForestTrainer<ObjectHistogram<BootstrappedVector>, GiniHistogram, RandomForestClassifierTrainer> {
	 private Map<Double, Integer> lblMapping = new HashMap<>();
	 public RandomForestClassifierTrainer(List<FeatureMeta> meta) {
		 super(meta);
	 }
	 protected RandomForestClassifierTrainer instance() {
		 return this;
	 }
	 protected boolean init(Dataset<EmptyContext, BootstrappedDatasetPartition> dataset) {
		 Set<Double> uniqLabels = dataset.compute( x -> {
			 Set<Double> labels = new HashSet<>();
			 for (int i = 0;
			 i < x.getRowsCount();
			 i++) labels.add(x.getRow(i).label());
			 return labels;
		 }
		, (l, r) -> {
			 if (l == null) return r;
			 if (r == null) return l;
			 Set<Double> lbls = new HashSet<>();
			 lbls.addAll(l);
			 lbls.addAll(r);
			 return lbls;
		 }
		 );
		 if(uniqLabels == null) return false;
		 int i = 0;
		 for (Double label : uniqLabels) lblMapping.put(label, i++);
		 return super.init(dataset);
	 }
	 protected ModelsComposition buildComposition(List<TreeRoot> models) {
		 return new ModelsComposition(models, new OnMajorityPredictionsAggregator());
	 }
	 protected ImpurityHistogramsComputer<GiniHistogram> createImpurityHistogramsComputer() {
		 return new GiniHistogramsComputer(lblMapping);
	 }
	 protected LeafValuesComputer<ObjectHistogram<BootstrappedVector>> createLeafStatisticsAggregator() {
		 return new ClassifierLeafValuesComputer(lblMapping);
	 }
	 public RandomForestClassifierTrainer withEnvironmentBuilder(LearningEnvironmentBuilder envBuilder) {
		 return (RandomForestClassifierTrainer)super.withEnvironmentBuilder(envBuilder);
	 }
}",0,0,0,0
"private void handleStateLeaving(InetAddress endpoint, String[] pieces) {
	 assert pieces.length == 2;
	 String moveValue = pieces[1];
	 Token token = getPartitioner().getTokenFactory().fromString(moveValue);
	 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" state leaving, token "" + token);
	 if (!tokenMetadata_.isMember(endpoint)) {
		 logger_.info(""Node "" + endpoint + "" state jump to leaving"");
		 tokenMetadata_.updateNormalToken(token, endpoint);
	 }
	 else if (!tokenMetadata_.getToken(endpoint).equals(token)) {
		 logger_.warn(""Node "" + endpoint + "" 'leaving' token mismatch. Long network partition?"");
		 tokenMetadata_.updateNormalToken(token, endpoint);
	 }
	 tokenMetadata_.addLeavingEndpoint(endpoint);
	 calculatePendingRanges();
 }",0,0,0,0
"public interface ErrorCarryingFrameBody extends FrameBody{
	 Error getError();
}",0,0,0,0
"public abstract class JenaConnection implements Connection {
	 private static final Logger LOGGER = LoggerFactory.getLogger(JenaConnection.class);
	 public static final int DEFAULT_HOLDABILITY = ResultSet.CLOSE_CURSORS_AT_COMMIT;
	 public final static boolean DEFAULT_AUTO_COMMIT = true;
	 public final static int DEFAULT_ISOLATION_LEVEL = TRANSACTION_NONE;
	 private Properties clientInfo = new Properties();
	 private int holdability = DEFAULT_HOLDABILITY;
	 private SQLWarning warnings = null;
	 private boolean autoCommit = DEFAULT_AUTO_COMMIT;
	 private int isolationLevel = DEFAULT_ISOLATION_LEVEL;
	 private int compatibilityLevel = JdbcCompatibility.DEFAULT;
	 private List<Statement> statements = new ArrayList<>();
	 private List<CommandPreProcessor> preProcessors = new ArrayList<>();
	 private List<ResultsPostProcessor> postProcessors = new ArrayList<>();
	 public JenaConnection(int holdability, boolean autoCommit, int transactionLevel, int compatibilityLevel) throws SQLException {
		 this.checkHoldability(holdability);
		 this.holdability = holdability;
		 this.setAutoCommit(autoCommit);
		 this.setTransactionIsolation(transactionLevel);
		 this.compatibilityLevel = JdbcCompatibility.normalizeLevel(compatibilityLevel);
	 }
	 public int getJdbcCompatibilityLevel() {
		 return this.compatibilityLevel;
	 }
	 public void setJdbcCompatibilityLevel(int level) {
		 this.compatibilityLevel = JdbcCompatibility.normalizeLevel(level);
	 }
	 public final void addPreProcessor(CommandPreProcessor preProcessor) {
		 if (preProcessor == null) return;
		 this.preProcessors.add(preProcessor);
	 }
	 public final void addPostProcessor(ResultsPostProcessor postProcessor) {
		 if (postProcessor == null) return;
		 this.postProcessors.add(postProcessor);
	 }
	 public final void insertPreProcessor(int index, CommandPreProcessor preProcessor) {
		 if (preProcessor == null) return;
		 this.preProcessors.add(index, preProcessor);
	 }
	 public final void insertPostProcessor(int index, ResultsPostProcessor postProcessor) {
		 if (postProcessor == null) return;
		 this.postProcessors.add(index, postProcessor);
	 }
	 public final void removePreProcessor(CommandPreProcessor preProcessor) {
		 if (preProcessor == null) return;
		 this.preProcessors.remove(preProcessor);
	 }
	 public final void removePostProcessor(ResultsPostProcessor postProcessor) {
		 if (postProcessor == null) return;
		 this.postProcessors.remove(postProcessor);
	 }
	 public final void removePreProcessor(int index) {
		 this.preProcessors.remove(index);
	 }
	 public final void removePostProcessor(int index) {
		 this.postProcessors.remove(index);
	 }
	 public final void clearPreProcessors() {
		 this.preProcessors.clear();
	 }
	 public final void clearPostProcessors() {
		 this.postProcessors.clear();
	 }
	 public final Iterator<CommandPreProcessor> getPreProcessors() {
		 return this.preProcessors.iterator();
	 }
	 public final Iterator<ResultsPostProcessor> getPostProcessors() {
		 return this.postProcessors.iterator();
	 }
	 public final String applyPreProcessors(String text) throws SQLException {
		 for (CommandPreProcessor preProcessor : this.preProcessors) {
			 if (preProcessor == null) continue;
			 text = preProcessor.preProcessCommandText(text);
		 }
		 return text;
	 }
	 public final Query applyPreProcessors(Query q) throws SQLException {
		 for (CommandPreProcessor preProcessor : this.preProcessors) {
			 if (preProcessor == null) continue;
			 q = preProcessor.preProcessQuery(q);
		 }
		 return q;
	 }
	 public final UpdateRequest applyPreProcessors(UpdateRequest u) throws SQLException {
		 for (CommandPreProcessor preProcessor : this.preProcessors) {
			 if (preProcessor == null) continue;
			 u = preProcessor.preProcessUpdate(u);
		 }
		 return u;
	 }
	 public final org.apache.jena.query.ResultSet applyPostProcessors(org.apache.jena.query.ResultSet results) throws SQLException {
		 for (ResultsPostProcessor postProcessor : this.postProcessors) {
			 if (postProcessor == null) continue;
			 results = postProcessor.postProcessResults(results);
		 }
		 return results;
	 }
	 public final Iterator<Triple> applyPostProcessors(Iterator<Triple> triples) throws SQLException {
		 for (ResultsPostProcessor postProcessor : this.postProcessors) {
			 if (postProcessor == null) continue;
			 triples = postProcessor.postProcessResults(triples);
		 }
		 return triples;
	 }
	 public final boolean applyPostProcessors(boolean result) throws SQLException {
		 for (ResultsPostProcessor postProcessor : this.postProcessors) {
			 if (postProcessor == null) continue;
			 result = postProcessor.postProcessResults(result);
		 }
		 return result;
	 }
	 public final SelectResultsMetadata applyPostProcessors(SelectResultsMetadata metadata) throws SQLException {
		 for (ResultsPostProcessor postProcessor : this.postProcessors) {
			 if (postProcessor == null) continue;
			 metadata = postProcessor.postProcessResultsMetadata(metadata);
		 }
		 return metadata;
	 }
	 public final TripleResultsMetadata applyPostProcessors(TripleResultsMetadata metadata) throws SQLException {
		 for (ResultsPostProcessor postProcessor : this.postProcessors) {
			 if (postProcessor == null) continue;
			 metadata = postProcessor.postProcessResultsMetadata(metadata);
		 }
		 return metadata;
	 }
	 public final AskResultsMetadata applyPostProcessors(AskResultsMetadata metadata) throws SQLException {
		 for (ResultsPostProcessor postProcessor : this.postProcessors) {
			 if (postProcessor == null) continue;
			 metadata = postProcessor.postProcessResultsMetadata(metadata);
		 }
		 return metadata;
	 }
	 public boolean isWrapperFor(Class<?> arg0) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T unwrap(Class<T> arg0) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void clearWarnings() {
		 this.warnings = null;
	 }
	 public final void close() throws SQLException {
		 try {
			 LOGGER.info(""Closing connection..."");
			 this.closeStatements();
		 }
		 finally {
			 this.closeInternal();
			 LOGGER.info(""Connection was closed"");
		 }
	 }
	 private void closeStatements() throws SQLException {
		 synchronized (this.statements) {
			 if (this.statements.size() > 0) {
				 LOGGER.info(""Attempting to close "" + this.statements.size() + "" open statements"");
				 for (Statement stmt : this.statements) {
					 stmt.close();
				 }
				 LOGGER.info(""All open statements were closed"");
				 this.statements.clear();
			 }
		 }
	 }
	 protected abstract void closeInternal() throws SQLException;
	 public void commit() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot commit on a closed connection"");
		 try {
			 LOGGER.info(""Attempting to commit a transaction..."");
			 this.commitInternal();
			 LOGGER.info(""Transaction was committed"");
			 if (this.holdability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
				 LOGGER.info(""Holdability set to CLOSE_CURSORS_AT_COMMIT so closing open statements"");
				 this.closeStatements();
			 }
		 }
		 catch (SQLException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 LOGGER.error(""Unexpected error in transaction commit"", e);
			 throw new SQLException(""Unexpected error committing transaction"", e);
		 }
	 }
	 protected abstract void commitInternal() throws SQLException;
	 public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Blob createBlob() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Clob createClob() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public NClob createNClob() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLXML createSQLXML() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public final Statement createStatement() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
	 }
	 public final Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.createStatement(resultSetType, resultSetConcurrency, this.getHoldability());
	 }
	 public final Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 JenaStatement stmt = this.createStatementInternal(resultSetType, resultSetConcurrency, resultSetHoldability);
		 synchronized (this.statements) {
			 this.statements.add(stmt);
		 }
		 return stmt;
	 }
	 protected abstract JenaStatement createStatementInternal(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException;
	 public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public boolean getAutoCommit() {
		 return this.autoCommit;
	 }
	 public String getCatalog() {
		 return JenaMetadata.DEFAULT_CATALOG;
	 }
	 public Properties getClientInfo() {
		 return this.clientInfo;
	 }
	 public String getClientInfo(String name) {
		 return this.clientInfo.getProperty(name);
	 }
	 public int getHoldability() {
		 return this.holdability;
	 }
	 public abstract DatabaseMetaData getMetaData() throws SQLException;
	 public int getTransactionIsolation() {
		 return this.isolationLevel;
	 }
	 public Map<String, Class<?>> getTypeMap() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLWarning getWarnings() {
		 return this.warnings;
	 }
	 public abstract boolean isClosed() throws SQLException;
	 public abstract boolean isReadOnly() throws SQLException;
	 public abstract boolean isValid(int timeout) throws SQLException;
	 public String nativeSQL(String sql) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public CallableStatement prepareCall(String sql) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public PreparedStatement prepareStatement(String sql) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
	 }
	 public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.prepareStatement(sql);
	 }
	 public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.prepareStatement(sql);
	 }
	 public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.prepareStatement(sql);
	 }
	 public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.prepareStatement(sql, resultSetType, resultSetConcurrency, this.holdability);
	 }
	 public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot create a statement after the connection was closed"");
		 return this.createPreparedStatementInternal(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
	 }
	 protected abstract JenaPreparedStatement createPreparedStatementInternal(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException;
	 public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void rollback() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Cannot rollback on a closed connection"");
		 try {
			 LOGGER.info(""Attempting to rollback a transaction..."");
			 this.rollbackInternal();
			 LOGGER.info(""Transaction was rolled back"");
			 if (this.holdability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
				 LOGGER.info(""Holdability is set to CLOSE_CURSORS_AT_COMMIT so closing open statements"");
				 this.closeStatements();
			 }
		 }
		 catch (SQLException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 throw new SQLException(""Unexpected error rolling back transaction"", e);
		 }
	 }
	 protected abstract void rollbackInternal() throws SQLException;
	 public void rollback(Savepoint savepoint) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setAutoCommit(boolean autoCommit) {
		 this.autoCommit = autoCommit;
	 }
	 public void setCatalog(String catalog) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setClientInfo(Properties properties) {
		 this.clientInfo = properties;
	 }
	 public void setClientInfo(String name, String value) {
		 this.clientInfo.put(name, value);
	 }
	 public void setHoldability(int holdability) throws SQLException {
		 this.checkHoldability(holdability);
		 this.holdability = holdability;
	 }
	 protected void checkHoldability(int h) throws SQLException {
		 switch (h) {
			 case ResultSet.CLOSE_CURSORS_AT_COMMIT: case ResultSet.HOLD_CURSORS_OVER_COMMIT: return;
			 default: throw new SQLRecoverableException(String.format(""%d is not a valid holdability setting"", h));
		 }
	 }
	 public abstract void setReadOnly(boolean readOnly) throws SQLException;
	 public Savepoint setSavepoint() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Savepoint setSavepoint(String name) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setTransactionIsolation(int level) throws SQLException {
		 this.checkTransactionIsolation(level);
		 this.isolationLevel = level;
	 }
	 protected abstract void checkTransactionIsolation(int level) throws SQLException;
	 public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 protected void setWarning(SQLWarning warning) {
		 LOGGER.warn(""SQL Warning was issued"", warning);
		 if (this.warnings == null) {
			 this.warnings = warning;
		 }
		 else {
			 warning.setNextWarning(this.warnings);
			 this.warnings = warning;
		 }
	 }
	 protected void setWarning(String warning) {
		 this.setWarning(new SQLWarning(warning));
	 }
	 protected void setWarning(String warning, Throwable cause) {
		 this.setWarning(new SQLWarning(warning, cause));
	 }
	 public void setSchema(String schema) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}
	 public String getSchema() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}
	 public void abort(java.util.concurrent.Executor executor) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}
	 public int getNetworkTimeout() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}
	 public void setNetworkTimeout(java.util.concurrent.Executor executor, int milliseconds) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}
}",1,0,0,0
"public class ConfigurationException extends UncheckedException {
	 private static final long serialVersionUID = 1L;
	 public ConfigurationException(Message msg) {
		 super(msg);
	 }
	 public ConfigurationException(Message msg, Throwable cause) {
		 super(msg, cause);
	 }
	 public ConfigurationException(Throwable cause) {
		 super(cause);
	 }
}",0,0,0,0
"public ClientListenerResponse doHandle(OdbcRequest req) {
	 if (!busyLock.enterBusy()) return new OdbcResponse(IgniteQueryErrorCode.UNKNOWN, ""Failed to handle ODBC request because node is stopping: "" + req);
	 if (actx != null) AuthorizationContext.context(actx);
	 try {
		 switch (req.command()) {
			 case QRY_EXEC: return executeQuery((OdbcQueryExecuteRequest)req);
			 case QRY_EXEC_BATCH: return executeBatchQuery((OdbcQueryExecuteBatchRequest)req);
			 case STREAMING_BATCH: return dispatchBatchOrdered((OdbcStreamingBatchRequest)req);
			 case QRY_FETCH: return fetchQuery((OdbcQueryFetchRequest)req);
			 case QRY_CLOSE: return closeQuery((OdbcQueryCloseRequest)req);
			 case META_COLS: return getColumnsMeta((OdbcQueryGetColumnsMetaRequest)req);
			 case META_TBLS: return getTablesMeta((OdbcQueryGetTablesMetaRequest)req);
			 case META_PARAMS: return getParamsMeta((OdbcQueryGetParamsMetaRequest)req);
			 case MORE_RESULTS: return moreResults((OdbcQueryMoreResultsRequest)req);
		 }
		 return new OdbcResponse(IgniteQueryErrorCode.UNKNOWN, ""Unsupported ODBC request: "" + req);
	 }
	 finally {
		 AuthorizationContext.clear();
		 busyLock.leaveBusy();
	 }
 }",0,0,1,0
"public final class FunctionExpressionNode extends RSourceSectionNode implements RSyntaxNode, RSyntaxFunction {
	 public static FunctionExpressionNode create(SourceSection src, RootCallTarget callTarget) {
		 return new FunctionExpressionNode(src, callTarget);
	 }
	 private SetVisibilityNode visibility = SetVisibilityNode.create();
	 private RootCallTarget callTarget;
	 private final PromiseDeoptimizeFrameNode deoptFrameNode;
	 private boolean initialized = false;
	 private FunctionExpressionNode(SourceSection src, RootCallTarget callTarget) {
		 super(src);
		 this.callTarget = callTarget;
		 this.deoptFrameNode = EagerEvalHelper.optExprs() || EagerEvalHelper.optVars() || EagerEvalHelper.optDefault() ? new PromiseDeoptimizeFrameNode() : null;
	 }
	 public RFunction execute(VirtualFrame frame) {
		 visibility.execute(frame, true);
		 MaterializedFrame matFrame = frame.materialize();
		 if (deoptFrameNode != null) {
			 deoptFrameNode.deoptimizeFrame(RArguments.getArguments(matFrame));
		 }
		 if (!initialized) {
			 CompilerDirectives.transferToInterpreterAndInvalidate();
			 if (!FrameSlotChangeMonitor.isEnclosingFrameDescriptor(callTarget.getRootNode().getFrameDescriptor(), frame)) {
				 if (!FrameSlotChangeMonitor.isEnclosingFrameDescriptor(callTarget.getRootNode().getFrameDescriptor(), null)) {
					 RRootNode root = (RRootNode) callTarget.getRootNode();
					 callTarget = root.duplicateWithNewFrameDescriptor();
				 }
				 FrameSlotChangeMonitor.initializeEnclosingFrame(callTarget.getRootNode().getFrameDescriptor(), frame);
			 }
			 initialized = true;
		 }
		 return RDataFactory.createFunction(RFunction.NO_NAME, RFunction.NO_NAME, callTarget, null, matFrame);
	 }
	 public RootCallTarget getCallTarget() {
		 return callTarget;
	 }
	 public RSyntaxElement[] getSyntaxArgumentDefaults() {
		 return RASTUtils.asSyntaxNodes(((FunctionDefinitionNode) callTarget.getRootNode()).getFormalArguments().getArguments());
	 }
	 public RSyntaxElement getSyntaxBody() {
		 return ((FunctionDefinitionNode) callTarget.getRootNode()).getBody();
	 }
	 public ArgumentsSignature getSyntaxSignature() {
		 return ((FunctionDefinitionNode) callTarget.getRootNode()).getFormalArguments().getSignature();
	 }
	 public String getSyntaxDebugName() {
		 return ((RRootNode) callTarget.getRootNode()).getName();
	 }
}",1,1,0,0
"public static class APIRequestCreateMessengerProfile extends APIRequest<Page> {
	 Page lastResponse = null;
	 public Page getLastResponse() {
		 return lastResponse;
	 }
	 public static final String[] PARAMS = {
	 ""get_started"", ""persistent_menu"", ""target_audience"", ""whitelisted_domains"", ""greeting"", ""account_linking_url"", ""payment_settings"", ""home_url"", }
	;
	 public static final String[] FIELDS = {
	 }
	;
	 public Page parseResponse(String response, String header) throws APIException {
		 return Page.parseResponse(response, getContext(), this, header).head();
	 }
	 public Page execute() throws APIException {
		 return execute(new HashMap<String, Object>());
	 }
	 public Page execute(Map<String, Object> extraParams) throws APIException {
		 ResponseWrapper rw = executeInternal(extraParams);
		 lastResponse = parseResponse(rw.getBody(), rw.getHeader());
		 return lastResponse;
	 }
	 public ListenableFuture<Page> executeAsync() throws APIException {
		 return executeAsync(new HashMap<String, Object>());
	 }
	;
	 public ListenableFuture<Page> executeAsync(Map<String, Object> extraParams) throws APIException {
		 return Futures.transform( executeAsyncInternal(extraParams), new Function<ResponseWrapper, Page>() {
			 public Page apply(ResponseWrapper result) {
				 try {
					 return APIRequestCreateMessengerProfile.this.parseResponse(result.getBody(), result.getHeader());
				 }
				 catch (Exception e) {
					 throw new RuntimeException(e);
				 }
			 }
		 }
		 );
	 }
	;
	 public APIRequestCreateMessengerProfile(String nodeId, APIContext context) {
		 super(context, nodeId, ""/messenger_profile"", ""POST"", Arrays.asList(PARAMS));
	 }
	 public APIRequestCreateMessengerProfile setParam(String param, Object value) {
		 setParamInternal(param, value);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setParams(Map<String, Object> params) {
		 setParamsInternal(params);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setGetStarted (Object getStarted) {
		 this.setParam(""get_started"", getStarted);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setGetStarted (String getStarted) {
		 this.setParam(""get_started"", getStarted);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setPersistentMenu (List<Object> persistentMenu) {
		 this.setParam(""persistent_menu"", persistentMenu);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setPersistentMenu (String persistentMenu) {
		 this.setParam(""persistent_menu"", persistentMenu);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setTargetAudience (Object targetAudience) {
		 this.setParam(""target_audience"", targetAudience);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setTargetAudience (String targetAudience) {
		 this.setParam(""target_audience"", targetAudience);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setWhitelistedDomains (List<String> whitelistedDomains) {
		 this.setParam(""whitelisted_domains"", whitelistedDomains);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setWhitelistedDomains (String whitelistedDomains) {
		 this.setParam(""whitelisted_domains"", whitelistedDomains);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setGreeting (List<Object> greeting) {
		 this.setParam(""greeting"", greeting);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setGreeting (String greeting) {
		 this.setParam(""greeting"", greeting);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setAccountLinkingUrl (String accountLinkingUrl) {
		 this.setParam(""account_linking_url"", accountLinkingUrl);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setPaymentSettings (Object paymentSettings) {
		 this.setParam(""payment_settings"", paymentSettings);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setPaymentSettings (String paymentSettings) {
		 this.setParam(""payment_settings"", paymentSettings);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setHomeUrl (Object homeUrl) {
		 this.setParam(""home_url"", homeUrl);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile setHomeUrl (String homeUrl) {
		 this.setParam(""home_url"", homeUrl);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile requestAllFields () {
		 return this.requestAllFields(true);
	 }
	 public APIRequestCreateMessengerProfile requestAllFields (boolean value) {
		 for (String field : FIELDS) {
			 this.requestField(field, value);
		 }
		 return this;
	 }
	 public APIRequestCreateMessengerProfile requestFields (List<String> fields) {
		 return this.requestFields(fields, true);
	 }
	 public APIRequestCreateMessengerProfile requestFields (List<String> fields, boolean value) {
		 for (String field : fields) {
			 this.requestField(field, value);
		 }
		 return this;
	 }
	 public APIRequestCreateMessengerProfile requestField (String field) {
		 this.requestField(field, true);
		 return this;
	 }
	 public APIRequestCreateMessengerProfile requestField (String field, boolean value) {
		 this.requestFieldInternal(field, value);
		 return this;
	 }
 }",1,0,0,0
"class MacOSXSocketOptions extends PlatformSocketOptions {
	 public MacOSXSocketOptions() {
	 }
	 boolean keepAliveOptionsSupported() {
		 return keepAliveOptionsSupported0();
	 }
	 void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {
		 setTcpkeepAliveProbes0(fd, value);
	 }
	 void setTcpKeepAliveTime(int fd, final int value) throws SocketException {
		 setTcpKeepAliveTime0(fd, value);
	 }
	 void setTcpKeepAliveIntvl(int fd, final int value) throws SocketException {
		 setTcpKeepAliveIntvl0(fd, value);
	 }
	 int getTcpkeepAliveProbes(int fd) throws SocketException {
		 return getTcpkeepAliveProbes0(fd);
	 }
	 int getTcpKeepAliveTime(int fd) throws SocketException {
		 return getTcpKeepAliveTime0(fd);
	 }
	 int getTcpKeepAliveIntvl(int fd) throws SocketException {
		 return getTcpKeepAliveIntvl0(fd);
	 }
	 private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;
	 private static native void setTcpKeepAliveTime0(int fd, int value) throws SocketException;
	 private static native void setTcpKeepAliveIntvl0(int fd, int value) throws SocketException;
	 private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;
	 private static native int getTcpKeepAliveTime0(int fd) throws SocketException;
	 private static native int getTcpKeepAliveIntvl0(int fd) throws SocketException;
	 private static native boolean keepAliveOptionsSupported0();
	 static {
		 AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
			 System.loadLibrary(""extnet"");
			 return null;
		 }
		);
	 }
}",0,1,0,0
"public class HttpRequestBuilder {
	 private final String method;
	 private final String url;
	 private Duration timeout = Duration.ofSeconds(5);
	 private Properties headers;
	 private InputStream inputStream;
	 private String contentType;
	 private HttpRequestBuilder(String method, String url) {
		 this.method = method;
		 this.url = url;
	 }
	 public static HttpRequestBuilder getFrom(String url) {
		 return new HttpRequestBuilder(""GET"", url);
	 }
	 public static HttpRequestBuilder postTo(String url) {
		 return new HttpRequestBuilder(""POST"", url);
	 }
	 public HttpRequestBuilder withTimeout(Duration timeout) {
		 this.timeout = timeout;
		 return this;
	 }
	 public HttpRequestBuilder withHeader(String header, String value) {
		 Properties localHeaders = headers;
		 if (localHeaders == null) {
			 headers = new Properties();
			 localHeaders = headers;
		 }
		 localHeaders.put(header, value);
		 return this;
	 }
	 public HttpRequestBuilder withContent(String content) {
		 this.inputStream = new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));
		 return this;
	 }
	 public HttpRequestBuilder withContent(String content, String contentType) {
		 withContent(content);
		 this.contentType = contentType;
		 return this;
	 }
	 public String getContentAsString() throws IOException {
		 int timeoutMillis = (int) timeout.toMillis();
		 return HttpUtil.executeUrl(method, url, headers, inputStream, contentType, timeoutMillis);
	 }
}",0,0,0,0
"public static Dataset[] generateCoordinates(Dataset angles, final double[] geometricParameters) {
	if (geometricParameters.length != PARAMETERS)throw new IllegalArgumentException(""Need "" + PARAMETERS + "" parameters"");
	Dataset[] coords = new Dataset[2];
	DoubleDataset x = DatasetFactory.zeros(DoubleDataset.class, angles.getShape());
	DoubleDataset y = DatasetFactory.zeros(DoubleDataset.class, angles.getShape());
	coords[0] = x;
	coords[1] = y;
	final double ca = Math.cos(geometricParameters[2]);
	final double sa = Math.sin(geometricParameters[2]);
	final IndexIterator it = angles.getIterator();
	int i = 0;
	while (it.hasNext()) {
		final double t = angles.getElementDoubleAbs(it.index);
		final double ct = Math.cos(t);
		final double st = Math.sin(t);
		x.setAbs(i, geometricParameters[3] + geometricParameters[0]*ca*ct - geometricParameters[1]*sa*st);
		y.setAbs(i, geometricParameters[4] + geometricParameters[0]*sa*ct + geometricParameters[1]*ca*st);
		i++;
	}
	return coords;
}",0,0,1,0
"void prepare(Map<String, Object> topoConf, TopologyContext context, OutputCollector collector, KeyValueState<TaskStream, WindowState> windowState) {
	 init(topoConf, context, collector, windowState);
	 super.prepare(topoConf, context, collector);
 }",0,0,0,0
"int loadFSEdits( Configuration conf ) throws IOException {
	 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
	 FSDirectory fsDir = fsNamesys.dir;
	 int numEdits = 0;
	 int logVersion = 0;
	 Vector<File> files = new Vector<File>();
	 for (int idx = 0;
	 idx < editFiles.length;
	 idx++) {
		 if (editFiles[idx].exists()) {
			 files.add(editFiles[idx]);
		 }
	 }
	 long maxLength = Long.MIN_VALUE;
	 File edits = null;
	 for (Iterator<File> it = files.iterator();
	 it.hasNext();
	) {
		 File f = it.next();
		 long length = f.length();
		 if (length > maxLength) {
			 maxLength = length;
			 edits = f;
		 }
	 }
	 if (edits != null) {
		 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(edits)));
		 in.mark( 4 );
		 if( in.available() > 0 ) {
			 logVersion = in.readByte();
			 in.reset();
			 if( logVersion >= 0 ) logVersion = 0;
			 else logVersion = in.readInt();
			 if( logVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IOException( ""Unexpected version of the file system log file: "" + logVersion + "". Current version = "" + FSConstants.DFS_CURRENT_VERSION + ""."" );
		 }
		 short replication = (short)conf.getInt(""dfs.replication"", 3);
		 try {
			 while (in.available() > 0) {
				 byte opcode = in.readByte();
				 numEdits++;
				 switch (opcode) {
					 case OP_ADD: {
						 UTF8 name = new UTF8();
						 ArrayWritable aw = null;
						 Writable writables[];
						 if( logVersion >= 0 ) name.readFields(in);
						 else {
							 aw = new ArrayWritable(UTF8.class);
							 aw.readFields(in);
							 writables = aw.get();
							 if( writables.length != 2 ) throw new IOException(""Incorrect data fortmat. "" + ""Name & replication pair expected"");
							 name = (UTF8) writables[0];
							 replication = Short.parseShort( ((UTF8)writables[1]).toString());
							 replication = adjustReplication( replication, conf );
						 }
						 aw = new ArrayWritable(Block.class);
						 aw.readFields(in);
						 writables = aw.get();
						 Block blocks[] = new Block[writables.length];
						 System.arraycopy(writables, 0, blocks, 0, blocks.length);
						 fsDir.unprotectedAddFile(name, blocks, replication );
						 break;
					 }
					 case OP_SET_REPLICATION: {
						 UTF8 src = new UTF8();
						 UTF8 repl = new UTF8();
						 src.readFields(in);
						 repl.readFields(in);
						 replication = adjustReplication( fromLogReplication(repl), conf);
						 fsDir.unprotectedSetReplication(src.toString(), replication, null);
						 break;
					 }
					 case OP_RENAME: {
						 UTF8 src = new UTF8();
						 UTF8 dst = new UTF8();
						 src.readFields(in);
						 dst.readFields(in);
						 fsDir.unprotectedRenameTo(src, dst);
						 break;
					 }
					 case OP_DELETE: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedDelete(src);
						 break;
					 }
					 case OP_MKDIR: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedMkdir(src.toString());
						 break;
					 }
					 case OP_DATANODE_ADD: {
						 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
						 DatanodeDescriptor node = new DatanodeDescriptor();
						 node.readFields(in);
						 fsNamesys.unprotectedAddDatanode( node );
						 break;
					 }
					 case OP_DATANODE_REMOVE: {
						 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
						 DatanodeID nodeID = new DatanodeID();
						 nodeID.readFields(in);
						 DatanodeDescriptor node = fsNamesys.getDatanode( nodeID );
						 if( node != null ) {
							 fsNamesys.unprotectedRemoveDatanode( node );
							 fsNamesys.wipeDatanode( nodeID );
						 }
						 break;
					 }
					 default: {
						 throw new IOException(""Never seen opcode "" + opcode);
					 }
				 }
			 }
		 }
		 finally {
			 in.close();
		 }
	 }
	 if( logVersion != FSConstants.DFS_CURRENT_VERSION ) numEdits++;
	 return numEdits;
 }",0,0,1,0
"public class NativeJavaObject implements Scriptable, Wrapper, Serializable{
	 static final long serialVersionUID = -6948590651130498591L;
	 public NativeJavaObject() {
	 }
	 public NativeJavaObject(Scriptable scope, Object javaObject, Class staticType) {
		 this(scope, javaObject, staticType, false);
	 }
	 public NativeJavaObject(Scriptable scope, Object javaObject, Class staticType, boolean isAdapter) {
		 this.parent = scope;
		 this.javaObject = javaObject;
		 this.staticType = staticType;
		 this.isAdapter = isAdapter;
		 initMembers();
	 }
	 protected void initMembers() {
		 Class dynamicType;
		 if (javaObject != null) {
			 dynamicType = javaObject.getClass();
		 }
		 else {
			 dynamicType = staticType;
		 }
		 members = JavaMembers.lookupClass(parent, dynamicType, staticType, isAdapter);
		 fieldAndMethods = members.getFieldAndMethodsObjects(this, javaObject, false);
	 }
	 public boolean has(String name, Scriptable start) {
		 return members.has(name, false);
	 }
	 public boolean has(int index, Scriptable start) {
		 return false;
	 }
	 public Object get(String name, Scriptable start) {
		 if (fieldAndMethods != null) {
			 Object result = fieldAndMethods.get(name);
			 if (result != null) {
				 return result;
			 }
		 }
		 return members.get(this, name, javaObject, false);
	 }
	 public Object get(int index, Scriptable start) {
		 throw members.reportMemberNotFound(Integer.toString(index));
	 }
	 public void put(String name, Scriptable start, Object value) {
		 if (prototype == null || members.has(name, false)) members.put(this, name, javaObject, value, false);
		 else prototype.put(name, prototype, value);
	 }
	 public void put(int index, Scriptable start, Object value) {
		 throw members.reportMemberNotFound(Integer.toString(index));
	 }
	 public boolean hasInstance(Scriptable value) {
		 return false;
	 }
	 public void delete(String name) {
	 }
	 public void delete(int index) {
	 }
	 public Scriptable getPrototype() {
		 if (prototype == null && javaObject instanceof String) {
			 return ScriptableObject.getClassPrototype(parent, ""String"");
		 }
		 return prototype;
	 }
	 public void setPrototype(Scriptable m) {
		 prototype = m;
	 }
	 public Scriptable getParentScope() {
		 return parent;
	 }
	 public void setParentScope(Scriptable m) {
		 parent = m;
	 }
	 public Object[] getIds() {
		 return members.getIds(false);
	 }
	 public static Object wrap(Scriptable scope, Object obj, Class staticType) {
		 Context cx = Context.getContext();
		 return cx.getWrapFactory().wrap(cx, scope, obj, staticType);
	 }
	 public Object unwrap() {
		 return javaObject;
	 }
	 public String getClassName() {
		 return ""JavaObject"";
	 }
	 public Object getDefaultValue(Class hint) {
		 Object value;
		 if (hint == null) {
			 if (javaObject instanceof Boolean) {
				 hint = ScriptRuntime.BooleanClass;
			 }
		 }
		 if (hint == null || hint == ScriptRuntime.StringClass) {
			 value = javaObject.toString();
		 }
		 else {
			 String converterName;
			 if (hint == ScriptRuntime.BooleanClass) {
				 converterName = ""booleanValue"";
			 }
			 else if (hint == ScriptRuntime.NumberClass) {
				 converterName = ""doubleValue"";
			 }
			 else {
				 throw Context.reportRuntimeError0(""msg.default.value"");
			 }
			 Object converterObject = get(converterName, this);
			 if (converterObject instanceof Function) {
				 Function f = (Function)converterObject;
				 value = f.call(Context.getContext(), f.getParentScope(), this, ScriptRuntime.emptyArgs);
			 }
			 else {
				 if (hint == ScriptRuntime.NumberClass && javaObject instanceof Boolean) {
					 boolean b = ((Boolean)javaObject).booleanValue();
					 value = ScriptRuntime.wrapNumber(b ? 1.0 : 0.0);
				 }
				 else {
					 value = javaObject.toString();
				 }
			 }
		 }
		 return value;
	 }
	 public static boolean canConvert(Object fromObj, Class to) {
		 int weight = getConversionWeight(fromObj, to);
		 return (weight < CONVERSION_NONE);
	 }
	 private static final int JSTYPE_UNDEFINED = 0;
	 private static final int JSTYPE_NULL = 1;
	 private static final int JSTYPE_BOOLEAN = 2;
	 private static final int JSTYPE_NUMBER = 3;
	 private static final int JSTYPE_STRING = 4;
	 private static final int JSTYPE_JAVA_CLASS = 5;
	 private static final int JSTYPE_JAVA_OBJECT = 6;
	 private static final int JSTYPE_JAVA_ARRAY = 7;
	 private static final int JSTYPE_OBJECT = 8;
	 static final byte CONVERSION_TRIVIAL = 1;
	 static final byte CONVERSION_NONTRIVIAL = 0;
	 static final byte CONVERSION_NONE = 99;
	 static int getConversionWeight(Object fromObj, Class to) {
		 int fromCode = getJSTypeCode(fromObj);
		 switch (fromCode) {
			 case JSTYPE_UNDEFINED: if (to == ScriptRuntime.StringClass || to == ScriptRuntime.ObjectClass) {
				 return 1;
			 }
			 break;
			 case JSTYPE_NULL: if (!to.isPrimitive()) {
				 return 1;
			 }
			 break;
			 case JSTYPE_BOOLEAN: if (to == Boolean.TYPE) {
				 return 1;
			 }
			 else if (to == ScriptRuntime.BooleanClass) {
				 return 2;
			 }
			 else if (to == ScriptRuntime.ObjectClass) {
				 return 3;
			 }
			 else if (to == ScriptRuntime.StringClass) {
				 return 4;
			 }
			 break;
			 case JSTYPE_NUMBER: if (to.isPrimitive()) {
				 if (to == Double.TYPE) {
					 return 1;
				 }
				 else if (to != Boolean.TYPE) {
					 return 1 + getSizeRank(to);
				 }
			 }
			 else {
				 if (to == ScriptRuntime.StringClass) {
					 return 9;
				 }
				 else if (to == ScriptRuntime.ObjectClass) {
					 return 10;
				 }
				 else if (ScriptRuntime.NumberClass.isAssignableFrom(to)) {
					 return 2;
				 }
			 }
			 break;
			 case JSTYPE_STRING: if (to == ScriptRuntime.StringClass) {
				 return 1;
			 }
			 else if (to.isInstance(fromObj)) {
				 return 2;
			 }
			 else if (to.isPrimitive()) {
				 if (to == Character.TYPE) {
					 return 3;
				 }
				 else if (to != Boolean.TYPE) {
					 return 4;
				 }
			 }
			 break;
			 case JSTYPE_JAVA_CLASS: if (to == ScriptRuntime.ClassClass) {
				 return 1;
			 }
			 else if (to == ScriptRuntime.ObjectClass) {
				 return 3;
			 }
			 else if (to == ScriptRuntime.StringClass) {
				 return 4;
			 }
			 break;
			 case JSTYPE_JAVA_OBJECT: case JSTYPE_JAVA_ARRAY: Object javaObj = fromObj;
			 if (javaObj instanceof Wrapper) {
				 javaObj = ((Wrapper)javaObj).unwrap();
			 }
			 if (to.isInstance(javaObj)) {
				 return CONVERSION_NONTRIVIAL;
			 }
			 if (to == ScriptRuntime.StringClass) {
				 return 2;
			 }
			 else if (to.isPrimitive() && to != Boolean.TYPE) {
				 return (fromCode == JSTYPE_JAVA_ARRAY) ? CONVERSION_NONTRIVIAL : 2 + getSizeRank(to);
			 }
			 break;
			 case JSTYPE_OBJECT: if (to == fromObj.getClass()) {
				 return 1;
			 }
			 if (to.isArray()) {
				 if (fromObj instanceof NativeArray) {
					 return 1;
				 }
			 }
			 else if (to == ScriptRuntime.ObjectClass) {
				 return 2;
			 }
			 else if (to == ScriptRuntime.StringClass) {
				 return 3;
			 }
			 else if (to == ScriptRuntime.DateClass) {
				 if (fromObj instanceof NativeDate) {
					 return 1;
				 }
			 }
			 else if (to.isInterface()) {
				 if (fromObj instanceof Function) {
					 if (to.getMethods().length == 1) {
						 return 1;
					 }
				 }
				 return 11;
			 }
			 else if (to.isPrimitive() && to != Boolean.TYPE) {
				 return 3 + getSizeRank(to);
			 }
			 break;
		 }
		 return CONVERSION_NONE;
	 }
	 static int getSizeRank(Class aType) {
		 if (aType == Double.TYPE) {
			 return 1;
		 }
		 else if (aType == Float.TYPE) {
			 return 2;
		 }
		 else if (aType == Long.TYPE) {
			 return 3;
		 }
		 else if (aType == Integer.TYPE) {
			 return 4;
		 }
		 else if (aType == Short.TYPE) {
			 return 5;
		 }
		 else if (aType == Character.TYPE) {
			 return 6;
		 }
		 else if (aType == Byte.TYPE) {
			 return 7;
		 }
		 else if (aType == Boolean.TYPE) {
			 return CONVERSION_NONE;
		 }
		 else {
			 return 8;
		 }
	 }
	 private static int getJSTypeCode(Object value) {
		 if (value == null) {
			 return JSTYPE_NULL;
		 }
		 else if (value == Undefined.instance) {
			 return JSTYPE_UNDEFINED;
		 }
		 else if (value instanceof String) {
			 return JSTYPE_STRING;
		 }
		 else if (value instanceof Number) {
			 return JSTYPE_NUMBER;
		 }
		 else if (value instanceof Boolean) {
			 return JSTYPE_BOOLEAN;
		 }
		 else if (value instanceof Scriptable) {
			 if (value instanceof NativeJavaClass) {
				 return JSTYPE_JAVA_CLASS;
			 }
			 else if (value instanceof NativeJavaArray) {
				 return JSTYPE_JAVA_ARRAY;
			 }
			 else if (value instanceof Wrapper) {
				 return JSTYPE_JAVA_OBJECT;
			 }
			 else {
				 return JSTYPE_OBJECT;
			 }
		 }
		 else if (value instanceof Class) {
			 return JSTYPE_JAVA_CLASS;
		 }
		 else {
			 Class valueClass = value.getClass();
			 if (valueClass.isArray()) {
				 return JSTYPE_JAVA_ARRAY;
			 }
			 else {
				 return JSTYPE_JAVA_OBJECT;
			 }
		 }
	 }
	 public static Object coerceType(Class type, Object value) {
		 return coerceTypeImpl(type, value);
	 }
	 static Object coerceTypeImpl(Class type, Object value) {
		 if (value != null && value.getClass() == type) {
			 return value;
		 }
		 switch (getJSTypeCode(value)) {
			 case JSTYPE_NULL: if (type.isPrimitive()) {
				 reportConversionError(value, type);
			 }
			 return null;
			 case JSTYPE_UNDEFINED: if (type == ScriptRuntime.StringClass || type == ScriptRuntime.ObjectClass) {
				 return ""undefined"";
			 }
			 else {
				 reportConversionError(""undefined"", type);
			 }
			 break;
			 case JSTYPE_BOOLEAN: if (type == Boolean.TYPE || type == ScriptRuntime.BooleanClass || type == ScriptRuntime.ObjectClass) {
				 return value;
			 }
			 else if (type == ScriptRuntime.StringClass) {
				 return value.toString();
			 }
			 else {
				 reportConversionError(value, type);
			 }
			 break;
			 case JSTYPE_NUMBER: if (type == ScriptRuntime.StringClass) {
				 return ScriptRuntime.toString(value);
			 }
			 else if (type == ScriptRuntime.ObjectClass) {
				 return coerceToNumber(Double.TYPE, value);
			 }
			 else if ((type.isPrimitive() && type != Boolean.TYPE) || ScriptRuntime.NumberClass.isAssignableFrom(type)) {
				 return coerceToNumber(type, value);
			 }
			 else {
				 reportConversionError(value, type);
			 }
			 break;
			 case JSTYPE_STRING: if (type == ScriptRuntime.StringClass || type.isInstance(value)) {
				 return value;
			 }
			 else if (type == Character.TYPE || type == ScriptRuntime.CharacterClass) {
				 if (((String)value).length() == 1) {
					 return new Character(((String)value).charAt(0));
				 }
				 else {
					 return coerceToNumber(type, value);
				 }
			 }
			 else if ((type.isPrimitive() && type != Boolean.TYPE) || ScriptRuntime.NumberClass.isAssignableFrom(type)) {
				 return coerceToNumber(type, value);
			 }
			 else {
				 reportConversionError(value, type);
			 }
			 break;
			 case JSTYPE_JAVA_CLASS: if (value instanceof Wrapper) {
				 value = ((Wrapper)value).unwrap();
			 }
			 if (type == ScriptRuntime.ClassClass || type == ScriptRuntime.ObjectClass) {
				 return value;
			 }
			 else if (type == ScriptRuntime.StringClass) {
				 return value.toString();
			 }
			 else {
				 reportConversionError(value, type);
			 }
			 break;
			 case JSTYPE_JAVA_OBJECT: case JSTYPE_JAVA_ARRAY: if (value instanceof Wrapper) {
				 value = ((Wrapper)value).unwrap();
			 }
			 if (type.isPrimitive()) {
				 if (type == Boolean.TYPE) {
					 reportConversionError(value, type);
				 }
				 return coerceToNumber(type, value);
			 }
			 else {
				 if (type == ScriptRuntime.StringClass) {
					 return value.toString();
				 }
				 else {
					 if (type.isInstance(value)) {
						 return value;
					 }
					 else {
						 reportConversionError(value, type);
					 }
				 }
			 }
			 break;
			 case JSTYPE_OBJECT: if (type == ScriptRuntime.StringClass) {
				 return ScriptRuntime.toString(value);
			 }
			 else if (type.isPrimitive()) {
				 if (type == Boolean.TYPE) {
					 reportConversionError(value, type);
				 }
				 return coerceToNumber(type, value);
			 }
			 else if (type.isInstance(value)) {
				 return value;
			 }
			 else if (type == ScriptRuntime.DateClass && value instanceof NativeDate) {
				 double time = ((NativeDate)value).getJSTimeValue();
				 return new Date((long)time);
			 }
			 else if (type.isArray() && value instanceof NativeArray) {
				 NativeArray array = (NativeArray) value;
				 long length = array.getLength();
				 Class arrayType = type.getComponentType();
				 Object Result = Array.newInstance(arrayType, (int)length);
				 for (int i = 0 ;
				 i < length ;
				 ++i) {
					 try {
						 Array.set(Result, i, coerceType(arrayType, array.get(i, array)));
					 }
					 catch (EvaluatorException ee) {
						 reportConversionError(value, type);
					 }
				 }
				 return Result;
			 }
			 else if (value instanceof Wrapper) {
				 value = ((Wrapper)value).unwrap();
				 if (type.isInstance(value)) return value;
				 reportConversionError(value, type);
			 }
			 else if (type.isInterface() && value instanceof Callable) {
				 if (value instanceof ScriptableObject) {
					 ScriptableObject so = (ScriptableObject)value;
					 Object key = Kit.makeHashKeyFromPair( COERCED_INTERFACE_KEY, type);
					 Object old = so.getAssociatedValue(key);
					 if (old != null) {
						 return old;
					 }
					 Context cx = Context.getContext();
					 Object glue = InterfaceAdapter.create(cx, type, (Callable)value);
					 glue = so.associateValue(key, glue);
					 return glue;
				 }
				 reportConversionError(value, type);
			 }
			 else {
				 reportConversionError(value, type);
			 }
			 break;
		 }
		 return value;
	 }
	 private static Object coerceToNumber(Class type, Object value) {
		 Class valueClass = value.getClass();
		 if (type == Character.TYPE || type == ScriptRuntime.CharacterClass) {
			 if (valueClass == ScriptRuntime.CharacterClass) {
				 return value;
			 }
			 return new Character((char)toInteger(value, ScriptRuntime.CharacterClass, Character.MIN_VALUE, Character.MAX_VALUE));
		 }
		 if (type == ScriptRuntime.ObjectClass || type == ScriptRuntime.DoubleClass || type == Double.TYPE) {
			 return valueClass == ScriptRuntime.DoubleClass ? value : new Double(toDouble(value));
		 }
		 if (type == ScriptRuntime.FloatClass || type == Float.TYPE) {
			 if (valueClass == ScriptRuntime.FloatClass) {
				 return value;
			 }
			 else {
				 double number = toDouble(value);
				 if (Double.isInfinite(number) || Double.isNaN(number) || number == 0.0) {
					 return new Float((float)number);
				 }
				 else {
					 double absNumber = Math.abs(number);
					 if (absNumber < Float.MIN_VALUE) {
						 return new Float((number > 0.0) ? +0.0 : -0.0);
					 }
					 else if (absNumber > Float.MAX_VALUE) {
						 return new Float((number > 0.0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY);
					 }
					 else {
						 return new Float((float)number);
					 }
				 }
			 }
		 }
		 if (type == ScriptRuntime.IntegerClass || type == Integer.TYPE) {
			 if (valueClass == ScriptRuntime.IntegerClass) {
				 return value;
			 }
			 else {
				 return new Integer((int)toInteger(value, ScriptRuntime.IntegerClass, Integer.MIN_VALUE, Integer.MAX_VALUE));
			 }
		 }
		 if (type == ScriptRuntime.LongClass || type == Long.TYPE) {
			 if (valueClass == ScriptRuntime.LongClass) {
				 return value;
			 }
			 else {
				 final double max = Double.longBitsToDouble(0x43dfffffffffffffL);
				 final double min = Double.longBitsToDouble(0xc3e0000000000000L);
				 return new Long(toInteger(value, ScriptRuntime.LongClass, min, max));
			 }
		 }
		 if (type == ScriptRuntime.ShortClass || type == Short.TYPE) {
			 if (valueClass == ScriptRuntime.ShortClass) {
				 return value;
			 }
			 else {
				 return new Short((short)toInteger(value, ScriptRuntime.ShortClass, Short.MIN_VALUE, Short.MAX_VALUE));
			 }
		 }
		 if (type == ScriptRuntime.ByteClass || type == Byte.TYPE) {
			 if (valueClass == ScriptRuntime.ByteClass) {
				 return value;
			 }
			 else {
				 return new Byte((byte)toInteger(value, ScriptRuntime.ByteClass, Byte.MIN_VALUE, Byte.MAX_VALUE));
			 }
		 }
		 return new Double(toDouble(value));
	 }
	 private static double toDouble(Object value) {
		 if (value instanceof Number) {
			 return ((Number)value).doubleValue();
		 }
		 else if (value instanceof String) {
			 return ScriptRuntime.toNumber((String)value);
		 }
		 else if (value instanceof Scriptable) {
			 if (value instanceof Wrapper) {
				 return toDouble(((Wrapper)value).unwrap());
			 }
			 else {
				 return ScriptRuntime.toNumber(value);
			 }
		 }
		 else {
			 Method meth;
			 try {
				 meth = value.getClass().getMethod(""doubleValue"", (Class [])null);
			 }
			 catch (NoSuchMethodException e) {
				 meth = null;
			 }
			 catch (SecurityException e) {
				 meth = null;
			 }
			 if (meth != null) {
				 try {
					 return ((Number)meth.invoke(value, (Object [])null)).doubleValue();
				 }
				 catch (IllegalAccessException e) {
					 reportConversionError(value, Double.TYPE);
				 }
				 catch (InvocationTargetException e) {
					 reportConversionError(value, Double.TYPE);
				 }
			 }
			 return ScriptRuntime.toNumber(value.toString());
		 }
	 }
	 private static long toInteger(Object value, Class type, double min, double max) {
		 double d = toDouble(value);
		 if (Double.isInfinite(d) || Double.isNaN(d)) {
			 reportConversionError(ScriptRuntime.toString(value), type);
		 }
		 if (d > 0.0) {
			 d = Math.floor(d);
		 }
		 else {
			 d = Math.ceil(d);
		 }
		 if (d < min || d > max) {
			 reportConversionError(ScriptRuntime.toString(value), type);
		 }
		 return (long)d;
	 }
	 static void reportConversionError(Object value, Class type) {
		 throw Context.reportRuntimeError2( ""msg.conversion.not.allowed"", String.valueOf(value), JavaMembers.javaSignature(type));
	 }
	 private void writeObject(ObjectOutputStream out) throws IOException {
		 out.defaultWriteObject();
		 out.writeBoolean(isAdapter);
		 if (isAdapter) {
			 if (adapter_writeAdapterObject == null) {
				 throw new IOException();
			 }
			 Object[] args = {
			 javaObject, out }
			;
			 try {
				 adapter_writeAdapterObject.invoke(null, args);
			 }
			 catch (Exception ex) {
				 throw new IOException();
			 }
		 }
		 else {
			 out.writeObject(javaObject);
		 }
		 if (staticType != null) {
			 out.writeObject(staticType.getClass().getName());
		 }
		 else {
			 out.writeObject(null);
		 }
	 }
	 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		 in.defaultReadObject();
		 isAdapter = in.readBoolean();
		 if (isAdapter) {
			 if (adapter_readAdapterObject == null) throw new ClassNotFoundException();
			 Object[] args = {
			 this, in }
			;
			 try {
				 javaObject = adapter_readAdapterObject.invoke(null, args);
			 }
			 catch (Exception ex) {
				 throw new IOException();
			 }
		 }
		 else {
			 javaObject = in.readObject();
		 }
		 String className = (String)in.readObject();
		 if (className != null) {
			 staticType = Class.forName(className);
		 }
		 else {
			 staticType = null;
		 }
		 initMembers();
	 }
	 protected Scriptable prototype;
	 protected Scriptable parent;
	 protected transient Object javaObject;
	 protected transient Class staticType;
	 protected transient JavaMembers members;
	 private transient Hashtable fieldAndMethods;
	 private transient boolean isAdapter;
	 private static final Object COERCED_INTERFACE_KEY = new Object();
	 private static Method adapter_writeAdapterObject;
	 private static Method adapter_readAdapterObject;
	 static {
		 Class[] sig2 = new Class[2];
		 Class cl = Kit.classOrNull(""org.mozilla.javascript.JavaAdapter"");
		 if (cl != null) {
			 try {
				 sig2[0] = ScriptRuntime.ObjectClass;
				 sig2[1] = Kit.classOrNull(""java.io.ObjectOutputStream"");
				 adapter_writeAdapterObject = cl.getMethod(""writeAdapterObject"", sig2);
				 sig2[0] = ScriptRuntime.ScriptableClass;
				 sig2[1] = Kit.classOrNull(""java.io.ObjectInputStream"");
				 adapter_readAdapterObject = cl.getMethod(""readAdapterObject"", sig2);
			 }
			 catch (Exception ex) {
				 adapter_writeAdapterObject = null;
				 adapter_readAdapterObject = null;
			 }
		 }
	 }
}",0,0,0,0
"public DTMDefaultBaseTraversers(DTMManager mgr, Source source, int dtmIdentity, DTMWSFilter whiteSpaceFilter, XMLStringFactory xstringfactory, boolean doIndexing, int blocksize, boolean usePrevsib, boolean newNameTable);",0,0,0,1
"void setContent(String key, String content);",0,0,0,0
"public final class ExtensionUtil {
	 private ExtensionUtil() {
	 }
	 static ArrayList toExtensions(final List adapters) throws BuildException {
		 final ArrayList results = new ArrayList();
		 final int size = adapters.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 final ExtensionAdapter adapter = (ExtensionAdapter) adapters.get(i);
			 final Extension extension = adapter.toExtension();
			 results.add(extension);
		 }
		 return results;
	 }
	 static void extractExtensions(final Project project, final List libraries, final List fileset) throws BuildException {
		 if (!fileset.isEmpty()) {
			 final Extension[] extensions = getExtensions(project, fileset);
			 for (int i = 0;
			 i < extensions.length;
			 i++) {
				 libraries.add(extensions[ i ]);
			 }
		 }
	 }
	 private static Extension[] getExtensions(final Project project, final List libraries) throws BuildException {
		 final ArrayList extensions = new ArrayList();
		 final Iterator iterator = libraries.iterator();
		 while (iterator.hasNext()) {
			 final FileSet fileSet = (FileSet) iterator.next();
			 boolean includeImpl = true;
			 boolean includeURL = true;
			 if (fileSet instanceof LibFileSet) {
				 LibFileSet libFileSet = (LibFileSet) fileSet;
				 includeImpl = libFileSet.isIncludeImpl();
				 includeURL = libFileSet.isIncludeURL();
			 }
			 final DirectoryScanner scanner = fileSet.getDirectoryScanner(project);
			 final File basedir = scanner.getBasedir();
			 final String[] files = scanner.getIncludedFiles();
			 for (int i = 0;
			 i < files.length;
			 i++) {
				 final File file = new File(basedir, files[ i ]);
				 loadExtensions(file, extensions, includeImpl, includeURL);
			 }
		 }
		 return (Extension[]) extensions.toArray(new Extension[extensions.size()]);
	 }
	 private static void loadExtensions(final File file, final List extensionList, final boolean includeImpl, final boolean includeURL) throws BuildException {
		 try {
			 final JarFile jarFile = new JarFile(file);
			 final Extension[] extensions = Extension.getAvailable(jarFile.getManifest());
			 for (int i = 0;
			 i < extensions.length;
			 i++) {
				 final Extension extension = extensions[ i ];
				 addExtension(extensionList, extension, includeImpl, includeURL);
			 }
		 }
		 catch (final Exception e) {
			 throw new BuildException(e.getMessage(), e);
		 }
	 }
	 private static void addExtension(final List extensionList, final Extension originalExtension, final boolean includeImpl, final boolean includeURL) {
		 Extension extension = originalExtension;
		 if (!includeURL && null != extension.getImplementationURL()) {
			 extension = new Extension(extension.getExtensionName(), extension.getSpecificationVersion().toString(), extension.getSpecificationVendor(), extension.getImplementationVersion().toString(), extension.getImplementationVendor(), extension.getImplementationVendorID(), null);
		 }
		 final boolean hasImplAttributes = null != extension.getImplementationURL() || null != extension.getImplementationVersion() || null != extension.getImplementationVendorID() || null != extension.getImplementationVendor();
		 if (!includeImpl && hasImplAttributes) {
			 extension = new Extension(extension.getExtensionName(), extension.getSpecificationVersion().toString(), extension.getSpecificationVendor(), null, null, null, extension.getImplementationURL());
		 }
		 extensionList.add(extension);
	 }
	 static Manifest getManifest(final File file) throws BuildException {
		 try {
			 final JarFile jarFile = new JarFile(file);
			 Manifest m = jarFile.getManifest();
			 if (m == null) {
				 throw new BuildException(file + "" doesn't have a MANIFEST"");
			 }
			 return m;
		 }
		 catch (final IOException ioe) {
			 throw new BuildException(ioe.getMessage(), ioe);
		 }
	 }
}",0,0,0,0
"public void closeIfFinished() throws IOException {
	 if (files.isEmpty()) {
		 HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();
		 for (Future<SSTableReader> future : buildFutures) {
			 try {
				 SSTableReader sstable = future.get();
				 assert sstable.getTableName().equals(table);
				 if (sstable == null) continue;
				 ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());
				 cfs.addSSTable(sstable);
				 if (!cfstores.containsKey(cfs)) cfstores.put(cfs, new ArrayList<SSTableReader>());
				 cfstores.get(cfs).add(sstable);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
			 catch (ExecutionException e) {
				 throw new RuntimeException(e);
			 }
		 }
		 for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet()) {
			 if (entry.getKey() != null && !entry.getKey().getIndexedColumns().isEmpty()) entry.getKey().buildSecondaryIndexes(entry.getValue(), entry.getKey().getIndexedColumns());
		 }
		 StreamReply reply = new StreamReply("""", getSessionId(), StreamReply.Status.SESSION_FINISHED);
		 logger.info(""Finished streaming session {
		}
		 from {
		}
		"", getSessionId(), getHost());
		 MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());
		 if (callback != null) callback.run();
		 sessions.remove(context);
	 }
 }",0,0,0,0
"ValueNode preprocess(int numTables,FromList outerFromList,SubqueryList outerSubqueryList,PredicateList outerPredicateList) throws StandardException{
	if (preprocessed){
		return this;
	}
	preprocessed = true;
	booleanflattenable;
	ValueNodetopNode = this;
	 final boolean haveOrderBy;
	 if (orderByList != null) {
		 haveOrderBy = true;
		 if (orderByList.size() > 1) {
			 orderByList.removeDupColumns();
		 }
		 resultSet.pushOrderByList(orderByList);
		 orderByList = null;
	 }
	 else {
		 haveOrderBy = false;
	 }
	 resultSet = resultSet.preprocess(numTables, null, (FromList) null);
	 if (leftOperand != null) {
		 leftOperand = leftOperand.preprocess(numTables, outerFromList, outerSubqueryList, outerPredicateList);
	 }
	if (resultSet instanceof SelectNode){
		if (((SelectNode) resultSet).hasDistinct()){
			((SelectNode) resultSet).clearDistinct();
			if (subqueryType == EXPRESSION_SUBQUERY){
				distinctExpression = true;
			}
		}
	}
	if ((isIN() || isANY()) &&resultSet.returnsAtMostOneRow()){
		if (! hasCorrelatedCRs()){
			changeToCorrespondingExpressionType();
		}
	}
	flattenable = (resultSet instanceof RowResultSetNode) && underTopAndNode && !havingSubquery && !haveOrderBy && offset == null && fetchFirst == null && !isWhereExistsAnyInWithWhereSubquery() && parentComparisonOperator != null;
	if (flattenable){
		leftOperand = parentComparisonOperator.getLeftOperand();
		RowResultSetNode rrsn = (RowResultSetNode) resultSet;
		 FromList fl = new FromList(getContextManager());
		outerSubqueryList.removeElement(this);
		if (rrsn.subquerys.size() != 0){
			fl.addElement(rrsn);
			outerFromList.destructiveAppend(fl);
		}
		outerSubqueryList.destructiveAppend(rrsn.subquerys);
		return getNewJoinCondition(leftOperand, getRightOperand());
	}
	boolean flattenableNotExists = (isNOT_EXISTS() || canAllBeFlattened());
	flattenable = (resultSet instanceof SelectNode) && !((SelectNode)resultSet).hasWindows() && !haveOrderBy && offset == null && fetchFirst == null && underTopAndNode && !havingSubquery && !isWhereExistsAnyInWithWhereSubquery() && (isIN() || isANY() || isEXISTS() || flattenableNotExists || parentComparisonOperator != null);
	if (flattenable){
		SelectNodeselect = (SelectNode) resultSet;
		if ((!select.hasAggregatesInSelectList()) && (select.havingClause == null)){
			ValueNode origLeftOperand = leftOperand;
			boolean additionalEQ =(subqueryType == IN_SUBQUERY) ||(subqueryType == EQ_ANY_SUBQUERY);
			additionalEQ = additionalEQ &&((leftOperand instanceof ConstantNode) || (leftOperand instanceof ColumnReference) || (leftOperand.requiresTypeFromContext()));
			 if (parentComparisonOperator != null){
				leftOperand = parentComparisonOperator.getLeftOperand();
			}
			if ((! flattenableNotExists) && select.uniqueSubquery(additionalEQ)){
				return flattenToNormalJoin(numTables, outerFromList, outerSubqueryList, outerPredicateList);
			}
			else if ( (isIN() || isANY() || isEXISTS() || flattenableNotExists) && ((leftOperand == null) ? true : leftOperand.categorize(new JBitSet(numTables), false)) && select.getWherePredicates().allPushable()){
				 FromBaseTable fbt = singleFromBaseTable(select.getFromList());
				 if (fbt != null && (!flattenableNotExists || (select.getWherePredicates().allReference(fbt) && rightOperandFlattenableToNotExists(numTables, fbt)))) {
					 return flattenToExistsJoin(numTables, outerFromList, outerSubqueryList, outerPredicateList, flattenableNotExists);
				 }
			}
			leftOperand = origLeftOperand;
		}
	}
	 resultSet.pushQueryExpressionSuffix();
	 resultSet.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
	if (leftOperand != null){
		topNode = pushNewPredicate(numTables);
		pushedNewPredicate = true;
	}
	 else if (isEXISTS() || isNOT_EXISTS()){
		 topNode = genIsNullTree(isEXISTS());
		subqueryType = EXISTS_SUBQUERY;
	}
	isInvariant();
	hasCorrelatedCRs();
	if (parentComparisonOperator != null){
		parentComparisonOperator.setRightOperand(topNode);
		return parentComparisonOperator;
	}
	return topNode;
}",0,0,1,0
"static public File makePathRelativeIfPossible(File root, File f) {
	if (f.toString().indexOf(""${
		"")>=0) return f;
		File orgfile = f;
		try {
			if (f.isAbsolute() == false) {
				f = new File(root, f.toString());
			 }
			f = f.getCanonicalFile();
			f = f.getAbsoluteFile();
			root = root.getCanonicalFile();
			root = root.getAbsoluteFile();
		 }
		 catch (IOException iox){
			 iox.printStackTrace();
			 System.out.println(""Failed, returning "" + orgfile);
			 return orgfile;
		}
		Vector rootvec = new Vector();
		Vector targetvec = new Vector();
		File cur;
		cur = root;
		while (cur != null) {
			String n = cur.getName();
			if (n.equals("""")) n = cur.getAbsolutePath();
			rootvec.add(0, n);
			cur = cur.getParentFile();
		 }
		cur = f;
		while (cur != null) {
			String n = cur.getName();
			if (n.equals("""")) n = cur.getAbsolutePath();
			targetvec.add(0, n);
			cur = cur.getParentFile();
		 }
		int cursor = 0;
		while ((cursor < rootvec.size()) && (cursor < targetvec.size())) {
			if (rootvec.elementAt(cursor).equals(targetvec.elementAt(cursor)) == false) break;
			cursor++;
		 }
		if (cursor == 0) return f;
		if ((cursor == rootvec.size()) && (cursor == targetvec.size())) return new File(""."");
		StringBuffer buffer = new StringBuffer();
		for (int i=cursor;
		 i<rootvec.size();
		 i++) {
			buffer.append(""../"");
		 }
		for (int i=cursor;
		 i<targetvec.size();
		 i++) {
			buffer.append(targetvec.elementAt(i).toString());
			buffer.append(""/"");
		 }
		return new File(buffer.toString());
	 }",0,0,1,0
"public class Targeting extends APINode {
	 private String mAdgroupId = null;
	 private Long mAgeMax = null;
	 private Long mAgeMin = null;
	 private String mAlternateAutoTargetingOption = null;
	 private String mAppInstallState = null;
	 private List<String> mAudienceNetworkPositions = null;
	 private List<IDName> mBehaviors = null;
	 private List<String> mBrandSafetyContentFilterLevels = null;
	 private List<String> mBrandSafetyContentSeverityLevels = null;
	 private CatalogBasedTargeting mCatalogBasedTargeting = null;
	 private List<IDName> mCities = null;
	 private List<Long> mCollegeYears = null;
	 private List<IDName> mConnections = null;
	 private List<IDName> mContextualTargetingCategories = null;
	 private List<String> mCountries = null;
	 private List<String> mCountry = null;
	 private List<String> mCountryGroups = null;
	 private List<RawCustomAudience> mCustomAudiences = null;
	 private List<EnumDevicePlatforms> mDevicePlatforms = null;
	 private Boolean mDirectInstallDevices = null;
	 private List<String> mDynamicAudienceIds = null;
	 private List<IDName> mEducationMajors = null;
	 private List<IDName> mEducationSchools = null;
	 private List<Long> mEducationStatuses = null;
	 private List<String> mEffectiveAudienceNetworkPositions = null;
	 private List<EnumEffectiveDevicePlatforms> mEffectiveDevicePlatforms = null;
	 private List<String> mEffectiveFacebookPositions = null;
	 private List<String> mEffectiveInstagramPositions = null;
	 private List<String> mEffectiveMessengerPositions = null;
	 private List<String> mEffectivePublisherPlatforms = null;
	 private List<TargetingDynamicRule> mEngagementSpecs = null;
	 private List<IDName> mEthnicAffinity = null;
	 private List<String> mExcludeReachedSince = null;
	 private List<IDName> mExcludedConnections = null;
	 private List<IDName> mExcludedCustomAudiences = null;
	 private List<String> mExcludedDynamicAudienceIds = null;
	 private List<TargetingDynamicRule> mExcludedEngagementSpecs = null;
	 private TargetingGeoLocation mExcludedGeoLocations = null;
	 private List<String> mExcludedMobileDeviceModel = null;
	 private List<TargetingProductAudienceSpec> mExcludedProductAudienceSpecs = null;
	 private List<String> mExcludedPublisherCategories = null;
	 private List<String> mExcludedPublisherListIds = null;
	 private List<String> mExcludedUserDevice = null;
	 private FlexibleTargeting mExclusions = null;
	 private List<String> mFacebookPositions = null;
	 private List<IDName> mFamilyStatuses = null;
	 private String mFbDealId = null;
	 private List<FlexibleTargeting> mFlexibleSpec = null;
	 private List<IDName> mFriendsOfConnections = null;
	 private List<Long> mGenders = null;
	 private List<IDName> mGeneration = null;
	 private TargetingGeoLocation mGeoLocations = null;
	 private List<IDName> mHomeOwnership = null;
	 private List<IDName> mHomeType = null;
	 private List<IDName> mHomeValue = null;
	 private List<IDName> mHouseholdComposition = null;
	 private List<IDName> mIncome = null;
	 private List<IDName> mIndustries = null;
	 private List<String> mInstagramPositions = null;
	 private List<String> mInstreamVideoSponsorshipPlacements = null;
	 private List<Long> mInterestedIn = null;
	 private List<IDName> mInterests = null;
	 private Boolean mIsWhatsappDestinationAd = null;
	 private List<String> mKeywords = null;
	 private List<IDName> mLifeEvents = null;
	 private List<Long> mLocales = null;
	 private List<String> mMessengerPositions = null;
	 private List<IDName> mMoms = null;
	 private List<IDName> mNetWorth = null;
	 private List<IDName> mOfficeType = null;
	 private List<String> mPlacePageSetIds = null;
	 private List<Long> mPoliticalViews = null;
	 private List<IDName> mPolitics = null;
	 private List<TargetingProductAudienceSpec> mProductAudienceSpecs = null;
	 private TargetingProspectingAudience mProspectingAudience = null;
	 private List<String> mPublisherPlatforms = null;
	 private List<String> mPublisherVisibilityCategories = null;
	 private String mRadius = null;
	 private List<IDName> mRegions = null;
	 private List<Long> mRelationshipStatuses = null;
	 private List<String> mSiteCategory = null;
	 private String mTargetingOptimization = null;
	 private List<IDName> mUserAdclusters = null;
	 private List<String> mUserDevice = null;
	 private List<Long> mUserEvent = null;
	 private List<String> mUserOs = null;
	 private List<String> mWirelessCarrier = null;
	 private List<IDName> mWorkEmployers = null;
	 private List<IDName> mWorkPositions = null;
	 private List<String> mZips = null;
	 protected static Gson gson = null;
	 public Targeting() {
	 }
	 public String getId() {
		 return null;
	 }
	 public static Targeting loadJSON(String json, APIContext context, String header) {
		 Targeting targeting = getGson().fromJson(json, Targeting.class);
		 if (context.isDebug()) {
			 JsonParser parser = new JsonParser();
			 JsonElement o1 = parser.parse(json);
			 JsonElement o2 = parser.parse(targeting.toString());
			 if (o1.getAsJsonObject().get(""__fb_trace_id__"") != null) {
				 o2.getAsJsonObject().add(""__fb_trace_id__"", o1.getAsJsonObject().get(""__fb_trace_id__""));
			 }
			 if (!o1.equals(o2)) {
				 context.log(""[Warning] When parsing response, object is not consistent with JSON:"");
				 context.log(""[JSON]"" + o1);
				 context.log(""[Object]"" + o2);
			 }
			;
		 }
		 targeting.context = context;
		 targeting.rawValue = json;
		 targeting.header = header;
		 return targeting;
	 }
	 public static APINodeList<Targeting> parseResponse(String json, APIContext context, APIRequest request, String header) throws MalformedResponseException {
		 APINodeList<Targeting> targetings = new APINodeList<Targeting>(request, json, header);
		 JsonArray arr;
		 JsonObject obj;
		 JsonParser parser = new JsonParser();
		 Exception exception = null;
		 try{
			 JsonElement result = parser.parse(json);
			 if (result.isJsonArray()) {
				 arr = result.getAsJsonArray();
				 for (int i = 0;
				 i < arr.size();
				 i++) {
					 targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));
				 }
				;
				 return targetings;
			 }
			 else if (result.isJsonObject()) {
				 obj = result.getAsJsonObject();
				 if (obj.has(""data"")) {
					 if (obj.has(""paging"")) {
						 JsonObject paging = obj.get(""paging"").getAsJsonObject();
						 if (paging.has(""cursors"")) {
							 JsonObject cursors = paging.get(""cursors"").getAsJsonObject();
							 String before = cursors.has(""before"") ? cursors.get(""before"").getAsString() : null;
							 String after = cursors.has(""after"") ? cursors.get(""after"").getAsString() : null;
							 targetings.setCursors(before, after);
						 }
						 String previous = paging.has(""previous"") ? paging.get(""previous"").getAsString() : null;
						 String next = paging.has(""next"") ? paging.get(""next"").getAsString() : null;
						 targetings.setPaging(previous, next);
						 if (context.hasAppSecret()) {
							 targetings.setAppSecret(context.getAppSecretProof());
						 }
					 }
					 if (obj.get(""data"").isJsonArray()) {
						 arr = obj.get(""data"").getAsJsonArray();
						 for (int i = 0;
						 i < arr.size();
						 i++) {
							 targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));
						 }
						;
					 }
					 else if (obj.get(""data"").isJsonObject()) {
						 obj = obj.get(""data"").getAsJsonObject();
						 boolean isRedownload = false;
						 for (String s : new String[]{
						""campaigns"", ""adsets"", ""ads""}
						) {
							 if (obj.has(s)) {
								 isRedownload = true;
								 obj = obj.getAsJsonObject(s);
								 for (Map.Entry<String, JsonElement> entry : obj.entrySet()) {
									 targetings.add(loadJSON(entry.getValue().toString(), context, header));
								 }
								 break;
							 }
						 }
						 if (!isRedownload) {
							 targetings.add(loadJSON(obj.toString(), context, header));
						 }
					 }
					 return targetings;
				 }
				 else if (obj.has(""images"")) {
					 obj = obj.get(""images"").getAsJsonObject();
					 for (Map.Entry<String, JsonElement> entry : obj.entrySet()) {
						 targetings.add(loadJSON(entry.getValue().toString(), context, header));
					 }
					 return targetings;
				 }
				 else {
					 boolean isIdIndexedArray = true;
					 for (Map.Entry entry : obj.entrySet()) {
						 String key = (String) entry.getKey();
						 if (key.equals(""__fb_trace_id__"")) {
							 continue;
						 }
						 JsonElement value = (JsonElement) entry.getValue();
						 if ( value != null && value.isJsonObject() && value.getAsJsonObject().has(""id"") && value.getAsJsonObject().get(""id"") != null && value.getAsJsonObject().get(""id"").getAsString().equals(key) ) {
							 targetings.add(loadJSON(value.toString(), context, header));
						 }
						 else {
							 isIdIndexedArray = false;
							 break;
						 }
					 }
					 if (isIdIndexedArray) {
						 return targetings;
					 }
					 targetings.clear();
					 targetings.add(loadJSON(json, context, header));
					 return targetings;
				 }
			 }
		 }
		 catch (Exception e) {
			 exception = e;
		 }
		 throw new MalformedResponseException( ""Invalid response string: "" + json, exception );
	 }
	 public APIContext getContext() {
		 return context;
	 }
	 public void setContext(APIContext context) {
		 this.context = context;
	 }
	 public String toString() {
		 return getGson().toJson(this);
	 }
	 public String getFieldAdgroupId() {
		 return mAdgroupId;
	 }
	 public Targeting setFieldAdgroupId(String value) {
		 this.mAdgroupId = value;
		 return this;
	 }
	 public Long getFieldAgeMax() {
		 return mAgeMax;
	 }
	 public Targeting setFieldAgeMax(Long value) {
		 this.mAgeMax = value;
		 return this;
	 }
	 public Long getFieldAgeMin() {
		 return mAgeMin;
	 }
	 public Targeting setFieldAgeMin(Long value) {
		 this.mAgeMin = value;
		 return this;
	 }
	 public String getFieldAlternateAutoTargetingOption() {
		 return mAlternateAutoTargetingOption;
	 }
	 public Targeting setFieldAlternateAutoTargetingOption(String value) {
		 this.mAlternateAutoTargetingOption = value;
		 return this;
	 }
	 public String getFieldAppInstallState() {
		 return mAppInstallState;
	 }
	 public Targeting setFieldAppInstallState(String value) {
		 this.mAppInstallState = value;
		 return this;
	 }
	 public List<String> getFieldAudienceNetworkPositions() {
		 return mAudienceNetworkPositions;
	 }
	 public Targeting setFieldAudienceNetworkPositions(List<String> value) {
		 this.mAudienceNetworkPositions = value;
		 return this;
	 }
	 public List<IDName> getFieldBehaviors() {
		 return mBehaviors;
	 }
	 public Targeting setFieldBehaviors(List<IDName> value) {
		 this.mBehaviors = value;
		 return this;
	 }
	 public Targeting setFieldBehaviors(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mBehaviors = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldBrandSafetyContentFilterLevels() {
		 return mBrandSafetyContentFilterLevels;
	 }
	 public Targeting setFieldBrandSafetyContentFilterLevels(List<String> value) {
		 this.mBrandSafetyContentFilterLevels = value;
		 return this;
	 }
	 public List<String> getFieldBrandSafetyContentSeverityLevels() {
		 return mBrandSafetyContentSeverityLevels;
	 }
	 public Targeting setFieldBrandSafetyContentSeverityLevels(List<String> value) {
		 this.mBrandSafetyContentSeverityLevels = value;
		 return this;
	 }
	 public CatalogBasedTargeting getFieldCatalogBasedTargeting() {
		 return mCatalogBasedTargeting;
	 }
	 public Targeting setFieldCatalogBasedTargeting(CatalogBasedTargeting value) {
		 this.mCatalogBasedTargeting = value;
		 return this;
	 }
	 public Targeting setFieldCatalogBasedTargeting(String value) {
		 Type type = new TypeToken<CatalogBasedTargeting>(){
		}
		.getType();
		 this.mCatalogBasedTargeting = CatalogBasedTargeting.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldCities() {
		 return mCities;
	 }
	 public Targeting setFieldCities(List<IDName> value) {
		 this.mCities = value;
		 return this;
	 }
	 public Targeting setFieldCities(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mCities = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<Long> getFieldCollegeYears() {
		 return mCollegeYears;
	 }
	 public Targeting setFieldCollegeYears(List<Long> value) {
		 this.mCollegeYears = value;
		 return this;
	 }
	 public List<IDName> getFieldConnections() {
		 return mConnections;
	 }
	 public Targeting setFieldConnections(List<IDName> value) {
		 this.mConnections = value;
		 return this;
	 }
	 public Targeting setFieldConnections(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mConnections = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldContextualTargetingCategories() {
		 return mContextualTargetingCategories;
	 }
	 public Targeting setFieldContextualTargetingCategories(List<IDName> value) {
		 this.mContextualTargetingCategories = value;
		 return this;
	 }
	 public Targeting setFieldContextualTargetingCategories(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mContextualTargetingCategories = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldCountries() {
		 return mCountries;
	 }
	 public Targeting setFieldCountries(List<String> value) {
		 this.mCountries = value;
		 return this;
	 }
	 public List<String> getFieldCountry() {
		 return mCountry;
	 }
	 public Targeting setFieldCountry(List<String> value) {
		 this.mCountry = value;
		 return this;
	 }
	 public List<String> getFieldCountryGroups() {
		 return mCountryGroups;
	 }
	 public Targeting setFieldCountryGroups(List<String> value) {
		 this.mCountryGroups = value;
		 return this;
	 }
	 public List<RawCustomAudience> getFieldCustomAudiences() {
		 return mCustomAudiences;
	 }
	 public Targeting setFieldCustomAudiences(List<RawCustomAudience> value) {
		 this.mCustomAudiences = value;
		 return this;
	 }
	 public Targeting setFieldCustomAudiences(String value) {
		 Type type = new TypeToken<List<RawCustomAudience>>(){
		}
		.getType();
		 this.mCustomAudiences = RawCustomAudience.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<EnumDevicePlatforms> getFieldDevicePlatforms() {
		 return mDevicePlatforms;
	 }
	 public Targeting setFieldDevicePlatforms(List<EnumDevicePlatforms> value) {
		 this.mDevicePlatforms = value;
		 return this;
	 }
	 public Boolean getFieldDirectInstallDevices() {
		 return mDirectInstallDevices;
	 }
	 public Targeting setFieldDirectInstallDevices(Boolean value) {
		 this.mDirectInstallDevices = value;
		 return this;
	 }
	 public List<String> getFieldDynamicAudienceIds() {
		 return mDynamicAudienceIds;
	 }
	 public Targeting setFieldDynamicAudienceIds(List<String> value) {
		 this.mDynamicAudienceIds = value;
		 return this;
	 }
	 public List<IDName> getFieldEducationMajors() {
		 return mEducationMajors;
	 }
	 public Targeting setFieldEducationMajors(List<IDName> value) {
		 this.mEducationMajors = value;
		 return this;
	 }
	 public Targeting setFieldEducationMajors(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mEducationMajors = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldEducationSchools() {
		 return mEducationSchools;
	 }
	 public Targeting setFieldEducationSchools(List<IDName> value) {
		 this.mEducationSchools = value;
		 return this;
	 }
	 public Targeting setFieldEducationSchools(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mEducationSchools = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<Long> getFieldEducationStatuses() {
		 return mEducationStatuses;
	 }
	 public Targeting setFieldEducationStatuses(List<Long> value) {
		 this.mEducationStatuses = value;
		 return this;
	 }
	 public List<String> getFieldEffectiveAudienceNetworkPositions() {
		 return mEffectiveAudienceNetworkPositions;
	 }
	 public Targeting setFieldEffectiveAudienceNetworkPositions(List<String> value) {
		 this.mEffectiveAudienceNetworkPositions = value;
		 return this;
	 }
	 public List<EnumEffectiveDevicePlatforms> getFieldEffectiveDevicePlatforms() {
		 return mEffectiveDevicePlatforms;
	 }
	 public Targeting setFieldEffectiveDevicePlatforms(List<EnumEffectiveDevicePlatforms> value) {
		 this.mEffectiveDevicePlatforms = value;
		 return this;
	 }
	 public List<String> getFieldEffectiveFacebookPositions() {
		 return mEffectiveFacebookPositions;
	 }
	 public Targeting setFieldEffectiveFacebookPositions(List<String> value) {
		 this.mEffectiveFacebookPositions = value;
		 return this;
	 }
	 public List<String> getFieldEffectiveInstagramPositions() {
		 return mEffectiveInstagramPositions;
	 }
	 public Targeting setFieldEffectiveInstagramPositions(List<String> value) {
		 this.mEffectiveInstagramPositions = value;
		 return this;
	 }
	 public List<String> getFieldEffectiveMessengerPositions() {
		 return mEffectiveMessengerPositions;
	 }
	 public Targeting setFieldEffectiveMessengerPositions(List<String> value) {
		 this.mEffectiveMessengerPositions = value;
		 return this;
	 }
	 public List<String> getFieldEffectivePublisherPlatforms() {
		 return mEffectivePublisherPlatforms;
	 }
	 public Targeting setFieldEffectivePublisherPlatforms(List<String> value) {
		 this.mEffectivePublisherPlatforms = value;
		 return this;
	 }
	 public List<TargetingDynamicRule> getFieldEngagementSpecs() {
		 return mEngagementSpecs;
	 }
	 public Targeting setFieldEngagementSpecs(List<TargetingDynamicRule> value) {
		 this.mEngagementSpecs = value;
		 return this;
	 }
	 public Targeting setFieldEngagementSpecs(String value) {
		 Type type = new TypeToken<List<TargetingDynamicRule>>(){
		}
		.getType();
		 this.mEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldEthnicAffinity() {
		 return mEthnicAffinity;
	 }
	 public Targeting setFieldEthnicAffinity(List<IDName> value) {
		 this.mEthnicAffinity = value;
		 return this;
	 }
	 public Targeting setFieldEthnicAffinity(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mEthnicAffinity = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldExcludeReachedSince() {
		 return mExcludeReachedSince;
	 }
	 public Targeting setFieldExcludeReachedSince(List<String> value) {
		 this.mExcludeReachedSince = value;
		 return this;
	 }
	 public List<IDName> getFieldExcludedConnections() {
		 return mExcludedConnections;
	 }
	 public Targeting setFieldExcludedConnections(List<IDName> value) {
		 this.mExcludedConnections = value;
		 return this;
	 }
	 public Targeting setFieldExcludedConnections(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mExcludedConnections = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldExcludedCustomAudiences() {
		 return mExcludedCustomAudiences;
	 }
	 public Targeting setFieldExcludedCustomAudiences(List<IDName> value) {
		 this.mExcludedCustomAudiences = value;
		 return this;
	 }
	 public Targeting setFieldExcludedCustomAudiences(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mExcludedCustomAudiences = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldExcludedDynamicAudienceIds() {
		 return mExcludedDynamicAudienceIds;
	 }
	 public Targeting setFieldExcludedDynamicAudienceIds(List<String> value) {
		 this.mExcludedDynamicAudienceIds = value;
		 return this;
	 }
	 public List<TargetingDynamicRule> getFieldExcludedEngagementSpecs() {
		 return mExcludedEngagementSpecs;
	 }
	 public Targeting setFieldExcludedEngagementSpecs(List<TargetingDynamicRule> value) {
		 this.mExcludedEngagementSpecs = value;
		 return this;
	 }
	 public Targeting setFieldExcludedEngagementSpecs(String value) {
		 Type type = new TypeToken<List<TargetingDynamicRule>>(){
		}
		.getType();
		 this.mExcludedEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);
		 return this;
	 }
	 public TargetingGeoLocation getFieldExcludedGeoLocations() {
		 return mExcludedGeoLocations;
	 }
	 public Targeting setFieldExcludedGeoLocations(TargetingGeoLocation value) {
		 this.mExcludedGeoLocations = value;
		 return this;
	 }
	 public Targeting setFieldExcludedGeoLocations(String value) {
		 Type type = new TypeToken<TargetingGeoLocation>(){
		}
		.getType();
		 this.mExcludedGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldExcludedMobileDeviceModel() {
		 return mExcludedMobileDeviceModel;
	 }
	 public Targeting setFieldExcludedMobileDeviceModel(List<String> value) {
		 this.mExcludedMobileDeviceModel = value;
		 return this;
	 }
	 public List<TargetingProductAudienceSpec> getFieldExcludedProductAudienceSpecs() {
		 return mExcludedProductAudienceSpecs;
	 }
	 public Targeting setFieldExcludedProductAudienceSpecs(List<TargetingProductAudienceSpec> value) {
		 this.mExcludedProductAudienceSpecs = value;
		 return this;
	 }
	 public Targeting setFieldExcludedProductAudienceSpecs(String value) {
		 Type type = new TypeToken<List<TargetingProductAudienceSpec>>(){
		}
		.getType();
		 this.mExcludedProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldExcludedPublisherCategories() {
		 return mExcludedPublisherCategories;
	 }
	 public Targeting setFieldExcludedPublisherCategories(List<String> value) {
		 this.mExcludedPublisherCategories = value;
		 return this;
	 }
	 public List<String> getFieldExcludedPublisherListIds() {
		 return mExcludedPublisherListIds;
	 }
	 public Targeting setFieldExcludedPublisherListIds(List<String> value) {
		 this.mExcludedPublisherListIds = value;
		 return this;
	 }
	 public List<String> getFieldExcludedUserDevice() {
		 return mExcludedUserDevice;
	 }
	 public Targeting setFieldExcludedUserDevice(List<String> value) {
		 this.mExcludedUserDevice = value;
		 return this;
	 }
	 public FlexibleTargeting getFieldExclusions() {
		 return mExclusions;
	 }
	 public Targeting setFieldExclusions(FlexibleTargeting value) {
		 this.mExclusions = value;
		 return this;
	 }
	 public Targeting setFieldExclusions(String value) {
		 Type type = new TypeToken<FlexibleTargeting>(){
		}
		.getType();
		 this.mExclusions = FlexibleTargeting.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldFacebookPositions() {
		 return mFacebookPositions;
	 }
	 public Targeting setFieldFacebookPositions(List<String> value) {
		 this.mFacebookPositions = value;
		 return this;
	 }
	 public List<IDName> getFieldFamilyStatuses() {
		 return mFamilyStatuses;
	 }
	 public Targeting setFieldFamilyStatuses(List<IDName> value) {
		 this.mFamilyStatuses = value;
		 return this;
	 }
	 public Targeting setFieldFamilyStatuses(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mFamilyStatuses = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public String getFieldFbDealId() {
		 return mFbDealId;
	 }
	 public Targeting setFieldFbDealId(String value) {
		 this.mFbDealId = value;
		 return this;
	 }
	 public List<FlexibleTargeting> getFieldFlexibleSpec() {
		 return mFlexibleSpec;
	 }
	 public Targeting setFieldFlexibleSpec(List<FlexibleTargeting> value) {
		 this.mFlexibleSpec = value;
		 return this;
	 }
	 public Targeting setFieldFlexibleSpec(String value) {
		 Type type = new TypeToken<List<FlexibleTargeting>>(){
		}
		.getType();
		 this.mFlexibleSpec = FlexibleTargeting.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldFriendsOfConnections() {
		 return mFriendsOfConnections;
	 }
	 public Targeting setFieldFriendsOfConnections(List<IDName> value) {
		 this.mFriendsOfConnections = value;
		 return this;
	 }
	 public Targeting setFieldFriendsOfConnections(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mFriendsOfConnections = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<Long> getFieldGenders() {
		 return mGenders;
	 }
	 public Targeting setFieldGenders(List<Long> value) {
		 this.mGenders = value;
		 return this;
	 }
	 public List<IDName> getFieldGeneration() {
		 return mGeneration;
	 }
	 public Targeting setFieldGeneration(List<IDName> value) {
		 this.mGeneration = value;
		 return this;
	 }
	 public Targeting setFieldGeneration(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mGeneration = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public TargetingGeoLocation getFieldGeoLocations() {
		 return mGeoLocations;
	 }
	 public Targeting setFieldGeoLocations(TargetingGeoLocation value) {
		 this.mGeoLocations = value;
		 return this;
	 }
	 public Targeting setFieldGeoLocations(String value) {
		 Type type = new TypeToken<TargetingGeoLocation>(){
		}
		.getType();
		 this.mGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldHomeOwnership() {
		 return mHomeOwnership;
	 }
	 public Targeting setFieldHomeOwnership(List<IDName> value) {
		 this.mHomeOwnership = value;
		 return this;
	 }
	 public Targeting setFieldHomeOwnership(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mHomeOwnership = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldHomeType() {
		 return mHomeType;
	 }
	 public Targeting setFieldHomeType(List<IDName> value) {
		 this.mHomeType = value;
		 return this;
	 }
	 public Targeting setFieldHomeType(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mHomeType = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldHomeValue() {
		 return mHomeValue;
	 }
	 public Targeting setFieldHomeValue(List<IDName> value) {
		 this.mHomeValue = value;
		 return this;
	 }
	 public Targeting setFieldHomeValue(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mHomeValue = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldHouseholdComposition() {
		 return mHouseholdComposition;
	 }
	 public Targeting setFieldHouseholdComposition(List<IDName> value) {
		 this.mHouseholdComposition = value;
		 return this;
	 }
	 public Targeting setFieldHouseholdComposition(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mHouseholdComposition = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldIncome() {
		 return mIncome;
	 }
	 public Targeting setFieldIncome(List<IDName> value) {
		 this.mIncome = value;
		 return this;
	 }
	 public Targeting setFieldIncome(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mIncome = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldIndustries() {
		 return mIndustries;
	 }
	 public Targeting setFieldIndustries(List<IDName> value) {
		 this.mIndustries = value;
		 return this;
	 }
	 public Targeting setFieldIndustries(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mIndustries = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldInstagramPositions() {
		 return mInstagramPositions;
	 }
	 public Targeting setFieldInstagramPositions(List<String> value) {
		 this.mInstagramPositions = value;
		 return this;
	 }
	 public List<String> getFieldInstreamVideoSponsorshipPlacements() {
		 return mInstreamVideoSponsorshipPlacements;
	 }
	 public Targeting setFieldInstreamVideoSponsorshipPlacements(List<String> value) {
		 this.mInstreamVideoSponsorshipPlacements = value;
		 return this;
	 }
	 public List<Long> getFieldInterestedIn() {
		 return mInterestedIn;
	 }
	 public Targeting setFieldInterestedIn(List<Long> value) {
		 this.mInterestedIn = value;
		 return this;
	 }
	 public List<IDName> getFieldInterests() {
		 return mInterests;
	 }
	 public Targeting setFieldInterests(List<IDName> value) {
		 this.mInterests = value;
		 return this;
	 }
	 public Targeting setFieldInterests(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mInterests = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public Boolean getFieldIsWhatsappDestinationAd() {
		 return mIsWhatsappDestinationAd;
	 }
	 public Targeting setFieldIsWhatsappDestinationAd(Boolean value) {
		 this.mIsWhatsappDestinationAd = value;
		 return this;
	 }
	 public List<String> getFieldKeywords() {
		 return mKeywords;
	 }
	 public Targeting setFieldKeywords(List<String> value) {
		 this.mKeywords = value;
		 return this;
	 }
	 public List<IDName> getFieldLifeEvents() {
		 return mLifeEvents;
	 }
	 public Targeting setFieldLifeEvents(List<IDName> value) {
		 this.mLifeEvents = value;
		 return this;
	 }
	 public Targeting setFieldLifeEvents(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mLifeEvents = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<Long> getFieldLocales() {
		 return mLocales;
	 }
	 public Targeting setFieldLocales(List<Long> value) {
		 this.mLocales = value;
		 return this;
	 }
	 public List<String> getFieldMessengerPositions() {
		 return mMessengerPositions;
	 }
	 public Targeting setFieldMessengerPositions(List<String> value) {
		 this.mMessengerPositions = value;
		 return this;
	 }
	 public List<IDName> getFieldMoms() {
		 return mMoms;
	 }
	 public Targeting setFieldMoms(List<IDName> value) {
		 this.mMoms = value;
		 return this;
	 }
	 public Targeting setFieldMoms(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mMoms = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldNetWorth() {
		 return mNetWorth;
	 }
	 public Targeting setFieldNetWorth(List<IDName> value) {
		 this.mNetWorth = value;
		 return this;
	 }
	 public Targeting setFieldNetWorth(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mNetWorth = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldOfficeType() {
		 return mOfficeType;
	 }
	 public Targeting setFieldOfficeType(List<IDName> value) {
		 this.mOfficeType = value;
		 return this;
	 }
	 public Targeting setFieldOfficeType(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mOfficeType = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldPlacePageSetIds() {
		 return mPlacePageSetIds;
	 }
	 public Targeting setFieldPlacePageSetIds(List<String> value) {
		 this.mPlacePageSetIds = value;
		 return this;
	 }
	 public List<Long> getFieldPoliticalViews() {
		 return mPoliticalViews;
	 }
	 public Targeting setFieldPoliticalViews(List<Long> value) {
		 this.mPoliticalViews = value;
		 return this;
	 }
	 public List<IDName> getFieldPolitics() {
		 return mPolitics;
	 }
	 public Targeting setFieldPolitics(List<IDName> value) {
		 this.mPolitics = value;
		 return this;
	 }
	 public Targeting setFieldPolitics(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mPolitics = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<TargetingProductAudienceSpec> getFieldProductAudienceSpecs() {
		 return mProductAudienceSpecs;
	 }
	 public Targeting setFieldProductAudienceSpecs(List<TargetingProductAudienceSpec> value) {
		 this.mProductAudienceSpecs = value;
		 return this;
	 }
	 public Targeting setFieldProductAudienceSpecs(String value) {
		 Type type = new TypeToken<List<TargetingProductAudienceSpec>>(){
		}
		.getType();
		 this.mProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);
		 return this;
	 }
	 public TargetingProspectingAudience getFieldProspectingAudience() {
		 return mProspectingAudience;
	 }
	 public Targeting setFieldProspectingAudience(TargetingProspectingAudience value) {
		 this.mProspectingAudience = value;
		 return this;
	 }
	 public Targeting setFieldProspectingAudience(String value) {
		 Type type = new TypeToken<TargetingProspectingAudience>(){
		}
		.getType();
		 this.mProspectingAudience = TargetingProspectingAudience.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldPublisherPlatforms() {
		 return mPublisherPlatforms;
	 }
	 public Targeting setFieldPublisherPlatforms(List<String> value) {
		 this.mPublisherPlatforms = value;
		 return this;
	 }
	 public List<String> getFieldPublisherVisibilityCategories() {
		 return mPublisherVisibilityCategories;
	 }
	 public Targeting setFieldPublisherVisibilityCategories(List<String> value) {
		 this.mPublisherVisibilityCategories = value;
		 return this;
	 }
	 public String getFieldRadius() {
		 return mRadius;
	 }
	 public Targeting setFieldRadius(String value) {
		 this.mRadius = value;
		 return this;
	 }
	 public List<IDName> getFieldRegions() {
		 return mRegions;
	 }
	 public Targeting setFieldRegions(List<IDName> value) {
		 this.mRegions = value;
		 return this;
	 }
	 public Targeting setFieldRegions(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mRegions = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<Long> getFieldRelationshipStatuses() {
		 return mRelationshipStatuses;
	 }
	 public Targeting setFieldRelationshipStatuses(List<Long> value) {
		 this.mRelationshipStatuses = value;
		 return this;
	 }
	 public List<String> getFieldSiteCategory() {
		 return mSiteCategory;
	 }
	 public Targeting setFieldSiteCategory(List<String> value) {
		 this.mSiteCategory = value;
		 return this;
	 }
	 public String getFieldTargetingOptimization() {
		 return mTargetingOptimization;
	 }
	 public Targeting setFieldTargetingOptimization(String value) {
		 this.mTargetingOptimization = value;
		 return this;
	 }
	 public List<IDName> getFieldUserAdclusters() {
		 return mUserAdclusters;
	 }
	 public Targeting setFieldUserAdclusters(List<IDName> value) {
		 this.mUserAdclusters = value;
		 return this;
	 }
	 public Targeting setFieldUserAdclusters(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mUserAdclusters = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldUserDevice() {
		 return mUserDevice;
	 }
	 public Targeting setFieldUserDevice(List<String> value) {
		 this.mUserDevice = value;
		 return this;
	 }
	 public List<Long> getFieldUserEvent() {
		 return mUserEvent;
	 }
	 public Targeting setFieldUserEvent(List<Long> value) {
		 this.mUserEvent = value;
		 return this;
	 }
	 public List<String> getFieldUserOs() {
		 return mUserOs;
	 }
	 public Targeting setFieldUserOs(List<String> value) {
		 this.mUserOs = value;
		 return this;
	 }
	 public List<String> getFieldWirelessCarrier() {
		 return mWirelessCarrier;
	 }
	 public Targeting setFieldWirelessCarrier(List<String> value) {
		 this.mWirelessCarrier = value;
		 return this;
	 }
	 public List<IDName> getFieldWorkEmployers() {
		 return mWorkEmployers;
	 }
	 public Targeting setFieldWorkEmployers(List<IDName> value) {
		 this.mWorkEmployers = value;
		 return this;
	 }
	 public Targeting setFieldWorkEmployers(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mWorkEmployers = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<IDName> getFieldWorkPositions() {
		 return mWorkPositions;
	 }
	 public Targeting setFieldWorkPositions(List<IDName> value) {
		 this.mWorkPositions = value;
		 return this;
	 }
	 public Targeting setFieldWorkPositions(String value) {
		 Type type = new TypeToken<List<IDName>>(){
		}
		.getType();
		 this.mWorkPositions = IDName.getGson().fromJson(value, type);
		 return this;
	 }
	 public List<String> getFieldZips() {
		 return mZips;
	 }
	 public Targeting setFieldZips(List<String> value) {
		 this.mZips = value;
		 return this;
	 }
	 public static enum EnumDevicePlatforms {
		 VALUE_CONNECTED_TV(""connected_tv""), VALUE_DESKTOP(""desktop""), VALUE_MOBILE(""mobile""), NULL(null);
		 private String value;
		 private EnumDevicePlatforms(String value) {
			 this.value = value;
		 }
		 public String toString() {
			 return value;
		 }
	 }
	 public static enum EnumEffectiveDevicePlatforms {
		 VALUE_CONNECTED_TV(""connected_tv""), VALUE_DESKTOP(""desktop""), VALUE_MOBILE(""mobile""), NULL(null);
		 private String value;
		 private EnumEffectiveDevicePlatforms(String value) {
			 this.value = value;
		 }
		 public String toString() {
			 return value;
		 }
	 }
	 synchronized static Gson getGson() {
		 if (gson != null) {
			 return gson;
		 }
		 else {
			 gson = new GsonBuilder() .excludeFieldsWithModifiers(Modifier.STATIC) .excludeFieldsWithModifiers(Modifier.PROTECTED) .disableHtmlEscaping() .create();
		 }
		 return gson;
	 }
	 public Targeting copyFrom(Targeting instance) {
		 this.mAdgroupId = instance.mAdgroupId;
		 this.mAgeMax = instance.mAgeMax;
		 this.mAgeMin = instance.mAgeMin;
		 this.mAlternateAutoTargetingOption = instance.mAlternateAutoTargetingOption;
		 this.mAppInstallState = instance.mAppInstallState;
		 this.mAudienceNetworkPositions = instance.mAudienceNetworkPositions;
		 this.mBehaviors = instance.mBehaviors;
		 this.mBrandSafetyContentFilterLevels = instance.mBrandSafetyContentFilterLevels;
		 this.mBrandSafetyContentSeverityLevels = instance.mBrandSafetyContentSeverityLevels;
		 this.mCatalogBasedTargeting = instance.mCatalogBasedTargeting;
		 this.mCities = instance.mCities;
		 this.mCollegeYears = instance.mCollegeYears;
		 this.mConnections = instance.mConnections;
		 this.mContextualTargetingCategories = instance.mContextualTargetingCategories;
		 this.mCountries = instance.mCountries;
		 this.mCountry = instance.mCountry;
		 this.mCountryGroups = instance.mCountryGroups;
		 this.mCustomAudiences = instance.mCustomAudiences;
		 this.mDevicePlatforms = instance.mDevicePlatforms;
		 this.mDirectInstallDevices = instance.mDirectInstallDevices;
		 this.mDynamicAudienceIds = instance.mDynamicAudienceIds;
		 this.mEducationMajors = instance.mEducationMajors;
		 this.mEducationSchools = instance.mEducationSchools;
		 this.mEducationStatuses = instance.mEducationStatuses;
		 this.mEffectiveAudienceNetworkPositions = instance.mEffectiveAudienceNetworkPositions;
		 this.mEffectiveDevicePlatforms = instance.mEffectiveDevicePlatforms;
		 this.mEffectiveFacebookPositions = instance.mEffectiveFacebookPositions;
		 this.mEffectiveInstagramPositions = instance.mEffectiveInstagramPositions;
		 this.mEffectiveMessengerPositions = instance.mEffectiveMessengerPositions;
		 this.mEffectivePublisherPlatforms = instance.mEffectivePublisherPlatforms;
		 this.mEngagementSpecs = instance.mEngagementSpecs;
		 this.mEthnicAffinity = instance.mEthnicAffinity;
		 this.mExcludeReachedSince = instance.mExcludeReachedSince;
		 this.mExcludedConnections = instance.mExcludedConnections;
		 this.mExcludedCustomAudiences = instance.mExcludedCustomAudiences;
		 this.mExcludedDynamicAudienceIds = instance.mExcludedDynamicAudienceIds;
		 this.mExcludedEngagementSpecs = instance.mExcludedEngagementSpecs;
		 this.mExcludedGeoLocations = instance.mExcludedGeoLocations;
		 this.mExcludedMobileDeviceModel = instance.mExcludedMobileDeviceModel;
		 this.mExcludedProductAudienceSpecs = instance.mExcludedProductAudienceSpecs;
		 this.mExcludedPublisherCategories = instance.mExcludedPublisherCategories;
		 this.mExcludedPublisherListIds = instance.mExcludedPublisherListIds;
		 this.mExcludedUserDevice = instance.mExcludedUserDevice;
		 this.mExclusions = instance.mExclusions;
		 this.mFacebookPositions = instance.mFacebookPositions;
		 this.mFamilyStatuses = instance.mFamilyStatuses;
		 this.mFbDealId = instance.mFbDealId;
		 this.mFlexibleSpec = instance.mFlexibleSpec;
		 this.mFriendsOfConnections = instance.mFriendsOfConnections;
		 this.mGenders = instance.mGenders;
		 this.mGeneration = instance.mGeneration;
		 this.mGeoLocations = instance.mGeoLocations;
		 this.mHomeOwnership = instance.mHomeOwnership;
		 this.mHomeType = instance.mHomeType;
		 this.mHomeValue = instance.mHomeValue;
		 this.mHouseholdComposition = instance.mHouseholdComposition;
		 this.mIncome = instance.mIncome;
		 this.mIndustries = instance.mIndustries;
		 this.mInstagramPositions = instance.mInstagramPositions;
		 this.mInstreamVideoSponsorshipPlacements = instance.mInstreamVideoSponsorshipPlacements;
		 this.mInterestedIn = instance.mInterestedIn;
		 this.mInterests = instance.mInterests;
		 this.mIsWhatsappDestinationAd = instance.mIsWhatsappDestinationAd;
		 this.mKeywords = instance.mKeywords;
		 this.mLifeEvents = instance.mLifeEvents;
		 this.mLocales = instance.mLocales;
		 this.mMessengerPositions = instance.mMessengerPositions;
		 this.mMoms = instance.mMoms;
		 this.mNetWorth = instance.mNetWorth;
		 this.mOfficeType = instance.mOfficeType;
		 this.mPlacePageSetIds = instance.mPlacePageSetIds;
		 this.mPoliticalViews = instance.mPoliticalViews;
		 this.mPolitics = instance.mPolitics;
		 this.mProductAudienceSpecs = instance.mProductAudienceSpecs;
		 this.mProspectingAudience = instance.mProspectingAudience;
		 this.mPublisherPlatforms = instance.mPublisherPlatforms;
		 this.mPublisherVisibilityCategories = instance.mPublisherVisibilityCategories;
		 this.mRadius = instance.mRadius;
		 this.mRegions = instance.mRegions;
		 this.mRelationshipStatuses = instance.mRelationshipStatuses;
		 this.mSiteCategory = instance.mSiteCategory;
		 this.mTargetingOptimization = instance.mTargetingOptimization;
		 this.mUserAdclusters = instance.mUserAdclusters;
		 this.mUserDevice = instance.mUserDevice;
		 this.mUserEvent = instance.mUserEvent;
		 this.mUserOs = instance.mUserOs;
		 this.mWirelessCarrier = instance.mWirelessCarrier;
		 this.mWorkEmployers = instance.mWorkEmployers;
		 this.mWorkPositions = instance.mWorkPositions;
		 this.mZips = instance.mZips;
		 this.context = instance.context;
		 this.rawValue = instance.rawValue;
		 return this;
	 }
	 public static APIRequest.ResponseParser<Targeting> getParser() {
		 return new APIRequest.ResponseParser<Targeting>() {
			 public APINodeList<Targeting> parseResponse(String response, APIContext context, APIRequest<Targeting> request, String header) throws MalformedResponseException {
				 return Targeting.parseResponse(response, context, request, header);
			 }
		 }
		;
	 }
}",1,1,0,0
"public class DefsTable{
	 private final static Logger logger = LoggerFactory.getLogger(DefsTable.class);
	 private final static DecoderFactory DIRECT_DECODERS = new DecoderFactory().configureDirectDecoder(true);
	 public static final ByteBuffer DEFINITION_SCHEMA_COLUMN_NAME = ByteBufferUtil.bytes(""Avro/Schema"");
	 public static final String OLD_MIGRATIONS_CF = ""Migrations"";
	 public static final String OLD_SCHEMA_CF = ""Schema"";
	 public static synchronized void dumpToStorage(Collection<KSMetaData> keyspaces) throws IOException {
		 long timestamp = System.currentTimeMillis();
		 for (KSMetaData ksMetaData : keyspaces) ksMetaData.toSchema(timestamp).apply();
	 }
	 public static Collection<KSMetaData> loadFromTable() throws IOException {
		 List<Row> serializedSchema = SystemTable.serializedSchema(SystemTable.SCHEMA_KEYSPACES_CF);
		 List<KSMetaData> keyspaces = new ArrayList<KSMetaData>();
		 for (Row row : serializedSchema) {
			 if (row.cf == null || row.cf.isEmpty() || row.cf.isMarkedForDelete()) continue;
			 keyspaces.add(KSMetaData.fromSchema(row, serializedColumnFamilies(row.key)));
		 }
		 return keyspaces;
	 }
	 public static ByteBuffer searchComposite(String name, boolean start) {
		 assert name != null;
		 ByteBuffer nameBytes = UTF8Type.instance.decompose(name);
		 int length = nameBytes.remaining();
		 byte[] bytes = new byte[2 + length + 1];
		 bytes[0] = (byte)((length >> 8) & 0xFF);
		 bytes[1] = (byte)(length & 0xFF);
		 ByteBufferUtil.arrayCopy(nameBytes, 0, bytes, 2, length);
		 bytes[bytes.length - 1] = (byte)(start ? 0 : 1);
		 return ByteBuffer.wrap(bytes);
	 }
	 private static Row serializedColumnFamilies(DecoratedKey ksNameKey) {
		 ColumnFamilyStore cfsStore = SystemTable.schemaCFS(SystemTable.SCHEMA_COLUMNFAMILIES_CF);
		 return new Row(ksNameKey, cfsStore.getColumnFamily(QueryFilter.getIdentityFilter(ksNameKey, new QueryPath(SystemTable.SCHEMA_COLUMNFAMILIES_CF))));
	 }
	 public static synchronized Collection<KSMetaData> loadFromStorage(UUID version) throws IOException {
		 DecoratedKey vkey = StorageService.getPartitioner().decorateKey(toUTF8Bytes(version));
		 Table defs = Table.open(Table.SYSTEM_TABLE);
		 ColumnFamilyStore cfStore = defs.getColumnFamilyStore(OLD_SCHEMA_CF);
		 ColumnFamily cf = cfStore.getColumnFamily(QueryFilter.getIdentityFilter(vkey, new QueryPath(OLD_SCHEMA_CF)));
		 IColumn avroschema = cf.getColumn(DEFINITION_SCHEMA_COLUMN_NAME);
		 Collection<KSMetaData> keyspaces = Collections.emptyList();
		 if (avroschema != null) {
			 ByteBuffer value = avroschema.value();
			 org.apache.avro.Schema schema = org.apache.avro.Schema.parse(ByteBufferUtil.string(value));
			 keyspaces = new ArrayList<KSMetaData>();
			 for (IColumn column : cf.getSortedColumns()) {
				 if (column.name().equals(DEFINITION_SCHEMA_COLUMN_NAME)) continue;
				 KsDef ks = deserializeAvro(schema, column.value(), new KsDef());
				 keyspaces.add(Avro.ksFromAvro(ks));
			 }
			 dumpToStorage(keyspaces);
			 logger.info(""Truncating deprecated system column families (migrations, schema)..."");
			 dropColumnFamily(Table.SYSTEM_TABLE, OLD_MIGRATIONS_CF);
			 dropColumnFamily(Table.SYSTEM_TABLE, OLD_SCHEMA_CF);
		 }
		 return keyspaces;
	 }
	 public static void mergeRemoteSchema(byte[] data, int version) throws ConfigurationException, IOException {
		 if (version < MessagingService.VERSION_11) {
			 logger.error(""Can't accept schema migrations from Cassandra versions previous to 1.1, please update first."");
			 return;
		 }
		 mergeSchema(MigrationManager.deserializeMigrationMessage(data, version));
	 }
	 public static synchronized void mergeSchema(Collection<RowMutation> mutations) throws ConfigurationException, IOException {
		 Map<DecoratedKey, ColumnFamily> oldKeyspaces = SystemTable.getSchema(SystemTable.SCHEMA_KEYSPACES_CF);
		 Map<DecoratedKey, ColumnFamily> oldColumnFamilies = SystemTable.getSchema(SystemTable.SCHEMA_COLUMNFAMILIES_CF);
		 for (RowMutation mutation : mutations) mutation.apply();
		 if (!StorageService.instance.isClientMode()) flushSchemaCFs();
		 Schema.instance.updateVersionAndAnnounce();
		 Map<DecoratedKey, ColumnFamily> newKeyspaces = SystemTable.getSchema(SystemTable.SCHEMA_KEYSPACES_CF);
		 Map<DecoratedKey, ColumnFamily> newColumnFamilies = SystemTable.getSchema(SystemTable.SCHEMA_COLUMNFAMILIES_CF);
		 Set<String> keyspacesToDrop = mergeKeyspaces(oldKeyspaces, newKeyspaces);
		 mergeColumnFamilies(oldColumnFamilies, newColumnFamilies);
		 for (String keyspaceToDrop : keyspacesToDrop) dropKeyspace(keyspaceToDrop);
	 }
	 private static Set<String> mergeKeyspaces(Map<DecoratedKey, ColumnFamily> old, Map<DecoratedKey, ColumnFamily> updated) throws ConfigurationException, IOException {
		 MapDifference<DecoratedKey, ColumnFamily> diff = Maps.difference(old, updated);
		 for (Map.Entry<DecoratedKey, ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet()) {
			 ColumnFamily ksAttrs = entry.getValue();
			 if (!ksAttrs.isEmpty()) addKeyspace(KSMetaData.fromSchema(new Row(entry.getKey(), entry.getValue()), Collections.<CFMetaData>emptyList()));
		 }
		 Map<DecoratedKey, MapDifference.ValueDifference<ColumnFamily>> modifiedEntries = diff.entriesDiffering();
		 List<DecoratedKey> leftToProcess = new ArrayList<DecoratedKey>();
		 for (Map.Entry<DecoratedKey, MapDifference.ValueDifference<ColumnFamily>> entry : modifiedEntries.entrySet()) {
			 ColumnFamily prevValue = entry.getValue().leftValue();
			 ColumnFamily newValue = entry.getValue().rightValue();
			 if (prevValue.isEmpty()) {
				 addKeyspace(KSMetaData.fromSchema(new Row(entry.getKey(), newValue), Collections.<CFMetaData>emptyList()));
				 continue;
			 }
			 leftToProcess.add(entry.getKey());
		 }
		 if (leftToProcess.size() == 0) return Collections.emptySet();
		 Set<String> keyspacesToDrop = new HashSet<String>();
		 for (DecoratedKey key : leftToProcess) {
			 MapDifference.ValueDifference<ColumnFamily> valueDiff = modifiedEntries.get(key);
			 ColumnFamily newState = valueDiff.rightValue();
			 if (newState.isEmpty()) keyspacesToDrop.add(AsciiType.instance.getString(key.key));
			 else updateKeyspace(KSMetaData.fromSchema(new Row(key, newState), Collections.<CFMetaData>emptyList()));
		 }
		 return keyspacesToDrop;
	 }
	 private static void mergeColumnFamilies(Map<DecoratedKey, ColumnFamily> old, Map<DecoratedKey, ColumnFamily> updated) throws ConfigurationException, IOException {
		 MapDifference<DecoratedKey, ColumnFamily> diff = Maps.difference(old, updated);
		 for (Map.Entry<DecoratedKey, ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet()) {
			 ColumnFamily cfAttrs = entry.getValue();
			 if (!cfAttrs.isEmpty()) {
				 Map<String, CFMetaData> cfDefs = KSMetaData.deserializeColumnFamilies(new Row(entry.getKey(), cfAttrs));
				 for (CFMetaData cfDef : cfDefs.values()) addColumnFamily(cfDef);
			 }
		 }
		 Map<DecoratedKey, MapDifference.ValueDifference<ColumnFamily>> modifiedEntries = diff.entriesDiffering();
		 for (DecoratedKey keyspace : modifiedEntries.keySet()) {
			 MapDifference.ValueDifference<ColumnFamily> valueDiff = modifiedEntries.get(keyspace);
			 ColumnFamily prevValue = valueDiff.leftValue();
			 ColumnFamily newValue = valueDiff.rightValue();
			 Row newRow = new Row(keyspace, newValue);
			 if (prevValue.isEmpty()) {
				 for (CFMetaData cfm : KSMetaData.deserializeColumnFamilies(newRow).values()) addColumnFamily(cfm);
			 }
			 else if (newValue.isEmpty()) {
				 for (CFMetaData cfm : KSMetaData.deserializeColumnFamilies(new Row(keyspace, prevValue)).values()) dropColumnFamily(cfm.ksName, cfm.cfName);
			 }
			 else {
				 String ksName = AsciiType.instance.getString(keyspace.key);
				 Map<String, CFMetaData> oldCfDefs = new HashMap<String, CFMetaData>();
				 for (CFMetaData cfm : Schema.instance.getKSMetaData(ksName).cfMetaData().values()) oldCfDefs.put(cfm.cfName, cfm);
				 Map<String, CFMetaData> newCfDefs = KSMetaData.deserializeColumnFamilies(newRow);
				 MapDifference<String, CFMetaData> cfDefDiff = Maps.difference(oldCfDefs, newCfDefs);
				 for (CFMetaData cfDef : cfDefDiff.entriesOnlyOnRight().values()) addColumnFamily(cfDef);
				 for (CFMetaData cfDef : cfDefDiff.entriesOnlyOnLeft().values()) dropColumnFamily(cfDef.ksName, cfDef.cfName);
				 for (MapDifference.ValueDifference<CFMetaData> cfDef : cfDefDiff.entriesDiffering().values()) updateColumnFamily(cfDef.rightValue());
			 }
		 }
	 }
	 private static void addKeyspace(KSMetaData ksm) {
		 assert Schema.instance.getKSMetaData(ksm.name) == null;
		 Schema.instance.load(ksm);
		 if (!StorageService.instance.isClientMode()) Table.open(ksm.name);
	 }
	 private static void addColumnFamily(CFMetaData cfm) throws IOException {
		 assert Schema.instance.getCFMetaData(cfm.ksName, cfm.cfName) == null;
		 KSMetaData ksm = Schema.instance.getTableDefinition(cfm.ksName);
		 ksm = KSMetaData.cloneWith(ksm, Iterables.concat(ksm.cfMetaData().values(), Collections.singleton(cfm)));
		 Schema.instance.load(cfm);
		 Table.open(cfm.ksName);
		 Schema.instance.setTableDefinition(ksm);
		 if (!StorageService.instance.isClientMode()) Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
	 }
	 private static void updateKeyspace(KSMetaData newState) throws IOException {
		 KSMetaData oldKsm = Schema.instance.getKSMetaData(newState.name);
		 assert oldKsm != null;
		 KSMetaData newKsm = KSMetaData.cloneWith(oldKsm.reloadAttributes(), oldKsm.cfMetaData().values());
		 Schema.instance.setTableDefinition(newKsm);
		 try {
			 if (!StorageService.instance.isClientMode()) Table.open(newState.name).createReplicationStrategy(newKsm);
		 }
		 catch (ConfigurationException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 private static void updateColumnFamily(CFMetaData newState) throws IOException {
		 CFMetaData cfm = Schema.instance.getCFMetaData(newState.ksName, newState.cfName);
		 assert cfm != null;
		 cfm.reload();
		 if (!StorageService.instance.isClientMode()) {
			 Table table = Table.open(cfm.ksName);
			 table.getColumnFamilyStore(cfm.cfName).reload();
		 }
	 }
	 private static void dropKeyspace(String ksName) throws IOException {
		 KSMetaData ksm = Schema.instance.getTableDefinition(ksName);
		 String snapshotName = Table.getTimestampedSnapshotName(ksName);
		 for (CFMetaData cfm : ksm.cfMetaData().values()) {
			 ColumnFamilyStore cfs = Table.open(ksm.name).getColumnFamilyStore(cfm.cfName);
			 Schema.instance.purge(cfm);
			 if (!StorageService.instance.isClientMode()) {
				 if (DatabaseDescriptor.isAutoSnapshot()) cfs.snapshot(snapshotName);
				 Table.open(ksm.name).dropCf(cfm.cfId);
			 }
		 }
		 Table.clear(ksm.name);
		 Schema.instance.clearTableDefinition(ksm);
	 }
	 private static void dropColumnFamily(String ksName, String cfName) throws IOException {
		 KSMetaData ksm = Schema.instance.getTableDefinition(ksName);
		 assert ksm != null;
		 ColumnFamilyStore cfs = Table.open(ksName).getColumnFamilyStore(cfName);
		 assert cfs != null;
		 CFMetaData cfm = ksm.cfMetaData().get(cfName);
		 Schema.instance.purge(cfm);
		 Schema.instance.setTableDefinition(makeNewKeyspaceDefinition(ksm, cfm));
		 if (!StorageService.instance.isClientMode()) {
			 if (DatabaseDescriptor.isAutoSnapshot()) cfs.snapshot(Table.getTimestampedSnapshotName(cfs.columnFamily));
			 Table.open(ksm.name).dropCf(cfm.cfId);
		 }
	 }
	 private static KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm, CFMetaData toExclude) {
		 List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
		 newCfs.remove(toExclude);
		 assert newCfs.size() == ksm.cfMetaData().size() - 1;
		 return KSMetaData.cloneWith(ksm, newCfs);
	 }
	 private static void flushSchemaCFs() {
		 flushSchemaCF(SystemTable.SCHEMA_KEYSPACES_CF);
		 flushSchemaCF(SystemTable.SCHEMA_COLUMNFAMILIES_CF);
		 flushSchemaCF(SystemTable.SCHEMA_COLUMNS_CF);
	 }
	 private static void flushSchemaCF(String cfName) {
		 Future<?> flush = SystemTable.schemaCFS(cfName).forceFlush();
		 if (flush != null) FBUtilities.waitOnFuture(flush);
	 }
	 private static ByteBuffer toUTF8Bytes(UUID version) {
		 return ByteBufferUtil.bytes(version.toString());
	 }
	 public static <T extends SpecificRecord> T deserializeAvro(org.apache.avro.Schema writer, ByteBuffer bytes, T ob) throws IOException {
		 BinaryDecoder dec = DIRECT_DECODERS.createBinaryDecoder(ByteBufferUtil.getArray(bytes), null);
		 SpecificDatumReader<T> reader = new SpecificDatumReader<T>(writer);
		 reader.setExpected(ob.getSchema());
		 return reader.read(ob, dec);
	 }
}",0,0,0,0
"public TagArgument createTag() {
	 TagArgument ta = new TagArgument();
	 tags.addElement (ta);
	 return ta;
 }",0,0,0,0
"public class XPathTokenManager implements XPathConstants{
	 private Stack stateStack = new Stack();
	 static final int PARENMARKER = 2000;
	 private void pushState() {
		 stateStack.addElement(new Integer(curLexState));
	 }
	 private void pushState(int state) {
		 stateStack.push(new Integer(state));
	 }
	 private void popState() {
		 if (stateStack.size() == 0) {
			 printLinePos();
		 }
		 int nextState = ((Integer) stateStack.pop()).intValue();
		 if(nextState == PARENMARKER) printLinePos();
		 SwitchTo(nextState);
	 }
	 private boolean isState(int state) {
		 for (int i = 0;
		 i < stateStack.size();
		 i++) {
			 if(((Integer) stateStack.elementAt(i)).intValue() == state) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private void pushParenState(int commaState, int rparState) {
		 stateStack.push(new Integer(rparState));
		 stateStack.push(new Integer(commaState));
		 stateStack.push(new Integer(PARENMARKER));
		 SwitchTo(commaState);
	 }
	 public void printLinePos() {
		 System.err.println(""Line: "" + input_stream.getEndLine());
	 }
	 public java.io.PrintStream debugStream = System.out;
	 public void setDebugStream(java.io.PrintStream ds) {
		 debugStream = ds;
	 }
	private final int jjStopStringLiteralDfa_14(int pos, long active0){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_14(int pos, long active0){
		 return jjMoveNfa_14(jjStopStringLiteralDfa_14(pos, active0), pos + 1);
	}
	private final int jjStopAtPos(int pos, int kind){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 return pos + 1;
	}
	private final int jjStartNfaWithStates_14(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_14(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_14(){
		 switch(curChar) {
			 case 63: return jjMoveStringLiteralDfa1_14(0x20000L);
			 default : return jjMoveNfa_14(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_14(long active0){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_14(0, active0);
			 return 1;
		 }
		 switch(curChar) {
			 case 62: if ((active0 & 0x20000L) != 0L) return jjStopAtPos(1, 17);
			 break;
			 default : break;
		 }
		 return jjStartNfa_14(0, active0);
	}
	private final void jjCheckNAdd(int state){
		 if (jjrounds[state] != jjround) {
			 jjstateSet[jjnewStateCnt++] = state;
			 jjrounds[state] = jjround;
		 }
	}
	private final void jjAddStates(int start, int end){
		 do {
			 jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		 }
		 while (start++ != end);
	}
	private final void jjCheckNAddTwoStates(int state1, int state2){
		 jjCheckNAdd(state1);
		 jjCheckNAdd(state2);
	}
	private final void jjCheckNAddStates(int start, int end){
		 do {
			 jjCheckNAdd(jjnextStates[start]);
		 }
		 while (start++ != end);
	}
	private final void jjCheckNAddStates(int start){
		 jjCheckNAdd(jjnextStates[start]);
		 jjCheckNAdd(jjnextStates[start + 1]);
	}
	static final long[] jjbitVec0 = {
	 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL}
	;
	static final long[] jjbitVec2 = {
	 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL}
	;
	static final long[] jjbitVec3 = {
	 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL}
	;
	static final long[] jjbitVec4 = {
	 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L}
	;
	static final long[] jjbitVec5 = {
	 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL}
	;
	static final long[] jjbitVec6 = {
	 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL}
	;
	static final long[] jjbitVec7 = {
	 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L}
	;
	static final long[] jjbitVec8 = {
	 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL}
	;
	static final long[] jjbitVec9 = {
	 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L}
	;
	static final long[] jjbitVec10 = {
	 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L}
	;
	static final long[] jjbitVec11 = {
	 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L}
	;
	static final long[] jjbitVec12 = {
	 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L}
	;
	static final long[] jjbitVec13 = {
	 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L}
	;
	static final long[] jjbitVec14 = {
	 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL}
	;
	static final long[] jjbitVec15 = {
	 0x0L, 0x3fffffffeffL, 0x0L, 0x0L}
	;
	static final long[] jjbitVec16 = {
	 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL}
	;
	static final long[] jjbitVec17 = {
	 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L}
	;
	static final long[] jjbitVec18 = {
	 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL}
	;
	static final long[] jjbitVec19 = {
	 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL}
	;
	static final long[] jjbitVec20 = {
	 0x4c4000000000L, 0x0L, 0x7L, 0x0L}
	;
	static final long[] jjbitVec21 = {
	 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL}
	;
	static final long[] jjbitVec22 = {
	 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L}
	;
	static final long[] jjbitVec23 = {
	 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L}
	;
	static final long[] jjbitVec24 = {
	 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L}
	;
	static final long[] jjbitVec25 = {
	 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL}
	;
	static final long[] jjbitVec26 = {
	 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L}
	;
	static final long[] jjbitVec27 = {
	 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL}
	;
	static final long[] jjbitVec28 = {
	 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL}
	;
	static final long[] jjbitVec29 = {
	 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L}
	;
	static final long[] jjbitVec30 = {
	 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL}
	;
	static final long[] jjbitVec31 = {
	 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL}
	;
	static final long[] jjbitVec32 = {
	 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL}
	;
	static final long[] jjbitVec33 = {
	 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L}
	;
	static final long[] jjbitVec34 = {
	 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL}
	;
	static final long[] jjbitVec35 = {
	 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L}
	;
	static final long[] jjbitVec36 = {
	 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL}
	;
	static final long[] jjbitVec37 = {
	 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L}
	;
	static final long[] jjbitVec38 = {
	 0x0L, 0x0L, 0x0L, 0x21fff0000L}
	;
	static final long[] jjbitVec39 = {
	 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL}
	;
	private final int jjMoveNfa_14(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 3;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: case 2: if ((0x100002600L & l) == 0L) break;
						 kind = 238;
						 jjCheckNAdd(2);
						 break;
						 case 1: if ((0x3ff600000000000L & l) == 0L) break;
						 kind = 46;
						 jjstateSet[jjnewStateCnt++] = 1;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: case 1: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 46) kind = 46;
						 jjCheckNAdd(1);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 46) kind = 46;
						 jjCheckNAdd(1);
						 break;
						 case 1: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 46) kind = 46;
						 jjCheckNAdd(1);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_3(int pos, long active0, long active1, long active2){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_3(int pos, long active0, long active1, long active2){
		 return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0, active1, active2), pos + 1);
	}
	private final int jjStartNfaWithStates_3(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_3(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_3(){
		 switch(curChar) {
			 case 59: return jjStopAtPos(0, 170);
			 case 101: return jjMoveStringLiteralDfa1_3(0x100L);
			 default : return jjMoveNfa_3(7, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_3(long active0){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(0, active0, 0L, 0L);
			 return 1;
		 }
		 switch(curChar) {
			 case 110: return jjMoveStringLiteralDfa2_3(active0, 0x100L);
			 default : break;
		 }
		 return jjStartNfa_3(0, active0, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa2_3(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_3(0, old0, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(1, active0, 0L, 0L);
			 return 2;
		 }
		 switch(curChar) {
			 case 99: return jjMoveStringLiteralDfa3_3(active0, 0x100L);
			 default : break;
		 }
		 return jjStartNfa_3(1, active0, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa3_3(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_3(1, old0, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(2, active0, 0L, 0L);
			 return 3;
		 }
		 switch(curChar) {
			 case 111: return jjMoveStringLiteralDfa4_3(active0, 0x100L);
			 default : break;
		 }
		 return jjStartNfa_3(2, active0, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa4_3(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_3(2, old0, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(3, active0, 0L, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 100: return jjMoveStringLiteralDfa5_3(active0, 0x100L);
			 default : break;
		 }
		 return jjStartNfa_3(3, active0, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa5_3(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_3(3, old0, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(4, active0, 0L, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 105: return jjMoveStringLiteralDfa6_3(active0, 0x100L);
			 default : break;
		 }
		 return jjStartNfa_3(4, active0, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa6_3(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_3(4, old0, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(5, active0, 0L, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 110: return jjMoveStringLiteralDfa7_3(active0, 0x100L);
			 default : break;
		 }
		 return jjStartNfa_3(5, active0, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa7_3(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_3(5, old0, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_3(6, active0, 0L, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 103: if ((active0 & 0x100L) != 0L) return jjStopAtPos(7, 8);
			 break;
			 default : break;
		 }
		 return jjStartNfa_3(6, active0, 0L, 0L);
	}
	static final long[] jjbitVec40 = {
	 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL}
	;
	static final long[] jjbitVec41 = {
	 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL}
	;
	private final int jjMoveNfa_3(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 7;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 7: if ((0x100002600L & l) != 0L) {
							 if (kind > 12) kind = 12;
							 jjCheckNAdd(6);
						 }
						 else if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 else if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 0: if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 1: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 2: if (curChar != 34) break;
						 if (kind > 7) kind = 7;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 case 3: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 4: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 5: if (curChar != 39) break;
						 if (kind > 7) kind = 7;
						 jjstateSet[jjnewStateCnt++] = 3;
						 break;
						 case 6: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(6);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: jjAddStates(0, 1);
						 break;
						 case 4: jjAddStates(2, 3);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(0, 1);
						 break;
						 case 4: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(2, 3);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_15(int pos, long active0){
		 switch (pos) {
			 case 0: if ((active0 & 0x20000L) != 0L) {
				 jjmatchedKind = 215;
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_15(int pos, long active0){
		 return jjMoveNfa_15(jjStopStringLiteralDfa_15(pos, active0), pos + 1);
	}
	private final int jjStartNfaWithStates_15(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_15(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_15(){
		 switch(curChar) {
			 case 63: return jjMoveStringLiteralDfa1_15(0x20000L);
			 default : return jjMoveNfa_15(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_15(long active0){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_15(0, active0);
			 return 1;
		 }
		 switch(curChar) {
			 case 62: if ((active0 & 0x20000L) != 0L) return jjStopAtPos(1, 17);
			 break;
			 default : break;
		 }
		 return jjStartNfa_15(0, active0);
	}
	static final long[] jjbitVec42 = {
	 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0x7fffffffffffffffL}
	;
	static final long[] jjbitVec43 = {
	 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffffL}
	;
	private final int jjMoveNfa_15(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 1;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) kind = 215;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: kind = 215;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 215) kind = 215;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_21(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_21(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_21(jjStopStringLiteralDfa_21(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_21(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_21(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_21(){
		 switch(curChar) {
			 case 62: return jjStopAtPos(0, 201);
			 default : return jjMoveNfa_21(1, 0);
		 }
	}
	private final int jjMoveNfa_21(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 6;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 237;
						 jjCheckNAdd(0);
						 break;
						 case 2: if ((0x3ff600000000000L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 5: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 203) kind = 203;
						 jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: case 5: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAdd(5);
						 break;
						 case 5: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_22(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x40000000000L) != 0L) {
				 jjmatchedKind = 213;
				 return 2;
			 }
			 return -1;
			 case 1: if ((active3 & 0x40000000000L) != 0L) {
				 jjmatchedKind = 214;
				 jjmatchedPos = 1;
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_22(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_22(jjStopStringLiteralDfa_22(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_22(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_22(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_22(){
		 switch(curChar) {
			 case 45: return jjMoveStringLiteralDfa1_22(0x40000000000L);
			 default : return jjMoveNfa_22(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_22(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_22(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 45: return jjMoveStringLiteralDfa2_22(active3, 0x40000000000L);
			 default : break;
		 }
		 return jjStartNfa_22(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_22(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_22(0, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_22(1, 0L, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 62: if ((active3 & 0x40000000000L) != 0L) return jjStopAtPos(2, 234);
			 break;
			 default : break;
		 }
		 return jjStartNfa_22(1, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_22(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 3;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) {
							 if (kind > 213) kind = 213;
						 }
						 if (curChar == 45) jjstateSet[jjnewStateCnt++] = 2;
						 break;
						 case 1: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 2;
						 break;
						 case 2: if ((0xffffffff00002600L & l) != 0L && kind > 214) kind = 214;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (kind > 213) kind = 213;
						 break;
						 case 2: if (kind > 214) kind = 214;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 213) kind = 213;
						 break;
						 case 2: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 214) kind = 214;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_24(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x100000000L) != 0L) {
				 jjmatchedKind = 223;
				 return -1;
			 }
			 return -1;
			 case 1: if ((active3 & 0x100000000L) != 0L) {
				 if (jjmatchedPos == 0) {
					 jjmatchedKind = 223;
					 jjmatchedPos = 0;
				 }
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_24(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_24(jjStopStringLiteralDfa_24(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_24(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_24(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_24(){
		 switch(curChar) {
			 case 58: return jjMoveStringLiteralDfa1_24(0x100000000L);
			 default : return jjMoveNfa_24(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_24(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_24(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: return jjMoveStringLiteralDfa2_24(active3, 0x100000000L);
			 default : break;
		 }
		 return jjStartNfa_24(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_24(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_24(0, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_24(1, 0L, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 41: if ((active3 & 0x100000000L) != 0L) return jjStopAtPos(2, 224);
			 break;
			 default : break;
		 }
		 return jjStartNfa_24(1, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_24(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 2;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) {
							 if (kind > 223) kind = 223;
						 }
						 if ((0x100002600L & l) != 0L) {
							 if (kind > 239) kind = 239;
							 jjCheckNAdd(1);
						 }
						 break;
						 case 1: if ((0x100002600L & l) == 0L) break;
						 if (kind > 239) kind = 239;
						 jjCheckNAdd(1);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: kind = 223;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 223) kind = 223;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_7(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_7(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_7(jjStopStringLiteralDfa_7(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_7(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_7(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_7(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_7(0x800000000L);
			 case 41: return jjStopAtPos(0, 139);
			 case 42: return jjStopAtPos(0, 102);
			 case 123: return jjStopAtPos(0, 205);
			 default : return jjMoveNfa_7(9, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_7(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_7(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) return jjStopAtPos(1, 227);
			 break;
			 default : break;
		 }
		 return jjStartNfa_7(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_7(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 31;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 9: case 0: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(0);
						 break;
						 case 2: if ((0x100002600L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 40 && kind > 157) kind = 157;
						 break;
						 case 11: if ((0x100002600L & l) != 0L) jjAddStates(9, 10);
						 break;
						 case 12: if (curChar == 40 && kind > 160) kind = 160;
						 break;
						 case 19: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 18;
						 break;
						 case 27: if ((0x3ff600000000000L & l) != 0L) jjAddStates(11, 12);
						 break;
						 case 28: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 29;
						 break;
						 case 30: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 185) kind = 185;
						 jjstateSet[jjnewStateCnt++] = 30;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 9: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 185) kind = 185;
							 jjCheckNAddStates(13, 15);
						 }
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 24;
						 else if (curChar == 101) jjstateSet[jjnewStateCnt++] = 8;
						 break;
						 case 1: if (curChar == 116) jjAddStates(4, 5);
						 break;
						 case 4: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 1;
						 break;
						 case 5: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 6: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 case 7: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 6;
						 break;
						 case 8: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 7;
						 break;
						 case 10: if (curChar == 116) jjAddStates(9, 10);
						 break;
						 case 13: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 10;
						 break;
						 case 14: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 13;
						 break;
						 case 15: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 14;
						 break;
						 case 16: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 15;
						 break;
						 case 17: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 16;
						 break;
						 case 18: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 17;
						 break;
						 case 20: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 19;
						 break;
						 case 21: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 20;
						 break;
						 case 22: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 21;
						 break;
						 case 23: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 22;
						 break;
						 case 24: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 23;
						 break;
						 case 25: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 24;
						 break;
						 case 26: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 185) kind = 185;
						 jjCheckNAddStates(13, 15);
						 break;
						 case 27: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(27, 28);
						 break;
						 case 29: case 30: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 185) kind = 185;
						 jjCheckNAdd(30);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 9: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 185) kind = 185;
						 jjCheckNAddStates(13, 15);
						 break;
						 case 27: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(27, 28);
						 break;
						 case 29: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 185) kind = 185;
						 jjCheckNAdd(30);
						 break;
						 case 30: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 185) kind = 185;
						 jjCheckNAdd(30);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 31 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_25(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_25(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_25(jjStopStringLiteralDfa_25(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_25(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_25(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_25(){
		 switch(curChar) {
			 case 101: return jjMoveStringLiteralDfa1_25(0x8000000000L);
			 case 112: return jjMoveStringLiteralDfa1_25(0x4000000000L);
			 default : return jjMoveNfa_25(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_25(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 114: return jjMoveStringLiteralDfa2_25(active3, 0x4000000000L);
			 case 120: return jjMoveStringLiteralDfa2_25(active3, 0x8000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(0, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(1, 0L, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa3_25(active3, 0x4000000000L);
			 case 116: return jjMoveStringLiteralDfa3_25(active3, 0x8000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(1, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa3_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(1, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(2, 0L, 0L, 0L, active3);
			 return 3;
		 }
		 switch(curChar) {
			 case 101: return jjMoveStringLiteralDfa4_25(active3, 0x8000000000L);
			 case 103: return jjMoveStringLiteralDfa4_25(active3, 0x4000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(2, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa4_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(2, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(3, 0L, 0L, 0L, active3);
			 return 4;
		 }
		 switch(curChar) {
			 case 109: return jjMoveStringLiteralDfa5_25(active3, 0x4000000000L);
			 case 110: return jjMoveStringLiteralDfa5_25(active3, 0x8000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(3, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa5_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(3, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(4, 0L, 0L, 0L, active3);
			 return 5;
		 }
		 switch(curChar) {
			 case 97: if ((active3 & 0x4000000000L) != 0L) return jjStopAtPos(5, 230);
			 break;
			 case 115: return jjMoveStringLiteralDfa6_25(active3, 0x8000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(4, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa6_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(4, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(5, 0L, 0L, 0L, active3);
			 return 6;
		 }
		 switch(curChar) {
			 case 105: return jjMoveStringLiteralDfa7_25(active3, 0x8000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(5, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa7_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(5, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(6, 0L, 0L, 0L, active3);
			 return 7;
		 }
		 switch(curChar) {
			 case 111: return jjMoveStringLiteralDfa8_25(active3, 0x8000000000L);
			 default : break;
		 }
		 return jjStartNfa_25(6, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa8_25(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_25(6, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_25(7, 0L, 0L, 0L, active3);
			 return 8;
		 }
		 switch(curChar) {
			 case 110: if ((active3 & 0x8000000000L) != 0L) return jjStopAtPos(8, 231);
			 break;
			 default : break;
		 }
		 return jjStartNfa_25(7, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_25(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 1;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 239;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_23(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x2840000000L) != 0L) {
				 jjmatchedKind = 228;
				 return -1;
			 }
			 return -1;
			 case 1: if ((active3 & 0x2840000000L) != 0L) {
				 if (jjmatchedPos == 0) {
					 jjmatchedKind = 228;
					 jjmatchedPos = 0;
				 }
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_23(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_23(jjStopStringLiteralDfa_23(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_23(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_23(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_23(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_23(0x840000000L);
			 case 58: return jjMoveStringLiteralDfa1_23(0x2000000000L);
			 default : return jjMoveNfa_23(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_23(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_23(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 41: if ((active3 & 0x2000000000L) != 0L) return jjStopAtPos(1, 229);
			 break;
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_23(active3, 0x40000000L);
			 default : break;
		 }
		 return jjStartNfa_23(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_23(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_23(0, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_23(1, 0L, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 default : break;
		 }
		 return jjStartNfa_23(1, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_23(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 1;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) kind = 228;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: kind = 228;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 228) kind = 228;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_4(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active0 & 0x100080000000000L) != 0L || (active1 & 0x780000000000048L) != 0L) {
				 jjmatchedKind = 183;
				 return 202;
			 }
			 if ((active0 & 0x200000000000000L) != 0L || (active1 & 0x4L) != 0L) {
				 jjmatchedKind = 183;
				 return 140;
			 }
			 if ((active1 & 0x40000000000000L) != 0L) {
				 jjmatchedKind = 183;
				 return 44;
			 }
			 if ((active1 & 0x400L) != 0L) {
				 jjmatchedKind = 183;
				 return 101;
			 }
			 if ((active0 & 0x240000000000L) != 0L || (active1 & 0x800000000020L) != 0L) {
				 jjmatchedKind = 183;
				 return 83;
			 }
			 if ((active0 & 0x20000000000L) != 0L) {
				 jjmatchedKind = 183;
				 return 14;
			 }
			 if ((active0 & 0x10000000000L) != 0L || (active1 & 0x300L) != 0L) {
				 jjmatchedKind = 183;
				 return 55;
			 }
			 if ((active0 & 0x80000000000000L) != 0L) {
				 jjmatchedKind = 183;
				 return 161;
			 }
			 if ((active0 & 0x400004000000000L) != 0L || (active1 & 0x20000000000080L) != 0L) {
				 jjmatchedKind = 183;
				 return 124;
			 }
			 if ((active0 & 0x8000000000L) != 0L) {
				 jjmatchedKind = 183;
				 return 52;
			 }
			 return -1;
			 case 1: if ((active0 & 0x8000000000L) != 0L) return 51;
			 if ((active0 & 0x400000000000000L) != 0L) {
				 if (jjmatchedPos != 1) {
					 jjmatchedKind = 183;
					 jjmatchedPos = 1;
				 }
				 return 131;
			 }
			 if ((active0 & 0x200000000000L) != 0L || (active1 & 0x20L) != 0L) return 82;
			 if ((active1 & 0x7e0800000000104L) != 0L) return 202;
			 if ((active1 & 0x400L) != 0L) {
				 if (jjmatchedPos != 1) {
					 jjmatchedKind = 183;
					 jjmatchedPos = 1;
				 }
				 return 100;
			 }
			 if ((active1 & 0x200L) != 0L) return 71;
			 if ((active0 & 0x3800f4000000000L) != 0L || (active1 & 0xc8L) != 0L) {
				 if (jjmatchedPos != 1) {
					 jjmatchedKind = 183;
					 jjmatchedPos = 1;
				 }
				 return 202;
			 }
			 return -1;
			 case 2: if ((active0 & 0x780044000000000L) != 0L || (active1 & 0xe8L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 2;
				 return 202;
			 }
			 if ((active1 & 0x400L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 2;
				 return 99;
			 }
			 if ((active0 & 0xb0000000000L) != 0L) return 202;
			 return -1;
			 case 3: if ((active0 & 0x600040000000000L) != 0L || (active1 & 0x400L) != 0L) return 202;
			 if ((active0 & 0x180004000000000L) != 0L || (active1 & 0xe8L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 3;
				 return 202;
			 }
			 return -1;
			 case 4: if ((active0 & 0x180004000000000L) != 0L || (active1 & 0xa0L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 4;
				 return 202;
			 }
			 if ((active1 & 0x48L) != 0L) return 202;
			 return -1;
			 case 5: if ((active0 & 0x80004000000000L) != 0L || (active1 & 0x20L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 5;
				 return 202;
			 }
			 if ((active0 & 0x100000000000000L) != 0L || (active1 & 0x80L) != 0L) return 202;
			 return -1;
			 case 6: if ((active0 & 0x80004000000000L) != 0L || (active1 & 0x20L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 6;
				 return 202;
			 }
			 return -1;
			 case 7: if ((active0 & 0x80000000000000L) != 0L || (active1 & 0x20L) != 0L) {
				 jjmatchedKind = 183;
				 jjmatchedPos = 7;
				 return 202;
			 }
			 if ((active0 & 0x4000000000L) != 0L) return 202;
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_4(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_4(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_4(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_4(){
		 switch(curChar) {
			 case 33: return jjMoveStringLiteralDfa1_4(0x0L, 0x1000000000000L, 0x0L);
			 case 36: return jjStopAtPos(0, 49);
			 case 40: jjmatchedKind = 134;
			 return jjMoveStringLiteralDfa1_4(0x0L, 0x0L, 0x840000000L);
			 case 44: return jjStopAtPos(0, 168);
			 case 45: return jjStopAtPos(0, 126);
			 case 58: return jjMoveStringLiteralDfa1_4(0x0L, 0x800000000000000L, 0x0L);
			 case 59: return jjStopAtPos(0, 170);
			 case 60: jjmatchedKind = 124;
			 return jjMoveStringLiteralDfa1_4(0x0L, 0x6000000000000L, 0x0L);
			 case 61: return jjStopAtPos(0, 109);
			 case 62: jjmatchedKind = 125;
			 return jjMoveStringLiteralDfa1_4(0x0L, 0x18000000000000L, 0x0L);
			 case 91: return jjStopAtPos(0, 136);
			 case 97: return jjMoveStringLiteralDfa1_4(0x10000000000L, 0x300L, 0x0L);
			 case 99: return jjMoveStringLiteralDfa1_4(0x0L, 0x400L, 0x0L);
			 case 100: return jjMoveStringLiteralDfa1_4(0x20000000000L, 0x0L, 0x0L);
			 case 101: return jjMoveStringLiteralDfa1_4(0x400004000000000L, 0x20000000000080L, 0x0L);
			 case 103: return jjMoveStringLiteralDfa1_4(0x0L, 0x180000000000000L, 0x0L);
			 case 105: return jjMoveStringLiteralDfa1_4(0x240000000000L, 0x800000000020L, 0x0L);
			 case 108: return jjMoveStringLiteralDfa1_4(0x0L, 0x600000000000000L, 0x0L);
			 case 109: return jjMoveStringLiteralDfa1_4(0x80000000000L, 0x0L, 0x0L);
			 case 110: return jjMoveStringLiteralDfa1_4(0x0L, 0x40000000000000L, 0x0L);
			 case 111: return jjMoveStringLiteralDfa1_4(0x8000000000L, 0x0L, 0x0L);
			 case 114: return jjMoveStringLiteralDfa1_4(0x100000000000000L, 0x0L, 0x0L);
			 case 115: return jjMoveStringLiteralDfa1_4(0x80000000000000L, 0x0L, 0x0L);
			 case 116: return jjMoveStringLiteralDfa1_4(0x200000000000000L, 0x4L, 0x0L);
			 case 117: return jjMoveStringLiteralDfa1_4(0x0L, 0x40L, 0x0L);
			 case 119: return jjMoveStringLiteralDfa1_4(0x0L, 0x8L, 0x0L);
			 case 124: return jjStopAtPos(0, 133);
			 default : return jjMoveNfa_4(15, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_4(long active0, long active1, long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(0, active0, active1, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_4(active0, 0L, active1, 0L, active3, 0x40000000L);
			 case 60: if ((active1 & 0x4000000000000L) != 0L) return jjStopAtPos(1, 114);
			 break;
			 case 61: if ((active1 & 0x1000000000000L) != 0L) return jjStopAtPos(1, 112);
			 else if ((active1 & 0x2000000000000L) != 0L) return jjStopAtPos(1, 113);
			 else if ((active1 & 0x8000000000000L) != 0L) return jjStopAtPos(1, 115);
			 else if ((active1 & 0x800000000000000L) != 0L) return jjStopAtPos(1, 123);
			 break;
			 case 62: if ((active1 & 0x10000000000000L) != 0L) return jjStopAtPos(1, 116);
			 break;
			 case 97: return jjMoveStringLiteralDfa2_4(active0, 0x80000000000000L, active1, 0x400L, active3, 0L);
			 case 100: return jjMoveStringLiteralDfa2_4(active0, 0x40000000000L, active1, 0L, active3, 0L);
			 case 101: if ((active1 & 0x40000000000000L) != 0L) return jjStartNfaWithStates_4(1, 118, 202);
			 else if ((active1 & 0x100000000000000L) != 0L) return jjStartNfaWithStates_4(1, 120, 202);
			 else if ((active1 & 0x400000000000000L) != 0L) return jjStartNfaWithStates_4(1, 122, 202);
			 return jjMoveStringLiteralDfa2_4(active0, 0x100000000000000L, active1, 0L, active3, 0L);
			 case 104: return jjMoveStringLiteralDfa2_4(active0, 0x200000000000000L, active1, 0x8L, active3, 0L);
			 case 105: return jjMoveStringLiteralDfa2_4(active0, 0x20000000000L, active1, 0L, active3, 0L);
			 case 108: return jjMoveStringLiteralDfa2_4(active0, 0x400000000000000L, active1, 0L, active3, 0L);
			 case 110: if ((active0 & 0x200000000000L) != 0L) {
				 jjmatchedKind = 45;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_4(active0, 0x10000000000L, active1, 0x60L, active3, 0L);
			 case 111: if ((active1 & 0x4L) != 0L) return jjStartNfaWithStates_4(1, 66, 202);
			 return jjMoveStringLiteralDfa2_4(active0, 0x80000000000L, active1, 0L, active3, 0L);
			 case 113: if ((active1 & 0x20000000000000L) != 0L) return jjStartNfaWithStates_4(1, 117, 202);
			 break;
			 case 114: if ((active0 & 0x8000000000L) != 0L) return jjStartNfaWithStates_4(1, 39, 51);
			 break;
			 case 115: if ((active1 & 0x100L) != 0L) return jjStartNfaWithStates_4(1, 72, 202);
			 else if ((active1 & 0x800000000000L) != 0L) return jjStartNfaWithStates_4(1, 111, 202);
			 break;
			 case 116: if ((active1 & 0x200L) != 0L) return jjStartNfaWithStates_4(1, 73, 71);
			 else if ((active1 & 0x80000000000000L) != 0L) return jjStartNfaWithStates_4(1, 119, 202);
			 else if ((active1 & 0x200000000000000L) != 0L) return jjStartNfaWithStates_4(1, 121, 202);
			 break;
			 case 120: return jjMoveStringLiteralDfa2_4(active0, 0x4000000000L, active1, 0x80L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_4(0, active0, active1, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_4(long old0, long active0, long old1, long active1, long old3, long active3){
		 if (((active0 &= old0) | (active1 &= old1) | (active3 &= old3)) == 0L) return jjStartNfa_4(0, old0, old1, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(1, active0, active1, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 case 99: return jjMoveStringLiteralDfa3_4(active0, 0L, active1, 0x80L, active3, 0L);
			 case 100: if ((active0 & 0x10000000000L) != 0L) return jjStartNfaWithStates_4(2, 40, 202);
			 else if ((active0 & 0x80000000000L) != 0L) return jjStartNfaWithStates_4(2, 43, 202);
			 break;
			 case 101: return jjMoveStringLiteralDfa3_4(active0, 0x200000000000000L, active1, 0x8L, active3, 0L);
			 case 105: return jjMoveStringLiteralDfa3_4(active0, 0x40000000000L, active1, 0x40L, active3, 0L);
			 case 115: return jjMoveStringLiteralDfa3_4(active0, 0x400000000000000L, active1, 0x400L, active3, 0L);
			 case 116: return jjMoveStringLiteralDfa3_4(active0, 0x180004000000000L, active1, 0x20L, active3, 0L);
			 case 118: if ((active0 & 0x20000000000L) != 0L) return jjStartNfaWithStates_4(2, 41, 202);
			 break;
			 default : break;
		 }
		 return jjStartNfa_4(1, active0, active1, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa3_4(long old0, long active0, long old1, long active1, long old3, long active3){
		 if (((active0 &= old0) | (active1 &= old1) | (active3 &= old3)) == 0L) return jjStartNfa_4(1, old0, old1, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(2, active0, active1, 0L, 0L);
			 return 3;
		 }
		 switch(curChar) {
			 case 101: if ((active0 & 0x400000000000000L) != 0L) return jjStartNfaWithStates_4(3, 58, 202);
			 else if ((active1 & 0x400L) != 0L) return jjStartNfaWithStates_4(3, 74, 202);
			 return jjMoveStringLiteralDfa4_4(active0, 0x4000000000L, active1, 0xa0L);
			 case 105: return jjMoveStringLiteralDfa4_4(active0, 0x80000000000000L, active1, 0L);
			 case 110: if ((active0 & 0x200000000000000L) != 0L) return jjStartNfaWithStates_4(3, 57, 202);
			 break;
			 case 111: return jjMoveStringLiteralDfa4_4(active0, 0L, active1, 0x40L);
			 case 114: return jjMoveStringLiteralDfa4_4(active0, 0L, active1, 0x8L);
			 case 117: return jjMoveStringLiteralDfa4_4(active0, 0x100000000000000L, active1, 0L);
			 case 118: if ((active0 & 0x40000000000L) != 0L) return jjStartNfaWithStates_4(3, 42, 202);
			 break;
			 default : break;
		 }
		 return jjStartNfa_4(2, active0, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa4_4(long old0, long active0, long old1, long active1){
		 if (((active0 &= old0) | (active1 &= old1)) == 0L) return jjStartNfa_4(2, old0, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(3, active0, active1, 0L, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 101: if ((active1 & 0x8L) != 0L) return jjStartNfaWithStates_4(4, 67, 202);
			 break;
			 case 110: if ((active1 & 0x40L) != 0L) return jjStartNfaWithStates_4(4, 70, 202);
			 break;
			 case 112: return jjMoveStringLiteralDfa5_4(active0, 0L, active1, 0x80L);
			 case 114: return jjMoveStringLiteralDfa5_4(active0, 0x100004000000000L, active1, 0x20L);
			 case 115: return jjMoveStringLiteralDfa5_4(active0, 0x80000000000000L, active1, 0L);
			 default : break;
		 }
		 return jjStartNfa_4(3, active0, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa5_4(long old0, long active0, long old1, long active1){
		 if (((active0 &= old0) | (active1 &= old1)) == 0L) return jjStartNfa_4(3, old0, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(4, active0, active1, 0L, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 102: return jjMoveStringLiteralDfa6_4(active0, 0x80000000000000L, active1, 0L);
			 case 110: if ((active0 & 0x100000000000000L) != 0L) return jjStartNfaWithStates_4(5, 56, 202);
			 return jjMoveStringLiteralDfa6_4(active0, 0x4000000000L, active1, 0L);
			 case 115: return jjMoveStringLiteralDfa6_4(active0, 0L, active1, 0x20L);
			 case 116: if ((active1 & 0x80L) != 0L) return jjStartNfaWithStates_4(5, 71, 202);
			 break;
			 default : break;
		 }
		 return jjStartNfa_4(4, active0, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa6_4(long old0, long active0, long old1, long active1){
		 if (((active0 &= old0) | (active1 &= old1)) == 0L) return jjStartNfa_4(4, old0, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(5, active0, active1, 0L, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa7_4(active0, 0x4000000000L, active1, 0L);
			 case 101: return jjMoveStringLiteralDfa7_4(active0, 0L, active1, 0x20L);
			 case 105: return jjMoveStringLiteralDfa7_4(active0, 0x80000000000000L, active1, 0L);
			 default : break;
		 }
		 return jjStartNfa_4(5, active0, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa7_4(long old0, long active0, long old1, long active1){
		 if (((active0 &= old0) | (active1 &= old1)) == 0L) return jjStartNfa_4(5, old0, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(6, active0, active1, 0L, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 99: return jjMoveStringLiteralDfa8_4(active0, 0L, active1, 0x20L);
			 case 101: return jjMoveStringLiteralDfa8_4(active0, 0x80000000000000L, active1, 0L);
			 case 108: if ((active0 & 0x4000000000L) != 0L) return jjStartNfaWithStates_4(7, 38, 202);
			 break;
			 default : break;
		 }
		 return jjStartNfa_4(6, active0, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa8_4(long old0, long active0, long old1, long active1){
		 if (((active0 &= old0) | (active1 &= old1)) == 0L) return jjStartNfa_4(6, old0, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_4(7, active0, active1, 0L, 0L);
			 return 8;
		 }
		 switch(curChar) {
			 case 115: if ((active0 & 0x80000000000000L) != 0L) return jjStartNfaWithStates_4(8, 55, 202);
			 break;
			 case 116: if ((active1 & 0x20L) != 0L) return jjStartNfaWithStates_4(8, 69, 202);
			 break;
			 default : break;
		 }
		 return jjStartNfa_4(7, active0, active1, 0L, 0L);
	}
	private final int jjMoveNfa_4(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 202;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 51: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 101: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 161: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 44: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 14: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 202: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 71: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if ((0x100002600L & l) != 0L) jjCheckNAddStates(16, 18);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 else if (curChar == 39) jjCheckNAddTwoStates(61, 62);
						 else if (curChar == 34) jjCheckNAddTwoStates(58, 59);
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 99: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 124: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 83: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 131: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 55: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 82: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 52: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 140: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 15: case 0: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(0);
						 break;
						 case 100: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 2: if ((0x100002600L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 40 && kind > 150) kind = 150;
						 break;
						 case 7: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 6;
						 break;
						 case 17: if ((0x100002600L & l) != 0L) jjAddStates(19, 20);
						 break;
						 case 18: if (curChar == 40 && kind > 162) kind = 162;
						 break;
						 case 29: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 28;
						 break;
						 case 41: if ((0x100002600L & l) != 0L) jjAddStates(21, 22);
						 break;
						 case 42: if (curChar == 40 && kind > 165) kind = 165;
						 break;
						 case 47: if ((0x100002600L & l) != 0L) jjAddStates(23, 24);
						 break;
						 case 56: if ((0x100002600L & l) != 0L) jjCheckNAddStates(16, 18);
						 break;
						 case 57: if (curChar == 34) jjCheckNAddTwoStates(58, 59);
						 break;
						 case 58: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(58, 59);
						 break;
						 case 59: if (curChar != 34) break;
						 if (kind > 9) kind = 9;
						 jjCheckNAdd(57);
						 break;
						 case 60: if (curChar == 39) jjCheckNAddTwoStates(61, 62);
						 break;
						 case 61: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(61, 62);
						 break;
						 case 62: if (curChar != 39) break;
						 if (kind > 9) kind = 9;
						 jjCheckNAdd(60);
						 break;
						 case 64: if ((0x100002600L & l) != 0L) jjAddStates(25, 26);
						 break;
						 case 65: if (curChar == 40 && kind > 158) kind = 158;
						 break;
						 case 75: if ((0x100002600L & l) != 0L) jjAddStates(27, 28);
						 break;
						 case 85: if ((0x100002600L & l) != 0L) jjAddStates(29, 30);
						 break;
						 case 86: if (curChar == 40) jjCheckNAddTwoStates(87, 88);
						 break;
						 case 87: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(87, 88);
						 break;
						 case 88: if (curChar == 41 && kind > 77) kind = 77;
						 break;
						 case 93: if ((0x100002600L & l) != 0L) jjAddStates(31, 32);
						 break;
						 case 103: if ((0x100002600L & l) != 0L) jjAddStates(33, 34);
						 break;
						 case 109: if ((0x100002600L & l) != 0L) jjAddStates(35, 36);
						 break;
						 case 110: if (curChar == 40 && kind > 164) kind = 164;
						 break;
						 case 118: if ((0x100002600L & l) != 0L) jjAddStates(37, 38);
						 break;
						 case 119: if (curChar == 40) jjCheckNAddTwoStates(120, 121);
						 break;
						 case 120: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(120, 121);
						 break;
						 case 121: if (curChar == 41 && kind > 96) kind = 96;
						 break;
						 case 126: if ((0x100002600L & l) != 0L) jjAddStates(39, 40);
						 break;
						 case 127: if (curChar == 40 && kind > 156) kind = 156;
						 break;
						 case 135: if ((0x100002600L & l) != 0L) jjAddStates(41, 42);
						 break;
						 case 142: if ((0x100002600L & l) != 0L) jjAddStates(43, 44);
						 break;
						 case 143: if (curChar == 40 && kind > 163) kind = 163;
						 break;
						 case 148: if ((0x100002600L & l) != 0L) jjAddStates(45, 46);
						 break;
						 case 149: if (curChar == 40 && kind > 159) kind = 159;
						 break;
						 case 156: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 155;
						 break;
						 case 163: if ((0x100002600L & l) != 0L) jjAddStates(47, 48);
						 break;
						 case 164: if (curChar == 40 && kind > 161) kind = 161;
						 break;
						 case 173: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 172;
						 break;
						 case 180: if ((0x100002600L & l) != 0L) jjAddStates(49, 50);
						 break;
						 case 182: if ((0x100002600L & l) != 0L) jjAddStates(51, 52);
						 break;
						 case 194: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 195: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 196;
						 break;
						 case 197: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAdd(197);
						 break;
						 case 198: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 break;
						 case 199: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 200;
						 break;
						 case 201: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(201);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 51: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 100) jjstateSet[jjnewStateCnt++] = 50;
						 break;
						 case 101: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 111) jjstateSet[jjnewStateCnt++] = 114;
						 else if (curChar == 97) jjstateSet[jjnewStateCnt++] = 106;
						 if (curChar == 97) jjstateSet[jjnewStateCnt++] = 100;
						 break;
						 case 161: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 191;
						 else if (curChar == 99) jjstateSet[jjnewStateCnt++] = 177;
						 if (curChar == 99) jjstateSet[jjnewStateCnt++] = 160;
						 break;
						 case 44: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 111) jjstateSet[jjnewStateCnt++] = 43;
						 break;
						 case 14: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 111) jjstateSet[jjnewStateCnt++] = 13;
						 break;
						 case 202: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 71: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 70;
						 break;
						 case 99: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 103;
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 98;
						 break;
						 case 124: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 108) jjstateSet[jjnewStateCnt++] = 131;
						 else if (curChar == 109) jjstateSet[jjnewStateCnt++] = 123;
						 break;
						 case 83: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 89;
						 else if (curChar == 110) jjstateSet[jjnewStateCnt++] = 82;
						 break;
						 case 131: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 101) jjstateSet[jjnewStateCnt++] = 130;
						 break;
						 case 55: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 71;
						 if (curChar == 116) jjAddStates(16, 18);
						 break;
						 case 82: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 81;
						 break;
						 case 52: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 114) jjstateSet[jjnewStateCnt++] = 51;
						 break;
						 case 140: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 101) jjstateSet[jjnewStateCnt++] = 144;
						 else if (curChar == 114) jjstateSet[jjnewStateCnt++] = 139;
						 break;
						 case 15: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAddStates(53, 58);
						 }
						 if (curChar == 115) jjAddStates(59, 61);
						 else if (curChar == 116) jjAddStates(62, 63);
						 else if (curChar == 101) jjAddStates(64, 65);
						 else if (curChar == 99) jjAddStates(66, 68);
						 else if (curChar == 105) jjAddStates(69, 70);
						 else if (curChar == 97) jjAddStates(71, 72);
						 else if (curChar == 111) jjstateSet[jjnewStateCnt++] = 52;
						 else if (curChar == 110) jjstateSet[jjnewStateCnt++] = 44;
						 else if (curChar == 112) jjstateSet[jjnewStateCnt++] = 38;
						 else if (curChar == 100) jjstateSet[jjnewStateCnt++] = 14;
						 break;
						 case 100: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 102;
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 99;
						 break;
						 case 1: if (curChar == 101) jjAddStates(4, 5);
						 break;
						 case 4: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 1;
						 break;
						 case 5: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 6: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 case 8: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 7;
						 break;
						 case 9: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 8;
						 break;
						 case 10: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 10;
						 break;
						 case 12: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 16: if (curChar == 110) jjAddStates(19, 20);
						 break;
						 case 19: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 16;
						 break;
						 case 20: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 19;
						 break;
						 case 21: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 20;
						 break;
						 case 22: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 21;
						 break;
						 case 23: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 22;
						 break;
						 case 24: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 23;
						 break;
						 case 25: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 24;
						 break;
						 case 26: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 25;
						 break;
						 case 27: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 26;
						 break;
						 case 28: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 27;
						 break;
						 case 30: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 29;
						 break;
						 case 31: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 30;
						 break;
						 case 32: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 31;
						 break;
						 case 33: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 32;
						 break;
						 case 34: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 33;
						 break;
						 case 35: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 34;
						 break;
						 case 36: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 35;
						 break;
						 case 37: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 36;
						 break;
						 case 38: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 37;
						 break;
						 case 39: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 38;
						 break;
						 case 40: if (curChar == 101) jjAddStates(21, 22);
						 break;
						 case 43: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 40;
						 break;
						 case 45: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 44;
						 break;
						 case 46: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 47;
						 break;
						 case 48: if (curChar == 121 && kind > 176) kind = 176;
						 break;
						 case 49: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 48;
						 break;
						 case 50: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 46;
						 break;
						 case 53: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 52;
						 break;
						 case 54: if (curChar == 97) jjAddStates(71, 72);
						 break;
						 case 58: jjAddStates(73, 74);
						 break;
						 case 61: jjAddStates(75, 76);
						 break;
						 case 63: if (curChar == 101) jjAddStates(25, 26);
						 break;
						 case 66: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 63;
						 break;
						 case 67: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 66;
						 break;
						 case 68: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 67;
						 break;
						 case 69: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 68;
						 break;
						 case 70: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 69;
						 break;
						 case 72: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 71;
						 break;
						 case 73: if (curChar == 105) jjAddStates(69, 70);
						 break;
						 case 74: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 75;
						 break;
						 case 76: if (curChar == 102 && kind > 75) kind = 75;
						 break;
						 case 77: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 76;
						 break;
						 case 78: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 74;
						 break;
						 case 79: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 78;
						 break;
						 case 80: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 79;
						 break;
						 case 81: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 80;
						 break;
						 case 84: if (curChar == 109) jjAddStates(29, 30);
						 break;
						 case 89: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 84;
						 break;
						 case 90: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 89;
						 break;
						 case 91: if (curChar == 99) jjAddStates(66, 68);
						 break;
						 case 92: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 93;
						 break;
						 case 94: if (curChar == 115 && kind > 76) kind = 76;
						 break;
						 case 95: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 94;
						 break;
						 case 96: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 92;
						 break;
						 case 97: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 96;
						 break;
						 case 98: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 97;
						 break;
						 case 102: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 103;
						 break;
						 case 104: if (curChar == 115 && kind > 144) kind = 144;
						 break;
						 case 105: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 104;
						 break;
						 case 106: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 102;
						 break;
						 case 107: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 106;
						 break;
						 case 108: if (curChar == 116) jjAddStates(35, 36);
						 break;
						 case 111: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 108;
						 break;
						 case 112: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 111;
						 break;
						 case 113: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 112;
						 break;
						 case 114: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 113;
						 break;
						 case 115: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 114;
						 break;
						 case 116: if (curChar == 101) jjAddStates(64, 65);
						 break;
						 case 117: if (curChar == 121) jjAddStates(37, 38);
						 break;
						 case 122: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 117;
						 break;
						 case 123: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 122;
						 break;
						 case 125: if (curChar == 116) jjAddStates(39, 40);
						 break;
						 case 128: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 125;
						 break;
						 case 129: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 128;
						 break;
						 case 130: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 129;
						 break;
						 case 132: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 131;
						 break;
						 case 133: if (curChar == 116) jjAddStates(62, 63);
						 break;
						 case 134: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 135;
						 break;
						 case 136: if (curChar == 115 && kind > 145) kind = 145;
						 break;
						 case 137: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 136;
						 break;
						 case 138: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 134;
						 break;
						 case 139: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 138;
						 break;
						 case 141: if (curChar == 116) jjAddStates(43, 44);
						 break;
						 case 144: if (curChar == 120) jjstateSet[jjnewStateCnt++] = 141;
						 break;
						 case 145: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 144;
						 break;
						 case 146: if (curChar == 115) jjAddStates(59, 61);
						 break;
						 case 147: if (curChar == 116) jjAddStates(45, 46);
						 break;
						 case 150: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 147;
						 break;
						 case 151: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 150;
						 break;
						 case 152: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 151;
						 break;
						 case 153: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 152;
						 break;
						 case 154: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 153;
						 break;
						 case 155: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 154;
						 break;
						 case 157: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 156;
						 break;
						 case 158: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 157;
						 break;
						 case 159: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 158;
						 break;
						 case 160: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 159;
						 break;
						 case 162: if (curChar == 101) jjAddStates(47, 48);
						 break;
						 case 165: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 162;
						 break;
						 case 166: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 165;
						 break;
						 case 167: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 166;
						 break;
						 case 168: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 167;
						 break;
						 case 169: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 168;
						 break;
						 case 170: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 169;
						 break;
						 case 171: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 170;
						 break;
						 case 172: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 171;
						 break;
						 case 174: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 173;
						 break;
						 case 175: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 174;
						 break;
						 case 176: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 175;
						 break;
						 case 177: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 176;
						 break;
						 case 178: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 177;
						 break;
						 case 179: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 180;
						 break;
						 case 181: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 182;
						 break;
						 case 183: if (curChar == 121 && kind > 177) kind = 177;
						 break;
						 case 184: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 183;
						 break;
						 case 185: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 181;
						 break;
						 case 186: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 185;
						 break;
						 case 187: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 186;
						 break;
						 case 188: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 187;
						 break;
						 case 189: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 179;
						 break;
						 case 190: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 189;
						 break;
						 case 191: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 190;
						 break;
						 case 192: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 191;
						 break;
						 case 193: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAddStates(53, 58);
						 break;
						 case 194: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 196: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAdd(197);
						 break;
						 case 197: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAdd(197);
						 break;
						 case 198: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(198, 199);
						 break;
						 case 200: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(201);
						 break;
						 case 201: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(201);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 51: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 101: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 161: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 44: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 14: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 202: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 71: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 99: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 124: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 83: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 131: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 55: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 82: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 52: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 140: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 15: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAddStates(53, 58);
						 break;
						 case 100: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 183) kind = 183;
							 jjCheckNAdd(197);
						 }
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 184) kind = 184;
							 jjCheckNAdd(201);
						 }
						 break;
						 case 58: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(73, 74);
						 break;
						 case 61: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(75, 76);
						 break;
						 case 194: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(194, 195);
						 break;
						 case 196: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAdd(197);
						 break;
						 case 197: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 183) kind = 183;
						 jjCheckNAdd(197);
						 break;
						 case 198: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(198, 199);
						 break;
						 case 200: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(201);
						 break;
						 case 201: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(201);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 202 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjMoveStringLiteralDfa0_18(){
		 return jjMoveNfa_18(1, 0);
	}
	private final int jjMoveNfa_18(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 6;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 239;
						 jjCheckNAdd(0);
						 break;
						 case 2: if ((0x3ff600000000000L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 5: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 186) kind = 186;
						 jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 186) kind = 186;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: case 5: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 186) kind = 186;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 186) kind = 186;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 186) kind = 186;
						 jjCheckNAdd(5);
						 break;
						 case 5: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 186) kind = 186;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_13(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x8000L) != 0L) {
				 jjmatchedKind = 210;
				 return -1;
			 }
			 return -1;
			 case 1: if ((active3 & 0x8000L) != 0L) {
				 if (jjmatchedPos == 0) {
					 jjmatchedKind = 210;
					 jjmatchedPos = 0;
				 }
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_13(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_13(jjStopStringLiteralDfa_13(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_13(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_13(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_13(){
		 switch(curChar) {
			 case 60: jjmatchedKind = 196;
			 return jjMoveStringLiteralDfa1_13(0x10000L, 0x8000000000000000L, 0x20000000100L);
			 case 123: jjmatchedKind = 204;
			 return jjMoveStringLiteralDfa1_13(0x0L, 0x0L, 0x4000L);
			 case 125: return jjMoveStringLiteralDfa1_13(0x0L, 0x0L, 0x8000L);
			 default : return jjMoveNfa_13(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_13(long active0, long active2, long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(0, active0, 0L, active2, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 33: return jjMoveStringLiteralDfa2_13(active0, 0L, active2, 0x8000000000000000L, active3, 0x20000000000L);
			 case 47: if ((active3 & 0x100L) != 0L) return jjStopAtPos(1, 200);
			 break;
			 case 63: if ((active0 & 0x10000L) != 0L) return jjStopAtPos(1, 16);
			 break;
			 case 123: if ((active3 & 0x4000L) != 0L) return jjStopAtPos(1, 206);
			 break;
			 case 125: if ((active3 & 0x8000L) != 0L) return jjStopAtPos(1, 207);
			 break;
			 default : break;
		 }
		 return jjStartNfa_13(0, active0, 0L, active2, active3);
	}
	private final int jjMoveStringLiteralDfa2_13(long old0, long active0, long old2, long active2, long old3, long active3){
		 if (((active0 &= old0) | (active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_13(0, old0, 0L, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(1, 0L, 0L, active2, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 45: return jjMoveStringLiteralDfa3_13(active2, 0L, active3, 0x20000000000L);
			 case 91: return jjMoveStringLiteralDfa3_13(active2, 0x8000000000000000L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_13(1, 0L, 0L, active2, active3);
	}
	private final int jjMoveStringLiteralDfa3_13(long old2, long active2, long old3, long active3){
		 if (((active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_13(1, 0L, 0L, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(2, 0L, 0L, active2, active3);
			 return 3;
		 }
		 switch(curChar) {
			 case 45: if ((active3 & 0x20000000000L) != 0L) return jjStopAtPos(3, 233);
			 break;
			 case 67: return jjMoveStringLiteralDfa4_13(active2, 0x8000000000000000L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_13(2, 0L, 0L, active2, active3);
	}
	private final int jjMoveStringLiteralDfa4_13(long old2, long active2, long old3, long active3){
		 if (((active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_13(2, 0L, 0L, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(3, 0L, 0L, active2, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 68: return jjMoveStringLiteralDfa5_13(active2, 0x8000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_13(3, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa5_13(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_13(3, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(4, 0L, 0L, active2, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 65: return jjMoveStringLiteralDfa6_13(active2, 0x8000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_13(4, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa6_13(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_13(4, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(5, 0L, 0L, active2, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 84: return jjMoveStringLiteralDfa7_13(active2, 0x8000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_13(5, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa7_13(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_13(5, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(6, 0L, 0L, active2, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 65: return jjMoveStringLiteralDfa8_13(active2, 0x8000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_13(6, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa8_13(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_13(6, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_13(7, 0L, 0L, active2, 0L);
			 return 8;
		 }
		 switch(curChar) {
			 case 91: if ((active2 & 0x8000000000000000L) != 0L) return jjStopAtPos(8, 191);
			 break;
			 default : break;
		 }
		 return jjStartNfa_13(7, 0L, 0L, active2, 0L);
	}
	private final int jjMoveNfa_13(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 21;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) {
							 if (kind > 210) kind = 210;
						 }
						 if (curChar == 38) jjstateSet[jjnewStateCnt++] = 14;
						 if (curChar == 38) jjAddStates(77, 80);
						 break;
						 case 2: if (curChar == 59 && kind > 193) kind = 193;
						 break;
						 case 14: if (curChar == 35) jjCheckNAddTwoStates(15, 17);
						 break;
						 case 15: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(15, 16);
						 break;
						 case 16: if (curChar == 59 && kind > 194) kind = 194;
						 break;
						 case 18: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(18, 16);
						 break;
						 case 19: if (curChar == 38) jjstateSet[jjnewStateCnt++] = 14;
						 break;
						 case 20: if ((0xffffffff00002600L & l) != 0L && kind > 210) kind = 210;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (kind > 210) kind = 210;
						 break;
						 case 1: if (curChar == 116) jjCheckNAdd(2);
						 break;
						 case 3: if (curChar == 108) jjCheckNAdd(1);
						 break;
						 case 4: if (curChar == 103) jjCheckNAdd(1);
						 break;
						 case 5: if (curChar == 111) jjCheckNAdd(1);
						 break;
						 case 6: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 case 7: if (curChar == 113) jjstateSet[jjnewStateCnt++] = 6;
						 break;
						 case 8: if (curChar == 97) jjAddStates(81, 82);
						 break;
						 case 9: if (curChar == 112) jjCheckNAdd(2);
						 break;
						 case 10: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 115) jjCheckNAdd(2);
						 break;
						 case 12: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 17: if (curChar == 120) jjCheckNAdd(18);
						 break;
						 case 18: if ((0x7e0000007eL & l) != 0L) jjCheckNAddTwoStates(18, 16);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 210) kind = 210;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 21 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_1(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active0 & 0x80000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 return 57;
			 }
			 if ((active0 & 0x240000000000L) != 0L || (active1 & 0x800000000020L) != 0L) {
				 jjmatchedKind = 249;
				 return 24;
			 }
			 if ((active1 & 0x600000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 return 34;
			 }
			 if ((active1 & 0x410L) != 0L) {
				 jjmatchedKind = 249;
				 return 82;
			 }
			 if ((active0 & 0x400004000000000L) != 0L || (active1 & 0x20000000000080L) != 0L) {
				 jjmatchedKind = 249;
				 return 102;
			 }
			 if ((active0 & 0x9000b3200000000L) != 0L || (active1 & 0x1c0000000000348L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 return 52;
			 }
			 if ((active0 & 0x200000000000000L) != 0L || (active1 & 0x4L) != 0L) {
				 jjmatchedKind = 249;
				 return 42;
			 }
			 if ((active0 & 0x8100000000L) != 0L) {
				 jjmatchedKind = 249;
				 return 50;
			 }
			 return -1;
			 case 1: if ((active0 & 0x8100000000L) != 0L) return 49;
			 if ((active0 & 0x200000000000L) != 0L || (active1 & 0x20L) != 0L) return 23;
			 if ((active1 & 0x400000000000000L) != 0L) return 31;
			 if ((active0 & 0x2000000000L) != 0L || (active1 & 0x3e0800000000304L) != 0L || (active2 & 0x4000000000000L) != 0L) return 52;
			 if ((active1 & 0x400L) != 0L) {
				 if (jjmatchedPos != 1) {
					 jjmatchedKind = 249;
					 jjmatchedPos = 1;
				 }
				 return 81;
			 }
			 if ((active0 & 0xf800f5200000000L) != 0L || (active1 & 0xd8L) != 0L || (active2 & 0x8000000000000L) != 0L) {
				 if (jjmatchedPos != 1) {
					 jjmatchedKind = 249;
					 jjmatchedPos = 1;
				 }
				 return 52;
			 }
			 return -1;
			 case 2: if ((active0 & 0xf80044200000000L) != 0L || (active1 & 0xf8L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 2;
				 return 52;
			 }
			 if ((active1 & 0x400L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 2;
				 return 80;
			 }
			 if ((active0 & 0xb1000000000L) != 0L) return 52;
			 if ((active0 & 0x100000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 2;
				 return 48;
			 }
			 return -1;
			 case 3: if ((active0 & 0x980004200000000L) != 0L || (active1 & 0xf8L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 3;
				 return 52;
			 }
			 if ((active0 & 0x100000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 3;
				 return 44;
			 }
			 if ((active0 & 0x600040000000000L) != 0L || (active1 & 0x400L) != 0L) return 52;
			 return -1;
			 case 4: if ((active0 & 0x100000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 4;
				 return 113;
			 }
			 if ((active1 & 0x48L) != 0L) return 52;
			 if ((active0 & 0x980004200000000L) != 0L || (active1 & 0xb0L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 4;
				 return 52;
			 }
			 return -1;
			 case 5: if ((active0 & 0x880004300000000L) != 0L || (active1 & 0x30L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 5;
				 return 52;
			 }
			 if ((active0 & 0x100000000000000L) != 0L || (active1 & 0x80L) != 0L) return 52;
			 return -1;
			 case 6: if ((active0 & 0x80004200000000L) != 0L || (active1 & 0x30L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 6;
				 return 52;
			 }
			 if ((active0 & 0x800000100000000L) != 0L) return 52;
			 return -1;
			 case 7: if ((active0 & 0x4000000000L) != 0L) return 52;
			 if ((active0 & 0x80000200000000L) != 0L || (active1 & 0x30L) != 0L || (active2 & 0xc000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 7;
				 return 52;
			 }
			 return -1;
			 case 8: if ((active2 & 0x8000000000000L) != 0L) {
				 jjmatchedKind = 249;
				 jjmatchedPos = 8;
				 return 52;
			 }
			 if ((active0 & 0x80000200000000L) != 0L || (active1 & 0x30L) != 0L || (active2 & 0x4000000000000L) != 0L) return 52;
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_1(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_1(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_1(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_1(){
		 switch(curChar) {
			 case 33: return jjMoveStringLiteralDfa1_1(0x0L, 0x1000000000000L, 0x0L, 0x0L);
			 case 36: return jjStopAtPos(0, 49);
			 case 37: return jjMoveStringLiteralDfa1_1(0x0L, 0x0L, 0x80000000000L, 0x0L);
			 case 40: return jjMoveStringLiteralDfa1_1(0x0L, 0x0L, 0x0L, 0x840000000L);
			 case 41: return jjStopAtPos(0, 138);
			 case 42: return jjStopAtPos(0, 44);
			 case 43: return jjStopAtPos(0, 127);
			 case 44: return jjStopAtPos(0, 168);
			 case 45: return jjStopAtPos(0, 126);
			 case 47: jjmatchedKind = 107;
			 return jjMoveStringLiteralDfa1_1(0x0L, 0x100000000000L, 0x0L, 0x0L);
			 case 58: return jjMoveStringLiteralDfa1_1(0x0L, 0x800000000000000L, 0x0L, 0x0L);
			 case 59: return jjStopAtPos(0, 170);
			 case 60: jjmatchedKind = 124;
			 return jjMoveStringLiteralDfa1_1(0x0L, 0x6000000000000L, 0x0L, 0x0L);
			 case 61: return jjStopAtPos(0, 109);
			 case 62: jjmatchedKind = 125;
			 return jjMoveStringLiteralDfa1_1(0x0L, 0x18000000000000L, 0x0L, 0x0L);
			 case 63: return jjStopAtPos(0, 130);
			 case 91: return jjStopAtPos(0, 136);
			 case 93: return jjStopAtPos(0, 137);
			 case 97: return jjMoveStringLiteralDfa1_1(0x10000000000L, 0x300L, 0x4000000000000L, 0x0L);
			 case 99: return jjMoveStringLiteralDfa1_1(0x0L, 0x410L, 0x0L, 0x0L);
			 case 100: return jjMoveStringLiteralDfa1_1(0x800020000000000L, 0x0L, 0x8000000000000L, 0x0L);
			 case 101: return jjMoveStringLiteralDfa1_1(0x400004000000000L, 0x20000000000080L, 0x0L, 0x0L);
			 case 103: return jjMoveStringLiteralDfa1_1(0x0L, 0x180000000000000L, 0x0L, 0x0L);
			 case 105: return jjMoveStringLiteralDfa1_1(0x240000000000L, 0x800000000020L, 0x0L, 0x0L);
			 case 108: return jjMoveStringLiteralDfa1_1(0x0L, 0x600000000000000L, 0x0L, 0x0L);
			 case 109: return jjMoveStringLiteralDfa1_1(0x80000000000L, 0x0L, 0x0L, 0x0L);
			 case 110: return jjMoveStringLiteralDfa1_1(0x2000000000L, 0x40000000000000L, 0x0L, 0x0L);
			 case 111: return jjMoveStringLiteralDfa1_1(0x8100000000L, 0x0L, 0x0L, 0x0L);
			 case 114: return jjMoveStringLiteralDfa1_1(0x100000000000000L, 0x0L, 0x0L, 0x0L);
			 case 115: return jjMoveStringLiteralDfa1_1(0x80000000000000L, 0x0L, 0x0L, 0x0L);
			 case 116: return jjMoveStringLiteralDfa1_1(0x200000000000000L, 0x4L, 0x0L, 0x0L);
			 case 117: return jjMoveStringLiteralDfa1_1(0x200000000L, 0x40L, 0x0L, 0x0L);
			 case 119: return jjMoveStringLiteralDfa1_1(0x0L, 0x8L, 0x0L, 0x0L);
			 case 121: return jjMoveStringLiteralDfa1_1(0x1000000000L, 0x0L, 0x0L, 0x0L);
			 case 123: return jjStopAtPos(0, 205);
			 case 124: return jjStopAtPos(0, 133);
			 case 125: return jjStopAtPos(0, 241);
			 default : return jjMoveNfa_1(14, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_1(long active0, long active1, long active2, long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(0, active0, active1, active2, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 37: return jjMoveStringLiteralDfa2_1(active0, 0L, active1, 0L, active2, 0x80000000000L, active3, 0L);
			 case 47: if ((active1 & 0x100000000000L) != 0L) return jjStopAtPos(1, 108);
			 break;
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_1(active0, 0L, active1, 0L, active2, 0L, active3, 0x40000000L);
			 case 60: if ((active1 & 0x4000000000000L) != 0L) return jjStopAtPos(1, 114);
			 break;
			 case 61: if ((active1 & 0x1000000000000L) != 0L) return jjStopAtPos(1, 112);
			 else if ((active1 & 0x2000000000000L) != 0L) return jjStopAtPos(1, 113);
			 else if ((active1 & 0x8000000000000L) != 0L) return jjStopAtPos(1, 115);
			 else if ((active1 & 0x800000000000000L) != 0L) return jjStopAtPos(1, 123);
			 break;
			 case 62: if ((active1 & 0x10000000000000L) != 0L) return jjStopAtPos(1, 116);
			 break;
			 case 97: return jjMoveStringLiteralDfa2_1(active0, 0x80000000000000L, active1, 0x400L, active2, 0L, active3, 0L);
			 case 100: return jjMoveStringLiteralDfa2_1(active0, 0x40000000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 101: if ((active1 & 0x40000000000000L) != 0L) return jjStartNfaWithStates_1(1, 118, 52);
			 else if ((active1 & 0x100000000000000L) != 0L) return jjStartNfaWithStates_1(1, 120, 52);
			 else if ((active1 & 0x400000000000000L) != 0L) return jjStartNfaWithStates_1(1, 122, 31);
			 return jjMoveStringLiteralDfa2_1(active0, 0x900001000000000L, active1, 0L, active2, 0x8000000000000L, active3, 0L);
			 case 104: return jjMoveStringLiteralDfa2_1(active0, 0x200000000000000L, active1, 0x8L, active2, 0L, active3, 0L);
			 case 105: return jjMoveStringLiteralDfa2_1(active0, 0x20000000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 108: return jjMoveStringLiteralDfa2_1(active0, 0x400000000000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 110: if ((active0 & 0x200000000000L) != 0L) {
				 jjmatchedKind = 45;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_1(active0, 0x10200000000L, active1, 0x60L, active2, 0L, active3, 0L);
			 case 111: if ((active0 & 0x2000000000L) != 0L) return jjStartNfaWithStates_1(1, 37, 52);
			 else if ((active1 & 0x4L) != 0L) return jjStartNfaWithStates_1(1, 66, 52);
			 return jjMoveStringLiteralDfa2_1(active0, 0x80000000000L, active1, 0x10L, active2, 0L, active3, 0L);
			 case 113: if ((active1 & 0x20000000000000L) != 0L) return jjStartNfaWithStates_1(1, 117, 52);
			 break;
			 case 114: if ((active0 & 0x8000000000L) != 0L) {
				 jjmatchedKind = 39;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_1(active0, 0x100000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 115: if ((active1 & 0x100L) != 0L) {
				 jjmatchedKind = 72;
				 jjmatchedPos = 1;
			 }
			 else if ((active1 & 0x800000000000L) != 0L) return jjStartNfaWithStates_1(1, 111, 52);
			 return jjMoveStringLiteralDfa2_1(active0, 0L, active1, 0L, active2, 0x4000000000000L, active3, 0L);
			 case 116: if ((active1 & 0x200L) != 0L) return jjStartNfaWithStates_1(1, 73, 52);
			 else if ((active1 & 0x80000000000000L) != 0L) return jjStartNfaWithStates_1(1, 119, 52);
			 else if ((active1 & 0x200000000000000L) != 0L) return jjStartNfaWithStates_1(1, 121, 52);
			 break;
			 case 120: return jjMoveStringLiteralDfa2_1(active0, 0x4000000000L, active1, 0x80L, active2, 0L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_1(0, active0, active1, active2, active3);
	}
	private final int jjMoveStringLiteralDfa2_1(long old0, long active0, long old1, long active1, long old2, long active2, long old3, long active3){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_1(0, old0, old1, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(1, active0, active1, active2, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 37: if ((active2 & 0x80000000000L) != 0L) return jjStopAtPos(2, 171);
			 break;
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 case 99: return jjMoveStringLiteralDfa3_1(active0, 0L, active1, 0x80L, active2, 0x4000000000000L, active3, 0L);
			 case 100: if ((active0 & 0x10000000000L) != 0L) return jjStartNfaWithStates_1(2, 40, 52);
			 else if ((active0 & 0x80000000000L) != 0L) return jjStartNfaWithStates_1(2, 43, 52);
			 return jjMoveStringLiteralDfa3_1(active0, 0x100000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 101: return jjMoveStringLiteralDfa3_1(active0, 0x200000000000000L, active1, 0x8L, active2, 0L, active3, 0L);
			 case 102: return jjMoveStringLiteralDfa3_1(active0, 0x800000000000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 105: return jjMoveStringLiteralDfa3_1(active0, 0x40000000000L, active1, 0x40L, active2, 0L, active3, 0L);
			 case 108: return jjMoveStringLiteralDfa3_1(active0, 0L, active1, 0x10L, active2, 0L, active3, 0L);
			 case 111: return jjMoveStringLiteralDfa3_1(active0, 0x200000000L, active1, 0L, active2, 0L, active3, 0L);
			 case 115: if ((active0 & 0x1000000000L) != 0L) return jjStartNfaWithStates_1(2, 36, 52);
			 return jjMoveStringLiteralDfa3_1(active0, 0x400000000000000L, active1, 0x400L, active2, 0x8000000000000L, active3, 0L);
			 case 116: return jjMoveStringLiteralDfa3_1(active0, 0x180004000000000L, active1, 0x20L, active2, 0L, active3, 0L);
			 case 118: if ((active0 & 0x20000000000L) != 0L) return jjStartNfaWithStates_1(2, 41, 52);
			 break;
			 default : break;
		 }
		 return jjStartNfa_1(1, active0, active1, active2, active3);
	}
	private final int jjMoveStringLiteralDfa3_1(long old0, long active0, long old1, long active1, long old2, long active2, long old3, long active3){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_1(1, old0, old1, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(2, active0, active1, active2, 0L);
			 return 3;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa4_1(active0, 0x800000000000000L, active1, 0L, active2, 0L);
			 case 99: return jjMoveStringLiteralDfa4_1(active0, 0L, active1, 0L, active2, 0x8000000000000L);
			 case 101: if ((active0 & 0x400000000000000L) != 0L) return jjStartNfaWithStates_1(3, 58, 52);
			 else if ((active1 & 0x400L) != 0L) return jjStartNfaWithStates_1(3, 74, 52);
			 return jjMoveStringLiteralDfa4_1(active0, 0x4100000000L, active1, 0xa0L, active2, 0x4000000000000L);
			 case 105: return jjMoveStringLiteralDfa4_1(active0, 0x80000000000000L, active1, 0L, active2, 0L);
			 case 108: return jjMoveStringLiteralDfa4_1(active0, 0L, active1, 0x10L, active2, 0L);
			 case 110: if ((active0 & 0x200000000000000L) != 0L) return jjStartNfaWithStates_1(3, 57, 52);
			 break;
			 case 111: return jjMoveStringLiteralDfa4_1(active0, 0L, active1, 0x40L, active2, 0L);
			 case 114: return jjMoveStringLiteralDfa4_1(active0, 0x200000000L, active1, 0x8L, active2, 0L);
			 case 117: return jjMoveStringLiteralDfa4_1(active0, 0x100000000000000L, active1, 0L, active2, 0L);
			 case 118: if ((active0 & 0x40000000000L) != 0L) return jjStartNfaWithStates_1(3, 42, 52);
			 break;
			 default : break;
		 }
		 return jjStartNfa_1(2, active0, active1, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa4_1(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_1(2, old0, old1, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(3, active0, active1, active2, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa5_1(active0, 0L, active1, 0x10L, active2, 0L);
			 case 100: return jjMoveStringLiteralDfa5_1(active0, 0x200000000L, active1, 0L, active2, 0L);
			 case 101: if ((active1 & 0x8L) != 0L) return jjStartNfaWithStates_1(4, 67, 52);
			 return jjMoveStringLiteralDfa5_1(active0, 0L, active1, 0L, active2, 0x8000000000000L);
			 case 110: if ((active1 & 0x40L) != 0L) return jjStartNfaWithStates_1(4, 70, 52);
			 return jjMoveStringLiteralDfa5_1(active0, 0L, active1, 0L, active2, 0x4000000000000L);
			 case 112: return jjMoveStringLiteralDfa5_1(active0, 0L, active1, 0x80L, active2, 0L);
			 case 114: return jjMoveStringLiteralDfa5_1(active0, 0x100004100000000L, active1, 0x20L, active2, 0L);
			 case 115: return jjMoveStringLiteralDfa5_1(active0, 0x80000000000000L, active1, 0L, active2, 0L);
			 case 117: return jjMoveStringLiteralDfa5_1(active0, 0x800000000000000L, active1, 0L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_1(3, active0, active1, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa5_1(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_1(3, old0, old1, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(4, active0, active1, active2, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 100: return jjMoveStringLiteralDfa6_1(active0, 0L, active1, 0L, active2, 0x4000000000000L);
			 case 101: return jjMoveStringLiteralDfa6_1(active0, 0x300000000L, active1, 0L, active2, 0L);
			 case 102: return jjMoveStringLiteralDfa6_1(active0, 0x80000000000000L, active1, 0L, active2, 0L);
			 case 108: return jjMoveStringLiteralDfa6_1(active0, 0x800000000000000L, active1, 0L, active2, 0L);
			 case 110: if ((active0 & 0x100000000000000L) != 0L) return jjStartNfaWithStates_1(5, 56, 52);
			 return jjMoveStringLiteralDfa6_1(active0, 0x4000000000L, active1, 0L, active2, 0x8000000000000L);
			 case 115: return jjMoveStringLiteralDfa6_1(active0, 0L, active1, 0x20L, active2, 0L);
			 case 116: if ((active1 & 0x80L) != 0L) return jjStartNfaWithStates_1(5, 71, 52);
			 return jjMoveStringLiteralDfa6_1(active0, 0L, active1, 0x10L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_1(4, active0, active1, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa6_1(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_1(4, old0, old1, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(5, active0, active1, active2, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa7_1(active0, 0x4000000000L, active1, 0L, active2, 0L);
			 case 100: if ((active0 & 0x100000000L) != 0L) return jjStartNfaWithStates_1(6, 32, 52);
			 return jjMoveStringLiteralDfa7_1(active0, 0L, active1, 0L, active2, 0x8000000000000L);
			 case 101: return jjMoveStringLiteralDfa7_1(active0, 0L, active1, 0x20L, active2, 0L);
			 case 105: return jjMoveStringLiteralDfa7_1(active0, 0x80000000000000L, active1, 0x10L, active2, 0x4000000000000L);
			 case 114: return jjMoveStringLiteralDfa7_1(active0, 0x200000000L, active1, 0L, active2, 0L);
			 case 116: if ((active0 & 0x800000000000000L) != 0L) return jjStartNfaWithStates_1(6, 59, 52);
			 break;
			 default : break;
		 }
		 return jjStartNfa_1(5, active0, active1, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa7_1(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_1(5, old0, old1, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(6, active0, active1, active2, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 99: return jjMoveStringLiteralDfa8_1(active0, 0L, active1, 0x20L, active2, 0L);
			 case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000200000000L, active1, 0L, active2, 0L);
			 case 105: return jjMoveStringLiteralDfa8_1(active0, 0L, active1, 0L, active2, 0x8000000000000L);
			 case 108: if ((active0 & 0x4000000000L) != 0L) return jjStartNfaWithStates_1(7, 38, 52);
			 break;
			 case 110: return jjMoveStringLiteralDfa8_1(active0, 0L, active1, 0L, active2, 0x4000000000000L);
			 case 111: return jjMoveStringLiteralDfa8_1(active0, 0L, active1, 0x10L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_1(6, active0, active1, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa8_1(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_1(6, old0, old1, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(7, active0, active1, active2, 0L);
			 return 8;
		 }
		 switch(curChar) {
			 case 100: if ((active0 & 0x200000000L) != 0L) return jjStartNfaWithStates_1(8, 33, 52);
			 break;
			 case 103: if ((active2 & 0x4000000000000L) != 0L) return jjStartNfaWithStates_1(8, 178, 52);
			 break;
			 case 110: if ((active1 & 0x10L) != 0L) return jjStartNfaWithStates_1(8, 68, 52);
			 return jjMoveStringLiteralDfa9_1(active0, 0L, active1, 0L, active2, 0x8000000000000L);
			 case 115: if ((active0 & 0x80000000000000L) != 0L) return jjStartNfaWithStates_1(8, 55, 52);
			 break;
			 case 116: if ((active1 & 0x20L) != 0L) return jjStartNfaWithStates_1(8, 69, 52);
			 break;
			 default : break;
		 }
		 return jjStartNfa_1(7, active0, active1, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa9_1(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_1(7, old0, old1, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_1(8, 0L, 0L, active2, 0L);
			 return 9;
		 }
		 switch(curChar) {
			 case 103: if ((active2 & 0x8000000000000L) != 0L) return jjStartNfaWithStates_1(9, 179, 52);
			 break;
			 default : break;
		 }
		 return jjStartNfa_1(8, 0L, 0L, active2, 0L);
	}
	private final int jjMoveNfa_1(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 113;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 44: case 52: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 81: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 24: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 49: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 42: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 113: if ((0x3ff000000000000L & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 else if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(45, 47);
						 break;
						 case 31: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 57: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 34: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 80: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 23: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 14: if ((0x3ff000000000000L & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 else if ((0x100002600L & l) != 0L) {
							 if (kind > 12) kind = 12;
							 jjCheckNAdd(6);
						 }
						 else if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 else if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 48: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 50: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 82: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 102: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 0: if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 1: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 2: if (curChar != 34) break;
						 if (kind > 4) kind = 4;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 case 3: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 4: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 5: if (curChar != 39) break;
						 if (kind > 4) kind = 4;
						 jjstateSet[jjnewStateCnt++] = 3;
						 break;
						 case 6: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(6);
						 break;
						 case 16: if ((0x100002600L & l) != 0L) jjAddStates(83, 84);
						 break;
						 case 27: if ((0x100002600L & l) != 0L) jjAddStates(11, 12);
						 break;
						 case 28: if (curChar == 36 && kind > 142) kind = 142;
						 break;
						 case 32: if ((0x100002600L & l) != 0L) jjAddStates(85, 86);
						 break;
						 case 33: if (curChar == 36 && kind > 143) kind = 143;
						 break;
						 case 37: if ((0x100002600L & l) != 0L) jjAddStates(87, 88);
						 break;
						 case 45: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(45, 47);
						 break;
						 case 59: if ((0x100002600L & l) != 0L) jjAddStates(89, 90);
						 break;
						 case 61: if ((0x100002600L & l) != 0L) jjAddStates(91, 92);
						 break;
						 case 74: if ((0x100002600L & l) != 0L) jjAddStates(93, 94);
						 break;
						 case 84: if ((0x100002600L & l) != 0L) jjAddStates(95, 96);
						 break;
						 case 91: if ((0x100002600L & l) != 0L) jjAddStates(97, 98);
						 break;
						 case 104: if ((0x100002600L & l) != 0L) jjAddStates(99, 100);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 44: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 114) jjstateSet[jjnewStateCnt++] = 45;
						 break;
						 case 81: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 83;
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 80;
						 break;
						 case 24: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 110) jjstateSet[jjnewStateCnt++] = 23;
						 break;
						 case 49: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 100) jjstateSet[jjnewStateCnt++] = 48;
						 break;
						 case 42: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 114) jjstateSet[jjnewStateCnt++] = 41;
						 break;
						 case 113: case 52: if ((0x7fffffe07fffffeL & l) == 0L) break;
						 if (kind > 249) kind = 249;
						 jjCheckNAdd(52);
						 break;
						 case 31: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 116) jjAddStates(85, 86);
						 break;
						 case 57: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 70;
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 56;
						 break;
						 case 34: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 101) jjstateSet[jjnewStateCnt++] = 31;
						 break;
						 case 80: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 84;
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 79;
						 break;
						 case 23: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 115) jjstateSet[jjnewStateCnt++] = 22;
						 break;
						 case 14: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 101) jjAddStates(101, 102);
						 else if (curChar == 99) jjAddStates(103, 104);
						 else if (curChar == 115) jjAddStates(105, 106);
						 else if (curChar == 111) jjstateSet[jjnewStateCnt++] = 50;
						 else if (curChar == 116) jjstateSet[jjnewStateCnt++] = 42;
						 else if (curChar == 108) jjstateSet[jjnewStateCnt++] = 34;
						 else if (curChar == 102) jjstateSet[jjnewStateCnt++] = 29;
						 else if (curChar == 105) jjstateSet[jjnewStateCnt++] = 24;
						 else if (curChar == 112) jjstateSet[jjnewStateCnt++] = 13;
						 break;
						 case 48: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 101) jjstateSet[jjnewStateCnt++] = 44;
						 break;
						 case 50: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 114) jjstateSet[jjnewStateCnt++] = 49;
						 break;
						 case 82: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 97) jjstateSet[jjnewStateCnt++] = 87;
						 if (curChar == 97) jjstateSet[jjnewStateCnt++] = 81;
						 break;
						 case 102: if ((0x7fffffe07fffffeL & l) != 0L) {
							 if (kind > 249) kind = 249;
							 jjCheckNAdd(52);
						 }
						 if (curChar == 109) jjstateSet[jjnewStateCnt++] = 111;
						 if (curChar == 109) jjstateSet[jjnewStateCnt++] = 101;
						 break;
						 case 1: jjAddStates(0, 1);
						 break;
						 case 4: jjAddStates(2, 3);
						 break;
						 case 7: if (curChar == 101 && kind > 52) kind = 52;
						 break;
						 case 8: if (curChar == 118) jjstateSet[jjnewStateCnt++] = 7;
						 break;
						 case 9: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 8;
						 break;
						 case 10: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 10;
						 break;
						 case 12: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 15: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 16;
						 break;
						 case 17: if (curChar == 102 && kind > 75) kind = 75;
						 break;
						 case 18: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 17;
						 break;
						 case 19: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 15;
						 break;
						 case 20: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 19;
						 break;
						 case 21: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 20;
						 break;
						 case 22: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 21;
						 break;
						 case 25: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 24;
						 break;
						 case 26: if (curChar == 114) jjAddStates(11, 12);
						 break;
						 case 29: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 26;
						 break;
						 case 30: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 29;
						 break;
						 case 35: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 34;
						 break;
						 case 36: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 37;
						 break;
						 case 38: if (curChar == 115 && kind > 145) kind = 145;
						 break;
						 case 39: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 38;
						 break;
						 case 40: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 36;
						 break;
						 case 41: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 40;
						 break;
						 case 43: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 42;
						 break;
						 case 46: if (curChar == 121 && kind > 176) kind = 176;
						 break;
						 case 47: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 46;
						 break;
						 case 51: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 50;
						 break;
						 case 53: if (curChar == 115) jjAddStates(105, 106);
						 break;
						 case 54: if (curChar == 112 && kind > 52) kind = 52;
						 break;
						 case 55: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 54;
						 break;
						 case 56: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 55;
						 break;
						 case 58: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 59;
						 break;
						 case 60: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 61;
						 break;
						 case 62: if (curChar == 121 && kind > 177) kind = 177;
						 break;
						 case 63: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 62;
						 break;
						 case 64: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 60;
						 break;
						 case 65: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 64;
						 break;
						 case 66: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 65;
						 break;
						 case 67: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 66;
						 break;
						 case 68: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 58;
						 break;
						 case 69: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 68;
						 break;
						 case 70: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 69;
						 break;
						 case 71: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 70;
						 break;
						 case 72: if (curChar == 99) jjAddStates(103, 104);
						 break;
						 case 73: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 74;
						 break;
						 case 75: if (curChar == 115 && kind > 76) kind = 76;
						 break;
						 case 76: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 75;
						 break;
						 case 77: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 73;
						 break;
						 case 78: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 77;
						 break;
						 case 79: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 78;
						 break;
						 case 83: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 84;
						 break;
						 case 85: if (curChar == 115 && kind > 144) kind = 144;
						 break;
						 case 86: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 85;
						 break;
						 case 87: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 83;
						 break;
						 case 88: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 87;
						 break;
						 case 89: if (curChar == 101) jjAddStates(101, 102);
						 break;
						 case 90: if (curChar == 121) jjstateSet[jjnewStateCnt++] = 91;
						 break;
						 case 92: if (curChar == 116 && kind > 180) kind = 180;
						 break;
						 case 93: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 92;
						 break;
						 case 94: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 93;
						 break;
						 case 95: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 94;
						 break;
						 case 96: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 95;
						 break;
						 case 97: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 96;
						 break;
						 case 98: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 97;
						 break;
						 case 99: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 98;
						 break;
						 case 100: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 90;
						 break;
						 case 101: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 100;
						 break;
						 case 103: if (curChar == 121) jjstateSet[jjnewStateCnt++] = 104;
						 break;
						 case 105: if (curChar == 116 && kind > 181) kind = 181;
						 break;
						 case 106: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 105;
						 break;
						 case 107: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 106;
						 break;
						 case 108: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 107;
						 break;
						 case 109: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 108;
						 break;
						 case 110: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 103;
						 break;
						 case 111: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 110;
						 break;
						 case 112: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 111;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(0, 1);
						 break;
						 case 4: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(2, 3);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 113 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjMoveStringLiteralDfa0_19(){
		 return jjMoveNfa_19(0, 0);
	}
	private final int jjMoveNfa_19(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 4;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L && kind > 216) kind = 216;
						 break;
						 case 2: if (curChar == 62 && kind > 192) kind = 192;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (kind > 216) kind = 216;
						 if (curChar == 93) jjstateSet[jjnewStateCnt++] = 1;
						 break;
						 case 1: if (curChar == 93) jjstateSet[jjnewStateCnt++] = 2;
						 break;
						 case 3: if (kind > 216) kind = 216;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 216) kind = 216;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_6(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_6(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_6(jjStopStringLiteralDfa_6(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_6(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_6(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_6(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_6(0x0L, 0x840000000L);
			 case 110: return jjMoveStringLiteralDfa1_6(0x1L, 0x0L);
			 default : return jjMoveNfa_6(21, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_6(long active1, long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(0, 0L, active1, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_6(active1, 0L, active3, 0x40000000L);
			 case 97: return jjMoveStringLiteralDfa2_6(active1, 0x1L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_6(0, 0L, active1, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_6(long old1, long active1, long old3, long active3){
		 if (((active1 &= old1) | (active3 &= old3)) == 0L) return jjStartNfa_6(0, 0L, old1, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(1, 0L, active1, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 case 109: return jjMoveStringLiteralDfa3_6(active1, 0x1L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_6(1, 0L, active1, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa3_6(long old1, long active1, long old3, long active3){
		 if (((active1 &= old1) | (active3 &= old3)) == 0L) return jjStartNfa_6(1, 0L, old1, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(2, 0L, active1, 0L, 0L);
			 return 3;
		 }
		 switch(curChar) {
			 case 101: return jjMoveStringLiteralDfa4_6(active1, 0x1L);
			 default : break;
		 }
		 return jjStartNfa_6(2, 0L, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa4_6(long old1, long active1){
		 if (((active1 &= old1)) == 0L) return jjStartNfa_6(2, 0L, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(3, 0L, active1, 0L, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 115: return jjMoveStringLiteralDfa5_6(active1, 0x1L);
			 default : break;
		 }
		 return jjStartNfa_6(3, 0L, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa5_6(long old1, long active1){
		 if (((active1 &= old1)) == 0L) return jjStartNfa_6(3, 0L, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(4, 0L, active1, 0L, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 112: return jjMoveStringLiteralDfa6_6(active1, 0x1L);
			 default : break;
		 }
		 return jjStartNfa_6(4, 0L, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa6_6(long old1, long active1){
		 if (((active1 &= old1)) == 0L) return jjStartNfa_6(4, 0L, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(5, 0L, active1, 0L, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa7_6(active1, 0x1L);
			 default : break;
		 }
		 return jjStartNfa_6(5, 0L, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa7_6(long old1, long active1){
		 if (((active1 &= old1)) == 0L) return jjStartNfa_6(5, 0L, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(6, 0L, active1, 0L, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 99: return jjMoveStringLiteralDfa8_6(active1, 0x1L);
			 default : break;
		 }
		 return jjStartNfa_6(6, 0L, active1, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa8_6(long old1, long active1){
		 if (((active1 &= old1)) == 0L) return jjStartNfa_6(6, 0L, old1, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_6(7, 0L, active1, 0L, 0L);
			 return 8;
		 }
		 switch(curChar) {
			 case 101: if ((active1 & 0x1L) != 0L) return jjStopAtPos(8, 64);
			 break;
			 default : break;
		 }
		 return jjStartNfa_6(7, 0L, active1, 0L, 0L);
	}
	private final int jjMoveNfa_6(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 22;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 21: if ((0x100002600L & l) != 0L) {
							 if (kind > 12) kind = 12;
							 jjCheckNAdd(6);
						 }
						 else if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 else if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 0: if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 1: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 2: if (curChar != 34) break;
						 if (kind > 10) kind = 10;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 case 3: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 4: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 5: if (curChar != 39) break;
						 if (kind > 10) kind = 10;
						 jjstateSet[jjnewStateCnt++] = 3;
						 break;
						 case 6: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(6);
						 break;
						 case 8: if ((0x100002600L & l) != 0L) jjAddStates(107, 108);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 21: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 20;
						 break;
						 case 1: jjAddStates(0, 1);
						 break;
						 case 4: jjAddStates(2, 3);
						 break;
						 case 7: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 8;
						 break;
						 case 9: if (curChar == 116 && kind > 93) kind = 93;
						 break;
						 case 10: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 10;
						 break;
						 case 12: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 14: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 13;
						 break;
						 case 15: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 14;
						 break;
						 case 16: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 7;
						 break;
						 case 17: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 16;
						 break;
						 case 18: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 17;
						 break;
						 case 19: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 18;
						 break;
						 case 20: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 19;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(0, 1);
						 break;
						 case 4: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(2, 3);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 22 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_10(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_10(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_10(jjStopStringLiteralDfa_10(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_10(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_10(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_10(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_10(0x840000000L);
			 default : return jjMoveNfa_10(1, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_10(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_10(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_10(active3, 0x40000000L);
			 default : break;
		 }
		 return jjStartNfa_10(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_10(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_10(0, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_10(1, 0L, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 default : break;
		 }
		 return jjStartNfa_10(1, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_10(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 6;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 12;
						 jjCheckNAdd(0);
						 break;
						 case 2: if ((0x3ff600000000000L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 5: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 50) kind = 50;
						 jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 50) kind = 50;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: case 5: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 50) kind = 50;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 50) kind = 50;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 50) kind = 50;
						 jjCheckNAdd(5);
						 break;
						 case 5: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 50) kind = 50;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_16(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_16(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_16(jjStopStringLiteralDfa_16(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_16(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_16(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_16(){
		 switch(curChar) {
			 case 34: return jjStopAtPos(0, 172);
			 case 39: return jjStopAtPos(0, 217);
			 case 47: return jjMoveStringLiteralDfa1_16(0x80L);
			 case 61: return jjStopAtPos(0, 202);
			 case 62: return jjStopAtPos(0, 198);
			 default : return jjMoveNfa_16(1, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_16(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_16(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 62: if ((active3 & 0x80L) != 0L) return jjStopAtPos(1, 199);
			 break;
			 default : break;
		 }
		 return jjStartNfa_16(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_16(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 6;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 237;
						 jjCheckNAdd(0);
						 break;
						 case 2: if ((0x3ff600000000000L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 5: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 203) kind = 203;
						 jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: case 5: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAdd(5);
						 break;
						 case 5: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 203) kind = 203;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_9(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_9(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_9(jjStopStringLiteralDfa_9(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_9(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_9(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_9(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_9(0x800000000L);
			 default : return jjMoveNfa_9(1, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_9(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_9(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) return jjStopAtPos(1, 227);
			 break;
			 default : break;
		 }
		 return jjStartNfa_9(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_9(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 6;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 12;
						 jjCheckNAdd(0);
						 break;
						 case 2: if ((0x3ff600000000000L & l) != 0L) jjAddStates(4, 5);
						 break;
						 case 3: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 5: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 184) kind = 184;
						 jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: case 5: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAddStates(6, 8);
						 break;
						 case 2: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(2, 3);
						 break;
						 case 4: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(5);
						 break;
						 case 5: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 184) kind = 184;
						 jjCheckNAdd(5);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_5(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_5(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_5(jjStopStringLiteralDfa_5(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_5(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_5(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_5(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_5(0x840000000L);
			 case 61: return jjStopAtPos(0, 110);
			 default : return jjMoveNfa_5(7, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_5(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_5(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_5(active3, 0x40000000L);
			 default : break;
		 }
		 return jjStartNfa_5(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_5(long old3, long active3){
		 if (((active3 &= old3)) == 0L) return jjStartNfa_5(0, 0L, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_5(1, 0L, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 default : break;
		 }
		 return jjStartNfa_5(1, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_5(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 9;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 7: if ((0x100002600L & l) != 0L) {
							 if (kind > 12) kind = 12;
							 jjCheckNAdd(6);
						 }
						 else if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 else if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 0: if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 1: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 2: if (curChar != 34) break;
						 if (kind > 10) kind = 10;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 case 3: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 4: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 5: if (curChar != 39) break;
						 if (kind > 10) kind = 10;
						 jjstateSet[jjnewStateCnt++] = 3;
						 break;
						 case 6: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(6);
						 break;
						 case 8: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 188) kind = 188;
						 jjstateSet[jjnewStateCnt++] = 8;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 7: case 8: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 188) kind = 188;
						 jjCheckNAdd(8);
						 break;
						 case 1: jjAddStates(0, 1);
						 break;
						 case 4: jjAddStates(2, 3);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 7: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 188) kind = 188;
						 jjCheckNAdd(8);
						 break;
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(0, 1);
						 break;
						 case 4: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(2, 3);
						 break;
						 case 8: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 188) kind = 188;
						 jjCheckNAdd(8);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 9 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_2(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_2(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_2(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_2(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_2(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_2(0x800000000L);
			 case 41: return jjStopAtPos(0, 139);
			 default : return jjMoveNfa_2(6, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_2(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_2(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) return jjStopAtPos(1, 227);
			 break;
			 default : break;
		 }
		 return jjStartNfa_2(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_2(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 8;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 6: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 else if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 0: if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 1: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 2: if (curChar != 34) break;
						 if (kind > 5) kind = 5;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 case 3: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 4: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 5: if (curChar != 39) break;
						 if (kind > 5) kind = 5;
						 jjstateSet[jjnewStateCnt++] = 3;
						 break;
						 case 7: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 189) kind = 189;
						 jjstateSet[jjnewStateCnt++] = 7;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 6: case 7: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 189) kind = 189;
						 jjCheckNAdd(7);
						 break;
						 case 1: jjAddStates(0, 1);
						 break;
						 case 4: jjAddStates(2, 3);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 6: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 189) kind = 189;
						 jjCheckNAdd(7);
						 break;
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(0, 1);
						 break;
						 case 4: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(2, 3);
						 break;
						 case 7: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 189) kind = 189;
						 jjCheckNAdd(7);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 8 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_8(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_8(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_8(jjStopStringLiteralDfa_8(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_8(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_8(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_8(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_8(0x0L, 0x840000000L);
			 case 112: return jjMoveStringLiteralDfa1_8(0x4000000000000000L, 0x0L);
			 case 115: return jjMoveStringLiteralDfa1_8(0x8000000000000000L, 0x0L);
			 default : return jjMoveNfa_8(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_8(long active0, long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(0, active0, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_8(active0, 0L, active3, 0x40000000L);
			 case 114: return jjMoveStringLiteralDfa2_8(active0, 0x4000000000000000L, active3, 0L);
			 case 116: return jjMoveStringLiteralDfa2_8(active0, 0x8000000000000000L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_8(0, active0, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa2_8(long old0, long active0, long old3, long active3){
		 if (((active0 &= old0) | (active3 &= old3)) == 0L) return jjStartNfa_8(0, old0, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(1, active0, 0L, 0L, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 case 101: return jjMoveStringLiteralDfa3_8(active0, 0x4000000000000000L, active3, 0L);
			 case 114: return jjMoveStringLiteralDfa3_8(active0, 0x8000000000000000L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_8(1, active0, 0L, 0L, active3);
	}
	private final int jjMoveStringLiteralDfa3_8(long old0, long active0, long old3, long active3){
		 if (((active0 &= old0) | (active3 &= old3)) == 0L) return jjStartNfa_8(1, old0, 0L, 0L, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(2, active0, 0L, 0L, 0L);
			 return 3;
		 }
		 switch(curChar) {
			 case 105: return jjMoveStringLiteralDfa4_8(active0, 0x8000000000000000L);
			 case 115: return jjMoveStringLiteralDfa4_8(active0, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_8(2, active0, 0L, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa4_8(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_8(2, old0, 0L, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(3, active0, 0L, 0L, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 101: return jjMoveStringLiteralDfa5_8(active0, 0x4000000000000000L);
			 case 112: if ((active0 & 0x8000000000000000L) != 0L) return jjStopAtPos(4, 63);
			 break;
			 default : break;
		 }
		 return jjStartNfa_8(3, active0, 0L, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa5_8(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_8(3, old0, 0L, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(4, active0, 0L, 0L, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 114: return jjMoveStringLiteralDfa6_8(active0, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_8(4, active0, 0L, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa6_8(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_8(4, old0, 0L, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(5, active0, 0L, 0L, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 118: return jjMoveStringLiteralDfa7_8(active0, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_8(5, active0, 0L, 0L, 0L);
	}
	private final int jjMoveStringLiteralDfa7_8(long old0, long active0){
		 if (((active0 &= old0)) == 0L) return jjStartNfa_8(5, old0, 0L, 0L, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_8(6, active0, 0L, 0L, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 101: if ((active0 & 0x4000000000000000L) != 0L) return jjStopAtPos(7, 62);
			 break;
			 default : break;
		 }
		 return jjStartNfa_8(6, active0, 0L, 0L, 0L);
	}
	private final int jjMoveNfa_8(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 1;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 12;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active1 & 0x2000000000L) != 0L) return 58;
			 if ((active1 & 0x100L) != 0L) {
				 jjmatchedKind = 235;
				 return 96;
			 }
			 if ((active2 & 0xc00000000000L) != 0L) return 803;
			 return -1;
			 case 1: if ((active1 & 0x100L) != 0L) return 804;
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_0(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_0(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_0(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_0(){
		 switch(curChar) {
			 case 36: return jjStopAtPos(0, 49);
			 case 37: return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x80000000000L, 0x0L);
			 case 40: jjmatchedKind = 134;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x0L, 0x840000000L);
			 case 41: return jjStopAtPos(0, 138);
			 case 42: return jjStartNfaWithStates_0(0, 101, 58);
			 case 43: return jjStopAtPos(0, 129);
			 case 44: return jjStopAtPos(0, 168);
			 case 45: return jjStopAtPos(0, 128);
			 case 46: jjmatchedKind = 174;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x800000000000L, 0x0L);
			 case 47: jjmatchedKind = 105;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x40000000000L, 0x0L, 0x0L);
			 case 59: return jjStopAtPos(0, 170);
			 case 60: jjmatchedKind = 197;
			 return jjMoveStringLiteralDfa1_0(0x8000L, 0x0L, 0x4000000000000000L, 0x10000000000L);
			 case 64: return jjStopAtPos(0, 135);
			 case 97: return jjMoveStringLiteralDfa1_0(0x0L, 0x100L, 0x0L, 0x0L);
			 case 123: return jjStopAtPos(0, 205);
			 case 125: return jjStopAtPos(0, 241);
			 default : return jjMoveNfa_0(19, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2, long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(0, active0, active1, active2, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 33: return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x4000000000000000L, active3, 0x10000000000L);
			 case 37: return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x80000000000L, active3, 0L);
			 case 46: if ((active2 & 0x800000000000L) != 0L) return jjStopAtPos(1, 175);
			 break;
			 case 47: if ((active1 & 0x40000000000L) != 0L) return jjStopAtPos(1, 106);
			 break;
			 case 58: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 227;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0L, active3, 0x40000000L);
			 case 63: if ((active0 & 0x8000L) != 0L) return jjStopAtPos(1, 15);
			 break;
			 case 115: if ((active1 & 0x100L) != 0L) return jjStartNfaWithStates_0(1, 72, 804);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(0, active0, active1, active2, active3);
	}
	private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2, long old3, long active3){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_0(0, old0, old1, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(1, 0L, 0L, active2, active3);
			 return 2;
		 }
		 switch(curChar) {
			 case 37: if ((active2 & 0x80000000000L) != 0L) return jjStopAtPos(2, 171);
			 break;
			 case 45: return jjMoveStringLiteralDfa3_0(active2, 0L, active3, 0x10000000000L);
			 case 58: if ((active3 & 0x40000000L) != 0L) return jjStopAtPos(2, 222);
			 break;
			 case 91: return jjMoveStringLiteralDfa3_0(active2, 0x4000000000000000L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_0(1, 0L, 0L, active2, active3);
	}
	private final int jjMoveStringLiteralDfa3_0(long old2, long active2, long old3, long active3){
		 if (((active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_0(1, 0L, 0L, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(2, 0L, 0L, active2, active3);
			 return 3;
		 }
		 switch(curChar) {
			 case 45: if ((active3 & 0x10000000000L) != 0L) return jjStopAtPos(3, 232);
			 break;
			 case 67: return jjMoveStringLiteralDfa4_0(active2, 0x4000000000000000L, active3, 0L);
			 default : break;
		 }
		 return jjStartNfa_0(2, 0L, 0L, active2, active3);
	}
	private final int jjMoveStringLiteralDfa4_0(long old2, long active2, long old3, long active3){
		 if (((active2 &= old2) | (active3 &= old3)) == 0L) return jjStartNfa_0(2, 0L, 0L, old2, old3);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(3, 0L, 0L, active2, 0L);
			 return 4;
		 }
		 switch(curChar) {
			 case 68: return jjMoveStringLiteralDfa5_0(active2, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_0(3, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa5_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(3, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(4, 0L, 0L, active2, 0L);
			 return 5;
		 }
		 switch(curChar) {
			 case 65: return jjMoveStringLiteralDfa6_0(active2, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_0(4, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa6_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(4, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(5, 0L, 0L, active2, 0L);
			 return 6;
		 }
		 switch(curChar) {
			 case 84: return jjMoveStringLiteralDfa7_0(active2, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_0(5, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa7_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(5, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(6, 0L, 0L, active2, 0L);
			 return 7;
		 }
		 switch(curChar) {
			 case 65: return jjMoveStringLiteralDfa8_0(active2, 0x4000000000000000L);
			 default : break;
		 }
		 return jjStartNfa_0(6, 0L, 0L, active2, 0L);
	}
	private final int jjMoveStringLiteralDfa8_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(6, 0L, 0L, old2, 0L);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(7, 0L, 0L, active2, 0L);
			 return 8;
		 }
		 switch(curChar) {
			 case 91: if ((active2 & 0x4000000000000000L) != 0L) return jjStopAtPos(8, 190);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(7, 0L, 0L, active2, 0L);
	}
	private final int jjMoveNfa_0(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 803;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 804: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 235) kind = 235;
							 jjCheckNAdd(775);
						 }
						 else if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(770, 771);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 774;
						 else if (curChar == 40) {
							 if (kind > 187) kind = 187;
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(772, 773);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 768;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddStates(109, 111);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 765;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(766, 767);
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(763, 764);
						 break;
						 case 96: if ((0x3ff600000000000L & l) != 0L) {
							 if (kind > 235) kind = 235;
							 jjCheckNAdd(775);
						 }
						 else if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(770, 771);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 774;
						 else if (curChar == 40) {
							 if (kind > 187) kind = 187;
						 }
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(772, 773);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 768;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddStates(109, 111);
						 else if (curChar == 58) jjstateSet[jjnewStateCnt++] = 765;
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(766, 767);
						 if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(763, 764);
						 break;
						 case 19: if ((0x3ff000000000000L & l) != 0L) {
							 if (kind > 1) kind = 1;
							 jjCheckNAddStates(112, 121);
						 }
						 else if ((0x100002600L & l) != 0L) {
							 if (kind > 12) kind = 12;
							 jjCheckNAdd(36);
						 }
						 else if (curChar == 46) jjCheckNAddStates(122, 124);
						 else if (curChar == 42) jjstateSet[jjnewStateCnt++] = 58;
						 else if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 else if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 803: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(125, 127);
						 if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(93, 80);
						 if ((0x3ff000000000000L & l) != 0L) {
							 if (kind > 2) kind = 2;
							 jjCheckNAdd(92);
						 }
						 break;
						 case 0: if (curChar == 34) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 1: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(1, 2);
						 break;
						 case 2: if (curChar != 34) break;
						 if (kind > 4) kind = 4;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 case 3: if (curChar == 39) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 4: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(4, 5);
						 break;
						 case 5: if (curChar != 39) break;
						 if (kind > 4) kind = 4;
						 jjstateSet[jjnewStateCnt++] = 3;
						 break;
						 case 7: if ((0x100002600L & l) != 0L) jjAddStates(128, 129);
						 break;
						 case 21: if ((0x100002600L & l) != 0L) jjAddStates(130, 131);
						 break;
						 case 36: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(36);
						 break;
						 case 38: if ((0x100002600L & l) != 0L) jjAddStates(132, 133);
						 break;
						 case 47: if ((0x100002600L & l) != 0L) jjAddStates(134, 135);
						 break;
						 case 57: if (curChar == 42) jjstateSet[jjnewStateCnt++] = 58;
						 break;
						 case 58: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 59;
						 break;
						 case 60: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 104) kind = 104;
						 jjstateSet[jjnewStateCnt++] = 60;
						 break;
						 case 62: if ((0x100002600L & l) != 0L) jjAddStates(136, 137);
						 break;
						 case 63: if (curChar == 36 && kind > 143) kind = 143;
						 break;
						 case 67: if ((0x100002600L & l) != 0L) jjAddStates(138, 139);
						 break;
						 case 68: if (curChar == 40 && kind > 152) kind = 152;
						 break;
						 case 72: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 1) kind = 1;
						 jjCheckNAddStates(112, 121);
						 break;
						 case 73: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 1) kind = 1;
						 jjCheckNAdd(73);
						 break;
						 case 74: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(74, 75);
						 break;
						 case 75: if (curChar != 46) break;
						 if (kind > 2) kind = 2;
						 jjCheckNAdd(76);
						 break;
						 case 76: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 2) kind = 2;
						 jjCheckNAdd(76);
						 break;
						 case 77: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(140, 142);
						 break;
						 case 78: if (curChar == 46) jjCheckNAddTwoStates(79, 80);
						 break;
						 case 79: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(79, 80);
						 break;
						 case 81: if ((0x280000000000L & l) != 0L) jjCheckNAdd(82);
						 break;
						 case 82: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 3) kind = 3;
						 jjCheckNAdd(82);
						 break;
						 case 83: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(143, 146);
						 break;
						 case 84: if (curChar == 46) jjCheckNAddStates(147, 149);
						 break;
						 case 85: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(147, 149);
						 break;
						 case 87: if ((0x280000000000L & l) != 0L) jjCheckNAdd(88);
						 break;
						 case 88: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(88, 89);
						 break;
						 case 90: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 250) kind = 250;
						 jjstateSet[jjnewStateCnt++] = 90;
						 break;
						 case 91: if (curChar == 46) jjCheckNAddStates(122, 124);
						 break;
						 case 92: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 2) kind = 2;
						 jjCheckNAdd(92);
						 break;
						 case 93: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(93, 80);
						 break;
						 case 94: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(125, 127);
						 break;
						 case 97: if ((0x100002600L & l) != 0L) jjCheckNAddStates(150, 152);
						 break;
						 case 98: if (curChar == 34) jjCheckNAddTwoStates(99, 100);
						 break;
						 case 99: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(99, 100);
						 break;
						 case 100: if (curChar != 34) break;
						 if (kind > 9) kind = 9;
						 jjCheckNAdd(98);
						 break;
						 case 101: if (curChar == 39) jjCheckNAddTwoStates(102, 103);
						 break;
						 case 102: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(102, 103);
						 break;
						 case 103: if (curChar != 39) break;
						 if (kind > 9) kind = 9;
						 jjCheckNAdd(101);
						 break;
						 case 105: if ((0x100002600L & l) != 0L) jjAddStates(153, 154);
						 break;
						 case 106: if (curChar == 58 && kind > 21) kind = 21;
						 break;
						 case 107: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 106;
						 break;
						 case 116: if ((0x100002600L & l) != 0L) jjAddStates(155, 156);
						 break;
						 case 117: if (curChar == 58 && kind > 24) kind = 24;
						 break;
						 case 118: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 117;
						 break;
						 case 126: if ((0x100002600L & l) != 0L) jjAddStates(157, 158);
						 break;
						 case 127: if (curChar == 58 && kind > 29) kind = 29;
						 break;
						 case 128: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 127;
						 break;
						 case 132: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 131;
						 break;
						 case 135: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 134;
						 break;
						 case 144: if ((0x100002600L & l) != 0L) jjAddStates(159, 160);
						 break;
						 case 145: if (curChar == 40 && kind > 79) kind = 79;
						 break;
						 case 154: if ((0x100002600L & l) != 0L) jjAddStates(161, 162);
						 break;
						 case 156: if ((0x3ff600000000000L & l) != 0L) jjAddStates(163, 164);
						 break;
						 case 157: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 158;
						 break;
						 case 159: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddStates(165, 167);
						 break;
						 case 160: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(160, 161);
						 break;
						 case 170: if ((0x100002600L & l) != 0L) jjAddStates(168, 169);
						 break;
						 case 181: if ((0x100002600L & l) != 0L) jjAddStates(170, 171);
						 break;
						 case 182: if (curChar == 58 && kind > 18) kind = 18;
						 break;
						 case 183: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 182;
						 break;
						 case 188: if ((0x100002600L & l) != 0L) jjAddStates(172, 173);
						 break;
						 case 196: if ((0x100002600L & l) != 0L) jjAddStates(174, 175);
						 break;
						 case 197: if (curChar == 40 && kind > 153) kind = 153;
						 break;
						 case 205: if ((0x100002600L & l) != 0L) jjAddStates(176, 177);
						 break;
						 case 206: if (curChar == 58 && kind > 19) kind = 19;
						 break;
						 case 207: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 206;
						 break;
						 case 217: if ((0x100002600L & l) != 0L) jjAddStates(178, 179);
						 break;
						 case 218: if (curChar == 58 && kind > 23) kind = 23;
						 break;
						 case 219: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 218;
						 break;
						 case 223: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 222;
						 break;
						 case 226: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 225;
						 break;
						 case 237: if ((0x100002600L & l) != 0L) jjAddStates(180, 181);
						 break;
						 case 252: if ((0x100002600L & l) != 0L) jjAddStates(182, 183);
						 break;
						 case 267: if ((0x100002600L & l) != 0L) jjAddStates(184, 185);
						 break;
						 case 269: if ((0x100002600L & l) != 0L) jjAddStates(186, 187);
						 break;
						 case 287: if ((0x100002600L & l) != 0L) jjAddStates(188, 189);
						 break;
						 case 298: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 297;
						 break;
						 case 312: if ((0x100002600L & l) != 0L) jjAddStates(190, 191);
						 break;
						 case 331: if ((0x100002600L & l) != 0L) jjAddStates(192, 193);
						 break;
						 case 346: if ((0x100002600L & l) != 0L) jjAddStates(194, 195);
						 break;
						 case 350: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 349;
						 break;
						 case 361: if ((0x100002600L & l) != 0L) jjAddStates(196, 197);
						 break;
						 case 377: if ((0x100002600L & l) != 0L) jjAddStates(198, 199);
						 break;
						 case 379: if ((0x100002600L & l) != 0L) jjAddStates(200, 201);
						 break;
						 case 401: if ((0x100002600L & l) != 0L) jjAddStates(202, 203);
						 break;
						 case 403: if ((0x100002600L & l) != 0L) jjAddStates(204, 205);
						 break;
						 case 423: if ((0x100002600L & l) != 0L) jjAddStates(206, 207);
						 break;
						 case 425: if ((0x100002600L & l) != 0L) jjAddStates(208, 209);
						 break;
						 case 446: if ((0x100002600L & l) != 0L) jjAddStates(210, 211);
						 break;
						 case 447: if (curChar == 40 && kind > 149) kind = 149;
						 break;
						 case 451: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 450;
						 break;
						 case 460: if ((0x100002600L & l) != 0L) jjAddStates(212, 213);
						 break;
						 case 469: if ((0x100002600L & l) != 0L) jjAddStates(214, 215);
						 break;
						 case 471: if ((0x100002600L & l) != 0L) jjAddStates(216, 217);
						 break;
						 case 472: if (curChar == 36 && kind > 182) kind = 182;
						 break;
						 case 487: if ((0x100002600L & l) != 0L) jjAddStates(218, 219);
						 break;
						 case 488: if (curChar == 58 && kind > 20) kind = 20;
						 break;
						 case 489: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 488;
						 break;
						 case 495: if ((0x100002600L & l) != 0L) jjAddStates(220, 221);
						 break;
						 case 496: if (curChar == 58 && kind > 26) kind = 26;
						 break;
						 case 497: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 496;
						 break;
						 case 504: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 503;
						 break;
						 case 514: if ((0x100002600L & l) != 0L) jjAddStates(222, 223);
						 break;
						 case 515: if (curChar == 58 && kind > 28) kind = 28;
						 break;
						 case 516: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 515;
						 break;
						 case 525: if ((0x100002600L & l) != 0L) jjAddStates(224, 225);
						 break;
						 case 527: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddStates(226, 228);
						 break;
						 case 528: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(528, 529);
						 break;
						 case 540: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 539;
						 break;
						 case 551: if ((0x100002600L & l) != 0L) jjAddStates(229, 230);
						 break;
						 case 563: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 562;
						 break;
						 case 574: if ((0x100002600L & l) != 0L) jjAddStates(231, 232);
						 break;
						 case 575: if (curChar == 40 && kind > 155) kind = 155;
						 break;
						 case 586: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 585;
						 break;
						 case 598: if ((0x100002600L & l) != 0L) jjAddStates(233, 234);
						 break;
						 case 599: if (curChar == 58 && kind > 22) kind = 22;
						 break;
						 case 600: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 599;
						 break;
						 case 604: if ((0x100002600L & l) != 0L) jjAddStates(235, 236);
						 break;
						 case 605: if (curChar == 40 && kind > 80) kind = 80;
						 break;
						 case 612: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 611;
						 break;
						 case 619: if ((0x100002600L & l) != 0L) jjAddStates(237, 238);
						 break;
						 case 620: if (curChar == 40 && kind > 81) kind = 81;
						 break;
						 case 629: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 628;
						 break;
						 case 636: if ((0x100002600L & l) != 0L) jjAddStates(239, 240);
						 break;
						 case 637: if (curChar == 36 && kind > 140) kind = 140;
						 break;
						 case 642: if ((0x100002600L & l) != 0L) jjAddStates(241, 242);
						 break;
						 case 643: if (curChar == 58 && kind > 25) kind = 25;
						 break;
						 case 644: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 643;
						 break;
						 case 651: if (curChar == 45) jjstateSet[jjnewStateCnt++] = 650;
						 break;
						 case 661: if ((0x100002600L & l) != 0L) jjAddStates(243, 244);
						 break;
						 case 662: if (curChar == 58 && kind > 27) kind = 27;
						 break;
						 case 663: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 662;
						 break;
						 case 672: if ((0x100002600L & l) != 0L) jjAddStates(245, 246);
						 break;
						 case 673: if (curChar == 36 && kind > 142) kind = 142;
						 break;
						 case 677: if ((0x100002600L & l) != 0L) jjAddStates(247, 248);
						 break;
						 case 678: if (curChar == 40 && kind > 78) kind = 78;
						 break;
						 case 685: if ((0x100002600L & l) != 0L) jjAddStates(249, 250);
						 break;
						 case 687: if ((0x3ff600000000000L & l) != 0L) jjAddStates(251, 252);
						 break;
						 case 688: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 689;
						 break;
						 case 690: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddStates(253, 255);
						 break;
						 case 691: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(691, 692);
						 break;
						 case 699: if ((0x100002600L & l) != 0L) jjAddStates(256, 257);
						 break;
						 case 707: if ((0x100002600L & l) != 0L) jjAddStates(258, 259);
						 break;
						 case 708: if (curChar == 36 && kind > 141) kind = 141;
						 break;
						 case 714: if ((0x100002600L & l) != 0L) jjAddStates(260, 261);
						 break;
						 case 719: if ((0x100002600L & l) != 0L) jjAddStates(262, 263);
						 break;
						 case 720: if (curChar == 40 && kind > 154) kind = 154;
						 break;
						 case 724: if ((0x100002600L & l) != 0L) jjAddStates(264, 265);
						 break;
						 case 725: if (curChar == 40 && kind > 167) kind = 167;
						 break;
						 case 736: if ((0x100002600L & l) != 0L) jjAddStates(266, 267);
						 break;
						 case 748: if ((0x100002600L & l) != 0L) jjAddStates(268, 269);
						 break;
						 case 760: if ((0x100002600L & l) != 0L) jjAddStates(270, 271);
						 break;
						 case 761: if (curChar == 40 && kind > 166) kind = 166;
						 break;
						 case 763: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(763, 764);
						 break;
						 case 764: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 765;
						 break;
						 case 765: if (curChar == 42 && kind > 103) kind = 103;
						 break;
						 case 766: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(766, 767);
						 break;
						 case 767: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 768;
						 break;
						 case 769: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddStates(109, 111);
						 break;
						 case 770: if ((0x100002600L & l) != 0L) jjCheckNAddTwoStates(770, 771);
						 break;
						 case 771: if (curChar == 40 && kind > 187) kind = 187;
						 break;
						 case 772: if ((0x3ff600000000000L & l) != 0L) jjCheckNAddTwoStates(772, 773);
						 break;
						 case 773: if (curChar == 58) jjstateSet[jjnewStateCnt++] = 774;
						 break;
						 case 775: if ((0x3ff600000000000L & l) == 0L) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAdd(775);
						 break;
						 case 778: if ((0x100002600L & l) != 0L) jjAddStates(272, 273);
						 break;
						 case 787: if ((0x100002600L & l) != 0L) jjAddStates(274, 276);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 804: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 235) kind = 235;
							 jjCheckNAdd(775);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(772, 773);
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(109, 111);
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(766, 767);
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(763, 764);
						 break;
						 case 96: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 235) kind = 235;
							 jjCheckNAdd(775);
						 }
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(772, 773);
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(109, 111);
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(766, 767);
						 if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(763, 764);
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 177;
						 else if (curChar == 110) jjstateSet[jjnewStateCnt++] = 141;
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 167;
						 else if (curChar == 110) jjstateSet[jjnewStateCnt++] = 123;
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 151;
						 if (curChar == 116) jjstateSet[jjnewStateCnt++] = 113;
						 if (curChar == 116) jjAddStates(150, 152);
						 break;
						 case 19: if ((0x7fffffe87fffffeL & l) != 0L) {
							 if (kind > 235) kind = 235;
							 jjCheckNAddStates(277, 286);
						 }
						 if (curChar == 118) jjAddStates(287, 288);
						 else if (curChar == 105) jjAddStates(289, 291);
						 else if (curChar == 116) jjAddStates(292, 294);
						 else if (curChar == 101) jjAddStates(295, 298);
						 else if (curChar == 102) jjAddStates(299, 301);
						 else if (curChar == 115) jjAddStates(302, 305);
						 else if (curChar == 112) jjAddStates(306, 311);
						 else if (curChar == 100) jjAddStates(312, 327);
						 else if (curChar == 99) jjAddStates(328, 330);
						 else if (curChar == 97) jjAddStates(331, 337);
						 else if (curChar == 110) jjstateSet[jjnewStateCnt++] = 70;
						 else if (curChar == 108) jjstateSet[jjnewStateCnt++] = 64;
						 else if (curChar == 117) jjstateSet[jjnewStateCnt++] = 55;
						 else if (curChar == 111) jjstateSet[jjnewStateCnt++] = 44;
						 else if (curChar == 109) jjstateSet[jjnewStateCnt++] = 34;
						 else if (curChar == 120) jjstateSet[jjnewStateCnt++] = 18;
						 break;
						 case 1: jjAddStates(0, 1);
						 break;
						 case 4: jjAddStates(2, 3);
						 break;
						 case 6: if (curChar == 121) jjAddStates(128, 129);
						 break;
						 case 8: if (curChar == 110 && kind > 6) kind = 6;
						 break;
						 case 9: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 8;
						 break;
						 case 10: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 10;
						 break;
						 case 12: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 14: if (curChar == 118) jjstateSet[jjnewStateCnt++] = 13;
						 break;
						 case 15: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 6;
						 break;
						 case 16: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 15;
						 break;
						 case 17: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 16;
						 break;
						 case 18: if (curChar == 113) jjstateSet[jjnewStateCnt++] = 17;
						 break;
						 case 20: if (curChar == 101) jjAddStates(130, 131);
						 break;
						 case 22: if (curChar == 101 && kind > 11) kind = 11;
						 break;
						 case 23: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 22;
						 break;
						 case 24: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 23;
						 break;
						 case 25: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 24;
						 break;
						 case 26: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 25;
						 break;
						 case 27: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 26;
						 break;
						 case 28: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 27;
						 break;
						 case 29: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 28;
						 break;
						 case 30: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 29;
						 break;
						 case 31: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 20;
						 break;
						 case 32: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 31;
						 break;
						 case 33: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 32;
						 break;
						 case 34: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 33;
						 break;
						 case 35: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 34;
						 break;
						 case 37: if (curChar == 100) jjAddStates(132, 133);
						 break;
						 case 39: if (curChar == 123 && kind > 82) kind = 82;
						 break;
						 case 40: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 37;
						 break;
						 case 41: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 40;
						 break;
						 case 42: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 41;
						 break;
						 case 43: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 42;
						 break;
						 case 44: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 43;
						 break;
						 case 45: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 44;
						 break;
						 case 46: if (curChar == 100) jjAddStates(134, 135);
						 break;
						 case 48: if (curChar == 123 && kind > 83) kind = 83;
						 break;
						 case 49: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 46;
						 break;
						 case 50: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 49;
						 break;
						 case 51: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 50;
						 break;
						 case 52: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 51;
						 break;
						 case 53: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 52;
						 break;
						 case 54: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 53;
						 break;
						 case 55: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 54;
						 break;
						 case 56: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 55;
						 break;
						 case 59: case 60: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 104) kind = 104;
						 jjCheckNAdd(60);
						 break;
						 case 61: if (curChar == 116) jjAddStates(136, 137);
						 break;
						 case 64: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 61;
						 break;
						 case 65: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 64;
						 break;
						 case 66: if (curChar == 101) jjAddStates(138, 139);
						 break;
						 case 69: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 66;
						 break;
						 case 70: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 69;
						 break;
						 case 71: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 70;
						 break;
						 case 80: if ((0x2000000020L & l) != 0L) jjAddStates(338, 339);
						 break;
						 case 86: if ((0x2000000020L & l) != 0L) jjAddStates(340, 341);
						 break;
						 case 89: case 90: if ((0x7fffffe07fffffeL & l) == 0L) break;
						 if (kind > 250) kind = 250;
						 jjCheckNAdd(90);
						 break;
						 case 95: if (curChar == 97) jjAddStates(331, 337);
						 break;
						 case 99: jjAddStates(342, 343);
						 break;
						 case 102: jjAddStates(344, 345);
						 break;
						 case 104: if (curChar == 101) jjAddStates(153, 154);
						 break;
						 case 108: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 104;
						 break;
						 case 109: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 108;
						 break;
						 case 110: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 109;
						 break;
						 case 111: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 110;
						 break;
						 case 112: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 111;
						 break;
						 case 113: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 112;
						 break;
						 case 114: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 113;
						 break;
						 case 115: if (curChar == 114) jjAddStates(155, 156);
						 break;
						 case 119: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 115;
						 break;
						 case 120: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 119;
						 break;
						 case 121: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 120;
						 break;
						 case 122: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 121;
						 break;
						 case 123: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 122;
						 break;
						 case 124: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 123;
						 break;
						 case 125: if (curChar == 102) jjAddStates(157, 158);
						 break;
						 case 129: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 125;
						 break;
						 case 130: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 129;
						 break;
						 case 131: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 130;
						 break;
						 case 133: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 132;
						 break;
						 case 134: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 133;
						 break;
						 case 136: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 135;
						 break;
						 case 137: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 136;
						 break;
						 case 138: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 137;
						 break;
						 case 139: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 138;
						 break;
						 case 140: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 139;
						 break;
						 case 141: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 140;
						 break;
						 case 142: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 141;
						 break;
						 case 143: if (curChar == 101) jjAddStates(159, 160);
						 break;
						 case 146: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 143;
						 break;
						 case 147: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 146;
						 break;
						 case 148: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 147;
						 break;
						 case 149: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 148;
						 break;
						 case 150: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 149;
						 break;
						 case 151: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 150;
						 break;
						 case 152: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 151;
						 break;
						 case 153: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 154;
						 break;
						 case 155: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(346, 350);
						 break;
						 case 156: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(156, 157);
						 break;
						 case 158: case 159: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(165, 167);
						 break;
						 case 161: if (curChar == 123 && kind > 85) kind = 85;
						 break;
						 case 162: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 153;
						 break;
						 case 163: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 162;
						 break;
						 case 164: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 163;
						 break;
						 case 165: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 164;
						 break;
						 case 166: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 165;
						 break;
						 case 167: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 166;
						 break;
						 case 168: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 167;
						 break;
						 case 169: if (curChar == 101) jjAddStates(168, 169);
						 break;
						 case 171: if (curChar == 123 && kind > 90) kind = 90;
						 break;
						 case 172: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 169;
						 break;
						 case 173: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 172;
						 break;
						 case 174: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 173;
						 break;
						 case 175: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 174;
						 break;
						 case 176: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 175;
						 break;
						 case 177: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 176;
						 break;
						 case 178: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 177;
						 break;
						 case 179: if (curChar == 99) jjAddStates(328, 330);
						 break;
						 case 180: if (curChar == 100) jjAddStates(170, 171);
						 break;
						 case 184: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 180;
						 break;
						 case 185: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 184;
						 break;
						 case 186: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 185;
						 break;
						 case 187: if (curChar == 116) jjAddStates(172, 173);
						 break;
						 case 189: if (curChar == 123 && kind > 88) kind = 88;
						 break;
						 case 190: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 187;
						 break;
						 case 191: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 190;
						 break;
						 case 192: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 191;
						 break;
						 case 193: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 192;
						 break;
						 case 194: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 193;
						 break;
						 case 195: if (curChar == 116) jjAddStates(174, 175);
						 break;
						 case 198: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 195;
						 break;
						 case 199: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 198;
						 break;
						 case 200: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 199;
						 break;
						 case 201: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 200;
						 break;
						 case 202: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 201;
						 break;
						 case 203: if (curChar == 100) jjAddStates(312, 327);
						 break;
						 case 204: if (curChar == 116) jjAddStates(176, 177);
						 break;
						 case 208: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 204;
						 break;
						 case 209: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 208;
						 break;
						 case 210: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 209;
						 break;
						 case 211: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 210;
						 break;
						 case 212: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 211;
						 break;
						 case 213: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 212;
						 break;
						 case 214: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 213;
						 break;
						 case 215: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 214;
						 break;
						 case 216: if (curChar == 102) jjAddStates(178, 179);
						 break;
						 case 220: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 216;
						 break;
						 case 221: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 220;
						 break;
						 case 222: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 221;
						 break;
						 case 224: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 223;
						 break;
						 case 225: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 224;
						 break;
						 case 227: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 226;
						 break;
						 case 228: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 227;
						 break;
						 case 229: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 228;
						 break;
						 case 230: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 229;
						 break;
						 case 231: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 230;
						 break;
						 case 232: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 231;
						 break;
						 case 233: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 232;
						 break;
						 case 234: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 233;
						 break;
						 case 235: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 234;
						 break;
						 case 236: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 237;
						 break;
						 case 238: if (curChar == 110 && kind > 30) kind = 30;
						 break;
						 case 239: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 238;
						 break;
						 case 240: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 239;
						 break;
						 case 241: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 240;
						 break;
						 case 242: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 241;
						 break;
						 case 243: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 242;
						 break;
						 case 244: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 243;
						 break;
						 case 245: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 244;
						 break;
						 case 246: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 236;
						 break;
						 case 247: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 246;
						 break;
						 case 248: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 247;
						 break;
						 case 249: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 248;
						 break;
						 case 250: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 249;
						 break;
						 case 251: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 252;
						 break;
						 case 253: if (curChar == 103 && kind > 31) kind = 31;
						 break;
						 case 254: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 253;
						 break;
						 case 255: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 254;
						 break;
						 case 256: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 255;
						 break;
						 case 257: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 256;
						 break;
						 case 258: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 257;
						 break;
						 case 259: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 258;
						 break;
						 case 260: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 259;
						 break;
						 case 261: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 251;
						 break;
						 case 262: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 261;
						 break;
						 case 263: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 262;
						 break;
						 case 264: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 263;
						 break;
						 case 265: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 264;
						 break;
						 case 266: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 267;
						 break;
						 case 268: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 269;
						 break;
						 case 270: if (curChar == 114 && kind > 34) kind = 34;
						 break;
						 case 271: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 270;
						 break;
						 case 272: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 271;
						 break;
						 case 273: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 272;
						 break;
						 case 274: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 273;
						 break;
						 case 275: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 268;
						 break;
						 case 276: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 275;
						 break;
						 case 277: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 276;
						 break;
						 case 278: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 277;
						 break;
						 case 279: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 278;
						 break;
						 case 280: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 279;
						 break;
						 case 281: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 266;
						 break;
						 case 282: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 281;
						 break;
						 case 283: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 282;
						 break;
						 case 284: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 283;
						 break;
						 case 285: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 284;
						 break;
						 case 286: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 287;
						 break;
						 case 288: if (curChar == 115 && kind > 35) kind = 35;
						 break;
						 case 289: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 288;
						 break;
						 case 290: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 289;
						 break;
						 case 291: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 290;
						 break;
						 case 292: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 291;
						 break;
						 case 293: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 292;
						 break;
						 case 294: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 293;
						 break;
						 case 295: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 294;
						 break;
						 case 296: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 295;
						 break;
						 case 297: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 296;
						 break;
						 case 299: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 298;
						 break;
						 case 300: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 299;
						 break;
						 case 301: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 300;
						 break;
						 case 302: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 301;
						 break;
						 case 303: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 302;
						 break;
						 case 304: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 303;
						 break;
						 case 305: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 304;
						 break;
						 case 306: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 286;
						 break;
						 case 307: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 306;
						 break;
						 case 308: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 307;
						 break;
						 case 309: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 308;
						 break;
						 case 310: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 309;
						 break;
						 case 311: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 312;
						 break;
						 case 313: if (curChar == 110 && kind > 54) kind = 54;
						 break;
						 case 314: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 313;
						 break;
						 case 315: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 314;
						 break;
						 case 316: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 315;
						 break;
						 case 317: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 316;
						 break;
						 case 318: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 317;
						 break;
						 case 319: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 318;
						 break;
						 case 320: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 319;
						 break;
						 case 321: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 320;
						 break;
						 case 322: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 321;
						 break;
						 case 323: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 322;
						 break;
						 case 324: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 323;
						 break;
						 case 325: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 311;
						 break;
						 case 326: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 325;
						 break;
						 case 327: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 326;
						 break;
						 case 328: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 327;
						 break;
						 case 329: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 328;
						 break;
						 case 330: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 331;
						 break;
						 case 332: if (curChar == 101 && kind > 60) kind = 60;
						 break;
						 case 333: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 332;
						 break;
						 case 334: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 333;
						 break;
						 case 335: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 334;
						 break;
						 case 336: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 335;
						 break;
						 case 337: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 336;
						 break;
						 case 338: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 337;
						 break;
						 case 339: if (curChar == 120) jjstateSet[jjnewStateCnt++] = 338;
						 break;
						 case 340: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 330;
						 break;
						 case 341: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 340;
						 break;
						 case 342: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 341;
						 break;
						 case 343: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 342;
						 break;
						 case 344: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 343;
						 break;
						 case 345: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 346;
						 break;
						 case 347: if (curChar == 105 && kind > 61) kind = 61;
						 break;
						 case 348: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 347;
						 break;
						 case 349: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 348;
						 break;
						 case 351: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 350;
						 break;
						 case 352: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 351;
						 break;
						 case 353: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 352;
						 break;
						 case 354: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 353;
						 break;
						 case 355: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 345;
						 break;
						 case 356: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 355;
						 break;
						 case 357: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 356;
						 break;
						 case 358: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 357;
						 break;
						 case 359: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 358;
						 break;
						 case 360: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 361;
						 break;
						 case 362: if (curChar == 101 && kind > 65) kind = 65;
						 break;
						 case 363: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 362;
						 break;
						 case 364: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 363;
						 break;
						 case 365: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 364;
						 break;
						 case 366: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 365;
						 break;
						 case 367: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 366;
						 break;
						 case 368: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 367;
						 break;
						 case 369: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 368;
						 break;
						 case 370: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 369;
						 break;
						 case 371: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 360;
						 break;
						 case 372: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 371;
						 break;
						 case 373: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 372;
						 break;
						 case 374: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 373;
						 break;
						 case 375: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 374;
						 break;
						 case 376: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 377;
						 break;
						 case 378: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 379;
						 break;
						 case 380: if (curChar == 110 && kind > 92) kind = 92;
						 break;
						 case 381: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 380;
						 break;
						 case 382: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 381;
						 break;
						 case 383: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 382;
						 break;
						 case 384: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 383;
						 break;
						 case 385: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 384;
						 break;
						 case 386: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 385;
						 break;
						 case 387: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 386;
						 break;
						 case 388: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 387;
						 break;
						 case 389: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 378;
						 break;
						 case 390: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 389;
						 break;
						 case 391: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 390;
						 break;
						 case 392: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 391;
						 break;
						 case 393: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 392;
						 break;
						 case 394: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 393;
						 break;
						 case 395: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 376;
						 break;
						 case 396: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 395;
						 break;
						 case 397: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 396;
						 break;
						 case 398: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 397;
						 break;
						 case 399: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 398;
						 break;
						 case 400: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 401;
						 break;
						 case 402: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 403;
						 break;
						 case 404: if (curChar == 116 && kind > 94) kind = 94;
						 break;
						 case 405: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 404;
						 break;
						 case 406: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 405;
						 break;
						 case 407: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 406;
						 break;
						 case 408: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 407;
						 break;
						 case 409: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 408;
						 break;
						 case 410: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 409;
						 break;
						 case 411: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 402;
						 break;
						 case 412: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 411;
						 break;
						 case 413: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 412;
						 break;
						 case 414: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 413;
						 break;
						 case 415: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 414;
						 break;
						 case 416: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 415;
						 break;
						 case 417: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 400;
						 break;
						 case 418: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 417;
						 break;
						 case 419: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 418;
						 break;
						 case 420: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 419;
						 break;
						 case 421: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 420;
						 break;
						 case 422: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 423;
						 break;
						 case 424: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 425;
						 break;
						 case 426: if (curChar == 110 && kind > 95) kind = 95;
						 break;
						 case 427: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 426;
						 break;
						 case 428: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 427;
						 break;
						 case 429: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 428;
						 break;
						 case 430: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 429;
						 break;
						 case 431: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 430;
						 break;
						 case 432: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 431;
						 break;
						 case 433: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 432;
						 break;
						 case 434: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 424;
						 break;
						 case 435: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 434;
						 break;
						 case 436: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 435;
						 break;
						 case 437: if (curChar == 102) jjstateSet[jjnewStateCnt++] = 436;
						 break;
						 case 438: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 437;
						 break;
						 case 439: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 438;
						 break;
						 case 440: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 422;
						 break;
						 case 441: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 440;
						 break;
						 case 442: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 441;
						 break;
						 case 443: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 442;
						 break;
						 case 444: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 443;
						 break;
						 case 445: if (curChar == 101) jjAddStates(210, 211);
						 break;
						 case 448: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 445;
						 break;
						 case 449: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 448;
						 break;
						 case 450: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 449;
						 break;
						 case 452: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 451;
						 break;
						 case 453: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 452;
						 break;
						 case 454: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 453;
						 break;
						 case 455: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 454;
						 break;
						 case 456: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 455;
						 break;
						 case 457: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 456;
						 break;
						 case 458: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 457;
						 break;
						 case 459: if (curChar == 116) jjAddStates(212, 213);
						 break;
						 case 461: if (curChar == 123 && kind > 151) kind = 151;
						 break;
						 case 462: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 459;
						 break;
						 case 463: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 462;
						 break;
						 case 464: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 463;
						 break;
						 case 465: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 464;
						 break;
						 case 466: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 465;
						 break;
						 case 467: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 466;
						 break;
						 case 468: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 469;
						 break;
						 case 470: if (curChar == 101) jjAddStates(216, 217);
						 break;
						 case 473: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 470;
						 break;
						 case 474: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 473;
						 break;
						 case 475: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 474;
						 break;
						 case 476: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 475;
						 break;
						 case 477: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 476;
						 break;
						 case 478: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 477;
						 break;
						 case 479: if (curChar == 118) jjstateSet[jjnewStateCnt++] = 478;
						 break;
						 case 480: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 468;
						 break;
						 case 481: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 480;
						 break;
						 case 482: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 481;
						 break;
						 case 483: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 482;
						 break;
						 case 484: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 483;
						 break;
						 case 485: if (curChar == 112) jjAddStates(306, 311);
						 break;
						 case 486: if (curChar == 116) jjAddStates(218, 219);
						 break;
						 case 490: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 486;
						 break;
						 case 491: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 490;
						 break;
						 case 492: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 491;
						 break;
						 case 493: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 492;
						 break;
						 case 494: if (curChar == 103) jjAddStates(220, 221);
						 break;
						 case 498: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 494;
						 break;
						 case 499: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 498;
						 break;
						 case 500: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 499;
						 break;
						 case 501: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 500;
						 break;
						 case 502: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 501;
						 break;
						 case 503: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 502;
						 break;
						 case 505: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 504;
						 break;
						 case 506: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 505;
						 break;
						 case 507: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 506;
						 break;
						 case 508: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 507;
						 break;
						 case 509: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 508;
						 break;
						 case 510: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 509;
						 break;
						 case 511: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 510;
						 break;
						 case 512: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 511;
						 break;
						 case 513: if (curChar == 103) jjAddStates(222, 223);
						 break;
						 case 517: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 513;
						 break;
						 case 518: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 517;
						 break;
						 case 519: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 518;
						 break;
						 case 520: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 519;
						 break;
						 case 521: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 520;
						 break;
						 case 522: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 521;
						 break;
						 case 523: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 522;
						 break;
						 case 524: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 525;
						 break;
						 case 526: case 527: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(226, 228);
						 break;
						 case 529: if (curChar == 123 && kind > 86) kind = 86;
						 break;
						 case 530: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 524;
						 break;
						 case 531: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 530;
						 break;
						 case 532: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 531;
						 break;
						 case 533: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 532;
						 break;
						 case 534: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 533;
						 break;
						 case 535: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 534;
						 break;
						 case 536: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 535;
						 break;
						 case 537: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 536;
						 break;
						 case 538: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 537;
						 break;
						 case 539: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 538;
						 break;
						 case 541: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 540;
						 break;
						 case 542: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 541;
						 break;
						 case 543: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 542;
						 break;
						 case 544: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 543;
						 break;
						 case 545: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 544;
						 break;
						 case 546: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 545;
						 break;
						 case 547: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 546;
						 break;
						 case 548: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 547;
						 break;
						 case 549: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 548;
						 break;
						 case 550: if (curChar == 110) jjAddStates(229, 230);
						 break;
						 case 552: if (curChar == 123 && kind > 87) kind = 87;
						 break;
						 case 553: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 550;
						 break;
						 case 554: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 553;
						 break;
						 case 555: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 554;
						 break;
						 case 556: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 555;
						 break;
						 case 557: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 556;
						 break;
						 case 558: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 557;
						 break;
						 case 559: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 558;
						 break;
						 case 560: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 559;
						 break;
						 case 561: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 560;
						 break;
						 case 562: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 561;
						 break;
						 case 564: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 563;
						 break;
						 case 565: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 564;
						 break;
						 case 566: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 565;
						 break;
						 case 567: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 566;
						 break;
						 case 568: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 567;
						 break;
						 case 569: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 568;
						 break;
						 case 570: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 569;
						 break;
						 case 571: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 570;
						 break;
						 case 572: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 571;
						 break;
						 case 573: if (curChar == 110) jjAddStates(231, 232);
						 break;
						 case 576: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 573;
						 break;
						 case 577: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 576;
						 break;
						 case 578: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 577;
						 break;
						 case 579: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 578;
						 break;
						 case 580: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 579;
						 break;
						 case 581: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 580;
						 break;
						 case 582: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 581;
						 break;
						 case 583: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 582;
						 break;
						 case 584: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 583;
						 break;
						 case 585: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 584;
						 break;
						 case 587: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 586;
						 break;
						 case 588: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 587;
						 break;
						 case 589: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 588;
						 break;
						 case 590: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 589;
						 break;
						 case 591: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 590;
						 break;
						 case 592: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 591;
						 break;
						 case 593: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 592;
						 break;
						 case 594: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 593;
						 break;
						 case 595: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 594;
						 break;
						 case 596: if (curChar == 115) jjAddStates(302, 305);
						 break;
						 case 597: if (curChar == 102) jjAddStates(233, 234);
						 break;
						 case 601: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 597;
						 break;
						 case 602: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 601;
						 break;
						 case 603: if (curChar == 116) jjAddStates(235, 236);
						 break;
						 case 606: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 603;
						 break;
						 case 607: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 606;
						 break;
						 case 608: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 607;
						 break;
						 case 609: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 608;
						 break;
						 case 610: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 609;
						 break;
						 case 611: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 610;
						 break;
						 case 613: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 612;
						 break;
						 case 614: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 613;
						 break;
						 case 615: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 614;
						 break;
						 case 616: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 615;
						 break;
						 case 617: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 616;
						 break;
						 case 618: if (curChar == 101) jjAddStates(237, 238);
						 break;
						 case 621: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 618;
						 break;
						 case 622: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 621;
						 break;
						 case 623: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 622;
						 break;
						 case 624: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 623;
						 break;
						 case 625: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 624;
						 break;
						 case 626: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 625;
						 break;
						 case 627: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 626;
						 break;
						 case 628: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 627;
						 break;
						 case 630: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 629;
						 break;
						 case 631: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 630;
						 break;
						 case 632: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 631;
						 break;
						 case 633: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 632;
						 break;
						 case 634: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 633;
						 break;
						 case 635: if (curChar == 101) jjAddStates(239, 240);
						 break;
						 case 638: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 635;
						 break;
						 case 639: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 638;
						 break;
						 case 640: if (curChar == 102) jjAddStates(299, 301);
						 break;
						 case 641: if (curChar == 103) jjAddStates(241, 242);
						 break;
						 case 645: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 641;
						 break;
						 case 646: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 645;
						 break;
						 case 647: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 646;
						 break;
						 case 648: if (curChar == 98) jjstateSet[jjnewStateCnt++] = 647;
						 break;
						 case 649: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 648;
						 break;
						 case 650: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 649;
						 break;
						 case 652: if (curChar == 103) jjstateSet[jjnewStateCnt++] = 651;
						 break;
						 case 653: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 652;
						 break;
						 case 654: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 653;
						 break;
						 case 655: if (curChar == 119) jjstateSet[jjnewStateCnt++] = 654;
						 break;
						 case 656: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 655;
						 break;
						 case 657: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 656;
						 break;
						 case 658: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 657;
						 break;
						 case 659: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 658;
						 break;
						 case 660: if (curChar == 103) jjAddStates(243, 244);
						 break;
						 case 664: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 660;
						 break;
						 case 665: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 664;
						 break;
						 case 666: if (curChar == 119) jjstateSet[jjnewStateCnt++] = 665;
						 break;
						 case 667: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 666;
						 break;
						 case 668: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 667;
						 break;
						 case 669: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 668;
						 break;
						 case 670: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 669;
						 break;
						 case 671: if (curChar == 114) jjAddStates(245, 246);
						 break;
						 case 674: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 671;
						 break;
						 case 675: if (curChar == 101) jjAddStates(295, 298);
						 break;
						 case 676: if (curChar == 116) jjAddStates(247, 248);
						 break;
						 case 679: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 676;
						 break;
						 case 680: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 679;
						 break;
						 case 681: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 680;
						 break;
						 case 682: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 681;
						 break;
						 case 683: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 682;
						 break;
						 case 684: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 685;
						 break;
						 case 686: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(351, 355);
						 break;
						 case 687: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(687, 688);
						 break;
						 case 689: case 690: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(253, 255);
						 break;
						 case 692: if (curChar == 123 && kind > 84) kind = 84;
						 break;
						 case 693: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 684;
						 break;
						 case 694: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 693;
						 break;
						 case 695: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 694;
						 break;
						 case 696: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 695;
						 break;
						 case 697: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 696;
						 break;
						 case 698: if (curChar == 116) jjAddStates(256, 257);
						 break;
						 case 700: if (curChar == 123 && kind > 89) kind = 89;
						 break;
						 case 701: if (curChar == 110) jjstateSet[jjnewStateCnt++] = 698;
						 break;
						 case 702: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 701;
						 break;
						 case 703: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 702;
						 break;
						 case 704: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 703;
						 break;
						 case 705: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 704;
						 break;
						 case 706: if (curChar == 121) jjAddStates(258, 259);
						 break;
						 case 709: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 706;
						 break;
						 case 710: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 709;
						 break;
						 case 711: if (curChar == 118) jjstateSet[jjnewStateCnt++] = 710;
						 break;
						 case 712: if (curChar == 116) jjAddStates(292, 294);
						 break;
						 case 713: if (curChar == 116) jjAddStates(260, 261);
						 break;
						 case 715: if (curChar == 123 && kind > 91) kind = 91;
						 break;
						 case 716: if (curChar == 120) jjstateSet[jjnewStateCnt++] = 713;
						 break;
						 case 717: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 716;
						 break;
						 case 718: if (curChar == 116) jjAddStates(262, 263);
						 break;
						 case 721: if (curChar == 120) jjstateSet[jjnewStateCnt++] = 718;
						 break;
						 case 722: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 721;
						 break;
						 case 723: if (curChar == 104) jjAddStates(264, 265);
						 break;
						 case 726: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 723;
						 break;
						 case 727: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 726;
						 break;
						 case 728: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 727;
						 break;
						 case 729: if (curChar == 119) jjstateSet[jjnewStateCnt++] = 728;
						 break;
						 case 730: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 729;
						 break;
						 case 731: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 730;
						 break;
						 case 732: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 731;
						 break;
						 case 733: if (curChar == 121) jjstateSet[jjnewStateCnt++] = 732;
						 break;
						 case 734: if (curChar == 105) jjAddStates(289, 291);
						 break;
						 case 735: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 736;
						 break;
						 case 737: if (curChar == 97 && kind > 97) kind = 97;
						 break;
						 case 738: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 737;
						 break;
						 case 739: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 738;
						 break;
						 case 740: if (curChar == 104) jjstateSet[jjnewStateCnt++] = 739;
						 break;
						 case 741: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 740;
						 break;
						 case 742: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 741;
						 break;
						 case 743: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 735;
						 break;
						 case 744: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 743;
						 break;
						 case 745: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 744;
						 break;
						 case 746: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 745;
						 break;
						 case 747: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 748;
						 break;
						 case 749: if (curChar == 101 && kind > 98) kind = 98;
						 break;
						 case 750: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 749;
						 break;
						 case 751: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 750;
						 break;
						 case 752: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 751;
						 break;
						 case 753: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 752;
						 break;
						 case 754: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 753;
						 break;
						 case 755: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 747;
						 break;
						 case 756: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 755;
						 break;
						 case 757: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 756;
						 break;
						 case 758: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 757;
						 break;
						 case 759: if (curChar == 102) jjAddStates(270, 271);
						 break;
						 case 762: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAddStates(277, 286);
						 break;
						 case 763: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(763, 764);
						 break;
						 case 766: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(766, 767);
						 break;
						 case 768: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(109, 111);
						 break;
						 case 769: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddStates(109, 111);
						 break;
						 case 772: if ((0x7fffffe87fffffeL & l) != 0L) jjCheckNAddTwoStates(772, 773);
						 break;
						 case 774: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAdd(775);
						 break;
						 case 775: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAdd(775);
						 break;
						 case 776: if (curChar == 118) jjAddStates(287, 288);
						 break;
						 case 777: if (curChar == 101) jjAddStates(272, 273);
						 break;
						 case 779: if (curChar == 123 && kind > 146) kind = 146;
						 break;
						 case 780: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 777;
						 break;
						 case 781: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 780;
						 break;
						 case 782: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 781;
						 break;
						 case 783: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 782;
						 break;
						 case 784: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 783;
						 break;
						 case 785: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 784;
						 break;
						 case 786: if (curChar == 101) jjstateSet[jjnewStateCnt++] = 787;
						 break;
						 case 788: if (curChar == 120 && kind > 147) kind = 147;
						 break;
						 case 789: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 788;
						 break;
						 case 790: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 789;
						 break;
						 case 791: if (curChar == 116 && kind > 147) kind = 147;
						 break;
						 case 792: if (curChar == 99) jjstateSet[jjnewStateCnt++] = 791;
						 break;
						 case 793: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 792;
						 break;
						 case 794: if (curChar == 114) jjstateSet[jjnewStateCnt++] = 793;
						 break;
						 case 795: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 794;
						 break;
						 case 796: if (curChar == 115) jjstateSet[jjnewStateCnt++] = 795;
						 break;
						 case 797: if (curChar == 116) jjstateSet[jjnewStateCnt++] = 786;
						 break;
						 case 798: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 797;
						 break;
						 case 799: if (curChar == 100) jjstateSet[jjnewStateCnt++] = 798;
						 break;
						 case 800: if (curChar == 105) jjstateSet[jjnewStateCnt++] = 799;
						 break;
						 case 801: if (curChar == 108) jjstateSet[jjnewStateCnt++] = 800;
						 break;
						 case 802: if (curChar == 97) jjstateSet[jjnewStateCnt++] = 801;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 804: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(763, 764);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(766, 767);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(109, 111);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(772, 773);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 235) kind = 235;
							 jjCheckNAdd(775);
						 }
						 break;
						 case 96: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(763, 764);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(766, 767);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(109, 111);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(772, 773);
						 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							 if (kind > 235) kind = 235;
							 jjCheckNAdd(775);
						 }
						 break;
						 case 19: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAddStates(277, 286);
						 break;
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(0, 1);
						 break;
						 case 4: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(2, 3);
						 break;
						 case 59: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 104) kind = 104;
						 jjCheckNAdd(60);
						 break;
						 case 60: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 104) kind = 104;
						 jjCheckNAdd(60);
						 break;
						 case 99: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(342, 343);
						 break;
						 case 102: if (jjCanMove_2(hiByte, i1, i2, l1, l2)) jjAddStates(344, 345);
						 break;
						 case 155: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(346, 350);
						 break;
						 case 156: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(156, 157);
						 break;
						 case 158: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(165, 167);
						 break;
						 case 159: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(165, 167);
						 break;
						 case 526: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(226, 228);
						 break;
						 case 527: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(226, 228);
						 break;
						 case 686: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(351, 355);
						 break;
						 case 687: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(687, 688);
						 break;
						 case 689: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(253, 255);
						 break;
						 case 690: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(253, 255);
						 break;
						 case 763: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(763, 764);
						 break;
						 case 766: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(766, 767);
						 break;
						 case 768: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(109, 111);
						 break;
						 case 769: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddStates(109, 111);
						 break;
						 case 772: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(772, 773);
						 break;
						 case 774: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAdd(775);
						 break;
						 case 775: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 235) kind = 235;
						 jjCheckNAdd(775);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 803 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_20(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x4028000L) != 0L) {
				 jjmatchedKind = 212;
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_20(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_20(jjStopStringLiteralDfa_20(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_20(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_20(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_20(){
		 switch(curChar) {
			 case 39: jjmatchedKind = 212;
			 return jjMoveStringLiteralDfa1_20(0x20000L);
			 case 123: jjmatchedKind = 204;
			 return jjMoveStringLiteralDfa1_20(0x4000L);
			 case 125: return jjMoveStringLiteralDfa1_20(0x8000L);
			 default : return jjMoveNfa_20(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_20(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_20(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 39: if ((active3 & 0x20000L) != 0L) return jjStopAtPos(1, 209);
			 break;
			 case 123: if ((active3 & 0x4000L) != 0L) return jjStopAtPos(1, 206);
			 break;
			 case 125: if ((active3 & 0x8000L) != 0L) return jjStopAtPos(1, 207);
			 break;
			 default : break;
		 }
		 return jjStartNfa_20(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_20(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 21;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) {
							 if (kind > 212) kind = 212;
						 }
						 if (curChar == 38) jjstateSet[jjnewStateCnt++] = 14;
						 if (curChar == 38) jjAddStates(77, 80);
						 break;
						 case 2: if (curChar == 59 && kind > 193) kind = 193;
						 break;
						 case 14: if (curChar == 35) jjCheckNAddTwoStates(15, 17);
						 break;
						 case 15: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(15, 16);
						 break;
						 case 16: if (curChar == 59 && kind > 194) kind = 194;
						 break;
						 case 18: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(18, 16);
						 break;
						 case 19: if (curChar == 38) jjstateSet[jjnewStateCnt++] = 14;
						 break;
						 case 20: if ((0xffffffff00002600L & l) != 0L && kind > 212) kind = 212;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (kind > 212) kind = 212;
						 break;
						 case 1: if (curChar == 116) jjCheckNAdd(2);
						 break;
						 case 3: if (curChar == 108) jjCheckNAdd(1);
						 break;
						 case 4: if (curChar == 103) jjCheckNAdd(1);
						 break;
						 case 5: if (curChar == 111) jjCheckNAdd(1);
						 break;
						 case 6: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 case 7: if (curChar == 113) jjstateSet[jjnewStateCnt++] = 6;
						 break;
						 case 8: if (curChar == 97) jjAddStates(81, 82);
						 break;
						 case 9: if (curChar == 112) jjCheckNAdd(2);
						 break;
						 case 10: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 115) jjCheckNAdd(2);
						 break;
						 case 12: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 17: if (curChar == 120) jjCheckNAdd(18);
						 break;
						 case 18: if ((0x7e0000007eL & l) != 0L) jjCheckNAddTwoStates(18, 16);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 212) kind = 212;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 21 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_11(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x800000000L) != 0L) {
				 jjmatchedKind = 14;
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_11(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_11(jjStopStringLiteralDfa_11(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_11(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_11(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_11(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_11(0x800000000L);
			 case 42: return jjStopAtPos(0, 131);
			 case 43: return jjStopAtPos(0, 132);
			 case 63: return jjStopAtPos(0, 130);
			 default : return jjMoveNfa_11(1, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_11(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_11(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) return jjStopAtPos(1, 227);
			 break;
			 default : break;
		 }
		 return jjStartNfa_11(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_11(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 2;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if ((0x7ffff3ffffffffffL & l) != 0L) {
							 if (kind > 14) kind = 14;
						 }
						 if ((0x100002600L & l) != 0L) {
							 if (kind > 12) kind = 12;
							 jjCheckNAdd(0);
						 }
						 break;
						 case 0: if ((0x100002600L & l) == 0L) break;
						 if (kind > 12) kind = 12;
						 jjCheckNAdd(0);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: kind = 14;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 1: if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 14) kind = 14;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_17(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 case 0: if ((active3 & 0x8000L) != 0L) {
				 jjmatchedKind = 211;
				 return -1;
			 }
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_17(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_17(jjStopStringLiteralDfa_17(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_17(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_17(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_17(){
		 switch(curChar) {
			 case 34: jjmatchedKind = 173;
			 return jjMoveStringLiteralDfa1_17(0x10000L);
			 case 123: jjmatchedKind = 204;
			 return jjMoveStringLiteralDfa1_17(0x4000L);
			 case 125: return jjMoveStringLiteralDfa1_17(0x8000L);
			 default : return jjMoveNfa_17(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_17(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_17(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 34: if ((active3 & 0x10000L) != 0L) return jjStopAtPos(1, 208);
			 break;
			 case 123: if ((active3 & 0x4000L) != 0L) return jjStopAtPos(1, 206);
			 break;
			 case 125: if ((active3 & 0x8000L) != 0L) return jjStopAtPos(1, 207);
			 break;
			 default : break;
		 }
		 return jjStartNfa_17(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_17(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 21;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0xffffffff00002600L & l) != 0L) {
							 if (kind > 211) kind = 211;
						 }
						 if (curChar == 38) jjstateSet[jjnewStateCnt++] = 14;
						 if (curChar == 38) jjAddStates(77, 80);
						 break;
						 case 2: if (curChar == 59 && kind > 193) kind = 193;
						 break;
						 case 14: if (curChar == 35) jjCheckNAddTwoStates(15, 17);
						 break;
						 case 15: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(15, 16);
						 break;
						 case 16: if (curChar == 59 && kind > 194) kind = 194;
						 break;
						 case 18: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(18, 16);
						 break;
						 case 19: if (curChar == 38) jjstateSet[jjnewStateCnt++] = 14;
						 break;
						 case 20: if ((0xffffffff00002600L & l) != 0L && kind > 211) kind = 211;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (kind > 211) kind = 211;
						 break;
						 case 1: if (curChar == 116) jjCheckNAdd(2);
						 break;
						 case 3: if (curChar == 108) jjCheckNAdd(1);
						 break;
						 case 4: if (curChar == 103) jjCheckNAdd(1);
						 break;
						 case 5: if (curChar == 111) jjCheckNAdd(1);
						 break;
						 case 6: if (curChar == 117) jjstateSet[jjnewStateCnt++] = 5;
						 break;
						 case 7: if (curChar == 113) jjstateSet[jjnewStateCnt++] = 6;
						 break;
						 case 8: if (curChar == 97) jjAddStates(81, 82);
						 break;
						 case 9: if (curChar == 112) jjCheckNAdd(2);
						 break;
						 case 10: if (curChar == 109) jjstateSet[jjnewStateCnt++] = 9;
						 break;
						 case 11: if (curChar == 115) jjCheckNAdd(2);
						 break;
						 case 12: if (curChar == 111) jjstateSet[jjnewStateCnt++] = 11;
						 break;
						 case 13: if (curChar == 112) jjstateSet[jjnewStateCnt++] = 12;
						 break;
						 case 17: if (curChar == 120) jjCheckNAdd(18);
						 break;
						 case 18: if ((0x7e0000007eL & l) != 0L) jjCheckNAddTwoStates(18, 16);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 211) kind = 211;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 21 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	private final int jjStopStringLiteralDfa_12(int pos, long active0, long active1, long active2, long active3){
		 switch (pos) {
			 default : return -1;
		 }
	}
	private final int jjStartNfa_12(int pos, long active0, long active1, long active2, long active3){
		 return jjMoveNfa_12(jjStopStringLiteralDfa_12(pos, active0, active1, active2, active3), pos + 1);
	}
	private final int jjStartNfaWithStates_12(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_12(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_12(){
		 switch(curChar) {
			 case 40: return jjMoveStringLiteralDfa1_12(0x800000000L);
			 case 41: return jjStopAtPos(0, 139);
			 case 44: return jjStopAtPos(0, 169);
			 case 63: return jjStopAtPos(0, 53);
			 case 123: return jjStopAtPos(0, 205);
			 default : return jjMoveNfa_12(0, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_12(long active3){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_12(0, 0L, 0L, 0L, active3);
			 return 1;
		 }
		 switch(curChar) {
			 case 58: if ((active3 & 0x800000000L) != 0L) return jjStopAtPos(1, 227);
			 break;
			 default : break;
		 }
		 return jjStartNfa_12(0, 0L, 0L, 0L, active3);
	}
	private final int jjMoveNfa_12(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 1;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 0: if ((0x100002600L & l) == 0L) break;
						 kind = 12;
						 jjstateSet[jjnewStateCnt++] = 0;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	static final int[] jjnextStates = {
	 1, 2, 4, 5, 2, 3, 2, 3, 5, 11, 12, 27, 28, 27, 28, 30, 56, 57, 60, 17, 18, 41, 42, 47, 49, 64, 65, 75, 77, 85, 86, 93, 95, 103, 105, 109, 110, 118, 119, 126, 127, 135, 137, 142, 143, 148, 149, 163, 164, 180, 188, 182, 184, 194, 195, 197, 198, 199, 201, 161, 178, 192, 140, 145, 124, 132, 101, 107, 115, 83, 90, 55, 72, 58, 59, 61, 62, 3, 4, 7, 8, 10, 13, 16, 18, 32, 33, 37, 39, 59, 67, 61, 63, 74, 76, 84, 86, 91, 99, 104, 109, 102, 112, 82, 88, 57, 71, 8, 15, 769, 770, 771, 73, 74, 75, 77, 78, 80, 83, 84, 86, 89, 92, 93, 94, 94, 86, 89, 7, 14, 21, 30, 38, 39, 47, 48, 62, 63, 67, 68, 77, 78, 80, 83, 84, 86, 89, 85, 86, 89, 97, 98, 101, 105, 107, 116, 118, 126, 128, 144, 145, 154, 155, 156, 157, 159, 160, 161, 170, 171, 181, 183, 188, 189, 196, 197, 205, 207, 217, 219, 237, 245, 252, 260, 267, 280, 269, 274, 287, 305, 312, 324, 331, 339, 346, 354, 361, 370, 377, 394, 379, 388, 401, 416, 403, 410, 423, 439, 425, 433, 446, 447, 460, 461, 469, 479, 471, 472, 487, 489, 495, 497, 514, 516, 525, 526, 527, 528, 529, 551, 552, 574, 575, 598, 600, 604, 605, 619, 620, 636, 637, 642, 644, 661, 663, 672, 673, 677, 678, 685, 686, 687, 688, 690, 691, 692, 699, 700, 707, 708, 714, 715, 719, 720, 724, 725, 736, 742, 748, 754, 760, 761, 778, 779, 787, 790, 796, 763, 764, 766, 767, 769, 770, 771, 772, 773, 775, 785, 802, 746, 758, 759, 717, 722, 733, 683, 697, 705, 711, 659, 670, 674, 602, 617, 634, 639, 493, 512, 523, 549, 572, 595, 215, 235, 250, 265, 285, 310, 329, 344, 359, 375, 399, 421, 444, 458, 467, 484, 186, 194, 202, 96, 114, 124, 142, 152, 168, 178, 81, 82, 87, 88, 99, 100, 102, 103, 156, 157, 159, 160, 161, 687, 688, 690, 691, 692, }
	;
	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec2[i2] & l2) != 0L);
			 case 1: return ((jjbitVec3[i2] & l2) != 0L);
			 case 2: return ((jjbitVec4[i2] & l2) != 0L);
			 case 3: return ((jjbitVec5[i2] & l2) != 0L);
			 case 4: return ((jjbitVec6[i2] & l2) != 0L);
			 case 5: return ((jjbitVec7[i2] & l2) != 0L);
			 case 6: return ((jjbitVec8[i2] & l2) != 0L);
			 case 9: return ((jjbitVec9[i2] & l2) != 0L);
			 case 10: return ((jjbitVec10[i2] & l2) != 0L);
			 case 11: return ((jjbitVec11[i2] & l2) != 0L);
			 case 12: return ((jjbitVec12[i2] & l2) != 0L);
			 case 13: return ((jjbitVec13[i2] & l2) != 0L);
			 case 14: return ((jjbitVec14[i2] & l2) != 0L);
			 case 15: return ((jjbitVec15[i2] & l2) != 0L);
			 case 16: return ((jjbitVec16[i2] & l2) != 0L);
			 case 17: return ((jjbitVec17[i2] & l2) != 0L);
			 case 30: return ((jjbitVec18[i2] & l2) != 0L);
			 case 31: return ((jjbitVec19[i2] & l2) != 0L);
			 case 33: return ((jjbitVec20[i2] & l2) != 0L);
			 case 48: return ((jjbitVec21[i2] & l2) != 0L);
			 case 49: return ((jjbitVec22[i2] & l2) != 0L);
			 case 159: return ((jjbitVec23[i2] & l2) != 0L);
			 case 215: return ((jjbitVec24[i2] & l2) != 0L);
			 default : if ((jjbitVec0[i1] & l1) != 0L) return true;
			 return false;
		 }
	}
	private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec25[i2] & l2) != 0L);
			 case 1: return ((jjbitVec3[i2] & l2) != 0L);
			 case 2: return ((jjbitVec26[i2] & l2) != 0L);
			 case 3: return ((jjbitVec27[i2] & l2) != 0L);
			 case 4: return ((jjbitVec28[i2] & l2) != 0L);
			 case 5: return ((jjbitVec29[i2] & l2) != 0L);
			 case 6: return ((jjbitVec30[i2] & l2) != 0L);
			 case 9: return ((jjbitVec31[i2] & l2) != 0L);
			 case 10: return ((jjbitVec32[i2] & l2) != 0L);
			 case 11: return ((jjbitVec33[i2] & l2) != 0L);
			 case 12: return ((jjbitVec34[i2] & l2) != 0L);
			 case 13: return ((jjbitVec35[i2] & l2) != 0L);
			 case 14: return ((jjbitVec36[i2] & l2) != 0L);
			 case 15: return ((jjbitVec37[i2] & l2) != 0L);
			 case 16: return ((jjbitVec16[i2] & l2) != 0L);
			 case 17: return ((jjbitVec17[i2] & l2) != 0L);
			 case 30: return ((jjbitVec18[i2] & l2) != 0L);
			 case 31: return ((jjbitVec19[i2] & l2) != 0L);
			 case 32: return ((jjbitVec38[i2] & l2) != 0L);
			 case 33: return ((jjbitVec20[i2] & l2) != 0L);
			 case 48: return ((jjbitVec39[i2] & l2) != 0L);
			 case 49: return ((jjbitVec22[i2] & l2) != 0L);
			 case 159: return ((jjbitVec23[i2] & l2) != 0L);
			 case 215: return ((jjbitVec24[i2] & l2) != 0L);
			 default : if ((jjbitVec0[i1] & l1) != 0L) return true;
			 return false;
		 }
	}
	private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec41[i2] & l2) != 0L);
			 default : if ((jjbitVec40[i1] & l1) != 0L) return true;
			 return false;
		 }
	}
	private static final boolean jjCanMove_3(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec41[i2] & l2) != 0L);
			 case 255: return ((jjbitVec43[i2] & l2) != 0L);
			 default : if ((jjbitVec42[i1] & l1) != 0L) return true;
			 return false;
		 }
	}
	public static final String[] jjstrLiteralImages = {
	"""", null, null, null, null, null, null, null, ""\145\156\143\157\144\151\156\147"", null, null, null, null, null, null, ""\74\77"", ""\74\77"", ""\77\76"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, ""\157\162\144\145\162\145\144"", ""\165\156\157\162\144\145\162\145\144"", null, null, ""\171\145\163"", ""\156\157"", ""\145\170\164\145\162\156\141\154"", ""\157\162"", ""\141\156\144"", ""\144\151\166"", ""\151\144\151\166"", ""\155\157\144"", ""\52"", ""\151\156"", null, null, null, ""\44"", null, null, null, ""\77"", null, ""\163\141\164\151\163\146\151\145\163"", ""\162\145\164\165\162\156"", ""\164\150\145\156"", ""\145\154\163\145"", ""\144\145\146\141\165\154\164"", null, null, ""\160\162\145\163\145\162\166\145"", ""\163\164\162\151\160"", ""\156\141\155\145\163\160\141\143\145"", null, ""\164\157"", ""\167\150\145\162\145"", ""\143\157\154\154\141\164\151\157\156"", ""\151\156\164\145\162\163\145\143\164"", ""\165\156\151\157\156"", ""\145\170\143\145\160\164"", ""\141\163"", ""\141\164"", ""\143\141\163\145"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, ""\52"", ""\52"", null, null, ""\57"", ""\57\57"", ""\57"", ""\57\57"", ""\75"", ""\75"", ""\151\163"", ""\41\75"", ""\74\75"", ""\74\74"", ""\76\75"", ""\76\76"", ""\145\161"", ""\156\145"", ""\147\164"", ""\147\145"", ""\154\164"", ""\154\145"", ""\72\75"", ""\74"", ""\76"", ""\55"", ""\53"", ""\55"", ""\53"", ""\77"", ""\52"", ""\53"", ""\174"", ""\50"", ""\100"", ""\133"", ""\135"", ""\51"", ""\51"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, ""\54"", ""\54"", ""\73"", ""\45\45\45"", ""\42"", ""\42"", ""\56"", ""\56\56"", null, null, ""\141\163\143\145\156\144\151\156\147"", ""\144\145\163\143\145\156\144\151\156\147"", null, null, null, null, null, null, null, null, null, null, ""\74\41\133\103\104\101\124\101\133"", ""\74\41\133\103\104\101\124\101\133"", null, null, null, null, ""\74"", ""\74"", ""\76"", ""\57\76"", ""\74\57"", ""\76"", ""\75"", null, ""\173"", ""\173"", ""\173\173"", ""\175\175"", ""\42\42"", ""\47\47"", null, null, null, null, null, null, null, ""\47"", ""\47"", null, null, null, null, null, null, null, null, null, null, null, null, null, ""\74\41\55\55"", ""\74\41\55\55"", ""\55\55\76"", null, null, null, null, null, null, ""\175"", null, null, null, null, null, null, null, null, null, }
	;
	public static final String[] lexStateNames = {
	 ""DEFAULT"", ""OPERATOR"", ""KINDTESTFORPI"", ""XQUERYVERSION"", ""ITEMTYPE"", ""NAMESPACEDECL"", ""NAMESPACEKEYWORD"", ""KINDTEST"", ""XMLSPACE_DECL"", ""SINGLETYPE"", ""VARNAME"", ""OCCURRENCEINDICATOR"", ""CLOSEKINDTEST"", ""ELEMENT_CONTENT"", ""PROCESSING_INSTRUCTION"", ""PROCESSING_INSTRUCTION_CONTENT"", ""START_TAG"", ""QUOT_ATTRIBUTE_CONTENT"", ""EXT_NAME"", ""CDATA_SECTION"", ""APOS_ATTRIBUTE_CONTENT"", ""END_TAG"", ""XML_COMMENT"", ""EXPR_COMMENT"", ""EXT_CONTENT"", ""EXT_KEY"", }
	;
	public static final int[] jjnewLexState = {
	 -1, 1, 1, 1, 1, -1, 3, -1, -1, 0, 0, 5, -1, -1, 1, 14, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 10, 1, -1, 0, -1, 1, 0, 0, 0, 0, -1, 8, 5, 0, 0, 5, 5, 0, 0, -1, 0, 0, 0, 4, 0, 4, 4, 9, 11, 7, 7, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, 6, 6, 1, 6, 6, -1, -1, 1, 12, 1, 1, -1, -1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, 0, -1, 0, -1, 1, -1, 10, 10, 10, 10, 9, 4, -1, -1, -1, 7, 7, -1, 7, 7, 7, 2, 7, -1, 7, 7, -1, 7, 2, 7, 7, 7, -1, -1, 0, 7, 0, 0, 17, 16, 1, 1, 0, 0, -1, -1, -1, -1, 10, 11, 1, 12, 24, -1, -1, -1, 19, 19, -1, -1, -1, -1, 16, 16, 13, -1, 21, -1, -1, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, 16, -1, -1, -1, 25, -1, -1, -1, -1, 23, -1, -1, 18, 18, 22, 22, -1, 1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, }
	;
	static final long[] jjtoToken = {
	 0xfff67fffffff8fffL, 0xffffffe7ffffffffL, 0xfbffffffffefffffL, 0x26f0007fffff7L, }
	;
	static final long[] jjtoSkip = {
	 0x5000L, 0x0L, 0x400000000000000L, 0x60080f9c0000000L, }
	;
	static final long[] jjtoSpecial = {
	 0x0L, 0x0L, 0x400000000000000L, 0x80f9c0000000L, }
	;
	protected SimpleCharStream input_stream;
	private final int[] jjrounds = new int[803];
	private final int[] jjstateSet = new int[1606];
	StringBuffer image;
	int jjimageLen;
	int lengthOfMatch;
	protected char curChar;
	public XPathTokenManager(SimpleCharStream stream){
		 if (SimpleCharStream.staticFlag) throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
		 input_stream = stream;
	}
	public XPathTokenManager(SimpleCharStream stream, int lexState){
		 this(stream);
		 SwitchTo(lexState);
	}
	public void ReInit(SimpleCharStream stream){
		 jjmatchedPos = jjnewStateCnt = 0;
		 curLexState = defaultLexState;
		 input_stream = stream;
		 ReInitRounds();
	}
	private final void ReInitRounds(){
		 int i;
		 jjround = 0x80000001;
		 for (i = 803;
		 i-- > 0;
		) jjrounds[i] = 0x80000000;
	}
	public void ReInit(SimpleCharStream stream, int lexState){
		 ReInit(stream);
		 SwitchTo(lexState);
	}
	public void SwitchTo(int lexState){
		 if (lexState >= 26 || lexState < 0) throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
		 else curLexState = lexState;
	}
	protected Token jjFillToken(){
		 Token t = Token.newToken(jjmatchedKind);
		 t.kind = jjmatchedKind;
		 String im = jjstrLiteralImages[jjmatchedKind];
		 t.image = (im == null) ? input_stream.GetImage() : im;
		 t.beginLine = input_stream.getBeginLine();
		 t.beginColumn = input_stream.getBeginColumn();
		 t.endLine = input_stream.getEndLine();
		 t.endColumn = input_stream.getEndColumn();
		 return t;
	}
	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;
	public Token getNextToken() {
		 int kind;
		 Token specialToken = null;
		 Token matchedToken;
		 int curPos = 0;
		 EOFLoop : for (;
		;
		) {
			 try {
				 curChar = input_stream.BeginToken();
			 }
			 catch(java.io.IOException e) {
				 jjmatchedKind = 0;
				 matchedToken = jjFillToken();
				 matchedToken.specialToken = specialToken;
				 return matchedToken;
			 }
			 image = null;
			 jjimageLen = 0;
			 switch(curLexState) {
				 case 0: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_0();
				 break;
				 case 1: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_1();
				 break;
				 case 2: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_2();
				 break;
				 case 3: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_3();
				 break;
				 case 4: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_4();
				 break;
				 case 5: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_5();
				 break;
				 case 6: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_6();
				 break;
				 case 7: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_7();
				 break;
				 case 8: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_8();
				 break;
				 case 9: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_9();
				 break;
				 case 10: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_10();
				 break;
				 case 11: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_11();
				 break;
				 case 12: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_12();
				 break;
				 case 13: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_13();
				 break;
				 case 14: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_14();
				 break;
				 case 15: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_15();
				 break;
				 case 16: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_16();
				 break;
				 case 17: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_17();
				 break;
				 case 18: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_18();
				 break;
				 case 19: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_19();
				 break;
				 case 20: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_20();
				 break;
				 case 21: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_21();
				 break;
				 case 22: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_22();
				 break;
				 case 23: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_23();
				 break;
				 case 24: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_24();
				 break;
				 case 25: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_25();
				 break;
			 }
			 if (jjmatchedKind != 0x7fffffff) {
				 if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
				 if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
					 matchedToken = jjFillToken();
					 matchedToken.specialToken = specialToken;
					 TokenLexicalActions(matchedToken);
					 if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind];
					 return matchedToken;
				 }
				 else {
					 if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						 matchedToken = jjFillToken();
						 if (specialToken == null) specialToken = matchedToken;
						 else {
							 matchedToken.specialToken = specialToken;
							 specialToken = (specialToken.next = matchedToken);
						 }
						 SkipLexicalActions(matchedToken);
					 }
					 else SkipLexicalActions(null);
					 if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind];
					 continue EOFLoop;
				 }
			 }
			 int error_line = input_stream.getEndLine();
			 int error_column = input_stream.getEndColumn();
			 String error_after = null;
			 boolean EOFSeen = false;
			 try {
				 input_stream.readChar();
				 input_stream.backup(1);
			 }
			 catch (java.io.IOException e1) {
				 EOFSeen = true;
				 error_after = curPos <= 1 ? """" : input_stream.GetImage();
				 if (curChar == '\n' || curChar == '\r') {
					 error_line++;
					 error_column = 0;
				 }
				 else error_column++;
			 }
			 if (!EOFSeen) {
				 input_stream.backup(1);
				 error_after = curPos <= 1 ? """" : input_stream.GetImage();
			 }
			 throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
		 }
	}
	void SkipLexicalActions(Token matchedToken){
		 switch(jjmatchedKind) {
			 case 14 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 input_stream.backup(1);
			 break;
			 case 222 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState();
			 break;
			 case 224 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 popState();
			 break;
			 case 227 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState();
			 break;
			 case 229 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 popState();
			 break;
			 default : break;
		 }
	}
	void TokenLexicalActions(Token matchedToken){
		 switch(jjmatchedKind) {
			 case 15 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[15]);
			 pushState(OPERATOR);
			 break;
			 case 16 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[16]);
			 pushState();
			 break;
			 case 17 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[17]);
			 popState();
			 break;
			 case 78 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 79 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 80 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 81 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 82 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 83 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 84 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 85 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 86 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 87 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 88 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 89 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 90 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 91 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 139 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[139]);
			 popState();
			 break;
			 case 146 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 147 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 149 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 150 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 151 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 152 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 153 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 154 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 155 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OPERATOR);
			 break;
			 case 156 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 157 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(KINDTEST);
			 break;
			 case 158 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 159 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 160 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(KINDTEST);
			 break;
			 case 161 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 162 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 163 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 164 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 165 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 pushState(OCCURRENCEINDICATOR);
			 break;
			 case 190 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[190]);
			 pushState(OPERATOR);
			 break;
			 case 191 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[191]);
			 pushState();
			 break;
			 case 192 : if (image == null) image = new StringBuffer();
			 image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			 popState();
			 break;
			 case 196 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[196]);
			 pushState();
			 break;
			 case 197 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[197]);
			 pushState(OPERATOR);
			 break;
			 case 199 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[199]);
			 popState();
			 break;
			 case 201 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[201]);
			 popState();
			 break;
			 case 204 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[204]);
			 pushState();
			 break;
			 case 205 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[205]);
			 pushState(OPERATOR);
			 break;
			 case 232 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[232]);
			 pushState(OPERATOR);
			 break;
			 case 233 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[233]);
			 pushState();
			 break;
			 case 234 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[234]);
			 popState();
			 break;
			 case 241 : if (image == null) image = new StringBuffer();
			 image.append(jjstrLiteralImages[241]);
			 popState();
			 break;
			 default : break;
		 }
	}
}",1,0,0,0
static boolean hasMethodBody(short accessFlag);,0,0,0,0
"public class RegExpImpl implements RegExpProxy {
	 public boolean isRegExp(Scriptable obj) {
		 return obj instanceof NativeRegExp;
	 }
	 public Object compileRegExp(Context cx, String source, String flags) {
		 return NativeRegExp.compileRE(source, flags, false);
	 }
	 public Scriptable wrapRegExp(Context cx, Scriptable scope, Object compiled) {
		 return new NativeRegExp(scope, compiled);
	 }
	 public Object action(Context cx, Scriptable scope, Scriptable thisObj, Object[] args, int actionType) {
		 GlobData data = new GlobData();
		 data.mode = actionType;
		 switch (actionType) {
			 case RA_MATCH: {
				 Object rval;
				 data.optarg = 1;
				 rval = matchOrReplace(cx, scope, thisObj, args, this, data, false);
				 return data.arrayobj == null ? rval : data.arrayobj;
			 }
			 case RA_SEARCH: data.optarg = 1;
			 return matchOrReplace(cx, scope, thisObj, args, this, data, false);
			 case RA_REPLACE: {
				 Object arg1 = args.length < 2 ? Undefined.instance : args[1];
				 String repstr = null;
				 Function lambda = null;
				 if (arg1 instanceof Function) {
					 lambda = (Function) arg1;
				 }
				 else {
					 repstr = ScriptRuntime.toString(arg1);
				 }
				 data.optarg = 2;
				 data.lambda = lambda;
				 data.repstr = repstr;
				 data.dollar = repstr == null ? -1 : repstr.indexOf('$');
				 data.charBuf = null;
				 data.leftIndex = 0;
				 Object val = matchOrReplace(cx, scope, thisObj, args, this, data, true);
				 SubString rc = this.rightContext;
				 if (data.charBuf == null) {
					 if (data.global || val == null || !val.equals(Boolean.TRUE)) {
						 return data.str;
					 }
					 SubString lc = this.leftContext;
					 replace_glob(data, cx, scope, this, lc.index, lc.length);
				 }
				 data.charBuf.append(rc.charArray, rc.index, rc.length);
				 return data.charBuf.toString();
			 }
			 default: throw Kit.codeBug();
		 }
	 }
	 private static Object matchOrReplace(Context cx, Scriptable scope, Scriptable thisObj, Object[] args, RegExpImpl reImpl, GlobData data, boolean forceFlat) {
		 NativeRegExp re;
		 String str = ScriptRuntime.toString(thisObj);
		 data.str = str;
		 Scriptable topScope = ScriptableObject.getTopLevelScope(scope);
		 if (args.length == 0) {
			 Object compiled = NativeRegExp.compileRE("""", """", false);
			 re = new NativeRegExp(topScope, compiled);
		 }
		 else if (args[0] instanceof NativeRegExp) {
			 re = (NativeRegExp) args[0];
		 }
		 else {
			 String src = ScriptRuntime.toString(args[0]);
			 String opt;
			 if (data.optarg < args.length) {
				 args[0] = src;
				 opt = ScriptRuntime.toString(args[data.optarg]);
			 }
			 else {
				 opt = null;
			 }
			 Object compiled = NativeRegExp.compileRE(src, opt, forceFlat);
			 re = new NativeRegExp(topScope, compiled);
		 }
		 data.regexp = re;
		 data.global = (re.getFlags() & NativeRegExp.JSREG_GLOB) != 0;
		 int[] indexp = {
		 0 }
		;
		 Object result = null;
		 if (data.mode == RA_SEARCH) {
			 result = re.executeRegExp(cx, scope, reImpl, str, indexp, NativeRegExp.TEST);
			 if (result != null && result.equals(Boolean.TRUE)) result = new Integer(reImpl.leftContext.length);
			 else result = new Integer(-1);
		 }
		 else if (data.global) {
			 re.lastIndex = 0;
			 for (int count = 0;
			 indexp[0] <= str.length();
			 count++) {
				 result = re.executeRegExp(cx, scope, reImpl, str, indexp, NativeRegExp.TEST);
				 if (result == null || !result.equals(Boolean.TRUE)) break;
				 if (data.mode == RA_MATCH) {
					 match_glob(data, cx, scope, count, reImpl);
				 }
				 else {
					 if (data.mode != RA_REPLACE) Kit.codeBug();
					 SubString lastMatch = reImpl.lastMatch;
					 int leftIndex = data.leftIndex;
					 int leftlen = lastMatch.index - leftIndex;
					 data.leftIndex = lastMatch.index + lastMatch.length;
					 replace_glob(data, cx, scope, reImpl, leftIndex, leftlen);
				 }
				 if (reImpl.lastMatch.length == 0) {
					 if (indexp[0] == str.length()) break;
					 indexp[0]++;
				 }
			 }
		 }
		 else {
			 result = re.executeRegExp(cx, scope, reImpl, str, indexp, ((data.mode == RA_REPLACE) ? NativeRegExp.TEST : NativeRegExp.MATCH));
		 }
		 return result;
	 }
	 public int find_split(Context cx, Scriptable scope, String target, String separator, Scriptable reObj, int[] ip, int[] matchlen, boolean[] matched, String[][] parensp) {
		 int i = ip[0];
		 int length = target.length();
		 int result;
		 int version = cx.getLanguageVersion();
		 NativeRegExp re = (NativeRegExp) reObj;
		 again: while (true) {
			 int ipsave = ip[0];
			 ip[0] = i;
			 Object ret = re.executeRegExp(cx, scope, this, target, ip, NativeRegExp.TEST);
			 if (ret != Boolean.TRUE) {
				 ip[0] = ipsave;
				 matchlen[0] = 1;
				 matched[0] = false;
				 return length;
			 }
			 i = ip[0];
			 ip[0] = ipsave;
			 matched[0] = true;
			 SubString sep = this.lastMatch;
			 matchlen[0] = sep.length;
			 if (matchlen[0] == 0) {
				 if (i == ip[0]) {
					 if (i == length) {
						 if (version == Context.VERSION_1_2) {
							 matchlen[0] = 1;
							 result = i;
						 }
						 else result = -1;
						 break;
					 }
					 i++;
					 continue again;
				 }
			 }
			 result = i - matchlen[0];
			 break;
		 }
		 int size = (parens == null) ? 0 : parens.length;
		 parensp[0] = new String[size];
		 for (int num = 0;
		 num < size;
		 num++) {
			 SubString parsub = getParenSubString(num);
			 parensp[0][num] = parsub.toString();
		 }
		 return result;
	 }
	 SubString getParenSubString(int i) {
		 if (parens != null && i < parens.length) {
			 SubString parsub = parens[i];
			 if (parsub != null) {
				 return parsub;
			 }
		 }
		 return SubString.emptySubString;
	 }
	 private static void match_glob(GlobData mdata, Context cx, Scriptable scope, int count, RegExpImpl reImpl) {
		 if (mdata.arrayobj == null) {
			 Scriptable s = ScriptableObject.getTopLevelScope(scope);
			 mdata.arrayobj = ScriptRuntime.newObject(cx, s, ""Array"", null);
		 }
		 SubString matchsub = reImpl.lastMatch;
		 String matchstr = matchsub.toString();
		 mdata.arrayobj.put(count, mdata.arrayobj, matchstr);
	 }
	 private static void replace_glob(GlobData rdata, Context cx, Scriptable scope, RegExpImpl reImpl, int leftIndex, int leftlen) {
		 int replen;
		 String lambdaStr;
		 if (rdata.lambda != null) {
			 SubString[] parens = reImpl.parens;
			 int parenCount = (parens == null) ? 0 : parens.length;
			 Object[] args = new Object[parenCount + 3];
			 args[0] = reImpl.lastMatch.toString();
			 for (int i=0;
			 i < parenCount;
			 i++) {
				 SubString sub = parens[i];
				 if (sub != null) {
					 args[i+1] = sub.toString();
				 }
				 else {
					 args[i+1] = Undefined.instance;
				 }
			 }
			 args[parenCount+1] = new Integer(reImpl.leftContext.length);
			 args[parenCount+2] = rdata.str;
			 Scriptable parent = ScriptableObject.getTopLevelScope(scope);
			 Object result = rdata.lambda.call(cx, parent, parent, args);
			 lambdaStr = ScriptRuntime.toString(result);
			 replen = lambdaStr.length();
		 }
		 else {
			 lambdaStr = null;
			 replen = rdata.repstr.length();
			 if (rdata.dollar >= 0) {
				 int[] skip = new int[1];
				 int dp = rdata.dollar;
				 do {
					 SubString sub = interpretDollar(cx, reImpl, rdata.repstr, dp, skip);
					 if (sub != null) {
						 replen += sub.length - skip[0];
						 dp += skip[0];
					 }
					 else {
						 ++dp;
					 }
					 dp = rdata.repstr.indexOf('$', dp);
				 }
				 while (dp >= 0);
			 }
		 }
		 int growth = leftlen + replen + reImpl.rightContext.length;
		 StringBuffer charBuf = rdata.charBuf;
		 if (charBuf == null) {
			 charBuf = new StringBuffer(growth);
			 rdata.charBuf = charBuf;
		 }
		 else {
			 charBuf.ensureCapacity(rdata.charBuf.length() + growth);
		 }
		 charBuf.append(reImpl.leftContext.charArray, leftIndex, leftlen);
		 if (rdata.lambda != null) {
			 charBuf.append(lambdaStr);
		 }
		 else {
			 do_replace(rdata, cx, reImpl);
		 }
	 }
	 private static SubString interpretDollar(Context cx, RegExpImpl res, String da, int dp, int[] skip) {
		 char dc;
		 int num, tmp;
		 if (da.charAt(dp) != '$') Kit.codeBug();
		 int version = cx.getLanguageVersion();
		 if (version != Context.VERSION_DEFAULT && version <= Context.VERSION_1_4) {
			 if (dp > 0 && da.charAt(dp - 1) == '\\') return null;
		 }
		 int daL = da.length();
		 if (dp + 1 >= daL) return null;
		 dc = da.charAt(dp + 1);
		 if (NativeRegExp.isDigit(dc)) {
			 int cp;
			 if (version != Context.VERSION_DEFAULT && version <= Context.VERSION_1_4) {
				 if (dc == '0') return null;
				 num = 0;
				 cp = dp;
				 while (++cp < daL && NativeRegExp.isDigit(dc = da.charAt(cp))) {
					 tmp = 10 * num + (dc - '0');
					 if (tmp < num) break;
					 num = tmp;
				 }
			 }
			 else {
				 int parenCount = (res.parens == null) ? 0 : res.parens.length;
				 num = dc - '0';
				 if (num > parenCount) return null;
				 cp = dp + 2;
				 if ((dp + 2) < daL) {
					 dc = da.charAt(dp + 2);
					 if (NativeRegExp.isDigit(dc)) {
						 tmp = 10 * num + (dc - '0');
						 if (tmp <= parenCount) {
							 cp++;
							 num = tmp;
						 }
					 }
				 }
				 if (num == 0) return null;
			 }
			 num--;
			 skip[0] = cp - dp;
			 return res.getParenSubString(num);
		 }
		 skip[0] = 2;
		 switch (dc) {
			 case '$': return new SubString(""$"");
			 case '&': return res.lastMatch;
			 case '+': return res.lastParen;
			 case '`': if (version == Context.VERSION_1_2) {
				 res.leftContext.index = 0;
				 res.leftContext.length = res.lastMatch.index;
			 }
			 return res.leftContext;
			 case '\'': return res.rightContext;
		 }
		 return null;
	 }
	 private static void do_replace(GlobData rdata, Context cx, RegExpImpl regExpImpl) {
		 StringBuffer charBuf = rdata.charBuf;
		 int cp = 0;
		 String da = rdata.repstr;
		 int dp = rdata.dollar;
		 if (dp != -1) {
			 int[] skip = new int[1];
			 do {
				 int len = dp - cp;
				 charBuf.append(da.substring(cp, dp));
				 cp = dp;
				 SubString sub = interpretDollar(cx, regExpImpl, da, dp, skip);
				 if (sub != null) {
					 len = sub.length;
					 if (len > 0) {
						 charBuf.append(sub.charArray, sub.index, len);
					 }
					 cp += skip[0];
					 dp += skip[0];
				 }
				 else {
					 ++dp;
				 }
				 dp = da.indexOf('$', dp);
			 }
			 while (dp >= 0);
		 }
		 int daL = da.length();
		 if (daL > cp) {
			 charBuf.append(da.substring(cp, daL));
		 }
	 }
	 String input;
	 boolean multiline;
	 SubString[] parens;
	 SubString lastMatch;
	 SubString lastParen;
	 SubString leftContext;
	 SubString rightContext;
 }
final class GlobData{
	 int mode;
	 int optarg;
	 boolean global;
	 String str;
	 NativeRegExp regexp;
	 Scriptable arrayobj;
	 Function lambda;
	 String repstr;
	 int dollar = -1;
	 StringBuffer charBuf;
	 int leftIndex;
 }",0,0,0,0
"public class OntResourceImpl extends ResourceImpl implements OntResource{
	 public static final String[] KNOWN_LANGUAGES = new String[] {
	OWL.NS, RDF.getURI(), RDFS.getURI(), XSDDatatype.XSD}
	;
	 public static Implementation factory = new Implementation() {
		 public EnhNode wrap( Node n, EnhGraph eg ) {
			 if (canWrap( n, eg )) {
				 return new OntResourceImpl( n, eg );
			 }
			 else {
				 throw new ConversionException( ""Cannot convert node "" + n.toString() + "" to OntResource"");
			 }
		 }
		 public boolean canWrap( Node node, EnhGraph eg ) {
			 return node.isURI() || node.isBlank();
		 }
	 }
	;
	 private static final Logger log = LoggerFactory.getLogger( OntResourceImpl.class );
	 public OntResourceImpl( Node n, EnhGraph g ) {
		 super( n, g );
	 }
	 public OntModel getOntModel() {
		 Model m = getModel();
		 return (m instanceof OntModel) ? (OntModel) m : null;
	 }
	 public Profile getProfile() {
		 try {
			 return ((OntModel) getModel()).getProfile();
		 }
		 catch (ClassCastException e) {
			 throw new JenaException( ""Resource "" + toString() + "" is not attached to an OntModel, so cannot access its language profile"" );
		 }
	 }
	 public boolean isOntLanguageTerm() {
		 if ( isURIResource() ) {
			 for ( String KNOWN_LANGUAGE : KNOWN_LANGUAGES ) {
				 if ( getURI().startsWith( KNOWN_LANGUAGE ) ) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 public void setSameAs( Resource res ) {
		 setPropertyValue( getProfile().SAME_AS(), ""SAME_AS"", res );
	 }
	 public void addSameAs( Resource res ) {
		 addPropertyValue( getProfile().SAME_AS(), ""SAME_AS"", res );
	 }
	 public OntResource getSameAs() {
		 return objectAsResource( getProfile().SAME_AS(), ""SAME_AS"" );
	 }
	 public ExtendedIterator<OntResource> listSameAs() {
		 return listAs( getProfile().SAME_AS(), ""SAME_AS"", OntResource.class );
	 }
	 public boolean isSameAs( Resource res ) {
		 return hasPropertyValue( getProfile().SAME_AS(), ""SAME_AS"", res );
	 }
	 public void removeSameAs( Resource res ) {
		 removePropertyValue( getProfile().SAME_AS(), ""SAME_AS"", res );
	 }
	 public void setDifferentFrom( Resource res ) {
		 setPropertyValue( getProfile().DIFFERENT_FROM(), ""DIFFERENT_FROM"", res );
	 }
	 public void addDifferentFrom( Resource res ) {
		 addPropertyValue( getProfile().DIFFERENT_FROM(), ""DIFFERENT_FROM"", res );
	 }
	 public OntResource getDifferentFrom() {
		 return objectAsResource( getProfile().DIFFERENT_FROM(), ""DIFFERENT_FROM"" );
	 }
	 public ExtendedIterator<OntResource> listDifferentFrom() {
		 return listAs( getProfile().DIFFERENT_FROM(), ""DIFFERENT_FROM"", OntResource.class );
	 }
	 public boolean isDifferentFrom( Resource res ) {
		 return hasPropertyValue( getProfile().DIFFERENT_FROM(), ""DIFFERENT_FROM"", res );
	 }
	 public void removeDifferentFrom( Resource res ) {
		 removePropertyValue( getProfile().DIFFERENT_FROM(), ""DIFFERENT_FROM"", res );
	 }
	 public void setSeeAlso( Resource res ) {
		 setPropertyValue( getProfile().SEE_ALSO(), ""SEE_ALSO"", res );
	 }
	 public void addSeeAlso( Resource res ) {
		 addPropertyValue( getProfile().SEE_ALSO(), ""SEE_ALSO"", res );
	 }
	 public Resource getSeeAlso() {
		 return objectAsResource( getProfile().SEE_ALSO(), ""SEE_ALSO"" );
	 }
	 public ExtendedIterator<RDFNode> listSeeAlso() {
		 checkProfile( getProfile().SEE_ALSO(), ""SEE_ALSO"" );
		 return WrappedIterator.create( listProperties( getProfile().SEE_ALSO() ) ) .mapWith( s -> asOntResource( s.getObject() ) );
	 }
	 public boolean hasSeeAlso( Resource res ) {
		 return hasPropertyValue( getProfile().SEE_ALSO(), ""SEE_ALSO"", res );
	 }
	 public void removeSeeAlso( Resource res ) {
		 removePropertyValue( getProfile().SEE_ALSO(), ""SEE_ALSO"", res );
	 }
	 public void setIsDefinedBy( Resource res ) {
		 setPropertyValue( getProfile().IS_DEFINED_BY(), ""IS_DEFINED_BY"", res );
	 }
	 public void addIsDefinedBy( Resource res ) {
		 addPropertyValue( getProfile().IS_DEFINED_BY(), ""IS_DEFINED_BY"", res );
	 }
	 public Resource getIsDefinedBy() {
		 return objectAsResource( getProfile().IS_DEFINED_BY(), ""IS_DEFINED_BY"" );
	 }
	 public ExtendedIterator<RDFNode> listIsDefinedBy() {
		 checkProfile( getProfile().IS_DEFINED_BY(), ""IS_DEFINED_BY"" );
		 return WrappedIterator.create( listProperties( getProfile().IS_DEFINED_BY() ) ) .mapWith( s -> asOntResource( s.getObject() ) );
	 }
	 public boolean isDefinedBy( Resource res ) {
		 return hasPropertyValue( getProfile().IS_DEFINED_BY(), ""IS_DEFINED_BY"", res );
	 }
	 public void removeDefinedBy( Resource res ) {
		 removePropertyValue( getProfile().IS_DEFINED_BY(), ""IS_DEFINED_BY"", res );
	 }
	 public void setVersionInfo( String info ) {
		 checkProfile( getProfile().VERSION_INFO(), ""VERSION_INFO"" );
		 removeAll( getProfile().VERSION_INFO() );
		 addVersionInfo( info );
	 }
	 public void addVersionInfo( String info ) {
		 checkProfile( getProfile().VERSION_INFO(), ""VERSION_INFO"" );
		 addProperty( getProfile().VERSION_INFO(), getModel().createLiteral( info ) );
	 }
	 public String getVersionInfo() {
		 checkProfile( getProfile().VERSION_INFO(), ""VERSION_INFO"" );
		 try {
			 return getRequiredProperty( getProfile().VERSION_INFO() ).getString();
		 }
		 catch (PropertyNotFoundException ignore) {
			 return null;
		 }
	 }
	 public ExtendedIterator<String> listVersionInfo() {
		 checkProfile( getProfile().VERSION_INFO(), ""VERSION_INFO"" );
		 return WrappedIterator.create( listProperties( getProfile().VERSION_INFO() ) ) .mapWith( s -> s.getString() );
	 }
	 public boolean hasVersionInfo( String info ) {
		 checkProfile( getProfile().VERSION_INFO(), ""VERSION_INFO"" );
		 return hasProperty( getProfile().VERSION_INFO(), info );
	 }
	 public void removeVersionInfo( String info ) {
		 checkProfile( getProfile().VERSION_INFO(), ""VERSION_INFO"" );
		 Literal infoAsLiteral = ResourceFactory.createPlainLiteral( info );
		 getModel().remove( this, getProfile().VERSION_INFO(), infoAsLiteral );
	 }
	 public void setLabel( String label, String lang ) {
		 checkProfile( getProfile().LABEL(), ""LABEL"" );
		 removeAll( getProfile().LABEL() );
		 addLabel( label, lang );
	 }
	 public void addLabel( String label, String lang ) {
		 addLabel( getModel().createLiteral( label, lang ) );
	 }
	 public void addLabel( Literal label ) {
		 addPropertyValue( getProfile().LABEL(), ""LABEL"", label );
	 }
	 public String getLabel( String lang ) {
		 checkProfile( getProfile().LABEL(), ""LABEL"" );
		 if (lang == null || lang.length() == 0) {
			 try {
				 return getRequiredProperty( getProfile().LABEL() ).getString();
			 }
			 catch (PropertyNotFoundException ignore) {
				 return null;
			 }
		 }
		 else {
			 return selectLang( listProperties( getProfile().LABEL() ), lang );
		 }
	 }
	 public ExtendedIterator<RDFNode> listLabels( String lang ) {
		 checkProfile( getProfile().LABEL(), ""LABEL"" );
		 return WrappedIterator.create( listProperties( getProfile().LABEL() ) ) .filterKeep( new LangTagFilter( lang ) ) .mapWith( s -> s.getObject() );
	 }
	 public boolean hasLabel( String label, String lang ) {
		 return hasLabel( getModel().createLiteral( label, lang ) );
	 }
	 public boolean hasLabel( Literal label ) {
		 boolean found = false;
		 ExtendedIterator<RDFNode> i = listLabels( label.getLanguage() );
		 while (!found && i.hasNext()) {
			 found = label.equals( i.next() );
		 }
		 i.close();
		 return found;
	 }
	 public void removeLabel( String label, String lang ) {
		 removeLabel( getModel().createLiteral( label, lang ) );
	 }
	 public void removeLabel( Literal label ) {
		 removePropertyValue( getProfile().LABEL(), ""LABEL"", label );
	 }
	 public void setComment( String comment, String lang ) {
		 checkProfile( getProfile().COMMENT(), ""COMMENT"" );
		 removeAll( getProfile().COMMENT() );
		 addComment( comment, lang );
	 }
	 public void addComment( String comment, String lang ) {
		 addComment( getModel().createLiteral( comment, lang ) );
	 }
	 public void addComment( Literal comment ) {
		 checkProfile( getProfile().COMMENT(), ""COMMENT"" );
		 addProperty( getProfile().COMMENT(), comment );
	 }
	 public String getComment( String lang ) {
		 checkProfile( getProfile().COMMENT(), ""COMMENT"" );
		 if (lang == null) {
			 try {
				 return getRequiredProperty( getProfile().COMMENT() ).getString();
			 }
			 catch (PropertyNotFoundException ignore) {
				 return null;
			 }
		 }
		 else {
			 return selectLang( listProperties( getProfile().COMMENT() ), lang );
		 }
	 }
	 public ExtendedIterator<RDFNode> listComments( String lang ) {
		 checkProfile( getProfile().COMMENT(), ""COMMENT"" );
		 return WrappedIterator.create( listProperties( getProfile().COMMENT() ) ) .filterKeep( new LangTagFilter( lang ) ) .mapWith( s -> s.getObject() );
	 }
	 public boolean hasComment( String comment, String lang ) {
		 return hasComment( getModel().createLiteral( comment, lang ) );
	 }
	 public boolean hasComment( Literal comment ) {
		 boolean found = false;
		 ExtendedIterator<RDFNode> i = listComments( comment.getLanguage() );
		 while (!found && i.hasNext()) {
			 found = comment.equals( i.next() );
		 }
		 i.close();
		 return found;
	 }
	 public void removeComment( String comment, String lang ) {
		 removeComment( getModel().createLiteral( comment, lang ) );
	 }
	 public void removeComment( Literal comment ) {
		 removePropertyValue( getProfile().COMMENT(), ""COMMENT"", comment );
	 }
	 public void setRDFType( Resource cls ) {
		 setPropertyValue( RDF.type, ""rdf:type"", cls );
	 }
	 public void addRDFType( Resource cls ) {
		 addPropertyValue( RDF.type, ""rdf:type"", cls );
	 }
	 public Resource getRDFType() {
		 return getRDFType( false );
	 }
	 public Resource getRDFType( boolean direct ) {
		 ExtendedIterator<Resource> i = null;
		 try {
			 i = listRDFTypes( direct );
			 return i.hasNext() ? i.next(): null;
		 }
		 finally {
			 if ( i != null ) i.close();
		 }
	 }
	 public ExtendedIterator<Resource> listRDFTypes( boolean direct ) {
		 ExtendedIterator<Resource> i = listDirectPropertyValues( RDF.type, ""rdf:type"", Resource.class, getProfile().SUB_CLASS_OF(), direct, false );
		 return i.filterKeep( new UniqueFilter<Resource>());
	 }
	 public boolean hasRDFType( String uri ) {
		 return hasRDFType( getModel().getResource( uri ) );
	 }
	 public boolean hasRDFType( Resource ontClass ) {
		 return hasRDFType( ontClass, ""unknown"", false );
	 }
	 public boolean hasRDFType( Resource ontClass, boolean direct ) {
		 return hasRDFType( ontClass, ""unknown"", direct );
	 }
	 protected boolean hasRDFType( Resource ontClass, String name, boolean direct ) {
		 checkProfile( ontClass, name );
		 if (!direct) {
			 return hasPropertyValue( RDF.type, ""rdf:type"", ontClass );
		 }
		 else {
			 ExtendedIterator<Resource> i = null;
			 try {
				 i = listRDFTypes( true );
				 while (i.hasNext()) {
					 if (ontClass.equals( i.next() )) {
						 return true;
					 }
				 }
				 return false;
			 }
			 finally {
				 if ( i != null ) i.close();
			 }
		 }
	 }
	 public void removeRDFType( Resource cls ) {
		 removePropertyValue( RDF.type, ""rdf:type"", cls );
	 }
	 public int getCardinality( Property p ) {
		 int n = 0;
		 for (Iterator<RDFNode> i =listPropertyValues( p ).filterKeep( new UniqueFilter<RDFNode>());
		 i.hasNext();
		 n++) {
			 i.next();
		 }
		 return n;
	 }
	 public void setPropertyValue( Property property, RDFNode value ) {
		 removeAll( property );
		 if (value != null) {
			 addProperty( property, value );
		 }
	 }
	 public RDFNode getPropertyValue( Property property ) {
		 Statement s = getProperty( property );
		 if (s == null) {
			 return null;
		 }
		 else {
			 return asOntResource( s.getObject() );
		 }
	 }
	 public NodeIterator listPropertyValues( Property property ) {
		 return new NodeIteratorImpl( listProperties( property ).mapWith( s -> asOntResource( s.getObject() ) ), null );
	 }
	 public void remove() {
		 Set<Statement> stmts = new HashSet<>();
		 List<Resource> lists = new ArrayList<>();
		 List<Statement> skip = new ArrayList<>();
		 Property first = getProfile().FIRST();
		 for (StmtIterator i = listProperties();
		 i.hasNext();
		 ) {
			 stmts.add( i.next() );
		 }
		 for (StmtIterator i = getModel().listStatements( null, null, this );
		 i.hasNext();
		 ) {
			 stmts.add( i.next() );
		 }
		 for ( Statement s : stmts ) {
			 if ( s.getPredicate().equals( first ) && s.getObject().equals( this ) ) {
				 log.debug( toString() + "" is referened from an RDFList, so will not be fully removed"" );
				 skip.add( s );
			 }
			 else if ( s.getObject() instanceof Resource ) {
				 Resource obj = s.getResource();
				 if ( obj.canAs( RDFList.class ) ) {
					 lists.add( obj );
				 }
			 }
		 }
		 for ( Resource r : lists ) {
			 stmts.addAll( ( (RDFListImpl) r.as( RDFList.class ) ).collectStatements() );
		 }
		 stmts.removeAll( skip );
		 for ( Statement stmt : stmts ) {
			 stmt.remove();
		 }
	 }
	 public void removeProperty( Property property, RDFNode value ) {
		 getModel().remove( this, property, value );
	 }
	 public AnnotationProperty asAnnotationProperty() {
		 return as( AnnotationProperty.class );
	 }
	 public OntProperty asProperty() {
		 return as( OntProperty.class );
	 }
	 public ObjectProperty asObjectProperty() {
		 return as( ObjectProperty.class );
	 }
	 public DatatypeProperty asDatatypeProperty() {
		 return as( DatatypeProperty.class );
	 }
	 public Individual asIndividual() {
		 return as( Individual.class );
	 }
	 public OntClass asClass() {
		 return as( OntClass.class );
	 }
	 public Ontology asOntology() {
		 return as( Ontology.class );
	 }
	 public AllDifferent asAllDifferent() {
		 return as( AllDifferent.class );
	 }
	 public DataRange asDataRange() {
		 return as( DataRange.class );
	 }
	 public boolean isAnnotationProperty() {
		 return getProfile().ANNOTATION_PROPERTY() != null && canAs( AnnotationProperty.class );
	 }
	 public boolean isProperty() {
		 return canAs( OntProperty.class );
	 }
	 public boolean isObjectProperty() {
		 return getProfile().OBJECT_PROPERTY() != null && canAs( ObjectProperty.class );
	 }
	 public boolean isDatatypeProperty() {
		 return getProfile().DATATYPE_PROPERTY() != null && canAs( DatatypeProperty.class );
	 }
	 public boolean isIndividual() {
		 OntModel m = (getModel() instanceof OntModel) ? (OntModel) getModel() : null;
		 if ( m == null ) return false ;
		 boolean useInf = false;
		 useInf = m.getProfile().THING() != null && m.getReasoner() != null && m.getReasoner().supportsProperty( ReasonerVocabulary.individualAsThingP );
		 StmtIterator i = null, j = null;
		 try {
			 if (!useInf) {
				 for (i = listProperties( RDF.type );
				 i.hasNext();
				 ) {
					 Resource rType = i.nextStatement().getResource();
					 if (rType.equals( m.getProfile().THING() )) {
						 return true;
					 }
					 if (rType.equals( getProfile().CLASS() ) || rType.equals( RDFS.Resource ) || rType.equals( RDF.Property ) || rType.equals( RDFS.Datatype ) || rType.equals( RDF.List )) {
						 continue;
					 }
					 for (j = rType.listProperties( RDF.type );
					 j.hasNext();
					 ) {
						 if (j.nextStatement().getResource().equals( getProfile().CLASS() )) {
							 return true;
						 }
					 }
				 }
				 return false;
			 }
			 else {
				 return hasProperty( RDF.type, getProfile().THING() );
			 }
		 }
		 finally {
			 if (i != null) {
				 i.close();
			 }
			 if (j != null) {
				 j.close();
			 }
		 }
	 }
	 public boolean isClass() {
		 return canAs( OntClass.class );
	 }
	 public boolean isOntology() {
		 return getProfile().ONTOLOGY() != null && canAs( Ontology.class );
	 }
	 public boolean isDataRange() {
		 return getProfile().DATARANGE() != null && canAs( DataRange.class );
	 }
	 public boolean isAllDifferent() {
		 return getProfile().ALL_DIFFERENT() != null && canAs( AllDifferent.class );
	 }
	 protected static boolean hasType( Node n, EnhGraph g, Resource type ) {
		 boolean hasType = false;
		 ClosableIterator<Triple> i = g.asGraph().find( n, RDF.type.asNode(), type.asNode() );
		 hasType = i.hasNext();
		 i.close();
		 return hasType;
	 }
	 protected void checkProfile( Object term, String name ) {
		 if (term == null) {
			 throw new ProfileException( name, getProfile() );
		 }
	 }
	 protected String selectLang( StmtIterator stmts, String lang ) {
		 String found = null;
		 while (stmts.hasNext()) {
			 RDFNode n = stmts.nextStatement().getObject();
			 if (n instanceof Literal) {
				 Literal l = (Literal) n;
				 String lLang = l.getLanguage();
				 if (lang.equalsIgnoreCase( lLang )) {
					 found = l.getString();
					 break;
				 }
				 else if (lLang != null && lLang.length() > 1 && lang.equalsIgnoreCase( lLang.substring( 0, 2 ) )) {
					 found = l.getString();
				 }
				 else if (found == null && lLang == null) {
					 found = l.getString();
				 }
			 }
		 }
		 stmts.close();
		 return found;
	 }
	 protected boolean langTagMatch( String desired, String target ) {
		 return (desired == null) || (desired.equalsIgnoreCase( target )) || (target.length() > desired.length() && desired.equalsIgnoreCase( target.substring( desired.length() ) ));
	 }
	 protected <T extends RDFNode> T objectAs( Property p, String name, Class<T> asClass ) {
		 checkProfile( p, name );
		 try {
			 return getRequiredProperty( p ).getObject().as( asClass );
		 }
		 catch (PropertyNotFoundException e) {
			 return null;
		 }
	 }
	 protected OntResource objectAsResource( Property p, String name ) {
		 return objectAs( p, name, OntResource.class );
	 }
	 protected OntProperty objectAsProperty( Property p, String name ) {
		 return objectAs( p, name, OntProperty.class );
	 }
	 protected int objectAsInt( Property p, String name ) {
		 checkProfile( p, name );
		 return getRequiredProperty( p ).getInt();
	 }
	 protected <T extends RDFNode> ExtendedIterator<T> listAs( Property p, String name, Class<T> cls ) {
		 checkProfile( p, name );
		 return WrappedIterator.create( listProperties( p ) ).mapWith( s -> s.getObject().as( cls ) );
	 }
	 protected void addPropertyValue( Property p, String name, RDFNode value ) {
		 checkProfile( p, name );
		 addProperty( p, value );
	 }
	 protected void setPropertyValue( Property p, String name, RDFNode value ) {
		 checkProfile( p, name );
		 removeAll( p );
		 addProperty( p, value );
	 }
	 protected boolean hasPropertyValue( Property p, String name, RDFNode value ) {
		 checkProfile( p, name );
		 return hasProperty( p, value );
	 }
	 protected void addListPropertyValue( Property p, String name, RDFNode value ) {
		 checkProfile( p, name );
		 if (hasProperty( p )) {
			 RDFNode cur = getRequiredProperty( p ).getObject();
			 if (!cur.canAs( RDFList.class )) {
				 throw new OntologyException( ""Tried to add a value to a list-valued property "" + p + "" but the current value is not a list: "" + cur );
			 }
			 RDFList values = cur.as( RDFList.class );
			 if (!values.contains( value )){
				 RDFList newValues = values.with( value );
				 if (newValues != values) {
					 removeAll( p );
					 addProperty( p, newValues );
				 }
			 }
		 }
		 else {
			 addProperty( p, ((OntModel) getModel()).createList( new RDFNode[] {
			value}
			 ) );
		 }
	 }
	 protected <T extends RDFNode> T convertToType( Resource type, String name, Class<T> cls ) {
		 checkProfile( type, name );
		 if (canAs( cls )) {
			 return as( cls );
		 }
		 addProperty( RDF.type, type );
		 return as( cls );
	 }
	 protected <T extends Resource> ExtendedIterator<T> listDirectPropertyValues( Property p, String name, Class<T> cls, Property orderRel, boolean direct, boolean inverse ) {
		 Iterator<T> i = null;
		 checkProfile( p, name );
		 Property sc = p;
		 if (direct) {
			 sc = getModel().getProperty( ReasonerRegistry.makeDirect( sc.asNode() ).getURI() );
		 }
		 Resource subject = inverse ? null : this;
		 Resource object = inverse ? this : null;
		 Function<Statement, T> mapper = inverse ? s -> s.getSubject().as( cls ) : s -> s.getObject().as( cls );
		 OntModel m = (OntModel) getGraph();
		 InfGraph ig = null;
		 if (m.getGraph() instanceof InfGraph) {
			 ig = (InfGraph) m.getGraph();
		 }
		 if (!direct || ((ig != null) && ig.getReasoner().supportsProperty( sc ))) {
			 i = getModel().listStatements( subject, sc, object ).mapWith( mapper );
		 }
		 else {
			 i = computeDirectValues( p, orderRel, inverse, subject, object, mapper );
		 }
		 return WrappedIterator.create(i).filterKeep( new UniqueFilter<T>());
	 }
	 private <T extends Resource> Iterator<T> computeDirectValues( Property p, Property orderRel, boolean inverse, Resource subject, Resource object, Function<Statement, T> mapper ) {
		 ExtendedIterator<T> j = getModel().listStatements( subject, p, object ) .mapWith( mapper );
		 List<T> s = new ArrayList<>();
		 for( ;
		 j.hasNext();
		 ) {
			 s.add( j.next() );
		 }
		 ResourceUtils.removeEquiv( s, orderRel, this );
		 boolean withheld = s.remove( this );
		 List<List<T>> partition = ResourceUtils.partition( s, orderRel );
		 Map<Resource, List<T>> equivSets = new HashMap<>();
		 s.clear();
		 for ( List<T> part : partition ) {
			 if ( part.size() == 1 ) {
				 s.add( part.get( 0 ) );
			 }
			 else {
				 T r = part.remove( 0 );
				 equivSets.put( r, part );
				 s.add( r );
			 }
		 }
		 s = ResourceUtils.maximalLowerElements( s, orderRel, inverse );
		 List<T> s2 = new ArrayList<>();
		 for ( T r : s ) {
			 s2.add( r );
			 if ( equivSets.containsKey( r ) ) {
				 s2.addAll( equivSets.get( r ) );
			 }
		 }
		 if (withheld) {
			 s2.add( (T) this );
		 }
		 return s2.iterator();
	 }
	 protected void removePropertyValue( Property prop, String name, RDFNode value ) {
		 checkProfile( prop, name );
		 getModel().remove( this, prop, value );
	 }
	 private static RDFNode asOntResource( RDFNode n ) {
		 return n.isResource() ? n.as( OntResource.class ) : n;
	 }
	 protected class LangTagFilter implements Predicate<Statement> {
		 protected String m_lang;
		 public LangTagFilter( String lang ) {
			 m_lang = lang;
		 }
		 public boolean test( Statement x ) {
			 RDFNode o = x.getObject();
			 return o.isLiteral() && langTagMatch( m_lang, o.asLiteral().getLanguage() );
		 }
	 }
}",1,0,0,0
"public final class LegendFont extends Font {
	 public static final Color FOREGROUND_COLOR = new Color(100, 100, 100);
	 public static final Color BACKGROUND_COLOR = new Color(255, 255, 255);
	 private static final Font baseFont = baseFont();
	 public LegendFont() {
		 super(baseFont);
	 }
	 private static Font baseFont() {
		 Font font = new JLabel().getFont();
		 return new Font(font.getName(), font.getStyle(), font.getSize() - 2);
	 }
}",0,0,0,0
"public class SQLDropTableStatement extends SQLStatementImpl implements SQLDropStatement {
	 private List<SQLCommentHint> hints;
	 protected List<SQLExprTableSource> tableSources = new ArrayList<SQLExprTableSource>();
	 private boolean purge;
	 protected boolean cascade = false;
	 protected boolean restrict = false;
	 protected boolean ifExists = false;
	 private boolean temporary = false;
	 public SQLDropTableStatement(){
	 }
	 public SQLDropTableStatement(String dbType){
		 super (dbType);
	 }
	 public SQLDropTableStatement(SQLName name, String dbType){
		 this(new SQLExprTableSource(name), dbType);
	 }
	 public SQLDropTableStatement(SQLName name){
		 this (name, null);
	 }
	 public SQLDropTableStatement(SQLExprTableSource tableSource){
		 this (tableSource, null);
	 }
	 public SQLDropTableStatement(SQLExprTableSource tableSource, String dbType){
		 this (dbType);
		 this.tableSources.add(tableSource);
	 }
	 public List<SQLExprTableSource> getTableSources() {
		 return tableSources;
	 }
	 public void addPartition(SQLExprTableSource tableSource) {
		 if (tableSource != null) {
			 tableSource.setParent(this);
		 }
		 this.tableSources.add(tableSource);
	 }
	 public void setName(SQLName name) {
		 this.addTableSource(new SQLExprTableSource(name));
	 }
	 public void addTableSource(SQLName name) {
		 this.addTableSource(new SQLExprTableSource(name));
	 }
	 public void addTableSource(SQLExprTableSource tableSource) {
		 tableSources.add(tableSource);
	 }
	 protected void accept0(SQLASTVisitor visitor) {
		 if (visitor.visit(this)) {
			 this.acceptChild(visitor, tableSources);
		 }
		 visitor.endVisit(this);
	 }
	 public List getChildren() {
		 return this.tableSources;
	 }
	 public boolean isPurge() {
		 return purge;
	 }
	 public void setPurge(boolean purge) {
		 this.purge = purge;
	 }
	 public boolean isIfExists() {
		 return ifExists;
	 }
	 public void setIfExists(boolean ifExists) {
		 this.ifExists = ifExists;
	 }
	 public boolean isCascade() {
		 return cascade;
	 }
	 public void setCascade(boolean cascade) {
		 this.cascade = cascade;
	 }
	 public boolean isRestrict() {
		 return restrict;
	 }
	 public void setRestrict(boolean restrict) {
		 this.restrict = restrict;
	 }
	 public boolean isTemporary() {
		 return temporary;
	 }
	 public void setTemporary(boolean temporary) {
		 this.temporary = temporary;
	 }
	 public List<SQLCommentHint> getHints() {
		 return hints;
	 }
	 public void setHints(List<SQLCommentHint> hints) {
		 this.hints = hints;
	 }
}",1,1,0,0
"public synchronized int hashCode() {
	 if (isReference()) {
		 return getCheckedRef().hashCode();
	 }
	 return v == null ? 0 : v.hashCode();
 }",0,0,0,0
"public class ReferenceProperty implements Property<EntityReference>{
	 EntityReference reference;
	 public ReferenceProperty() {
	 }
	 public ReferenceProperty( EntityReference reference ) {
		 this.reference = reference;
	 }
	 public EntityReference get() {
		 return reference;
	 }
	 public void set( EntityReference newValue ) throws IllegalArgumentException, IllegalStateException {
		 reference = newValue;
	 }
}",0,1,0,0
"public void serialize(ColumnFamily columnFamily, DataOutput dos) {
	 try {
		 if (columnFamily == null) {
			 dos.writeBoolean(false);
			 return;
		 }
		 dos.writeBoolean(true);
		 dos.writeInt(columnFamily.id());
	 }
	 catch (IOException e) {
		 throw new RuntimeException(e);
	 }
	 serializeForSSTable(columnFamily, dos);
 }",0,0,0,0
"public class ServletContextListenerStartup implements ServletContextListener {
	 public static final String IGNITE_CFG_FILE_PATH_PARAM = ""IgniteConfigurationFilePath"";
	 private final Collection<String> igniteInstanceNames = new ArrayList<>();
	 public void contextInitialized(ServletContextEvent evt) {
		 ServletContext ctx = evt.getServletContext();
		 String cfgFile = ctx.getInitParameter(IGNITE_CFG_FILE_PATH_PARAM);
		 Collection<IgniteConfiguration> cfgs;
		 GridSpringResourceContext rsrcCtx = null;
		 if (cfgFile != null) {
			 URL cfgUrl = null;
			 try {
				 cfgUrl = evt.getServletContext().getResource(""/META-INF/"" + cfgFile);
			 }
			 catch (MalformedURLException ignored) {
			 }
			 if (cfgUrl == null) cfgUrl = U.resolveIgniteUrl(cfgFile);
			 if (cfgUrl == null) throw new IgniteException(""Failed to find Spring configuration file (path provided should be "" + ""either absolute, relative to IGNITE_HOME, or relative to META-INF folder): "" + cfgFile);
			 IgniteBiTuple<Collection<IgniteConfiguration>, ? extends GridSpringResourceContext> t;
			 try {
				 t = IgnitionEx.loadConfigurations(cfgUrl);
			 }
			 catch (IgniteCheckedException e) {
				 throw new IgniteException(""Failed to load Ignite configuration."", e);
			 }
			 cfgs = t.get1();
			 rsrcCtx = t.get2();
			 if (cfgs.isEmpty()) throw new IgniteException(""Can't find grid factory configuration in: "" + cfgUrl);
		 }
		 else cfgs = Collections.<IgniteConfiguration>singleton(new IgniteConfiguration());
		 try {
			 assert !cfgs.isEmpty();
			 for (IgniteConfiguration cfg : cfgs) {
				 assert cfg != null;
				 Ignite ignite;
				 synchronized (ServletContextListenerStartup.class) {
					 try {
						 ignite = G.ignite(cfg.getIgniteInstanceName());
					 }
					 catch (IgniteIllegalStateException ignored) {
						 ignite = IgnitionEx.start(new IgniteConfiguration(cfg), rsrcCtx);
					 }
				 }
				 if (ignite != null) igniteInstanceNames.add(ignite.name());
			 }
		 }
		 catch (IgniteCheckedException e) {
			 for (String name : igniteInstanceNames) G.stop(name, true);
			 throw new IgniteException(""Failed to start Ignite."", e);
		 }
	 }
	 public void contextDestroyed(ServletContextEvent evt) {
		 for (String name: igniteInstanceNames) G.stop(name, true);
	 }
	 public String toString() {
		 return S.toString(ServletContextListenerStartup.class, this);
	 }
}",1,0,0,0
"public class TableAliasImpl extends SQLSyntaxElementBase<TableAlias, TableAlias> implements TableAlias{
	 private final String _tableAlias;
	 private final ColumnNameList _columnAliases;
	 public TableAliasImpl( SQLProcessorAggregator processor, String tableAlias, ColumnNameList columnNames ) {
		 this( processor, TableAlias.class, tableAlias, columnNames );
	 }
	 protected TableAliasImpl( SQLProcessorAggregator processor, Class<? extends TableAlias> implementingClass, String tableAlias, ColumnNameList columnNames ) {
		 super( processor, implementingClass );
		 Objects.requireNonNull( tableAlias, ""table alias table name"" );
		 this._tableAlias = tableAlias;
		 this._columnAliases = columnNames;
	 }
	 public ColumnNameList getColumnAliases() {
		 return this._columnAliases;
	 }
	 public String getTableAlias() {
		 return this._tableAlias;
	 }
	 protected boolean doesEqual( TableAlias another ) {
		 return this._tableAlias.equals( another.getTableAlias() ) && bothNullOrEquals( this._columnAliases, another.getColumnAliases() );
	 }
}",0,1,0,0
"private AttributeSetter createAttributeSetter(final Method m, Class arg, final String attrName) {
	 final Class reflectedArg = PRIMITIVE_TYPE_MAP.containsKey(arg) ? (Class) PRIMITIVE_TYPE_MAP.get(arg) : arg;
	 if (java.lang.String.class.equals(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 m.invoke(parent, (Object[]) new String[] {
				value}
				);
			 }
		 }
		;
	 }
	 if (java.lang.Character.class.equals(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 if (value.length() == 0) {
					 throw new BuildException(""The value \""\"" is not a "" + ""legal value for attribute \"""" + attrName + ""\"""");
				 }
				 m.invoke(parent, (Object[]) new Character[] {
				new Character(value.charAt(0))}
				);
			 }
		 }
		;
	 }
	 if (java.lang.Boolean.class.equals(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 m.invoke(parent, (Object[]) new Boolean[] {
				 Project.toBoolean(value) ? Boolean.TRUE : Boolean.FALSE }
				);
			 }
		 }
		;
	 }
	 if (java.lang.Class.class.equals(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 m.invoke(parent, new Object[] {
					Class.forName(value)}
					);
				 }
				 catch (ClassNotFoundException ce) {
					 throw new BuildException(ce);
				 }
			 }
		 }
		;
	 }
	 if (java.io.File.class.equals(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 m.invoke(parent, new Object[] {
				p.resolveFile(value)}
				);
			 }
		 }
		;
	 }
	 if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 EnumeratedAttribute ea = (EnumeratedAttribute) reflectedArg.newInstance();
					 ea.setValue(value);
					 m.invoke(parent, new Object[] {
					ea}
					);
				 }
				 catch (InstantiationException ie) {
					 throw new BuildException(ie);
				 }
			 }
		 }
		;
	 }
	 Class enumClass = null;
	 try {
		 enumClass = Class.forName(""java.lang.Enum"");
	 }
	 catch (ClassNotFoundException e) {
	 }
	 if (enumClass != null && enumClass.isAssignableFrom(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 m.invoke(parent, new Object[] {
						 reflectedArg.getMethod(""valueOf"", new Class[] {
						String.class}
						). invoke(null, new Object[] {
						value}
					)}
					);
				 }
				 catch (InvocationTargetException x) {
					 if (x.getTargetException() instanceof IllegalArgumentException) {
						 throw new BuildException(""'"" + value + ""' is not a permitted value for "" + reflectedArg.getName());
					 }
					 throw extractBuildException(x);
				 }
				 catch (Exception x) {
					 throw new BuildException(x);
				 }
			 }
		 }
		;
	 }
	 if (java.lang.Long.class.equals(reflectedArg)) {
		 return new AttributeSetter(m) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 m.invoke(parent, new Object[] {
					 new Long(StringUtils.parseHumanSizes(value)) }
					);
				 }
				 catch (InvocationTargetException e) {
					 throw e;
				 }
				 catch (IllegalAccessException e) {
					 throw e;
				 }
				 catch (Exception e) {
					 throw new BuildException(e);
				 }
			 }
		 }
		;
	 }
	 boolean includeProject;
	 Constructor c;
	 try {
		 c = reflectedArg.getConstructor(new Class[] {
		Project.class, String.class}
		);
		 includeProject = true;
	 }
	 catch (NoSuchMethodException nme) {
		 try {
			 c = reflectedArg.getConstructor(new Class[] {
			String.class}
			);
			 includeProject = false;
		 }
		 catch (NoSuchMethodException nme2) {
			 return null;
		 }
	 }
	 final boolean finalIncludeProject = includeProject;
	 final Constructor finalConstructor = c;
	 return new AttributeSetter(m) {
		 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
			 try {
				 Object[] args = finalIncludeProject ? new Object[] {
				p, value}
				 : new Object[] {
				value}
				;
				 Object attribute = finalConstructor.newInstance(args);
				 if (p != null) {
					 p.setProjectReference(attribute);
				 }
				 m.invoke(parent, new Object[] {
				attribute}
				);
			 }
			 catch (InstantiationException ie) {
				 throw new BuildException(ie);
			 }
		 }
	 }
	;
 }",0,0,1,0
"public synchronized Task pollForNewTask(String taskTracker) {
	 int remainingReduceLoad = 0;
	 int remainingMapLoad = 0;
	 int numTaskTrackers;
	 TaskTrackerStatus tts;
	 int avgMapLoad = 0;
	 int avgReduceLoad = 0;
	 synchronized (taskTrackers) {
		 numTaskTrackers = taskTrackers.size();
		 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
	 }
	 synchronized(jobsByArrival){
		 for (Iterator it = jobsByArrival.iterator();
		 it.hasNext();
		 ) {
			 JobInProgress job = (JobInProgress) it.next();
			 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
				 int totalMapTasks = job.desiredMaps();
				 int totalReduceTasks = job.desiredReduces();
				 remainingMapLoad += (totalMapTasks - job.finishedMaps());
				 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
			 }
		 }
	 }
	 if (numTaskTrackers > 0) {
		 avgMapLoad = remainingMapLoad / numTaskTrackers;
		 avgReduceLoad = remainingReduceLoad / numTaskTrackers;
	 }
	 int totalCapacity = numTaskTrackers * maxCurrentTasks;
	 if (tts == null) {
		 LOG.warn(""Unknown task tracker polling;
		 ignoring: "" + taskTracker);
		 return null;
	 }
	 int numMaps = tts.countMapTasks();
	 int numReduces = tts.countReduceTasks();
	 synchronized (jobsByArrival) {
		 if ((numMaps < maxCurrentTasks) && (numMaps <= avgMapLoad + 1 + TASK_ALLOC_EPSILON)) {
			 int totalNeededMaps = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewMapTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 myMetrics.launchMap();
					 return t;
				 }
				 totalNeededMaps += job.desiredMaps();
				 int padding = 0;
				 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, (int)(totalNeededMaps * PAD_FRACTION));
				 }
				 if (totalMaps + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
		 if ((numReduces < maxCurrentTasks) && (numReduces <= avgReduceLoad + 1 + TASK_ALLOC_EPSILON)) {
			 int totalNeededReduces = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewReduceTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 myMetrics.launchReduce();
					 return t;
				 }
				 totalNeededReduces += job.desiredReduces();
				 int padding = 0;
				 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, (int) (totalNeededReduces * PAD_FRACTION));
				 }
				 if (totalReduces + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public static String join(String separator, String... fragments){
	if (fragments.length < 1){
		return """";
	}
	else if (fragments.length < 2){
		return fragments[0];
	}
	else{
		StringBuffer buff = new StringBuffer(128);
		if (fragments[0] != null){
			buff.append(fragments[0]);
		}
		for (int i = 1;
		 i < fragments.length;
		 i++){
			if ((fragments[i - 1] != null) || (fragments[i] != null)){
				boolean lhsClosed = fragments[i - 1].endsWith(separator);
				boolean rhsClosed = fragments[i].startsWith(separator);
				if (lhsClosed && rhsClosed){
					buff.append(fragments[i].substring(1));
				}
				else if (!lhsClosed && !rhsClosed){
					buff.append(separator).append(fragments[i]);
				}
				else{
					buff.append(fragments[i]);
				}
			}
		}
		return buff.toString();
	}
}",0,0,0,0
"public class SourceCodeParser implements Scannable {
	private Scanner scanner;
	JavaClass javaClass;
	ConstantPoolGenerator cpl = new ConstantPoolGenerator();
	boolean precompile = false;
	public SourceCodeParser(File file) throws ParsingException {
		scanner = new Scanner(file);
	}
	public SourceCodeParser(String content) throws ParsingException {
		scanner = new Scanner(content);
	}
	public JavaClass parse() throws ParsingException {
		javaClass = new JavaClass();
		cpl = new ConstantPoolGenerator();
		if (precompile == true) {
			preprocessConstantValues();
		}
		parseClass();
		return javaClass;
	}
	private void preprocessConstantValues() throws ParsingException {
		scanner.mark();
		String t;
		while (scanner.nextToken() != EOF) {
			switch (scanner.tokenType()) {
				case String:t = scanner.token();
				cpl.addString(Util.parseViewableString(t.substring(1, t.length() - 1)));
				break;
				case Number_Double:t = scanner.token();
				cpl.addDouble( parseDouble(t ));
				case Number_Long:t = scanner.token();
				cpl.addDouble(parseLong(t ));
				break;
			}
		}
		scanner.restore();
	}
	private void parseClass() throws ParsingException, GrammerException {
		scanner.nextToken();
		if (scanner.tokenType() == Attribute) {
			parseMajorOrMinor();
		}
		parseClassSignature();
		parseFields();
		parseMethods();
		parseClassAttributes();
		if (scanner.tokenType() != Bracket_Right) {
		exception(scanner, ""'}
		'.expected.here"");
	}
	if (scanner.nextToken() != EOF) {
		exception(scanner, ""end.of.class.expected.here"");
	}
	javaClass.constantPool = cpl.getConstantPool();
	javaClass.constant_pool_count = javaClass.constantPool.getConstantPoolCount();
}
private void parseClassSignature() throws ParsingException {
	int acc = 0;
	while (scanner.tokenType() == AccessFlag) {
		acc = acc | Util.getAccessFlag_Class(scanner.token());
		scanner.nextToken();
	}
	if (acc == 0) {
		exception(scanner, ""\""class\"".expected.here"");
	}
	javaClass.access_flags = (short) acc;
	javaClass.this_class = cpl.addClass(scanner.token());
	scanner.nextToken();
	while (scanner.tokenType() != Bracket_Left && scanner.tokenType() != EOF) {
		if (""extends"".equals(scanner.token()) == true) {
			scanner.nextToken();
			javaClass.super_class = cpl.addClass(scanner.token());
			scanner.nextToken();
		}
		 else if (""implements"".equals(scanner.token()) == true) {
			scanner.nextToken();
			IntegerArray array = new IntegerArray(5);
			while (scanner.tokenType() != Bracket_Left && scanner.tokenType() != EOF) {
				array.add(cpl.addClass(scanner.token()));
				scanner.nextToken();
				if (scanner.tokenType() == Comma) {
					scanner.nextToken();
				}
			}
			javaClass.interfaces = array.getAll();
			javaClass.interfaces_count = javaClass.interfaces.length;
		}
		 else {
			exception(scanner, ""unexpected.character.here"");
		}
	}
	scanner.nextToken();
}
private void parseFields() throws ParsingException, GrammerException {
	ArrayList fields = new ArrayList(10);
	Object field;
	do {
		field = parseField();
		if (field != null) {
			fields.add(field);
		}
	}
	 while (field != null);
	javaClass.fields = (Field[]) fields.toArray(new Field[fields.size()]);
	javaClass.fields_count = javaClass.fields.length;
}
private Field parseField() throws ParsingException, GrammerException {
	if (scanner.tokenType() == Attribute || scanner.tokenType() == Bracket_Right) {
		return null;
	}
	scanner.mark();
	int acc = 0;
	while (scanner.tokenType() == AccessFlag) {
		acc = acc | Util.getAccessFlag_Field(scanner.token());
		scanner.nextToken();
	}
	String fieldType = scanner.token();
	scanner.nextToken();
	String fieldName = scanner.token();
	scanner.nextToken();
	String maybeEuqal = scanner.token();
	 if (fieldType.indexOf('(') != -1 || fieldName.indexOf('(') != -1 || maybeEuqal.indexOf('(') != -1) {
		scanner.restore();
		return null;
	}
	ArrayList attributes = new ArrayList(3);
	fieldType = Util.toInnerType(fieldType);
	if (scanner.tokenType() == Equal) {
		scanner.nextToken();
		String constValue = scanner.token();
		int const_index;
		Attribute_ConstantValue con = null;
		switch (fieldType.charAt(0)) {
			case 'B':case 'C':case 'I':case 'S':case 'Z':const_index = cpl.addInteger(parseInteger(constValue));
			con = new Attribute_ConstantValue(2, const_index);
			break;
			case 'D':const_index = cpl.addDouble(parseDouble(constValue));
			con = new Attribute_ConstantValue(2, const_index);
			break;
			case 'F':const_index = cpl.addFloat(parseFloat(constValue));
			con = new Attribute_ConstantValue(2, const_index);
			break;
			case 'J':const_index = cpl.addLong(parseLong(constValue));
			con = new Attribute_ConstantValue(2, const_index);
			break;
			case 'L':if (fieldType.equals(""Ljava/lang/String;
			"") == true) {
				const_index = cpl.addString(Util.parseViewableString(constValue.substring(1, constValue.length() - 1)));
				 con = new Attribute_ConstantValue(2, const_index);
				break;
			}
			default:exception(scanner, ""can.not.assign.contant.value.to.this.field.type.only.primitive.types.and.string.allowed"");
		}
		con.attribute_name_index = cpl.addUtf8(""ConstantValue"");
		attributes.add(con);
		scanner.nextToken();
	}
	while (scanner.tokenType() == Attribute) {
		attributes.add(parseAttribute());
	}
	Field ret = new Field(acc, cpl.addUtf8(fieldName), cpl.addUtf8(fieldType), attributes.size(), (Attribute[]) attributes.toArray(new Attribute[attributes.size()]));
	return ret;
}
private void parseMethods() throws ParsingException, GrammerException {
	ArrayList methods = new ArrayList(10);
	Object method;
	do {
		method = parseMethod();
		if (method != null) {
			methods.add(method);
		}
	}
	 while (method != null);
	javaClass.methods = (Method[]) methods.toArray(new Method[methods.size()]);
	javaClass.methods_count = javaClass.methods.length;
}
private Method parseMethod() throws ParsingException, GrammerException {
	if (scanner.tokenType() == Attribute || scanner.tokenType() == Bracket_Right || scanner.tokenType() == EOF) {
		return null;
	}
	Method method = new Method(0, 0, 0, 0, new Attribute[0]);
	LabeledInstructions li;
	ArrayList attributes = new ArrayList(4), codeAttributes;
	parseMethodSignature(method, attributes);
	if (Util.hasMethodBody((short) method.access_flags) == true) {
		codeAttributes = new ArrayList(4);
		li = parseMethodInstructions(method);
		Attribute_Code code = new Attribute_Code();
		code.attribute_name_index = cpl.addUtf8(""Code"");
		code.codes = li.codes;
		parseMethodAttributes(method, attributes, li, code, codeAttributes);
		code.code_length = li.codeLength;
		code.attributes = (Attribute[]) codeAttributes.toArray(new Attribute[codeAttributes.size()]);
		code.attributes_count = code.attributes.length;
		code.attribute_length = 2+ 2+ 4+ code.code_length+ 2+ code.exception_table_length * 8 + 2;
		for (int i = 0;
		 i < code.attributes_count;
		 i++) {
			code.attribute_length += code.attributes[i].attribute_length + 6;
		}
		attributes.add(code);
	}
	 else {
		parseMethodAttributes(method, attributes, null, null, null);
	}
	scanner.nextToken();
	method.attributes = (Attribute[]) attributes.toArray(new Attribute[attributes.size()]);
	method.attributes_count = method.attributes.length;
	return method;
}
private void parseMethodAttributes(Method method, ArrayList attributes, LabeledInstructions li, Attribute_Code code, ArrayList codeAttributes)throws GrammerException, ParsingException {
	String temp;
	while (scanner.tokenType() == Attribute) {
		temp = scanner.token();
		if (temp.indexOf(Constants.ATTRIBUTE_NAME_LOCAL_VARIABLE) != -1) {
			codeAttributes.add(parseLocalVariableTable(temp, li.labels));
			scanner.nextToken();
		}
		 else if (temp.indexOf(Constants.ATTRIBUTE_NAME_EXCEPTION_TABLE) != -1) {
			code.exception_table = parseExceptionTable(temp, li.labels);
			code.exception_table_length = code.exception_table.length;
			scanner.nextToken();
		}
		 else if (temp.indexOf(Constants.ATTRIBUTE_NAME_MAX_STACK) != -1) {
			parseMaxStackOrLocals(code);
			scanner.nextToken();
		}
		 else if (temp.indexOf(Constants.ATTRIBUTE_NAME_MAX_LOCAL) != -1) {
			parseMaxStackOrLocals(code);
			scanner.nextToken();
		}
		 else if (temp.indexOf(Constants.ATTRIBUTE_NAME_DEPRECATED) != -1) {
			attributes.add(parseAttribute());
		}
		 else if (temp.indexOf(Constants.ATTRIBUTE_NAME_SYNTHETIC) != -1) {
			attributes.add(parseAttribute());
		}
		 else if (temp.indexOf(Constants.ATTRIBUTE_NAME_LINE_NUMBER_TABLE) != -1) {
			scanner.nextToken();
			if (false) {
				parseLineNumbers(null);
			}
		}
		 else {
			exception(scanner, ""unexpected.attribute."" + scanner.token());
		}
	}
}
private Attribute parseLineNumbers(String s) {
	return null;
}
private LabeledInstructions parseMethodInstructions(Method method) throws ParsingException, GrammerException {
	Hashtable labelMap = new Hashtable();
	ArrayList toUpdate = new ArrayList();
	ArrayList codes = new ArrayList(), info;
	Attribute_Code.Opcode op = null;
	OpcodeInfo opinfo;
	String temp, retType, type, label = null;
	StringBuffer paras = new StringBuffer();
	int t = 0, i = 0, j = 0, high, low, npairs, counter, tokenType, offset = 0, codeLength = 0;
	byte[][] operands = null;
	boolean isWide = false, record = false;
	while (scanner.tokenType() != EOF && scanner.tokenType() != Attribute && scanner.tokenType() != Bracket_Right) {
		switch (scanner.tokenType()) {
			case JavaName:record = true;
			label = scanner.token();
			if (scanner.nextToken() != Colon) {
				exception(scanner, ""expecting.':'.after.label.name"");
			}
			if (scanner.nextToken() != Instruction) {
				exception(scanner, ""expecting.instruction.after.label"");
			}
			case Instruction: {
				opinfo = OpcodeHelper.getOpcodeInfo(scanner.token());
				switch (opinfo.opcode) {
					case Constants.TABLESWITCH:scanner.nextToken();
					info = new ArrayList();
					if (scanner.token().equals(""default"") == false) {
						exception(scanner, ""'default'.expected.here"");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					scanner.nextToken();
					info.add(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""low"") == false) {
						exception(scanner, ""'low'.expected.here."");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here."");
					}
					low = parseInteger(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""high"") == false) {
						exception(scanner, ""'high'.expected.here."");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here."");
					}
					high = parseInteger(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""jump_table"") == false) {
						exception(scanner, ""'jump_table'.expected.here."");
					}
					if (scanner.nextToken() != Colon) {
						exception(scanner, ""':'.expected.here."");
					}
					scanner.nextToken();
					counter = 0;
					while (scanner.tokenType() != EOF) {
						if (scanner.tokenType() != JavaName) {
							exception(scanner, ""label.name.expected.here"");
						}
						info.add(scanner.token());
						if (scanner.nextToken() != Comma) {
							break;
						}
						scanner.nextToken();
					}
					operands = new byte[high - low + 5][];
					operands[0] = new byte[3 - offset % 4];
					for (i = 0;
					 i < operands[0].length;
					 i++) {
						operands[0][i] = (byte) 0;
					}
					operands[2] = Util.getBytes(low, 4);
					operands[3] = Util.getBytes(high, 4);
					op = new OpcodeWrapper(offset, opinfo.opcode, operands, info);
					toUpdate.add(op);
					codeLength = 1 + operands[0].length + operands.length * 4 - 4;
					info = null;
					break;
					case Constants.LOOKUPSWITCH:scanner.nextToken();
					info = new ArrayList();
					if (scanner.token().equals(""default"") == false) {
						exception(scanner, ""'default'.expected.here"");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					scanner.nextToken();
					info.add(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""npairs"") == false) {
						exception(scanner, ""'npairs'.expected.here."");
					}
					if (scanner.nextToken() != Equal) {
						exception(scanner, ""'='.expected.here."");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here."");
					}
					npairs = parseInteger(scanner.token());
					if (scanner.nextToken() != Comma) {
						exception(scanner, ""','.expected.here."");
					}
					scanner.nextToken();
					if (scanner.token().equals(""jump_table"") == false) {
						exception(scanner, ""'jump_table'.expected.here."");
					}
					if (scanner.nextToken() != Colon) {
						exception(scanner, ""':'.expected.here."");
					}
					scanner.nextToken();
					operands = new byte[npairs * 2 + 3][];
					operands[0] = new byte[3 - offset % 4];
					for (i = 0;
					 i < operands[0].length;
					 i++) {
						operands[0][i] = (byte) 0;
					}
					operands[2] = Util.getBytes(npairs, 4);
					counter = 3;
					while (scanner.tokenType() != EOF) {
						if (scanner.tokenType() != Number_Integer) {
							exception(scanner, ""number.expected.here"");
						}
						operands[counter] = Util.getBytes(parseInteger(scanner.token()), 4);
						counter = counter + 2;
						if (scanner.nextToken() != Pointer) {
							exception(scanner, ""->.expected.here"");
						}
						scanner.nextToken();
						info.add(scanner.token());
						if (scanner.nextToken() != Comma) {
							break;
						}
						scanner.nextToken();
					}
					op = new OpcodeWrapper(offset, opinfo.opcode, operands, info);
					codeLength = 1 + operands[0].length + operands.length * 4 - 4;
					toUpdate.add(op);
					info = null;
					break;
					case Constants.GETFIELD:case Constants.GETSTATIC:case Constants.PUTFIELD:case Constants.PUTSTATIC:scanner.nextToken();
					operands = new byte[1][];
					type = scanner.token();
					scanner.nextToken();
					temp = scanner.token();
					i = temp.lastIndexOf('.');
					i = cpl.addFieldref(temp.substring(i + 1), temp.substring(0, i), type);
					operands[0] = Util.getBytes(i, 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.INVOKESPECIAL:case Constants.INVOKESTATIC:case Constants.INVOKEVIRTUAL:operands = new byte[1][];
					scanner.nextToken();
					retType = scanner.token();
					scanner.nextToken();
					temp = scanner.token();
					i = temp.lastIndexOf('.');
					if ((scanner.nextToken() == SBracket_Left) == false) {
						exception(scanner, ""'('.expected.here"");
					}
					if (scanner.nextToken() != SBracket_Right) {
						while (scanner.tokenType() != SBracket_Right && scanner.tokenType() != EOF) {
							paras.append(scanner.token());
							if (scanner.nextToken() == Comma) {
								paras.append(',');
								scanner.nextToken();
							}
						}
						if (scanner.tokenType() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					 else {
						paras.append("""");
					}
					operands[0] = Util.getBytes(cpl.addMethodref(temp.substring(i + 1), temp.substring(0, i), retType, paras.toString()), 2);
					paras.delete(0, paras.length());
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.INVOKEINTERFACE:scanner.nextToken();
					operands = new byte[3][];
					retType = scanner.token();
					scanner.nextToken();
					temp = scanner.token();
					i = temp.lastIndexOf('.');
					if (scanner.nextToken() == SBracket_Left == false) {
						exception(scanner, ""'('.expected.here"");
					}
					if (scanner.nextToken() != SBracket_Right) {
						while (scanner.tokenType() != SBracket_Right && scanner.tokenType() != EOF) {
							paras.append(scanner.token());
							if (scanner.nextToken() == Comma) {
								paras.append(',');
								scanner.nextToken();
							}
						}
						if (scanner.tokenType() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					 else {
						paras.append("""");
					}
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""number.expected.here"");
					}
					t = parseInteger(scanner.token());
					operands[0] = Util.getBytes(cpl.addInterfaceMethodref(temp.substring(i + 1), temp.substring(0, i), retType, paras.toString()), 2);
					operands[1] = Util.getBytes(t, 1);
					operands[2] = Util.getBytes(0, 1);
					 codeLength = 5;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					paras.delete(0, paras.length());
					break;
					case Constants.NEW:case Constants.CHECKCAST:case Constants.INSTANCEOF:scanner.nextToken();
					operands = new byte[1][];
					operands[0] = Util.getBytes(cpl.addClass(scanner.token()), 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.LDC:scanner.nextToken();
					operands = new byte[1][];
					temp = scanner.token();
					tokenType = scanner.tokenType();
					if (tokenType == String) {
						i = cpl.addString(Util.parseViewableString(temp.substring(1, temp.length() - 1)));
					}
					 else if (tokenType == Number_Float || tokenType == Number_Float_Positive_Infinity || tokenType == Number_Float_Negativ_Infinity|| tokenType == Number_Float_NaN) {
						i = cpl.addFloat(parseFloat(temp));
					}
					 else if (tokenType == Number_Integer) {
						i = cpl.addInteger(parseInteger(temp));
					}
					 else {
						exception(scanner, ""expecting.integer.or.string.or.float.here"");
					}
					if (i < 255) {
						operands[0] = Util.getBytes(i, 1);
						codeLength = 2;
						op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					}
					 else {
						operands[0] = Util.getBytes(i, 2);
						op = new Attribute_Code.Opcode(offset, Constants.LDC_W, operands);
						codeLength = 3;
					}
					scanner.nextToken();
					break;
					case Constants.LDC_W:scanner.nextToken();
					operands = new byte[1][];
					temp = scanner.token();
					tokenType = scanner.tokenType();
					if (tokenType == String) {
						i = cpl.addString(Util.parseViewableString(temp.substring(1, temp.length() - 1)));
					}
					 else if (tokenType == Number_Float || tokenType == Number_Float_NaN || tokenType == Number_Float_Negativ_Infinity|| tokenType == Number_Float_Positive_Infinity) {
						i = cpl.addFloat(parseFloat(temp));
					}
					 else if (tokenType == Number_Integer) {
						i = cpl.addInteger(parseInteger(temp));
					}
					 else {
						exception(scanner, ""expecting.integer.or.string.or.float.here"");
					}
					operands[0] = Util.getBytes(i, 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.LDC2_W:scanner.nextToken();
					operands = new byte[1][];
					temp = scanner.token();
					tokenType = scanner.tokenType();
					if (tokenType == Number_Long) {
						i = cpl.addLong(parseLong(temp));
					}
					 else if (tokenType == Number_Double || tokenType == Number_Double_NaN || tokenType == Number_Double_Negativ_Infinity|| tokenType == Number_Double_Positive_Infinity) {
						i = cpl.addDouble(parseDouble(temp));
					}
					 else {
						exception(scanner, ""expecting.long.or.double.here"");
					}
					operands[0] = Util.getBytes(i, 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.NEWARRAY:scanner.nextToken();
					operands = new byte[1][1];
					operands[0][0] = Util.getPrimitiveTypeCode(scanner.token());
					codeLength = 2;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.ANEWARRAY:scanner.nextToken();
					operands = new byte[1][];
					operands[0] = Util.getBytes(cpl.addClass(scanner.token()), 2);
					codeLength = 3;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.MULTIANEWARRAY:scanner.nextToken();
					operands = new byte[2][];
					type = scanner.token();
					if (scanner.nextToken() != Number_Integer) {
						exception(scanner, ""dimesion.number.expected.here"");
					}
					i = parseInteger(scanner.token());
					operands[1] = Util.getBytes(i, 1);
					 operands[0] = Util.getBytes(cpl.addClass(type), 2);
					codeLength = 4;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.WIDE:isWide = true;
					codeLength = 1;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.IINC:operands = new byte[2][];
					scanner.nextToken();
					if (scanner.tokenType() == Number_Integer) {
						i = parseInteger(scanner.token());
					}
					 else {
						if (scanner.nextToken() != SBracket_Left) {
							exception(scanner, ""'('.expected.here"");
						}
						if (scanner.nextToken() != Number_Integer) {
							exception(scanner, ""local.variable.index.expected.here"");
						}
						i = parseInteger(scanner.token());
						if (scanner.nextToken() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					scanner.nextToken();
					if (scanner.tokenType() != Number_Integer) {
						exception(scanner, ""increment.amount.expected.here"");
					}
					j = parseInteger(scanner.token());
					if (isWide == true) {
						operands[0] = Util.getBytes(i, 2);
						operands[1] = Util.getBytes(j, 2);
						codeLength = 5;
					}
					 else {
						operands[0] = Util.getBytes(i, 1);
						operands[1] = Util.getBytes(j, 1);
						codeLength = 3;
					}
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.ALOAD:case Constants.ASTORE:case Constants.DLOAD:case Constants.DSTORE:case Constants.FLOAD:case Constants.FSTORE:case Constants.ILOAD:case Constants.ISTORE:case Constants.LLOAD:case Constants.LSTORE:case Constants.RET:operands = new byte[1][];
					scanner.nextToken();
					if (scanner.tokenType() == Number_Integer) {
						i = parseInteger(scanner.token());
					}
					 else {
						if (scanner.nextToken() != SBracket_Left) {
							exception(scanner, ""'('.expected.here"");
						}
						if (scanner.nextToken() != Number_Integer) {
							exception(scanner, ""local.variable.index.expected.here"");
						}
						i = parseInteger(scanner.token());
						if (scanner.nextToken() != SBracket_Right) {
							exception(scanner, ""')'.expected.here"");
						}
					}
					if (isWide == true) {
						operands[0] = Util.getBytes(i, 2);
						codeLength = 2;
						isWide = false;
					}
					 else {
						operands[0] = Util.getBytes(i, 1);
						codeLength = 2;
					}
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
					scanner.nextToken();
					break;
					case Constants.GOTO:case Constants.IFEQ:case Constants.IFGE:case Constants.IFGT:case Constants.IFLE:case Constants.IFLT:case Constants.JSR:case Constants.IFNE:case Constants.IFNONNULL:case Constants.IFNULL:case Constants.IF_ACMPEQ:case Constants.IF_ACMPNE:case Constants.IF_ICMPEQ:case Constants.IF_ICMPGE:case Constants.IF_ICMPGT:case Constants.IF_ICMPLE:case Constants.IF_ICMPLT:case Constants.IF_ICMPNE:case Constants.GOTO_W:case Constants.JSR_W:scanner.nextToken();
					operands = new byte[1][];
					codeLength = 3;
					op = new OpcodeWrapper(offset, opinfo.opcode, operands, scanner.token());
					toUpdate.add(op);
					scanner.nextToken();
					break;
					case Constants.BIPUSH:default:operands = new byte[opinfo.operandsCount][];
					for (i = 0;
					 i < opinfo.operandsCount;
					 i++) {
						if (scanner.nextToken() != Number_Integer) {
							exception(scanner, ""number.expected.here"");
						}
						operands[i] = Util.getBytes(parseInteger(scanner.token()), opinfo.operandsLength[i]);
						codeLength = codeLength + opinfo.operandsLength[i];
					}
					scanner.nextToken();
					codeLength++;
					op = new Attribute_Code.Opcode(offset, opinfo.opcode, operands);
				}
				break;
			}
			case Attribute:break;
			default:exception(scanner, ""label.name.or.instructions.expected.here"");
		}
		offset = offset + codeLength;
		codes.add(op);
		if (record) {
			labelMap.put(label, op);
			label = null;
		}
		record = false;
		operands = null;
		codeLength = 0;
	}
	updateLabelLinks(labelMap, toUpdate);
	return new LabeledInstructions((Attribute_Code.Opcode[]) codes.toArray(new Attribute_Code.Opcode[codes.size()]), labelMap, offset);
}
private void updateLabelLinks(Hashtable labels, ArrayList toUpdate) throws GrammerException {
	OpcodeWrapper op;
	ArrayList list;
	String label;
	int counter;
	byte[][] operands;
	for (int i = 0;
	 i < toUpdate.size();
	 i++) {
		op = (OpcodeWrapper) toUpdate.get(i);
		operands = op.operands;
		switch (op.opcode) {
			case Constants.TABLESWITCH:list = (ArrayList) op.info;
			counter = operands.length;
			operands[1] = Util.getBytes(getOffset((String) list.get(0), labels, false) - op.offset, 4);
			counter = 1;
			for (int j = 4;
			 j < operands.length;
			 j++) {
				operands[j] = Util.getBytes(getOffset((String) list.get(counter++), labels, false) - op.offset, 4);
			}
			break;
			case Constants.LOOKUPSWITCH:list = (ArrayList) op.info;
			counter = operands.length;
			operands[1] = Util.getBytes(getOffset((String) list.get(0), labels, false) - op.offset, 4);
			counter = 1;
			for (int j = 4;
			 j < operands.length;
			 j++) {
				operands[j] = Util.getBytes(getOffset((String) list.get(counter++), labels, false) - op.offset, 4);
				j++;
			}
			break;
			case Constants.GOTO:case Constants.IFEQ:case Constants.IFGE:case Constants.IFGT:case Constants.IFLE:case Constants.IFLT:case Constants.JSR:case Constants.IFNE:case Constants.IFNONNULL:case Constants.IFNULL:case Constants.IF_ACMPEQ:case Constants.IF_ACMPNE:case Constants.IF_ICMPEQ:case Constants.IF_ICMPGE:case Constants.IF_ICMPGT:case Constants.IF_ICMPLE:case Constants.IF_ICMPLT:case Constants.IF_ICMPNE:label = (String) op.info;
			operands[0] = Util.getBytes(getOffset(label, labels, false) - op.offset, 2);
			break;
			case Constants.GOTO_W:case Constants.JSR_W:label = (String) op.info;
			operands[0] = Util.getBytes(getOffset(label, labels, false) - op.offset, 4);
			break;
		}
	}
}
private void parseMethodSignature(Method method, ArrayList attributes) throws ParsingException, GrammerException {
	int acc = 0;
	String methodName, retType;
	StringBuffer para = new StringBuffer(15);
	while (scanner.tokenType() == AccessFlag) {
		acc = acc | Util.getAccessFlag_Method(scanner.token());
		scanner.nextToken();
	}
	retType = scanner.token();
	scanner.nextToken();
	methodName = scanner.token();
	scanner.nextToken();
	if (scanner.tokenType() != SBracket_Left) {
		exception(scanner, ""'('.expected.here"");
	}
	scanner.nextToken();
	if (scanner.tokenType() == SBracket_Right) {
		para.append("""");
	}
	 else {
		while (scanner.tokenType() != EOF && scanner.tokenType() != SBracket_Right) {
			para = para.append(scanner.token());
			if (scanner.nextToken() == Comma) {
				para.append(',');
				scanner.nextToken();
			}
		}
		if (scanner.tokenType() != SBracket_Right) {
			throw new ParsingException(scanner.getOffset(), ""')'.expected.here"");
		}
	}
	retType = Util.toInnerType(retType);
	method.descriptor_index = cpl.addUtf8(""("" + Util.toInnerParameterTypes(para.toString()) + "")"" + retType);
	method.name_index = cpl.addUtf8(methodName);
	method.access_flags = acc;
	scanner.nextToken();
	if (""throws"".equals(scanner.token()) == true) {
		IntegerArray thr = new IntegerArray(4);
		while (scanner.tokenType() != Bracket_Left && scanner.tokenType() != EOF) {
			scanner.nextToken();
			thr.add(cpl.addClass(scanner.token()));
			scanner.nextToken();
			if (scanner.tokenType() != Bracket_Left && scanner.tokenType() != Comma) {
				exception(scanner, ""invalid.throw.clause"");
			}
		}
		Attribute att = new Attribute_Exceptions(2 + 2 * thr.getAll().length, thr.getAll().length, thr.getAll());
		att.attribute_name_index = cpl.addUtf8(""Exceptions"");
		attributes.add(att);
	}
	 else if (scanner.tokenType() == Bracket_Left) {
	}
	 else {
		exception(scanner, ""'{
			'.expected.here"");
		}
		scanner.nextToken();
	}
	private Attribute_LocalVariableTable parseLocalVariableTable(String s, Hashtable map) throws ParsingException, GrammerException {
		Scanner sc;
		sc = Scanner.partialScanner(scanner.getContent(), scanner.getOffset() + 1, scanner.getLength() - 2, scanner.getColumnNumberStart() + 1,scanner.getLineNumberStart());
		ArrayList lvts = new ArrayList();
		String type, name, index;
		int start, end;
		sc.nextToken();
		if (sc.nextToken() != Colon) {
			exception(sc, ""':'.expected"");
		}
		sc.nextToken();
		while (sc.tokenType() != EOF) {
			type = sc.token();
			sc.nextToken();
			name = sc.token();
			sc.nextToken();
			if (""start"".equals(sc.token()) == false) {
				exception(sc, ""'start'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			start = getOffset(sc.token(), map, false);
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""end"".equals(sc.token()) == false) {
				exception(sc, ""'end'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			end = getOffset(sc.token(), map, true);
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""index"".equals(sc.token()) == false) {
				exception(sc, ""'index'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			if (sc.nextToken() != Number_Integer) {
				exception(sc, ""local.variable.index.expected.here"");
			}
			index = sc.token();
			lvts.add(new Attribute_LocalVariableTable.LocalVariable(start, end - start, cpl.addUtf8(name), cpl.addUtf8(Util.toInnerType(type)),parseInteger(index)));
			sc.nextToken();
		}
		Attribute_LocalVariableTable.LocalVariable[] lvs = (Attribute_LocalVariableTable.LocalVariable[]) lvts.toArray(new Attribute_LocalVariableTable.LocalVariable[lvts.size()]);
		Attribute_LocalVariableTable lvt = new Attribute_LocalVariableTable(10 * lvs.length + 2, lvs.length, lvs);
		lvt.attribute_name_index = cpl.addUtf8(""LocalVariableTable"");
		return lvt;
	}
	private Attribute_Code.ExceptionTableItem[] parseExceptionTable(String s, Hashtable map) throws ParsingException, GrammerException {
		Scanner sc;
		sc = Scanner.partialScanner(scanner.getContent(), scanner.getOffset() + 1, scanner.getLength() - 2, scanner.getColumnNumberStart() + 1,scanner.getLineNumberStart());
		ArrayList excs = new ArrayList();
		int start, end, handler, catch_type;
		sc.nextToken();
		if (sc.nextToken() != Colon) {
			exception(sc, ""':'.expected"");
		}
		sc.nextToken();
		while (sc.tokenType() != EOF) {
			if (""start"".equals(sc.token()) == false) {
				exception(sc, ""'start'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(scanner, ""'='.expected.here"");
			}
			sc.nextToken();
			start = getOffset(sc.token(), map, false);
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""end"".equals(sc.token()) == false) {
				exception(sc, ""'end'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			end = getOffset(sc.token(), map, false);
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""handler"".equals(sc.token()) == false) {
				exception(sc, ""'handler'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			handler = getOffset(sc.token(), map, false);
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""catch_type"".equals(sc.token()) == false) {
				exception(sc, ""'catch_type'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			if (""0"".equals(sc.token())) {
				catch_type = 0;
			}
			 else {
				catch_type = cpl.addClass(sc.token());
			}
			excs.add(new Attribute_Code.ExceptionTableItem(start, end, handler, catch_type));
			sc.nextToken();
		}
		return (Attribute_Code.ExceptionTableItem[]) excs.toArray(new Attribute_Code.ExceptionTableItem[excs.size()]);
	}
	private int getOffset(String label, Hashtable map, boolean countingInstructionLength) throws GrammerException {
		Attribute_Code.Opcode op = (Attribute_Code.Opcode) map.get(label);
		if (op == null) {
			return -1;
		}
		if (countingInstructionLength == false) {
			return op.offset;
		}
		 else {
			return op.offset + Constants.NO_OF_OPERANDS[op.opcode & 0xFF] + 1;
		}
	}
	private Attribute parseAttribute() throws GrammerException, ParsingException {
		String s = scanner.token();
		Attribute att;
		if (s.indexOf(Constants.ATTRIBUTE_NAME_DEPRECATED) != -1) {
			att = new Attribute_Deprecated();
			att.attribute_name_index = cpl.addUtf8(""Deprecated"");
			scanner.nextToken();
			return att;
		}
		 else if (s.indexOf(Constants.ATTRIBUTE_NAME_SYNTHETIC) != -1) {
			att = new Attribute_Synthetic();
			att.attribute_name_index = cpl.addUtf8(""Synthetic"");
			scanner.nextToken();
			return att;
		}
		 else if (s.indexOf(Constants.ATTRIBUTE_NAME_SOURCE_FILE) != -1) {
			att = new Attribute_SourceFile(2, cpl.addUtf8(s.substring(s.lastIndexOf(':') + 1, s.length() - 1).trim()));
			att.attribute_name_index = cpl.addUtf8(""SourceFile"");
			scanner.nextToken();
			return att;
		}
		 else {
			exception(scanner, ""can.not.process.attribute"");
		}
		return null;
	}
	private Attribute_InnerClasses parseInnerClasses() throws ParsingException, GrammerException {
		Scanner sc;
		sc = Scanner.partialScanner(scanner.getContent(), scanner.getOffset() + 1, scanner.getLength() - 2, scanner.getColumnNumberStart() + 1,scanner.getLineNumberStart());
		ArrayList ins = new ArrayList();
		int access_flag = 0, inner_name_index, inner_class_info, outer_class_info;
		sc.nextToken();
		if (sc.nextToken() != Colon) {
			exception(sc, ""':'.expected"");
		}
		sc.nextToken();
		while (sc.tokenType() != EOF) {
			if (""access"".equals(sc.token()) == false) {
				exception(sc, ""'access'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			while (sc.nextToken() == AccessFlag) {
				access_flag = Util.getAccessFlag_Class(sc.token()) | access_flag;
			}
			if (sc.tokenType() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""name"".equals(sc.token()) == false) {
				exception(sc, ""'name'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			if (""0"".equals(sc.token()) == true) {
				inner_name_index = 0;
			}
			 else {
				inner_name_index = cpl.addUtf8(sc.token());
			}
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""fullname"".equals(sc.token()) == false) {
				exception(sc, ""'fullname'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			inner_class_info = cpl.addClass(sc.token());
			if (sc.nextToken() != Comma) {
				exception(sc, ""','.expected.here"");
			}
			sc.nextToken();
			if (""outername"".equals(sc.token()) == false) {
				exception(sc, ""'outername'.expected.here"");
			}
			if (sc.nextToken() != Equal) {
				exception(sc, ""'='.expected.here"");
			}
			sc.nextToken();
			if (""0"".equals(sc.token())) {
				outer_class_info = 0;
			}
			 else {
				outer_class_info = cpl.addClass(sc.token());
			}
			sc.nextToken();
			ins.add(new Attribute_InnerClasses.InnerClass(inner_class_info, outer_class_info, inner_name_index, access_flag));
		}
		Attribute_InnerClasses ret = new Attribute_InnerClasses(8 * ins.size() + 2, ins.size(), (Attribute_InnerClasses.InnerClass[]) ins.toArray(new Attribute_InnerClasses.InnerClass[ins.size()]));
		ret.attribute_name_index = cpl.addUtf8(""InnerClasses"");
		return ret;
	}
	private void parseClassAttributes() throws GrammerException, ParsingException {
		String s;
		ArrayList attributes = new ArrayList(4);
		int colonIndex , nameIndex;
		while (scanner.tokenType() == Attribute) {
			s = scanner.token();
			colonIndex = s.indexOf(':');
			nameIndex = s.indexOf(Constants.ATTRIBUTE_NAME_INNER_CLASSES);
			if (nameIndex!=-1 && nameIndex<colonIndex) {
				attributes.add(parseInnerClasses());
				scanner.nextToken();
			}
			 else {
				attributes.add(parseAttribute());
			}
		}
		javaClass.attributes = (Attribute[]) attributes.toArray(new Attribute[attributes.size()]);
		javaClass.attributes_count = attributes.size();
	}
	private void parseMaxStackOrLocals(Attribute_Code code) throws ParsingException {
		Scanner sc = Scanner.partialScanner(scanner.getContent(), scanner.getOffset() + 1, scanner.getLength() - 2,scanner.getColumnNumberStart() + 1, scanner.getLineNumberStart());
		sc.nextToken();
		if (sc.token().equals(Constants.ATTRIBUTE_NAME_MAX_STACK) == true) {
			if (sc.nextToken() != Colon) {
				exception(sc, ""':'.expected.here"");
			}
			if (sc.nextToken() != Number_Integer) {
				exception(sc, ""invalid.max.stack.value"");
			}
			code.max_stack = parseInteger(sc.token());
		}
		 else if (sc.token().equals(Constants.ATTRIBUTE_NAME_MAX_LOCAL) == true) {
			if (sc.nextToken() != Colon) {
				exception(sc, ""':'.expected.here"");
			}
			if (sc.nextToken() != Number_Integer) {
				exception(sc, ""invalid.max.local.value"");
			}
			code.max_locals = parseInteger(sc.token());
		}
	}
	private void parseMajorOrMinor() throws GrammerException, ParsingException {
		String s;
		while (scanner.tokenType() == Attribute) {
			s = scanner.token();
			if (s.indexOf(Constants.ATTRIBUTE_NAME_MAJOR_VERSION) != -1) {
				try {
					javaClass.major_version = parseInteger(s.substring(s.indexOf(':') + 1, s.lastIndexOf(']')).trim());
				}
				 catch (NumberFormatException ne) {
					exception(scanner, ""invalid.major.version.definition"");
				}
			}
			 else if (s.indexOf(Constants.ATTRIBUTE_NAME_MINOR_VERSION) != -1) {
				try {
					javaClass.minor_version = parseInteger(s.substring(s.indexOf(':') + 1, s.lastIndexOf(']')).trim());
				}
				 catch (NumberFormatException ne) {
					exception(scanner, ""invalid.minor.version.definition"");
				}
			}
			 else {
				exception(scanner, ""unexpected.attribute.here"");
			}
			scanner.nextToken();
		}
	}
	private static int parseInteger(String s) {
		if (s.startsWith(""0x"") || s.startsWith(""0X"")) {
			return Integer.parseInt(s.substring(2), 16);
		}
		 else {
			return Integer.parseInt(s);
		}
	}
	private static long parseLong(String s) {
		if (s.endsWith(""l"") || s.endsWith(""L"")) {
			s = s.substring(0, s.length() - 1);
		}
		if (s.startsWith(""0x"") || s.startsWith(""0X"")) {
			return Long.parseLong(s.substring(2), 16);
		}
		 else {
			return Long.parseLong(s);
		}
	}
	private static float parseFloat(String s) {
		if (s.endsWith(""f"") || s.endsWith(""F"")) {
			s = s.substring(0, s.length() - 1);
		}
		return Float.parseFloat(s);
	}
	private static double parseDouble(String s) {
		if (s.endsWith(""d"") || s.endsWith(""D"")) {
			s = s.substring(0, s.length() - 1);
		}
		return Double.parseDouble(s);
	}
	private static void exception(Scanner sc, String msg) throws ParsingException {
		throw new GrammerException(sc.getOffset(), sc.getLineNumberStart(), sc.getColumnNumberStart(), msg);
	}
	private static class OpcodeWrapper extends Attribute_Code.Opcode {
		public Object info = null;
		public OpcodeWrapper(Attribute_Code.Opcode op) {
			super.offset = op.offset;
			super.opcode = op.opcode;
			super.operands = op.operands;
		}
		public OpcodeWrapper(int offset, byte opcode, byte[][] operands, Object info) {
			super(offset, opcode, operands);
			this.info = info;
		}
	}
	private class LabeledInstructions {
		Attribute_Code.Opcode[] codes;
		Hashtable labels;
		int codeLength;
		public LabeledInstructions(Attribute_Code.Opcode[] codes, Hashtable labels, int code_length) {
			this.codes = codes;
			this.labels = labels;
			this.codeLength = code_length;
		}
	}
	public static void main(String[] args) throws Exception {
		SourceCodeParser pa = new SourceCodeParser(""e:\\work\\TestClass.jc"");
		pa.parse();
	}
}",1,0,0,0
"public final class ContentLength extends HeaderLong {
	public ContentLength(Long value) {
		super(value);
	}
	public static ContentLength forString(String value) {
		if (value == null)return null;
		return new ContentLength(value);
	}
	private ContentLength(String value) {
		super(value);
	}
}",0,0,0,0
"static final long hash(long key) {
	 long hash = key * HashMixer;
	 hash ^= hash >>> R;
	 hash *= HashMixer;
	 return hash;
 }",0,0,0,0
"public class RedirectRequestTarget implements IRequestTarget{
	private final String redirectUrl;
	public RedirectRequestTarget(String redirectUrl){
		if (Strings.isEmpty(redirectUrl)){
			throw new IllegalArgumentException(""The redirect URL passed to the RedirectRequestTarget constructor can not be null or empty."");
		}
		this.redirectUrl = redirectUrl;
	}
	public void detach(RequestCycle requestCycle){
	}
	public void respond(RequestCycle requestCycle){
		Response response = requestCycle.getResponse();
		response.reset();
		if (redirectUrl.startsWith(""/"")){
			RequestContext rc = RequestContext.get();
			if (rc.isPortletRequest() && ((PortletRequestContext)rc).isEmbedded()){
				response.redirect(redirectUrl);
			}
			else{
				String location = RequestCycle.get().getProcessor().getRequestCodingStrategy().rewriteStaticRelativeUrl(redirectUrl.substring(1));
				if (location.startsWith(""./"")){
					location = location.length() == 2 ? ""."" : location.substring(2);
				}
				response.redirect(location);
			}
		}
		else if (redirectUrl.contains("":{
			response.redirect(redirectUrl);
		}
		else{
			response.redirect(RequestCycle.get().getRequest().getRelativePathPrefixToWicketHandler() +redirectUrl);
		}
	}
}",0,0,0,0
"public class ContextAwareFactory implements RepositoryFactory {
	public static final String REPOSITORY_TYPE = ""openrdf:ContextAwareRepository"";
	public String getRepositoryType() {
		return REPOSITORY_TYPE;
	}
	public RepositoryImplConfig getConfig() {
		return new ContextAwareConfig();
	}
	public Repository getRepository(RepositoryImplConfig configuration) throws RepositoryConfigException {
		if (configuration instanceof ContextAwareConfig) {
			ContextAwareConfig config = (ContextAwareConfig) configuration;
			ContextAwareRepository repo = new ContextAwareRepository();
			repo.setIncludeInferred(config.isIncludeInferred());
			repo.setMaxQueryTime(config.getMaxQueryTime());
			repo.setQueryLanguage(config.getQueryLanguage());
			repo.setBaseURI(config.getBaseURI());
			repo.setReadContexts(config.getReadContexts());
			repo.setAddContexts(config.getAddContexts());
			repo.setRemoveContexts(config.getRemoveContexts());
			repo.setArchiveContexts(config.getArchiveContexts());
			repo.setInsertContext(config.getInsertContext());
			return repo;
		}
		throw new RepositoryConfigException(""Invalid configuration class: "" + configuration.getClass());
	}
}",0,0,0,0
"public boolean execute(double key, float val);",0,0,0,0
"public class POCastDummy extends ExpressionOperator {
	 private static final long serialVersionUID = 1L;
	 public POCastDummy(OperatorKey k) {
		 super(k);
	 }
	 public POCastDummy(OperatorKey k, int rp) {
		 super(k, rp);
	 }
	 public void visit(PhyPlanVisitor v) throws VisitorException {
	 }
	 public String name() {
		 return ""Cast - "" + mKey.toString();
	 }
	 public boolean supportsMultipleInputs() {
		 return false;
	 }
	 public Result getNextInteger() throws ExecException {
		 Result res = inputs.get(0).getNextInteger();
		 if(res.returnStatus != POStatus.STATUS_OK){
			 return res;
		 }
		 if(res.result instanceof DataByteArray){
			 String rslt = ((DataByteArray)res.result).toString();
			 res.result = Integer.parseInt(rslt.trim());
			 return res;
		 }
		 return new Result();
	 }
	 public Result getNextString() throws ExecException {
		 Result res = inputs.get(0).getNextString();
		 if(res.returnStatus != POStatus.STATUS_OK){
			 return res;
		 }
		 if(res.result instanceof DataByteArray){
			 String rslt = ((DataByteArray)res.result).toString();
			 res.result = rslt;
			 return res;
		 }
		 return new Result();
	 }
	 protected List<ExpressionOperator> getChildExpressions() {
		 return null;
	 }
	 public Tuple illustratorMarkup(Object in, Object out, int eqClassIndex) {
		 return null;
	 }
}",1,0,0,0
"static void loadITAGs() {
	if (itags != null) {
		return;
	}
	itags = new HashMap<Integer, String>();
	itags.put(5, ""320 x 240"");
	itags.put(6, ""450 x 270"");
	itags.put(13, ""Small"");
	itags.put(17, ""176 x 144"");
	itags.put(18, ""480 x 360"");
	itags.put(22, ""1280 x 720"");
	itags.put(34, ""480 x 360"");
	itags.put(35, ""640 x 480 "");
	itags.put(36, ""320 x 240"");
	itags.put(37, ""1920 x 1080"");
	itags.put(38, ""2048 x 1080"");
	itags.put(43, ""480 x 360"");
	itags.put(44, ""640 x 480"");
	itags.put(45, ""1280 x 720"");
	itags.put(46, ""1920 x 1080"");
	itags.put(59, ""854 x 480"");
	itags.put(78, ""854 x 480"");
	itags.put(82, ""480 x 360 3D"");
	itags.put(83, ""640 x 480 3D"");
	itags.put(84, ""1280 x 720 3D"");
	itags.put(85, ""1920 x 1080 3D"");
	itags.put(100, ""480 x 360 3D"");
	itags.put(101, ""640 x 480 3D"");
	itags.put(102, ""1280 x 720 3D"");
	itags.put(133, ""320 x 240"");
	itags.put(134, ""480 x 360"");
	itags.put(135, ""640 x 480"");
	itags.put(136, ""1280 x 720"");
	itags.put(137, ""1920 x 1080"");
	itags.put(139, ""Low bitrate"");
	itags.put(140, ""Med bitrate"");
	itags.put(141, ""Hi bitrate"");
	itags.put(160, ""256 x 144"");
	itags.put(167, ""360p"");
	itags.put(168, ""480p"");
	itags.put(169, ""720p"");
	itags.put(170, ""1080p"");
	itags.put(171, ""Med bitrate"");
	itags.put(172, ""Hi bitrate"");
	itags.put(218, ""480"");
	itags.put(219, ""480"");
	itags.put(242, ""320 x 240"");
	itags.put(243, ""480 x 360"");
	itags.put(244, ""640 x 480"");
	itags.put(245, ""640 x 480"");
	itags.put(246, ""640 x 480"");
	itags.put(247, ""1280 x 720"");
	itags.put(248, ""1920 x 1080"");
	itags.put(264, ""1440p"");
	itags.put(266, ""2160p"");
	itags.put(271, ""1440p"");
	itags.put(272, ""2160p"");
	itags.put(278, ""144p"");
	itags.put(298, ""720p"");
	itags.put(302, ""720p"");
	itags.put(303, ""1080p"");
	itags.put(308, ""1440p"");
	itags.put(313, ""2160p"");
	itags.put(315, ""2160p"");
	itags.put(299, ""2160p"");
}",0,0,1,0
"private static class SpscArrayQueueReservoir extends AbstractReservoir {
	 private final int maxSpinMillis = 10;
	 private final SpscArrayQueue<Object> queue;
	 private SpscArrayQueueReservoir(final String id, final int capacity) {
		 super(id);
		 queue = new SpscArrayQueue<>(capacity);
	 }
	 public Tuple sweep() {
		 Object o;
		 final SpscArrayQueue<Object> queue = this.queue;
		 final Sink<Object> sink = getSink();
		 while ((o = queue.peek()) != null) {
			 if (o instanceof Tuple) {
				 return (Tuple)o;
			 }
			 count++;
			 sink.put(queue.poll());
		 }
		 return null;
	 }
	 public boolean add(Object o) {
		 return queue.add(o);
	 }
	 public Object remove() {
		 return queue.remove();
	 }
	 public Object peek() {
		 return queue.peek();
	 }
	 public int size(final boolean dataTupleAware) {
		 return queue.size();
	 }
	 public int capacity() {
		 return queue.capacity();
	 }
	 public int drainTo(final Collection<? super Object> container) {
		 return queue.drain(new MessagePassingQueue.Consumer<Object>() {
			 public void accept(Object o) {
				 container.add(o);
			 }
		 }
		);
	 }
	 public boolean offer(Object o) {
		 return queue.offer(o);
	 }
	 public void put(Object o) throws InterruptedException {
		 long spinMillis = 0;
		 final SpscArrayQueue<Object> queue = this.queue;
		 while (!queue.offer(o)) {
			 sleep(spinMillis);
			 spinMillis = Math.min(maxSpinMillis, spinMillis + 1);
		 }
	 }
	 public boolean offer(Object o, long timeout, TimeUnit unit) throws InterruptedException {
		 throw new UnsupportedOperationException();
	 }
	 public Object take() throws InterruptedException {
		 throw new UnsupportedOperationException();
	 }
	 public Object poll(long timeout, TimeUnit unit) throws InterruptedException {
		 throw new UnsupportedOperationException();
	 }
	 public int remainingCapacity() {
		 final SpscArrayQueue<Object> queue = this.queue;
		 return queue.capacity() - queue.size();
	 }
	 public boolean remove(Object o) {
		 return queue.remove(o);
	 }
	 public boolean contains(Object o) {
		 return queue.contains(o);
	 }
	 public int drainTo(final Collection<? super Object> collection, int maxElements) {
		 return queue.drain(new MessagePassingQueue.Consumer<Object>() {
			 public void accept(Object o) {
				 collection.add(o);
			 }
		 }
		, maxElements);
	 }
	 public Object poll() {
		 return queue.poll();
	 }
	 public Object element() {
		 return queue.element();
	 }
	 public boolean isEmpty() {
		 return queue.peek() == null;
	 }
	 public Iterator<Object> iterator() {
		 return queue.iterator();
	 }
	 public Object[] toArray() {
		 return queue.toArray();
	 }
	 public <T> T[] toArray(T[] a) {
		 return queue.toArray(a);
	 }
	 public boolean containsAll(Collection<?> c) {
		 return queue.containsAll(c);
	 }
	 public boolean addAll(Collection<?> c) {
		 return queue.addAll(c);
	 }
	 public boolean removeAll(Collection<?> c) {
		 return queue.removeAll(c);
	 }
	 public boolean retainAll(Collection<?> c) {
		 return queue.retainAll(c);
	 }
	 public int size() {
		 return queue.size();
	 }
	 public void clear() {
		 queue.clear();
	 }
	 protected SpscArrayQueue<Object> getQueue() {
		 return queue;
	 }
 }",0,0,0,0
"public void run() {
	 byte[] inbuf = new byte[2048];
	 int bytesread;
	 int bytesleft;
	 int br;
	 int offset;
	 boolean eos;
	 try {
		 ExchangeSessionFactory.checkConfig();
		 while (true) {
			 offset = 0;
			 bytesread = is.read(inbuf, offset, 1);
			 if (bytesread < 0) {
				 break;
			 }
			 if (inbuf[offset++] != (Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR)) {
				 continue;
			 }
			 bytesread = is.read(inbuf, offset, 1);
			 if (bytesread < 0) {
				 break;
			 }
			 int seqlen = inbuf[offset++];
			 if ((seqlen & 0x80) == 0x80) {
				 int seqlenlen = seqlen & 0x7f;
				 bytesread = 0;
				 eos = false;
				 while (bytesread < seqlenlen) {
					 br = is.read(inbuf, offset + bytesread, seqlenlen - bytesread);
					 if (br < 0) {
						 eos = true;
						 break;
					 }
					 bytesread += br;
				 }
				 if (eos) {
					 break;
				 }
				 seqlen = 0;
				 for (int i = 0;
				 i < seqlenlen;
				 i++) {
					 seqlen = (seqlen << 8) + (inbuf[offset + i] & 0xff);
				 }
				 offset += bytesread;
			 }
			 bytesleft = seqlen;
			 if ((offset + bytesleft) > inbuf.length) {
				 byte[] nbuf = new byte[offset + bytesleft];
				 System.arraycopy(inbuf, 0, nbuf, 0, offset);
				 inbuf = nbuf;
			 }
			 while (bytesleft > 0) {
				 bytesread = is.read(inbuf, offset, bytesleft);
				 if (bytesread < 0) {
					 break;
				 }
				 offset += bytesread;
				 bytesleft -= bytesread;
			 }
			 DavGatewayTray.switchIcon();
			 handleRequest(inbuf, offset);
		 }
	 }
	 catch (SocketException e) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
	 }
	 catch (SocketTimeoutException e) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_CLOSE_CONNECTION_ON_TIMEOUT""));
	 }
	 catch (Exception e) {
		 DavGatewayTray.log(e);
		 try {
			 sendErr(0, LDAP_REP_BIND, e);
		 }
		 catch (IOException e2) {
			 DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
		 }
	 }
	 finally {
		 synchronized (searchThreadMap) {
			 for (SearchRunnable searchRunnable : searchThreadMap.values()) {
				 searchRunnable.abandon();
			 }
		 }
		 close();
	 }
	 DavGatewayTray.resetIcon();
 }",0,0,1,0
"public class InitMethod$JAXB extends JAXBObject<InitMethod> {
	 public InitMethod$JAXB() {
	 super(InitMethod.class, null, new QName(""http: }
	 public static InitMethod readInitMethod(final XoXMLStreamReader reader, final RuntimeContext context) throws Exception {
		 return _read(reader, context);
	 }
	 public static void writeInitMethod(final XoXMLStreamWriter writer, final InitMethod initMethod, final RuntimeContext context) throws Exception {
		 _write(writer, initMethod, context);
	 }
	 public void write(final XoXMLStreamWriter writer, final InitMethod initMethod, final RuntimeContext context) throws Exception {
		 _write(writer, initMethod, context);
	 }
	 public final static InitMethod _read(final XoXMLStreamReader reader, RuntimeContext context) throws Exception {
		 if (reader.isXsiNil()) {
			 return null;
		 }
		 if (context == null) {
			 context = new RuntimeContext();
		 }
		 final InitMethod initMethod = new InitMethod();
		 context.beforeUnmarshal(initMethod, LifecycleCallback.NONE);
		 final QName xsiType = reader.getXsiType();
		 if (xsiType != null) {
			 if ((""init-methodType"" != xsiType.getLocalPart()) || (""http: return context.unexpectedXsiType(reader, InitMethod.class);
		 }
	 }
	 for (final Attribute attribute : reader.getAttributes()) {
		 if ((""id"" == attribute.getLocalName()) && (("""" == attribute.getNamespace()) || (attribute.getNamespace() == null))) {
			 final String id = Adapters.collapsedStringAdapterAdapter.unmarshal(attribute.getValue());
			 context.addXmlId(reader, id, initMethod);
			 initMethod.id = id;
		 }
		 else if (XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI != attribute.getNamespace()) {
			 context.unexpectedAttribute(attribute, new QName("""", ""id""));
		 }
	 }
	 for (final XoXMLStreamReader elementReader : reader.getChildElements()) {
		 if ((""create-method"" == elementReader.getLocalName()) && (""http: final NamedMethod createMethod = readNamedMethod(elementReader, context);
		 initMethod.createMethod = createMethod;
	 }
	 else if ((""bean-method"" == elementReader.getLocalName()) && (""http: final NamedMethod beanMethod = readNamedMethod(elementReader, context);
	 initMethod.beanMethod = beanMethod;
 }
 else {
 context.unexpectedElement(elementReader, new QName(""http: }
 }
 context.afterUnmarshal(initMethod, LifecycleCallback.NONE);
 return initMethod;
 }
 public final InitMethod read(final XoXMLStreamReader reader, final RuntimeContext context) throws Exception {
 return _read(reader, context);
 }
 public final static void _write(final XoXMLStreamWriter writer, final InitMethod initMethod, RuntimeContext context) throws Exception {
 if (initMethod == null) {
 writer.writeXsiNil();
 return;
 }
 if (context == null) {
 context = new RuntimeContext();
 }
 final String prefix = writer.getUniquePrefix(""http: if (InitMethod.class != initMethod.getClass()) {
 context.unexpectedSubclass(writer, initMethod, InitMethod.class);
 return;
 }
 context.beforeMarshal(initMethod, LifecycleCallback.NONE);
 final String idRaw = initMethod.id;
 if (idRaw != null) {
 String id = null;
 try {
	 id = Adapters.collapsedStringAdapterAdapter.marshal(idRaw);
 }
 catch (final Exception e) {
	 context.xmlAdapterError(initMethod, ""id"", CollapsedStringAdapter.class, String.class, String.class, e);
 }
 writer.writeAttribute("""", """", ""id"", id);
 }
 final NamedMethod createMethod = initMethod.createMethod;
 if (createMethod != null) {
 writer.writeStartElement(prefix, ""create-method"", ""http: writeNamedMethod(writer, createMethod, context);
 writer.writeEndElement();
 }
 else {
 context.unexpectedNullValue(initMethod, ""createMethod"");
 }
 final NamedMethod beanMethod = initMethod.beanMethod;
 if (beanMethod != null) {
 writer.writeStartElement(prefix, ""bean-method"", ""http: writeNamedMethod(writer, beanMethod, context);
 writer.writeEndElement();
 }
 else {
 context.unexpectedNullValue(initMethod, ""beanMethod"");
 }
 context.afterMarshal(initMethod, LifecycleCallback.NONE);
 }
}",0,0,0,0
"public static class RoundUInt1 implements DrillSimpleFunc {
	 UInt1Holder in;
	 UInt1Holder out;
	 public void setup() {
	 }
	 public void eval() {
		 out.value = in.value;
	 }
 }",0,0,0,0
"private EntityCollection createETStreamOnComplexProp(Edm edm, OData odata) {
	 EntityCollection entityCollection = new EntityCollection();
	 Link readLink = new Link();
	 readLink.setRel(Constants.NS_MEDIA_READ_LINK_REL);
	 readLink.setHref(""readLink"");
	 Entity entity = new Entity();
	 entity.addProperty(createPrimitive(""PropertyStream"", createImage(""darkturquoise"")));
	 readLink.setInlineEntity(entity);
	 Link readLink1 = new Link();
	 readLink1.setRel(Constants.NS_MEDIA_READ_LINK_REL);
	 readLink1.setHref(""readLink"");
	 entity = new Entity();
	 entity.addProperty(createPrimitive(""PropertyEntityStream"", createImage(""darkturquoise"")));
	 readLink1.setInlineEntity(entity);
	 entityCollection.getEntities().add(new Entity() .addProperty(createPrimitive(""PropertyInt16"", Short.MAX_VALUE)) .addProperty(createPrimitive(""PropertyInt32"", Integer.MAX_VALUE)) .addProperty(new Property(null, ""PropertyEntityStream"", ValueType.PRIMITIVE, readLink1)) .addProperty(createComplex(""PropertyCompWithStream"", ComplexTypeProvider.nameCTWithStreamProp.getFullQualifiedNameAsString(), new Property(null, ""PropertyStream"", ValueType.PRIMITIVE, readLink), createComplex(""PropertyComp"", ComplexTypeProvider.nameCTTwoPrim.getFullQualifiedNameAsString(), createPrimitive(""PropertyInt16"", (short) 333), createPrimitive(""PropertyString"", ""TEST123"")))));
	 Link editLink = new Link();
	 editLink.setRel(Constants.NS_MEDIA_EDIT_LINK_REL);
	 editLink.setHref(""http: editLink.setMediaETag(""eTag"");
	 editLink.setType(""image/jpeg"");
	 entity = new Entity();
	 entity.addProperty(createPrimitive(""PropertyStream"", createImage(""royalblue"")));
	 editLink.setInlineEntity(entity);
	 Link editLink2 = new Link();
	 editLink2.setRel(Constants.NS_MEDIA_EDIT_LINK_REL);
	 editLink2.setHref(""http: editLink2.setMediaETag(""eTag"");
	 editLink2.setType(""image/jpeg"");
	 entity = new Entity();
	 entity.addProperty(createPrimitive(""PropertyEntityStream"", createImage(""royalblue"")));
	 editLink2.setInlineEntity(entity);
	 entityCollection.getEntities().add(new Entity() .addProperty(createPrimitive(""PropertyInt16"", (short) 7)) .addProperty(createPrimitive(""PropertyInt32"", (Integer) 10)) .addProperty(new Property(null, ""PropertyEntityStream"", ValueType.PRIMITIVE, editLink2)) .addProperty(createComplex(""PropertyCompWithStream"", ComplexTypeProvider.nameCTWithStreamProp.getFullQualifiedNameAsString(), new Property(null, ""PropertyStream"", ValueType.PRIMITIVE, editLink), createComplex(""PropertyComp"", ComplexTypeProvider.nameCTTwoPrim.getFullQualifiedNameAsString(), createPrimitive(""PropertyInt16"", (short) 333), createPrimitive(""PropertyString"", ""TEST123"")))));
	 setEntityType(entityCollection, edm.getEntityType(EntityTypeProvider.nameETStreamOnComplexProp));
	 createEntityId(edm, odata, ""ESStreamOnComplexProp"", entityCollection);
	 createOperations(""ESStreamOnComplexProp"", entityCollection, EntityTypeProvider.nameETStreamOnComplexProp);
	 return entityCollection;
 }",0,0,1,0
"public class Application{
	 private static Framework m_framework = null;
	 public static void main(String[] args) {
		 String[] locations = args != null ? args : new String[0];
		 System.out.println(""\nWelcome to My Launcher"");
		 System.out.println(""======================\n"");
		 try {
			 Map<String, String> config = ConfigUtil.createConfig();
			 m_framework = createFramework(config);
			 m_framework.init();
			 m_framework.start();
			 installAndStartBundles(locations);
			 m_framework.waitForStop(0);
			 System.exit(0);
		 }
		 catch (Exception ex) {
			 System.err.println(""Could not create framework: "" + ex);
			 ex.printStackTrace();
			 System.exit(-1);
		 }
	 }
	 private static Framework createFramework(Map<String, String> config) {
		 ServiceLoader<FrameworkFactory> factoryLoader = ServiceLoader.load(FrameworkFactory.class);
		 for(FrameworkFactory factory : factoryLoader){
			 return factory.newFramework(config);
		 }
		 throw new IllegalStateException(""Unable to load FrameworkFactory service."");
	 }
	 private static void installAndStartBundles(String... bundleLocations) throws BundleException {
		 BundleContext bundleContext = m_framework.getBundleContext();
		 Activator hostActivator = new Activator();
		 hostActivator.start(bundleContext);
		 for (String location : bundleLocations) {
			 Bundle addition = bundleContext.installBundle(location);
			 addition.start();
		 }
	 }
}",0,0,0,0
"public final Link<Void> moveDownLink(final String id, final ListItem<T> item){
	return new Link<Void>(id){
		private static final long serialVersionUID = 1L;
		public void onClick(){
			final int index = item.getIndex();
			if (index != -1){
				addStateChange(new Change(){
					private static final long serialVersionUID = 1L;
					final int oldIndex = index;
					public void undo(){
						Collections.swap(getList(), oldIndex + 1, oldIndex);
					}
				}
				);
				Collections.swap(getList(), index, index + 1);
				ListView.this.removeAll();
			}
		}
		public boolean isEnabled(){
			return item.getIndex() != (getList().size() - 1);
		}
	}
	;
}",0,0,0,0
"protected EntityDecl resolveNonCharEntity() throws XMLStreamException {
	 int avail = mInputEnd - mInputPtr;
	 if (avail < 6) {
		 --mInputPtr;
		 if (!ensureInput(6)) {
			 avail = inputInBuffer();
			 if (avail < 3) {
				 throwUnexpectedEOF(SUFFIX_IN_ENTITY_REF);
			 }
		 }
		 else {
			 avail = 6;
		 }
		 ++mInputPtr;
	 }
	 char c = mInputBuffer[mInputPtr];
	 if (c == '#') {
		 return null;
	 }
	 if (c == 'a') {
		 char d = mInputBuffer[mInputPtr+1];
		 if (d == 'm') {
			 if (avail >= 4 && mInputBuffer[mInputPtr+2] == 'p' && mInputBuffer[mInputPtr+3] == ';
			') {
				 return null;
			 }
		 }
		 else if (d == 'p') {
			 if (avail >= 5 && mInputBuffer[mInputPtr+2] == 'o' && mInputBuffer[mInputPtr+3] == 's' && mInputBuffer[mInputPtr+4] == ';
			') {
				 return null;
			 }
		 }
	 }
	 else if (c == 'l') {
		 if (avail >= 3 && mInputBuffer[mInputPtr+1] == 't' && mInputBuffer[mInputPtr+2] == ';
		') {
			 return null;
		 }
	 }
	 else if (c == 'g') {
		 if (avail >= 3 && mInputBuffer[mInputPtr+1] == 't' && mInputBuffer[mInputPtr+2] == ';
		') {
			 return null;
		 }
	 }
	 else if (c == 'q') {
		 if (avail >= 5 && mInputBuffer[mInputPtr+1] == 'u' && mInputBuffer[mInputPtr+2] == 'o' && mInputBuffer[mInputPtr+3] == 't' && mInputBuffer[mInputPtr+4] == ';
		') {
			 return null;
		 }
	 }
	 ++mInputPtr;
	 String id = parseEntityName(c);
	 mCurrName = id;
	 return findEntity(id, null);
 }",0,0,1,0
"class DirectExecutorService implements ExecutorService {
	static final DirectExecutorService INSTANCE = new DirectExecutorService();
	private boolean isShutdown = false;
	public void shutdown() {
		isShutdown = true;
	}
	public List<Runnable> shutdownNow() {
		isShutdown = true;
		return Collections.emptyList();
	}
	public boolean isShutdown() {
		return isShutdown;
	}
	public boolean isTerminated() {
		return isShutdown;
	}
	public boolean awaitTermination(long timeout, TimeUnit unit) {
		return isShutdown;
	}
	public <T> Future<T> submit( Callable<T> task) {
		try {
			T result = task.call();
			return new CompletedFuture<>(result, null);
		}
		 catch (Exception e) {
			return new CompletedFuture<>(null, e);
		}
	}
	public <T> Future<T> submit( Runnable task, T result) {
		task.run();
		return new CompletedFuture<>(result, null);
	}
	public Future<?> submit( Runnable task) {
		task.run();
		return new CompletedFuture<>(null, null);
	}
	public <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) {
		ArrayList<Future<T>> result = new ArrayList<>();
		for (Callable<T> task : tasks) {
			try {
				result.add(new CompletedFuture<>(task.call(), null));
			}
			 catch (Exception e) {
				result.add(new CompletedFuture<>(null, e));
			}
		}
		return result;
	}
	public <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) {
		long end = System.currentTimeMillis() + unit.toMillis(timeout);
		Iterator<? extends Callable<T>> iterator = tasks.iterator();
		ArrayList<Future<T>> result = new ArrayList<>();
		while (end > System.currentTimeMillis() && iterator.hasNext()) {
			Callable<T> callable = iterator.next();
			try {
				result.add(new CompletedFuture<>(callable.call(), null));
			}
			 catch (Exception e) {
				result.add(new CompletedFuture<>(null, e));
			}
		}
		while (iterator.hasNext()) {
			iterator.next();
			result.add(new Future<T>() {
				public boolean cancel(boolean mayInterruptIfRunning) {
					return false;
				}
				public boolean isCancelled() {
					return true;
				}
				public boolean isDone() {
					return false;
				}
				public T get() {
					throw new CancellationException(""Task has been cancelled."");
				}
				public T get(long timeout, TimeUnit unit) {
					throw new CancellationException(""Task has been cancelled."");
				}
			}
			);
		}
		return result;
	}
	public <T> T invokeAny( Collection<? extends Callable<T>> tasks) throws ExecutionException {
		Exception exception = null;
		for (Callable<T> task : tasks) {
			try {
				return task.call();
			}
			 catch (Exception e) {
				exception = e;
			}
		}
		throw new ExecutionException(""No tasks finished successfully."", exception);
	}
	public <T> T invokeAny( Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit) throws ExecutionException, TimeoutException {
		long end = System.currentTimeMillis() + unit.toMillis(timeout);
		Exception exception = null;
		Iterator<? extends Callable<T>> iterator = tasks.iterator();
		while (end > System.currentTimeMillis() && iterator.hasNext()) {
			Callable<T> callable = iterator.next();
			try {
				return callable.call();
			}
			 catch (Exception e) {
				exception = e;
			}
		}
		if (iterator.hasNext()) {
			throw new TimeoutException(""Could not finish execution of tasks within time."");
		}
		 else {
			throw new ExecutionException(""No tasks finished successfully."", exception);
		}
	}
	public void execute( Runnable command) {
		command.run();
	}
	static class CompletedFuture<V> implements Future<V> {
		private final V value;
		private final Exception exception;
		CompletedFuture(V value, Exception exception) {
			this.value = value;
			this.exception = exception;
		}
		public boolean cancel(boolean mayInterruptIfRunning) {
			return false;
		}
		public boolean isCancelled() {
			return false;
		}
		public boolean isDone() {
			return true;
		}
		public V get() throws ExecutionException {
			if (exception != null) {
				throw new ExecutionException(exception);
			}
			 else {
				return value;
			}
		}
		public V get(long timeout, TimeUnit unit) throws ExecutionException {
			return get();
		}
	}
}",1,0,0,0
"private static class Wrap<T> extends DoFn<T, KV<Long, T>> {
	 public void processElement(ProcessContext ctx) {
		 ctx.output(KV.of(ctx.timestamp().getMillis(), ctx.element()));
	 }
 }",0,1,0,0
"public class CheProductInfoDataProvider extends ProductInfoDataProviderImpl {
	 private final LocalizationConstant locale;
	 private final Resources resources;
	 public CheProductInfoDataProvider(LocalizationConstant locale, Resources resources) {
		 this.locale = locale;
		 this.resources = resources;
	 }
	 public String getName() {
		 return locale.getProductName();
	 }
	 public String getSupportLink() {
		 return locale.getSupportLink();
	 }
	 public String getDocumentTitle() {
		 return locale.cheTabTitle();
	 }
	 public String getDocumentTitle(String workspaceName) {
		 return locale.cheTabTitle(workspaceName);
	 }
	 public SVGResource getLogo() {
		 return resources.logo();
	 }
	 public SVGResource getWaterMarkLogo() {
		 return resources.waterMarkLogo();
	 }
	 public String getSupportTitle() {
		 return locale.supportTitle();
	 }
}",1,1,0,0
"public class LimitedSizeDataCollection<STORAGE_DATA extends ComparableStorageData> implements SWCollection<STORAGE_DATA> {
	 private final HashMap<STORAGE_DATA, LinkedList<STORAGE_DATA>> data;
	 private final int limitedSize;
	 private volatile boolean writing;
	 private volatile boolean reading;
	 LimitedSizeDataCollection(int limitedSize) {
		 this.data = new HashMap<>();
		 this.writing = false;
		 this.reading = false;
		 this.limitedSize = limitedSize;
	 }
	 public void finishWriting() {
		 writing = false;
	 }
	 public void writing() {
		 writing = true;
	 }
	 public boolean isWriting() {
		 return writing;
	 }
	 public void finishReading() {
		 reading = false;
	 }
	 public void reading() {
		 reading = true;
	 }
	 public boolean isReading() {
		 return reading;
	 }
	 public int size() {
		 return data.size();
	 }
	 public void clear() {
		 data.clear();
	 }
	 public boolean containsKey(STORAGE_DATA key) {
		 throw new UnsupportedOperationException(""Limited size data collection doesn't support containsKey operation."");
	 }
	 public STORAGE_DATA get(STORAGE_DATA key) {
		 throw new UnsupportedOperationException(""Limited size data collection doesn't support get operation."");
	 }
	 public void put(STORAGE_DATA value) {
		 LinkedList<STORAGE_DATA> storageDataList = this.data.get(value);
		 if (storageDataList == null) {
			 storageDataList = new LinkedList<>();
			 data.put(value, storageDataList);
		 }
		 if (storageDataList.size() < limitedSize) {
			 storageDataList.add(value);
			 return;
		 }
		 for (int i = 0;
		 i < storageDataList.size();
		 i++) {
			 STORAGE_DATA storageData = storageDataList.get(i);
			 if (value.compareTo(storageData) <= 0) {
				 if (i == 0) {
				 }
				 else {
					 storageDataList.add(i, value);
					 storageDataList.removeFirst();
				 }
				 return;
			 }
		 }
		 storageDataList.addLast(value);
		 storageDataList.removeFirst();
	 }
	 public Collection<STORAGE_DATA> collection() {
		 List<STORAGE_DATA> collection = new ArrayList<>();
		 data.values().forEach(e -> e.forEach(collection::add));
		 return collection;
	 }
}",0,1,0,0
"public class LightSample {
	 private Ray shadowRay;
	 private Color ldiff;
	 private Color lspec;
	 LightSample next;
	 public LightSample() {
		 ldiff = lspec = null;
		 shadowRay = null;
		 next = null;
	 }
	 boolean isValid() {
		 return ldiff != null && lspec != null && shadowRay != null;
	 }
	 public void setShadowRay(Ray shadowRay) {
		 this.shadowRay = shadowRay;
	 }
	 public final void traceShadow(ShadingState state) {
		 Color opacity = state.traceShadow(shadowRay);
		 Color.blend(ldiff, Color.BLACK, opacity, ldiff);
		 Color.blend(lspec, Color.BLACK, opacity, lspec);
	 }
	 public Ray getShadowRay() {
		 return shadowRay;
	 }
	 public Color getDiffuseRadiance() {
		 return ldiff;
	 }
	 public Color getSpecularRadiance() {
		 return lspec;
	 }
	 public void setRadiance(Color d, Color s) {
		 ldiff = d.copy();
		 lspec = s.copy();
	 }
	 public float dot(Vector3 v) {
		 return shadowRay.dot(v);
	 }
}",0,1,0,0
"public class XMLInputSource {
	 protected String fPublicId;
	 protected String fSystemId;
	 protected String fBaseSystemId;
	 protected InputStream fByteStream;
	 protected Reader fCharStream;
	 protected String fEncoding;
	 public XMLInputSource(String publicId, String systemId, String baseSystemId) {
		 fPublicId = publicId;
		 fSystemId = systemId;
		 fBaseSystemId = baseSystemId;
	 }
	 public XMLInputSource(XMLResourceIdentifier resourceIdentifier) {
		 fPublicId = resourceIdentifier.getPublicId();
		 fSystemId = resourceIdentifier.getLiteralSystemId();
		 fBaseSystemId = resourceIdentifier.getBaseSystemId();
	 }
	 public XMLInputSource(String publicId, String systemId, String baseSystemId, InputStream byteStream, String encoding) {
		 fPublicId = publicId;
		 fSystemId = systemId;
		 fBaseSystemId = baseSystemId;
		 fByteStream = byteStream;
		 fEncoding = encoding;
	 }
	 public XMLInputSource(String publicId, String systemId, String baseSystemId, Reader charStream, String encoding) {
		 fPublicId = publicId;
		 fSystemId = systemId;
		 fBaseSystemId = baseSystemId;
		 fCharStream = charStream;
		 fEncoding = encoding;
	 }
	 public void setPublicId(String publicId) {
		 fPublicId = publicId;
	 }
	 public String getPublicId() {
		 return fPublicId;
	 }
	 public void setSystemId(String systemId) {
		 fSystemId = systemId;
	 }
	 public String getSystemId() {
		 return fSystemId;
	 }
	 public void setBaseSystemId(String baseSystemId) {
		 fBaseSystemId = baseSystemId;
	 }
	 public String getBaseSystemId() {
		 return fBaseSystemId;
	 }
	 public void setByteStream(InputStream byteStream) {
		 fByteStream = byteStream;
	 }
	 public InputStream getByteStream() {
		 return fByteStream;
	 }
	 public void setCharacterStream(Reader charStream) {
		 fCharStream = charStream;
	 }
	 public Reader getCharacterStream() {
		 return fCharStream;
	 }
	 public void setEncoding(String encoding) {
		 fEncoding = encoding;
	 }
	 public String getEncoding() {
		 return fEncoding;
	 }
 }",0,1,0,0
"public class DotGraph extends DotNode {
	 public boolean topLevel = false;
	 public Set<DotEdge> edges = new HashSet<DotEdge>();
	 public Set<DotNode> nodes = new HashSet<DotNode>();
	 public Map<String, String> edgeAttributes = new HashMap<String, String>();
	 public Map<String, String> nodeAttributes = new HashMap<String, String>();
	 public DotGraph(String name) {
		 super(name);
	 }
	 public String toString() {
		 String graphType = topLevel ? ""digraph "" : ""subgraph "";
		 StringBuilder sb = new StringBuilder(graphType);
		 sb.append(name);
		 sb.append(""{
			\n"");
			 for (Map.Entry<String, String> attr : attributes.entrySet()) sb.append(attr.getKey() + ""="" + attr.getValue() + "";
			\n"");
			 if (nodeAttributes.size() > 0) {
				 int index = 0;
				 sb.append(""node ["");
				 for (Map.Entry<String, String> attr : nodeAttributes.entrySet()) {
					 sb.append(attr.getKey() + ""="" + attr.getValue());
					 if (index < nodeAttributes.size() - 1) sb.append("", "");
					 index++;
				 }
				 sb.append(""];
				\n"");
			 }
			 if (edgeAttributes.size() > 0) {
				 int index = 0;
				 sb.append(""edge ["");
				 for (Map.Entry<String, String> attr : edgeAttributes.entrySet()) {
					 sb.append(attr.getKey() + ""="" + attr.getValue());
					 if (index < edgeAttributes.size() - 1) sb.append("", "");
					 index++;
				 }
				 sb.append(""];
				\n"");
			 }
			 for (DotNode node : nodes) sb.append(node.toString() + "";
			\n"");
			 for (DotEdge edge : edges) sb.append(edge.toString() + "";
			\n"");
		 sb.append(""}
		"");
		 return sb.toString();
	 }
	 public boolean equals(Object other) {
		 if (other != null && other instanceof DotGraph) {
			 DotGraph graph = (DotGraph) other;
			 return graph.getLabel().equals(getLabel()) && edges.equals(graph.edges) && nodes.equals(graph.nodes);
		 }
		 return false;
	 }
	 public int hashCode() {
		 return getLabel().hashCode() * edgeAttributes.hashCode() * nodeAttributes.hashCode();
	 }
	 private Set<DotNode> getRootNodes() {
		 Set<DotNode> roots = new HashSet<DotNode>(nodes);
		 for (DotEdge edge : edges) roots.remove(edge.toNode);
		 return roots;
	 }
	 public boolean isomorphic(DotNode other) {
		 if (other instanceof DotGraph) {
			 DotGraph graph = (DotGraph) other;
			 return graph.getLabel().equals(getLabel()) && graph.getCanonicalName().equals(getCanonicalName());
		 }
		 return false;
	 }
	 public String getCanonicalName() {
		 StringBuilder sb = new StringBuilder("""");
		 ArrayList<String> children = new ArrayList<>();
		 Set<DotNode> roots = getRootNodes();
		 for (DotNode root : roots) children.add(root.getCanonicalName());
		 Collections.sort(children);
		 for (String nodeName : children) sb.append(nodeName);
		 sb.insert(0, '#');
		 sb.insert(sb.length(), '#');
		 return sb.toString();
	 }
	 public String getLabel() {
		 StringBuilder label = new StringBuilder(super.getLabel());
		 ArrayList<String> children = new ArrayList<>();
		 Set<DotNode> roots = getRootNodes();
		 for (DotNode root : roots) children.add(root.getLabel());
		 Collections.sort(children);
		 for (String nodeLabel : children) label.append(nodeLabel);
		 label.insert(0, '\""');
		 label.insert(label.length(), '\""');
		 return label.toString();
	 }
}",1,0,0,0
"public interface Customer1677Repository extends CrudRepository<Customer1677, Long> {
	List<Customer1677> findByLastName(String lastName);
}",0,0,0,0
"public void subdeflate(org.apache.cassandra.db.migration.avro.Migration mi) {
	 org.apache.cassandra.db.migration.avro.AddColumnFamily acf = new org.apache.cassandra.db.migration.avro.AddColumnFamily();
	 acf.cf = cfm.deflate();
	 mi.migration = acf;
 }",0,0,0,0
"public class Status {
	 public String getAction() {
		 return action;
	 }
	 public Result getResult() {
		 return result;
	 }
	 public String getDetails() {
		 return details;
	 }
	 private String action;
	 private Result result;
	 private String details;
	 public Status(String action, Result result, String details) {
		 this.action = action;
		 this.result = result;
		 this.details = details;
	 }
	 public static enum Result {
	 SUCCESSFUL, FAILED, }
	 public String toString() {
		 return String.format(""%s\t%s\t%s"", action, result, details);
	 }
}",0,1,0,0
"abstract class BinaryOperatorHelper extends OperatorHelper implements BiPredicate<Type, Type> {
	 BinaryOperatorHelper(Tag tag) {
		 super(tag);
	 }
	 final OperatorSymbol doLookup(Type t1, Type t2) {
		 return doLookup(op -> isBinaryOperatorApplicable(op, t1, t2));
	 }
	 boolean isBinaryOperatorApplicable(OperatorSymbol op, Type t1, Type t2) {
		 List<Type> formals = op.type.getParameterTypes();
		 return types.isSameType(formals.head, t1) && types.isSameType(formals.tail.head, t2);
	 }
	 final BinaryOperatorHelper addBinaryOperator(OperatorType arg1, OperatorType arg2, OperatorType res, int... opcode) {
		 operatorSuppliers = operatorSuppliers.prepend(() -> makeOperator(name, List.of(arg1, arg2), res, opcode));
		 return this;
	 }
	 abstract OperatorSymbol resolve(Type t1, Type t2);
 }",0,0,0,0
"public class Comment implements DocumentElement{
	private final String text;
	public Comment(final String text){
		this.text = text;
	}
	public String getText(){
		return text;
	}
	public String toString(){
		return ""[comment = '"" + text + ""']"";
	}
}",0,0,0,0
"private boolean generateChecksums() throws BuildException {
	 boolean checksumMatches = true;
	 FileInputStream fis = null;
	 FileOutputStream fos = null;
	 byte[] buf = new byte[readBufferSize];
	 try {
		 for (Enumeration e = includeFileMap.keys();
		 e.hasMoreElements();
		) {
			 messageDigest.reset();
			 File src = (File) e.nextElement();
			 if (!isCondition) {
				 log(""Calculating "" + algorithm + "" checksum for "" + src, Project.MSG_VERBOSE);
			 }
			 fis = new FileInputStream(src);
			 DigestInputStream dis = new DigestInputStream(fis, messageDigest);
			 while (dis.read(buf, 0, readBufferSize) != -1) {
			 }
			 dis.close();
			 fis.close();
			 fis = null;
			 byte[] fileDigest = messageDigest.digest ();
			 if (totalproperty != null) {
				 allDigests.put(src, fileDigest);
			 }
			 String checksum = createDigestString(fileDigest);
			 Object destination = includeFileMap.get(src);
			 if (destination instanceof java.lang.String) {
				 String prop = (String) destination;
				 if (isCondition) {
					 checksumMatches = checksumMatches && checksum.equals(property);
				 }
				 else {
					 getProject().setNewProperty(prop, checksum);
				 }
			 }
			 else if (destination instanceof java.io.File) {
				 if (isCondition) {
					 File existingFile = (File) destination;
					 if (existingFile.exists()) {
						 try {
							 String suppliedChecksum = readChecksum(existingFile);
							 checksumMatches = checksumMatches && checksum.equals(suppliedChecksum);
						 }
						 catch (BuildException be) {
							 checksumMatches = false;
						 }
					 }
					 else {
						 checksumMatches = false;
					 }
				 }
				 else {
					 File dest = (File) destination;
					 fos = new FileOutputStream(dest);
					 fos.write(format.format(new Object[] {
					 checksum, src.getName(), FileUtils .getRelativePath(dest .getParentFile(), src), FileUtils .getRelativePath(getProject() .getBaseDir(), src), src.getAbsolutePath() }
					).getBytes());
					 fos.write(StringUtils.LINE_SEP.getBytes());
					 fos.close();
					 fos = null;
				 }
			 }
		 }
		 if (totalproperty != null) {
			 Set keys = allDigests.keySet();
			 Object[] keyArray = keys.toArray();
			 Arrays.sort(keyArray, new Comparator() {
				 public int compare(Object o1, Object o2) {
					 File f1 = (File) o1;
					 File f2 = (File) o2;
					 return f1 == null ? (f2 == null ? 0 : -1) : (f2 == null ? 1 : getRelativeFilePath(f1) .compareTo(getRelativeFilePath(f2)));
				 }
			 }
			);
			 messageDigest.reset();
			 for (int i = 0;
			 i < keyArray.length;
			 i++) {
				 File src = (File) keyArray[i];
				 byte[] digest = (byte[]) allDigests.get(src);
				 messageDigest.update(digest);
				 String fileName = getRelativeFilePath(src);
				 messageDigest.update(fileName.getBytes());
			 }
			 String totalChecksum = createDigestString(messageDigest.digest());
			 getProject().setNewProperty(totalproperty, totalChecksum);
		 }
	 }
	 catch (Exception e) {
		 throw new BuildException(e, getLocation());
	 }
	 finally {
		 FileUtils.close(fis);
		 FileUtils.close(fos);
	 }
	 return checksumMatches;
 }",0,0,0,0
"protected BrowseXMLElement(ModeController pModeController, Vector ArrowLinkAdapters, HashMap IDToTarget);",0,0,0,0
"final class MSATokenRequest {
	 private static final String TAG = MSATokenRequest.class.getName();
	 public static final class GrantType {
		 public static final String CODE = ""authorization_code"";
		 public static final String REFRESH = ""refresh_token"";
	 }
	 public static final class Result {
		 public static enum Status {
		 SUCCESS, TRANSIENT_FAILURE, PERMANENT_FAILURE }
		 private final Status mStatus;
		 private String mAccessToken = null;
		 private String mRefreshToken = null;
		 private int mExpiresIn = 0;
		 Result(Status status, JSONObject responseJson) {
			 mStatus = status;
			 if (responseJson != null) {
				 mAccessToken = responseJson.optString(""access_token"", null);
				 mRefreshToken = responseJson.optString(""refresh_token"", null);
				 mExpiresIn = responseJson.optInt(""expires_in"");
			 }
		 }
		 public Status getStatus() {
			 return mStatus;
		 }
		 public String getAccessToken() {
			 return mAccessToken;
		 }
		 public String getRefreshToken() {
			 return mRefreshToken;
		 }
		 public int getExpiresIn() {
			 return mExpiresIn;
		 }
	 }
	 private final String mClientId;
	 private final String mGrantType;
	 private final String mScope;
	 private final String mRedirectUri;
	 public MSATokenRequest(String clientId, String grantType, String scope, String redirectUri) {
		 mClientId = clientId;
		 mGrantType = grantType;
		 mScope = scope;
		 mRedirectUri = redirectUri;
	 }
	 private static String getQueryString(List<Pair<String, String>> params) throws UnsupportedEncodingException {
		 StringBuilder queryStringBuilder = new StringBuilder();
		 boolean isFirstParam = true;
		 for (Pair<String, String> param : params) {
			 if (isFirstParam) {
				 isFirstParam = false;
			 }
			 else {
				 queryStringBuilder.append(""&"");
			 }
			 queryStringBuilder.append(URLEncoder.encode(param.first, ""UTF-8""));
			 queryStringBuilder.append(""="");
			 queryStringBuilder.append(URLEncoder.encode(param.second, ""UTF-8""));
		 }
		 return queryStringBuilder.toString();
	 }
	 public static AsyncOperation<MSATokenRequest.Result> requestAsync( final String clientId, final String grantType, final String scope, final String redirectUri, final String token) {
		 if (token == null || token.length() <= 0) {
			 Log.e(TAG, ""Refresh token or auth code for MSATokenRequest was unexpectedly empty - treating as permanent failure."");
			 return AsyncOperation.completedFuture(new MSATokenRequest.Result(Result.Status.PERMANENT_FAILURE, null));
		 }
		 return AsyncOperation.supplyAsync(new AsyncOperation.Supplier<MSATokenRequest.Result>() {
			 public MSATokenRequest.Result get() {
				 HttpsURLConnection connection = null;
				 MSATokenRequest.Result.Status status = Result.Status.TRANSIENT_FAILURE;
				 JSONObject responseJson = null;
				 try {
					 List<Pair<String, String>> params = new LinkedList<>();
					 params.add(new Pair<>(""client_id"", clientId));
					 params.add(new Pair<>(""grant_type"", grantType));
					 if (grantType.equals(GrantType.CODE)) {
						 params.add(new Pair<>(""redirect_uri"", redirectUri));
						 params.add(new Pair<>(""code"", token));
					 }
					 else if (grantType.equals(GrantType.REFRESH)) {
						 params.add(new Pair<>(""scope"", scope));
						 params.add(new Pair<>(grantType, token));
					 }
					 String queryString = getQueryString(params);
					 URL url = new URL(""https: connection = (HttpsURLConnection)url.openConnection();
					 connection.setDoOutput(true);
					 connection.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");
					 IOUtil.writeUTF8Stream(connection.getOutputStream(), queryString);
					 int responseCode = connection.getResponseCode();
					 if (responseCode >= 500) {
						 status = Result.Status.TRANSIENT_FAILURE;
					 }
					 else if (responseCode >= 400) {
						 status = Result.Status.PERMANENT_FAILURE;
					 }
					 else if ((responseCode >= 200 && responseCode < 300) || responseCode == 304) {
						 status = Result.Status.SUCCESS;
					 }
					 else {
						 status = Result.Status.TRANSIENT_FAILURE;
					 }
					 if (status == Result.Status.SUCCESS) {
						 responseJson = new JSONObject(IOUtil.readUTF8Stream(connection.getInputStream()));
					 }
					 else {
						 Log.e(TAG, ""Failed to get token with HTTP code: "" + responseCode);
					 }
				 }
				 catch (IOException | JSONException e) {
					 Log.e(TAG, ""Failed to get token: \"""" + e.getLocalizedMessage() + ""\"""");
				 }
				 finally {
					 if (connection != null) {
						 connection.disconnect();
					 }
					 return new MSATokenRequest.Result(status, responseJson);
				 }
			 }
		 }
		);
	 }
	 public AsyncOperation<MSATokenRequest.Result> requestAsync(String token) {
		 return requestAsync(mClientId, mGrantType, mScope, mRedirectUri, token);
	 }
}",1,0,0,0
"public interface PortBased extends NetworkBased {
	 int getPort();
}",0,0,0,0
"public BatchResponsePart executeChangeSet(final BatchHandler handler, final List<ODataRequest> requests) throws ODataException {
	 List<ODataResponse> responses = new ArrayList<ODataResponse>();
	 try {
		 oDataJPAContext.getODataJPATransaction().begin();
		 for (ODataRequest request : requests) {
			 oDataJPAContext.setODataContext(getContext());
			 ODataResponse response = handler.handleRequest(request);
			 if (response.getStatus().getStatusCode() >= HttpStatusCodes.BAD_REQUEST.getStatusCode()) {
				 oDataJPAContext.getODataJPATransaction().rollback();
				 List<ODataResponse> errorResponses = new ArrayList<ODataResponse>(1);
				 errorResponses.add(response);
				 return BatchResponsePart.responses(errorResponses).changeSet(false).build();
			 }
			 responses.add(response);
		 }
		 oDataJPAContext.getODataJPATransaction().commit();
		 return BatchResponsePart.responses(responses).changeSet(true).build();
	 }
	 catch (Exception e) {
		 throw new ODataException(""Error on processing request content:"" + e.getMessage(), e);
	 }
	 finally {
		 close(true);
	 }
 }",0,0,1,0
"public class ByteCode {
	 public static final int NOP = 0x00, ACONST_NULL = 0x01, ICONST_M1 = 0x02, ICONST_0 = 0x03, ICONST_1 = 0x04, ICONST_2 = 0x05, ICONST_3 = 0x06, ICONST_4 = 0x07, ICONST_5 = 0x08, LCONST_0 = 0x09, LCONST_1 = 0x0A, FCONST_0 = 0x0B, FCONST_1 = 0x0C, FCONST_2 = 0x0D, DCONST_0 = 0x0E, DCONST_1 = 0x0F, BIPUSH = 0x10, SIPUSH = 0x11, LDC = 0x12, LDC_W = 0x13, LDC2_W = 0x14, ILOAD = 0x15, LLOAD = 0x16, FLOAD = 0x17, DLOAD = 0x18, ALOAD = 0x19, ILOAD_0 = 0x1A, ILOAD_1 = 0x1B, ILOAD_2 = 0x1C, ILOAD_3 = 0x1D, LLOAD_0 = 0x1E, LLOAD_1 = 0x1F, LLOAD_2 = 0x20, LLOAD_3 = 0x21, FLOAD_0 = 0x22, FLOAD_1 = 0x23, FLOAD_2 = 0x24, FLOAD_3 = 0x25, DLOAD_0 = 0x26, DLOAD_1 = 0x27, DLOAD_2 = 0x28, DLOAD_3 = 0x29, ALOAD_0 = 0x2A, ALOAD_1 = 0x2B, ALOAD_2 = 0x2C, ALOAD_3 = 0x2D, IALOAD = 0x2E, LALOAD = 0x2F, FALOAD = 0x30, DALOAD = 0x31, AALOAD = 0x32, BALOAD = 0x33, CALOAD = 0x34, SALOAD = 0x35, ISTORE = 0x36, LSTORE = 0x37, FSTORE = 0x38, DSTORE = 0x39, ASTORE = 0x3A, ISTORE_0 = 0x3B, ISTORE_1 = 0x3C, ISTORE_2 = 0x3D, ISTORE_3 = 0x3E, LSTORE_0 = 0x3F, LSTORE_1 = 0x40, LSTORE_2 = 0x41, LSTORE_3 = 0x42, FSTORE_0 = 0x43, FSTORE_1 = 0x44, FSTORE_2 = 0x45, FSTORE_3 = 0x46, DSTORE_0 = 0x47, DSTORE_1 = 0x48, DSTORE_2 = 0x49, DSTORE_3 = 0x4A, ASTORE_0 = 0x4B, ASTORE_1 = 0x4C, ASTORE_2 = 0x4D, ASTORE_3 = 0x4E, IASTORE = 0x4F, LASTORE = 0x50, FASTORE = 0x51, DASTORE = 0x52, AASTORE = 0x53, BASTORE = 0x54, CASTORE = 0x55, SASTORE = 0x56, POP = 0x57, POP2 = 0x58, DUP = 0x59, DUP_X1 = 0x5A, DUP_X2 = 0x5B, DUP2 = 0x5C, DUP2_X1 = 0x5D, DUP2_X2 = 0x5E, SWAP = 0x5F, IADD = 0x60, LADD = 0x61, FADD = 0x62, DADD = 0x63, ISUB = 0x64, LSUB = 0x65, FSUB = 0x66, DSUB = 0x67, IMUL = 0x68, LMUL = 0x69, FMUL = 0x6A, DMUL = 0x6B, IDIV = 0x6C, LDIV = 0x6D, FDIV = 0x6E, DDIV = 0x6F, IREM = 0x70, LREM = 0x71, FREM = 0x72, DREM = 0x73, INEG = 0x74, LNEG = 0x75, FNEG = 0x76, DNEG = 0x77, ISHL = 0x78, LSHL = 0x79, ISHR = 0x7A, LSHR = 0x7B, IUSHR = 0x7C, LUSHR = 0x7D, IAND = 0x7E, LAND = 0x7F, IOR = 0x80, LOR = 0x81, IXOR = 0x82, LXOR = 0x83, IINC = 0x84, I2L = 0x85, I2F = 0x86, I2D = 0x87, L2I = 0x88, L2F = 0x89, L2D = 0x8A, F2I = 0x8B, F2L = 0x8C, F2D = 0x8D, D2I = 0x8E, D2L = 0x8F, D2F = 0x90, I2B = 0x91, I2C = 0x92, I2S = 0x93, LCMP = 0x94, FCMPL = 0x95, FCMPG = 0x96, DCMPL = 0x97, DCMPG = 0x98, IFEQ = 0x99, IFNE = 0x9A, IFLT = 0x9B, IFGE = 0x9C, IFGT = 0x9D, IFLE = 0x9E, IF_ICMPEQ = 0x9F, IF_ICMPNE = 0xA0, IF_ICMPLT = 0xA1, IF_ICMPGE = 0xA2, IF_ICMPGT = 0xA3, IF_ICMPLE = 0xA4, IF_ACMPEQ = 0xA5, IF_ACMPNE = 0xA6, GOTO = 0xA7, JSR = 0xA8, RET = 0xA9, TABLESWITCH = 0xAA, LOOKUPSWITCH = 0xAB, IRETURN = 0xAC, LRETURN = 0xAD, FRETURN = 0xAE, DRETURN = 0xAF, ARETURN = 0xB0, RETURN = 0xB1, GETSTATIC = 0xB2, PUTSTATIC = 0xB3, GETFIELD = 0xB4, PUTFIELD = 0xB5, INVOKEVIRTUAL = 0xB6, INVOKESPECIAL = 0xB7, INVOKESTATIC = 0xB8, INVOKEINTERFACE = 0xB9, NEW = 0xBB, NEWARRAY = 0xBC, ANEWARRAY = 0xBD, ARRAYLENGTH = 0xBE, ATHROW = 0xBF, CHECKCAST = 0xC0, INSTANCEOF = 0xC1, MONITORENTER = 0xC2, MONITOREXIT = 0xC3, WIDE = 0xC4, MULTIANEWARRAY = 0xC5, IFNULL = 0xC6, IFNONNULL = 0xC7, GOTO_W = 0xC8, JSR_W = 0xC9, BREAKPOINT = 0xCA, IMPDEP1 = 0xFE, IMPDEP2 = 0xFF;
	 public static final byte T_BOOLEAN = 4, T_CHAR = 5, T_FLOAT = 6, T_DOUBLE = 7, T_BYTE = 8, T_SHORT = 9, T_INT = 10, T_LONG = 11;
}",1,0,0,0
"public interface UpgradeRequest{
	 void addExtensions(ExtensionConfig... configs);
	 void addExtensions(String... configs);
	 void clearHeaders();
	 List<HttpCookie> getCookies();
	 List<ExtensionConfig> getExtensions();
	 String getHeader(String name);
	 int getHeaderInt(String name);
	 Map<String, List<String>> getHeaders();
	 List<String> getHeaders(String name);
	 String getHost();
	 String getHttpVersion();
	 String getMethod();
	 String getOrigin();
	 Map<String, List<String>> getParameterMap();
	 String getProtocolVersion();
	 String getQueryString();
	 URI getRequestURI();
	 Object getSession();
	 List<String> getSubProtocols();
	 Principal getUserPrincipal();
	 boolean hasSubProtocol(String test);
	 boolean isOrigin(String test);
	 boolean isSecure();
	 void setCookies(List<HttpCookie> cookies);
	 void setExtensions(List<ExtensionConfig> configs);
	 void setHeader(String name, List<String> values);
	 void setHeader(String name, String value);
	 void setHeaders(Map<String, List<String>> headers);
	 void setHttpVersion(String httpVersion);
	 void setMethod(String method);
	 void setRequestURI(URI uri);
	 void setSession(Object session);
	 void setSubProtocols(List<String> protocols);
	 void setSubProtocols(String... protocols);
}",1,1,0,0
"public void response(Message message) {
	 repairResolver.preprocess(message);
	 if (repairResolver.getMessageCount() == count) {
		 StageManager.getStage(Stage.READ_REPAIR).execute(new WrappedRunnable() {
			 protected void runMayThrow() throws DigestMismatchException, IOException {
				 repairResolver.resolve();
			 }
		 }
		);
	 }
 }",0,0,0,0
"public class ReloadingFileBasedConfigurationBuilder<T extends FileBasedConfiguration> extends FileBasedConfigurationBuilder<T> implements ReloadingControllerSupport{
	 private static final ReloadingDetectorFactory DEFAULT_DETECTOR_FACTORY = new DefaultReloadingDetectorFactory();
	 private final ReloadingController reloadingController;
	 private volatile ReloadingDetector resultReloadingDetector;
	 public ReloadingFileBasedConfigurationBuilder(final Class<? extends T> resCls, final Map<String, Object> params) {
		 super(resCls, params);
		 reloadingController = createReloadingController();
	 }
	 public ReloadingFileBasedConfigurationBuilder(final Class<? extends T> resCls, final Map<String, Object> params, final boolean allowFailOnInit) {
		 super(resCls, params, allowFailOnInit);
		 reloadingController = createReloadingController();
	 }
	 public ReloadingFileBasedConfigurationBuilder(final Class<? extends T> resCls) {
		 super(resCls);
		 reloadingController = createReloadingController();
	 }
	 public ReloadingController getReloadingController() {
		 return reloadingController;
	 }
	 public ReloadingFileBasedConfigurationBuilder<T> configure( final BuilderParameters... params) {
		 super.configure(params);
		 return this;
	 }
	 protected ReloadingDetector createReloadingDetector(final FileHandler handler, final FileBasedBuilderParametersImpl fbparams) throws ConfigurationException {
		 return fetchDetectorFactory(fbparams).createReloadingDetector(handler, fbparams);
	 }
	 protected void initFileHandler(final FileHandler handler) throws ConfigurationException {
		 super.initFileHandler(handler);
		 resultReloadingDetector = createReloadingDetector(handler, FileBasedBuilderParametersImpl.fromParameters( getParameters(), true));
	 }
	 private ReloadingController createReloadingController() {
		 final ReloadingDetector ctrlDetector = createReloadingDetectorForController();
		 final ReloadingController ctrl = new ReloadingController(ctrlDetector);
		 connectToReloadingController(ctrl);
		 return ctrl;
	 }
	 private ReloadingDetector createReloadingDetectorForController() {
		 return new ReloadingDetector() {
			 public void reloadingPerformed() {
				 final ReloadingDetector detector = resultReloadingDetector;
				 if (detector != null) {
					 detector.reloadingPerformed();
				 }
			 }
			 public boolean isReloadingRequired() {
				 final ReloadingDetector detector = resultReloadingDetector;
				 return (detector != null) && detector.isReloadingRequired();
			 }
		 }
		;
	 }
	 private static ReloadingDetectorFactory fetchDetectorFactory( final FileBasedBuilderParametersImpl params) {
		 final ReloadingDetectorFactory factory = params.getReloadingDetectorFactory();
		 return (factory != null) ? factory : DEFAULT_DETECTOR_FACTORY;
	 }
}",1,1,0,0
"public Proxy(InetAddress local, int local_port, InetAddress remote, int remote_port, boolean verbose, boolean debug, String mapping_file);",0,0,0,1
"private void setModalFieldsTooltips() {
	 this.tooltipInput.setTitle(MSGS.firewallPortForwardFormInboundInterfaceToolTip());
	 this.tooltipOutput.setTitle(MSGS.firewallPortForwardFormOutboundInterfaceToolTip());
	 this.tooltipLan.setTitle(MSGS.firewallPortForwardFormLanAddressToolTip());
	 this.tooltipProtocol.setTitle(MSGS.firewallPortForwardFormProtocolToolTip());
	 this.tooltipInternal.setTitle(MSGS.firewallPortForwardFormInternalPortToolTip());
	 this.tooltipExternal.setTitle(MSGS.firewallPortForwardFormExternalPortToolTip());
	 this.tooltipEnable.setTitle(MSGS.firewallPortForwardFormMasqueradingToolTip());
	 this.tooltipPermittedNw.setTitle(MSGS.firewallPortForwardFormPermittedNetworkToolTip());
	 this.tooltipPermittedMac.setTitle(MSGS.firewallPortForwardFormPermittedMacAddressToolTip());
	 this.tooltipSource.setTitle(MSGS.firewallPortForwardFormSourcePortRangeToolTip());
	 this.tooltipInput.reconfigure();
	 this.tooltipOutput.reconfigure();
	 this.tooltipLan.reconfigure();
	 this.tooltipProtocol.reconfigure();
	 this.tooltipExternal.reconfigure();
	 this.tooltipInternal.reconfigure();
	 this.tooltipEnable.reconfigure();
	 this.tooltipPermittedNw.reconfigure();
	 this.tooltipPermittedMac.reconfigure();
	 this.tooltipSource.reconfigure();
 }",0,0,1,0
"public class WebSocketSecurityConfigextends AbstractSecurityWebSocketMessageBrokerConfigurer {
	protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
		messages.simpMessageDestMatchers(""/queue*-user*"", ""/topic*-user*"").denyAll().anyMessage().authenticated();
	}
}",1,0,0,0
"static boolean isWhiteSpace(char ch[], int start, int length);",0,0,0,0
"public JobStatus submitJob(String jobFile) throws IOException {
	 totalSubmissions++;
	 JobInProgress job = createJob(jobFile);
	 return job.getStatus();
 }",0,0,0,0
"public void actionPerformed(ActionEvent e) {
	Config config = Config.getInstance();
	if (e.getSource() instanceof JComponent) {
		String name = ((JComponent) e.getSource()).getName();
		if (name == null) {
			return;
		}
		if (name.startsWith(""STOP"")) {
			stopQueue(name);
		}
		 else if (name.equals(""OPT_UPDATE_FFMPEG"")) {
			if (warningPanel != null) {
				warningPanel.setVisible(false);
			}
			updateFFmpeg();
		}
		 else if (name.startsWith(""FORMAT"")) {
			convert(name);
		}
		 else if (name.startsWith(""START"")) {
			startQueue(name);
		}
		 else if (""ADD_URL"".equals(name) || ""MENU_ADD_URL"".equals(name)) {
			XDMApp.getInstance().addDownload(null, null);
		}
		 else if (""ALL_DOWNLOADS"".equals(name)) {
			tabClicked(e);
			config.setStateFilter(XDMConstants.ALL);
			filter();
		}
		 else if (""ALL_UNFINISHED"".equals(name)) {
			tabClicked(e);
			config.setStateFilter(XDMConstants.UNFINISHED);
			filter();
		}
		 else if (""ALL_FINISHED"".equals(name)) {
			tabClicked(e);
			config.setStateFilter(XDMConstants.FINISHED);
			filter();
		}
		 else if (""PAUSE"".equals(name) || ""MENU_PAUSE"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			for (int i = 0;
			 i < ids.length;
			 i++) {
				XDMApp.getInstance().pauseDownload(ids[i]);
			}
		}
		 else if (""CTX_COPY_URL"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			if (ids.length > 0) {
				String id = ids[0];
				XDMUtils.copyURL(XDMApp.getInstance().getURL(id));
			}
		}
		 else if (""MENU_RESTART"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			for (int i = 0;
			 i < ids.length;
			 i++) {
				XDMApp.getInstance().restartDownload(ids[i]);
			}
		}
		 else if (""RESUME"".equals(name) || ""MENU_RESUME"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			for (int i = 0;
			 i < ids.length;
			 i++) {
				XDMApp.getInstance().resumeDownload(ids[i], true);
			}
		}
		 else if (""CTX_OPEN_FILE"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			if (ids.length > 0) {
				String id = ids[0];
				openFile(id);
			}
		}
		 else if (""CTX_OPEN_FOLDER"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			if (ids.length > 0) {
				String id = ids[0];
				openFolder(id);
			}
		}
		 else if (""MENU_EXIT"".equals(name)) {
			XDMApp.getInstance().exit();
		}
		 else if (""0"".equals(name)) {
			config.setSortField(0);
			filter();
		}
		 else if (""1"".equals(name)) {
			config.setSortField(1);
			filter();
		}
		 else if (""2"".equals(name)) {
			config.setSortField(2);
			filter();
		}
		 else if (""3"".equals(name)) {
			config.setSortField(3);
			filter();
		}
		 else if (""4"".equals(name)) {
			config.setSortAsc(true);
			filter();
		}
		 else if (""5"".equals(name)) {
			config.setSortAsc(false);
			filter();
		}
		 else if (""BTN_SEARCH"".equals(name)) {
			config.setSearchText(txtSearch.getText());
			filter();
		}
		 else if (""CAT_DOCUMENTS"".equals(name)) {
			config.setCategoryFilter(XDMConstants.DOCUMENTS);
			updateSidePanel((JLabel) e.getSource());
		}
		 else if (""CAT_COMPRESSED"".equals(name)) {
			config.setCategoryFilter(XDMConstants.COMPRESSED);
			updateSidePanel((JLabel) e.getSource());
		}
		 else if (""CAT_MUSIC"".equals(name)) {
			config.setCategoryFilter(XDMConstants.MUSIC);
			updateSidePanel((JLabel) e.getSource());
		}
		 else if (""CAT_PROGRAMS"".equals(name)) {
			config.setCategoryFilter(XDMConstants.PROGRAMS);
			updateSidePanel((JLabel) e.getSource());
		}
		 else if (""CAT_VIDEOS"".equals(name)) {
			config.setCategoryFilter(XDMConstants.VIDEO);
			updateSidePanel((JLabel) e.getSource());
		}
		 else if (""CAT_ALL"".equals(name)) {
			config.setCategoryFilter(XDMConstants.ALL);
			updateSidePanel((JLabel) e.getSource());
		}
		 else if (""MENU_CLIP_ADD"".equals(name)) {
			int ret = MessageBox.show(this, ""sample title"",""sample textdgdfgdfgdfghdfh gfhsdgh gfgfh dfgdfqwewrqwerwerqwerqwerwerwqerqwerqwerqwerwerwegfterj jgh ker gwekl hwgklerhg ek hrkjlwhlk kj hgeklgh jkle herklj gheklwerjgh sample textdgdfgdfgdfghdfh gfhsdgh gfgfh dfgdfqwewrqwerwerqwerqwerwerwqerqwerqwerqwerwerwegfterj jgh ker gwekl hwgklerhg ek hrkjlwhlk kj hgeklgh jkle herklj gheklwerjgh"",MessageBox.OK_OPTION, MessageBox.OK);
			System.out.println(""After: "" + ret);
		}
		 else if (""MENU_OPTIONS"".equals(name) || ""OPTIONS"".equals(name)) {
			SettingsPage.getInstance().showPanel(this, ""PG_SETTINGS"");
		}
		 else if (""MENU_REFRESH_LINK"".equals(name)) {
			openRefreshPage();
		}
		 else if (""MENU_PROPERTIES"".equals(name)) {
			showProperties();
		}
		 else if (""MENU_BROWSER_INT"".equals(name)) {
			SettingsPage.getInstance().showPanel(this, ""BTN_MONITORING"");
		}
		 else if (""MENU_SPEED_LIMITER"".equals(name)) {
			SettingsPage.getInstance().showPanel(this, ""BTN_NETWORK"");
		}
		 else if (""DESC_Q_TITLE"".equals(name)) {
			SettingsPage.getInstance().showPanel(this, ""Q_MAN"");
		}
		 else if (""MENU_MEDIA_CONVERTER"".equals(name)) {
			VideoDownloadWindow vw = new VideoDownloadWindow(null, null);
			vw.setVisible(true);
		}
		 else if (""MENU_DELETE_DWN"".equals(name) || ""DELETE"".equals(name)) {
			if (MessageBox.show(this, StringResource.get(""DEL_TITLE""), StringResource.get(""DEL_SEL_TEXT""),MessageBox.YES_NO_OPTION, MessageBox.YES) == MessageBox.YES) {
				String[] ids = lv.getSelectedIds();
				ArrayList<String> idList = new ArrayList<String>();
				for (int i = 0;
				 i < ids.length;
				 i++) {
					idList.add(ids[i]);
				}
				XDMApp.getInstance().deleteDownloads(idList);
			}
		}
		 else if (""MENU_DELETE_COMPLETED"".equals(name)) {
			if (MessageBox.show(this, StringResource.get(""DEL_TITLE""), StringResource.get(""DEL_FINISHED_TEXT""),MessageBox.YES_NO_OPTION, MessageBox.YES) == MessageBox.YES) {
				XDMApp.getInstance().deleteCompleted();
			}
		}
		 else if (""MENU_ABOUT"".equals(name)) {
			AboutPage aboutPage = new AboutPage(this);
			aboutPage.showPanel();
		}
		 else if (""CTX_SAVE_AS"".equals(name)) {
			String[] ids = lv.getSelectedIds();
			if (ids.length > 0) {
				String id = ids[0];
				changeFile(id);
			}
		}
		 else if (""MENU_VIDEO_DWN"".equals(name)) {
			showVideoDwnDlg();
		}
		 else if (""MENU_IMPORT"".equals(name)) {
			JFileChooser jfc = new JFileChooser();
			if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
				File file = jfc.getSelectedFile();
				XDMApp.getInstance().loadDownloadList(file);
			}
		}
		 else if (""MENU_EXPORT"".equals(name)) {
			JFileChooser jfc = new JFileChooser();
			if (jfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
				File file = jfc.getSelectedFile();
				XDMApp.getInstance().saveDownloadList(file);
			}
		}
		 else if (""MENU_CONTENTS"".equals(name)) {
		XDMUtils.browseURL(""http:}
		 else if (""MENU_HOME_PAGE"".equals(name)) {
		XDMUtils.browseURL(""http:}
		 else if (""MENU_UPDATE"".equals(name)) {
		XDMUtils.browseURL(""http:}
		 else if (""MENU_LANG"".equals(name)) {
			showLanguageDlg();
		}
	}
}",0,0,1,0
"public class DatabaseTestCases {
	 private static final Logger logger = LoggerFactory.getLogger(DatabaseTestCases.class);
	 protected static String hostAddress = ""localhost"";
	 protected static int port = 20000;
	 protected static String userName = ""admin"";
	 protected static String password = ""admin"";
	 protected static String driver = ""org.apache.derby.jdbc.ClientDriver"";
	 public static String getHostAddress() {
		 return hostAddress;
	 }
	 public static int getPort() {
		 return port;
	 }
	 public static String getUserName() {
		 return userName;
	 }
	 public static String getPassword() {
		 return password;
	 }
	 public static String getDriver() {
		 return driver;
	 }
	 public static String getJDBCUrl() {
		 return new StringBuilder().append(""jdbc:derby: .append(""/experiment_catalog;
		create=true;
		user="").append(getUserName()).append("";
		password="") .append(getPassword()).toString();
	 }
	 public static void waitTillServerStarts() {
		 DBUtil dbUtil = null;
		 try {
			 dbUtil = new DBUtil(getJDBCUrl(), getUserName(), getPassword(), getDriver());
		 }
		 catch (Exception e) {
		 }
		 Connection connection = null;
		 try {
			 if (dbUtil != null) {
				 connection = dbUtil.getConnection();
			 }
		 }
		 catch (Throwable e) {
		 }
		 while (connection == null) {
			 try {
				 Thread.sleep(1000);
				 try {
					 if (dbUtil != null) {
						 connection = dbUtil.getConnection();
					 }
				 }
				 catch (SQLException e) {
				 }
			 }
			 catch (InterruptedException e) {
			 }
		 }
	 }
	 public static void executeSQL(String sql) throws Exception {
		 DBUtil dbUtil = new DBUtil(getJDBCUrl(), getUserName(), getPassword(), getDriver());
		 dbUtil.executeSQL(sql);
	 }
	 public DBUtil getDbUtil () throws Exception {
		 return new DBUtil(getJDBCUrl(), getUserName(), getPassword(), getDriver());
	 }
	 public Connection getConnection() throws Exception {
		 DBUtil dbUtil = getDbUtil ();
		 Connection connection = dbUtil.getConnection();
		 connection.setAutoCommit(true);
		 return connection;
	 }
}",0,0,0,0
"public void validateTwoSegments(final IndexableAdapter adapter1, final IndexableAdapter adapter2) {
	 if (adapter1.getNumRows() != adapter2.getNumRows()) {
		 throw new SegmentValidationException( ""Row count mismatch. Expected [%d] found [%d]"", adapter1.getNumRows(), adapter2.getNumRows() );
	 }
	 {
		 final Set<String> dimNames1 = Sets.newHashSet(adapter1.getDimensionNames());
		 final Set<String> dimNames2 = Sets.newHashSet(adapter2.getDimensionNames());
		 if (!dimNames1.equals(dimNames2)) {
			 throw new SegmentValidationException( ""Dimension names differ. Expected [%s] found [%s]"", dimNames1, dimNames2 );
		 }
		 final Set<String> metNames1 = Sets.newHashSet(adapter1.getMetricNames());
		 final Set<String> metNames2 = Sets.newHashSet(adapter2.getMetricNames());
		 if (!metNames1.equals(metNames2)) {
			 throw new SegmentValidationException(""Metric names differ. Expected [%s] found [%s]"", metNames1, metNames2);
		 }
	 }
	 final RowIterator it1 = adapter1.getRows();
	 final RowIterator it2 = adapter2.getRows();
	 long row = 0L;
	 while (it1.moveToNext()) {
		 if (!it2.moveToNext()) {
			 throw new SegmentValidationException(""Unexpected end of second adapter"");
		 }
		 final RowPointer rp1 = it1.getPointer();
		 final RowPointer rp2 = it2.getPointer();
		 ++row;
		 if (rp1.getRowNum() != rp2.getRowNum()) {
			 throw new SegmentValidationException(""Row number mismatch: [%d] vs [%d]"", rp1.getRowNum(), rp2.getRowNum());
		 }
		 try {
			 validateRowValues(rp1, adapter1, rp2, adapter2);
		 }
		 catch (SegmentValidationException ex) {
			 throw new SegmentValidationException(ex, ""Validation failure on row %d: [%s] vs [%s]"", row, rp1, rp2);
		 }
	 }
	 if (it2.moveToNext()) {
		 throw new SegmentValidationException(""Unexpected end of first adapter"");
	 }
	 if (row != adapter1.getNumRows()) {
		 throw new SegmentValidationException( ""Actual Row count mismatch. Expected [%d] found [%d]"", row, adapter1.getNumRows() );
	 }
 }",0,0,1,0
"public static class CompactionCanceledException extends Exception {
	 private static final long serialVersionUID = 1L;
 }",0,0,0,0
"public class ResourceLink<T> extends Link<T> implements IResourceListener{
	private static final long serialVersionUID = 1L;
	private final ResourceReference resourceReference;
	private final Resource resource;
	private final ValueMap resourceParameters;
	public ResourceLink(final String id, final ResourceReference resourceReference){
		this(id, resourceReference, null);
	}
	public ResourceLink(final String id, final ResourceReference resourceReference,ValueMap resourceParameters){
		super(id);
		this.resourceReference = resourceReference;
		this.resourceParameters = resourceParameters;
		resource = null;
	}
	public ResourceLink(final String id, final Resource resource){
		super(id);
		this.resource = resource;
		resourceReference = null;
		resourceParameters = null;
	}
	public void onClick(){
	}
	public final void onResourceRequested(){
		resource.onResourceRequested();
		onLinkClicked();
	}
	protected final CharSequence getURL(){
		if (resourceReference != null){
			resourceReference.bind(getApplication());
			return getRequestCycle().urlFor(resourceReference, resourceParameters);
		}
		return urlFor(IResourceListener.INTERFACE);
	}
}",0,0,0,0
"private TokenizedPattern[] fillNonPatternSet(Map map, String[] patterns) {
	 ArrayList al = new ArrayList(patterns.length);
	 for (int i = 0;
	 i < patterns.length;
	 i++) {
		 if (!SelectorUtils.hasWildcards(patterns[i])) {
			 String s = isCaseSensitive() ? patterns[i] : patterns[i].toUpperCase();
			 map.put(s, new TokenizedPath(s));
		 }
		 else {
			 al.add(new TokenizedPattern(patterns[i]));
		 }
	 }
	 return (TokenizedPattern[]) al.toArray(new TokenizedPattern[al.size()]);
 }",0,0,0,0
"public interface OffloadIndexBlock extends Closeable {
	 IndexInputStream toStream() throws IOException;
	 OffloadIndexEntry getIndexEntryForEntry(long messageEntryId) throws IOException;
	 int getEntryCount();
	 LedgerMetadata getLedgerMetadata();
	 long getDataObjectLength();
	 long getDataBlockHeaderLength();
	 public static class IndexInputStream extends FilterInputStream {
		 final long streamSize;
		 public IndexInputStream(InputStream in, long streamSize) {
			 super(in);
			 this.streamSize = streamSize;
		 }
		 public long getStreamSize() {
			 return streamSize;
		 }
	 }
}",0,0,0,0
"public class SystemUtils{
	 private static Logger log = LoggerFactory.getLogger(SystemUtils.class.getName());
	 private static boolean logging = false ;
	 static public ClassLoader chooseClassLoader() {
		 ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
		 if ( logging && classLoader != null ) log.trace(""Using thread classloader"") ;
		 if ( classLoader == null ) {
			 classLoader = ClassLoader.getSystemClassLoader() ;
			 if ( logging && classLoader != null ) log.trace(""Using system classloader"") ;
		 }
		 if ( classLoader == null ) throw new AtlasException(""Failed to find a classloader"") ;
		 return classLoader ;
	 }
}",0,0,0,0
"public class XMLDTDValidator implements XMLComponent, XMLDocumentFilter, XMLDTDValidatorFilter, RevalidationHandler {
	 private static final int TOP_LEVEL_SCOPE = -1;
	 protected static final String NAMESPACES = Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
	 protected static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
	 protected static final String DYNAMIC_VALIDATION = Constants.XERCES_FEATURE_PREFIX + Constants.DYNAMIC_VALIDATION_FEATURE;
	 protected static final String BALANCE_SYNTAX_TREES = Constants.XERCES_FEATURE_PREFIX + Constants.BALANCE_SYNTAX_TREES;
	 protected static final String WARN_ON_DUPLICATE_ATTDEF = Constants.XERCES_FEATURE_PREFIX + Constants.WARN_ON_DUPLICATE_ATTDEF_FEATURE;
	 protected static final String PARSER_SETTINGS = Constants.XERCES_FEATURE_PREFIX + Constants.PARSER_SETTINGS;
	 protected static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
	 protected static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
	 protected static final String GRAMMAR_POOL = Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
	 protected static final String DATATYPE_VALIDATOR_FACTORY = Constants.XERCES_PROPERTY_PREFIX + Constants.DATATYPE_VALIDATOR_FACTORY_PROPERTY;
	 protected static final String VALIDATION_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY;
	 private static final String[] RECOGNIZED_FEATURES = {
	 NAMESPACES, VALIDATION, DYNAMIC_VALIDATION, BALANCE_SYNTAX_TREES }
	;
	 private static final Boolean[] FEATURE_DEFAULTS = {
	 null, null, Boolean.FALSE, Boolean.FALSE, }
	;
	 private static final String[] RECOGNIZED_PROPERTIES = {
	 SYMBOL_TABLE, ERROR_REPORTER, GRAMMAR_POOL, DATATYPE_VALIDATOR_FACTORY, VALIDATION_MANAGER }
	;
	 private static final Object[] PROPERTY_DEFAULTS = {
	 null, null, null, null, null, }
	;
	 private static final boolean DEBUG_ATTRIBUTES = false;
	 private static final boolean DEBUG_ELEMENT_CHILDREN = false;
	 protected ValidationManager fValidationManager = null;
	 protected final ValidationState fValidationState = new ValidationState();
	 protected boolean fNamespaces;
	 protected boolean fValidation;
	 protected boolean fDTDValidation;
	 protected boolean fDynamicValidation;
	 protected boolean fBalanceSyntaxTrees;
	 protected boolean fWarnDuplicateAttdef;
	 protected SymbolTable fSymbolTable;
	 protected XMLErrorReporter fErrorReporter;
	 protected XMLGrammarPool fGrammarPool;
	 protected DTDGrammarBucket fGrammarBucket;
	 protected XMLLocator fDocLocation;
	 protected NamespaceContext fNamespaceContext = null;
	 protected DTDDVFactory fDatatypeValidatorFactory;
	 protected XMLDocumentHandler fDocumentHandler;
	 protected XMLDocumentSource fDocumentSource;
	 protected DTDGrammar fDTDGrammar;
	 protected boolean fSeenDoctypeDecl = false;
	 private boolean fPerformValidation;
	 private String fSchemaType;
	 private final QName fCurrentElement = new QName();
	 private int fCurrentElementIndex = -1;
	 private int fCurrentContentSpecType = -1;
	 private final QName fRootElement = new QName();
	 private boolean fInCDATASection = false;
	 private int[] fElementIndexStack = new int[8];
	 private int[] fContentSpecTypeStack = new int[8];
	 private QName[] fElementQNamePartsStack = new QName[8];
	 private QName[] fElementChildren = new QName[32];
	 private int fElementChildrenLength = 0;
	 private int[] fElementChildrenOffsetStack = new int[32];
	 private int fElementDepth = -1;
	 private boolean fSeenRootElement = false;
	 private boolean fInElementContent = false;
	 private XMLElementDecl fTempElementDecl = new XMLElementDecl();
	 private final XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl();
	 private final XMLEntityDecl fEntityDecl = new XMLEntityDecl();
	 private final QName fTempQName = new QName();
	 private final StringBuffer fBuffer = new StringBuffer();
	 protected DatatypeValidator fValID;
	 protected DatatypeValidator fValIDRef;
	 protected DatatypeValidator fValIDRefs;
	 protected DatatypeValidator fValENTITY;
	 protected DatatypeValidator fValENTITIES;
	 protected DatatypeValidator fValNMTOKEN;
	 protected DatatypeValidator fValNMTOKENS;
	 protected DatatypeValidator fValNOTATION;
	 public XMLDTDValidator() {
		 for (int i = 0;
		 i < fElementQNamePartsStack.length;
		 i++) {
			 fElementQNamePartsStack[i] = new QName();
		 }
		 fGrammarBucket = new DTDGrammarBucket();
	 }
	 DTDGrammarBucket getGrammarBucket() {
		 return fGrammarBucket;
	 }
	 public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
		 fDTDGrammar = null;
		 fSeenDoctypeDecl = false;
		 fInCDATASection = false;
		 fSeenRootElement = false;
		 fInElementContent = false;
		 fCurrentElementIndex = -1;
		 fCurrentContentSpecType = -1;
		 fRootElement.clear();
		fValidationState.resetIDTables();
		fGrammarBucket.clear();
		fElementDepth = -1;
		 fElementChildrenLength = 0;
		 boolean parser_settings;
		 try {
			 parser_settings = componentManager.getFeature(PARSER_SETTINGS);
		 }
		 catch (XMLConfigurationException e){
			 parser_settings = true;
		 }
		 if (!parser_settings){
			fValidationManager.addValidationState(fValidationState);
			 return;
		 }
		 try {
			 fNamespaces = componentManager.getFeature(NAMESPACES);
		 }
		 catch (XMLConfigurationException e) {
			 fNamespaces = true;
		 }
		 try {
			 fValidation = componentManager.getFeature(VALIDATION);
		 }
		 catch (XMLConfigurationException e) {
			 fValidation = false;
		 }
		 try {
			 fDTDValidation = !(componentManager.getFeature(Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE));
		 }
		 catch (XMLConfigurationException e) {
			 fDTDValidation = true;
		 }
		 try {
			 fDynamicValidation = componentManager.getFeature(DYNAMIC_VALIDATION);
		 }
		 catch (XMLConfigurationException e) {
			 fDynamicValidation = false;
		 }
		 try {
			 fBalanceSyntaxTrees = componentManager.getFeature(BALANCE_SYNTAX_TREES);
		 }
		 catch (XMLConfigurationException e) {
			 fBalanceSyntaxTrees = false;
		 }
		 try {
			 fWarnDuplicateAttdef = componentManager.getFeature(WARN_ON_DUPLICATE_ATTDEF);
		 }
		 catch (XMLConfigurationException e) {
			 fWarnDuplicateAttdef = false;
		 }
		 try {
			 fSchemaType = (String)componentManager.getProperty (Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE);
		 }
		 catch (XMLConfigurationException e){
			 fSchemaType = null;
		 }
		 fValidationManager= (ValidationManager)componentManager.getProperty(VALIDATION_MANAGER);
		 fValidationManager.addValidationState(fValidationState);
		 fValidationState.setUsingNamespaces(fNamespaces);
		 fErrorReporter = (XMLErrorReporter)componentManager.getProperty(Constants.XERCES_PROPERTY_PREFIX+Constants.ERROR_REPORTER_PROPERTY);
		 fSymbolTable = (SymbolTable)componentManager.getProperty(Constants.XERCES_PROPERTY_PREFIX+Constants.SYMBOL_TABLE_PROPERTY);
		 try {
			 fGrammarPool= (XMLGrammarPool)componentManager.getProperty(GRAMMAR_POOL);
		 }
		 catch (XMLConfigurationException e) {
			 fGrammarPool = null;
		 }
		 fDatatypeValidatorFactory = (DTDDVFactory)componentManager.getProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.DATATYPE_VALIDATOR_FACTORY_PROPERTY);
		init();
	 }
	 public String[] getRecognizedFeatures() {
		 return (String[])(RECOGNIZED_FEATURES.clone());
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
	 }
	 public String[] getRecognizedProperties() {
		 return (String[])(RECOGNIZED_PROPERTIES.clone());
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
	 }
	 public Boolean getFeatureDefault(String featureId) {
		 for (int i = 0;
		 i < RECOGNIZED_FEATURES.length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return FEATURE_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 for (int i = 0;
		 i < RECOGNIZED_PROPERTIES.length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return PROPERTY_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public void setDocumentHandler(XMLDocumentHandler documentHandler) {
		 fDocumentHandler = documentHandler;
	 }
	 public XMLDocumentHandler getDocumentHandler() {
		 return fDocumentHandler;
	 }
	 public void setDocumentSource(XMLDocumentSource source){
		 fDocumentSource = source;
	 }
	 public XMLDocumentSource getDocumentSource (){
		 return fDocumentSource;
	 }
	 public void startDocument(XMLLocator locator, String encoding, NamespaceContext namespaceContext, Augmentations augs) throws XNIException {
		 if (fGrammarPool != null) {
			 Grammar [] grammars = fGrammarPool.retrieveInitialGrammarSet(XMLGrammarDescription.XML_DTD);
			 final int length = (grammars != null) ? grammars.length : 0;
			 for (int i = 0;
			 i < length;
			 ++i) {
				 fGrammarBucket.putGrammar((DTDGrammar)grammars[i]);
			 }
		 }
		 fDocLocation = locator;
		 fNamespaceContext = namespaceContext;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startDocument(locator, encoding, namespaceContext, augs);
		 }
	 }
	 public void xmlDecl(String version, String encoding, String standalone, Augmentations augs) throws XNIException {
		 fGrammarBucket.setStandalone(standalone != null && standalone.equals(""yes""));
		 if (fDocumentHandler != null) {
			 fDocumentHandler.xmlDecl(version, encoding, standalone, augs);
		 }
	 }
	 public void doctypeDecl(String rootElement, String publicId, String systemId, Augmentations augs) throws XNIException {
		 fSeenDoctypeDecl = true;
		 fRootElement.setValues(null, rootElement, rootElement, null);
		 String eid = null;
		 try {
			 eid = XMLEntityManager.expandSystemId(systemId, fDocLocation.getExpandedSystemId(), false);
		 }
		 catch (java.io.IOException e) {
		 }
		 XMLDTDDescription grammarDesc = new XMLDTDDescription(publicId, systemId, fDocLocation.getExpandedSystemId(), eid, rootElement);
		 fDTDGrammar = fGrammarBucket.getGrammar(grammarDesc);
		 if(fDTDGrammar == null) {
			 if (fGrammarPool != null && (systemId != null || publicId != null)) {
				 fDTDGrammar = (DTDGrammar)fGrammarPool.retrieveGrammar(grammarDesc);
			 }
		 }
		 if(fDTDGrammar == null) {
			 if (!fBalanceSyntaxTrees) {
				 fDTDGrammar = new DTDGrammar(fSymbolTable, grammarDesc);
			 }
			 else {
				 fDTDGrammar = new BalancedDTDGrammar(fSymbolTable, grammarDesc);
			 }
		 }
		 else {
			 fValidationManager.setCachedDTD(true);
		 }
		 fGrammarBucket.setActiveGrammar(fDTDGrammar);
		 if (fDocumentHandler != null) {
			 fDocumentHandler.doctypeDecl(rootElement, publicId, systemId, augs);
		 }
	 }
	 public void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {
		 handleStartElement(element, attributes, augs);
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startElement(element, attributes, augs);
		 }
	 }
	 public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {
		 boolean removed = handleStartElement(element, attributes, augs);
		 if (fDocumentHandler !=null) {
			 fDocumentHandler.emptyElement(element, attributes, augs);
		 }
		 if (!removed) {
			 handleEndElement(element, augs, true);
		 }
	 }
	 public void characters(XMLString text, Augmentations augs) throws XNIException {
		 boolean callNextCharacters = true;
		 boolean allWhiteSpace = true;
		 for (int i=text.offset;
		 i< text.offset+text.length;
		 i++) {
			 if (!isSpace(text.ch[i])) {
				 allWhiteSpace = false;
				 break;
			 }
		 }
		 if (fInElementContent && allWhiteSpace && !fInCDATASection) {
			 if (fDocumentHandler != null) {
				 fDocumentHandler.ignorableWhitespace(text, augs);
				 callNextCharacters = false;
			 }
		 }
		 if (fPerformValidation) {
			 if (fInElementContent) {
				 if (fGrammarBucket.getStandalone() && fDTDGrammar.getElementDeclIsExternal(fCurrentElementIndex)) {
					 if (allWhiteSpace) {
						 fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, ""MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE"", null, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
				 if (!allWhiteSpace) {
					 charDataInContent();
				 }
				 if (augs != null && augs.getItem(Constants.CHAR_REF_PROBABLE_WS) == Boolean.TRUE) {
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_CONTENT_INVALID_SPECIFIED"", new Object[]{
					 fCurrentElement.rawname, fDTDGrammar.getContentSpecAsString(fElementDepth), ""character reference""}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
			 if (fCurrentContentSpecType == XMLElementDecl.TYPE_EMPTY) {
				 charDataInContent();
			 }
		 }
		 if (callNextCharacters && fDocumentHandler != null) {
			 fDocumentHandler.characters(text, augs);
		 }
	 }
	 public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.ignorableWhitespace(text, augs);
		 }
	 }
	 public void endElement(QName element, Augmentations augs) throws XNIException {
		 handleEndElement(element, augs, false);
	 }
	 public void startCDATA(Augmentations augs) throws XNIException {
		 if (fPerformValidation && fInElementContent) {
			 charDataInContent();
		 }
		 fInCDATASection = true;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startCDATA(augs);
		 }
	 }
	 public void endCDATA(Augmentations augs) throws XNIException {
		 fInCDATASection = false;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endCDATA(augs);
		 }
	 }
	 public void endDocument(Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endDocument(augs);
		 }
	 }
	 public void comment(XMLString text, Augmentations augs) throws XNIException {
		 if (fPerformValidation && fElementDepth >= 0 && fDTDGrammar != null) {
			 fDTDGrammar.getElementDecl(fCurrentElementIndex, fTempElementDecl);
			 if (fTempElementDecl.type == XMLElementDecl.TYPE_EMPTY) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_CONTENT_INVALID_SPECIFIED"", new Object[]{
				 fCurrentElement.rawname, ""EMPTY"", ""comment""}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.comment(text, augs);
		 }
	 }
	 public void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {
		 if (fPerformValidation && fElementDepth >= 0 && fDTDGrammar != null) {
			 fDTDGrammar.getElementDecl(fCurrentElementIndex, fTempElementDecl);
			 if (fTempElementDecl.type == XMLElementDecl.TYPE_EMPTY) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_CONTENT_INVALID_SPECIFIED"", new Object[]{
				 fCurrentElement.rawname, ""EMPTY"", ""processing instruction""}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.processingInstruction(target, data, augs);
		 }
	 }
	 public void startGeneralEntity(String name, XMLResourceIdentifier identifier, String encoding, Augmentations augs) throws XNIException {
		 if (fPerformValidation && fElementDepth >= 0 && fDTDGrammar != null) {
			 fDTDGrammar.getElementDecl(fCurrentElementIndex, fTempElementDecl);
			 if (fTempElementDecl.type == XMLElementDecl.TYPE_EMPTY) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_CONTENT_INVALID_SPECIFIED"", new Object[]{
				 fCurrentElement.rawname, ""EMPTY"", ""ENTITY""}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
			 if (fGrammarBucket.getStandalone()) {
				 XMLDTDLoader.checkStandaloneEntityRef(name, fDTDGrammar, fEntityDecl, fErrorReporter);
			 }
		 }
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startGeneralEntity(name, identifier, encoding, augs);
		 }
	 }
	 public void endGeneralEntity(String name, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endGeneralEntity(name, augs);
		 }
	 }
	 public void textDecl(String version, String encoding, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.textDecl(version, encoding, augs);
		 }
	 }
	 public final boolean hasGrammar(){
		 return (fDTDGrammar != null);
	 }
	 public final boolean validate(){
		 return (fSchemaType != Constants.NS_XMLSCHEMA) && (!fDynamicValidation && fValidation || fDynamicValidation && fSeenDoctypeDecl) && (fDTDValidation || fSeenDoctypeDecl);
	 }
	 protected void addDTDDefaultAttrsAndValidate(QName elementName, int elementIndex, XMLAttributes attributes) throws XNIException {
		 if (elementIndex == -1 || fDTDGrammar == null) {
			 return;
		 }
		 int attlistIndex = fDTDGrammar.getFirstAttributeDeclIndex(elementIndex);
		 while (attlistIndex != -1) {
			 fDTDGrammar.getAttributeDecl(attlistIndex, fTempAttDecl);
			 if (DEBUG_ATTRIBUTES) {
				 if (fTempAttDecl != null) {
					 XMLElementDecl elementDecl = new XMLElementDecl();
					 fDTDGrammar.getElementDecl(elementIndex, elementDecl);
					 System.out.println(""element: ""+(elementDecl.name.localpart));
					 System.out.println(""attlistIndex "" + attlistIndex + ""\n""+ ""attName : '""+(fTempAttDecl.name.localpart) + ""'\n"" + ""attType : ""+fTempAttDecl.simpleType.type + ""\n"" + ""attDefaultType : ""+fTempAttDecl.simpleType.defaultType + ""\n"" + ""attDefaultValue : '""+fTempAttDecl.simpleType.defaultValue + ""'\n"" + attributes.getLength() +""\n"" );
				 }
			 }
			 String attPrefix = fTempAttDecl.name.prefix;
			 String attLocalpart = fTempAttDecl.name.localpart;
			 String attRawName = fTempAttDecl.name.rawname;
			 String attType = getAttributeTypeName(fTempAttDecl);
			 int attDefaultType =fTempAttDecl.simpleType.defaultType;
			 String attValue = null;
			 if (fTempAttDecl.simpleType.defaultValue != null) {
				 attValue = fTempAttDecl.simpleType.defaultValue;
			 }
			 boolean specified = false;
			 boolean required = attDefaultType == XMLSimpleType.DEFAULT_TYPE_REQUIRED;
			 boolean cdata = attType == XMLSymbols.fCDATASymbol;
			 if (!cdata || required || attValue != null) {
				 int attrCount = attributes.getLength();
				 for (int i = 0;
				 i < attrCount;
				 i++) {
					 if (attributes.getQName(i) == attRawName) {
						 specified = true;
						 break;
					 }
				 }
			 }
			 if (!specified) {
				 if (required) {
					 if (fPerformValidation) {
						 Object[] args = {
						elementName.localpart, attRawName}
						;
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED"", args, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
				 else if (attValue != null) {
					 if (fPerformValidation && fGrammarBucket.getStandalone()) {
						 if (fDTDGrammar.getAttributeDeclIsExternal(attlistIndex)) {
							 Object[] args = {
							 elementName.localpart, attRawName}
							;
							 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED"", args, XMLErrorReporter.SEVERITY_ERROR);
						 }
					 }
					 if (fNamespaces) {
						 int index = attRawName.indexOf(':');
						 if (index != -1) {
							 attPrefix = attRawName.substring(0, index);
							 attPrefix = fSymbolTable.addSymbol(attPrefix);
							 attLocalpart = attRawName.substring(index + 1);
							 attLocalpart = fSymbolTable.addSymbol(attLocalpart);
						 }
					 }
					 fTempQName.setValues(attPrefix, attLocalpart, attRawName, fTempAttDecl.name.uri);
					 int newAttr = attributes.addAttribute(fTempQName, attType, attValue);
				 }
			 }
			 attlistIndex = fDTDGrammar.getNextAttributeDeclIndex(attlistIndex);
		 }
		 int attrCount = attributes.getLength();
		 for (int i = 0;
		 i < attrCount;
		 i++) {
			 String attrRawName = attributes.getQName(i);
			 boolean declared = false;
			 if (fPerformValidation) {
				 if (fGrammarBucket.getStandalone()) {
					 String nonNormalizedValue = attributes.getNonNormalizedValue(i);
					 if (nonNormalizedValue != null) {
						 String entityName = getExternalEntityRefInAttrValue(nonNormalizedValue);
						 if (entityName != null) {
							 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE"", new Object[]{
							entityName}
							, XMLErrorReporter.SEVERITY_ERROR);
						 }
					 }
				 }
			 }
			 int attDefIndex = -1;
			 int position = fDTDGrammar.getFirstAttributeDeclIndex(elementIndex);
			 while (position != -1) {
				 fDTDGrammar.getAttributeDecl(position, fTempAttDecl);
				 if (fTempAttDecl.name.rawname == attrRawName) {
					 attDefIndex = position;
					 declared = true;
					 break;
				 }
				 position = fDTDGrammar.getNextAttributeDeclIndex(position);
			 }
			 if (!declared) {
				 if (fPerformValidation) {
					 Object[] args = {
					 elementName.rawname, attrRawName}
					;
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_ATTRIBUTE_NOT_DECLARED"", args,XMLErrorReporter.SEVERITY_ERROR);
				 }
				 continue;
			 }
			 String type = getAttributeTypeName(fTempAttDecl);
			 attributes.setType(i, type);
			 attributes.getAugmentations(i).putItem(Constants.ATTRIBUTE_DECLARED, Boolean.TRUE);
			 boolean changedByNormalization = false;
			 String oldValue = attributes.getValue(i);
			 String attrValue = oldValue;
			 if (attributes.isSpecified(i) && type != XMLSymbols.fCDATASymbol) {
				 changedByNormalization = normalizeAttrValue(attributes, i);
				 attrValue = attributes.getValue(i);
				 if (fPerformValidation && fGrammarBucket.getStandalone() && changedByNormalization && fDTDGrammar.getAttributeDeclIsExternal(position) ) {
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE"", new Object[]{
					attrRawName, oldValue, attrValue}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
			 if (!fPerformValidation) {
				 continue;
			 }
			 if (fTempAttDecl.simpleType.defaultType == XMLSimpleType.DEFAULT_TYPE_FIXED) {
				 String defaultValue = fTempAttDecl.simpleType.defaultValue;
				 if (!attrValue.equals(defaultValue)) {
					 Object[] args = {
					elementName.localpart, attrRawName, attrValue, defaultValue}
					;
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_FIXED_ATTVALUE_INVALID"", args, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
			 if (fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_ENTITY || fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_ENUMERATION || fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_ID || fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_IDREF || fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_NMTOKEN || fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_NOTATION ) {
				 validateDTDattribute(elementName, attrValue, fTempAttDecl);
			 }
		 }
	 }
	 protected String getExternalEntityRefInAttrValue(String nonNormalizedValue) {
		 int valLength = nonNormalizedValue.length();
		 int ampIndex = nonNormalizedValue.indexOf('&');
		 while (ampIndex != -1) {
			 if (ampIndex + 1 < valLength && nonNormalizedValue.charAt(ampIndex+1) != '#') {
				 int semicolonIndex = nonNormalizedValue.indexOf(';
				', ampIndex+1);
				 String entityName = nonNormalizedValue.substring(ampIndex+1, semicolonIndex);
				 entityName = fSymbolTable.addSymbol(entityName);
				 int entIndex = fDTDGrammar.getEntityDeclIndex(entityName);
				 if (entIndex > -1) {
					 fDTDGrammar.getEntityDecl(entIndex, fEntityDecl);
					 if (fEntityDecl.inExternal || (entityName = getExternalEntityRefInAttrValue(fEntityDecl.value)) != null) {
						 return entityName;
					 }
				 }
			 }
			 ampIndex = nonNormalizedValue.indexOf('&', ampIndex+1);
		 }
		 return null;
	 }
	 protected void validateDTDattribute(QName element, String attValue, XMLAttributeDecl attributeDecl) throws XNIException {
		 switch (attributeDecl.simpleType.type) {
			 case XMLSimpleType.TYPE_ENTITY: {
				 boolean isAlistAttribute = attributeDecl.simpleType.list;
				 try {
					 if (isAlistAttribute) {
						 fValENTITIES.validate(attValue, fValidationState);
					 }
					 else {
						 fValENTITY.validate(attValue, fValidationState);
					 }
				 }
				 catch (InvalidDatatypeValueException ex) {
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ex.getKey(), ex.getArgs(), XMLErrorReporter.SEVERITY_ERROR );
				 }
				 break;
			 }
			 case XMLSimpleType.TYPE_NOTATION: case XMLSimpleType.TYPE_ENUMERATION: {
				 boolean found = false;
				 String [] enumVals = attributeDecl.simpleType.enumeration;
				 if (enumVals == null) {
					 found = false;
				 }
				 else for (int i = 0;
				 i < enumVals.length;
				 i++) {
					 if (attValue == enumVals[i] || attValue.equals(enumVals[i])) {
						 found = true;
						 break;
					 }
				 }
				 if (!found) {
					 StringBuffer enumValueString = new StringBuffer();
					 if (enumVals != null) for (int i = 0;
					 i < enumVals.length;
					 i++) {
						 enumValueString.append(enumVals[i]+"" "");
					 }
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_ATTRIBUTE_VALUE_NOT_IN_LIST"", new Object[]{
					attributeDecl.name.rawname, attValue, enumValueString}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
				 break;
			 }
			 case XMLSimpleType.TYPE_ID: {
				 try {
					 fValID.validate(attValue, fValidationState);
				 }
				 catch (InvalidDatatypeValueException ex) {
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ex.getKey(), ex.getArgs(), XMLErrorReporter.SEVERITY_ERROR );
				 }
				 break;
			 }
			 case XMLSimpleType.TYPE_IDREF: {
				 boolean isAlistAttribute = attributeDecl.simpleType.list;
				 try {
					 if (isAlistAttribute) {
						 fValIDRefs.validate(attValue, fValidationState);
					 }
					 else {
						 fValIDRef.validate(attValue, fValidationState);
					 }
				 }
				 catch (InvalidDatatypeValueException ex) {
					 if (isAlistAttribute) {
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""IDREFSInvalid"", new Object[]{
						attValue}
						, XMLErrorReporter.SEVERITY_ERROR );
					 }
					 else {
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ex.getKey(), ex.getArgs(), XMLErrorReporter.SEVERITY_ERROR );
					 }
				 }
				 break;
			 }
			 case XMLSimpleType.TYPE_NMTOKEN: {
				 boolean isAlistAttribute = attributeDecl.simpleType.list;
				 try {
					 if (isAlistAttribute) {
						 fValNMTOKENS.validate(attValue, fValidationState);
					 }
					 else {
						 fValNMTOKEN.validate(attValue, fValidationState);
					 }
				 }
				 catch (InvalidDatatypeValueException ex) {
					 if (isAlistAttribute) {
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""NMTOKENSInvalid"", new Object[] {
						 attValue}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
					 else {
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""NMTOKENInvalid"", new Object[] {
						 attValue}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
				 break;
			 }
		 }
	 }
	 protected boolean invalidStandaloneAttDef(QName element, QName attribute) {
		 boolean state = true;
		 return state;
	 }
	 private boolean normalizeAttrValue(XMLAttributes attributes, int index) {
		 boolean leadingSpace = true;
		 boolean spaceStart = false;
		 boolean readingNonSpace = false;
		 int count = 0;
		 int eaten = 0;
		 String attrValue = attributes.getValue(index);
		 char[] attValue = new char[attrValue.length()];
		 fBuffer.setLength(0);
		 attrValue.getChars(0, attrValue.length(), attValue, 0);
		 for (int i = 0;
		 i < attValue.length;
		 i++) {
			 if (attValue[i] == ' ') {
				 if (readingNonSpace) {
					 spaceStart = true;
					 readingNonSpace = false;
				 }
				 if (spaceStart && !leadingSpace) {
					 spaceStart = false;
					 fBuffer.append(attValue[i]);
					 count++;
				 }
				 else {
					 if (leadingSpace || !spaceStart) {
						 eaten ++;
					 }
				 }
			 }
			 else {
				 readingNonSpace = true;
				 spaceStart = false;
				 leadingSpace = false;
				 fBuffer.append(attValue[i]);
				 count++;
			 }
		 }
		 if (count > 0 && fBuffer.charAt(count-1) == ' ') {
			 fBuffer.setLength(count-1);
		 }
		 String newValue = fBuffer.toString();
		 attributes.setValue(index, newValue);
		 return ! attrValue.equals(newValue);
	 }
	 private final void rootElementSpecified(QName rootElement) throws XNIException {
		 if (fPerformValidation) {
			 String root1 = fRootElement.rawname;
			 String root2 = rootElement.rawname;
			 if (root1 == null || !root1.equals(root2)) {
				 fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, ""RootElementTypeMustMatchDoctypedecl"", new Object[]{
				root1, root2}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
		 }
	 }
	 private int checkContent(int elementIndex, QName[] children, int childOffset, int childCount) throws XNIException {
		 fDTDGrammar.getElementDecl(elementIndex, fTempElementDecl);
		 final String elementType = fCurrentElement.rawname;
		 final int contentType = fCurrentContentSpecType;
		 if (contentType == XMLElementDecl.TYPE_EMPTY) {
			 if (childCount != 0) {
				 return 0;
			 }
		 }
		 else if (contentType == XMLElementDecl.TYPE_ANY) {
		 }
		 else if (contentType == XMLElementDecl.TYPE_MIXED || contentType == XMLElementDecl.TYPE_CHILDREN) {
			 ContentModelValidator cmElem = null;
			 cmElem = fTempElementDecl.contentModelValidator;
			 int result = cmElem.validate(children, childOffset, childCount);
			 return result;
		 }
		 else if (contentType == -1) {
		 }
		 else if (contentType == XMLElementDecl.TYPE_SIMPLE) {
		 }
		 else {
		 }
		 return -1;
	 }
	 private int getContentSpecType(int elementIndex) {
		 int contentSpecType = -1;
		 if (elementIndex > -1) {
			 if (fDTDGrammar.getElementDecl(elementIndex,fTempElementDecl)) {
				 contentSpecType = fTempElementDecl.type;
			 }
		 }
		 return contentSpecType;
	 }
	 private void charDataInContent() {
		 if (DEBUG_ELEMENT_CHILDREN) {
			 System.out.println(""charDataInContent()"");
		 }
		 if (fElementChildren.length <= fElementChildrenLength) {
			 QName[] newarray = new QName[fElementChildren.length * 2];
			 System.arraycopy(fElementChildren, 0, newarray, 0, fElementChildren.length);
			 fElementChildren = newarray;
		 }
		 QName qname = fElementChildren[fElementChildrenLength];
		 if (qname == null) {
			 for (int i = fElementChildrenLength;
			 i < fElementChildren.length;
			 i++) {
				 fElementChildren[i] = new QName();
			 }
			 qname = fElementChildren[fElementChildrenLength];
		 }
		 qname.clear();
		 fElementChildrenLength++;
	 }
	 private String getAttributeTypeName(XMLAttributeDecl attrDecl) {
		 switch (attrDecl.simpleType.type) {
			 case XMLSimpleType.TYPE_ENTITY: {
				 return attrDecl.simpleType.list ? XMLSymbols.fENTITIESSymbol : XMLSymbols.fENTITYSymbol;
			 }
			 case XMLSimpleType.TYPE_ENUMERATION: {
				 StringBuffer buffer = new StringBuffer();
				 buffer.append('(');
				 for (int i=0;
				 i<attrDecl.simpleType.enumeration.length ;
				 i++) {
					 if (i > 0) {
						 buffer.append(""|"");
					 }
					 buffer.append(attrDecl.simpleType.enumeration[i]);
				 }
				 buffer.append(')');
				 return fSymbolTable.addSymbol(buffer.toString());
			 }
			 case XMLSimpleType.TYPE_ID: {
				 return XMLSymbols.fIDSymbol;
			 }
			 case XMLSimpleType.TYPE_IDREF: {
				 return attrDecl.simpleType.list ? XMLSymbols.fIDREFSSymbol : XMLSymbols.fIDREFSymbol;
			 }
			 case XMLSimpleType.TYPE_NMTOKEN: {
				 return attrDecl.simpleType.list ? XMLSymbols.fNMTOKENSSymbol : XMLSymbols.fNMTOKENSymbol;
			 }
			 case XMLSimpleType.TYPE_NOTATION: {
				 return XMLSymbols.fNOTATIONSymbol;
			 }
		 }
		 return XMLSymbols.fCDATASymbol;
	 }
	 protected void init() {
		 if (fValidation || fDynamicValidation) {
			 try {
				 fValID = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fIDSymbol);
				 fValIDRef = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fIDREFSymbol);
				 fValIDRefs = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fIDREFSSymbol);
				 fValENTITY = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fENTITYSymbol);
				 fValENTITIES = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fENTITIESSymbol);
				 fValNMTOKEN = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fNMTOKENSymbol);
				 fValNMTOKENS = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fNMTOKENSSymbol);
				 fValNOTATION = fDatatypeValidatorFactory.getBuiltInDV(XMLSymbols.fNOTATIONSymbol);
			 }
			 catch (Exception e) {
				 e.printStackTrace(System.err);
			 }
		 }
	 }
	 private void ensureStackCapacity (int newElementDepth) {
		 if (newElementDepth == fElementQNamePartsStack.length) {
			 QName[] newStackOfQueue = new QName[newElementDepth * 2];
			 System.arraycopy(this.fElementQNamePartsStack, 0, newStackOfQueue, 0, newElementDepth );
			 fElementQNamePartsStack = newStackOfQueue;
			 QName qname = fElementQNamePartsStack[newElementDepth];
			 if (qname == null) {
				 for (int i = newElementDepth;
				 i < fElementQNamePartsStack.length;
				 i++) {
					 fElementQNamePartsStack[i] = new QName();
				 }
			 }
			 int[] newStack = new int[newElementDepth * 2];
			 System.arraycopy(fElementIndexStack, 0, newStack, 0, newElementDepth);
			 fElementIndexStack = newStack;
			 newStack = new int[newElementDepth * 2];
			 System.arraycopy(fContentSpecTypeStack, 0, newStack, 0, newElementDepth);
			 fContentSpecTypeStack = newStack;
		 }
	 }
	 protected boolean handleStartElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {
		 if (!fSeenRootElement) {
			 fPerformValidation = validate();
			 fSeenRootElement = true;
			 fValidationManager.setEntityState(fDTDGrammar);
			 fValidationManager.setGrammarFound(fSeenDoctypeDecl);
			 rootElementSpecified(element);
		 }
		 if (fDTDGrammar == null) {
			 if (!fPerformValidation) {
				 fCurrentElementIndex = -1;
				 fCurrentContentSpecType = -1;
				 fInElementContent = false;
			 }
			 if (fPerformValidation) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_GRAMMAR_NOT_FOUND"", new Object[]{
				 element.rawname}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
			 if (fDocumentSource !=null ) {
				 fDocumentSource.setDocumentHandler(fDocumentHandler);
				 if (fDocumentHandler != null) fDocumentHandler.setDocumentSource(fDocumentSource);
				 return true;
			 }
		 }
		 else {
			 fCurrentElementIndex = fDTDGrammar.getElementDeclIndex(element);
			 fCurrentContentSpecType = fDTDGrammar.getContentSpecType(fCurrentElementIndex);
			 if (fCurrentContentSpecType == -1 && fPerformValidation) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_ELEMENT_NOT_DECLARED"", new Object[]{
				 element.rawname}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
			 addDTDDefaultAttrsAndValidate(element, fCurrentElementIndex, attributes);
		 }
		 fInElementContent = fCurrentContentSpecType == XMLElementDecl.TYPE_CHILDREN;
		 fElementDepth++;
		 if (fPerformValidation) {
			 if (fElementChildrenOffsetStack.length <= fElementDepth) {
				 int newarray[] = new int[fElementChildrenOffsetStack.length * 2];
				 System.arraycopy(fElementChildrenOffsetStack, 0, newarray, 0, fElementChildrenOffsetStack.length);
				 fElementChildrenOffsetStack = newarray;
			 }
			 fElementChildrenOffsetStack[fElementDepth] = fElementChildrenLength;
			 if (fElementChildren.length <= fElementChildrenLength) {
				 QName[] newarray = new QName[fElementChildrenLength * 2];
				 System.arraycopy(fElementChildren, 0, newarray, 0, fElementChildren.length);
				 fElementChildren = newarray;
			 }
			 QName qname = fElementChildren[fElementChildrenLength];
			 if (qname == null) {
				 for (int i = fElementChildrenLength;
				 i < fElementChildren.length;
				 i++) {
					 fElementChildren[i] = new QName();
				 }
				 qname = fElementChildren[fElementChildrenLength];
			 }
			 qname.setValues(element);
			 fElementChildrenLength++;
		 }
		 fCurrentElement.setValues(element);
		 ensureStackCapacity(fElementDepth);
		 fElementQNamePartsStack[fElementDepth].setValues(fCurrentElement);
		 fElementIndexStack[fElementDepth] = fCurrentElementIndex;
		 fContentSpecTypeStack[fElementDepth] = fCurrentContentSpecType;
		 startNamespaceScope(element, attributes, augs);
		 return false;
	 }
	 protected void startNamespaceScope(QName element, XMLAttributes attributes, Augmentations augs){
	 }
	 protected void handleEndElement(QName element, Augmentations augs, boolean isEmpty) throws XNIException {
		 fElementDepth--;
		 if (fPerformValidation) {
			 int elementIndex = fCurrentElementIndex;
			 if (elementIndex != -1 && fCurrentContentSpecType != -1) {
				 QName children[] = fElementChildren;
				 int childrenOffset = fElementChildrenOffsetStack[fElementDepth + 1] + 1;
				 int childrenLength = fElementChildrenLength - childrenOffset;
				 int result = checkContent(elementIndex, children, childrenOffset, childrenLength);
				 if (result != -1) {
					 fDTDGrammar.getElementDecl(elementIndex, fTempElementDecl);
					 if (fTempElementDecl.type == XMLElementDecl.TYPE_EMPTY) {
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_CONTENT_INVALID"", new Object[]{
						 element.rawname, ""EMPTY""}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
					 else {
						 String messageKey = result != childrenLength ? ""MSG_CONTENT_INVALID"" : ""MSG_CONTENT_INCOMPLETE"";
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, messageKey, new Object[]{
						 element.rawname, fDTDGrammar.getContentSpecAsString(elementIndex)}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
			 }
			 fElementChildrenLength = fElementChildrenOffsetStack[fElementDepth + 1] + 1;
		 }
		 endNamespaceScope(fCurrentElement, augs, isEmpty);
		 if (fElementDepth < -1) {
			 throw new RuntimeException(""FWK008 Element stack underflow"");
		 }
		 if (fElementDepth < 0) {
			 fCurrentElement.clear();
			 fCurrentElementIndex = -1;
			 fCurrentContentSpecType = -1;
			 fInElementContent = false;
			 if (fPerformValidation) {
				 String value = fValidationState.checkIDRefID();
				 if (value != null) {
					 fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, ""MSG_ELEMENT_WITH_ID_REQUIRED"", new Object[]{
					value}
					, XMLErrorReporter.SEVERITY_ERROR );
				 }
			 }
			 return;
		 }
		 fCurrentElement.setValues(fElementQNamePartsStack[fElementDepth]);
		 fCurrentElementIndex = fElementIndexStack[fElementDepth];
		 fCurrentContentSpecType = fContentSpecTypeStack[fElementDepth];
		 fInElementContent = (fCurrentContentSpecType == XMLElementDecl.TYPE_CHILDREN);
	 }
	 protected void endNamespaceScope(QName element, Augmentations augs, boolean isEmpty){
		 if (fDocumentHandler != null && !isEmpty) {
			 fDocumentHandler.endElement(fCurrentElement, augs);
		 }
	 }
	 protected boolean isSpace(int c) {
		 return XMLChar.isSpace(c);
	 }
	 public boolean characterData(String data, Augmentations augs) {
		 characters(new XMLString(data.toCharArray(), 0, data.length()), augs);
		 return true;
	 }
}",1,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 int width = originalImage.getWidth();
	 int height = originalImage.getHeight();
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 int centerI = width / 2;
	 int centerJ = height / 2;
	 int lengthI = width / 4;
	 int lengthJ = height / 6;
	 int startI = centerI - lengthI / 2;
	 int goalI = centerI + lengthI / 2;
	 int startJ = centerJ - lengthJ / 2;
	 int goalJ = centerJ + lengthJ / 2;
	 boolean[][] visited;
	 visited = new boolean[width][height];
	 int color;
	 for (int i = startI;
	 i < goalI;
	 i++) {
		 for (int j = startJ;
		 j < goalJ;
		 j++) {
			 color = new Color(originalImage.getRGB(i, j)).getRed();
			 if (color == 0) {
				 if (!visited[i][j]) {
					 BFS(i, j, visited);
				 }
			 }
		 }
	 }
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 if (!visited[i][j]) {
				 int white = 255;
				 color = ImageUtilities.colorToRGB(alpha, white, white, white);
				 filteredImage.setRGB(i, j, color);
			 }
			 else {
				 int black = 0;
				 color = ImageUtilities.colorToRGB(alpha, black, black, black);
				 filteredImage.setRGB(i, j, color);
			 }
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"protected HttpMethod buildLogonMethod(HttpClient httpClient, HttpMethod initmethod) throws IOException {
	 HttpMethod logonMethod = null;
	 HtmlCleaner cleaner = new HtmlCleaner();
	 userNameInputs.clear();
	 try {
		 TagNode node = cleaner.clean(initmethod.getResponseBodyAsStream());
		 List forms = node.getElementListByName(""form"", true);
		 TagNode logonForm = null;
		 if (forms.size() == 1) {
			 logonForm = (TagNode) forms.get(0);
		 }
		 else if (forms.size() > 1) {
			 for (Object form : forms) {
				 if (""logonForm"".equals(((TagNode) form).getAttributeByName(""name""))) {
					 logonForm = ((TagNode) form);
				 }
			 }
		 }
		 if (logonForm != null) {
			 String logonMethodPath = logonForm.getAttributeByName(""action"");
			 if (logonMethodPath != null && logonMethodPath.length() == 0) {
				 logonMethodPath = ""/owa/auth.owa"";
			 }
			 logonMethod = new PostMethod(getAbsoluteUri(initmethod, logonMethodPath));
			 List inputList = node.getElementListByName(""input"", true);
			 for (Object input : inputList) {
				 String type = ((TagNode) input).getAttributeByName(""type"");
				 String name = ((TagNode) input).getAttributeByName(""name"");
				 String value = ((TagNode) input).getAttributeByName(""value"");
				 if (""hidden"".equalsIgnoreCase(type) && name != null && value != null) {
					 ((PostMethod) logonMethod).addParameter(name, value);
				 }
				 if (USER_NAME_FIELDS.contains(name)) {
					 userNameInputs.add(name);
				 }
				 else if (PASSWORD_FIELDS.contains(name)) {
					 passwordInput = name;
				 }
				 else if (""addr"".equals(name)) {
					 HttpMethod newInitMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, logonMethod);
					 logonMethod = buildLogonMethod(httpClient, newInitMethod);
				 }
				 else if (TOKEN_FIELDS.contains(name)) {
					 ((PostMethod) logonMethod).addParameter(name, DavGatewayOTPPrompt.getOneTimePassword());
				 }
				 else if (""otc"".equals(name)) {
					 String pinsafeUser = getAliasFromLogin();
					 if (pinsafeUser == null) {
						 pinsafeUser = userName;
					 }
					 GetMethod getMethod = new GetMethod(""/PINsafeISAFilter.dll?username="" + pinsafeUser);
					 try {
						 int status = httpClient.executeMethod(getMethod);
						 if (status != HttpStatus.SC_OK) {
							 throw DavGatewayHttpClientFacade.buildHttpException(getMethod);
						 }
						 BufferedImage captchaImage = ImageIO.read(getMethod.getResponseBodyAsStream());
						 ((PostMethod) logonMethod).addParameter(name, DavGatewayOTPPrompt.getCaptchaValue(captchaImage));
					 }
					 finally {
						 getMethod.releaseConnection();
					 }
				 }
			 }
		 }
		 else {
			 List frameList = node.getElementListByName(""frame"", true);
			 if (frameList.size() == 1) {
				 String src = ((TagNode) frameList.get(0)).getAttributeByName(""src"");
				 if (src != null) {
					 LOGGER.debug(""Frames detected in form page, try frame content"");
					 initmethod.releaseConnection();
					 HttpMethod newInitMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, src);
					 logonMethod = buildLogonMethod(httpClient, newInitMethod);
				 }
			 }
			 else {
				 List scriptList = node.getElementListByName(""script"", true);
				 for (Object script : scriptList) {
					 List contents = ((TagNode) script).getChildren();
					 for (Object content : contents) {
						 if (content instanceof CommentNode) {
							 String scriptValue = ((CommentNode) content).getCommentedContent();
							 String sUrl = StringUtil.getToken(scriptValue, ""var a_sUrl = \"""", ""\"""");
							 String sLgn = StringUtil.getToken(scriptValue, ""var a_sLgnQS = \"""", ""\"""");
							 if (sLgn == null) {
								 sLgn = StringUtil.getToken(scriptValue, ""var a_sLgn = \"""", ""\"""");
							 }
							 if (sUrl != null && sLgn != null) {
								 String src = getScriptBasedFormURL(initmethod, sLgn + sUrl);
								 LOGGER.debug(""Detected script based logon, redirect to form at "" + src);
								 HttpMethod newInitMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, src);
								 logonMethod = buildLogonMethod(httpClient, newInitMethod);
							 }
						 }
						 else if (content instanceof ContentNode) {
							 String scriptValue = ((ContentNode) content).getContent().toString();
							 String location = StringUtil.getToken(scriptValue, ""window.location.replace(\"""", ""\"""");
							 if (location != null) {
								 LOGGER.debug(""Post logon redirect to: "" + location);
								 logonMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, location);
							 }
						 }
					 }
				 }
			 }
		 }
	 }
	 catch (IOException e) {
		 LOGGER.error(""Error parsing login form at "" + initmethod.getURI());
	 }
	 finally {
		 initmethod.releaseConnection();
	 }
	 return logonMethod;
 }",0,0,1,0
"public class Equal implements CompareOp {
	 private PrimitiveComparison comp;
	 public Equal() {
	}
	 public Equal(PrimitiveComparison comp) {
		 this.comp = comp;
	 }
	 public void setPrimitiveCompare(PrimitiveComparison comp) {
		 this.comp = comp;
	 }
	 public PrimitiveComparison getPrimitiveCompare() {
		 return comp;
	 }
	 public boolean accept(byte[] val) {
		 return comp.isEqual(val);
	 }
}",0,0,0,0
"public long getBytesComplete() {
	 return bytesComplete;
 }",0,0,0,0
"public void configure(Context context) {
	 this.headerName = context.getString(CONFIG_MULTIPLEX_HEADER_NAME, DEFAULT_MULTIPLEX_HEADER);
	 Map<String, Channel> channelNameMap = getChannelNameMap();
	 defaultChannels = getChannelListFromNames( context.getString(CONFIG_DEFAULT_CHANNEL), channelNameMap);
	 Map<String, String> mapConfig = context.getSubProperties(CONFIG_PREFIX_MAPPING);
	 channelMapping = new HashMap<String, List<Channel>>();
	 for (String headerValue : mapConfig.keySet()) {
		 List<Channel> configuredChannels = getChannelListFromNames( mapConfig.get(headerValue), channelNameMap);
		 if (configuredChannels.size() == 0) {
			 throw new FlumeException(""No channel configured for when "" + ""header value is: "" + headerValue);
		 }
		 if (channelMapping.put(headerValue, configuredChannels) != null) {
			 throw new FlumeException(""Selector channel configured twice"");
		 }
	 }
	 Map<String, String> optionalChannelsMapping = context.getSubProperties(CONFIG_PREFIX_OPTIONAL + ""."");
	 optionalChannels = new HashMap<String, List<Channel>>();
	 for (String hdr : optionalChannelsMapping.keySet()) {
		 List<Channel> confChannels = getChannelListFromNames( optionalChannelsMapping.get(hdr), channelNameMap);
		 if (confChannels.isEmpty()) {
			 confChannels = EMPTY_LIST;
		 }
		 List<Channel> reqdChannels = channelMapping.get(hdr);
		 if (reqdChannels == null || reqdChannels.isEmpty()) {
			 reqdChannels = defaultChannels;
		 }
		 for (Channel c : reqdChannels) {
			 if (confChannels.contains(c)) {
				 confChannels.remove(c);
			 }
		 }
		 if (optionalChannels.put(hdr, confChannels) != null) {
			 throw new FlumeException(""Selector channel configured twice"");
		 }
	 }
 }",0,0,1,0
protected List<Object> getConfigurableObjects();,0,0,0,0
"public class ConditionTask extends ConditionBase {
	 private String property = null;
	 private Object value = ""true"";
	 private Object alternative = null;
	 public ConditionTask() {
		 super(""condition"");
	 }
	 public void setProperty(String p) {
		 property = p;
	 }
	 public void setValue(Object value) {
		 this.value = value;
	 }
	 public void setValue(String v) {
		 setValue((Object) v);
	 }
	 public void setElse(Object alt) {
		 alternative = alt;
	 }
	 public void setElse(String e) {
		 setElse((Object) e);
	 }
	 public void execute() throws BuildException {
		 if (countConditions() > 1) {
			 throw new BuildException(""You must not nest more than one condition into <"" + getTaskName() + "">"");
		 }
		 if (countConditions() < 1) {
			 throw new BuildException(""You must nest a condition into <"" + getTaskName() + "">"");
		 }
		 if (property == null) {
			 throw new BuildException(""The property attribute is required."");
		 }
		 Condition c = (Condition) getConditions().nextElement();
		 if (c.eval()) {
			 log(""Condition true;
			 setting "" + property + "" to "" + value, Project.MSG_DEBUG);
			 PropertyHelper.getPropertyHelper(getProject()).setNewProperty(property, value);
		 }
		 else if (alternative != null) {
			 log(""Condition false;
			 setting "" + property + "" to "" + alternative, Project.MSG_DEBUG);
			 PropertyHelper.getPropertyHelper(getProject()).setNewProperty(property, alternative);
		 }
		 else {
			 log(""Condition false;
			 not setting "" + property, Project.MSG_DEBUG);
		 }
	 }
}",0,0,0,0
"static void exception(int offset, int line, int column, String msg) throws ParsingException;",0,0,0,1
"public final class ZipLong implements Cloneable {
	 private static final int WORD = 4;
	 private static final int BYTE_BIT_SIZE = 8;
	 private static final int BYTE_MASK = 0xFF;
	 private static final int BYTE_1 = 1;
	 private static final int BYTE_1_MASK = 0xFF00;
	 private static final int BYTE_1_SHIFT = 8;
	 private static final int BYTE_2 = 2;
	 private static final int BYTE_2_MASK = 0xFF0000;
	 private static final int BYTE_2_SHIFT = 16;
	 private static final int BYTE_3 = 3;
	 private static final long BYTE_3_MASK = 0xFF000000L;
	 private static final int BYTE_3_SHIFT = 24;
	 private long value;
	 public ZipLong(long value) {
		 this.value = value;
	 }
	 public ZipLong (byte[] bytes) {
		 this(bytes, 0);
	 }
	 public ZipLong (byte[] bytes, int offset) {
		 value = ZipLong.getValue(bytes, offset);
	 }
	 public byte[] getBytes() {
		 return ZipLong.getBytes(value);
	 }
	 public long getValue() {
		 return value;
	 }
	 public static byte[] getBytes(long value) {
		 byte[] result = new byte[WORD];
		 result[0] = (byte) ((value & BYTE_MASK));
		 result[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);
		 result[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);
		 result[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);
		 return result;
	 }
	 public static long getValue(byte[] bytes, int offset) {
		 long value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;
		 value += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;
		 value += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;
		 value += (bytes[offset] & BYTE_MASK);
		 return value;
	 }
	 public static long getValue(byte[] bytes) {
		 return getValue(bytes, 0);
	 }
	 public boolean equals(Object o) {
		 if (o == null || !(o instanceof ZipLong)) {
			 return false;
		 }
		 return value == ((ZipLong) o).getValue();
	 }
	 public int hashCode() {
		 return (int) value;
	 }
}",0,0,0,0
"public static String getDefaultIndexName(String cfName, AbstractType<T> comparator, ByteBuffer columnName) {
	 return (cfName + ""_"" + comparator.getString(columnName) + ""_idx"").replaceAll(""\\W"", """");
 }",0,0,0,0
"public abstract class ConnectionFactoryUtils {
	private static final Log logger = LogFactory.getLog(ConnectionFactoryUtils.class);
	public static Connection getConnection(ConnectionFactory cf) throws CannotGetCciConnectionException {
		return getConnection(cf, null);
	}
	public static Connection getConnection(ConnectionFactory cf, ConnectionSpec spec)throws CannotGetCciConnectionException {
		try {
			if (spec != null) {
				Assert.notNull(cf, ""No ConnectionFactory specified"");
				return cf.getConnection(spec);
			}
			else {
				return doGetConnection(cf);
			}
		}
		catch (ResourceException ex) {
			throw new CannotGetCciConnectionException(""Could not get CCI Connection"", ex);
		}
	}
	public static Connection doGetConnection(ConnectionFactory cf) throws ResourceException {
		Assert.notNull(cf, ""No ConnectionFactory specified"");
		ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(cf);
		if (conHolder != null) {
			return conHolder.getConnection();
		}
		logger.debug(""Opening CCI Connection"");
		Connection con = cf.getConnection();
		if (TransactionSynchronizationManager.isSynchronizationActive()) {
			conHolder = new ConnectionHolder(con);
			conHolder.setSynchronizedWithTransaction(true);
			TransactionSynchronizationManager.registerSynchronization(new ConnectionSynchronization(conHolder, cf));
			TransactionSynchronizationManager.bindResource(cf, conHolder);
		}
		return con;
	}
	public static boolean isConnectionTransactional(Connection con, ConnectionFactory cf) {
		if (cf == null) {
			return false;
		}
		ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(cf);
		return (conHolder != null && conHolder.getConnection() == con);
	}
	public static void releaseConnection( Connection con, ConnectionFactory cf) {
		try {
			doReleaseConnection(con, cf);
		}
		catch (ResourceException ex) {
			logger.debug(""Could not close CCI Connection"", ex);
		}
		catch (Throwable ex) {
			logger.debug(""Unexpected exception on closing CCI Connection"", ex);
		}
	}
	public static void doReleaseConnection( Connection con, ConnectionFactory cf)throws ResourceException {
		if (con == null || isConnectionTransactional(con, cf)) {
			return;
		}
		con.close();
	}
	private static class ConnectionSynchronizationextends ResourceHolderSynchronization<ConnectionHolder, ConnectionFactory> {
		public ConnectionSynchronization(ConnectionHolder connectionHolder, ConnectionFactory connectionFactory) {
			super(connectionHolder, connectionFactory);
		}
		protected void releaseResource(ConnectionHolder resourceHolder, ConnectionFactory resourceKey) {
			releaseConnection(resourceHolder.getConnection(), resourceKey);
		}
	}
}",0,0,0,0
"public class RadioDirective extends AbstractDirective {
	 public String getBeanName() {
		 return ""radio"";
	 }
	 protected Component getBean(ValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		 return new Radio(stack, req, res);
	 }
}",0,0,0,0
"abstract static class Builder<T> {
	 abstract Builder<T> setHosts(List<String> hosts);
	 abstract Builder<T> setPort(Integer port);
	 abstract Builder<T> setKeyspace(String keyspace);
	 abstract Builder<T> setEntity(Class<T> entity);
	 abstract Builder<T> setUsername(String username);
	 abstract Builder<T> setPassword(String password);
	 abstract Builder<T> setLocalDc(String localDc);
	 abstract Builder<T> setConsistencyLevel(String consistencyLevel);
	 abstract Builder<T> setMutationType(MutationType mutationType);
	 abstract Write<T> build();
 }",0,1,0,0
"public class QuickServer implements Runnable, Service, Cloneable, Serializable {
	private final static String VER = ""1.4.7"";
	private final static String NEW_LINE = ""\r\n"";
	static {
		System.out.print(""Loading QuickServer v""+getVersion()+"" "");
	}
	private String serverBanner;
	private String clientAuthenticationHandlerString;
	 private String clientEventHandlerString;
	 private String clientExtendedEventHandlerString;
	 private String clientCommandHandlerString;
	private String clientObjectHandlerString;
	 private String clientBinaryHandlerString;
	 private String clientWriteHandlerString;
	 private String clientDataString;
	private Authenticator authenticator;
	private ClientAuthenticationHandler clientAuthenticationHandler;
	 private ClientEventHandler clientEventHandler;
	 private ClientExtendedEventHandler clientExtendedEventHandler;
	 private ClientCommandHandler clientCommandHandler;
	private ClientObjectHandler clientObjectHandler;
	 private ClientBinaryHandler clientBinaryHandler;
	 private ClientWriteHandler clientWriteHandler;
	 private ClientData clientData;
	protected Class clientDataClass;
	private int serverPort = 9876;
	private Thread t;
	 private ServerSocket server;
	private String serverName = ""QuickServer"";
	private long maxConnection = -1;
	private int socketTimeout = 60 * 1000;
	 private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";
	private String timeoutMsg = ""-ERR Timeout"";
	private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";
	private int maxAuthTry = 5;
	 static {
		System.out.print(""."");
	}
	private InetAddress ipAddr;
	private boolean stopServer;
	private Object[] storeObjects;
	private QSAdminServer adminServer;
	private static final Logger logger = Logger.getLogger(QuickServer.class.getName());
	private Logger appLogger;
	private long suspendMaxConnection;
	 private String suspendMaxConnectionMsg;
	 private int serviceState = Service.UNKNOWN;
	static {
		System.out.print(""."");
	}
	private QuickServerConfig config = new QuickServerConfig();
	private String consoleLoggingformatter;
	private String consoleLoggingLevel = ""INFO"";
	private ClientPool pool;
	private ObjectPool clientHandlerPool;
	private ObjectPool clientDataPool;
	private DBPoolUtil dBPoolUtil;
	private String loggingLevel = ""INFO"";
	private boolean skipValidation = false;
	private boolean communicationLogging = true;
	private String securityManagerClass;
	private AccessConstraintConfig accessConstraintConfig;
	private ClassLoader classLoader;
	private String applicationJarPath;
	private ServerHooks serverHooks;
	private ArrayList listOfServerHooks;
	static {
		System.out.print(""."");
	}
	private Secure secure;
	private BasicServerConfig basicConfig = config;
	private SSLContext sslc;
	private KeyManager km[] = null;
	private TrustManager tm[] = null;
	private boolean runningSecure = false;
	private SecureStoreManager secureStoreManager = null;
	private Exception exceptionInRun = null;
	private ServerSocketChannel serverSocketChannel;
	private Selector selector;
	private boolean blockingMode = true;
	private ObjectPool byteBufferPool;
	private java.util.Date lastStartTime;
	private ClientIdentifier clientIdentifier;
	private GhostSocketReaper ghostSocketReaper;
	private PoolManager poolManager;
	private QSObjectPoolMaker qsObjectPoolMaker;
	private DataMode defaultDataModeIN = DataMode.STRING;
	private DataMode defaultDataModeOUT = DataMode.STRING;
	private Throwable serviceError;
	private Map registerChannelRequestMap;
	static {
		System.out.println("" Done"");
	}
	public static final String getVersion() {
		return VER;
	}
	public static final float getVersionNo() {
		return getVersionNo(VER);
	}
	public static final float getVersionNo(String ver) {
		float version = 0;
		int i = ver.indexOf("" "");
		 if(i == -1)i = ver.length();
		ver = ver.substring(0, i);
		i = ver.indexOf(""."");
		 if(i!=-1) {
			int j = ver.indexOf(""."", i);
			if(j!=-1) {
				ver = ver.substring(0, i)+"".""+MyString.replaceAll(ver.substring(i+1), ""."", """");
			}
		}
		try{
			version = Float.parseFloat(ver);
		}
		 catch(NumberFormatException e) {
			throw new RuntimeException(""Corrupt QuickServer"");
		}
		return version;
	}
	public static String getNewLine() {
		return NEW_LINE;
	}
	public String toString() {
		return serverName + "" : "" + getPort();
	}
	public QuickServer() {
	}
	public QuickServer(String commandHandler) {
		setClientCommandHandler(commandHandler);
	}
	public QuickServer(String commandHandler,int port) {
		this(commandHandler);
		 setPort(port);
	}
	public void startServer() throws AppException {
		logger.fine(""Starting ""+getName());
		if(isClosed() == false) {
			logger.warning(""Server ""+getName()+"" already running."");
			throw new AppException(""Server ""+getName()+"" already running."");
		}
		if(serverBanner == null) {
			serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
			logger.finest(""Default Server Banner Generated"");
		}
		try{
			loadApplicationClasses();
			Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
			clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
			clientIdentifier.setQuickServer(QuickServer.this);
			Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
			poolManager = (PoolManager) poolManagerClass.newInstance();
			Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
			qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
			loadServerHooksClasses();
			processServerHooks(ServerHook.PRE_STARTUP);
			if(getSecure().isLoad()==true)loadSSLContext();
			 loadBusinessLogic();
		}
		 catch(ClassNotFoundException e) {
			logger.severe(""Could not load class/s : "" + e.getMessage());
			throw new AppException(""Could not load class/s : "" + e.getMessage());
		}
		 catch(InstantiationException e) {
			logger.severe(""Could not instantiate class/s : "" + e.getMessage());
			throw new AppException(""Could not instantiate class/s : ""+e.getMessage());
		}
		 catch(IllegalAccessException e) {
			logger.severe(""Illegal access to class/s : "" + e.getMessage());
			throw new AppException(""Illegal access to class/s : "" + e.getMessage());
		}
		 catch(IOException e) {
			logger.severe(""IOException : "" + e.getMessage());
			logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
			throw new AppException(""IOException : "" + e.getMessage());
		}
		 catch(Exception e) {
			logger.severe(""Exception : "" + e.getMessage());
			logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
			throw new AppException(""Exception : "" + e);
		}
		if(getSecurityManagerClass()!=null) {
			System.setSecurityManager(getSecurityManager());
		}
		blockingMode = getBasicConfig().getServerMode().getBlocking();
		setServiceState(Service.INIT);
		t = new Thread(this, ""QuickServer - ""+getName());
		t.start();
		do {
			Thread.yield();
		}
		 while(getServiceState()==Service.INIT);
		if(getServiceState()!=Service.RUNNING) {
			if(exceptionInRun!=null)throw new AppException(""Could not start server ""+getName()+""! Details: ""+exceptionInRun);
			elsethrow new AppException(""Could not start server ""+getName());
		}
		lastStartTime = new java.util.Date();
		logger.fine(""Started ""+getName()+"", Date: ""+lastStartTime);
	}
	public void stopServer() throws AppException {
		processServerHooks(ServerHook.PRE_SHUTDOWN);
		logger.warning(""Stopping ""+getName());
		stopServer = true;
		Socket death = null;
		if(isClosed()==true) {
			logger.warning(""Server ""+getName()+"" is not running!"");
			throw new AppException(""Server ""+getName()+"" is not running!"");
		}
		try{
			if(getBlockingMode()==true) {
				if(getSecure().isEnable()==false) {
					death = new Socket(server.getInetAddress(), server.getLocalPort());
					death.getInputStream().read();
					death.close();
				}
				 else {
					death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
					Thread.currentThread().sleep(100);
					death.close();
				}
			}
			if(serverSocketChannel!=null) {
				serverSocketChannel.close();
			}
		}
		 catch(IOException e){
			logger.fine(""IOError stopping ""+getName()+"": ""+e);
		}
		 catch(Exception e){
			logger.warning(""Error stopping ""+getName()+"": ""+e);
			throw new AppException(""Error in stopServer ""+getName()+"": ""+e);
		}
		for(int i=0;
		getServiceState()!=Service.STOPPED;
		i++) {
			try {
				Thread.sleep(60);
			}
			 catch(Exception e) {
				logger.warning(""Error waiting for ""+getName()+"" to fully stop. Error: ""+e);
			}
			if(i>1000) {
				logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
				System.exit(-1);
			}
		}
		if(adminServer==null || getQSAdminServer().getServer()!=this) {
			setClassLoader(null);
		}
		logger.info(""Stopped ""+getName());
	}
	public void restartServer() throws AppException {
		stopServer();
		startServer();
	}
	public String getName() {
		return serverName;
	}
	public void setName(String name) {
		serverName = name;
		logger.finest(""Set to : ""+name);
	}
	public String getServerBanner() {
		return serverBanner;
	}
	public void setServerBanner(String banner) {
		serverBanner = banner;
		logger.finest(""Set to : ""+banner);
	}
	public void setPort(int port) {
		if(port<0) {
			throw new IllegalArgumentException(""Port number can not be less than 0!"");
		}
		serverPort=port;
		logger.finest(""Set to ""+port);
	}
	public int getPort() {
		if(isClosed()==false) {
			return server.getLocalPort();
		}
		if(getSecure().isEnable()==false) {
			return serverPort;
		}
		 else {
			int _port = getSecure().getPort();
			if(_port == -1) return serverPort;
			elsereturn _port;
		}
	}
	public void setClientCommandHandler(String handler) {
		clientCommandHandlerString = handler;
		logger.finest(""Set to ""+handler);
	}
	public String getClientCommandHandler() {
		return clientCommandHandlerString;
	}
	public void setClientAuthenticationHandler(String authenticator) {
		clientAuthenticationHandlerString = authenticator;
		logger.finest(""Set to ""+authenticator);
	}
	public String getClientAuthenticationHandler() {
		return clientAuthenticationHandlerString;
	}
	public void setAuthenticator(String authenticator) {
		clientAuthenticationHandlerString = authenticator;
		logger.finest(""Set to ""+authenticator);
	}
	public String getAuthenticator() {
		return clientAuthenticationHandlerString;
	}
	public void setClientData(String data) {
		this.clientDataString = data;
		logger.finest(""Set to ""+data);
	}
	public String getClientData() {
		return clientDataString;
	}
	public void setTimeout(int time) {
		if(time>0)socketTimeout = time;
		elsesocketTimeout = 0;
		logger.finest(""Set to ""+socketTimeout);
	}
	public int getTimeout() {
		return socketTimeout;
	}
	public void setMaxAuthTry(int authTry) {
		maxAuthTry = authTry;
		logger.finest(""Set to ""+authTry);
	}
	public int getMaxAuthTry() {
		return maxAuthTry;
	}
	public void setMaxAuthTryMsg(String msg) {
		maxAuthTryMsg = msg;
		logger.finest(""Set to ""+msg);
	}
	public String getMaxAuthTryMsg() {
		return maxAuthTryMsg;
	}
	public void setTimeoutMsg(String msg) {
		timeoutMsg = msg;
		logger.finest(""Set to ""+msg);
	}
	public String getTimeoutMsg() {
		return timeoutMsg;
	}
	private TheClient initTheClient() {
		TheClient theClient = new TheClient();
		theClient.setServer(QuickServer.this);
		theClient.setTimeoutMsg(getTimeoutMsg());
		theClient.setMaxAuthTry(getMaxAuthTry());
		 theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
		theClient.setClientEventHandler(clientEventHandler);
		theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
		 theClient.setClientCommandHandler(clientCommandHandler);
		theClient.setClientObjectHandler(clientObjectHandler);
		 theClient.setClientBinaryHandler(clientBinaryHandler);
		 theClient.setClientWriteHandler(clientWriteHandler);
		 theClient.setAuthenticator(authenticator);
		 theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
		 theClient.setTimeout(socketTimeout);
		theClient.setMaxConnectionMsg(maxConnectionMsg);
		theClient.setCommunicationLogging(getCommunicationLogging());
		 return theClient;
	}
	public void run() {
		exceptionInRun = null;
		TheClient theClient = initTheClient();
		try {
			stopServer = false;
			closeAllPools();
			initAllPools();
			makeServerSocket();
			System.out.println(serverBanner);
			 setServiceState(Service.RUNNING);
			 processServerHooks(ServerHook.POST_STARTUP);
			 if(getBlockingMode()==false) {
				runNonBlocking(theClient);
				if(stopServer==true) {
					logger.finest(""Closing selector for ""+getName());
					selector.close();
				}
				return;
			}
			 else {
				runBlocking(theClient);
			}
		}
		 catch(BindException e) {
			exceptionInRun = e;
			logger.severe(getName()+"" BindException for Port ""+getPort()+"" @ ""+getBindAddr().getHostAddress()+"" : ""+e.getMessage());
		}
		 catch(javax.net.ssl.SSLException e) {
			exceptionInRun = e;
			logger.severe(""SSLException ""+e);
			logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
		}
		 catch(IOException e) {
			exceptionInRun = e;
			logger.severe(""IOError ""+e);
			logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
		}
		 catch(Exception e) {
			exceptionInRun = e;
			logger.severe(""Error ""+e);
			logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
		}
		 finally {
			if(getBlockingMode()==true) {
				logger.warning(""Closing ""+getName());
				try{
					if(isClosed()==false) {
						server.close();
					}
				}
				 catch(Exception e){
					throw new RuntimeException(e);
				}
				server = null;
				serverSocketChannel = null;
				setServiceState(Service.STOPPED);
				logger.warning(""Closed ""+getName());
				processServerHooks(ServerHook.POST_SHUTDOWN);
			}
			 else if(getBlockingMode()==false && exceptionInRun!=null) {
				logger.warning(""Closing ""+getName()+"" - Had Error: ""+exceptionInRun);
				try{
					if(isClosed()==false) {
						if(serverSocketChannel!=null)serverSocketChannel.close();
						if(server!=null)server.close();
					}
				}
				 catch(Exception e){
					throw new RuntimeException(e);
				}
				server = null;
				serverSocketChannel = null;
				setServiceState(Service.STOPPED);
				logger.warning(""Closed ""+getName());
				processServerHooks(ServerHook.POST_SHUTDOWN);
			}
		}
	}
	 public void setMaxConnection(long maxConnection) {
		if(getServiceState()==Service.SUSPENDED)suspendMaxConnection = maxConnection;
		elsethis.maxConnection = maxConnection;
		logger.finest(""Set to ""+maxConnection);
	}
	public long getMaxConnection() {
		return maxConnection;
	}
	public long getClientCount() {
		if(clientHandlerPool != null) {
			try {
				return getClientHandlerPool().getNumActive();
			}
			 catch(Exception e) {
				return 0;
			}
		}
		return 0;
	}
	public void setMaxConnectionMsg(String maxConnectionMsg) {
		if(getServiceState() == Service.SUSPENDED)suspendMaxConnectionMsg = maxConnectionMsg;
		elsethis.maxConnectionMsg = maxConnectionMsg;
		logger.finest(""Set to ""+maxConnectionMsg);
	}
	public String getMaxConnectionMsg() {
		return maxConnectionMsg;
	}
	public void setBindAddr(String bindAddr) throws UnknownHostException {
		ipAddr = InetAddress.getByName(bindAddr);
		logger.finest(""Set to ""+bindAddr);
	}
	public InetAddress getBindAddr() {
		if(ipAddr==null) {
			try{
				ipAddr = InetAddress.getByName(""0.0.0.0"");
			}
			 catch(Exception e){
				logger.warning(""Unable to create default ip(0.0.0.0) : ""+e);
				throw new RuntimeException(""Error: Unable to find servers own ip : ""+e);
			}
		}
		return ipAddr;
	}
	public void setStoreObjects(Object[] storeObjects) {
		this.storeObjects = storeObjects;
	}
	public Object[] getStoreObjects() {
		return storeObjects;
	}
	public void setQSAdminServerPort(int port) {
		getQSAdminServer().getServer().setPort(port);
	}
	public int getQSAdminServerPort() {
		return getQSAdminServer().getServer().getPort();
	}
	public void setQSAdminServerAuthenticator(String authenticator) {
		getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
	}
	public String getQSAdminServerAuthenticator() {
		return getQSAdminServer().getServer().getAuthenticator();
	}
	public void startQSAdminServer(int port, String authenticator) throws AppException {
		getQSAdminServer().setClientAuthenticationHandler(authenticator);
		getQSAdminServer().startServer(port);
	}
	public void startQSAdminServer() throws AppException {
		getQSAdminServer().startServer();
	}
	public QSAdminServer getQSAdminServer() {
		if(adminServer==null)adminServer = new QSAdminServer(QuickServer.this);
		return adminServer;
	}
	public void setQSAdminServer(QSAdminServer adminServer) {
		if(adminServer==null)this.adminServer = adminServer;
	}
	public boolean isClosed() {
		if(server==null)return true;
		return server.isClosed();
	}
	public Logger getAppLogger() {
		if(appLogger!=null)return appLogger;
		return logger;
	}
	public void setAppLogger(Logger appLogger) {
		this.appLogger = appLogger;
	}
	public void setClientObjectHandler(String handler) {
		clientObjectHandlerString = handler;
		logger.finest(""Set to ""+handler);
	}
	public String getClientObjectHandler() {
		return clientObjectHandlerString;
	}
	public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException,IllegalAccessException {
		if(formatter==null)return;
		consoleLoggingformatter = formatter;
		Formatter conformatter = (Formatter) getClass(formatter, true).newInstance();
		Logger jdkLogger = Logger.getLogger("""");
		Handler[] handlers = jdkLogger.getHandlers();
		for(int index = 0;
		 index < handlers.length;
		 index++ ) {
			if(ConsoleHandler.class.isInstance(handlers[index])) {
				handlers[index].setFormatter(conformatter);
			}
		}
		logger.finest(""Set to ""+formatter);
	}
	public String getConsoleLoggingFormatter() {
		return consoleLoggingformatter;
	}
	public void setConsoleLoggingToMini() {
		try{
			setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
		}
		 catch(Exception e) {
			logger.warning(""Setting to logging.MiniFormatter : ""+e);
		}
	}
	public void setConsoleLoggingToMicro() {
		try{
			setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
		}
		 catch(Exception e) {
			logger.warning(""Setting to MicroFormatter : ""+e);
		}
	}
	public void setConsoleLoggingLevel(Level level) {
		Logger rlogger = Logger.getLogger("""");
		Handler[] handlers = rlogger.getHandlers();
		for(int index = 0;
		 index < handlers.length;
		 index++ ) {
			if(ConsoleHandler.class.isInstance(handlers[index])) {
				handlers[index].setLevel(level);
			}
		}
		if(level==Level.SEVERE)consoleLoggingLevel = ""SEVERE"";
		else if(level==Level.WARNING)consoleLoggingLevel = ""WARNING"";
		else if(level==Level.INFO)consoleLoggingLevel = ""INFO"";
		else if(level==Level.CONFIG)consoleLoggingLevel = ""CONFIG"";
		else if(level==Level.FINE)consoleLoggingLevel = ""FINE"";
		else if(level==Level.FINER)consoleLoggingLevel = ""FINER"";
		else if(level==Level.FINEST)consoleLoggingLevel = ""FINEST"";
		else consoleLoggingLevel = ""UNKNOWN"";
		logger.fine(""Set to ""+level);
	}
	public String getConsoleLoggingLevel() {
		return consoleLoggingLevel;
	}
	public void setLoggingLevel(Level level) {
		Logger rlogger = Logger.getLogger("""");
		Handler[] handlers = rlogger.getHandlers();
		for(int index = 0;
		 index < handlers.length;
		 index++ ) {
			 handlers[index].setLevel(level);
		}
		if(level==Level.SEVERE)loggingLevel = ""SEVERE"";
		else if(level==Level.WARNING)loggingLevel = ""WARNING"";
		else if(level==Level.INFO)loggingLevel = ""INFO"";
		else if(level==Level.CONFIG)loggingLevel = ""CONFIG"";
		else if(level==Level.FINE)loggingLevel = ""FINE"";
		else if(level==Level.FINER)loggingLevel = ""FINER"";
		else if(level==Level.FINEST)loggingLevel = ""FINEST"";
		else loggingLevel = ""UNKNOWN"";
		consoleLoggingLevel = loggingLevel;
		logger.fine(""Set to ""+level);
	}
	/public Throwable getServiceError() {
		return serviceError;
	}
	public synchronized boolean initService(Object param[]) {
		serviceError = null;
		try {
			initServer(param);
		}
		 catch(Exception e) {
			serviceError = e;
			return false;
		}
		return true;
	}
	public synchronized boolean initService(QuickServerConfig qsConfig) {
		serviceError = null;
		try {
			initServer(qsConfig);
		}
		 catch(Exception e) {
			serviceError = e;
			return false;
		}
		return true;
	}
	public boolean startService() {
		serviceError = null;
		if(getServiceState() == Service.RUNNING)return false;
		try{
			startServer();
		}
		 catch(AppException e) {
			serviceError = e;
			return false;
		}
		return true;
	}
	public boolean stopService() {
		serviceError = null;
		if(getServiceState() == Service.STOPPED)return false;
		try{
			stopServer();
			clearAllPools();
		}
		 catch(AppException e) {
			serviceError = e;
			return false;
		}
		 catch(Exception e) {
			serviceError = e;
			return false;
		}
		return true;
	}
	public boolean suspendService() {
		serviceError = null;
		if(getServiceState() == Service.RUNNING) {
			suspendMaxConnection = maxConnection;
			suspendMaxConnectionMsg = maxConnectionMsg;
			maxConnection = 0;
			maxConnectionMsg = ""Service is suspended."";
			setServiceState(Service.SUSPENDED);
			logger.info(""Service ""+getName()+"" is suspended."");
			return true;
		}
		return false;
	}
	public boolean resumeService() {
		serviceError = null;
		if(getServiceState() == Service.SUSPENDED) {
			maxConnection = suspendMaxConnection;
			maxConnectionMsg = suspendMaxConnectionMsg;
			setServiceState(Service.RUNNING);
			logger.info(""Service ""+getName()+"" resumed."");
			return true;
		}
		return false;
	}
	public String info() {
		serviceError = null;
		StringBuffer buf = new StringBuffer();
		buf.append(getName()+""\n"");
		buf.append(getBindAddr().getHostAddress()+"" ""+getPort()+""\n"");
		return buf.toString();
	}
	public synchronized void initServer(Object param[]) throws AppException {
		QuickServerConfig qsConfig = null;
		try {
			qsConfig = ConfigReader.read( (String)param[0]);
		}
		 catch(Exception e) {
			logger.severe(""Could not init server from xml file ""+(new File((String)param[0]).getAbsolutePath())+"" : "" +e);
			throw new AppException(""Could not init server from xml file"",e);
		}
		initServer(qsConfig);
	}
	public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
		setConfig(qsConfig);
		try {
			configQuickServer();
			loadApplicationClasses();
			InitServerHooks ish = getConfig().getInitServerHooks();
			if(ish!=null) {
				Iterator iterator = ish.iterator();
				String initServerHookClassName = null;
				Class initServerHookClass = null;
				InitServerHook initServerHook = null;
				while(iterator.hasNext()) {
					initServerHookClassName = (String)iterator.next();
					initServerHookClass = getClass(initServerHookClassName, true);
					initServerHook = (InitServerHook) initServerHookClass.newInstance();
					logger.info(""Loaded init server hook: "" + initServerHookClassName);
					logger.fine(""Init server hook info: "" + initServerHook.info());
					initServerHook.handleInit(QuickServer.this);
				}
			}
		}
		 catch(Exception e) {
			logger.severe(""Could not load init server hook: "" +e);
			logger.warning(""StackTrace:\n""+MyString.getStackTrace(e));
			throw new AppException(""Could not load init server hook"",e);
		}
		setServiceState(Service.INIT);
		logger.finest(""\r\n""+MyString.getSystemInfo(getVersion()));
	}
	public int getServiceState() {
		return serviceState;
	}
	public void setServiceState(int state) {
		serviceState = state;
	}
	private void configConsoleLoggingLevel(QuickServer qs, String temp) {
		if(temp.equals(""SEVERE""))qs.setConsoleLoggingLevel(Level.SEVERE);
		else if(temp.equals(""WARNING""))qs.setConsoleLoggingLevel(Level.WARNING);
		else if(temp.equals(""INFO""))qs.setConsoleLoggingLevel(Level.INFO);
		else if(temp.equals(""CONFIG""))qs.setConsoleLoggingLevel(Level.CONFIG);
		else if(temp.equals(""FINE""))qs.setConsoleLoggingLevel(Level.FINE);
		else if(temp.equals(""FINER""))qs.setConsoleLoggingLevel(Level.FINER);
		else if(temp.equals(""FINEST""))qs.setConsoleLoggingLevel(Level.FINEST);
		else logger.warning(""unknown level ""+temp);
	}
	public void configQuickServer(QuickServerConfig config) throws Exception {
		QuickServer qs = QuickServer.this;
		qs.setConfig(config);
		 qs.setBasicConfig(config);
		String temp = config.getConsoleLoggingLevel();
		configConsoleLoggingLevel(qs, temp);
		temp = null;
		qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
		qs.setName(config.getName());
		qs.setPort(config.getPort());
		qs.setClientEventHandler(config.getClientEventHandler());
		qs.setClientCommandHandler(config.getClientCommandHandler());
		if(config.getAuthenticator()!=null)qs.setAuthenticator(config.getAuthenticator());
		 else if(config.getClientAuthenticationHandler()!=null)qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
		 qs.setClientObjectHandler(config.getClientObjectHandler());
		qs.setClientBinaryHandler(config.getClientBinaryHandler());
		qs.setClientWriteHandler(config.getClientWriteHandler());
		qs.setClientData(config.getClientData());
		qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
		qs.setDefaultDataMode(config.getDefaultDataMode());
		qs.setServerBanner(config.getServerBanner());
		qs.setTimeout(config.getTimeout());
		qs.setMaxAuthTry(config.getMaxAuthTry());
		qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
		qs.setTimeoutMsg(config.getTimeoutMsg());
		qs.setMaxConnection(config.getMaxConnection());
		qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
		qs.setBindAddr(config.getBindAddr());
		qs.setCommunicationLogging(config.getCommunicationLogging());
		qs.setSecurityManagerClass(config.getSecurityManagerClass());
		qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
		temp = config.getApplicationJarPath();
		if(temp!=null) {
			File ajp = new File(temp);
			if(ajp.isAbsolute()==false) {
				temp = config.getConfigFile();
				ajp = new File(temp);
				temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
				config.setApplicationJarPath(temp);
				temp = null;
			}
			qs.setApplicationJarPath(config.getApplicationJarPath());
			if(config.getQSAdminServerConfig() != null ) {
				getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
			}
		}
		qs.setServerHooks(config.getServerHooks());
		qs.setSecure(config.getSecure());
	}
	public void configQuickServer(QSAdminServerConfig config) throws Exception {
		QuickServer qs = getQSAdminServer().getServer();
		qs.setBasicConfig(config);
		String temp = getConsoleLoggingLevel();
		configConsoleLoggingLevel(qs, temp);
		qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
		qs.setClientEventHandler(config.getClientEventHandler());
		qs.setClientCommandHandler(config.getClientCommandHandler());
		qs.setName(config.getName());
		qs.setPort(config.getPort());
		if(config.getAuthenticator()!=null)qs.setAuthenticator(config.getAuthenticator());
		 else if(config.getClientAuthenticationHandler()!=null)qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
		 qs.setClientObjectHandler(config.getClientObjectHandler());
		qs.setClientBinaryHandler(config.getClientBinaryHandler());
		qs.setClientWriteHandler(config.getClientWriteHandler());
		qs.setClientData(config.getClientData());
		qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
		qs.setDefaultDataMode(config.getDefaultDataMode());
		qs.setServerBanner(config.getServerBanner());
		qs.setTimeout(config.getTimeout());
		qs.setMaxAuthTry(config.getMaxAuthTry());
		qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
		qs.setTimeoutMsg(config.getTimeoutMsg());
		qs.setMaxConnection(config.getMaxConnection());
		qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
		qs.setBindAddr(config.getBindAddr());
		qs.setCommunicationLogging(config.getCommunicationLogging());
		getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
		if(config.getCommandShellEnable().equals(""true""))getQSAdminServer().setShellEnable(true);
		getQSAdminServer().setPromptName(config.getCommandShellPromptName());
		qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
		qs.setServerHooks(config.getServerHooks());
		qs.setSecure(config.getSecure());
	}
	public void configQuickServer() throws Exception {
		configQuickServer(getConfig());
		if(getConfig().getQSAdminServerConfig() != null ) {
			configQuickServer(getConfig().getQSAdminServerConfig());
		}
	}
	public static void main(String args[]) {
		try {
			if(args.length >= 1) {
				if(args[0].equals(""-about"")) {
					org.quickserver.net.server.gui.About.main(null);
				}
				 else if(args[0].equals(""-load"") && args.length>=2) {
					QuickServer qs = QuickServer.load(args[1]);
					if(qs!=null) handleOptions(args, qs);
				}
				 else {
					System.out.println(printUsage());
				}
			}
			 else {
				System.out.println(printUsage());
				org.quickserver.net.server.gui.About.showAbout();
			}
		}
		 catch(Exception e) {
			e.printStackTrace();
		}
	}
	public static QuickServer load(String xml) throws AppException {
		QuickServer qs = new QuickServer();
		Object config[] = new Object[] {
		xml}
		;
		qs.initServer(config);
		qs.startServer();
		if(qs.getConfig().getQSAdminServerConfig()!= null) {
			qs.startQSAdminServer();
		}
		return qs;
	}
	private static String printUsage() {
		StringBuffer sb = new StringBuffer();
		sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
		sb.append(""Copyright (C) QuickServer.org\n\n"");
		sb.append(""Usage: QuickServer [-options]\n"");
		sb.append(""Where options include:\n"");
		sb.append("" -about\t""+""Opens About Dialog box\n"");
		sb.append("" -load <xml_config_file> [load-options]\t""+""Loads the server from xml file.\n"");
		sb.append("" Where load-options include:\n"");
		sb.append("" -fullXML2File <file_name>\t""+""Dumps the Full XML configuration of the QuickServer loaded.\n"");
		return sb.toString();
	}
	private static void handleOptions(String args[], QuickServer quickserver) {
		if(args.length<3) return;
		if(args[2].equals(""-fullXML2File"") && args.length>=4) {
			File file = new File(args[3]);
			logger.info(""Writing full xml configuration to file: ""+file.getAbsolutePath());
			try {
				TextFile.write(file, quickserver.getConfig().toXML(null));
			}
			 catch(Exception e) {
				logger.warning(""Error writing full xml configuration: ""+e);
			}
		}
	}
	public void clearAllPools() throws Exception {
		try {
			if(pool!=null)getClientPool().clear();
			if(clientHandlerPool!=null)getClientHandlerPool().clear();
			if(getClientDataPool()!=null)getClientDataPool().clear();
			if(getDBPoolUtil()!=null)getDBPoolUtil().clean();
			if(byteBufferPool!=null)getByteBufferPool().clear();
		}
		 catch(Exception e) {
			logger.warning(""Error: ""+e);
			throw e;
		}
	}
	public void closeAllPools() throws Exception {
		if(pool==null && clientHandlerPool==null && getClientDataPool()==null &&getDBPoolUtil()==null && byteBufferPool==null) {
			return;
		}
		logger.fine(""Closing pools for ""+getName());
		try {
			if(pool!=null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
				logger.finer(""Closing ClientThread pool."");
				getClientPool().close();
			}
			if(clientHandlerPool!=null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
				logger.finer(""Closing ClientHandler pool."");
				getClientHandlerPool().close();
			}
			if(getClientDataPool()!=null && PoolHelper.isPoolOpen(getClientDataPool())) {
				logger.finer(""Closing ClientData pool."");
				getClientDataPool().close();
			}
			if(getDBPoolUtil()!=null) {
				logger.finer(""Closing DB pool."");
				getDBPoolUtil().clean();
			}
			if(byteBufferPool!=null && PoolHelper.isPoolOpen(getByteBufferPool())) {
				logger.finer(""Closing ByteBuffer pool."");
				getByteBufferPool().close();
			}
			logger.fine(""Closed pools for ""+getName());
		}
		 catch(Exception e) {
			logger.warning(""Error closing pools for ""+getName()+"": ""+e);
			throw e;
		}
	}
	public void initAllPools() throws Exception {
		logger.fine(""Creating pools"");
		if(getBlockingMode()==false) {
			makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
		}
		makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
		makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
		if(clientDataClass!=null) {
			try {
				clientData = (ClientData)clientDataClass.newInstance();
				if(PoolableObject.class.isInstance(clientData)==true) {
					PoolableObject po = (PoolableObject)clientData;
					if( po.isPoolable()==true) {
						makeClientDataPool(po.getPoolableObjectFactory(),getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig() );
					}
					 else {
						clientDataPool = null;
						logger.fine(""ClientData is not poolable!"");
					}
				}
			}
			 catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw e;
			}
		}
		try {
			makeDBObjectPool();
		}
		 catch(Exception e) {
			logger.warning(""Error in makeDBObjectPool() : ""+e);
			logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
			throw e;
		}
		logger.fine(""Created pools"");
	}
	public ClientPool getClientPool() {
		if(pool==null)throw new IllegalStateException(""No ClientPool available yet!"");
		return pool;
	}
	private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
		logger.finer(""Creating ClientHandler pool"");
		PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
		clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
		poolManager.initPool(clientHandlerPool, opConfig);
		clientHandlerPool = makeQSObjectPool(clientHandlerPool);
		clientIdentifier.setClientHandlerPool((QSObjectPool)clientHandlerPool);
	}
	public ObjectPool getClientHandlerPool() {
		if(clientHandlerPool==null)throw new IllegalStateException(""No ClientHandler Pool available yet!"");
		return clientHandlerPool;
	}
	public void setConfig(QuickServerConfig config) {
		this.config = config;
	}
	public QuickServerConfig getConfig() {
		return config;
	}
	private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
		logger.finer(""Creating ClientData pool"");
		clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
		poolManager.initPool(clientDataPool, opConfig);
		clientDataPool = makeQSObjectPool(clientDataPool);
	}
	public ObjectPool getClientDataPool() {
		return clientDataPool;
	}
	public DBPoolUtil getDBPoolUtil() {
		return dBPoolUtil;
	}
	public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
		getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
	}
	private void makeDBObjectPool() throws Exception {
		if(getConfig().getDBObjectPoolConfig()!=null) {
			logger.fine(""Creating DBObject Pool"");
			Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
			dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
			dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
			dBPoolUtil.initPool();
		}
	}
	public ClientHandler findFirstClientById(String id) {
		return clientIdentifier.findFirstClientById(id);
	}
	public Iterator findAllClient() {
		return clientIdentifier.findAllClient();
	}
	public Iterator findAllClientById(String pattern) {
		return clientIdentifier.findAllClientById(pattern);
	}
	public ClientHandler findClientByKey(String key) {
		return clientIdentifier.findClientByKey(key);
	}
	public Iterator findAllClientByKey(String pattern) {
		return clientIdentifier.findAllClientByKey(pattern);
	}
	public void nextClientIsTrusted() {
		setSkipValidation(true);
	}
	private boolean getSkipValidation() {
		return skipValidation;
	}
	private synchronized void setSkipValidation(boolean validation) {
		skipValidation = validation;
	}
	public void setCommunicationLogging(boolean communicationLogging) {
		this.communicationLogging = communicationLogging;
	}
	public boolean getCommunicationLogging() {
		return communicationLogging;
	}
	public void setSecurityManagerClass(String securityManagerClass) {
		if(securityManagerClass!=null)this.securityManagerClass = securityManagerClass;
	}
	public String getSecurityManagerClass() {
		return securityManagerClass;
	}
	public SecurityManager getSecurityManager() throws AppException {
		if(getSecurityManagerClass()==null)return null;
		SecurityManager sm = null;
		try {
			sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
		}
		 catch(ClassNotFoundException e) {
			throw new AppException(e.getMessage());
		}
		 catch(InstantiationException e) {
			throw new AppException(e.getMessage());
		}
		 catch(IllegalAccessException e) {
			throw new AppException(e.getMessage());
		}
		return sm;
	}
	public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
		this.accessConstraintConfig = accessConstraintConfig;
	}
	public AccessConstraintConfig getAccessConstraintConfig() {
		return accessConstraintConfig;
	}
	public void setClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
		Thread.currentThread().setContextClassLoader(classLoader);
	}
	public ClassLoader getClassLoader() {
		return classLoader;
	}
	 public Class getClass(String name, boolean reload) throws ClassNotFoundException {
		if(name==null) throw new IllegalArgumentException(""Class name can't be null!"");
		logger.finest(""Class: ""+name+"", reload: ""+reload);
		if(reload==true && classLoader!=null) {
			return classLoader.loadClass(name);
		}
		 else if(reload==true && classLoader==null && this.getClass().getClassLoader()!=null) {
			return this.getClass().getClassLoader().loadClass(name);
		}
		 else if(reload==false && classLoader!=null) {
			return Class.forName(name, true, classLoader);
		}
		 else {
			return Class.forName(name, true, this.getClass().getClassLoader());
		}
	 }
	protected void setApplicationJarPath(String applicationJarPath) {
		this.applicationJarPath = applicationJarPath;
	}
	public String getApplicationJarPath() {
		return applicationJarPath;
	}
	public void setServerHooks(ServerHooks serverHooks) {
		this.serverHooks = serverHooks;
	}
	public ServerHooks getServerHooks() {
		if(serverHooks==null)serverHooks = new ServerHooks();
		return serverHooks;
	}
	private void loadServerHooksClasses() {
		if(getServerHooks()==null) return;
		listOfServerHooks = new ArrayList();
		ServerHook serverHook = null;
		String serverHookClassName = null;
		Class serverHookClass = null;
		serverHook = new GhostSocketReaper();
		serverHook.initHook(QuickServer.this);
		listOfServerHooks.add(serverHook);
		ghostSocketReaper = (GhostSocketReaper) serverHook;
		Iterator iterator = getServerHooks().iterator();
		while(iterator.hasNext()) {
			serverHookClassName = (String)iterator.next();
			try{
				serverHookClass = getClass(serverHookClassName, true);
				serverHook = (ServerHook)serverHookClass.newInstance();
				serverHook.initHook(QuickServer.this);
				listOfServerHooks.add(serverHook);
				logger.info(""Loaded server hook: "" + serverHookClassName);
				logger.fine(""Server hook info: "" + serverHook.info());
			}
			 catch(Exception e) {
				logger.warning(""Could not load server hook [""+serverHookClassName+""]: "" + e);
				logger.fine(""StackTrace:\n""+MyString.getStackTrace(e));
			}
		}
	}
	private void processServerHooks(int event) {
		if(listOfServerHooks==null) {
			logger.warning(""listOfServerHooks was null!"");
			return;
		}
		ServerHook serverHook = null;
		boolean result = false;
		Iterator iterator = listOfServerHooks.iterator();
		String hooktype = ""UNKNOWN"";
		switch(event) {
			case ServerHook.PRE_STARTUP: hooktype=""PRE_STARTUP"";
			break;
			case ServerHook.POST_STARTUP: hooktype=""POST_STARTUP"";
			break;
			case ServerHook.PRE_SHUTDOWN: hooktype=""PRE_SHUTDOWN"";
			break;
			case ServerHook.POST_SHUTDOWN: hooktype=""POST_SHUTDOWN"";
			break;
		}
		while(iterator.hasNext()) {
			serverHook = (ServerHook)iterator.next();
			try{
				result = serverHook.handleEvent(event);
			}
			 catch(Exception e) {
				result = false;
				logger.warning(""Error invoking ""+hooktype+"" hook [""+serverHook.getClass().getName()+""]: "" + e.getMessage());
			}
			logger.fine(""Invoked ""+hooktype+"" hook [""+serverHook.getClass().getName()+""] was: ""+result);
		}
	}
	public Object clone() {
		Object object = null;
		try {
			object = super.clone();
			 QuickServer _qs = (QuickServer) object;
			_qs.setQSAdminServer( new QSAdminServer(_qs) );
		}
		 catch(CloneNotSupportedException e) {
			logger.warning(""Error cloning : ""+e);
		}
		return object;
	}
	public void setSecure(Secure secure) {
		this.secure = secure;
	}
	public Secure getSecure() {
		if(secure==null) secure = new Secure();
		return secure;
	}
	public boolean isRunningSecure() {
		return runningSecure;
	}
	public void setRunningSecure(boolean runningSecure) {
		this.runningSecure = runningSecure;
	}
	private File makeAbsoluteToConfig(String fileName) {
		Assertion.affirm(fileName!=null, ""FileName can't be null"");
		return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
	}
	protected void makeServerSocket() throws BindException, IOException {
		server = null;
		logger.finest(""Binding ""+getName()+"" to IP: ""+getBindAddr());
		InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
		try {
			NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
			if(ni!=null) {
				logger.fine(""NetworkInterface: ""+ni);
			}
		}
		 catch(Exception igrnore) {
		}
		 catch(Error igrnore) {
		}
		if(getSecure().isEnable()==false) {
			logger.fine(""Making a normal ServerSocket for ""+getName());
			setRunningSecure(false);
			if(getBlockingMode()==false) {
				serverSocketChannel = ServerSocketChannel.open();
				server = serverSocketChannel.socket();
				server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
			}
			 else {
				server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
			}
		}
		 else {
			logger.fine(""Making a secure ServerSocket for ""+getName());
			try{
				ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
				SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
				serversocket.setNeedClientAuth(secure.isClientAuthEnable());
				setRunningSecure(true);
				secureStoreManager.logSSLServerSocketInfo(serversocket);
				server = serversocket;
				serverSocketChannel = server.getChannel();
				if(serverSocketChannel==null && getBlockingMode()==false) {
					logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
					blockingMode = true;
				}
			}
			 catch(NoSuchAlgorithmException e){
				logger.warning(""NoSuchAlgorithmException : ""+e);
				throw new IOException(""Error creating secure socket : ""+e.getMessage());
			}
			 catch(KeyManagementException e) {
				logger.warning(""KeyManagementException : ""+e);
				throw new IOException(""Error creating secure socket : ""+e.getMessage());
			}
		}
		server.setReuseAddress(true);
		if(getBlockingMode()==false) {
			logger.fine(""Server Mode ""+getName()+"" - Non Blocking"");
			if(selector==null || selector.isOpen()==false) {
				logger.finest(""Opening new selector"");
				selector = Selector.open();
			}
			 else {
				logger.finest(""Reusing selector: ""+selector);
			}
			serverSocketChannel.configureBlocking(false);
			serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
			selector.wakeup();
		}
		 else {
			logger.fine(""Server Mode ""+getName()+"" - Blocking"");
		}
	}
	public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
		Assertion.affirm(basicConfig!=null, ""BasicServerConfig can't be null"");
		this.basicConfig = basicConfig;
	}
	public BasicServerConfig getBasicConfig() {
		return basicConfig;
	}
	public void loadSSLContext() throws IOException {
		if(getSecure().isLoad()==false) {
			throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
		}
		logger.info(""Loading Secure Context.."");
		km = null;
		tm = null;
		try {
			String ssManager = ""org.quickserver.security.SecureStoreManager"";
			if(getSecure().getSecureStore()!=null)ssManager = getSecure().getSecureStore().getSecureStoreManager();
			Class secureStoreManagerClass = getClass(ssManager, true);
			secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
			km = secureStoreManager.loadKeyManagers(getConfig());
			logger.fine(""KeyManager got"");
			tm = secureStoreManager.loadTrustManagers(getConfig());
			logger.fine(""TrustManager got"");
			sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
			sslc.init(km, tm, null);
			logger.fine(""SSLContext loaded"");
		}
		 catch(KeyStoreException e) {
			logger.warning(""KeyStoreException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(NoSuchAlgorithmException e) {
			logger.warning(""NoSuchAlgorithmException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(NoSuchProviderException e) {
			logger.warning(""NoSuchProviderException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(UnrecoverableKeyException e) {
			logger.warning(""UnrecoverableKeyException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(CertificateException e) {
			logger.warning(""CertificateException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(KeyManagementException e) {
			logger.warning(""KeyManagementException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(GeneralSecurityException e) {
			logger.warning(""GeneralSecurityException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(ClassNotFoundException e) {
			logger.warning(""ClassNotFoundException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(InstantiationException e) {
			logger.warning(""InstantiationException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
		 catch(IllegalAccessException e) {
			logger.warning(""IllegalAccessException : ""+e);
			throw new IOException(""Error creating secure socket : ""+e.getMessage());
		}
	}
	public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
		return getSSLContext(null);
	}
	public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
		if(sslc==null) loadSSLContext();
		if(protocol!=null && secureStoreManager!=null) {
			SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
			_sslc.init(km, tm, null);
			return _sslc;
		}
		return sslc;
	}
	public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
		if(sslc==null) loadSSLContext();
		return secureStoreManager.getSocketFactory(getSSLContext());
	}
	public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
		if(sslc==null) loadSSLContext();
		return secureStoreManager.getSocketFactory(getSSLContext(protocol));
	}
	public void setClientBinaryHandler(String handler) {
		clientBinaryHandlerString = handler;
		logger.finest(""Set to ""+handler);
	}
	public String getClientBinaryHandler() {
		return clientBinaryHandlerString;
	}
	public void setSelector(Selector selector) {
		this.selector = selector;
	}
	public Selector getSelector() {
		return selector;
	}
	private void runBlocking(TheClient theClient) throws Exception {
		Socket client = null;
		ClientHandler _chPolled = null;
		int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
		while(true) {
			client = server.accept();
			if(linger<0) {
				client.setSoLinger(false, 0);
			}
			 else {
				client.setSoLinger(true, linger);
			}
			if(stopServer) {
				try {
					client.close();
				}
				 catch(Exception e) {
				}
				break;
			}
			if(checkAccessConstraint(client)==false) {
				continue;
			}
			if(getSkipValidation()!=true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
				theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
			}
			 else {
				theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
			}
			theClient.setTrusted(getSkipValidation());
			theClient.setSocket(client);
			theClient.setSocketChannel(client.getChannel());
			 if(clientDataClass != null) {
				if(getClientDataPool()==null) {
					clientData = (ClientData)clientDataClass.newInstance();
				}
				 else {
					clientData = (ClientData)getClientDataPool().borrowObject();
				}
				theClient.setClientData(clientData);
			}
			try {
				_chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
				_chPolled.handleClient(theClient);
			}
			 catch(java.util.NoSuchElementException nsee) {
				logger.warning(""Could not borrow ClientHandler from pool. Error: ""+nsee);
				logger.warning(""Closing Socket [""+client+""] since no ClientHandler available."");
				client.close();
			}
			if(_chPolled!=null) {
				try {
					getClientPool().addClient(_chPolled, true);
				}
				 catch(java.util.NoSuchElementException nsee) {
					logger.warning(""Could not borrow Thread from pool. Error: ""+nsee);
				}
				_chPolled = null;
			}
			client = null;
			setSkipValidation(false);
		}
	}
	private void runNonBlocking(TheClient theClient) throws Exception {
		int selectCount = 0;
		Iterator iterator = null;
		SelectionKey key = null;
		ServerSocketChannel serverChannel = null;
		SocketChannel socketChannel = null;
		Socket client = null;
		ClientHandler _chPolled = null;
		boolean stopServerProcessed = false;
		int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
		registerChannelRequestMap = new HashMap();
		while(true) {
			selectCount = selector.select(500);
			synchronized(registerChannelRequestMap) {
				if(registerChannelRequestMap.size()>0) {
					RegisterChannelRequest req = null;
					Object hashkey = null;
					iterator = registerChannelRequestMap.keySet().iterator();
					while(iterator.hasNext()) {
						hashkey = iterator.next();
						req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
						req.register(getSelector());
					}
					iterator = null;
					registerChannelRequestMap.clear();
				}
			}
			if(stopServer==true && stopServerProcessed==false) {
				logger.warning(""Closing ""+getName());
				serverSocketChannel.close();
				stopServerProcessed = true;
				server = null;
				serverSocketChannel = null;
				setServiceState(Service.STOPPED);
				logger.warning(""Closed ""+getName());
				processServerHooks(ServerHook.POST_SHUTDOWN);
			}
			if(stopServer==false && stopServerProcessed==true) {
				logger.finest(""Server must have re-started.. will break"");
				break;
			}
			if(selectCount==0 && stopServerProcessed==true) {
				java.util.Set keyset = selector.keys();
				if(keyset.isEmpty()==true && getClientCount()<=0) {
					break;
				}
				 else {
					continue;
				}
			}
			 else if(selectCount==0) {
				continue;
			}
			iterator = selector.selectedKeys().iterator();
			while(iterator.hasNext()) {
				key = (SelectionKey) iterator.next();
				if(key.isValid()==false) {
					iterator.remove();
					continue;
				}
				if(key.isAcceptable() && stopServer==false) {
					logger.finest(""Key is Acceptable"");
					serverChannel = (ServerSocketChannel) key.channel();
					socketChannel = serverChannel.accept();
					if(socketChannel==null) {
						iterator.remove();
						continue;
					}
					client = socketChannel.socket();
					if(linger<0) {
						client.setSoLinger(false, 0);
					}
					 else {
						client.setSoLinger(true, linger);
					}
					if(checkAccessConstraint(client)==false) {
						iterator.remove();
						continue;
					}
					socketChannel.configureBlocking(false);
					theClient.setTrusted(getSkipValidation());
					theClient.setSocket(socketChannel.socket());
					theClient.setSocketChannel(socketChannel);
					if(clientDataClass != null) {
						if(getClientDataPool()==null) {
							clientData = (ClientData)clientDataClass.newInstance();
						}
						 else {
							clientData = (ClientData)getClientDataPool().borrowObject();
						}
						theClient.setClientData(clientData);
					}
					if(getSkipValidation()!=true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
						theClient.setClientEvent(ClientEvent.MAX_CON);
					}
					 else {
						theClient.setClientEvent(ClientEvent.ACCEPT);
					}
					try {
						_chPolled = (ClientHandler)getClientHandlerPool().borrowObject();
						logger.finest(""Asking ""+_chPolled.getName()+"" to handle."");
						 _chPolled.handleClient(theClient);
					}
					 catch(java.util.NoSuchElementException nsee) {
						logger.warning(""Could not borrow ClientHandler Object from pool. Error: ""+nsee);
						logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no ClientHandler available."");
						socketChannel.close();
					}
					if(_chPolled!=null) {
						try {
							getClientPool().addClient(_chPolled, true);
						}
						 catch(java.util.NoSuchElementException nsee) {
							logger.warning(""Could not borrow Thread from pool. Error: ""+nsee);
						}
						_chPolled = null;
					}
					socketChannel = null;
					client = null;
					setSkipValidation(false);
				}
				 else if(key.isValid() && key.isReadable()) {
					boolean addedEvent = false;
					ClientHandler _ch = null;
					try {
						_ch = (ClientHandler)key.attachment();
						logger.finest(""Key is Readable, removing OP_READ from interestOps for ""+_ch.getName());
						key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
						_ch.addEvent(ClientEvent.READ);
						addedEvent= true;
						getClientPool().addClient(_ch);
					}
					 catch(CancelledKeyException cke) {
						logger.fine(""Ignored Error - Key was Cancelled: ""+cke);
					}
					 catch(java.util.NoSuchElementException nsee) {
						logger.finest(""NoSuchElementException: ""+nsee);
						if(addedEvent) _ch.removeEvent(ClientEvent.READ);
						continue;
					}
					_ch = null;
				}
				 else if(key.isValid() && key.isWritable()) {
					if(getClientPool().shouldNioWriteHappen()==false) {
						continue;
					 }
					boolean addedEvent = false;
					ClientHandler _ch = null;
					try {
						_ch = (ClientHandler)key.attachment();
						logger.finest(""Key is Writable, removing OP_WRITE from interestOps for ""+_ch.getName());
						key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
						_ch.addEvent(ClientEvent.WRITE);
						addedEvent= true;
						getClientPool().addClient(_ch);
					}
					 catch(CancelledKeyException cke) {
						logger.fine(""Ignored Error - Key was Cancelled: ""+cke);
					}
					 catch(java.util.NoSuchElementException nsee) {
						logger.finest(""NoSuchElementException: ""+nsee);
						if(addedEvent) _ch.removeEvent(ClientEvent.WRITE);
						continue;
					}
					_ch = null;
				}
				 else if(stopServer==true && key.isAcceptable()) {
					setSkipValidation(false);
				}
				 else {
					logger.warning(""Unknown key got in SelectionKey: ""+key);
				}
				iterator.remove();
				 Thread.yield();
			}
			 iterator = null;
		}
	}
	private boolean checkAccessConstraint(Socket socket) {
		try {
			if(getAccessConstraintConfig()!=null) {
				getAccessConstraintConfig().checkAccept(socket);
			}
			return true;
		}
		 catch(SecurityException se) {
			logger.warning(""SecurityException occurred accepting connection : ""+se.getMessage());
			return false;
		}
	}
	public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
		if(getSelector()==null) {
			throw new IllegalStateException(""Selector is not open!"");
		}
		if(channel==null) {
			throw new IllegalArgumentException(""Can't register a null channel!"");
		}
		if(channel.isConnected()==false) {
			throw new ClosedChannelException();
		}
		RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
		RegisterChannelRequest reqOld = null;
		synchronized(registerChannelRequestMap) {
			reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
			if(reqOld==null) {
				registerChannelRequestMap.put(channel, req);
				getSelector().wakeup();
				return true;
			}
			 else {
				if(reqOld.equals(req)==false) {
					reqOld.setOps(reqOld.getOps() | req.getOps());
					reqOld.setAtt(req.getAtt());
					return true;
				}
				return false;
			}
		}
	}
	private void makeByteBufferPool(PoolConfig opConfig) {
		logger.finer(""Creating ByteBufferPool pool"");
		int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
		boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
		PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
		byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
		poolManager.initPool(byteBufferPool, opConfig);
	}
	public ObjectPool getByteBufferPool() {
		return byteBufferPool;
	}
	private void makeClientPool(PoolConfig opConfig) throws Exception {
		logger.finer(""Creating ClientThread pool"");
		ThreadObjectFactory factory = new ThreadObjectFactory();
		ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
		pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
		factory.setClientPool(pool);
		pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
		poolManager.initPool(objectPool, opConfig);
	}
	public void setClientWriteHandler(String handler) {
		clientWriteHandlerString = handler;
		logger.finest(""Set to ""+handler);
	}
	public String getClientWriteHandler() {
		return clientWriteHandlerString;
	}
	public java.util.Date getLastStartTime() {
		return lastStartTime;
	}
	public static void setDebugNonBlockingMode(boolean flag) {
		org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
		org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
	}
	public ClientIdentifier getClientIdentifier() {
		return clientIdentifier;
	}
	private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
		return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
	}
	public boolean getBlockingMode() {
		return blockingMode;
	}
	protected void loadBusinessLogic() throws Exception {
		if(clientCommandHandlerString == null && clientEventHandlerString == null) {
			logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
			throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
		}
		clientCommandHandler = null;
		if(clientCommandHandlerString != null) {
			logger.finest(""Loading ClientCommandHandler class.."");
			Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
			clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
		}
		boolean setClientCommandHandlerLookup = false;
		clientEventHandler = null;
		if(clientEventHandlerString==null) {
			clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
			setClientCommandHandlerLookup = true;
		}
		logger.finest(""Loading ClientEventHandler class.."");
		if(clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
			clientEventHandler = (ClientEventHandler) clientCommandHandler;
		}
		 else {
			clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
			if(setClientCommandHandlerLookup) {
				((DefaultClientEventHandler)clientEventHandler).setClientCommandHandler(clientCommandHandler);
			}
		}
		clientExtendedEventHandler = null;
		if(clientExtendedEventHandlerString != null) {
			logger.finest(""Loading ClientExtendedEventHandler class.."");
			if(clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
				clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
			}
			 else if(clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
				clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
			}
			 else {
				Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
				clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
			}
		}
		clientObjectHandler = null;
		if(clientObjectHandlerString != null) {
			logger.finest(""Loading ClientObjectHandler class.."");
			if(clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
				clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
			}
			 else if(clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
				clientObjectHandler = (ClientObjectHandler) clientEventHandler;
			}
			 else if(clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
				clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
			}
			 else {
				clientObjectHandler = (ClientObjectHandler)getClass(clientObjectHandlerString, true).newInstance();
			}
		}
		 clientBinaryHandler = null;
		if(clientBinaryHandlerString != null) {
			logger.finest(""Loading ClientBinaryHandler class.."");
			if(clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
				clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
			}
			 else if(clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
				clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
			}
			 else if(clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
				clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
			}
			 else if(clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
				clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
			}
			 else {
				clientBinaryHandler = (ClientBinaryHandler)getClass(clientBinaryHandlerString, true).newInstance();
			}
		}
		 clientWriteHandler = null;
		if(clientWriteHandlerString != null) {
			logger.finest(""Loading ClientWriteHandler class.."");
			if(clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
				clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
			}
			 else if(clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
				clientWriteHandler = (ClientWriteHandler) clientEventHandler;
			}
			 else if(clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
				clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
			}
			 else if(clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
				clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
			}
			 else if(clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
				clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
			}
			 else {
				clientWriteHandler = (ClientWriteHandler)getClass(clientWriteHandlerString, true).newInstance();
			}
		}
		 Class authenticatorClass = null;
		if(clientAuthenticationHandlerString != null) {
			logger.finest(""Loading ClientAuthenticationHandler class.."");
			authenticatorClass = getClass(clientAuthenticationHandlerString, true);
		}
		if(authenticatorClass!=null) {
			Object obj = authenticatorClass.newInstance();
			if(ClientAuthenticationHandler.class.isInstance(obj))clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
			elseauthenticator = (Authenticator) obj;
		}
		clientDataClass = null;
		if(clientDataString != null) {
			logger.finest(""Loading ClientData class.."");
			clientDataClass = getClass(clientDataString, true);
		}
		Assertion.affirm(clientEventHandler!=null, ""ClientEventHandler was not loaded!"");
	}
	public void setClientEventHandler(String handler) {
		clientEventHandlerString = handler;
		logger.finest(""Set to ""+handler);
	}
	public String getClientEventHandler() {
		return clientEventHandlerString;
	}
	public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
		if(dataType==DataType.IN)this.defaultDataModeIN = dataMode;
		if(dataType==DataType.OUT)this.defaultDataModeOUT = dataMode;
	}
	public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
		defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
		defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
		;
	}
	public DataMode getDefaultDataMode(DataType dataType) {
		if(dataType==DataType.IN)return defaultDataModeIN;
		if(dataType==DataType.OUT)return defaultDataModeOUT;
		elsethrow new IllegalArgumentException(""Unknown DataType: ""+dataType);
	}
	public void setClientExtendedEventHandler(String handler) {
		clientExtendedEventHandlerString = handler;
		logger.finest(""Set to ""+handler);
	}
	public String getClientExtendedEventHandler() {
		return clientExtendedEventHandlerString;
	}
	private void loadApplicationClasses() throws Exception {
		if(getApplicationJarPath()!=null && getClassLoader()==null) {
			setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
			if(adminServer!=null) {
				adminServer.getServer().setClassLoader(getClassLoader());
			}
		}
	}
}",1,0,0,0
"public final Description matchClass(ClassTree classTree, VisitorState state) {
	 if (!HAS_CONSTRUCTORS_WITH_INJECT.matches(classTree, state)) {
		 return Description.NO_MATCH;
	 }
	 List<MethodTree> ctors = ASTHelpers.getConstructors(classTree);
	 List<MethodTree> ctorsWithInject = ctors.stream() .filter(c -> hasInjectAnnotation().matches(c, state)) .collect(toImmutableList());
	 if (ctorsWithInject.size() != 1) {
		 return Description.NO_MATCH;
	 }
	 Set<Symbol> variablesAssigned = new HashSet<>();
	 new TreeScanner<Void, Void>() {
		 public Void visitAssignment(AssignmentTree tree, Void unused) {
			 Symbol symbol = ASTHelpers.getSymbol(tree.getVariable());
			 if (symbol != null && symbol.getKind() == ElementKind.FIELD && !symbol.isStatic()) {
				 variablesAssigned.add(symbol);
			 }
			 return super.visitAssignment(tree, null);
		 }
	 }
	.scan((JCTree) getOnlyElement(ctorsWithInject), null);
	 SuggestedFix.Builder fix = SuggestedFix.builder();
	 VariableTree variableTreeFirstMatch = null;
	 for (Tree member : classTree.getMembers()) {
		 if (!(member instanceof VariableTree)) {
			 continue;
		 }
		 VariableTree variableTree = (VariableTree) member;
		 if (!INSTANCE_FIELD_WITH_INJECT.matches(variableTree, state)) {
			 continue;
		 }
		 if (!variablesAssigned.contains(ASTHelpers.getSymbol(variableTree))) {
			 continue;
		 }
		 variableTreeFirstMatch = variableTree;
		 removeInjectAnnotationFromVariable(variableTree, state).ifPresent(fix::merge);
	 }
	 if (variableTreeFirstMatch == null) {
		 return Description.NO_MATCH;
	 }
	 if (fix.isEmpty()) {
		 return describeMatch(variableTreeFirstMatch);
	 }
	 return describeMatch(variableTreeFirstMatch, fix.build());
 }",0,0,1,0
"public static final class Builder extends com.google.protobuf.GeneratedMessage.Builder<Builder> implements org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpecOrBuilder {
	 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
		 return org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.internal_static_SignableVertexSpec_descriptor;
	 }
	 protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
		 return org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.internal_static_SignableVertexSpec_fieldAccessorTable .ensureFieldAccessorsInitialized( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec.class, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec.Builder.class);
	 }
	 private Builder() {
		 maybeForceBuilderInitialization();
	 }
	 private Builder( com.google.protobuf.GeneratedMessage.BuilderParent parent) {
		 super(parent);
		 maybeForceBuilderInitialization();
	 }
	 private void maybeForceBuilderInitialization() {
		 if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
			 getQueryIdentifierFieldBuilder();
			 getProcessorDescriptorFieldBuilder();
			 getInputSpecsFieldBuilder();
			 getOutputSpecsFieldBuilder();
			 getGroupedInputSpecsFieldBuilder();
		 }
	 }
	 private static Builder create() {
		 return new Builder();
	 }
	 public Builder clear() {
		 super.clear();
		 user_ = """";
		 bitField0_ = (bitField0_ & ~0x00000001);
		 signatureKeyId_ = 0L;
		 bitField0_ = (bitField0_ & ~0x00000002);
		 if (queryIdentifierBuilder_ == null) {
			 queryIdentifier_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.getDefaultInstance();
		 }
		 else {
			 queryIdentifierBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000004);
		 hiveQueryId_ = """";
		 bitField0_ = (bitField0_ & ~0x00000008);
		 dagName_ = """";
		 bitField0_ = (bitField0_ & ~0x00000010);
		 vertexName_ = """";
		 bitField0_ = (bitField0_ & ~0x00000020);
		 vertexIndex_ = 0;
		 bitField0_ = (bitField0_ & ~0x00000040);
		 tokenIdentifier_ = """";
		 bitField0_ = (bitField0_ & ~0x00000080);
		 if (processorDescriptorBuilder_ == null) {
			 processorDescriptor_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.getDefaultInstance();
		 }
		 else {
			 processorDescriptorBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000100);
		 if (inputSpecsBuilder_ == null) {
			 inputSpecs_ = java.util.Collections.emptyList();
			 bitField0_ = (bitField0_ & ~0x00000200);
		 }
		 else {
			 inputSpecsBuilder_.clear();
		 }
		 if (outputSpecsBuilder_ == null) {
			 outputSpecs_ = java.util.Collections.emptyList();
			 bitField0_ = (bitField0_ & ~0x00000400);
		 }
		 else {
			 outputSpecsBuilder_.clear();
		 }
		 if (groupedInputSpecsBuilder_ == null) {
			 groupedInputSpecs_ = java.util.Collections.emptyList();
			 bitField0_ = (bitField0_ & ~0x00000800);
		 }
		 else {
			 groupedInputSpecsBuilder_.clear();
		 }
		 vertexParallelism_ = 0;
		 bitField0_ = (bitField0_ & ~0x00001000);
		 isExternalSubmission_ = false;
		 bitField0_ = (bitField0_ & ~0x00002000);
		 return this;
	 }
	 public Builder clone() {
		 return create().mergeFrom(buildPartial());
	 }
	 public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
		 return org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.internal_static_SignableVertexSpec_descriptor;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec getDefaultInstanceForType() {
		 return org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec.getDefaultInstance();
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec build() {
		 org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec result = buildPartial();
		 if (!result.isInitialized()) {
			 throw newUninitializedMessageException(result);
		 }
		 return result;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec buildPartial() {
		 org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec result = new org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec(this);
		 int from_bitField0_ = bitField0_;
		 int to_bitField0_ = 0;
		 if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
			 to_bitField0_ |= 0x00000001;
		 }
		 result.user_ = user_;
		 if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
			 to_bitField0_ |= 0x00000002;
		 }
		 result.signatureKeyId_ = signatureKeyId_;
		 if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
			 to_bitField0_ |= 0x00000004;
		 }
		 if (queryIdentifierBuilder_ == null) {
			 result.queryIdentifier_ = queryIdentifier_;
		 }
		 else {
			 result.queryIdentifier_ = queryIdentifierBuilder_.build();
		 }
		 if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
			 to_bitField0_ |= 0x00000008;
		 }
		 result.hiveQueryId_ = hiveQueryId_;
		 if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
			 to_bitField0_ |= 0x00000010;
		 }
		 result.dagName_ = dagName_;
		 if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
			 to_bitField0_ |= 0x00000020;
		 }
		 result.vertexName_ = vertexName_;
		 if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
			 to_bitField0_ |= 0x00000040;
		 }
		 result.vertexIndex_ = vertexIndex_;
		 if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
			 to_bitField0_ |= 0x00000080;
		 }
		 result.tokenIdentifier_ = tokenIdentifier_;
		 if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
			 to_bitField0_ |= 0x00000100;
		 }
		 if (processorDescriptorBuilder_ == null) {
			 result.processorDescriptor_ = processorDescriptor_;
		 }
		 else {
			 result.processorDescriptor_ = processorDescriptorBuilder_.build();
		 }
		 if (inputSpecsBuilder_ == null) {
			 if (((bitField0_ & 0x00000200) == 0x00000200)) {
				 inputSpecs_ = java.util.Collections.unmodifiableList(inputSpecs_);
				 bitField0_ = (bitField0_ & ~0x00000200);
			 }
			 result.inputSpecs_ = inputSpecs_;
		 }
		 else {
			 result.inputSpecs_ = inputSpecsBuilder_.build();
		 }
		 if (outputSpecsBuilder_ == null) {
			 if (((bitField0_ & 0x00000400) == 0x00000400)) {
				 outputSpecs_ = java.util.Collections.unmodifiableList(outputSpecs_);
				 bitField0_ = (bitField0_ & ~0x00000400);
			 }
			 result.outputSpecs_ = outputSpecs_;
		 }
		 else {
			 result.outputSpecs_ = outputSpecsBuilder_.build();
		 }
		 if (groupedInputSpecsBuilder_ == null) {
			 if (((bitField0_ & 0x00000800) == 0x00000800)) {
				 groupedInputSpecs_ = java.util.Collections.unmodifiableList(groupedInputSpecs_);
				 bitField0_ = (bitField0_ & ~0x00000800);
			 }
			 result.groupedInputSpecs_ = groupedInputSpecs_;
		 }
		 else {
			 result.groupedInputSpecs_ = groupedInputSpecsBuilder_.build();
		 }
		 if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
			 to_bitField0_ |= 0x00000200;
		 }
		 result.vertexParallelism_ = vertexParallelism_;
		 if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
			 to_bitField0_ |= 0x00000400;
		 }
		 result.isExternalSubmission_ = isExternalSubmission_;
		 result.bitField0_ = to_bitField0_;
		 onBuilt();
		 return result;
	 }
	 public Builder mergeFrom(com.google.protobuf.Message other) {
		 if (other instanceof org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec) {
			 return mergeFrom((org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec)other);
		 }
		 else {
			 super.mergeFrom(other);
			 return this;
		 }
	 }
	 public Builder mergeFrom(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec other) {
		 if (other == org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec.getDefaultInstance()) return this;
		 if (other.hasUser()) {
			 bitField0_ |= 0x00000001;
			 user_ = other.user_;
			 onChanged();
		 }
		 if (other.hasSignatureKeyId()) {
			 setSignatureKeyId(other.getSignatureKeyId());
		 }
		 if (other.hasQueryIdentifier()) {
			 mergeQueryIdentifier(other.getQueryIdentifier());
		 }
		 if (other.hasHiveQueryId()) {
			 bitField0_ |= 0x00000008;
			 hiveQueryId_ = other.hiveQueryId_;
			 onChanged();
		 }
		 if (other.hasDagName()) {
			 bitField0_ |= 0x00000010;
			 dagName_ = other.dagName_;
			 onChanged();
		 }
		 if (other.hasVertexName()) {
			 bitField0_ |= 0x00000020;
			 vertexName_ = other.vertexName_;
			 onChanged();
		 }
		 if (other.hasVertexIndex()) {
			 setVertexIndex(other.getVertexIndex());
		 }
		 if (other.hasTokenIdentifier()) {
			 bitField0_ |= 0x00000080;
			 tokenIdentifier_ = other.tokenIdentifier_;
			 onChanged();
		 }
		 if (other.hasProcessorDescriptor()) {
			 mergeProcessorDescriptor(other.getProcessorDescriptor());
		 }
		 if (inputSpecsBuilder_ == null) {
			 if (!other.inputSpecs_.isEmpty()) {
				 if (inputSpecs_.isEmpty()) {
					 inputSpecs_ = other.inputSpecs_;
					 bitField0_ = (bitField0_ & ~0x00000200);
				 }
				 else {
					 ensureInputSpecsIsMutable();
					 inputSpecs_.addAll(other.inputSpecs_);
				 }
				 onChanged();
			 }
		 }
		 else {
			 if (!other.inputSpecs_.isEmpty()) {
				 if (inputSpecsBuilder_.isEmpty()) {
					 inputSpecsBuilder_.dispose();
					 inputSpecsBuilder_ = null;
					 inputSpecs_ = other.inputSpecs_;
					 bitField0_ = (bitField0_ & ~0x00000200);
					 inputSpecsBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getInputSpecsFieldBuilder() : null;
				 }
				 else {
					 inputSpecsBuilder_.addAllMessages(other.inputSpecs_);
				 }
			 }
		 }
		 if (outputSpecsBuilder_ == null) {
			 if (!other.outputSpecs_.isEmpty()) {
				 if (outputSpecs_.isEmpty()) {
					 outputSpecs_ = other.outputSpecs_;
					 bitField0_ = (bitField0_ & ~0x00000400);
				 }
				 else {
					 ensureOutputSpecsIsMutable();
					 outputSpecs_.addAll(other.outputSpecs_);
				 }
				 onChanged();
			 }
		 }
		 else {
			 if (!other.outputSpecs_.isEmpty()) {
				 if (outputSpecsBuilder_.isEmpty()) {
					 outputSpecsBuilder_.dispose();
					 outputSpecsBuilder_ = null;
					 outputSpecs_ = other.outputSpecs_;
					 bitField0_ = (bitField0_ & ~0x00000400);
					 outputSpecsBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getOutputSpecsFieldBuilder() : null;
				 }
				 else {
					 outputSpecsBuilder_.addAllMessages(other.outputSpecs_);
				 }
			 }
		 }
		 if (groupedInputSpecsBuilder_ == null) {
			 if (!other.groupedInputSpecs_.isEmpty()) {
				 if (groupedInputSpecs_.isEmpty()) {
					 groupedInputSpecs_ = other.groupedInputSpecs_;
					 bitField0_ = (bitField0_ & ~0x00000800);
				 }
				 else {
					 ensureGroupedInputSpecsIsMutable();
					 groupedInputSpecs_.addAll(other.groupedInputSpecs_);
				 }
				 onChanged();
			 }
		 }
		 else {
			 if (!other.groupedInputSpecs_.isEmpty()) {
				 if (groupedInputSpecsBuilder_.isEmpty()) {
					 groupedInputSpecsBuilder_.dispose();
					 groupedInputSpecsBuilder_ = null;
					 groupedInputSpecs_ = other.groupedInputSpecs_;
					 bitField0_ = (bitField0_ & ~0x00000800);
					 groupedInputSpecsBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getGroupedInputSpecsFieldBuilder() : null;
				 }
				 else {
					 groupedInputSpecsBuilder_.addAllMessages(other.groupedInputSpecs_);
				 }
			 }
		 }
		 if (other.hasVertexParallelism()) {
			 setVertexParallelism(other.getVertexParallelism());
		 }
		 if (other.hasIsExternalSubmission()) {
			 setIsExternalSubmission(other.getIsExternalSubmission());
		 }
		 this.mergeUnknownFields(other.getUnknownFields());
		 return this;
	 }
	 public final boolean isInitialized() {
		 return true;
	 }
	 public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec parsedMessage = null;
		 try {
			 parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
		 }
		 catch (com.google.protobuf.InvalidProtocolBufferException e) {
			 parsedMessage = (org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.SignableVertexSpec) e.getUnfinishedMessage();
			 throw e;
		 }
		 finally {
			 if (parsedMessage != null) {
				 mergeFrom(parsedMessage);
			 }
		 }
		 return this;
	 }
	 private int bitField0_;
	 private java.lang.Object user_ = """";
	 public boolean hasUser() {
		 return ((bitField0_ & 0x00000001) == 0x00000001);
	 }
	 public java.lang.String getUser() {
		 java.lang.Object ref = user_;
		 if (!(ref instanceof java.lang.String)) {
			 java.lang.String s = ((com.google.protobuf.ByteString) ref) .toStringUtf8();
			 user_ = s;
			 return s;
		 }
		 else {
			 return (java.lang.String) ref;
		 }
	 }
	 public com.google.protobuf.ByteString getUserBytes() {
		 java.lang.Object ref = user_;
		 if (ref instanceof String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 user_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public Builder setUser( java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000001;
		 user_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearUser() {
		 bitField0_ = (bitField0_ & ~0x00000001);
		 user_ = getDefaultInstance().getUser();
		 onChanged();
		 return this;
	 }
	 public Builder setUserBytes( com.google.protobuf.ByteString value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000001;
		 user_ = value;
		 onChanged();
		 return this;
	 }
	 private long signatureKeyId_ ;
	 public boolean hasSignatureKeyId() {
		 return ((bitField0_ & 0x00000002) == 0x00000002);
	 }
	 public long getSignatureKeyId() {
		 return signatureKeyId_;
	 }
	 public Builder setSignatureKeyId(long value) {
		 bitField0_ |= 0x00000002;
		 signatureKeyId_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearSignatureKeyId() {
		 bitField0_ = (bitField0_ & ~0x00000002);
		 signatureKeyId_ = 0L;
		 onChanged();
		 return this;
	 }
	 private org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto queryIdentifier_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.getDefaultInstance();
	 private com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProtoOrBuilder> queryIdentifierBuilder_;
	 public boolean hasQueryIdentifier() {
		 return ((bitField0_ & 0x00000004) == 0x00000004);
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto getQueryIdentifier() {
		 if (queryIdentifierBuilder_ == null) {
			 return queryIdentifier_;
		 }
		 else {
			 return queryIdentifierBuilder_.getMessage();
		 }
	 }
	 public Builder setQueryIdentifier(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto value) {
		 if (queryIdentifierBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 queryIdentifier_ = value;
			 onChanged();
		 }
		 else {
			 queryIdentifierBuilder_.setMessage(value);
		 }
		 bitField0_ |= 0x00000004;
		 return this;
	 }
	 public Builder setQueryIdentifier( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.Builder builderForValue) {
		 if (queryIdentifierBuilder_ == null) {
			 queryIdentifier_ = builderForValue.build();
			 onChanged();
		 }
		 else {
			 queryIdentifierBuilder_.setMessage(builderForValue.build());
		 }
		 bitField0_ |= 0x00000004;
		 return this;
	 }
	 public Builder mergeQueryIdentifier(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto value) {
		 if (queryIdentifierBuilder_ == null) {
			 if (((bitField0_ & 0x00000004) == 0x00000004) && queryIdentifier_ != org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.getDefaultInstance()) {
				 queryIdentifier_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.newBuilder(queryIdentifier_).mergeFrom(value).buildPartial();
			 }
			 else {
				 queryIdentifier_ = value;
			 }
			 onChanged();
		 }
		 else {
			 queryIdentifierBuilder_.mergeFrom(value);
		 }
		 bitField0_ |= 0x00000004;
		 return this;
	 }
	 public Builder clearQueryIdentifier() {
		 if (queryIdentifierBuilder_ == null) {
			 queryIdentifier_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.getDefaultInstance();
			 onChanged();
		 }
		 else {
			 queryIdentifierBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000004);
		 return this;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.Builder getQueryIdentifierBuilder() {
		 bitField0_ |= 0x00000004;
		 onChanged();
		 return getQueryIdentifierFieldBuilder().getBuilder();
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProtoOrBuilder getQueryIdentifierOrBuilder() {
		 if (queryIdentifierBuilder_ != null) {
			 return queryIdentifierBuilder_.getMessageOrBuilder();
		 }
		 else {
			 return queryIdentifier_;
		 }
	 }
	 private com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProtoOrBuilder> getQueryIdentifierFieldBuilder() {
		 if (queryIdentifierBuilder_ == null) {
			 queryIdentifierBuilder_ = new com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.QueryIdentifierProtoOrBuilder>( queryIdentifier_, getParentForChildren(), isClean());
			 queryIdentifier_ = null;
		 }
		 return queryIdentifierBuilder_;
	 }
	 private java.lang.Object hiveQueryId_ = """";
	 public boolean hasHiveQueryId() {
		 return ((bitField0_ & 0x00000008) == 0x00000008);
	 }
	 public java.lang.String getHiveQueryId() {
		 java.lang.Object ref = hiveQueryId_;
		 if (!(ref instanceof java.lang.String)) {
			 java.lang.String s = ((com.google.protobuf.ByteString) ref) .toStringUtf8();
			 hiveQueryId_ = s;
			 return s;
		 }
		 else {
			 return (java.lang.String) ref;
		 }
	 }
	 public com.google.protobuf.ByteString getHiveQueryIdBytes() {
		 java.lang.Object ref = hiveQueryId_;
		 if (ref instanceof String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 hiveQueryId_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public Builder setHiveQueryId( java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000008;
		 hiveQueryId_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearHiveQueryId() {
		 bitField0_ = (bitField0_ & ~0x00000008);
		 hiveQueryId_ = getDefaultInstance().getHiveQueryId();
		 onChanged();
		 return this;
	 }
	 public Builder setHiveQueryIdBytes( com.google.protobuf.ByteString value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000008;
		 hiveQueryId_ = value;
		 onChanged();
		 return this;
	 }
	 private java.lang.Object dagName_ = """";
	 public boolean hasDagName() {
		 return ((bitField0_ & 0x00000010) == 0x00000010);
	 }
	 public java.lang.String getDagName() {
		 java.lang.Object ref = dagName_;
		 if (!(ref instanceof java.lang.String)) {
			 java.lang.String s = ((com.google.protobuf.ByteString) ref) .toStringUtf8();
			 dagName_ = s;
			 return s;
		 }
		 else {
			 return (java.lang.String) ref;
		 }
	 }
	 public com.google.protobuf.ByteString getDagNameBytes() {
		 java.lang.Object ref = dagName_;
		 if (ref instanceof String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 dagName_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public Builder setDagName( java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000010;
		 dagName_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearDagName() {
		 bitField0_ = (bitField0_ & ~0x00000010);
		 dagName_ = getDefaultInstance().getDagName();
		 onChanged();
		 return this;
	 }
	 public Builder setDagNameBytes( com.google.protobuf.ByteString value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000010;
		 dagName_ = value;
		 onChanged();
		 return this;
	 }
	 private java.lang.Object vertexName_ = """";
	 public boolean hasVertexName() {
		 return ((bitField0_ & 0x00000020) == 0x00000020);
	 }
	 public java.lang.String getVertexName() {
		 java.lang.Object ref = vertexName_;
		 if (!(ref instanceof java.lang.String)) {
			 java.lang.String s = ((com.google.protobuf.ByteString) ref) .toStringUtf8();
			 vertexName_ = s;
			 return s;
		 }
		 else {
			 return (java.lang.String) ref;
		 }
	 }
	 public com.google.protobuf.ByteString getVertexNameBytes() {
		 java.lang.Object ref = vertexName_;
		 if (ref instanceof String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 vertexName_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public Builder setVertexName( java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000020;
		 vertexName_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearVertexName() {
		 bitField0_ = (bitField0_ & ~0x00000020);
		 vertexName_ = getDefaultInstance().getVertexName();
		 onChanged();
		 return this;
	 }
	 public Builder setVertexNameBytes( com.google.protobuf.ByteString value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000020;
		 vertexName_ = value;
		 onChanged();
		 return this;
	 }
	 private int vertexIndex_ ;
	 public boolean hasVertexIndex() {
		 return ((bitField0_ & 0x00000040) == 0x00000040);
	 }
	 public int getVertexIndex() {
		 return vertexIndex_;
	 }
	 public Builder setVertexIndex(int value) {
		 bitField0_ |= 0x00000040;
		 vertexIndex_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearVertexIndex() {
		 bitField0_ = (bitField0_ & ~0x00000040);
		 vertexIndex_ = 0;
		 onChanged();
		 return this;
	 }
	 private java.lang.Object tokenIdentifier_ = """";
	 public boolean hasTokenIdentifier() {
		 return ((bitField0_ & 0x00000080) == 0x00000080);
	 }
	 public java.lang.String getTokenIdentifier() {
		 java.lang.Object ref = tokenIdentifier_;
		 if (!(ref instanceof java.lang.String)) {
			 java.lang.String s = ((com.google.protobuf.ByteString) ref) .toStringUtf8();
			 tokenIdentifier_ = s;
			 return s;
		 }
		 else {
			 return (java.lang.String) ref;
		 }
	 }
	 public com.google.protobuf.ByteString getTokenIdentifierBytes() {
		 java.lang.Object ref = tokenIdentifier_;
		 if (ref instanceof String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 tokenIdentifier_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public Builder setTokenIdentifier( java.lang.String value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000080;
		 tokenIdentifier_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearTokenIdentifier() {
		 bitField0_ = (bitField0_ & ~0x00000080);
		 tokenIdentifier_ = getDefaultInstance().getTokenIdentifier();
		 onChanged();
		 return this;
	 }
	 public Builder setTokenIdentifierBytes( com.google.protobuf.ByteString value) {
		 if (value == null) {
			 throw new NullPointerException();
		 }
		 bitField0_ |= 0x00000080;
		 tokenIdentifier_ = value;
		 onChanged();
		 return this;
	 }
	 private org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto processorDescriptor_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.getDefaultInstance();
	 private com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProtoOrBuilder> processorDescriptorBuilder_;
	 public boolean hasProcessorDescriptor() {
		 return ((bitField0_ & 0x00000100) == 0x00000100);
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto getProcessorDescriptor() {
		 if (processorDescriptorBuilder_ == null) {
			 return processorDescriptor_;
		 }
		 else {
			 return processorDescriptorBuilder_.getMessage();
		 }
	 }
	 public Builder setProcessorDescriptor(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto value) {
		 if (processorDescriptorBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 processorDescriptor_ = value;
			 onChanged();
		 }
		 else {
			 processorDescriptorBuilder_.setMessage(value);
		 }
		 bitField0_ |= 0x00000100;
		 return this;
	 }
	 public Builder setProcessorDescriptor( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.Builder builderForValue) {
		 if (processorDescriptorBuilder_ == null) {
			 processorDescriptor_ = builderForValue.build();
			 onChanged();
		 }
		 else {
			 processorDescriptorBuilder_.setMessage(builderForValue.build());
		 }
		 bitField0_ |= 0x00000100;
		 return this;
	 }
	 public Builder mergeProcessorDescriptor(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto value) {
		 if (processorDescriptorBuilder_ == null) {
			 if (((bitField0_ & 0x00000100) == 0x00000100) && processorDescriptor_ != org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.getDefaultInstance()) {
				 processorDescriptor_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.newBuilder(processorDescriptor_).mergeFrom(value).buildPartial();
			 }
			 else {
				 processorDescriptor_ = value;
			 }
			 onChanged();
		 }
		 else {
			 processorDescriptorBuilder_.mergeFrom(value);
		 }
		 bitField0_ |= 0x00000100;
		 return this;
	 }
	 public Builder clearProcessorDescriptor() {
		 if (processorDescriptorBuilder_ == null) {
			 processorDescriptor_ = org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.getDefaultInstance();
			 onChanged();
		 }
		 else {
			 processorDescriptorBuilder_.clear();
		 }
		 bitField0_ = (bitField0_ & ~0x00000100);
		 return this;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.Builder getProcessorDescriptorBuilder() {
		 bitField0_ |= 0x00000100;
		 onChanged();
		 return getProcessorDescriptorFieldBuilder().getBuilder();
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProtoOrBuilder getProcessorDescriptorOrBuilder() {
		 if (processorDescriptorBuilder_ != null) {
			 return processorDescriptorBuilder_.getMessageOrBuilder();
		 }
		 else {
			 return processorDescriptor_;
		 }
	 }
	 private com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProtoOrBuilder> getProcessorDescriptorFieldBuilder() {
		 if (processorDescriptorBuilder_ == null) {
			 processorDescriptorBuilder_ = new com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.EntityDescriptorProtoOrBuilder>( processorDescriptor_, getParentForChildren(), isClean());
			 processorDescriptor_ = null;
		 }
		 return processorDescriptorBuilder_;
	 }
	 private java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto> inputSpecs_ = java.util.Collections.emptyList();
	 private void ensureInputSpecsIsMutable() {
		 if (!((bitField0_ & 0x00000200) == 0x00000200)) {
			 inputSpecs_ = new java.util.ArrayList<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto>(inputSpecs_);
			 bitField0_ |= 0x00000200;
		 }
	 }
	 private com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder> inputSpecsBuilder_;
	 public java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto> getInputSpecsList() {
		 if (inputSpecsBuilder_ == null) {
			 return java.util.Collections.unmodifiableList(inputSpecs_);
		 }
		 else {
			 return inputSpecsBuilder_.getMessageList();
		 }
	 }
	 public int getInputSpecsCount() {
		 if (inputSpecsBuilder_ == null) {
			 return inputSpecs_.size();
		 }
		 else {
			 return inputSpecsBuilder_.getCount();
		 }
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto getInputSpecs(int index) {
		 if (inputSpecsBuilder_ == null) {
			 return inputSpecs_.get(index);
		 }
		 else {
			 return inputSpecsBuilder_.getMessage(index);
		 }
	 }
	 public Builder setInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto value) {
		 if (inputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureInputSpecsIsMutable();
			 inputSpecs_.set(index, value);
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.setMessage(index, value);
		 }
		 return this;
	 }
	 public Builder setInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder builderForValue) {
		 if (inputSpecsBuilder_ == null) {
			 ensureInputSpecsIsMutable();
			 inputSpecs_.set(index, builderForValue.build());
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.setMessage(index, builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addInputSpecs(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto value) {
		 if (inputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureInputSpecsIsMutable();
			 inputSpecs_.add(value);
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.addMessage(value);
		 }
		 return this;
	 }
	 public Builder addInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto value) {
		 if (inputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureInputSpecsIsMutable();
			 inputSpecs_.add(index, value);
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.addMessage(index, value);
		 }
		 return this;
	 }
	 public Builder addInputSpecs( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder builderForValue) {
		 if (inputSpecsBuilder_ == null) {
			 ensureInputSpecsIsMutable();
			 inputSpecs_.add(builderForValue.build());
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.addMessage(builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder builderForValue) {
		 if (inputSpecsBuilder_ == null) {
			 ensureInputSpecsIsMutable();
			 inputSpecs_.add(index, builderForValue.build());
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.addMessage(index, builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addAllInputSpecs( java.lang.Iterable<? extends org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto> values) {
		 if (inputSpecsBuilder_ == null) {
			 ensureInputSpecsIsMutable();
			 super.addAll(values, inputSpecs_);
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.addAllMessages(values);
		 }
		 return this;
	 }
	 public Builder clearInputSpecs() {
		 if (inputSpecsBuilder_ == null) {
			 inputSpecs_ = java.util.Collections.emptyList();
			 bitField0_ = (bitField0_ & ~0x00000200);
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.clear();
		 }
		 return this;
	 }
	 public Builder removeInputSpecs(int index) {
		 if (inputSpecsBuilder_ == null) {
			 ensureInputSpecsIsMutable();
			 inputSpecs_.remove(index);
			 onChanged();
		 }
		 else {
			 inputSpecsBuilder_.remove(index);
		 }
		 return this;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder getInputSpecsBuilder( int index) {
		 return getInputSpecsFieldBuilder().getBuilder(index);
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder getInputSpecsOrBuilder( int index) {
		 if (inputSpecsBuilder_ == null) {
			 return inputSpecs_.get(index);
		 }
		 else {
			 return inputSpecsBuilder_.getMessageOrBuilder(index);
		 }
	 }
	 public java.util.List<? extends org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder> getInputSpecsOrBuilderList() {
		 if (inputSpecsBuilder_ != null) {
			 return inputSpecsBuilder_.getMessageOrBuilderList();
		 }
		 else {
			 return java.util.Collections.unmodifiableList(inputSpecs_);
		 }
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder addInputSpecsBuilder() {
		 return getInputSpecsFieldBuilder().addBuilder( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.getDefaultInstance());
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder addInputSpecsBuilder( int index) {
		 return getInputSpecsFieldBuilder().addBuilder( index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.getDefaultInstance());
	 }
	 public java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder> getInputSpecsBuilderList() {
		 return getInputSpecsFieldBuilder().getBuilderList();
	 }
	 private com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder> getInputSpecsFieldBuilder() {
		 if (inputSpecsBuilder_ == null) {
			 inputSpecsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder>( inputSpecs_, ((bitField0_ & 0x00000200) == 0x00000200), getParentForChildren(), isClean());
			 inputSpecs_ = null;
		 }
		 return inputSpecsBuilder_;
	 }
	 private java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto> outputSpecs_ = java.util.Collections.emptyList();
	 private void ensureOutputSpecsIsMutable() {
		 if (!((bitField0_ & 0x00000400) == 0x00000400)) {
			 outputSpecs_ = new java.util.ArrayList<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto>(outputSpecs_);
			 bitField0_ |= 0x00000400;
		 }
	 }
	 private com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder> outputSpecsBuilder_;
	 public java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto> getOutputSpecsList() {
		 if (outputSpecsBuilder_ == null) {
			 return java.util.Collections.unmodifiableList(outputSpecs_);
		 }
		 else {
			 return outputSpecsBuilder_.getMessageList();
		 }
	 }
	 public int getOutputSpecsCount() {
		 if (outputSpecsBuilder_ == null) {
			 return outputSpecs_.size();
		 }
		 else {
			 return outputSpecsBuilder_.getCount();
		 }
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto getOutputSpecs(int index) {
		 if (outputSpecsBuilder_ == null) {
			 return outputSpecs_.get(index);
		 }
		 else {
			 return outputSpecsBuilder_.getMessage(index);
		 }
	 }
	 public Builder setOutputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto value) {
		 if (outputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.set(index, value);
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.setMessage(index, value);
		 }
		 return this;
	 }
	 public Builder setOutputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder builderForValue) {
		 if (outputSpecsBuilder_ == null) {
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.set(index, builderForValue.build());
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.setMessage(index, builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addOutputSpecs(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto value) {
		 if (outputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.add(value);
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.addMessage(value);
		 }
		 return this;
	 }
	 public Builder addOutputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto value) {
		 if (outputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.add(index, value);
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.addMessage(index, value);
		 }
		 return this;
	 }
	 public Builder addOutputSpecs( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder builderForValue) {
		 if (outputSpecsBuilder_ == null) {
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.add(builderForValue.build());
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.addMessage(builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addOutputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder builderForValue) {
		 if (outputSpecsBuilder_ == null) {
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.add(index, builderForValue.build());
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.addMessage(index, builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addAllOutputSpecs( java.lang.Iterable<? extends org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto> values) {
		 if (outputSpecsBuilder_ == null) {
			 ensureOutputSpecsIsMutable();
			 super.addAll(values, outputSpecs_);
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.addAllMessages(values);
		 }
		 return this;
	 }
	 public Builder clearOutputSpecs() {
		 if (outputSpecsBuilder_ == null) {
			 outputSpecs_ = java.util.Collections.emptyList();
			 bitField0_ = (bitField0_ & ~0x00000400);
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.clear();
		 }
		 return this;
	 }
	 public Builder removeOutputSpecs(int index) {
		 if (outputSpecsBuilder_ == null) {
			 ensureOutputSpecsIsMutable();
			 outputSpecs_.remove(index);
			 onChanged();
		 }
		 else {
			 outputSpecsBuilder_.remove(index);
		 }
		 return this;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder getOutputSpecsBuilder( int index) {
		 return getOutputSpecsFieldBuilder().getBuilder(index);
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder getOutputSpecsOrBuilder( int index) {
		 if (outputSpecsBuilder_ == null) {
			 return outputSpecs_.get(index);
		 }
		 else {
			 return outputSpecsBuilder_.getMessageOrBuilder(index);
		 }
	 }
	 public java.util.List<? extends org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder> getOutputSpecsOrBuilderList() {
		 if (outputSpecsBuilder_ != null) {
			 return outputSpecsBuilder_.getMessageOrBuilderList();
		 }
		 else {
			 return java.util.Collections.unmodifiableList(outputSpecs_);
		 }
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder addOutputSpecsBuilder() {
		 return getOutputSpecsFieldBuilder().addBuilder( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.getDefaultInstance());
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder addOutputSpecsBuilder( int index) {
		 return getOutputSpecsFieldBuilder().addBuilder( index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.getDefaultInstance());
	 }
	 public java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder> getOutputSpecsBuilderList() {
		 return getOutputSpecsFieldBuilder().getBuilderList();
	 }
	 private com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder> getOutputSpecsFieldBuilder() {
		 if (outputSpecsBuilder_ == null) {
			 outputSpecsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.IOSpecProtoOrBuilder>( outputSpecs_, ((bitField0_ & 0x00000400) == 0x00000400), getParentForChildren(), isClean());
			 outputSpecs_ = null;
		 }
		 return outputSpecsBuilder_;
	 }
	 private java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto> groupedInputSpecs_ = java.util.Collections.emptyList();
	 private void ensureGroupedInputSpecsIsMutable() {
		 if (!((bitField0_ & 0x00000800) == 0x00000800)) {
			 groupedInputSpecs_ = new java.util.ArrayList<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto>(groupedInputSpecs_);
			 bitField0_ |= 0x00000800;
		 }
	 }
	 private com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProtoOrBuilder> groupedInputSpecsBuilder_;
	 public java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto> getGroupedInputSpecsList() {
		 if (groupedInputSpecsBuilder_ == null) {
			 return java.util.Collections.unmodifiableList(groupedInputSpecs_);
		 }
		 else {
			 return groupedInputSpecsBuilder_.getMessageList();
		 }
	 }
	 public int getGroupedInputSpecsCount() {
		 if (groupedInputSpecsBuilder_ == null) {
			 return groupedInputSpecs_.size();
		 }
		 else {
			 return groupedInputSpecsBuilder_.getCount();
		 }
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto getGroupedInputSpecs(int index) {
		 if (groupedInputSpecsBuilder_ == null) {
			 return groupedInputSpecs_.get(index);
		 }
		 else {
			 return groupedInputSpecsBuilder_.getMessage(index);
		 }
	 }
	 public Builder setGroupedInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto value) {
		 if (groupedInputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.set(index, value);
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.setMessage(index, value);
		 }
		 return this;
	 }
	 public Builder setGroupedInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder builderForValue) {
		 if (groupedInputSpecsBuilder_ == null) {
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.set(index, builderForValue.build());
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.setMessage(index, builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addGroupedInputSpecs(org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto value) {
		 if (groupedInputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.add(value);
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.addMessage(value);
		 }
		 return this;
	 }
	 public Builder addGroupedInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto value) {
		 if (groupedInputSpecsBuilder_ == null) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.add(index, value);
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.addMessage(index, value);
		 }
		 return this;
	 }
	 public Builder addGroupedInputSpecs( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder builderForValue) {
		 if (groupedInputSpecsBuilder_ == null) {
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.add(builderForValue.build());
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.addMessage(builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addGroupedInputSpecs( int index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder builderForValue) {
		 if (groupedInputSpecsBuilder_ == null) {
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.add(index, builderForValue.build());
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.addMessage(index, builderForValue.build());
		 }
		 return this;
	 }
	 public Builder addAllGroupedInputSpecs( java.lang.Iterable<? extends org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto> values) {
		 if (groupedInputSpecsBuilder_ == null) {
			 ensureGroupedInputSpecsIsMutable();
			 super.addAll(values, groupedInputSpecs_);
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.addAllMessages(values);
		 }
		 return this;
	 }
	 public Builder clearGroupedInputSpecs() {
		 if (groupedInputSpecsBuilder_ == null) {
			 groupedInputSpecs_ = java.util.Collections.emptyList();
			 bitField0_ = (bitField0_ & ~0x00000800);
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.clear();
		 }
		 return this;
	 }
	 public Builder removeGroupedInputSpecs(int index) {
		 if (groupedInputSpecsBuilder_ == null) {
			 ensureGroupedInputSpecsIsMutable();
			 groupedInputSpecs_.remove(index);
			 onChanged();
		 }
		 else {
			 groupedInputSpecsBuilder_.remove(index);
		 }
		 return this;
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder getGroupedInputSpecsBuilder( int index) {
		 return getGroupedInputSpecsFieldBuilder().getBuilder(index);
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProtoOrBuilder getGroupedInputSpecsOrBuilder( int index) {
		 if (groupedInputSpecsBuilder_ == null) {
			 return groupedInputSpecs_.get(index);
		 }
		 else {
			 return groupedInputSpecsBuilder_.getMessageOrBuilder(index);
		 }
	 }
	 public java.util.List<? extends org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProtoOrBuilder> getGroupedInputSpecsOrBuilderList() {
		 if (groupedInputSpecsBuilder_ != null) {
			 return groupedInputSpecsBuilder_.getMessageOrBuilderList();
		 }
		 else {
			 return java.util.Collections.unmodifiableList(groupedInputSpecs_);
		 }
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder addGroupedInputSpecsBuilder() {
		 return getGroupedInputSpecsFieldBuilder().addBuilder( org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.getDefaultInstance());
	 }
	 public org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder addGroupedInputSpecsBuilder( int index) {
		 return getGroupedInputSpecsFieldBuilder().addBuilder( index, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.getDefaultInstance());
	 }
	 public java.util.List<org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder> getGroupedInputSpecsBuilderList() {
		 return getGroupedInputSpecsFieldBuilder().getBuilderList();
	 }
	 private com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProtoOrBuilder> getGroupedInputSpecsFieldBuilder() {
		 if (groupedInputSpecsBuilder_ == null) {
			 groupedInputSpecsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder< org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProto.Builder, org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.GroupInputSpecProtoOrBuilder>( groupedInputSpecs_, ((bitField0_ & 0x00000800) == 0x00000800), getParentForChildren(), isClean());
			 groupedInputSpecs_ = null;
		 }
		 return groupedInputSpecsBuilder_;
	 }
	 private int vertexParallelism_ ;
	 public boolean hasVertexParallelism() {
		 return ((bitField0_ & 0x00001000) == 0x00001000);
	 }
	 public int getVertexParallelism() {
		 return vertexParallelism_;
	 }
	 public Builder setVertexParallelism(int value) {
		 bitField0_ |= 0x00001000;
		 vertexParallelism_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearVertexParallelism() {
		 bitField0_ = (bitField0_ & ~0x00001000);
		 vertexParallelism_ = 0;
		 onChanged();
		 return this;
	 }
	 private boolean isExternalSubmission_ ;
	 public boolean hasIsExternalSubmission() {
		 return ((bitField0_ & 0x00002000) == 0x00002000);
	 }
	 public boolean getIsExternalSubmission() {
		 return isExternalSubmission_;
	 }
	 public Builder setIsExternalSubmission(boolean value) {
		 bitField0_ |= 0x00002000;
		 isExternalSubmission_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearIsExternalSubmission() {
		 bitField0_ = (bitField0_ & ~0x00002000);
		 isExternalSubmission_ = false;
		 onChanged();
		 return this;
	 }
 }",1,0,0,0
"public class FmtSelector {
	 private String classname;
	 private String extension = "".txt"";
	 private OutputStream out = System.out;
	 private File outFile;
	 private boolean useFile = true;
	 public Formatter createFormatter() throws BuildException {
		 if (classname == null) {
			 throw new BuildException(""missing formatter class name"");
		 }
		 Class fmtClass = null;
		 try {
			 fmtClass = Class.forName(classname);
		 }
		 catch (ClassNotFoundException e) {
			 throw new BuildException(e);
		 }
		 Formatter fmt = null;
		 try {
			 fmt = (Formatter) fmtClass.newInstance();
		 }
		 catch (IllegalAccessException e) {
			 throw new BuildException(e);
		 }
		 catch (InstantiationException e) {
			 throw new BuildException(e);
		 }
		 catch (ClassCastException e) {
			 throw new BuildException(classname + "" is not a Formatter"");
		 }
		 if (useFile && outFile != null) {
			 try {
				 out = new FileOutputStream(outFile);
			 }
			 catch (java.io.IOException e) {
				 throw new BuildException(e);
			 }
		 }
		 fmt.setOutput(out);
		 return fmt;
	 }
	 private static Hashtable extensions = null;
	 private static Hashtable types = null;
	 {
		 types = new Hashtable();
		 types.put (""brief"", ""org.quilt.reports.BriefFormatter"");
		 types.put (""plain"", ""org.quilt.reports.PlainFormatter"");
		 types.put (""summary"", ""org.quilt.reports.SummaryFormatter"");
		 types.put (""xml"", ""org.quilt.reports.XMLFormatter"");
		 extensions = new Hashtable();
		 extensions.put (""org.quilt.reports.BriefFormatter"", "".txt"");
		 extensions.put (""org.quilt.reports.PlainFormatter"", "".txt"");
		 extensions.put (""org.quilt.reports.SummaryFormatter"", "".txt"");
		 extensions.put (""org.quilt.reports.XMLFormatter"", "".xml"");
	 }
	 public boolean isKnownType (String t) {
		 return types.containsKey(t);
	 }
	 public void setType (String t) {
		 if (! types.containsKey(t) ) {
			 throw new BuildException (""unknown formatter type "" + t);
		 }
		 classname = (String) types.get(t);
		 extension = (String) extensions.get(classname);
	 }
	 public String getClassname() {
		 return classname;
	 }
	 public void setClassname(String classname) {
		 this.classname = classname;
	 }
	 public String getExtension() {
		 return extension;
	 }
	 public void setExtension(String ext) {
		 extension = ext;
	 }
	 public void setOutfile(File out) {
		 outFile = out;
	 }
	 public void setOutput(OutputStream out) {
		 out = out;
	 }
	 public boolean getUseFile() {
		 return useFile;
	 }
	 public void setUseFile(boolean b) {
		 this.useFile = b;
	 }
	 public String toString() {
		 return ""Formatter: "" + classname + "", extension: "" + extension;
	 }
}",0,1,0,0
"public class NodeOrderer implements ILayoutPhase<TreeLayoutPhases, TGraph> {
	 private static final LayoutProcessorConfiguration<TreeLayoutPhases, TGraph> INTERMEDIATE_PROCESSING_CONFIG = LayoutProcessorConfiguration.<TreeLayoutPhases, TGraph>create() .before(TreeLayoutPhases.P2_NODE_ORDERING) .add(IntermediateProcessorStrategy.ROOT_PROC) .add(IntermediateProcessorStrategy.FAN_PROC);
	 public LayoutProcessorConfiguration<TreeLayoutPhases, TGraph> getLayoutProcessorConfiguration(final TGraph graph) {
		 return INTERMEDIATE_PROCESSING_CONFIG;
	 }
	 public void process(final TGraph tGraph, final IElkProgressMonitor progressMonitor) {
		 progressMonitor.begin(""Processor arrange node"", 1);
		 TNode root = null;
		 LinkedList<TNode> roots = new LinkedList<TNode>();
		 Iterator<TNode> it = tGraph.getNodes().iterator();
		 while (root == null && it.hasNext()) {
			 TNode tNode = it.next();
			 if (tNode.getProperty(InternalProperties.ROOT)) {
				 root = tNode;
			 }
		 }
		 roots.add(root);
		 orderLevel(roots, progressMonitor.subTask(1.0f));
		 progressMonitor.done();
	 }
	 private void orderLevel(final LinkedList<TNode> currentLevel, final IElkProgressMonitor progressMonitor) {
		 progressMonitor.begin(""Processor arrange level"", 1);
		 int pos = 0;
		 Collections.sort(currentLevel, PropertyHolderComparator.with(InternalProperties.FAN));
		 int firstOcc = currentLevel.size();
		 ListIterator<TNode> it = currentLevel.listIterator(currentLevel.size());
		 boolean notNull = true;
		 while (notNull && it.hasPrevious()) {
			 TNode tNode = (TNode) it.previous();
			 if ((tNode.getProperty(InternalProperties.FAN) == 0)) {
				 firstOcc--;
			 }
			 else {
				 notNull = false;
			 }
		 }
		 List<TNode> tmp = currentLevel.subList(0, firstOcc);
		 LinkedList<TNode> inners = new LinkedList<TNode>(tmp);
		 tmp = currentLevel.subList(firstOcc, currentLevel.size());
		 LinkedList<TNode> leaves = new LinkedList<TNode>(tmp);
		 if (inners.isEmpty()) {
			 for (TNode tENode : leaves) {
				 tENode.setProperty(InternalProperties.POSITION, pos++);
			 }
		 }
		 else {
			 int size = inners.size();
			 for (TNode tPNode : inners) {
				 tPNode.setProperty(InternalProperties.POSITION, pos++);
				 LinkedList<TNode> children = tPNode.getChildrenCopy();
				 orderLevel(children, progressMonitor.subTask(1 / size));
				 Collections.sort(children, Collections.reverseOrder(PropertyHolderComparator.with(InternalProperties.POSITION)));
				 List<TEdge> sortedOutEdges = new LinkedList<TEdge>();
				 for (TNode tNode : children) {
					 for (TEdge tEdge : tPNode.getOutgoingEdges()) {
						 if (tEdge.getTarget() == tNode) {
							 sortedOutEdges.add(tEdge);
						 }
					 }
				 }
				 tPNode.getOutgoingEdges().clear();
				 tPNode.getOutgoingEdges().addAll(sortedOutEdges);
				 it = leaves.listIterator(leaves.size());
				 int fillGap = tPNode.getOutgoingEdges().size();
				 notNull = true;
				 while ((0 < fillGap) && notNull && it.hasPrevious()) {
					 TNode tNode = (TNode) it.previous();
					 if ((tNode.getProperty(InternalProperties.FAN) == 0)) {
						 tNode.setProperty(InternalProperties.POSITION, pos++);
						 fillGap--;
						 it.remove();
					 }
					 else {
						 notNull = false;
					 }
				 }
			 }
		 }
		 progressMonitor.done();
	 }
}",1,0,0,0
"public class XMLSchemaValidator implements XMLComponent, XMLDocumentFilter, FieldActivator, RevalidationHandler {
	 private static final boolean DEBUG = false;
	 protected static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
	 protected static final String SCHEMA_VALIDATION = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
	 protected static final String SCHEMA_FULL_CHECKING = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_FULL_CHECKING;
	 protected static final String DYNAMIC_VALIDATION = Constants.XERCES_FEATURE_PREFIX + Constants.DYNAMIC_VALIDATION_FEATURE;
	 protected static final String NORMALIZE_DATA = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_NORMALIZED_VALUE;
	 protected static final String SCHEMA_ELEMENT_DEFAULT = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_ELEMENT_DEFAULT;
	 protected static final String SCHEMA_AUGMENT_PSVI = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_AUGMENT_PSVI;
	 protected static final String ALLOW_JAVA_ENCODINGS = Constants.XERCES_FEATURE_PREFIX + Constants.ALLOW_JAVA_ENCODINGS_FEATURE;
	 protected static final String STANDARD_URI_CONFORMANT_FEATURE = Constants.XERCES_FEATURE_PREFIX + Constants.STANDARD_URI_CONFORMANT_FEATURE;
	 protected static final String GENERATE_SYNTHETIC_ANNOTATIONS = Constants.XERCES_FEATURE_PREFIX + Constants.GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE;
	 protected static final String VALIDATE_ANNOTATIONS = Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATE_ANNOTATIONS_FEATURE;
	 protected static final String HONOUR_ALL_SCHEMALOCATIONS = Constants.XERCES_FEATURE_PREFIX + Constants.HONOUR_ALL_SCHEMALOCATIONS_FEATURE;
	 protected static final String USE_GRAMMAR_POOL_ONLY = Constants.XERCES_FEATURE_PREFIX + Constants.USE_GRAMMAR_POOL_ONLY_FEATURE;
	 protected static final String CONTINUE_AFTER_FATAL_ERROR = Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE;
	 protected static final String PARSER_SETTINGS = Constants.XERCES_FEATURE_PREFIX + Constants.PARSER_SETTINGS;
	 protected static final String NAMESPACE_GROWTH = Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACE_GROWTH_FEATURE;
	 protected static final String TOLERATE_DUPLICATES = Constants.XERCES_FEATURE_PREFIX + Constants.TOLERATE_DUPLICATES_FEATURE;
	 protected static final String IGNORE_XSI_TYPE = Constants.XERCES_FEATURE_PREFIX + Constants.IGNORE_XSI_TYPE_FEATURE;
	 protected static final String ID_IDREF_CHECKING = Constants.XERCES_FEATURE_PREFIX + Constants.ID_IDREF_CHECKING_FEATURE;
	 protected static final String UNPARSED_ENTITY_CHECKING = Constants.XERCES_FEATURE_PREFIX + Constants.UNPARSED_ENTITY_CHECKING_FEATURE;
	 protected static final String IDENTITY_CONSTRAINT_CHECKING = Constants.XERCES_FEATURE_PREFIX + Constants.IDC_CHECKING_FEATURE;
	 public static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
	 public static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
	 public static final String ENTITY_RESOLVER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
	 public static final String XMLGRAMMAR_POOL = Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
	 protected static final String VALIDATION_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY;
	 protected static final String ENTITY_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY;
	 protected static final String SCHEMA_LOCATION = Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_LOCATION;
	 protected static final String SCHEMA_NONS_LOCATION = Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_NONS_LOCATION;
	 protected static final String JAXP_SCHEMA_SOURCE = Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE;
	 protected static final String JAXP_SCHEMA_LANGUAGE = Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE;
	 protected static final String ROOT_TYPE_DEF = Constants.XERCES_PROPERTY_PREFIX + Constants.ROOT_TYPE_DEFINITION_PROPERTY;
	 protected static final String ROOT_ELEMENT_DECL = Constants.XERCES_PROPERTY_PREFIX + Constants.ROOT_ELEMENT_DECLARATION_PROPERTY;
	 protected static final String SCHEMA_DV_FACTORY = Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_DV_FACTORY_PROPERTY;
	 private static final String[] RECOGNIZED_FEATURES = {
	 VALIDATION, SCHEMA_VALIDATION, DYNAMIC_VALIDATION, SCHEMA_FULL_CHECKING, ALLOW_JAVA_ENCODINGS, CONTINUE_AFTER_FATAL_ERROR, STANDARD_URI_CONFORMANT_FEATURE, GENERATE_SYNTHETIC_ANNOTATIONS, VALIDATE_ANNOTATIONS, HONOUR_ALL_SCHEMALOCATIONS, USE_GRAMMAR_POOL_ONLY, IGNORE_XSI_TYPE, ID_IDREF_CHECKING, IDENTITY_CONSTRAINT_CHECKING, UNPARSED_ENTITY_CHECKING, NAMESPACE_GROWTH, TOLERATE_DUPLICATES }
	;
	 private static final Boolean[] FEATURE_DEFAULTS = {
	 null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null }
	;
	 private static final String[] RECOGNIZED_PROPERTIES = {
	 SYMBOL_TABLE, ERROR_REPORTER, ENTITY_RESOLVER, VALIDATION_MANAGER, SCHEMA_LOCATION, SCHEMA_NONS_LOCATION, JAXP_SCHEMA_SOURCE, JAXP_SCHEMA_LANGUAGE, ROOT_TYPE_DEF, ROOT_ELEMENT_DECL, SCHEMA_DV_FACTORY, }
	;
	 private static final Object[] PROPERTY_DEFAULTS = {
	 null, null, null, null, null, null, null, null, null, null, null}
	;
	 protected static final int ID_CONSTRAINT_NUM = 1;
	 static final XSAttributeDecl XSI_TYPE = SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_TYPE);
	 static final XSAttributeDecl XSI_NIL = SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_NIL);
	 static final XSAttributeDecl XSI_SCHEMALOCATION = SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_SCHEMALOCATION);
	 static final XSAttributeDecl XSI_NONAMESPACESCHEMALOCATION = SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);
	 private static final Hashtable EMPTY_TABLE = new Hashtable();
	 protected ElementPSVImpl fCurrentPSVI = new ElementPSVImpl();
	 protected final AugmentationsImpl fAugmentations = new AugmentationsImpl();
	 protected XMLString fDefaultValue;
	 protected boolean fDynamicValidation = false;
	 protected boolean fSchemaDynamicValidation = false;
	 protected boolean fDoValidation = false;
	 protected boolean fFullChecking = false;
	 protected boolean fNormalizeData = true;
	 protected boolean fSchemaElementDefault = true;
	 protected boolean fAugPSVI = true;
	 protected boolean fIdConstraint = false;
	 protected boolean fUseGrammarPoolOnly = false;
	 protected boolean fNamespaceGrowth = false;
	 private String fSchemaType = null;
	 protected boolean fEntityRef = false;
	 protected boolean fInCDATA = false;
	 protected SymbolTable fSymbolTable;
	 private XMLLocator fLocator;
	 protected final class XSIErrorReporter {
		 XMLErrorReporter fErrorReporter;
		 Vector fErrors = new Vector();
		 int[] fContext = new int[INITIAL_STACK_SIZE];
		 int fContextCount;
		 public void reset(XMLErrorReporter errorReporter) {
			 fErrorReporter = errorReporter;
			 fErrors.removeAllElements();
			 fContextCount = 0;
		 }
		 public void pushContext() {
			 if (!fAugPSVI) {
				 return;
			 }
			 if (fContextCount == fContext.length) {
				 int newSize = fContextCount + INC_STACK_SIZE;
				 int[] newArray = new int[newSize];
				 System.arraycopy(fContext, 0, newArray, 0, fContextCount);
				 fContext = newArray;
			 }
			 fContext[fContextCount++] = fErrors.size();
		 }
		 public String[] popContext() {
			 if (!fAugPSVI) {
				 return null;
			 }
			 int contextPos = fContext[--fContextCount];
			 int size = fErrors.size() - contextPos;
			 if (size == 0) return null;
			 String[] errors = new String[size];
			 for (int i = 0;
			 i < size;
			 i++) {
				 errors[i] = (String) fErrors.elementAt(contextPos + i);
			 }
			 fErrors.setSize(contextPos);
			 return errors;
		 }
		 public String[] mergeContext() {
			 if (!fAugPSVI) {
				 return null;
			 }
			 int contextPos = fContext[--fContextCount];
			 int size = fErrors.size() - contextPos;
			 if (size == 0) return null;
			 String[] errors = new String[size];
			 for (int i = 0;
			 i < size;
			 i++) {
				 errors[i] = (String) fErrors.elementAt(contextPos + i);
			 }
			 return errors;
		 }
		 public void reportError(String domain, String key, Object[] arguments, short severity) throws XNIException {
			 String message = fErrorReporter.reportError(domain, key, arguments, severity);
			 if (fAugPSVI) {
				 fErrors.addElement(key);
				 fErrors.addElement(message);
			 }
		 }
		 public void reportError( XMLLocator location, String domain, String key, Object[] arguments, short severity) throws XNIException {
			 String message = fErrorReporter.reportError(location, domain, key, arguments, severity);
			 if (fAugPSVI) {
				 fErrors.addElement(key);
				 fErrors.addElement(message);
			 }
		 }
	 }
	 protected final XSIErrorReporter fXSIErrorReporter = new XSIErrorReporter();
	 protected XMLEntityResolver fEntityResolver;
	 protected ValidationManager fValidationManager = null;
	 protected ConfigurableValidationState fValidationState = new ConfigurableValidationState();
	 protected XMLGrammarPool fGrammarPool;
	 protected String fExternalSchemas = null;
	 protected String fExternalNoNamespaceSchema = null;
	 protected Object fJaxpSchemaSource = null;
	 protected final XSDDescription fXSDDescription = new XSDDescription();
	 protected final Hashtable fLocationPairs = new Hashtable();
	 protected final Hashtable fExpandedLocationPairs = new Hashtable();
	 protected final ArrayList fUnparsedLocations = new ArrayList();
	 protected XMLDocumentHandler fDocumentHandler;
	 protected XMLDocumentSource fDocumentSource;
	 public String[] getRecognizedFeatures() {
		 return (String[]) (RECOGNIZED_FEATURES.clone());
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
	 }
	 public String[] getRecognizedProperties() {
		 return (String[]) (RECOGNIZED_PROPERTIES.clone());
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
		 if (propertyId.equals(ROOT_TYPE_DEF)) {
			 if (value == null) {
				 fRootTypeQName = null;
				 fRootTypeDefinition = null;
			 }
			 else if (value instanceof javax.xml.namespace.QName) {
				 fRootTypeQName = (javax.xml.namespace.QName) value;
				 fRootTypeDefinition = null;
			 }
			 else {
				 fRootTypeDefinition = (XSTypeDefinition) value;
				 fRootTypeQName = null;
			 }
		 }
		 else if (propertyId.equals(ROOT_ELEMENT_DECL)) {
			 if (value == null) {
				 fRootElementDeclQName = null;
				 fRootElementDeclaration = null;
			 }
			 else if (value instanceof javax.xml.namespace.QName) {
				 fRootElementDeclQName = (javax.xml.namespace.QName) value;
				 fRootElementDeclaration = null;
			 }
			 else {
				 fRootElementDeclaration = (XSElementDecl) value;
				 fRootElementDeclQName = null;
			 }
		 }
	 }
	 public Boolean getFeatureDefault(String featureId) {
		 for (int i = 0;
		 i < RECOGNIZED_FEATURES.length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return FEATURE_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 for (int i = 0;
		 i < RECOGNIZED_PROPERTIES.length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return PROPERTY_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public void setDocumentHandler(XMLDocumentHandler documentHandler) {
		 fDocumentHandler = documentHandler;
	 }
	 public XMLDocumentHandler getDocumentHandler() {
		 return fDocumentHandler;
	 }
	 public void setDocumentSource(XMLDocumentSource source) {
		 fDocumentSource = source;
	 }
	 public XMLDocumentSource getDocumentSource() {
		 return fDocumentSource;
	 }
	 public void startDocument( XMLLocator locator, String encoding, NamespaceContext namespaceContext, Augmentations augs) throws XNIException {
		 fValidationState.setNamespaceSupport(namespaceContext);
		 fState4XsiType.setNamespaceSupport(namespaceContext);
		 fState4ApplyDefault.setNamespaceSupport(namespaceContext);
		 fLocator = locator;
		 handleStartDocument(locator, encoding);
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startDocument(locator, encoding, namespaceContext, augs);
		 }
	 }
	 public void xmlDecl(String version, String encoding, String standalone, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.xmlDecl(version, encoding, standalone, augs);
		 }
	 }
	 public void doctypeDecl( String rootElement, String publicId, String systemId, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.doctypeDecl(rootElement, publicId, systemId, augs);
		 }
	 }
	 public void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {
		 Augmentations modifiedAugs = handleStartElement(element, attributes, augs);
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startElement(element, attributes, modifiedAugs);
		 }
	 }
	 public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {
		 Augmentations modifiedAugs = handleStartElement(element, attributes, augs);
		 fDefaultValue = null;
		 if (fElementDepth != -2) modifiedAugs = handleEndElement(element, modifiedAugs);
		 if (fDocumentHandler != null) {
			 if (!fSchemaElementDefault || fDefaultValue == null) {
				 fDocumentHandler.emptyElement(element, attributes, modifiedAugs);
			 }
			 else {
				 fDocumentHandler.startElement(element, attributes, modifiedAugs);
				 fDocumentHandler.characters(fDefaultValue, null);
				 fDocumentHandler.endElement(element, modifiedAugs);
			 }
		 }
	 }
	 public void characters(XMLString text, Augmentations augs) throws XNIException {
		 text = handleCharacters(text);
		 if (fDocumentHandler != null) {
			 if (fNormalizeData && fUnionType) {
				 if (augs != null) fDocumentHandler.characters(fEmptyXMLStr, augs);
			 }
			 else {
				 fDocumentHandler.characters(text, augs);
			 }
		 }
	 }
	 public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException {
		 handleIgnorableWhitespace(text);
		 if (fDocumentHandler != null) {
			 fDocumentHandler.ignorableWhitespace(text, augs);
		 }
	 }
	 public void endElement(QName element, Augmentations augs) throws XNIException {
		 fDefaultValue = null;
		 Augmentations modifiedAugs = handleEndElement(element, augs);
		 if (fDocumentHandler != null) {
			 if (!fSchemaElementDefault || fDefaultValue == null) {
				 fDocumentHandler.endElement(element, modifiedAugs);
			 }
			 else {
				 fDocumentHandler.characters(fDefaultValue, null);
				 fDocumentHandler.endElement(element, modifiedAugs);
			 }
		 }
	 }
	 public void startCDATA(Augmentations augs) throws XNIException {
		 fInCDATA = true;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startCDATA(augs);
		 }
	 }
	 public void endCDATA(Augmentations augs) throws XNIException {
		 fInCDATA = false;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endCDATA(augs);
		 }
	 }
	 public void endDocument(Augmentations augs) throws XNIException {
		 handleEndDocument();
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endDocument(augs);
		 }
		 fLocator = null;
	 }
	 public boolean characterData(String data, Augmentations augs) {
		 fSawText = fSawText || data.length() > 0;
		 if (fNormalizeData && fWhiteSpace != -1 && fWhiteSpace != XSSimpleType.WS_PRESERVE) {
			 normalizeWhitespace(data, fWhiteSpace == XSSimpleType.WS_COLLAPSE);
			 fBuffer.append(fNormalizedStr.ch, fNormalizedStr.offset, fNormalizedStr.length);
		 }
		 else {
			 if (fAppendBuffer) fBuffer.append(data);
		 }
		 boolean allWhiteSpace = true;
		 if (fCurrentType != null && fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
			 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
			 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT) {
				 for (int i = 0;
				 i < data.length();
				 i++) {
					 if (!XMLChar.isSpace(data.charAt(i))) {
						 allWhiteSpace = false;
						 fSawCharacters = true;
						 break;
					 }
				 }
			 }
		 }
		 return allWhiteSpace;
	 }
	 public void elementDefault(String data) {
	 }
	 public void startGeneralEntity( String name, XMLResourceIdentifier identifier, String encoding, Augmentations augs) throws XNIException {
		 fEntityRef = true;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startGeneralEntity(name, identifier, encoding, augs);
		 }
	 }
	 public void textDecl(String version, String encoding, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.textDecl(version, encoding, augs);
		 }
	 }
	 public void comment(XMLString text, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.comment(text, augs);
		 }
	 }
	 public void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.processingInstruction(target, data, augs);
		 }
	 }
	 public void endGeneralEntity(String name, Augmentations augs) throws XNIException {
		 fEntityRef = false;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endGeneralEntity(name, augs);
		 }
	 }
	 static final int INITIAL_STACK_SIZE = 8;
	 static final int INC_STACK_SIZE = 8;
	 private static final boolean DEBUG_NORMALIZATION = false;
	 private final XMLString fEmptyXMLStr = new XMLString(null, 0, -1);
	 private static final int BUFFER_SIZE = 20;
	 private final XMLString fNormalizedStr = new XMLString();
	 private boolean fFirstChunk = true;
	 private boolean fTrailing = false;
	 private short fWhiteSpace = -1;
	 private boolean fUnionType = false;
	 private final XSGrammarBucket fGrammarBucket = new XSGrammarBucket();
	 private final SubstitutionGroupHandler fSubGroupHandler = new SubstitutionGroupHandler(fGrammarBucket);
	 private final XSSimpleType fQNameDV = (XSSimpleType) SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(SchemaSymbols.ATTVAL_QNAME);
	 private final CMNodeFactory nodeFactory = new CMNodeFactory();
	 private final CMBuilder fCMBuilder = new CMBuilder(nodeFactory);
	 private final XMLSchemaLoader fSchemaLoader = new XMLSchemaLoader( fXSIErrorReporter.fErrorReporter, fGrammarBucket, fSubGroupHandler, fCMBuilder);
	 private String fValidationRoot;
	 private int fSkipValidationDepth;
	 private int fNFullValidationDepth;
	 private int fNNoneValidationDepth;
	 private int fElementDepth;
	 private boolean fSubElement;
	 private boolean[] fSubElementStack = new boolean[INITIAL_STACK_SIZE];
	 private XSElementDecl fCurrentElemDecl;
	 private XSElementDecl[] fElemDeclStack = new XSElementDecl[INITIAL_STACK_SIZE];
	 private boolean fNil;
	 private boolean[] fNilStack = new boolean[INITIAL_STACK_SIZE];
	 private XSNotationDecl fNotation;
	 private XSNotationDecl[] fNotationStack = new XSNotationDecl[INITIAL_STACK_SIZE];
	 private XSTypeDefinition fCurrentType;
	 private XSTypeDefinition[] fTypeStack = new XSTypeDefinition[INITIAL_STACK_SIZE];
	 private XSCMValidator fCurrentCM;
	 private XSCMValidator[] fCMStack = new XSCMValidator[INITIAL_STACK_SIZE];
	 private int[] fCurrCMState;
	 private int[][] fCMStateStack = new int[INITIAL_STACK_SIZE][];
	 private boolean fStrictAssess = true;
	 private boolean[] fStrictAssessStack = new boolean[INITIAL_STACK_SIZE];
	 private final StringBuffer fBuffer = new StringBuffer();
	 private boolean fAppendBuffer = true;
	 private boolean fSawText = false;
	 private boolean[] fSawTextStack = new boolean[INITIAL_STACK_SIZE];
	 private boolean fSawCharacters = false;
	 private boolean[] fStringContent = new boolean[INITIAL_STACK_SIZE];
	 private final QName fTempQName = new QName();
	 private javax.xml.namespace.QName fRootTypeQName = null;
	 private XSTypeDefinition fRootTypeDefinition = null;
	 private javax.xml.namespace.QName fRootElementDeclQName = null;
	 private XSElementDecl fRootElementDeclaration = null;
	 private int fIgnoreXSITypeDepth;
	 private boolean fIDCChecking;
	 private ValidatedInfo fValidatedInfo = new ValidatedInfo();
	 private ValidationState fState4XsiType = new ValidationState();
	 private ValidationState fState4ApplyDefault = new ValidationState();
	 protected XPathMatcherStack fMatcherStack = new XPathMatcherStack();
	 protected ValueStoreCache fValueStoreCache = new ValueStoreCache();
	 public XMLSchemaValidator() {
		 fState4XsiType.setExtraChecking(false);
		 fState4ApplyDefault.setFacetChecking(false);
	 }
	 public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
		 fIdConstraint = false;
		 fLocationPairs.clear();
		 fExpandedLocationPairs.clear();
		 fValidationState.resetIDTables();
		 fSchemaLoader.reset(componentManager);
		 fCurrentElemDecl = null;
		 fCurrentCM = null;
		 fCurrCMState = null;
		 fSkipValidationDepth = -1;
		 fNFullValidationDepth = -1;
		 fNNoneValidationDepth = -1;
		 fElementDepth = -1;
		 fSubElement = false;
		 fSchemaDynamicValidation = false;
		 fEntityRef = false;
		 fInCDATA = false;
		 fMatcherStack.clear();
		 fXSIErrorReporter.reset((XMLErrorReporter) componentManager.getProperty(ERROR_REPORTER));
		 boolean parser_settings;
		 try {
			 parser_settings = componentManager.getFeature(PARSER_SETTINGS);
		 }
		 catch (XMLConfigurationException e){
			 parser_settings = true;
		 }
		 if (!parser_settings) {
			 fValidationManager.addValidationState(fValidationState);
			 nodeFactory.reset();
			 XMLSchemaLoader.processExternalHints( fExternalSchemas, fExternalNoNamespaceSchema, fLocationPairs, fXSIErrorReporter.fErrorReporter);
			 return;
		 }
		 nodeFactory.reset(componentManager);
		 SymbolTable symbolTable = (SymbolTable) componentManager.getProperty(SYMBOL_TABLE);
		 if (symbolTable != fSymbolTable) {
			 fSymbolTable = symbolTable;
		 }
		 try {
			 fNamespaceGrowth = componentManager.getFeature(NAMESPACE_GROWTH);
		 }
		 catch (XMLConfigurationException e) {
			 fNamespaceGrowth = false;
		 }
		 try {
			 fDynamicValidation = componentManager.getFeature(DYNAMIC_VALIDATION);
		 }
		 catch (XMLConfigurationException e) {
			 fDynamicValidation = false;
		 }
		 if (fDynamicValidation) {
			 fDoValidation = true;
		 }
		 else {
			 try {
				 fDoValidation = componentManager.getFeature(VALIDATION);
			 }
			 catch (XMLConfigurationException e) {
				 fDoValidation = false;
			 }
		 }
		 if (fDoValidation) {
			 try {
				 fDoValidation = componentManager.getFeature(XMLSchemaValidator.SCHEMA_VALIDATION);
			 }
			 catch (XMLConfigurationException e) {
			 }
		 }
		 try {
			 fFullChecking = componentManager.getFeature(SCHEMA_FULL_CHECKING);
		 }
		 catch (XMLConfigurationException e) {
			 fFullChecking = false;
		 }
		 try {
			 fNormalizeData = componentManager.getFeature(NORMALIZE_DATA);
		 }
		 catch (XMLConfigurationException e) {
			 fNormalizeData = false;
		 }
		 try {
			 fSchemaElementDefault = componentManager.getFeature(SCHEMA_ELEMENT_DEFAULT);
		 }
		 catch (XMLConfigurationException e) {
			 fSchemaElementDefault = false;
		 }
		 try {
			 fAugPSVI = componentManager.getFeature(SCHEMA_AUGMENT_PSVI);
		 }
		 catch (XMLConfigurationException e) {
			 fAugPSVI = true;
		 }
		 try {
			 fSchemaType = (String) componentManager.getProperty( Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE);
		 }
		 catch (XMLConfigurationException e) {
			 fSchemaType = null;
		 }
		 try {
			 fUseGrammarPoolOnly = componentManager.getFeature(USE_GRAMMAR_POOL_ONLY);
		 }
		 catch (XMLConfigurationException e) {
			 fUseGrammarPoolOnly = false;
		 }
		 fEntityResolver = (XMLEntityResolver) componentManager.getProperty(ENTITY_MANAGER);
		 fValidationManager = (ValidationManager) componentManager.getProperty(VALIDATION_MANAGER);
		 fValidationManager.addValidationState(fValidationState);
		 fValidationState.setSymbolTable(fSymbolTable);
		 try {
			 final Object rootType = componentManager.getProperty(ROOT_TYPE_DEF);
			 if (rootType == null) {
				 fRootTypeQName = null;
				 fRootTypeDefinition = null;
			 }
			 else if (rootType instanceof javax.xml.namespace.QName) {
				 fRootTypeQName = (javax.xml.namespace.QName) rootType;
				 fRootTypeDefinition = null;
			 }
			 else {
				 fRootTypeDefinition = (XSTypeDefinition) rootType;
				 fRootTypeQName = null;
			 }
		 }
		 catch (XMLConfigurationException e) {
			 fRootTypeQName = null;
			 fRootTypeDefinition = null;
		 }
		 try {
			 final Object rootDecl = componentManager.getProperty(ROOT_ELEMENT_DECL);
			 if (rootDecl == null) {
				 fRootElementDeclQName = null;
				 fRootElementDeclaration = null;
			 }
			 else if (rootDecl instanceof javax.xml.namespace.QName) {
				 fRootElementDeclQName = (javax.xml.namespace.QName) rootDecl;
				 fRootElementDeclaration = null;
			 }
			 else {
				 fRootElementDeclaration = (XSElementDecl) rootDecl;
				 fRootElementDeclQName = null;
			 }
		 }
		 catch (XMLConfigurationException e) {
			 fRootElementDeclQName = null;
			 fRootElementDeclaration = null;
		 }
		 boolean ignoreXSIType;
		 try {
			 ignoreXSIType = componentManager.getFeature(IGNORE_XSI_TYPE);
		 }
		 catch (XMLConfigurationException e) {
			 ignoreXSIType = false;
		 }
		 fIgnoreXSITypeDepth = ignoreXSIType ? 0 : -1;
		 try {
			 fIDCChecking = componentManager.getFeature(IDENTITY_CONSTRAINT_CHECKING);
		 }
		 catch (XMLConfigurationException e) {
			 fIDCChecking = true;
		 }
		 try {
			 fValidationState.setIdIdrefChecking(componentManager.getFeature(ID_IDREF_CHECKING));
		 }
		 catch (XMLConfigurationException e) {
			 fValidationState.setIdIdrefChecking(true);
		 }
		 try {
			 fValidationState.setUnparsedEntityChecking(componentManager.getFeature(UNPARSED_ENTITY_CHECKING));
		 }
		 catch (XMLConfigurationException e) {
			 fValidationState.setUnparsedEntityChecking(true);
		 }
		 try {
			 fExternalSchemas = (String) componentManager.getProperty(SCHEMA_LOCATION);
			 fExternalNoNamespaceSchema = (String) componentManager.getProperty(SCHEMA_NONS_LOCATION);
		 }
		 catch (XMLConfigurationException e) {
			 fExternalSchemas = null;
			 fExternalNoNamespaceSchema = null;
		 }
		 XMLSchemaLoader.processExternalHints( fExternalSchemas, fExternalNoNamespaceSchema, fLocationPairs, fXSIErrorReporter.fErrorReporter);
		 try {
			 fJaxpSchemaSource = componentManager.getProperty(JAXP_SCHEMA_SOURCE);
		 }
		 catch (XMLConfigurationException e) {
			 fJaxpSchemaSource = null;
		 }
		 try {
			 fGrammarPool = (XMLGrammarPool) componentManager.getProperty(XMLGRAMMAR_POOL);
		 }
		 catch (XMLConfigurationException e) {
			 fGrammarPool = null;
		 }
		 fState4XsiType.setSymbolTable(symbolTable);
		 fState4ApplyDefault.setSymbolTable(symbolTable);
	 }
	 public void startValueScopeFor(IdentityConstraint identityConstraint, int initialDepth) {
		 ValueStoreBase valueStore = fValueStoreCache.getValueStoreFor(identityConstraint, initialDepth);
		 valueStore.startValueScope();
	 }
	 public XPathMatcher activateField(Field field, int initialDepth) {
		 ValueStore valueStore = fValueStoreCache.getValueStoreFor(field.getIdentityConstraint(), initialDepth);
		 XPathMatcher matcher = field.createMatcher(valueStore);
		 fMatcherStack.addMatcher(matcher);
		 matcher.startDocumentFragment();
		 return matcher;
	 }
	 public void endValueScopeFor(IdentityConstraint identityConstraint, int initialDepth) {
		 ValueStoreBase valueStore = fValueStoreCache.getValueStoreFor(identityConstraint, initialDepth);
		 valueStore.endValueScope();
	 }
	 private void activateSelectorFor(IdentityConstraint ic) {
		 Selector selector = ic.getSelector();
		 FieldActivator activator = this;
		 if (selector == null) return;
		 XPathMatcher matcher = selector.createMatcher(activator, fElementDepth);
		 fMatcherStack.addMatcher(matcher);
		 matcher.startDocumentFragment();
	 }
	 void ensureStackCapacity() {
		 if (fElementDepth == fElemDeclStack.length) {
			 int newSize = fElementDepth + INC_STACK_SIZE;
			 boolean[] newArrayB = new boolean[newSize];
			 System.arraycopy(fSubElementStack, 0, newArrayB, 0, fElementDepth);
			 fSubElementStack = newArrayB;
			 XSElementDecl[] newArrayE = new XSElementDecl[newSize];
			 System.arraycopy(fElemDeclStack, 0, newArrayE, 0, fElementDepth);
			 fElemDeclStack = newArrayE;
			 newArrayB = new boolean[newSize];
			 System.arraycopy(fNilStack, 0, newArrayB, 0, fElementDepth);
			 fNilStack = newArrayB;
			 XSNotationDecl[] newArrayN = new XSNotationDecl[newSize];
			 System.arraycopy(fNotationStack, 0, newArrayN, 0, fElementDepth);
			 fNotationStack = newArrayN;
			 XSTypeDefinition[] newArrayT = new XSTypeDefinition[newSize];
			 System.arraycopy(fTypeStack, 0, newArrayT, 0, fElementDepth);
			 fTypeStack = newArrayT;
			 XSCMValidator[] newArrayC = new XSCMValidator[newSize];
			 System.arraycopy(fCMStack, 0, newArrayC, 0, fElementDepth);
			 fCMStack = newArrayC;
			 newArrayB = new boolean[newSize];
			 System.arraycopy(fSawTextStack, 0, newArrayB, 0, fElementDepth);
			 fSawTextStack = newArrayB;
			 newArrayB = new boolean[newSize];
			 System.arraycopy(fStringContent, 0, newArrayB, 0, fElementDepth);
			 fStringContent = newArrayB;
			 newArrayB = new boolean[newSize];
			 System.arraycopy(fStrictAssessStack, 0, newArrayB, 0, fElementDepth);
			 fStrictAssessStack = newArrayB;
			 int[][] newArrayIA = new int[newSize][];
			 System.arraycopy(fCMStateStack, 0, newArrayIA, 0, fElementDepth);
			 fCMStateStack = newArrayIA;
		 }
	 }
	 void handleStartDocument(XMLLocator locator, String encoding) {
		 if (fIDCChecking) {
			 fValueStoreCache.startDocument();
		 }
		 if (fAugPSVI) {
			 fCurrentPSVI.fGrammars = null;
			 fCurrentPSVI.fSchemaInformation = null;
		 }
	 }
	 void handleEndDocument() {
		 if (fIDCChecking) {
			 fValueStoreCache.endDocument();
		 }
	 }
	 XMLString handleCharacters(XMLString text) {
		 if (fSkipValidationDepth >= 0) return text;
		 fSawText = fSawText || text.length > 0;
		 if (fNormalizeData && fWhiteSpace != -1 && fWhiteSpace != XSSimpleType.WS_PRESERVE) {
			 normalizeWhitespace(text, fWhiteSpace == XSSimpleType.WS_COLLAPSE);
			 text = fNormalizedStr;
		 }
		 if (fAppendBuffer) fBuffer.append(text.ch, text.offset, text.length);
		 if (fCurrentType != null && fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
			 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
			 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT) {
				 for (int i = text.offset;
				 i < text.offset + text.length;
				 i++) {
					 if (!XMLChar.isSpace(text.ch[i])) {
						 fSawCharacters = true;
						 break;
					 }
				 }
			 }
		 }
		 return text;
	 }
	 private void normalizeWhitespace(XMLString value, boolean collapse) {
		 boolean skipSpace = collapse;
		 boolean sawNonWS = false;
		 boolean leading = false;
		 boolean trailing = false;
		 char c;
		 int size = value.offset + value.length;
		 if (fNormalizedStr.ch == null || fNormalizedStr.ch.length < value.length + 1) {
			 fNormalizedStr.ch = new char[value.length + 1];
		 }
		 fNormalizedStr.offset = 1;
		 fNormalizedStr.length = 1;
		 for (int i = value.offset;
		 i < size;
		 i++) {
			 c = value.ch[i];
			 if (XMLChar.isSpace(c)) {
				 if (!skipSpace) {
					 fNormalizedStr.ch[fNormalizedStr.length++] = ' ';
					 skipSpace = collapse;
				 }
				 if (!sawNonWS) {
					 leading = true;
				 }
			 }
			 else {
				 fNormalizedStr.ch[fNormalizedStr.length++] = c;
				 skipSpace = false;
				 sawNonWS = true;
			 }
		 }
		 if (skipSpace) {
			 if (fNormalizedStr.length > 1) {
				 fNormalizedStr.length--;
				 trailing = true;
			 }
			 else if (leading && !fFirstChunk) {
				 trailing = true;
			 }
		 }
		 if (fNormalizedStr.length > 1) {
			 if (!fFirstChunk && (fWhiteSpace == XSSimpleType.WS_COLLAPSE)) {
				 if (fTrailing) {
					 fNormalizedStr.offset = 0;
					 fNormalizedStr.ch[0] = ' ';
				 }
				 else if (leading) {
					 fNormalizedStr.offset = 0;
					 fNormalizedStr.ch[0] = ' ';
				 }
			 }
		 }
		 fNormalizedStr.length -= fNormalizedStr.offset;
		 fTrailing = trailing;
		 if (trailing || sawNonWS) fFirstChunk = false;
	 }
	 private void normalizeWhitespace(String value, boolean collapse) {
		 boolean skipSpace = collapse;
		 char c;
		 int size = value.length();
		 if (fNormalizedStr.ch == null || fNormalizedStr.ch.length < size) {
			 fNormalizedStr.ch = new char[size];
		 }
		 fNormalizedStr.offset = 0;
		 fNormalizedStr.length = 0;
		 for (int i = 0;
		 i < size;
		 i++) {
			 c = value.charAt(i);
			 if (XMLChar.isSpace(c)) {
				 if (!skipSpace) {
					 fNormalizedStr.ch[fNormalizedStr.length++] = ' ';
					 skipSpace = collapse;
				 }
			 }
			 else {
				 fNormalizedStr.ch[fNormalizedStr.length++] = c;
				 skipSpace = false;
			 }
		 }
		 if (skipSpace) {
			 if (fNormalizedStr.length != 0) fNormalizedStr.length--;
		 }
	 }
	 void handleIgnorableWhitespace(XMLString text) {
		 if (fSkipValidationDepth >= 0) return;
	 }
	 Augmentations handleStartElement(QName element, XMLAttributes attributes, Augmentations augs) {
		 if (DEBUG) {
			 System.out.println(""==>handleStartElement: "" + element);
		 }
		 if (fElementDepth == -1 && fValidationManager.isGrammarFound()) {
			 if (fSchemaType == null) {
				 fSchemaDynamicValidation = true;
			 }
			 else {
			 }
		 }
		 String sLocation = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_SCHEMALOCATION);
		 String nsLocation = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);
		 storeLocations(sLocation, nsLocation);
		 if (fSkipValidationDepth >= 0) {
			 fElementDepth++;
			 if (fAugPSVI) augs = getEmptyAugs(augs);
			 return augs;
		 }
		 Object decl = null;
		 if (fCurrentCM != null) {
			 decl = fCurrentCM.oneTransition(element, fCurrCMState, fSubGroupHandler);
			 if (fCurrCMState[0] == XSCMValidator.FIRST_ERROR) {
				 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
				 Vector next;
				 if (ctype.fParticle != null && (next = fCurrentCM.whatCanGoHere(fCurrCMState)).size() > 0) {
					 String expected = expectedStr(next);
					 final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);
					 if (occurenceInfo != null) {
						 final int minOccurs = occurenceInfo[0];
						 final int maxOccurs = occurenceInfo[1];
						 final int count = occurenceInfo[2];
						 if (count < minOccurs) {
							 final int required = minOccurs - count;
							 if (required > 1) {
								 reportSchemaError(""cvc-complex-type.2.4.h"", new Object[] {
								 element.rawname, fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) }
								);
							 }
							 else {
								 reportSchemaError(""cvc-complex-type.2.4.g"", new Object[] {
								 element.rawname, fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) }
								);
							 }
						 }
						 else if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
							 reportSchemaError(""cvc-complex-type.2.4.e"", new Object[] {
							 element.rawname, expected, Integer.toString(maxOccurs) }
							);
						 }
						 else {
							 reportSchemaError(""cvc-complex-type.2.4.a"", new Object[] {
							 element.rawname, expected }
							);
						 }
					 }
					 else {
						 reportSchemaError(""cvc-complex-type.2.4.a"", new Object[] {
						 element.rawname, expected }
						);
					 }
				 }
				 else {
					 final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);
					 if (occurenceInfo != null) {
						 final int maxOccurs = occurenceInfo[1];
						 final int count = occurenceInfo[2];
						 if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
							 reportSchemaError(""cvc-complex-type.2.4.f"", new Object[] {
							 element.rawname, Integer.toString(maxOccurs) }
							);
						 }
						 else {
							 reportSchemaError(""cvc-complex-type.2.4.d"", new Object[] {
							 element.rawname }
							);
						 }
					 }
					 else {
						 reportSchemaError(""cvc-complex-type.2.4.d"", new Object[] {
						 element.rawname }
						);
					 }
				 }
			 }
		 }
		 if (fElementDepth != -1) {
			 ensureStackCapacity();
			 fSubElementStack[fElementDepth] = true;
			 fSubElement = false;
			 fElemDeclStack[fElementDepth] = fCurrentElemDecl;
			 fNilStack[fElementDepth] = fNil;
			 fNotationStack[fElementDepth] = fNotation;
			 fTypeStack[fElementDepth] = fCurrentType;
			 fStrictAssessStack[fElementDepth] = fStrictAssess;
			 fCMStack[fElementDepth] = fCurrentCM;
			 fCMStateStack[fElementDepth] = fCurrCMState;
			 fSawTextStack[fElementDepth] = fSawText;
			 fStringContent[fElementDepth] = fSawCharacters;
		 }
		 fElementDepth++;
		 fCurrentElemDecl = null;
		 XSWildcardDecl wildcard = null;
		 fCurrentType = null;
		 fStrictAssess = true;
		 fNil = false;
		 fNotation = null;
		 fBuffer.setLength(0);
		 fSawText = false;
		 fSawCharacters = false;
		 if (decl != null) {
			 if (decl instanceof XSElementDecl) {
				 fCurrentElemDecl = (XSElementDecl) decl;
			 }
			 else {
				 wildcard = (XSWildcardDecl) decl;
			 }
		 }
		 if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_SKIP) {
			 fSkipValidationDepth = fElementDepth;
			 if (fAugPSVI) augs = getEmptyAugs(augs);
			 return augs;
		 }
		 if (fElementDepth == 0) {
			 if (fRootElementDeclaration != null) {
				 fCurrentElemDecl = fRootElementDeclaration;
				 checkElementMatchesRootElementDecl(fCurrentElemDecl, element);
			 }
			 else if (fRootElementDeclQName != null) {
				 processRootElementDeclQName(fRootElementDeclQName, element);
			 }
			 else if (fRootTypeDefinition != null) {
				 fCurrentType = fRootTypeDefinition;
			 }
			 else if (fRootTypeQName != null) {
				 processRootTypeQName(fRootTypeQName);
			 }
		 }
		 if (fCurrentType == null) {
			 if (fCurrentElemDecl == null) {
				 SchemaGrammar sGrammar = findSchemaGrammar( XSDDescription.CONTEXT_ELEMENT, element.uri, null, element, attributes);
				 if (sGrammar != null) {
					 fCurrentElemDecl = sGrammar.getGlobalElementDecl(element.localpart);
				 }
			 }
			 if (fCurrentElemDecl != null) {
				 fCurrentType = fCurrentElemDecl.fType;
			 }
		 }
		 if (fElementDepth == fIgnoreXSITypeDepth && fCurrentElemDecl == null) {
			 fIgnoreXSITypeDepth++;
		 }
		 String xsiType = null;
		 if (fElementDepth >= fIgnoreXSITypeDepth) {
			 xsiType = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_TYPE);
		 }
		 if (fCurrentType == null && xsiType == null) {
			 if (fElementDepth == 0) {
				 if (fDynamicValidation || fSchemaDynamicValidation) {
					 if (fDocumentSource != null) {
						 fDocumentSource.setDocumentHandler(fDocumentHandler);
						 if (fDocumentHandler != null) fDocumentHandler.setDocumentSource(fDocumentSource);
						 fElementDepth = -2;
						 return augs;
					 }
					 fSkipValidationDepth = fElementDepth;
					 if (fAugPSVI) augs = getEmptyAugs(augs);
					 return augs;
				 }
				 fXSIErrorReporter.fErrorReporter.reportError( XSMessageFormatter.SCHEMA_DOMAIN, ""cvc-elt.1.a"", new Object[] {
				 element.rawname }
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
			 else if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {
				 reportSchemaError(""cvc-complex-type.2.4.c"", new Object[] {
				 element.rawname }
				);
			 }
			 fCurrentType = SchemaGrammar.fAnyType;
			 fStrictAssess = false;
			 fNFullValidationDepth = fElementDepth;
			 fAppendBuffer = false;
			 fXSIErrorReporter.pushContext();
		 }
		 else {
			 fXSIErrorReporter.pushContext();
			 if (xsiType != null) {
				 XSTypeDefinition oldType = fCurrentType;
				 fCurrentType = getAndCheckXsiType(element, xsiType, attributes);
				 if (fCurrentType == null) {
					 if (oldType == null) fCurrentType = SchemaGrammar.fAnyType;
					 else fCurrentType = oldType;
				 }
			 }
			 fNNoneValidationDepth = fElementDepth;
			 if (fCurrentElemDecl != null && fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {
				 fAppendBuffer = true;
			 }
			 else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {
				 fAppendBuffer = true;
			 }
			 else {
				 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
				 fAppendBuffer = (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE);
			 }
		 }
		 if (fCurrentElemDecl != null && fCurrentElemDecl.getAbstract()) reportSchemaError(""cvc-elt.2"", new Object[] {
		 element.rawname }
		);
		 if (fElementDepth == 0) {
			 fValidationRoot = element.rawname;
		 }
		 if (fNormalizeData) {
			 fFirstChunk = true;
			 fTrailing = false;
			 fUnionType = false;
			 fWhiteSpace = -1;
		 }
		 if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
			 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
			 if (ctype.getAbstract()) {
				 reportSchemaError(""cvc-type.2"", new Object[] {
				 element.rawname }
				);
			 }
			 if (fNormalizeData) {
				 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {
					 if (ctype.fXSSimpleType.getVariety() == XSSimpleType.VARIETY_UNION) {
						 fUnionType = true;
					 }
					 else {
						 try {
							 fWhiteSpace = ctype.fXSSimpleType.getWhitespace();
						 }
						 catch (DatatypeException e) {
						 }
					 }
				 }
			 }
		 }
		 else if (fNormalizeData) {
			 XSSimpleType dv = (XSSimpleType) fCurrentType;
			 if (dv.getVariety() == XSSimpleType.VARIETY_UNION) {
				 fUnionType = true;
			 }
			 else {
				 try {
					 fWhiteSpace = dv.getWhitespace();
				 }
				 catch (DatatypeException e) {
				 }
			 }
		 }
		 fCurrentCM = null;
		 if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
			 fCurrentCM = ((XSComplexTypeDecl) fCurrentType).getContentModel(fCMBuilder);
		 }
		 fCurrCMState = null;
		 if (fCurrentCM != null) fCurrCMState = fCurrentCM.startContentModel();
		 String xsiNil = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NIL);
		 if (xsiNil != null && fCurrentElemDecl != null) fNil = getXsiNil(element, xsiNil);
		 XSAttributeGroupDecl attrGrp = null;
		 if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
			 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
			 attrGrp = ctype.getAttrGrp();
		 }
		 if (fIDCChecking) {
			 fValueStoreCache.startElement();
			 fMatcherStack.pushContext();
			 if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0) {
				 fIdConstraint = true;
				 fValueStoreCache.initValueStoresFor(fCurrentElemDecl, this);
			 }
		 }
		 processAttributes(element, attributes, attrGrp);
		 if (attrGrp != null) {
			 addDefaultAttributes(element, attributes, attrGrp);
		 }
		 int count = fMatcherStack.getMatcherCount();
		 for (int i = 0;
		 i < count;
		 i++) {
			 XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
			 matcher.startElement( element, attributes);
		 }
		 if (fAugPSVI) {
			 augs = getEmptyAugs(augs);
			 fCurrentPSVI.fValidationContext = fValidationRoot;
			 fCurrentPSVI.fDeclaration = fCurrentElemDecl;
			 fCurrentPSVI.fTypeDecl = fCurrentType;
			 fCurrentPSVI.fNotation = fNotation;
			 fCurrentPSVI.fNil = fNil;
		 }
		 return augs;
	 }
	 Augmentations handleEndElement(QName element, Augmentations augs) {
		 if (DEBUG) {
			 System.out.println(""==>handleEndElement:"" + element);
		 }
		 if (fSkipValidationDepth >= 0) {
			 if (fSkipValidationDepth == fElementDepth && fSkipValidationDepth > 0) {
				 fNFullValidationDepth = fSkipValidationDepth - 1;
				 fSkipValidationDepth = -1;
				 fElementDepth--;
				 fSubElement = fSubElementStack[fElementDepth];
				 fCurrentElemDecl = fElemDeclStack[fElementDepth];
				 fNil = fNilStack[fElementDepth];
				 fNotation = fNotationStack[fElementDepth];
				 fCurrentType = fTypeStack[fElementDepth];
				 fCurrentCM = fCMStack[fElementDepth];
				 fStrictAssess = fStrictAssessStack[fElementDepth];
				 fCurrCMState = fCMStateStack[fElementDepth];
				 fSawText = fSawTextStack[fElementDepth];
				 fSawCharacters = fStringContent[fElementDepth];
			 }
			 else {
				 fElementDepth--;
			 }
			 if (fElementDepth == -1 && fFullChecking && !fUseGrammarPoolOnly) {
				 XSConstraints.fullSchemaChecking( fGrammarBucket, fSubGroupHandler, fCMBuilder, fXSIErrorReporter.fErrorReporter);
			 }
			 if (fAugPSVI) augs = getEmptyAugs(augs);
			 return augs;
		 }
		 processElementContent(element);
		 if (fIDCChecking) {
			 int oldCount = fMatcherStack.getMatcherCount();
			 for (int i = oldCount - 1;
			 i >= 0;
			 i--) {
				 XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
				 if (fCurrentElemDecl == null) {
					 matcher.endElement(element, fCurrentType, false, fValidatedInfo.actualValue, fValidatedInfo.actualValueType, fValidatedInfo.itemValueTypes);
				 }
				 else {
					 matcher.endElement( element, fCurrentType, fCurrentElemDecl.getNillable(), fDefaultValue == null ? fValidatedInfo.actualValue : fCurrentElemDecl.fDefault.actualValue, fDefaultValue == null ? fValidatedInfo.actualValueType : fCurrentElemDecl.fDefault.actualValueType, fDefaultValue == null ? fValidatedInfo.itemValueTypes : fCurrentElemDecl.fDefault.itemValueTypes);
				 }
			 }
			 if (fMatcherStack.size() > 0) {
				 fMatcherStack.popContext();
			 }
			 int newCount = fMatcherStack.getMatcherCount();
			 for (int i = oldCount - 1;
			 i >= newCount;
			 i--) {
				 XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
				 if (matcher instanceof Selector.Matcher) {
					 Selector.Matcher selMatcher = (Selector.Matcher) matcher;
					 IdentityConstraint id;
					 if ((id = selMatcher.getIdentityConstraint()) != null && id.getCategory() != IdentityConstraint.IC_KEYREF) {
						 fValueStoreCache.transplant(id, selMatcher.getInitialDepth());
					 }
				 }
			 }
			 for (int i = oldCount - 1;
			 i >= newCount;
			 i--) {
				 XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
				 if (matcher instanceof Selector.Matcher) {
					 Selector.Matcher selMatcher = (Selector.Matcher) matcher;
					 IdentityConstraint id;
					 if ((id = selMatcher.getIdentityConstraint()) != null && id.getCategory() == IdentityConstraint.IC_KEYREF) {
						 ValueStoreBase values = fValueStoreCache.getValueStoreFor(id, selMatcher.getInitialDepth());
						 if (values != null) values.endDocumentFragment();
					 }
				 }
			 }
			 fValueStoreCache.endElement();
		 }
		 if (fElementDepth < fIgnoreXSITypeDepth) {
			 fIgnoreXSITypeDepth--;
		 }
		 SchemaGrammar[] grammars = null;
		 if (fElementDepth == 0) {
			 String invIdRef = fValidationState.checkIDRefID();
			 fValidationState.resetIDTables();
			 if (invIdRef != null) {
				 reportSchemaError(""cvc-id.1"", new Object[] {
				 invIdRef }
				);
			 }
			 if (fFullChecking && !fUseGrammarPoolOnly) {
				 XSConstraints.fullSchemaChecking( fGrammarBucket, fSubGroupHandler, fCMBuilder, fXSIErrorReporter.fErrorReporter);
			 }
			 grammars = fGrammarBucket.getGrammars();
			 if (fGrammarPool != null) {
				 for (int k=0;
				 k < grammars.length;
				 k++) {
					 grammars[k].setImmutable(true);
				 }
				 fGrammarPool.cacheGrammars(XMLGrammarDescription.XML_SCHEMA, grammars);
			 }
			 augs = endElementPSVI(true, grammars, augs);
		 }
		 else {
			 augs = endElementPSVI(false, grammars, augs);
			 fElementDepth--;
			 fSubElement = fSubElementStack[fElementDepth];
			 fCurrentElemDecl = fElemDeclStack[fElementDepth];
			 fNil = fNilStack[fElementDepth];
			 fNotation = fNotationStack[fElementDepth];
			 fCurrentType = fTypeStack[fElementDepth];
			 fCurrentCM = fCMStack[fElementDepth];
			 fStrictAssess = fStrictAssessStack[fElementDepth];
			 fCurrCMState = fCMStateStack[fElementDepth];
			 fSawText = fSawTextStack[fElementDepth];
			 fSawCharacters = fStringContent[fElementDepth];
			 fWhiteSpace = -1;
			 fAppendBuffer = false;
			 fUnionType = false;
		 }
		 return augs;
	 }
	 final Augmentations endElementPSVI( boolean root, SchemaGrammar[] grammars, Augmentations augs) {
		 if (fAugPSVI) {
			 augs = getEmptyAugs(augs);
			 fCurrentPSVI.fDeclaration = this.fCurrentElemDecl;
			 fCurrentPSVI.fTypeDecl = this.fCurrentType;
			 fCurrentPSVI.fNotation = this.fNotation;
			 fCurrentPSVI.fValidationContext = this.fValidationRoot;
			 fCurrentPSVI.fNil = this.fNil;
			 if (fElementDepth > fNFullValidationDepth) {
				 fCurrentPSVI.fValidationAttempted = ElementPSVI.VALIDATION_FULL;
			 }
			 else if (fElementDepth > fNNoneValidationDepth) {
				 fCurrentPSVI.fValidationAttempted = ElementPSVI.VALIDATION_NONE;
			 }
			 else {
				 fCurrentPSVI.fValidationAttempted = ElementPSVI.VALIDATION_PARTIAL;
			 }
			 if (fNFullValidationDepth == fElementDepth) {
				 fNFullValidationDepth = fElementDepth - 1;
			 }
			 if (fNNoneValidationDepth == fElementDepth) {
				 fNNoneValidationDepth = fElementDepth - 1;
			 }
			 if (fDefaultValue != null) fCurrentPSVI.fSpecified = true;
			 fCurrentPSVI.fMemberType = fValidatedInfo.memberType;
			 fCurrentPSVI.fNormalizedValue = fValidatedInfo.normalizedValue;
			 fCurrentPSVI.fActualValue = fValidatedInfo.actualValue;
			 fCurrentPSVI.fActualValueType = fValidatedInfo.actualValueType;
			 fCurrentPSVI.fItemValueTypes = fValidatedInfo.itemValueTypes;
			 if (fStrictAssess) {
				 String[] errors = fXSIErrorReporter.mergeContext();
				 fCurrentPSVI.fErrors = errors;
				 fCurrentPSVI.fValidity = (errors == null) ? ElementPSVI.VALIDITY_VALID : ElementPSVI.VALIDITY_INVALID;
			 }
			 else {
				 fCurrentPSVI.fValidity = ElementPSVI.VALIDITY_NOTKNOWN;
				 fXSIErrorReporter.popContext();
			 }
			 if (root) {
				 fCurrentPSVI.fGrammars = grammars;
				 fCurrentPSVI.fSchemaInformation = null;
			 }
		 }
		 return augs;
	 }
	 Augmentations getEmptyAugs(Augmentations augs) {
		 if (augs == null) {
			 augs = fAugmentations;
			 augs.removeAllItems();
		 }
		 augs.putItem(Constants.ELEMENT_PSVI, fCurrentPSVI);
		 fCurrentPSVI.reset();
		 return augs;
	 }
	 void storeLocations(String sLocation, String nsLocation) {
		 if (sLocation != null) {
			 if (!XMLSchemaLoader.tokenizeSchemaLocationStr(sLocation, fLocationPairs)) {
				 fXSIErrorReporter.reportError( XSMessageFormatter.SCHEMA_DOMAIN, ""SchemaLocation"", new Object[] {
				 sLocation }
				, XMLErrorReporter.SEVERITY_WARNING);
			 }
		 }
		 if (nsLocation != null) {
			 XMLSchemaLoader.LocationArray la = ((XMLSchemaLoader.LocationArray) fLocationPairs.get(XMLSymbols.EMPTY_STRING));
			 if (la == null) {
				 la = new XMLSchemaLoader.LocationArray();
				 fLocationPairs.put(XMLSymbols.EMPTY_STRING, la);
			 }
			 la.addLocation(nsLocation);
		 }
	 }
	 SchemaGrammar findSchemaGrammar( short contextType, String namespace, QName enclosingElement, QName triggeringComponent, XMLAttributes attributes) {
		 SchemaGrammar grammar = null;
		 grammar = fGrammarBucket.getGrammar(namespace);
		 if (grammar == null) {
			 fXSDDescription.setNamespace(namespace);
			 if (fGrammarPool != null) {
				 grammar = (SchemaGrammar) fGrammarPool.retrieveGrammar(fXSDDescription);
				 if (grammar != null) {
					 if (!fGrammarBucket.putGrammar(grammar, true, fNamespaceGrowth)) {
						 fXSIErrorReporter.fErrorReporter.reportError( XSMessageFormatter.SCHEMA_DOMAIN, ""GrammarConflict"", null, XMLErrorReporter.SEVERITY_WARNING);
						 grammar = null;
					 }
				 }
			 }
		 }
		 if (!fUseGrammarPoolOnly && (grammar == null || (fNamespaceGrowth && !hasSchemaComponent(grammar, contextType, triggeringComponent)))) {
			 fXSDDescription.reset();
			 fXSDDescription.fContextType = contextType;
			 fXSDDescription.setNamespace(namespace);
			 fXSDDescription.fEnclosedElementName = enclosingElement;
			 fXSDDescription.fTriggeringComponent = triggeringComponent;
			 fXSDDescription.fAttributes = attributes;
			 if (fLocator != null) {
				 fXSDDescription.setBaseSystemId(fLocator.getExpandedSystemId());
			 }
			 Hashtable locationPairs = fLocationPairs;
			 Object locationArray = locationPairs.get(namespace == null ? XMLSymbols.EMPTY_STRING : namespace);
			 if (locationArray != null) {
				 String[] temp = ((XMLSchemaLoader.LocationArray) locationArray).getLocationArray();
				 if (temp.length != 0) {
					 setLocationHints(fXSDDescription, temp, grammar);
				 }
			 }
			 if (grammar == null || fXSDDescription.fLocationHints != null) {
				 boolean toParseSchema = true;
				 if (grammar != null) {
					 locationPairs = EMPTY_TABLE;
				 }
				 try {
					 XMLInputSource xis = XMLSchemaLoader.resolveDocument( fXSDDescription, locationPairs, fEntityResolver);
					 if (grammar != null && fNamespaceGrowth) {
						 try {
							 if (grammar.getDocumentLocations().contains(XMLEntityManager.expandSystemId(xis.getSystemId(), xis.getBaseSystemId(), false))) {
								 toParseSchema = false;
							 }
						 }
						 catch (MalformedURIException e) {
						 }
					 }
					 if (toParseSchema) {
						 grammar = fSchemaLoader.loadSchema(fXSDDescription, xis, fLocationPairs);
					 }
				 }
				 catch (IOException ex) {
					 final String [] locationHints = fXSDDescription.getLocationHints();
					 fXSIErrorReporter.fErrorReporter.reportError( XSMessageFormatter.SCHEMA_DOMAIN, ""schema_reference.4"", new Object[] {
					 locationHints != null ? locationHints[0] : XMLSymbols.EMPTY_STRING }
					, XMLErrorReporter.SEVERITY_WARNING, ex);
				 }
			 }
		 }
		 return grammar;
	 }
	 private boolean hasSchemaComponent(SchemaGrammar grammar, short contextType, QName triggeringComponent) {
		 if (grammar != null && triggeringComponent != null) {
			 String localName = triggeringComponent.localpart;
			 if (localName != null && localName.length() > 0) {
				 switch (contextType) {
					 case XSDDescription.CONTEXT_ELEMENT: return grammar.getElementDeclaration(localName) != null;
					 case XSDDescription.CONTEXT_ATTRIBUTE: return grammar.getAttributeDeclaration(localName) != null;
					 case XSDDescription.CONTEXT_XSITYPE: return grammar.getTypeDefinition(localName) != null;
				 }
			 }
		 }
		 return false;
	 }
	 private void setLocationHints(XSDDescription desc, String[] locations, SchemaGrammar grammar) {
		 int length = locations.length;
		 if (grammar == null) {
			 fXSDDescription.fLocationHints = new String[length];
			 System.arraycopy(locations, 0, fXSDDescription.fLocationHints, 0, length);
		 }
		 else {
			 setLocationHints(desc, locations, grammar.getDocumentLocations());
		 }
	 }
	 private void setLocationHints(XSDDescription desc, String[] locations, StringList docLocations) {
		 int length = locations.length;
		 String[] hints = new String[length];
		 int counter = 0;
		 for (int i=0;
		 i<length;
		 i++) {
			 try {
				 String id = XMLEntityManager.expandSystemId(locations[i], desc.getBaseSystemId(), false);
				 if (!docLocations.contains(id)) {
					 hints[counter++] = locations[i];
				 }
			 }
			 catch (MalformedURIException e) {
			 }
		 }
		 if (counter > 0) {
			 if (counter == length) {
				 fXSDDescription.fLocationHints = hints;
			 }
			 else {
				 fXSDDescription.fLocationHints = new String[counter];
				 System.arraycopy(hints, 0, fXSDDescription.fLocationHints, 0, counter);
			 }
		 }
	 }
	 XSTypeDefinition getAndCheckXsiType(QName element, String xsiType, XMLAttributes attributes) {
		 QName typeName = null;
		 try {
			 typeName = (QName) fQNameDV.validate(xsiType, fValidationState, null);
		 }
		 catch (InvalidDatatypeValueException e) {
			 reportSchemaError(e.getKey(), e.getArgs());
			 reportSchemaError( ""cvc-elt.4.1"", new Object[] {
			 element.rawname, SchemaSymbols.URI_XSI + "","" + SchemaSymbols.XSI_TYPE, xsiType }
			);
			 return null;
		 }
		 XSTypeDefinition type = null;
		 if (typeName.uri == SchemaSymbols.URI_SCHEMAFORSCHEMA) {
			 type = SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(typeName.localpart);
		 }
		 if (type == null) {
			 SchemaGrammar grammar = findSchemaGrammar( XSDDescription.CONTEXT_XSITYPE, typeName.uri, element, typeName, attributes);
			 if (grammar != null) type = grammar.getGlobalTypeDecl(typeName.localpart);
		 }
		 if (type == null) {
			 reportSchemaError(""cvc-elt.4.2"", new Object[] {
			 element.rawname, xsiType }
			);
			 return null;
		 }
		 if (fCurrentType != null) {
			 short block = XSConstants.DERIVATION_NONE;
			 if (fCurrentElemDecl != null) {
				 block = fCurrentElemDecl.fBlock;
			 }
			 if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
				 block |= ((XSComplexTypeDecl) fCurrentType).fBlock;
			 }
			 if (!XSConstraints.checkTypeDerivationOk(type, fCurrentType, block)) {
				 reportSchemaError( ""cvc-elt.4.3"", new Object[] {
				 element.rawname, xsiType, fCurrentType.getName()}
				);
			 }
		 }
		 return type;
	 }
	 boolean getXsiNil(QName element, String xsiNil) {
		 if (fCurrentElemDecl != null && !fCurrentElemDecl.getNillable()) {
			 reportSchemaError( ""cvc-elt.3.1"", new Object[] {
			 element.rawname, SchemaSymbols.URI_XSI + "","" + SchemaSymbols.XSI_NIL }
			);
		 }
		 else {
			 String value = XMLChar.trim(xsiNil);
			 if (value.equals(SchemaSymbols.ATTVAL_TRUE) || value.equals(SchemaSymbols.ATTVAL_TRUE_1)) {
				 if (fCurrentElemDecl != null && fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {
					 reportSchemaError( ""cvc-elt.3.2.2"", new Object[] {
					 element.rawname, SchemaSymbols.URI_XSI + "","" + SchemaSymbols.XSI_NIL }
					);
				 }
				 return true;
			 }
		 }
		 return false;
	 }
	 void processAttributes(QName element, XMLAttributes attributes, XSAttributeGroupDecl attrGrp) {
		 if (DEBUG) {
			 System.out.println(""==>processAttributes: "" + attributes.getLength());
		 }
		 String wildcardIDName = null;
		 int attCount = attributes.getLength();
		 Augmentations augs = null;
		 AttributePSVImpl attrPSVI = null;
		 boolean isSimple = fCurrentType == null || fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE;
		 XSObjectList attrUses = null;
		 int useCount = 0;
		 XSWildcardDecl attrWildcard = null;
		 if (!isSimple) {
			 attrUses = attrGrp.getAttributeUses();
			 useCount = attrUses.getLength();
			 attrWildcard = attrGrp.fAttributeWC;
		 }
		 for (int index = 0;
		 index < attCount;
		 index++) {
			 attributes.getName(index, fTempQName);
			 if (DEBUG) {
				 System.out.println(""==>process attribute: "" + fTempQName);
			 }
			 if (fAugPSVI || fIdConstraint) {
				 augs = attributes.getAugmentations(index);
				 attrPSVI = (AttributePSVImpl) augs.getItem(Constants.ATTRIBUTE_PSVI);
				 if (attrPSVI != null) {
					 attrPSVI.reset();
				 }
				 else {
					 attrPSVI = new AttributePSVImpl();
					 augs.putItem(Constants.ATTRIBUTE_PSVI, attrPSVI);
				 }
				 attrPSVI.fValidationContext = fValidationRoot;
			 }
			 if (fTempQName.uri == SchemaSymbols.URI_XSI) {
				 XSAttributeDecl attrDecl = null;
				 if (fTempQName.localpart == SchemaSymbols.XSI_TYPE) {
					 attrDecl = XSI_TYPE;
				 }
				 else if (fTempQName.localpart == SchemaSymbols.XSI_NIL) {
					 attrDecl = XSI_NIL;
				 }
				 else if (fTempQName.localpart == SchemaSymbols.XSI_SCHEMALOCATION) {
					 attrDecl = XSI_SCHEMALOCATION;
				 }
				 else if (fTempQName.localpart == SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION) {
					 attrDecl = XSI_NONAMESPACESCHEMALOCATION;
				 }
				 if (attrDecl != null) {
					 processOneAttribute(element, attributes, index, attrDecl, null, attrPSVI);
					 continue;
				 }
			 }
			 if (fTempQName.rawname == XMLSymbols.PREFIX_XMLNS || fTempQName.rawname.startsWith(""xmlns:"")) {
				 continue;
			 }
			 if (isSimple) {
				 reportSchemaError( ""cvc-type.3.1.1"", new Object[] {
				 element.rawname, fTempQName.rawname }
				);
				 continue;
			 }
			 XSAttributeUseImpl currUse = null, oneUse;
			 for (int i = 0;
			 i < useCount;
			 i++) {
				 oneUse = (XSAttributeUseImpl) attrUses.item(i);
				 if (oneUse.fAttrDecl.fName == fTempQName.localpart && oneUse.fAttrDecl.fTargetNamespace == fTempQName.uri) {
					 currUse = oneUse;
					 break;
				 }
			 }
			 if (currUse == null) {
				 if (attrWildcard == null || !attrWildcard.allowNamespace(fTempQName.uri)) {
					 reportSchemaError( ""cvc-complex-type.3.2.2"", new Object[] {
					 element.rawname, fTempQName.rawname }
					);
					 fNFullValidationDepth = fElementDepth;
					 continue;
				 }
			 }
			 XSAttributeDecl currDecl = null;
			 if (currUse != null) {
				 currDecl = currUse.fAttrDecl;
			 }
			 else {
				 if (attrWildcard.fProcessContents == XSWildcardDecl.PC_SKIP) continue;
				 SchemaGrammar grammar = findSchemaGrammar( XSDDescription.CONTEXT_ATTRIBUTE, fTempQName.uri, element, fTempQName, attributes);
				 if (grammar != null) {
					 currDecl = grammar.getGlobalAttributeDecl(fTempQName.localpart);
				 }
				 if (currDecl == null) {
					 if (attrWildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {
						 reportSchemaError( ""cvc-complex-type.3.2.2"", new Object[] {
						 element.rawname, fTempQName.rawname }
						);
					 }
					 continue;
				 }
				 else {
					 if (currDecl.fType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE && ((XSSimpleType) currDecl.fType).isIDType()) {
						 if (wildcardIDName != null) {
							 reportSchemaError( ""cvc-complex-type.5.1"", new Object[] {
							 element.rawname, currDecl.fName, wildcardIDName }
							);
						 }
						 else wildcardIDName = currDecl.fName;
					 }
				 }
			 }
			 processOneAttribute(element, attributes, index, currDecl, currUse, attrPSVI);
		 }
		 if (!isSimple && attrGrp.fIDAttrName != null && wildcardIDName != null) {
			 reportSchemaError( ""cvc-complex-type.5.2"", new Object[] {
			 element.rawname, wildcardIDName, attrGrp.fIDAttrName }
			);
		 }
	 }
	 void processOneAttribute( QName element, XMLAttributes attributes, int index, XSAttributeDecl currDecl, XSAttributeUseImpl currUse, AttributePSVImpl attrPSVI) {
		 String attrValue = attributes.getValue(index);
		 fXSIErrorReporter.pushContext();
		 XSSimpleType attDV = currDecl.fType;
		 Object actualValue = null;
		 try {
			 actualValue = attDV.validate(attrValue, fValidationState, fValidatedInfo);
			 if (fNormalizeData) {
				 attributes.setValue(index, fValidatedInfo.normalizedValue);
			 }
			 if (attDV.getVariety() == XSSimpleType.VARIETY_ATOMIC && attDV.getPrimitiveKind() == XSSimpleType.PRIMITIVE_NOTATION) {
				 QName qName = (QName) actualValue;
				 SchemaGrammar grammar = fGrammarBucket.getGrammar(qName.uri);
				 if (grammar != null) {
					 fNotation = grammar.getGlobalNotationDecl(qName.localpart);
				 }
			 }
		 }
		 catch (InvalidDatatypeValueException idve) {
			 reportSchemaError(idve.getKey(), idve.getArgs());
			 reportSchemaError( ""cvc-attribute.3"", new Object[] {
			 element.rawname, fTempQName.rawname, attrValue, (attDV instanceof XSSimpleTypeDecl) ? ((XSSimpleTypeDecl) attDV).getTypeName() : attDV.getName()}
			);
		 }
		 if (actualValue != null && currDecl.getConstraintType() == XSConstants.VC_FIXED) {
			 if (!ValidatedInfo.isComparable(fValidatedInfo, currDecl.fDefault) || !actualValue.equals(currDecl.fDefault.actualValue)) {
				 reportSchemaError( ""cvc-attribute.4"", new Object[] {
				 element.rawname, fTempQName.rawname, attrValue, currDecl.fDefault.stringValue()}
				);
			 }
		 }
		 if (actualValue != null && currUse != null && currUse.fConstraintType == XSConstants.VC_FIXED) {
			 if (!ValidatedInfo.isComparable(fValidatedInfo, currUse.fDefault) || !actualValue.equals(currUse.fDefault.actualValue)) {
				 reportSchemaError( ""cvc-complex-type.3.1"", new Object[] {
				 element.rawname, fTempQName.rawname, attrValue, currUse.fDefault.stringValue()}
				);
			 }
		 }
		 if (fIdConstraint) {
			 attrPSVI.fActualValue = actualValue;
		 }
		 if (fAugPSVI) {
			 attrPSVI.fDeclaration = currDecl;
			 attrPSVI.fTypeDecl = attDV;
			 attrPSVI.fMemberType = fValidatedInfo.memberType;
			 attrPSVI.fNormalizedValue = fValidatedInfo.normalizedValue;
			 attrPSVI.fActualValue = fValidatedInfo.actualValue;
			 attrPSVI.fActualValueType = fValidatedInfo.actualValueType;
			 attrPSVI.fItemValueTypes = fValidatedInfo.itemValueTypes;
			 attrPSVI.fValidationAttempted = AttributePSVI.VALIDATION_FULL;
			 fNNoneValidationDepth = fElementDepth;
			 String[] errors = fXSIErrorReporter.mergeContext();
			 attrPSVI.fErrors = errors;
			 attrPSVI.fValidity = (errors == null) ? AttributePSVI.VALIDITY_VALID : AttributePSVI.VALIDITY_INVALID;
		 }
	 }
	 void addDefaultAttributes( QName element, XMLAttributes attributes, XSAttributeGroupDecl attrGrp) {
		 if (DEBUG) {
			 System.out.println(""==>addDefaultAttributes: "" + element);
		 }
		 XSObjectList attrUses = attrGrp.getAttributeUses();
		 int useCount = attrUses.getLength();
		 XSAttributeUseImpl currUse;
		 XSAttributeDecl currDecl;
		 short constType;
		 ValidatedInfo defaultValue;
		 boolean isSpecified;
		 QName attName;
		 for (int i = 0;
		 i < useCount;
		 i++) {
			 currUse = (XSAttributeUseImpl) attrUses.item(i);
			 currDecl = currUse.fAttrDecl;
			 constType = currUse.fConstraintType;
			 defaultValue = currUse.fDefault;
			 if (constType == XSConstants.VC_NONE) {
				 constType = currDecl.getConstraintType();
				 defaultValue = currDecl.fDefault;
			 }
			 isSpecified = attributes.getValue(currDecl.fTargetNamespace, currDecl.fName) != null;
			 if (currUse.fUse == SchemaSymbols.USE_REQUIRED) {
				 if (!isSpecified) reportSchemaError( ""cvc-complex-type.4"", new Object[] {
				 element.rawname, currDecl.fName }
				);
			 }
			 if (!isSpecified && constType != XSConstants.VC_NONE) {
				 attName = new QName(null, currDecl.fName, currDecl.fName, currDecl.fTargetNamespace);
				 String normalized = (defaultValue != null) ? defaultValue.stringValue() : """";
				 int attrIndex;
				 if (attributes instanceof XMLAttributesImpl) {
					 XMLAttributesImpl attrs = (XMLAttributesImpl) attributes;
					 attrIndex = attrs.getLength();
					 attrs.addAttributeNS(attName, ""CDATA"", normalized);
				 }
				 else {
					 attrIndex = attributes.addAttribute(attName, ""CDATA"", normalized);
				 }
				 if (fAugPSVI) {
					 Augmentations augs = attributes.getAugmentations(attrIndex);
					 AttributePSVImpl attrPSVI = new AttributePSVImpl();
					 augs.putItem(Constants.ATTRIBUTE_PSVI, attrPSVI);
					 attrPSVI.fDeclaration = currDecl;
					 attrPSVI.fTypeDecl = currDecl.fType;
					 attrPSVI.fMemberType = defaultValue.memberType;
					 attrPSVI.fNormalizedValue = normalized;
					 attrPSVI.fActualValue = defaultValue.actualValue;
					 attrPSVI.fActualValueType = defaultValue.actualValueType;
					 attrPSVI.fItemValueTypes = defaultValue.itemValueTypes;
					 attrPSVI.fValidationContext = fValidationRoot;
					 attrPSVI.fValidity = AttributePSVI.VALIDITY_VALID;
					 attrPSVI.fValidationAttempted = AttributePSVI.VALIDATION_FULL;
					 attrPSVI.fSpecified = true;
				 }
			 }
		 }
	 }
	 void processElementContent(QName element) {
		 if (fCurrentElemDecl != null && fCurrentElemDecl.fDefault != null && !fSawText && !fSubElement && !fNil) {
			 String strv = fCurrentElemDecl.fDefault.stringValue();
			 int bufLen = strv.length();
			 if (fNormalizedStr.ch == null || fNormalizedStr.ch.length < bufLen) {
				 fNormalizedStr.ch = new char[bufLen];
			 }
			 strv.getChars(0, bufLen, fNormalizedStr.ch, 0);
			 fNormalizedStr.offset = 0;
			 fNormalizedStr.length = bufLen;
			 fDefaultValue = fNormalizedStr;
		 }
		 fValidatedInfo.normalizedValue = null;
		 if (fNil) {
			 if (fSubElement || fSawText) {
				 reportSchemaError( ""cvc-elt.3.2.1"", new Object[] {
				 element.rawname, SchemaSymbols.URI_XSI + "","" + SchemaSymbols.XSI_NIL }
				);
			 }
		 }
		 this.fValidatedInfo.reset();
		 if (fCurrentElemDecl != null && fCurrentElemDecl.getConstraintType() != XSConstants.VC_NONE && !fSubElement && !fSawText && !fNil) {
			 if (fCurrentType != fCurrentElemDecl.fType) {
				 if (XSConstraints .ElementDefaultValidImmediate( fCurrentType, fCurrentElemDecl.fDefault.stringValue(), fState4XsiType, null) == null) reportSchemaError( ""cvc-elt.5.1.1"", new Object[] {
				 element.rawname, fCurrentType.getName(), fCurrentElemDecl.fDefault.stringValue()}
				);
			 }
			 elementLocallyValidType(element, fCurrentElemDecl.fDefault.stringValue());
		 }
		 else {
			 Object actualValue = elementLocallyValidType(element, fBuffer);
			 if (fCurrentElemDecl != null && fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED && !fNil) {
				 String content = fBuffer.toString();
				 if (fSubElement) reportSchemaError(""cvc-elt.5.2.2.1"", new Object[] {
				 element.rawname }
				);
				 if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
					 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
					 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_MIXED) {
						 if (!fCurrentElemDecl.fDefault.normalizedValue.equals(content)) reportSchemaError( ""cvc-elt.5.2.2.2.1"", new Object[] {
						 element.rawname, content, fCurrentElemDecl.fDefault.normalizedValue }
						);
					 }
					 else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {
						 if (actualValue != null && (!ValidatedInfo.isComparable(fValidatedInfo, fCurrentElemDecl.fDefault) || !actualValue.equals(fCurrentElemDecl.fDefault.actualValue))) {
							 reportSchemaError( ""cvc-elt.5.2.2.2.2"", new Object[] {
							 element.rawname, content, fCurrentElemDecl.fDefault.stringValue()}
							);
						 }
					 }
				 }
				 else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {
					 if (actualValue != null && (!ValidatedInfo.isComparable(fValidatedInfo, fCurrentElemDecl.fDefault) || !actualValue.equals(fCurrentElemDecl.fDefault.actualValue))) {
						 reportSchemaError( ""cvc-elt.5.2.2.2.2"", new Object[] {
						 element.rawname, content, fCurrentElemDecl.fDefault.stringValue()}
						);
					 }
				 }
			 }
		 }
		 if (fDefaultValue == null && fNormalizeData && fDocumentHandler != null && fUnionType) {
			 String content = fValidatedInfo.normalizedValue;
			 if (content == null) content = fBuffer.toString();
			 int bufLen = content.length();
			 if (fNormalizedStr.ch == null || fNormalizedStr.ch.length < bufLen) {
				 fNormalizedStr.ch = new char[bufLen];
			 }
			 content.getChars(0, bufLen, fNormalizedStr.ch, 0);
			 fNormalizedStr.offset = 0;
			 fNormalizedStr.length = bufLen;
			 fDocumentHandler.characters(fNormalizedStr, null);
		 }
	 }
	 Object elementLocallyValidType(QName element, Object textContent) {
		 if (fCurrentType == null) return null;
		 Object retValue = null;
		 if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {
			 if (fSubElement) reportSchemaError(""cvc-type.3.1.2"", new Object[] {
			 element.rawname }
			);
			 if (!fNil) {
				 XSSimpleType dv = (XSSimpleType) fCurrentType;
				 try {
					 if (!fNormalizeData || fUnionType) {
						 fValidationState.setNormalizationRequired(true);
					 }
					 retValue = dv.validate(textContent, fValidationState, fValidatedInfo);
				 }
				 catch (InvalidDatatypeValueException e) {
					 reportSchemaError(e.getKey(), e.getArgs());
					 reportSchemaError( ""cvc-type.3.1.3"", new Object[] {
					 element.rawname, textContent }
					);
				 }
			 }
		 }
		 else {
			 retValue = elementLocallyValidComplexType(element, textContent);
		 }
		 return retValue;
	 }
	 Object elementLocallyValidComplexType(QName element, Object textContent) {
		 Object actualValue = null;
		 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
		 if (!fNil) {
			 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_EMPTY && (fSubElement || fSawText)) {
				 reportSchemaError(""cvc-complex-type.2.1"", new Object[] {
				 element.rawname }
				);
			 }
			 else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {
				 if (fSubElement) reportSchemaError(""cvc-complex-type.2.2"", new Object[] {
				 element.rawname }
				);
				 XSSimpleType dv = ctype.fXSSimpleType;
				 try {
					 if (!fNormalizeData || fUnionType) {
						 fValidationState.setNormalizationRequired(true);
					 }
					 actualValue = dv.validate(textContent, fValidationState, fValidatedInfo);
				 }
				 catch (InvalidDatatypeValueException e) {
					 reportSchemaError(e.getKey(), e.getArgs());
					 reportSchemaError(""cvc-complex-type.2.2"", new Object[] {
					 element.rawname }
					);
				 }
			 }
			 else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT) {
				 if (fSawCharacters) {
					 reportSchemaError(""cvc-complex-type.2.3"", new Object[] {
					 element.rawname }
					);
				 }
			 }
			 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT || ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_MIXED) {
				 if (DEBUG) {
					 System.out.println(fCurrCMState);
				 }
				 if (fCurrCMState[0] >= 0 && !fCurrentCM.endContentModel(fCurrCMState)) {
					 String expected = expectedStr(fCurrentCM.whatCanGoHere(fCurrCMState));
					 final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);
					 if (occurenceInfo != null) {
						 final int minOccurs = occurenceInfo[0];
						 final int count = occurenceInfo[2];
						 if (count < minOccurs) {
							 final int required = minOccurs - count;
							 if (required > 1) {
								 reportSchemaError(""cvc-complex-type.2.4.j"", new Object[] {
								 element.rawname, fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) }
								);
							 }
							 else {
								 reportSchemaError(""cvc-complex-type.2.4.i"", new Object[] {
								 element.rawname, fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) }
								);
							 }
						 }
						 else {
							 reportSchemaError(""cvc-complex-type.2.4.b"", new Object[] {
							 element.rawname, expected }
							);
						 }
					 }
					 else {
						 reportSchemaError(""cvc-complex-type.2.4.b"", new Object[] {
						 element.rawname, expected }
						);
					 }
				 }
			 }
		 }
		 return actualValue;
	 }
	 void processRootTypeQName(final javax.xml.namespace.QName rootTypeQName) {
		 String rootTypeNamespace = rootTypeQName.getNamespaceURI();
		 if (rootTypeNamespace != null && rootTypeNamespace.equals(XMLConstants.NULL_NS_URI)) {
			 rootTypeNamespace = null;
		 }
		 if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(rootTypeNamespace)) {
			 fCurrentType = SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(rootTypeQName.getLocalPart());
		 }
		 else {
			 final SchemaGrammar grammarForRootType = findSchemaGrammar( XSDDescription.CONTEXT_ELEMENT, rootTypeNamespace, null, null, null);
			 if (grammarForRootType != null) {
				 fCurrentType = grammarForRootType.getGlobalTypeDecl(rootTypeQName.getLocalPart());
			 }
		 }
		 if (fCurrentType == null) {
			 String typeName = (rootTypeQName.getPrefix().equals(XMLConstants.DEFAULT_NS_PREFIX)) ? rootTypeQName.getLocalPart() : rootTypeQName.getPrefix()+"":""+rootTypeQName.getLocalPart();
			 reportSchemaError(""cvc-type.1"", new Object[] {
			typeName}
			);
		 }
	 }
	 void processRootElementDeclQName(final javax.xml.namespace.QName rootElementDeclQName, final QName element) {
		 String rootElementDeclNamespace = rootElementDeclQName.getNamespaceURI();
		 if (rootElementDeclNamespace != null && rootElementDeclNamespace.equals(XMLConstants.NULL_NS_URI)) {
			 rootElementDeclNamespace = null;
		 }
		 final SchemaGrammar grammarForRootElement = findSchemaGrammar( XSDDescription.CONTEXT_ELEMENT, rootElementDeclNamespace, null, null, null);
		 if (grammarForRootElement != null) {
			 fCurrentElemDecl = grammarForRootElement.getGlobalElementDecl(rootElementDeclQName.getLocalPart());
		 }
		 if (fCurrentElemDecl == null) {
			 String declName = (rootElementDeclQName.getPrefix().equals(XMLConstants.DEFAULT_NS_PREFIX)) ? rootElementDeclQName.getLocalPart() : rootElementDeclQName.getPrefix()+"":""+rootElementDeclQName.getLocalPart();
			 reportSchemaError(""cvc-elt.1.a"", new Object[] {
			declName}
			);
		 }
		 else {
			 checkElementMatchesRootElementDecl(fCurrentElemDecl, element);
		 }
	 }
	 void checkElementMatchesRootElementDecl(final XSElementDecl rootElementDecl, final QName element) {
		 if (element.localpart != rootElementDecl.fName || element.uri != rootElementDecl.fTargetNamespace) {
			 reportSchemaError(""cvc-elt.1.b"", new Object[] {
			element.rawname, rootElementDecl.fName}
			);
		 }
	 }
	 void reportSchemaError(String key, Object[] arguments) {
		 if (fDoValidation) fXSIErrorReporter.reportError( XSMessageFormatter.SCHEMA_DOMAIN, key, arguments, XMLErrorReporter.SEVERITY_ERROR);
	 }
	 private String expectedStr(Vector expected) {
		 StringBuffer ret = new StringBuffer(""{
			"");
			 int size = expected.size();
			 for (int i = 0;
			 i < size;
			 i++) {
				 if (i > 0) ret.append("", "");
				 ret.append(expected.elementAt(i).toString());
			 }
		 ret.append('}
		');
		 return ret.toString();
	 }
	 protected static class XPathMatcherStack {
		 protected XPathMatcher[] fMatchers = new XPathMatcher[4];
		 protected int fMatchersCount;
		 protected IntStack fContextStack = new IntStack();
		 public XPathMatcherStack() {
		 }
		 public void clear() {
			 for (int i = 0;
			 i < fMatchersCount;
			 i++) {
				 fMatchers[i] = null;
			 }
			 fMatchersCount = 0;
			 fContextStack.clear();
		 }
		 public int size() {
			 return fContextStack.size();
		 }
		 public int getMatcherCount() {
			 return fMatchersCount;
		 }
		 public void addMatcher(XPathMatcher matcher) {
			 ensureMatcherCapacity();
			 fMatchers[fMatchersCount++] = matcher;
		 }
		 public XPathMatcher getMatcherAt(int index) {
			 return fMatchers[index];
		 }
		 public void pushContext() {
			 fContextStack.push(fMatchersCount);
		 }
		 public void popContext() {
			 fMatchersCount = fContextStack.pop();
		 }
		 private void ensureMatcherCapacity() {
			 if (fMatchersCount == fMatchers.length) {
				 XPathMatcher[] array = new XPathMatcher[fMatchers.length * 2];
				 System.arraycopy(fMatchers, 0, array, 0, fMatchers.length);
				 fMatchers = array;
			 }
		 }
	 }
	 protected abstract class ValueStoreBase implements ValueStore {
		 protected IdentityConstraint fIdentityConstraint;
		 protected int fFieldCount = 0;
		 protected Field[] fFields = null;
		 protected Object[] fLocalValues = null;
		 protected short[] fLocalValueTypes = null;
		 protected ShortList[] fLocalItemValueTypes = null;
		 protected int fValuesCount;
		 public final Vector fValues = new Vector();
		 public ShortVector fValueTypes = null;
		 public Vector fItemValueTypes = null;
		 private boolean fUseValueTypeVector = false;
		 private int fValueTypesLength = 0;
		 private short fValueType = 0;
		 private boolean fUseItemValueTypeVector = false;
		 private int fItemValueTypesLength = 0;
		 private ShortList fItemValueType = null;
		 final StringBuffer fTempBuffer = new StringBuffer();
		 protected ValueStoreBase(IdentityConstraint identityConstraint) {
			 fIdentityConstraint = identityConstraint;
			 fFieldCount = fIdentityConstraint.getFieldCount();
			 fFields = new Field[fFieldCount];
			 fLocalValues = new Object[fFieldCount];
			 fLocalValueTypes = new short[fFieldCount];
			 fLocalItemValueTypes = new ShortList[fFieldCount];
			 for (int i = 0;
			 i < fFieldCount;
			 i++) {
				 fFields[i] = fIdentityConstraint.getFieldAt(i);
			 }
		 }
		 public void clear() {
			 fValuesCount = 0;
			 fUseValueTypeVector = false;
			 fValueTypesLength = 0;
			 fValueType = 0;
			 fUseItemValueTypeVector = false;
			 fItemValueTypesLength = 0;
			 fItemValueType = null;
			 fValues.setSize(0);
			 if (fValueTypes != null) {
				 fValueTypes.clear();
			 }
			 if (fItemValueTypes != null) {
				 fItemValueTypes.setSize(0);
			 }
		 }
		 public void append(ValueStoreBase newVal) {
			 for (int i = 0;
			 i < newVal.fValues.size();
			 i++) {
				 fValues.addElement(newVal.fValues.elementAt(i));
			 }
		 }
		 public void startValueScope() {
			 fValuesCount = 0;
			 for (int i = 0;
			 i < fFieldCount;
			 i++) {
				 fLocalValues[i] = null;
				 fLocalValueTypes[i] = 0;
				 fLocalItemValueTypes[i] = null;
			 }
		 }
		 public void endValueScope() {
			 if (fValuesCount == 0) {
				 if (fIdentityConstraint.getCategory() == IdentityConstraint.IC_KEY) {
					 String code = ""AbsentKeyValue"";
					 String eName = fIdentityConstraint.getElementName();
					 String cName = fIdentityConstraint.getIdentityConstraintName();
					 reportSchemaError(code, new Object[] {
					 eName, cName }
					);
				 }
				 return;
			 }
			 if (fValuesCount != fFieldCount) {
				 if (fIdentityConstraint.getCategory() == IdentityConstraint.IC_KEY) {
					 String code = ""KeyNotEnoughValues"";
					 UniqueOrKey key = (UniqueOrKey) fIdentityConstraint;
					 String eName = fIdentityConstraint.getElementName();
					 String cName = key.getIdentityConstraintName();
					 reportSchemaError(code, new Object[] {
					 eName, cName }
					);
				 }
				 return;
			 }
		 }
		 public void endDocumentFragment() {
		 }
		 public void endDocument() {
		 }
		 public void reportError(String key, Object[] args) {
			 reportSchemaError(key, args);
		 }
		 public void addValue(Field field, boolean mayMatch, Object actualValue, short valueType, ShortList itemValueType) {
			 int i;
			 for (i = fFieldCount - 1;
			 i > -1;
			 i--) {
				 if (fFields[i] == field) {
					 break;
				 }
			 }
			 if (i == -1) {
				 String code = ""UnknownField"";
				 String eName = fIdentityConstraint.getElementName();
				 String cName = fIdentityConstraint.getIdentityConstraintName();
				 reportSchemaError(code, new Object[] {
				 field.toString(), eName, cName }
				);
				 return;
			 }
			 if (!mayMatch) {
				 String code = ""FieldMultipleMatch"";
				 String cName = fIdentityConstraint.getIdentityConstraintName();
				 reportSchemaError(code, new Object[] {
				 field.toString(), cName }
				);
			 }
			 else {
				 fValuesCount++;
			 }
			 fLocalValues[i] = actualValue;
			 fLocalValueTypes[i] = valueType;
			 fLocalItemValueTypes[i] = itemValueType;
			 if (fValuesCount == fFieldCount) {
				 checkDuplicateValues();
				 for (i = 0;
				 i < fFieldCount;
				 i++) {
					 fValues.addElement(fLocalValues[i]);
					 addValueType(fLocalValueTypes[i]);
					 addItemValueType(fLocalItemValueTypes[i]);
				 }
			 }
		 }
		 public boolean contains() {
			 int next = 0;
			 final int size = fValues.size();
			 LOOP : for (int i = 0;
			 i < size;
			 i = next) {
				 next = i + fFieldCount;
				 for (int j = 0;
				 j < fFieldCount;
				 j++) {
					 Object value1 = fLocalValues[j];
					 Object value2 = fValues.elementAt(i);
					 short valueType1 = fLocalValueTypes[j];
					 short valueType2 = getValueTypeAt(i);
					 if (value1 == null || value2 == null || valueType1 != valueType2 || !(value1.equals(value2))) {
						 continue LOOP;
					 }
					 else if(valueType1 == XSConstants.LIST_DT || valueType1 == XSConstants.LISTOFUNION_DT) {
						 ShortList list1 = fLocalItemValueTypes[j];
						 ShortList list2 = getItemValueTypeAt(i);
						 if(list1 == null || list2 == null || !list1.equals(list2)) continue LOOP;
					 }
					 i++;
				 }
				 return true;
			 }
			 return false;
		 }
		 public int contains(ValueStoreBase vsb) {
			 final Vector values = vsb.fValues;
			 final int size1 = values.size();
			 if (fFieldCount <= 1) {
				 for (int i = 0;
				 i < size1;
				 ++i) {
					 short val = vsb.getValueTypeAt(i);
					 if (!valueTypeContains(val) || !fValues.contains(values.elementAt(i))) {
						 return i;
					 }
					 else if(val == XSConstants.LIST_DT || val == XSConstants.LISTOFUNION_DT) {
						 ShortList list1 = vsb.getItemValueTypeAt(i);
						 if (!itemValueTypeContains(list1)) {
							 return i;
						 }
					 }
				 }
			 }
			 else {
				 final int size2 = fValues.size();
				 OUTER: for (int i = 0;
				 i < size1;
				 i += fFieldCount) {
					 INNER: for (int j = 0;
					 j < size2;
					 j += fFieldCount) {
						 for (int k = 0;
						 k < fFieldCount;
						 ++k) {
							 final Object value1 = values.elementAt(i+k);
							 final Object value2 = fValues.elementAt(j+k);
							 final short valueType1 = vsb.getValueTypeAt(i+k);
							 final short valueType2 = getValueTypeAt(j+k);
							 if (value1 != value2 && (valueType1 != valueType2 || value1 == null || !value1.equals(value2))) {
								 continue INNER;
							 }
							 else if(valueType1 == XSConstants.LIST_DT || valueType1 == XSConstants.LISTOFUNION_DT) {
								 ShortList list1 = vsb.getItemValueTypeAt(i+k);
								 ShortList list2 = getItemValueTypeAt(j+k);
								 if (list1 == null || list2 == null || !list1.equals(list2)) {
									 continue INNER;
								 }
							 }
						 }
						 continue OUTER;
					 }
					 return i;
				 }
			 }
			 return -1;
		 }
		 protected void checkDuplicateValues() {
		 }
		 protected String toString(Object[] values) {
			 int size = values.length;
			 if (size == 0) {
				 return """";
			 }
			 fTempBuffer.setLength(0);
			 for (int i = 0;
			 i < size;
			 i++) {
				 if (i > 0) {
					 fTempBuffer.append(',');
				 }
				 fTempBuffer.append(values[i]);
			 }
			 return fTempBuffer.toString();
		 }
		 protected String toString(Vector values, int start, int length) {
			 if (length == 0) {
				 return """";
			 }
			 if (length == 1) {
				 return String.valueOf(values.elementAt(start));
			 }
			 StringBuffer str = new StringBuffer();
			 for (int i = 0;
			 i < length;
			 i++) {
				 if (i > 0) {
					 str.append(',');
				 }
				 str.append(values.elementAt(start + i));
			 }
			 return str.toString();
		 }
		 public String toString() {
			 String s = super.toString();
			 int index1 = s.lastIndexOf('$');
			 if (index1 != -1) {
				 s = s.substring(index1 + 1);
			 }
			 int index2 = s.lastIndexOf('.');
			 if (index2 != -1) {
				 s = s.substring(index2 + 1);
			 }
			 return s + '[' + fIdentityConstraint + ']';
		 }
		 private void addValueType(short type) {
			 if (fUseValueTypeVector) {
				 fValueTypes.add(type);
			 }
			 else if (fValueTypesLength++ == 0) {
				 fValueType = type;
			 }
			 else if (fValueType != type) {
				 fUseValueTypeVector = true;
				 if (fValueTypes == null) {
					 fValueTypes = new ShortVector(fValueTypesLength * 2);
				 }
				 for (int i = 1;
				 i < fValueTypesLength;
				 ++i) {
					 fValueTypes.add(fValueType);
				 }
				 fValueTypes.add(type);
			 }
		 }
		 private short getValueTypeAt(int index) {
			 if (fUseValueTypeVector) {
				 return fValueTypes.valueAt(index);
			 }
			 return fValueType;
		 }
		 private boolean valueTypeContains(short value) {
			 if (fUseValueTypeVector) {
				 return fValueTypes.contains(value);
			 }
			 return fValueType == value;
		 }
		 private void addItemValueType(ShortList itemValueType) {
			 if (fUseItemValueTypeVector) {
				 fItemValueTypes.add(itemValueType);
			 }
			 else if (fItemValueTypesLength++ == 0) {
				 fItemValueType = itemValueType;
			 }
			 else if (!(fItemValueType == itemValueType || (fItemValueType != null && fItemValueType.equals(itemValueType)))) {
				 fUseItemValueTypeVector = true;
				 if (fItemValueTypes == null) {
					 fItemValueTypes = new Vector(fItemValueTypesLength * 2);
				 }
				 for (int i = 1;
				 i < fItemValueTypesLength;
				 ++i) {
					 fItemValueTypes.add(fItemValueType);
				 }
				 fItemValueTypes.add(itemValueType);
			 }
		 }
		 private ShortList getItemValueTypeAt(int index) {
			 if (fUseItemValueTypeVector) {
				 return (ShortList) fItemValueTypes.elementAt(index);
			 }
			 return fItemValueType;
		 }
		 private boolean itemValueTypeContains(ShortList value) {
			 if (fUseItemValueTypeVector) {
				 return fItemValueTypes.contains(value);
			 }
			 return fItemValueType == value || (fItemValueType != null && fItemValueType.equals(value));
		 }
	 }
	 protected class UniqueValueStore extends ValueStoreBase {
		 public UniqueValueStore(UniqueOrKey unique) {
			 super(unique);
		 }
		 protected void checkDuplicateValues() {
			 if (contains()) {
				 String code = ""DuplicateUnique"";
				 String value = toString(fLocalValues);
				 String eName = fIdentityConstraint.getElementName();
				 String cName = fIdentityConstraint.getIdentityConstraintName();
				 reportSchemaError(code, new Object[] {
				 value, eName, cName }
				);
			 }
		 }
	 }
	 protected class KeyValueStore extends ValueStoreBase {
		 public KeyValueStore(UniqueOrKey key) {
			 super(key);
		 }
		 protected void checkDuplicateValues() {
			 if (contains()) {
				 String code = ""DuplicateKey"";
				 String value = toString(fLocalValues);
				 String eName = fIdentityConstraint.getElementName();
				 String cName = fIdentityConstraint.getIdentityConstraintName();
				 reportSchemaError(code, new Object[] {
				 value, eName, cName }
				);
			 }
		 }
	 }
	 protected class KeyRefValueStore extends ValueStoreBase {
		 protected ValueStoreBase fKeyValueStore;
		 public KeyRefValueStore(KeyRef keyRef, KeyValueStore keyValueStore) {
			 super(keyRef);
			 fKeyValueStore = keyValueStore;
		 }
		 public void endDocumentFragment() {
			 super.endDocumentFragment();
			 fKeyValueStore = (ValueStoreBase) fValueStoreCache.fGlobalIDConstraintMap.get( ((KeyRef) fIdentityConstraint).getKey());
			 if (fKeyValueStore == null) {
				 String code = ""KeyRefOutOfScope"";
				 String value = fIdentityConstraint.toString();
				 reportSchemaError(code, new Object[] {
				 value }
				);
				 return;
			 }
			 int errorIndex = fKeyValueStore.contains(this);
			 if (errorIndex != -1) {
				 String code = ""KeyNotFound"";
				 String values = toString(fValues, errorIndex, fFieldCount);
				 String element = fIdentityConstraint.getElementName();
				 String name = fIdentityConstraint.getName();
				 reportSchemaError(code, new Object[] {
				 name, values, element }
				);
			 }
		 }
		 public void endDocument() {
			 super.endDocument();
		 }
	 }
	 protected class ValueStoreCache {
		 final LocalIDKey fLocalId = new LocalIDKey();
		 protected final ArrayList fValueStores = new ArrayList();
		 protected final HashMap fIdentityConstraint2ValueStoreMap = new HashMap();
		 protected final Stack fGlobalMapStack = new Stack();
		 protected final HashMap fGlobalIDConstraintMap = new HashMap();
		 public ValueStoreCache() {
		 }
		 public void startDocument() {
			 fValueStores.clear();
			 fIdentityConstraint2ValueStoreMap.clear();
			 fGlobalIDConstraintMap.clear();
			 fGlobalMapStack.removeAllElements();
		 }
		 public void startElement() {
			 if (fGlobalIDConstraintMap.size() > 0) fGlobalMapStack.push(fGlobalIDConstraintMap.clone());
			 else fGlobalMapStack.push(null);
			 fGlobalIDConstraintMap.clear();
		 }
		 public void endElement() {
			 if (fGlobalMapStack.isEmpty()) {
				 return;
			 }
			 HashMap oldMap = (HashMap) fGlobalMapStack.pop();
			 if (oldMap == null) {
				 return;
			 }
			 Iterator entries = oldMap.entrySet().iterator();
			 while (entries.hasNext()) {
				 Map.Entry entry = (Map.Entry) entries.next();
				 IdentityConstraint id = (IdentityConstraint) entry.getKey();
				 ValueStoreBase oldVal = (ValueStoreBase) entry.getValue();
				 if (oldVal != null) {
					 ValueStoreBase currVal = (ValueStoreBase) fGlobalIDConstraintMap.get(id);
					 if (currVal == null) {
						 fGlobalIDConstraintMap.put(id, oldVal);
					 }
					 else if (currVal != oldVal) {
						 currVal.append(oldVal);
					 }
				 }
			 }
		 }
		 public void initValueStoresFor(XSElementDecl eDecl, FieldActivator activator) {
			 IdentityConstraint[] icArray = eDecl.fIDConstraints;
			 int icCount = eDecl.fIDCPos;
			 for (int i = 0;
			 i < icCount;
			 i++) {
				 switch (icArray[i].getCategory()) {
					 case (IdentityConstraint.IC_UNIQUE) : UniqueOrKey unique = (UniqueOrKey) icArray[i];
					 LocalIDKey toHash = new LocalIDKey(unique, fElementDepth);
					 UniqueValueStore uniqueValueStore = (UniqueValueStore) fIdentityConstraint2ValueStoreMap.get(toHash);
					 if (uniqueValueStore == null) {
						 uniqueValueStore = new UniqueValueStore(unique);
						 fIdentityConstraint2ValueStoreMap.put(toHash, uniqueValueStore);
					 }
					 else {
						 uniqueValueStore.clear();
					 }
					 fValueStores.add(uniqueValueStore);
					 activateSelectorFor(icArray[i]);
					 break;
					 case (IdentityConstraint.IC_KEY) : UniqueOrKey key = (UniqueOrKey) icArray[i];
					 toHash = new LocalIDKey(key, fElementDepth);
					 KeyValueStore keyValueStore = (KeyValueStore) fIdentityConstraint2ValueStoreMap.get(toHash);
					 if (keyValueStore == null) {
						 keyValueStore = new KeyValueStore(key);
						 fIdentityConstraint2ValueStoreMap.put(toHash, keyValueStore);
					 }
					 else {
						 keyValueStore.clear();
					 }
					 fValueStores.add(keyValueStore);
					 activateSelectorFor(icArray[i]);
					 break;
					 case (IdentityConstraint.IC_KEYREF) : KeyRef keyRef = (KeyRef) icArray[i];
					 toHash = new LocalIDKey(keyRef, fElementDepth);
					 KeyRefValueStore keyRefValueStore = (KeyRefValueStore) fIdentityConstraint2ValueStoreMap.get(toHash);
					 if (keyRefValueStore == null) {
						 keyRefValueStore = new KeyRefValueStore(keyRef, null);
						 fIdentityConstraint2ValueStoreMap.put(toHash, keyRefValueStore);
					 }
					 else {
						 keyRefValueStore.clear();
					 }
					 fValueStores.add(keyRefValueStore);
					 activateSelectorFor(icArray[i]);
					 break;
				 }
			 }
		 }
		 public ValueStoreBase getValueStoreFor(IdentityConstraint id, int initialDepth) {
			 fLocalId.fDepth = initialDepth;
			 fLocalId.fId = id;
			 return (ValueStoreBase) fIdentityConstraint2ValueStoreMap.get(fLocalId);
		 }
		 public ValueStoreBase getGlobalValueStoreFor(IdentityConstraint id) {
			 return (ValueStoreBase) fGlobalIDConstraintMap.get(id);
		 }
		 public void transplant(IdentityConstraint id, int initialDepth) {
			 fLocalId.fDepth = initialDepth;
			 fLocalId.fId = id;
			 ValueStoreBase newVals = (ValueStoreBase) fIdentityConstraint2ValueStoreMap.get(fLocalId);
			 if (id.getCategory() == IdentityConstraint.IC_KEYREF) return;
			 ValueStoreBase currVals = (ValueStoreBase) fGlobalIDConstraintMap.get(id);
			 if (currVals != null) {
				 currVals.append(newVals);
				 fGlobalIDConstraintMap.put(id, currVals);
			 }
			 else fGlobalIDConstraintMap.put(id, newVals);
		 }
		 public void endDocument() {
			 int count = fValueStores.size();
			 for (int i = 0;
			 i < count;
			 i++) {
				 ValueStoreBase valueStore = (ValueStoreBase) fValueStores.get(i);
				 valueStore.endDocument();
			 }
		 }
		 public String toString() {
			 String s = super.toString();
			 int index1 = s.lastIndexOf('$');
			 if (index1 != -1) {
				 return s.substring(index1 + 1);
			 }
			 int index2 = s.lastIndexOf('.');
			 if (index2 != -1) {
				 return s.substring(index2 + 1);
			 }
			 return s;
		 }
	 }
	 protected static final class LocalIDKey {
		 public IdentityConstraint fId;
		 public int fDepth;
		 public LocalIDKey() {
		 }
		 public LocalIDKey(IdentityConstraint id, int depth) {
			 fId = id;
			 fDepth = depth;
		 }
		 public int hashCode() {
			 return fId.hashCode() + fDepth;
		 }
		 public boolean equals(Object localIDKey) {
			 if (localIDKey instanceof LocalIDKey) {
				 LocalIDKey lIDKey = (LocalIDKey) localIDKey;
				 return (lIDKey.fId == fId && lIDKey.fDepth == fDepth);
			 }
			 return false;
		 }
	 }
	 protected static final class ShortVector {
		 private int fLength;
		 private short[] fData;
		 public ShortVector() {
		}
		 public ShortVector(int initialCapacity) {
			 fData = new short[initialCapacity];
		 }
		 public int length() {
			 return fLength;
		 }
		 public void add(short value) {
			 ensureCapacity(fLength + 1);
			 fData[fLength++] = value;
		 }
		 public short valueAt(int position) {
			 return fData[position];
		 }
		 public void clear() {
			 fLength = 0;
		 }
		 public boolean contains(short value) {
			 for (int i = 0;
			 i < fLength;
			 ++i) {
				 if (fData[i] == value) {
					 return true;
				 }
			 }
			 return false;
		 }
		 private void ensureCapacity(int size) {
			 if (fData == null) {
				 fData = new short[8];
			 }
			 else if (fData.length <= size) {
				 short[] newdata = new short[fData.length * 2];
				 System.arraycopy(fData, 0, newdata, 0, fData.length);
				 fData = newdata;
			 }
		 }
	 }
}",1,0,0,0
"public class ModuleOptionsReferenceDoc {
	private static final Pattern FENCE_START_REGEX = Pattern.compile(""^private ModuleRegistry moduleRegistry = new ResourceModuleRegistry(""file:./modules"");
	private ModuleOptionsMetadataResolver moduleOptionsMetadataResolver = new DefaultModuleOptionsMetadataResolver();
	private ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();
	public static void main(String... paths) throws IOException {
		ModuleOptionsReferenceDoc runner = new ModuleOptionsReferenceDoc();
		for (String path : paths) {
			runner.updateSingleFile(path);
		}
	}
	private void updateSingleFile(String path) throws IOException {
		File originalFile = new File(path);
		Assert.isTrue(originalFile.exists() && !originalFile.isDirectory(),String.format(""'%s' does not exist or points to a directory"", originalFile.getAbsolutePath()));
		File backup = new File(originalFile.getAbsolutePath() + "".backup"");
		originalFile.renameTo(backup);
		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(backup), ""UTF-8""));
		PrintStream out = new PrintStream(new FileOutputStream(originalFile), false, ""UTF-8"");
		ModuleType type = null;
		String name = null;
		int openingLineNumber = 0;
		int ln = 1;
		for (String line = reader.readLine();
		 line != null;
		 line = reader.readLine(), ln++) {
			Matcher startMatcher = FENCE_START_REGEX.matcher(line);
			if (startMatcher.matches()) {
				checkPreviousTagHasBeenClosed(originalFile, backup, out, type, name, openingLineNumber);
				type = ModuleType.valueOf(startMatcher.group(1));
				name = startMatcher.group(2);
				openingLineNumber = ln;
				out.println(line);
			}
			else if (type != null && line.equals(String.format(""generateWarning(out, name, type);
			generateAsciidoc(out, name, type);
			type = null;
			name = null;
			out.println(line);
		}
		else if (type == null) {
			out.println(line);
		}
	}
	checkPreviousTagHasBeenClosed(originalFile, backup, out, type, name, openingLineNumber);
	out.close();
	reader.close();
	backup.delete();
}
private void checkPreviousTagHasBeenClosed(File originalFile, File backup, PrintStream out, ModuleType type,String name, int openingLineNumber) {
	if (type != null) {
		out.close();
		originalFile.delete();
		backup.renameTo(originalFile);
		throw new IllegalStateException(String.format(""In %s, found 'originalFile.getAbsolutePath(), type, name, openingLineNumber));
	}
}
private void generateWarning(PrintStream out, String name, ModuleType type) {
	out.format(""out.format(""ModuleOptionsReferenceDoc.class.getSimpleName());
}
private void generateAsciidoc(PrintStream out, String name, ModuleType type)throws IOException {
	ModuleDefinition def = moduleRegistry.findDefinition(name, type);
	ModuleOptionsMetadata moduleOptionsMetadata = moduleOptionsMetadataResolver.resolve(def);
	Resource moduleLoc = resourcePatternResolver.getResource(((SimpleModuleDefinition) def).getLocation());
	ClassLoader moduleClassLoader = ModuleUtils.createModuleDiscoveryClassLoader(moduleLoc, ModuleOptionsReferenceDoc.class.getClassLoader());
	if (!moduleOptionsMetadata.iterator().hasNext()) {
		out.format(""The **%s** %s has no particular option (in addition to options shared by all modules)%n%n"",pt(def.getName()), pt(def.getType()));
		return;
	}
	out.format(""The **%s** %s has the following options:%n%n"", pt(def.getName()), pt(def.getType()));
	List<ModuleOption> options = new ArrayList<ModuleOption>();
	for (ModuleOption mo : moduleOptionsMetadata) {
		options.add(mo);
	}
	Collections.sort(options, new Comparator<ModuleOption>() {
		public int compare(ModuleOption o1, ModuleOption o2) {
			return o1.getName().compareTo(o2.getName());
		}
	}
	);
	for (ModuleOption mo : options) {
		String prettyDefault = prettifyDefaultValue(mo);
		String maybeEnumHint = generateEnumValues(mo, moduleClassLoader);
		out.format(""%s:: %s *(%s, %s%s)*%n"", pt(mo.getName()), pt(mo.getDescription()),pt(shortClassName(mo.getType())),prettyDefault, maybeEnumHint);
	}
}
private String shortClassName(String fqName) {
	int lastDot = fqName.lastIndexOf('.');
	return lastDot >= 0 ? fqName.substring(lastDot + 1) : fqName;
}
private String generateEnumValues(ModuleOption mo, ClassLoader moduleClassLoader) {
	String canonical = mo.getType();
	String system = canonical.replaceAll(""(.*\\p{
	Upper}
	[^\\.]*)\\.(\\p{
	Upper}
	.*)"", ""$1\\$$2"");
	Class<?> clazz = null;
	try {
		clazz = Class.forName(system, false, moduleClassLoader);
	}
	catch (ClassNotFoundException e) {
		return """";
	}
	if (Enum.class.isAssignableFrom(clazz)) {
		String values = StringUtils.arrayToCommaDelimitedString(clazz.getEnumConstants());
		return String.format("", possible values: `%s`"", values);
	}
	elsereturn """";
}
private String prettifyDefaultValue(ModuleOption mo) {
	if (mo.getDefaultValue() == null) {
		return ""no default"";
	}
	String result = stringify(mo.getDefaultValue());
	result = result.replace(ModulePlaceholders.XD_STREAM_NAME, ""<stream name>"");
	result = result.replace(ModulePlaceholders.XD_JOB_NAME, ""<job name>"");
	return ""default: `"" + result + ""`"";
}
private String stringify(Object element) {
	Class<?> clazz = element.getClass();
	if (clazz == byte[].class) {
		return Arrays.toString((byte[]) element);
	}
	else if (clazz == short[].class) {
		return Arrays.toString((short[]) element);
	}
	else if (clazz == int[].class) {
		return Arrays.toString((int[]) element);
	}
	else if (clazz == long[].class) {
		return Arrays.toString((long[]) element);
	}
	else if (clazz == char[].class) {
		return Arrays.toString((char[]) element);
	}
	else if (clazz == float[].class) {
		return Arrays.toString((float[]) element);
	}
	else if (clazz == double[].class) {
		return Arrays.toString((double[]) element);
	}
	else if (clazz == boolean[].class) {
		return Arrays.toString((boolean[]) element);
	}
	else if (element instanceof Object[]) {
		return Arrays.deepToString((Object[]) element);
	}
	else {
		return element.toString();
	}
}
private String pt(Object original) {
	return ""$$"" + original + ""$$"";
}
}",1,0,0,0
"public class TriMeshBeveler{
	 private TriangleMesh origMesh, mesh;
	 private boolean selected[], newSelection[];
	 private int mode;
	 private Vec3 faceInsets[][], faceNormal[];
	 private Vector newIndex;
	 public static final int BEVEL_FACES = 0;
	 public static final int BEVEL_FACE_GROUPS = 1;
	 public static final int BEVEL_EDGES = 2;
	 public static final int BEVEL_VERTICES = 3;
	 public TriMeshBeveler(TriangleMesh theMesh, boolean selection[], int bevelMode) {
		 origMesh = theMesh;
		 selected = selection;
		 mode = bevelMode;
		 if (mode < 0 || mode > 3) throw new IllegalArgumentException();
	 }
	 public TriangleMesh bevelMesh(double height, double width) {
		 switch (mode) {
			 case BEVEL_FACES: return bevelIndividualFaces(height, width);
			 case BEVEL_FACE_GROUPS: return bevelFacesAsGroup(height, width);
			 case BEVEL_EDGES: return bevelEdges(height, width);
			 case BEVEL_VERTICES: return bevelVertices(height, width);
		 }
		 return null;
	 }
	 private TriangleMesh bevelIndividualFaces(double height, double width) {
		 mesh = (TriangleMesh) origMesh.duplicate();
		 if (width == 0.0 && height == 0.0) {
			 newSelection = selected;
			 return mesh;
		 }
		 Vertex v[] = (Vertex []) mesh.getVertices();
		 Edge e[] = mesh.getEdges();
		 Face f[] = mesh.getFaces();
		 int i, j;
		 Vector face = new Vector(), vert = new Vector();
		 newIndex = new Vector();
		 findVertexInsets(height, width);
		 for (i = 0;
		 i < v.length;
		 i++) vert.addElement(v[i]);
		 for (i = 0;
		 i < f.length;
		 i++) {
			if (selected[i]) {
				 j = vert.size();
				 vert.addElement(offsetVertex(mesh, v[f[i].v1], faceInsets[i][0]));
				 vert.addElement(offsetVertex(mesh, v[f[i].v2], faceInsets[i][1]));
				 vert.addElement(offsetVertex(mesh, v[f[i].v3], faceInsets[i][2]));
				 newIndex.addElement(new Integer(face.size()));
				 face.addElement(new int [] {
				j, j+1, j+2, i}
				);
				 face.addElement(new int [] {
				f[i].v1, f[i].v2, j, i}
				);
				 face.addElement(new int [] {
				j, f[i].v2, j+1, i}
				);
				 face.addElement(new int [] {
				f[i].v2, f[i].v3, j+1, i}
				);
				 face.addElement(new int [] {
				j+1, f[i].v3, j+2, i}
				);
				 face.addElement(new int [] {
				f[i].v3, f[i].v1, j+2, i}
				);
				 face.addElement(new int [] {
				j+2, f[i].v1, j, i}
				);
			 }
			else face.addElement(new int [] {
			f[i].v1, f[i].v2, f[i].v3, i}
			);
		 }
		 prepareMesh(mesh, face, vert, null);
		 Edge newe[] = mesh.getEdges();
		 for (i = 0;
		 i < e.length;
		 i++) for (j = 0;
		 j < newe.length;
		 j++)if ((e[i].v1 == newe[j].v1 && e[i].v2 == newe[j].v2) ||(e[i].v1 == newe[j].v2 && e[i].v2 == newe[j].v1)) {
			 newe[j].smoothness = e[i].smoothness;
			 break;
		 }
		 newSelection = new boolean [mesh.getFaces().length];
		 for (i = 0;
		 i < newIndex.size();
		 i++) newSelection[((Integer) newIndex.elementAt(i)).intValue()] = true;
		 return mesh;
	 }
	 private void findVertexInsets(double height, double width) {
		 Vertex v[] = (Vertex []) mesh.getVertices();
		 Face f[] = mesh.getFaces();
		 double length, dot;
		 Vec3 e1, e2, e3, normal;
		 int i;
		 faceInsets = new Vec3 [f.length][];
		 for (i = 0;
		 i < f.length;
		 i++) if (selected[i]){
			 faceInsets[i] = new Vec3 [3];
			 e1 = v[f[i].v2].r.minus(v[f[i].v1].r);
			 e2 = v[f[i].v3].r.minus(v[f[i].v2].r);
			 e3 = v[f[i].v1].r.minus(v[f[i].v3].r);
			 e1.normalize();
			 e2.normalize();
			 e3.normalize();
			 normal = e1.cross(e2);
			 length = normal.length();
			 if (length == 0.0) faceInsets[i][0] = faceInsets[i][1] = faceInsets[i][2] = new Vec3();
			 else {
				 normal.scale(height/length);
				 dot = -e1.dot(e3);
				 faceInsets[i][0] = e1.minus(e3).times(width/Math.sqrt(1-dot*dot)).plus(normal);
				 dot = -e2.dot(e1);
				 faceInsets[i][1] = e2.minus(e1).times(width/Math.sqrt(1-dot*dot)).plus(normal);
				 dot = -e3.dot(e2);
				 faceInsets[i][2] = e3.minus(e2).times(width/Math.sqrt(1-dot*dot)).plus(normal);
			 }
		}
	 }
	 private TriangleMesh bevelFacesAsGroup(double height, double width) {
		 mesh = (TriangleMesh) origMesh.duplicate();
		 if (width == 0.0 && height == 0.0) {
			 newSelection = selected;
			 return mesh;
		 }
		 Vertex v[] = (Vertex []) mesh.getVertices();
		 Edge e[] = mesh.getEdges();
		 Face f1, f2, f[] = mesh.getFaces();
		 int i, j, k, m, n, newface[][], vertFace[][], numVertFaces[], tempFace[], bev[];
		 int group[], touchCount[], groupCount;
		 Vec3 temp = new Vec3();
		 Vector face = new Vector(), vert = new Vector(), bevel = new Vector();
		 boolean someSelected[] = new boolean [v.length], allSelected[] = new boolean [v.length];
		 boolean touching[][], inGroup[], beveled[] = new boolean [e.length];
		 double coeff[][] = new double [3][3], rhs[] = new double [3];
		 newIndex = new Vector();
		 findEdgeInsets(height, width);
		 for (i = 0;
		 i < v.length;
		 i++) vert.addElement(v[i]);
		 for (i = 0;
		 i < f.length;
		 i++) face.addElement(new int [] {
		f[i].v1, f[i].v2, f[i].v3, i}
		);
		 for (i = 0;
		 i < v.length;
		 i++) allSelected[i] = true;
		 for (i = 0;
		 i < f.length;
		 i++) {
			if (selected[i]) someSelected[f[i].v1] = someSelected[f[i].v2] = someSelected[f[i].v3] = true;
			else allSelected[f[i].v1] = allSelected[f[i].v2] = allSelected[f[i].v3] = false;
		 }
		 vertFace = new int [v.length][];
		 numVertFaces = new int [v.length];
		 for (i = 0;
		 i < f.length;
		 i++) if (selected[i]){
			 numVertFaces[f[i].v1]++;
			 numVertFaces[f[i].v2]++;
			 numVertFaces[f[i].v3]++;
		}
		 for (i = 0;
		 i < v.length;
		 i++) {
			vertFace[i] = new int [numVertFaces[i]];
			numVertFaces[i] = 0;
		 }
		 for (i = 0;
		 i < f.length;
		 i++) if (selected[i]){
			 vertFace[f[i].v1][numVertFaces[f[i].v1]++] = i;
			 vertFace[f[i].v2][numVertFaces[f[i].v2]++] = i;
			 vertFace[f[i].v3][numVertFaces[f[i].v3]++] = i;
		}
		 for (i = 0;
		 i < v.length;
		 i++) {
			if (allSelected[i]) {
				 for (j = 0;
				 j < 3;
				 j++) rhs[j] = coeff[j][0] = coeff[j][1] = coeff[j][2] = 0.0;
				 for (j = 0;
				 j < numVertFaces[i];
				 j++) {
					coeff[0][0] += faceNormal[vertFace[i][j]].x * faceNormal[vertFace[i][j]].x;
					coeff[0][1] += faceNormal[vertFace[i][j]].x * faceNormal[vertFace[i][j]].y;
					coeff[0][2] += faceNormal[vertFace[i][j]].x * faceNormal[vertFace[i][j]].z;
					coeff[1][1] += faceNormal[vertFace[i][j]].y * faceNormal[vertFace[i][j]].y;
					coeff[1][2] += faceNormal[vertFace[i][j]].y * faceNormal[vertFace[i][j]].z;
					coeff[2][2] += faceNormal[vertFace[i][j]].z * faceNormal[vertFace[i][j]].z;
					rhs[0] += height*faceNormal[vertFace[i][j]].x;
					rhs[1] += height*faceNormal[vertFace[i][j]].y;
					rhs[2] += height*faceNormal[vertFace[i][j]].z;
					newIndex.addElement(new Integer(vertFace[i][j]));
				 }
				 coeff[1][0] = coeff[0][1];
				 coeff[2][0] = coeff[0][2];
				 coeff[2][1] = coeff[1][2];
				 SVD.solve(coeff, rhs, 1e-3);
				 temp.set(rhs[0], rhs[1], rhs[2]);
				 vert.setElementAt(offsetVertex(mesh, (Vertex) vert.elementAt(i), temp), i);
			 }
			 else if (someSelected[i]) {
				 touching = new boolean [numVertFaces[i]][numVertFaces[i]];
				 for (j = 1;
				 j < numVertFaces[i];
				 j++) for (k = 0;
				 k < j;
				 k++){
					 f1 = f[vertFace[i][j]];
					 f2 = f[vertFace[i][k]];
					 if (f1.e1 == f2.e1 || f1.e1 == f2.e2 || f1.e1 == f2.e3 || f1.e2 == f2.e1 || f1.e2 == f2.e2 || f1.e2 == f2.e3 || f1.e3 == f2.e1 || f1.e3 == f2.e2 || f1.e3 == f2.e3) touching[j][k] = touching[k][j] = true;
				}
				 touchCount = new int [numVertFaces[i]];
				 for (j = 0;
				 j < numVertFaces[i];
				 j++) for (k = 0;
				 k < numVertFaces[i];
				 k++)touchCount[j] += touching[j][k] ? 1 : 0;
				 inGroup = new boolean [numVertFaces[i]];
				 group = new int [numVertFaces[i]];
				 while (true) {
					groupCount = 0;
					for (j = 0;
					 j < numVertFaces[i] && (inGroup[j] == true || touchCount[j] > 1);
					 j++);
					if (j == numVertFaces[i]) break;
					inGroup[j] = true;
					group[0] = j;
					groupCount = 1;
					while (touchCount[j] > (groupCount == 1 ? 0 : 1)) for (j = 0;
					 j < numVertFaces[i];
					 j++) if (!inGroup[j] && touching[group[groupCount-1]][j]) {
						group[groupCount++] = j;
						inGroup[j] = true;
						break;
					 }
					if (groupCount == 1) {
						 f1 = f[vertFace[i][group[0]]];
						 m = n = -1;
						 if (e[f1.e1].v1 == i || e[f1.e1].v2 == i) {
							bevel.addElement(new int [] {
							vertFace[i][group[0]], f1.e1}
							);
							m = 0;
						 }
						 if (e[f1.e2].v1 == i || e[f1.e2].v2 == i) {
							bevel.addElement(new int [] {
							vertFace[i][group[0]], f1.e2}
							);
							if (m == -1) m = 1;
							else n = 1;
						 }
						 if (e[f1.e3].v1 == i || e[f1.e3].v2 == i) {
							bevel.addElement(new int [] {
							vertFace[i][group[0]], f1.e3}
							);
							n = 2;
						 }
					 }
					else {
						 f1 = f[vertFace[i][group[0]]];
						 f2 = f[vertFace[i][group[1]]];
						 if ((e[f1.e1].v1 == i || e[f1.e1].v2 == i) && f2.e1 != f1.e1 && f2.e2 != f1.e1 && f2.e3 != f1.e1) {
							bevel.addElement(new int [] {
							vertFace[i][group[0]], f1.e1}
							);
							m = 0;
						 }
						 else if ((e[f1.e2].v1 == i || e[f1.e2].v2 == i) && f2.e1 != f1.e2 && f2.e2 != f1.e2 && f2.e3 != f1.e2) {
							bevel.addElement(new int [] {
							vertFace[i][group[0]], f1.e2}
							);
							m = 1;
						 }
						 else {
							bevel.addElement(new int [] {
							vertFace[i][group[0]], f1.e3}
							);
							m = 2;
						 }
						 f1 = f[vertFace[i][group[groupCount-1]]];
						 f2 = f[vertFace[i][group[groupCount-2]]];
						 if ((e[f1.e1].v1 == i || e[f1.e1].v2 == i) && f2.e1 != f1.e1 && f2.e2 != f1.e1 && f2.e3 != f1.e1) {
							bevel.addElement(new int [] {
							vertFace[i][group[groupCount-1]], f1.e1}
							);
							n = 0;
						 }
						 else if ((e[f1.e2].v1 == i || e[f1.e2].v2 == i) && f2.e1 != f1.e2 && f2.e2 != f1.e2 && f2.e3 != f1.e2) {
							bevel.addElement(new int [] {
							vertFace[i][group[groupCount-1]], f1.e2}
							);
							n = 1;
						 }
						 else {
							bevel.addElement(new int [] {
							vertFace[i][group[groupCount-1]], f1.e3}
							);
							n = 2;
						 }
					 }
					coeff[0][0] = faceInsets[vertFace[i][group[0]]][m].x;
					coeff[0][1] = faceInsets[vertFace[i][group[0]]][m].y;
					coeff[0][2] = faceInsets[vertFace[i][group[0]]][m].z;
					coeff[1][0] = faceInsets[vertFace[i][group[groupCount-1]]][n].x;
					coeff[1][1] = faceInsets[vertFace[i][group[groupCount-1]]][n].y;
					coeff[1][2] = faceInsets[vertFace[i][group[groupCount-1]]][n].z;
					coeff[2][0] = faceNormal[vertFace[i][group[0]]].x + faceNormal[vertFace[i][group[groupCount-1]]].x;
					coeff[2][1] = faceNormal[vertFace[i][group[0]]].y + faceNormal[vertFace[i][group[groupCount-1]]].y;
					coeff[2][2] = faceNormal[vertFace[i][group[0]]].z + faceNormal[vertFace[i][group[groupCount-1]]].z;
					rhs[0] = rhs[1] = width;
					rhs[2] = 2.0*height;
					SVD.solve(coeff, rhs, 1e-3);
					temp.set(rhs[0], rhs[1], rhs[2]);
					vert.addElement(offsetVertex(mesh, (Vertex) vert.elementAt(i), temp));
					k = vert.size()-1;
					for (j = 0;
					 j < groupCount;
					 j++) {
						 tempFace = (int []) face.elementAt(vertFace[i][group[j]]);
						 f1 = f[vertFace[i][group[j]]];
						 if (f1.v1 == i) tempFace[0] = k;
						 else if (f1.v2 == i) tempFace[1] = k;
						 else tempFace[2] = k;
						 newIndex.addElement(new Integer(vertFace[i][group[j]]));
					 }
				 }
			 }
		}
		 for (i = 0;
		 i < bevel.size();
		 i++) {
			bev = (int []) bevel.elementAt(i);
			if (beveled[bev[1]]) continue;
			beveled[bev[1]] = true;
			j = e[bev[1]].v1;
			k = e[bev[1]].v2;
			if ((f[bev[0]].v1 == k && f[bev[0]].v2 == j) || (f[bev[0]].v2 == k && f[bev[0]].v3 == j) || (f[bev[0]].v3 == k && f[bev[0]].v1 == j)) {
				 m = j;
				 j = k;
				 k = m;
			 }
			tempFace = (int []) face.elementAt(bev[0]);
			if (f[bev[0]].v1 == j) m = tempFace[0];
			else if (f[bev[0]].v2 == j) m = tempFace[1];
			else m = tempFace[2];
			if (f[bev[0]].v1 == k) n = tempFace[0];
			else if (f[bev[0]].v2 == k) n = tempFace[1];
			else n = tempFace[2];
			face.addElement(new int [] {
			j, k, m, bev[0]}
			);
			face.addElement(new int [] {
			m, k, n, bev[0]}
			);
		 }
		 prepareMesh(mesh, face, vert, null);
		 Edge newe[] = mesh.getEdges();
		 for (i = 0;
		 i < e.length;
		 i++) for (j = 0;
		 j < newe.length;
		 j++)if ((e[i].v1 == newe[j].v1 && e[i].v2 == newe[j].v2) ||(e[i].v1 == newe[j].v2 && e[i].v2 == newe[j].v1)) {
			 newe[j].smoothness = e[i].smoothness;
			 break;
		 }
		 newSelection = new boolean [mesh.getFaces().length];
		 for (i = 0;
		 i < newIndex.size();
		 i++) newSelection[((Integer) newIndex.elementAt(i)).intValue()] = true;
		 return mesh;
	 }
	 private void findEdgeInsets(double height, double width) {
		 Vertex v[] = (Vertex []) mesh.getVertices();
		 Face f[] = mesh.getFaces();
		 double length, dot;
		 Vec3 e1, e2, e3;
		 int i;
		 faceInsets = new Vec3 [f.length][];
		 faceNormal = new Vec3 [f.length];
		 for (i = 0;
		 i < f.length;
		 i++) if (selected[i]){
			 faceInsets[i] = new Vec3 [3];
			 e1 = v[f[i].v2].r.minus(v[f[i].v1].r);
			 e2 = v[f[i].v3].r.minus(v[f[i].v2].r);
			 e3 = v[f[i].v1].r.minus(v[f[i].v3].r);
			 e1.normalize();
			 e2.normalize();
			 e3.normalize();
			 faceNormal[i] = e1.cross(e2);
			 length = faceNormal[i].length();
			 if (length == 0.0) faceInsets[i][0] = faceInsets[i][1] = faceInsets[i][2] = faceNormal[i] = new Vec3();
			 else {
				 faceNormal[i].scale(1.0/length);
				 dot = -e1.dot(e2);
				 faceInsets[i][0] = e2.plus(e1.times(dot));
				 faceInsets[i][0].normalize();
				 dot = -e2.dot(e3);
				 faceInsets[i][1] = e3.plus(e2.times(dot));
				 faceInsets[i][1].normalize();
				 dot = -e3.dot(e1);
				 faceInsets[i][2] = e1.plus(e3.times(dot));
				 faceInsets[i][2].normalize();
			 }
		}
	 }
	 private Vertex offsetVertex(TriangleMesh mesh, Vertex v, Vec3 offset) {
		 Vertex vert = mesh.new Vertex(v);
		 vert.r.add(offset);
		 vert.edges = 0;
		 vert.firstEdge = -1;
		 return vert;
	 }
	 private TriangleMesh bevelVertices(double height, double width) {
		 mesh = (TriangleMesh) origMesh.duplicate();
		 if (width == 0.0) {
			 newSelection = selected;
			 return mesh;
		 }
		 Vertex v[] = (Vertex []) mesh.getVertices();
		 Edge e[] = mesh.getEdges();
		 Face f[] = mesh.getFaces();
		 Vec3 norm[] = mesh.getNormals();
		 int vertIndex[] = new int [v.length];
		 int extraVertIndex[][] = new int [v.length][], vertEdgeIndex[][] = new int [v.length][];
		 boolean forward[] = new boolean [v.length];
		 Vector face = new Vector(), vert = new Vector();
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 if (!selected[i]) {
				 vertIndex[i] = vert.size();
				 vert.addElement(v[i]);
				 continue;
			 }
			 int edges[] = v[i].getEdges();
			 vertEdgeIndex[i] = edges;
			 Vec3 edgeDir[] = new Vec3 [edges.length];
			 double dot[] = new double [edges.length];
			 double minDot = 1.0;
			 for (int j = 0;
			 j < edges.length;
			 j++) {
				 edgeDir[j] = v[e[edges[j]].v2].r.minus(v[e[edges[j]].v1].r);
				 edgeDir[j].normalize();
				 if (e[edges[j]].v2 == i) edgeDir[j].scale(-1.0);
				 dot[j] = Math.abs(norm[i].dot(edgeDir[j]));
				 if (dot[j] < minDot) minDot = dot[j];
			 }
			 double bevelDist = width/Math.tan(Math.acos(minDot));
			 extraVertIndex[i] = new int [edges.length];
			 for (int j = 0;
			 j < edges.length;
			 j++) {
				 extraVertIndex[i][j] = vert.size();
				 double dist = (dot[j] == 0.0 ? width : bevelDist/dot[j]);
				 vert.addElement(offsetVertex(mesh, v[i], edgeDir[j].times(dist)));
			 }
			 boolean convex = (norm[i].dot(edgeDir[0]) < 0.0);
			 vertIndex[i] = vert.size();
			 vert.addElement(offsetVertex(mesh, v[i], norm[i].times(convex ? height-bevelDist : height+bevelDist)));
			 Edge e0 = e[edges[0]];
			 Edge e1 = e[edges[1]];
			 Face fc = f[e0.f1];
			 int v0 = (e0.v1 == i ? e0.v2 : e0.v1);
			 int v1 = (e1.v1 == i ? e1.v2 : e1.v1);
			 forward[i] = ((fc.v1 == v0 && fc.v3 == v1) || (fc.v2 == v0 && fc.v1 == v1) || (fc.v3 == v0 && fc.v2 == v1));
		 }
		 for (int i = 0;
		 i < f.length;
		 i++) {
			 Face fc = f[i];
			 int origVert[] = new int [] {
			fc.v1, fc.v2, fc.v2, fc.v3, fc.v3, fc.v1}
			;
			 int origEdge[] = new int [] {
			fc.e1, fc.e1, fc.e2, fc.e2, fc.e3, fc.e3}
			;
			 int newVert[] = new int [6];
			 int numVert = 0;
			 for (int j = 0;
			 j < origVert.length;
			 j++) {
				 int index = vertIndex[origVert[j]];
				 if (selected[origVert[j]]) {
					 int orig = origVert[j];
					 for (int k = 0;
					 k < vertEdgeIndex[orig].length;
					 k++) if (vertEdgeIndex[orig][k] == origEdge[j]) {
						 index = extraVertIndex[orig][k];
						 break;
					 }
				 }
				 if (numVert == 0 || (index != newVert[numVert-1] && index != newVert[0])) newVert[numVert++] = index;
			 }
			 if (numVert == 3) face.addElement(new int [] {
			newVert[0], newVert[1], newVert[2], i}
			);
			 else if (numVert == 4) {
				 face.addElement(new int [] {
				newVert[0], newVert[1], newVert[2], i}
				);
				 face.addElement(new int [] {
				newVert[0], newVert[2], newVert[3], i}
				);
			 }
			 else for (int step = 1;
			 2*step < numVert;
			 step *= 2) {
				 int start;
				 for (start = 0;
				 start+2*step < numVert;
				 start += 2*step) face.addElement(new int [] {
				newVert[start], newVert[start+step], newVert[start+2*step], i}
				);
				 if (start+step < numVert) face.addElement(new int [] {
				newVert[start], newVert[start+step], newVert[0], i}
				);
			 }
		 }
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 if (!selected[i]) continue;
			 for (int j = 0;
			 j < extraVertIndex[i].length;
			 j++) {
				 int prev = (j == 0 ? vertEdgeIndex[i].length-1 : j-1);
				 if (forward[i]) face.addElement(new int [] {
				extraVertIndex[i][j], extraVertIndex[i][prev], vertIndex[i], -1}
				);
				 else face.addElement(new int [] {
				extraVertIndex[i][prev], extraVertIndex[i][j], vertIndex[i], -1}
				);
			 }
		 }
		 prepareMesh(mesh, face, vert, vertIndex);
		 Edge newe[] = mesh.getEdges();
		 for (int i = 0;
		 i < e.length;
		 i++) {
			 int v1 = vertIndex[e[i].v1];
			 int v2 = vertIndex[e[i].v2];
			 for (int j = 0;
			 j < newe.length;
			 j++)if ((v1 == newe[j].v1 && v2 == newe[j].v2) ||(v1 == newe[j].v2 && v2 == newe[j].v1)) {
				 newe[j].smoothness = e[i].smoothness;
				 break;
			 }
		 }
		 newSelection = new boolean [mesh.getVertices().length];
		 for (int i = 0;
		 i < vertIndex.length;
		 i++) if (selected[i]) newSelection[vertIndex[i]] = true;
		 return mesh;
	 }
	 private TriangleMesh bevelEdges(double height, double width) {
		 mesh = (TriangleMesh) origMesh.duplicate();
		 if (width == 0.0) {
			 newSelection = selected;
			 return mesh;
		 }
		 Vertex v[] = (Vertex []) mesh.getVertices();
		 Edge e[] = mesh.getEdges();
		 Face f[] = mesh.getFaces();
		 Vec3 norm[] = mesh.getNormals();
		 int vertIndex[] = new int [v.length];
		 int extraVertIndex[][] = new int [v.length][];
		 int faceVertIndex[][] = new int [v.length][];
		 boolean forward[] = new boolean [v.length];
		 Vector face = new Vector(), vert = new Vector();
		 Vec3 edgeDir[] = new Vec3 [e.length];
		 Vec3 bevelDir[] = new Vec3 [e.length];
		 Vec3 extrudeDir[] = new Vec3 [e.length];
		 for (int i = 0;
		 i < e.length;
		 i++) {
			 edgeDir[i] = v[e[i].v2].r.minus(v[e[i].v1].r);
			 if (selected[i]) {
				 Vec3 avgNorm = norm[e[i].v1].plus(norm[e[i].v2]);
				 bevelDir[i] = edgeDir[i].cross(avgNorm);
				 bevelDir[i].normalize();
				 extrudeDir[i] = bevelDir[i].cross(edgeDir[i]);
				 extrudeDir[i].normalize();
			 }
		 }
		 int vertEdgeIndex[][] = new int [v.length][];
		 int vertEdgeCount[] = new int [v.length];
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 vertEdgeIndex[i] = v[i].getEdges();
			 for (int j = 0;
			 j < vertEdgeIndex[i].length;
			 j++) if (selected[vertEdgeIndex[i][j]]) vertEdgeCount[i]++;
		 }
		 int vertFaceIndex[][] = new int [v.length][];
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 vertFaceIndex[i] = new int [vertEdgeIndex[i].length];
			 int e0 = vertEdgeIndex[i][0];
			 int e1 = vertEdgeIndex[i][1];
			 int prev = e[e0].f1;
			 if (f[prev].e1 == e1 || f[prev].e2 == e1 || f[prev].e3 == e1) prev = e[e0].f2;
			 for (int j = 0;
			 j < vertFaceIndex[i].length;
			 j++) {
				 Edge ed = e[vertEdgeIndex[i][j]];
				 vertFaceIndex[i][j] = (ed.f1 == prev ? ed.f2 : ed.f1);
				 prev = vertFaceIndex[i][j];
			 }
		 }
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 if (vertEdgeCount[i] == 0) {
				 vertIndex[i] = vert.size();
				 vert.addElement(v[i]);
				 continue;
			 }
			 int edges[] = vertEdgeIndex[i];
			 double offsetDist[] = new double [edges.length];
			 for (int j = 0;
			 j < edges.length;
			 j++) if (selected[edges[j]]) {
				 Vec3 offsetDir = extrudeDir[edges[j]];
				 double dot[] = new double [edges.length];
				 double minDot = 1.0;
				 for (int k = 0;
				 k < edges.length;
				 k++) if (!selected[edges[k]]) {
					 Vec3 dir = edgeDir[vertEdgeIndex[i][k]];
					 dot[k] = Math.abs(offsetDir.dot(dir));
					 if (dot[k] < minDot) minDot = dot[k];
				 }
				 double bevelDist = width/Math.tan(Math.acos(minDot));
				 for (int k = 0;
				 k < edges.length;
				 k++) if (!selected[edges[k]]) {
					 double dist = (dot[k] == 0.0 ? width : bevelDist/dot[k]);
					 if (dist > offsetDist[k]) offsetDist[k] = dist;
				 }
			 }
			 extraVertIndex[i] = new int [edges.length];
			 for (int j = 0;
			 j < edges.length;
			 j++) {
				 if (selected[edges[j]]) {
					 extraVertIndex[i][j] = -1;
					 continue;
				 }
				 extraVertIndex[i][j] = vert.size();
				 double dist = offsetDist[j];
				 if (e[edges[j]].v2 == i) dist = -dist;
				 vert.addElement(offsetVertex(mesh, v[i], edgeDir[edges[j]].times(dist)));
			 }
			 faceVertIndex[i] = new int [edges.length];
			 for (int j = 0;
			 j < edges.length;
			 j++) {
				 int next = j+1;
				 if (next == edges.length) next = (e[edges[0]].f2 == -1 ? -1 : 0);
				 if (next == -1 || (!selected[edges[j]] && !selected[edges[next]])) continue;
				 if (!selected[edges[j]]) {
					 faceVertIndex[i][j] = extraVertIndex[i][j];
					 continue;
				 }
				 if (!selected[edges[next]]) {
					 faceVertIndex[i][j] = extraVertIndex[i][next];
					 continue;
				 }
				 faceVertIndex[i][j] = vert.size();
				 double dist1 = offsetDist[j];
				 if (e[edges[j]].v2 == i) dist1 = -dist1;
				 double dist2 = offsetDist[next];
				 if (e[edges[next]].v2 == i) dist2 = -dist2;
				 double edgeDot = edgeDir[edges[j]].dot(edgeDir[edges[next]]);
				 double m[][] = new double [][] {
					{
					1.0, edgeDot}
					, {
					edgeDot, 1.0}
				}
				;
				 double b[] = new double [] {
				dist1, dist2}
				;
				 SVD.solve(m, b);
				 Vec3 offset = edgeDir[edges[j]].times(b[0]).plus(edgeDir[edges[next]].times(b[1]));
				 vert.addElement(offsetVertex(mesh, v[i], offset));
			 }
			 Edge e0 = e[edges[0]];
			 Edge e1 = e[edges[1]];
			 Face fc = f[e0.f1];
			 int v0 = (e0.v1 == i ? e0.v2 : e0.v1);
			 int v1 = (e1.v1 == i ? e1.v2 : e1.v1);
			 forward[i] = ((fc.v1 == v0 && fc.v3 == v1) || (fc.v2 == v0 && fc.v1 == v1) || (fc.v3 == v0 && fc.v2 == v1));
		 }
		 Vec3 idealEndPos[][] = new Vec3 [e.length][];
		 for (int i = 0;
		 i < e.length;
		 i++) {
			 if (!selected[i]) continue;
			 int faceList[] = new int [e[i].f2 == -1 ? 1 : 2];
			 faceList[0] = e[i].f1;
			 if (faceList.length > 1) faceList[1] = e[i].f2;
			 int vi[] = new int [4];
			 for (int j = 0;
			 j < faceList.length;
			 j++) {
				 int v1 = -1, v2 = -1;
				 for (int k = 0;
				 k < vertFaceIndex[e[i].v1].length && v1 == -1;
				 k++) if (vertFaceIndex[e[i].v1][k] == faceList[j]) v1 = faceVertIndex[e[i].v1][k];
				 for (int k = 0;
				 k < vertFaceIndex[e[i].v2].length && v2 == -1;
				 k++) if (vertFaceIndex[e[i].v2][k] == faceList[j]) v2 = faceVertIndex[e[i].v2][k];
				 vi[j*2] = v1;
				 vi[j*2+1] = v2;
			 }
			 idealEndPos[i] = new Vec3 [2];
			 if (faceList.length == 1) {
				 Vec3 delta;
				 double d;
				 delta = ((Vertex) vert.elementAt(vi[0])).r.minus(v[e[i].v1].r);
				 d = delta.dot(extrudeDir[i]);
				 idealEndPos[i][0] = v[e[i].v1].r.plus(extrudeDir[i].times(d));
				 delta = ((Vertex) vert.elementAt(vi[1])).r.minus(v[e[i].v2].r);
				 d = delta.dot(extrudeDir[i]);
				 idealEndPos[i][1] = v[e[i].v2].r.plus(extrudeDir[i].times(d));
			 }
			 else {
				 idealEndPos[i][0] = ((Vertex) vert.elementAt(vi[0])).r.plus(((Vertex) vert.elementAt(vi[2])).r).times(0.5);
				 idealEndPos[i][1] = ((Vertex) vert.elementAt(vi[1])).r.plus(((Vertex) vert.elementAt(vi[3])).r).times(0.5);
			 }
		 }
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 if (vertEdgeCount[i] == 0) continue;
			 Vec3 ideal[] = new Vec3 [vertEdgeCount[i]];
			 int index[] = new int [vertEdgeCount[i]];
			 int num = 0;
			 int edges[] = vertEdgeIndex[i];
			 for (int j = 0;
			 j < edges.length;
			 j++) {
				 int ej = edges[j];
				 if (selected[ej]) {
					 ideal[num] = (e[ej].v1 == i ? idealEndPos[ej][0] : idealEndPos[ej][1]);
					 ideal[num].subtract(v[i].r);
					 ideal[num].add(extrudeDir[ej].times(height));
					 index[num] = ej;
					 num++;
				 }
			 }
			 vertIndex[i] = vert.size();
			 if (ideal.length == 1) {
				 vert.addElement(offsetVertex(mesh, v[i], ideal[0]));
				 continue;
			 }
			 double m[][] = new double [2*ideal.length][];
			 double b[] = new double [2*ideal.length];
			 for (int j = 0;
			 j < ideal.length;
			 j++) {
				 Vec3 dir;
				 dir = extrudeDir[index[j]];
				 m[2*j] = new double [] {
				dir.x, dir.y, dir.z}
				;
				 b[2*j] = dir.dot(ideal[j]);
				 dir = bevelDir[index[j]];
				 m[2*j+1] = new double [] {
				dir.x, dir.y, dir.z}
				;
				 b[2*j+1] = dir.dot(ideal[j]);
			 }
			 SVD.solve(m, b);
			 vert.addElement(offsetVertex(mesh, v[i], new Vec3(b[0], b[1], b[2])));
		 }
		 for (int i = 0;
		 i < f.length;
		 i++) {
			 Face fc = f[i];
			 int origVert[] = new int [] {
			fc.v1, fc.v2, fc.v2, fc.v3, fc.v3, fc.v1}
			;
			 int origEdge[] = new int [] {
			fc.e1, fc.e1, fc.e2, fc.e2, fc.e3, fc.e3}
			;
			 int newVert[] = new int [6];
			 int numVert = 0;
			 for (int j = 0;
			 j < origEdge.length;
			 j++) {
				 int index = -1;
				 int orig = origVert[j];
				 if (extraVertIndex[orig] != null) {
					 for (int k = 0;
					 k < vertEdgeIndex[orig].length;
					 k++) if (vertEdgeIndex[orig][k] == origEdge[j]) {
						 if (extraVertIndex[orig][k] == -1) {
							 for (int m = 0;
							 m < vertFaceIndex[orig].length;
							 m++) if (vertFaceIndex[orig][m] == i) {
								 index = faceVertIndex[orig][m];
								 break;
							 }
						 }
						 else index = extraVertIndex[orig][k];
						 break;
					 }
				 }
				 else index = vertIndex[origVert[j]];
				 if (index > -1 && (numVert == 0 || (index != newVert[numVert-1] && index != newVert[0]))) newVert[numVert++] = index;
			 }
			 if (numVert == 3) face.addElement(new int [] {
			newVert[0], newVert[1], newVert[2], i}
			);
			 else if (numVert == 4) {
				 face.addElement(new int [] {
				newVert[0], newVert[1], newVert[2], i}
				);
				 face.addElement(new int [] {
				newVert[0], newVert[2], newVert[3], i}
				);
			 }
			 else for (int step = 1;
			 2*step < numVert;
			 step *= 2) {
				 int start;
				 for (start = 0;
				 start+2*step < numVert;
				 start += 2*step) face.addElement(new int [] {
				newVert[start], newVert[start+step], newVert[start+2*step], i}
				);
				 if (start+step < numVert) face.addElement(new int [] {
				newVert[start], newVert[start+step], newVert[0], i}
				);
			 }
		 }
		 for (int i = 0;
		 i < v.length;
		 i++) {
			 if (extraVertIndex[i] == null) continue;
			 for (int j = 0;
			 j < extraVertIndex[i].length;
			 j++) {
				 int prev = (j == 0 ? vertEdgeIndex[i].length-1 : j-1);
				 int v1 = extraVertIndex[i][j];
				 int v2 = extraVertIndex[i][prev];
				 if (v1 == -1 || v2 == -1) continue;
				 if (forward[i]) face.addElement(new int [] {
				v1, v2, vertIndex[i], -1}
				);
				 else face.addElement(new int [] {
				v2, v1, vertIndex[i], -1}
				);
			 }
		 }
		 for (int i = 0;
		 i < e.length;
		 i++) {
			 if (!selected[i]) continue;
			 int faceList[] = new int [e[i].f2 == -1 ? 1 : 2];
			 faceList[0] = e[i].f1;
			 if (faceList.length > 1) faceList[1] = e[i].f2;
			 for (int j = 0;
			 j < faceList.length;
			 j++) {
				 int v0, v1, v2, v3;
				 v0 = vertIndex[e[i].v1];
				 v3 = vertIndex[e[i].v2];
				 v1 = v2 = -1;
				 for (int k = 0;
				 k < vertFaceIndex[e[i].v1].length && v1 == -1;
				 k++) if (vertFaceIndex[e[i].v1][k] == faceList[j]) v1 = faceVertIndex[e[i].v1][k];
				 for (int k = 0;
				 k < vertFaceIndex[e[i].v2].length && v2 == -1;
				 k++) if (vertFaceIndex[e[i].v2][k] == faceList[j]) v2 = faceVertIndex[e[i].v2][k];
				 Face fc = f[faceList[j]];
				 if ((fc.v1 == e[i].v1 && fc.v3 == e[i].v2) || (fc.v2 == e[i].v1 && fc.v1 == e[i].v2) || (fc.v3 == e[i].v1 && fc.v2 == e[i].v2)) {
					 face.addElement(new int [] {
					v0, v1, v2, -1}
					);
					 face.addElement(new int [] {
					v2, v3, v0, -1}
					);
				 }
				 else {
					 face.addElement(new int [] {
					v1, v0, v2, -1}
					);
					 face.addElement(new int [] {
					v3, v2, v0, -1}
					);
				 }
			 }
		 }
		 prepareMesh(mesh, face, vert, vertIndex);
		 Edge newe[] = mesh.getEdges();
		 for (int i = 0;
		 i < e.length;
		 i++) {
			 int v1 = vertIndex[e[i].v1];
			 int v2 = vertIndex[e[i].v2];
			 for (int j = 0;
			 j < newe.length;
			 j++)if ((v1 == newe[j].v1 && v2 == newe[j].v2) ||(v1 == newe[j].v2 && v2 == newe[j].v1)) {
				 newe[j].smoothness = e[i].smoothness;
				 break;
			 }
		 }
		 newSelection = new boolean [newe.length];
		 for (int i = 0;
		 i < e.length;
		 i++) if (selected[i]) {
			 int v1 = vertIndex[e[i].v1];
			 int v2 = vertIndex[e[i].v2];
			 for (int j = 0;
			 j < newe.length;
			 j++) if ((v1 == newe[j].v1 && v2 == newe[j].v2) || (v1 == newe[j].v2 && v2 == newe[j].v1)) {
				 newSelection[j] = true;
				 break;
			 }
		 }
		 return mesh;
	 }
	 public boolean [] getNewSelection() {
		 return newSelection;
	 }
	 private void prepareMesh(TriangleMesh mesh, Vector face, Vector vert, int vertIndex[]) {
		 int newface[][] = new int [face.size()][];
		 Vertex newvert[] = new Vertex [vert.size()];
		 for (int i = 0;
		 i < face.size();
		 i++) {
			 int f[] = (int []) face.elementAt(i);
			 newface[i] = new int [] {
			f[0], f[1], f[2]}
			;
		 }
		 for (int i = 0;
		 i < vert.size();
		 i++) newvert[i] = (Vertex) vert.elementAt(i);
		 mesh.setShape(newvert, newface);
		 ParameterValue oldParam[] = mesh.getParameterValues();
		 ParameterValue newParam[] = new ParameterValue [oldParam.length];
		 for (int i = 0;
		 i < oldParam.length;
		 i++) {
			 if (oldParam[i] instanceof VertexParameterValue) {
				 double oldval[] = ((VertexParameterValue) oldParam[i]).getValue();
				 double newval[] = new double [vert.size()];
				 double defaultVal = mesh.getParameters()[i].defaultVal;
				 for (int j = 0;
				 j < newval.length;
				 j++) newval[j] = defaultVal;
				 if (vertIndex != null) for (int j = 0;
				 j < vertIndex.length;
				 j++) newval[vertIndex[j]] = oldval[j];
				 else for (int j = 0;
				 j < oldval.length;
				 j++) newval[j] = oldval[j];
				 newParam[i] = new VertexParameterValue(newval);
			 }
			 else if (oldParam[i] instanceof FaceParameterValue) {
				 double oldval[] = ((FaceParameterValue) oldParam[i]).getValue();
				 double newval[] = new double [face.size()];
				 double defaultVal = mesh.getParameters()[i].defaultVal;
				 for (int j = 0;
				 j < newval.length;
				 j++) {
					 int f[] = (int []) face.elementAt(j);
					 if (f[3] == -1) newval[j] = defaultVal;
					 else newval[j] = oldval[f[3]];
				 }
				 newParam[i] = new FaceParameterValue(newval);
			 }
			 else if (oldParam[i] instanceof FaceVertexParameterValue) {
				 FaceVertexParameterValue fvpv = (FaceVertexParameterValue) oldParam[i];
				 double newval[][] = new double [face.size()][3];
				 double defaultVal = mesh.getParameters()[i].defaultVal;
				 for (int j = 0;
				 j < face.size();
				 j++) {
					 int f[] = (int []) face.elementAt(j);
					 if (f[3] == -1) {
						 newval[j][0] = defaultVal;
						 newval[j][1] = defaultVal;
						 newval[j][2] = defaultVal;
					 }
					 else {
						 newval[j][0] = fvpv.getValue(f[3], 0);
						 newval[j][1] = fvpv.getValue(f[3], 1);
						 newval[j][2] = fvpv.getValue(f[3], 2);
					 }
				 }
				 newParam[i] = new FaceVertexParameterValue(newval);
			 }
			 else newParam[i] = oldParam[i];
		 }
		 mesh.setParameterValues(newParam);
	 }
}",1,0,0,0
"public interface Cell {
	 int getColumnIndex();
	 int getRowIndex();
	 Sheet getSheet();
	 Row getRow();
	 void setCellType(CellType cellType);
	 void setBlank();
	 CellType getCellType();
	 CellType getCellTypeEnum();
	 CellType getCachedFormulaResultType();
	 CellType getCachedFormulaResultTypeEnum();
	 void setCellValue(double value);
	 void setCellValue(Date value);
	 void setCellValue(Calendar value);
	 void setCellValue(RichTextString value);
	 void setCellValue(String value);
	 void setCellFormula(String formula) throws FormulaParseException, IllegalStateException;
	 void removeFormula() throws IllegalStateException;
	 String getCellFormula();
	 double getNumericCellValue();
	 Date getDateCellValue();
	 RichTextString getRichStringCellValue();
	 String getStringCellValue();
	 void setCellValue(boolean value);
	 void setCellErrorValue(byte value);
	 boolean getBooleanCellValue();
	 byte getErrorCellValue();
	 void setCellStyle(CellStyle style);
	 CellStyle getCellStyle();
	 void setAsActiveCell();
	 CellAddress getAddress();
	 void setCellComment(Comment comment);
	 Comment getCellComment();
	 void removeCellComment();
	 Hyperlink getHyperlink();
	 void setHyperlink(Hyperlink link);
	 void removeHyperlink();
	 CellRangeAddress getArrayFormulaRange();
	 boolean isPartOfArrayFormulaGroup();
}",0,0,0,0
"public void read(org.apache.thrift.protocol.TProtocol iprot, add_check_constraint_result struct) throws org.apache.thrift.TException {
	 org.apache.thrift.protocol.TField schemeField;
	 iprot.readStructBegin();
	 while (true) {
		 schemeField = iprot.readFieldBegin();
		 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
			 break;
		 }
		 switch (schemeField.id) {
			 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
				 struct.o1 = new NoSuchObjectException();
				 struct.o1.read(iprot);
				 struct.setO1IsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
				 struct.o2 = new MetaException();
				 struct.o2.read(iprot);
				 struct.setO2IsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
		 }
		 iprot.readFieldEnd();
	 }
	 iprot.readStructEnd();
	 struct.validate();
 }",0,0,1,0
"public ServiceDefinition[] findServicesByToolID(final String toolId) {
	 try {
		 ensureDiskCacheLoaded();
		 accessLock.readLock().lock();
		 final boolean returnAll = toolId == null || toolId.length() == 0;
		 final List<ServiceDefinition> requestedDefinitions = new ArrayList<ServiceDefinition>();
		 for (final Map<GUID, ServiceDefinition> mapServiceInstances : mapServices.values()) {
			 for (final ServiceDefinition definition : mapServiceInstances.values()) {
				 if (returnAll || toolId.equalsIgnoreCase(definition.getToolID())) {
					 requestedDefinitions.add((ServiceDefinition) definition.clone());
				 }
			 }
		 }
		 if (requestedDefinitions.size() == 0) {
			 return null;
		 }
		 return requestedDefinitions.toArray(new ServiceDefinition[requestedDefinitions.size()]);
	 }
	 finally {
		 accessLock.readLock().unlock();
	 }
 }",0,0,1,0
"public class SimpleSnitch extends AbstractEndpointSnitch{
	 public String getRack(InetAddress endpoint) {
		 return ""rack1"";
	 }
	 public String getDatacenter(InetAddress endpoint) {
		 return ""datacenter1"";
	 }
	 public List<InetAddress> getSortedListByProximity(final InetAddress address, Collection<InetAddress> addresses) {
		 return new ArrayList<InetAddress>(addresses);
	 }
	 public void sortByProximity(final InetAddress address, List<InetAddress> addresses) {
	 }
}",0,0,0,0
"public class JpegRewriter extends BinaryFileParser {
	 private static final ByteOrder JPEG_BYTE_ORDER = ByteOrder.BIG_ENDIAN;
	 private static final SegmentFilter EXIF_SEGMENT_FILTER = new SegmentFilter() {
		 public boolean filter(final JFIFPieceSegment segment) {
			 return segment.isExifSegment();
		 }
	 }
	;
	 private static final SegmentFilter XMP_SEGMENT_FILTER = new SegmentFilter() {
		 public boolean filter(final JFIFPieceSegment segment) {
			 return segment.isXmpSegment();
		 }
	 }
	;
	 private static final SegmentFilter PHOTOSHOP_APP13_SEGMENT_FILTER = new SegmentFilter() {
		 public boolean filter(final JFIFPieceSegment segment) {
			 return segment.isPhotoshopApp13Segment();
		 }
	 }
	;
	 public JpegRewriter() {
		 setByteOrder(JPEG_BYTE_ORDER);
	 }
	 protected static class JFIFPieces {
		 public final List<JFIFPiece> pieces;
		 public final List<JFIFPiece> segmentPieces;
		 public JFIFPieces(final List<JFIFPiece> pieces, final List<JFIFPiece> segmentPieces) {
			 this.pieces = pieces;
			 this.segmentPieces = segmentPieces;
		 }
	 }
	 protected abstract static class JFIFPiece {
		 protected abstract void write(OutputStream os) throws IOException;
		 public String toString() {
			 return ""["" + this.getClass().getName() + ""]"";
		 }
	 }
	 protected static class JFIFPieceSegment extends JFIFPiece {
		 public final int marker;
		 private final byte[] markerBytes;
		 private final byte[] segmentLengthBytes;
		 private final byte[] segmentData;
		 public JFIFPieceSegment(final int marker, final byte[] segmentData) {
			 this(marker, ByteConversions.toBytes((short) marker, JPEG_BYTE_ORDER), ByteConversions.toBytes((short) (segmentData.length + 2), JPEG_BYTE_ORDER), segmentData);
		 }
		 JFIFPieceSegment(final int marker, final byte[] markerBytes, final byte[] segmentLengthBytes, final byte[] segmentData) {
			 this.marker = marker;
			 this.markerBytes = markerBytes;
			 this.segmentLengthBytes = segmentLengthBytes;
			 this.segmentData = segmentData;
		 }
		 public String toString() {
			 return ""["" + this.getClass().getName() + "" (0x"" + Integer.toHexString(marker) + "")]"";
		 }
		 protected void write(final OutputStream os) throws IOException {
			 os.write(markerBytes);
			 os.write(segmentLengthBytes);
			 os.write(segmentData);
		 }
		 public boolean isApp1Segment() {
			 return marker == JpegConstants.JPEG_APP1_MARKER;
		 }
		 public boolean isAppSegment() {
			 return marker >= JpegConstants.JPEG_APP0_MARKER && marker <= JpegConstants.JPEG_APP15_MARKER;
		 }
		 public boolean isExifSegment() {
			 if (marker != JpegConstants.JPEG_APP1_MARKER) {
				 return false;
			 }
			 if (!startsWith(segmentData, JpegConstants.EXIF_IDENTIFIER_CODE)) {
				 return false;
			 }
			 return true;
		 }
		 public boolean isPhotoshopApp13Segment() {
			 if (marker != JpegConstants.JPEG_APP13_MARKER) {
				 return false;
			 }
			 if (!new IptcParser().isPhotoshopJpegSegment(segmentData)) {
				 return false;
			 }
			 return true;
		 }
		 public boolean isXmpSegment() {
			 if (marker != JpegConstants.JPEG_APP1_MARKER) {
				 return false;
			 }
			 if (!startsWith(segmentData, JpegConstants.XMP_IDENTIFIER)) {
				 return false;
			 }
			 return true;
		 }
		 public byte[] getSegmentData() {
			 return segmentData;
		 }
	 }
	 static class JFIFPieceImageData extends JFIFPiece {
		 private final byte[] markerBytes;
		 private final byte[] imageData;
		 JFIFPieceImageData(final byte[] markerBytes, final byte[] imageData) {
			 super();
			 this.markerBytes = markerBytes;
			 this.imageData = imageData;
		 }
		 protected void write(final OutputStream os) throws IOException {
			 os.write(markerBytes);
			 os.write(imageData);
		 }
	 }
	 protected JFIFPieces analyzeJFIF(final ByteSource byteSource) throws ImageReadException, IOException {
		 final List<JFIFPiece> pieces = new ArrayList<>();
		 final List<JFIFPiece> segmentPieces = new ArrayList<>();
		 final JpegUtils.Visitor visitor = new JpegUtils.Visitor() {
			 public boolean beginSOS() {
				 return true;
			 }
			 public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {
				 pieces.add(new JFIFPieceImageData(markerBytes, imageData));
			 }
			 public boolean visitSegment(final int marker, final byte[] markerBytes, final int segmentLength, final byte[] segmentLengthBytes, final byte[] segmentData) throws ImageReadException, IOException {
				 final JFIFPiece piece = new JFIFPieceSegment(marker, markerBytes, segmentLengthBytes, segmentData);
				 pieces.add(piece);
				 segmentPieces.add(piece);
				 return true;
			 }
		 }
		;
		 new JpegUtils().traverseJFIF(byteSource, visitor);
		 return new JFIFPieces(pieces, segmentPieces);
	 }
	 private interface SegmentFilter {
		 boolean filter(JFIFPieceSegment segment);
	 }
	 protected <T extends JFIFPiece> List<T> removeXmpSegments(final List<T> segments) {
		 return filterSegments(segments, XMP_SEGMENT_FILTER);
	 }
	 protected <T extends JFIFPiece> List<T> removePhotoshopApp13Segments( final List<T> segments) {
		 return filterSegments(segments, PHOTOSHOP_APP13_SEGMENT_FILTER);
	 }
	 protected <T extends JFIFPiece> List<T> findPhotoshopApp13Segments( final List<T> segments) {
		 return filterSegments(segments, PHOTOSHOP_APP13_SEGMENT_FILTER, true);
	 }
	 protected <T extends JFIFPiece> List<T> removeExifSegments(final List<T> segments) {
		 return filterSegments(segments, EXIF_SEGMENT_FILTER);
	 }
	 protected <T extends JFIFPiece> List<T> filterSegments(final List<T> segments, final SegmentFilter filter) {
		 return filterSegments(segments, filter, false);
	 }
	 protected <T extends JFIFPiece> List<T> filterSegments(final List<T> segments, final SegmentFilter filter, final boolean reverse) {
		 final List<T> result = new ArrayList<>();
		 for (final T piece : segments) {
			 if (piece instanceof JFIFPieceSegment) {
				 if (filter.filter((JFIFPieceSegment) piece) ^ !reverse) {
					 result.add(piece);
				 }
			 }
			 else if (!reverse) {
				 result.add(piece);
			 }
		 }
		 return result;
	 }
	 protected <T extends JFIFPiece, U extends JFIFPiece> List<JFIFPiece> insertBeforeFirstAppSegments( final List<T> segments, final List<U> newSegments) throws ImageWriteException {
		 int firstAppIndex = -1;
		 for (int i = 0;
		 i < segments.size();
		 i++) {
			 final JFIFPiece piece = segments.get(i);
			 if (!(piece instanceof JFIFPieceSegment)) {
				 continue;
			 }
			 final JFIFPieceSegment segment = (JFIFPieceSegment) piece;
			 if (segment.isAppSegment()) {
				 if (firstAppIndex == -1) {
					 firstAppIndex = i;
				 }
			 }
		 }
		 final List<JFIFPiece> result = new ArrayList<JFIFPiece>(segments);
		 if (firstAppIndex == -1) {
			 throw new ImageWriteException(""JPEG file has no APP segments."");
		 }
		 result.addAll(firstAppIndex, newSegments);
		 return result;
	 }
	 protected <T extends JFIFPiece, U extends JFIFPiece> List<JFIFPiece> insertAfterLastAppSegments( final List<T> segments, final List<U> newSegments) throws ImageWriteException {
		 int lastAppIndex = -1;
		 for (int i = 0;
		 i < segments.size();
		 i++) {
			 final JFIFPiece piece = segments.get(i);
			 if (!(piece instanceof JFIFPieceSegment)) {
				 continue;
			 }
			 final JFIFPieceSegment segment = (JFIFPieceSegment) piece;
			 if (segment.isAppSegment()) {
				 lastAppIndex = i;
			 }
		 }
		 final List<JFIFPiece> result = new ArrayList<JFIFPiece>(segments);
		 if (lastAppIndex == -1) {
			 if (segments.size() < 1) {
				 throw new ImageWriteException(""JPEG file has no APP segments."");
			 }
			 result.addAll(1, newSegments);
		 }
		 else {
			 result.addAll(lastAppIndex + 1, newSegments);
		 }
		 return result;
	 }
	 protected void writeSegments(final OutputStream outputStream, final List<? extends JFIFPiece> segments) throws IOException {
		 try (DataOutputStream os = new DataOutputStream(outputStream)) {
			 JpegConstants.SOI.writeTo(os);
			 for (final JFIFPiece piece : segments) {
				 piece.write(os);
			 }
		 }
	 }
	 public static class JpegSegmentOverflowException extends ImageWriteException {
		 private static final long serialVersionUID = -1062145751550646846L;
		 public JpegSegmentOverflowException(final String message) {
			 super(message);
		 }
	 }
}",1,0,0,0
"protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) {
	 int nNodes, nHeap, n1, n2, i, j, k;
	 boolean tooLong;
	 int[] heap = new int[MAX_ALPHA_SIZE + 2];
	 int[] weight = new int[MAX_ALPHA_SIZE * 2];
	 int[] parent = new int[MAX_ALPHA_SIZE * 2];
	 for (i = 0;
	 i < alphaSize;
	 i++) {
		 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
	 }
	 while (true) {
		 nNodes = alphaSize;
		 nHeap = 0;
		 heap[0] = 0;
		 weight[0] = 0;
		 parent[0] = -2;
		 for (i = 1;
		 i <= alphaSize;
		 i++) {
			 parent[i] = -1;
			 nHeap++;
			 heap[nHeap] = i;
			 {
				 int zz, tmp;
				 zz = nHeap;
				 tmp = heap[zz];
				 while (weight[tmp] < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
		 }
		 if (!(nHeap < (MAX_ALPHA_SIZE + 2))) {
			 panic();
		 }
		 while (nHeap > 1) {
			 n1 = heap[1];
			 heap[1] = heap[nHeap];
			 nHeap--;
			 {
				 int zz = 0, yy = 0, tmp = 0;
				 zz = 1;
				 tmp = heap[zz];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
			 }
			 n2 = heap[1];
			 heap[1] = heap[nHeap];
			 nHeap--;
			 {
				 int zz = 0, yy = 0, tmp = 0;
				 zz = 1;
				 tmp = heap[zz];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
			 }
			 nNodes++;
			 parent[n1] = parent[n2] = nNodes;
			 weight[nNodes] = ((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) | (1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));
			 parent[nNodes] = -1;
			 nHeap++;
			 heap[nHeap] = nNodes;
			 {
				 int zz = 0, tmp = 0;
				 zz = nHeap;
				 tmp = heap[zz];
				 while (weight[tmp] < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
		 }
		 if (!(nNodes < (MAX_ALPHA_SIZE * 2))) {
			 panic();
		 }
		 tooLong = false;
		 for (i = 1;
		 i <= alphaSize;
		 i++) {
			 j = 0;
			 k = i;
			 while (parent[k] >= 0) {
				 k = parent[k];
				 j++;
			 }
			 len[i - 1] = (char) j;
			 if (j > maxLen) {
				 tooLong = true;
			 }
		 }
		 if (!tooLong) {
			 break;
		 }
		 for (i = 1;
		 i < alphaSize;
		 i++) {
			 j = weight[i] >> 8;
			 j = 1 + (j / 2);
			 weight[i] = j << 8;
		 }
	 }
 }",0,0,1,0
"public class NativeJavaConstructor extends BaseFunction{
	 static final long serialVersionUID = -8149253217482668463L;
	 MemberBox ctor;
	 public NativeJavaConstructor(MemberBox ctor) {
		 this.ctor = ctor;
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return NativeJavaClass.constructSpecific(cx, scope, args, ctor);
	 }
	 public String getFunctionName() {
		 String sig = JavaMembers.liveConnectSignature(ctor.argTypes);
		 return ""<init>"".concat(sig);
	 }
	 public String toString() {
		 return ""[JavaConstructor "" + ctor.getName() + ""]"";
	 }
}",0,0,0,0
"public Boolean handleAddCatalogItem(Object catalogItemBeingAdded) {
	 return isEntitledToAddCatalogItem(context, catalogItemBeingAdded);
 }",0,0,0,0
"public class ConnectionLoadBalanceServer {
	 private static final Logger logger = LoggerFactory.getLogger(ConnectionLoadBalanceServer.class);
	 private final String hostname;
	 private final int port;
	 private final SSLContext sslContext;
	 private final ExecutorService threadPool;
	 private final LoadBalanceProtocol loadBalanceProtocol;
	 private final int connectionTimeoutMillis;
	 private final int numThreads;
	 private final EventReporter eventReporter;
	 private volatile Set<CommunicateAction> communicationActions = Collections.emptySet();
	 private final BlockingQueue<Socket> connectionQueue = new LinkedBlockingQueue<>();
	 private volatile AcceptConnection acceptConnection;
	 private volatile ServerSocket serverSocket;
	 private volatile boolean stopped = true;
	 public ConnectionLoadBalanceServer(final String hostname, final int port, final SSLContext sslContext, final int numThreads, final LoadBalanceProtocol loadBalanceProtocol, final EventReporter eventReporter, final int connectionTimeoutMillis) {
		 this.hostname = hostname;
		 this.port = port;
		 this.sslContext = sslContext;
		 this.loadBalanceProtocol = loadBalanceProtocol;
		 this.connectionTimeoutMillis = connectionTimeoutMillis;
		 this.numThreads = numThreads;
		 this.eventReporter = eventReporter;
		 threadPool = new FlowEngine(numThreads, ""Load Balance Server"");
	 }
	 public void start() throws IOException {
		 if (!stopped) {
			 return;
		 }
		 stopped = false;
		 if (serverSocket != null) {
			 return;
		 }
		 try {
			 serverSocket = createServerSocket();
		 }
		 catch (final Exception e) {
			 throw new IOException(""Could not begin listening for incoming connections in order to load balance data across the cluster. Please verify the values of the "" + ""'nifi.cluster.load.balance.port' and 'nifi.cluster.load.balance.host' properties as well as the 'nifi.security.*' properties"", e);
		 }
		 final Set<CommunicateAction> actions = new HashSet<>(numThreads);
		 for (int i=0;
		 i < numThreads;
		 i++) {
			 final CommunicateAction action = new CommunicateAction(loadBalanceProtocol);
			 actions.add(action);
			 threadPool.submit(action);
		 }
		 this.communicationActions = actions;
		 acceptConnection = new AcceptConnection(serverSocket);
		 final Thread receiveConnectionThread = new Thread(acceptConnection);
		 receiveConnectionThread.setName(""Receive Queue Load-Balancing Connections"");
		 receiveConnectionThread.start();
	 }
	 public int getPort() {
		 return serverSocket.getLocalPort();
	 }
	 public void stop() {
		 stopped = false;
		 threadPool.shutdown();
		 if (acceptConnection != null) {
			 acceptConnection.stop();
		 }
		 communicationActions.forEach(CommunicateAction::stop);
		 Socket socket;
		 while ((socket = connectionQueue.poll()) != null) {
			 try {
				 socket.close();
				 logger.info(""{
				}
				 Closed connection to {
				}
				 on Server stop"", this, socket.getRemoteSocketAddress());
			 }
			 catch (final IOException ioe) {
				 logger.warn(""Failed to properly close socket to "" + socket.getRemoteSocketAddress(), ioe);
			 }
		 }
	 }
	 private ServerSocket createServerSocket() throws IOException {
		 final InetAddress inetAddress = hostname == null ? null : InetAddress.getByName(hostname);
		 if (sslContext == null) {
			 return new ServerSocket(port, 50, InetAddress.getByName(hostname));
		 }
		 else {
			 final ServerSocket serverSocket = sslContext.getServerSocketFactory().createServerSocket(port, 50, inetAddress);
			 ((SSLServerSocket) serverSocket).setNeedClientAuth(true);
			 return serverSocket;
		 }
	 }
	 private class CommunicateAction implements Runnable {
		 private final LoadBalanceProtocol loadBalanceProtocol;
		 private volatile boolean stopped = false;
		 public CommunicateAction(final LoadBalanceProtocol loadBalanceProtocol) {
			 this.loadBalanceProtocol = loadBalanceProtocol;
		 }
		 public void stop() {
			 this.stopped = true;
		 }
		 public void run() {
			 String peerDescription = ""<Unknown Client>"";
			 while (!stopped) {
				 Socket socket = null;
				 try {
					 socket = connectionQueue.poll(1, TimeUnit.SECONDS);
					 if (socket == null) {
						 continue;
					 }
					 peerDescription = socket.getRemoteSocketAddress().toString();
					 if (socket.isClosed()) {
						 logger.debug(""Connection to Peer {
						}
						 is closed. Will not attempt to communicate over this Socket."", peerDescription);
						 continue;
					 }
					 logger.debug(""Receiving FlowFiles from Peer {
					}
					"", peerDescription);
					 loadBalanceProtocol.receiveFlowFiles(socket);
					 if (socket.isConnected()) {
						 logger.debug(""Finished receiving FlowFiles from Peer {
						}
						. Will recycle connection."", peerDescription);
						 connectionQueue.offer(socket);
					 }
					 else {
						 logger.debug(""Finished receiving FlowFiles from Peer {
						}
						. Socket is no longer connected so will not recycle connection."", peerDescription);
					 }
				 }
				 catch (final Exception e) {
					 if (socket != null) {
						 try {
							 socket.close();
						 }
						 catch (final IOException ioe) {
							 e.addSuppressed(ioe);
						 }
					 }
					 logger.error(""Failed to communicate with Peer {
					}
					"", peerDescription, e);
					 eventReporter.reportEvent(Severity.ERROR, ""Load Balanced Connection"", ""Failed to receive FlowFiles for Load Balancing due to "" + e);
				 }
			 }
			 logger.info(""Connection Load Balance Server shutdown. Will no longer handle incoming requests."");
		 }
	 }
	 private class AcceptConnection implements Runnable {
		 private final ServerSocket serverSocket;
		 private volatile boolean stopped = false;
		 public AcceptConnection(final ServerSocket serverSocket) {
			 this.serverSocket = serverSocket;
		 }
		 public void stop() {
			 stopped = true;
		 }
		 public void run() {
			 try {
				 serverSocket.setSoTimeout(1000);
			 }
			 catch (final Exception e) {
				 logger.error(""Failed to set soTimeout on Server Socket for Load Balancing data across cluster"", e);
			 }
			 while (!stopped) {
				 try {
					 final Socket socket;
					 try {
						 socket = serverSocket.accept();
					 }
					 catch (final SocketTimeoutException ste) {
						 continue;
					 }
					 socket.setSoTimeout(connectionTimeoutMillis);
					 connectionQueue.offer(socket);
				 }
				 catch (final Exception e) {
					 logger.error(""{
					}
					 Failed to accept connection from other node in cluster"", ConnectionLoadBalanceServer.this, e);
				 }
			 }
			 try {
				 serverSocket.close();
			 }
			 catch (final Exception e) {
				 logger.warn(""Failed to properly shutdown Server Socket for Load Balancing"", e);
			 }
		 }
	 }
	 public String toString() {
		 return ""ConnectionLoadBalanceServer[hostname="" + hostname + "", port="" + port + "", secure="" + (sslContext != null) + ""]"";
	 }
}",1,0,0,0
"public class AccessRoleCreatorImpl extends AbstractKapuaEntityCreator<AccessRole> implements AccessRoleCreator {
	 private static final long serialVersionUID = 972154225756734130L;
	 private KapuaId accessInfo;
	 private KapuaId roleId;
	 public AccessRoleCreatorImpl(KapuaId scopeId) {
		 super(scopeId);
	 }
	 public KapuaId getAccessInfoId() {
		 return accessInfo;
	 }
	 public void setAccessInfoId(KapuaId accessInfo) {
		 this.accessInfo = accessInfo;
	 }
	 public KapuaId getRoleId() {
		 return roleId;
	 }
	 public void setRoleId(KapuaId roleId) {
		 this.roleId = roleId;
	 }
}",0,1,0,0
"public class TarResource extends ArchiveResource {
	 private String userName = """";
	 private String groupName = """";
	 private int uid;
	 private int gid;
	 public TarResource() {
	 }
	 public TarResource(File a, TarEntry e) {
		 super(a, true);
		 setEntry(e);
	 }
	 public TarResource(Resource a, TarEntry e) {
		 super(a, true);
		 setEntry(e);
	 }
	 public InputStream getInputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getInputStream();
		 }
		 Resource archive = getArchive();
		 final TarInputStream i = new TarInputStream(archive.getInputStream());
		 TarEntry te = null;
		 while ((te = i.getNextEntry()) != null) {
			 if (te.getName().equals(getName())) {
				 return i;
			 }
		 }
		 FileUtils.close(i);
		 throw new BuildException(""no entry "" + getName() + "" in "" + getArchive());
	 }
	 public OutputStream getOutputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getOutputStream();
		 }
		 throw new UnsupportedOperationException( ""Use the tar task for tar output."");
	 }
	 public String getUserName() {
		 if (isReference()) {
			 return ((TarResource) getCheckedRef()).getUserName();
		 }
		 checkEntry();
		 return userName;
	 }
	 public String getGroup() {
		 if (isReference()) {
			 return ((TarResource) getCheckedRef()).getGroup();
		 }
		 checkEntry();
		 return groupName;
	 }
	 public int getUid() {
		 if (isReference()) {
			 return ((TarResource) getCheckedRef()).getUid();
		 }
		 checkEntry();
		 return uid;
	 }
	 public int getGid() {
		 if (isReference()) {
			 return ((TarResource) getCheckedRef()).getGid();
		 }
		 checkEntry();
		 return gid;
	 }
	 protected void fetchEntry() {
		 Resource archive = getArchive();
		 TarInputStream i = null;
		 try {
			 i = new TarInputStream(archive.getInputStream());
			 TarEntry te = null;
			 while ((te = i.getNextEntry()) != null) {
				 if (te.getName().equals(getName())) {
					 setEntry(te);
					 return;
				 }
			 }
		 }
		 catch (IOException e) {
			 log(e.getMessage(), Project.MSG_DEBUG);
			 throw new BuildException(e);
		 }
		 finally {
			 if (i != null) {
				 FileUtils.close(i);
			 }
		 }
		 setEntry(null);
	 }
	 private void setEntry(TarEntry e) {
		 if (e == null) {
			 setExists(false);
			 return;
		 }
		 setName(e.getName());
		 setExists(true);
		 setLastModified(e.getModTime().getTime());
		 setDirectory(e.isDirectory());
		 setSize(e.getSize());
		 setMode(e.getMode());
		 userName = e.getUserName();
		 groupName = e.getGroupName();
		 uid = e.getUserId();
		 gid = e.getGroupId();
	 }
}",0,0,0,0
"public void createBatchTargetInstances(AbstractTarget aTarget, Schedule aSchedule, TargetGroup aGroup, boolean checkAgency) {
	 int objectType = aTarget.getObjectType();
	 if( objectType == AbstractTarget.TYPE_TARGET || ( objectType == AbstractTarget.TYPE_GROUP && aGroup.getSipType() == TargetGroup.ONE_SIP ) ) {
		 if(checkAgency && !aTarget.getOwner().getAgency().equals(aSchedule.getOwningUser().getAgency())) {
			 return;
		 }
		 else if(!aTarget.isSchedulable()) {
			 return;
		 }
		 else {
			 Set<TargetInstance> targetInstances = new HashSet<TargetInstance>();
			 int daysToSchedule = EnvironmentFactory.getEnv().getDaysToSchedule();
			 Calendar cal = Calendar.getInstance();
			 cal.setTime(new Date());
			 cal.add(Calendar.DAY_OF_MONTH, daysToSchedule);
			 Date scheduleTill = aSchedule.getEndDate() == null ? cal.getTime() : DateUtils.earliestDate(aSchedule.getEndDate(), cal.getTime());
			 Date startFrom = targetDao.getLatestScheduledDate(aTarget, aSchedule);
			 if(startFrom == null) {
				 startFrom = new Date();
			 }
			 startFrom = DateUtils.latestDate(startFrom, aSchedule.getStartDate());
			 List<Annotation> targetAnnotations = getAnnotations(aTarget);
			 boolean firstForTarget = false;
			 for(startFrom = aSchedule.getNextExecutionDate(startFrom);
			 startFrom != null && startFrom.before(scheduleTill);
			 startFrom = aSchedule.getNextExecutionDate(startFrom)) {
				 TargetInstance ti = new TargetInstance();
				 ti.setTarget(aTarget);
				 ti.setSchedule(aSchedule);
				 ti.setScheduledTime(startFrom);
				 ti.setOwner(aSchedule.getOwningUser());
				 if ( !firstForTarget && instanceManager.countTargetInstancesByTarget(aTarget.getOid()) == 0 ) {
					 ti.setFirstFromTarget(true);
					 firstForTarget = true;
				 }
				 if( objectType == AbstractTarget.TYPE_TARGET ) {
					 for (Iterator<Annotation> i = targetAnnotations.iterator( );
					 i.hasNext();
					 ) {
						 Annotation toCopy = i.next();
						 if (toCopy.isAlertable()) {
							 Annotation annotation = new Annotation();
							 annotation.setDate(toCopy.getDate());
							 annotation.setNote(toCopy.getNote());
							 annotation.setAlertable(true);
							 annotation.setUser(toCopy.getUser());
							 annotation.setObjectType(TargetInstance.class.getName());
							 ti.addAnnotation(annotation);
						 }
					 }
					 ti.setUseAQA(isTargetUsingAQA(aTarget.getOid()));
				 }
				 targetInstances.add(ti);
			 }
			 for(TargetInstance toSave: targetInstances) {
				 targetInstanceDao.save(toSave);
				 for(Annotation anno : toSave.getAnnotations()) {
					 anno.setObjectOid(toSave.getOid());
				 }
				 annotationDAO.saveAnnotations(toSave.getAnnotations());
				 log.debug("" Saved TI: "" + toSave.getOid());
			 }
			 log.debug("" Created "" + targetInstances.size());
		 }
	 }
	 else if(objectType == AbstractTarget.TYPE_GROUP && aGroup.getSipType() == TargetGroup.MANY_SIP ) {
		 for(GroupMember member: aGroup.getChildren()) {
			 AbstractTarget child = targetDao.load(member.getChild().getOid());
			 if(child.getObjectType() == AbstractTarget.TYPE_GROUP) {
				 continue;
			 }
			 createBatchTargetInstances(child, aSchedule, null, checkAgency);
		 }
		 return;
	 }
	 else {
		 String type = null;
		 if(aTarget instanceof TargetGroup) {
			 type = """" + ((TargetGroup) aTarget).getSipType();
		 }
		 throw new WCTRuntimeException(""Unknown Target Type: "" + aTarget.getClass() + "" ("" + type + "")"");
	 }
 }",0,0,1,0
"public final class NamedMethodGenerator extends MethodGenerator {
	 protected static final int CURRENT_INDEX = 4;
	 private static final int PARAM_START_INDEX = 5;
	 public NamedMethodGenerator(int access_flags, Type return_type,Type[] arg_types, String[] arg_names,String method_name, String class_name,InstructionList il, ConstantPoolGen cp) {
		super(access_flags, return_type, arg_types, arg_names, method_name, class_name, il, cp);
	 }
	 public int getLocalIndex(String name) {
		if (name.equals(""current"")) {
			 return CURRENT_INDEX;
		}
		return super.getLocalIndex(name);
	 }
	 public Instruction loadParameter(int index) {
		 return new ALOAD(index + PARAM_START_INDEX);
	 }
	 public Instruction storeParameter(int index) {
		 return new ASTORE(index + PARAM_START_INDEX);
	 }
}",0,0,0,0
"public class HBaseStorage extends LoadFunc implements StoreFuncInterface, LoadPushDown, OrderedLoadFunc, StoreResources, CollectableLoadFunc {
	 private static final Log LOG = LogFactory.getLog(HBaseStorage.class);
	 private final static String STRING_CASTER = ""UTF8StorageConverter"";
	 private final static String BYTE_CASTER = ""HBaseBinaryConverter"";
	 private final static String CASTER_PROPERTY = ""pig.hbase.caster"";
	 private final static String ASTERISK = ""*"";
	 private final static String COLON = "":"";
	 private final static String HBASE_SECURITY_CONF_KEY = ""hbase.security.authentication"";
	 private final static String HBASE_CONFIG_SET = ""hbase.config.set"";
	 private final static String HBASE_TOKEN_SET = ""hbase.token.set"";
	 private List<ColumnInfo> columnInfo_ = Lists.newArrayList();
	 private JobConf m_conf;
	 private RecordReader reader;
	 private RecordWriter writer;
	 private TableOutputFormat outputFormat = null;
	 private Scan scan;
	 private String contextSignature = null;
	 private final CommandLine configuredOptions_;
	 private final static Options validOptions_ = new Options();
	 private final static CommandLineParser parser_ = new GnuParser();
	 private boolean loadRowKey_;
	 private String delimiter_;
	 private boolean ignoreWhitespace_;
	 private final long limit_;
	 private final boolean cacheBlocks_;
	 private final int caching_;
	 private boolean noWAL_;
	 private final long minTimestamp_;
	 private final long maxTimestamp_;
	 private final long timestamp_;
	 private boolean includeTimestamp_;
	 private boolean includeTombstone_;
	 protected transient byte[] gt_;
	 protected transient byte[] gte_;
	 protected transient byte[] lt_;
	 protected transient byte[] lte_;
	 private String regex_;
	 private LoadCaster caster_;
	 private ResourceSchema schema_;
	 private RequiredFieldList requiredFieldList;
	 private static void populateValidOptions() {
		 Option loadKey = OptionBuilder.hasOptionalArgs(1).withArgName(""loadKey"").withLongOpt(""loadKey"").withDescription(""Load Key"").create();
		 validOptions_.addOption(loadKey);
		 validOptions_.addOption(""gt"", true, ""Records must be greater than this value "" + ""(binary, double-slash-escaped)"");
		 validOptions_.addOption(""lt"", true, ""Records must be less than this value (binary, double-slash-escaped)"");
		 validOptions_.addOption(""gte"", true, ""Records must be greater than or equal to this value"");
		 validOptions_.addOption(""lte"", true, ""Records must be less than or equal to this value"");
		 validOptions_.addOption(""regex"", true, ""Record must match this regular expression"");
		 validOptions_.addOption(""cacheBlocks"", true, ""Set whether blocks should be cached for the scan"");
		 validOptions_.addOption(""caching"", true, ""Number of rows scanners should cache"");
		 validOptions_.addOption(""limit"", true, ""Per-region limit"");
		 validOptions_.addOption(""maxResultsPerColumnFamily"", true, ""Limit the maximum number of values returned per row per column family"");
		 validOptions_.addOption(""delim"", true, ""Column delimiter"");
		 validOptions_.addOption(""ignoreWhitespace"", true, ""Ignore spaces when parsing columns"");
		 validOptions_.addOption(""caster"", true, ""Caster to use for converting values. A class name, "" + ""HBaseBinaryConverter, or Utf8StorageConverter. For storage, casters must implement LoadStoreCaster."");
		 Option noWal = OptionBuilder.hasOptionalArgs(1).withArgName(""noWAL"").withLongOpt(""noWAL"").withDescription(""Sets the write ahead to false for faster loading. To be used with extreme caution since this could result in data loss (see http: validOptions_.addOption(noWal);
		 validOptions_.addOption(""minTimestamp"", true, ""Record must have timestamp greater or equal to this value"");
		 validOptions_.addOption(""maxTimestamp"", true, ""Record must have timestamp less then this value"");
		 validOptions_.addOption(""timestamp"", true, ""Record must have timestamp equal to this value"");
		 validOptions_.addOption(""includeTimestamp"", false, ""Record will include the timestamp after the rowkey on store (rowkey, timestamp, ...)"");
		 validOptions_.addOption(""includeTombstone"", false, ""Record will include a tombstone marker on store after the rowKey and timestamp (if included) (rowkey, [timestamp,] tombstone, ...)"");
	 }
	 public HBaseStorage(String columnList) throws ParseException, IOException {
		 this(columnList,"""");
	 }
	 public HBaseStorage(String columnList, String optString) throws ParseException, IOException {
		 populateValidOptions();
		 String[] optsArr = optString.split("" "");
		 try {
			 configuredOptions_ = parser_.parse(validOptions_, optsArr);
		 }
		 catch (ParseException e) {
			 HelpFormatter formatter = new HelpFormatter();
			 formatter.printHelp( ""[-loadKey] [-gt] [-gte] [-lt] [-lte] [-regex] [-cacheBlocks] [-caching] [-caster] [-noWAL] [-limit] [-maxResultsPerColumnFamily] [-delim] [-ignoreWhitespace] [-minTimestamp] [-maxTimestamp] [-timestamp] [-includeTimestamp] [-includeTombstone]"", validOptions_ );
			 throw e;
		 }
		loadRowKey_ = false;
		if (configuredOptions_.hasOption(""loadKey"")) {
			String value = configuredOptions_.getOptionValue(""loadKey"");
			if (""true"".equalsIgnoreCase(value) || """".equalsIgnoreCase(value) || value == null ) {
				loadRowKey_ = true;
			}
		}
		 delimiter_ = "","";
		 if (configuredOptions_.getOptionValue(""delim"") != null) {
			 delimiter_ = configuredOptions_.getOptionValue(""delim"");
		 }
		 ignoreWhitespace_ = true;
		 if (configuredOptions_.hasOption(""ignoreWhitespace"")) {
			 String value = configuredOptions_.getOptionValue(""ignoreWhitespace"");
			 if (!""true"".equalsIgnoreCase(value)) {
				 ignoreWhitespace_ = false;
			 }
		 }
		 columnInfo_ = parseColumnList(columnList, delimiter_, ignoreWhitespace_);
		 String defaultCaster = UDFContext.getUDFContext().getClientSystemProps() != null ? UDFContext.getUDFContext().getClientSystemProps().getProperty(CASTER_PROPERTY, STRING_CASTER) : STRING_CASTER;
		 String casterOption = configuredOptions_.getOptionValue(""caster"", defaultCaster);
		 if (STRING_CASTER.equalsIgnoreCase(casterOption)) {
			 caster_ = new Utf8StorageConverter();
		 }
		 else if (BYTE_CASTER.equalsIgnoreCase(casterOption)) {
			 caster_ = new HBaseBinaryConverter();
		 }
		 else {
			 try {
				 caster_ = (LoadCaster) PigContext.instantiateFuncFromSpec(casterOption);
			 }
			 catch (ClassCastException e) {
				 LOG.error(""Configured caster does not implement LoadCaster interface."");
				 throw new IOException(e);
			 }
			 catch (RuntimeException e) {
				 LOG.error(""Configured caster class not found."", e);
				 throw new IOException(e);
			 }
		 }
		 LOG.debug(""Using caster "" + caster_.getClass());
		 caching_ = Integer.valueOf(configuredOptions_.getOptionValue(""caching"", ""100""));
		 cacheBlocks_ = Boolean.valueOf(configuredOptions_.getOptionValue(""cacheBlocks"", ""false""));
		 limit_ = Long.valueOf(configuredOptions_.getOptionValue(""limit"", ""-1""));
		 noWAL_ = false;
		if (configuredOptions_.hasOption(""noWAL"")) {
			String value = configuredOptions_.getOptionValue(""noWAL"");
			if (""true"".equalsIgnoreCase(value) || """".equalsIgnoreCase(value) || value == null) {
				noWAL_ = true;
			}
		}
		 if (configuredOptions_.hasOption(""minTimestamp"")){
			 minTimestamp_ = Long.parseLong(configuredOptions_.getOptionValue(""minTimestamp""));
		 }
		 else {
			 minTimestamp_ = 0;
		 }
		 if (configuredOptions_.hasOption(""maxTimestamp"")){
			 maxTimestamp_ = Long.parseLong(configuredOptions_.getOptionValue(""maxTimestamp""));
		 }
		 else {
			 maxTimestamp_ = Long.MAX_VALUE;
		 }
		 if (configuredOptions_.hasOption(""timestamp"")){
			 timestamp_ = Long.parseLong(configuredOptions_.getOptionValue(""timestamp""));
		 }
		 else {
			 timestamp_ = 0;
		 }
		 includeTimestamp_ = false;
		 if (configuredOptions_.hasOption(""includeTimestamp"")) {
			 String value = configuredOptions_.getOptionValue(""includeTimestamp"");
			 if (""true"".equalsIgnoreCase(value) || """".equalsIgnoreCase(value) || value == null ) {
				 includeTimestamp_ = true;
			 }
		 }
		 includeTombstone_ = false;
		 if (configuredOptions_.hasOption(""includeTombstone"")) {
			 String value = configuredOptions_.getOptionValue(""includeTombstone"");
			 if (""true"".equalsIgnoreCase(value) || """".equalsIgnoreCase(value) || value == null ) {
				 includeTombstone_ = true;
			 }
		 }
		 initScan();
	 }
	 private Properties getUDFProperties() {
		 return UDFContext.getUDFContext() .getUDFProperties(this.getClass(), new String[] {
		contextSignature}
		);
	 }
	 private String projectedFieldsName() {
		 return contextSignature + ""_projectedFields"";
	 }
	 private List<ColumnInfo> parseColumnList(String columnList, String delimiter, boolean ignoreWhitespace) {
		 List<ColumnInfo> columnInfo = new ArrayList<ColumnInfo>();
		 String[] colNames = columnList.split(delimiter);
		 if(ignoreWhitespace) {
			 List<String> columns = new ArrayList<String>();
			 for (String colName : colNames) {
				 String[] subColNames = colName.split("" "");
				 for (String subColName : subColNames) {
					 subColName = subColName.trim();
					 if (subColName.length() > 0) columns.add(subColName);
				 }
			 }
			 colNames = columns.toArray(new String[columns.size()]);
		 }
		 for (String colName : colNames) {
			 columnInfo.add(new ColumnInfo(colName));
		 }
		 return columnInfo;
	 }
	 private void initScan() throws IOException{
		 scan = new Scan();
		 scan.setCacheBlocks(cacheBlocks_);
		 scan.setCaching(caching_);
		 if (configuredOptions_.hasOption(""gt"")) {
			 gt_ = Bytes.toBytesBinary(Utils.slashisize(configuredOptions_.getOptionValue(""gt"")));
			 addRowFilter(CompareOp.GREATER, gt_);
			 scan.setStartRow(gt_);
		 }
		 if (configuredOptions_.hasOption(""lt"")) {
			 lt_ = Bytes.toBytesBinary(Utils.slashisize(configuredOptions_.getOptionValue(""lt"")));
			 addRowFilter(CompareOp.LESS, lt_);
			 scan.setStopRow(lt_);
		 }
		 if (configuredOptions_.hasOption(""gte"")) {
			 gte_ = Bytes.toBytesBinary(Utils.slashisize(configuredOptions_.getOptionValue(""gte"")));
			 scan.setStartRow(gte_);
		 }
		 if (configuredOptions_.hasOption(""lte"")) {
			 lte_ = Bytes.toBytesBinary(Utils.slashisize(configuredOptions_.getOptionValue(""lte"")));
			 byte[] lt = increment(lte_);
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(String.format(""Incrementing lte value of %s from bytes %s to %s to set stop row"", Bytes.toString(lte_), toString(lte_), toString(lt)));
			 }
			 if (lt != null) {
				 scan.setStopRow(increment(lte_));
			 }
			 addFilter(new WhileMatchFilter(new RowFilter(CompareOp.LESS_OR_EQUAL, new BinaryComparator(lte_))));
		 }
		 if (configuredOptions_.hasOption(""regex"")) {
			 regex_ = Utils.slashisize(configuredOptions_.getOptionValue(""regex""));
			 addFilter(new RowFilter(CompareOp.EQUAL, new RegexStringComparator(regex_)));
		 }
		 if (configuredOptions_.hasOption(""minTimestamp"") || configuredOptions_.hasOption(""maxTimestamp"")){
			 scan.setTimeRange(minTimestamp_, maxTimestamp_);
		 }
		 if (configuredOptions_.hasOption(""timestamp"")){
			 scan.setTimeStamp(timestamp_);
		 }
		 if (configuredOptions_.hasOption(""maxResultsPerColumnFamily"")){
			 int maxResultsPerColumnFamily_ = Integer.valueOf(configuredOptions_.getOptionValue(""maxResultsPerColumnFamily""));
			 scan.setMaxResultsPerColumnFamily(maxResultsPerColumnFamily_);
		 }
		 boolean columnPrefixExists = false;
		 for (ColumnInfo columnInfo : columnInfo_) {
			 if (columnInfo.getColumnPrefix() != null) {
				 columnPrefixExists = true;
				 break;
			 }
		 }
		 if (!columnPrefixExists) {
			 addFiltersWithoutColumnPrefix(columnInfo_);
		 }
		 else {
			 addFiltersWithColumnPrefix(columnInfo_);
		 }
	 }
	 private void addFiltersWithoutColumnPrefix(List<ColumnInfo> columnInfos) {
		 Map<String, List<ColumnInfo>> groupedMap = groupByFamily(columnInfos);
		 for (Entry<String, List<ColumnInfo>> entrySet : groupedMap.entrySet()) {
			 boolean onlyColumns = true;
			 for (ColumnInfo columnInfo : entrySet.getValue()) {
				 if (columnInfo.isColumnMap()) {
					 onlyColumns = false;
					 break;
				 }
			 }
			 if (onlyColumns) {
				 for (ColumnInfo columnInfo : entrySet.getValue()) {
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""Adding column to scan via addColumn with cf:name = "" + Bytes.toString(columnInfo.getColumnFamily()) + "":"" + Bytes.toString(columnInfo.getColumnName()));
					 }
					 scan.addColumn(columnInfo.getColumnFamily(), columnInfo.getColumnName());
				 }
			 }
			 else {
				 String family = entrySet.getKey();
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Adding column family to scan via addFamily with cf:name = "" + family);
				 }
				 scan.addFamily(Bytes.toBytes(family));
			 }
		 }
	 }
	 private void addFiltersWithColumnPrefix(List<ColumnInfo> columnInfos) {
		 FilterList allColumnFilters = null;
		 Map<String, List<ColumnInfo>> groupedMap = groupByFamily(columnInfos);
		 for (String cfString : groupedMap.keySet()) {
			 List<ColumnInfo> columnInfoList = groupedMap.get(cfString);
			 byte[] cf = Bytes.toBytes(cfString);
			 if (allColumnFilters == null) {
				 allColumnFilters = new FilterList(FilterList.Operator.MUST_PASS_ONE);
			 }
			 FilterList thisColumnGroupFilter = new FilterList(FilterList.Operator.MUST_PASS_ALL);
			 thisColumnGroupFilter.addFilter(new FamilyFilter(CompareOp.EQUAL, new BinaryComparator(cf)));
			 FilterList columnFilters = new FilterList(FilterList.Operator.MUST_PASS_ONE);
			 for (ColumnInfo colInfo : columnInfoList) {
				 if (colInfo.isColumnMap()) {
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""Adding family:prefix filters with values "" + Bytes.toString(colInfo.getColumnFamily()) + COLON + Bytes.toString(colInfo.getColumnPrefix()));
					 }
					 if (colInfo.getColumnPrefix() != null) {
						 columnFilters.addFilter(new ColumnPrefixFilter( colInfo.getColumnPrefix()));
					 }
				 }
				 else {
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""Adding family:descriptor filters with values "" + Bytes.toString(colInfo.getColumnFamily()) + COLON + Bytes.toString(colInfo.getColumnName()));
					 }
					 columnFilters.addFilter(new QualifierFilter(CompareOp.EQUAL, new BinaryComparator(colInfo.getColumnName())));
				 }
			 }
			 if (columnFilters.getFilters().size() != 0) {
				 thisColumnGroupFilter.addFilter(columnFilters);
			 }
			 allColumnFilters.addFilter(thisColumnGroupFilter);
		 }
		 if (allColumnFilters != null) {
			 addFilter(allColumnFilters);
		 }
	 }
	 private void addRowFilter(CompareOp op, byte[] val) {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Adding filter "" + op.toString() + "" with value "" + Bytes.toStringBinary(val));
		 }
		 addFilter(new RowFilter(op, new BinaryComparator(val)));
	 }
	 private void addFilter(Filter filter) {
		 FilterList scanFilter = (FilterList) scan.getFilter();
		 if (scanFilter == null) {
			 scanFilter = new FilterList(FilterList.Operator.MUST_PASS_ALL);
		 }
		 scanFilter.addFilter(filter);
		 scan.setFilter(scanFilter);
	 }
	 public List<ColumnInfo> getColumnInfoList() {
		 return columnInfo_;
	 }
	 protected void setColumnInfoList(List<ColumnInfo> columnInfoList) {
		 this.columnInfo_ = columnInfoList;
	 }
	 protected void storeProjectedFieldNames(RequiredFieldList requiredFieldList) throws FrontendException {
		 try {
			 getUDFProperties().setProperty(projectedFieldsName(), ObjectSerializer.serialize(requiredFieldList));
		 }
		 catch (IOException e) {
			 throw new FrontendException(e);
		 }
	 }
	 public Tuple getNext() throws IOException {
		 try {
			 if (reader.nextKeyValue()) {
				 ImmutableBytesWritable rowKey = (ImmutableBytesWritable) reader .getCurrentKey();
				 Result result = (Result) reader.getCurrentValue();
				 int tupleSize = columnInfo_.size();
				 NavigableMap<byte[], NavigableMap<byte[], byte[]>> resultsMap = result.getNoVersionMap();
				 if (loadRowKey_){
					 tupleSize++;
				 }
				 Tuple tuple=TupleFactory.getInstance().newTuple(tupleSize);
				 int startIndex=0;
				 if (loadRowKey_){
					 tuple.set(0, new DataByteArray(rowKey.get()));
					 startIndex++;
				 }
				 for (int i = 0;
				i < columnInfo_.size();
				 ++i){
					 int currentIndex = startIndex + i;
					 ColumnInfo columnInfo = columnInfo_.get(i);
					 if (columnInfo.isColumnMap()) {
						 NavigableMap<byte[], byte[]> cfResults = resultsMap.get(columnInfo.getColumnFamily());
						 Map<String, DataByteArray> cfMap = new HashMap<String, DataByteArray>();
						 if (cfResults != null) {
							 for (byte[] quantifier : cfResults.keySet()) {
								 if (columnInfo.getColumnPrefix() == null || columnInfo.hasPrefixMatch(quantifier)) {
									 byte[] cell = cfResults.get(quantifier);
									 DataByteArray value = cell == null ? null : new DataByteArray(cell);
									 cfMap.put(Bytes.toString(quantifier), value);
								 }
							 }
						 }
						 tuple.set(currentIndex, cfMap);
					 }
					 else {
						 byte[] cell=result.getValue(columnInfo.getColumnFamily(), columnInfo.getColumnName());
						 DataByteArray value = cell == null ? null : new DataByteArray(cell);
						 tuple.set(currentIndex, value);
					 }
				 }
				 if (LOG.isDebugEnabled()) {
					 for (int i = 0;
					 i < tuple.size();
					 i++) {
						 LOG.debug(""tuple value:"" + tuple.get(i));
					 }
				 }
				 return tuple;
			 }
		 }
		 catch (InterruptedException e) {
			 throw new IOException(e);
		 }
		 return null;
	 }
	 public InputFormat getInputFormat() {
		 TableInputFormat inputFormat = new HBaseTableIFBuilder() .withLimit(limit_) .withGt(gt_) .withGte(gte_) .withLt(lt_) .withLte(lte_) .withConf(m_conf) .build();
		 inputFormat.setScan(scan);
		 return inputFormat;
	 }
	 public void prepareToRead(RecordReader reader, PigSplit split) {
		 this.reader = reader;
	 }
	 public void setUDFContextSignature(String signature) {
		 this.contextSignature = signature;
	 }
	 public void setLocation(String location, Job job) throws IOException {
		 Properties udfProps = getUDFProperties();
		 job.getConfiguration().setBoolean(""pig.noSplitCombination"", true);
		 m_conf = initializeLocalJobConfig(job);
		 String tablename = location;
		 if (location.startsWith(""hbase: tablename = location.substring(8);
	 }
	 m_conf.set(TableInputFormat.INPUT_TABLE, tablename);
	 String projectedFields = udfProps.getProperty( projectedFieldsName() );
	 if (projectedFields != null) {
		 pushProjection((RequiredFieldList) ObjectSerializer.deserialize(projectedFields));
	 }
	 addFiltersWithoutColumnPrefix(columnInfo_);
	 if (requiredFieldList != null) {
		 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[] {
		contextSignature}
		);
		 p.setProperty(contextSignature + ""_projectedFields"", ObjectSerializer.serialize(requiredFieldList));
	 }
 }
 public List<String> getShipFiles() {
	 try {
		 Configuration conf = new Configuration();
		 TableMapReduceUtil.addHBaseDependencyJars(conf);
		 if (conf.get(""tmpjars"") != null) {
			 String[] tmpjars = conf.getStrings(""tmpjars"");
			 List<String> shipFiles = new ArrayList<String>(tmpjars.length);
			 for (String tmpjar : tmpjars) {
				 shipFiles.add(new URL(tmpjar).getPath());
			 }
			 return shipFiles;
		 }
	 }
	 catch (IOException e) {
		 if(e instanceof MalformedURLException){
			 LOG.debug(""TableMapReduceUtils#addHBaseDependencyJars tmpjars"" + "" had malformed url. Falling back to previous logic."", e);
		 }
		else {
			 LOG.debug(""TableMapReduceUtils#addHBaseDependencyJars invocation"" + "" failed. Falling back to previous logic."", e);
		 }
	 }
	 List<Class> classList = new ArrayList<Class>();
	 classList.add(org.apache.hadoop.hbase.client.HTable.class);
	 classList.add(org.apache.hadoop.hbase.mapreduce.TableSplit.class);
	 classList.add(org.apache.zookeeper.ZooKeeper.class);
	 addClassToList(""org.cloudera.htrace.Trace"", classList);
	 addClassToList(""org.apache.hadoop.hbase.protobuf.generated.HBaseProtos"", classList);
	 addClassToList(""org.apache.hadoop.hbase.TableName"", classList);
	 addClassToList(""org.apache.hadoop.hbase.CompatibilityFactory"", classList);
	 addClassToList(""org.jboss.netty.channel.ChannelFactory"", classList);
	 return FuncUtils.getShipFiles(classList);
 }
 public void addCredentials(Credentials credentials, Configuration conf) {
	 JobConf jobConf = initializeLocalJobConfig(conf);
	 if (""kerberos"".equalsIgnoreCase(jobConf.get(HBASE_SECURITY_CONF_KEY))) {
		 LOG.info(""hbase is configured to use Kerberos, attempting to fetch delegation token."");
		 try {
			 User currentUser = User.getCurrent();
			 UserGroupInformation currentUserGroupInformation = currentUser.getUGI();
			 if (currentUserGroupInformation.hasKerberosCredentials()) {
				 try (Connection connection = ConnectionFactory.createConnection(jobConf, currentUser)) {
					 TokenUtil.obtainTokenForJob(connection, jobConf, currentUser);
					 LOG.info(""Token retrieval succeeded for user "" + currentUser.getName());
					 credentials.addAll(jobConf.getCredentials());
				 }
			 }
			 else {
				 LOG.info(""Not fetching hbase delegation token as no Kerberos TGT is available for user "" + currentUser.getName());
			 }
		 }
		 catch (RuntimeException re) {
			 throw re;
		 }
		 catch (Exception e) {
			 throw new UndeclaredThrowableException(e, ""Unexpected error calling TokenUtil.obtainTokenForJob()"");
		 }
	 }
	 else {
		 LOG.info(""hbase is not configured to use kerberos, skipping delegation token"");
	 }
 }
 private void addClassToList(String className, List<Class> classList) {
	 try {
		 Class klass = Class.forName(className);
		 classList.add(klass);
	 }
	 catch (ClassNotFoundException e) {
		 LOG.debug(""Skipping adding jar for class: "" + className);
	 }
 }
 private JobConf initializeLocalJobConfig(Configuration jobConf) {
	 Properties udfProps = getUDFProperties();
	 JobConf localConf = new JobConf(jobConf);
	 if (udfProps.containsKey(HBASE_CONFIG_SET)) {
		 for (Entry<Object, Object> entry : udfProps.entrySet()) {
			 localConf.set((String) entry.getKey(), (String) entry.getValue());
		 }
	 }
	 else {
		 Configuration hbaseConf = HBaseConfiguration.create();
		 for (Entry<String, String> entry : hbaseConf) {
			 if (jobConf.get(entry.getKey()) == null) {
				 udfProps.setProperty(entry.getKey(), entry.getValue());
				 localConf.set(entry.getKey(), entry.getValue());
			 }
		 }
		 udfProps.setProperty(HBASE_CONFIG_SET, ""true"");
	 }
	 return localConf;
 }
 private JobConf initializeLocalJobConfig(Job job) {
	 return initializeLocalJobConfig(job.getConfiguration());
 }
 public String relativeToAbsolutePath(String location, Path curDir) throws IOException {
	 return location;
 }
 public LoadCaster getLoadCaster() throws IOException {
	 return caster_;
 }
 public OutputFormat getOutputFormat() throws IOException {
	 if (outputFormat == null) {
		 if (m_conf == null) {
			 throw new IllegalStateException(""setStoreLocation has not been called"");
		 }
		 else {
			 this.outputFormat = new TableOutputFormat();
			 this.outputFormat.setConf(m_conf);
		 }
	 }
	 return outputFormat;
 }
 public void checkSchema(ResourceSchema s) throws IOException {
	 if (! (caster_ instanceof LoadStoreCaster)) {
		 LOG.error(""Caster must implement LoadStoreCaster for writing to HBase."");
		 throw new IOException(""Bad Caster "" + caster_.getClass());
	 }
	 schema_ = s;
	 getUDFProperties().setProperty(contextSignature + ""_schema"", ObjectSerializer.serialize(schema_));
 }
 public void prepareToWrite( RecordWriter writer) throws IOException {
	 this.writer = writer;
 }
 public void putNext(Tuple t) throws IOException {
	 ResourceFieldSchema[] fieldSchemas = (schema_ == null) ? null : schema_.getFields();
	 byte type = (fieldSchemas == null) ? DataType.findType(t.get(0)) : fieldSchemas[0].getType();
	 long ts;
	 int startIndex=1;
	 if (includeTimestamp_) {
		 byte timestampType = (fieldSchemas == null) ? DataType.findType(t.get(startIndex)) : fieldSchemas[startIndex].getType();
		 LoadStoreCaster caster = (LoadStoreCaster) caster_;
		 switch (timestampType) {
			 case DataType.BYTEARRAY: ts = caster.bytesToLong(((DataByteArray)t.get(startIndex)).get());
			 break;
			 case DataType.LONG: ts = ((Long)t.get(startIndex)).longValue();
			 break;
			 case DataType.DATETIME: ts = ((DateTime)t.get(startIndex)).getMillis();
			 break;
			 default: throw new IOException(""Unable to find a converter for timestamp field "" + t.get(startIndex));
		 }
		 startIndex++;
	 }
	 else {
		 ts = System.currentTimeMillis();
	 }
	 if (includeTombstone_) {
		 if (((Boolean)t.get(startIndex)).booleanValue()) {
			 Delete delete = createDelete(t.get(0), type, ts);
			 try {
				 writer.write(null, delete);
				 return;
			 }
			 catch (InterruptedException e) {
				 throw new IOException(e);
			 }
		 }
		 startIndex++;
	 }
	 Put put = createPut(t.get(0), type);
	 if (LOG.isDebugEnabled()) {
		 LOG.debug(""putNext -- WAL disabled: "" + noWAL_);
		 for (ColumnInfo columnInfo : columnInfo_) {
			 LOG.debug(""putNext -- col: "" + columnInfo);
		 }
	 }
	 for (int i=startIndex;
	i<t.size();
	++i){
		 ColumnInfo columnInfo = columnInfo_.get(i-startIndex);
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""putNext - tuple: "" + i + "", value="" + t.get(i) + "", cf:column="" + columnInfo);
		 }
		 if (!columnInfo.isColumnMap()) {
			 put.addColumn(columnInfo.getColumnFamily(), columnInfo.getColumnName(), ts, objToBytes(t.get(i), (fieldSchemas == null) ? DataType.findType(t.get(i)) : fieldSchemas[i].getType()));
		 }
		 else {
			 Map<String, Object> cfMap = (Map<String, Object>) t.get(i);
			 if (cfMap!=null) {
				 for (String colName : cfMap.keySet()) {
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""putNext - colName="" + colName + "", class: "" + colName.getClass());
					 }
					 put.addColumn(columnInfo.getColumnFamily(), Bytes.toBytes(colName.toString()), ts, objToBytes(cfMap.get(colName), DataType.findType(cfMap.get(colName))));
				 }
			 }
		 }
	 }
	 try {
		 if (!put.isEmpty()) {
			 writer.write(null, put);
		 }
	 }
	 catch (InterruptedException e) {
		 throw new IOException(e);
	 }
 }
 public Delete createDelete(Object key, byte type, long timestamp) throws IOException {
	 Delete delete = new Delete(objToBytes(key, type));
	 delete.setTimestamp(timestamp);
	 if(noWAL_) {
		 delete.setDurability(Durability.SKIP_WAL);
	 }
	 return delete;
 }
 public Put createPut(Object key, byte type) throws IOException {
	 Put put = new Put(objToBytes(key, type));
	 if(noWAL_) {
		 put.setDurability(Durability.SKIP_WAL);
	 }
	 return put;
 }
 private byte[] objToBytes(Object o, byte type) throws IOException {
	 LoadStoreCaster caster = (LoadStoreCaster) caster_;
	 if (o == null) return null;
	 switch (type) {
		 case DataType.BYTEARRAY: return ((DataByteArray) o).get();
		 case DataType.BAG: return caster.toBytes((DataBag) o);
		 case DataType.CHARARRAY: return caster.toBytes((String) o);
		 case DataType.DOUBLE: return caster.toBytes((Double) o);
		 case DataType.FLOAT: return caster.toBytes((Float) o);
		 case DataType.INTEGER: return caster.toBytes((Integer) o);
		 case DataType.LONG: return caster.toBytes((Long) o);
		 case DataType.BIGINTEGER: return caster.toBytes((BigInteger) o);
		 case DataType.BIGDECIMAL: return caster.toBytes((BigDecimal) o);
		 case DataType.BOOLEAN: return caster.toBytes((Boolean) o);
		 case DataType.DATETIME: return caster.toBytes((DateTime) o);
		 case DataType.MAP: return caster.toBytes((Map<String, Object>) o);
		 case DataType.NULL: return null;
		 case DataType.TUPLE: return caster.toBytes((Tuple) o);
		 case DataType.ERROR: throw new IOException(""Unable to determine type of "" + o.getClass());
		 default: throw new IOException(""Unable to find a converter for tuple field "" + o);
	 }
 }
 public String relToAbsPathForStoreLocation(String location, Path curDir) throws IOException {
	 return location;
 }
 public void setStoreFuncUDFContextSignature(String signature) {
	 this.contextSignature = signature;
 }
 public void setStoreLocation(String location, Job job) throws IOException {
	 if (location.startsWith(""hbase: job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, location.substring(8));
 }
else{
	 job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, location);
 }
 String serializedSchema = getUDFProperties().getProperty(contextSignature + ""_schema"");
 if (serializedSchema!= null) {
	 schema_ = (ResourceSchema) ObjectSerializer.deserialize(serializedSchema);
 }
 m_conf = initializeLocalJobConfig(job);
 }
 public void cleanupOnFailure(String location, Job job) throws IOException {
 }
 public void cleanupOnSuccess(String location, Job job) throws IOException {
 }
 public List<OperatorSet> getFeatures() {
 return Arrays.asList(LoadPushDown.OperatorSet.PROJECTION);
 }
 public RequiredFieldResponse pushProjection( RequiredFieldList requiredFieldList) throws FrontendException {
 List<RequiredField> requiredFields = requiredFieldList.getFields();
 List<ColumnInfo> newColumns = Lists.newArrayListWithExpectedSize(requiredFields.size());
 if (this.requiredFieldList != null) {
	 LOG.debug(""projection is already set. skipping."");
	 return new RequiredFieldResponse(true);
 }
 int colOffset = loadRowKey_ ? 1 : 0;
 int projOffset = colOffset;
 this.requiredFieldList = requiredFieldList;
 if (requiredFieldList != null && requiredFields.size() > (columnInfo_.size() + colOffset)) {
	 throw new FrontendException(""The list of columns to project from HBase ("" + requiredFields.size() + "") is larger than HBaseStorage is configured to load ("" + (columnInfo_.size() + colOffset) + "")."");
 }
 storeProjectedFieldNames(requiredFieldList);
 if (loadRowKey_ && ( requiredFields.size() < 1 || requiredFields.get(0).getIndex() != 0)) {
	 loadRowKey_ = false;
	 projOffset = 0;
 }
 for (int i = projOffset;
 i < requiredFields.size();
 i++) {
	 int fieldIndex = requiredFields.get(i).getIndex();
	 newColumns.add(columnInfo_.get(fieldIndex - colOffset));
 }
 if (LOG.isDebugEnabled()) {
	 LOG.debug(""pushProjection After Projection: loadRowKey is "" + loadRowKey_) ;
	 for (ColumnInfo colInfo : newColumns) {
		 LOG.debug(""pushProjection -- col: "" + colInfo);
	 }
 }
 setColumnInfoList(newColumns);
 return new RequiredFieldResponse(true);
 }
 public void ensureAllKeyInstancesInSameSplit() throws IOException {
 LOG.debug(""ensureAllKeyInstancesInSameSplit"");
 }
 public WritableComparable<TableSplit> getSplitComparable(InputSplit split) throws IOException {
 if (split instanceof TableSplit) {
	 return new TableSplitComparable((TableSplit) split);
 }
 else {
	 throw new RuntimeException(""LoadFunc expected split of type TableSplit but was "" + split.getClass().getName());
 }
 }
 public class ColumnInfo {
 final String originalColumnName;
 final byte[] columnFamily;
 final byte[] columnName;
 final byte[] columnPrefix;
 public ColumnInfo(String colName) {
	 originalColumnName = colName;
	 String[] cfAndColumn = colName.split(COLON, 2);
	 columnFamily = Bytes.toBytes(cfAndColumn[0]);
	 if (cfAndColumn.length > 1 && cfAndColumn[1].length() > 0 && !ASTERISK.equals(cfAndColumn[1])) {
		 if (cfAndColumn[1].endsWith(ASTERISK)) {
			 columnPrefix = Bytes.toBytes(cfAndColumn[1].substring(0, cfAndColumn[1].length() - 1));
			 columnName = null;
		 }
		 else {
			 columnName = Bytes.toBytes(cfAndColumn[1]);
			 columnPrefix = null;
		 }
	 }
	 else {
		 columnPrefix = null;
		 columnName = null;
	 }
 }
 public byte[] getColumnFamily() {
	 return columnFamily;
 }
 public byte[] getColumnName() {
	 return columnName;
 }
 public byte[] getColumnPrefix() {
	 return columnPrefix;
 }
 public boolean isColumnMap() {
	 return columnName == null;
 }
 public boolean hasPrefixMatch(byte[] qualifier) {
	 return Bytes.startsWith(qualifier, columnPrefix);
 }
 public String toString() {
	 return originalColumnName;
 }
 }
 static Map<String, List<ColumnInfo>> groupByFamily(List<ColumnInfo> columnInfos) {
 Map<String, List<ColumnInfo>> groupedMap = new HashMap<String, List<ColumnInfo>>();
 for (ColumnInfo columnInfo : columnInfos) {
	 String cf = Bytes.toString(columnInfo.getColumnFamily());
	 List<ColumnInfo> columnInfoList = groupedMap.get(cf);
	 if (columnInfoList == null) {
		 columnInfoList = new ArrayList<ColumnInfo>();
	 }
	 columnInfoList.add(columnInfo);
	 groupedMap.put(cf, columnInfoList);
 }
 return groupedMap;
 }
 static String toString(byte[] bytes) {
 if (bytes == null) {
	 return null;
 }
 StringBuffer sb = new StringBuffer();
 for (int i = 0;
 i < bytes.length;
 i++) {
	 if (i > 0) {
		 sb.append(""|"");
	 }
	 sb.append(bytes[i]);
 }
 return sb.toString();
 }
 static byte[] increment(byte[] bytes) {
 boolean allAtMax = true;
 for(int i = 0;
 i < bytes.length;
 i++) {
	 if((bytes[bytes.length - i - 1] & 0x0ff) != 255) {
		 allAtMax = false;
		 break;
	 }
 }
 if (allAtMax) {
	 return Arrays.copyOf(bytes, bytes.length + 1);
 }
 byte[] incremented = bytes.clone();
 for(int i = bytes.length - 1;
 i >= 0;
 i--) {
	 boolean carry = false;
	 int val = bytes[i] & 0x0ff;
	 int total = val + 1;
	 if(total > 255) {
		 carry = true;
		 total %= 256;
	 }
	 else if (total < 0) {
		 carry = true;
	 }
	 incremented[i] = (byte)total;
	 if (!carry) return incremented;
 }
 return incremented;
 }
 public Boolean supportsParallelWriteToStoreLocation() {
 return true;
 }
}",1,0,0,0
"private static void handleSnapshots(NodeCommand nc, String tag, String[] cmdArgs, NodeProbe probe) throws InterruptedException, IOException {
	 int length = cmdArgs.length > 1 ? cmdArgs.length - 1 : 0;
	 String[] keyspaces = new String[length];
	 for (int i = 0;
	 i < keyspaces.length;
	 i++) keyspaces[i] = cmdArgs[i + 1];
	 switch (nc) {
		 case SNAPSHOT : if (tag == null || tag.equals("""")) tag = new Long(System.currentTimeMillis()).toString();
		 probe.takeSnapshot(tag, keyspaces);
		 System.out.println(""Snapshot directory: "" + tag);
		 break;
		 case CLEARSNAPSHOT : probe.clearSnapshot(tag, keyspaces);
		 break;
	 }
 }",0,0,0,0
"public class ByteBufferObjectPoolConfig extends PoolConfig {
	public ByteBufferObjectPoolConfig() {
		super();
	}
	public ByteBufferObjectPoolConfig(PoolConfig poolConfig) {
		setMaxActive(poolConfig.getMaxActive());
		setMaxIdle(poolConfig.getMaxIdle());
		setInitSize(poolConfig.getInitSize());
	}
	public String toXML(String pad) {
		if(pad==null) pad="""";
		StringBuffer sb = new StringBuffer();
		sb.append(pad+""<byte-buffer-object-pool>\n"");
		sb.append(pad+""\t<max-active>""+getMaxActive()+""</max-active>\n"");
		sb.append(pad+""\t<max-idle>""+getMaxIdle()+""</max-idle>\n"");
		sb.append(pad+""\t<init-size>""+getInitSize()+""</init-size>\n"");
		sb.append(pad+""</byte-buffer-object-pool>\n"");
		return sb.toString();
	}
}",0,1,0,0
"public Map<String, String> getTokenToEndpointMap() {
	 return ssProxy.getTokenToEndpointMap();
 }",0,0,0,0
"public class Procfile extends HashMap<String, String> {
	private static final long serialVersionUID = 1L;
	public static Procfile load(InputStream inputStream) throws IOException {
		Procfile procfile = new Procfile();
		BufferedReader reader = null;
		try {
			String line = null;
			reader = new BufferedReader(new InputStreamReader(inputStream));
			while ((line = reader.readLine()) != null) {
				if (line.isEmpty() || line.trim().isEmpty())continue;
				line = line.trim();
				String[] p = line.split("":"", 2);
				 if (p.length == 2)procfile.put(p[0], p[1]);
			}
			return procfile;
		}
		 finally {
			if (reader != null)reader.close();
		}
	}
}",0,0,0,0
"public class SummaryJUnitResultFormatter implements JUnitResultFormatter, JUnitTaskMirror.SummaryJUnitResultFormatterMirror {
	 private static final double ONE_SECOND = 1000.0;
	 private NumberFormat nf = NumberFormat.getInstance();
	 private OutputStream out;
	 private boolean withOutAndErr = false;
	 private String systemOutput = null;
	 private String systemError = null;
	 public SummaryJUnitResultFormatter() {
	 }
	 public void startTestSuite(JUnitTest suite) {
		 String newLine = System.getProperty(""line.separator"");
		 StringBuffer sb = new StringBuffer(""Running "");
		 sb.append(suite.getName());
		 sb.append(newLine);
		 try {
			 out.write(sb.toString().getBytes());
			 out.flush();
		 }
		 catch (IOException ioex) {
			 throw new BuildException(""Unable to write summary output"", ioex);
		 }
	 }
	 public void startTest(Test t) {
	 }
	 public void endTest(Test test) {
	 }
	 public void addFailure(Test test, Throwable t) {
	 }
	 public void addFailure(Test test, AssertionFailedError t) {
		 addFailure(test, (Throwable) t);
	 }
	 public void addError(Test test, Throwable t) {
	 }
	 public void setOutput(OutputStream out) {
		 this.out = out;
	 }
	 public void setSystemOutput(String out) {
		 systemOutput = out;
	 }
	 public void setSystemError(String err) {
		 systemError = err;
	 }
	 public void setWithOutAndErr(boolean value) {
		 withOutAndErr = value;
	 }
	 public void endTestSuite(JUnitTest suite) throws BuildException {
		 String newLine = System.getProperty(""line.separator"");
		 StringBuffer sb = new StringBuffer(""Tests run: "");
		 sb.append(suite.runCount());
		 sb.append("", Failures: "");
		 sb.append(suite.failureCount());
		 sb.append("", Errors: "");
		 sb.append(suite.errorCount());
		 sb.append("", Time elapsed: "");
		 sb.append(nf.format(suite.getRunTime() / ONE_SECOND));
		 sb.append("" sec"");
		 sb.append(newLine);
		 if (withOutAndErr) {
			 if (systemOutput != null && systemOutput.length() > 0) {
				 sb.append(""Output:"").append(newLine).append(systemOutput) .append(newLine);
			 }
			 if (systemError != null && systemError.length() > 0) {
				 sb.append(""Error: "").append(newLine).append(systemError) .append(newLine);
			 }
		 }
		 try {
			 out.write(sb.toString().getBytes());
			 out.flush();
		 }
		 catch (IOException ioex) {
			 throw new BuildException(""Unable to write summary output"", ioex);
		 }
		 finally {
			 if (out != System.out && out != System.err) {
				 try {
					 out.close();
				 }
				 catch (IOException e) {
				 }
			 }
		 }
	 }
}",0,0,0,0
"public final class HostsSupportImpl {
	 public static final String LOCALHOST_PROPERTIES_FILENAME = ""localhost"" + Storage.DEFAULT_PROPERTIES_EXT;
	 private static final String HOSTS_STORAGE_DIRNAME = ""hosts"";
	 private static final Object hostsStorageDirectoryStringLock = new Object();
	 private static String hostsStorageDirectoryString;
	 public static String getStorageDirectoryString() {
		 synchronized(hostsStorageDirectoryStringLock) {
			 if (hostsStorageDirectoryString == null) hostsStorageDirectoryString = Storage.getPersistentStorageDirectoryString() + File.separator + HOSTS_STORAGE_DIRNAME;
			 return hostsStorageDirectoryString;
		 }
	 }
}",0,0,0,0
"class BufferedHttpServletResponse implements HttpServletResponse{
	private StringBufferWriter sbw = new StringBufferWriter();
	private PrintWriter pw = new PrintWriter(sbw);
	private List<Cookie> cookies;
	private int status = -1;
	private Map<String, Object> headers;
	private HttpServletResponse realResponse;
	private String redirect;
	private String contentType;
	private byte[] byteBuffer;
	private Locale locale;
	private String encoding;
	public BufferedHttpServletResponse(HttpServletResponse realResponse){
		this.realResponse = realResponse;
	}
	public void addCookie(Cookie cookie){
		isOpen();
		if (cookies == null){
			cookies = new ArrayList<Cookie>(2);
		}
		cookies.add(cookie);
	}
	public boolean containsHeader(String name){
		isOpen();
		if (headers == null){
			return false;
		}
		return headers.containsKey(name);
	}
	public String encodeURL(String url){
		isOpen();
		return realResponse.encodeURL(url);
	}
	public String encodeRedirectURL(String url){
		isOpen();
		return realResponse.encodeRedirectURL(url);
	}
	public String encodeUrl(String url){
		isOpen();
		return realResponse.encodeURL(url);
	}
	public String encodeRedirectUrl(String url){
		isOpen();
		return realResponse.encodeRedirectURL(url);
	}
	public void sendError(int sc, String msg) throws IOException{
		isOpen();
		realResponse.sendError(sc, msg);
	}
	public void sendError(int sc) throws IOException{
		isOpen();
		realResponse.sendError(sc);
	}
	public void sendRedirect(String location) throws IOException{
		isOpen();
		redirect = location;
	}
	public String getRedirectUrl(){
		isOpen();
		return redirect;
	}
	private void testAndCreateHeaders(){
		isOpen();
		if (headers == null){
			headers = new HashMap<String, Object>();
		}
	}
	private void isOpen(){
		if (realResponse == null){
			throw new WicketRuntimeException(""the buffered servlet response already closed."");
		}
	}
	private void addHeaderObject(String name, Object object){
		Object previousObject = headers.get(name);
		if (previousObject == null){
			headers.put(name, object);
		}
		else if (previousObject instanceof List){
			((List<Object>)previousObject).add(object);
		}
		else{
			ArrayList<Object> list = new ArrayList<Object>();
			list.add(previousObject);
			list.add(object);
			headers.put(name, list);
		}
	}
	public void setDateHeader(String name, long date){
		testAndCreateHeaders();
		headers.put(name, date);
	}
	public void addDateHeader(String name, long date){
		testAndCreateHeaders();
		addHeaderObject(name, date);
	}
	public void setHeader(String name, String value){
		testAndCreateHeaders();
		headers.put(name, value);
	}
	public void addHeader(String name, String value){
		testAndCreateHeaders();
		addHeaderObject(name, value);
	}
	public void setIntHeader(String name, int value){
		testAndCreateHeaders();
		headers.put(name, new Integer(value));
	}
	public void addIntHeader(String name, int value){
		testAndCreateHeaders();
		addHeaderObject(name, value);
	}
	public void setStatus(int statusCode){
		status = statusCode;
	}
	public void setStatus(int sc, String sm){
		throw new UnsupportedOperationException(""not supported in the buffered http response, use setStatus(int)"");
	}
	public String getCharacterEncoding(){
		isOpen();
		return encoding;
	}
	public void setCharacterEncoding(String encoding){
		this.encoding = encoding;
	}
	public ServletOutputStream getOutputStream() throws IOException{
		throw new UnsupportedOperationException(""Cannot get output stream on BufferedResponse"");
	}
	public PrintWriter getWriter() throws IOException{
		isOpen();
		return pw;
	}
	public void setContentLength(int len){
		isOpen();
	}
	public void setContentType(String type){
		isOpen();
		contentType = type;
	}
	public String getContentType(){
		return contentType;
	}
	public void setBufferSize(int size){
		isOpen();
	}
	public int getBufferSize(){
		isOpen();
		return Integer.MAX_VALUE;
	}
	public void flushBuffer() throws IOException{
		isOpen();
	}
	public void resetBuffer(){
		isOpen();
		sbw.reset();
	}
	public boolean isCommitted(){
		return pw == null;
	}
	public void reset(){
		resetBuffer();
		headers = null;
		cookies = null;
	}
	public void setLocale(Locale loc){
		isOpen();
		locale = loc;
	}
	public Locale getLocale(){
		isOpen();
		if (locale == null){
			return realResponse.getLocale();
		}
		return locale;
	}
	public int getContentLength(){
		isOpen();
		return sbw.getStringBuffer().length();
	}
	public final void filter(Response response){
		isOpen();
		AppendingStringBuffer buffer = sbw.getStringBuffer();
		if (redirect == null && buffer.length() != 0){
			buffer = response.filter(buffer);
			sbw.setStringBuffer(buffer);
		}
	}
	public void close(){
		isOpen();
		pw.close();
		byteBuffer = convertToCharset(sbw.getStringBuffer(), getCharacterEncoding());
		pw = null;
		sbw = null;
		realResponse = null;
	}
	private static byte[] convertToCharset(final AppendingStringBuffer output, final String encoding){
		if (encoding == null){
			throw new WicketRuntimeException(""Internal error: encoding must not be null"");
		}
		final ByteArrayOutputStream baos = new ByteArrayOutputStream((int)(output.length() * 1.2));
		final OutputStreamWriter osw;
		final byte[] bytes;
		try{
			osw = new OutputStreamWriter(baos, encoding);
			osw.write(output.getValue(), 0, output.length());
			osw.close();
			bytes = baos.toByteArray();
		}
		catch (Exception ex){
			throw new WicketRuntimeException(""Can't convert response to charset: "" + encoding, ex);
		}
		return bytes;
	}
	public void writeTo(HttpServletResponse servletResponse) throws IOException{
		if (status != -1){
			servletResponse.setStatus(status);
		}
		if (headers != null){
			for (Entry<String, Object> stringObjectEntry : headers.entrySet()){
				String name = stringObjectEntry.getKey();
				Object value = stringObjectEntry.getValue();
				if (value instanceof List){
					List<?> lst = (List<?>)value;
					for (Object aLst : lst){
						addHeader(name, aLst, servletResponse);
					}
				}
				else{
					setHeader(name, value, servletResponse);
				}
			}
		}
		if (cookies != null){
			for (Cookie cookie : cookies){
				servletResponse.addCookie(cookie);
			}
		}
		if (locale != null){
			servletResponse.setLocale(locale);
		}
		servletResponse.setContentLength(byteBuffer.length);
		servletResponse.setContentType(contentType);
		final OutputStream out = servletResponse.getOutputStream();
		out.write(byteBuffer);
		out.close();
	}
	private static void setHeader(String name, Object value, HttpServletResponse servletResponse){
		if (value instanceof String){
			servletResponse.setHeader(name, (String)value);
		}
		else if (value instanceof Long){
			servletResponse.setDateHeader(name, (Long)value);
		}
		else if (value instanceof Integer){
			servletResponse.setIntHeader(name, (Integer)value);
		}
	}
	private static void addHeader(String name, Object value, HttpServletResponse servletResponse){
		if (value instanceof String){
			servletResponse.addHeader(name, (String)value);
		}
		else if (value instanceof Long){
			servletResponse.addDateHeader(name, (Long)value);
		}
		else if (value instanceof Integer){
			servletResponse.addIntHeader(name, (Integer)value);
		}
	}
}",0,0,0,0
"public class CronExpression implements Serializable, Cloneable {
	 private static final long serialVersionUID = 12423409423L;
	 protected static final int SECOND = 0;
	 protected static final int MINUTE = 1;
	 protected static final int HOUR = 2;
	 protected static final int DAY_OF_MONTH = 3;
	 protected static final int MONTH = 4;
	 protected static final int DAY_OF_WEEK = 5;
	 protected static final int YEAR = 6;
	 protected static final int ALL_SPEC_INT = 99;
	 protected static final int NO_SPEC_INT = 98;
	 protected static final Integer ALL_SPEC = new Integer(ALL_SPEC_INT);
	 protected static final Integer NO_SPEC = new Integer(NO_SPEC_INT);
	 protected static final Map monthMap = new HashMap(20);
	 protected static final Map dayMap = new HashMap(60);
	 static {
		 monthMap.put(""JAN"", new Integer(0));
		 monthMap.put(""FEB"", new Integer(1));
		 monthMap.put(""MAR"", new Integer(2));
		 monthMap.put(""APR"", new Integer(3));
		 monthMap.put(""MAY"", new Integer(4));
		 monthMap.put(""JUN"", new Integer(5));
		 monthMap.put(""JUL"", new Integer(6));
		 monthMap.put(""AUG"", new Integer(7));
		 monthMap.put(""SEP"", new Integer(8));
		 monthMap.put(""OCT"", new Integer(9));
		 monthMap.put(""NOV"", new Integer(10));
		 monthMap.put(""DEC"", new Integer(11));
		 dayMap.put(""SUN"", new Integer(1));
		 dayMap.put(""MON"", new Integer(2));
		 dayMap.put(""TUE"", new Integer(3));
		 dayMap.put(""WED"", new Integer(4));
		 dayMap.put(""THU"", new Integer(5));
		 dayMap.put(""FRI"", new Integer(6));
		 dayMap.put(""SAT"", new Integer(7));
	 }
	 private String cronExpression = null;
	 private TimeZone timeZone = null;
	 protected transient TreeSet seconds;
	 protected transient TreeSet minutes;
	 protected transient TreeSet hours;
	 protected transient TreeSet daysOfMonth;
	 protected transient TreeSet months;
	 protected transient TreeSet daysOfWeek;
	 protected transient TreeSet years;
	 protected transient boolean lastdayOfWeek = false;
	 protected transient int nthdayOfWeek = 0;
	 protected transient boolean lastdayOfMonth = false;
	 protected transient boolean nearestWeekday = false;
	 protected transient boolean expressionParsed = false;
	 public CronExpression(String cronExpression) throws ParseException {
		 if (cronExpression == null) {
			 throw new IllegalArgumentException(""cronExpression cannot be null"");
		 }
		 this.cronExpression = cronExpression.toUpperCase(Locale.US);
		 buildExpression(this.cronExpression);
	 }
	 public boolean isSatisfiedBy(Date date) {
		 Calendar testDateCal = Calendar.getInstance(getTimeZone());
		 testDateCal.setTime(date);
		 testDateCal.set(Calendar.MILLISECOND, 0);
		 Date originalDate = testDateCal.getTime();
		 testDateCal.add(Calendar.SECOND, -1);
		 Date timeAfter = getTimeAfter(testDateCal.getTime());
		 return ((timeAfter != null) && (timeAfter.equals(originalDate)));
	 }
	 public Date getNextValidTimeAfter(Date date) {
		 return getTimeAfter(date);
	 }
	 public Date getNextInvalidTimeAfter(Date date) {
		 long difference = 1000;
		 Calendar adjustCal = Calendar.getInstance(getTimeZone());
		 adjustCal.setTime(date);
		 adjustCal.set(Calendar.MILLISECOND, 0);
		 Date lastDate = adjustCal.getTime();
		 Date newDate = null;
		 while (difference == 1000) {
			 newDate = getTimeAfter(lastDate);
			 difference = newDate.getTime() - lastDate.getTime();
			 if (difference == 1000) {
				 lastDate = newDate;
			 }
		 }
		 return new Date(lastDate.getTime() + 1000);
	 }
	 public TimeZone getTimeZone() {
		 if (timeZone == null) {
			 timeZone = TimeZone.getDefault();
		 }
		 return timeZone;
	 }
	 public void setTimeZone(TimeZone timeZone) {
		 this.timeZone = timeZone;
	 }
	 public String toString() {
		 return cronExpression;
	 }
	 public static boolean isValidExpression(String cronExpression) {
		 try {
			 new CronExpression(cronExpression);
		 }
		 catch (ParseException pe) {
			 return false;
		 }
		 return true;
	 }
	 protected void buildExpression(String expression) throws ParseException {
		 expressionParsed = true;
		 try {
			 if (seconds == null) {
				 seconds = new TreeSet();
			 }
			 if (minutes == null) {
				 minutes = new TreeSet();
			 }
			 if (hours == null) {
				 hours = new TreeSet();
			 }
			 if (daysOfMonth == null) {
				 daysOfMonth = new TreeSet();
			 }
			 if (months == null) {
				 months = new TreeSet();
			 }
			 if (daysOfWeek == null) {
				 daysOfWeek = new TreeSet();
			 }
			 if (years == null) {
				 years = new TreeSet();
			 }
			 int exprOn = SECOND;
			 StringTokenizer exprsTok = new StringTokenizer(expression, "" \t"", false);
			 while (exprsTok.hasMoreTokens() && exprOn <= YEAR) {
				 String expr = exprsTok.nextToken().trim();
				 if(exprOn == DAY_OF_MONTH && expr.indexOf('L') != -1 && expr.length() > 1 && expr.indexOf("","") >= 0) {
					 throw new ParseException(""Support for specifying 'L' and 'LW' with other days of the month is not implemented"", -1);
				 }
				 if(exprOn == DAY_OF_WEEK && expr.indexOf('L') != -1 && expr.length() > 1 && expr.indexOf("","") >= 0) {
					 throw new ParseException(""Support for specifying 'L' with other days of the week is not implemented"", -1);
				 }
				 StringTokenizer vTok = new StringTokenizer(expr, "","");
				 while (vTok.hasMoreTokens()) {
					 String v = vTok.nextToken();
					 storeExpressionVals(0, v, exprOn);
				 }
				 exprOn++;
			 }
			 if (exprOn <= DAY_OF_WEEK) {
				 throw new ParseException(""Unexpected end of expression."", expression.length());
			 }
			 if (exprOn <= YEAR) {
				 storeExpressionVals(0, ""*"", YEAR);
			 }
			 TreeSet dow = getSet(DAY_OF_WEEK);
			 TreeSet dom = getSet(DAY_OF_MONTH);
			 boolean dayOfMSpec = !dom.contains(NO_SPEC);
			 boolean dayOfWSpec = !dow.contains(NO_SPEC);
			 if (dayOfMSpec && !dayOfWSpec) {
			 }
			 else if (dayOfWSpec && !dayOfMSpec) {
			 }
			 else {
				 throw new ParseException( ""Support for specifying both a day-of-week AND a day-of-month parameter is not implemented."", 0);
			 }
		 }
		 catch (ParseException pe) {
			 throw pe;
		 }
		 catch (Exception e) {
			 throw new ParseException(""Illegal cron expression format ("" + e.toString() + "")"", 0);
		 }
	 }
	 protected int storeExpressionVals(int pos, String s, int type) throws ParseException {
		 int incr = 0;
		 int i = skipWhiteSpace(pos, s);
		 if (i >= s.length()) {
			 return i;
		 }
		 char c = s.charAt(i);
		 if ((c >= 'A') && (c <= 'Z') && (!s.equals(""L"")) && (!s.equals(""LW""))) {
			 String sub = s.substring(i, i + 3);
			 int sval = -1;
			 int eval = -1;
			 if (type == MONTH) {
				 sval = getMonthNumber(sub) + 1;
				 if (sval <= 0) {
					 throw new ParseException(""Invalid Month value: '"" + sub + ""'"", i);
				 }
				 if (s.length() > i + 3) {
					 c = s.charAt(i + 3);
					 if (c == '-') {
						 i += 4;
						 sub = s.substring(i, i + 3);
						 eval = getMonthNumber(sub) + 1;
						 if (eval <= 0) {
							 throw new ParseException(""Invalid Month value: '"" + sub + ""'"", i);
						 }
					 }
				 }
			 }
			 else if (type == DAY_OF_WEEK) {
				 sval = getDayOfWeekNumber(sub);
				 if (sval < 0) {
					 throw new ParseException(""Invalid Day-of-Week value: '"" + sub + ""'"", i);
				 }
				 if (s.length() > i + 3) {
					 c = s.charAt(i + 3);
					 if (c == '-') {
						 i += 4;
						 sub = s.substring(i, i + 3);
						 eval = getDayOfWeekNumber(sub);
						 if (eval < 0) {
							 throw new ParseException( ""Invalid Day-of-Week value: '"" + sub + ""'"", i);
						 }
					 }
					 else if (c == '#') {
						 try {
							 i += 4;
							 nthdayOfWeek = Integer.parseInt(s.substring(i));
							 if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {
								 throw new Exception();
							 }
						 }
						 catch (Exception e) {
							 throw new ParseException( ""A numeric value between 1 and 5 must follow the '#' option"", i);
						 }
					 }
					 else if (c == 'L') {
						 lastdayOfWeek = true;
						 i++;
					 }
				 }
			 }
			 else {
				 throw new ParseException( ""Illegal characters for this position: '"" + sub + ""'"", i);
			 }
			 if (eval != -1) {
				 incr = 1;
			 }
			 addToSet(sval, eval, incr, type);
			 return (i + 3);
		 }
		 if (c == '?') {
			 i++;
			 if ((i + 1) < s.length() && (s.charAt(i) != ' ' && s.charAt(i + 1) != '\t')) {
				 throw new ParseException(""Illegal character after '?': "" + s.charAt(i), i);
			 }
			 if (type != DAY_OF_WEEK && type != DAY_OF_MONTH) {
				 throw new ParseException( ""'?' can only be specfied for Day-of-Month or Day-of-Week."", i);
			 }
			 if (type == DAY_OF_WEEK && !lastdayOfMonth) {
				 int val = ((Integer) daysOfMonth.last()).intValue();
				 if (val == NO_SPEC_INT) {
					 throw new ParseException( ""'?' can only be specfied for Day-of-Month -OR- Day-of-Week."", i);
				 }
			 }
			 addToSet(NO_SPEC_INT, -1, 0, type);
			 return i;
		 }
		 if (c == '*' || c == '/') {
			 if (c == '*' && (i + 1) >= s.length()) {
				 addToSet(ALL_SPEC_INT, -1, incr, type);
				 return i + 1;
			 }
			 else if (c == '/' && ((i + 1) >= s.length() || s.charAt(i + 1) == ' ' || s .charAt(i + 1) == '\t')) {
				 throw new ParseException(""'/' must be followed by an integer."", i);
			 }
			 else if (c == '*') {
				 i++;
			 }
			 c = s.charAt(i);
			 if (c == '/') {
				 i++;
				 if (i >= s.length()) {
					 throw new ParseException(""Unexpected end of string."", i);
				 }
				 incr = getNumericValue(s, i);
				 i++;
				 if (incr > 10) {
					 i++;
				 }
				 if (incr > 59 && (type == SECOND || type == MINUTE)) {
					 throw new ParseException(""Increment > 60 : "" + incr, i);
				 }
				 else if (incr > 23 && (type == HOUR)) {
					 throw new ParseException(""Increment > 24 : "" + incr, i);
				 }
				 else if (incr > 31 && (type == DAY_OF_MONTH)) {
					 throw new ParseException(""Increment > 31 : "" + incr, i);
				 }
				 else if (incr > 7 && (type == DAY_OF_WEEK)) {
					 throw new ParseException(""Increment > 7 : "" + incr, i);
				 }
				 else if (incr > 12 && (type == MONTH)) {
					 throw new ParseException(""Increment > 12 : "" + incr, i);
				 }
			 }
			 else {
				 incr = 1;
			 }
			 addToSet(ALL_SPEC_INT, -1, incr, type);
			 return i;
		 }
		 else if (c == 'L') {
			 i++;
			 if (type == DAY_OF_MONTH) {
				 lastdayOfMonth = true;
			 }
			 if (type == DAY_OF_WEEK) {
				 addToSet(7, 7, 0, type);
			 }
			 if(type == DAY_OF_MONTH && s.length() > i) {
				 c = s.charAt(i);
				 if(c == 'W') {
					 nearestWeekday = true;
					 i++;
				 }
			 }
			 return i;
		 }
		 else if (c >= '0' && c <= '9') {
			 int val = Integer.parseInt(String.valueOf(c));
			 i++;
			 if (i >= s.length()) {
				 addToSet(val, -1, -1, type);
			 }
			 else {
				 c = s.charAt(i);
				 if (c >= '0' && c <= '9') {
					 ValueSet vs = getValue(val, s, i);
					 val = vs.value;
					 i = vs.pos;
				 }
				 i = checkNext(i, s, val, type);
				 return i;
			 }
		 }
		 else {
			 throw new ParseException(""Unexpected character: "" + c, i);
		 }
		 return i;
	 }
	 protected int checkNext(int pos, String s, int val, int type) throws ParseException {
		 int end = -1;
		 int i = pos;
		 if (i >= s.length()) {
			 addToSet(val, end, -1, type);
			 return i;
		 }
		 char c = s.charAt(pos);
		 if (c == 'L') {
			 if (type == DAY_OF_WEEK) {
				 if(val < 1 || val > 7) throw new ParseException(""Day-of-Week values must be between 1 and 7"", -1);
				 lastdayOfWeek = true;
			 }
			 else {
				 throw new ParseException(""'L' option is not valid here. (pos="" + i + "")"", i);
			 }
			 TreeSet set = getSet(type);
			 set.add(new Integer(val));
			 i++;
			 return i;
		 }
		 if (c == 'W') {
			 if (type == DAY_OF_MONTH) {
				 nearestWeekday = true;
			 }
			 else {
				 throw new ParseException(""'W' option is not valid here. (pos="" + i + "")"", i);
			 }
			 TreeSet set = getSet(type);
			 set.add(new Integer(val));
			 i++;
			 return i;
		 }
		 if (c == '#') {
			 if (type != DAY_OF_WEEK) {
				 throw new ParseException(""'#' option is not valid here. (pos="" + i + "")"", i);
			 }
			 i++;
			 try {
				 nthdayOfWeek = Integer.parseInt(s.substring(i));
				 if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {
					 throw new Exception();
				 }
			 }
			 catch (Exception e) {
				 throw new ParseException( ""A numeric value between 1 and 5 must follow the '#' option"", i);
			 }
			 TreeSet set = getSet(type);
			 set.add(new Integer(val));
			 i++;
			 return i;
		 }
		 if (c == '-') {
			 i++;
			 c = s.charAt(i);
			 int v = Integer.parseInt(String.valueOf(c));
			 end = v;
			 i++;
			 if (i >= s.length()) {
				 addToSet(val, end, 1, type);
				 return i;
			 }
			 c = s.charAt(i);
			 if (c >= '0' && c <= '9') {
				 ValueSet vs = getValue(v, s, i);
				 int v1 = vs.value;
				 end = v1;
				 i = vs.pos;
			 }
			 if (i < s.length() && ((c = s.charAt(i)) == '/')) {
				 i++;
				 c = s.charAt(i);
				 int v2 = Integer.parseInt(String.valueOf(c));
				 i++;
				 if (i >= s.length()) {
					 addToSet(val, end, v2, type);
					 return i;
				 }
				 c = s.charAt(i);
				 if (c >= '0' && c <= '9') {
					 ValueSet vs = getValue(v2, s, i);
					 int v3 = vs.value;
					 addToSet(val, end, v3, type);
					 i = vs.pos;
					 return i;
				 }
				 else {
					 addToSet(val, end, v2, type);
					 return i;
				 }
			 }
			 else {
				 addToSet(val, end, 1, type);
				 return i;
			 }
		 }
		 if (c == '/') {
			 i++;
			 c = s.charAt(i);
			 int v2 = Integer.parseInt(String.valueOf(c));
			 i++;
			 if (i >= s.length()) {
				 addToSet(val, end, v2, type);
				 return i;
			 }
			 c = s.charAt(i);
			 if (c >= '0' && c <= '9') {
				 ValueSet vs = getValue(v2, s, i);
				 int v3 = vs.value;
				 addToSet(val, end, v3, type);
				 i = vs.pos;
				 return i;
			 }
			 else {
				 throw new ParseException(""Unexpected character '"" + c + ""' after '/'"", i);
			 }
		 }
		 addToSet(val, end, 0, type);
		 i++;
		 return i;
	 }
	 public String getCronExpression() {
		 return cronExpression;
	 }
	 public String getExpressionSummary() {
		 StringBuffer buf = new StringBuffer();
		 buf.append(""seconds: "");
		 buf.append(getExpressionSetSummary(seconds));
		 buf.append(""\n"");
		 buf.append(""minutes: "");
		 buf.append(getExpressionSetSummary(minutes));
		 buf.append(""\n"");
		 buf.append(""hours: "");
		 buf.append(getExpressionSetSummary(hours));
		 buf.append(""\n"");
		 buf.append(""daysOfMonth: "");
		 buf.append(getExpressionSetSummary(daysOfMonth));
		 buf.append(""\n"");
		 buf.append(""months: "");
		 buf.append(getExpressionSetSummary(months));
		 buf.append(""\n"");
		 buf.append(""daysOfWeek: "");
		 buf.append(getExpressionSetSummary(daysOfWeek));
		 buf.append(""\n"");
		 buf.append(""lastdayOfWeek: "");
		 buf.append(lastdayOfWeek);
		 buf.append(""\n"");
		 buf.append(""nearestWeekday: "");
		 buf.append(nearestWeekday);
		 buf.append(""\n"");
		 buf.append(""NthDayOfWeek: "");
		 buf.append(nthdayOfWeek);
		 buf.append(""\n"");
		 buf.append(""lastdayOfMonth: "");
		 buf.append(lastdayOfMonth);
		 buf.append(""\n"");
		 buf.append(""years: "");
		 buf.append(getExpressionSetSummary(years));
		 buf.append(""\n"");
		 return buf.toString();
	 }
	 protected String getExpressionSetSummary(java.util.Set set) {
		 if (set.contains(NO_SPEC)) {
			 return ""?"";
		 }
		 if (set.contains(ALL_SPEC)) {
			 return ""*"";
		 }
		 StringBuffer buf = new StringBuffer();
		 Iterator itr = set.iterator();
		 boolean first = true;
		 while (itr.hasNext()) {
			 Integer iVal = (Integer) itr.next();
			 String val = iVal.toString();
			 if (!first) {
				 buf.append("","");
			 }
			 buf.append(val);
			 first = false;
		 }
		 return buf.toString();
	 }
	 protected String getExpressionSetSummary(java.util.ArrayList list) {
		 if (list.contains(NO_SPEC)) {
			 return ""?"";
		 }
		 if (list.contains(ALL_SPEC)) {
			 return ""*"";
		 }
		 StringBuffer buf = new StringBuffer();
		 Iterator itr = list.iterator();
		 boolean first = true;
		 while (itr.hasNext()) {
			 Integer iVal = (Integer) itr.next();
			 String val = iVal.toString();
			 if (!first) {
				 buf.append("","");
			 }
			 buf.append(val);
			 first = false;
		 }
		 return buf.toString();
	 }
	 protected int skipWhiteSpace(int i, String s) {
		 for (;
		 i < s.length() && (s.charAt(i) == ' ' || s.charAt(i) == '\t');
		 i++) {
			 ;
		 }
		 return i;
	 }
	 protected int findNextWhiteSpace(int i, String s) {
		 for (;
		 i < s.length() && (s.charAt(i) != ' ' || s.charAt(i) != '\t');
		 i++) {
			 ;
		 }
		 return i;
	 }
	 protected void addToSet(int val, int end, int incr, int type) throws ParseException {
		 TreeSet set = getSet(type);
		 if (type == SECOND || type == MINUTE) {
			 if ((val < 0 || val > 59 || end > 59) && (val != ALL_SPEC_INT)) {
				 throw new ParseException( ""Minute and Second values must be between 0 and 59"", -1);
			 }
		 }
		 else if (type == HOUR) {
			 if ((val < 0 || val > 23 || end > 23) && (val != ALL_SPEC_INT)) {
				 throw new ParseException( ""Hour values must be between 0 and 23"", -1);
			 }
		 }
		 else if (type == DAY_OF_MONTH) {
			 if ((val < 1 || val > 31 || end > 31) && (val != ALL_SPEC_INT) && (val != NO_SPEC_INT)) {
				 throw new ParseException( ""Day of month values must be between 1 and 31"", -1);
			 }
		 }
		 else if (type == MONTH) {
			 if ((val < 1 || val > 12 || end > 12) && (val != ALL_SPEC_INT)) {
				 throw new ParseException( ""Month values must be between 1 and 12"", -1);
			 }
		 }
		 else if (type == DAY_OF_WEEK) {
			 if ((val == 0 || val > 7 || end > 7) && (val != ALL_SPEC_INT) && (val != NO_SPEC_INT)) {
				 throw new ParseException( ""Day-of-Week values must be between 1 and 7"", -1);
			 }
		 }
		 if ((incr == 0 || incr == -1) && val != ALL_SPEC_INT) {
			 if (val != -1) {
				 set.add(new Integer(val));
			 }
			 else {
				 set.add(NO_SPEC);
			 }
			 return;
		 }
		 int startAt = val;
		 int stopAt = end;
		 if (val == ALL_SPEC_INT && incr <= 0) {
			 incr = 1;
			 set.add(ALL_SPEC);
		 }
		 if (type == SECOND || type == MINUTE) {
			 if (stopAt == -1) {
				 stopAt = 59;
			 }
			 if (startAt == -1 || startAt == ALL_SPEC_INT) {
				 startAt = 0;
			 }
		 }
		 else if (type == HOUR) {
			 if (stopAt == -1) {
				 stopAt = 23;
			 }
			 if (startAt == -1 || startAt == ALL_SPEC_INT) {
				 startAt = 0;
			 }
		 }
		 else if (type == DAY_OF_MONTH) {
			 if (stopAt == -1) {
				 stopAt = 31;
			 }
			 if (startAt == -1 || startAt == ALL_SPEC_INT) {
				 startAt = 1;
			 }
		 }
		 else if (type == MONTH) {
			 if (stopAt == -1) {
				 stopAt = 12;
			 }
			 if (startAt == -1 || startAt == ALL_SPEC_INT) {
				 startAt = 1;
			 }
		 }
		 else if (type == DAY_OF_WEEK) {
			 if (stopAt == -1) {
				 stopAt = 7;
			 }
			 if (startAt == -1 || startAt == ALL_SPEC_INT) {
				 startAt = 1;
			 }
		 }
		 else if (type == YEAR) {
			 if (stopAt == -1) {
				 stopAt = CronTrigger.YEAR_TO_GIVEUP_SCHEDULING_AT;
			 }
			 if (startAt == -1 || startAt == ALL_SPEC_INT) {
				 startAt = 1970;
			 }
		 }
		 int max = -1;
		 if (stopAt < startAt) {
			 switch (type) {
				 case SECOND : max = 60;
				 break;
				 case MINUTE : max = 60;
				 break;
				 case HOUR : max = 24;
				 break;
				 case MONTH : max = 12;
				 break;
				 case DAY_OF_WEEK : max = 7;
				 break;
				 case DAY_OF_MONTH : max = 31;
				 break;
				 case YEAR : throw new IllegalArgumentException(""Start year must be less than stop year"");
				 default : throw new IllegalArgumentException(""Unexpected type encountered"");
			 }
			 stopAt += max;
		 }
		 for (int i = startAt;
		 i <= stopAt;
		 i += incr) {
			 if (max == -1) {
				 set.add(new Integer(i));
			 }
			 else {
				 int i2 = i % max;
				 if (i2 == 0 && (type == MONTH || type == DAY_OF_WEEK || type == DAY_OF_MONTH) ) {
					 i2 = max;
				 }
				 set.add(new Integer(i2));
			 }
		 }
	 }
	 protected TreeSet getSet(int type) {
		 switch (type) {
			 case SECOND: return seconds;
			 case MINUTE: return minutes;
			 case HOUR: return hours;
			 case DAY_OF_MONTH: return daysOfMonth;
			 case MONTH: return months;
			 case DAY_OF_WEEK: return daysOfWeek;
			 case YEAR: return years;
			 default: return null;
		 }
	 }
	 protected ValueSet getValue(int v, String s, int i) {
		 char c = s.charAt(i);
		 String s1 = String.valueOf(v);
		 while (c >= '0' && c <= '9') {
			 s1 += c;
			 i++;
			 if (i >= s.length()) {
				 break;
			 }
			 c = s.charAt(i);
		 }
		 ValueSet val = new ValueSet();
		 val.pos = (i < s.length()) ? i : i + 1;
		 val.value = Integer.parseInt(s1);
		 return val;
	 }
	 protected int getNumericValue(String s, int i) {
		 int endOfVal = findNextWhiteSpace(i, s);
		 String val = s.substring(i, endOfVal);
		 return Integer.parseInt(val);
	 }
	 protected int getMonthNumber(String s) {
		 Integer integer = (Integer) monthMap.get(s);
		 if (integer == null) {
			 return -1;
		 }
		 return integer.intValue();
	 }
	 protected int getDayOfWeekNumber(String s) {
		 Integer integer = (Integer) dayMap.get(s);
		 if (integer == null) {
			 return -1;
		 }
		 return integer.intValue();
	 }
	 protected Date getTimeAfter(Date afterTime) {
		 Calendar cl = new java.util.GregorianCalendar(getTimeZone());
		 afterTime = new Date(afterTime.getTime() + 1000);
		 cl.setTime(afterTime);
		 cl.set(Calendar.MILLISECOND, 0);
		 boolean gotOne = false;
		 while (!gotOne) {
			 if(cl.get(Calendar.YEAR) > 2999) {
				 return null;
			 }
			 SortedSet st = null;
			 int t = 0;
			 int sec = cl.get(Calendar.SECOND);
			 int min = cl.get(Calendar.MINUTE);
			 st = seconds.tailSet(new Integer(sec));
			 if (st != null && st.size() != 0) {
				 sec = ((Integer) st.first()).intValue();
			 }
			 else {
				 sec = ((Integer) seconds.first()).intValue();
				 min++;
				 cl.set(Calendar.MINUTE, min);
			 }
			 cl.set(Calendar.SECOND, sec);
			 min = cl.get(Calendar.MINUTE);
			 int hr = cl.get(Calendar.HOUR_OF_DAY);
			 t = -1;
			 st = minutes.tailSet(new Integer(min));
			 if (st != null && st.size() != 0) {
				 t = min;
				 min = ((Integer) st.first()).intValue();
			 }
			 else {
				 min = ((Integer) minutes.first()).intValue();
				 hr++;
			 }
			 if (min != t) {
				 cl.set(Calendar.SECOND, 0);
				 cl.set(Calendar.MINUTE, min);
				 setCalendarHour(cl, hr);
				 continue;
			 }
			 cl.set(Calendar.MINUTE, min);
			 hr = cl.get(Calendar.HOUR_OF_DAY);
			 int day = cl.get(Calendar.DAY_OF_MONTH);
			 t = -1;
			 st = hours.tailSet(new Integer(hr));
			 if (st != null && st.size() != 0) {
				 t = hr;
				 hr = ((Integer) st.first()).intValue();
			 }
			 else {
				 hr = ((Integer) hours.first()).intValue();
				 day++;
			 }
			 if (hr != t) {
				 cl.set(Calendar.SECOND, 0);
				 cl.set(Calendar.MINUTE, 0);
				 cl.set(Calendar.DAY_OF_MONTH, day);
				 setCalendarHour(cl, hr);
				 continue;
			 }
			 cl.set(Calendar.HOUR_OF_DAY, hr);
			 day = cl.get(Calendar.DAY_OF_MONTH);
			 int mon = cl.get(Calendar.MONTH) + 1;
			 t = -1;
			 int tmon = mon;
			 boolean dayOfMSpec = !daysOfMonth.contains(NO_SPEC);
			 boolean dayOfWSpec = !daysOfWeek.contains(NO_SPEC);
			 if (dayOfMSpec && !dayOfWSpec) {
				 st = daysOfMonth.tailSet(new Integer(day));
				 if (lastdayOfMonth) {
					 if(!nearestWeekday) {
						 t = day;
						 day = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
					 }
					 else {
						 t = day;
						 day = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
						 java.util.Calendar tcal = java.util.Calendar.getInstance(getTimeZone());
						 tcal.set(Calendar.SECOND, 0);
						 tcal.set(Calendar.MINUTE, 0);
						 tcal.set(Calendar.HOUR_OF_DAY, 0);
						 tcal.set(Calendar.DAY_OF_MONTH, day);
						 tcal.set(Calendar.MONTH, mon - 1);
						 tcal.set(Calendar.YEAR, cl.get(Calendar.YEAR));
						 int ldom = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
						 int dow = tcal.get(Calendar.DAY_OF_WEEK);
						 if(dow == Calendar.SATURDAY && day == 1) {
							 day += 2;
						 }
						 else if(dow == Calendar.SATURDAY) {
							 day -= 1;
						 }
						 else if(dow == Calendar.SUNDAY && day == ldom) {
							 day -= 2;
						 }
						 else if(dow == Calendar.SUNDAY) {
							 day += 1;
						 }
						 tcal.set(Calendar.SECOND, sec);
						 tcal.set(Calendar.MINUTE, min);
						 tcal.set(Calendar.HOUR_OF_DAY, hr);
						 tcal.set(Calendar.DAY_OF_MONTH, day);
						 tcal.set(Calendar.MONTH, mon - 1);
						 Date nTime = tcal.getTime();
						 if(nTime.before(afterTime)) {
							 day = 1;
							 mon++;
						 }
					 }
				 }
				 else if(nearestWeekday) {
					 t = day;
					 day = ((Integer) daysOfMonth.first()).intValue();
					 java.util.Calendar tcal = java.util.Calendar.getInstance(getTimeZone());
					 tcal.set(Calendar.SECOND, 0);
					 tcal.set(Calendar.MINUTE, 0);
					 tcal.set(Calendar.HOUR_OF_DAY, 0);
					 tcal.set(Calendar.DAY_OF_MONTH, day);
					 tcal.set(Calendar.MONTH, mon - 1);
					 tcal.set(Calendar.YEAR, cl.get(Calendar.YEAR));
					 int ldom = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
					 int dow = tcal.get(Calendar.DAY_OF_WEEK);
					 if(dow == Calendar.SATURDAY && day == 1) {
						 day += 2;
					 }
					 else if(dow == Calendar.SATURDAY) {
						 day -= 1;
					 }
					 else if(dow == Calendar.SUNDAY && day == ldom) {
						 day -= 2;
					 }
					 else if(dow == Calendar.SUNDAY) {
						 day += 1;
					 }
					 tcal.set(Calendar.SECOND, sec);
					 tcal.set(Calendar.MINUTE, min);
					 tcal.set(Calendar.HOUR_OF_DAY, hr);
					 tcal.set(Calendar.DAY_OF_MONTH, day);
					 tcal.set(Calendar.MONTH, mon - 1);
					 Date nTime = tcal.getTime();
					 if(nTime.before(afterTime)) {
						 day = ((Integer) daysOfMonth.first()).intValue();
						 mon++;
					 }
				 }
				 else if (st != null && st.size() != 0) {
					 t = day;
					 day = ((Integer) st.first()).intValue();
					 int lastDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
					 if (day > lastDay) {
						 day = ((Integer) daysOfMonth.first()).intValue();
						 mon++;
					 }
				 }
				 else {
					 day = ((Integer) daysOfMonth.first()).intValue();
					 mon++;
				 }
				 if (day != t || mon != tmon) {
					 cl.set(Calendar.SECOND, 0);
					 cl.set(Calendar.MINUTE, 0);
					 cl.set(Calendar.HOUR_OF_DAY, 0);
					 cl.set(Calendar.DAY_OF_MONTH, day);
					 cl.set(Calendar.MONTH, mon - 1);
					 continue;
				 }
			 }
			 else if (dayOfWSpec && !dayOfMSpec) {
				 if (lastdayOfWeek) {
					 int dow = ((Integer) daysOfWeek.first()).intValue();
					 int cDow = cl.get(Calendar.DAY_OF_WEEK);
					 int daysToAdd = 0;
					 if (cDow < dow) {
						 daysToAdd = dow - cDow;
					 }
					 if (cDow > dow) {
						 daysToAdd = dow + (7 - cDow);
					 }
					 int lDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
					 if (day + daysToAdd > lDay) {
						 cl.set(Calendar.SECOND, 0);
						 cl.set(Calendar.MINUTE, 0);
						 cl.set(Calendar.HOUR_OF_DAY, 0);
						 cl.set(Calendar.DAY_OF_MONTH, 1);
						 cl.set(Calendar.MONTH, mon);
						 continue;
					 }
					 while ((day + daysToAdd + 7) <= lDay) {
						 daysToAdd += 7;
					 }
					 day += daysToAdd;
					 if (daysToAdd > 0) {
						 cl.set(Calendar.SECOND, 0);
						 cl.set(Calendar.MINUTE, 0);
						 cl.set(Calendar.HOUR_OF_DAY, 0);
						 cl.set(Calendar.DAY_OF_MONTH, day);
						 cl.set(Calendar.MONTH, mon - 1);
						 continue;
					 }
				 }
				 else if (nthdayOfWeek != 0) {
					 int dow = ((Integer) daysOfWeek.first()).intValue();
					 int cDow = cl.get(Calendar.DAY_OF_WEEK);
					 int daysToAdd = 0;
					 if (cDow < dow) {
						 daysToAdd = dow - cDow;
					 }
					 else if (cDow > dow) {
						 daysToAdd = dow + (7 - cDow);
					 }
					 boolean dayShifted = false;
					 if (daysToAdd > 0) {
						 dayShifted = true;
					 }
					 day += daysToAdd;
					 int weekOfMonth = day / 7;
					 if (day % 7 > 0) {
						 weekOfMonth++;
					 }
					 daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;
					 day += daysToAdd;
					 if (daysToAdd < 0 || day > getLastDayOfMonth(mon, cl .get(Calendar.YEAR))) {
						 cl.set(Calendar.SECOND, 0);
						 cl.set(Calendar.MINUTE, 0);
						 cl.set(Calendar.HOUR_OF_DAY, 0);
						 cl.set(Calendar.DAY_OF_MONTH, 1);
						 cl.set(Calendar.MONTH, mon);
						 continue;
					 }
					 else if (daysToAdd > 0 || dayShifted) {
						 cl.set(Calendar.SECOND, 0);
						 cl.set(Calendar.MINUTE, 0);
						 cl.set(Calendar.HOUR_OF_DAY, 0);
						 cl.set(Calendar.DAY_OF_MONTH, day);
						 cl.set(Calendar.MONTH, mon - 1);
						 continue;
					 }
				 }
				 else {
					 int cDow = cl.get(Calendar.DAY_OF_WEEK);
					 int dow = ((Integer) daysOfWeek.first()).intValue();
					 st = daysOfWeek.tailSet(new Integer(cDow));
					 if (st != null && st.size() > 0) {
						 dow = ((Integer) st.first()).intValue();
					 }
					 int daysToAdd = 0;
					 if (cDow < dow) {
						 daysToAdd = dow - cDow;
					 }
					 if (cDow > dow) {
						 daysToAdd = dow + (7 - cDow);
					 }
					 int lDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
					 if (day + daysToAdd > lDay) {
						 cl.set(Calendar.SECOND, 0);
						 cl.set(Calendar.MINUTE, 0);
						 cl.set(Calendar.HOUR_OF_DAY, 0);
						 cl.set(Calendar.DAY_OF_MONTH, 1);
						 cl.set(Calendar.MONTH, mon);
						 continue;
					 }
					 else if (daysToAdd > 0) {
						 cl.set(Calendar.SECOND, 0);
						 cl.set(Calendar.MINUTE, 0);
						 cl.set(Calendar.HOUR_OF_DAY, 0);
						 cl.set(Calendar.DAY_OF_MONTH, day + daysToAdd);
						 cl.set(Calendar.MONTH, mon - 1);
						 continue;
					 }
				 }
			 }
			 else {
				 throw new UnsupportedOperationException( ""Support for specifying both a day-of-week AND a day-of-month parameter is not implemented."");
			 }
			 cl.set(Calendar.DAY_OF_MONTH, day);
			 mon = cl.get(Calendar.MONTH) + 1;
			 int year = cl.get(Calendar.YEAR);
			 t = -1;
			 if (year > CronTrigger.YEAR_TO_GIVEUP_SCHEDULING_AT) {
				 return null;
			 }
			 st = months.tailSet(new Integer(mon));
			 if (st != null && st.size() != 0) {
				 t = mon;
				 mon = ((Integer) st.first()).intValue();
			 }
			 else {
				 mon = ((Integer) months.first()).intValue();
				 year++;
			 }
			 if (mon != t) {
				 cl.set(Calendar.SECOND, 0);
				 cl.set(Calendar.MINUTE, 0);
				 cl.set(Calendar.HOUR_OF_DAY, 0);
				 cl.set(Calendar.DAY_OF_MONTH, 1);
				 cl.set(Calendar.MONTH, mon - 1);
				 cl.set(Calendar.YEAR, year);
				 continue;
			 }
			 cl.set(Calendar.MONTH, mon - 1);
			 year = cl.get(Calendar.YEAR);
			 t = -1;
			 st = years.tailSet(new Integer(year));
			 if (st != null && st.size() != 0) {
				 t = year;
				 year = ((Integer) st.first()).intValue();
			 }
			 else {
				 return null;
			 }
			 if (year != t) {
				 cl.set(Calendar.SECOND, 0);
				 cl.set(Calendar.MINUTE, 0);
				 cl.set(Calendar.HOUR_OF_DAY, 0);
				 cl.set(Calendar.DAY_OF_MONTH, 1);
				 cl.set(Calendar.MONTH, 0);
				 cl.set(Calendar.YEAR, year);
				 continue;
			 }
			 cl.set(Calendar.YEAR, year);
			 gotOne = true;
		 }
		 return cl.getTime();
	 }
	 protected void setCalendarHour(Calendar cal, int hour) {
		 cal.set(java.util.Calendar.HOUR_OF_DAY, hour);
		 if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {
			 cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1);
		 }
	 }
	 protected Date getTimeBefore(Date endTime) {
		 return null;
	 }
	 public Date getFinalFireTime() {
		 return null;
	 }
	 protected boolean isLeapYear(int year) {
		 return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));
	 }
	 protected int getLastDayOfMonth(int monthNum, int year) {
		 switch (monthNum) {
			 case 1: return 31;
			 case 2: return (isLeapYear(year)) ? 29 : 28;
			 case 3: return 31;
			 case 4: return 30;
			 case 5: return 31;
			 case 6: return 30;
			 case 7: return 31;
			 case 8: return 31;
			 case 9: return 30;
			 case 10: return 31;
			 case 11: return 30;
			 case 12: return 31;
			 default: throw new IllegalArgumentException(""Illegal month number: "" + monthNum);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream stream) throws java.io.IOException, ClassNotFoundException {
		 stream.defaultReadObject();
		 try {
			 buildExpression(cronExpression);
		 }
		 catch (Exception ignore) {
		 }
	 }
	 public Object clone() {
		 CronExpression copy = null;
		 try {
			 copy = new CronExpression(getCronExpression());
			 if(getTimeZone() != null) copy.setTimeZone((TimeZone) getTimeZone().clone());
		 }
		 catch (ParseException ex) {
			 throw new IncompatibleClassChangeError(""Not Cloneable."");
		 }
		 return copy;
	 }
 }
class ValueSet {
	 public int value;
	 public int pos;
}",1,0,0,0
"long getUpdateTimestamp() {
	 return updateTimestamp;
 }",0,0,0,0
"public abstract class TargetPoolCreationOptions{
	 public enum SessionAffinityValue {
	 CLIENT_IP, CLIENT_IP_PROTO, NONE }
	 public abstract String name();
	 public abstract List<URI> healthChecks();
	 public abstract List<URI> instances();
	 public abstract SessionAffinityValue sessionAffinity();
	 public abstract Float failoverRatio();
	 public abstract URI backupPool();
	 public abstract String description();
	 public static TargetPoolCreationOptions create(String name, List<URI> healthChecks, List<URI> instances, SessionAffinityValue sessionAffinity, Float failoverRatio, URI backupPool, String description) {
		 return new AutoValue_TargetPoolCreationOptions(name, healthChecks, instances, sessionAffinity, failoverRatio, backupPool, description);
	 }
	 TargetPoolCreationOptions() {
	 }
	 public static class Builder {
		 private String name;
		 private List<URI> healthChecks;
		 private List<URI> instances;
		 private SessionAffinityValue sessionAffinity;
		 private Float failoverRatio;
		 private URI backupPool;
		 private String description;
		 public Builder(String name){
			 checkNotNull(name, ""TargetPoolCreationOptions name cannot be null"");
			 this.name = name;
		 }
		 public Builder healthChecks(List<URI> healthChecks){
			 this.healthChecks = healthChecks;
			 return this;
		 }
		 public Builder instances(List<URI> instances){
			 this.instances = instances;
			 return this;
		 }
		 public Builder sessionAffinity(SessionAffinityValue sessionAffinity){
			 this.sessionAffinity = sessionAffinity;
			 return this;
		 }
		 public Builder failoverRatio(float failoverRatio){
			 this.failoverRatio = failoverRatio;
			 return this;
		 }
		 public Builder backupPool(URI backupPool){
			 this.backupPool = backupPool;
			 return this;
		 }
		 public Builder description(String description){
			 this.description = description;
			 return this;
		 }
		 public TargetPoolCreationOptions build() {
			 return create(name, healthChecks, instances, sessionAffinity, failoverRatio, backupPool, description);
		 }
	 }
}",0,0,0,0
"public class HtmlSpecialTag extends MarkupElement{
	protected final XmlTag xmlTag;
	private int flags = 0;
	private final HttpTagType httpTagType;
	public HtmlSpecialTag(final XmlTag tag, final HttpTagType httpTagType){
		xmlTag = tag.makeImmutable();
		this.httpTagType = httpTagType;
	}
	public final void setFlag(final int flag, final boolean set){
		if (set){
			flags |= flag;
		}
		else{
			flags &= ~flag;
		}
	}
	public final boolean getFlag(final int flag){
		return (flags & flag) != 0;
	}
	public final int getLength(){
		return xmlTag.getLength();
	}
	public final int getPos(){
		return xmlTag.getPos();
	}
	public final TagType getType(){
		return xmlTag.getType();
	}
	public final boolean isClose(){
		return xmlTag.isClose();
	}
	public final boolean isOpen(){
		return xmlTag.isOpen();
	}
	public final boolean isOpenClose(){
		return xmlTag.isOpenClose();
	}
	void copyPropertiesTo(final HtmlSpecialTag dest){
		dest.flags = flags;
	}
	public CharSequence toCharSequence(){
		return xmlTag.toCharSequence();
	}
	public final String toString(){
		return """" + httpTagType + "": '"" + xmlTag.toString() + ""'"";
	}
	public final void writeOutput(final Response response, final boolean stripWicketAttributes,final String namespace){
		response.write(toString());
	}
	public final String toUserDebugString(){
		return xmlTag.toUserDebugString();
	}
	public final XmlTag getXmlTag(){
		return xmlTag;
	}
	public boolean equalTo(final MarkupElement element){
		if (element instanceof HtmlSpecialTag){
			final HtmlSpecialTag that = (HtmlSpecialTag)element;
			return getXmlTag().equalTo(that.getXmlTag());
		}
		return false;
	}
	public void onBeforeRender(final Component component, final MarkupStream markupStream){
	}
	public final HttpTagType getHttpTagType(){
		return httpTagType;
	}
}",0,0,0,0
"private class ValueCollection extends AbstractCollection {
	 public int size() {
		 return CacheMap.this.size();
	 }
	 public Iterator iterator() {
		 return new EntryIterator(EntryIterator.VALUE);
	 }
 }",0,0,0,0
"public void dump(PrintStream out) {
	out.println(""HEADER:"");
out.println(""int Machine="" + Machine + "" out.println(""int NumberOfSections="" + NumberOfSections + "" out.println(""long TimeDateStamp="" + TimeDateStamp + "" out.println(""long PointerToSymbolTable="" + PointerToSymbolTable + "" out.println(""long NumberOfSymbols="" + NumberOfSymbols + "" out.println(""int SizeOfOptionalHeader="" + SizeOfOptionalHeader + "" out.println(""int Characteristics="" + Characteristics + "" out.println(""int Magic="" + Magic + "" out.println(""short MajorLinkerVersion="" + MajorLinkerVersion + "" out.println(""short MinorLinkerVersion="" + MinorLinkerVersion + "" out.println(""long SizeOfCode="" + SizeOfCode + "" out.println(""long SizeOfInitializedData="" + SizeOfInitializedData + "" out.println(""long SizeOfUninitializedData="" + SizeOfUninitializedData + "" out.println(""long AddressOfEntryPoint="" + AddressOfEntryPoint + "" out.println(""long BaseOfCode="" + BaseOfCode + "" out.println(""long BaseOfData="" + BaseOfData + "" out.println(""long ImageBase="" + ImageBase + "" out.println(""long SectionAlignment="" + SectionAlignment + "" out.println(""long FileAlignment="" + FileAlignment + "" out.println(""int MajorOperatingSystemVersion="" + MajorOperatingSystemVersion + "" out.println(""int MinorOperatingSystemVersion="" + MinorOperatingSystemVersion + "" out.println(""int MajorImageVersion="" + MajorImageVersion + "" out.println(""int MinorImageVersion="" + MinorImageVersion + "" out.println(""int MajorSubsystemVersion="" + MajorSubsystemVersion + "" out.println(""int MinorSubsystemVersion="" + MinorSubsystemVersion + "" out.println(""long Reserved1="" + Reserved1 + "" out.println(""long SizeOfImage="" + SizeOfImage + "" out.println(""long SizeOfHeaders="" + SizeOfHeaders + "" out.println(""long CheckSum="" + CheckSum + "" out.println(""int Subsystem="" + Subsystem + "" out.println(""int DllCharacteristics="" + DllCharacteristics + "" out.println(""long SizeOfStackReserve="" + SizeOfStackReserve + "" out.println(""long SizeOfStackCommit="" + SizeOfStackCommit + "" out.println(""long SizeOfHeapReserve="" + SizeOfHeapReserve + "" out.println(""long SizeOfHeapCommit="" + SizeOfHeapCommit + "" out.println(""long LoaderFlags="" + LoaderFlags + "" out.println(""long NumberOfRvaAndSizes="" + NumberOfRvaAndSizes + "" out.println(""long ExportDirectory_VA="" + ExportDirectory_VA +"" out.println(""long ExportDirectory_Size="" + ExportDirectory_Size +"" out.println(""long ImportDirectory_VA="" + ImportDirectory_VA +"" out.println(""long ImportDirectory_Size="" + ImportDirectory_Size +"" out.println(""long ResourceDirectory_VA="" + ResourceDirectory_VA +"" out.println(""long ResourceDirectory_Size="" + ResourceDirectory_Size +"" out.println(""long ExceptionDirectory_VA="" + ExceptionDirectory_VA +"" out.println(""long ExceptionDirectory_Size="" + ExceptionDirectory_Size +"" out.println(""long SecurityDirectory_VA="" + SecurityDirectory_VA +"" out.println(""long SecurityDirectory_Size="" + SecurityDirectory_Size +"" out.println(""long BaseRelocationTable_VA="" + BaseRelocationTable_VA +"" out.println(""long BaseRelocationTable_Size="" + BaseRelocationTable_Size +"" out.println(""long DebugDirectory_VA="" + DebugDirectory_VA +"" out.println(""long DebugDirectory_Size="" + DebugDirectory_Size +"" out.println(""long ArchitectureSpecificData_VA="" + ArchitectureSpecificData_VA +"" out.println(""long ArchitectureSpecificData_Size="" + ArchitectureSpecificData_Size +"" out.println(""long RVAofGP_VA="" + RVAofGP_VA +"" out.println(""long RVAofGP_Size="" + RVAofGP_Size +"" out.println(""long TLSDirectory_VA="" + TLSDirectory_VA +"" out.println(""long TLSDirectory_Size="" + TLSDirectory_Size +"" out.println(""long LoadConfigurationDirectory_VA="" + LoadConfigurationDirectory_VA +"" out.println(""long LoadConfigurationDirectory_Size="" + LoadConfigurationDirectory_Size +"" out.println(""long BoundImportDirectoryinheaders_VA="" + BoundImportDirectoryinheaders_VA +"" out.println(""long BoundImportDirectoryinheaders_Size="" + BoundImportDirectoryinheaders_Size +"" out.println(""long ImportAddressTable_VA="" + ImportAddressTable_VA +"" out.println(""long ImportAddressTable_Size="" + ImportAddressTable_Size +"" out.println(""long DelayLoadImportDescriptors_VA="" + DelayLoadImportDescriptors_VA +"" out.println(""long DelayLoadImportDescriptors_Size="" + DelayLoadImportDescriptors_Size +"" out.println(""long COMRuntimedescriptor_VA="" + COMRuntimedescriptor_VA +"" out.println(""long COMRuntimedescriptor_Size="" + COMRuntimedescriptor_Size +"" }",0,0,1,0
"public Socket createSocket(String host, int port) throws IOException {
	 try {
		 return getSSLContext().getSocketFactory().createSocket(host, port);
	 }
	 catch (NoSuchAlgorithmException e) {
		 throw new IOException(e + "" "" + e.getMessage());
	 }
	 catch (KeyManagementException e) {
		 throw new IOException(e + "" "" + e.getMessage());
	 }
	 catch (KeyStoreException e) {
		 throw new IOException(e + "" "" + e.getMessage());
	 }
	 catch (InvalidAlgorithmParameterException e) {
		 throw new IOException(e + "" "" + e.getMessage());
	 }
 }",0,0,0,0
"public static final class OpCopyBlockProto extends com.google.protobuf.GeneratedMessage implements OpCopyBlockProtoOrBuilder {
	 private OpCopyBlockProto(Builder builder) {
		 super(builder);
	 }
	 private OpCopyBlockProto(boolean noInit) {
	}
	 private static final OpCopyBlockProto defaultInstance;
	 public static OpCopyBlockProto getDefaultInstance() {
		 return defaultInstance;
	 }
	 public OpCopyBlockProto getDefaultInstanceForType() {
		 return defaultInstance;
	 }
	 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
		 return org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.internal_static_OpCopyBlockProto_descriptor;
	 }
	 protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
		 return org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.internal_static_OpCopyBlockProto_fieldAccessorTable;
	 }
	 private int bitField0_;
	 public static final int HEADER_FIELD_NUMBER = 1;
	 private org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto header_;
	 public boolean hasHeader() {
		 return ((bitField0_ & 0x00000001) == 0x00000001);
	 }
	 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto getHeader() {
		 return header_;
	 }
	 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProtoOrBuilder getHeaderOrBuilder() {
		 return header_;
	 }
	 private void initFields() {
		 header_ = org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.getDefaultInstance();
	 }
	 private byte memoizedIsInitialized = -1;
	 public final boolean isInitialized() {
		 byte isInitialized = memoizedIsInitialized;
		 if (isInitialized != -1) return isInitialized == 1;
		 if (!hasHeader()) {
			 memoizedIsInitialized = 0;
			 return false;
		 }
		 if (!getHeader().isInitialized()) {
			 memoizedIsInitialized = 0;
			 return false;
		 }
		 memoizedIsInitialized = 1;
		 return true;
	 }
	 public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
		 getSerializedSize();
		 if (((bitField0_ & 0x00000001) == 0x00000001)) {
			 output.writeMessage(1, header_);
		 }
		 getUnknownFields().writeTo(output);
	 }
	 private int memoizedSerializedSize = -1;
	 public int getSerializedSize() {
		 int size = memoizedSerializedSize;
		 if (size != -1) return size;
		 size = 0;
		 if (((bitField0_ & 0x00000001) == 0x00000001)) {
			 size += com.google.protobuf.CodedOutputStream .computeMessageSize(1, header_);
		 }
		 size += getUnknownFields().getSerializedSize();
		 memoizedSerializedSize = size;
		 return size;
	 }
	 private static final long serialVersionUID = 0L;
	 protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
		 return super.writeReplace();
	 }
	 public boolean equals(final java.lang.Object obj) {
		 if (obj == this) {
			 return true;
		 }
		 if (!(obj instanceof org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto)) {
			 return super.equals(obj);
		 }
		 org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto other = (org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto) obj;
		 boolean result = true;
		 result = result && (hasHeader() == other.hasHeader());
		 if (hasHeader()) {
			 result = result && getHeader() .equals(other.getHeader());
		 }
		 result = result && getUnknownFields().equals(other.getUnknownFields());
		 return result;
	 }
	 public int hashCode() {
		 int hash = 41;
		 hash = (19 * hash) + getDescriptorForType().hashCode();
		 if (hasHeader()) {
			 hash = (37 * hash) + HEADER_FIELD_NUMBER;
			 hash = (53 * hash) + getHeader().hashCode();
		 }
		 hash = (29 * hash) + getUnknownFields().hashCode();
		 return hash;
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom( com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return newBuilder().mergeFrom(data).buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom( com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return newBuilder().mergeFrom(data, extensionRegistry) .buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return newBuilder().mergeFrom(data).buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom( byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return newBuilder().mergeFrom(data, extensionRegistry) .buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom(java.io.InputStream input) throws java.io.IOException {
		 return newBuilder().mergeFrom(input).buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return newBuilder().mergeFrom(input, extensionRegistry) .buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
		 Builder builder = newBuilder();
		 if (builder.mergeDelimitedFrom(input)) {
			 return builder.buildParsed();
		 }
		 else {
			 return null;
		 }
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseDelimitedFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 Builder builder = newBuilder();
		 if (builder.mergeDelimitedFrom(input, extensionRegistry)) {
			 return builder.buildParsed();
		 }
		 else {
			 return null;
		 }
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom( com.google.protobuf.CodedInputStream input) throws java.io.IOException {
		 return newBuilder().mergeFrom(input).buildParsed();
	 }
	 public static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto parseFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return newBuilder().mergeFrom(input, extensionRegistry) .buildParsed();
	 }
	 public static Builder newBuilder() {
		 return Builder.create();
	 }
	 public Builder newBuilderForType() {
		 return newBuilder();
	 }
	 public static Builder newBuilder(org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto prototype) {
		 return newBuilder().mergeFrom(prototype);
	 }
	 public Builder toBuilder() {
		 return newBuilder(this);
	 }
	 protected Builder newBuilderForType( com.google.protobuf.GeneratedMessage.BuilderParent parent) {
		 Builder builder = new Builder(parent);
		 return builder;
	 }
	 public static final class Builder extends com.google.protobuf.GeneratedMessage.Builder<Builder> implements org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProtoOrBuilder {
		 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
			 return org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.internal_static_OpCopyBlockProto_descriptor;
		 }
		 protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
			 return org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.internal_static_OpCopyBlockProto_fieldAccessorTable;
		 }
		 private Builder() {
			 maybeForceBuilderInitialization();
		 }
		 private Builder(BuilderParent parent) {
			 super(parent);
			 maybeForceBuilderInitialization();
		 }
		 private void maybeForceBuilderInitialization() {
			 if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
				 getHeaderFieldBuilder();
			 }
		 }
		 private static Builder create() {
			 return new Builder();
		 }
		 public Builder clear() {
			 super.clear();
			 if (headerBuilder_ == null) {
				 header_ = org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.getDefaultInstance();
			 }
			 else {
				 headerBuilder_.clear();
			 }
			 bitField0_ = (bitField0_ & ~0x00000001);
			 return this;
		 }
		 public Builder clone() {
			 return create().mergeFrom(buildPartial());
		 }
		 public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
			 return org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto.getDescriptor();
		 }
		 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto getDefaultInstanceForType() {
			 return org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto.getDefaultInstance();
		 }
		 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto build() {
			 org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto result = buildPartial();
			 if (!result.isInitialized()) {
				 throw newUninitializedMessageException(result);
			 }
			 return result;
		 }
		 private org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto buildParsed() throws com.google.protobuf.InvalidProtocolBufferException {
			 org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto result = buildPartial();
			 if (!result.isInitialized()) {
				 throw newUninitializedMessageException( result).asInvalidProtocolBufferException();
			 }
			 return result;
		 }
		 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto buildPartial() {
			 org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto result = new org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto(this);
			 int from_bitField0_ = bitField0_;
			 int to_bitField0_ = 0;
			 if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
				 to_bitField0_ |= 0x00000001;
			 }
			 if (headerBuilder_ == null) {
				 result.header_ = header_;
			 }
			 else {
				 result.header_ = headerBuilder_.build();
			 }
			 result.bitField0_ = to_bitField0_;
			 onBuilt();
			 return result;
		 }
		 public Builder mergeFrom(com.google.protobuf.Message other) {
			 if (other instanceof org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto) {
				 return mergeFrom((org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto)other);
			 }
			 else {
				 super.mergeFrom(other);
				 return this;
			 }
		 }
		 public Builder mergeFrom(org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto other) {
			 if (other == org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.OpCopyBlockProto.getDefaultInstance()) return this;
			 if (other.hasHeader()) {
				 mergeHeader(other.getHeader());
			 }
			 this.mergeUnknownFields(other.getUnknownFields());
			 return this;
		 }
		 public final boolean isInitialized() {
			 if (!hasHeader()) {
				 return false;
			 }
			 if (!getHeader().isInitialized()) {
				 return false;
			 }
			 return true;
		 }
		 public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			 com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder( this.getUnknownFields());
			 while (true) {
				 int tag = input.readTag();
				 switch (tag) {
					 case 0: this.setUnknownFields(unknownFields.build());
					 onChanged();
					 return this;
					 default: {
						 if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
							 this.setUnknownFields(unknownFields.build());
							 onChanged();
							 return this;
						 }
						 break;
					 }
					 case 10: {
						 org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.Builder subBuilder = org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.newBuilder();
						 if (hasHeader()) {
							 subBuilder.mergeFrom(getHeader());
						 }
						 input.readMessage(subBuilder, extensionRegistry);
						 setHeader(subBuilder.buildPartial());
						 break;
					 }
				 }
			 }
		 }
		 private int bitField0_;
		 private org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto header_ = org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.getDefaultInstance();
		 private com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto, org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.Builder, org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProtoOrBuilder> headerBuilder_;
		 public boolean hasHeader() {
			 return ((bitField0_ & 0x00000001) == 0x00000001);
		 }
		 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto getHeader() {
			 if (headerBuilder_ == null) {
				 return header_;
			 }
			 else {
				 return headerBuilder_.getMessage();
			 }
		 }
		 public Builder setHeader(org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto value) {
			 if (headerBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 header_ = value;
				 onChanged();
			 }
			 else {
				 headerBuilder_.setMessage(value);
			 }
			 bitField0_ |= 0x00000001;
			 return this;
		 }
		 public Builder setHeader( org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.Builder builderForValue) {
			 if (headerBuilder_ == null) {
				 header_ = builderForValue.build();
				 onChanged();
			 }
			 else {
				 headerBuilder_.setMessage(builderForValue.build());
			 }
			 bitField0_ |= 0x00000001;
			 return this;
		 }
		 public Builder mergeHeader(org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto value) {
			 if (headerBuilder_ == null) {
				 if (((bitField0_ & 0x00000001) == 0x00000001) && header_ != org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.getDefaultInstance()) {
					 header_ = org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.newBuilder(header_).mergeFrom(value).buildPartial();
				 }
				 else {
					 header_ = value;
				 }
				 onChanged();
			 }
			 else {
				 headerBuilder_.mergeFrom(value);
			 }
			 bitField0_ |= 0x00000001;
			 return this;
		 }
		 public Builder clearHeader() {
			 if (headerBuilder_ == null) {
				 header_ = org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.getDefaultInstance();
				 onChanged();
			 }
			 else {
				 headerBuilder_.clear();
			 }
			 bitField0_ = (bitField0_ & ~0x00000001);
			 return this;
		 }
		 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.Builder getHeaderBuilder() {
			 bitField0_ |= 0x00000001;
			 onChanged();
			 return getHeaderFieldBuilder().getBuilder();
		 }
		 public org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProtoOrBuilder getHeaderOrBuilder() {
			 if (headerBuilder_ != null) {
				 return headerBuilder_.getMessageOrBuilder();
			 }
			 else {
				 return header_;
			 }
		 }
		 private com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto, org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.Builder, org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProtoOrBuilder> getHeaderFieldBuilder() {
			 if (headerBuilder_ == null) {
				 headerBuilder_ = new com.google.protobuf.SingleFieldBuilder< org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto, org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProto.Builder, org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BaseHeaderProtoOrBuilder>( header_, getParentForChildren(), isClean());
				 header_ = null;
			 }
			 return headerBuilder_;
		 }
	 }
	 static {
		 defaultInstance = new OpCopyBlockProto(true);
		 defaultInstance.initFields();
	 }
 }",1,1,0,0
"public synchronized void write(WritableComparable key, Writable value) throws IOException {
	 out.write(key.toString().getBytes(""UTF-8""));
	 out.writeByte('\t');
	 out.write(value.toString().getBytes(""UTF-8""));
	 out.writeByte('\n');
 }",0,0,0,0
"protected void loadVtimezone() {
	 try {
		 String timezoneId = null;
		 if (!""Exchange2007_SP1"".equals(serverVersion)) {
			 GetUserConfigurationMethod getUserConfigurationMethod = new GetUserConfigurationMethod();
			 executeMethod(getUserConfigurationMethod);
			 EWSMethod.Item item = getUserConfigurationMethod.getResponseItem();
			 if (item != null) {
				 timezoneId = item.get(""timezone"");
			 }
		 }
		 else if (!directEws) {
			 timezoneId = getTimezoneidFromOptions();
		 }
		 if (timezoneId == null) {
			 timezoneId = Settings.getProperty(""davmail.timezoneId"");
		 }
		 if (timezoneId == null) {
			 LOGGER.warn(""Unable to get user timezone, using GMT Standard Time. Set davmail.timezoneId setting to override this."");
			 timezoneId = ""GMT Standard Time"";
		 }
		 createCalendarFolder(""davmailtemp"", null);
		 EWSMethod.Item item = new EWSMethod.Item();
		 item.type = ""CalendarItem"";
		 if (!""Exchange2007_SP1"".equals(serverVersion)) {
			 SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"", Locale.ENGLISH);
			 dateFormatter.setTimeZone(GMT_TIMEZONE);
			 Calendar cal = Calendar.getInstance();
			 item.put(""Start"", dateFormatter.format(cal.getTime()));
			 cal.add(Calendar.DAY_OF_MONTH, 1);
			 item.put(""End"", dateFormatter.format(cal.getTime()));
			 item.put(""StartTimeZone"", timezoneId);
		 }
		 else {
			 item.put(""MeetingTimeZone"", timezoneId);
		 }
		 CreateItemMethod createItemMethod = new CreateItemMethod(MessageDisposition.SaveOnly, SendMeetingInvitations.SendToNone, getFolderId(""davmailtemp""), item);
		 executeMethod(createItemMethod);
		 item = createItemMethod.getResponseItem();
		 VCalendar vCalendar = new VCalendar(getContent(new ItemId(item)), email, null);
		 this.vTimezone = vCalendar.getVTimezone();
		 deleteFolder(""davmailtemp"");
	 }
	 catch (IOException e) {
		 LOGGER.warn(""Unable to get VTIMEZONE info: "" + e, e);
	 }
 }",0,0,1,0
"public Page getPreviousRenderedPage(){
	return previousRenderedPage;
}",0,0,0,0
"public static final class NameMappings {
	private final Map<AbstractElement, String> mappings;
	public NameMappings(DomainmodelGrammarAccess grammarAccess) {
		ImmutableMap.Builder<AbstractElement, String> builder = ImmutableMap.builder();
		init(builder, grammarAccess);
		this.mappings = builder.build();
	}
	public String getRuleName(AbstractElement element) {
		return mappings.get(element);
	}
	private static void init(ImmutableMap.Builder<AbstractElement, String> builder, DomainmodelGrammarAccess grammarAccess) {
		builder.put(grammarAccess.getAbstractElementAccess().getAlternatives(), ""rule__AbstractElement__Alternatives"");
		builder.put(grammarAccess.getFeatureAccess().getAlternatives(), ""rule__Feature__Alternatives"");
		builder.put(grammarAccess.getXAssignmentAccess().getAlternatives(), ""rule__XAssignment__Alternatives"");
		builder.put(grammarAccess.getOpMultiAssignAccess().getAlternatives(), ""rule__OpMultiAssign__Alternatives"");
		builder.put(grammarAccess.getOpEqualityAccess().getAlternatives(), ""rule__OpEquality__Alternatives"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getAlternatives_1(), ""rule__XRelationalExpression__Alternatives_1"");
		builder.put(grammarAccess.getOpCompareAccess().getAlternatives(), ""rule__OpCompare__Alternatives"");
		builder.put(grammarAccess.getOpOtherAccess().getAlternatives(), ""rule__OpOther__Alternatives"");
		builder.put(grammarAccess.getOpOtherAccess().getAlternatives_5_1(), ""rule__OpOther__Alternatives_5_1"");
		builder.put(grammarAccess.getOpOtherAccess().getAlternatives_6_1(), ""rule__OpOther__Alternatives_6_1"");
		builder.put(grammarAccess.getOpAddAccess().getAlternatives(), ""rule__OpAdd__Alternatives"");
		builder.put(grammarAccess.getOpMultiAccess().getAlternatives(), ""rule__OpMulti__Alternatives"");
		builder.put(grammarAccess.getXUnaryOperationAccess().getAlternatives(), ""rule__XUnaryOperation__Alternatives"");
		builder.put(grammarAccess.getOpUnaryAccess().getAlternatives(), ""rule__OpUnary__Alternatives"");
		builder.put(grammarAccess.getOpPostfixAccess().getAlternatives(), ""rule__OpPostfix__Alternatives"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getAlternatives_1(), ""rule__XMemberFeatureCall__Alternatives_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getAlternatives_1_0_0_0_1(), ""rule__XMemberFeatureCall__Alternatives_1_0_0_0_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getAlternatives_1_1_0_0_1(), ""rule__XMemberFeatureCall__Alternatives_1_1_0_0_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getAlternatives_1_1_3_1(), ""rule__XMemberFeatureCall__Alternatives_1_1_3_1"");
		builder.put(grammarAccess.getXPrimaryExpressionAccess().getAlternatives(), ""rule__XPrimaryExpression__Alternatives"");
		builder.put(grammarAccess.getXLiteralAccess().getAlternatives(), ""rule__XLiteral__Alternatives"");
		builder.put(grammarAccess.getXCollectionLiteralAccess().getAlternatives(), ""rule__XCollectionLiteral__Alternatives"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getAlternatives_2(), ""rule__XSwitchExpression__Alternatives_2"");
		builder.put(grammarAccess.getXCasePartAccess().getAlternatives_3(), ""rule__XCasePart__Alternatives_3"");
		builder.put(grammarAccess.getXExpressionOrVarDeclarationAccess().getAlternatives(), ""rule__XExpressionOrVarDeclaration__Alternatives"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getAlternatives_1(), ""rule__XVariableDeclaration__Alternatives_1"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getAlternatives_2(), ""rule__XVariableDeclaration__Alternatives_2"");
		builder.put(grammarAccess.getXFeatureCallAccess().getAlternatives_3_1(), ""rule__XFeatureCall__Alternatives_3_1"");
		builder.put(grammarAccess.getFeatureCallIDAccess().getAlternatives(), ""rule__FeatureCallID__Alternatives"");
		builder.put(grammarAccess.getIdOrSuperAccess().getAlternatives(), ""rule__IdOrSuper__Alternatives"");
		builder.put(grammarAccess.getXConstructorCallAccess().getAlternatives_4_1(), ""rule__XConstructorCall__Alternatives_4_1"");
		builder.put(grammarAccess.getXBooleanLiteralAccess().getAlternatives_1(), ""rule__XBooleanLiteral__Alternatives_1"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getAlternatives_3(), ""rule__XTryCatchFinallyExpression__Alternatives_3"");
		builder.put(grammarAccess.getNumberAccess().getAlternatives(), ""rule__Number__Alternatives"");
		builder.put(grammarAccess.getNumberAccess().getAlternatives_1_0(), ""rule__Number__Alternatives_1_0"");
		builder.put(grammarAccess.getNumberAccess().getAlternatives_1_1_1(), ""rule__Number__Alternatives_1_1_1"");
		builder.put(grammarAccess.getJvmTypeReferenceAccess().getAlternatives(), ""rule__JvmTypeReference__Alternatives"");
		builder.put(grammarAccess.getJvmArgumentTypeReferenceAccess().getAlternatives(), ""rule__JvmArgumentTypeReference__Alternatives"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getAlternatives_2(), ""rule__JvmWildcardTypeReference__Alternatives_2"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getAlternatives_1(), ""rule__XImportDeclaration__Alternatives_1"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getAlternatives_1_0_3(), ""rule__XImportDeclaration__Alternatives_1_0_3"");
		builder.put(grammarAccess.getDomainModelAccess().getGroup(), ""rule__DomainModel__Group__0"");
		builder.put(grammarAccess.getPackageDeclarationAccess().getGroup(), ""rule__PackageDeclaration__Group__0"");
		builder.put(grammarAccess.getEntityAccess().getGroup(), ""rule__Entity__Group__0"");
		builder.put(grammarAccess.getEntityAccess().getGroup_2(), ""rule__Entity__Group_2__0"");
		builder.put(grammarAccess.getPropertyAccess().getGroup(), ""rule__Property__Group__0"");
		builder.put(grammarAccess.getOperationAccess().getGroup(), ""rule__Operation__Group__0"");
		builder.put(grammarAccess.getOperationAccess().getGroup_3(), ""rule__Operation__Group_3__0"");
		builder.put(grammarAccess.getOperationAccess().getGroup_3_1(), ""rule__Operation__Group_3_1__0"");
		builder.put(grammarAccess.getOperationAccess().getGroup_5(), ""rule__Operation__Group_5__0"");
		builder.put(grammarAccess.getXAssignmentAccess().getGroup_0(), ""rule__XAssignment__Group_0__0"");
		builder.put(grammarAccess.getXAssignmentAccess().getGroup_1(), ""rule__XAssignment__Group_1__0"");
		builder.put(grammarAccess.getXAssignmentAccess().getGroup_1_1(), ""rule__XAssignment__Group_1_1__0"");
		builder.put(grammarAccess.getXAssignmentAccess().getGroup_1_1_0(), ""rule__XAssignment__Group_1_1_0__0"");
		builder.put(grammarAccess.getXAssignmentAccess().getGroup_1_1_0_0(), ""rule__XAssignment__Group_1_1_0_0__0"");
		builder.put(grammarAccess.getOpMultiAssignAccess().getGroup_5(), ""rule__OpMultiAssign__Group_5__0"");
		builder.put(grammarAccess.getOpMultiAssignAccess().getGroup_6(), ""rule__OpMultiAssign__Group_6__0"");
		builder.put(grammarAccess.getXOrExpressionAccess().getGroup(), ""rule__XOrExpression__Group__0"");
		builder.put(grammarAccess.getXOrExpressionAccess().getGroup_1(), ""rule__XOrExpression__Group_1__0"");
		builder.put(grammarAccess.getXOrExpressionAccess().getGroup_1_0(), ""rule__XOrExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXOrExpressionAccess().getGroup_1_0_0(), ""rule__XOrExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXAndExpressionAccess().getGroup(), ""rule__XAndExpression__Group__0"");
		builder.put(grammarAccess.getXAndExpressionAccess().getGroup_1(), ""rule__XAndExpression__Group_1__0"");
		builder.put(grammarAccess.getXAndExpressionAccess().getGroup_1_0(), ""rule__XAndExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXAndExpressionAccess().getGroup_1_0_0(), ""rule__XAndExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXEqualityExpressionAccess().getGroup(), ""rule__XEqualityExpression__Group__0"");
		builder.put(grammarAccess.getXEqualityExpressionAccess().getGroup_1(), ""rule__XEqualityExpression__Group_1__0"");
		builder.put(grammarAccess.getXEqualityExpressionAccess().getGroup_1_0(), ""rule__XEqualityExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXEqualityExpressionAccess().getGroup_1_0_0(), ""rule__XEqualityExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup(), ""rule__XRelationalExpression__Group__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup_1_0(), ""rule__XRelationalExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup_1_0_0(), ""rule__XRelationalExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup_1_0_0_0(), ""rule__XRelationalExpression__Group_1_0_0_0__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup_1_1(), ""rule__XRelationalExpression__Group_1_1__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup_1_1_0(), ""rule__XRelationalExpression__Group_1_1_0__0"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getGroup_1_1_0_0(), ""rule__XRelationalExpression__Group_1_1_0_0__0"");
		builder.put(grammarAccess.getOpCompareAccess().getGroup_1(), ""rule__OpCompare__Group_1__0"");
		builder.put(grammarAccess.getXOtherOperatorExpressionAccess().getGroup(), ""rule__XOtherOperatorExpression__Group__0"");
		builder.put(grammarAccess.getXOtherOperatorExpressionAccess().getGroup_1(), ""rule__XOtherOperatorExpression__Group_1__0"");
		builder.put(grammarAccess.getXOtherOperatorExpressionAccess().getGroup_1_0(), ""rule__XOtherOperatorExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXOtherOperatorExpressionAccess().getGroup_1_0_0(), ""rule__XOtherOperatorExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_2(), ""rule__OpOther__Group_2__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_5(), ""rule__OpOther__Group_5__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_5_1_0(), ""rule__OpOther__Group_5_1_0__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_5_1_0_0(), ""rule__OpOther__Group_5_1_0_0__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_6(), ""rule__OpOther__Group_6__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_6_1_0(), ""rule__OpOther__Group_6_1_0__0"");
		builder.put(grammarAccess.getOpOtherAccess().getGroup_6_1_0_0(), ""rule__OpOther__Group_6_1_0_0__0"");
		builder.put(grammarAccess.getXAdditiveExpressionAccess().getGroup(), ""rule__XAdditiveExpression__Group__0"");
		builder.put(grammarAccess.getXAdditiveExpressionAccess().getGroup_1(), ""rule__XAdditiveExpression__Group_1__0"");
		builder.put(grammarAccess.getXAdditiveExpressionAccess().getGroup_1_0(), ""rule__XAdditiveExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXAdditiveExpressionAccess().getGroup_1_0_0(), ""rule__XAdditiveExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXMultiplicativeExpressionAccess().getGroup(), ""rule__XMultiplicativeExpression__Group__0"");
		builder.put(grammarAccess.getXMultiplicativeExpressionAccess().getGroup_1(), ""rule__XMultiplicativeExpression__Group_1__0"");
		builder.put(grammarAccess.getXMultiplicativeExpressionAccess().getGroup_1_0(), ""rule__XMultiplicativeExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXMultiplicativeExpressionAccess().getGroup_1_0_0(), ""rule__XMultiplicativeExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXUnaryOperationAccess().getGroup_0(), ""rule__XUnaryOperation__Group_0__0"");
		builder.put(grammarAccess.getXCastedExpressionAccess().getGroup(), ""rule__XCastedExpression__Group__0"");
		builder.put(grammarAccess.getXCastedExpressionAccess().getGroup_1(), ""rule__XCastedExpression__Group_1__0"");
		builder.put(grammarAccess.getXCastedExpressionAccess().getGroup_1_0(), ""rule__XCastedExpression__Group_1_0__0"");
		builder.put(grammarAccess.getXCastedExpressionAccess().getGroup_1_0_0(), ""rule__XCastedExpression__Group_1_0_0__0"");
		builder.put(grammarAccess.getXPostfixOperationAccess().getGroup(), ""rule__XPostfixOperation__Group__0"");
		builder.put(grammarAccess.getXPostfixOperationAccess().getGroup_1(), ""rule__XPostfixOperation__Group_1__0"");
		builder.put(grammarAccess.getXPostfixOperationAccess().getGroup_1_0(), ""rule__XPostfixOperation__Group_1_0__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup(), ""rule__XMemberFeatureCall__Group__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_0(), ""rule__XMemberFeatureCall__Group_1_0__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_0_0(), ""rule__XMemberFeatureCall__Group_1_0_0__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_0_0_0(), ""rule__XMemberFeatureCall__Group_1_0_0_0__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1(), ""rule__XMemberFeatureCall__Group_1_1__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_0(), ""rule__XMemberFeatureCall__Group_1_1_0__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_0_0(), ""rule__XMemberFeatureCall__Group_1_1_0_0__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_1(), ""rule__XMemberFeatureCall__Group_1_1_1__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_1_2(), ""rule__XMemberFeatureCall__Group_1_1_1_2__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_3(), ""rule__XMemberFeatureCall__Group_1_1_3__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_3_1_1(), ""rule__XMemberFeatureCall__Group_1_1_3_1_1__0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getGroup_1_1_3_1_1_1(), ""rule__XMemberFeatureCall__Group_1_1_3_1_1_1__0"");
		builder.put(grammarAccess.getXSetLiteralAccess().getGroup(), ""rule__XSetLiteral__Group__0"");
		builder.put(grammarAccess.getXSetLiteralAccess().getGroup_3(), ""rule__XSetLiteral__Group_3__0"");
		builder.put(grammarAccess.getXSetLiteralAccess().getGroup_3_1(), ""rule__XSetLiteral__Group_3_1__0"");
		builder.put(grammarAccess.getXListLiteralAccess().getGroup(), ""rule__XListLiteral__Group__0"");
		builder.put(grammarAccess.getXListLiteralAccess().getGroup_3(), ""rule__XListLiteral__Group_3__0"");
		builder.put(grammarAccess.getXListLiteralAccess().getGroup_3_1(), ""rule__XListLiteral__Group_3_1__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup(), ""rule__XClosure__Group__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup_0(), ""rule__XClosure__Group_0__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup_0_0(), ""rule__XClosure__Group_0_0__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup_1(), ""rule__XClosure__Group_1__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup_1_0(), ""rule__XClosure__Group_1_0__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup_1_0_0(), ""rule__XClosure__Group_1_0_0__0"");
		builder.put(grammarAccess.getXClosureAccess().getGroup_1_0_0_1(), ""rule__XClosure__Group_1_0_0_1__0"");
		builder.put(grammarAccess.getXExpressionInClosureAccess().getGroup(), ""rule__XExpressionInClosure__Group__0"");
		builder.put(grammarAccess.getXExpressionInClosureAccess().getGroup_1(), ""rule__XExpressionInClosure__Group_1__0"");
		builder.put(grammarAccess.getXShortClosureAccess().getGroup(), ""rule__XShortClosure__Group__0"");
		builder.put(grammarAccess.getXShortClosureAccess().getGroup_0(), ""rule__XShortClosure__Group_0__0"");
		builder.put(grammarAccess.getXShortClosureAccess().getGroup_0_0(), ""rule__XShortClosure__Group_0_0__0"");
		builder.put(grammarAccess.getXShortClosureAccess().getGroup_0_0_1(), ""rule__XShortClosure__Group_0_0_1__0"");
		builder.put(grammarAccess.getXShortClosureAccess().getGroup_0_0_1_1(), ""rule__XShortClosure__Group_0_0_1_1__0"");
		builder.put(grammarAccess.getXParenthesizedExpressionAccess().getGroup(), ""rule__XParenthesizedExpression__Group__0"");
		builder.put(grammarAccess.getXIfExpressionAccess().getGroup(), ""rule__XIfExpression__Group__0"");
		builder.put(grammarAccess.getXIfExpressionAccess().getGroup_6(), ""rule__XIfExpression__Group_6__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup(), ""rule__XSwitchExpression__Group__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_2_0(), ""rule__XSwitchExpression__Group_2_0__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_2_0_0(), ""rule__XSwitchExpression__Group_2_0_0__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_2_0_0_0(), ""rule__XSwitchExpression__Group_2_0_0_0__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_2_1(), ""rule__XSwitchExpression__Group_2_1__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_2_1_0(), ""rule__XSwitchExpression__Group_2_1_0__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_2_1_0_0(), ""rule__XSwitchExpression__Group_2_1_0_0__0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getGroup_5(), ""rule__XSwitchExpression__Group_5__0"");
		builder.put(grammarAccess.getXCasePartAccess().getGroup(), ""rule__XCasePart__Group__0"");
		builder.put(grammarAccess.getXCasePartAccess().getGroup_2(), ""rule__XCasePart__Group_2__0"");
		builder.put(grammarAccess.getXCasePartAccess().getGroup_3_0(), ""rule__XCasePart__Group_3_0__0"");
		builder.put(grammarAccess.getXForLoopExpressionAccess().getGroup(), ""rule__XForLoopExpression__Group__0"");
		builder.put(grammarAccess.getXForLoopExpressionAccess().getGroup_0(), ""rule__XForLoopExpression__Group_0__0"");
		builder.put(grammarAccess.getXForLoopExpressionAccess().getGroup_0_0(), ""rule__XForLoopExpression__Group_0_0__0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getGroup(), ""rule__XBasicForLoopExpression__Group__0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getGroup_3(), ""rule__XBasicForLoopExpression__Group_3__0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getGroup_3_1(), ""rule__XBasicForLoopExpression__Group_3_1__0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getGroup_7(), ""rule__XBasicForLoopExpression__Group_7__0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getGroup_7_1(), ""rule__XBasicForLoopExpression__Group_7_1__0"");
		builder.put(grammarAccess.getXWhileExpressionAccess().getGroup(), ""rule__XWhileExpression__Group__0"");
		builder.put(grammarAccess.getXDoWhileExpressionAccess().getGroup(), ""rule__XDoWhileExpression__Group__0"");
		builder.put(grammarAccess.getXBlockExpressionAccess().getGroup(), ""rule__XBlockExpression__Group__0"");
		builder.put(grammarAccess.getXBlockExpressionAccess().getGroup_2(), ""rule__XBlockExpression__Group_2__0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getGroup(), ""rule__XVariableDeclaration__Group__0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getGroup_2_0(), ""rule__XVariableDeclaration__Group_2_0__0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getGroup_2_0_0(), ""rule__XVariableDeclaration__Group_2_0_0__0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getGroup_3(), ""rule__XVariableDeclaration__Group_3__0"");
		builder.put(grammarAccess.getJvmFormalParameterAccess().getGroup(), ""rule__JvmFormalParameter__Group__0"");
		builder.put(grammarAccess.getFullJvmFormalParameterAccess().getGroup(), ""rule__FullJvmFormalParameter__Group__0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getGroup(), ""rule__XFeatureCall__Group__0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getGroup_1(), ""rule__XFeatureCall__Group_1__0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getGroup_1_2(), ""rule__XFeatureCall__Group_1_2__0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getGroup_3(), ""rule__XFeatureCall__Group_3__0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getGroup_3_1_1(), ""rule__XFeatureCall__Group_3_1_1__0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getGroup_3_1_1_1(), ""rule__XFeatureCall__Group_3_1_1_1__0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getGroup(), ""rule__XConstructorCall__Group__0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getGroup_3(), ""rule__XConstructorCall__Group_3__0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getGroup_3_2(), ""rule__XConstructorCall__Group_3_2__0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getGroup_4(), ""rule__XConstructorCall__Group_4__0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getGroup_4_1_1(), ""rule__XConstructorCall__Group_4_1_1__0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getGroup_4_1_1_1(), ""rule__XConstructorCall__Group_4_1_1_1__0"");
		builder.put(grammarAccess.getXBooleanLiteralAccess().getGroup(), ""rule__XBooleanLiteral__Group__0"");
		builder.put(grammarAccess.getXNullLiteralAccess().getGroup(), ""rule__XNullLiteral__Group__0"");
		builder.put(grammarAccess.getXNumberLiteralAccess().getGroup(), ""rule__XNumberLiteral__Group__0"");
		builder.put(grammarAccess.getXStringLiteralAccess().getGroup(), ""rule__XStringLiteral__Group__0"");
		builder.put(grammarAccess.getXTypeLiteralAccess().getGroup(), ""rule__XTypeLiteral__Group__0"");
		builder.put(grammarAccess.getXThrowExpressionAccess().getGroup(), ""rule__XThrowExpression__Group__0"");
		builder.put(grammarAccess.getXReturnExpressionAccess().getGroup(), ""rule__XReturnExpression__Group__0"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getGroup(), ""rule__XTryCatchFinallyExpression__Group__0"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getGroup_3_0(), ""rule__XTryCatchFinallyExpression__Group_3_0__0"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getGroup_3_0_1(), ""rule__XTryCatchFinallyExpression__Group_3_0_1__0"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getGroup_3_1(), ""rule__XTryCatchFinallyExpression__Group_3_1__0"");
		builder.put(grammarAccess.getXSynchronizedExpressionAccess().getGroup(), ""rule__XSynchronizedExpression__Group__0"");
		builder.put(grammarAccess.getXSynchronizedExpressionAccess().getGroup_0(), ""rule__XSynchronizedExpression__Group_0__0"");
		builder.put(grammarAccess.getXSynchronizedExpressionAccess().getGroup_0_0(), ""rule__XSynchronizedExpression__Group_0_0__0"");
		builder.put(grammarAccess.getXCatchClauseAccess().getGroup(), ""rule__XCatchClause__Group__0"");
		builder.put(grammarAccess.getQualifiedNameAccess().getGroup(), ""rule__QualifiedName__Group__0"");
		builder.put(grammarAccess.getQualifiedNameAccess().getGroup_1(), ""rule__QualifiedName__Group_1__0"");
		builder.put(grammarAccess.getNumberAccess().getGroup_1(), ""rule__Number__Group_1__0"");
		builder.put(grammarAccess.getNumberAccess().getGroup_1_1(), ""rule__Number__Group_1_1__0"");
		builder.put(grammarAccess.getStaticQualifierAccess().getGroup(), ""rule__StaticQualifier__Group__0"");
		builder.put(grammarAccess.getJvmTypeReferenceAccess().getGroup_0(), ""rule__JvmTypeReference__Group_0__0"");
		builder.put(grammarAccess.getJvmTypeReferenceAccess().getGroup_0_1(), ""rule__JvmTypeReference__Group_0_1__0"");
		builder.put(grammarAccess.getJvmTypeReferenceAccess().getGroup_0_1_0(), ""rule__JvmTypeReference__Group_0_1_0__0"");
		builder.put(grammarAccess.getArrayBracketsAccess().getGroup(), ""rule__ArrayBrackets__Group__0"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getGroup(), ""rule__XFunctionTypeRef__Group__0"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getGroup_0(), ""rule__XFunctionTypeRef__Group_0__0"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getGroup_0_1(), ""rule__XFunctionTypeRef__Group_0_1__0"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getGroup_0_1_1(), ""rule__XFunctionTypeRef__Group_0_1_1__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup(), ""rule__JvmParameterizedTypeReference__Group__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1(), ""rule__JvmParameterizedTypeReference__Group_1__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1_2(), ""rule__JvmParameterizedTypeReference__Group_1_2__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1_4(), ""rule__JvmParameterizedTypeReference__Group_1_4__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1_4_0(), ""rule__JvmParameterizedTypeReference__Group_1_4_0__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1_4_0_0(), ""rule__JvmParameterizedTypeReference__Group_1_4_0_0__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1_4_2(), ""rule__JvmParameterizedTypeReference__Group_1_4_2__0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getGroup_1_4_2_2(), ""rule__JvmParameterizedTypeReference__Group_1_4_2_2__0"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getGroup(), ""rule__JvmWildcardTypeReference__Group__0"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getGroup_2_0(), ""rule__JvmWildcardTypeReference__Group_2_0__0"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getGroup_2_1(), ""rule__JvmWildcardTypeReference__Group_2_1__0"");
		builder.put(grammarAccess.getJvmUpperBoundAccess().getGroup(), ""rule__JvmUpperBound__Group__0"");
		builder.put(grammarAccess.getJvmUpperBoundAndedAccess().getGroup(), ""rule__JvmUpperBoundAnded__Group__0"");
		builder.put(grammarAccess.getJvmLowerBoundAccess().getGroup(), ""rule__JvmLowerBound__Group__0"");
		builder.put(grammarAccess.getJvmLowerBoundAndedAccess().getGroup(), ""rule__JvmLowerBoundAnded__Group__0"");
		builder.put(grammarAccess.getJvmTypeParameterAccess().getGroup(), ""rule__JvmTypeParameter__Group__0"");
		builder.put(grammarAccess.getJvmTypeParameterAccess().getGroup_1(), ""rule__JvmTypeParameter__Group_1__0"");
		builder.put(grammarAccess.getQualifiedNameWithWildcardAccess().getGroup(), ""rule__QualifiedNameWithWildcard__Group__0"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getGroup(), ""rule__XImportDeclaration__Group__0"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getGroup_1_0(), ""rule__XImportDeclaration__Group_1_0__0"");
		builder.put(grammarAccess.getQualifiedNameInStaticImportAccess().getGroup(), ""rule__QualifiedNameInStaticImport__Group__0"");
		builder.put(grammarAccess.getDomainModelAccess().getImportSectionAssignment_0(), ""rule__DomainModel__ImportSectionAssignment_0"");
		builder.put(grammarAccess.getDomainModelAccess().getElementsAssignment_1(), ""rule__DomainModel__ElementsAssignment_1"");
		builder.put(grammarAccess.getPackageDeclarationAccess().getNameAssignment_1(), ""rule__PackageDeclaration__NameAssignment_1"");
		builder.put(grammarAccess.getPackageDeclarationAccess().getElementsAssignment_3(), ""rule__PackageDeclaration__ElementsAssignment_3"");
		builder.put(grammarAccess.getEntityAccess().getNameAssignment_1(), ""rule__Entity__NameAssignment_1"");
		builder.put(grammarAccess.getEntityAccess().getSuperTypeAssignment_2_1(), ""rule__Entity__SuperTypeAssignment_2_1"");
		builder.put(grammarAccess.getEntityAccess().getFeaturesAssignment_4(), ""rule__Entity__FeaturesAssignment_4"");
		builder.put(grammarAccess.getPropertyAccess().getNameAssignment_0(), ""rule__Property__NameAssignment_0"");
		builder.put(grammarAccess.getPropertyAccess().getTypeAssignment_2(), ""rule__Property__TypeAssignment_2"");
		builder.put(grammarAccess.getOperationAccess().getNameAssignment_1(), ""rule__Operation__NameAssignment_1"");
		builder.put(grammarAccess.getOperationAccess().getParamsAssignment_3_0(), ""rule__Operation__ParamsAssignment_3_0"");
		builder.put(grammarAccess.getOperationAccess().getParamsAssignment_3_1_1(), ""rule__Operation__ParamsAssignment_3_1_1"");
		builder.put(grammarAccess.getOperationAccess().getTypeAssignment_5_1(), ""rule__Operation__TypeAssignment_5_1"");
		builder.put(grammarAccess.getOperationAccess().getBodyAssignment_6(), ""rule__Operation__BodyAssignment_6"");
		builder.put(grammarAccess.getXAssignmentAccess().getFeatureAssignment_0_1(), ""rule__XAssignment__FeatureAssignment_0_1"");
		builder.put(grammarAccess.getXAssignmentAccess().getValueAssignment_0_3(), ""rule__XAssignment__ValueAssignment_0_3"");
		builder.put(grammarAccess.getXAssignmentAccess().getFeatureAssignment_1_1_0_0_1(), ""rule__XAssignment__FeatureAssignment_1_1_0_0_1"");
		builder.put(grammarAccess.getXAssignmentAccess().getRightOperandAssignment_1_1_1(), ""rule__XAssignment__RightOperandAssignment_1_1_1"");
		builder.put(grammarAccess.getXOrExpressionAccess().getFeatureAssignment_1_0_0_1(), ""rule__XOrExpression__FeatureAssignment_1_0_0_1"");
		builder.put(grammarAccess.getXOrExpressionAccess().getRightOperandAssignment_1_1(), ""rule__XOrExpression__RightOperandAssignment_1_1"");
		builder.put(grammarAccess.getXAndExpressionAccess().getFeatureAssignment_1_0_0_1(), ""rule__XAndExpression__FeatureAssignment_1_0_0_1"");
		builder.put(grammarAccess.getXAndExpressionAccess().getRightOperandAssignment_1_1(), ""rule__XAndExpression__RightOperandAssignment_1_1"");
		builder.put(grammarAccess.getXEqualityExpressionAccess().getFeatureAssignment_1_0_0_1(), ""rule__XEqualityExpression__FeatureAssignment_1_0_0_1"");
		builder.put(grammarAccess.getXEqualityExpressionAccess().getRightOperandAssignment_1_1(), ""rule__XEqualityExpression__RightOperandAssignment_1_1"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getTypeAssignment_1_0_1(), ""rule__XRelationalExpression__TypeAssignment_1_0_1"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getFeatureAssignment_1_1_0_0_1(), ""rule__XRelationalExpression__FeatureAssignment_1_1_0_0_1"");
		builder.put(grammarAccess.getXRelationalExpressionAccess().getRightOperandAssignment_1_1_1(), ""rule__XRelationalExpression__RightOperandAssignment_1_1_1"");
		builder.put(grammarAccess.getXOtherOperatorExpressionAccess().getFeatureAssignment_1_0_0_1(), ""rule__XOtherOperatorExpression__FeatureAssignment_1_0_0_1"");
		builder.put(grammarAccess.getXOtherOperatorExpressionAccess().getRightOperandAssignment_1_1(), ""rule__XOtherOperatorExpression__RightOperandAssignment_1_1"");
		builder.put(grammarAccess.getXAdditiveExpressionAccess().getFeatureAssignment_1_0_0_1(), ""rule__XAdditiveExpression__FeatureAssignment_1_0_0_1"");
		builder.put(grammarAccess.getXAdditiveExpressionAccess().getRightOperandAssignment_1_1(), ""rule__XAdditiveExpression__RightOperandAssignment_1_1"");
		builder.put(grammarAccess.getXMultiplicativeExpressionAccess().getFeatureAssignment_1_0_0_1(), ""rule__XMultiplicativeExpression__FeatureAssignment_1_0_0_1"");
		builder.put(grammarAccess.getXMultiplicativeExpressionAccess().getRightOperandAssignment_1_1(), ""rule__XMultiplicativeExpression__RightOperandAssignment_1_1"");
		builder.put(grammarAccess.getXUnaryOperationAccess().getFeatureAssignment_0_1(), ""rule__XUnaryOperation__FeatureAssignment_0_1"");
		builder.put(grammarAccess.getXUnaryOperationAccess().getOperandAssignment_0_2(), ""rule__XUnaryOperation__OperandAssignment_0_2"");
		builder.put(grammarAccess.getXCastedExpressionAccess().getTypeAssignment_1_1(), ""rule__XCastedExpression__TypeAssignment_1_1"");
		builder.put(grammarAccess.getXPostfixOperationAccess().getFeatureAssignment_1_0_1(), ""rule__XPostfixOperation__FeatureAssignment_1_0_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getExplicitStaticAssignment_1_0_0_0_1_1(), ""rule__XMemberFeatureCall__ExplicitStaticAssignment_1_0_0_0_1_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getFeatureAssignment_1_0_0_0_2(), ""rule__XMemberFeatureCall__FeatureAssignment_1_0_0_0_2"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getValueAssignment_1_0_1(), ""rule__XMemberFeatureCall__ValueAssignment_1_0_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getNullSafeAssignment_1_1_0_0_1_1(), ""rule__XMemberFeatureCall__NullSafeAssignment_1_1_0_0_1_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getExplicitStaticAssignment_1_1_0_0_1_2(), ""rule__XMemberFeatureCall__ExplicitStaticAssignment_1_1_0_0_1_2"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getTypeArgumentsAssignment_1_1_1_1(), ""rule__XMemberFeatureCall__TypeArgumentsAssignment_1_1_1_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getTypeArgumentsAssignment_1_1_1_2_1(), ""rule__XMemberFeatureCall__TypeArgumentsAssignment_1_1_1_2_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getFeatureAssignment_1_1_2(), ""rule__XMemberFeatureCall__FeatureAssignment_1_1_2"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getExplicitOperationCallAssignment_1_1_3_0(), ""rule__XMemberFeatureCall__ExplicitOperationCallAssignment_1_1_3_0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getMemberCallArgumentsAssignment_1_1_3_1_0(), ""rule__XMemberFeatureCall__MemberCallArgumentsAssignment_1_1_3_1_0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getMemberCallArgumentsAssignment_1_1_3_1_1_0(), ""rule__XMemberFeatureCall__MemberCallArgumentsAssignment_1_1_3_1_1_0"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getMemberCallArgumentsAssignment_1_1_3_1_1_1_1(), ""rule__XMemberFeatureCall__MemberCallArgumentsAssignment_1_1_3_1_1_1_1"");
		builder.put(grammarAccess.getXMemberFeatureCallAccess().getMemberCallArgumentsAssignment_1_1_4(), ""rule__XMemberFeatureCall__MemberCallArgumentsAssignment_1_1_4"");
		builder.put(grammarAccess.getXSetLiteralAccess().getElementsAssignment_3_0(), ""rule__XSetLiteral__ElementsAssignment_3_0"");
		builder.put(grammarAccess.getXSetLiteralAccess().getElementsAssignment_3_1_1(), ""rule__XSetLiteral__ElementsAssignment_3_1_1"");
		builder.put(grammarAccess.getXListLiteralAccess().getElementsAssignment_3_0(), ""rule__XListLiteral__ElementsAssignment_3_0"");
		builder.put(grammarAccess.getXListLiteralAccess().getElementsAssignment_3_1_1(), ""rule__XListLiteral__ElementsAssignment_3_1_1"");
		builder.put(grammarAccess.getXClosureAccess().getDeclaredFormalParametersAssignment_1_0_0_0(), ""rule__XClosure__DeclaredFormalParametersAssignment_1_0_0_0"");
		builder.put(grammarAccess.getXClosureAccess().getDeclaredFormalParametersAssignment_1_0_0_1_1(), ""rule__XClosure__DeclaredFormalParametersAssignment_1_0_0_1_1"");
		builder.put(grammarAccess.getXClosureAccess().getExplicitSyntaxAssignment_1_0_1(), ""rule__XClosure__ExplicitSyntaxAssignment_1_0_1"");
		builder.put(grammarAccess.getXClosureAccess().getExpressionAssignment_2(), ""rule__XClosure__ExpressionAssignment_2"");
		builder.put(grammarAccess.getXExpressionInClosureAccess().getExpressionsAssignment_1_0(), ""rule__XExpressionInClosure__ExpressionsAssignment_1_0"");
		builder.put(grammarAccess.getXShortClosureAccess().getDeclaredFormalParametersAssignment_0_0_1_0(), ""rule__XShortClosure__DeclaredFormalParametersAssignment_0_0_1_0"");
		builder.put(grammarAccess.getXShortClosureAccess().getDeclaredFormalParametersAssignment_0_0_1_1_1(), ""rule__XShortClosure__DeclaredFormalParametersAssignment_0_0_1_1_1"");
		builder.put(grammarAccess.getXShortClosureAccess().getExplicitSyntaxAssignment_0_0_2(), ""rule__XShortClosure__ExplicitSyntaxAssignment_0_0_2"");
		builder.put(grammarAccess.getXShortClosureAccess().getExpressionAssignment_1(), ""rule__XShortClosure__ExpressionAssignment_1"");
		builder.put(grammarAccess.getXIfExpressionAccess().getIfAssignment_3(), ""rule__XIfExpression__IfAssignment_3"");
		builder.put(grammarAccess.getXIfExpressionAccess().getThenAssignment_5(), ""rule__XIfExpression__ThenAssignment_5"");
		builder.put(grammarAccess.getXIfExpressionAccess().getElseAssignment_6_1(), ""rule__XIfExpression__ElseAssignment_6_1"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getDeclaredParamAssignment_2_0_0_0_1(), ""rule__XSwitchExpression__DeclaredParamAssignment_2_0_0_0_1"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getSwitchAssignment_2_0_1(), ""rule__XSwitchExpression__SwitchAssignment_2_0_1"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getDeclaredParamAssignment_2_1_0_0_0(), ""rule__XSwitchExpression__DeclaredParamAssignment_2_1_0_0_0"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getSwitchAssignment_2_1_1(), ""rule__XSwitchExpression__SwitchAssignment_2_1_1"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getCasesAssignment_4(), ""rule__XSwitchExpression__CasesAssignment_4"");
		builder.put(grammarAccess.getXSwitchExpressionAccess().getDefaultAssignment_5_2(), ""rule__XSwitchExpression__DefaultAssignment_5_2"");
		builder.put(grammarAccess.getXCasePartAccess().getTypeGuardAssignment_1(), ""rule__XCasePart__TypeGuardAssignment_1"");
		builder.put(grammarAccess.getXCasePartAccess().getCaseAssignment_2_1(), ""rule__XCasePart__CaseAssignment_2_1"");
		builder.put(grammarAccess.getXCasePartAccess().getThenAssignment_3_0_1(), ""rule__XCasePart__ThenAssignment_3_0_1"");
		builder.put(grammarAccess.getXCasePartAccess().getFallThroughAssignment_3_1(), ""rule__XCasePart__FallThroughAssignment_3_1"");
		builder.put(grammarAccess.getXForLoopExpressionAccess().getDeclaredParamAssignment_0_0_3(), ""rule__XForLoopExpression__DeclaredParamAssignment_0_0_3"");
		builder.put(grammarAccess.getXForLoopExpressionAccess().getForExpressionAssignment_1(), ""rule__XForLoopExpression__ForExpressionAssignment_1"");
		builder.put(grammarAccess.getXForLoopExpressionAccess().getEachExpressionAssignment_3(), ""rule__XForLoopExpression__EachExpressionAssignment_3"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getInitExpressionsAssignment_3_0(), ""rule__XBasicForLoopExpression__InitExpressionsAssignment_3_0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getInitExpressionsAssignment_3_1_1(), ""rule__XBasicForLoopExpression__InitExpressionsAssignment_3_1_1"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getExpressionAssignment_5(), ""rule__XBasicForLoopExpression__ExpressionAssignment_5"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getUpdateExpressionsAssignment_7_0(), ""rule__XBasicForLoopExpression__UpdateExpressionsAssignment_7_0"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getUpdateExpressionsAssignment_7_1_1(), ""rule__XBasicForLoopExpression__UpdateExpressionsAssignment_7_1_1"");
		builder.put(grammarAccess.getXBasicForLoopExpressionAccess().getEachExpressionAssignment_9(), ""rule__XBasicForLoopExpression__EachExpressionAssignment_9"");
		builder.put(grammarAccess.getXWhileExpressionAccess().getPredicateAssignment_3(), ""rule__XWhileExpression__PredicateAssignment_3"");
		builder.put(grammarAccess.getXWhileExpressionAccess().getBodyAssignment_5(), ""rule__XWhileExpression__BodyAssignment_5"");
		builder.put(grammarAccess.getXDoWhileExpressionAccess().getBodyAssignment_2(), ""rule__XDoWhileExpression__BodyAssignment_2"");
		builder.put(grammarAccess.getXDoWhileExpressionAccess().getPredicateAssignment_5(), ""rule__XDoWhileExpression__PredicateAssignment_5"");
		builder.put(grammarAccess.getXBlockExpressionAccess().getExpressionsAssignment_2_0(), ""rule__XBlockExpression__ExpressionsAssignment_2_0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getWriteableAssignment_1_0(), ""rule__XVariableDeclaration__WriteableAssignment_1_0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getTypeAssignment_2_0_0_0(), ""rule__XVariableDeclaration__TypeAssignment_2_0_0_0"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getNameAssignment_2_0_0_1(), ""rule__XVariableDeclaration__NameAssignment_2_0_0_1"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getNameAssignment_2_1(), ""rule__XVariableDeclaration__NameAssignment_2_1"");
		builder.put(grammarAccess.getXVariableDeclarationAccess().getRightAssignment_3_1(), ""rule__XVariableDeclaration__RightAssignment_3_1"");
		builder.put(grammarAccess.getJvmFormalParameterAccess().getParameterTypeAssignment_0(), ""rule__JvmFormalParameter__ParameterTypeAssignment_0"");
		builder.put(grammarAccess.getJvmFormalParameterAccess().getNameAssignment_1(), ""rule__JvmFormalParameter__NameAssignment_1"");
		builder.put(grammarAccess.getFullJvmFormalParameterAccess().getParameterTypeAssignment_0(), ""rule__FullJvmFormalParameter__ParameterTypeAssignment_0"");
		builder.put(grammarAccess.getFullJvmFormalParameterAccess().getNameAssignment_1(), ""rule__FullJvmFormalParameter__NameAssignment_1"");
		builder.put(grammarAccess.getXFeatureCallAccess().getTypeArgumentsAssignment_1_1(), ""rule__XFeatureCall__TypeArgumentsAssignment_1_1"");
		builder.put(grammarAccess.getXFeatureCallAccess().getTypeArgumentsAssignment_1_2_1(), ""rule__XFeatureCall__TypeArgumentsAssignment_1_2_1"");
		builder.put(grammarAccess.getXFeatureCallAccess().getFeatureAssignment_2(), ""rule__XFeatureCall__FeatureAssignment_2"");
		builder.put(grammarAccess.getXFeatureCallAccess().getExplicitOperationCallAssignment_3_0(), ""rule__XFeatureCall__ExplicitOperationCallAssignment_3_0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getFeatureCallArgumentsAssignment_3_1_0(), ""rule__XFeatureCall__FeatureCallArgumentsAssignment_3_1_0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getFeatureCallArgumentsAssignment_3_1_1_0(), ""rule__XFeatureCall__FeatureCallArgumentsAssignment_3_1_1_0"");
		builder.put(grammarAccess.getXFeatureCallAccess().getFeatureCallArgumentsAssignment_3_1_1_1_1(), ""rule__XFeatureCall__FeatureCallArgumentsAssignment_3_1_1_1_1"");
		builder.put(grammarAccess.getXFeatureCallAccess().getFeatureCallArgumentsAssignment_4(), ""rule__XFeatureCall__FeatureCallArgumentsAssignment_4"");
		builder.put(grammarAccess.getXConstructorCallAccess().getConstructorAssignment_2(), ""rule__XConstructorCall__ConstructorAssignment_2"");
		builder.put(grammarAccess.getXConstructorCallAccess().getTypeArgumentsAssignment_3_1(), ""rule__XConstructorCall__TypeArgumentsAssignment_3_1"");
		builder.put(grammarAccess.getXConstructorCallAccess().getTypeArgumentsAssignment_3_2_1(), ""rule__XConstructorCall__TypeArgumentsAssignment_3_2_1"");
		builder.put(grammarAccess.getXConstructorCallAccess().getExplicitConstructorCallAssignment_4_0(), ""rule__XConstructorCall__ExplicitConstructorCallAssignment_4_0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getArgumentsAssignment_4_1_0(), ""rule__XConstructorCall__ArgumentsAssignment_4_1_0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getArgumentsAssignment_4_1_1_0(), ""rule__XConstructorCall__ArgumentsAssignment_4_1_1_0"");
		builder.put(grammarAccess.getXConstructorCallAccess().getArgumentsAssignment_4_1_1_1_1(), ""rule__XConstructorCall__ArgumentsAssignment_4_1_1_1_1"");
		builder.put(grammarAccess.getXConstructorCallAccess().getArgumentsAssignment_5(), ""rule__XConstructorCall__ArgumentsAssignment_5"");
		builder.put(grammarAccess.getXBooleanLiteralAccess().getIsTrueAssignment_1_1(), ""rule__XBooleanLiteral__IsTrueAssignment_1_1"");
		builder.put(grammarAccess.getXNumberLiteralAccess().getValueAssignment_1(), ""rule__XNumberLiteral__ValueAssignment_1"");
		builder.put(grammarAccess.getXStringLiteralAccess().getValueAssignment_1(), ""rule__XStringLiteral__ValueAssignment_1"");
		builder.put(grammarAccess.getXTypeLiteralAccess().getTypeAssignment_3(), ""rule__XTypeLiteral__TypeAssignment_3"");
		builder.put(grammarAccess.getXTypeLiteralAccess().getArrayDimensionsAssignment_4(), ""rule__XTypeLiteral__ArrayDimensionsAssignment_4"");
		builder.put(grammarAccess.getXThrowExpressionAccess().getExpressionAssignment_2(), ""rule__XThrowExpression__ExpressionAssignment_2"");
		builder.put(grammarAccess.getXReturnExpressionAccess().getExpressionAssignment_2(), ""rule__XReturnExpression__ExpressionAssignment_2"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getExpressionAssignment_2(), ""rule__XTryCatchFinallyExpression__ExpressionAssignment_2"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getCatchClausesAssignment_3_0_0(), ""rule__XTryCatchFinallyExpression__CatchClausesAssignment_3_0_0"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getFinallyExpressionAssignment_3_0_1_1(), ""rule__XTryCatchFinallyExpression__FinallyExpressionAssignment_3_0_1_1"");
		builder.put(grammarAccess.getXTryCatchFinallyExpressionAccess().getFinallyExpressionAssignment_3_1_1(), ""rule__XTryCatchFinallyExpression__FinallyExpressionAssignment_3_1_1"");
		builder.put(grammarAccess.getXSynchronizedExpressionAccess().getParamAssignment_1(), ""rule__XSynchronizedExpression__ParamAssignment_1"");
		builder.put(grammarAccess.getXSynchronizedExpressionAccess().getExpressionAssignment_3(), ""rule__XSynchronizedExpression__ExpressionAssignment_3"");
		builder.put(grammarAccess.getXCatchClauseAccess().getDeclaredParamAssignment_2(), ""rule__XCatchClause__DeclaredParamAssignment_2"");
		builder.put(grammarAccess.getXCatchClauseAccess().getExpressionAssignment_4(), ""rule__XCatchClause__ExpressionAssignment_4"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getParamTypesAssignment_0_1_0(), ""rule__XFunctionTypeRef__ParamTypesAssignment_0_1_0"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getParamTypesAssignment_0_1_1_1(), ""rule__XFunctionTypeRef__ParamTypesAssignment_0_1_1_1"");
		builder.put(grammarAccess.getXFunctionTypeRefAccess().getReturnTypeAssignment_2(), ""rule__XFunctionTypeRef__ReturnTypeAssignment_2"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getTypeAssignment_0(), ""rule__JvmParameterizedTypeReference__TypeAssignment_0"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsAssignment_1_1(), ""rule__JvmParameterizedTypeReference__ArgumentsAssignment_1_1"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsAssignment_1_2_1(), ""rule__JvmParameterizedTypeReference__ArgumentsAssignment_1_2_1"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getTypeAssignment_1_4_1(), ""rule__JvmParameterizedTypeReference__TypeAssignment_1_4_1"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsAssignment_1_4_2_1(), ""rule__JvmParameterizedTypeReference__ArgumentsAssignment_1_4_2_1"");
		builder.put(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsAssignment_1_4_2_2_1(), ""rule__JvmParameterizedTypeReference__ArgumentsAssignment_1_4_2_2_1"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getConstraintsAssignment_2_0_0(), ""rule__JvmWildcardTypeReference__ConstraintsAssignment_2_0_0"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getConstraintsAssignment_2_0_1(), ""rule__JvmWildcardTypeReference__ConstraintsAssignment_2_0_1"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getConstraintsAssignment_2_1_0(), ""rule__JvmWildcardTypeReference__ConstraintsAssignment_2_1_0"");
		builder.put(grammarAccess.getJvmWildcardTypeReferenceAccess().getConstraintsAssignment_2_1_1(), ""rule__JvmWildcardTypeReference__ConstraintsAssignment_2_1_1"");
		builder.put(grammarAccess.getJvmUpperBoundAccess().getTypeReferenceAssignment_1(), ""rule__JvmUpperBound__TypeReferenceAssignment_1"");
		builder.put(grammarAccess.getJvmUpperBoundAndedAccess().getTypeReferenceAssignment_1(), ""rule__JvmUpperBoundAnded__TypeReferenceAssignment_1"");
		builder.put(grammarAccess.getJvmLowerBoundAccess().getTypeReferenceAssignment_1(), ""rule__JvmLowerBound__TypeReferenceAssignment_1"");
		builder.put(grammarAccess.getJvmLowerBoundAndedAccess().getTypeReferenceAssignment_1(), ""rule__JvmLowerBoundAnded__TypeReferenceAssignment_1"");
		builder.put(grammarAccess.getJvmTypeParameterAccess().getNameAssignment_0(), ""rule__JvmTypeParameter__NameAssignment_0"");
		builder.put(grammarAccess.getJvmTypeParameterAccess().getConstraintsAssignment_1_0(), ""rule__JvmTypeParameter__ConstraintsAssignment_1_0"");
		builder.put(grammarAccess.getJvmTypeParameterAccess().getConstraintsAssignment_1_1(), ""rule__JvmTypeParameter__ConstraintsAssignment_1_1"");
		builder.put(grammarAccess.getXImportSectionAccess().getImportDeclarationsAssignment(), ""rule__XImportSection__ImportDeclarationsAssignment"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getStaticAssignment_1_0_0(), ""rule__XImportDeclaration__StaticAssignment_1_0_0"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getExtensionAssignment_1_0_1(), ""rule__XImportDeclaration__ExtensionAssignment_1_0_1"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getImportedTypeAssignment_1_0_2(), ""rule__XImportDeclaration__ImportedTypeAssignment_1_0_2"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getWildcardAssignment_1_0_3_0(), ""rule__XImportDeclaration__WildcardAssignment_1_0_3_0"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getMemberNameAssignment_1_0_3_1(), ""rule__XImportDeclaration__MemberNameAssignment_1_0_3_1"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getImportedTypeAssignment_1_1(), ""rule__XImportDeclaration__ImportedTypeAssignment_1_1"");
		builder.put(grammarAccess.getXImportDeclarationAccess().getImportedNamespaceAssignment_1_2(), ""rule__XImportDeclaration__ImportedNamespaceAssignment_1_2"");
	}
}",0,0,0,0
"private static int[] getIntArray(String string) {
	 if (string.equals(""[]"")) {
		 return new int[]{
		}
		;
	 }
	 string = string.substring(1, string.length() - 1);
	 String[] splits = string.split("","");
	 int[] array = new int[splits.length];
	 for (int i = 0;
	 i < splits.length;
	 i++) {
		 array[i] = Integer.parseInt(splits[i]);
	 }
	 return array;
 }",0,0,1,0
"public HTMLDocument handleURL(String suburl, HTTPSession sess1, HTTPRequestHeader head) throws WebMailException, ServletException {
	if(sess1 == null) {
		 throw new WebMailException(""No session was given. If you feel this is incorrect, please contact your system administrator"");
	}
	WebMailSession session=(WebMailSession)sess1;
	UserData user=session.getUser();
	HTMLDocument content;
	Locale locale = user.getPreferredLocale();
	session.storeMessage(head);
	if(head.isContentSet(""SEND"")) {
		 try {
			MimeMessage msg=new MimeMessage(mailsession);
			Address from[]=new Address[1];
			try {
				 from[0]=new InternetAddress( TranscodeUtil.transcodeThenEncodeByLocale(session.getUser().getEmail(), null, locale), TranscodeUtil.transcodeThenEncodeByLocale(session.getUser().getFullName(), null, locale) );
			}
			 catch(UnsupportedEncodingException e) {
				 store.log(Storage.LOG_WARN, ""Unsupported Encoding while trying to send message: ""+e.getMessage());
				 from[0]=new InternetAddress(session.getUser().getEmail(), session.getUser().getFullName());
			}
			StringTokenizer t;
			try {
				 t = new StringTokenizer(TranscodeUtil.transcodeThenEncodeByLocale(head.getContent(""TO""), null, locale).trim(), "","");
			}
			 catch(UnsupportedEncodingException e) {
				 store.log(Storage.LOG_WARN, ""Unsupported Encoding while trying to send message: ""+e.getMessage());
				 t=new StringTokenizer(head.getContent(""TO"").trim(),"",;
				"");
			}
			if(t.countTokens()<1) {
				 throw new MessagingException(""The recipient field must not be empty!"");
			}
			Address to[]=new Address[t.countTokens()];
			int i=0;
			while(t.hasMoreTokens()) {
				 to[i]=new InternetAddress(t.nextToken().trim());
				 i++;
			}
			try {
				 t = new StringTokenizer(TranscodeUtil.transcodeThenEncodeByLocale(head.getContent(""CC""), null, locale).trim(), "","");
			}
			 catch(UnsupportedEncodingException e) {
				 store.log(Storage.LOG_WARN, ""Unsupported Encoding while trying to send message: ""+e.getMessage());
				 t=new StringTokenizer(head.getContent(""CC"").trim(),"",;
				"");
			}
			Address cc[]=new Address[t.countTokens()];
			i=0;
			while(t.hasMoreTokens()) {
				 cc[i]=new InternetAddress(t.nextToken().trim());
				 i++;
			}
			try {
				 t = new StringTokenizer(TranscodeUtil.transcodeThenEncodeByLocale(head.getContent(""BCC""), null, locale).trim(), "","");
			}
			 catch(UnsupportedEncodingException e) {
				 store.log(Storage.LOG_WARN, ""Unsupported Encoding while trying to send message: ""+e.getMessage());
				 t=new StringTokenizer(head.getContent(""BCC"").trim(),"",;
				"");
			}
			Address bcc[]=new Address[t.countTokens()];
			i=0;
			while(t.hasMoreTokens()) {
				 bcc[i]=new InternetAddress(t.nextToken().trim());
				 i++;
			}
			session.setSent(false);
			msg.addFrom(from);
			if(to.length > 0) {
				 msg.addRecipients(Message.RecipientType.TO,to);
			}
			if(cc.length > 0) {
				 msg.addRecipients(Message.RecipientType.CC,cc);
			}
			if(bcc.length > 0) {
				 msg.addRecipients(Message.RecipientType.BCC,bcc);
			}
			msg.addHeader(""X-Mailer"",WebMailServer.getVersion()+"", ""+getName()+"" plugin v""+getVersion());
			String subject = null;
			if(!head.isContentSet(""SUBJECT"")) {
				 subject=""no subject"";
			}
			 else {
				 try {
					subject = TranscodeUtil.transcodeThenEncodeByLocale(head.getContent(""SUBJECT""), ""ISO8859_1"", locale);
				 }
				 catch(UnsupportedEncodingException e) {
					store.log(Storage.LOG_WARN,""Unsupported Encoding while trying to send message: ""+e.getMessage());
					subject=head.getContent(""SUBJECT"");
				 }
			 }
			msg.addHeader(""Subject"",subject);
			if(head.isContentSet(""REPLY-TO"")) {
				 msg.addHeader(""Reply-To"", TranscodeUtil.transcodeThenEncodeByLocale(head.getContent(""REPLY-TO""), ""ISO8859_1"", locale));
			}
			msg.setSentDate(new Date(System.currentTimeMillis()));
			String contnt=head.getContent(""BODY"");
			String charset=""utf-8"";
			MimeMultipart cont=new MimeMultipart();
			MimeBodyPart txt=new MimeBodyPart();
			contnt = new String(contnt.getBytes(""ISO8859_1""), ""UTF-8"");
			if (locale.getLanguage().equals(""zh"") && locale.getCountry().equals(""TW"")) {
				 txt.setText(contnt, ""Big5"");
				 txt.setHeader(""Content-Type"",""text/plain;
				 charset=\""Big5\"""");
				 txt.setHeader(""Content-Transfer-Encoding"", ""quoted-printable"");
			 }
			 else {
				 txt.setText(contnt,""utf-8"");
				 txt.setHeader(""Content-Type"",""text/plain;
				 charset=\""utf-8\"""");
				 txt.setHeader(""Content-Transfer-Encoding"", ""quoted-printable"");
			 }
			cont.addBodyPart(txt);
			if(store.getConfig(""ADVERTISEMENT ATTACH"").equals(""YES"")) {
				 MimeBodyPart adv=new MimeBodyPart();
				 String file="""";
				 if(store.getConfig(""ADVERTISEMENT SIGNATURE PATH"").startsWith(""/"")) {
					file=store.getConfig(""ADVERTISEMENT SIGNATURE PATH"");
				 }
				 else {
					file=parent.getProperty(""webmail.data.path"")+System.getProperty(""file.separator"")+ store.getConfig(""ADVERTISEMENT SIGNATURE PATH"");
				 }
				 String advcont="""";
				 try {
					BufferedReader fin=new BufferedReader(new FileReader(file));
					String line=fin.readLine();
					while(line!= null && !line.equals("""")) {
						 advcont+=line+""\n"";
						 line=fin.readLine();
					}
					fin.close();
				 }
				 catch(IOException ex) {
				}
				 if (locale.getLanguage().equals(""zh"") &&locale.getCountry().equals(""TW"")) {
					advcont = new String(advcont.getBytes(), ""Big5"");
					adv.setText(advcont,""Big5"");
					adv.setHeader(""Content-Type"",""text/plain;
					 charset=\""Big5\"""");
					adv.setHeader(""Content-Transfer-Encoding"", ""quoted-printable"");
				 }
				 else {
					advcont = new String(advcont.getBytes(), ""UTF-8"");
					 adv.setText(advcont,""utf-8"");
					 adv.setHeader(""Content-Type"",""text/plain;
					 charset=\""utf-8\"""");
					 adv.setHeader(""Content-Transfer-Encoding"", ""quoted-printable"");
				 }
				 cont.addBodyPart(adv);
			}
			Enumeration atts=session.getAttachments().keys();
			while(atts.hasMoreElements()) {
				 ByteStore bs=session.getAttachment((String)atts.nextElement());
				 InternetHeaders ih=new InternetHeaders();
				 ih.addHeader(""Content-Type"",bs.getContentType());
				 ih.addHeader(""Content-Transfer-Encoding"",""BASE64"");
				 PipedInputStream pin=new PipedInputStream();
				 PipedOutputStream pout=new PipedOutputStream(pin);
				 StreamConnector sconn=new StreamConnector(pin,(int)(bs.getSize()*1.6)+1000);
				 BufferedOutputStream encoder=new BufferedOutputStream(MimeUtility.encode(pout,""BASE64""));
				 encoder.write(bs.getBytes());
				 encoder.flush();
				 encoder.close();
				 MimeBodyPart att1=new MimeBodyPart(ih,sconn.getResult().getBytes());
				 att1.addHeader(""Content-Type"",bs.getContentType());
				 att1.setDescription(bs.getDescription(),""utf-8"");
				 String fileName = bs.getName();
				 System.err.println(""fileName: "" + fileName);
				 if (locale.getLanguage().equals(""zh"") && locale.getCountry().equals(""TW"")) {
					fileName = MimeUtility.encodeText(fileName, ""Big5"", null);
				 }
				 att1.setFileName(fileName);
				 cont.addBodyPart(att1);
			}
			msg.setContent(cont);
			msg.saveChanges();
			boolean savesuccess=true;
			msg.setHeader(""Message-ID"",session.getUserModel().getWorkMessage().getAttribute(""msgid""));
			if(session.getUser().wantsSaveSent()) {
				 String folderhash=session.getUser().getSentFolder();
				 try {
					Folder folder=session.getFolder(folderhash);
					Message[] m=new Message[1];
					m[0]=msg;
					folder.appendMessages(m);
				 }
				 catch(MessagingException e) {
					savesuccess=false;
				 }
				 catch(NullPointerException e) {
					savesuccess=false;
				 }
			}
			boolean sendsuccess=false;
			try {
				 Transport.send(msg);
				 Address sent[]=new Address[to.length+cc.length+bcc.length];
				 int c1=0;
				int c2=0;
				 for(c1=0;
				c1<to.length;
				c1++) {
					sent[c1]=to[c1];
				 }
				 for(c2=0;
				c2<cc.length;
				c2++) {
					sent[c1+c2]=cc[c2];
				 }
				 for(int c3=0;
				c3<bcc.length;
				c3++) {
					sent[c1+c2+c3]=bcc[c3];
				 }
				 sendsuccess=true;
				 throw new SendFailedException(""success"",new Exception(""success""),sent,null,null);
			}
			 catch(SendFailedException e) {
				 session.handleTransportException(e);
			}
			content=new XHTMLDocument(session.getModel(), store.getStylesheet(""sendresult.xsl"", user.getPreferredLocale(),user.getTheme()));
			if(sendsuccess) session.clearWork();
		 }
		 catch(Exception e) {
			e.printStackTrace();
			store.log(Storage.LOG_ERR,e);
			throw new DocumentNotFoundException(""Could not send message. (Reason: ""+e.getMessage()+"")"");
		 }
	}
	 else if(head.isContentSet(""ATTACH"")) {
		 content=parent.getURLHandler().handleURL(""/compose/attach"",session,head);
	}
	 else {
		 throw new DocumentNotFoundException(""Could not send message. (Reason: No content given)"");
	}",0,0,1,0
"protected class ColorPaletteView extends View {
	 private static final int PALETTE_COLUMNS = 7;
	 private static final int PALETTE_ROWS = 10;
	 private static final int PALETTE_FIELD_WIDTH = 50;
	 private static final int PALETTE_FIELD_HEIGHT = 50;
	 private static final float GRID_STROKE_WIDTH = 5;
	 private final BasicFieldColorView mParent;
	 private final Paint mAreaPaint = new Paint();
	 private final Paint mGridPaint = new Paint();
	 private final int[] mColorArray = new int[]{
	 0xffffffff, 0xffcccccc, 0xffc0c0c0, 0xff999999, 0xff666666, 0xff333333, 0xff000000, 0xffffcccc, 0xffff6666, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000, 0xffffcc99, 0xffff9966, 0xffff9900, 0xffff6600, 0xffcc6600, 0xff993300, 0xff663300, 0xffffff99, 0xffffff66, 0xffffcc66, 0xffffcc33, 0xffcc9933, 0xff996633, 0xff663333, 0xffffffcc, 0xffffff33, 0xffffff00, 0xffffcc00, 0xff999900, 0xff666600, 0xff333300, 0xff99ff99, 0xff66ff99, 0xff33ff33, 0xff33cc00, 0xff009900, 0xff006600, 0xff003300, 0xff99ffff, 0xff33ffff, 0xff66cccc, 0xff00cccc, 0xff339999, 0xff336666, 0xff003333, 0xffccffff, 0xff66ffff, 0xff33ccff, 0xff3366ff, 0xff3333ff, 0xff000099, 0xff000066, 0xffccccff, 0xff9999ff, 0xff6666cc, 0xff6633ff, 0xff6600cc, 0xff333399, 0xff330099, 0xffffccff, 0xffff99ff, 0xffcc66cc, 0xffcc33cc, 0xff993399, 0xff663366, 0xff330033 }
	;
	 ColorPaletteView(BasicFieldColorView parent) {
		 super(parent.getContext());
		 mParent = parent;
		 mGridPaint.setColor(Color.DKGRAY);
		 mGridPaint.setStrokeWidth(GRID_STROKE_WIDTH);
		 mGridPaint.setStyle(Paint.Style.STROKE);
	 }
	 public int getMinimumWidth() {
		 return PALETTE_FIELD_WIDTH * PALETTE_COLUMNS;
	 }
	 public int getMinimumHeight() {
		 return PALETTE_FIELD_HEIGHT * PALETTE_ROWS;
	 }
	 public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		 setMeasuredDimension(getMinimumWidth(), getMinimumHeight());
	 }
	 public void onDraw(Canvas canvas) {
		 drawPalette(canvas);
		 drawGrid(canvas);
	 }
	 public boolean onTouchEvent(MotionEvent motionEvent) {
		 if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
			 int i = Math.min(PALETTE_COLUMNS - 1, (int) motionEvent.getX() / PALETTE_FIELD_WIDTH);
			 int j = Math.min(PALETTE_ROWS - 1, (int) motionEvent.getY() / PALETTE_FIELD_HEIGHT);
			 int index = i + j * PALETTE_COLUMNS;
			 mParent.setBackgroundColor(mColorArray[index]);
			 mParent.mColorField.setColor(mColorArray[index]);
			 mParent.mColorPopupWindow.dismiss();
			 return true;
		 }
		 return false;
	 }
	 private void drawPalette(Canvas canvas) {
		 int paletteIndex = 0;
		 for (int j = 0;
		 j < PALETTE_ROWS;
		 ++j) {
			 int y = j * PALETTE_FIELD_HEIGHT;
			 for (int i = 0;
			 i < PALETTE_COLUMNS;
			 ++i, ++paletteIndex) {
				 int x = i * PALETTE_FIELD_WIDTH;
				 mAreaPaint.setColor(mColorArray[paletteIndex]);
				 canvas.drawRect( x, y, x + PALETTE_FIELD_WIDTH, y + PALETTE_FIELD_HEIGHT, mAreaPaint);
			 }
		 }
	 }
	 private void drawGrid(Canvas canvas) {
		 int width = getMeasuredWidth();
		 int height = getMeasuredHeight();
		 canvas.drawRect(0, 0, width - 1, height - 1, mGridPaint);
		 for (int j = 0;
		 j < PALETTE_ROWS;
		 ++j) {
			 int y = j * PALETTE_FIELD_HEIGHT;
			 canvas.drawLine(0, y, width - 1, y, mGridPaint);
		 }
		 for (int i = 0;
		 i < PALETTE_COLUMNS;
		 ++i) {
			 int x = i * PALETTE_FIELD_WIDTH;
			 canvas.drawLine(x, 0, x, height - 1, mGridPaint);
		 }
	 }
 }",0,0,0,0
"public class NewLogicalPlanUtil {
	 public static LogicalRelationalOperator getRelOpFromPlan(LogicalPlan plan, Class<?> c){
		 List<LogicalRelationalOperator>ops = getRelOpsFromPlan(plan,c);
		 if(ops.size() == 0) return null;
		 else if(ops.size() > 1){
			 fail(""more than one operator of class "" + c + "" found in lp "" + plan);
			 return null;
		 }
		else return ops.get(0);
	 }
	 public static List<LogicalRelationalOperator> getRelOpsFromPlan( LogicalPlan plan, Class<?> c) {
		 Iterator<Operator> it = plan.getOperators();
		 ArrayList<LogicalRelationalOperator> ops = new ArrayList<LogicalRelationalOperator>();
		 while(it.hasNext()){
			 Operator op = it.next();
			 if(op.getClass() == c){
				 ops.add((LogicalRelationalOperator) op);
			 }
			 if(op instanceof LOForEach){
				 ops.addAll(getRelOpsFromPlan(((LOForEach)op).getInnerPlan(), c));
			 }
		 }
		 return ops;
	 }
}",1,0,0,0
", }
)public class TyperefCustomDoubleAssociationKeyResource extends AssociationResourceTemplate<Message>{
 public Message get(final CompoundKey key, final CustomString[] stringArray) {
	 return new Message().setId(((CustomDouble) key.getPart(""src"")).toDouble() + ""->"" + ((URI) key.getPart( ""dest"")).getHost()) .setMessage(String.format(""I need some $20. Array contents %s."", Arrays.asList(stringArray))) .setTone(Tone.SINCERE);
 }
}",0,0,0,0
"final class NflyFSystem extends FileSystem {
	 private static final Log LOG = LogFactory.getLog(NflyFSystem.class);
	 private static final String NFLY_TMP_PREFIX = ""_nfly_tmp_"";
	 enum NflyKey {
	 minReplication, readMostRecent, repairOnRead }
	 private static final int DEFAULT_MIN_REPLICATION = 2;
	 private static URI nflyURI = URI.create(""nfly: private final NflyNode[] nodes;
	 private final int minReplication;
	 private final EnumSet<NflyKey> nflyFlags;
	 private final Node myNode;
	 private final NetworkTopology topology;
	 private static class NflyNode extends NodeBase {
		 private final ChRootedFileSystem fs;
		 NflyNode(String hostName, String rackName, URI uri, Configuration conf) throws IOException {
			 this(hostName, rackName, new ChRootedFileSystem(uri, conf));
		 }
		 NflyNode(String hostName, String rackName, ChRootedFileSystem fs) {
			 super(hostName, rackName);
			 this.fs = fs;
		 }
		 ChRootedFileSystem getFs() {
			 return fs;
		 }
		 public boolean equals(Object o) {
			 return super.equals(o);
		 }
		 public int hashCode() {
			 return super.hashCode();
		 }
	 }
	 private static final class MRNflyNode extends NflyNode implements Comparable<MRNflyNode> {
		 private FileStatus status;
		 private MRNflyNode(NflyNode n) {
			 super(n.getName(), n.getNetworkLocation(), n.fs);
		 }
		 private void updateFileStatus(Path f) throws IOException {
			 final FileStatus tmpStatus = getFs().getFileStatus(f);
			 status = tmpStatus == null ? notFoundStatus(f) : tmpStatus;
		 }
		 public int compareTo(MRNflyNode other) {
			 if (status == null) {
				 return other.status == null ? 0 : 1;
			 }
			 else if (other.status == null) {
				 return -1;
			 }
			 else {
				 final long mtime = status.getModificationTime();
				 final long their = other.status.getModificationTime();
				 return Long.compare(their, mtime);
			 }
		 }
		 public boolean equals(Object o) {
			 if (!(o instanceof MRNflyNode)) {
				 return false;
			 }
			 MRNflyNode other = (MRNflyNode) o;
			 return 0 == compareTo(other);
		 }
		 public int hashCode() {
			 return super.hashCode();
		 }
		 private FileStatus nflyStatus() throws IOException {
			 return new NflyStatus(getFs(), status);
		 }
		 private FileStatus cloneStatus() throws IOException {
			 return new FileStatus(status.getLen(), status.isDirectory(), status.getReplication(), status.getBlockSize(), status.getModificationTime(), status.getAccessTime(), null, null, null, status.isSymlink() ? status.getSymlink() : null, status.getPath());
		 }
	 }
	 private MRNflyNode[] workSet() {
		 final MRNflyNode[] res = new MRNflyNode[nodes.length];
		 for (int i = 0;
		 i < res.length;
		 i++) {
			 res[i] = new MRNflyNode(nodes[i]);
		 }
		 return res;
	 }
	 private static String getRack(String rackString) {
		 return rackString == null ? NetworkTopology.DEFAULT_RACK : rackString;
	 }
	 private NflyFSystem(URI[] uris, Configuration conf, int minReplication, EnumSet<NflyKey> nflyFlags) throws IOException {
		 if (uris.length < minReplication) {
			 throw new IOException(minReplication + "" < "" + uris.length + "": Minimum replication < #destinations"");
		 }
		 setConf(conf);
		 final String localHostName = InetAddress.getLocalHost().getHostName();
		 final List<String> hostStrings = new ArrayList<String>(uris.length + 1);
		 for (URI uri : uris) {
			 final String uriHost = uri.getHost();
			 hostStrings.add(uriHost == null ? localHostName : uriHost);
		 }
		 hostStrings.add(localHostName);
		 final DNSToSwitchMapping tmpDns = ReflectionUtils.newInstance(conf.getClass( CommonConfigurationKeys.NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY, ScriptBasedMapping.class, DNSToSwitchMapping.class), conf);
		 final List<String> rackStrings = tmpDns.resolve(hostStrings);
		 nodes = new NflyNode[uris.length];
		 final Iterator<String> rackIter = rackStrings.iterator();
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 nodes[i] = new NflyNode(hostStrings.get(i), rackIter.next(), uris[i], conf);
		 }
		 myNode = new NodeBase(localHostName, getRack(rackIter.next()));
		 topology = NetworkTopology.getInstance(conf);
		 topology.sortByDistance(myNode, nodes, nodes.length);
		 this.minReplication = minReplication;
		 this.nflyFlags = nflyFlags;
		 statistics = getStatistics(nflyURI.getScheme(), getClass());
	 }
	 private final class NflyOutputStream extends OutputStream {
		 private final Path nflyPath;
		 private final Path tmpPath;
		 private final FSDataOutputStream[] outputStreams;
		 private final BitSet opSet;
		 private final boolean useOverwrite;
		 private NflyOutputStream(Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {
			 nflyPath = f;
			 tmpPath = getNflyTmpPath(f);
			 outputStreams = new FSDataOutputStream[nodes.length];
			 for (int i = 0;
			 i < outputStreams.length;
			 i++) {
				 outputStreams[i] = nodes[i].fs.create(tmpPath, permission, true, bufferSize, replication, blockSize, progress);
			 }
			 opSet = new BitSet(outputStreams.length);
			 opSet.set(0, outputStreams.length);
			 useOverwrite = false;
		 }
		 private void mayThrow(List<IOException> ioExceptions) throws IOException {
			 final IOException ioe = MultipleIOException .createIOException(ioExceptions);
			 if (opSet.cardinality() < minReplication) {
				 throw ioe;
			 }
			 else {
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Exceptions occurred: "" + ioe);
				 }
			 }
		 }
		 public void write(int d) throws IOException {
			 final List<IOException> ioExceptions = new ArrayList<IOException>();
			 for (int i = opSet.nextSetBit(0);
			 i >=0;
			 i = opSet.nextSetBit(i + 1)) {
				 try {
					 outputStreams[i].write(d);
				 }
				 catch (Throwable t) {
					 osException(i, ""write"", t, ioExceptions);
				 }
			 }
			 mayThrow(ioExceptions);
		 }
		 private void osException(int i, String op, Throwable t, List<IOException> ioExceptions) {
			 opSet.clear(i);
			 processThrowable(nodes[i], op, t, ioExceptions, tmpPath, nflyPath);
		 }
		 public void write(byte[] bytes, int offset, int len) throws IOException {
			 final List<IOException> ioExceptions = new ArrayList<IOException>();
			 for (int i = opSet.nextSetBit(0);
			 i >= 0;
			 i = opSet.nextSetBit(i + 1)) {
				 try {
					 outputStreams[i].write(bytes, offset, len);
				 }
				 catch (Throwable t) {
					 osException(i, ""write"", t, ioExceptions);
				 }
			 }
			 mayThrow(ioExceptions);
		 }
		 public void flush() throws IOException {
			 final List<IOException> ioExceptions = new ArrayList<IOException>();
			 for (int i = opSet.nextSetBit(0);
			 i >= 0;
			 i = opSet.nextSetBit(i + 1)) {
				 try {
					 outputStreams[i].flush();
				 }
				 catch (Throwable t) {
					 osException(i, ""flush"", t, ioExceptions);
				 }
			 }
			 mayThrow(ioExceptions);
		 }
		 public void close() throws IOException {
			 final List<IOException> ioExceptions = new ArrayList<IOException>();
			 for (int i = opSet.nextSetBit(0);
			 i >= 0;
			 i = opSet.nextSetBit(i + 1)) {
				 try {
					 outputStreams[i].close();
				 }
				 catch (Throwable t) {
					 osException(i, ""close"", t, ioExceptions);
				 }
			 }
			 if (opSet.cardinality() < minReplication) {
				 cleanupAllTmpFiles();
				 throw new IOException(""Failed to sufficiently replicate: min="" + minReplication + "" actual="" + opSet.cardinality());
			 }
			 else {
				 commit();
			 }
		 }
		 private void cleanupAllTmpFiles() throws IOException {
			 for (int i = 0;
			 i < outputStreams.length;
			 i++) {
				 try {
					 nodes[i].fs.delete(tmpPath);
				 }
				 catch (Throwable t) {
					 processThrowable(nodes[i], ""delete"", t, null, tmpPath);
				 }
			 }
		 }
		 private void commit() throws IOException {
			 final List<IOException> ioExceptions = new ArrayList<IOException>();
			 for (int i = opSet.nextSetBit(0);
			 i >= 0;
			 i = opSet.nextSetBit(i + 1)) {
				 final NflyNode nflyNode = nodes[i];
				 try {
					 if (useOverwrite) {
						 nflyNode.fs.delete(nflyPath);
					 }
					 nflyNode.fs.rename(tmpPath, nflyPath);
				 }
				 catch (Throwable t) {
					 osException(i, ""commit"", t, ioExceptions);
				 }
			 }
			 if (opSet.cardinality() < minReplication) {
				 throw MultipleIOException.createIOException(ioExceptions);
			 }
			 final long commitTime = System.currentTimeMillis();
			 for (int i = opSet.nextSetBit(0);
			 i >= 0;
			 i = opSet.nextSetBit(i + 1)) {
				 try {
					 nodes[i].fs.setTimes(nflyPath, commitTime, commitTime);
				 }
				 catch (Throwable t) {
					 LOG.info(""Failed to set timestamp: "" + nodes[i] + "" "" + nflyPath);
				 }
			 }
		 }
	 }
	 private Path getNflyTmpPath(Path f) {
		 return new Path(f.getParent(), NFLY_TMP_PREFIX + f.getName());
	 }
	 static final class NflyStatus extends FileStatus {
		 private static final long serialVersionUID = 0x21f276d8;
		 private final FileStatus realStatus;
		 private final String strippedRoot;
		 private NflyStatus(ChRootedFileSystem realFs, FileStatus realStatus) throws IOException {
			 this.realStatus = realStatus;
			 this.strippedRoot = realFs.stripOutRoot(realStatus.getPath());
		 }
		 String stripRoot() throws IOException {
			 return strippedRoot;
		 }
		 public long getLen() {
			 return realStatus.getLen();
		 }
		 public boolean isFile() {
			 return realStatus.isFile();
		 }
		 public boolean isDirectory() {
			 return realStatus.isDirectory();
		 }
		 public boolean isSymlink() {
			 return realStatus.isSymlink();
		 }
		 public long getBlockSize() {
			 return realStatus.getBlockSize();
		 }
		 public short getReplication() {
			 return realStatus.getReplication();
		 }
		 public long getModificationTime() {
			 return realStatus.getModificationTime();
		 }
		 public long getAccessTime() {
			 return realStatus.getAccessTime();
		 }
		 public FsPermission getPermission() {
			 return realStatus.getPermission();
		 }
		 public String getOwner() {
			 return realStatus.getOwner();
		 }
		 public String getGroup() {
			 return realStatus.getGroup();
		 }
		 public Path getPath() {
			 return realStatus.getPath();
		 }
		 public void setPath(Path p) {
			 realStatus.setPath(p);
		 }
		 public Path getSymlink() throws IOException {
			 return realStatus.getSymlink();
		 }
		 public void setSymlink(Path p) {
			 realStatus.setSymlink(p);
		 }
		 public boolean equals(Object o) {
			 return realStatus.equals(o);
		 }
		 public int hashCode() {
			 return realStatus.hashCode();
		 }
		 public String toString() {
			 return realStatus.toString();
		 }
	 }
	 public URI getUri() {
		 return nflyURI;
	 }
	 public FSDataInputStream open(Path f, int bufferSize) throws IOException {
		 final List<IOException> ioExceptions = new ArrayList<IOException>(nodes.length);
		 int numNotFounds = 0;
		 final MRNflyNode[] mrNodes = workSet();
		 for (final MRNflyNode nflyNode : mrNodes) {
			 try {
				 if (nflyFlags.contains(NflyKey.repairOnRead) || nflyFlags.contains(NflyKey.readMostRecent)) {
					 nflyNode.updateFileStatus(f);
				 }
				 else {
					 return nflyNode.getFs().open(f, bufferSize);
				 }
			 }
			 catch (FileNotFoundException fnfe) {
				 nflyNode.status = notFoundStatus(f);
				 numNotFounds++;
				 processThrowable(nflyNode, ""open"", fnfe, ioExceptions, f);
			 }
			 catch (Throwable t) {
				 processThrowable(nflyNode, ""open"", t, ioExceptions, f);
			 }
		 }
		 if (nflyFlags.contains(NflyKey.readMostRecent)) {
			 Arrays.sort(mrNodes);
		 }
		 final FSDataInputStream fsdisAfterRepair = repairAndOpen(mrNodes, f, bufferSize);
		 if (fsdisAfterRepair != null) {
			 return fsdisAfterRepair;
		 }
		 mayThrowFileNotFound(ioExceptions, numNotFounds);
		 throw MultipleIOException.createIOException(ioExceptions);
	 }
	 private static FileStatus notFoundStatus(Path f) {
		 return new FileStatus(-1, false, 0, 0, 0, f);
	 }
	 private FSDataInputStream repairAndOpen(MRNflyNode[] mrNodes, Path f, int bufferSize) {
		 long maxMtime = 0L;
		 for (final MRNflyNode srcNode : mrNodes) {
			 if (srcNode.status == null || srcNode.status.getLen() < 0L) {
				 continue;
			 }
			 if (srcNode.status.getModificationTime() > maxMtime) {
				 maxMtime = srcNode.status.getModificationTime();
			 }
			 for (final MRNflyNode dstNode : mrNodes) {
				 if (dstNode.status == null || srcNode.compareTo(dstNode) == 0) {
					 continue;
				 }
				 try {
					 final FileStatus srcStatus = srcNode.cloneStatus();
					 srcStatus.setPath(f);
					 final Path tmpPath = getNflyTmpPath(f);
					 FileUtil.copy(srcNode.getFs(), srcStatus, dstNode.getFs(), tmpPath, false, true, getConf());
					 dstNode.getFs().delete(f, false);
					 if (dstNode.getFs().rename(tmpPath, f)) {
						 try {
							 dstNode.getFs().setTimes(f, srcNode.status.getModificationTime(), srcNode.status.getAccessTime());
						 }
						 finally {
							 srcStatus.setPath(dstNode.getFs().makeQualified(f));
							 dstNode.status = srcStatus;
						 }
					 }
				 }
				 catch (IOException ioe) {
					 LOG.info(f + "" "" + srcNode + ""->"" + dstNode + "": Failed to repair"", ioe);
				 }
			 }
		 }
		 if (maxMtime > 0) {
			 final List<MRNflyNode> mrList = new ArrayList<MRNflyNode>();
			 for (final MRNflyNode openNode : mrNodes) {
				 if (openNode.status != null && openNode.status.getLen() >= 0L) {
					 if (openNode.status.getModificationTime() == maxMtime) {
						 mrList.add(openNode);
					 }
				 }
			 }
			 final MRNflyNode[] readNodes = mrList.toArray(new MRNflyNode[0]);
			 topology.sortByDistance(myNode, readNodes, readNodes.length);
			 for (final MRNflyNode rNode : readNodes) {
				 try {
					 return rNode.getFs().open(f, bufferSize);
				 }
				 catch (IOException e) {
					 LOG.info(f + "": Failed to open at "" + rNode.getFs().getUri());
				 }
			 }
		 }
		 return null;
	 }
	 private void mayThrowFileNotFound(List<IOException> ioExceptions, int numNotFounds) throws FileNotFoundException {
		 if (numNotFounds == nodes.length) {
			 throw (FileNotFoundException)ioExceptions.get(nodes.length - 1);
		 }
	 }
	 public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {
		 return new FSDataOutputStream(new NflyOutputStream(f, permission, overwrite, bufferSize, replication, blockSize, progress), statistics);
	 }
	 public FSDataOutputStream append(Path f, int bufferSize, Progressable progress) throws IOException {
		 return null;
	 }
	 public boolean rename(Path src, Path dst) throws IOException {
		 final List<IOException> ioExceptions = new ArrayList<IOException>();
		 int numNotFounds = 0;
		 boolean succ = true;
		 for (final NflyNode nflyNode : nodes) {
			 try {
				 succ &= nflyNode.fs.rename(src, dst);
			 }
			 catch (FileNotFoundException fnfe) {
				 numNotFounds++;
				 processThrowable(nflyNode, ""rename"", fnfe, ioExceptions, src, dst);
			 }
			 catch (Throwable t) {
				 processThrowable(nflyNode, ""rename"", t, ioExceptions, src, dst);
				 succ = false;
			 }
		 }
		 mayThrowFileNotFound(ioExceptions, numNotFounds);
		 if (ioExceptions.size() == nodes.length) {
			 throw MultipleIOException.createIOException(ioExceptions);
		 }
		 return succ;
	 }
	 public boolean delete(Path f, boolean recursive) throws IOException {
		 final List<IOException> ioExceptions = new ArrayList<IOException>();
		 int numNotFounds = 0;
		 boolean succ = true;
		 for (final NflyNode nflyNode : nodes) {
			 try {
				 succ &= nflyNode.fs.delete(f);
			 }
			 catch (FileNotFoundException fnfe) {
				 numNotFounds++;
				 processThrowable(nflyNode, ""delete"", fnfe, ioExceptions, f);
			 }
			 catch (Throwable t) {
				 processThrowable(nflyNode, ""delete"", t, ioExceptions, f);
				 succ = false;
			 }
		 }
		 mayThrowFileNotFound(ioExceptions, numNotFounds);
		 if (ioExceptions.size() == nodes.length) {
			 throw MultipleIOException.createIOException(ioExceptions);
		 }
		 return succ;
	 }
	 public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {
		 final List<IOException> ioExceptions = new ArrayList<IOException>(nodes.length);
		 final MRNflyNode[] mrNodes = workSet();
		 if (nflyFlags.contains(NflyKey.readMostRecent)) {
			 int numNotFounds = 0;
			 for (final MRNflyNode nflyNode : mrNodes) {
				 try {
					 nflyNode.updateFileStatus(f);
				 }
				 catch (FileNotFoundException fnfe) {
					 numNotFounds++;
					 processThrowable(nflyNode, ""listStatus"", fnfe, ioExceptions, f);
				 }
				 catch (Throwable t) {
					 processThrowable(nflyNode, ""listStatus"", t, ioExceptions, f);
				 }
			 }
			 mayThrowFileNotFound(ioExceptions, numNotFounds);
			 Arrays.sort(mrNodes);
		 }
		 int numNotFounds = 0;
		 for (final MRNflyNode nflyNode : mrNodes) {
			 try {
				 final FileStatus[] realStats = nflyNode.getFs().listStatus(f);
				 final FileStatus[] nflyStats = new FileStatus[realStats.length];
				 for (int i = 0;
				 i < realStats.length;
				 i++) {
					 nflyStats[i] = new NflyStatus(nflyNode.getFs(), realStats[i]);
				 }
				 return nflyStats;
			 }
			 catch (FileNotFoundException fnfe) {
				 numNotFounds++;
				 processThrowable(nflyNode, ""listStatus"", fnfe, ioExceptions, f);
			 }
			 catch (Throwable t) {
				 processThrowable(nflyNode, ""listStatus"", t, ioExceptions, f);
			 }
		 }
		 mayThrowFileNotFound(ioExceptions, numNotFounds);
		 throw MultipleIOException.createIOException(ioExceptions);
	 }
	 public RemoteIterator<LocatedFileStatus> listLocatedStatus(Path f) throws FileNotFoundException, IOException {
		 return super.listLocatedStatus(f);
	 }
	 public void setWorkingDirectory(Path newDir) {
		 for (final NflyNode nflyNode : nodes) {
			 nflyNode.fs.setWorkingDirectory(newDir);
		 }
	 }
	 public Path getWorkingDirectory() {
		 return nodes[0].fs.getWorkingDirectory();
	 }
	 public boolean mkdirs(Path f, FsPermission permission) throws IOException {
		 boolean succ = true;
		 for (final NflyNode nflyNode : nodes) {
			 succ &= nflyNode.fs.mkdirs(f, permission);
		 }
		 return succ;
	 }
	 public FileStatus getFileStatus(Path f) throws IOException {
		 final List<IOException> ioExceptions = new ArrayList<IOException>(nodes.length);
		 int numNotFounds = 0;
		 final MRNflyNode[] mrNodes = workSet();
		 long maxMtime = Long.MIN_VALUE;
		 int maxMtimeIdx = Integer.MIN_VALUE;
		 for (int i = 0;
		 i < mrNodes.length;
		 i++) {
			 MRNflyNode nflyNode = mrNodes[i];
			 try {
				 nflyNode.updateFileStatus(f);
				 if (nflyFlags.contains(NflyKey.readMostRecent)) {
					 final long nflyTime = nflyNode.status.getModificationTime();
					 if (nflyTime > maxMtime) {
						 maxMtime = nflyTime;
						 maxMtimeIdx = i;
					 }
				 }
				 else {
					 return nflyNode.nflyStatus();
				 }
			 }
			 catch (FileNotFoundException fnfe) {
				 numNotFounds++;
				 processThrowable(nflyNode, ""getFileStatus"", fnfe, ioExceptions, f);
			 }
			 catch (Throwable t) {
				 processThrowable(nflyNode, ""getFileStatus"", t, ioExceptions, f);
			 }
		 }
		 if (maxMtimeIdx >= 0) {
			 return mrNodes[maxMtimeIdx].nflyStatus();
		 }
		 mayThrowFileNotFound(ioExceptions, numNotFounds);
		 throw MultipleIOException.createIOException(ioExceptions);
	 }
	 private static void processThrowable(NflyNode nflyNode, String op, Throwable t, List<IOException> ioExceptions, Path... f) {
		 final String errMsg = Arrays.toString(f) + "": failed to "" + op + "" "" + nflyNode.fs.getUri();
		 final IOException ioex;
		 if (t instanceof FileNotFoundException) {
			 ioex = new FileNotFoundException(errMsg);
			 ioex.initCause(t);
		 }
		 else {
			 ioex = new IOException(errMsg, t);
		 }
		 if (ioExceptions != null) {
			 ioExceptions.add(ioex);
		 }
	 }
	 static FileSystem createFileSystem(URI[] uris, Configuration conf, String settings) throws IOException {
		 int minRepl = DEFAULT_MIN_REPLICATION;
		 EnumSet<NflyKey> nflyFlags = EnumSet.noneOf(NflyKey.class);
		 final String[] kvPairs = StringUtils.split(settings);
		 for (String kv : kvPairs) {
			 final String[] kvPair = StringUtils.split(kv, '=');
			 if (kvPair.length != 2) {
				 throw new IllegalArgumentException(kv);
			 }
			 NflyKey nflyKey = NflyKey.valueOf(kvPair[0]);
			 switch (nflyKey) {
				 case minReplication: minRepl = Integer.parseInt(kvPair[1]);
				 break;
				 case repairOnRead: case readMostRecent: if (Boolean.valueOf(kvPair[1])) {
					 nflyFlags.add(nflyKey);
				 }
				 break;
				 default: throw new IllegalArgumentException(nflyKey + "": Infeasible"");
			 }
		 }
		 return new NflyFSystem(uris, conf, minRepl, nflyFlags);
	 }
}",1,1,0,0
"public void setChangeProperty(String changeProperty) {
	 this.changeProperty = changeProperty;
 }",0,0,0,0
"public class WireAdminImpl implements WireAdmin, ServiceListener {
	private BundleContext m_bundleContext;
	 private Map m_consumers = new HashMap();
	 private Map m_producers = new HashMap();
	 private List m_wires;
	 private Filter m_consumerFilter;
	private Filter m_producerFilter;
	 private EventManager m_eventManager;
	private static int m_wireCount = 0;
	 private AsyncMethodCaller m_asyncMethodCaller = new AsyncMethodCaller();
	 private static PrintStream m_traceout = null;
	 private static PrintStream m_errorout = System.err;
	WireAdminImpl(BundleContext bundleContext) {
		m_bundleContext = bundleContext;
		 if(bundleContext.getProperty(""fr.imag.adele.wireadmin.trace"") != null) {
			 String value = bundleContext.getProperty(""fr.imag.adele.wireadmin.trace"");
			 if(value.equals(""true"")) {
				 m_traceout = System.out;
			 }
		 }
		 m_eventManager = new EventManager(m_bundleContext);
		try {
			m_producerFilter = m_bundleContext.createFilter(""(objectClass=org.osgi.service.wireadmin.Producer)"");
			m_consumerFilter = m_bundleContext.createFilter(""(objectClass=org.osgi.service.wireadmin.Consumer)"");
		}
		 catch (InvalidSyntaxException e) {
		}
		 getPersistentWires();
		 new Thread(m_asyncMethodCaller).start();
		 try {
			 m_bundleContext.addServiceListener(this,""(|""+m_producerFilter.toString()+m_consumerFilter.toString()+"")"");
			 ServiceReference[] producerRefs = m_bundleContext.getServiceReferences(Producer.class.getName(),null);
			 if(producerRefs!=null) {
				 synchronized(m_producers) {
					 for(int i=0;
					i<producerRefs.length;
					i++) {
						 ServiceReference currentRef=(ServiceReference)producerRefs[i];
						 Iterator wireIt = m_wires.iterator();
						 while(wireIt.hasNext()) {
							 WireImpl currentWire = (WireImpl) wireIt.next();
							 if(currentWire.getProducerPID().equals(currentRef.getProperty(Constants.SERVICE_PID))) {
								 currentWire.bindProducer(currentRef);
							 }
						 }
						 m_producers.put(currentRef,new ArrayList());
					 }
				 }
			 }
			 ServiceReference[] consumerRefs = m_bundleContext.getServiceReferences(Consumer.class.getName(),null);
			 if(consumerRefs!=null) {
				 for(int i=0;
				i<consumerRefs.length;
				i++) {
					 synchronized(m_consumers) {
						 ServiceReference currentRef=(ServiceReference)consumerRefs[i];
						 Iterator wireIt = m_wires.iterator();
						 while(wireIt.hasNext()) {
							 WireImpl currentWire = (WireImpl) wireIt.next();
							 if(currentWire.getConsumerPID().equals(currentRef.getProperty(Constants.SERVICE_PID))) {
								 currentWire.bindConsumer(currentRef);
							 }
						 }
						 m_consumers.put(currentRef,new ArrayList());
					 }
				 }
			 }
		 }
		 catch (InvalidSyntaxException e) {
			 trace(e);
		 }
		 synchronized(m_wires) {
			 Iterator wireIterator = m_wires.iterator();
			 while(wireIterator.hasNext()) {
				 WireImpl currentWire = (WireImpl) wireIterator.next();
				 if(currentWire.isConnected()) {
					 List wires = (List) m_producers.get(currentWire.getProducerServiceRef());
					 wires.add(currentWire);
					 m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
					 wires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
					 wires.add(currentWire);
					 m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
				 }
			 }
		 }
	 }
	 void setServiceReference(ServiceReference ref) {
		 m_eventManager.setServiceReference(ref);
	 }
	public Wire createWire(String producerPID, String consumerPID, Dictionary props) {
		 ServiceReference producerServiceRef = null;
		 ServiceReference consumerServiceRef = null;
		 Dictionary properties;
		 if(props == null) {
			 properties = new Hashtable();
		 }
		 else {
			 properties = cloneProperties(props);
		 }
		 properties.put(WireConstants.WIREADMIN_CONSUMER_PID, consumerPID);
		 properties.put(WireConstants.WIREADMIN_PRODUCER_PID, producerPID);
		 properties.put(WireConstants.WIREADMIN_PID, generateWirePID());
		 WireImpl wire = new WireImpl(producerPID, consumerPID, properties);
		 wire.initialize(m_bundleContext,m_eventManager);
		 synchronized(m_wires) {
			 m_wires.add(wire);
		 }
		 m_eventManager.fireEvent(WireAdminEvent.WIRE_CREATED,wire);
		 synchronized (m_producers) {
			 Iterator producerIterator = m_producers.keySet().iterator();
			 while(producerIterator.hasNext()) {
				 producerServiceRef = (ServiceReference) producerIterator.next();
				 if (producerServiceRef.getProperty(Constants.SERVICE_PID).equals(producerPID)) {
					 wire.bindProducer(producerServiceRef);
					 break;
				 }
			 }
		 }
		 synchronized (m_consumers) {
			 Iterator consumerIterator = m_consumers.keySet().iterator();
			 while(consumerIterator.hasNext()) {
				 consumerServiceRef = (ServiceReference) consumerIterator.next();
				 if (consumerServiceRef.getProperty(Constants.SERVICE_PID).equals(consumerPID)) {
					 wire.bindConsumer(consumerServiceRef);
					 break;
				 }
			 }
		 }
		 if(wire.isConnected()) {
			 List wires = (List) m_producers.get(producerServiceRef);
			 wires.add(wire);
			 m_asyncMethodCaller.consumersConnected(wire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
			 wires = (List) m_consumers.get(consumerServiceRef);
			 wires.add(wire);
			 m_asyncMethodCaller.producersConnected(wire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
		 }
		 persistWires();
		 return wire;
	 }
	public void deleteWire(Wire wire) {
		 if(m_wires.contains(wire)) {
			 WireImpl wireImpl = (WireImpl) wire;
			 m_wires.remove(wire);
			 if(wireImpl.isConnected()) {
				 List wires = (List) m_producers.get(wireImpl.getProducerServiceRef());
				 wires.remove(wireImpl);
				 m_asyncMethodCaller.consumersConnected(wireImpl.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
				 wires = (List) m_consumers.get(wireImpl.getConsumerServiceRef());
				 wires.remove(wireImpl);
				 m_asyncMethodCaller.producersConnected(wireImpl.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
			 }
			 wireImpl.invalidate();
			 m_eventManager.fireEvent(WireAdminEvent.WIRE_DELETED,wireImpl);
			 persistWires();
		 }
		 else {
			 traceln(""WireAdminImpl: Cannot delete a wire that is not managed by this service"");
		 }
	}
	public void updateWire(Wire wire, Dictionary props) {
		 if(m_wires.contains(wire) == false) {
			 traceln(""WireAdminImpl: Cannot update a wire that is not managed by this service"");
			 return;
		 }
		 Dictionary properties = cloneProperties(props);
		 properties.put(WireConstants.WIREADMIN_CONSUMER_PID,wire.getProperties().get(WireConstants.WIREADMIN_CONSUMER_PID));
		 properties.put(WireConstants.WIREADMIN_PRODUCER_PID,wire.getProperties().get(WireConstants.WIREADMIN_PRODUCER_PID));
		 properties.put(WireConstants.WIREADMIN_PID,wire.getProperties().get(WireConstants.WIREADMIN_PID));
		 WireImpl wireImpl = (WireImpl) wire;
		 wireImpl.updateProperties(properties);
		 if(wireImpl.isConnected()) {
			 List wires = (List) m_producers.get(wireImpl.getProducerServiceRef());
			 m_asyncMethodCaller.consumersConnected(wireImpl.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
			 wires = (List) m_consumers.get(wireImpl.getConsumerServiceRef());
			 m_asyncMethodCaller.producersConnected(wireImpl.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
		 }
		 m_eventManager.fireEvent(WireAdminEvent.WIRE_UPDATED,wireImpl);
	}
	public Wire[] getWires(String filter) throws InvalidSyntaxException {
		List res = null;
		if (filter == null) {
			 return (Wire [])m_wires.toArray(new Wire[m_wires.size()]);
		}
		 else {
			Filter tempFilter = m_bundleContext.createFilter(filter);
			Iterator iter = m_wires.iterator();
			while (iter.hasNext()) {
				WireImpl currentWire = (WireImpl) iter.next();
				if (tempFilter.match(currentWire.getProperties())) {
					if (res == null) {
						res = new ArrayList();
					 }
					res.add(currentWire);
				}
			}
		}
		if (res == null) {
			return null;
		}
		 else {
			 return (Wire [])res.toArray(new Wire[res.size()]);
		}
	}
	 public void serviceChanged(ServiceEvent e) {
		ServiceReference serviceRef = e.getServiceReference();
		if (m_consumerFilter.match(serviceRef)) {
			switch (e.getType()) {
				 case ServiceEvent.REGISTERED : traceln(""consumer registered"");
				 List wires = new ArrayList();
				 synchronized(m_consumers) {
					 m_consumers.put(serviceRef,wires);
				 }
				 synchronized(m_wires) {
					 Iterator wireIt = m_wires.iterator();
					 boolean called = false;
					 while(wireIt.hasNext()) {
						 WireImpl currentWire = (WireImpl) wireIt.next();
						 if(currentWire.getConsumerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID))) {
							 currentWire.bindConsumer(serviceRef);
							 if(currentWire.isConnected()) {
								 wires.add(currentWire);
								 called = true;
								 m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
								 List producerWires = (List) m_producers.get(currentWire.getProducerServiceRef());
								 producerWires.add(currentWire);
								 m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])producerWires.toArray(new Wire[producerWires.size()]));
							 }
						 }
					 }
					 if(!called) {
						 m_asyncMethodCaller.producersConnected((Consumer) m_bundleContext.getService(serviceRef),null);
					 }
				 }
				 break;
				 case ServiceEvent.UNREGISTERING : traceln(""consumer unregistering"");
				 synchronized(m_consumers) {
					 m_consumers.remove(serviceRef);
				 }
				 synchronized(m_wires) {
					 Iterator wireIt = m_wires.iterator();
					 while(wireIt.hasNext()) {
						 WireImpl currentWire = (WireImpl) wireIt.next();
						 if(currentWire.getConsumerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID))) {
							 if(currentWire.isConnected()) {
								 currentWire.unbindConsumer();
								 List producerWires = (List) m_producers.get(currentWire.getProducerServiceRef());
								 producerWires.remove(currentWire);
								 m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])producerWires.toArray(new Wire[producerWires.size()]));
							 }
							 else {
								 currentWire.unbindConsumer();
							 }
						 }
					 }
				 }
				 break;
				 case ServiceEvent.MODIFIED : traceln(""consumer service modified"");
				 break;
			 }
		 }
		if (m_producerFilter.match(serviceRef)) {
			 switch (e.getType()) {
				 case ServiceEvent.REGISTERED : traceln(""producer registered"");
				 List wires = new ArrayList();
				 synchronized(m_producers) {
					 m_producers.put(serviceRef,wires);
				 }
				 synchronized(m_wires) {
					 Iterator wireIt = m_wires.iterator();
					 boolean called = false;
					 while(wireIt.hasNext()) {
						 WireImpl currentWire = (WireImpl) wireIt.next();
						 if(currentWire.getProducerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID))) {
							 currentWire.bindProducer(serviceRef);
							 if(currentWire.isConnected()) {
								 wires.add(currentWire);
								 called = true;
								 m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
								 List consumerWires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
								 consumerWires.add(currentWire);
								 m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])consumerWires.toArray(new Wire[consumerWires.size()]));
							 }
						 }
					 }
					 if(!called) {
						 m_asyncMethodCaller.consumersConnected((Producer) m_bundleContext.getService(serviceRef),null);
					 }
				 }
				 break;
				 case ServiceEvent.UNREGISTERING : traceln(""Producer unregistering"");
				 synchronized(m_producers) {
					 m_producers.remove(serviceRef);
				 }
				 synchronized(m_wires) {
					 Iterator wireIt = m_wires.iterator();
					 while(wireIt.hasNext()) {
						 WireImpl currentWire = (WireImpl) wireIt.next();
						 if(currentWire.getProducerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID))) {
							 if(currentWire.isConnected()) {
								 currentWire.unbindProducer();
								 List consumerWires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
								 consumerWires.remove(currentWire);
								 m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])consumerWires.toArray(new Wire[consumerWires.size()]));
							 }
							 else {
								 currentWire.unbindProducer();
							 }
						 }
					 }
				 }
				 break;
				 case ServiceEvent.MODIFIED : traceln(""producer service modified"");
				 break;
			 }
		 }
	 }
	synchronized void releaseAll() {
		 Iterator wireIt = m_wires.iterator();
		 while(wireIt.hasNext()) {
			 WireImpl currentWire = (WireImpl) wireIt.next();
			 currentWire.invalidate();
		 }
		 Iterator producerIt = m_producers.keySet().iterator();
		 while (producerIt.hasNext()) {
			 ServiceReference producerRef = (ServiceReference) producerIt.next();
			 ((Producer)m_bundleContext.getService(producerRef)).consumersConnected(null);
		 }
		 Iterator consumerIt = m_consumers.keySet().iterator();
		 while (consumerIt.hasNext()) {
			 ServiceReference consumerRef = (ServiceReference) consumerIt.next();
			 ((Consumer)m_bundleContext.getService(consumerRef)).producersConnected(null);
		 }
		 m_asyncMethodCaller.stop();
		 m_eventManager.stop();
		 persistWires();
	}
	 private String generateWirePID() {
		 Date d = new Date();
		 String PID=""wire.""+m_bundleContext.getBundle().getBundleId()+d.hashCode()+m_wireCount;
		 m_wireCount ++;
		 if(m_wireCount>9) {
			 m_wireCount = 0;
		 }
		 return PID;
	 }
	 private void getPersistentWires() {
		 try {
			 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(m_bundleContext.getDataFile(""wires.ser"")));
			 m_wires = (ArrayList) ois.readObject();
			 ois.close();
			 if(m_wires!=null) {
				 traceln(""Deserialized ""+m_wires.size()+"" wires"");
				 Iterator wireIt = m_wires.iterator();
				 while(wireIt.hasNext()) {
					 WireImpl currentWire = (WireImpl) wireIt.next();
					 currentWire.initialize(m_bundleContext,m_eventManager);
				 }
			 }
			 else {
				 traceln(""Couldn't Deserialize wires"");
				 m_wires = new ArrayList();
			 }
		 }
		 catch(FileNotFoundException ex) {
			 m_wires = new ArrayList();
		 }
		 catch(Exception ex) {
			 trace(ex);
			 m_wires = new ArrayList();
		 }
	 }
	 private void persistWires() {
		 try {
			 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(m_bundleContext.getDataFile(""wires.ser"")));
			 oos.writeObject(m_wires);
			 oos.close();
			 traceln(""Serialized ""+m_wires.size()+"" wires"");
		 }
		 catch(Exception ex) {
			 trace(ex);
		 }
	 }
	 static void error(String message) {
		 if (m_errorout != null) {
			 m_errorout.println(message);
		 }
	 }
	static void traceln(String message) {
		if (m_traceout != null) {
			trace(message);
			trace(""\n"");
		}
	}
	static void trace(String message) {
		if (m_traceout != null) {
			m_traceout.print(message);
		}
	}
	static void trace(Exception e) {
		if (m_traceout != null) {
			e.printStackTrace(m_traceout);
		}
	}
	 private Dictionary cloneProperties(Dictionary dictionary){
		 Dictionary properties=new Hashtable();
		 if (dictionary == null) {
			 properties = new Hashtable();
		 }
		 else {
			 Enumeration enumeration=dictionary.keys();
			 while(enumeration.hasMoreElements()){
				 Object key=enumeration.nextElement();
				 Object value=dictionary.get(key);
				 properties.put(key,value);
			 }
		 }
		 return properties;
	 }
	 class AsyncMethodCaller implements Runnable {
		 private boolean m_stop = false;
		 private List m_methodCallStack = new ArrayList();
		 public void run() {
			 while (!m_stop) {
				 Object nextTarget[] = null;
				 synchronized (m_methodCallStack) {
					 while (m_methodCallStack.size() == 0) {
						 try {
							 m_methodCallStack.wait();
						 }
						 catch (InterruptedException ex) {
						 }
					 }
					 nextTarget = (Object[]) m_methodCallStack.remove(0);
				 }
				 if(nextTarget[0] instanceof Producer) {
					 try {
						 ((Producer)nextTarget[0]).consumersConnected((Wire[])nextTarget[1]);
					 }
					 catch(Exception ex) {
						 trace(ex);
					 }
				 }
				 if(nextTarget[0] instanceof Consumer) {
					 try {
						 ((Consumer)nextTarget[0]).producersConnected((Wire[])nextTarget[1]);
					 }
					 catch(Exception ex) {
						 trace(ex);
					 }
				 }
			 }
		 }
		 public void producersConnected(Consumer c,Wire []wires) {
			 synchronized (m_methodCallStack) {
				 m_methodCallStack.add(new Object[]{
				c,wires}
				);
				 m_methodCallStack.notify();
			 }
		 }
		 public void consumersConnected(Producer p,Wire []wires) {
			 synchronized (m_methodCallStack) {
				 m_methodCallStack.add(new Object[]{
				p,wires}
				);
				 m_methodCallStack.notify();
			 }
		 }
		 void stop() {
			 m_stop = true;
		 }
	 }
}",1,0,0,0
"public final class ResultImpl implements AtlasIndexQuery.Result<AtlasJanusVertex, AtlasJanusEdge> {
	 private JanusGraphIndexQuery.Result<JanusGraphVertex> source;
	 public ResultImpl(JanusGraphIndexQuery.Result<JanusGraphVertex> source) {
		 this.source = source;
	 }
	 public AtlasVertex<AtlasJanusVertex, AtlasJanusEdge> getVertex() {
		 return GraphDbObjectFactory.createVertex(graph, source.getElement());
	 }
	 public double getScore() {
		 return source.getScore();
	 }
 }",0,0,0,0
"private static class DoubleTreeWriter extends TreeWriter {
	 private final PositionedOutputStream stream;
	 private final SerializationUtils utils;
	 DoubleTreeWriter(int columnId, TypeDescription schema, StreamFactory writer, boolean nullable) throws IOException {
		 super(columnId, schema, writer, nullable);
		 this.stream = writer.createStream(id, OrcProto.Stream.Kind.DATA);
		 this.utils = new SerializationUtils();
		 recordPosition(rowIndexPosition);
	 }
	 void write(Datum datum) throws IOException {
		 super.write(datum);
		 if (datum != null && datum.isNotNull()) {
			 double val = datum.asFloat8();
			 indexStatistics.updateDouble(val);
			 if (createBloomFilter) {
				 bloomFilter.addDouble(val);
			 }
			 utils.writeDouble(stream, val);
		 }
	 }
	 void writeStripe(OrcProto.StripeFooter.Builder builder, int requiredIndexEntries) throws IOException {
		 super.writeStripe(builder, requiredIndexEntries);
		 stream.flush();
		 recordPosition(rowIndexPosition);
	 }
	 void recordPosition(PositionRecorder recorder) throws IOException {
		 super.recordPosition(recorder);
		 stream.getPosition(recorder);
	 }
 }",1,0,0,0
"class LexerHost implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {
	 private static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 2048;
	 private static final int YYINITIAL = 0;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 0 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\41\0\1\5\2\0\1\5\1\0\7\5\1\21\1\4\1\0\1\11""+ ""\1\13\1\14\2\15\1\16\4\12\1\10\1\5\1\0\1\5\3\0""+ ""\6\7\24\22\1\1\1\0\1\6\1\0\1\20\1\0\6\3\17\17""+ ""\1\2\4\17\3\0\1\5\1\0\uff80\23"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\2\1\1\2\1\3\1\4\5\3\1\5\1\6\5\2""+ ""\2\3\1\4\1\3\1\7\1\6\2\4\1\10\1\11""+ ""\5\3\2\5\1\12\1\13\1\14\1\6\1\15\7\2""+ ""\1\7\1\10\1\7\1\16\1\7\1\17\1\20\1\21""+ ""\1\15\1\4\1\12\1\11\2\10\1\22\1\23\1\11""+ ""\1\24\7\3\1\13\1\5\1\12\1\14\1\12\1\25""+ ""\1\26\1\27\1\13\1\30\1\31\1\32\1\14\1\33""+ ""\1\6\1\11\1\15\1\34\11\2\1\35\5\2\1\16""+ ""\1\17\1\36\1\21\1\37\1\23\1\16\1\7\1\10""+ ""\1\7\1\13\1\15\1\17\1\20\1\21\1\25\1\24""+ ""\1\10\1\25\1\24\1\22\1\23\1\40\1\26\1\24""+ ""\6\3\1\27\1\30\1\32\1\5\1\12\1\33\1\25""+ ""\1\41\1\42\1\26\1\43\1\27\1\13\1\25\1\33""+ ""\1\30\1\42\1\31\1\32\1\44\1\14\1\26\1\33""+ ""\1\6\1\11\1\15\1\24\1\34\1\45\1\46\14\2""+ ""\1\47\15\2\2\36\1\37\1\50\1\51\1\37\1\52""+ ""\1\53\1\7\1\10\2\7\1\15\2\10\1\24\1\13""+ ""\1\25\1\13\1\33\1\15\1\20\1\22\1\31\1\34""+ ""\1\25\1\43\1\24\1\41\2\40\2\43\7\3\1\13""+ ""\1\25\1\41\1\42\1\43\1\54\1\13\1\25\1\33""+ ""\2\44\1\14\1\26\1\33\1\43\1\15\1\24\1\15""+ ""\1\24\34\2\1\36\1\50\1\36\1\37\1\36\1\55""+ ""\1\51\1\37\1\52\1\50\1\51\1\56\1\37\1\57""+ ""\1\53\1\52\1\53\1\60\1\7\1\10\1\7\1\15""+ ""\1\10\1\24\1\13\1\25\1\33\1\54\2\43\6\3""+ ""\1\55\1\57\1\54\1\13\1\25\1\33\1\43\1\33""+ ""\1\43\1\51\1\53\1\15\1\24\41\2\1\36\1\37""+ ""\1\36\1\55\1\51\1\16\1\17\1\21\1\36\1\37""+ ""\1\36\1\50\1\51\1\37\1\52\1\53\2\55\1\57""+ ""\1\61\1\62\1\51\1\56\1\37\1\57\1\53\1\23""+ ""\1\50\1\52\1\50\1\61\1\56\1\51\1\53\1\62""+ ""\1\56\1\57\1\63\1\64\1\53\1\60\1\52\1\63""+ ""\1\60\1\64\1\60\1\20\1\22\1\34\1\40\1\31""+ ""\1\41\1\44\1\54\4\65\3\3\1\55\1\57\1\61""+ ""\1\62\1\63\1\64\1\62\1\64\1\33\1\43\1\56""+ ""\1\60\37\2\1\36\1\37\1\55\1\50\1\52\1\50""+ ""\1\56\1\52\1\60\1\61\1\55\1\57\1\62\1\63""+ ""\1\61\1\62\1\66\1\51\1\53\1\57\1\50\1\52""+ ""\1\50\1\56\1\52\1\60\1\61\1\63\1\66\1\51""+ ""\1\53\1\62\1\66\1\56\1\60\1\66\1\64\1\63""+ ""\1\64\2\67\1\64\2\67\1\70\3\65\1\70\1\61""+ ""\1\63\1\66\1\67\37\2\1\50\1\52\1\55\1\57""+ ""\1\20\1\22\1\34\1\40\1\31\1\41\1\44\1\55""+ ""\1\57\1\66\1\54\1\61\1\63\1\62\1\64\1\66""+ ""\1\51\1\53\1\50\1\52\1\50\1\56\1\52\1\60""+ ""\1\61\1\63\1\66\1\56\1\60\1\62\1\64\1\56""+ ""\1\60\3\67\1\70\1\65\1\27\1\30\1\32\1\42""+ ""\36\2\1\55\1\57\1\61\1\63\1\61\1\63\1\62""+ ""\1\64\1\66\1\67\1\56\1\60\1\20\1\22\1\34""+ ""\1\40\1\31\1\41\1\44\1\54\1\62\1\64\1\56""+ ""\1\60\35\2\1\61\1\63\1\61\1\63\1\66\1\67""+ ""\1\66\1\67\1\66\1\67\30\2\1\71\1\66\1\67""+ ""\26\2\1\72\110\2"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[809];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\24\0\50\0\74\0\120\0\144\0\170\0\214""+ ""\0\240\0\264\0\310\0\334\0\360\0\u0104\0\u0118\0\u012c""+ ""\0\u0140\0\u0154\0\u0168\0\u017c\0\u0190\0\u01a4\0\u01b8\0\u01cc""+ ""\0\u01e0\0\u01f4\0\u0208\0\u021c\0\u0230\0\u0244\0\u0258\0\u026c""+ ""\0\u0280\0\u0294\0\u02a8\0\u02bc\0\u02d0\0\u02e4\0\u02f8\0\u030c""+ ""\0\u0320\0\u0334\0\u0348\0\u035c\0\u0370\0\u0384\0\u0398\0\u03ac""+ ""\0\u03c0\0\u03d4\0\u03e8\0\u03fc\0\u0410\0\u0424\0\u0438\0\u044c""+ ""\0\u0460\0\u0474\0\u0488\0\u049c\0\u04b0\0\u04c4\0\u04d8\0\u04ec""+ ""\0\u0500\0\u0514\0\u0528\0\u053c\0\u0550\0\u0564\0\u0578\0\u058c""+ ""\0\u05a0\0\u05b4\0\u05c8\0\u05dc\0\u05f0\0\u0604\0\u0618\0\u062c""+ ""\0\u0640\0\u0654\0\u0668\0\u067c\0\u0690\0\u06a4\0\u06b8\0\u06cc""+ ""\0\u06e0\0\u06f4\0\u0708\0\u071c\0\u0730\0\u0744\0\u0758\0\u076c""+ ""\0\u0780\0\u0794\0\360\0\u07a8\0\u07bc\0\u07d0\0\u07e4\0\u07f8""+ ""\0\u080c\0\u0820\0\u0834\0\u0848\0\u085c\0\u0870\0\u0884\0\u0898""+ ""\0\u08ac\0\u08c0\0\u08d4\0\u08e8\0\u08fc\0\u0910\0\u0924\0\u0938""+ ""\0\u094c\0\u0960\0\u0974\0\u0988\0\u099c\0\u09b0\0\u09c4\0\u09d8""+ ""\0\u09ec\0\u0a00\0\u0a14\0\u0a28\0\u0a3c\0\u0a50\0\u0a64\0\u0a78""+ ""\0\u0a8c\0\u0aa0\0\u0ab4\0\u0ac8\0\u0adc\0\u0af0\0\u0b04\0\u0b18""+ ""\0\u0b2c\0\u0b40\0\u0b54\0\u0b68\0\u0b7c\0\u0b90\0\u0ba4\0\u0bb8""+ ""\0\u0bcc\0\u0be0\0\u0bf4\0\u0c08\0\u0c1c\0\u0c30\0\u0c44\0\u0c58""+ ""\0\u0c6c\0\u0c80\0\u0c94\0\360\0\360\0\u0ca8\0\u0cbc\0\u0cd0""+ ""\0\u0ce4\0\u0cf8\0\u0d0c\0\u0d20\0\u0d34\0\u0d48\0\u0d5c\0\u0d70""+ ""\0\u0d84\0\360\0\u0d98\0\u0dac\0\u0dc0\0\u0dd4\0\u0de8\0\u0dfc""+ ""\0\u0e10\0\u0e24\0\u0e38\0\u0e4c\0\u0e60\0\u0e74\0\u0e88\0\u0e9c""+ ""\0\u0eb0\0\u0ec4\0\u0ed8\0\u0eec\0\u0f00\0\u0f14\0\u0f28\0\u0f3c""+ ""\0\u0f50\0\u0f64\0\u0f78\0\u0f8c\0\u0fa0\0\u0fb4\0\u0fc8\0\u0fdc""+ ""\0\u0ff0\0\u1004\0\u1018\0\u102c\0\u1040\0\u1054\0\u1068\0\u107c""+ ""\0\u1090\0\u10a4\0\u10b8\0\u10cc\0\u10e0\0\u10f4\0\u1108\0\u111c""+ ""\0\u1130\0\u1144\0\u1158\0\u116c\0\u1180\0\u1194\0\u11a8\0\u11bc""+ ""\0\u11d0\0\u11e4\0\u11f8\0\u120c\0\u1220\0\u1234\0\u1248\0\u125c""+ ""\0\u1270\0\u1284\0\u1298\0\u12ac\0\u12c0\0\u12d4\0\u12e8\0\u12fc""+ ""\0\u1310\0\u1324\0\u1338\0\u134c\0\u1360\0\u1374\0\u1388\0\u139c""+ ""\0\u13b0\0\u13c4\0\u13d8\0\u13ec\0\u1400\0\u1414\0\u1428\0\u143c""+ ""\0\u1450\0\u1464\0\u1478\0\u148c\0\u14a0\0\u14b4\0\u14c8\0\u14dc""+ ""\0\u14f0\0\u1504\0\u1518\0\u152c\0\u1540\0\u1554\0\u1568\0\u157c""+ ""\0\u1590\0\u15a4\0\u15b8\0\u15cc\0\u15e0\0\u15f4\0\u1608\0\u161c""+ ""\0\u1630\0\u1644\0\u1658\0\u166c\0\u1680\0\u1694\0\u16a8\0\u16bc""+ ""\0\u16d0\0\u16e4\0\u16f8\0\u170c\0\u1720\0\u1734\0\u1748\0\u175c""+ ""\0\u1770\0\u1784\0\u1798\0\u17ac\0\u17c0\0\u17d4\0\u17e8\0\u17fc""+ ""\0\u1810\0\u1824\0\u1838\0\u184c\0\u1860\0\u1874\0\u1888\0\u189c""+ ""\0\u18b0\0\u18c4\0\u18d8\0\u18ec\0\u1900\0\u1914\0\u1928\0\u193c""+ ""\0\u1950\0\u1964\0\u1978\0\u198c\0\u19a0\0\u19b4\0\u19c8\0\u19dc""+ ""\0\u19f0\0\u1a04\0\u1a18\0\u1a2c\0\u1a40\0\u1a54\0\u1a68\0\u1a7c""+ ""\0\u1a90\0\u1aa4\0\u1ab8\0\u1acc\0\u1ae0\0\u1af4\0\u1b08\0\u1b1c""+ ""\0\u1b30\0\u1b44\0\u1b58\0\u1b6c\0\u1b80\0\u1b94\0\u1ba8\0\u1bbc""+ ""\0\u1bd0\0\u1be4\0\u1bf8\0\u1c0c\0\u1c20\0\u1c34\0\u1c48\0\u1c5c""+ ""\0\u1c70\0\u1c84\0\u1c98\0\u1cac\0\u1cc0\0\u1cd4\0\u1ce8\0\u1cfc""+ ""\0\u1d10\0\u1d24\0\u1d38\0\u1d4c\0\u1d60\0\u1d74\0\u1d88\0\u1d9c""+ ""\0\u1db0\0\u1dc4\0\u1dd8\0\u1dec\0\u1e00\0\u1e14\0\u1e28\0\u1e3c""+ ""\0\u1e50\0\u1e64\0\u1e78\0\u1e8c\0\u1ea0\0\u1eb4\0\u1ec8\0\u1edc""+ ""\0\u1ef0\0\u1f04\0\u1f18\0\u1f2c\0\u1f40\0\u1f54\0\u1f68\0\u1f7c""+ ""\0\u1f90\0\u1fa4\0\u1fb8\0\u1fcc\0\u1fe0\0\u1ff4\0\u2008\0\u201c""+ ""\0\u2030\0\u2044\0\u2058\0\u206c\0\u2080\0\u2094\0\u20a8\0\u20bc""+ ""\0\u20d0\0\u20e4\0\u20f8\0\u210c\0\u2120\0\u2134\0\u2148\0\u215c""+ ""\0\u2170\0\u2184\0\u2198\0\u21ac\0\u21c0\0\u21d4\0\u21e8\0\u21fc""+ ""\0\u2210\0\u2224\0\u2238\0\u224c\0\u2260\0\u2274\0\u2288\0\u229c""+ ""\0\u22b0\0\u22c4\0\u22d8\0\u22ec\0\u2300\0\u2314\0\u2328\0\u233c""+ ""\0\u2350\0\u2364\0\u2378\0\u238c\0\u23a0\0\u23b4\0\u23c8\0\u23dc""+ ""\0\u23f0\0\u2404\0\u2418\0\u242c\0\u2440\0\u2454\0\u2468\0\u247c""+ ""\0\u2490\0\u24a4\0\u24b8\0\u24cc\0\u24e0\0\u24f4\0\u2508\0\u251c""+ ""\0\u2530\0\u2544\0\u2558\0\u256c\0\u2580\0\u2594\0\u25a8\0\u25bc""+ ""\0\u25d0\0\u25e4\0\u25f8\0\u260c\0\u2620\0\u2634\0\u2648\0\u265c""+ ""\0\u2670\0\u2684\0\u2698\0\u26ac\0\u26c0\0\u26d4\0\u26e8\0\u26fc""+ ""\0\u2710\0\u2724\0\u2738\0\u274c\0\u2760\0\u2760\0\u2774\0\u2788""+ ""\0\u2008\0\u279c\0\u27b0\0\u27c4\0\u27d8\0\u27ec\0\u2800\0\u2814""+ ""\0\u2828\0\u283c\0\u2850\0\u2864\0\u2878\0\u288c\0\u28a0\0\u28b4""+ ""\0\u28c8\0\u28dc\0\u28f0\0\u2904\0\u2918\0\u292c\0\u2940\0\u2954""+ ""\0\u2968\0\u297c\0\u2990\0\u29a4\0\u29b8\0\u29cc\0\u29e0\0\u29f4""+ ""\0\u2a08\0\u2a1c\0\u2a30\0\u2a44\0\u2a58\0\u2a6c\0\u2a80\0\u2a94""+ ""\0\u2aa8\0\u2abc\0\u2ad0\0\u2ae4\0\u2af8\0\u2b0c\0\u2b20\0\u2b34""+ ""\0\u2b48\0\u2b5c\0\u2b70\0\u2b84\0\u2b98\0\u2bac\0\u2bc0\0\u2bd4""+ ""\0\u2be8\0\u2bfc\0\u2c10\0\u2c24\0\u2c38\0\u2c4c\0\u2c60\0\u2c74""+ ""\0\u2c88\0\u2c9c\0\u2cb0\0\u2cc4\0\u2cd8\0\u2cec\0\u2d00\0\u2d14""+ ""\0\u2d28\0\u2d3c\0\u2d50\0\u2d64\0\u2d78\0\u2d78\0\u2d8c\0\u2da0""+ ""\0\u2db4\0\u2dc8\0\u2ddc\0\u2df0\0\u2e04\0\u2e18\0\u2e2c\0\u2e40""+ ""\0\u2e54\0\u2e68\0\u2e7c\0\u2e90\0\u2ea4\0\u2eb8\0\u2ecc\0\u2ee0""+ ""\0\u2ef4\0\u2f08\0\u2f1c\0\u2f30\0\u2f44\0\u2f58\0\u2f6c\0\u2f80""+ ""\0\u2f94\0\u2fa8\0\u2fbc\0\u2fd0\0\u2fe4\0\u2ff8\0\u300c\0\u3020""+ ""\0\u3034\0\u3048\0\u305c\0\u3070\0\u3084\0\u3098\0\u30ac\0\u30c0""+ ""\0\u30d4\0\u30e8\0\u30fc\0\u3110\0\u3124\0\u3138\0\u314c\0\u3160""+ ""\0\u3174\0\u3188\0\u319c\0\u31b0\0\u31c4\0\u31d8\0\u31ec\0\u3200""+ ""\0\u3214\0\u3228\0\u323c\0\u3250\0\u3264\0\u3278\0\u328c\0\u32a0""+ ""\0\u32b4\0\u32c8\0\u32dc\0\u32f0\0\u3304\0\u3318\0\u332c\0\u3340""+ ""\0\u3354\0\u3368\0\u337c\0\u3390\0\u33a4\0\u33b8\0\u33cc\0\u33e0""+ ""\0\u33f4\0\u3408\0\u341c\0\u3430\0\u3444\0\u3458\0\u346c\0\u3480""+ ""\0\u3494\0\u34a8\0\u34bc\0\u34d0\0\u34e4\0\u34f8\0\u350c\0\u3520""+ ""\0\u3534\0\u3548\0\u355c\0\u3570\0\u3584\0\u3598\0\u35ac\0\u35c0""+ ""\0\u35d4\0\u35e8\0\u35fc\0\u3610\0\u3624\0\u3638\0\u364c\0\u3660""+ ""\0\u3674\0\u3688\0\u369c\0\u36b0\0\u36c4\0\u36d8\0\u36ec\0\360""+ ""\0\u3700\0\u3714\0\u3728\0\u373c\0\u3750\0\u3764\0\u3778\0\u378c""+ ""\0\u37a0\0\u37b4\0\u37c8\0\u37dc\0\u37f0\0\u3804\0\u3818\0\u382c""+ ""\0\u3840\0\u3854\0\u3868\0\u387c\0\u3890\0\u38a4\0\u38b8\0\u38cc""+ ""\0\360\0\u38e0\0\u38f4\0\u3908\0\u391c\0\u3930\0\u3944\0\u3958""+ ""\0\u396c\0\u3980\0\u3994\0\u39a8\0\u39bc\0\u39d0\0\u39e4\0\u39f8""+ ""\0\u3a0c\0\u3a20\0\u3a34\0\u3a48\0\u3a5c\0\u3a70\0\u3a84\0\u3a98""+ ""\0\u3aac\0\u3ac0\0\u3ad4\0\u3ae8\0\u3afc\0\u3b10\0\u3b24\0\u3b38""+ ""\0\u3b4c\0\u3b60\0\u3b74\0\u3b88\0\u3b9c\0\u3bb0\0\u3bc4\0\u3bd8""+ ""\0\u3bec\0\u3c00\0\u3c14\0\u3c28\0\u3c3c\0\u3c50\0\u3c64\0\u3c78""+ ""\0\u3c8c\0\u3ca0\0\u3cb4\0\u3cc8\0\u3cdc\0\u3cf0\0\u3d04\0\u3d18""+ ""\0\u3d2c\0\u3d40\0\u3d54\0\u3d68\0\u3d7c\0\u3d90\0\u3da4\0\u3db8""+ ""\0\u3dcc\0\u3de0\0\u3df4\0\u3e08\0\u3e1c\0\u3e30\0\u3e44\0\u3e58""+ ""\0\u3e6c"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[809];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\2\1\3\2\4\3\2\1\5\1\2\1\6\1\7""+ ""\1\10\1\11\2\7\1\4\1\12\1\13\1\5\1\14""+ ""\24\2\2\15\1\16\1\17\3\15\1\20\1\21\6\17""+ ""\5\15\2\2\2\22\1\23\2\2\1\24\1\2\7\22""+ ""\1\25\1\26\1\24\1\27\2\2\2\24\1\30\2\2""+ ""\1\24\1\2\7\24\1\31\1\32\1\24\1\33\2\2""+ ""\2\22\1\34\2\2\1\24\1\2\6\35\1\22\1\25""+ ""\1\26\1\24\1\27\2\2\2\22\1\34\2\2\1\24""+ ""\1\2\6\36\1\22\1\25\1\26\1\24\1\27\2\2""+ ""\2\22\1\34\2\2\1\24\1\2\6\37\1\22\1\25""+ ""\1\26\1\24\1\27\2\2\2\22\1\34\2\2\1\24""+ ""\1\2\1\37\1\36\3\37\1\40\1\22\1\25\1\26""+ ""\1\24\1\27\2\2\2\25\1\23\2\2\1\31\1\2""+ ""\10\25\1\26\1\31\1\27\2\2\2\41\1\42\2\2""+ ""\1\43\1\2\10\41\1\44\1\43\1\45\2\2\2\27""+ ""\1\46\2\2\1\33\1\2\10\27\1\47\1\33\1\27""+ ""\27\15\1\50\3\15\1\51\1\15\6\50\10\15\1\52""+ ""\3\15\1\53\1\54\6\52\10\15\1\53\3\15\1\53""+ ""\1\55\6\53\15\15\1\56\13\15\2\2\2\25\1\23""+ ""\2\2\1\31\1\2\10\25\1\57\1\31\1\27\2\2""+ ""\2\4\3\2\1\5\1\2\7\4\1\12\1\13\1\5""+ ""\1\14\2\2\2\31\1\30\2\2\1\31\1\2\10\31""+ ""\1\60\1\31\1\33\2\2\2\25\1\23\2\2\1\31""+ ""\1\2\10\25\1\61\1\31\1\27\2\2\2\62\1\63""+ ""\2\2\1\64\1\2\10\62\1\65\1\64\1\66\2\2""+ ""\2\27\1\46\2\2\1\33\1\2\10\27\1\67\1\33""+ ""\1\27\2\2\2\5\3\2\1\5\1\2\7\5\1\70""+ ""\1\71\1\5\1\72\2\2\2\31\1\30\2\2\1\31""+ ""\1\2\10\31\1\73\1\31\1\33\2\2\2\64\1\74""+ ""\2\2\1\64\1\2\10\64\1\75\1\64\1\76\2\2""+ ""\2\33\1\77\2\2\1\33\1\2\10\33\1\100\2\33""+ ""\2\2\2\4\3\2\1\5\1\2\1\101\1\102\1\103""+ ""\1\104\2\102\1\4\1\12\1\13\1\5\1\14\2\2""+ ""\2\25\1\105\2\2\1\31\1\2\6\106\2\25\1\57""+ ""\1\31\1\27\2\2\2\25\1\34\2\2\1\31\1\2""+ ""\6\106\2\25\1\57\1\31\1\27\2\2\2\25\1\34""+ ""\2\2\1\31\1\2\6\107\2\25\1\57\1\31\1\27""+ ""\2\2\2\25\1\34\2\2\1\31\1\2\1\107\1\106""+ ""\4\107\2\25\1\57\1\31\1\27\2\2\2\41\1\42""+ ""\2\2\1\43\1\2\10\41\1\110\1\43\1\45\2\2""+ ""\2\111\3\2\1\112\1\2\7\111\2\13\1\112\1\113""+ ""\2\2\2\43\1\114\2\2\1\43\1\2\10\43\1\115""+ ""\1\43\1\116\2\2\2\117\1\120\2\2\1\121\1\2""+ ""\10\117\1\122\1\121\1\123\2\2\2\45\1\124\2\2""+ ""\1\116\1\2\10\45\1\125\1\116\1\45\2\2\2\126""+ ""\3\2\1\127\1\2\7\126\1\14\1\113\1\127\1\14""+ ""\2\2\2\66\1\130\2\2\1\76\1\2\10\66\1\131""+ ""\1\76\1\66\3\15\1\50\1\132\2\15\1\51\1\15""+ ""\6\50\10\15\1\51\1\133\2\15\1\51\1\15\6\51""+ ""\10\15\1\134\3\15\1\135\1\54\6\134\10\15\1\135""+ ""\3\15\1\135\1\55\6\135\10\15\1\136\3\15\1\137""+ ""\1\140\6\136\10\15\1\137\3\15\1\137\1\141\6\137""+ ""\10\15\1\142\2\15\1\143\1\144\1\15\1\145\1\146""+ ""\1\147\1\150\2\146\5\15\2\2\2\151\1\63\2\2""+ ""\1\152\1\2\10\151\1\153\1\152\1\154\2\2\2\152""+ ""\1\74\2\2\1\152\1\2\10\152\1\155\1\152\1\156""+ ""\2\2\2\151\1\63\2\2\1\152\1\2\10\151\1\65""+ ""\1\152\1\154\2\2\2\62\1\157\2\2\1\64\1\2""+ ""\10\62\1\65\1\64\1\66\2\2\2\160\3\2\1\161""+ ""\1\2\7\160\1\162\1\163\1\161\1\164\2\2\2\64""+ ""\1\165\2\2\1\64\1\2\10\64\1\75\1\64\1\76""+ ""\2\2\2\62\1\166\2\2\1\64\1\2\10\62\1\65""+ ""\1\64\1\66\2\2\2\66\1\167\2\2\1\76\1\2""+ ""\10\66\1\131\1\76\1\66\2\2\2\154\1\130\2\2""+ ""\1\156\1\2\10\154\1\131\1\156\1\154\2\2\2\31""+ ""\1\30\2\2\1\31\1\2\10\31\1\32\1\31\1\33""+ ""\2\2\2\43\1\114\2\2\1\43\1\2\10\43\1\170""+ ""\1\43\1\116\2\2\2\33\1\77\2\2\1\33\1\2""+ ""\10\33\1\171\2\33\2\2\2\152\1\74\2\2\1\152""+ ""\1\2\10\152\1\75\1\152\1\156\2\2\2\161\3\2""+ ""\1\161\1\2\7\161\1\172\1\173\1\161\1\174\2\2""+ ""\2\64\1\175\2\2\1\64\1\2\10\64\1\75\1\64""+ ""\1\76\2\2\2\76\1\176\2\2\1\76\1\2\10\76""+ ""\1\177\2\76\2\2\2\127\3\2\1\127\1\2\7\127""+ ""\1\72\1\200\1\127\1\72\2\2\2\156\1\201\2\2""+ ""\1\156\1\2\10\156\1\177\2\156\2\2\2\22\1\202""+ ""\2\2\1\24\1\2\6\203\1\22\1\25\1\26\1\24""+ ""\1\27\2\2\2\22\1\202\2\2\1\24\1\2\6\204""+ ""\1\22\1\25\1\26\1\24\1\27\2\2\2\22\1\202""+ ""\2\2\1\24\1\2\6\205\1\22\1\25\1\26\1\24""+ ""\1\27\2\2\2\22\1\202\2\2\1\24\1\2\1\205""+ ""\1\204\3\205\1\206\1\22\1\25\1\26\1\24\1\27""+ ""\2\2\2\4\3\2\1\5\1\2\6\207\1\4\1\12""+ ""\1\13\1\5\1\14\2\2\2\25\1\105\2\2\1\31""+ ""\1\2\6\106\2\25\1\61\1\31\1\27\2\2\2\25""+ ""\1\34\2\2\1\31\1\2\6\106\2\25\1\61\1\31""+ ""\1\27\2\2\2\210\1\120\2\2\1\211\1\2\10\210""+ ""\1\122\1\211\1\212\2\2\2\213\1\42\2\2\1\214""+ ""\1\2\7\213\1\41\1\44\1\214\1\45\2\2\2\214""+ ""\1\114\2\2\1\214\1\2\7\214\1\43\1\170\1\214""+ ""\1\116\2\2\2\45\1\124\2\2\1\116\1\2\10\45""+ ""\1\215\1\116\1\45\2\2\2\112\3\2\1\112\1\2""+ ""\7\112\2\71\1\112\1\200\2\2\2\211\1\216\2\2""+ ""\1\211\1\2\10\211\1\217\1\211\1\220\2\2\2\116""+ ""\1\221\2\2\1\116\1\2\10\116\1\222\2\116\2\2""+ ""\2\117\1\223\2\2\1\121\1\2\10\117\1\122\1\121""+ ""\1\123\2\2\2\224\3\2\1\225\1\2\7\224\2\163""+ ""\1\225\1\226\2\2\2\121\1\227\2\2\1\121\1\2""+ ""\10\121\1\217\1\121\1\230\2\2\2\117\1\231\2\2""+ ""\1\121\1\2\10\117\1\122\1\121\1\123\2\2\2\123""+ ""\1\232\2\2\1\230\1\2\10\123\1\233\1\230\1\123""+ ""\2\2\2\234\3\2\1\235\1\2\7\234\2\113\1\235""+ ""\1\113\2\2\2\212\1\236\2\2\1\220\1\2\10\212""+ ""\1\233\1\220\1\212\2\2\2\237\1\46\2\2\1\240""+ ""\1\2\7\237\1\27\1\47\1\240\1\27\2\2\2\240""+ ""\1\77\2\2\1\240\1\2\7\240\1\33\1\171\1\240""+ ""\1\33\2\2\2\241\3\2\1\242\1\2\7\241\1\164""+ ""\1\226\1\242\1\164\2\2\2\66\1\243\2\2\1\76""+ ""\1\2\10\66\1\131\1\76\1\66\2\15\4\132\1\244""+ ""\14\132\3\15\4\133\1\245\14\133\4\15\1\246\3\15""+ ""\1\247\1\54\6\246\10\15\1\247\3\15\1\247\1\55""+ ""\6\247\10\15\1\250\3\15\1\251\1\252\6\250\10\15""+ ""\1\251\3\15\1\251\1\253\6\251\10\15\1\254\2\15""+ ""\1\143\1\255\1\15\1\256\1\257\1\260\1\261\2\257""+ ""\10\15\1\255\2\15\1\262\1\255\1\15\1\263\1\264""+ ""\1\265\1\266\2\264\10\15\1\267\2\15\1\143\1\270""+ ""\1\271\6\267\10\15\1\270\2\15\1\262\1\270\1\272""+ ""\6\270\10\15\1\267\1\273\1\15\1\143\1\270\1\271""+ ""\6\274\10\15\1\267\1\273\1\15\1\143\1\270\1\271""+ ""\6\275\10\15\1\267\1\273\1\15\1\143\1\270\1\271""+ ""\6\276\10\15\1\267\1\273\1\15\1\143\1\270\1\271""+ ""\1\276\1\275\3\276\1\277\5\15\2\2\2\25\1\157""+ ""\2\2\1\31\1\2\10\25\1\61\1\31\1\27\2\2""+ ""\2\31\1\165\2\2\1\31\1\2\10\31\1\73\1\31""+ ""\1\33\2\2\2\300\1\301\2\2\1\302\1\2\10\300""+ ""\1\303\1\302\1\304\2\2\2\27\1\167\2\2\1\33""+ ""\1\2\10\27\1\67\1\33\1\27\2\2\2\302\1\305""+ ""\2\2\1\302\1\2\10\302\1\306\1\302\1\307\2\2""+ ""\2\33\1\176\2\2\1\33\1\2\10\33\1\100\2\33""+ ""\2\2\2\62\3\2\1\64\1\2\10\62\1\117\1\64""+ ""\1\66\2\2\2\310\1\63\2\2\1\311\1\2\7\310""+ ""\1\312\1\313\1\311\1\314\2\2\2\311\1\74\2\2""+ ""\1\311\1\2\7\311\1\315\1\316\1\311\1\317\2\2""+ ""\2\312\1\63\2\2\1\315\1\2\10\312\1\313\1\315""+ ""\1\314\2\2\2\320\1\120\2\2\1\321\1\2\10\320""+ ""\1\322\1\321\1\323\2\2\2\314\1\130\2\2\1\317""+ ""\1\2\10\314\1\324\1\317\1\314\2\2\2\64\3\2""+ ""\1\64\1\2\10\64\1\121\1\64\1\76\2\2\2\325""+ ""\3\2\1\326\1\2\10\325\1\327\1\326\1\330\2\2""+ ""\2\66\3\2\1\76\1\2\10\66\1\123\1\76\1\66""+ ""\2\2\2\121\1\216\2\2\1\121\1\2\10\121\1\217""+ ""\1\121\1\230\2\2\2\76\1\201\2\2\1\76\1\2""+ ""\10\76\1\177\2\76\2\2\2\315\1\74\2\2\1\315""+ ""\1\2\10\315\1\316\1\315\1\317\2\2\2\321\1\216""+ ""\2\2\1\321\1\2\10\321\1\331\1\321\1\332\2\2""+ ""\2\317\1\201\2\2\1\317\1\2\10\317\1\333\2\317""+ ""\2\2\2\326\3\2\1\326\1\2\10\326\1\334\1\326""+ ""\1\335\2\2\2\76\3\2\1\76\1\2\10\76\1\230""+ ""\2\76\2\2\2\76\1\336\2\2\1\76\1\2\10\76""+ ""\1\177\2\76\2\2\2\116\1\221\2\2\1\116\1\2""+ ""\10\116\1\337\2\116\2\2\2\242\3\2\1\242\1\2""+ ""\7\242\1\174\1\340\1\242\1\174\2\2\2\4\3\2""+ ""\1\5\1\2\1\341\1\342\1\343\1\344\2\342\1\4""+ ""\1\12\1\13\1\5\1\14\2\2\2\25\1\345\2\2""+ ""\1\31\1\2\6\346\2\25\1\57\1\31\1\27\2\2""+ ""\2\25\1\202\2\2\1\31\1\2\6\346\2\25\1\57""+ ""\1\31\1\27\2\2\2\25\1\202\2\2\1\31\1\2""+ ""\6\347\2\25\1\57\1\31\1\27\2\2\2\25\1\202""+ ""\2\2\1\31\1\2\1\347\1\346\4\347\2\25\1\57""+ ""\1\31\1\27\2\2\2\22\1\345\2\2\1\24\1\2""+ ""\6\203\1\22\1\25\1\26\1\24\1\27\2\2\2\41""+ ""\1\223\2\2\1\43\1\2\10\41\1\110\1\43\1\45""+ ""\2\2\2\43\1\227\2\2\1\43\1\2\10\43\1\115""+ ""\1\43\1\116\2\2\2\45\1\232\2\2\1\116\1\2""+ ""\10\45\1\125\1\116\1\45\2\2\2\41\1\42\2\2""+ ""\1\43\1\2\10\41\1\350\1\43\1\45\2\2\2\43""+ ""\1\114\2\2\1\43\1\2\10\43\1\351\1\43\1\116""+ ""\2\2\2\123\1\236\2\2\1\230\1\2\10\123\1\233""+ ""\1\230\1\123\2\2\2\225\3\2\1\225\1\2\7\225""+ ""\2\173\1\225\1\340\2\2\2\121\1\352\2\2\1\121""+ ""\1\2\10\121\1\217\1\121\1\230\2\2\2\116\1\353""+ ""\2\2\1\116\1\2\10\116\1\222\2\116\2\2\2\235""+ ""\3\2\1\235\1\2\7\235\2\200\1\235\1\200\2\2""+ ""\2\220\1\354\2\2\1\220\1\2\10\220\1\355\2\220""+ ""\2\2\2\117\3\2\1\121\1\2\11\117\1\121\1\123""+ ""\2\2\2\356\1\120\2\2\1\357\1\2\7\356\1\320""+ ""\1\322\1\357\1\323\2\2\2\357\1\216\2\2\1\357""+ ""\1\2\7\357\1\321\1\331\1\357\1\332\2\2\2\323""+ ""\1\236\2\2\1\332\1\2\10\323\1\360\1\332\1\323""+ ""\2\2\2\121\3\2\1\121\1\2\12\121\1\230\2\2""+ ""\2\230\1\353\2\2\1\230\1\2\10\230\1\355\2\230""+ ""\2\2\2\327\3\2\1\334\1\2\11\327\1\334\1\361""+ ""\2\2\2\123\3\2\1\230\1\2\11\123\1\230\1\123""+ ""\2\2\2\123\1\362\2\2\1\230\1\2\10\123\1\233""+ ""\1\230\1\123\2\2\2\363\1\124\2\2\1\364\1\2""+ ""\7\363\1\45\1\215\1\364\1\45\2\2\2\364\1\221""+ ""\2\2\1\364\1\2\7\364\1\116\1\337\1\364\1\116""+ ""\2\2\2\365\3\2\1\366\1\2\7\365\2\226\1\366""+ ""\1\226\2\2\2\27\1\46\2\2\1\33\1\2\10\27""+ ""\1\367\1\33\1\27\2\2\2\33\1\77\2\2\1\33""+ ""\1\2\10\33\1\370\2\33\2\2\2\371\1\130\2\2""+ ""\1\372\1\2\7\371\1\314\1\324\1\372\1\314\2\2""+ ""\2\372\1\201\2\2\1\372\1\2\7\372\1\317\1\333""+ ""\1\372\1\317\2\2\2\330\3\2\1\335\1\2\10\330""+ ""\1\361\1\335\1\330\10\15\1\54\23\15\1\55\16\15""+ ""\1\373\3\15\1\374\1\252\6\373\10\15\1\374\3\15""+ ""\1\374\1\253\6\374\10\15\1\375\3\15\1\376\1\377""+ ""\6\375\10\15\1\376\3\15\1\376\1\u0100\6\376\10\15""+ ""\1\u0101\2\15\1\143\1\u0102\1\u0103\6\u0101\10\15\1\u0102""+ ""\2\15\1\262\1\u0102\1\u0104\6\u0102\10\15\1\u0101\1\273""+ ""\1\15\1\143\1\u0102\1\u0103\6\u0105\10\15\1\u0101\1\273""+ ""\1\15\1\143\1\u0102\1\u0103\6\u0106\10\15\1\u0101\1\273""+ ""\1\15\1\143\1\u0102\1\u0103\6\u0107\10\15\1\u0101\1\273""+ ""\1\15\1\143\1\u0102\1\u0103\1\u0107\1\u0106\3\u0107\1\u0108""+ ""\10\15\1\u0102\1\u0109\1\15\1\262\1\u0102\1\u0104\6\u010a""+ ""\10\15\1\u0102\1\u0109\1\15\1\262\1\u0102\1\u0104\6\u010b""+ ""\10\15\1\u0102\1\u0109\1\15\1\262\1\u0102\1\u0104\6\u010c""+ ""\10\15\1\u0102\1\u0109\1\15\1\262\1\u0102\1\u0104\1\u010c""+ ""\1\u010b\3\u010c\1\u010d\10\15\1\u010e\2\15\1\143\1\u010f""+ ""\1\271\6\u010e\10\15\1\u010f\2\15\1\262\1\u010f\1\272""+ ""\6\u010f\10\15\1\254\3\15\1\255\1\15\1\256\1\257""+ ""\1\260\1\261\2\257\10\15\1\255\3\15\1\255\1\15""+ ""\1\263\1\264\1\265\1\266\2\264\16\15\1\u0110\1\u0111""+ ""\1\u0112\1\u0113\2\u0111\10\15\1\u010e\1\u0114\1\15\1\143""+ ""\1\u010f\1\271\6\u0115\10\15\1\u010e\1\273\1\15\1\143""+ ""\1\u010f\1\271\6\u0115\10\15\1\u010e\1\273\1\15\1\143""+ ""\1\u010f\1\271\6\u0116\10\15\1\u010e\1\273\1\15\1\143""+ ""\1\u010f\1\271\1\u0116\1\u0115\4\u0116\5\15\2\2\2\300""+ ""\1\u0117\2\2\1\302\1\2\10\300\1\u0118\1\302\1\304""+ ""\2\2\2\u0119\3\2\1\u011a\1\2\7\u0119\1\u011b\1\u011c""+ ""\1\u011a\1\u011d\2\2\2\302\1\u011e\2\2\1\302\1\2""+ ""\10\302\1\u011f\1\302\1\307\2\2\2\62\1\u0120\2\2""+ ""\1\64\1\2\10\62\1\65\1\64\1\66\2\2\2\304""+ ""\1\u0121\2\2\1\307\1\2\10\304\1\u0122\1\307\1\304""+ ""\2\2\2\u011a\3\2\1\u011a\1\2\7\u011a\1\u0123\1\u0124""+ ""\1\u011a\1\u0125\2\2\2\64\1\u0126\2\2\1\64\1\2""+ ""\10\64\1\75\1\64\1\76\2\2\2\307\1\u0127\2\2""+ ""\1\307\1\2\10\307\1\u0128\2\307\2\2\2\312\1\63""+ ""\2\2\1\315\1\2\10\312\1\u0129\1\315\1\314\2\2""+ ""\2\315\1\74\2\2\1\315\1\2\10\315\1\u012a\1\315""+ ""\1\317\2\2\2\312\1\63\2\2\1\315\1\2\10\312""+ ""\1\u012b\1\315\1\314\2\2\2\325\1\63\2\2\1\326""+ ""\1\2\11\325\1\326\1\330\2\2\2\314\1\130\2\2""+ ""\1\317\1\2\10\314\1\u012c\1\317\1\314\2\2\2\315""+ ""\1\74\2\2\1\315\1\2\10\315\1\u012d\1\315\1\317""+ ""\2\2\2\326\1\74\2\2\1\326\1\2\12\326\1\335""+ ""\2\2\2\317\1\201\2\2\1\317\1\2\10\317\1\u012e""+ ""\2\317\2\2\2\320\1\120\2\2\1\321\1\2\10\320""+ ""\1\u012f\1\321\1\323\2\2\2\321\1\216\2\2\1\321""+ ""\1\2\10\321\1\u0130\1\321\1\332\2\2\2\327\1\120""+ ""\2\2\1\334\1\2\11\327\1\334\1\361\2\2\2\323""+ ""\1\236\2\2\1\332\1\2\10\323\1\u0131\1\332\1\323""+ ""\2\2\2\330\1\130\2\2\1\335\1\2\11\330\1\335""+ ""\1\330\2\2\2\325\1\166\2\2\1\326\1\2\11\325""+ ""\1\326\1\330\2\2\2\326\1\175\2\2\1\326\1\2""+ ""\12\326\1\335\2\2\2\327\1\231\2\2\1\334\1\2""+ ""\11\327\1\334\1\361\2\2\2\330\1\243\2\2\1\335""+ ""\1\2\11\330\1\335\1\330\2\2\2\334\1\216\2\2""+ ""\1\334\1\2\12\334\1\u0132\2\2\2\332\1\354\2\2""+ ""\1\332\1\2\10\332\1\u0133\2\332\2\2\2\335\1\201""+ ""\2\2\1\335\1\2\13\335\2\2\2\334\1\352\2\2""+ ""\1\334\1\2\12\334\1\u0132\2\2\2\335\1\336\2\2""+ ""\1\335\1\2\13\335\2\2\2\335\3\2\1\335\1\2""+ ""\10\335\1\u0132\2\335\2\2\2\230\1\354\2\2\1\230""+ ""\1\2\10\230\1\355\2\230\2\2\2\332\1\354\2\2""+ ""\1\332\1\2\10\332\1\u0134\2\332\2\2\2\22\1\u0135""+ ""\2\2\1\24\1\2\6\u0136\1\22\1\25\1\26\1\24""+ ""\1\27\2\2\2\22\1\u0135\2\2\1\24\1\2\6\u0137""+ ""\1\22\1\25\1\26\1\24\1\27\2\2\2\22\1\u0135""+ ""\2\2\1\24\1\2\6\u0138\1\22\1\25\1\26\1\24""+ ""\1\27\2\2\2\22\1\u0135\2\2\1\24\1\2\1\u0138""+ ""\1\u0137\3\u0138\1\u0139\1\22\1\25\1\26\1\24\1\27""+ ""\2\2\2\4\3\2\1\5\1\2\6\u013a\1\4\1\12""+ ""\1\13\1\5\1\14\2\2\2\25\1\345\2\2\1\31""+ ""\1\2\6\346\2\25\1\61\1\31\1\27\2\2\2\25""+ ""\1\202\2\2\1\31\1\2\6\346\2\25\1\61\1\31""+ ""\1\27\2\2\2\210\1\120\2\2\1\211\1\2\10\210""+ ""\1\u013b\1\211\1\212\2\2\2\211\1\216\2\2\1\211""+ ""\1\2\10\211\1\u013c\1\211\1\220\2\2\2\334\3\2""+ ""\1\334\1\2\12\334\1\u0132\2\2\2\230\3\2\1\230""+ ""\1\2\13\230\2\2\2\366\3\2\1\366\1\2\7\366""+ ""\2\340\1\366\1\340\2\2\2\230\1\u013d\2\2\1\230""+ ""\1\2\10\230\1\355\2\230\2\2\2\320\1\120\2\2""+ ""\1\321\1\2\10\320\1\u013e\1\321\1\323\2\2\2\321""+ ""\1\216\2\2\1\321\1\2\10\321\1\u013f\1\321\1\332""+ ""\2\2\2\361\1\236\2\2\1\u0132\1\2\11\361\1\u0132""+ ""\1\361\2\2\2\361\1\362\2\2\1\u0132\1\2\11\361""+ ""\1\u0132\1\361\2\2\2\361\3\2\1\u0132\1\2\11\361""+ ""\1\u0132\1\361\2\2\2\45\1\124\2\2\1\116\1\2""+ ""\10\45\1\u0140\1\116\1\45\2\2\2\116\1\221\2\2""+ ""\1\116\1\2\10\116\1\u0141\2\116\2\2\2\u0142\1\236""+ ""\2\2\1\u0143\1\2\7\u0142\1\323\1\360\1\u0143\1\323""+ ""\2\2\2\u0143\1\354\2\2\1\u0143\1\2\7\u0143\1\332""+ ""\1\u0134\1\u0143\1\332\2\2\2\154\1\130\2\2\1\156""+ ""\1\2\10\154\1\u0144\1\156\1\154\2\2\2\156\1\201""+ ""\2\2\1\156\1\2\10\156\1\u0145\2\156\2\2\2\314""+ ""\1\130\2\2\1\317\1\2\10\314\1\u0146\1\317\1\314""+ ""\2\2\2\317\1\201\2\2\1\317\1\2\10\317\1\u0147""+ ""\2\317\3\15\1\u0148\3\15\1\u0149\1\252\6\u0148\10\15""+ ""\1\u0149\3\15\1\u0149\1\253\6\u0149\10\15\1\u014a\3\15""+ ""\1\u014b\1\u014c\6\u014a\10\15\1\u014b\3\15\1\u014b\1\u014d""+ ""\6\u014b\10\15\1\u014e\2\15\1\143\1\u014f\1\15\1\u0150""+ ""\1\u0151\1\u0152\1\u0153\2\u0151\10\15\1\u014f\2\15\1\262""+ ""\1\u014f\1\15\1\u0154\1\u0155\1\u0156\1\u0157\2\u0155\10\15""+ ""\1\u0158\2\15\1\143\1\u0159\1\u0103\6\u0158\10\15\1\u0159""+ ""\2\15\1\262\1\u0159\1\u0104\6\u0159\10\15\1\u014e\3\15""+ ""\1\u014f\1\15\1\u0150\1\u0151\1\u0152\1\u0153\2\u0151\10\15""+ ""\1\u014f\3\15\1\u014f\1\15\1\u0154\1\u0155\1\u0156\1\u0157""+ ""\2\u0155\10\15\1\u0158\1\u0114\1\15\1\143\1\u0159\1\u0103""+ ""\6\u015a\10\15\1\u0158\1\273\1\15\1\143\1\u0159\1\u0103""+ ""\6\u015a\10\15\1\u0158\1\273\1\15\1\143\1\u0159\1\u0103""+ ""\6\u015b\10\15\1\u0158\1\273\1\15\1\143\1\u0159\1\u0103""+ ""\1\u015b\1\u015a\4\u015b\16\15\1\u015c\1\u015d\1\u015e\1\u015f""+ ""\2\u015d\10\15\1\u0159\1\u0160\1\15\1\262\1\u0159\1\u0104""+ ""\6\u0161\10\15\1\u0159\1\u0109\1\15\1\262\1\u0159\1\u0104""+ ""\6\u0161\10\15\1\u0159\1\u0109\1\15\1\262\1\u0159\1\u0104""+ ""\6\u0162\10\15\1\u0159\1\u0109\1\15\1\262\1\u0159\1\u0104""+ ""\1\u0162\1\u0161\4\u0162\10\15\1\u0163\2\15\1\143\1\u0164""+ ""\1\271\6\u0163\10\15\1\u0164\2\15\1\262\1\u0164\1\272""+ ""\6\u0164\11\15\1\u0165\4\15\6\u0166\11\15\1\u0165\4\15""+ ""\6\u0110\11\15\1\u0165\4\15\6\u0111\11\15\1\u0165\4\15""+ ""\1\u0111\1\u0110\3\u0111\1\u0167\16\15\6\u0166\10\15\1\u0163""+ ""\1\u0114\1\15\1\143\1\u0164\1\271\6\u0168\10\15\1\u0163""+ ""\1\273\1\15\1\143\1\u0164\1\271\6\u0168\5\15\2\2""+ ""\2\u0169\3\2\1\u016a\1\2\7\u0169\1\u016b\1\u016c\1\u016a""+ ""\1\u016d\2\2\2\u016e\1\u0120\2\2\1\u016f\1\2\10\u016e""+ ""\1\65\1\u016f\1\u0170\2\2\2\u0171\1\301\2\2\1\u0172""+ ""\1\2\7\u0171\1\u0173\1\u0174\1\u0172\1\u0175\2\2\2\u0172""+ ""\1\305\2\2\1\u0172\1\2\7\u0172\1\u0176\1\u0177\1\u0172""+ ""\1\u0178\2\2\2\u0173\1\301\2\2\1\u0176\1\2\10\u0173""+ ""\1\u0174\1\u0176\1\u0175\2\2\2\u0179\1\u017a\2\2\1\u017b""+ ""\1\2\10\u0179\1\u017c\1\u017b\1\u017d\2\2\2\u0175\1\u017e""+ ""\2\2\1\u0178\1\2\10\u0175\1\u017f\1\u0178\1\u0175\2\2""+ ""\2\u016a\3\2\1\u016a\1\2\7\u016a\1\u0180\1\u0181\1\u016a""+ ""\1\u0182\2\2\2\u016f\1\u0126\2\2\1\u016f\1\2\10\u016f""+ ""\1\75\1\u016f\1\u0183\2\2\2\u0184\3\2\1\u0185\1\2""+ ""\7\u0184\1\u0186\1\u0187\1\u0185\1\u0188\2\2\2\u0189\3\2""+ ""\1\u018a\1\2\7\u0189\1\u016d\1\u018b\1\u018a\1\u016d\2\2""+ ""\2\u0170\1\u018c\2\2\1\u0183\1\2\10\u0170\1\131\1\u0183""+ ""\1\u0170\2\2\2\u0176\1\305\2\2\1\u0176\1\2\10\u0176""+ ""\1\u0177\1\u0176\1\u0178\2\2\2\u017b\1\u018d\2\2\1\u017b""+ ""\1\2\10\u017b\1\u018e\1\u017b\1\u018f\2\2\2\u0178\1\u0190""+ ""\2\2\1\u0178\1\2\10\u0178\1\u0191\2\u0178\2\2\2\u0185""+ ""\3\2\1\u0185\1\2\7\u0185\1\u0192\1\u0193\1\u0185\1\u0194""+ ""\2\2\2\u018a\3\2\1\u018a\1\2\7\u018a\1\u0182\1\u0195""+ ""\1\u018a\1\u0182\2\2\2\u0183\1\u0196\2\2\1\u0183\1\2""+ ""\10\u0183\1\177\2\u0183\2\2\2\u0197\1\63\2\2\1\u0198""+ ""\1\2\10\u0197\1\u0186\1\u0198\1\u0199\2\2\2\u0198\1\74""+ ""\2\2\1\u0198\1\2\10\u0198\1\u0192\1\u0198\1\u019a\2\2""+ ""\2\u0197\1\63\2\2\1\u0198\1\2\10\u0197\1\325\1\u0198""+ ""\1\u0199\2\2\2\u0199\1\130\2\2\1\u019a\1\2\10\u0199""+ ""\1\330\1\u019a\1\u0199\2\2\2\u0198\1\74\2\2\1\u0198""+ ""\1\2\10\u0198\1\326\1\u0198\1\u019a\2\2\2\u019a\1\201""+ ""\2\2\1\u019a\1\2\10\u019a\1\335\2\u019a\2\2\2\u019b""+ ""\1\120\2\2\1\u019c\1\2\10\u019b\1\327\1\u019c\1\u019d""+ ""\2\2\2\u019c\1\216\2\2\1\u019c\1\2\10\u019c\1\334""+ ""\1\u019c\1\u019e\2\2\2\u019d\1\236\2\2\1\u019e\1\2""+ ""\10\u019d\1\361\1\u019e\1\u019d\2\2\2\u0132\1\u013d\2\2""+ ""\1\u0132\1\2\13\u0132\2\2\2\u019e\1\354\2\2\1\u019e""+ ""\1\2\10\u019e\1\u0132\2\u019e\2\2\2\u0132\1\354\2\2""+ ""\1\u0132\1\2\13\u0132\2\2\2\4\3\2\1\5\1\2""+ ""\1\u019f\1\u01a0\1\u01a1\1\u01a2\2\u01a0\1\4\1\12\1\13""+ ""\1\5\1\14\2\2\2\25\1\u01a3\2\2\1\31\1\2""+ ""\6\u01a4\2\25\1\57\1\31\1\27\2\2\2\25\1\u0135""+ ""\2\2\1\31\1\2\6\u01a4\2\25\1\57\1\31\1\27""+ ""\2\2\2\25\1\u0135\2\2\1\31\1\2\6\u01a5\2\25""+ ""\1\57\1\31\1\27\2\2\2\25\1\u0135\2\2\1\31""+ ""\1\2\1\u01a5\1\u01a4\4\u01a5\2\25\1\57\1\31\1\27""+ ""\2\2\2\22\1\u01a3\2\2\1\24\1\2\6\u0136\1\22""+ ""\1\25\1\26\1\24\1\27\2\2\2\u01a6\1\u017a\2\2""+ ""\1\u01a7\1\2\10\u01a6\1\u01a8\1\u01a7\1\u01a9\2\2\2\u01a7""+ ""\1\u018d\2\2\1\u01a7\1\2\10\u01a7\1\u01aa\1\u01a7\1\u01ab""+ ""\2\2\2\u0132\3\2\1\u0132\1\2\13\u0132\2\2\2\u019b""+ ""\1\120\2\2\1\u019c\1\2\10\u019b\1\u0187\1\u019c\1\u019d""+ ""\2\2\2\u019c\1\216\2\2\1\u019c\1\2\10\u019c\1\u0193""+ ""\1\u019c\1\u019e\2\2\2\212\1\236\2\2\1\220\1\2""+ ""\10\212\1\u01ac\1\220\1\212\2\2\2\220\1\354\2\2""+ ""\1\220\1\2\10\220\1\u01ad\2\220\2\2\2\323\1\236""+ ""\2\2\1\332\1\2\10\323\1\u01ae\1\332\1\323\2\2""+ ""\2\332\1\354\2\2\1\332\1\2\10\332\1\u01af\2\332""+ ""\2\2\2\304\1\u017e\2\2\1\307\1\2\10\304\1\u01b0""+ ""\1\307\1\304\2\2\2\307\1\u0190\2\2\1\307\1\2""+ ""\10\307\1\u01b1\2\307\2\2\2\u0199\1\130\2\2\1\u019a""+ ""\1\2\10\u0199\1\u0188\1\u019a\1\u0199\2\2\2\u019a\1\201""+ ""\2\2\1\u019a\1\2\10\u019a\1\u0194\2\u019a\10\15\1\252""+ ""\23\15\1\253\16\15\1\u01b2\3\15\1\u01b3\1\u014c\6\u01b2""+ ""\10\15\1\u01b3\3\15\1\u01b3\1\u014d\6\u01b3\10\15\1\u01b4""+ ""\3\15\1\u01b5\1\u01b6\6\u01b4\10\15\1\u01b5\3\15\1\u01b5""+ ""\1\u01b7\6\u01b5\10\15\1\u01b8\2\15\1\143\1\u01b9\1\u01ba""+ ""\6\u01b8\10\15\1\u01b9\2\15\1\262\1\u01b9\1\u01bb\6\u01b9""+ ""\10\15\1\u01b8\1\273\1\15\1\143\1\u01b9\1\u01ba\6\u01bc""+ ""\10\15\1\u01b8\1\273\1\15\1\143\1\u01b9\1\u01ba\6\u01bd""+ ""\10\15\1\u01b8\1\273\1\15\1\143\1\u01b9\1\u01ba\6\u01be""+ ""\10\15\1\u01b8\1\273\1\15\1\143\1\u01b9\1\u01ba\1\u01be""+ ""\1\u01bd\3\u01be\1\u01bf\10\15\1\u01b9\1\u0109\1\15\1\262""+ ""\1\u01b9\1\u01bb\6\u01c0\10\15\1\u01b9\1\u0109\1\15\1\262""+ ""\1\u01b9\1\u01bb\6\u01c1\10\15\1\u01b9\1\u0109\1\15\1\262""+ ""\1\u01b9\1\u01bb\6\u01c2\10\15\1\u01b9\1\u0109\1\15\1\262""+ ""\1\u01b9\1\u01bb\1\u01c2\1\u01c1\3\u01c2\1\u01c3\10\15\1\u01c4""+ ""\2\15\1\143\1\u01c5\1\u0103\6\u01c4\10\15\1\u01c5\2\15""+ ""\1\262\1\u01c5\1\u0104\6\u01c5\10\15\1\u01c4\1\u0114\1\15""+ ""\1\143\1\u01c5\1\u0103\6\u01c6\10\15\1\u01c4\1\273\1\15""+ ""\1\143\1\u01c5\1\u0103\6\u01c6\11\15\1\u01c7\4\15\6\u01c8""+ ""\11\15\1\u01c7\4\15\6\u015c\11\15\1\u01c7\4\15\6\u015d""+ ""\11\15\1\u01c7\4\15\1\u015d\1\u015c\3\u015d\1\u01c9\16\15""+ ""\6\u01c8\10\15\1\u01c5\1\u0160\1\15\1\262\1\u01c5\1\u0104""+ ""\6\u01ca\10\15\1\u01c5\1\u0109\1\15\1\262\1\u01c5\1\u0104""+ ""\6\u01ca\13\15\1\143\1\15\1\271\21\15\1\262\1\15""+ ""\1\272\24\15\1\u01cb\1\u01cc\1\u01cd\1\u01ce\2\u01cc\11\15""+ ""\1\u01cf\4\15\6\u0166\11\15\1\u0165\4\15\1\u0110\1\u0166""+ ""\4\u0110\11\15\1\u0114\1\15\1\143\1\15\1\271\6\u01d0""+ ""\5\15\2\2\2\u01d1\1\u0117\2\2\1\u01d2\1\2\7\u01d1""+ ""\1\300\1\303\1\u01d2\1\304\2\2\2\u01d2\1\u011e\2\2""+ ""\1\u01d2\1\2\7\u01d2\1\302\1\306\1\u01d2\1\307\2\2""+ ""\2\300\1\u0117\2\2\1\302\1\2\10\300\1\303\1\302""+ ""\1\304\2\2\2\u01a6\1\u01d3\2\2\1\u01a7\1\2\10\u01a6""+ ""\1\u01a8\1\u01a7\1\u01a9\2\2\2\304\1\u0121\2\2\1\307""+ ""\1\2\10\304\1\u01b0\1\307\1\304\2\2\2\300\1\157""+ ""\2\2\1\302\1\2\10\300\1\u0118\1\302\1\304\2\2""+ ""\2\302\1\165\2\2\1\302\1\2\10\302\1\u011f\1\302""+ ""\1\307\2\2\2\304\1\167\2\2\1\307\1\2\10\304""+ ""\1\u0122\1\307\1\304\2\2\2\u0173\1\301\2\2\1\u0176""+ ""\1\2\10\u0173\1\u01d4\1\u0176\1\u0175\2\2\2\u0176\1\305""+ ""\2\2\1\u0176\1\2\10\u0176\1\u01d5\1\u0176\1\u0178\2\2""+ ""\2\u0173\1\301\2\2\1\u0176\1\2\10\u0173\1\u01d6\1\u0176""+ ""\1\u0175\2\2\2\325\1\u0120\2\2\1\326\1\2\11\325""+ ""\1\326\1\330\2\2\2\u0175\1\u017e\2\2\1\u0178\1\2""+ ""\10\u0175\1\u01d7\1\u0178\1\u0175\2\2\2\u0176\1\305\2\2""+ ""\1\u0176\1\2\10\u0176\1\u01d8\1\u0176\1\u0178\2\2\2\326""+ ""\1\u0126\2\2\1\326\1\2\12\326\1\335\2\2\2\u0178""+ ""\1\u0190\2\2\1\u0178\1\2\10\u0178\1\u01d9\2\u0178\2\2""+ ""\2\u0179\1\u017a\2\2\1\u017b\1\2\10\u0179\1\u01da\1\u017b""+ ""\1\u017d\2\2\2\u01db\3\2\1\u01dc\1\2\7\u01db\2\u011c""+ ""\1\u01dc\1\u01dd\2\2\2\u017b\1\u018d\2\2\1\u017b\1\2""+ ""\10\u017b\1\u01de\1\u017b\1\u018f\2\2\2\327\1\u01df\2\2""+ ""\1\334\1\2\11\327\1\334\1\361\2\2\2\u017d\1\u01e0""+ ""\2\2\1\u018f\1\2\10\u017d\1\u01e1\1\u018f\1\u017d\2\2""+ ""\2\u01e2\3\2\1\u01e3\1\2\7\u01e2\1\u011d\1\u01dd\1\u01e3""+ ""\1\u011d\2\2\2\330\1\u018c\2\2\1\335\1\2\11\330""+ ""\1\335\1\330\2\2\2\302\1\u011e\2\2\1\302\1\2""+ ""\10\302\1\306\1\302\1\307\2\2\2\u01a7\1\u01e4\2\2""+ ""\1\u01a7\1\2\10\u01a7\1\u01aa\1\u01a7\1\u01ab\2\2\2\307""+ ""\1\u0127\2\2\1\307\1\2\10\307\1\u01b1\2\307\2\2""+ ""\2\307\1\176\2\2\1\307\1\2\10\307\1\u0128\2\307""+ ""\2\2\2\u01e5\1\u0120\2\2\1\u01e6\1\2\7\u01e5\1\u01e7""+ ""\1\u0174\1\u01e6\1\u01e8\2\2\2\u01e6\1\u0126\2\2\1\u01e6""+ ""\1\2\7\u01e6\1\u01e9\1\u0177\1\u01e6\1\u01ea\2\2\2\u01e7""+ ""\1\u0120\2\2\1\u01e9\1\2\10\u01e7\1\u0174\1\u01e9\1\u01e8""+ ""\2\2\2\u01eb\1\u01df\2\2\1\u01ec\1\2\10\u01eb\1\u017c""+ ""\1\u01ec\1\u01ed\2\2\2\u01e8\1\u018c\2\2\1\u01ea\1\2""+ ""\10\u01e8\1\u017f\1\u01ea\1\u01e8\2\2\2\u01ee\1\u0121\2\2""+ ""\1\u01ef\1\2\7\u01ee\1\304\1\u01b0\1\u01ef\1\304\2\2""+ ""\2\u01ef\1\u0127\2\2\1\u01ef\1\2\7\u01ef\1\307\1\u01b1""+ ""\1\u01ef\1\307\2\2\2\u01a9\1\u01f0\2\2\1\u01ab\1\2""+ ""\10\u01a9\1\u01f1\1\u01ab\1\u01a9\2\2\2\u01f2\3\2\1\u01f3""+ ""\1\2\7\u01f2\1\u0188\1\u01f4\1\u01f3\1\u0188\2\2\2\u01dc""+ ""\3\2\1\u01dc\1\2\7\u01dc\2\u0124\1\u01dc\1\u01f5\2\2""+ ""\2\334\1\u01f6\2\2\1\334\1\2\12\334\1\u0132\2\2""+ ""\2\u018f\1\u01f7\2\2\1\u018f\1\2\10\u018f\1\u01f8\2\u018f""+ ""\2\2\2\u01e3\3\2\1\u01e3\1\2\7\u01e3\1\u0125\1\u01f5""+ ""\1\u01e3\1\u0125\2\2\2\335\1\u0196\2\2\1\335\1\2""+ ""\13\335\2\2\2\u01e9\1\u0126\2\2\1\u01e9\1\2\10\u01e9""+ ""\1\u0177\1\u01e9\1\u01ea\2\2\2\u01ec\1\u01f6\2\2\1\u01ec""+ ""\1\2\10\u01ec\1\u018e\1\u01ec\1\u01f9\2\2\2\u01ea\1\u0196""+ ""\2\2\1\u01ea\1\2\10\u01ea\1\u0191\2\u01ea\2\2\2\u01ab""+ ""\1\u01fa\2\2\1\u01ab\1\2\10\u01ab\1\u01fb\2\u01ab\2\2""+ ""\2\u01f3\3\2\1\u01f3\1\2\7\u01f3\1\u0194\1\u01fc\1\u01f3""+ ""\1\u0194\2\2\2\312\1\166\2\2\1\315\1\2\10\312""+ ""\1\u012b\1\315\1\314\2\2\2\315\1\175\2\2\1\315""+ ""\1\2\10\315\1\u012d\1\315\1\317\2\2\2\314\1\243""+ ""\2\2\1\317\1\2\10\314\1\u012c\1\317\1\314\2\2""+ ""\2\317\1\336\2\2\1\317\1\2\10\317\1\u012e\2\317""+ ""\2\2\2\320\1\231\2\2\1\321\1\2\10\320\1\u012f""+ ""\1\321\1\323\2\2\2\321\1\352\2\2\1\321\1\2""+ ""\10\321\1\u0130\1\321\1\332\2\2\2\323\1\362\2\2""+ ""\1\332\1\2\10\323\1\u0131\1\332\1\323\2\2\2\332""+ ""\1\u013d\2\2\1\332\1\2\10\332\1\u0133\2\332\2\2""+ ""\2\22\1\23\2\2\1\24\1\2\6\u01fd\1\22\1\25""+ ""\1\26\1\24\1\27\2\2\2\22\1\23\2\2\1\24""+ ""\1\2\6\u01fe\1\22\1\25\1\26\1\24\1\27\2\2""+ ""\2\22\1\23\2\2\1\24\1\2\6\u01ff\1\22\1\25""+ ""\1\26\1\24\1\27\2\2\2\22\1\23\2\2\1\24""+ ""\1\2\1\u01ff\1\u01fe\3\u01ff\1\u0200\1\22\1\25\1\26""+ ""\1\24\1\27\2\2\2\4\3\2\1\5\1\2\6\u0201""+ ""\1\4\1\12\1\13\1\5\1\14\2\2\2\25\1\u01a3""+ ""\2\2\1\31\1\2\6\u01a4\2\25\1\61\1\31\1\27""+ ""\2\2\2\25\1\u0135\2\2\1\31\1\2\6\u01a4\2\25""+ ""\1\61\1\31\1\27\2\2\2\u01a6\1\u01d3\2\2\1\u01a7""+ ""\1\2\10\u01a6\1\u0202\1\u01a7\1\u01a9\2\2\2\u01a7\1\u01e4""+ ""\2\2\1\u01a7\1\2\10\u01a7\1\u0203\1\u01a7\1\u01ab\2\2""+ ""\2\117\1\u01df\2\2\1\121\1\2\10\117\1\122\1\121""+ ""\1\123\2\2\2\u01a9\1\u01f0\2\2\1\u01ab\1\2\10\u01a9""+ ""\1\u0204\1\u01ab\1\u01a9\2\2\2\121\1\u01f6\2\2\1\121""+ ""\1\2\10\121\1\217\1\121\1\230\2\2\2\u01ab\1\u01fa""+ ""\2\2\1\u01ab\1\2\10\u01ab\1\u0205\2\u01ab\2\2\2\u01a9""+ ""\1\u01e0\2\2\1\u01ab\1\2\10\u01a9\1\u01f1\1\u01ab\1\u01a9""+ ""\2\2\2\u01ab\1\u01f7\2\2\1\u01ab\1\2\10\u01ab\1\u01fb""+ ""\2\u01ab\2\2\2\u019d\1\236\2\2\1\u019e\1\2\10\u019d""+ ""\1\u01f4\1\u019e\1\u019d\2\2\2\u019e\1\354\2\2\1\u019e""+ ""\1\2\10\u019e\1\u01fc\2\u019e\2\2\2\66\1\u018c\2\2""+ ""\1\76\1\2\10\66\1\131\1\76\1\66\2\2\2\76""+ ""\1\u0196\2\2\1\76\1\2\10\76\1\177\2\76\3\15""+ ""\1\u0206\3\15\1\u0207\1\u014c\6\u0206\10\15\1\u0207\3\15""+ ""\1\u0207\1\u014d\6\u0207\10\15\1\u0208\3\15\1\u0209\1\u020a""+ ""\6\u0208\10\15\1\u0209\3\15\1\u0209\1\u020b\6\u0209\10\15""+ ""\1\u020c\2\15\1\143\1\u020d\1\15\1\u020e\1\u020f\1\u0210""+ ""\1\u0211\2\u020f\10\15\1\u020d\2\15\1\262\1\u020d\1\15""+ ""\1\u0212\1\u0213\1\u0214\1\u0215\2\u0213\10\15\1\u0216\2\15""+ ""\1\143\1\u0217\1\u01ba\6\u0216\10\15\1\u0217\2\15\1\262""+ ""\1\u0217\1\u01bb\6\u0217\10\15\1\u020c\3\15\1\u020d\1\15""+ ""\1\u020e\1\u020f\1\u0210\1\u0211\2\u020f\10\15\1\u020d\3\15""+ ""\1\u020d\1\15\1\u0212\1\u0213\1\u0214\1\u0215\2\u0213\10\15""+ ""\1\u0216\1\u0114\1\15\1\143\1\u0217\1\u01ba\6\u0218\10\15""+ ""\1\u0216\1\273\1\15\1\143\1\u0217\1\u01ba\6\u0218\10\15""+ ""\1\u0216\1\273\1\15\1\143\1\u0217\1\u01ba\6\u0219\10\15""+ ""\1\u0216\1\273\1\15\1\143\1\u0217\1\u01ba\1\u0219\1\u0218""+ ""\4\u0219\10\15\1\u0217\1\u0160\1\15\1\262\1\u0217\1\u01bb""+ ""\6\u021a\10\15\1\u0217\1\u0109\1\15\1\262\1\u0217\1\u01bb""+ ""\6\u021a\10\15\1\u0217\1\u0109\1\15\1\262\1\u0217\1\u01bb""+ ""\6\u021b\10\15\1\u0217\1\u0109\1\15\1\262\1\u0217\1\u01bb""+ ""\1\u021b\1\u021a\4\u021b\13\15\1\143\1\15\1\u0103\21\15""+ ""\1\262\1\15\1\u0104\17\15\1\u0114\1\15\1\143\1\15""+ ""\1\u0103\6\u01d0\16\15\1\u021c\1\u021d\1\u021e\1\u021f\2\u021d""+ ""\11\15\1\u0220\4\15\6\u01c8\11\15\1\u01c7\4\15\1\u015c""+ ""\1\u01c8\4\u015c\11\15\1\u0160\1\15\1\262\1\15\1\u0104""+ ""\6\u0221\11\15\1\u0222\4\15\6\u0223\11\15\1\u0222\4\15""+ ""\6\u01cb\11\15\1\u0222\4\15\6\u01cc\11\15\1\u0222\4\15""+ ""\1\u01cc\1\u01cb\3\u01cc\1\u0224\16\15\6\u0223\11\15\1\u0114""+ ""\4\15\6\u01d0\5\15\2\2\2\300\1\u0117\2\2\1\302""+ ""\1\2\10\300\1\u0225\1\302\1\304\2\2\2\302\1\u011e""+ ""\2\2\1\302\1\2\10\302\1\u0226\1\302\1\307\2\2""+ ""\2\u0227\3\2\1\u0228\1\2\7\u0227\2\u016c\1\u0228\1\u018b""+ ""\2\2\2\u0229\1\u0120\2\2\1\u022a\1\2\10\u0229\1\u011b""+ ""\1\u022a\1\u022b\2\2\2\u022a\1\u0126\2\2\1\u022a\1\2""+ ""\10\u022a\1\u0123\1\u022a\1\u022c\2\2\2\u0229\1\u0120\2\2""+ ""\1\u022a\1\2\10\u0229\1\325\1\u022a\1\u022b\2\2\2\u022b""+ ""\1\u018c\2\2\1\u022c\1\2\10\u022b\1\330\1\u022c\1\u022b""+ ""\2\2\2\u022a\1\u0126\2\2\1\u022a\1\2\10\u022a\1\326""+ ""\1\u022a\1\u022c\2\2\2\u022c\1\u0196\2\2\1\u022c\1\2""+ ""\10\u022c\1\335\2\u022c\2\2\2\u022d\1\u01df\2\2\1\u022e""+ ""\1\2\10\u022d\1\327\1\u022e\1\u022f\2\2\2\u0230\1\u017a""+ ""\2\2\1\u0231\1\2\7\u0230\1\u0179\1\u017c\1\u0231\1\u017d""+ ""\2\2\2\u0231\1\u018d\2\2\1\u0231\1\2\7\u0231\1\u017b""+ ""\1\u018e\1\u0231\1\u018f\2\2\2\u017d\1\u01e0\2\2\1\u018f""+ ""\1\2\10\u017d\1\u0232\1\u018f\1\u017d\2\2\2\u022e\1\u01f6""+ ""\2\2\1\u022e\1\2\10\u022e\1\334\1\u022e\1\u0233\2\2""+ ""\2\u0234\3\2\1\u0235\1\2\7\u0234\2\u0187\1\u0235\1\u01f4""+ ""\2\2\2\u0236\3\2\1\u0237\1\2\7\u0236\2\u01dd\1\u0237""+ ""\1\u01dd\2\2\2\u022f\1\u0238\2\2\1\u0233\1\2\10\u022f""+ ""\1\361\1\u0233\1\u022f\2\2\2\u0239\1\u017e\2\2\1\u023a""+ ""\1\2\7\u0239\1\u0175\1\u017f\1\u023a\1\u0175\2\2\2\u023a""+ ""\1\u0190\2\2\1\u023a\1\2\7\u023a\1\u0178\1\u0191\1\u023a""+ ""\1\u0178\2\2\2\u0228\3\2\1\u0228\1\2\7\u0228\2\u0181""+ ""\1\u0228\1\u0195\2\2\2\u01e7\1\u0120\2\2\1\u01e9\1\2""+ ""\10\u01e7\1\u023b\1\u01e9\1\u01e8\2\2\2\u01e9\1\u0126\2\2""+ ""\1\u01e9\1\2\10\u01e9\1\u023c\1\u01e9\1\u01ea\2\2\2\u01e7""+ ""\1\u0120\2\2\1\u01e9\1\2\10\u01e7\1\u023d\1\u01e9\1\u01e8""+ ""\2\2\2\u01e8\1\u018c\2\2\1\u01ea\1\2\10\u01e8\1\u023e""+ ""\1\u01ea\1\u01e8\2\2\2\u01e9\1\u0126\2\2\1\u01e9\1\2""+ ""\10\u01e9\1\u023f\1\u01e9\1\u01ea\2\2\2\u01ea\1\u0196\2\2""+ ""\1\u01ea\1\2\10\u01ea\1\u0240\2\u01ea\2\2\2\u01eb\1\u01df""+ ""\2\2\1\u01ec\1\2\10\u01eb\1\u0241\1\u01ec\1\u01ed\2\2""+ ""\2\u01ec\1\u01f6\2\2\1\u01ec\1\2\10\u01ec\1\u0242\1\u01ec""+ ""\1\u01f9\2\2\2\u01ed\1\u0238\2\2\1\u01f9\1\2\10\u01ed""+ ""\1\u0243\1\u01f9\1\u01ed\2\2\2\304\1\u0121\2\2\1\307""+ ""\1\2\10\304\1\u0244\1\307\1\304\2\2\2\307\1\u0127""+ ""\2\2\1\307\1\2\10\307\1\u0245\2\307\2\2\2\u0246""+ ""\3\2\1\u0247\1\2\7\u0246\2\u018b\1\u0247\1\u018b\2\2""+ ""\2\123\1\u0238\2\2\1\230\1\2\10\123\1\233\1\230""+ ""\1\123\2\2\2\u0248\1\u018c\2\2\1\u0249\1\2\7\u0248""+ ""\1\u01e8\1\u017f\1\u0249\1\u01e8\2\2\2\u0249\1\u0196\2\2""+ ""\1\u0249\1\2\7\u0249\1\u01ea\1\u0191\1\u0249\1\u01ea\2\2""+ ""\2\u01ed\1\u0238\2\2\1\u01f9\1\2\10\u01ed\1\u0232\1\u01f9""+ ""\1\u01ed\2\2\2\u018f\1\u01f7\2\2\1\u018f\1\2\10\u018f""+ ""\1\u024a\2\u018f\2\2\2\u0235\3\2\1\u0235\1\2\7\u0235""+ ""\2\u0193\1\u0235\1\u01fc\2\2\2\u0237\3\2\1\u0237\1\2""+ ""\7\u0237\2\u01f5\1\u0237\1\u01f5\2\2\2\u0233\1\u024b\2\2""+ ""\1\u0233\1\2\10\u0233\1\u0132\2\u0233\2\2\2\u01f9\1\u024b""+ ""\2\2\1\u01f9\1\2\10\u01f9\1\u024c\2\u01f9\2\2\2\u0247""+ ""\3\2\1\u0247\1\2\7\u0247\2\u0195\1\u0247\1\u0195\2\2""+ ""\2\230\1\u024b\2\2\1\230\1\2\10\230\1\355\2\230""+ ""\2\2\2\u01f9\1\u024b\2\2\1\u01f9\1\2\10\u01f9\1\u024a""+ ""\2\u01f9\2\2\2\25\1\23\2\2\1\31\1\2\6\u024d""+ ""\2\25\1\57\1\31\1\27\2\2\2\25\1\23\2\2""+ ""\1\31\1\2\6\u024e\2\25\1\57\1\31\1\27\2\2""+ ""\2\25\1\23\2\2\1\31\1\2\1\u024e\1\u024d\4\u024e""+ ""\2\25\1\57\1\31\1\27\2\2\2\u024f\1\u01df\2\2""+ ""\1\u0250\1\2\10\u024f\1\122\1\u0250\1\u0251\2\2\2\u0250""+ ""\1\u01f6\2\2\1\u0250\1\2\10\u0250\1\217\1\u0250\1\u0252""+ ""\2\2\2\u0251\1\u0238\2\2\1\u0252\1\2\10\u0251\1\233""+ ""\1\u0252\1\u0251\2\2\2\u0252\1\u024b\2\2\1\u0252\1\2""+ ""\10\u0252\1\355\2\u0252\10\15\1\u014c\23\15\1\u014d\16\15""+ ""\1\u0253\3\15\1\u0254\1\u020a\6\u0253\10\15\1\u0254\3\15""+ ""\1\u0254\1\u020b\6\u0254\10\15\1\u0255\3\15\1\u0256\1\u0257""+ ""\6\u0255\10\15\1\u0256\3\15\1\u0256\1\u0258\6\u0256\10\15""+ ""\1\u0259\2\15\1\143\1\u025a\1\u025b\6\u0259\10\15\1\u025a""+ ""\2\15\1\262\1\u025a\1\u025c\6\u025a\10\15\1\u0259\1\273""+ ""\1\15\1\143\1\u025a\1\u025b\6\u025d\10\15\1\u0259\1\273""+ ""\1\15\1\143\1\u025a\1\u025b\6\u025e\10\15\1\u0259\1\273""+ ""\1\15\1\143\1\u025a\1\u025b\6\u025f\10\15\1\u0259\1\273""+ ""\1\15\1\143\1\u025a\1\u025b\1\u025f\1\u025e\3\u025f\1\u0260""+ ""\10\15\1\u025a\1\u0109\1\15\1\262\1\u025a\1\u025c\6\u0261""+ ""\10\15\1\u025a\1\u0109\1\15\1\262\1\u025a\1\u025c\6\u0262""+ ""\10\15\1\u025a\1\u0109\1\15\1\262\1\u025a\1\u025c\6\u0263""+ ""\10\15\1\u025a\1\u0109\1\15\1\262\1\u025a\1\u025c\1\u0263""+ ""\1\u0262\3\u0263\1\u0264\10\15\1\u0265\2\15\1\143\1\u0266""+ ""\1\u01ba\6\u0265\10\15\1\u0266\2\15\1\262\1\u0266\1\u01bb""+ ""\6\u0266\10\15\1\u0265\1\u0114\1\15\1\143\1\u0266\1\u01ba""+ ""\6\u0267\10\15\1\u0265\1\273\1\15\1\143\1\u0266\1\u01ba""+ ""\6\u0267\10\15\1\u0266\1\u0160\1\15\1\262\1\u0266\1\u01bb""+ ""\6\u0268\10\15\1\u0266\1\u0109\1\15\1\262\1\u0266\1\u01bb""+ ""\6\u0268\11\15\1\u0269\4\15\6\u026a\11\15\1\u0269\4\15""+ ""\6\u021c\11\15\1\u0269\4\15\6\u021d\11\15\1\u0269\4\15""+ ""\1\u021d\1\u021c\3\u021d\1\u026b\16\15\6\u026a\11\15\1\u0160""+ ""\4\15\6\u0221\16\15\1\u026c\1\u026d\1\u026e\1\u026f\2\u026d""+ ""\11\15\1\u0270\4\15\6\u0223\11\15\1\u0222\4\15\1\u01cb""+ ""\1\u0223\4\u01cb\5\15\2\2\2\u016e\1\u0120\2\2\1\u016f""+ ""\1\2\10\u016e\1\153\1\u016f\1\u0170\2\2\2\u016f\1\u0126""+ ""\2\2\1\u016f\1\2\10\u016f\1\155\1\u016f\1\u0183\2\2""+ ""\2\u0271\1\u01d3\2\2\1\u0272\1\2\7\u0271\1\u01a6\1\u01a8""+ ""\1\u0272\1\u01a9\2\2\2\u0272\1\u01e4\2\2\1\u0272\1\2""+ ""\7\u0272\1\u01a7\1\u01aa\1\u0272\1\u01ab\2\2\2\u0173\1\166""+ ""\2\2\1\u0176\1\2\10\u0173\1\u01d6\1\u0176\1\u0175\2\2""+ ""\2\u0176\1\175\2\2\1\u0176\1\2\10\u0176\1\u01d8\1\u0176""+ ""\1\u0178\2\2\2\u0175\1\243\2\2\1\u0178\1\2\10\u0175""+ ""\1\u01d7\1\u0178\1\u0175\2\2\2\u0178\1\336\2\2\1\u0178""+ ""\1\2\10\u0178\1\u01d9\2\u0178\2\2\2\u0179\1\231\2\2""+ ""\1\u017b\1\2\10\u0179\1\u01da\1\u017b\1\u017d\2\2\2\u017b""+ ""\1\352\2\2\1\u017b\1\2\10\u017b\1\u01de\1\u017b\1\u018f""+ ""\2\2\2\u017d\1\362\2\2\1\u018f\1\2\10\u017d\1\u01e1""+ ""\1\u018f\1\u017d\2\2\2\u0179\1\u017a\2\2\1\u017b\1\2""+ ""\10\u0179\1\u0273\1\u017b\1\u017d\2\2\2\u017b\1\u018d\2\2""+ ""\1\u017b\1\2\10\u017b\1\u0274\1\u017b\1\u018f\2\2\2\361""+ ""\1\u0238\2\2\1\u0132\1\2\11\361\1\u0132\1\361\2\2""+ ""\2\u018f\1\u013d\2\2\1\u018f\1\2\10\u018f\1\u01f8\2\u018f""+ ""\2\2\2\u0275\1\u01df\2\2\1\u0276\1\2\7\u0275\1\u01eb""+ ""\1\u017c\1\u0276\1\u01ed\2\2\2\u0276\1\u01f6\2\2\1\u0276""+ ""\1\2\7\u0276\1\u01ec\1\u018e\1\u0276\1\u01f9\2\2\2\u0277""+ ""\1\u01e0\2\2\1\u0278\1\2\7\u0277\1\u017d\1\u0232\1\u0278""+ ""\1\u017d\2\2\2\u0278\1\u01f7\2\2\1\u0278\1\2\7\u0278""+ ""\1\u018f\1\u024a\1\u0278\1\u018f\2\2\2\u0279\3\2\1\u027a""+ ""\1\2\7\u0279\2\u01f4\1\u027a\1\u01f4\2\2\2\u0175\1\u017e""+ ""\2\2\1\u0178\1\2\10\u0175\1\u027b\1\u0178\1\u0175\2\2""+ ""\2\u0178\1\u0190\2\2\1\u0178\1\2\10\u0178\1\u027c\2\u0178""+ ""\2\2\2\u027d\1\u0120\2\2\1\u027e\1\2\10\u027d\1\u0186""+ ""\1\u027e\1\u027f\2\2\2\u027e\1\u0126\2\2\1\u027e\1\2""+ ""\10\u027e\1\u0192\1\u027e\1\u0280\2\2\2\u027d\1\u0120\2\2""+ ""\1\u027e\1\2\10\u027d\1\325\1\u027e\1\u027f\2\2\2\u027f""+ ""\1\u018c\2\2\1\u0280\1\2\10\u027f\1\330\1\u0280\1\u027f""+ ""\2\2\2\u027e\1\u0126\2\2\1\u027e\1\2\10\u027e\1\326""+ ""\1\u027e\1\u0280\2\2\2\u0280\1\u0196\2\2\1\u0280\1\2""+ ""\10\u0280\1\335\2\u0280\2\2\2\u0281\1\u01df\2\2\1\u0282""+ ""\1\2\10\u0281\1\327\1\u0282\1\u0283\2\2\2\u0282\1\u01f6""+ ""\2\2\1\u0282\1\2\10\u0282\1\334\1\u0282\1\u0284\2\2""+ ""\2\u0283\1\u0238\2\2\1\u0284\1\2\10\u0283\1\361\1\u0284""+ ""\1\u0283\2\2\2\u0170\1\u018c\2\2\1\u0183\1\2\10\u0170""+ ""\1\u0144\1\u0183\1\u0170\2\2\2\u0183\1\u0196\2\2\1\u0183""+ ""\1\2\10\u0183\1\u0145\2\u0183\2\2\2\u0285\1\u01f0\2\2""+ ""\1\u0286\1\2\7\u0285\1\u01a9\1\u01f1\1\u0286\1\u01a9\2\2""+ ""\2\u0286\1\u01fa\2\2\1\u0286\1\2\7\u0286\1\u01ab\1\u01fb""+ ""\1\u0286\1\u01ab\2\2\2\u01e8\1\u018c\2\2\1\u01ea\1\2""+ ""\10\u01e8\1\u0287\1\u01ea\1\u01e8\2\2\2\u01ea\1\u0196\2\2""+ ""\1\u01ea\1\2\10\u01ea\1\u0288\2\u01ea\2\2\2\u0132\1\u024b""+ ""\2\2\1\u0132\1\2\13\u0132\2\2\2\u027a\3\2\1\u027a""+ ""\1\2\7\u027a\2\u01fc\1\u027a\1\u01fc\2\2\2\u0284\1\u024b""+ ""\2\2\1\u0284\1\2\10\u0284\1\u0132\2\u0284\2\2\2\25""+ ""\1\23\2\2\1\31\1\2\6\u024d\2\25\1\61\1\31""+ ""\1\27\2\2\2\u01a6\1\223\2\2\1\u01a7\1\2\10\u01a6""+ ""\1\u0202\1\u01a7\1\u01a9\2\2\2\u01a7\1\227\2\2\1\u01a7""+ ""\1\2\10\u01a7\1\u0203\1\u01a7\1\u01ab\2\2\2\u01a9\1\232""+ ""\2\2\1\u01ab\1\2\10\u01a9\1\u0204\1\u01ab\1\u01a9\2\2""+ ""\2\u01ab\1\353\2\2\1\u01ab\1\2\10\u01ab\1\u0205\2\u01ab""+ ""\3\15\1\u0289\3\15\1\u028a\1\u020a\6\u0289\10\15\1\u028a""+ ""\3\15\1\u028a\1\u020b\6\u028a\10\15\1\u028b\3\15\1\u028c""+ ""\1\u028d\6\u028b\10\15\1\u028c\3\15\1\u028c\1\u028e\6\u028c""+ ""\10\15\1\u028f\2\15\1\143\1\u0290\1\15\1\u0291\1\u0292""+ ""\1\u0293\1\u0294\2\u0292\10\15\1\u0290\2\15\1\262\1\u0290""+ ""\1\15\1\u0295\1\u0296\1\u0297\1\u0298\2\u0296\10\15\1\u0299""+ ""\2\15\1\143\1\u029a\1\u025b\6\u0299\10\15\1\u029a\2\15""+ ""\1\262\1\u029a\1\u025c\6\u029a\10\15\1\u028f\3\15\1\u0290""+ ""\1\15\1\u0291\1\u0292\1\u0293\1\u0294\2\u0292\10\15\1\u0290""+ ""\3\15\1\u0290\1\15\1\u0295\1\u0296\1\u0297\1\u0298\2\u0296""+ ""\10\15\1\u0299\1\u0114\1\15\1\143\1\u029a\1\u025b\6\u029b""+ ""\10\15\1\u0299\1\273\1\15\1\143\1\u029a\1\u025b\6\u029b""+ ""\10\15\1\u0299\1\273\1\15\1\143\1\u029a\1\u025b\6\u029c""+ ""\10\15\1\u0299\1\273\1\15\1\143\1\u029a\1\u025b\1\u029c""+ ""\1\u029b\4\u029c\10\15\1\u029a\1\u0160\1\15\1\262\1\u029a""+ ""\1\u025c\6\u029d\10\15\1\u029a\1\u0109\1\15\1\262\1\u029a""+ ""\1\u025c\6\u029d\10\15\1\u029a\1\u0109\1\15\1\262\1\u029a""+ ""\1\u025c\6\u029e\10\15\1\u029a\1\u0109\1\15\1\262\1\u029a""+ ""\1\u025c\1\u029e\1\u029d\4\u029e\13\15\1\143\1\15\1\u01ba""+ ""\21\15\1\262\1\15\1\u01bb\17\15\1\u0114\1\15\1\143""+ ""\1\15\1\u01ba\6\u01d0\11\15\1\u0160\1\15\1\262\1\15""+ ""\1\u01bb\6\u0221\16\15\1\u029f\1\u02a0\1\u02a1\1\u02a2\2\u02a0""+ ""\11\15\1\u02a3\4\15\6\u026a\11\15\1\u0269\4\15\1\u021c""+ ""\1\u026a\4\u021c\13\15\1\143\2\15\6\u02a4\13\15\1\143""+ ""\2\15\6\u026c\13\15\1\143\2\15\6\u026d\13\15\1\143""+ ""\2\15\1\u026d\1\u026c\3\u026d\1\u02a5\16\15\6\u02a4\5\15""+ ""\2\2\2\u01a6\1\u01d3\2\2\1\u01a7\1\2\10\u01a6\1\u02a6""+ ""\1\u01a7\1\u01a9\2\2\2\u01a7\1\u01e4\2\2\1\u01a7\1\2""+ ""\10\u01a7\1\u02a7\1\u01a7\1\u01ab\2\2\2\u022d\1\u01df\2\2""+ ""\1\u022e\1\2\10\u022d\1\u011c\1\u022e\1\u022f\2\2\2\u022e""+ ""\1\u01f6\2\2\1\u022e\1\2\10\u022e\1\u0124\1\u022e\1\u0233""+ ""\2\2\2\u01eb\1\u01df\2\2\1\u01ec\1\2\10\u01eb\1\u02a8""+ ""\1\u01ec\1\u01ed\2\2\2\u01ec\1\u01f6\2\2\1\u01ec\1\2""+ ""\10\u01ec\1\u02a9\1\u01ec\1\u01f9\2\2\2\u017d\1\u01e0\2\2""+ ""\1\u018f\1\2\10\u017d\1\u02aa\1\u018f\1\u017d\2\2\2\u018f""+ ""\1\u01f7\2\2\1\u018f\1\2\10\u018f\1\u02ab\2\u018f\2\2""+ ""\2\u02ac\1\u0238\2\2\1\u02ad\1\2\7\u02ac\1\u01ed\1\u0232""+ ""\1\u02ad\1\u01ed\2\2\2\u02ad\1\u024b\2\2\1\u02ad\1\2""+ ""\7\u02ad\1\u01f9\1\u024a\1\u02ad\1\u01f9\2\2\2\u022b\1\u018c""+ ""\2\2\1\u022c\1\2\10\u022b\1\u011d\1\u022c\1\u022b\2\2""+ ""\2\u022c\1\u0196\2\2\1\u022c\1\2\10\u022c\1\u0125\2\u022c""+ ""\2\2\2\u01e7\1\166\2\2\1\u01e9\1\2\10\u01e7\1\u023d""+ ""\1\u01e9\1\u01e8\2\2\2\u01e9\1\175\2\2\1\u01e9\1\2""+ ""\10\u01e9\1\u023f\1\u01e9\1\u01ea\2\2\2\u01e8\1\243\2\2""+ ""\1\u01ea\1\2\10\u01e8\1\u023e\1\u01ea\1\u01e8\2\2\2\u01ea""+ ""\1\336\2\2\1\u01ea\1\2\10\u01ea\1\u0240\2\u01ea\2\2""+ ""\2\u01eb\1\231\2\2\1\u01ec\1\2\10\u01eb\1\u0241\1\u01ec""+ ""\1\u01ed\2\2\2\u01ec\1\352\2\2\1\u01ec\1\2\10\u01ec""+ ""\1\u0242\1\u01ec\1\u01f9\2\2\2\u01ed\1\362\2\2\1\u01f9""+ ""\1\2\10\u01ed\1\u0243\1\u01f9\1\u01ed\2\2\2\u01f9\1\u013d""+ ""\2\2\1\u01f9\1\2\10\u01f9\1\u024c\2\u01f9\2\2\2\u01a9""+ ""\1\u01f0\2\2\1\u01ab\1\2\10\u01a9\1\u02ae\1\u01ab\1\u01a9""+ ""\2\2\2\u01ab\1\u01fa\2\2\1\u01ab\1\2\10\u01ab\1\u02af""+ ""\2\u01ab\2\2\2\u027f\1\u018c\2\2\1\u0280\1\2\10\u027f""+ ""\1\u0188\1\u0280\1\u027f\2\2\2\u0280\1\u0196\2\2\1\u0280""+ ""\1\2\10\u0280\1\u0194\2\u0280\10\15\1\u020a\23\15\1\u020b""+ ""\16\15\1\u02b0\3\15\1\u02b1\1\u028d\6\u02b0\10\15\1\u02b1""+ ""\3\15\1\u02b1\1\u028e\6\u02b1\10\15\1\u02b2\3\15\1\u02b3""+ ""\1\u02b4\6\u02b2\10\15\1\u02b3\3\15\1\u02b3\1\u02b5\6\u02b3""+ ""\10\15\1\u02b6\2\15\1\143\1\u02b7\1\u02b8\6\u02b6\10\15""+ ""\1\u02b7\2\15\1\262\1\u02b7\1\u02b9\6\u02b7\10\15\1\u02b6""+ ""\1\273\1\15\1\143\1\u02b7\1\u02b8\6\u02ba\10\15\1\u02b6""+ ""\1\273\1\15\1\143\1\u02b7\1\u02b8\6\u02bb\10\15\1\u02b6""+ ""\1\273\1\15\1\143\1\u02b7\1\u02b8\6\u02bc\10\15\1\u02b6""+ ""\1\273\1\15\1\143\1\u02b7\1\u02b8\1\u02bc\1\u02bb\3\u02bc""+ ""\1\u02bd\10\15\1\u02b7\1\u0109\1\15\1\262\1\u02b7\1\u02b9""+ ""\6\u02be\10\15\1\u02b7\1\u0109\1\15\1\262\1\u02b7\1\u02b9""+ ""\6\u02bf\10\15\1\u02b7\1\u0109\1\15\1\262\1\u02b7\1\u02b9""+ ""\6\u02c0\10\15\1\u02b7\1\u0109\1\15\1\262\1\u02b7\1\u02b9""+ ""\1\u02c0\1\u02bf\3\u02c0\1\u02c1\10\15\1\u02c2\2\15\1\143""+ ""\1\u02c3\1\u025b\6\u02c2\10\15\1\u02c3\2\15\1\262\1\u02c3""+ ""\1\u025c\6\u02c3\10\15\1\u02c2\1\u0114\1\15\1\143\1\u02c3""+ ""\1\u025b\6\u02c4\10\15\1\u02c2\1\273\1\15\1\143\1\u02c3""+ ""\1\u025b\6\u02c4\10\15\1\u02c3\1\u0160\1\15\1\262\1\u02c3""+ ""\1\u025c\6\u02c5\10\15\1\u02c3\1\u0109\1\15\1\262\1\u02c3""+ ""\1\u025c\6\u02c5\13\15\1\262\2\15\6\u02c6\13\15\1\262""+ ""\2\15\6\u029f\13\15\1\262\2\15\6\u02a0\13\15\1\262""+ ""\2\15\1\u02a0\1\u029f\3\u02a0\1\u02c7\16\15\6\u02c6\13\15""+ ""\1\u02c8\2\15\6\u02a4\13\15\1\143\2\15\1\u026c\1\u02a4""+ ""\4\u026c\5\15\2\2\2\u024f\1\u01df\2\2\1\u0250\1\2""+ ""\10\u024f\1\u013b\1\u0250\1\u0251\2\2\2\u0250\1\u01f6\2\2""+ ""\1\u0250\1\2\10\u0250\1\u013c\1\u0250\1\u0252\2\2\2\u0281""+ ""\1\u01df\2\2\1\u0282\1\2\10\u0281\1\u0187\1\u0282\1\u0283""+ ""\2\2\2\u0282\1\u01f6\2\2\1\u0282\1\2\10\u0282\1\u0193""+ ""\1\u0282\1\u0284\2\2\2\u022f\1\u0238\2\2\1\u0233\1\2""+ ""\10\u022f\1\u01dd\1\u0233\1\u022f\2\2\2\u0233\1\u024b\2\2""+ ""\1\u0233\1\2\10\u0233\1\u01f5\2\u0233\2\2\2\u01ed\1\u0238""+ ""\2\2\1\u01f9\1\2\10\u01ed\1\u02c9\1\u01f9\1\u01ed\2\2""+ ""\2\u01f9\1\u024b\2\2\1\u01f9\1\2\10\u01f9\1\u02ca\2\u01f9""+ ""\2\2\2\u0251\1\u0238\2\2\1\u0252\1\2\10\u0251\1\u01ac""+ ""\1\u0252\1\u0251\2\2\2\u0252\1\u024b\2\2\1\u0252\1\2""+ ""\10\u0252\1\u01ad\2\u0252\3\15\1\u02cb\3\15\1\u02cc\1\u028d""+ ""\6\u02cb\10\15\1\u02cc\3\15\1\u02cc\1\u028e\6\u02cc\10\15""+ ""\1\u02cd\3\15\1\u02ce\1\u02cf\6\u02cd\10\15\1\u02ce\3\15""+ ""\1\u02ce\1\u02d0\6\u02ce\10\15\1\u02d1\2\15\1\143\1\u02d2""+ ""\1\15\1\u02d3\1\u02d4\1\u02d5\1\u02d6\2\u02d4\10\15\1\u02d2""+ ""\2\15\1\262\1\u02d2\1\15\1\u02d7\1\u02d8\1\u02d9\1\u02da""+ ""\2\u02d8\10\15\1\u02db\2\15\1\143\1\u02dc\1\u02b8\6\u02db""+ ""\10\15\1\u02dc\2\15\1\262\1\u02dc\1\u02b9\6\u02dc\10\15""+ ""\1\u02d1\3\15\1\u02d2\1\15\1\u02d3\1\u02d4\1\u02d5\1\u02d6""+ ""\2\u02d4\10\15\1\u02d2\3\15\1\u02d2\1\15\1\u02d7\1\u02d8""+ ""\1\u02d9\1\u02da\2\u02d8\10\15\1\u02db\1\u0114\1\15\1\143""+ ""\1\u02dc\1\u02b8\6\u02dd\10\15\1\u02db\1\273\1\15\1\143""+ ""\1\u02dc\1\u02b8\6\u02dd\10\15\1\u02db\1\273\1\15\1\143""+ ""\1\u02dc\1\u02b8\6\u02de\10\15\1\u02db\1\273\1\15\1\143""+ ""\1\u02dc\1\u02b8\1\u02de\1\u02dd\4\u02de\10\15\1\u02dc\1\u0160""+ ""\1\15\1\262\1\u02dc\1\u02b9\6\u02df\10\15\1\u02dc\1\u0109""+ ""\1\15\1\262\1\u02dc\1\u02b9\6\u02df\10\15\1\u02dc\1\u0109""+ ""\1\15\1\262\1\u02dc\1\u02b9\6\u02e0\10\15\1\u02dc\1\u0109""+ ""\1\15\1\262\1\u02dc\1\u02b9\1\u02e0\1\u02df\4\u02e0\13\15""+ ""\1\143\1\15\1\u025b\21\15\1\262\1\15\1\u025c\17\15""+ ""\1\u0114\1\15\1\143\1\15\1\u025b\6\u01d0\11\15\1\u0160""+ ""\1\15\1\262\1\15\1\u025c\6\u0221\13\15\1\u02e1\2\15""+ ""\6\u02c6\13\15\1\262\2\15\1\u029f\1\u02c6\4\u029f\5\15""+ ""\2\2\2\u0283\1\u0238\2\2\1\u0284\1\2\10\u0283\1\u01f4""+ ""\1\u0284\1\u0283\2\2\2\u0284\1\u024b\2\2\1\u0284\1\2""+ ""\10\u0284\1\u01fc\2\u0284\10\15\1\u028d\23\15\1\u028e\16\15""+ ""\1\u02e2\3\15\1\u02e3\1\u02cf\6\u02e2\10\15\1\u02e3\3\15""+ ""\1\u02e3\1\u02d0\6\u02e3\10\15\1\u02e4\3\15\1\u02e5\1\u02e6""+ ""\1\u02e7\1\u02e8\1\u02e9\1\u02ea\2\u02e8\10\15\1\u02e5\3\15""+ ""\1\u02e5\1\u02eb\1\u02ec\1\u02ed\1\u02ee\1\u02ef\2\u02ed\10\15""+ ""\1\u02f0\2\15\1\143\1\u02f1\1\u02f2\6\u02f0\10\15\1\u02f1""+ ""\2\15\1\262\1\u02f1\1\u02f3\6\u02f1\10\15\1\u02f0\1\273""+ ""\1\15\1\143\1\u02f1\1\u02f2\6\u02f4\10\15\1\u02f0\1\273""+ ""\1\15\1\143\1\u02f1\1\u02f2\6\u02f5\10\15\1\u02f0\1\273""+ ""\1\15\1\143\1\u02f1\1\u02f2\6\u02f6\10\15\1\u02f0\1\273""+ ""\1\15\1\143\1\u02f1\1\u02f2\1\u02f6\1\u02f5\3\u02f6\1\u02f7""+ ""\10\15\1\u02f1\1\u0109\1\15\1\262\1\u02f1\1\u02f3\6\u02f8""+ ""\10\15\1\u02f1\1\u0109\1\15\1\262\1\u02f1\1\u02f3\6\u02f9""+ ""\10\15\1\u02f1\1\u0109\1\15\1\262\1\u02f1\1\u02f3\6\u02fa""+ ""\10\15\1\u02f1\1\u0109\1\15\1\262\1\u02f1\1\u02f3\1\u02fa""+ ""\1\u02f9\3\u02fa\1\u02fb\10\15\1\u02fc\2\15\1\143\1\u02fd""+ ""\1\u02b8\6\u02fc\10\15\1\u02fd\2\15\1\262\1\u02fd\1\u02b9""+ ""\6\u02fd\10\15\1\u02fc\1\u0114\1\15\1\143\1\u02fd\1\u02b8""+ ""\6\u02fe\10\15\1\u02fc\1\273\1\15\1\143\1\u02fd\1\u02b8""+ ""\6\u02fe\10\15\1\u02fd\1\u0160\1\15\1\262\1\u02fd\1\u02b9""+ ""\6\u02ff\10\15\1\u02fd\1\u0109\1\15\1\262\1\u02fd\1\u02b9""+ ""\6\u02ff\10\15\1\u0300\3\15\1\u0301\1\u02cf\6\u0300\10\15""+ ""\1\u0301\3\15\1\u0301\1\u02d0\6\u0301\10\15\1\u0302\3\15""+ ""\1\u0303\1\u0304\6\u0302\10\15\1\u0303\3\15\1\u0303\1\u0305""+ ""\6\u0303\10\15\1\u0306\2\15\1\143\1\u0307\1\15\6\u0306""+ ""\10\15\1\u0302\1\273\2\15\1\u0303\1\u0304\6\u0308\10\15""+ ""\1\u0302\1\273\2\15\1\u0303\1\u0304\6\u0309\10\15\1\u0302""+ ""\1\273\2\15\1\u0303\1\u0304\6\u030a\10\15\1\u0302\1\273""+ ""\2\15\1\u0303\1\u0304\1\u030a\1\u0309\3\u030a\1\u030b\10\15""+ ""\1\u0307\2\15\1\262\1\u0307\1\15\6\u0307\10\15\1\u0303""+ ""\1\u0109\2\15\1\u0303\1\u0305\6\u030c\10\15\1\u0303\1\u0109""+ ""\2\15\1\u0303\1\u0305\6\u030d\10\15\1\u0303\1\u0109\2\15""+ ""\1\u0303\1\u0305\6\u030e\10\15\1\u0303\1\u0109\2\15\1\u0303""+ ""\1\u0305\1\u030e\1\u030d\3\u030e\1\u030f\10\15\1\u0310\2\15""+ ""\1\143\1\u0311\1\u02f2\6\u0310\10\15\1\u0311\2\15\1\262""+ ""\1\u0311\1\u02f3\6\u0311\10\15\1\u0306\3\15\1\u0307\1\15""+ ""\6\u0306\10\15\1\u0307\3\15\1\u0307\1\15\6\u0307\10\15""+ ""\1\u0310\1\u0114\1\15\1\143\1\u0311\1\u02f2\6\u0312\10\15""+ ""\1\u0310\1\273\1\15\1\143\1\u0311\1\u02f2\6\u0312\10\15""+ ""\1\u0310\1\273\1\15\1\143\1\u0311\1\u02f2\6\u0313\10\15""+ ""\1\u0310\1\273\1\15\1\143\1\u0311\1\u02f2\1\u0313\1\u0312""+ ""\4\u0313\10\15\1\u0311\1\u0160\1\15\1\262\1\u0311\1\u02f3""+ ""\6\u0314\10\15\1\u0311\1\u0109\1\15\1\262\1\u0311\1\u02f3""+ ""\6\u0314\10\15\1\u0311\1\u0109\1\15\1\262\1\u0311\1\u02f3""+ ""\6\u0315\10\15\1\u0311\1\u0109\1\15\1\262\1\u0311\1\u02f3""+ ""\1\u0315\1\u0314\4\u0315\13\15\1\143\1\15\1\u02b8\21\15""+ ""\1\262\1\15\1\u02b9\17\15\1\u0114\1\15\1\143\1\15""+ ""\1\u02b8\6\u01d0\11\15\1\u0160\1\15\1\262\1\15\1\u02b9""+ ""\6\u0221\15\15\1\u02cf\23\15\1\u02d0\16\15\1\u0316\3\15""+ ""\1\u0317\1\u0304\6\u0316\10\15\1\u0317\3\15\1\u0317\1\u0305""+ ""\6\u0317\10\15\1\u0306\3\15\1\u0307\1\u0318\6\u0306\10\15""+ ""\1\u0307\3\15\1\u0307\1\u0319\6\u0307\10\15\1\u031a\2\15""+ ""\1\143\1\u031b\1\15\6\u031a\10\15\1\u031b\2\15\1\262""+ ""\1\u031b\1\15\6\u031b\10\15\1\u0316\1\u0114\2\15\1\u0317""+ ""\1\u0304\6\u031c\10\15\1\u0316\1\273\2\15\1\u0317\1\u0304""+ ""\6\u031c\10\15\1\u0316\1\273\2\15\1\u0317\1\u0304\6\u031d""+ ""\10\15\1\u0316\1\273\2\15\1\u0317\1\u0304\1\u031d\1\u031c""+ ""\4\u031d\10\15\1\u0317\1\u0160\2\15\1\u0317\1\u0305\6\u031e""+ ""\10\15\1\u0317\1\u0109\2\15\1\u0317\1\u0305\6\u031e\10\15""+ ""\1\u0317\1\u0109\2\15\1\u0317\1\u0305\6\u031f\10\15\1\u0317""+ ""\1\u0109\2\15\1\u0317\1\u0305\1\u031f\1\u031e\4\u031f\10\15""+ ""\1\u0320\2\15\1\143\1\u0321\1\u02f2\6\u0320\10\15\1\u0321""+ ""\2\15\1\262\1\u0321\1\u02f3\6\u0321\10\15\1\u0320\1\u0114""+ ""\1\15\1\143\1\u0321\1\u02f2\6\u0322\10\15\1\u0320\1\273""+ ""\1\15\1\143\1\u0321\1\u02f2\6\u0322\10\15\1\u0321\1\u0160""+ ""\1\15\1\262\1\u0321\1\u02f3\6\u0323\10\15\1\u0321\1\u0109""+ ""\1\15\1\262\1\u0321\1\u02f3\6\u0323\10\15\1\u0324\3\15""+ ""\1\u0325\1\u0304\6\u0324\10\15\1\u0325\3\15\1\u0325\1\u0305""+ ""\6\u0325\13\15\1\143\23\15\1\262\20\15\1\u0326\2\15""+ ""\1\143\1\u0327\1\15\6\u0326\10\15\1\u0327\2\15\1\262""+ ""\1\u0327\1\15\6\u0327\10\15\1\u0324\1\u0114\2\15\1\u0325""+ ""\1\u0304\6\u0328\10\15\1\u0324\1\273\2\15\1\u0325\1\u0304""+ ""\6\u0328\10\15\1\u0325\1\u0160\2\15\1\u0325\1\u0305\6\u0329""+ ""\10\15\1\u0325\1\u0109\2\15\1\u0325\1\u0305\6\u0329\13\15""+ ""\1\143\1\15\1\u02f2\21\15\1\262\1\15\1\u02f3\17\15""+ ""\1\u0114\1\15\1\143\1\15\1\u02f2\6\u01d0\11\15\1\u0160""+ ""\1\15\1\262\1\15\1\u02f3\6\u0221\15\15\1\u0304\23\15""+ ""\1\u0305\16\15\1\u0318\2\15\1\143\1\u0319\1\15\6\u0318""+ ""\10\15\1\u0319\2\15\1\262\1\u0319\1\15\6\u0319\11\15""+ ""\1\u0114\3\15\1\u0304\6\u01d0\11\15\1\u0160\3\15\1\u0305""+ ""\6\u0221\5\15"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[16000];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\u0329\1"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[809];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 private Parser parser;
	 private int range;
	 public void analyse(Parser p,int r) {
		 if (!p.has(r)) return;
		 analyse(p,r,p.uri,p.start(r),p.end(r));
	 }
	 public void analyse(Parser p,int r, String str) {
		 analyse(p,r,str,0,str.length());
	 }
	 synchronized private void analyse(Parser p,int r, String str, int start, int finish) {
		 parser = p;
		 range = r;
		 yyreset(null);
		 useXhost = false;
		 this.zzAtEOF = true;
		 int length = finish - start;
		 zzEndRead = length;
		 while (length > zzBuffer.length) zzBuffer = new char[zzBuffer.length*2];
		 str.getChars( start, finish, zzBuffer, 0);
		 try {
			 yylex();
		 }
		 catch (java.io.IOException e) {
		 }
		 xhost(str,start,finish);
	 }
	 LexerXHost lexXHost = new LexerXHost((java.io.Reader) null);
	 boolean useXhost;
	 private void xhost(String str, int start, int finish) {
		 if (useXhost) {
			 lexXHost.analyse(parser,range,str,start,finish);
		 }
	 }
	 private void error(int e) {
		 switch(e) {
			 case NOT_DNS_NAME: case NON_URI_CHARACTER: useXhost = true;
			 break;
		 }
		 parser.recordError(range,e);
	 }
	 private void rule(int rule) {
		 parser.matchedRule(range,rule);
	 }
	 LexerHost(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 LexerHost(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 72) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead > 0) {
			 zzEndRead+= numRead;
			 return false;
		 }
		 if (numRead == 0) {
			 int c = zzReader.read();
			 if (c == -1) {
				 return true;
			 }
			 else {
				 zzBuffer[zzEndRead++] = (char) c;
				 return false;
			 }
		 }
		 return true;
	 }
	 private final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 private final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEOFDone = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 private final int yystate() {
		 return zzLexicalState;
	 }
	 private final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 private final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 private final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 private final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 private void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	 private int yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 yychar+= zzMarkedPosL-zzStartRead;
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 32: {
					 rule(49);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 59: break;
				 case 37: {
					 rule(1);
				 }
				 case 60: break;
				 case 57: {
					 rule(4);
					 error(IP_V4_OCTET_RANGE);
				 }
				 case 61: break;
				 case 36: {
					 rule(55);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 62: break;
				 case 20: {
					 rule(17);
					 error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 63: break;
				 case 13: {
					 rule(15);
					 error(NON_URI_CHARACTER);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 64: break;
				 case 30: {
					 rule(26);
					 error(ACE_PREFIX);
				 }
				 case 65: break;
				 case 10: {
					 rule(20);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(LOWERCASE_PREFERRED);
				 }
				 case 66: break;
				 case 58: {
					 rule(6);
					 error(IPv6ADDRESS_SHOULD_BE_LOWERCASE);
					error(IP_V4_OCTET_RANGE);
				 }
				 case 67: break;
				 case 6: {
					 rule(14);
					 error(NON_URI_CHARACTER);
				 }
				 case 68: break;
				 case 53: {
					 rule(8);
				 }
				 case 69: break;
				 case 31: {
					 rule(28);
					 error(ACE_PREFIX);
					error(LOWERCASE_PREFERRED);
				 }
				 case 70: break;
				 case 5: {
					 rule(18);
					 error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 71: break;
				 case 15: {
					 rule(44);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(LOWERCASE_PREFERRED);
				 }
				 case 72: break;
				 case 38: {
					 rule(2);
					 error(IPv6ADDRESS_SHOULD_BE_LOWERCASE);
				 }
				 case 73: break;
				 case 50: {
					 rule(38);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
				 }
				 case 74: break;
				 case 26: {
					 rule(54);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
				 }
				 case 75: break;
				 case 47: {
					 rule(36);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(LOWERCASE_PREFERRED);
				 }
				 case 76: break;
				 case 33: {
					 rule(53);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 77: break;
				 case 40: {
					 rule(27);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 78: break;
				 case 27: {
					 rule(23);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 79: break;
				 case 56: {
					 rule(9);
					 error(IP_V4_OCTET_RANGE);
				 }
				 case 80: break;
				 case 55: {
					 rule(41);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 81: break;
				 case 45: {
					 rule(34);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 82: break;
				 case 16: {
					 rule(43);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 83: break;
				 case 48: {
					 rule(33);
					 error(ACE_PREFIX);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 84: break;
				 case 21: {
					 rule(21);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 85: break;
				 case 19: {
					 rule(48);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
				 }
				 case 86: break;
				 case 18: {
					 rule(45);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 87: break;
				 case 51: {
					 rule(37);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 88: break;
				 case 22: {
					 rule(24);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
				 }
				 case 89: break;
				 case 46: {
					 rule(31);
					 error(ACE_PREFIX);
					error(NON_URI_CHARACTER);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 90: break;
				 case 17: {
					 rule(46);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(NON_URI_CHARACTER);
				 }
				 case 91: break;
				 case 52: {
					 rule(40);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
				 }
				 case 92: break;
				 case 24: {
					 rule(52);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(LOWERCASE_PREFERRED);
				 }
				 case 93: break;
				 case 25: {
					 rule(51);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 94: break;
				 case 42: {
					 rule(29);
					 error(ACE_PREFIX);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 95: break;
				 case 41: {
					 rule(30);
					 error(ACE_PREFIX);
					error(NON_URI_CHARACTER);
				 }
				 case 96: break;
				 case 12: {
					 rule(22);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
				 }
				 case 97: break;
				 case 49: {
					 rule(35);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 98: break;
				 case 54: {
					 rule(39);
					 error(ACE_PREFIX);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 99: break;
				 case 3: {
					 rule(10);
				 }
				 case 100: break;
				 case 35: {
					 rule(25);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 101: break;
				 case 23: {
					 rule(50);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 102: break;
				 case 43: {
					 rule(32);
					 error(ACE_PREFIX);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
				 }
				 case 103: break;
				 case 29: {
					 rule(3);
				 }
				 case 104: break;
				 case 39: {
					 rule(5);
					 error(IPv6ADDRESS_SHOULD_BE_LOWERCASE);
				 }
				 case 105: break;
				 case 14: {
					 rule(42);
					 error(DOUBLE_DASH_IN_REG_NAME);
				 }
				 case 106: break;
				 case 2: {
					 rule(7);
					 error(IP_V6_OR_FUTURE_ADDRESS_SYNTAX);
				 }
				 case 107: break;
				 case 11: {
					 rule(19);
					 error(DNS_LABEL_DASH_START_OR_END);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 108: break;
				 case 8: {
					 rule(13);
					 error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 109: break;
				 case 1: {
					 rule(58);
					 error(NOT_DNS_NAME);
				 }
				 case 110: break;
				 case 28: {
					 rule(47);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(NON_URI_CHARACTER);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 111: break;
				 case 9: {
					 rule(16);
					 error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
				 }
				 case 112: break;
				 case 4: {
					 rule(12);
					 error(LOWERCASE_PREFERRED);
				 }
				 case 113: break;
				 case 34: {
					 rule(56);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
				 }
				 case 114: break;
				 case 44: {
					 rule(57);
					 error(DOUBLE_DASH_IN_REG_NAME);
					error(DNS_LABEL_DASH_START_OR_END);
					error(NON_URI_CHARACTER);
					error(LOWERCASE_PREFERRED);
					error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 115: break;
				 case 7: {
					 rule(11);
					 error(DNS_LABEL_DASH_START_OR_END);
				 }
				 case 116: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 return YYEOF;
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel{
	 protected EList<String> visibility;
	 protected EList<String> static_;
	 protected EList<String> synchronized_;
	 protected EList<String> abstract_;
	 protected EList<String> final_;
	 protected static final String NAME_EDEFAULT = null;
	 protected String name = NAME_EDEFAULT;
	 protected LoopedModelImpl() {
		 super();
	 }
	 protected EClass eStaticClass() {
		 return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;
	 }
	 public EList<String> getVisibility() {
		 if (visibility == null) {
			 visibility = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);
		 }
		 return visibility;
	 }
	 public EList<String> getStatic() {
		 if (static_ == null) {
			 static_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);
		 }
		 return static_;
	 }
	 public EList<String> getSynchronized() {
		 if (synchronized_ == null) {
			 synchronized_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);
		 }
		 return synchronized_;
	 }
	 public EList<String> getAbstract() {
		 if (abstract_ == null) {
			 abstract_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);
		 }
		 return abstract_;
	 }
	 public EList<String> getFinal() {
		 if (final_ == null) {
			 final_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);
		 }
		 return final_;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String newName) {
		 String oldName = name;
		 name = newName;
		 if (eNotificationRequired()) eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));
	 }
	 public Object eGet(int featureID, boolean resolve, boolean coreType) {
		 switch (featureID) {
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY: return getVisibility();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC: return getStatic();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED: return getSynchronized();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT: return getAbstract();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL: return getFinal();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME: return getName();
		 }
		 return super.eGet(featureID, resolve, coreType);
	 }
	 public void eSet(int featureID, Object newValue) {
		 switch (featureID) {
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY: getVisibility().clear();
			 getVisibility().addAll((Collection<? extends String>)newValue);
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC: getStatic().clear();
			 getStatic().addAll((Collection<? extends String>)newValue);
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED: getSynchronized().clear();
			 getSynchronized().addAll((Collection<? extends String>)newValue);
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT: getAbstract().clear();
			 getAbstract().addAll((Collection<? extends String>)newValue);
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL: getFinal().clear();
			 getFinal().addAll((Collection<? extends String>)newValue);
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME: setName((String)newValue);
			 return;
		 }
		 super.eSet(featureID, newValue);
	 }
	 public void eUnset(int featureID) {
		 switch (featureID) {
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY: getVisibility().clear();
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC: getStatic().clear();
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED: getSynchronized().clear();
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT: getAbstract().clear();
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL: getFinal().clear();
			 return;
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME: setName(NAME_EDEFAULT);
			 return;
		 }
		 super.eUnset(featureID);
	 }
	 public boolean eIsSet(int featureID) {
		 switch (featureID) {
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY: return visibility != null && !visibility.isEmpty();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC: return static_ != null && !static_.isEmpty();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED: return synchronized_ != null && !synchronized_.isEmpty();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT: return abstract_ != null && !abstract_.isEmpty();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL: return final_ != null && !final_.isEmpty();
			 case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME: return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
		 }
		 return super.eIsSet(featureID);
	 }
	 public String toString() {
		 if (eIsProxy()) return super.toString();
		 StringBuffer result = new StringBuffer(super.toString());
		 result.append("" (visibility: "");
		 result.append(visibility);
		 result.append("", static: "");
		 result.append(static_);
		 result.append("", synchronized: "");
		 result.append(synchronized_);
		 result.append("", abstract: "");
		 result.append(abstract_);
		 result.append("", final: "");
		 result.append(final_);
		 result.append("", name: "");
		 result.append(name);
		 result.append(')');
		 return result.toString();
	 }
}",1,1,0,0
"protected void exportLine(TableBuilder tableBuilder, JRPrintLine line, JRExporterGridCell gridCell) throws IOException;",0,0,0,0
"public class Bug288734TestLanguageSwitch<T> extends Switch<T>{
	 protected static Bug288734TestLanguagePackage modelPackage;
	 public Bug288734TestLanguageSwitch() {
		 if (modelPackage == null) {
			 modelPackage = Bug288734TestLanguagePackage.eINSTANCE;
		 }
	 }
	 protected boolean isSwitchFor(EPackage ePackage) {
		 return ePackage == modelPackage;
	 }
	 protected T doSwitch(int classifierID, EObject theEObject) {
		 switch (classifierID) {
			 case Bug288734TestLanguagePackage.MODEL: {
				 Model model = (Model)theEObject;
				 T result = caseModel(model);
				 if (result == null) result = defaultCase(theEObject);
				 return result;
			 }
			 case Bug288734TestLanguagePackage.TCONSTANT: {
				 TConstant tConstant = (TConstant)theEObject;
				 T result = caseTConstant(tConstant);
				 if (result == null) result = defaultCase(theEObject);
				 return result;
			 }
			 case Bug288734TestLanguagePackage.TSTRING_CONSTANT: {
				 TStringConstant tStringConstant = (TStringConstant)theEObject;
				 T result = caseTStringConstant(tStringConstant);
				 if (result == null) result = caseTConstant(tStringConstant);
				 if (result == null) result = defaultCase(theEObject);
				 return result;
			 }
			 case Bug288734TestLanguagePackage.TINTEGER_CONSTANT: {
				 TIntegerConstant tIntegerConstant = (TIntegerConstant)theEObject;
				 T result = caseTIntegerConstant(tIntegerConstant);
				 if (result == null) result = caseTConstant(tIntegerConstant);
				 if (result == null) result = defaultCase(theEObject);
				 return result;
			 }
			 case Bug288734TestLanguagePackage.TBOOLEAN_CONSTANT: {
				 TBooleanConstant tBooleanConstant = (TBooleanConstant)theEObject;
				 T result = caseTBooleanConstant(tBooleanConstant);
				 if (result == null) result = caseTConstant(tBooleanConstant);
				 if (result == null) result = defaultCase(theEObject);
				 return result;
			 }
			 case Bug288734TestLanguagePackage.TANNOTATION: {
				 TAnnotation tAnnotation = (TAnnotation)theEObject;
				 T result = caseTAnnotation(tAnnotation);
				 if (result == null) result = defaultCase(theEObject);
				 return result;
			 }
			 default: return defaultCase(theEObject);
		 }
	 }
	 public T caseModel(Model object) {
		 return null;
	 }
	 public T caseTConstant(TConstant object) {
		 return null;
	 }
	 public T caseTStringConstant(TStringConstant object) {
		 return null;
	 }
	 public T caseTIntegerConstant(TIntegerConstant object) {
		 return null;
	 }
	 public T caseTBooleanConstant(TBooleanConstant object) {
		 return null;
	 }
	 public T caseTAnnotation(TAnnotation object) {
		 return null;
	 }
	 public T defaultCase(EObject object) {
		 return null;
	 }
}",1,0,0,0
"public class FillStroke extends Surface {
	 public FillStroke() {
		 setBackground(WHITE);
	 }
	 public void render(int w, int h, Graphics2D g2) {
		 GeneralPath p = new GeneralPath(Path2D.WIND_EVEN_ODD);
		 p.moveTo(w * .5f, h * .15f);
		 p.lineTo(w * .8f, h * .75f);
		 p.lineTo(w * .2f, h * .75f);
		 g2.setColor(LIGHT_GRAY);
		 g2.fill(p);
		 g2.setColor(BLACK);
		 g2.setStroke(new BasicStroke(10));
		 g2.draw(p);
		 TextLayout tl = new TextLayout(""Fill, Stroke w/o closePath"", g2.getFont(), g2.getFontRenderContext());
		 tl.draw(g2, (float) (w / 2 - tl.getBounds().getWidth() / 2), h * .85f);
	 }
	 public static void main(String[] s) {
		 createDemoFrame(new FillStroke());
	 }
}",0,0,0,0
"private void sort() {
	 if (comparator == null) {
		 if (reverse) {
			 Collections.sort(lines, new Comparator() {
				 public int compare(Object o1, Object o2) {
					 String s1 = (String) o1;
					 String s2 = (String) o2;
					 return (-s1.compareTo(s2));
				 }
			 }
			);
		 }
		 else {
			 Collections.sort(lines);
		 }
	 }
	 else {
		 Collections.sort(lines, comparator);
	 }
 }",0,0,0,0
"class LexerXHost extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {
	 private static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 2048;
	 public static final int YYINITIAL = 0;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 1 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\11\14\1\13\1\13\2\14\1\13\22\14\1\12\1\3\1\17\1\0""+ ""\1\3\1\4\7\3\2\2\1\0\1\6\1\10\1\5\7\10\1\0""+ ""\1\3\1\17\1\3\1\17\2\0\6\7\24\1\1\0\1\17\1\0""+ ""\1\17\1\2\1\17\1\11\5\11\24\2\3\17\1\2\6\16\1\15""+ ""\32\16\ud760\22\u0400\20\u0400\21\u2000\22"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7""+ ""\1\10\1\11\1\12\1\13\2\14\1\15\1\16\3\0""+ ""\1\17\1\20\1\21\1\22\1\23"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[25];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\23\0\46\0\46\0\46\0\46\0\71\0\114""+ ""\0\46\0\46\0\46\0\46\0\46\0\137\0\46\0\46""+ ""\0\114\0\162\0\205\0\230\0\46\0\46\0\46\0\46""+ ""\0\46"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[25];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\3\1\4\1\5\1\6\1\7\2\5\1\4\2\5""+ ""\1\10\1\11\1\12\1\13\1\14\1\15\1\16\1\17""+ ""\1\20\1\3\1\4\1\5\1\6\1\7\2\5\1\4""+ ""\2\5\1\21\1\11\1\12\1\13\1\14\1\15\1\16""+ ""\1\17\1\20\30\0\1\22\3\23\1\24\23\0\1\25""+ ""\31\0\1\26\6\0\1\27\1\30\2\27\1\31\16\0""+ ""\4\27\1\31\16\0\5\31\11\0"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[171];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\2\0\4\11\2\1\5\11\1\1\2\11\1\1\3\0""+ ""\5\11"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[25];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 private int lastChar;
	 char[] zzBuffer() {
		 yyreset(null);
		 this.zzAtEOF = true;
		 int length = parser.end(range)-parser.start(range);
		 lastChar = length - 1;
		 zzEndRead = length;
		 while (length > zzBuffer.length) zzBuffer = new char[zzBuffer.length*2];
		 return zzBuffer;
	 }
	 protected void error(int e) {
		 switch(e) {
			 case PERCENT: case PERCENT_20: parser.recordError(HOST,USE_PUNYCODE_NOT_PERCENTS);
			 break;
		 }
		 parser.recordError(range,e);
	 }
	 LexerXHost(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 LexerXHost(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 90) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead > 0) {
			 zzEndRead+= numRead;
			 return false;
		 }
		 if (numRead == 0) {
			 int c = zzReader.read();
			 if (c == -1) {
				 return true;
			 }
			 else {
				 zzBuffer[zzEndRead++] = (char) c;
				 return false;
			 }
		 }
		 return true;
	 }
	 private final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 private final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEOFDone = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 private final int yystate() {
		 return zzLexicalState;
	 }
	 private final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 private final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 private final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 public void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	public int yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 yychar+= zzMarkedPosL-zzStartRead;
			 if (zzMarkedPosL > zzStartRead) {
				 switch (zzBufferL[zzMarkedPosL-1]) {
					 case '\n': case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': zzAtBOL = true;
					 break;
					 case '\r': if (zzMarkedPosL < zzEndReadL) zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 else if (zzAtEOF) zzAtBOL = false;
					 else {
						 boolean eof = zzRefill();
						 zzMarkedPosL = zzMarkedPos;
						 zzEndReadL = zzEndRead;
						 zzBufferL = zzBuffer;
						 if (eof) zzAtBOL = false;
						 else zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 }
					 break;
					 default: zzAtBOL = false;
				 }
			 }
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 if (zzAtBOL) zzState = ZZ_LEXSTATE[zzLexicalState+1];
			 else zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 15: {
					 rule(-70);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 20: break;
				 case 10: {
					 rule(-115);
					 error(DISCOURAGED_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 21: break;
				 case 13: {
					 rule(-150);
					 difficultChar();
				 }
				 case 22: break;
				 case 16: {
					 rule(-130);
					 surrogatePair();
				 }
				 case 23: break;
				 case 2: {
					 rule(1);
					 error(LOWERCASE_PREFERRED);
				 }
				 case 24: break;
				 case 17: {
					 rule(-40);
					 error(PERCENT);
				 }
				 case 25: break;
				 case 12: {
					 rule(-140);
					 error(LONE_SURROGATE);
					 difficultChar();
				 }
				 case 26: break;
				 case 14: {
					 rule(-80);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 27: break;
				 case 19: {
					 rule(-50);
					 error(PERCENT);
					 error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
				 }
				 case 28: break;
				 case 6: {
					 rule(-90);
					 if (yychar==lastChar) error(DOUBLE_WHITESPACE);
					 else error(WHITESPACE);
				 }
				 case 29: break;
				 case 11: {
					 rule(-120);
					 error(UNWISE_CHARACTER);
				 }
				 case 30: break;
				 case 9: {
					 rule(-113);
					 error(CONTROL_CHARACTER);
				 }
				 case 31: break;
				 case 3: {
					 rule(-10);
				 }
				 case 32: break;
				 case 18: {
					 rule(-30);
					 error(PERCENT_20);
				 }
				 case 33: break;
				 case 5: {
					 rule(-60);
					 error(ILLEGAL_PERCENT_ENCODING);
				 }
				 case 34: break;
				 case 4: {
					 rule(-20);
				 }
				 case 35: break;
				 case 7: {
					 rule(-100);
					 error(CONTROL_CHARACTER);
					 error(NOT_XML_SCHEMA_WHITESPACE);
				 }
				 case 36: break;
				 case 1: {
					 rule(-160);
					 error(ILLEGAL_CHARACTER);
				 }
				 case 37: break;
				 case 8: {
					 rule(-110);
					 error(NON_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 38: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 return YYEOF;
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public Enumeration getEntries() {
	 return entries.keys();
 }",0,0,0,0
"abstract public class BaseXMLWriter implements RDFXMLWriterI {
	 private static final String newline = JenaRuntime.getSystemProperty( ""line.separator"" );
	 static private final String DEFAULT_NS_ENTITY_NAME = ""this"";
	 static private final String DEFAULT_NS_ENTITY_NAME_ALT = ""here"";
	 private String defaultNSEntityName = ""UNSET"" ;
	 public BaseXMLWriter() {
		 setupMaps();
	 }
	private static Logger xlogger = LoggerFactory.getLogger( BaseXMLWriter.class );
	 protected static SimpleLogger logger = new SimpleLogger() {
		 public void warn(String s) {
			 xlogger.warn(s);
		 }
		 public void warn(String s, Exception e) {
			 xlogger.warn(s,e);
		 }
	 }
	;
	 public static SimpleLogger setLogger(SimpleLogger lg) {
		 SimpleLogger old = logger;
		 logger= lg;
		 return old;
	 }
	 abstract protected void unblockAll();
	 abstract protected void blockRule(Resource r);
	 abstract protected void writeBody ( Model mdl, PrintWriter pw, String baseUri, boolean inclXMLBase );
	static private Set<String> badRDF = new HashSet<>();
	private int jenaPrefixCount;
	static String RDFNS = RDF.getURI();
	static private Pattern jenaNamespace;
	static {
		 jenaNamespace =Pattern.compile(""j\\.([1-9][0-9]*|cook\\.up)"");
		badRDF.add(""RDF"");
		badRDF.add(""Description"");
		badRDF.add(""li"");
		badRDF.add(""about"");
		badRDF.add(""aboutEach"");
		badRDF.add(""aboutEachPrefix"");
		badRDF.add(""ID"");
		badRDF.add(""nodeID"");
		badRDF.add(""parseType"");
		badRDF.add(""datatype"");
		badRDF.add(""bagID"");
		badRDF.add(""resource"");
	}
	String xmlBase = null;
	 private IRIx baseURI;
	boolean longId = false;
	 private boolean demandGoodURIs = true;
	int tabSize = 2;
	int width = 60;
	HashMap<AnonId, String> anonMap = new HashMap<>();
	int anonCount = 0;
	static private RDFDefaultErrorHandler defaultErrorHandler =new RDFDefaultErrorHandler();
	RDFErrorHandler errorHandler = defaultErrorHandler;
	Boolean showXmlDeclaration = null;
	 protected Boolean showDoctypeDeclaration = Boolean.FALSE;
	String anonId(Resource r) {
		return longId ? longAnonId( r ) : shortAnonId( r );
	}
	private String shortAnonId(Resource r) {
		String result = anonMap.get(r.getId());
		if (result == null) {
			result = ""A"" + Integer.toString(anonCount++);
			anonMap.put(r.getId(), result);
		}
		return result;
	}
	private String longAnonId(Resource r) {
		String rid = r.getId().toString();
		 return XMLChar.isValidNCName( rid ) ? rid : escapedId( rid );
	}
	 private boolean writingAllModelPrefixNamespaces = true;
	 private Relation<String> nameSpaces = new Relation<>();
	 private Map<String, String> ns;
	 private PrefixMapping modelPrefixMapping;
	private Set<String> namespacesNeeded;
	void addNameSpace(String uri) {
		namespacesNeeded.add(uri);
	}
	 boolean isDefaultNamespace( String uri ) {
		 return """".equals( ns.get( uri ) );
	 }
	 private void addNameSpaces( Model model ) {
		 NsIterator nsIter = model.listNameSpaces();
		 while (nsIter.hasNext()) this.addNameSpace( nsIter.nextNs() );
	 }
	 private void primeNamespace( Model model ) {
		 Map<String, String> m = model.getNsPrefixMap();
		 for ( Entry<String, String> e : m.entrySet() ) {
			 String value = e.getValue();
			 String already = this.getPrefixFor( value );
			 if ( already == null ) {
				 this.setNsPrefix( model.getNsURIPrefix( value ), value );
				 if ( writingAllModelPrefixNamespaces ) {
					 this.addNameSpace( value );
				 }
			 }
		 }
		 if ( usesPrefix(model, """") ) {
			 String entityForEmptyPrefix = DEFAULT_NS_ENTITY_NAME ;
			 if ( usesPrefix(model, entityForEmptyPrefix) ) entityForEmptyPrefix = DEFAULT_NS_ENTITY_NAME_ALT ;
			 int i = 0 ;
			 while ( usesPrefix(model,entityForEmptyPrefix) ) {
				 entityForEmptyPrefix = DEFAULT_NS_ENTITY_NAME_ALT+"".""+i ;
				 i++ ;
			 }
			 defaultNSEntityName = entityForEmptyPrefix ;
		 }
	 }
	 void setupMaps() {
		 nameSpaces.set11(RDF.getURI(), ""rdf"");
		 nameSpaces.set11(RDFS.getURI(), ""rdfs"");
		 nameSpaces.set11(DC.getURI(), ""dc"");
		 nameSpaces.set11(RSS.getURI(), ""rss"");
		 nameSpaces.set11(""http: nameSpaces.set11(VCARD.getURI(), ""vcard"");
	 nameSpaces.set11(""http: }
	void workOutNamespaces() {
		if (ns == null) {
			 ns = new HashMap<>();
			 Set<String> prefixesUsed = new HashSet<>();
			setFromWriterSystemProperties( ns, prefixesUsed );
			 setFromGivenNamespaces( ns, prefixesUsed );
		 }
	}
	 private void setFromWriterSystemProperties( Map<String, String> ns, Set<String> prefixesUsed ) {
		 for ( String uri : namespacesNeeded ) {
			 String val = JenaRuntime.getSystemProperty( RDFWriterI.NSPREFIXPROPBASE + uri );
			 if ( val != null && checkLegalPrefix( val ) && !prefixesUsed.contains( val ) ) {
				 ns.put( uri, val );
				 prefixesUsed.add( val );
			 }
		 }
	 }
	 private void setFromGivenNamespaces( Map<String, String> ns, Set<String> prefixesUsed ) {
		 for ( String uri : namespacesNeeded ) {
			 if ( ns.containsKey( uri ) ) {
				 continue;
			 }
			 String val = null;
			 Set<String> s = nameSpaces.forward( uri );
			 if ( s != null ) {
				 Iterator<String> it2 = s.iterator();
				 if ( it2.hasNext() ) {
					 val = it2.next();
				 }
				 if ( prefixesUsed.contains( val ) ) {
					 val = null;
				 }
			 }
			 if ( val == null ) {
				 do {
					 val = ""j."" + ( jenaPrefixCount++ );
				 }
				 while ( prefixesUsed.contains( val ) );
			 }
			 ns.put( uri, val );
			 prefixesUsed.add( val );
		 }
	}
	final synchronized public void setNsPrefix(String prefix, String ns) {
		 if (checkLegalPrefix(prefix)) {
			 nameSpaces.set11(ns, prefix);
		 }
	 }
	 final public String getPrefixFor( String uri ) {
		 if (""http: if (""http: Set<String> s = nameSpaces.backward( uri );
		 if (s != null && s.size() == 1) return s.iterator().next();
		 return null;
	 }
	String xmlnsDecl() {
		workOutNamespaces();
		StringBuilder result = new StringBuilder();
		Iterator<Entry<String, String>> it = ns.entrySet().iterator();
		while (it.hasNext()) {
			Entry<String, String> ent = it.next();
			String prefix = ent.getValue();
			String uri = ent.getKey();
			 result.append( newline ).append( "" xmlns"" );
			if (prefix.length() > 0) result.append( ':' ).append( prefix );
			result.append( '=' ).append( substitutedAttribute( checkURI( uri ) ) );
		}
		return result.toString();
	}
	static final private int FAST = 1;
	static final private int START = 2;
	static final private int END = 3;
	static final private int ATTR = 4;
	static final private int FASTATTR = 5;
	String rdfEl(String local) {
		return tag(RDFNS, local, FAST, true);
	}
	String startElementTag(String uri, String local) {
		return tag(uri, local, START, false);
	}
	protected String startElementTag(String uriref) {
		return splitTag(uriref, START);
	}
	String attributeTag(String uriref) {
		return splitTag(uriref, ATTR);
	}
	String attributeTag(String uri, String local) {
		return tag(uri, local, ATTR, false);
	}
	String rdfAt(String local) {
		return tag(RDFNS, local, FASTATTR, true);
	}
	String endElementTag(String uri, String local) {
		return tag(uri, local, END, false);
	}
	protected String endElementTag(String uriref) {
		return splitTag(uriref, END);
	}
	String splitTag(String uriref, int type) {
		int split = Util.splitNamespaceXML( uriref );
		if (split == uriref.length()) throw new InvalidPropertyURIException( uriref );
		return tag( uriref.substring( 0, split ), uriref.substring( split ), type, true );
	 }
	String tag( String namespace, String local, int type, boolean localIsQname) {
		String prefix = ns.get( namespace );
		if (type != FAST && type != FASTATTR) {
			if ((!localIsQname) && !XMLChar.isValidNCName(local))return splitTag(namespace + local, type);
			if (namespace.equals(RDFNS)) {
				if (badRDF.contains(local)) {
					logger.warn(""The URI rdf:"" + local + "" cannot be serialized in RDF/XML."" );
					throw new InvalidPropertyURIException( ""rdf:"" + local );
				}
			}
		}
		boolean cookUp = false;
		if (prefix == null) {
			 checkURI( namespace );
			logger.warn(""Internal error: unexpected QName URI: <""+ namespace+ "">. Fixing up with j.cook.up code."",new BrokenException( ""unexpected QName URI "" + namespace ));
			cookUp = true;
		}
		 else if (prefix.length() == 0) {
			if (type == ATTR || type == FASTATTR)cookUp = true;
			elsereturn local;
		}
		if (cookUp) return cookUpAttribution( type, namespace, local );
		return prefix + "":"" + local;
	}
	 private String cookUpAttribution( int type, String namespace, String local ) {
		 String prefix = ""j.cook.up"";
		 switch (type) {
			 case FASTATTR : case ATTR : return ""xmlns:"" + prefix + ""="" + substitutedAttribute( namespace ) + "" "" + prefix + "":"" + local;
			 case START : return prefix + "":"" + local + "" xmlns:"" + prefix+ ""="" + substitutedAttribute( namespace );
			 default: case END : return prefix + "":"" + local;
			 case FAST : throw new BrokenException( ""cookup reached final FAST"" );
		 }
	 }
	 final public void write(Model model, OutputStream out, String base) {
		 write( model, FileUtils.asUTF8(out), base );
	 }
	 synchronized public void write(Model model, Writer out, String base) {
		setupNamespaces( model );
		PrintWriter pw = out instanceof PrintWriter ? (PrintWriter) out : new PrintWriter( out );
		if (!Boolean.FALSE.equals(showXmlDeclaration)) writeXMLDeclaration( out, pw );
		writeXMLBody( model, pw, base );
		pw.flush();
	}
	 private void setupNamespaces( Model model ) {
		 this.namespacesNeeded = new HashSet<>();
		 this.ns = null;
		 this.modelPrefixMapping = model;
		 primeNamespace( model );
		 addNameSpace( RDF.getURI() );
		 addNameSpaces(model);
		 jenaPrefixCount = 0;
	 }
	private void writeXMLBody( Model model, PrintWriter pw, String base ) {
		 if (showDoctypeDeclaration.booleanValue()) generateDoctypeDeclaration( model, pw );
		 if (xmlBase == null) {
			 baseURI = (base == null || base.length() == 0) ? null : IRIx.create(base);
			 writeBody(model, pw, base, false);
		 }
		 else {
			 baseURI = xmlBase.length() == 0 ? null : IRIx.create(xmlBase);
			 writeBody(model, pw, xmlBase, true);
		 }
	}
	protected static final Pattern predefinedEntityNames = Pattern.compile( ""amp|lt|gt|apos|quot"" );
	 public boolean isPredefinedEntityName( String name ) {
		 return predefinedEntityNames.matcher( name ).matches();
	 }
	 private String attributeQuoteChar =""\"""";
	 protected String attributeQuoted( String s ) {
		 return attributeQuoteChar + s + attributeQuoteChar;
	 }
	 protected String substitutedAttribute( String s ) {
		 String substituted = Util.substituteStandardEntities( s );
		 if (!showDoctypeDeclaration.booleanValue()) return attributeQuoted( substituted );
		 else {
			 int split = Util.splitNamespaceXML( substituted );
			 String namespace = substituted.substring( 0, split );
			 String prefix = modelPrefixMapping.getNsURIPrefix( namespace );
			 return prefix == null || isPredefinedEntityName( prefix ) ? attributeQuoted( substituted ) : attributeQuoted( ""&"" + strForPrefix(prefix) + "";
			"" + substituted.substring( split ) ) ;
		 }
	 }
	 private void generateDoctypeDeclaration( Model model, PrintWriter pw ) {
		 String rdfns = RDF.getURI();
		String rdfRDF = model.qnameFor( rdfns + ""RDF"" );
		 if ( rdfRDF == null ) {
			 model.setNsPrefix(""rdf"",rdfns);
			 rdfRDF = ""rdf:RDF"";
		 }
		 Map<String, String> prefixes = model.getNsPrefixMap();
		 pw.print( ""<!DOCTYPE "" + rdfRDF +"" ["" );
		 for ( String prefix : prefixes.keySet() ) {
			 if ( isPredefinedEntityName( prefix ) ) {
				 continue;
			 }
			 pw.print( newline + "" <!ENTITY "" + strForPrefix( prefix ) + "" '"" + Util.substituteEntitiesInEntityValue( prefixes.get( prefix ) ) + ""'>"" );
		 }
		 pw.print( ""]>"" + newline );
	 }
	private String strForPrefix(String prefix) {
		 if ( prefix.length() == 0 ) return defaultNSEntityName ;
		 return prefix ;
	 }
	private static boolean usesPrefix(Model model, String prefix){
		 return model.getNsPrefixURI(prefix) != null ;
	 }
	 private void writeXMLDeclaration(Writer out, PrintWriter pw) {
		String decl = null;
		if (out instanceof OutputStreamWriter) {
			String javaEnc = ((OutputStreamWriter) out).getEncoding();
			if (!(javaEnc.equals(""UTF8"") || javaEnc.equals(""UTF-16""))) {
				 CharEncoding encodingInfo = CharEncoding.create(javaEnc);
				String ianaEnc = encodingInfo.name();
				decl = ""<?xml version=""+attributeQuoted(""1.0"")+"" encoding="" + attributeQuoted(ianaEnc) + ""?>"";
				if (!encodingInfo.isIANA()) logger.warn(encodingInfo.warningMessage()+""\n""+ "" It is better to use a FileOutputStream, in place of a FileWriter."");
			}
		}
		if (decl == null && showXmlDeclaration != null)decl = ""<?xml version=""+attributeQuoted(""1.0"")+""?>"";
		if (decl != null) {
			pw.println(decl);
		}
	}
	 synchronized public RDFErrorHandler setErrorHandler(RDFErrorHandler errHandler) {
		RDFErrorHandler rslt = errorHandler;
		if (rslt == defaultErrorHandler) rslt = null;
		errorHandler = errHandler == null ? defaultErrorHandler : errHandler;
		return rslt;
	}
	static private final char ESCAPE = 'X';
	static private String escapedId(String id) {
		StringBuffer result = new StringBuffer();
		for (int i = 0;
		 i < id.length();
		 i++) {
			char ch = id.charAt(i);
			if (ch != ESCAPE&& (i == 0 ? XMLChar.isNCNameStart(ch) : XMLChar.isNCName(ch))) {
				result.append( ch );
			}
			 else {
				escape( result, ch );
			}
		}
		return result.toString();
	}
	 static final char [] hexchar = ""0123456789abcdef"".toCharArray();
	static private void escape( StringBuffer sb, char ch) {
		sb.append( ESCAPE );
		int charcode = ch;
		do {
			sb.append( hexchar[charcode & 15] );
			charcode = charcode >> 4;
		}
		 while (charcode != 0);
		sb.append( ESCAPE );
	}
	 final synchronized public Object setProperty( String propName, Object propValue ) {
		if (propName.equalsIgnoreCase(""showXmlDeclaration"")) {
			return setShowXmlDeclaration(propValue);
		 }
		 else if (propName.equalsIgnoreCase( ""showDoctypeDeclaration"" )) {
			 return setShowDoctypeDeclaration( propValue );
		 }
		 else if (propName.equalsIgnoreCase( ""minimalPrefixes"" )) {
			 try {
				 return Boolean.valueOf( !writingAllModelPrefixNamespaces );
			 }
			 finally {
				 writingAllModelPrefixNamespaces = !getBoolean( propValue );
			 }
		}
		 else if (propName.equalsIgnoreCase(""xmlbase"")) {
			String result = xmlBase;
			xmlBase = (String) propValue;
			return result;
		}
		 else if (propName.equalsIgnoreCase(""tab"")) {
			return setTab( propValue );
		}
		 else if (propName.equalsIgnoreCase(""width"")) {
			return setWidth(propValue);
		}
		 else if (propName.equalsIgnoreCase(""longid"")) {
			Boolean result = Boolean.valueOf(longId);
			longId = getBoolean(propValue);
			return result;
		}
		 else if (propName.equalsIgnoreCase(""attributeQuoteChar"")) {
			return setAttributeQuoteChar(propValue);
		}
		 else if (propName.equalsIgnoreCase( ""allowBadURIs"" )) {
			Boolean result = Boolean.valueOf( !demandGoodURIs );
			 demandGoodURIs = !getBoolean(propValue);
			return result;
		}
		 else if (propName.equalsIgnoreCase(""prettyTypes"")) {
			return setTypes((Resource[]) propValue);
		}
		 else if (propName.equalsIgnoreCase(""relativeURIs"")) {
			int old = relativeFlags;
			relativeFlags = str2flags((String) propValue);
			return flags2str(old);
		}
		 else if (propName.equalsIgnoreCase(""blockRules"")) {
			return setBlockRules(propValue);
		}
		 else {
			logger.warn(""Unsupported property: "" + propName);
			return null;
		}
	}
	private String setAttributeQuoteChar(Object propValue) {
		String oldValue = attributeQuoteChar;
		if ( ""\"""".equals(propValue) || ""'"".equals(propValue) ) attributeQuoteChar = (String)propValue;
		else logger.warn(""attributeQutpeChar must be either \""\\\""\"" or \', not \""""+propValue+""\"""" );
		return oldValue;
	}
	private Integer setWidth(Object propValue) {
		Integer oldValue = Integer.valueOf(width);
		if (propValue instanceof Integer) {
			width = ((Integer) propValue).intValue();
		}
		 else {
			try {
				width = Integer.parseInt((String) propValue);
			}
			 catch (Exception e) {
				logger.warn(""Bad value for width: '"" + propValue + ""' ["" + e.getMessage() + ""]"" );
			}
		}
		return oldValue;
	}
	private Integer setTab(Object propValue) {
		Integer result = Integer.valueOf(tabSize);
		if (propValue instanceof Integer) {
			tabSize = ((Integer) propValue).intValue();
		}
		 else {
			try {
				tabSize = Integer.parseInt((String) propValue);
			}
			 catch (Exception e) {
				logger.warn(""Bad value for tab: '"" + propValue + ""' ["" + e.getMessage() + ""]"" );
			}
		}
		return result;
	}
	 private String setShowDoctypeDeclaration( Object propValue ) {
		 String oldValue = showDoctypeDeclaration.toString();
		 showDoctypeDeclaration = getBooleanValue( propValue, Boolean.FALSE );
		 return oldValue;
	 }
	 private String setShowXmlDeclaration( Object propValue ) {
		 String oldValue = showXmlDeclaration == null ? null : showXmlDeclaration.toString();
		 showXmlDeclaration = getBooleanValue( propValue, null );
		 return oldValue;
	 }
	 static private boolean getBoolean( Object o ) {
		 return getBooleanValue( o, Boolean.FALSE ).booleanValue();
	 }
	 private static Boolean getBooleanValue( Object propValue, Boolean theDefault ) {
		 if (propValue == null) return theDefault;
		 else if (propValue instanceof Boolean) return (Boolean) propValue;
		 else if (propValue instanceof String) return stringToBoolean( (String) propValue, theDefault );
		 else throw new JenaException( ""cannot treat as boolean: "" + propValue );
	 }
	private static Boolean stringToBoolean( String b, Boolean theDefault ) {
		 if (b.equals( ""default"" )) return theDefault;
		 if (b.equalsIgnoreCase( ""true"" )) return Boolean.TRUE;
		 if (b.equalsIgnoreCase( ""false"" )) return Boolean.FALSE;
		 throw new BadBooleanException( b );
	 }
	Resource[] setTypes( Resource x[] ) {
		logger.warn( ""prettyTypes is not a property on the Basic RDF/XML writer."" );
		return null;
	}
	private Resource blockedRules[] = new Resource[]{
	RDFSyntax.propertyAttr}
	;
	Resource[] setBlockRules(Object o) {
		Resource rslt[] = blockedRules;
		unblockAll();
		if (o instanceof Resource[]) {
			blockedRules = (Resource[]) o;
		}
		 else {
			StringTokenizer tkn = new StringTokenizer((String) o, "", "");
			Vector<Resource> v = new Vector<>();
			while (tkn.hasMoreElements()) {
				String frag = tkn.nextToken();
				v.add(new ResourceImpl(RDFSyntax.getURI() + frag));
			}
			blockedRules = new Resource[v.size()];
			v.copyInto(blockedRules);
		}
		 for ( Resource blockedRule : blockedRules ) {
			 blockRule( blockedRule );
		 }
		return rslt;
	}
	private class IRIRelativize {
		 static final public int SAMEDOCUMENT = 1;
		 static final public int NETWORK = 2;
		 static final public int ABSOLUTE = 4;
		 static final public int CHILD = 8;
		 static final public int PARENT = 16;
		 static final public int GRANDPARENT = 32;
	}
	private int dftRelativeFlags = IRIRelativize.SAMEDOCUMENT | IRIRelativize.ABSOLUTE | IRIRelativize.CHILD | IRIRelativize.PARENT;
	private int relativeFlags = dftRelativeFlags;
	 protected String relativize( String uri ) {
		 return relativeFlags != 0 && baseURI != null ? relativize( baseURI, uri ) : checkURI( uri );
	 }
	 private String relativize( IRIx base, String uri ) {
		 if ( relativeFlags == 0 ) return uri;
		 if ( base instanceof IRIxJena ) {
			 org.apache.jena.iri.IRI baseImpl = ((IRIxJena)base).getImpl();
			 return baseImpl.relativize(uri, relativeFlags).toString();
		 }
		 try {
			 if ( relativeFlags != dftRelativeFlags ) {
				 org.apache.jena.iri.IRI baseImpl = org.apache.jena.iri.IRIFactory.iriImplementation().create(base.str());
				 return baseImpl.relativize(uri, relativeFlags).toString();
			 }
			 IRIx x = base.relativize( IRIx.create(uri) );
			 return x != null ? x.str() : uri ;
		 }
		 catch (IRIException ex) {
			 return uri;
		 }
	 }
	 private String checkURI( String uri ) {
		 if (demandGoodURIs) IRIs.checkEx(uri);
		 return uri;
	 }
	 private boolean checkLegalPrefix( String prefix ) {
		 if (prefix.equals("""")) return true;
		 if (prefix.toLowerCase().startsWith( ""xml"" )) logger.warn( ""Namespace prefix '"" + prefix + ""' is reserved by XML."" );
		 else if (!XMLChar.isValidNCName(prefix)) logger.warn( ""'"" + prefix + ""' is not a legal namespace prefix."" );
		 else if (jenaNamespace.matcher(prefix).matches()) logger.warn( ""Namespace prefix '"" + prefix + ""' is reserved by Jena."" );
		 else return true;
		 return false;
	 }
	 static private String flags2str(int f) {
		StringBuffer oldValue = new StringBuffer(64);
		if ( (f&IRIRelativize.SAMEDOCUMENT)!=0 ) oldValue.append( ""same-document, "" );
		if ( (f&IRIRelativize.NETWORK)!=0 ) oldValue.append( ""network, "");
		if ( (f&IRIRelativize.ABSOLUTE)!=0 ) oldValue.append(""absolute, "");
		if ( (f&IRIRelativize.CHILD)!=0 ) oldValue.append(""relative, "");
		if ((f&IRIRelativize.PARENT)!=0) oldValue.append(""parent, "");
		if ((f&IRIRelativize.GRANDPARENT)!=0) oldValue.append(""grandparent, "");
		if (oldValue.length() > 0) oldValue.setLength(oldValue.length()-2);
		 return oldValue.toString();
	}
	public static int str2flags(String pv){
		StringTokenizer tkn = new StringTokenizer(pv,"", "");
		int rslt = 0;
		while ( tkn.hasMoreElements() ) {
			 String flag = tkn.nextToken();
			 if ( flag.equals(""same-document"") ) rslt |= IRIRelativize.SAMEDOCUMENT;
			 else if ( flag.equals(""network"") ) rslt |= IRIRelativize.NETWORK;
			 else if ( flag.equals(""absolute"") ) rslt |= IRIRelativize.ABSOLUTE;
			 else if ( flag.equals(""relative"") ) rslt |= IRIRelativize.CHILD;
			 else if ( flag.equals(""parent"") ) rslt |= IRIRelativize.PARENT;
			 else if ( flag.equals(""grandparent"") ) rslt |= IRIRelativize.GRANDPARENT;
			 else logger.warn( ""Incorrect property value for relativeURIs: "" + flag );
		}
		return rslt;
	}
}",1,0,0,0
"protected String getInputNamePrefix(){
	return """";
}",0,0,0,0
"public class TestResource extends OntTestBase{
	 static public TestSuite suite() {
		 return new TestResource( ""TestResource"" );
	 }
	 public TestResource( String name ) {
		 super( name );
	 }
	 public OntTestCase[] getTests() {
		 return new OntTestCase[] {
			 new OntTestCase( ""OntResource.sameAs"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 OntResource b = m.getResource( NS + ""b"" ).as( OntResource.class );
					 OntResource c = m.getResource( NS + ""c"" ).as( OntResource.class );
					 a.addSameAs( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.SAME_AS() ) );
					 assertEquals( ""a should be sameAs b"", b, a.getSameAs() );
					 a.addSameAs( c );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.SAME_AS() ) );
					 iteratorTest( a.listSameAs(), new Object[] {
					b, c}
					 );
					 assertTrue( ""a should be the same as b"", a.isSameAs( b ) );
					 assertTrue( ""a should be the same as c"", a.isSameAs( c ) );
					 a.setSameAs( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.SAME_AS() ) );
					 assertEquals( ""a should be sameAs b"", b, a.getSameAs() );
					 a.removeSameAs( c );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.SAME_AS() ) );
					 a.removeSameAs( b );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.SAME_AS() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.differentFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 OntResource b = m.getResource( NS + ""b"" ).as( OntResource.class );
					 OntResource c = m.getResource( NS + ""c"" ).as( OntResource.class );
					 a.addDifferentFrom( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.DIFFERENT_FROM() ) );
					 assertEquals( ""a should be differentFrom b"", b, a.getDifferentFrom() );
					 a.addDifferentFrom( c );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.DIFFERENT_FROM() ) );
					 iteratorTest( a.listDifferentFrom(), new Object[] {
					b, c}
					 );
					 assertTrue( ""a should be diff from b"", a.isDifferentFrom( b ) );
					 assertTrue( ""a should be diff from c"", a.isDifferentFrom( c ) );
					 a.setDifferentFrom( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.DIFFERENT_FROM() ) );
					 assertEquals( ""a should be differentFrom b"", b, a.getDifferentFrom() );
					 a.removeDifferentFrom( c );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.DIFFERENT_FROM() ) );
					 a.removeDifferentFrom( b );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.DIFFERENT_FROM() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.seeAlso"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 OntResource b = m.getResource( NS + ""b"" ).as( OntResource.class );
					 OntResource c = m.getResource( NS + ""c"" ).as( OntResource.class );
					 a.addSeeAlso( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.SEE_ALSO() ) );
					 assertEquals( ""a should be seeAlso b"", b, a.getSeeAlso() );
					 a.addSeeAlso( c );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.SEE_ALSO() ) );
					 iteratorTest( a.listSeeAlso(), new Object[] {
					b, c}
					 );
					 assertTrue( ""a should have seeAlso b"", a.hasSeeAlso( b ) );
					 assertTrue( ""a should have seeAlso c"", a.hasSeeAlso( c ) );
					 a.setSeeAlso( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.SEE_ALSO() ) );
					 assertEquals( ""a should be seeAlso b"", b, a.getSeeAlso() );
					 a.removeSeeAlso( c );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.SEE_ALSO() ) );
					 a.removeSeeAlso( b );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.SEE_ALSO() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.isDefinedBy"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 OntResource b = m.getResource( NS + ""b"" ).as( OntResource.class );
					 OntResource c = m.getResource( NS + ""c"" ).as( OntResource.class );
					 a.addIsDefinedBy( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.IS_DEFINED_BY() ) );
					 assertEquals( ""a should be isDefinedBy b"", b, a.getIsDefinedBy() );
					 a.addIsDefinedBy( c );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.IS_DEFINED_BY() ) );
					 iteratorTest( a.listIsDefinedBy(), new Object[] {
					b, c}
					 );
					 assertTrue( ""a should be defined by b"", a.isDefinedBy( b ) );
					 assertTrue( ""a should be defined by c"", a.isDefinedBy( c ) );
					 a.setIsDefinedBy( b );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.IS_DEFINED_BY() ) );
					 assertEquals( ""a should be isDefinedBy b"", b, a.getIsDefinedBy() );
					 a.removeDefinedBy( c );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.IS_DEFINED_BY() ) );
					 a.removeDefinedBy( b );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.IS_DEFINED_BY() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.versionInfo"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 a.addVersionInfo( ""some info"" );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.VERSION_INFO() ) );
					 assertEquals( ""a has wrong version info"", ""some info"", a.getVersionInfo() );
					 a.addVersionInfo( ""more info"" );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.VERSION_INFO() ) );
					 iteratorTest( a.listVersionInfo(), new Object[] {
					""some info"", ""more info""}
					 );
					 assertTrue( ""a should have some info"", a.hasVersionInfo( ""some info"" ) );
					 assertTrue( ""a should have more info"", a.hasVersionInfo( ""more info"" ) );
					 a.setVersionInfo( ""new info"" );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.VERSION_INFO() ) );
					 assertEquals( ""a has wrong version info"", ""new info"", a.getVersionInfo() );
					 a.removeVersionInfo( ""old info"" );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.VERSION_INFO() ) );
					 a.removeVersionInfo( ""new info"" );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.VERSION_INFO() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.label.nolang"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 a.addLabel( ""some info"", null );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.LABEL() ) );
					 assertEquals( ""a has wrong label"", ""some info"", a.getLabel( null ) );
					 a.addLabel( ""more info"", null );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.LABEL() ) );
					 iteratorTest( a.listLabels( null ), new Object[] {
					m.createLiteral( ""some info"" ), m.createLiteral( ""more info"" )}
					 );
					 assertTrue( ""a should have label some info"", a.hasLabel( ""some info"", null ) );
					 assertTrue( ""a should have label more info"", a.hasLabel( ""more info"", null ) );
					 a.setLabel( ""new info"", null );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.LABEL() ) );
					 assertEquals( ""a has wrong label"", ""new info"", a.getLabel( null ) );
					 a.removeLabel( ""foo"", null );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.LABEL() ) );
					 a.removeLabel( ""new info"", null );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.LABEL() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.label.lang"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 a.addLabel( ""good"", ""EN"" );
					 assertEquals( ""wrong label"", ""good"", a.getLabel( null ) );
					 a.addLabel( ""bon"", ""FR"" );
					 assertEquals( ""wrong label"", ""good"", a.getLabel( ""EN"" ) );
					 assertEquals( ""wrong label"", null, a.getLabel( ""EN-GB"" ) );
					 assertEquals( ""wrong label"", ""bon"", a.getLabel( ""FR"" ) );
					 assertTrue( ""a should have label good"", a.hasLabel( ""good"", ""EN"" ) );
					 assertTrue( ""a should have label bon"", a.hasLabel( ""bon"", ""FR"" ) );
					 assertTrue( ""a should note have label good (DE)"", !a.hasLabel( ""good"", ""DE"" ) );
					 a.addLabel( ""spiffing"", ""EN-GB"" );
					 a.addLabel( ""duude"", ""EN-US"" );
					 assertEquals( ""wrong label"", ""spiffing"", a.getLabel( ""EN-GB"" ) );
					 assertEquals( ""wrong label"", ""duude"", a.getLabel( ""EN-US"" ) );
					 assertEquals( ""wrong label"", null, a.getLabel( ""DE"" ) );
					 a.addLabel( ""abcdef"", ""AB-CD"" );
					 assertEquals( ""wrong label"", ""abcdef"", a.getLabel( ""AB"" ) );
					 assertEquals( ""wrong label"", null, a.getLabel( ""AB-XY"" ) );
					 a.removeLabel( ""abcde"", ""AB-CD"" );
					 assertEquals( ""Cardinality should be 5"", 5, a.getCardinality( a.getProfile().LABEL() ) );
					 a.removeLabel( ""abcdef"", ""AB-CD"" );
					 assertEquals( ""Cardinality should be 4"", 4, a.getCardinality( a.getProfile().LABEL() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.comment.nolang"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 a.addComment( ""some info"", null );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.COMMENT() ) );
					 assertEquals( ""a has wrong comment"", ""some info"", a.getComment( null ) );
					 a.addComment( ""more info"", null );
					 assertEquals( ""Cardinality should be 2"", 2, a.getCardinality( prof.COMMENT() ) );
					 iteratorTest( a.listComments( null ), new Object[] {
					m.createLiteral( ""some info"" ), m.createLiteral( ""more info"" )}
					 );
					 assertTrue( ""a should have comment some info"", a.hasComment( ""some info"", null ) );
					 assertTrue( ""a should have comment more info"", a.hasComment( ""more info"", null ) );
					 a.setComment( ""new info"", null );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.COMMENT() ) );
					 assertEquals( ""a has wrong comment"", ""new info"", a.getComment( null ) );
					 a.removeComment( ""foo"", null );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( prof.COMMENT() ) );
					 a.removeComment( ""new info"", null );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( prof.COMMENT() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.comment.lang"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 a.addComment( ""good"", ""EN"" );
					 assertEquals( ""wrong comment"", ""good"", a.getComment( null ) );
					 a.addComment( ""bon"", ""FR"" );
					 assertEquals( ""wrong comment"", ""good"", a.getComment( ""EN"" ) );
					 assertEquals( ""wrong comment"", null, a.getComment( ""EN-GB"" ) );
					 assertEquals( ""wrong comment"", ""bon"", a.getComment( ""FR"" ) );
					 assertTrue( ""a should have label good"", a.hasComment( ""good"", ""EN"" ) );
					 assertTrue( ""a should have label bon"", a.hasComment( ""bon"", ""FR"" ) );
					 assertTrue( ""a should note have label good (DE)"", !a.hasComment( ""good"", ""DE"" ) );
					 a.addComment( ""spiffing"", ""EN-GB"" );
					 a.addComment( ""duude"", ""EN-US"" );
					 assertEquals( ""wrong comment"", ""spiffing"", a.getComment( ""EN-GB"" ) );
					 assertEquals( ""wrong comment"", ""duude"", a.getComment( ""EN-US"" ) );
					 assertEquals( ""wrong comment"", null, a.getComment( ""DE"" ) );
					 a.addComment( ""abcdef"", ""AB-CD"" );
					 assertEquals( ""wrong comment"", ""abcdef"", a.getComment( ""AB"" ) );
					 assertEquals( ""wrong comment"", null, a.getComment( ""AB-XY"" ) );
					 a.removeComment( ""abcde"", ""AB-CD"" );
					 assertEquals( ""Cardinality should be 5"", 5, a.getCardinality( a.getProfile().COMMENT() ) );
					 a.removeComment( ""abcdef"", ""AB-CD"" );
					 assertEquals( ""Cardinality should be 4"", 4, a.getCardinality( a.getProfile().COMMENT() ) );
				 }
			 }
			, new OntTestCase( ""OntResource.type (no inference)"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 A.addSubClass( B );
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 assertEquals( ""Cardinality of rdf:type is wrong"", 0, a.getCardinality( RDF.type ) );
					 a.addRDFType( B );
					 assertEquals( ""rdf:type of a is wrong"", B, a.getRDFType() );
					 assertEquals( ""rdf:type of a is wrong"", B, a.getRDFType( false ) );
					 iteratorTest( a.listRDFTypes( false ), new Object[] {
					B}
					 );
					 iteratorTest( a.listRDFTypes( true ), new Object[] {
					B}
					 );
					 a.addRDFType( A );
					 iteratorTest( a.listRDFTypes( false ), new Object[] {
					A,B}
					 );
					 iteratorTest( a.listRDFTypes( true ), new Object[] {
					B}
					 );
					 assertTrue( ""a should not be of class A direct"", !a.hasRDFType( A, true ));
					 assertTrue( ""a should not be of class B direct"", a.hasRDFType( B, true ));
					 OntClass C = m.createClass( NS + ""C"" );
					 a.setRDFType( C );
					 assertTrue( ""a should be of class C"", a.hasRDFType( C, false ));
					 assertTrue( ""a should not be of class A"", !a.hasRDFType( A, false ));
					 assertTrue( ""a should not be of class B"", !a.hasRDFType( B, false ));
					 a.removeRDFType( B );
					 assertEquals( ""Cardinality should be 1"", 1, a.getCardinality( RDF.type ) );
					 a.removeRDFType( C );
					 assertEquals( ""Cardinality should be 0"", 0, a.getCardinality( RDF.type ) );
				 }
			 }
			, new OntTestCase( ""OntResource.remove"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 OntClass D = m.createClass( NS + ""D"" );
					 OntClass E = m.createClass( NS + ""E"" );
					 A.addSubClass( B );
					 A.addSubClass( C );
					 C.addSubClass( D );
					 C.addSubClass( E );
					 assertTrue( ""super-class of E"", E.hasSuperClass( C, false ) );
					 iteratorTest( A.listSubClasses(), new Object[] {
					B,C}
					 );
					 C.remove();
					 assertTrue( ""super-class of D"", !D.hasSuperClass( C, false ) );
					 assertTrue( ""super-class of E"", !E.hasSuperClass( C, false ) );
					 iteratorTest( A.listSubClasses(), new Object[] {
					B}
					 );
				 }
			 }
			, new OntTestCase( ""OntResource.asClass"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().CLASS() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertTrue( ""should be class"", or.isClass() );
					 assertFalse( ""should not be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertTrue( ""should not be individual"", owlFull() || !or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asClass();
					 assertTrue( ""Should be OntClass"", n instanceof OntClass );
				 }
			 }
			, new OntTestCase( ""OntResource.asAnnotationProperty"", true, true, false) {
				 public void ontTest( OntModel m ) {
					 if (m.getProfile().ANNOTATION_PROPERTY() == null) {
						 throw new ProfileException(null,null);
					 }
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().ANNOTATION_PROPERTY() );
					 OntResource or = r.as( OntResource.class );
					 assertTrue( ""should be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertTrue( ""should be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asAnnotationProperty();
					 assertTrue( ""Should be AnnotationProperty"", n instanceof AnnotationProperty);
				 }
			 }
			, new OntTestCase( ""OntResource.asObjectProperty"", true, true, false) {
				 public void ontTest( OntModel m ) {
					 if (m.getProfile().OBJECT_PROPERTY() == null) {
						 throw new ProfileException(null,null);
					 }
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().OBJECT_PROPERTY() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertTrue( ""should be property"", or.isProperty() );
					 assertTrue( ""should be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asObjectProperty();
					 assertTrue( ""Should be ObjectProperty"", n instanceof ObjectProperty);
				 }
			 }
			, new OntTestCase( ""OntResource.asDatatypeProperty"", true, true, false) {
				 public void ontTest( OntModel m ) {
					 if (m.getProfile().DATATYPE_PROPERTY() == null) {
						 throw new ProfileException(null,null);
					 }
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().DATATYPE_PROPERTY() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertTrue( ""should be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertTrue( ""should be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asDatatypeProperty();
					 assertTrue( ""Should be DatatypeProperty"", n instanceof DatatypeProperty);
				 }
			 }
			, new OntTestCase( ""OntResource.asAllDifferent"", true, true, false) {
				 public void ontTest( OntModel m ) {
					 if (m.getProfile().ALL_DIFFERENT() == null) {
						 throw new ProfileException(null,null);
					 }
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().ALL_DIFFERENT() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertTrue( ""should be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertFalse( ""should not be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asAllDifferent();
					 assertTrue( ""Should be AnnotationProperty"", n instanceof AllDifferent);
				 }
			 }
			, new OntTestCase( ""OntResource.asProperty"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().PROPERTY() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertTrue( ""should be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asProperty();
					 assertTrue( ""Should be OntProperty"", n instanceof OntProperty);
				 }
			 }
			, new OntTestCase( ""OntResource.asIndividual"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Resource r = m.createResource();
					 Resource s = m.createResource();
					 s.addProperty( RDF.type, m.getProfile().CLASS() );
					 r.addProperty( RDF.type, s );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertFalse( ""should not be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertTrue( ""should be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asIndividual();
					 assertTrue( ""Should be individual"", n instanceof Individual);
				 }
			 }
			, new OntTestCase( ""OntResource.asDataRange"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 if (m.getProfile().DATARANGE() == null) {
						 throw new ProfileException(null,null);
					 }
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().DATARANGE() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertFalse( ""should not be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertTrue( ""should be data range"", or.isDataRange() );
					 assertFalse( ""should not be ontology"", or.isOntology() );
					 RDFNode n = or.asDataRange();
					 assertTrue( ""Should be DataRange"", n instanceof DataRange );
				 }
			 }
			, new OntTestCase( ""OntResource.asOntology"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 if (m.getProfile().ONTOLOGY() == null) {
						 throw new ProfileException(null,null);
					 }
					 Resource r = m.createResource();
					 r.addProperty( RDF.type, m.getProfile().ONTOLOGY() );
					 OntResource or = r.as( OntResource.class );
					 assertFalse( ""should not be annotation prop"", or.isAnnotationProperty() );
					 assertFalse( ""should not be all different"", or.isAllDifferent() );
					 assertFalse( ""should not be class"", or.isClass() );
					 assertFalse( ""should not be property"", or.isProperty() );
					 assertFalse( ""should not be object property"", or.isObjectProperty() );
					 assertFalse( ""should not be datatype property"", or.isDatatypeProperty() );
					 assertFalse( ""should not be individual"", or.isIndividual() );
					 assertFalse( ""should not be data range"", or.isDataRange() );
					 assertTrue( ""should be ontology"", or.isOntology() );
					 RDFNode n = or.asOntology();
					 assertTrue( ""Should be Ontology"", n instanceof Ontology);
				 }
			 }
			, new OntTestCase( ""OntResource.isLanguageTerm"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource or = m.getProfile().CLASS().inModel(m).as( OntResource.class );
					 assertTrue( ""should be a lang term"", or.isOntLanguageTerm() );
					 or = m.createOntResource( ""http: assertFalse( ""should not be a lang term"", or.isOntLanguageTerm() );
				 }
			 }
			, new OntTestCase( ""OntResource.getOntModel"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource or = m.createOntResource( ""http: OntModel m0 = or.getOntModel();
					 assertEquals( m, m0 );
				 }
			 }
			, new OntTestCase( ""OntResource.getPropertyValue - object prop"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource a = m.createOntResource( ""http: Resource b = m.createResource( ""http: OntProperty p = m.createOntProperty( ""http: m.add( a, p, b );
					 Object bb = a.getPropertyValue( p );
					 assertEquals( b, bb );
					 assertTrue( ""Return value should be an OntResource"", bb instanceof OntResource );
				 }
			 }
			, new OntTestCase( ""OntResource.getPropertyValue - missing prop"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource a = m.createOntResource( ""http: Resource b = m.createResource( ""http: OntProperty p = m.createOntProperty( ""http: OntProperty q = m.createOntProperty( ""http: m.add( a, p, b );
					 Object bb = a.getPropertyValue( q );
					 assertNull( bb );
				 }
			 }
			, new OntTestCase( ""OntResource.listPropertyValues - object prop"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntResource a = m.createOntResource( ""http: Resource b = m.createResource( ""http: OntProperty p = m.createOntProperty( ""http: Literal l = m.createTypedLiteral( false );
					 m.add( a, p, b );
					 m.add( a, p, l );
					 NodeIterator ni = a.listPropertyValues( p );
					 while (ni.hasNext()) {
						 RDFNode n = ni.nextNode();
						 if (n.isResource()) {
							 assertEquals( b, n );
							 assertTrue( ""Return value should be an OntResource"", n instanceof OntResource );
						 }
					 }
				 }
			 }
		, }
		;
	 }
}",1,0,0,0
"public void endElement( StylesheetHandler handler, String uri, String localName, String rawName) throws org.xml.sax.SAXException;",0,0,0,1
"private static class TerminalRuleCallFactory {
	public static IGrammarAwareElementType createTerminalRuleCallElementType() {
		return new IGrammarAwareElementType(""TerminalRuleCall_ELEMENT_TYPE"", XtextLanguage.INSTANCE, GRAMMAR_ACCESS.getTerminalRuleCallRule());
	}
	public static IGrammarAwareElementType createTerminalRuleCall_RuleAssignmentElementType() {
		return new IGrammarAwareElementType(""TerminalRuleCall_RuleAssignment_ELEMENT_TYPE"", XtextLanguage.INSTANCE, GRAMMAR_ACCESS.getTerminalRuleCallAccess().getRuleAssignment());
	}
	public static IGrammarAwareElementType createTerminalRuleCall_RuleAbstractRuleCrossReference_0ElementType() {
		return new IGrammarAwareElementType(""TerminalRuleCall_RuleAbstractRuleCrossReference_0_ELEMENT_TYPE"", XtextLanguage.INSTANCE, GRAMMAR_ACCESS.getTerminalRuleCallAccess().getRuleAbstractRuleCrossReference_0());
	}
	public static IGrammarAwareElementType createTerminalRuleCall_RuleAbstractRuleRuleIDParserRuleCall_0_1ElementType() {
		return new IGrammarAwareElementType(""TerminalRuleCall_RuleAbstractRuleRuleIDParserRuleCall_0_1_ELEMENT_TYPE"", XtextLanguage.INSTANCE, GRAMMAR_ACCESS.getTerminalRuleCallAccess().getRuleAbstractRuleRuleIDParserRuleCall_0_1());
	}
}",0,0,0,0
"public final class SparqlFieldQueryFactory implements FieldQueryFactory {
	 private static SparqlFieldQueryFactory instance;
	 public static SparqlFieldQueryFactory getInstance() {
		 if (instance == null) {
			 instance = new SparqlFieldQueryFactory();
		 }
		 return instance;
	 }
	 private SparqlFieldQueryFactory() {
		 super();
	 }
	 public SparqlFieldQuery createFieldQuery() {
		 return new SparqlFieldQuery();
	 }
	 public static SparqlFieldQuery getSparqlFieldQuery(FieldQuery parsedQuery) {
		 Logger logger = LoggerFactory.getLogger(SparqlFieldQueryFactory.class);
		 if (parsedQuery == null) {
			 logger.trace(""Parsed query is null."");
			 return null;
		 }
		 else if (parsedQuery instanceof SparqlFieldQuery) {
			 logger.trace(""Parsed query is a [SparqlFieldQuery]."");
			 return (SparqlFieldQuery) parsedQuery;
		 }
		 else {
			 logger.trace(""Parsed query is a [{
			}
			]."", parsedQuery.getClass().toString());
			 return parsedQuery.copyTo(new SparqlFieldQuery());
		 }
	 }
}",0,0,0,0
"public Boolean hasProperty(String name) {
	 return properties.containsKey(name);
 }",0,0,0,0
"public class StreamsDatum implements Serializable {
	 public StreamsDatum(Object document) {
		 this(document, null, null, null, new HashMap<>());
	 }
	 public StreamsDatum(Object document, String id) {
		 this(document, id, null, null, new HashMap<>());
	 }
	 public StreamsDatum(Object document, BigInteger sequenceid) {
		 this(document, null, null, sequenceid);
	 }
	 public StreamsDatum(Object document, DateTime timestamp) {
		 this(document, null, timestamp, null);
	 }
	 public StreamsDatum(Object document, DateTime timestamp, BigInteger sequenceid) {
		 this(document, null, timestamp, sequenceid);
	 }
	 public StreamsDatum(Object document, DateTime timestamp, Map<String, Object> metadata) {
		 this(document, null, timestamp, null, metadata);
	 }
	 public StreamsDatum(Object document, String id, DateTime timestamp) {
		 this(document, id, timestamp, null, new HashMap<>());
	 }
	 public StreamsDatum(Object document, String id, Map<String, Object> metadata) {
		 this(document, id, null, null, metadata);
	 }
	 public StreamsDatum(Object document, String id, BigInteger sequenceid, Map<String, Object> metadata) {
		 this(document, id, null, sequenceid, metadata);
	 }
	 public StreamsDatum(Object document, String id, BigInteger sequenceid) {
		 this(document, id, sequenceid, new HashMap<>());
	 }
	 public StreamsDatum(Object document, String id, DateTime timestamp, BigInteger sequenceid) {
		 this.document = document;
		 this.id = id;
		 this.timestamp = timestamp;
		 this.sequenceid = sequenceid;
		 this.metadata = new HashMap<>();
	 }
	 public StreamsDatum(Object document, String id, DateTime timestamp, BigInteger sequenceid, Map<String, Object> metadata) {
		 this.document = document;
		 this.id = id;
		 this.timestamp = timestamp;
		 this.sequenceid = sequenceid;
		 this.metadata = metadata;
	 }
	 public DateTime timestamp;
	 public BigInteger sequenceid;
	 public Map<String, Object> metadata;
	 public Object document;
	 private String id;
	 public DateTime getTimestamp() {
		 return timestamp;
	 }
	 public void setTimestamp(DateTime timestamp) {
		 this.timestamp = timestamp;
	 }
	 public BigInteger getSequenceid() {
		 return sequenceid;
	 }
	 public void setSequenceid(BigInteger sequenceid) {
		 this.sequenceid = sequenceid;
	 }
	 public Map<String, Object> getMetadata() {
		 return metadata;
	 }
	 public void setMetadata(Map<String, Object> metadata) {
		 this.metadata = metadata;
	 }
	 public Object getDocument() {
		 return document;
	 }
	 public void setDocument(Object document) {
		 this.document = document;
	 }
	 public String getId() {
		 if (this.id == null && this.document instanceof Activity) {
			 return ((Activity)this.document).getId();
		 }
		 return id;
	 }
	 public void setId(String id) {
		 this.id = id;
	 }
	 public boolean equals(Object configurationObject) {
		 if (configurationObject instanceof StreamsDatum) {
			 StreamsDatum that = (StreamsDatum) configurationObject;
			 if (this.document != null && this.document.equals(that.document)) {
				 return (this.timestamp != null ? this.timestamp.equals(that.timestamp) : that.timestamp == null) && (this.sequenceid != null ? this.sequenceid.equals(that.sequenceid) : that.sequenceid == null);
			 }
			 else {
				 return that.document == null && this.document == null;
			 }
		 }
		 else {
			 return false;
		 }
	 }
	 public String toString() {
		 return ""StreamsDatum{
		"" + ""timestamp="" + timestamp + "", sequenceid="" + sequenceid + "", metadata="" + metadata + "", document="" + document + "", id='"" + id + '\'' + '}
		';
	 }
}",1,1,0,0
"public String genJavaReadWrapper(String fname, String tag, boolean decl) {
	 String ret = """";
	 if (decl) {
		 ret = "" String ""+fname+"";
		\n"";
	 }
	 return ret + "" ""+fname+""=a_.readString(\""""+tag+""\"");
	\n"";
 }",0,0,0,0
"public class VideoProducerImplementation extends HandlerBase implements IVideoProducer{
	 private VideoProducer videoParams;
	 private Framebuffer fbo;
	 private FloatBuffer depthBuffer;
	 public boolean parseParameters(Object params) {
		 if (params == null || !(params instanceof VideoProducer)) return false;
		 this.videoParams = (VideoProducer) params;
		 return true;
	 }
	 public VideoType getVideoType() {
		 return VideoType.VIDEO;
	 }
	 public void getFrame(MissionInit missionInit, ByteBuffer buffer) {
		 if (!this.videoParams.isWantDepth()) {
			 getRGBFrame(buffer);
			 return;
		 }
		 final int width = this.videoParams.getWidth();
		 final int height = this.videoParams.getHeight();
		 GL30.glBindFramebuffer(GL30.GL_READ_FRAMEBUFFER, Minecraft.getMinecraft().getFramebuffer().framebufferObject);
		 GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, this.fbo.framebufferObject);
		 GL30.glBlitFramebuffer(0, 0, Minecraft.getMinecraft().getFramebuffer().framebufferWidth, Minecraft.getMinecraft().getFramebuffer().framebufferHeight, 0, 0, width, height, GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT, GL11.GL_NEAREST);
		 this.fbo.bindFramebuffer(true);
		 glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
		 glReadPixels(0, 0, width, height, GL_DEPTH_COMPONENT, GL_FLOAT, this.depthBuffer);
		 this.fbo.unbindFramebuffer();
		 float minval, maxval;
		 if (this.videoParams.getDepthScaling() == null || this.videoParams.getDepthScaling().isAutoscale()) {
			 minval = 1;
			 maxval = 0;
			 for (int i = 0;
			 i < width * height;
			 i++) {
				 float f = this.depthBuffer.get(i);
				 if (f < minval) minval = f;
				 if (f > maxval) maxval = f;
			 }
		 }
		 else {
			 minval = this.videoParams.getDepthScaling().getMin().floatValue();
			 maxval = this.videoParams.getDepthScaling().getMax().floatValue();
			 if (minval > maxval) {
				 float t = minval;
				 minval = maxval;
				 maxval = t;
			 }
		 }
		 float range = maxval - minval;
		 if (range < 0.000001) range = 0.000001f;
		 float scale = 255 / range;
		 for (int i = 0;
		 i < width * height;
		 i++) {
			 float f = this.depthBuffer.get(i);
			 f = (f < minval ? minval : (f > maxval ? maxval : f));
			 f -= minval;
			 f *= scale;
			 buffer.put(i * 4 + 3, (byte) f);
		 }
		 this.depthBuffer.clear();
	 }
	 public int getWidth() {
		 return this.videoParams.getWidth();
	 }
	 public int getHeight() {
		 return this.videoParams.getHeight();
	 }
	 public int getRequiredBufferSize() {
		 return this.videoParams.getWidth() * this.videoParams.getHeight() * (this.videoParams.isWantDepth() ? 4 : 3);
	 }
	 private void getRGBFrame(ByteBuffer buffer) {
		 final int format = GL_RGB;
		 final int width = this.videoParams.getWidth();
		 final int height = this.videoParams.getHeight();
		 this.fbo.bindFramebuffer(true);
		 Minecraft.getMinecraft().getFramebuffer().framebufferRenderExt(width, height, true);
		 glReadPixels(0, 0, width, height, format, GL_UNSIGNED_BYTE, buffer);
		 this.fbo.unbindFramebuffer();
		 GlStateManager.enableDepth();
		 Minecraft.getMinecraft().getFramebuffer().bindFramebuffer(true);
	 }
	 public void prepare(MissionInit missionInit) {
		 this.fbo = new Framebuffer(this.videoParams.getWidth(), this.videoParams.getHeight(), true);
		 if (this.videoParams.isWantDepth()) this.depthBuffer = BufferUtils.createFloatBuffer(this.videoParams.getWidth() * this.videoParams.getHeight());
		 Minecraft.getMinecraft().gameSettings.thirdPersonView = this.videoParams.getViewpoint();
	 }
	 public void cleanup() {
		 this.fbo.deleteFramebuffer();
	 }
}",1,0,0,0
"public class Pair<T1, T2>{
	 public final T1 left;
	 public final T2 right;
	 public Pair(T1 left, T2 right) {
		 this.left = left;
		 this.right = right;
	 }
	 public final int hashCode() {
		 int hashCode = 31 + (left == null ? 0 : left.hashCode());
		 return 31*hashCode + (right == null ? 0 : right.hashCode());
	 }
	 public final boolean equals(Object o) {
		 if(!(o instanceof Pair)) return false;
		 Pair that = (Pair)o;
		 return Objects.equal(left, that.left) && Objects.equal(right, that.right);
	 }
	 public String toString() {
		 return ""("" + left + "","" + right + "")"";
	 }
	 public static <X, Y> Pair<X, Y> create(X x, Y y) {
		 return new Pair<X, Y>(x, y);
	 }
}",0,0,0,0
"public class ConnectDialog extends InternalDialog implements DocumentListener, FocusListener, ItemListener, ListSelectionListener, KeyListener {
	 private static final int COL_NAME = 0;
	 private static final int COL_PID = 1;
	 JConsole jConsole;
	 JTextField userNameTF, passwordTF;
	 JRadioButton localRadioButton, remoteRadioButton;
	 JLabel localMessageLabel, remoteMessageLabel;
	 JTextField remoteTF;
	 JButton connectButton, cancelButton;
	 JPanel radioButtonPanel;
	 private Icon mastheadIcon = new MastheadIcon(Messages.CONNECT_DIALOG_MASTHEAD_TITLE);
	 private Color hintTextColor, disabledTableCellColor;
	 JTable vmTable;
	 ManagedVmTableModel vmModel = null;
	 JScrollPane localTableScrollPane = null;
	 private Action connectAction, cancelAction;
	 public ConnectDialog(JConsole jConsole) {
		 super(jConsole, Messages.CONNECT_DIALOG_TITLE, true);
		 this.jConsole = jConsole;
		 setAccessibleDescription(this, Messages.CONNECT_DIALOG_ACCESSIBLE_DESCRIPTION);
		 setDefaultCloseOperation(HIDE_ON_CLOSE);
		 setResizable(false);
		 Container cp = (JComponent)getContentPane();
		 radioButtonPanel = new JPanel(new BorderLayout(0, 12));
		 radioButtonPanel.setBorder(new EmptyBorder(6, 12, 12, 12));
		 ButtonGroup radioButtonGroup = new ButtonGroup();
		 JPanel bottomPanel = new JPanel(new BorderLayout());
		 statusBar = new JLabel("" "", JLabel.CENTER);
		 setAccessibleName(statusBar, Messages.CONNECT_DIALOG_STATUS_BAR_ACCESSIBLE_NAME);
		 Font normalLabelFont = statusBar.getFont();
		 Font boldLabelFont = normalLabelFont.deriveFont(Font.BOLD);
		 Font smallLabelFont = normalLabelFont.deriveFont(normalLabelFont.getSize2D() - 1);
		 JLabel mastheadLabel = new JLabel(mastheadIcon);
		 setAccessibleName(mastheadLabel, Messages.CONNECT_DIALOG_MASTHEAD_ACCESSIBLE_NAME);
		 cp.add(mastheadLabel, NORTH);
		 cp.add(radioButtonPanel, CENTER);
		 cp.add(bottomPanel, SOUTH);
		 createActions();
		 remoteTF = new JTextField();
		 remoteTF.addActionListener(connectAction);
		 remoteTF.getDocument().addDocumentListener(this);
		 remoteTF.addFocusListener(this);
		 remoteTF.setPreferredSize(remoteTF.getPreferredSize());
		 setAccessibleName(remoteTF, Messages.REMOTE_PROCESS_TEXT_FIELD_ACCESSIBLE_NAME);
		 if (JConsole.isLocalAttachAvailable()) {
			 vmModel = new ManagedVmTableModel();
			 vmTable = new LocalTabJTable(vmModel);
			 vmTable.setSelectionMode(SINGLE_SELECTION);
			 vmTable.setPreferredScrollableViewportSize(new Dimension(400, 250));
			 vmTable.setColumnSelectionAllowed(false);
			 vmTable.addFocusListener(this);
			 vmTable.getSelectionModel().addListSelectionListener(this);
			 TableColumnModel columnModel = vmTable.getColumnModel();
			 TableColumn pidColumn = columnModel.getColumn(COL_PID);
			 pidColumn.setMaxWidth(getLabelWidth(""9999999""));
			 pidColumn.setResizable(false);
			 TableColumn cmdLineColumn = columnModel.getColumn(COL_NAME);
			 cmdLineColumn.setResizable(false);
			 localRadioButton = new JRadioButton(Messages.LOCAL_PROCESS_COLON);
			 localRadioButton.setMnemonic(Resources.getMnemonicInt(Messages.LOCAL_PROCESS_COLON));
			 localRadioButton.setFont(boldLabelFont);
			 localRadioButton.addItemListener(this);
			 radioButtonGroup.add(localRadioButton);
			 JPanel localPanel = new JPanel(new BorderLayout());
			 JPanel localTablePanel = new JPanel(new BorderLayout());
			 radioButtonPanel.add(localPanel, NORTH);
			 localPanel.add(localRadioButton, NORTH);
			 localPanel.add(new Padder(localRadioButton), LINE_START);
			 localPanel.add(localTablePanel, CENTER);
			 localTableScrollPane = new JScrollPane(vmTable);
			 localTablePanel.add(localTableScrollPane, NORTH);
			 localMessageLabel = new JLabel("" "");
			 localMessageLabel.setFont(smallLabelFont);
			 localMessageLabel.setForeground(hintTextColor);
			 localTablePanel.add(localMessageLabel, SOUTH);
		 }
		 remoteRadioButton = new JRadioButton(Messages.REMOTE_PROCESS_COLON);
		 remoteRadioButton.setMnemonic(Resources.getMnemonicInt(Messages.REMOTE_PROCESS_COLON));
		 remoteRadioButton.setFont(boldLabelFont);
		 radioButtonGroup.add(remoteRadioButton);
		 JPanel remotePanel = new JPanel(new BorderLayout());
		 if (localRadioButton != null) {
			 remotePanel.add(remoteRadioButton, NORTH);
			 remotePanel.add(new Padder(remoteRadioButton), LINE_START);
			 Action nextRadioButtonAction = new AbstractAction(""nextRadioButton"") {
				 public void actionPerformed(ActionEvent ev) {
					 JRadioButton rb = (ev.getSource() == localRadioButton) ? remoteRadioButton : localRadioButton;
					 rb.doClick();
					 rb.requestFocus();
				 }
			 }
			;
			 localRadioButton.getActionMap().put(""nextRadioButton"", nextRadioButtonAction);
			 remoteRadioButton.getActionMap().put(""nextRadioButton"", nextRadioButtonAction);
			 localRadioButton.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), ""nextRadioButton"");
			 remoteRadioButton.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), ""nextRadioButton"");
		 }
		 else {
			 JLabel remoteLabel = new JLabel(remoteRadioButton.getText());
			 remoteLabel.setFont(boldLabelFont);
			 remotePanel.add(remoteLabel, NORTH);
		 }
		 radioButtonPanel.add(remotePanel, SOUTH);
		 JPanel remoteTFPanel = new JPanel(new BorderLayout());
		 remotePanel.add(remoteTFPanel, CENTER);
		 remoteTFPanel.add(remoteTF, NORTH);
		 remoteMessageLabel = new JLabel(""<html>"" + Messages.REMOTE_TF_USAGE + ""</html>"");
		 remoteMessageLabel.setFont(smallLabelFont);
		 remoteMessageLabel.setForeground(hintTextColor);
		 remoteTFPanel.add(remoteMessageLabel, CENTER);
		 JPanel userPwdPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 0, 0));
		 userPwdPanel.setBorder(new EmptyBorder(12, 0, 0, 0));
		 int tfWidth = JConsole.IS_WIN ? 12 : 8;
		 userNameTF = new JTextField(tfWidth);
		 userNameTF.addActionListener(connectAction);
		 userNameTF.getDocument().addDocumentListener(this);
		 userNameTF.addFocusListener(this);
		 setAccessibleName(userNameTF, Messages.USERNAME_ACCESSIBLE_NAME);
		 LabeledComponent lc;
		 lc = new LabeledComponent(Messages.USERNAME_COLON_, Resources.getMnemonicInt(Messages.USERNAME_COLON_), userNameTF);
		 lc.label.setFont(boldLabelFont);
		 userPwdPanel.add(lc);
		 passwordTF = new JPasswordField(tfWidth);
		 passwordTF.setPreferredSize(userNameTF.getPreferredSize());
		 passwordTF.addActionListener(connectAction);
		 passwordTF.getDocument().addDocumentListener(this);
		 passwordTF.addFocusListener(this);
		 setAccessibleName(passwordTF, Messages.PASSWORD_ACCESSIBLE_NAME);
		 lc = new LabeledComponent(Messages.PASSWORD_COLON_, Resources.getMnemonicInt(Messages.PASSWORD_COLON_), passwordTF);
		 lc.setBorder(new EmptyBorder(0, 12, 0, 0));
		 lc.label.setFont(boldLabelFont);
		 userPwdPanel.add(lc);
		 remoteTFPanel.add(userPwdPanel, SOUTH);
		 String connectButtonToolTipText = Messages.CONNECT_DIALOG_CONNECT_BUTTON_TOOLTIP;
		 connectButton = new JButton(connectAction);
		 connectButton.setToolTipText(connectButtonToolTipText);
		 cancelButton = new JButton(cancelAction);
		 JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.TRAILING));
		 buttonPanel.setBorder(new EmptyBorder(12, 12, 2, 12));
		 if (JConsole.IS_GTK) {
			 buttonPanel.add(cancelButton);
			 buttonPanel.add(connectButton);
		 }
		 else {
			 buttonPanel.add(connectButton);
			 buttonPanel.add(cancelButton);
		 }
		 bottomPanel.add(buttonPanel, NORTH);
		 bottomPanel.add(statusBar, SOUTH);
		 updateButtonStates();
		 Utilities.updateTransparency(this);
	 }
	 public void revalidate() {
		 Color disabledForeground = UIManager.getColor(""Label.disabledForeground"");
		 if (disabledForeground == null) {
			 disabledForeground = UIManager.getColor(""Label.disabledText"");
		 }
		 hintTextColor = ensureContrast(disabledForeground, UIManager.getColor(""Panel.background""));
		 disabledTableCellColor = ensureContrast(new Color(0x808080), UIManager.getColor(""Table.background""));
		 if (remoteMessageLabel != null) {
			 remoteMessageLabel.setForeground(hintTextColor);
			 String colorStr = String.format(""%06x"", hintTextColor.getRGB() & 0xFFFFFF);
			 remoteMessageLabel.setText(""<html><font color=#"" + colorStr + "">"" + Messages.REMOTE_TF_USAGE);
		 }
		 if (localMessageLabel != null) {
			 localMessageLabel.setForeground(hintTextColor);
			 valueChanged(null);
		 }
		 super.revalidate();
	 }
	 private void createActions() {
		 connectAction = new AbstractAction(Messages.CONNECT) {
			 {
				 putValue(Action.MNEMONIC_KEY, Resources.getMnemonicInt(Messages.CONNECT));
			 }
			 public void actionPerformed(ActionEvent ev) {
				 if (!isEnabled() || !isVisible()) {
					 return;
				 }
				 setVisible(false);
				 statusBar.setText("""");
				 if (remoteRadioButton.isSelected()) {
					 String txt = remoteTF.getText().trim();
					 String userName = userNameTF.getText().trim();
					 userName = userName.isEmpty() ? null : userName;
					 String password = passwordTF.getText();
					 password = password.isEmpty() ? null : password;
					 try {
						 if (txt.startsWith(JConsole.ROOT_URL)) {
							 String url = txt;
							 jConsole.addUrl(url, userName, password, false);
							 remoteTF.setText(JConsole.ROOT_URL);
							 return;
						 }
						 else {
							 String host = remoteTF.getText().trim();
							 String port = ""0"";
							 int index = host.lastIndexOf(':');
							 if (index >= 0) {
								 port = host.substring(index + 1);
								 host = host.substring(0, index);
							 }
							 if (host.length() > 0 && port.length() > 0) {
								 int p = Integer.parseInt(port.trim());
								 jConsole.addHost(host, p, userName, password);
								 remoteTF.setText("""");
								 userNameTF.setText("""");
								 passwordTF.setText("""");
								 return;
							 }
						 }
					 }
					 catch (Exception ex) {
						 statusBar.setText(ex.toString());
					 }
					 setVisible(true);
				 }
				 else if (localRadioButton != null && localRadioButton.isSelected()) {
					 int row = vmTable.getSelectedRow();
					 if (row >= 0) {
						 jConsole.addVmid(vmModel.vmAt(row));
					 }
					 refresh();
				 }
			 }
		 }
		;
		 cancelAction = new AbstractAction(Messages.CANCEL) {
			 public void actionPerformed(ActionEvent ev) {
				 setVisible(false);
				 statusBar.setText("""");
			 }
		 }
		;
	 }
	 private static JLabel tmpLabel = new JLabel();
	 public static int getLabelWidth(String text) {
		 tmpLabel.setText(text);
		 return (int) tmpLabel.getPreferredSize().getWidth() + 1;
	 }
	 private class LocalTabJTable extends JTable {
		 ManagedVmTableModel vmModel;
		 Border rendererBorder = new EmptyBorder(0, 6, 0, 6);
		 public LocalTabJTable(ManagedVmTableModel model) {
			 super(model);
			 this.vmModel = model;
			 if (!JConsole.IS_GTK) {
				 setShowVerticalLines(false);
				 setIntercellSpacing(new Dimension(0, 1));
			 }
			 addMouseListener(new MouseAdapter() {
				 public void mouseClicked(MouseEvent evt) {
					 if (evt.getClickCount() == 2) {
						 connectButton.doClick();
					 }
				 }
			 }
			);
			 getActionMap().put(""connect"", connectAction);
			 InputMap inputMap = getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
			 inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), ""connect"");
		 }
		 public String getToolTipText(MouseEvent e) {
			 String tip = null;
			 java.awt.Point p = e.getPoint();
			 int rowIndex = rowAtPoint(p);
			 int colIndex = columnAtPoint(p);
			 int realColumnIndex = convertColumnIndexToModel(colIndex);
			 if (realColumnIndex == COL_NAME) {
				 LocalVirtualMachine vmd = vmModel.vmAt(rowIndex);
				 tip = vmd.toString();
			 }
			 return tip;
		 }
		 public TableCellRenderer getCellRenderer(int row, int column) {
			 return new DefaultTableCellRenderer() {
				 public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
					 Component comp = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
					 if (!isSelected) {
						 LocalVirtualMachine lvm = vmModel.vmAt(row);
						 if (!lvm.isManageable() && !lvm.isAttachable()) {
							 comp.setForeground(disabledTableCellColor);
						 }
					 }
					 if (comp instanceof JLabel) {
						 JLabel label = (JLabel)comp;
						 label.setBorder(rendererBorder);
						 if (value instanceof Integer) {
							 label.setHorizontalAlignment(JLabel.RIGHT);
						 }
					 }
					 return comp;
				 }
			 }
			;
		 }
	 }
	 public void setConnectionParameters(String url, String host, int port, String userName, String password, String msg) {
		 if ((url != null && url.length() > 0) || (host != null && host.length() > 0 && port > 0)) {
			 remoteRadioButton.setSelected(true);
			 if (url != null && url.length() > 0) {
				 remoteTF.setText(url);
			 }
			 else {
				 remoteTF.setText(host+"":""+port);
			 }
			 userNameTF.setText((userName != null) ? userName : """");
			 passwordTF.setText((password != null) ? password : """");
			 statusBar.setText((msg != null) ? msg : """");
			 if (getPreferredSize().width > getWidth()) {
				 pack();
			 }
			 remoteTF.requestFocus();
			 remoteTF.selectAll();
		 }
	 }
	 public void itemStateChanged(ItemEvent ev) {
		 if (!localRadioButton.isSelected()) {
			 vmTable.getSelectionModel().clearSelection();
		 }
		 updateButtonStates();
	 }
	 private void updateButtonStates() {
		 boolean connectEnabled = false;
		 if (remoteRadioButton.isSelected()) {
			 connectEnabled = JConsole.isValidRemoteString(remoteTF.getText());
		 }
		 else if (localRadioButton != null && localRadioButton.isSelected()) {
			 int row = vmTable.getSelectedRow();
			 if (row >= 0) {
				 LocalVirtualMachine lvm = vmModel.vmAt(row);
				 connectEnabled = (lvm.isManageable() || lvm.isAttachable());
			 }
		 }
		 connectAction.setEnabled(connectEnabled);
	 }
	 public void insertUpdate(DocumentEvent e) {
		 updateButtonStates();
	 }
	 public void removeUpdate(DocumentEvent e) {
		 updateButtonStates();
	 }
	 public void changedUpdate(DocumentEvent e) {
		 updateButtonStates();
	 }
	 public void focusGained(FocusEvent e) {
		 Object source = e.getSource();
		 Component opposite = e.getOppositeComponent();
		 if (!e.isTemporary() && source instanceof JTextField && opposite instanceof JComponent && SwingUtilities.getRootPane(opposite) == getRootPane()) {
			 ((JTextField)source).selectAll();
		 }
		 if (source == remoteTF) {
			 remoteRadioButton.setSelected(true);
		 }
		 else if (source == vmTable) {
			 localRadioButton.setSelected(true);
			 if (vmModel.getRowCount() == 1) {
				 vmTable.setRowSelectionInterval(0, 0);
			 }
		 }
		 updateButtonStates();
	 }
	 public void focusLost(FocusEvent e) {
	 }
	 public void keyTyped(KeyEvent e) {
		 char c = e.getKeyChar();
		 if (c == KeyEvent.VK_ESCAPE) {
			 setVisible(false);
		 }
		 else if (!(Character.isDigit(c) || c == KeyEvent.VK_BACK_SPACE || c == KeyEvent.VK_DELETE)) {
			 getToolkit().beep();
			 e.consume();
		 }
	 }
	 public void setVisible(boolean b) {
		 boolean wasVisible = isVisible();
		 super.setVisible(b);
		 if (b && !wasVisible) {
			 SwingUtilities.invokeLater(new Runnable() {
				 public void run() {
					 if (remoteRadioButton.isSelected()) {
						 remoteTF.requestFocus();
						 remoteTF.selectAll();
					 }
				 }
			 }
			);
		 }
	 }
	 public void keyPressed(KeyEvent e) {
	 }
	 public void keyReleased(KeyEvent e) {
	 }
	 public void valueChanged(ListSelectionEvent e) {
		 updateButtonStates();
		 String labelText = "" "";
		 int row = vmTable.getSelectedRow();
		 if (row >= 0) {
			 LocalVirtualMachine lvm = vmModel.vmAt(row);
			 if (!lvm.isManageable()) {
				 if (lvm.isAttachable()) {
					 labelText = Messages.MANAGEMENT_WILL_BE_ENABLED;
				 }
				 else {
					 labelText = Messages.MANAGEMENT_NOT_ENABLED;
				 }
			 }
		 }
		 String colorStr = String.format(""%06x"", hintTextColor.getRGB() & 0xFFFFFF);
		 localMessageLabel.setText(""<html><font color=#"" + colorStr + "">"" + labelText);
	 }
	 public void refresh() {
		 if (vmModel != null) {
			 LocalVirtualMachine selected = null;
			 int row = vmTable.getSelectedRow();
			 if (row >= 0) {
				 selected = vmModel.vmAt(row);
			 }
			 vmModel.refresh();
			 int selectRow = -1;
			 int n = vmModel.getRowCount();
			 if (selected != null) {
				 for (int i = 0;
				 i < n;
				 i++) {
					 LocalVirtualMachine lvm = vmModel.vmAt(i);
					 if (selected.vmid() == lvm.vmid() && selected.toString().equals(lvm.toString())) {
						 selectRow = i;
						 break;
					 }
				 }
			 }
			 if (selectRow > -1) {
				 vmTable.setRowSelectionInterval(selectRow, selectRow);
			 }
			 else {
				 vmTable.getSelectionModel().clearSelection();
			 }
			 Dimension dim = vmTable.getPreferredSize();
			 dim.height = Math.min(dim.height-1, 100);
			 localTableScrollPane.setVerticalScrollBarPolicy((dim.height < 100) ? JScrollPane.VERTICAL_SCROLLBAR_NEVER : JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
			 localTableScrollPane.getViewport().setMinimumSize(dim);
			 localTableScrollPane.getViewport().setPreferredSize(dim);
		 }
		 pack();
		 setLocationRelativeTo(jConsole);
	 }
	 private static class ManagedVmTableModel extends AbstractTableModel {
		 private static String[] columnNames = {
		 Messages.COLUMN_NAME, Messages.COLUMN_PID, }
		;
		 private List<LocalVirtualMachine> vmList;
		 public int getColumnCount() {
			 return columnNames.length;
		 }
		 public String getColumnName(int col) {
			 return columnNames[col];
		 }
		 public synchronized int getRowCount() {
			 return vmList.size();
		 }
		 public synchronized Object getValueAt(int row, int col) {
			 assert col >= 0 && col <= columnNames.length;
			 LocalVirtualMachine vm = vmList.get(row);
			 switch (col) {
				 case COL_NAME: return vm.displayName();
				 case COL_PID: return vm.vmid();
				 default: return null;
			 }
		 }
		 public Class<?> getColumnClass(int column) {
			 switch (column) {
				 case COL_NAME: return String.class;
				 case COL_PID: return Integer.class;
				 default: return super.getColumnClass(column);
			 }
		 }
		 public ManagedVmTableModel() {
			 refresh();
		 }
		 public synchronized LocalVirtualMachine vmAt(int pos) {
			 return vmList.get(pos);
		 }
		 public synchronized void refresh() {
			 Map<Integer, LocalVirtualMachine> map = LocalVirtualMachine.getAllVirtualMachines();
			 vmList = new ArrayList<LocalVirtualMachine>();
			 vmList.addAll(map.values());
			 fireTableDataChanged();
		 }
	 }
	 private static class Padder extends JPanel {
		 JRadioButton radioButton;
		 Padder(JRadioButton radioButton) {
			 this.radioButton = radioButton;
			 setAccessibleName(this, Messages.BLANK);
		 }
		 public Dimension getPreferredSize() {
			 Rectangle r = getTextRectangle(radioButton);
			 int w = (r != null && r.x > 8) ? r.x : 22;
			 return new Dimension(w, 0);
		 }
		 private static Rectangle getTextRectangle(AbstractButton button) {
			 String text = button.getText();
			 Icon icon = (button.isEnabled()) ? button.getIcon() : button.getDisabledIcon();
			 if (icon == null && button.getUI() instanceof BasicRadioButtonUI) {
				 icon = ((BasicRadioButtonUI)button.getUI()).getDefaultIcon();
			 }
			 if ((icon == null) && (text == null)) {
				 return null;
			 }
			 Rectangle paintIconR = new Rectangle();
			 Rectangle paintTextR = new Rectangle();
			 Rectangle paintViewR = new Rectangle();
			 Insets paintViewInsets = new Insets(0, 0, 0, 0);
			 paintViewInsets = button.getInsets(paintViewInsets);
			 paintViewR.x = paintViewInsets.left;
			 paintViewR.y = paintViewInsets.top;
			 paintViewR.width = button.getWidth() - (paintViewInsets.left + paintViewInsets.right);
			 paintViewR.height = button.getHeight() - (paintViewInsets.top + paintViewInsets.bottom);
			 Graphics g = button.getGraphics();
			 if (g == null) {
				 return null;
			 }
			 SwingUtilities.layoutCompoundLabel(button, g.getFontMetrics(), text, icon, button.getVerticalAlignment(), button.getHorizontalAlignment(), button.getVerticalTextPosition(), button.getHorizontalTextPosition(), paintViewR, paintIconR, paintTextR, button.getIconTextGap());
			 return paintTextR;
		 }
	 }
}",1,0,0,0
"public void run() {
	long lastUpdateChecked = 0;
	try {
		Calendar cal = Calendar.getInstance();
		while (!stop) {
			try {
				long currentTime = System.currentTimeMillis();
				if (currentTime - lastKeepAwakePing > 3000) {
					if (!XDMApp.getInstance().isAllFinished()) {
						XDMUtils.keepAwakePing();
						lastKeepAwakePing = currentTime;
					}
				}
				ArrayList<DownloadQueue> queues = QueueManager.getInstance().getQueueList();
				for (int i = 0;
				 i < queues.size();
				 i++) {
					DownloadQueue queue = queues.get(i);
					if (queue.isRunning() || queue.getStartTime() == -1) {
						continue;
					}
					Date now = new Date();
					cal.setTime(now);
					Date onlyDate = DateTimeUtils.getDatePart(cal);
					long seconds = DateTimeUtils.getTimePart(now);
					if (seconds > queue.getStartTime()) {
						if (queue.getEndTime() > 0) {
							if (queue.getEndTime() < seconds) {
								continue;
							}
						}
					}
					 else {
						continue;
					}
					if (queue.isPeriodic()) {
						int day = cal.get(Calendar.DAY_OF_WEEK);
						int mask = 0x01 << (day - 1);
						if ((queue.getDayMask() & mask) != mask) {
							continue;
						}
					}
					 else {
						Date execDate = queue.getExecDate();
						if (execDate == null) {
							continue;
						}
						cal.setTime(execDate);
						Date onlyDate2 = DateTimeUtils.getDatePart(cal);
						if (onlyDate.compareTo(onlyDate2) < 0) {
							continue;
						}
					}
					queue.start();
				}
				for (int i = 0;
				 i < queues.size();
				 i++) {
					DownloadQueue queue = queues.get(i);
					if (!queue.isRunning()) {
						continue;
					}
					if (queue.getEndTime() < 1) {
						continue;
					}
					Date now = new Date();
					long seconds = DateTimeUtils.getTimePart(now);
					if (queue.getEndTime() < seconds) {
						queue.stop();
					}
				}
				Thread.sleep(1000);
			}
			 catch (Exception e2) {
				Logger.log(""error in scheduler: "" + e2);
				Logger.log(e2);
			}
			long now = System.currentTimeMillis();
			if (now - lastUpdateChecked > 3600 * 1000) {
				int stat = UpdateChecker.getUpdateStat();
				switch (stat) {
					case UpdateChecker.NO_UPDATE_AVAILABLE:break;
					case UpdateChecker.APP_UPDATE_AVAILABLE:XDMApp.getInstance().notifyAppUpdate();
					break;
					case UpdateChecker.COMP_NOT_INSTALLED:XDMApp.getInstance().notifyComponentInstall();
					break;
					case UpdateChecker.COMP_UPDATE_AVAILABLE:XDMApp.getInstance().notifyComponentUpdate();
					break;
				}
			}
			lastUpdateChecked = now;
		}
	}
	 catch (Exception e) {
		Logger.log(""error in scheduler: "" + e);
		Logger.log(e);
	}
}",0,0,1,0
"private void validateHeaders(){
	HtmlHeaderContainer header = (HtmlHeaderContainer)visitChildren(new IVisitor<Component>(){
		public Object component(Component component){
			if (component instanceof HtmlHeaderContainer){
				return component;
			}
			return IVisitor.CONTINUE_TRAVERSAL;
		}
	}
	);
	if (header == null){
		header = new HtmlHeaderContainer(HtmlHeaderSectionHandler.HEADER_ID);
		add(header);
		Response orgResponse = getRequestCycle().getResponse();
		try{
			final StringResponse response = new StringResponse();
			getRequestCycle().setResponse(response);
			renderHead(header);
			final HtmlHeaderContainer finalHeader = header;
			visitChildren(new IVisitor<Component>(){
				public Object component(Component component){
					component.renderHead(finalHeader);
					return CONTINUE_TRAVERSAL;
				}
			}
			);
			response.close();
			if (response.getBuffer().length() > 0){
				log.error(""^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"");
				log.error(""You probably forgot to add a <body> or <head> tag to your markup since no Header Container was \n"" +""found but components were found which want to write to the <head> section.\n"" +response.getBuffer());
				log.error(""^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"");
			}
		}
		catch (Exception e){
			log.error(""header/body check throws exception"", e);
		}
		finally{
			this.remove(header);
			getRequestCycle().setResponse(orgResponse);
		}
	}
}",0,0,0,0
"private void reportStatus() throws IOException {
	 String status;
	 synchronized (this) {
		 long elapsed = (System.currentTimeMillis() - start)/1000;
		 status = pages+"" pages, ""+errors+"" errors, "" + Math.round(((float)pages*10)/elapsed)/10.0+"" pages/s, "" + Math.round(((((float)bytes)*8)/1024)/elapsed)+"" kb/s, "";
	 }
	 reporter.setStatus(status);
 }",0,0,0,0
"public class StubConfiguration extends AbstractConfiguration {
	 private static final Logger LOG = LoggerFactory.getLogger(StubConfiguration.class);
	 private static final String STATUS_GETTER_URL_POSTFIX = ""config/public/stubdescriptor"";
	 private static final String STUB_CONFIG_STATUS_CHANGE_SETTER_URL_POSTFIX = ""config/admin/stub/changestatus"";
	 private static final String STUB_CONFIG_ORDER_CHANGE_SETTER_URL_POSTFIX = ""config/admin/stub/changeorder"";
	 private static final String DROP_STUB_CONFIG_URL_POSTFIX = ""config/admin/stub/drop"";
	 private static final String SAVE_STUB_CONFIG_URL_POSTFIX = ""config/admin/stub/save"";
	 private static final String GROUP_NAME = ""groupname"";
	 private static final String DIRECTION = ""direction"";
	 private static final String NEXT_STATUS = ""nextstatus"";
	 public StubConfiguration(WilmaServiceConfig config) {
		 super(config);
	 }
	 public StubConfiguration(WilmaServiceConfig config, WilmaHttpClient client) {
		 super(config, client);
	 }
	 public JSONObject getStubConfigInformation() {
		 LOG.debug(""Call stub configuration API."");
		 return getterRequest(STATUS_GETTER_URL_POSTFIX);
	 }
	 public boolean setStubConfigStatus(String groupName, StubConfigStatus status) {
		 LOG.debug(""Call stub status setter API with value: {
		}
		, for group: {
		}
		"", status, groupName);
		 return setterRequest(STUB_CONFIG_STATUS_CHANGE_SETTER_URL_POSTFIX, ImmutableMap.of(GROUP_NAME, groupName, NEXT_STATUS, Boolean.toString(status.getNextStatus())));
	 }
	 public boolean setStubConfigOrder(String groupName, StubConfigOrder order) {
		 LOG.debug(""Call stub order setter API with value: {
		}
		, for group: {
		}
		"", order, groupName);
		 return setterRequest(STUB_CONFIG_ORDER_CHANGE_SETTER_URL_POSTFIX, ImmutableMap.of(GROUP_NAME, groupName, DIRECTION, Integer.toString(order.getDirection())));
	 }
	 public boolean dropStubConfig(String groupName) {
		 LOG.debug(""Call drop stub configuration API for group: {
		}
		"", groupName);
		 return setterRequest(DROP_STUB_CONFIG_URL_POSTFIX, ImmutableMap.of(GROUP_NAME, groupName));
	 }
	 public boolean dropAllStubConfig() {
		 LOG.debug(""Call drop all stub configuration."");
		 boolean droppedAllStubConfig = true;
		 JSONObject stubConfig = getStubConfigInformation();
		 if ((stubConfig != null) && (stubConfig.length() > 0)) {
			 try {
				 LOG.debug(""Gets stub configs array from all stub configuration JSON."");
				 JSONArray configs = stubConfig.getJSONArray(""configs"");
				 for (int i = 0;
				 i < configs.length();
				 i++) {
					 LOG.debug(""Get the stub group name."");
					 String groupName = configs.getJSONObject(i).getString(""groupname"");
					 droppedAllStubConfig &= dropStubConfig(groupName);
					 LOG.info(""Dropped stub configuration: {
					}
					"", groupName);
				 }
			 }
			 catch (JSONException e) {
				 LOG.error(""Error occurred while dropping sub configuration. "", e);
				 droppedAllStubConfig = false;
			 }
		 }
		 else {
			 droppedAllStubConfig = false;
		 }
		 return droppedAllStubConfig;
	 }
	 public boolean persistActualStubConfig() {
		 LOG.debug(""Call save stub configuration API."");
		 return setterRequest(SAVE_STUB_CONFIG_URL_POSTFIX);
	 }
}",1,1,0,0
"NativeKeyHolder(P11Key p11Key, long keyID, Session keySession, boolean extractKeyInfo, boolean isTokenObject) {
	 this.p11Key = p11Key;
	 this.keyID = keyID;
	 this.refCount = -1;
	 byte[] ki = null;
	 if (isTokenObject) {
		 this.ref = null;
	 }
	 else {
		 this.ref = new SessionKeyRef(p11Key, keyID, keySession);
		 Token token = p11Key.token;
		 if (extractKeyInfo) {
			 try {
				 if (p11Key.sensitive && nativeKeyWrapperKeyID == 0) {
					 synchronized(NativeKeyHolder.class) {
						 CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes (O_GENERATE, CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {
						 new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY), new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 >> 3), }
						);
						 Session wrappingSession = null;
						 try {
							 wrappingSession = token.getObjSession();
							 nativeKeyWrapperKeyID = token.p11.C_GenerateKey (wrappingSession.id(), new CK_MECHANISM(CKM_AES_KEY_GEN), wrappingAttributes);
							 byte[] iv = new byte[16];
							 JCAUtil.getSecureRandom().nextBytes(iv);
							 nativeKeyWrapperMechanism = new CK_MECHANISM (CKM_AES_CBC_PAD, iv);
						 }
						 catch (PKCS11Exception e) {
						 }
						 finally {
							 token.releaseSession(wrappingSession);
						 }
					 }
				 }
				 Session opSession = null;
				 try {
					 opSession = token.getOpSession();
					 ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(), keyID, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);
				 }
				 catch (PKCS11Exception e) {
				 }
				 finally {
					 token.releaseSession(opSession);
				 }
			 }
			 catch (PKCS11Exception e) {
			 }
		 }
	 }
	 this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);
 }",0,0,1,0
"public class DefaultArtifact extends AbstractArtifact {
	 public static Artifact newIvyArtifact(ModuleRevisionId mrid, Date pubDate) {
		 return new DefaultArtifact(mrid, pubDate, ""ivy"", ""ivy"", ""xml"", true);
	 }
	 public static Artifact newPomArtifact(ModuleRevisionId mrid, Date pubDate) {
		 return new DefaultArtifact(mrid, pubDate, mrid.getName(), ""pom"", ""pom"", true);
	 }
	 public static Artifact cloneWithAnotherExt(Artifact artifact, String newExt) {
		 return cloneWithAnotherTypeAndExt(artifact, artifact.getType(), newExt);
	 }
	 public static Artifact cloneWithAnotherType(Artifact artifact, String newType) {
		 return cloneWithAnotherTypeAndExt(artifact, newType, artifact.getExt());
	 }
	 public static Artifact cloneWithAnotherTypeAndExt(Artifact artifact, String newType, String newExt) {
		 return new DefaultArtifact(ArtifactRevisionId.newInstance(artifact.getModuleRevisionId(), artifact.getName(), newType, newExt, artifact.getQualifiedExtraAttributes()), artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());
	 }
	 public static Artifact cloneWithAnotherName(Artifact artifact, String name) {
		 return new DefaultArtifact(ArtifactRevisionId.newInstance(artifact.getModuleRevisionId(), name, artifact.getType(), artifact.getExt(), artifact.getQualifiedExtraAttributes()), artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());
	 }
	 public static Artifact cloneWithAnotherMrid(Artifact artifact, ModuleRevisionId mrid) {
		 return new DefaultArtifact(ArtifactRevisionId.newInstance(mrid, artifact.getName(), artifact.getType(), artifact.getExt(), artifact.getQualifiedExtraAttributes()), artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());
	 }
	 private Date publicationDate;
	 private ArtifactRevisionId arid;
	 private URL url;
	 private boolean isMetadata = false;
	 public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type, String ext) {
		 this(mrid, publicationDate, name, type, ext, null, null);
	 }
	 public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type, String ext, boolean isMetadata) {
		 this(mrid, publicationDate, name, type, ext, null, null);
		 this.isMetadata = isMetadata;
	 }
	 public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type, String ext, Map<String, String> extraAttributes) {
		 this(mrid, publicationDate, name, type, ext, null, extraAttributes);
	 }
	 public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type, String ext, URL url, Map<String, String> extraAttributes) {
		 this(ArtifactRevisionId.newInstance(mrid, name, type, ext, extraAttributes), publicationDate, url, false);
	 }
	 public DefaultArtifact(ArtifactRevisionId arid, Date publicationDate, URL url, boolean isMetadata) {
		 if (arid == null) {
			 throw new NullPointerException(""null arid not allowed"");
		 }
		 if (publicationDate == null) {
			 publicationDate = new Date();
		 }
		 this.publicationDate = publicationDate;
		 this.arid = arid;
		 this.url = url;
		 this.isMetadata = isMetadata;
	 }
	 public ModuleRevisionId getModuleRevisionId() {
		 return arid.getModuleRevisionId();
	 }
	 public String getName() {
		 return arid.getName();
	 }
	 public Date getPublicationDate() {
		 return publicationDate;
	 }
	 public String getType() {
		 return arid.getType();
	 }
	 public String getExt() {
		 return arid.getExt();
	 }
	 public ArtifactRevisionId getId() {
		 return arid;
	 }
	 public String[] getConfigurations() {
		 return new String[0];
	 }
	 public URL getUrl() {
		 return url;
	 }
	 public boolean isMetadata() {
		 return isMetadata;
	 }
}",0,1,0,0
"public class ScriptValueImpl extends ActionValueImpl implements ScriptValue{
	protected static final String SCRIPT_EDEFAULT = null;
	protected String script = SCRIPT_EDEFAULT;
	protected ScriptValueImpl( ){
		super( );
	}
	protected EClass eStaticClass( ){
		return AttributePackage.Literals.SCRIPT_VALUE;
	}
	public String getScript( ){
		return script;
	}
	public void setScript( String newScript ){
		String oldScript = script;
		script = newScript;
		if ( eNotificationRequired( ) )eNotify( new ENotificationImpl( this,Notification.SET,AttributePackage.SCRIPT_VALUE__SCRIPT,oldScript,script ) );
	}
	public Object eGet( int featureID, boolean resolve, boolean coreType ){
		switch ( featureID ){
			case AttributePackage.SCRIPT_VALUE__SCRIPT :return getScript( );
		}
		return super.eGet( featureID, resolve, coreType );
	}
	public void eSet( int featureID, Object newValue ){
		switch ( featureID ){
			case AttributePackage.SCRIPT_VALUE__SCRIPT :setScript( (String) newValue );
			return;
		}
		super.eSet( featureID, newValue );
	}
	public void eUnset( int featureID ){
		switch ( featureID ){
			case AttributePackage.SCRIPT_VALUE__SCRIPT :setScript( SCRIPT_EDEFAULT );
			return;
		}
		super.eUnset( featureID );
	}
	public boolean eIsSet( int featureID ){
		switch ( featureID ){
			case AttributePackage.SCRIPT_VALUE__SCRIPT :return SCRIPT_EDEFAULT == null ? script != null: !SCRIPT_EDEFAULT.equals( script );
		}
		return super.eIsSet( featureID );
	}
	public String toString( ){
		if ( eIsProxy( ) )return super.toString( );
		StringBuffer result = new StringBuffer( super.toString( ) );
		result.append( "" (script: "" );
		 result.append( script );
		result.append( ')' );
		return result.toString( );
	}
	public static final ScriptValue create( String script ){
		ScriptValue sv = AttributeFactory.eINSTANCE.createScriptValue( );
		sv.setScript( script );
		return sv;
	}
	public ScriptValue copyInstance( ){
		ScriptValueImpl dest = new ScriptValueImpl( );
		dest.set( this );
		return dest;
	}
	protected void set( ScriptValue src ){
		super.set( src );
		script = src.getScript( );
	}
	public ScriptExpression getScriptExpression( ){
		ScriptExpression expression = new ScriptExpression( );
		expression.setType( ChartUtil.getExpressionType( script ) );
		expression.setValue( ChartUtil.getExpressionText( script ) );
		return expression;
	}
	public void setScriptExpression( ScriptExpression expression ){
		setScript( ChartUtil.adaptExpression( expression ) );
	}
}",1,0,0,0
"public class BusinessObjectWrapper2 {
	private String label = """";
	private CellView[] portviews;
	private DefaultMutableTreeNode value;
	public String getLabel() {
		return label;
	}
	public void setLabel(String stringValue) {
		this.label = stringValue;
	}
	public DefaultMutableTreeNode getValue() {
		return value;
	}
	public void setValue(DefaultMutableTreeNode value) {
		this.value = value;
	}
	public String toString() {
		return label;
	}
	public CellView[] getPortviews() {
		return portviews;
	}
	public void setPortviews(CellView[] portviews) {
		this.portviews = portviews;
	}
}",0,1,0,0
"public static void main(String argv[]) throws FileNotFoundException, IOException {
	 if (argv.length < 2) {
		 System.out.println(""Usage: java org.apache.nutch.db.WebDBReader (-local | -ndfs <namenode:port>) <db> [-pageurl url] | [-pagemd5 md5] | [-dumppageurl] | [-dumppagemd5] | [-toppages <k>] | [-linkurl url] | [-linkmd5 md5] | [-dumplinks] | [-stats]"");
		 return;
	 }
	 int i = 0;
	 NutchFileSystem nfs = NutchFileSystem.parseArgs(argv, i);
	 File dbDir = new File(argv[i++]);
	 WebDBReader reader = new WebDBReader(nfs, dbDir);
	 try {
		 String cmd = argv[i++];
		 if (""-pageurl"".equals(cmd)) {
			 String url = argv[i++];
			 System.out.println(reader.getPage(url.trim()));
		 }
		 else if (""-pagemd5"".equals(cmd)) {
			 MD5Hash md5 = new MD5Hash(argv[i++]);
			 Page pages[] = reader.getPages(md5);
			 System.out.println(""Found "" + pages.length + "" pages."");
			 for (int j = 0;
			 j < pages.length;
			 j++) {
				 System.out.println(""Page "" + j + "": "" + pages[j]);
			 }
		 }
		 else if (""-dumppageurl"".equals(cmd)) {
			 System.out.println(reader);
			 System.out.println();
			 int j = 1;
			 for (Enumeration e = reader.pages();
			 e.hasMoreElements();
			 j++) {
				 Page page = (Page) e.nextElement();
				 System.out.println(""Page "" + j + "": "" + page);
				 System.out.println();
			 }
		 }
		 else if (""-dumppagemd5"".equals(cmd)) {
			 System.out.println(reader);
			 System.out.println();
			 int j = 1;
			 for (Enumeration e = reader.pagesByMD5();
			 e.hasMoreElements();
			 j++) {
				 Page page = (Page) e.nextElement();
				 System.out.println(""Page "" + j + "": "" + page);
				 System.out.println();
			 }
		 }
		 else if (""-toppages"".equals(cmd)) {
			 int topSize = Integer.parseInt(argv[i++]);
			 SortedSet topSet = new TreeSet(new Comparator() {
				 public int compare(Object o1, Object o2) {
					 Page p1 = (Page) o1;
					 Page p2 = (Page) o2;
					 if (p1.getScore() < p2.getScore()) {
						 return -1;
					 }
					 else if (p1.getScore() == p2.getScore()) {
						 return p1.compareTo(p2);
					 }
					 else {
						 return 1;
					 }
				 }
			 }
			 );
			 Page lowestPage = null;
			 for (Enumeration e = reader.pages();
			 e.hasMoreElements();
			 ) {
				 Page curPage = (Page) e.nextElement();
				 if (topSet.size() < topSize) {
					 topSet.add(curPage);
					 lowestPage = (Page) topSet.first();
				 }
				 else if (lowestPage.getScore() < curPage.getScore()) {
					 topSet.remove(lowestPage);
					 topSet.add(curPage);
					 lowestPage = (Page) topSet.first();
				 }
			 }
			 int j = 0;
			 for (Iterator it = topSet.iterator();
			 it.hasNext();
			 j++) {
				 System.out.println(""Page "" + j + "": "" + (Page) it.next());
				 System.out.println();
			 }
		 }
		 else if (""-linkurl"".equals(cmd)) {
			 String url = argv[i++];
			 Link links[] = reader.getLinks(new UTF8(url.trim()));
			 System.out.println(""Found "" + links.length + "" links."");
			 for (int j = 0;
			 j < links.length;
			 j++) {
				 System.out.println(""Link "" + j + "": "" + links[j]);
			 }
		 }
		 else if (""-linkmd5"".equals(cmd)) {
			 MD5Hash fromID = new MD5Hash(argv[i++]);
			 Link links[] = reader.getLinks(fromID);
			 System.out.println(""Found "" + links.length + "" links."");
			 for (int j = 0;
			 j < links.length;
			 j++) {
				 System.out.println(""Link "" + j + "": "" + links[j]);
			 }
		 }
		 else if (""-dumplinks"".equals(cmd)) {
			 System.out.println(reader);
			 System.out.println();
			 Enumeration e = reader.pagesByMD5();
			 while (e.hasMoreElements()) {
				 Page page = (Page) e.nextElement();
				 Link[] links = reader.getLinks(page.getMD5());
				 if (links.length > 0) {
					 System.out.println(""from "" + page.getURL());
					 for (int j = 0;
					 j < links.length;
					 j++) {
						 System.out.println("" to "" + links[j].getURL());
					 }
					 System.out.println();
				 }
			 }
		 }
		 else if (""-stats"".equals(cmd)) {
			 System.out.println(""Stats for "" + reader);
			 System.out.println(""-------------------------------"");
			 System.out.println(""Number of pages: "" + reader.numPages());
			 System.out.println(""Number of links: "" + reader.numLinks());
		 }
		 else {
			 System.out.println(""Sorry, no command with name "" + cmd);
		 }
	 }
	 finally {
		 reader.close();
		 nfs.close();
	 }
 }",0,0,1,0
"private final int jjMoveNfa_0(int startState, int curPos){
	 int[] nextStates;
	 int startsAt = 0;
	 jjnewStateCnt = 10;
	 int i = 1;
	 jjstateSet[0] = startState;
	 int j, kind = 0x7fffffff;
	 for (;
	;
	) {
		 if (++jjround == 0x7fffffff) ReInitRounds();
		 if (curChar < 64) {
			 long l = 1L << curChar;
			 MatchLoop: do {
				 switch(jjstateSet[--i]) {
					 case 1: case 0: if ((0x3ff004000000000L & l) == 0L) break;
					 kind = 1;
					 jjCheckNAdd(0);
					 break;
					 case 2: if (curChar == 46) jjCheckNAdd(3);
					 break;
					 case 4: if (curChar != 46) break;
					 if (kind > 2) kind = 2;
					 jjCheckNAdd(3);
					 break;
					 case 7: if (curChar == 35) kind = 1;
					 break;
					 case 8: if (curChar == 43 && kind > 1) kind = 1;
					 break;
					 case 9: if (curChar == 43) jjstateSet[jjnewStateCnt++] = 8;
					 break;
					 default : break;
				 }
			 }
			 while(i != startsAt);
		 }
		 else if (curChar < 128) {
			 long l = 1L << (curChar & 077);
			 MatchLoop: do {
				 switch(jjstateSet[--i]) {
					 case 1: if ((0x7fffffe87fffffeL & l) != 0L) {
						 if (kind > 1) kind = 1;
						 jjCheckNAdd(0);
					 }
					 if ((0x7fffffe07fffffeL & l) != 0L) jjstateSet[jjnewStateCnt++] = 2;
					 if ((0x800000008L & l) != 0L) jjAddStates(0, 1);
					 break;
					 case 0: if ((0x7fffffe87fffffeL & l) == 0L) break;
					 if (kind > 1) kind = 1;
					 jjCheckNAdd(0);
					 break;
					 case 3: if ((0x7fffffe07fffffeL & l) != 0L) jjstateSet[jjnewStateCnt++] = 4;
					 break;
					 case 6: if ((0x800000008L & l) != 0L) jjAddStates(0, 1);
					 break;
					 default : break;
				 }
			 }
			 while(i != startsAt);
		 }
		 else {
			 int hiByte = (int)(curChar >> 8);
			 int i1 = hiByte >> 6;
			 long l1 = 1L << (hiByte & 077);
			 int i2 = (curChar & 0xff) >> 6;
			 long l2 = 1L << (curChar & 077);
			 MatchLoop: do {
				 switch(jjstateSet[--i]) {
					 case 1: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
						 if (kind > 1) kind = 1;
						 jjCheckNAdd(0);
					 }
					 if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjstateSet[jjnewStateCnt++] = 2;
					 if (jjCanMove_1(hiByte, i1, i2, l1, l2)) {
						 if (kind > 3) kind = 3;
					 }
					 break;
					 case 0: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
					 if (kind > 1) kind = 1;
					 jjCheckNAdd(0);
					 break;
					 case 3: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjstateSet[jjnewStateCnt++] = 4;
					 break;
					 case 5: if (jjCanMove_1(hiByte, i1, i2, l1, l2) && kind > 3) kind = 3;
					 break;
					 default : break;
				 }
			 }
			 while(i != startsAt);
		 }
		 if (kind != 0x7fffffff) {
			 jjmatchedKind = kind;
			 jjmatchedPos = curPos;
			 kind = 0x7fffffff;
		 }
		 ++curPos;
		 if ((i = jjnewStateCnt) == (startsAt = 10 - (jjnewStateCnt = startsAt))) return curPos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return curPos;
		 }
	 }
}",0,0,1,0
"public class MIMEBindingValidator extends AbstractDefinitionValidator {
	 public MIMEBindingValidator(Definition def) {
		 super(def);
	 }
	 public boolean isValid() {
		 Collection<Binding> bindings = CastUtils.cast(def.getBindings().values());
		 for (Binding binding : bindings) {
			 Collection<BindingOperation> bindingOps = CastUtils.cast(binding.getBindingOperations());
			 for (BindingOperation bindingOperation : bindingOps) {
				 if (bindingOperation.getBindingInput() == null) {
					 continue;
				 }
				 Collection<ExtensibilityElement> exts = CastUtils.cast(bindingOperation .getBindingInput() .getExtensibilityElements());
				 for (ExtensibilityElement extElement : exts) {
					 if (extElement instanceof MIMEMultipartRelated && !doValidate((MIMEMultipartRelated)extElement, bindingOperation.getName())) {
						 return false;
					 }
				 }
			 }
		 }
		 return true;
	 }
	 private boolean doValidate(MIMEMultipartRelated mimeExt, String operationName) {
		 boolean gotRootPart = false;
		 List<MIMEPart> parts = CastUtils.cast(mimeExt.getMIMEParts());
		 for (MIMEPart mPart : parts) {
			 List<MIMEContent> mimeContents = new ArrayList<>();
			 List<ExtensibilityElement> extns = CastUtils.cast(mPart.getExtensibilityElements());
			 for (ExtensibilityElement extElement : extns) {
				 if (SOAPBindingUtil.isSOAPBody(extElement)) {
					 if (gotRootPart) {
						 addErrorMessage(""Operation("" + operationName + ""): There's more than one soap body mime part"" + "" in its binding input"");
						 return false;
					 }
					 gotRootPart = true;
				 }
				 else if (extElement instanceof MIMEContent) {
					 mimeContents.add((MIMEContent)extElement);
				 }
			 }
			 if (!doValidateMimeContentPartNames(mimeContents, operationName)) {
				 return false;
			 }
		 }
		 if (!gotRootPart) {
			 addErrorMessage(""Operation("" + operationName + ""): There's no soap body in mime part"" + "" in its binding input"");
			 return false;
		 }
		 return true;
	 }
	 private boolean doValidateMimeContentPartNames(List<MIMEContent> mimeContents, String operationName) {
		 String partName = null;
		 for (MIMEContent mimeContent : mimeContents) {
			 String mimeContnetPart = mimeContent.getPart();
			 if (mimeContnetPart == null) {
				 addErrorMessage(""Operation("" + operationName + ""): Must provide part attribute value for meme:content elements"");
				 return false;
			 }
			 if (partName == null) {
				 partName = mimeContnetPart;
			 }
			 else {
				 if (!partName.equals(mimeContnetPart)) {
					 addErrorMessage(""Operation("" + operationName + ""): Part attribute value for meme:content "" + ""elements are different"");
					 return false;
				 }
			 }
		 }
		 return true;
	 }
}",0,0,0,0
"public class SingleThreadAccessCheckingTypeSerializer<T> extends TypeSerializer<T> {
	private static final long serialVersionUID = 131020282727167064L;
	private final SingleThreadAccessChecker singleThreadAccessChecker;
	private final TypeSerializer<T> originalSerializer;
	public SingleThreadAccessCheckingTypeSerializer(TypeSerializer<T> originalSerializer) {
		this.singleThreadAccessChecker = new SingleThreadAccessChecker();
		this.originalSerializer = originalSerializer;
	}
	public boolean isImmutableType() {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.isImmutableType();
		}
	}
	public TypeSerializer<T> duplicate() {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return new SingleThreadAccessCheckingTypeSerializer<>(originalSerializer.duplicate());
		}
	}
	public T createInstance() {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.createInstance();
		}
	}
	public T copy(T from) {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.copy(from);
		}
	}
	public T copy(T from, T reuse) {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.copy(from, reuse);
		}
	}
	public int getLength() {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.getLength();
		}
	}
	public void serialize(T record, DataOutputView target) throws IOException {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			originalSerializer.serialize(record, target);
		}
	}
	public T deserialize(DataInputView source) throws IOException {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.deserialize(source);
		}
	}
	public T deserialize(T reuse, DataInputView source) throws IOException {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.deserialize(reuse, source);
		}
	}
	public void copy(DataInputView source, DataOutputView target) throws IOException {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			originalSerializer.copy(source, target);
		}
	}
	public boolean equals(Object obj) {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return obj == this ||(obj != null && obj.getClass() == getClass() &&originalSerializer.equals(obj));
		}
	}
	public int hashCode() {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return originalSerializer.hashCode();
		}
	}
	public TypeSerializerSnapshot<T> snapshotConfiguration() {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			return new SingleThreadAccessCheckingTypeSerializerSnapshot<>(this);
		}
	}
	public static class SingleThreadAccessCheckingTypeSerializerSnapshot<T>extends CompositeTypeSerializerSnapshot<T, SingleThreadAccessCheckingTypeSerializer<T>> {
		public SingleThreadAccessCheckingTypeSerializerSnapshot() {
			super((Class<SingleThreadAccessCheckingTypeSerializer<T>>) (Class<?>) SingleThreadAccessCheckingTypeSerializer.class);
		}
		SingleThreadAccessCheckingTypeSerializerSnapshot(SingleThreadAccessCheckingTypeSerializer<T> serializerInstance) {
			super(serializerInstance);
		}
		protected int getCurrentOuterSnapshotVersion() {
			return 1;
		}
		protected TypeSerializer<?>[] getNestedSerializers(SingleThreadAccessCheckingTypeSerializer<T> outerSerializer) {
			return new TypeSerializer[] {
			 outerSerializer.originalSerializer }
			;
		}
		protected SingleThreadAccessCheckingTypeSerializer<T> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {
			return new SingleThreadAccessCheckingTypeSerializer<>((TypeSerializer<T>) nestedSerializers[0]);
		}
	}
	private void writeObject(ObjectOutputStream outputStream) throws IOException {
		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {
			outputStream.defaultWriteObject();
		}
	}
	private static class SingleThreadAccessChecker implements Serializable {
		private static final long serialVersionUID = 131020282727167064L;
		private transient AtomicReference<Thread> currentThreadRef = new AtomicReference<>();
		SingleThreadAccessCheck startSingleThreadAccessCheck() {
			assert(currentThreadRef.compareAndSet(null, Thread.currentThread())) :""The checker has concurrent access from "" + currentThreadRef.get();
			return new SingleThreadAccessCheck(currentThreadRef);
		}
		private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {
			inputStream.defaultReadObject();
			currentThreadRef = new AtomicReference<>();
		}
	}
	private static class SingleThreadAccessCheck implements AutoCloseable {
		private final AtomicReference<Thread> currentThreadRef;
		private SingleThreadAccessCheck(AtomicReference<Thread> currentThreadRef) {
			this.currentThreadRef = currentThreadRef;
		}
		public void close() {
			assert(currentThreadRef.compareAndSet(Thread.currentThread(), null)) :""The checker has concurrent access from "" + currentThreadRef.get();
		}
	}
}",1,0,0,0
"public abstract class SimpleNode<T> extends LeafNode{
	 protected Value value;
	 protected byte[] bytes;
	 public static final boolean EVAL_GREATER = true;
	 public static final boolean EVAL_LESSER = false;
	 protected SimpleNode( String attribute, byte[] bytes, AssertionType assertionType ) {
		 super( attribute, assertionType );
		 this.bytes = bytes;
	 }
	 protected SimpleNode( AttributeType attributeType, byte[] bytes, AssertionType assertionType ) {
		 super( attributeType, assertionType );
		 this.bytes = bytes;
		 try {
			 if ( attributeType.isHR() ) {
				 value = new Value( attributeType, Strings.utf8ToString( bytes ) );
			 }
			 else {
				 value = new Value( attributeType, bytes );
			 }
		 }
		 catch ( LdapInvalidAttributeValueException e ) {
			 throw new RuntimeException( e.getMessage() );
		 }
	 }
	 protected SimpleNode( String attribute, String string, AssertionType assertionType ) {
		 super( attribute, assertionType );
		 bytes = Strings.getBytesUtf8( string );
		 if ( attributeType != null ) {
			 try {
				 if ( attributeType.isHR() ) {
					 value = new Value( attributeType, string );
				 }
				 else {
					 value = new Value( attributeType, bytes );
				 }
			 }
			 catch ( LdapInvalidAttributeValueException e ) {
				 throw new RuntimeException( e.getMessage() );
			 }
		 }
	 }
	 protected SimpleNode( AttributeType attributeType, Value value, AssertionType assertionType ) {
		 super( attributeType, assertionType );
		 this.value = value;
	 }
	 public ExprNode clone() {
		 ExprNode clone = super.clone();
		 if ( value != null ) {
			 ( ( SimpleNode<T> ) clone ).value = value.clone();
		 }
		 else {
			 if ( bytes != null ) {
				 ( ( SimpleNode<T> ) clone ).bytes = new byte[bytes.length];
				 System.arraycopy( bytes, 0, ( ( SimpleNode<T> ) clone ).bytes, 0, bytes.length );
			 }
		 }
		 return clone;
	 }
	 public final Value getValue() {
		 if ( value == null ) {
			 return new Value( bytes );
		 }
		 else {
			 return value;
		 }
	 }
	 public String getEscapedValue() {
		 if ( value != null ) {
			 return escapeFilterValue( value.getAttributeType(), value.getBytes() );
		 }
		 else {
			 return escapeFilterValue( null, bytes );
		 }
	 }
	 public void setValue( Value value ) {
		 this.value = value;
		 this.bytes = value.getBytes();
	 }
	 public StringBuilder printToBuffer( StringBuilder buf ) {
		 if ( ( null != getAnnotations() ) && getAnnotations().containsKey( ""count"" ) ) {
			 buf.append( "":["" );
			 buf.append( getAnnotations().get( ""count"" ).toString() );
			 buf.append( ""] "" );
		 }
		 buf.append( ')' );
		 return buf;
	 }
	 public StringBuilder printRefinementToBuffer( StringBuilder buf ) {
		 if ( isSchemaAware() ) {
			 if ( !attributeType.getOid().equals( SchemaConstants.OBJECT_CLASS_AT_OID ) ) {
				 throw new UnsupportedOperationException( I18n.err( I18n.ERR_13318_INVALID_ATTR_IN_REFINEMENT, attribute ) );
			 }
		 }
		 else {
			 if ( ( attribute == null ) || !( SchemaConstants.OBJECT_CLASS_AT.equalsIgnoreCase( attribute ) || SchemaConstants.OBJECT_CLASS_AT_OID.equalsIgnoreCase( attribute ) ) ) {
				 throw new UnsupportedOperationException( I18n.err( I18n.ERR_13318_INVALID_ATTR_IN_REFINEMENT, attribute ) );
			 }
		 }
		 buf.append( ""item: "" ).append( value );
		 return buf;
	 }
	 public int hashCode() {
		 int h = 37;
		 h = h * 17 + super.hashCode();
		 h = h * 17 + ( value == null ? 0 : value.hashCode() );
		 return h;
	 }
	 public boolean equals( Object other ) {
		 if ( this == other ) {
			 return true;
		 }
		 if ( !( other instanceof SimpleNode<?> ) ) {
			 return false;
		 }
		 if ( other.getClass() != this.getClass() ) {
			 return false;
		 }
		 if ( !super.equals( other ) ) {
			 return false;
		 }
		 SimpleNode<?> otherNode = ( SimpleNode<?> ) other;
		 if ( value == null ) {
			 if ( bytes == null ) {
				 return otherNode.bytes == null;
			 }
			 else {
				 return Arrays.equals( bytes, otherNode.bytes );
			 }
		 }
		 else {
			 return value.equals( otherNode.value );
		 }
	 }
}",0,0,0,0
"private final static class DuplicatableProgressTrackingInputStream extends ProgressTrackingInputStream implements DuplicatableInputStream {
	 private DuplicatableProgressTrackingInputStream( final InputStream source, final ProgressTracker progressTracker) {
		 super(source, progressTracker);
		 if (!(source instanceof DuplicatableInputStream)) {
			 throw new IllegalStateException(""Source MUST be a DuplicatableInputStream"");
		 }
	 }
	 public InputStream duplicate() {
		 return ProgressTrackingInputStreamFactory.create( ((DuplicatableInputStream) getSource()).duplicate(), getProgressTracker().reset());
	 }
 }",0,1,0,0
"public class SqlTimestampConverter extends AbstractConverter{
	private static final long serialVersionUID = 1L;
	private final int dateFormat;
	private final int timeFormat;
	public SqlTimestampConverter(){
		dateFormat = DateFormat.SHORT;
		timeFormat = DateFormat.SHORT;
	}
	public SqlTimestampConverter(int dateFormat){
		this.dateFormat = dateFormat;
		timeFormat = DateFormat.SHORT;
	}
	public SqlTimestampConverter(int dateFormat, int timeFormat){
		this.dateFormat = dateFormat;
		this.timeFormat = timeFormat;
	}
	public Timestamp convertToObject(final String value, Locale locale){
		if (value == null){
			return null;
		}
		if (locale == null){
			locale = Locale.getDefault();
		}
		DateFormat format = DateFormat.getDateTimeInstance(dateFormat, timeFormat, locale);
		try{
			Date date = format.parse(value);
			return new Timestamp(date.getTime());
		}
		catch (ParseException e){
			throw newConversionException(""Cannot parse '"" + value + ""' using format "" + format,value, locale);
		}
	}
	public String convertToString(final Object value, Locale locale){
		if (value == null){
			return null;
		}
		if (locale == null){
			locale = Locale.getDefault();
		}
		Timestamp timestamp = (Timestamp)value;
		DateFormat format = DateFormat.getDateTimeInstance(dateFormat, timeFormat, locale);
		return format.format(timestamp);
	}
	protected Class<Timestamp> getTargetType(){
		return Timestamp.class;
	}
}",0,0,0,0
"private void doDefensiveChecks(DistribPhase phase) {
	 boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;
	 if (isReplayOrPeersync) return;
	 String from = req.getParams().get(DISTRIB_FROM);
	 ClusterState clusterState = zkController.getClusterState();
	 DocCollection docCollection = clusterState.getCollection(collection);
	 Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());
	 boolean localIsLeader = cloudDesc.isLeader();
	 if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) {
		 String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);
		 if (fromShard != null) {
			 if (mySlice.getState() == Slice.State.ACTIVE) {
				 throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, ""Request says it is coming from parent shard leader but we are in active state"");
			 }
			 Slice fromSlice = docCollection.getSlice(fromShard);
			 DocRouter.Range parentRange = fromSlice.getRange();
			 if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);
			 if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {
				 throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, ""Request says it is coming from parent shard leader but parent hash range is not superset of my range"");
			 }
		 }
		 else {
			 String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION);
			 if (fromCollection == null) {
				 log.error(""Request says it is coming from leader, but we are the leader: "" + req.getParamString());
				 SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, ""Request says it is coming from leader, but we are the leader"");
				 solrExc.setMetadata(""cause"", ""LeaderChanged"");
				 throw solrExc;
			 }
		 }
	 }
	 int count = 0;
	 while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {
		 count++;
		 localIsLeader = cloudDesc.isLeader();
		 try {
			 Thread.sleep(500);
		 }
		 catch (InterruptedException e) {
			 Thread.currentThread().interrupt();
		 }
	 }
	 if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {
		 log.error(""ClusterState says we are the leader, but locally we don't think so"");
		 throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, ""ClusterState says we are the leader ("" + zkController.getBaseUrl() + ""/"" + req.getCore().getName() + ""), but locally we don't think so. Request came from "" + from);
	 }
 }",0,0,1,0
"public class GEMLayoutAlgorithm extends JGraphLayoutAlgorithm implements GraphModelListener {
	 public final static String KEY_CAPTION = ""GEM-TEMPORARY-DATA"";
	 public final static String KEY_TEMPERATURE = ""Temperature"";
	 public final static String KEY_CURRENT_IMPULSE = ""Current_Impulse"";
	 public final static String KEY_LAST_IMPULSE = ""Last_Impulse"";
	 public final static String KEY_POSITION = ""Position"";
	 public final static String KEY_SKEWGAUGE = ""Skew_Gauge"";
	 public final static String KEY_RELATIVES = ""Relatives"";
	 public final static String KEY_MASSINDEX = ""Mass_Index"";
	 public final static String KEY_CLUSTERED_VERTICES = ""Clustered Vertices"";
	 public final static String KEY_CLUSTER = ""Cluster"";
	 public final static String KEY_IS_CLUSTER = ""is Cluster"";
	 public final static String KEY_CLUSTER_INIT_POSITION = ""initial Position of the Cluster"";
	 private ArrayList cellList;
	 private ArrayList applyCellList;
	 private ArrayList edgeList;
	 private double equalsNull = 0.00000000000000001;
	 protected double initTemperature = 10;
	 protected double minTemperature = 3;
	 protected double maxTemperature = 256;
	 protected double prefEdgeLength = 100;
	 protected double gravitation = 0.0625;
	 protected double randomImpulseRange = 32;
	 protected double alphaOsc = Math.toRadians(90);
	 protected double alphaRot = Math.toRadians(60);
	 protected double sigmaOsc = 1.0/3.0;
	 protected double sigmaRot = 1.0/2.0;
	 private int maxRounds;
	 private int countRounds;
	 private int recursionDepth;
	 private double overlapDetectWidth;
	 private double overlapPrefDistance;
	 private boolean avoidOverlapping;
	 private String layoutUpdateMethod;
	 private boolean shouldEndPerAverage;
	 private boolean shouldComputePermutation;
	 private boolean isActive = true;
	 private boolean isRunning = false;
	 private JGraph jgraph;
	 protected Properties config;
	 protected final static int VALUES_PUR = 0;
	 protected final static int VALUES_INC = 1;
	 private AnnealingLayoutAlgorithm optimizationAlgorithm;
	 private boolean useOptimizeAlgorithm;
	 private Properties optimizationAlgorithmConfig;
	 private boolean isClusteringEnabled;
	 private double clusterInitTemperature;
	 private double clusterForceScalingFactor;
	 private double clusteringFactor;
	 private double perimeterInitSize;
	 private double perimeterSizeInc;
	 public GEMLayoutAlgorithm(AnnealingLayoutAlgorithm optimizer){
		 cellList = new ArrayList();
		 applyCellList = new ArrayList();
		 edgeList = new ArrayList();
		 optimizationAlgorithm = optimizer;
	 }
	public String toString() {
		return ""GEM"";
	}
	public String getHint() {
		return ""Ignores selection"";
	}
	public JGraphLayoutSettings createSettings() {
		return new GEMLayoutSettings(this);
	}
	 public void run(JGraph graph, Object[] dynamic_cells, Object[] static_cells) {
		 isRunning = true;
		 jgraph = graph;
		 jgraph.getModel().addGraphModelListener(this);
		 cellList = new ArrayList();
		 applyCellList = new ArrayList();
		 getNodes(jgraph, dynamic_cells);
		 boolean isCanceled = initialize();
		 if( !isCanceled ) isCanceled = calculate();
		 if( !isCanceled && useOptimizeAlgorithm ) optimizationAlgorithm.performOptimization (applyCellList, cellList, edgeList, optimizationAlgorithmConfig);
		 if( !isCanceled ) correctCoordinates();
		 if( !isCanceled ) isCanceled = setNewCoordinates(jgraph);
		 removeTemporaryLayoutDataFromCells();
		 isRunning = false;
	}
	 protected void loadRuntimeValues(int valueID){
		 maxRounds = applyCellList.size() * 4;
		 countRounds = 0;
		 isActive = isTrue((String) config.get(GEMLayoutSettings.KEY_LAYOUT_UPDATE_ENABLED));
		 recursionDepth = Integer.parseInt((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_DEPTH));
		 layoutUpdateMethod = (String) config.get(GEMLayoutSettings.KEY_LAYOUT_UPDATE_METHOD);
		 if( valueID == VALUES_PUR ){
			 initTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_INIT_TEMPERATURE));
			 minTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_MIN_TEMPERATURE));
			 maxTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_MAX_TEMPERATURE));
			 prefEdgeLength = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_PREF_EDGE_LENGTH));
			 gravitation = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_GRAVITATION));
			 randomImpulseRange = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_RANDOM_IMPULSE_RANGE));
			 overlapDetectWidth = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_OVERLAPPING_DETECTION_WIDTH));
			 overlapPrefDistance = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_OVERLAPPING_PREF_DISTANCE));
			 shouldEndPerAverage = isTrue((String)config.get( GEMLayoutSettings.KEY_COMPUTE_PERMUTATION));
			 shouldComputePermutation = isTrue((String)config.get( GEMLayoutSettings.KEY_END_CONDITION_AVERAGE));
			 avoidOverlapping = isTrue((String)config.get( GEMLayoutSettings.KEY_AVOID_OVERLAPPING));
			 alphaOsc = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_ALPHA_OSC));
			 alphaRot = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_ALPHA_ROT));
			 sigmaOsc = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_SIGMA_OSC));
			 sigmaRot = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_SIGMA_ROT));
			 useOptimizeAlgorithm = isTrue((String)config.get( GEMLayoutSettings.KEY_OPTIMIZE_ALGORITHM_ENABLED));
			 optimizationAlgorithmConfig = (Properties) config.get( GEMLayoutSettings.KEY_OPTIMIZE_ALGORITHM_CONFIG);
		 }
		 else if( valueID == VALUES_INC ){
			 initTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_INIT_TEMPERATURE));
			 minTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_MIN_TEMPERATURE));
			 maxTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_MAX_TEMPERATURE));
			 prefEdgeLength = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_PREF_EDGE_LENGTH));
			 gravitation = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_GRAVITATION));
			 randomImpulseRange = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_RANDOM_IMPULSE_RANGE));
			 overlapDetectWidth = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_OVERLAPPING_DETECTION_WIDTH));
			 overlapPrefDistance = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_OVERLAPPING_PREF_DISTANCE));
			 shouldEndPerAverage = isTrue((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION));
			 shouldComputePermutation = isTrue((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_END_CONDITION_AVERAGE));
			 avoidOverlapping = isTrue((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_AVOID_OVERLAPPING));
			 alphaOsc = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_ALPHA_OSC));
			 alphaRot = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_ALPHA_ROT));
			 sigmaOsc = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_SIGMA_OSC));
			 sigmaRot = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_SIGMA_ROT));
			 useOptimizeAlgorithm = isTrue((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_OPTIMIZE_ALGORITHM_ENABLED));
			 optimizationAlgorithmConfig = (Properties) config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_OPTIMIZE_ALGORITHM_CONFIG);
			 perimeterInitSize = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETER_INIT_SIZE));
			 perimeterSizeInc = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETER_SIZE_INC));
			 isClusteringEnabled = isTrue((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED));
			 clusterInitTemperature = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_INIT_TEMPERATURE));
			 clusterForceScalingFactor = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_FORCE_SCALING_FACTOR));
			 clusteringFactor = Double.parseDouble((String)config.get( GEMLayoutSettings.KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR));
		 }
		 sigmaRot *= 1.0 / (applyCellList.size() == 0 ? 1 : applyCellList.size());
	 }
	 protected boolean isTrue(String boolValue){
		 if( boolValue != null ){
			 if( ""TRUE"".equals(boolValue.toUpperCase()) ){
				 return true;
			 }
			 else if( ""FALSE"".equals(boolValue.toUpperCase()) ){
				 return false;
			 }
		 }
		 return false;
	 }
	 private void getNodes(JGraph jgraph, Object[] cells){
		 Object[] all = jgraph.getRoots();
		 CellView[] view = jgraph.getGraphLayoutCache().getMapping(all,false);
		 CellView[] selectedView = jgraph.getGraphLayoutCache().getMapping( cells,false);
		 for (int i = 0;
		 i < view.length;
		 i++) if (view[i] instanceof VertexView){
			 cellList.add(view[i]);
			 applyCellList.add(view[i]);
		 }
		 else if( view[i] instanceof EdgeView ){
			 edgeList.add(view[i]);
		 }
		 for( int i = 0;
		 i < selectedView.length;
		 i++ ) if( selectedView[i] instanceof VertexView ) applyCellList.add(selectedView[i]);
	 }
	 private boolean initialize(){
		 int length = cellList.size();
		 for( int i = 0;
		 i < length;
		 i++ ){
			 CellView view = (CellView) cellList.get(i);
			 initializeVertice(view);
		 }
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ) computeLastImpulse( (CellView) applyCellList.get(i) );
		 return false;
	 }
	 private void initializeVertice(CellView view){
		 Map attributes = view.getAttributes();
		 if( attributes == null ) attributes = new Hashtable();
		 attributes.put(KEY_CAPTION,KEY_CAPTION);
		 initPosition(view);
		 if( isCluster(view) ){
			 attributes.put(KEY_TEMPERATURE, new Double(clusterInitTemperature));
		 }
		 else attributes.put(KEY_TEMPERATURE, new Double(initTemperature));
		 attributes.put(KEY_SKEWGAUGE, new Double(0.0));
		 attributes.put(KEY_CURRENT_IMPULSE,new Point2D.Double());
		 attributes.put(KEY_LAST_IMPULSE ,new Point2D.Double());
	 }
	 private boolean calculate(){
		 int length = applyCellList.size();
		 int[] sequence = new int[length];
		 boolean isCanceled = false;
		 if( !shouldComputePermutation ) for( int i = 0;
		 i < length;
		 i++ ) sequence[i] = i;
		 while( !isFrozen() && countRounds <= maxRounds && (!isCanceled) ){
			 if( shouldComputePermutation ) sequence = createPermutation(length);
			 for( int i = 0;
			 i < sequence.length;
			 i++ ){
				 CellView view = (CellView) applyCellList.get(sequence[i]);
				 computeCurrentImpulse(view);
				 updatePosAndTemp(view);
			 }
			 countRounds++;
		 }
		 return false;
	 }
	 private void computeCurrentImpulse(CellView view){
		 Point2D.Double impulse = computeImpulse(view);
		 view.getAttributes().put(KEY_CURRENT_IMPULSE,impulse);
	 }
	 private void computeLastImpulse(CellView view){
		 Point2D.Double impulse = computeImpulse(view);
		 view.getAttributes().put(KEY_LAST_IMPULSE,impulse);
	 }
	 private Point2D.Double computeImpulse(CellView view){
		 Point2D.Double impulse = new Point2D.Double();
		 Point2D.Double pos = getPosition(view);
		 double massIndex = getNodeWeight(view);
		 Point2D.Double barycenter = computeBarycenter(cellList);
		 Point2D.Double gravitationForce = new Point2D.Double( (barycenter.getX() - pos.getX()) * gravitation * massIndex, (barycenter.getY() - pos.getY()) * gravitation * massIndex);
		 Point2D.Double randomImpulse = getRandomVector(randomImpulseRange);
		 ArrayList repulsiveForce = new ArrayList();
		 for( int i = 0 ;
		 i < cellList.size();
		 i++ ) if( cellList.get(i) != view ){
			 Point2D.Double uPos = getPosition(i,cellList);
			 double deltaX = (pos.getX() - uPos.getX());
			 double deltaY = (pos.getY() - uPos.getY());
			 double absDelta = MathExtensions.abs(deltaX,deltaY);
			 if( absDelta > equalsNull ){
				 repulsiveForce.add(new Point2D.Double( deltaX * ((prefEdgeLength * prefEdgeLength) / (absDelta * absDelta)), deltaY * ((prefEdgeLength * prefEdgeLength) / (absDelta * absDelta))));
			 }
		 }
		 ArrayList relatives = getRelativesFrom(cellList,view);
		 ArrayList attractiveForce = new ArrayList(relatives.size());
		 for( int i = 0;
		 i < relatives.size();
		 i++ ){
			 Point2D.Double cPos = getPosition(i,relatives);
			 double deltaX = (pos.getX() - cPos.getX());
			 double deltaY = (pos.getY() - cPos.getY());
			 double absDelta = MathExtensions.abs(deltaX,deltaY);
			 attractiveForce.add(new Point2D.Double( deltaX * (( absDelta * absDelta ) / ( prefEdgeLength * prefEdgeLength * massIndex )), deltaY * (( absDelta * absDelta ) / ( prefEdgeLength * prefEdgeLength * massIndex ))));
		 }
		 ArrayList forcesByOverlapping = new ArrayList();
		 if( avoidOverlapping ){
			 Rectangle viewBounds = new Rectangle( (int)pos.x, (int)pos.y, (int)view.getBounds().getWidth(), (int)view.getBounds().getHeight());
			 Rectangle viewBorder = new Rectangle( (int)(viewBounds.getX()-overlapDetectWidth), (int)(viewBounds.getY()-overlapDetectWidth), (int)(viewBounds.getWidth()+(2.0*overlapDetectWidth)), (int)(viewBounds.getHeight()+(2.0*overlapDetectWidth)));
			 for( int i = 0;
			 i < cellList.size();
			 i++ ){
				 Point2D.Double uPos = getPosition(i,cellList);
				 Rectangle uBounds = new Rectangle( (int)uPos.x, (int)uPos.y, (int)((CellView)cellList.get(i)).getBounds().getWidth(), (int)((CellView)cellList.get(i)).getBounds().getHeight());
				 if( view != cellList.get(i) && viewBorder.intersects(uBounds) ){
					 Dimension viewSize = viewBounds.getSize();
					 Dimension uSize = uBounds.getSize();
					 double minDistance = (Math.max(viewSize.getWidth(),viewSize.getHeight())/2.0)+ (Math.max(uSize.getWidth(),uSize.getHeight())/2.0)+overlapPrefDistance;
					 double deltaX = (pos.x - uPos.x);
					 double deltaY = (pos.y - uPos.y);
					 if( deltaX < equalsNull && deltaX >= 0.0 ){
						 deltaX = equalsNull;
					 }
					 else if( deltaX > -equalsNull && deltaX <= 0.0 ){
						 deltaX = -equalsNull;
					 }
					 if( deltaY < equalsNull && deltaY >= 0.0 ){
						 deltaY = equalsNull;
					 }
					 else if( deltaY > -equalsNull && deltaY <= 0.0 ){
						 deltaY = -equalsNull;
					 }
					 double absDelta = MathExtensions.abs(deltaX,deltaY);
					 Point2D.Double force = new Point2D.Double( deltaX*(minDistance*minDistance)/(absDelta*absDelta), deltaY*(minDistance*minDistance)/(absDelta*absDelta));
					 forcesByOverlapping.add(force);
				 }
			 }
		 }
		 ArrayList additionalForce = new ArrayList();
		 impulse = add(impulse,gravitationForce);
		 impulse = add(impulse,randomImpulse);
		 for( int i = 0;
		 i < repulsiveForce.size();
		 i++ ) impulse = add(impulse,(Point2D.Double) repulsiveForce.get(i) );
		 for( int i = 0;
		 i < attractiveForce.size();
		 i++ ) impulse = sub(impulse,(Point2D.Double) attractiveForce.get(i) );
		 for( int i = 0;
		 i < forcesByOverlapping.size();
		 i++ ) impulse = add(impulse,(Point2D.Double) forcesByOverlapping.get(i));
		 for( int i = 0;
		 i < additionalForce.size();
		 i++ ) impulse = add(impulse,(Point2D.Double) additionalForce.get(i) );
		 return impulse;
	 }
	 private void updatePosAndTemp(CellView view){
		 Point2D.Double impulse = (Point2D.Double) view.getAttributes().get(KEY_CURRENT_IMPULSE);
		 Point2D.Double lastImpulse = (Point2D.Double) view.getAttributes().get(KEY_LAST_IMPULSE);
		 Point2D.Double position = getPosition(view);
		 double localTemperature = ((Double) view.getAttributes().get(KEY_TEMPERATURE)).doubleValue();
		 double skewGauge = ((Double) view.getAttributes().get(KEY_SKEWGAUGE)).doubleValue();
		 double absImpulse = MathExtensions.abs(impulse);
		 double absLastImpulse = MathExtensions.abs(lastImpulse);
		 if( absImpulse > equalsNull ){
			 if( isCluster(view) ){
				 impulse.setLocation( impulse.getX() * localTemperature * clusterForceScalingFactor / absImpulse, impulse.getY() * localTemperature * clusterForceScalingFactor / absImpulse);
			 }
			 else {
				 impulse.setLocation( impulse.getX() * localTemperature / absImpulse, impulse.getY() * localTemperature / absImpulse);
			 }
			 view.getAttributes().put(KEY_CURRENT_IMPULSE,impulse);
			 position.setLocation(position.getX()+impulse.getX(), position.getY()+impulse.getY());
			 view.getAttributes().put(KEY_POSITION,position);
		 }
		 if( absLastImpulse > equalsNull ){
			 double beta = MathExtensions.angleBetween(impulse,lastImpulse);
			 double sinBeta = Math.sin(beta);
			 double cosBeta = Math.cos(beta);
			 if( Math.abs(sinBeta) >= Math.sin((Math.PI/2.0)+(alphaRot/2.0)) ) skewGauge += sigmaRot * MathExtensions.sgn(sinBeta);
			 if( cosBeta < Math.cos(Math.PI+(alphaOsc/2.0)) ) localTemperature *= sigmaOsc * Math.abs(cosBeta);
			 localTemperature *= 1.0 - Math.abs(skewGauge);
			 localTemperature = Math.min(localTemperature,maxTemperature);
		 }
		 view.getAttributes().put(KEY_TEMPERATURE,new Double(localTemperature));
		 view.getAttributes().put(KEY_POSITION ,position);
		 view.getAttributes().put(KEY_SKEWGAUGE ,new Double(skewGauge));
		 view.getAttributes().put(KEY_LAST_IMPULSE,new Point2D.Double( impulse.getX(), impulse.getY()));
	 }
	 private Point2D.Double add(Point2D.Double v1, Point2D.Double v2){
		 return new Point2D.Double(v1.getX()+v2.getX(),v1.getY()+v2.getY());
	 }
	 private Point2D.Double sub(Point2D.Double v1, Point2D.Double v2){
		 return new Point2D.Double(v1.getX()-v2.getX(),v1.getY()-v2.getY());
	 }
	 private ArrayList getRelativesFrom(ArrayList list, CellView view){
		 ArrayList relatives = getRelatives(view);
		 ArrayList result = new ArrayList();
		 for( int i = 0;
		 i < relatives.size();
		 i++ ) if( list.contains(relatives.get(i)) ) result.add(relatives.get(i));
		 return result;
	 }
	 private ArrayList getRelatives(CellView view){
		 if( !(view instanceof VertexView) ) {
			 new Exception(""getRelatives 1"").printStackTrace();
			 return null;
		 }
		 if( view.getAttributes().containsKey(KEY_RELATIVES) ) return (ArrayList) view.getAttributes().get(KEY_RELATIVES);
		 ArrayList relatives = new ArrayList();
		 if( isCluster(view) ){
			 ArrayList clusteredVertices = (ArrayList) view.getAttributes().get(KEY_CLUSTERED_VERTICES);
			 for( int i = 0;
			 i < clusteredVertices.size();
			 i++ ){
				 ArrayList vertexRelatives = getRelatives( (CellView)clusteredVertices.get(i));
				 for( int j = 0;
				 j < vertexRelatives.size();
				 j++ ){
					 CellView relative = (CellView) vertexRelatives.get(j);
					 if( !clusteredVertices.contains(relative) ){
						 if( !relatives.contains(relative)) relatives.add(relative);
					 }
				 }
			 }
		 }
		 else {
			 ArrayList portsCells = new ArrayList();
			 VertexView vertexView = (VertexView)view;
			 GraphModel model = jgraph.getModel();
			 CellMapper mapper = jgraph.getGraphLayoutCache() ;
			 Object vertexCell = vertexView.getCell() ;
			 for (int i = 0;
			 i < model.getChildCount(vertexCell);
			 i++){
				 Object portCell = model.getChild(vertexCell, i);
				 portsCells.add(portCell);
			 }
			 for( int i = 0;
			 i < portsCells.size() ;
			 i++ ){
				 Object portCell = portsCells.get(i);
				 Iterator edges = model.edges(portCell);
				 while (edges.hasNext() ){
					 Object edge = edges.next() ;
					 Object nextPort = null;
					 if( model.getSource(edge) != portCell ){
						 nextPort = model.getSource(edge);
					 }
					 else {
						 nextPort = model.getTarget(edge);
					 }
					 CellView nextVertex = mapper.getMapping( model.getParent(nextPort), true);
					 relatives.add(nextVertex);
				 }
			 }
		 }
		 view.getAttributes().put(KEY_RELATIVES,relatives);
		 return relatives;
	 }
	 private double getNodeWeight(CellView view){
		 if( view.getAttributes().containsKey(KEY_MASSINDEX) ) return ((Double)view.getAttributes().get(KEY_MASSINDEX)). doubleValue();
		 int childCount = getRelatives(view).size();
		 double massIndex = (childCount + 1) / 2.0;
		 view.getAttributes().put(KEY_MASSINDEX,new Double(massIndex));
		 return massIndex;
	 }
	 private boolean setNewCoordinates(JGraph jgraph){
		 Map viewMap = new Hashtable();
		 for( int i = 0;
		 i < cellList.size();
		 i++ ){
			 Point2D.Double pos = getPosition(i,cellList);
			 Rectangle2D r = ((CellView)cellList.get(i)).getBounds();
			 r.setFrame(pos.getX() - (r.getWidth() /2.0), pos.getY() - (r.getHeight()/2.0), r.getWidth(), r.getHeight());
			 Object cell = ((CellView) cellList.get(i)).getCell();
			Map map = new Hashtable();
			 GraphConstants.setBounds(map, r);
			 viewMap.put(cell, map);
		 }
		 jgraph.getGraphLayoutCache().edit(viewMap,null,null,null);
		 return false;
	 }
	 private void removeTemporaryLayoutDataFromCells(){
		 for( int i = 0;
		 i < cellList.size();
		 i++ ) ((CellView)cellList.get(i)).getAttributes().clear();
	 }
	 private boolean isFrozen(){
		 double sumOfTemp = 0.0;
		 double globalTemp = 0.0;
		 boolean isFrozen = true;
		 for( int i = 0;
		 i < applyCellList.size();
		 i++ ){
			 double temperature = getTemperature(i,applyCellList);
			 sumOfTemp += temperature;
			 isFrozen = isFrozen && (temperature <= minTemperature);
			 if( !isFrozen && !shouldEndPerAverage ) break;
		 }
		 if( shouldEndPerAverage ){
			 globalTemp = sumOfTemp / applyCellList.size();
			 return globalTemp < minTemperature;
		 }
		 else return isFrozen;
	 }
	 private int[] createPermutation(int length){
		 int[] permutation = new int[length];
		 for( int i = 0;
		 i < permutation.length;
		 i++ ){
			 int newValue = (int)(Math.random()*length);
			 for( int j = 0;
			 j < i;
			 j++ ) if( newValue == permutation[j] ){
				 newValue = (int)(Math.random()*length);
				 j = -1;
			 }
			 permutation[i] = newValue;
		 }
		 return permutation;
	 }
	 private Point2D.Double getRandomVector(double length){
		 double alpha = Math.random()*Math.PI*2;
		 return new Point2D.Double(length*Math.cos(alpha), length*Math.sin(alpha));
	 }
	 private Point2D.Double computeBarycenter(ArrayList list){
		 double sumX = 0.0;
		 double sumY = 0.0;
		 for( int i = 0;
		 i < list.size();
		 i++ ){
			 CellView view = (CellView) list.get(i);
			 initPosition(view);
			 Point2D.Double pos = getPosition(view);
			 sumX += pos.x;
			 sumY += pos.y;
		 }
		 return new Point2D.Double(sumX/(list.size()), sumY/(list.size()));
	 }
	 private void initPosition(CellView view){
		 if( !view.getAttributes().containsKey(KEY_POSITION) ) view.getAttributes().put(KEY_POSITION,new Point2D.Double( view.getBounds().getCenterX(), view.getBounds().getCenterY()));
	 }
	 private void correctCoordinates(){
		 Rectangle boundingBox = getBoundingBox();
		 if( boundingBox != null ){
			 for( int i = 0;
			 i < cellList.size();
			 i++ ){
				 CellView view = (CellView) cellList.get(i);
				 Point2D.Double pos = getPosition(view);
				 Point2D.Double topLeftCorner = new Point2D.Double (pos.x + (view.getBounds().getWidth())/2, pos.y + (view.getBounds().getHeight())/2);
				 Point2D.Double newPos = new Point2D.Double( topLeftCorner.x-boundingBox.getX(), topLeftCorner.y-boundingBox.getY());
				 view.getAttributes().put(KEY_POSITION,newPos);
			 }
		 }
	 }
	 private Rectangle getBoundingBox(){
		 return getBoundingBox(cellList);
	 }
	 private Rectangle getBoundingBox(ArrayList verticeList){
		 if( verticeList.size() > 0 ){
			 Point2D.Double vertexPos = getPosition(0,verticeList);
			 Rectangle2D vertexSize = ((CellView)verticeList.get(0)).getBounds();
			 double minX = vertexPos.getX();
			 double minY = vertexPos.getY();
			 double maxX = vertexPos.getX()+vertexSize.getWidth();
			 double maxY = vertexPos.getY()+vertexSize.getHeight();
			 for( int i = 1;
			 i < verticeList.size();
			 i++ ){
				 vertexPos = getPosition(i,verticeList);
				 vertexSize =((CellView)verticeList.get(i)).getBounds();
				 if( minX > vertexPos.getX() ) minX = vertexPos.getX();
				 if( minY > vertexPos.getY() ) minY = vertexPos.getY();
				 if( maxX < vertexPos.getX()+vertexSize.getWidth() ) maxX = vertexPos.getX()+vertexSize.getWidth();
				 if( maxY < vertexPos.getY()+vertexSize.getHeight() ) maxY = vertexPos.getY()+vertexSize.getHeight();
			 }
			 Rectangle boundingBox = new Rectangle((int)minX, (int)minY, (int)(maxX-minX), (int)(maxY-minY));
			 return boundingBox;
		 }
		 return null;
	 }
	 private Point2D.Double getPosition(int index, ArrayList list){
		 return (Point2D.Double) getAttribute(index,KEY_POSITION,list);
	 }
	 private double getTemperature(int index, ArrayList list){
		 Double temperature = (Double) getAttribute(index,KEY_TEMPERATURE,list);
		 return temperature.doubleValue();
	 }
	 private Point2D.Double getPosition(CellView cell){
		 return (Point2D.Double) cell.getAttributes().get(KEY_POSITION);
	 }
	 private Object getAttribute(int index, String key, ArrayList list){
		 CellView view = (CellView) list.get(index);
		 return view.getAttributes().get(key);
	 }
	 private void arrangePlacement(CellView[] views){
		 for( int i = 0;
		 i < cellList.size();
		 i++ ) initPosition((CellView)cellList.get(i));
		 if( views != null ){
			 if( views.length > 0 ){
				 ArrayList cellLevelList = new ArrayList();
				 for( int i = 0;
				 i < views.length;
				 i++ ){
					 if( views[i] instanceof VertexView ){
						 ArrayList relatives = getRelativesFrom(cellList, views[i]);
						 if( relatives.size() > 0 ){
							 if( views[i].getAttributes() == null ) views[i].changeAttributes(new AttributeMap());
							 views[i].getAttributes().put(KEY_POSITION, computeBarycenter(relatives));
							 cellLevelList.add(views[i]);
						 }
					 }
				 }
				 for( int i = 0;
				 i < cellLevelList.size();
				 i++ ) cellList.add(cellLevelList.get(i));
				 int childViewCount = 0;
				 CellView[] possibleChildViews = new CellView[views.length-cellLevelList.size()];
				 for( int i = 0;
				 i < views.length;
				 i++ ) if( !cellLevelList.contains(views[i]) ) possibleChildViews[childViewCount++] = views[i];
				 arrangePlacement(possibleChildViews);
			 }
		 }
	 }
	 public void addApplyableVertices(VertexView[] vertexList){
		 for( int i = 0;
		 i < vertexList.length;
		 i++ ){
			 if( !applyCellList.contains(vertexList[i]) ) applyCellList.add(vertexList[i]);
			 if( !cellList.contains(vertexList[i]) ) cellList.add(vertexList[i]);
		 }
		 if( GEMLayoutSettings.KEY_LAYOUT_UPDATE_METHOD_PERIMETERS.equals(layoutUpdateMethod) ){
			 for( int i = 0;
			 i < vertexList.length;
			 i++ ){
				 double perimeterSize = perimeterInitSize;
				 Point2D.Double pos = getPosition(vertexList[i]);
				 for( int j = 0;
				 j < vertexList.length;
				 j++ ){
					 if( i != j ){
						 Point2D.Double oPos = getPosition(vertexList[j]);
						 if( Math.abs(pos.distance(oPos)) < (perimeterInitSize / 2.0) ) perimeterSize += perimeterSizeInc;
					 }
				 }
				 for( int j = 0;
				 j < cellList.size();
				 j++ ){
					 Point2D.Double uPos = getPosition(j,cellList);
					 if( Math.abs(pos.distance(uPos)) < (perimeterSize / 2.0) && !applyCellList.contains(cellList.get(j)) ) applyCellList.add(cellList.get(j));
				 }
			 }
			 vertexList = new VertexView[applyCellList.size()];
			 for( int i = 0;
			 i < applyCellList.size();
			 i++ ) vertexList[i] = (VertexView) applyCellList.get(i);
		 }
		 if( recursionDepth > 0 ) addRelativesToList(vertexList,recursionDepth);
	 }
	 private void addRelativesToList(VertexView[] vertexList, int depth){
		 if( vertexList == null ) return;
		 if( vertexList.length == 0 ) return;
		 if( depth == 0 ) return;
		 for( int i = 0;
		 i < vertexList.length;
		 i++ ){
			 ArrayList relatives = getRelatives(vertexList[i]);
			 VertexView[] relativeList = new VertexView[relatives.size()];
			 for( int j = 0;
			 j < relatives.size();
			 j++ ){
				 if( !applyCellList.contains(relatives.get(j)) ) applyCellList.add(relatives.get(j));
				 if( !cellList.contains(relatives.get(j)) ) cellList.add(relatives.get(j));
				 relativeList[j] = (VertexView) relatives.get(j);
			 }
			 addRelativesToList(relativeList,depth-1);
		 }
	 }
	 public void graphChanged(GraphModelEvent e){
		 if( !isRunning && isActive ){
			 isRunning = true;
			 GraphModelEvent.GraphModelChange change = e.getChange();
			 Object[] objRem = change.getRemoved();
			 Object[] objIns = change.getInserted();
			 if( objRem == null && objIns != null ){
				 for( int i = 0;
				 i < cellList.size();
				 i++ ) initPosition((CellView)cellList.get(i));
				 CellView[] viewInserted = jgraph.getGraphLayoutCache().getMapping(objIns,false);
				 applyCellList = new ArrayList();
				 int vertexViewCount = 0;
				 for( int i = 0;
				 i < viewInserted.length;
				 i++ ) if( viewInserted[i] instanceof VertexView ) vertexViewCount++;
				 VertexView[] vertexList = new VertexView[vertexViewCount];
				 vertexViewCount = 0;
				 for( int i = 0;
				 i < viewInserted.length;
				 i++ ) if( viewInserted[i] instanceof VertexView ) vertexList[vertexViewCount++] = (VertexView) viewInserted[i];
				 if( vertexList.length == 0 ){
					 isRunning = false;
					 return;
				 }
				 loadRuntimeValues(VALUES_INC);
				 sigmaRot /= 1.0 / applyCellList.size();
				 arrangePlacement(vertexList);
				 addApplyableVertices(vertexList);
				 if( applyCellList.size() == 0 ){
					 isRunning = false;
					 return;
				 }
				 if( isClusteringEnabled ){
					 clusterGraph();
				 }
				 sigmaRot *= 1.0 / applyCellList.size();
				 maxRounds = applyCellList.size() * 4;
				 initialize();
				 calculate();
				 if( isClusteringEnabled ) declusterGraph();
				 if( useOptimizeAlgorithm ) optimizationAlgorithm.run(jgraph, jgraph.getRoots(),null);
				 correctCoordinates();
				 setNewCoordinates(jgraph);
				 removeTemporaryLayoutDataFromCells();
			 }
			 else if( objRem != null && objIns == null ){
				 CellView[] viewRemoved = jgraph.getGraphLayoutCache().getMapping(objRem,false);
				 for( int i = 0;
				 i < viewRemoved.length;
				 i++ ){
					 if( viewRemoved[i] instanceof VertexView && cellList.contains(viewRemoved[i]) ){
						 applyCellList.remove(viewRemoved[i]);
						 cellList.remove(viewRemoved[i]);
					 }
				 }
			 }
			 isRunning = false;
		 }
	 }
	 protected void clusterGraph(){
		 int maxClusters = (int)((cellList.size() - applyCellList.size()) / clusteringFactor );
		 if( maxClusters == 0 ){
			 System.out.println(""maxClusters = 0"");
			 return;
		 }
		 if( cellList.size() <= 1 ){
			 System.out.println(""cellList.size() <= 1"");
			 return;
		 }
		 ArrayList clusterList = new ArrayList();
		 ArrayList cellsToCluster = new ArrayList();
		 for( int i = 0;
		 i < cellList.size();
		 i++ ) if( !applyCellList.contains(cellList.get(i)) ) cellsToCluster.add(cellList.get(i));
		 VertexView[] clusters = new VertexView[maxClusters];
		 Rectangle boundingBox = getBoundingBox();
		 for( int i = 0;
		 i < clusters.length;
		 i++ ){
			 clusters[i] = new VertexView(null);
			 Map attributes = clusters[i].getAttributes();
			 attributes.put(KEY_IS_CLUSTER,""true"");
			 attributes.put(KEY_POSITION,new Point2D.Double( Math.random()*boundingBox.width, Math.random()*boundingBox.height));
			 clusterList.add(clusters[i]);
		 }
		 for( int i = 0;
		 i < cellsToCluster.size();
		 i++ ){
			 VertexView cell = (VertexView) cellsToCluster.get(i);
			 Point2D.Double cellPos = getPosition(cell);
			 int clusterID = 0;
			 Point2D.Double clusterPos = getPosition((CellView)clusterList.get(0));
			 double minDistance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
			 for( int j = 1;
			 j < clusterList.size();
			 j++ ){
				 clusterPos = getPosition(j,clusterList);
				 double distance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
				 if( minDistance > distance ){
					 minDistance = distance;
					 clusterID = j;
				 }
			 }
			 VertexView cluster = (VertexView) clusterList.get(clusterID);
			 moveVerticeToCluster(cell,cluster);
		 }
		 boolean couldMakeItBetter = false;
		 do {
			 couldMakeItBetter = false;
			 for( int i = 0;
			 i < cellsToCluster.size();
			 i++ ){
				 VertexView cell = (VertexView) cellsToCluster.get(i);
				 VertexView oldCluster = (VertexView) cell.getAttributes().get(KEY_CLUSTER);
				 Point2D.Double cellPos = getPosition(cell);
				 Point2D.Double clusterPos = getPosition(oldCluster);
				 double distance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
				 for( int j = 0;
				 j < clusterList.size();
				 j++ ){
					 VertexView cluster = (VertexView) clusterList.get(j);
					 if( cluster != oldCluster ){
						 clusterPos = getPosition(cluster);
						 double newDistance = MathExtensions.getEuclideanDistance(cellPos,clusterPos);
						 if( newDistance < distance ){
							 moveVerticeToCluster(cell,cluster);
							 couldMakeItBetter = true;
							 break;
						 }
					 }
				 }
			 }
		 }
		 while( couldMakeItBetter );
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 if( !((VertexView)clusterList.get(i)).getAttributes().containsKey(KEY_CLUSTERED_VERTICES)){
				 clusterList.remove(i--);
			 }
			 else if( ((ArrayList)((VertexView)clusterList.get(i)).getAttributes().get(KEY_CLUSTERED_VERTICES)).size() == 0 ){
				 clusterList.remove(i--);
			 }
		 }
		 for( int i = 0;
		 i < cellsToCluster.size();
		 i++ ) cellList.remove(cellsToCluster.get(i));
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 applyCellList.add(clusterList.get(i));
			 cellList.add(clusterList.get(i));
		 }
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 VertexView cluster = (VertexView) clusterList.get(i);
			 Map attribs = cluster.getAttributes();
			 Point2D.Double clusterPos = (Point2D.Double) attribs.get(KEY_POSITION);
			 attribs.put(KEY_CLUSTER_INIT_POSITION, new Point2D.Double( clusterPos.x, clusterPos.y));
		 }
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 VertexView cluster = (VertexView)clusterList.get(i);
			 cluster.setCachedBounds(getBoundingBox((ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES)));
		 }
		 colorizeClusters(clusterList);
		 stop(20);
	 }
	 protected void moveVerticeToCluster(VertexView vertice, VertexView cluster){
		 if( !cluster.getAttributes().containsKey(KEY_CLUSTERED_VERTICES) ) cluster.getAttributes().put(KEY_CLUSTERED_VERTICES,new ArrayList());
		 ArrayList clusteredVertices = (ArrayList) cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
		 clusteredVertices.add(vertice);
		 if( vertice.getAttributes().containsKey(KEY_CLUSTER) ){
			 VertexView oldCluster = (VertexView) vertice.getAttributes().get(KEY_CLUSTER);
			 ArrayList list = (ArrayList)oldCluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
			 list.remove(vertice);
			 computeClusterPosition(oldCluster);
		 }
		 vertice.getAttributes().put(KEY_CLUSTER,cluster);
		 computeClusterPosition(cluster);
	 }
	 protected void computeClusterPosition(VertexView cluster){
		 ArrayList clusteredVertices = (ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
		 Point2D.Double clusterPos = computeBarycenter(clusteredVertices);
		 cluster.getAttributes().put(KEY_POSITION,clusterPos);
	 }
	 protected void declusterGraph(){
		 if( cellList.size() <= 1 ) return;
		 ArrayList clusterList = new ArrayList();
		 for( int i = 0;
		 i < cellList.size();
		 i++ ){
			 VertexView cell = ((VertexView)cellList.get(i));
			 if( isCluster(cell) ) clusterList.add(cell);
		 }
		 if( clusterList.size() == 0 ) return;
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 cellList.remove(clusterList.get(i));
			 applyCellList.remove(clusterList.get(i));
		 }
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ){
			 VertexView cluster = (VertexView)clusterList.get(i);
			 Map attribs = cluster.getAttributes();
			 Point2D.Double newClusterPos = getPosition(cluster);
			 Point2D.Double oldClusterPos = (Point2D.Double) attribs.get(KEY_CLUSTER_INIT_POSITION);
			 Point2D.Double move = new Point2D.Double(newClusterPos.x - oldClusterPos.x, newClusterPos.y - oldClusterPos.y);
			 ArrayList vertexList = (ArrayList)attribs.get(KEY_CLUSTERED_VERTICES);
			 for( int j = 0;
			 j < vertexList.size();
			 j++ ){
				 VertexView cell = (VertexView) vertexList.get(j);
				 Point2D.Double cellPos = getPosition(cell);
				 Point2D.Double newCellPos = new Point2D.Double(cellPos.x + move.x, cellPos.y + move.y);
				 cell.getAttributes().put(KEY_POSITION,newCellPos);
				 cellList.add(cell);
			 }
		 }
	 }
	 protected boolean isCluster(CellView cell){
		 if( cell.getAttributes().containsKey(KEY_IS_CLUSTER)){
			 if( isTrue((String)cell.getAttributes().get(KEY_IS_CLUSTER))){
				 return true;
			 }
			 else {
				 System.err.println(""FATAL ERROR: CELL CANNOT CLEARLY BE IDENTIFIED AS A CLUSTER!!!"");
				 return false;
			 }
		 }
		 else return false;
	 }
	 private void colorizeClusters(ArrayList clusterList){
		 Color[] colorList = new Color[] {
		 Color.black, Color.magenta, Color.yellow, Color.blue, Color.green, Color.gray, Color.cyan, Color.red, Color.darkGray, Color.lightGray, Color.orange, Color.pink }
		;
		 for( int i = 0;
		 i < clusterList.size();
		 i++ ) if( i < colorList.length ){
			 ArrayList clusteredVertices = (ArrayList) ((CellView)clusterList.get(i)).getAttributes().get(KEY_CLUSTERED_VERTICES);
			 showCellList(clusteredVertices,colorList[i]);
		 }
	 }
	 private void showCellList(ArrayList list, Color color){
		 Map viewMap = new Hashtable();
		 for( int i = 0;
		 i < list.size();
		 i++ ){
			 CellView view = (CellView)list.get(i);
			 Point2D.Double pos = getPosition(i,list);
			 Rectangle2D r = view.getBounds();
			 r.setFrame(pos.getX() - r.getWidth() /2.0, pos.getY() - r.getHeight()/2.0, r.getWidth(), r.getHeight());
			 Object cell = view.getCell();
			 Map attributes = new Hashtable();
			 GraphConstants.setBackground(attributes, color);
			 GraphConstants.setBounds (attributes, r);
			 viewMap.put(cell, attributes);
		 }
		 jgraph.getGraphLayoutCache().edit(viewMap,null,null,null);
	 }
	 private synchronized void stop(double sec){
		 try{
			 wait((long)(sec * 1000.0));
		 }
		 catch( Exception e ){
			 e.printStackTrace();
		 }
	 }
	 private void stop(int sec){
		 stop((double)sec);
	 }
	public AnnealingLayoutAlgorithm getOptimizationAlgorithm() {
		return optimizationAlgorithm;
	}
	public Properties getConfig() {
		return config;
	}
	public void setConfig(Properties configuration) {
		this.config = configuration;
		 loadRuntimeValues(VALUES_PUR);
	}
}",1,0,0,0
"public long awaitNanos(long nanosTimeout) throws InterruptedException {
	 throw new UnsupportedOperationException();
 }",0,0,0,0
"private int run(String[] args) throws LaunchException, MalformedURLException {
	 String antHomeProperty = System.getProperty(ANTHOME_PROPERTY);
	 File antHome = null;
	 File sourceJar = Locator.getClassSource(getClass());
	 File jarDir = sourceJar.getParentFile();
	 String mainClassname = MAIN_CLASS;
	 if (antHomeProperty != null) {
		 antHome = new File(antHomeProperty);
	 }
	 if (antHome == null || !antHome.exists()) {
		 antHome = jarDir.getParentFile();
		 setProperty(ANTHOME_PROPERTY, antHome.getAbsolutePath());
	 }
	 if (!antHome.exists()) {
		 throw new LaunchException(""Ant home is set incorrectly or "" + ""ant could not be located (estimated value=""+antHome.getAbsolutePath()+"")"");
	 }
	 List libPaths = new ArrayList();
	 String cpString = null;
	 List argList = new ArrayList();
	 String[] newArgs;
	 boolean noUserLib = false;
	 boolean noClassPath = false;
	 for (int i = 0;
	 i < args.length;
	 ++i) {
		 if (args[i].equals(""-lib"")) {
			 if (i == args.length - 1) {
				 throw new LaunchException(""The -lib argument must "" + ""be followed by a library location"");
			 }
			 libPaths.add(args[++i]);
		 }
		 else if (args[i].equals(""-cp"")) {
			 if (i == args.length - 1) {
				 throw new LaunchException(""The -cp argument must "" + ""be followed by a classpath expression"");
			 }
			 if (cpString != null) {
				 throw new LaunchException(""The -cp argument must "" + ""not be repeated"");
			 }
			 cpString = args[++i];
		 }
		 else if (args[i].equals(""--nouserlib"") || args[i].equals(""-nouserlib"")) {
			 noUserLib = true;
		 }
		 else if (args[i].equals(""--launchdiag"")) {
			 launchDiag = true;
		 }
		 else if (args[i].equals(""--noclasspath"") || args[i].equals(""-noclasspath"")) {
			 noClassPath = true;
		 }
		 else if (args[i].equals(""-main"")) {
			 if (i == args.length - 1) {
				 throw new LaunchException(""The -main argument must "" + ""be followed by a library location"");
			 }
			 mainClassname = args[++i];
		 }
		 else {
			 argList.add(args[i]);
		 }
	 }
	 logPath(""Launcher JAR"",sourceJar);
	 logPath(""Launcher JAR directory"", sourceJar.getParentFile());
	 logPath(""java.home"", new File(System.getProperty(""java.home"")));
	 if (argList.size() == args.length) {
		 newArgs = args;
	 }
	 else {
		 newArgs = (String[]) argList.toArray(new String[argList.size()]);
	 }
	 URL[] libURLs = getLibPathURLs( noClassPath ? null : cpString, libPaths);
	 URL[] systemURLs = getSystemURLs(jarDir);
	 URL[] userURLs = noUserLib ? new URL[0] : getUserURLs();
	 File toolsJAR = Locator.getToolsJar();
	 logPath(""tools.jar"",toolsJAR);
	 URL[] jars = getJarArray( libURLs, userURLs, systemURLs, toolsJAR);
	 StringBuffer baseClassPath = new StringBuffer(System.getProperty(JAVA_CLASS_PATH));
	 if (baseClassPath.charAt(baseClassPath.length() - 1) == File.pathSeparatorChar) {
		 baseClassPath.setLength(baseClassPath.length() - 1);
	 }
	 for (int i = 0;
	 i < jars.length;
	 ++i) {
		 baseClassPath.append(File.pathSeparatorChar);
		 baseClassPath.append(Locator.fromURI(jars[i].toString()));
	 }
	 setProperty(JAVA_CLASS_PATH, baseClassPath.toString());
	 URLClassLoader loader = new URLClassLoader(jars, Launcher.class.getClassLoader());
	 Thread.currentThread().setContextClassLoader(loader);
	 Class mainClass = null;
	 int exitCode = 0;
	 Throwable thrown=null;
	 try {
		 mainClass = loader.loadClass(mainClassname);
		 AntMain main = (AntMain) mainClass.newInstance();
		 main.startAnt(newArgs, null, null);
	 }
	 catch (InstantiationException ex) {
		 System.err.println( ""Incompatible version of "" + mainClassname + "" detected"");
		 File mainJar = Locator.getClassSource(mainClass);
		 System.err.println( ""Location of this class "" + mainJar);
		 thrown = ex;
	 }
	 catch (ClassNotFoundException cnfe) {
		 System.err.println( ""Failed to locate"" + mainClassname);
		 thrown = cnfe;
	 }
	 catch (Throwable t) {
		 t.printStackTrace(System.err);
		 thrown=t;
	 }
	 if(thrown!=null) {
		 System.err.println(ANTHOME_PROPERTY+"": ""+antHome.getAbsolutePath());
		 System.err.println(""Classpath: "" + baseClassPath.toString());
		 System.err.println(""Launcher JAR: "" + sourceJar.getAbsolutePath());
		 System.err.println(""Launcher Directory: "" + jarDir.getAbsolutePath());
		 exitCode = EXIT_CODE_ERROR;
	 }
	 return exitCode;
 }",0,0,1,0
"public interface ExternalLoadBalancerDeviceManager extends Manager {
	 public static final int DEFAULT_LOAD_BALANCER_CAPACITY = 50;
	 public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, String deviceName, ServerResource resource, boolean gslbProvider, boolean exclusiveGslbProvider, String gslbSitePublicIp, String gslbSitePrivateIp);
	 public boolean deleteExternalLoadBalancer(long hostId);
	 public List<Host> listExternalLoadBalancers(long physicalNetworkId, String deviceName);
	 public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException;
	 public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network);
	 public boolean applyLoadBalancerRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException;
	 public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException;
	 public List<LoadBalancerTO> getLBHealthChecks(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException;
}",1,0,0,0
"public final class HtmlHeaderSectionHandler extends AbstractMarkupFilter{
	private static final String BODY = ""body"";
	private static final String HEAD = ""head"";
	public static final String HEADER_ID = ""_header_"";
	private boolean foundHead = false;
	private boolean ignoreTheRest = false;
	private final Markup markup;
	public HtmlHeaderSectionHandler(final Markup markup){
		this.markup = markup;
	}
	public MarkupElement nextTag() throws ParseException{
		final ComponentTag tag = nextComponentTag();
		if (tag == null){
			return tag;
		}
		if (ignoreTheRest == true){
			return tag;
		}
		if (HEAD.equalsIgnoreCase(tag.getName())){
			if (tag.getNamespace() == null){
				if (tag.isClose()){
					foundHead = true;
				}
				else if (tag.getId() == null){
					tag.setId(HEADER_ID);
					tag.setAutoComponentTag(true);
					tag.setModified(true);
				}
				return tag;
			}
			else{
				foundHead = true;
			}
		}
		else if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null)){
			if (foundHead == false){
				insertHeadTag();
			}
			ignoreTheRest = true;
			return tag;
		}
		return tag;
	}
	private void insertHeadTag(){
		final ComponentTag openTag = new ComponentTag(HEAD, XmlTag.OPEN);
		openTag.setId(HEADER_ID);
		openTag.setAutoComponentTag(true);
		openTag.setModified(true);
		final ComponentTag closeTag = new ComponentTag(HEAD, XmlTag.CLOSE);
		closeTag.setOpenTag(openTag);
		closeTag.setModified(true);
		markup.addMarkupElement(openTag);
		markup.addMarkupElement(closeTag);
	}
}",0,0,0,0
"public class NetCommand {
	 private static final int DEFAULT_RESPONSE_THRESHOLD = 64;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 protected Task owner;
	 protected Execute executable;
	 protected Commandline commandLine;
	 protected String title;
	 protected String program;
	 protected boolean traceCommandLine = false;
	 protected boolean failOnError;
	 private File directory;
	 private boolean useResponseFile = false;
	 private File temporaryCommandFile;
	 private int automaticResponseFileThreshold = DEFAULT_RESPONSE_THRESHOLD;
	 public NetCommand(Task owner, String title, String program) {
		 this.owner = owner;
		 this.title = title;
		 this.program = program;
		 commandLine = new Commandline();
		 commandLine.setExecutable(program);
	 }
	 public void setTraceCommandLine(boolean b) {
		 traceCommandLine = b;
	 }
	 public void setFailOnError(boolean b) {
		 failOnError = b;
	 }
	 public boolean getFailFailOnError() {
		 return failOnError;
	 }
	 public void setDirectory(File directory) {
		 this.directory = directory;
	 }
	 protected void logVerbose(String msg) {
		 owner.getProject().log(msg, Project.MSG_VERBOSE);
	 }
	 protected void logError(String msg) {
		 owner.getProject().log(msg, Project.MSG_ERR);
	 }
	 public void addArgument(String argument) {
		 if (argument != null && argument.length() != 0) {
			 commandLine.createArgument().setValue(argument);
		 }
	 }
	 public void addArguments(String[] arguments) {
		 if (arguments != null && arguments.length != 0) {
			 for (int i = 0;
			 i < arguments.length;
			 i++) {
				 addArgument(arguments[i]);
			 }
		 }
	 }
	 public void addArgument(String argument1, String argument2) {
		 if (argument2 != null && argument2.length() != 0) {
			 commandLine.createArgument().setValue(argument1 + argument2);
		 }
	 }
	 public boolean isUseResponseFile() {
		 return useResponseFile;
	 }
	 public void setUseResponseFile(boolean useResponseFile) {
		 this.useResponseFile = useResponseFile;
	 }
	 public int getAutomaticResponseFileThreshold() {
		 return automaticResponseFileThreshold;
	 }
	 public void setAutomaticResponseFileThreshold(int automaticResponseFileThreshold) {
		 this.automaticResponseFileThreshold = automaticResponseFileThreshold;
	 }
	 protected void prepareExecutor() {
		 if (owner == null) {
			 throw new RuntimeException(""no owner"");
		 }
		 if (owner.getProject() == null) {
			 throw new RuntimeException(""Owner has no project"");
		 }
		 File dir = owner.getProject().getBaseDir();
		 if (directory != null) {
			 dir = directory;
		 }
		 ExecuteStreamHandler handler = new LogStreamHandler(owner, Project.MSG_INFO, Project.MSG_WARN);
		 executable = new Execute(handler, null);
		 executable.setAntRun(owner.getProject());
		 executable.setWorkingDirectory(dir);
	 }
	 public void runCommand() throws BuildException {
		 prepareExecutor();
		 int err = -1;
		 try {
			 if (traceCommandLine) {
				 owner.log(""In directory "" + executable.getWorkingDirectory());
				 owner.log(commandLine.describeCommand());
			 }
			 else {
				 logVerbose(""In directory "" + executable.getWorkingDirectory());
				 logVerbose(commandLine.describeCommand());
			 }
			 setExecutableCommandLine();
			 err = executable.execute();
			 if (Execute.isFailure(err)) {
				 if (failOnError) {
					 throw new BuildException(title + "" returned: "" + err, owner.getLocation());
				 }
				 else {
					 owner.log(title + "" Result: "" + err, Project.MSG_ERR);
				 }
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(title + "" failed: "" + e, e, owner.getLocation());
		 }
		 finally {
			 if (temporaryCommandFile != null) {
				 temporaryCommandFile.delete();
			 }
		 }
	 }
	 private void setExecutableCommandLine() {
		 String[] commands = commandLine.getCommandline();
		 if (automaticResponseFileThreshold > 0 && commands.length > automaticResponseFileThreshold) {
			 useResponseFile = true;
		 }
		 if (!useResponseFile || commands.length <= 1) {
			 executable.setCommandline(commands);
		 }
		 else {
			 FileOutputStream fos = null;
			 temporaryCommandFile = FILE_UTILS.createTempFile(""cmd"", "".txt"", null, false, true);
			 owner.log(""Using response file "" + temporaryCommandFile, Project.MSG_VERBOSE);
			 try {
				 fos = new FileOutputStream(temporaryCommandFile);
				 PrintWriter out = new PrintWriter(new BufferedOutputStream(fos));
				 for (int i = 1;
				 i < commands.length;
				 ++i) {
					 out.println(commands[i]);
				 }
				 out.flush();
				 out.close();
			 }
			 catch (IOException ex) {
				 throw new BuildException(""saving command stream to "" + temporaryCommandFile, ex);
			 }
			 String[] newCommandLine = new String[2];
			 newCommandLine[0] = commands[0];
			 newCommandLine[1] = ""@"" + temporaryCommandFile.getAbsolutePath();
			 logVerbose(Commandline.describeCommand(newCommandLine));
			 executable.setCommandline(newCommandLine);
		 }
	 }
	 public int scanOneFileset(DirectoryScanner scanner, Hashtable filesToBuild, long outputTimestamp) {
		 int filesOutOfDate = 0;
		 String[] dependencies = scanner.getIncludedFiles();
		 File base = scanner.getBasedir();
		 for (int i = 0;
		 i < dependencies.length;
		 i++) {
			 File targetFile = new File(base, dependencies[i]);
			 if (filesToBuild.get(targetFile) == null) {
				 filesToBuild.put(targetFile, targetFile);
				 if (targetFile.lastModified() > outputTimestamp) {
					 filesOutOfDate++;
					 owner.log(targetFile.toString() + "" is out of date"", Project.MSG_VERBOSE);
				 }
				 else {
					 owner.log(targetFile.toString(), Project.MSG_VERBOSE);
				 }
			 }
		 }
		 return filesOutOfDate;
	 }
}",0,0,0,0
"public static class ValidEmail {
	 String newEmail;
	 public String getNewEmail() {
		 return newEmail;
	 }
	 public void setNewEmail(String email) {
		 this.newEmail = email;
	 }
 }",0,1,0,0
"public class GitPgmCommand extends AbstractGitCommand {
	 public GitPgmCommand(GitLocationResolver rootDirResolver, String command, CloseableExecutorService executorService) {
		 super(rootDirResolver, command, executorService);
	 }
	 public void run() {
		 String command = getCommand();
		 OutputStream err = getErrorStream();
		 try {
			 List<String> strs = parseDelimitedString(command, "" "", true);
			 String[] args = strs.toArray(new String[strs.size()]);
			 for (int i = 0;
			 i < args.length;
			 i++) {
				 String argVal = args[i];
				 if (argVal.startsWith(""'"") && argVal.endsWith(""'"")) {
					 args[i] = argVal.substring(1, argVal.length() - 1);
					 argVal = args[i];
				 }
				 if (argVal.startsWith(""\"""") && argVal.endsWith(""\"""")) {
					 args[i] = argVal.substring(1, argVal.length() - 1);
					 argVal = args[i];
				 }
			 }
			 GitLocationResolver resolver = getGitLocationResolver();
			 Path rootDir = resolver.resolveRootDirectory(command, args, getServerSession(), getFileSystem());
			 ValidateUtils.checkState(rootDir != null, ""No root directory provided for %s command"", command);
			 new EmbeddedCommandRunner(rootDir).execute(args, getInputStream(), getOutputStream(), err);
			 onExit(0);
		 }
		 catch (Throwable t) {
			 try {
				 err.write((t.getMessage() + ""\n"").getBytes(StandardCharsets.UTF_8));
				 err.flush();
			 }
			 catch (IOException e) {
				 log.warn(""Failed {
				}
				 to flush command={
				}
				 failure: {
				}
				"", e.getClass().getSimpleName(), command, e.getMessage());
			 }
			 onExit(-1, t.getMessage());
		 }
	 }
}",0,0,0,0
"public class NodeId implements Comparable<NodeId>{
	 private static final Logger logger = LoggerFactory.getLogger(NodeId.class);
	 public static final int LENGTH = 16;
	 private static class LocalIds {
		 static final LocalNodeIdHistory instance = new LocalNodeIdHistory();
	 }
	 private ByteBuffer id;
	 private static LocalNodeIdHistory localIds() {
		 return LocalIds.instance;
	 }
	 public static NodeId getLocalId() {
		 return localIds().current.get();
	 }
	 public static synchronized void renewLocalId() {
		 localIds().renewCurrent();
	 }
	 public static List<NodeIdRecord> getOldLocalNodeIds() {
		 return localIds().olds;
	 }
	 public static NodeId fromInt(int n) {
		 long lowBits = 0xC000000000000000L | n;
		 return new NodeId(ByteBuffer.allocate(16).putLong(0, 0).putLong(8, lowBits));
	 }
	 public static NodeId wrap(ByteBuffer id) {
		 return new NodeId(id);
	 }
	 public static NodeId wrap(ByteBuffer bb, int offset) {
		 ByteBuffer dup = bb.duplicate();
		 dup.position(offset);
		 dup.limit(dup.position() + LENGTH);
		 return wrap(dup);
	 }
	 private NodeId(ByteBuffer id) {
		 if (id.remaining() != LENGTH) throw new IllegalArgumentException(""A NodeId representation is exactly "" + LENGTH + "" bytes"");
		 this.id = id;
	 }
	 public static NodeId generate() {
		 return new NodeId(ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress()))));
	 }
	 public ByteBuffer bytes() {
		 return id;
	 }
	 public boolean isLocalId() {
		 return equals(getLocalId());
	 }
	 public int compareTo(NodeId o) {
		 return ByteBufferUtil.compareSubArrays(id, id.position(), o.id, o.id.position(), NodeId.LENGTH);
	 }
	 public String toString() {
		 return UUIDGen.getUUID(id).toString();
	 }
	 public boolean equals(Object o) {
		 if (this == o) return true;
		 if (o == null || getClass() != o.getClass()) return false;
		 NodeId otherId = (NodeId)o;
		 return id.equals(otherId.id);
	 }
	 public int hashCode() {
		 return id.hashCode();
	 }
	 public static class OneShotRenewer {
		 private boolean renewed;
		 private final NodeId initialId;
		 public OneShotRenewer() {
			 renewed = false;
			 initialId = getLocalId();
		 }
		 public void maybeRenew(CounterColumn column) {
			 if (!renewed && column.hasNodeId(initialId)) {
				 renewLocalId();
				 renewed = true;
			 }
		 }
	 }
	 private static class LocalNodeIdHistory {
		 private final AtomicReference<NodeId> current;
		 private final List<NodeIdRecord> olds;
		 LocalNodeIdHistory() {
			 NodeId id = SystemTable.getCurrentLocalNodeId();
			 if (id == null) {
				 id = generate();
				 logger.info(""No saved local node id, using newly generated: {
				}
				"", id);
				 SystemTable.writeCurrentLocalNodeId(null, id, System.currentTimeMillis());
				 current = new AtomicReference<NodeId>(id);
				 olds = new CopyOnWriteArrayList();
			 }
			 else {
				 logger.info(""Saved local node id: {
				}
				"", id);
				 current = new AtomicReference<NodeId>(id);
				 olds = new CopyOnWriteArrayList(SystemTable.getOldLocalNodeIds());
			 }
		 }
		 synchronized void renewCurrent() {
			 long now = System.currentTimeMillis();
			 NodeId newNodeId = generate();
			 NodeId old = current.get();
			 SystemTable.writeCurrentLocalNodeId(old, newNodeId, now);
			 current.set(newNodeId);
			 olds.add(new NodeIdRecord(old, now));
		 }
	 }
	 public static class NodeIdRecord {
		 public final NodeId id;
		 public final long timestamp;
		 public NodeIdRecord(NodeId id, long timestamp) {
			 this.id = id;
			 this.timestamp = timestamp;
		 }
		 public boolean equals(Object o) {
			 if (this == o) return true;
			 if (o == null || getClass() != o.getClass()) return false;
			 NodeIdRecord otherRecord = (NodeIdRecord)o;
			 return id.equals(otherRecord.id) && timestamp == otherRecord.timestamp;
		 }
		 public String toString() {
			 return String.format(""(%s, %d)"", id.toString(), timestamp);
		 }
	 }
}",0,0,0,0
"public class UintMap implements Serializable {
	 public UintMap() {
		 this(4);
	 }
	 public UintMap(int initialCapacity) {
		 if (initialCapacity < 0) Kit.codeBug();
		 int minimalCapacity = initialCapacity * 4 / 3;
		 int i;
		 for (i = 2;
		 (1 << i) < minimalCapacity;
		 ++i) {
		 }
		 power = i;
		 if (check && power < 2) Kit.codeBug();
	 }
	 public boolean isEmpty() {
		 return keyCount == 0;
	 }
	 public int size() {
		 return keyCount;
	 }
	 public boolean has(int key) {
		 if (key < 0) Kit.codeBug();
		 return 0 <= findIndex(key);
	 }
	 public Object getObject(int key) {
		 if (key < 0) Kit.codeBug();
		 if (values != null) {
			 int index = findIndex(key);
			 if (0 <= index) {
				 return values[index];
			 }
		 }
		 return null;
	 }
	 public int getInt(int key, int defaultValue) {
		 if (key < 0) Kit.codeBug();
		 int index = findIndex(key);
		 if (0 <= index) {
			 if (ivaluesShift != 0) {
				 return keys[ivaluesShift + index];
			 }
			 return 0;
		 }
		 return defaultValue;
	 }
	 public int getExistingInt(int key) {
		 if (key < 0) Kit.codeBug();
		 int index = findIndex(key);
		 if (0 <= index) {
			 if (ivaluesShift != 0) {
				 return keys[ivaluesShift + index];
			 }
			 return 0;
		 }
		 Kit.codeBug();
		 return 0;
	 }
	 public void put(int key, Object value) {
		 if (key < 0) Kit.codeBug();
		 int index = ensureIndex(key, false);
		 if (values == null) {
			 values = new Object[1 << power];
		 }
		 values[index] = value;
	 }
	 public void put(int key, int value) {
		 if (key < 0) Kit.codeBug();
		 int index = ensureIndex(key, true);
		 if (ivaluesShift == 0) {
			 int N = 1 << power;
			 if (keys.length != N * 2) {
				 int[] tmp = new int[N * 2];
				 System.arraycopy(keys, 0, tmp, 0, N);
				 keys = tmp;
			 }
			 ivaluesShift = N;
		 }
		 keys[ivaluesShift + index] = value;
	 }
	 public void remove(int key) {
		 if (key < 0) Kit.codeBug();
		 int index = findIndex(key);
		 if (0 <= index) {
			 keys[index] = DELETED;
			 --keyCount;
			 if (values != null) {
				 values[index] = null;
			 }
			 if (ivaluesShift != 0) {
				 keys[ivaluesShift + index] = 0;
			 }
		 }
	 }
	 public void clear() {
		 int N = 1 << power;
		 if (keys != null) {
			 for (int i = 0;
			 i != N;
			 ++i) {
				 keys[i] = EMPTY;
			 }
			 if (values != null) {
				 for (int i = 0;
				 i != N;
				 ++i) {
					 values[i] = null;
				 }
			 }
		 }
		 ivaluesShift = 0;
		 keyCount = 0;
		 occupiedCount = 0;
	 }
	 public int[] getKeys() {
		 int[] keys = this.keys;
		 int n = keyCount;
		 int[] result = new int[n];
		 for (int i = 0;
		 n != 0;
		 ++i) {
			 int entry = keys[i];
			 if (entry != EMPTY && entry != DELETED) {
				 result[--n] = entry;
			 }
		 }
		 return result;
	 }
	 private static int tableLookupStep(int fraction, int mask, int power) {
		 int shift = 32 - 2 * power;
		 if (shift >= 0) {
			 return ((fraction >>> shift) & mask) | 1;
		 }
		 else {
			 return (fraction & (mask >>> -shift)) | 1;
		 }
	 }
	 private int findIndex(int key) {
		 int[] keys = this.keys;
		 if (keys != null) {
			 int fraction = key * A;
			 int index = fraction >>> (32 - power);
			 int entry = keys[index];
			 if (entry == key) {
				 return index;
			 }
			 if (entry != EMPTY) {
				 int mask = (1 << power) - 1;
				 int step = tableLookupStep(fraction, mask, power);
				 int n = 0;
				 do {
					 if (check) {
						 if (n >= occupiedCount) Kit.codeBug();
						 ++n;
					 }
					 index = (index + step) & mask;
					 entry = keys[index];
					 if (entry == key) {
						 return index;
					 }
				 }
				 while (entry != EMPTY);
			 }
		 }
		 return -1;
	 }
	 private int insertNewKey(int key) {
		 if (check && occupiedCount != keyCount) Kit.codeBug();
		 if (check && keyCount == 1 << power) Kit.codeBug();
		 int[] keys = this.keys;
		 int fraction = key * A;
		 int index = fraction >>> (32 - power);
		 if (keys[index] != EMPTY) {
			 int mask = (1 << power) - 1;
			 int step = tableLookupStep(fraction, mask, power);
			 int firstIndex = index;
			 do {
				 if (check && keys[index] == DELETED) Kit.codeBug();
				 index = (index + step) & mask;
				 if (check && firstIndex == index) Kit.codeBug();
			 }
			 while (keys[index] != EMPTY);
		 }
		 keys[index] = key;
		 ++occupiedCount;
		 ++keyCount;
		 return index;
	 }
	 private void rehashTable(boolean ensureIntSpace) {
		 if (keys != null) {
			 if (keyCount * 2 >= occupiedCount) {
				 ++power;
			 }
		 }
		 int N = 1 << power;
		 int[] old = keys;
		 int oldShift = ivaluesShift;
		 if (oldShift == 0 && !ensureIntSpace) {
			 keys = new int[N];
		 }
		 else {
			 ivaluesShift = N;
			 keys = new int[N * 2];
		 }
		 for (int i = 0;
		 i != N;
		 ++i) {
			 keys[i] = EMPTY;
		 }
		 Object[] oldValues = values;
		 if (oldValues != null) {
			 values = new Object[N];
		 }
		 int oldCount = keyCount;
		 occupiedCount = 0;
		 if (oldCount != 0) {
			 keyCount = 0;
			 for (int i = 0, remaining = oldCount;
			 remaining != 0;
			 ++i) {
				 int key = old[i];
				 if (key != EMPTY && key != DELETED) {
					 int index = insertNewKey(key);
					 if (oldValues != null) {
						 values[index] = oldValues[i];
					 }
					 if (oldShift != 0) {
						 keys[ivaluesShift + index] = old[oldShift + i];
					 }
					 --remaining;
				 }
			 }
		 }
	 }
	 private int ensureIndex(int key, boolean intType) {
		 int index = -1;
		 int firstDeleted = -1;
		 int[] keys = this.keys;
		 if (keys != null) {
			 int fraction = key * A;
			 index = fraction >>> (32 - power);
			 int entry = keys[index];
			 if (entry == key) {
				 return index;
			 }
			 if (entry != EMPTY) {
				 if (entry == DELETED) {
					 firstDeleted = index;
				 }
				 int mask = (1 << power) - 1;
				 int step = tableLookupStep(fraction, mask, power);
				 int n = 0;
				 do {
					 if (check) {
						 if (n >= occupiedCount) Kit.codeBug();
						 ++n;
					 }
					 index = (index + step) & mask;
					 entry = keys[index];
					 if (entry == key) {
						 return index;
					 }
					 if (entry == DELETED && firstDeleted < 0) {
						 firstDeleted = index;
					 }
				 }
				 while (entry != EMPTY);
			 }
		 }
		 if (check && keys != null && keys[index] != EMPTY) Kit.codeBug();
		 if (firstDeleted >= 0) {
			 index = firstDeleted;
		 }
		 else {
			 if (keys == null || occupiedCount * 4 >= (1 << power) * 3) {
				 rehashTable(intType);
				 keys = this.keys;
				 return insertNewKey(key);
			 }
			 ++occupiedCount;
		 }
		 keys[index] = key;
		 ++keyCount;
		 return index;
	 }
	 private void writeObject(ObjectOutputStream out) throws IOException {
		 out.defaultWriteObject();
		 int count = keyCount;
		 if (count != 0) {
			 boolean hasIntValues = (ivaluesShift != 0);
			 boolean hasObjectValues = (values != null);
			 out.writeBoolean(hasIntValues);
			 out.writeBoolean(hasObjectValues);
			 for (int i = 0;
			 count != 0;
			 ++i) {
				 int key = keys[i];
				 if (key != EMPTY && key != DELETED) {
					 --count;
					 out.writeInt(key);
					 if (hasIntValues) {
						 out.writeInt(keys[ivaluesShift + i]);
					 }
					 if (hasObjectValues) {
						 out.writeObject(values[i]);
					 }
				 }
			 }
		 }
	 }
	 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		 in.defaultReadObject();
		 int writtenKeyCount = keyCount;
		 if (writtenKeyCount != 0) {
			 keyCount = 0;
			 boolean hasIntValues = in.readBoolean();
			 boolean hasObjectValues = in.readBoolean();
			 int N = 1 << power;
			 if (hasIntValues) {
				 keys = new int[2 * N];
				 ivaluesShift = N;
			 }
			else {
				 keys = new int[N];
			 }
			 for (int i = 0;
			 i != N;
			 ++i) {
				 keys[i] = EMPTY;
			 }
			 if (hasObjectValues) {
				 values = new Object[N];
			 }
			 for (int i = 0;
			 i != writtenKeyCount;
			 ++i) {
				 int key = in.readInt();
				 int index = insertNewKey(key);
				 if (hasIntValues) {
					 int ivalue = in.readInt();
					 keys[ivaluesShift + index] = ivalue;
				 }
				 if (hasObjectValues) {
					 values[index] = in.readObject();
				 }
			 }
		 }
	 }
	 private static final int A = 0x9e3779b9;
	 private static final int EMPTY = -1;
	 private static final int DELETED = -2;
	 private transient int[] keys;
	 private transient Object[] values;
	 private int power;
	 private int keyCount;
	 private transient int occupiedCount;
	 private transient int ivaluesShift;
	 private static final boolean check = false;
}",0,0,0,0
"public static class getAllUserResourceProfiles<I extends Iface> extends org.apache.thrift.ProcessFunction<I, getAllUserResourceProfiles_args> {
	 public getAllUserResourceProfiles() {
		 super(""getAllUserResourceProfiles"");
	 }
	 public getAllUserResourceProfiles_args getEmptyArgsInstance() {
		 return new getAllUserResourceProfiles_args();
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public getAllUserResourceProfiles_result getResult(I iface, getAllUserResourceProfiles_args args) throws org.apache.thrift.TException {
		 getAllUserResourceProfiles_result result = new getAllUserResourceProfiles_result();
		 try {
			 result.success = iface.getAllUserResourceProfiles();
		 }
		 catch (org.apache.airavata.registry.api.exception.RegistryServiceException rse) {
			 result.rse = rse;
		 }
		 return result;
	 }
 }",0,0,0,0
"public class PrintingOptions{
	 private boolean printLineNumbers_ = false;
	 private boolean wrapText_ = false;
	 private boolean printHeader_ = false;
	 private boolean printSyntax_ = false;
	 private Font pageFont_ = new Font(""Courier"", Font.PLAIN, 10);
	 private Font headerFont_ = new Font(""Courier"", Font.BOLD, 10);
	 private PageFormat pageFormat_ = null;
	 public PrintingOptions() {
		 pageFormat_ = new PageFormat();
	 }
	 public PrintingOptions(boolean printLineNumbers, boolean wrapText, boolean printHeader, boolean printSyntax, Font pageFont, PageFormat pageFormat) {
		 printLineNumbers_ = printLineNumbers;
		 wrapText_ = wrapText;
		 printHeader_ = printHeader;
		 printSyntax_ = printSyntax;
		 pageFont_ = pageFont;
		 pageFormat_ = pageFormat;
		 headerFont_ = new Font(pageFont_.getName(), Font.BOLD, pageFont_.getSize());
	 }
	 public void setPrintLineNumbers(boolean printLineNumbers) {
		 printLineNumbers_ = printLineNumbers;
	 }
	 public boolean getPrintLineNumbers() {
		 return printLineNumbers_;
	 }
	 public void setWrapText(boolean wrapText) {
		 wrapText_ = wrapText;
	 }
	 public boolean getWrapText() {
		 return wrapText_;
	 }
	 public void setPrintHeader(boolean printHeader) {
		 printHeader_ = printHeader;
	 }
	 public boolean getPrintHeader() {
		 return printHeader_;
	 }
	 public void setPrintSyntax(boolean printSyntax) {
		 printSyntax_ = printSyntax;
	 }
	 public boolean getPrintSyntax() {
		 return printSyntax_;
	 }
	 public void setPageFont(Font pageFont) {
		 pageFont_ = pageFont;
		 headerFont_ = new Font(pageFont_.getName(), Font.BOLD, pageFont_.getSize());
	 }
	 public Font getPageFont() {
		 return pageFont_;
	 }
	 public Font getHeaderFont() {
		 return headerFont_;
	 }
	 public void setPageFormat(PageFormat pageFormat) {
		 pageFormat_ = pageFormat;
	 }
	 public PageFormat getPageFormat() {
		 return pageFormat_;
	 }
}",0,1,0,0
"public final class PostgreSQLDatabaseFunctions {
	 protected static Multimap<Pair<CConnection, String>, String> m_cache = HashMultimap.create();
	 private PostgreSQLDatabaseFunctions() {
	 }
	 protected static void checkArguments(final AbstractSQLProvider provider, final DebuggerTemplateManager debuggerManager) {
		 Preconditions.checkNotNull(provider, ""IE00413: Provider argument can not be null"");
		 Preconditions.checkNotNull(debuggerManager, ""IE01227: Debugger final manager argument can final not be null"");
		 Preconditions.checkArgument(debuggerManager.inSameDatabase(provider), ""IE00415: Debugger manager is not part of the given database"");
	 }
	 protected static boolean checkRawModulesTables(final CConnection connection, final String databaseName, final int rawModuleId) {
		 Preconditions.checkNotNull(connection, ""IE02261: Connection argument can not be null"");
		 Preconditions.checkNotNull(databaseName, ""IE02262: Database name argument can not be null"");
		 Preconditions.checkArgument(rawModuleId > 0, ""Raw module id %s must be a positive integer"", rawModuleId);
		 final ImmutableSet<String> rawTableNames = ImmutableSet.of(String.format(CTableNames.RAW_ADDRESS_COMMENTS_TABLE, rawModuleId), String.format(CTableNames.RAW_ADDRESS_REFERENCES_TABLE, rawModuleId), String.format(CTableNames.RAW_BASE_TYPES, rawModuleId), String.format(CTableNames.RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE, rawModuleId), String.format(CTableNames.RAW_BASIC_BLOCKS_TABLE, rawModuleId), String.format(CTableNames.RAW_CALLGRAPH_TABLE, rawModuleId), String.format(CTableNames.RAW_CONTROL_FLOW_GRAPHS_TABLE, rawModuleId), String.format(CTableNames.RAW_EXPRESSION_NODES_TABLE, rawModuleId), String.format(CTableNames.RAW_EXPRESSION_SUBSTITUTIONS_TABLE, rawModuleId), String.format(CTableNames.RAW_EXPRESSION_TREE_NODES_TABLE, rawModuleId), String.format(CTableNames.RAW_EXPRESSION_TREES_TABLE, rawModuleId), String.format(CTableNames.RAW_EXPRESSION_TYPES_TABLE, rawModuleId), String.format(CTableNames.RAW_FUNCTIONS_TABLE, rawModuleId), String.format(CTableNames.RAW_INSTRUCTIONS_TABLE, rawModuleId), String.format(CTableNames.RAW_OPERANDS_TABLE, rawModuleId), String.format(CTableNames.RAW_SECTIONS, rawModuleId), String.format(CTableNames.RAW_EXPRESSION_TYPE_INSTANCES, rawModuleId), String.format(CTableNames.RAW_TYPE_INSTACES, rawModuleId), String.format(CTableNames.RAW_TYPES, rawModuleId));
		 final Pair<CConnection, String> cacheKey = new Pair<>(connection, databaseName);
		 if (PostgreSQLDatabaseFunctions.queryCache(cacheKey, rawTableNames)) {
			 return true;
		 }
		 else {
			 if (!PostgreSQLDatabaseFunctions.fillCache(cacheKey)) {
				 return false;
			 }
			 return PostgreSQLDatabaseFunctions.queryCache(cacheKey, rawTableNames);
		 }
	 }
	 protected static boolean fillCache(final Pair<CConnection, String> cacheKey) {
		 PostgreSQLDatabaseFunctions.m_cache.clear();
		 final String query = ""SELECT table_name FROM information_schema.tables WHERE table_catalog = '"" + cacheKey.second() + ""' "";
		 try (ResultSet result = cacheKey.first().executeQuery(query, true)) {
			 while (result.next()) {
				 PostgreSQLDatabaseFunctions.m_cache.put(cacheKey, result.getString(1));
			 }
		 }
		 catch (final SQLException exception) {
			 return false;
		 }
		 return true;
	 }
	 protected static INaviRawModule findRawModule(final int rawModuleId, final List<INaviRawModule> rawModules) {
		 Preconditions.checkArgument(rawModuleId > 0, ""Raw module id %s must be positive integer"", rawModuleId);
		 Preconditions.checkNotNull(rawModules, ""IE02263: raw modules argument can not be null"");
		 for (final INaviRawModule rawModule : rawModules) {
			 if (rawModule.getId() == rawModuleId) {
				 return rawModule;
			 }
		 }
		 throw new IllegalStateException(""IE00160: Could not find raw module"");
	 }
	 protected static List<DebuggerTemplate> getAssignedDebuggers(final CConnection connection, final int projectId, final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {
		 Preconditions.checkNotNull(connection, ""IE02264: Connection argument can not be null"");
		 Preconditions.checkArgument(projectId > 0, ""Project id %s must be a positive integer."", projectId);
		 Preconditions.checkNotNull(debuggerManager, ""IE02265: debugger manager argument can not be null"");
		 final List<DebuggerTemplate> debuggerIds = new ArrayList<>();
		 final String query = String.format(""SELECT debugger_id FROM %s WHERE project_id = %d"", CTableNames.PROJECT_DEBUGGERS_TABLE, projectId);
		 try (ResultSet resultSet = connection.executeQuery(query, true)) {
			 while (resultSet.next()) {
				 debuggerIds.add(debuggerManager.findDebugger(resultSet.getInt(""debugger_id"")));
			 }
		 }
		 catch (final SQLException exception) {
			 throw new CouldntLoadDataException(exception);
		 }
		 return debuggerIds;
	 }
	 protected static int getRawModuleFunctionCount(final CConnection connection, final int rawModuleId) throws SQLException {
		 Preconditions.checkNotNull(connection, ""IE02266: Connection argument can not be null"");
		 Preconditions.checkArgument(rawModuleId > 0, ""Raw module id %s must be a positive integer"", rawModuleId);
		 final String query = ""SELECT count(*) AS fcount "" + "" FROM ex_"" + rawModuleId + ""_functions "" + "" WHERE address <> 0 "" + "" OR type <> 3"";
		 try (ResultSet resultSet = connection.executeQuery(query, true)) {
			 while (resultSet.next()) {
				 return resultSet.getInt(""fcount"");
			 }
			 return 0;
		 }
		 catch (final SQLException exception) {
			 throw new SQLException(""Could not load function count"");
		 }
	 }
	 protected static ArrayList<Integer> getRawModuleIDs(final CConnection connection) throws SQLException {
		 Preconditions.checkNotNull(connection, ""IE02267: Connection argument can not be null"");
		 final ArrayList<Integer> rawModuleIDs = new ArrayList<>();
		 try (ResultSet resultSet = connection.executeQuery(""SELECT id FROM modules"", true)) {
			 while (resultSet.next()) {
				 rawModuleIDs.add(resultSet.getInt(""id""));
			 }
		 }
		 catch (final Exception exception) {
			 return null;
		 }
		 return rawModuleIDs;
	 }
	 protected static boolean queryCache(final Pair<CConnection, String> cacheKey, final ImmutableSet<String> rawTableNames) {
		 return PostgreSQLDatabaseFunctions.m_cache.get(cacheKey).containsAll(rawTableNames);
	 }
	 public static DatabaseVersion getDatabaseVersion(final CConnection m_connection) throws CouldntLoadDataException, SQLException {
		 if (PostgreSQLHelpers.hasTable(m_connection, CTableNames.SECTIONS_TABLE)) {
			 return new DatabaseVersion(""6.0.0"");
		 }
		 if (PostgreSQLHelpers.hasTable(m_connection, CTableNames.USER_TABLE)) {
			 return new DatabaseVersion(""5.0.0"");
		 }
		 if (PostgreSQLHelpers.hasTable(m_connection, CTableNames.RAW_MODULES_TABLE) && PostgreSQLHelpers.hasTable(m_connection, CTableNames.MODULES_TABLE)) {
			 final ArrayList<Integer> rawModuleIds = getRawModuleIDs(m_connection);
			 if (rawModuleIds.isEmpty()) {
				 return new DatabaseVersion(""3.0.0"");
			 }
			 if (PostgreSQLHelpers.hasTable(m_connection, ""ex_"" + rawModuleIds.get(0) + ""_type_structs"")) {
				 return new DatabaseVersion(""4.0.0"");
			 }
			 return new DatabaseVersion(""3.0.0"");
		 }
		 return new DatabaseVersion(Constants.PROJECT_VERSION);
	 }
	 public static List<INaviModule> loadModules(final AbstractSQLProvider provider, final List<INaviRawModule> rawModules, final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {
		 Preconditions.checkNotNull(rawModules, ""IE02043: rawModules argument can not be null"");
		 PostgreSQLDatabaseFunctions.checkArguments(provider, debuggerManager);
		 final List<CModule> modules = new ArrayList<>();
		 final CConnection connection = provider.getConnection();
		 if (!PostgreSQLHelpers.hasTable(connection, CTableNames.MODULES_TABLE)) {
			 return new ArrayList<INaviModule>(modules);
		 }
		 final String query = ""SELECT id, raw_module_id, "" + CTableNames.MODULES_TABLE + "".name, "" + "" md5, sha1, description, import_time, modification_date, file_base, image_base, stared, "" + "" initialization_state, debugger_id, "" + "" (SELECT count(*) FROM "" + CTableNames.FUNCTIONS_TABLE + "" "" + "" WHERE id = "" + CTableNames.FUNCTIONS_TABLE + "".module_id) "" + "" AS function_count, "" + "" (SELECT count(*) FROM "" + CTableNames.MODULE_VIEWS_TABLE + "" JOIN "" + CTableNames.VIEWS_TABLE + "" ON view_id = id "" + "" WHERE type = 'non-native' and module_id = "" + CTableNames.MODULES_TABLE + "".id) "" + "" AS view_count FROM "" + CTableNames.MODULES_TABLE + "" "" + "" WHERE raw_module_id IS NOT NULL ORDER BY id"";
		 try (ResultSet resultSet = connection.executeQuery(query, true)) {
			 while (resultSet.next()) {
				 final int moduleId = resultSet.getInt(""id"");
				 final String name = PostgreSQLHelpers.readString(resultSet, ""name"");
				 final String md5 = PostgreSQLHelpers.readString(resultSet, ""md5"");
				 final String sha1 = PostgreSQLHelpers.readString(resultSet, ""sha1"");
				 final String comment = PostgreSQLHelpers.readString(resultSet, ""description"");
				 final Timestamp timestamp = resultSet.getTimestamp(""import_time"");
				 final Timestamp modificationDate = resultSet.getTimestamp(""modification_date"");
				 int functionCount = resultSet.getInt(""function_count"");
				 final int viewCount = resultSet.getInt(""view_count"");
				 final IAddress imageBase = PostgreSQLHelpers.loadAddress(resultSet, ""image_base"");
				 final IAddress fileBase = PostgreSQLHelpers.loadAddress(resultSet, ""file_base"");
				 final int debuggerId = resultSet.getInt(""debugger_id"");
				 final boolean isStared = resultSet.getBoolean(""stared"");
				 final int initializationState = resultSet.getInt(""initialization_state"");
				 final DebuggerTemplate description = debuggerManager.findDebugger(debuggerId);
				 final int rawModuleId = resultSet.getInt(""raw_module_id"");
				 final INaviRawModule rawModule = PostgreSQLDatabaseFunctions.findRawModule(rawModuleId, rawModules);
				 if ((functionCount == 0) && (rawModule != null)) {
					 functionCount = rawModule.getFunctionCount();
				 }
				 modules.add(new CModule(moduleId, name, comment, timestamp, modificationDate, md5, sha1, functionCount, viewCount, fileBase, imageBase, description, rawModule, initializationState, isStared, provider));
			 }
		 }
		 catch (final SQLException e) {
			 throw new CouldntLoadDataException(e);
		 }
		 return new ArrayList<INaviModule>(modules);
	 }
	 public static List<INaviProject> loadProjects(final AbstractSQLProvider provider, final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {
		 PostgreSQLDatabaseFunctions.checkArguments(provider, debuggerManager);
		 final CConnection connection = provider.getConnection();
		 final List<INaviProject> projects = new ArrayList<>();
		 if (!PostgreSQLHelpers.hasTable(connection, CTableNames.PROJECTS_TABLE)) {
			 return projects;
		 }
		 String query = ""SELECT id, name, description, creation_date, modification_date, "" + "" (SELECT count(*) FROM "" + CTableNames.ADDRESS_SPACES_TABLE + "" WHERE project_id = "" + CTableNames.PROJECTS_TABLE + "".id) "" + "" AS addressspace_count FROM "" + CTableNames.PROJECTS_TABLE;
		 try (ResultSet resultSet = connection.executeQuery(query, true)) {
			 while (resultSet.next()) {
				 final int projectId = resultSet.getInt(""id"");
				 final String name = PostgreSQLHelpers.readString(resultSet, ""name"");
				 final String description = PostgreSQLHelpers.readString(resultSet, ""description"");
				 final int addressSpaceCount = resultSet.getInt(""addressspace_count"");
				 final Timestamp creationDate = resultSet.getTimestamp(""creation_date"");
				 final Timestamp modificationDate = resultSet.getTimestamp(""modification_date"");
				 final List<DebuggerTemplate> debuggers = PostgreSQLDatabaseFunctions.getAssignedDebuggers(connection, projectId, debuggerManager);
				 projects.add(new CProject(projectId, name, description == null ? """" : description, creationDate, modificationDate, addressSpaceCount, debuggers, provider));
			 }
		 }
		 catch (final SQLException e) {
			 throw new CouldntLoadDataException(e);
		 }
		 return new ArrayList<INaviProject>(projects);
	 }
	 public static final List<INaviRawModule> loadRawModules(final AbstractSQLProvider provider) throws CouldntLoadDataException {
		 Preconditions.checkNotNull(provider, ""IE00416: Provider argument can not be null"");
		 final CConnection connection = provider.getConnection();
		 final List<INaviRawModule> modules = new ArrayList<INaviRawModule>();
		 if (!PostgreSQLHelpers.hasTable(connection, CTableNames.RAW_MODULES_TABLE)) {
			 return modules;
		 }
		 final String query = ""SELECT id, name FROM "" + CTableNames.RAW_MODULES_TABLE + "" ORDER BY id"";
		 try (ResultSet resultSet = connection.executeQuery(query, true)) {
			 while (resultSet.next()) {
				 final int rawModuleId = resultSet.getInt(""id"");
				 final String name = PostgreSQLHelpers.readString(resultSet, ""name"");
				 final boolean isComplete = PostgreSQLDatabaseFunctions.checkRawModulesTables(provider.getConnection(), PostgreSQLHelpers.getDatabaseName(provider.getConnection()), rawModuleId);
				 final int functionCount = isComplete ? PostgreSQLDatabaseFunctions.getRawModuleFunctionCount(connection, rawModuleId) : 0;
				 final CRawModule module = new CRawModule(rawModuleId, name, functionCount, isComplete, provider);
				 modules.add(module);
			 }
		 }
		 catch (final SQLException e) {
			 throw new CouldntLoadDataException(e);
		 }
		 return modules;
	 }
	 private static void databaseUpdater(final CConnection connection, final String resource) throws CouldntUpdateDatabaseException {
		 final BufferedReader input = new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(resource)));
		 final StringBuffer contents = new StringBuffer();
		 String line = null;
		 try {
			 while ((line = input.readLine()) != null) {
				 if (line.length() > 0 && line.charAt(0) == '#') {
					 continue;
				 }
				 contents.append(line);
				 contents.append('\n');
			 }
			 input.close();
		 }
		 catch (final IOException exception) {
			 throw new CouldntUpdateDatabaseException(exception.toString(), 40);
		 }
		 try (PreparedStatement statement = connection.getConnection().prepareStatement(contents.toString())) {
			 statement.execute();
		 }
		 catch (final SQLException exception) {
			 throw new CouldntUpdateDatabaseException(exception.toString(), 41);
		 }
	 }
	 public static void updateDatabase(final SQLProvider provider) throws CouldntUpdateDatabaseException {
		 try {
			 if (provider.getDatabaseVersion().compareTo(new DatabaseVersion(""4.0.0"")) == 0) {
				 databaseUpdater(provider.getConnection(), ""com/google/security/zynamics/binnavi/data/"" + ""postgresql_convert_4_0_7_to_5_0_0.sql"");
				 databaseUpdater(provider.getConnection(), ""com/google/security/zynamics/binnavi/data/"" + ""postgresql_convert_5_0_0_to_5_0_1.sql"");
			 }
			 else if (provider.getDatabaseVersion().compareTo(new DatabaseVersion(""5.0.0"")) == 0) {
				 databaseUpdater(provider.getConnection(), ""com/google/security/zynamics/binnavi/data/"" + ""postgresql_convert_5_0_0_to_5_0_1.sql"");
			 }
		 }
		 catch (final CouldntLoadDataException exception) {
			 CUtilityFunctions.logException(exception);
		 }
	 }
}",1,0,0,0
public Object clone();,0,0,0,0
"public class SpringMetadata implements BeanMetadata {
	 private final String beanName;
	 public SpringMetadata(String beanName) {
		 this.beanName = beanName;
	 }
	 public BeanDefinition getDefinition() {
		 return getBeanDefinition(beanName);
	 }
	 public String getId() {
		 return beanName;
	 }
	 public String getScope() {
		 return getDefinition().isSingleton() ? SCOPE_SINGLETON : SCOPE_PROTOTYPE;
	 }
	 public int getActivation() {
		 return getDefinition().isLazyInit() ? ACTIVATION_LAZY : ACTIVATION_EAGER;
	 }
	 public List<String> getDependsOn() {
		 String[] dependson = getDefinition().getDependsOn();
		 return dependson != null ? Arrays.asList(dependson) : Collections.<String>emptyList();
	 }
	 public String getClassName() {
		 return null;
	 }
	 public String getInitMethod() {
		 return null;
	 }
	 public String getDestroyMethod() {
		 return null;
	 }
	 public List<BeanArgument> getArguments() {
		 return Collections.<BeanArgument>singletonList(new BeanArgument() {
			 public Metadata getValue() {
				 return new ValueMetadata() {
					 public String getStringValue() {
						 return beanName;
					 }
					 public String getType() {
						 return null;
					 }
				 }
				;
			 }
			 public String getValueType() {
				 return null;
			 }
			 public int getIndex() {
				 return -1;
			 }
		 }
		);
	 }
	 public List<BeanProperty> getProperties() {
		 return Collections.emptyList();
	 }
	 public String getFactoryMethod() {
		 return ""getBean"";
	 }
	 public Target getFactoryComponent() {
		 return new RefMetadata() {
			 public String getComponentId() {
				 return BlueprintNamespaceHandler.SPRING_BEAN_FACTORY_ID;
			 }
		 }
		;
	 }
 }",0,0,0,0
"public void close() throws IOException {
	 buffer = null;
	 if (skipIOCache && bytesSinceCacheFlush > 0) CLibrary.trySkipCache(fd, 0, 0);
	 super.close();
 }",0,0,0,0
"class StandardDocFile extends DocFile {
	 private final Path file;
	 private StandardDocFile(Path file) {
		 this.file = file;
	 }
	 private StandardDocFile(Location location, DocPath path) {
		 super(location, path);
		 Assert.check(location == DocumentationTool.Location.DOCUMENTATION_OUTPUT);
		 this.file = newFile(getDestDir(), path.getPath());
	 }
	 public FileObject getFileObject() {
		 return getJavaFileObjectForInput(file);
	 }
	 public InputStream openInputStream() throws DocFileIOException {
		 try {
			 JavaFileObject fo = getJavaFileObjectForInput(file);
			 return new BufferedInputStream(fo.openInputStream());
		 }
		 catch (IOException e) {
			 throw new DocFileIOException(this, DocFileIOException.Mode.READ, e);
		 }
	 }
	 public OutputStream openOutputStream() throws DocFileIOException {
		 if (location != DocumentationTool.Location.DOCUMENTATION_OUTPUT) throw new IllegalStateException();
		 try {
			 OutputStream out = getFileObjectForOutput(path).openOutputStream();
			 return new BufferedOutputStream(out);
		 }
		 catch (IOException e) {
			 throw new DocFileIOException(this, DocFileIOException.Mode.WRITE, e);
		 }
	 }
	 public Writer openWriter() throws DocFileIOException, UnsupportedEncodingException {
		 if (location != DocumentationTool.Location.DOCUMENTATION_OUTPUT) throw new IllegalStateException();
		 try {
			 OutputStream out = getFileObjectForOutput(path).openOutputStream();
			 return new BufferedWriter(new OutputStreamWriter(out, configuration.docencoding));
		 }
		 catch (IOException e) {
			 throw new DocFileIOException(this, DocFileIOException.Mode.WRITE, e);
		 }
	 }
	 public boolean canRead() {
		 return Files.isReadable(file);
	 }
	 public boolean canWrite() {
		 return Files.isWritable(file);
	 }
	 public boolean exists() {
		 return Files.exists(file);
	 }
	 public String getName() {
		 return file.getFileName().toString();
	 }
	 public String getPath() {
		 return file.toString();
	 }
	 public boolean isAbsolute() {
		 return file.isAbsolute();
	 }
	 public boolean isDirectory() {
		 return Files.isDirectory(file);
	 }
	 public boolean isFile() {
		 return Files.isRegularFile(file);
	 }
	 public boolean isSameFile(DocFile other) {
		 if (!(other instanceof StandardDocFile)) return false;
		 try {
			 return Files.isSameFile(file, ((StandardDocFile) other).file);
		 }
		 catch (IOException e) {
			 return false;
		 }
	 }
	 public Iterable<DocFile> list() throws DocFileIOException {
		 List<DocFile> files = new ArrayList<>();
		 try (DirectoryStream<Path> ds = Files.newDirectoryStream(file)) {
			 for (Path f: ds) {
				 files.add(new StandardDocFile(f));
			 }
		 }
		 catch (IOException e) {
			 throw new DocFileIOException(this, DocFileIOException.Mode.READ, e);
		 }
		 return files;
	 }
	 public boolean mkdirs() {
		 try {
			 Files.createDirectories(file);
			 return true;
		 }
		 catch (IOException e) {
			 return false;
		 }
	 }
	 public DocFile resolve(DocPath p) {
		 return resolve(p.getPath());
	 }
	 public DocFile resolve(String p) {
		 if (location == null && path == null) {
			 return new StandardDocFile(file.resolve(p));
		 }
		 else {
			 return new StandardDocFile(location, path.resolve(p));
		 }
	 }
	 public DocFile resolveAgainst(Location locn) {
		 if (locn != DocumentationTool.Location.DOCUMENTATION_OUTPUT) throw new IllegalArgumentException();
		 return new StandardDocFile(getDestDir().resolve(file));
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 sb.append(""StandardDocFile["");
		 if (location != null) sb.append(""locn:"").append(location).append("","");
		 if (path != null) sb.append(""path:"").append(path.getPath()).append("","");
		 sb.append(""file:"").append(file);
		 sb.append(""]"");
		 return sb.toString();
	 }
	 private JavaFileObject getJavaFileObjectForInput(Path file) {
		 return fileManager.getJavaFileObjects(file).iterator().next();
	 }
	 private FileObject getFileObjectForOutput(DocPath path) throws IOException {
		 String p = path.getPath();
		 int lastSep = -1;
		 for (int i = 0;
		 i < p.length();
		 i++) {
			 char ch = p.charAt(i);
			 if (ch == '/') {
				 lastSep = i;
			 }
			 else if (i == lastSep + 1 && !Character.isJavaIdentifierStart(ch) || !Character.isJavaIdentifierPart(ch)) {
				 break;
			 }
		 }
		 String pkg = (lastSep == -1) ? """" : p.substring(0, lastSep);
		 String rest = p.substring(lastSep + 1);
		 return fileManager.getFileForOutput(location, pkg, rest, null);
	 }
 }",0,0,0,0
"public class QuickfixjEndpoint extends DefaultEndpoint implements QuickfixjEventListener, MultipleConsumersSupport {
	 public static final String EVENT_CATEGORY_KEY = ""EventCategory"";
	 public static final String SESSION_ID_KEY = ""SessionID"";
	 public static final String MESSAGE_TYPE_KEY = ""MessageType"";
	 public static final String DATA_DICTIONARY_KEY = ""DataDictionary"";
	 private final QuickfixjEngine engine;
	 private final List<QuickfixjConsumer> consumers = new CopyOnWriteArrayList<>();
	 private String configurationName;
	 private SessionID sessionID;
	 private boolean lazyCreateEngine;
	 public QuickfixjEndpoint(QuickfixjEngine engine, String uri, Component component) {
		 super(uri, component);
		 this.engine = engine;
	 }
	 public SessionID getSessionID() {
		 return sessionID;
	 }
	 public void setSessionID(SessionID sessionID) {
		 this.sessionID = sessionID;
	 }
	 public String getConfigurationName() {
		 return configurationName;
	 }
	 public void setConfigurationName(String configurationName) {
		 this.configurationName = configurationName;
	 }
	 public boolean isLazyCreateEngine() {
		 return lazyCreateEngine;
	 }
	 public void setLazyCreateEngine(boolean lazyCreateEngine) {
		 this.lazyCreateEngine = lazyCreateEngine;
	 }
	 public Consumer createConsumer(Processor processor) throws Exception {
		 log.info(""Creating QuickFIX/J consumer: {
		}
		, ExchangePattern={
		}
		"", sessionID != null ? sessionID : ""No Session"", getExchangePattern());
		 QuickfixjConsumer consumer = new QuickfixjConsumer(this, processor);
		 configureConsumer(consumer);
		 consumers.add(consumer);
		 return consumer;
	 }
	 public Producer createProducer() throws Exception {
		 log.info(""Creating QuickFIX/J producer: {
		}
		"", sessionID != null ? sessionID : ""No Session"");
		 if (isWildcarded()) {
			 throw new ResolveEndpointFailedException(""Cannot create consumer on wildcarded session identifier: "" + sessionID);
		 }
		 return new QuickfixjProducer(this);
	 }
	 public boolean isSingleton() {
		 return true;
	 }
	 public void onEvent(QuickfixjEventCategory eventCategory, SessionID sessionID, Message message) throws Exception {
		 if (this.sessionID == null || isMatching(sessionID)) {
			 for (QuickfixjConsumer consumer : consumers) {
				 Exchange exchange = QuickfixjConverters.toExchange(this, sessionID, message, eventCategory, getExchangePattern());
				 consumer.onExchange(exchange);
				 if (exchange.getException() != null) {
					 throw exchange.getException();
				 }
			 }
		 }
	 }
	 private boolean isMatching(SessionID sessionID) {
		 if (this.sessionID.equals(sessionID)) {
			 return true;
		 }
		 return isMatching(this.sessionID.getBeginString(), sessionID.getBeginString()) && isMatching(this.sessionID.getSenderCompID(), sessionID.getSenderCompID()) && isMatching(this.sessionID.getSenderSubID(), sessionID.getSenderSubID()) && isMatching(this.sessionID.getSenderLocationID(), sessionID.getSenderLocationID()) && isMatching(this.sessionID.getTargetCompID(), sessionID.getTargetCompID()) && isMatching(this.sessionID.getTargetSubID(), sessionID.getTargetSubID()) && isMatching(this.sessionID.getTargetLocationID(), sessionID.getTargetLocationID());
	 }
	 private boolean isMatching(String s1, String s2) {
		 return s1.equals("""") || s1.equals(""*"") || s1.equals(s2);
	 }
	 private boolean isWildcarded() {
		 if (sessionID == null) {
			 return false;
		 }
		 return sessionID.getBeginString().equals(""*"") || sessionID.getSenderCompID().equals(""*"") || sessionID.getSenderSubID().equals(""*"") || sessionID.getSenderLocationID().equals(""*"") || sessionID.getTargetCompID().equals(""*"") || sessionID.getTargetSubID().equals(""*"") || sessionID.getTargetLocationID().equals(""*"");
	 }
	 public boolean isMultipleConsumersSupported() {
		 return true;
	 }
	 public void ensureInitialized() throws Exception {
		 if (!engine.isInitialized()) {
			 synchronized (engine) {
				 if (!engine.isInitialized()) {
					 engine.initializeEngine();
					 engine.start();
				 }
			 }
		 }
	 }
	 public QuickfixjEngine getEngine() {
		 return engine;
	 }
	 protected void doStop() throws Exception {
		 consumers.clear();
	 }
}",1,1,0,0
"public void renderOnEventJavascript(String target, String event, String javascript){
	realResponse.renderOnEventJavascript(target, event, javascript);
}",0,0,0,0
"public ExchangeSession(String url, String userName, String password) throws IOException {
	 this.userName = userName;
	 try {
		 httpClient = DavGatewayHttpClientFacade.getInstance(url);
		 DavGatewayHttpClientFacade.createMultiThreadedHttpConnectionManager(httpClient);
		 boolean isBasicAuthentication = isBasicAuthentication(httpClient, url);
		 httpClient.getState().clearCookies();
		 if (preAuthUsername == null) {
			 int doubleQuoteIndex = this.userName.indexOf('""');
			 if (doubleQuoteIndex > 0) {
				 preAuthUsername = this.userName.substring(0, doubleQuoteIndex);
				 this.userName = this.userName.substring(doubleQuoteIndex + 1);
			 }
			 else {
				 preAuthUsername = this.userName;
			 }
		 }
		 DavGatewayHttpClientFacade.setCredentials(httpClient, userName, password);
		 HttpMethod method = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, url);
		 if (!this.isAuthenticated(method)) {
			 if (isBasicAuthentication) {
				 int status = method.getStatusCode();
				 if (status == HttpStatus.SC_UNAUTHORIZED) {
					 method.releaseConnection();
					 throw new DavMailAuthenticationException(""EXCEPTION_AUTHENTICATION_FAILED"");
				 }
				 else if (status != HttpStatus.SC_OK) {
					 method.releaseConnection();
					 throw DavGatewayHttpClientFacade.buildHttpException(method);
				 }
				 if (""/owa/auth/logon.aspx"".equals(method.getPath())) {
					 method = formLogin(httpClient, method, userName, password);
				 }
			 }
			 else {
				 method = formLogin(httpClient, method, userName, password);
			 }
		 }
		 if (isBasicAuthentication && !DavGatewayHttpClientFacade.hasNTLMorNegotiate(httpClient)) {
			 httpClient.getParams().setParameter(HttpClientParams.PREEMPTIVE_AUTHENTICATION, true);
		 }
		 buildSessionInfo(method);
	 }
	 catch (DavMailAuthenticationException exc) {
		 LOGGER.error(exc.getMessage());
		 throw exc;
	 }
	 catch (ConnectException exc) {
		 BundleMessage message = new BundleMessage(""EXCEPTION_CONNECT"", exc.getClass().getName(), exc.getMessage());
		 ExchangeSession.LOGGER.error(message);
		 throw new DavMailException(""EXCEPTION_DAVMAIL_CONFIGURATION"", message);
	 }
	 catch (UnknownHostException exc) {
		 BundleMessage message = new BundleMessage(""EXCEPTION_CONNECT"", exc.getClass().getName(), exc.getMessage());
		 ExchangeSession.LOGGER.error(message);
		 throw new DavMailException(""EXCEPTION_DAVMAIL_CONFIGURATION"", message);
	 }
	 catch (WebdavNotAvailableException exc) {
		 throw exc;
	 }
	 catch (IOException exc) {
		 LOGGER.error(BundleMessage.formatLog(""EXCEPTION_EXCHANGE_LOGIN_FAILED"", exc));
		 throw new DavMailException(""EXCEPTION_EXCHANGE_LOGIN_FAILED"", exc);
	 }
	 LOGGER.debug(""Session "" + this + "" created"");
 }",0,0,1,0
"private void createStudentNFR(int inputNum, List<Integer> inputSets, int outNum,double[][] pointsSets, double[][] timeSets) {
	this.setNetworkType(NeuralNetworkType.NEURO_FUZZY_REASONER);
	NeuronProperties neuronProperties = new NeuronProperties();
	Layer inLayer = LayerFactory.createLayer(inputNum, neuronProperties);
	this.addLayer(inLayer);
	neuronProperties.setProperty(""transferFunction"",TransferFunctionType.TRAPEZOID);
	Iterator<Integer> e = inputSets.iterator();
	int fuzzySetsNum = 0;
	while (e.hasNext()) {
		Integer i = e.next();
		fuzzySetsNum = fuzzySetsNum + i.intValue();
	}
	Layer setLayer = LayerFactory.createLayer(fuzzySetsNum,neuronProperties);
	this.addLayer(setLayer);
	Iterator<Integer> en;
	int c = 0;
	 for(Neuron cell : setLayer.getNeurons()) {
		Trapezoid tf = (Trapezoid) cell.getTransferFunction();
		if (c <= 3) {
			tf.setLeftLow(pointsSets[c][0]);
			tf.setLeftHigh(pointsSets[c][1]);
			tf.setRightLow(pointsSets[c][3]);
			tf.setRightHigh(pointsSets[c][2]);
		}
		 else {
			tf.setLeftLow(timeSets[c - 4][0]);
			tf.setLeftHigh(timeSets[c - 4][1]);
			tf.setRightLow(timeSets[c - 4][3]);
			tf.setRightHigh(timeSets[c - 4][2]);
		}
		c++;
	}
	int s = 0;
	 for (int i = 0;
	 i < inputNum;
	 i++) {
		 Neuron from = inLayer.getNeuronAt(i);
		int jmax = inputSets.get(i).intValue();
		for (int j = 0;
		 j < jmax;
		 j++) {
			Neuron to = setLayer.getNeuronAt(s);
			ConnectionFactory.createConnection(from, to, 1);
			s++;
		}
	}
	NeuronProperties ruleNeuronProperties = new NeuronProperties( Neuron.class, WeightedSum.class, Linear.class);
	en = inputSets.iterator();
	int fuzzyAntNum = 1;
	while (en.hasNext()) {
		Integer i = en.next();
		fuzzyAntNum = fuzzyAntNum * i.intValue();
	}
	Layer ruleLayer = LayerFactory.createLayer(fuzzyAntNum,ruleNeuronProperties);
	this.addLayer(ruleLayer);
	int scIdx = 0;
	 for (int i = 0;
	 i < inputNum;
	 i++) {
		 int setsNum = inputSets.get(i).intValue();
		for (int si = 0;
		 si < setsNum;
		 si++) {
			 if (i == 0) {
				Neuron from = setLayer.getNeuronAt(si);
				int connPerCell = fuzzyAntNum / setsNum;
				scIdx = si;
				for (int k = 0;
				 k < connPerCell;
				 k++) {
					 Neuron to = ruleLayer.getNeuronAt(si * connPerCell + k);
					ConnectionFactory.createConnection(from, to, 1);
				}
			 }
			 else {
				scIdx++;
				Neuron from = setLayer.getNeuronAt(scIdx);
				int connPerCell = fuzzyAntNum / setsNum;
				for (int k = 0;
				 k < connPerCell;
				 k++) {
					 int toIdx = si + k * setsNum;
					Neuron to = ruleLayer.getNeuronAt(toIdx);
					ConnectionFactory.createConnection(from, to, 1);
				}
			 }
		 }
	 }
	 neuronProperties = new NeuronProperties();
	neuronProperties.setProperty(""transferFunction"",TransferFunctionType.STEP);
	Layer outLayer = LayerFactory.createLayer(outNum, neuronProperties);
	this.addLayer(outLayer);
	ConnectionFactory.fullConnect(ruleLayer, outLayer);
	NeuralNetworkFactory.setDefaultIO(this);
	this.setLearningRule(new LMS());
}",0,0,1,0
"class CFRouteImpl implements CFRoute {
	final private String domain;
	final private String host;
	final private String path;
	final private int port;
	final private String fullRoute;
	CFRouteImpl(String domain, String host, String path, int port, String fullRoute) {
		super();
		this.domain = domain;
		this.host = host;
		this.path = path;
		this.port = port;
		this.fullRoute = fullRoute;
	}
	public String getDomain() {
		return domain;
	}
	public String getHost() {
		return host;
	}
	public String getPath() {
		return path;
	}
	public int getPort() {
		return port;
	}
	public String getRoute() {
		return fullRoute;
	}
	public String toString() {
		return ""CFRoute [domain="" + domain + "", host="" + host + "", path="" + path + "", port="" + port +""]"";
	}
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((domain == null) ? 0 : domain.hashCode());
		result = prime * result + ((fullRoute == null) ? 0 : fullRoute.hashCode());
		result = prime * result + ((host == null) ? 0 : host.hashCode());
		result = prime * result + ((path == null) ? 0 : path.hashCode());
		result = prime * result + port;
		return result;
	}
	public boolean equals(Object obj) {
		if (this == obj)return true;
		if (obj == null)return false;
		if (getClass() != obj.getClass())return false;
		CFRouteImpl other = (CFRouteImpl) obj;
		if (domain == null) {
			if (other.domain != null)return false;
		}
		 else if (!domain.equals(other.domain))return false;
		if (fullRoute == null) {
			if (other.fullRoute != null)return false;
		}
		 else if (!fullRoute.equals(other.fullRoute))return false;
		if (host == null) {
			if (other.host != null)return false;
		}
		 else if (!host.equals(other.host))return false;
		if (path == null) {
			if (other.path != null)return false;
		}
		 else if (!path.equals(other.path))return false;
		if (port != other.port)return false;
		return true;
	}
}",1,1,0,0
"public SystemDiagnosticsDTO createSystemDiagnosticsDto(final SystemDiagnostics sysDiagnostics) {
	 final SystemDiagnosticsDTO dto = new SystemDiagnosticsDTO();
	 final SystemDiagnosticsSnapshotDTO snapshot = new SystemDiagnosticsSnapshotDTO();
	 dto.setAggregateSnapshot(snapshot);
	 snapshot.setStatsLastRefreshed(new Date(sysDiagnostics.getCreationTimestamp()));
	 snapshot.setAvailableProcessors(sysDiagnostics.getAvailableProcessors());
	 snapshot.setProcessorLoadAverage(sysDiagnostics.getProcessorLoadAverage());
	 snapshot.setDaemonThreads(sysDiagnostics.getDaemonThreads());
	 snapshot.setTotalThreads(sysDiagnostics.getTotalThreads());
	 snapshot.setMaxHeap(FormatUtils.formatDataSize(sysDiagnostics.getMaxHeap()));
	 snapshot.setMaxHeapBytes(sysDiagnostics.getMaxHeap());
	 snapshot.setTotalHeap(FormatUtils.formatDataSize(sysDiagnostics.getTotalHeap()));
	 snapshot.setTotalHeapBytes(sysDiagnostics.getTotalHeap());
	 snapshot.setUsedHeap(FormatUtils.formatDataSize(sysDiagnostics.getUsedHeap()));
	 snapshot.setUsedHeapBytes(sysDiagnostics.getUsedHeap());
	 snapshot.setFreeHeap(FormatUtils.formatDataSize(sysDiagnostics.getFreeHeap()));
	 snapshot.setFreeHeapBytes(sysDiagnostics.getFreeHeap());
	 if (sysDiagnostics.getHeapUtilization() != -1) {
		 snapshot.setHeapUtilization(FormatUtils.formatUtilization(sysDiagnostics.getHeapUtilization()));
	 }
	 snapshot.setMaxNonHeap(FormatUtils.formatDataSize(sysDiagnostics.getMaxNonHeap()));
	 snapshot.setMaxNonHeapBytes(sysDiagnostics.getMaxNonHeap());
	 snapshot.setTotalNonHeap(FormatUtils.formatDataSize(sysDiagnostics.getTotalNonHeap()));
	 snapshot.setTotalNonHeapBytes(sysDiagnostics.getTotalNonHeap());
	 snapshot.setUsedNonHeap(FormatUtils.formatDataSize(sysDiagnostics.getUsedNonHeap()));
	 snapshot.setUsedNonHeapBytes(sysDiagnostics.getUsedNonHeap());
	 snapshot.setFreeNonHeap(FormatUtils.formatDataSize(sysDiagnostics.getFreeNonHeap()));
	 snapshot.setFreeNonHeapBytes(sysDiagnostics.getFreeNonHeap());
	 if (sysDiagnostics.getNonHeapUtilization() != -1) {
		 snapshot.setNonHeapUtilization(FormatUtils.formatUtilization(sysDiagnostics.getNonHeapUtilization()));
	 }
	 final SystemDiagnosticsSnapshotDTO.StorageUsageDTO flowFileRepositoryStorageUsageDto = createStorageUsageDTO(null, sysDiagnostics.getFlowFileRepositoryStorageUsage());
	 snapshot.setFlowFileRepositoryStorageUsage(flowFileRepositoryStorageUsageDto);
	 final Set<SystemDiagnosticsSnapshotDTO.StorageUsageDTO> contentRepositoryStorageUsageDtos = new LinkedHashSet<>();
	 snapshot.setContentRepositoryStorageUsage(contentRepositoryStorageUsageDtos);
	 for (final Map.Entry<String, StorageUsage> entry : sysDiagnostics.getContentRepositoryStorageUsage().entrySet()) {
		 contentRepositoryStorageUsageDtos.add(createStorageUsageDTO(entry.getKey(), entry.getValue()));
	 }
	 final Set<SystemDiagnosticsSnapshotDTO.StorageUsageDTO> provenanceRepositoryStorageUsageDtos = new LinkedHashSet<>();
	 snapshot.setProvenanceRepositoryStorageUsage(provenanceRepositoryStorageUsageDtos);
	 for (final Map.Entry<String, StorageUsage> entry : sysDiagnostics.getProvenanceRepositoryStorageUsage().entrySet()) {
		 provenanceRepositoryStorageUsageDtos.add(createStorageUsageDTO(entry.getKey(), entry.getValue()));
	 }
	 final Set<SystemDiagnosticsSnapshotDTO.GarbageCollectionDTO> garbageCollectionDtos = new LinkedHashSet<>();
	 snapshot.setGarbageCollection(garbageCollectionDtos);
	 for (final Map.Entry<String, GarbageCollection> entry : sysDiagnostics.getGarbageCollection().entrySet()) {
		 garbageCollectionDtos.add(createGarbageCollectionDTO(entry.getKey(), entry.getValue()));
	 }
	 final SystemDiagnosticsSnapshotDTO.VersionInfoDTO versionInfoDto = createVersionInfoDTO();
	 snapshot.setVersionInfo(versionInfoDto);
	 snapshot.setUptime(FormatUtils.formatHoursMinutesSeconds(sysDiagnostics.getUptime(), TimeUnit.MILLISECONDS));
	 return dto;
 }",0,0,1,0
"public class FTP extends Task {
	 protected static final int SEND_FILES = 0;
	 protected static final int GET_FILES = 1;
	 protected static final int DEL_FILES = 2;
	 protected static final int LIST_FILES = 3;
	 protected static final int MK_DIR = 4;
	 protected static final int CHMOD = 5;
	 protected static final int RM_DIR = 6;
	 protected static final int SITE_CMD = 7;
	 private static final int CODE_521 = 521;
	 private static final long GRANULARITY_MINUTE = 60000L;
	 public static final int DEFAULT_FTP_PORT = 21;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String remotedir;
	 private String server;
	 private String userid;
	 private String password;
	 private String account;
	 private File listing;
	 private boolean binary = true;
	 private boolean passive = false;
	 private boolean verbose = false;
	 private boolean newerOnly = false;
	 private long timeDiffMillis = 0;
	 private long granularityMillis = 0L;
	 private boolean timeDiffAuto = false;
	 private int action = SEND_FILES;
	 private Vector filesets = new Vector();
	 private Vector dirCache = new Vector();
	 private int transferred = 0;
	 private String remoteFileSep = ""/"";
	 private int port = DEFAULT_FTP_PORT;
	 private boolean skipFailedTransfers = false;
	 private int skipped = 0;
	 private boolean ignoreNoncriticalErrors = false;
	 private boolean preserveLastModified = false;
	 private String chmod = null;
	 private String umask = null;
	 private FTPSystemType systemTypeKey = FTPSystemType.getDefault();
	 private String defaultDateFormatConfig = null;
	 private String recentDateFormatConfig = null;
	 private LanguageCode serverLanguageCodeConfig = LanguageCode.getDefault();
	 private String serverTimeZoneConfig = null;
	 private String shortMonthNamesConfig = null;
	 private Granularity timestampGranularity = Granularity.getDefault();
	 private boolean isConfigurationSet = false;
	 private int retriesAllowed = 0;
	 private String siteCommand = null;
	 private String initialSiteCommand = null;
	 protected static final String[] ACTION_STRS = {
	 ""sending"", ""getting"", ""deleting"", ""listing"", ""making directory"", ""chmod"", ""removing"", ""site"" }
	;
	 protected static final String[] COMPLETED_ACTION_STRS = {
	 ""sent"", ""retrieved"", ""deleted"", ""listed"", ""created directory"", ""mode changed"", ""removed"", ""site command executed"" }
	;
	 protected static final String[] ACTION_TARGET_STRS = {
	 ""files"", ""files"", ""files"", ""files"", ""directory"", ""files"", ""directories"", ""site command"" }
	;
	 protected class FTPDirectoryScanner extends DirectoryScanner {
		 protected FTPClient ftp = null;
		 private String rootPath = null;
		 private boolean remoteSystemCaseSensitive = false;
		 private boolean remoteSensitivityChecked = false;
		 public FTPDirectoryScanner(FTPClient ftp) {
			 super();
			 this.ftp = ftp;
			 this.setFollowSymlinks(false);
		 }
		 public void scan() {
			 if (includes == null) {
				 includes = new String[1];
				 includes[0] = ""**"";
			 }
			 if (excludes == null) {
				 excludes = new String[0];
			 }
			 filesIncluded = new Vector();
			 filesNotIncluded = new Vector();
			 filesExcluded = new Vector();
			 dirsIncluded = new Vector();
			 dirsNotIncluded = new Vector();
			 dirsExcluded = new Vector();
			 try {
				 String cwd = ftp.printWorkingDirectory();
				 forceRemoteSensitivityCheck();
				 checkIncludePatterns();
				 clearCaches();
				 ftp.changeWorkingDirectory(cwd);
			 }
			 catch (IOException e) {
				 throw new BuildException(""Unable to scan FTP server: "", e);
			 }
		 }
		 private void checkIncludePatterns() {
			 Hashtable newroots = new Hashtable();
			 for (int icounter = 0;
			 icounter < includes.length;
			 icounter++) {
				 String newpattern = SelectorUtils.rtrimWildcardTokens(includes[icounter]);
				 newroots.put(newpattern, includes[icounter]);
			 }
			 if (remotedir == null) {
				 try {
					 remotedir = ftp.printWorkingDirectory();
				 }
				 catch (IOException e) {
					 throw new BuildException(""could not read current ftp directory"", getLocation());
				 }
			 }
			 AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, remotedir);
			 rootPath = baseFTPFile.getAbsolutePath();
			 if (newroots.containsKey("""")) {
				 scandir(rootPath, """", true);
			 }
			 else {
				 Enumeration enum2 = newroots.keys();
				 while (enum2.hasMoreElements()) {
					 String currentelement = (String) enum2.nextElement();
					 String originalpattern = (String) newroots.get(currentelement);
					 AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
					 boolean isOK = true;
					 boolean traversesSymlinks = false;
					 String path = null;
					 if (myfile.exists()) {
						 forceRemoteSensitivityCheck();
						 if (remoteSensitivityChecked && remoteSystemCaseSensitive && isFollowSymlinks()) {
							 path = myfile.getFastRelativePath();
						 }
						 else {
							 try {
								 path = myfile.getRelativePath();
								 traversesSymlinks = myfile.isTraverseSymlinks();
							 }
							 catch (IOException be) {
								 throw new BuildException(be, getLocation());
							 }
							 catch (BuildException be) {
								 isOK = false;
							 }
						 }
					 }
					 else {
						 isOK = false;
					 }
					 if (isOK) {
						 currentelement = path.replace(remoteFileSep.charAt(0), File.separatorChar);
						 if (!isFollowSymlinks() && traversesSymlinks) {
							 continue;
						 }
						 if (myfile.isDirectory()) {
							 if (isIncluded(currentelement) && currentelement.length() > 0) {
								 accountForIncludedDir(currentelement, myfile, true);
							 }
							 else {
								 if (currentelement.length() > 0) {
									 if (currentelement.charAt(currentelement .length() - 1) != File.separatorChar) {
										 currentelement = currentelement + File.separatorChar;
									 }
								 }
								 scandir(myfile.getAbsolutePath(), currentelement, true);
							 }
						 }
						 else {
							 if (isCaseSensitive && originalpattern.equals(currentelement)) {
								 accountForIncludedFile(currentelement);
							 }
							 else if (!isCaseSensitive && originalpattern .equalsIgnoreCase(currentelement)) {
								 accountForIncludedFile(currentelement);
							 }
						 }
					 }
				 }
			 }
		 }
		 protected void scandir(String dir, String vpath, boolean fast) {
			 if (fast && hasBeenScanned(vpath)) {
				 return;
			 }
			 try {
				 if (!ftp.changeWorkingDirectory(dir)) {
					 return;
				 }
				 String completePath = null;
				 if (!vpath.equals("""")) {
					 completePath = rootPath + remoteFileSep + vpath.replace(File.separatorChar, remoteFileSep.charAt(0));
				 }
				 else {
					 completePath = rootPath;
				 }
				 FTPFile[] newfiles = listFiles(completePath, false);
				 if (newfiles == null) {
					 ftp.changeToParentDirectory();
					 return;
				 }
				 for (int i = 0;
				 i < newfiles.length;
				 i++) {
					 FTPFile file = newfiles[i];
					 if (file != null && !file.getName().equals(""."") && !file.getName().equals("".."")) {
						 if (isFunctioningAsDirectory(ftp, dir, file)) {
							 String name = vpath + file.getName();
							 boolean slowScanAllowed = true;
							 if (!isFollowSymlinks() && file.isSymbolicLink()) {
								 dirsExcluded.addElement(name);
								 slowScanAllowed = false;
							 }
							 else if (isIncluded(name)) {
								 accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath) , fast);
							 }
							 else {
								 dirsNotIncluded.addElement(name);
								 if (fast && couldHoldIncluded(name)) {
									 scandir(file.getName(), name + File.separator, fast);
								 }
							 }
							 if (!fast && slowScanAllowed) {
								 scandir(file.getName(), name + File.separator, fast);
							 }
						 }
						 else {
							 String name = vpath + file.getName();
							 if (!isFollowSymlinks() && file.isSymbolicLink()) {
								 filesExcluded.addElement(name);
							 }
							 else if (isFunctioningAsFile(ftp, dir, file)) {
								 accountForIncludedFile(name);
							 }
						 }
					 }
				 }
				 ftp.changeToParentDirectory();
			 }
			 catch (IOException e) {
				 throw new BuildException(""Error while communicating with FTP "" + ""server: "", e);
			 }
		 }
		 private void accountForIncludedFile(String name) {
			 if (!filesIncluded.contains(name) && !filesExcluded.contains(name)) {
				 if (isIncluded(name)) {
					 if (!isExcluded(name)) {
						 filesIncluded.addElement(name);
					 }
					 else {
						 filesExcluded.addElement(name);
					 }
				 }
				 else {
					 filesNotIncluded.addElement(name);
				 }
			 }
		 }
		 private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
			 if (!dirsIncluded.contains(name) && !dirsExcluded.contains(name)) {
				 if (!isExcluded(name)) {
					 if (fast) {
						 if (file.isSymbolicLink()) {
							 try {
								 file.getClient().changeWorkingDirectory(file.curpwd);
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""could not change directory to curpwd"");
							 }
							 scandir(file.getLink(), name + File.separator, fast);
						 }
						 else {
							 try {
								 file.getClient().changeWorkingDirectory(file.curpwd);
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""could not change directory to curpwd"");
							 }
							 scandir(file.getName(), name + File.separator, fast);
						 }
					 }
					 dirsIncluded.addElement(name);
				 }
				 else {
					 dirsExcluded.addElement(name);
					 if (fast && couldHoldIncluded(name)) {
						 try {
							 file.getClient().changeWorkingDirectory(file.curpwd);
						 }
						 catch (IOException ioe) {
							 throw new BuildException(""could not change directory to curpwd"");
						 }
						 scandir(file.getName(), name + File.separator, fast);
					 }
				 }
			 }
		 }
		 private Map fileListMap = new HashMap();
		 private Set scannedDirs = new HashSet();
		 private boolean hasBeenScanned(String vpath) {
			 return !scannedDirs.add(vpath);
		 }
		 private void clearCaches() {
			 fileListMap.clear();
			 scannedDirs.clear();
		 }
		 public FTPFile[] listFiles(String directory, boolean changedir) {
			 String currentPath = directory;
			 if (changedir) {
				 try {
					 boolean result = ftp.changeWorkingDirectory(directory);
					 if (!result) {
						 return null;
					 }
					 currentPath = ftp.printWorkingDirectory();
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, getLocation());
				 }
			 }
			 if (fileListMap.containsKey(currentPath)) {
				 getProject().log(""filelist map used in listing files"", Project.MSG_DEBUG);
				 return ((FTPFile[]) fileListMap.get(currentPath));
			 }
			 FTPFile[] result = null;
			 try {
				 result = ftp.listFiles();
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, getLocation());
			 }
			 fileListMap.put(currentPath, result);
			 if (!remoteSensitivityChecked) {
				 checkRemoteSensitivity(result, directory);
			 }
			 return result;
		 }
		 private void forceRemoteSensitivityCheck() {
			 if (!remoteSensitivityChecked) {
				 try {
					 checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, getLocation());
				 }
			 }
		 }
		 public FTPFile[] listFiles(String directory) {
			 return listFiles(directory, true);
		 }
		 private void checkRemoteSensitivity(FTPFile[] array, String directory) {
			 if (array == null) {
				 return;
			 }
			 boolean candidateFound = false;
			 String target = null;
			 for (int icounter = 0;
			 icounter < array.length;
			 icounter++) {
				 if (array[icounter] != null && array[icounter].isDirectory()) {
					 if (!array[icounter].getName().equals(""."") && !array[icounter].getName().equals("".."")) {
						 candidateFound = true;
						 target = fiddleName(array[icounter].getName());
						 getProject().log(""will try to cd to "" + target + "" where a directory called "" + array[icounter].getName() + "" exists"", Project.MSG_DEBUG);
						 for (int pcounter = 0;
						 pcounter < array.length;
						 pcounter++) {
							 if (array[pcounter] != null && pcounter != icounter && target.equals(array[pcounter].getName())) {
								 candidateFound = false;
							 }
						 }
						 if (candidateFound) {
							 break;
						 }
					 }
				 }
			 }
			 if (candidateFound) {
				 try {
					 getProject().log(""testing case sensitivity, attempting to cd to "" + target, Project.MSG_DEBUG);
					 remoteSystemCaseSensitive = !ftp.changeWorkingDirectory(target);
				 }
				 catch (IOException ioe) {
					 remoteSystemCaseSensitive = true;
				 }
				 finally {
					 try {
						 ftp.changeWorkingDirectory(directory);
					 }
					 catch (IOException ioe) {
						 throw new BuildException(ioe, getLocation());
					 }
				 }
				 getProject().log(""remote system is case sensitive : "" + remoteSystemCaseSensitive, Project.MSG_VERBOSE);
				 remoteSensitivityChecked = true;
			 }
		 }
		 private String fiddleName(String origin) {
			 StringBuffer result = new StringBuffer();
			 for (int icounter = 0;
			 icounter < origin.length();
			 icounter++) {
				 if (Character.isLowerCase(origin.charAt(icounter))) {
					 result.append(Character.toUpperCase(origin.charAt(icounter)));
				 }
				 else if (Character.isUpperCase(origin.charAt(icounter))) {
					 result.append(Character.toLowerCase(origin.charAt(icounter)));
				 }
				 else {
					 result.append(origin.charAt(icounter));
				 }
			 }
			 return result.toString();
		 }
		 protected class AntFTPFile {
			 private FTPClient client;
			 private String curpwd;
			 private FTPFile ftpFile;
			 private AntFTPFile parent = null;
			 private boolean relativePathCalculated = false;
			 private boolean traversesSymlinks = false;
			 private String relativePath = """";
			 public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
				 this.client = client;
				 this.ftpFile = ftpFile;
				 this.curpwd = curpwd;
			 }
			 public AntFTPFile(AntFTPFile parent, String path) {
				 this.parent = parent;
				 this.client = parent.client;
				 Vector pathElements = SelectorUtils.tokenizePath(path);
				 try {
					 boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
					 if (!result) {
						 return;
					 }
					 this.curpwd = parent.getAbsolutePath();
				 }
				 catch (IOException ioe) {
					 throw new BuildException(""could not change working dir to "" + parent.curpwd);
				 }
				 for (int fcount = 0;
				 fcount < pathElements.size() - 1;
				 fcount++) {
					 String currentPathElement = (String) pathElements.elementAt(fcount);
					 try {
						 boolean result = this.client.changeWorkingDirectory(currentPathElement);
						 if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
							 currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement);
							 if (currentPathElement == null) {
								 return;
							 }
						 }
						 else if (!result) {
							 return;
						 }
						 this.curpwd = this.curpwd + remoteFileSep + currentPathElement;
					 }
					 catch (IOException ioe) {
						 throw new BuildException(""could not change working dir to "" + (String) pathElements.elementAt(fcount) + "" from "" + this.curpwd);
					 }
				 }
				 String lastpathelement = (String) pathElements.elementAt(pathElements.size() - 1);
				 FTPFile [] theFiles = listFiles(this.curpwd);
				 this.ftpFile = getFile(theFiles, lastpathelement);
			 }
			 private String findPathElementCaseUnsensitive(String parentPath, String soughtPathElement) {
				 FTPFile[] theFiles = listFiles(parentPath, false);
				 if (theFiles == null) {
					 return null;
				 }
				 for (int icounter = 0;
				 icounter < theFiles.length;
				 icounter++) {
					 if (theFiles[icounter] != null && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
						 return theFiles[icounter].getName();
					 }
				 }
				 return null;
			 }
			 public boolean exists() {
				 return (ftpFile != null);
			 }
			 public String getLink() {
				 return ftpFile.getLink();
			 }
			 public String getName() {
				 return ftpFile.getName();
			 }
			 public String getAbsolutePath() {
				 return curpwd + remoteFileSep + ftpFile.getName();
			 }
			 public String getFastRelativePath() {
				 String absPath = getAbsolutePath();
				 if (absPath.indexOf(rootPath + remoteFileSep) == 0) {
					 return absPath.substring(rootPath.length() + remoteFileSep.length());
				 }
				 return null;
			 }
			 public String getRelativePath() throws IOException, BuildException {
				 if (!relativePathCalculated) {
					 if (parent != null) {
						 traversesSymlinks = parent.isTraverseSymlinks();
						 relativePath = getRelativePath(parent.getAbsolutePath(), parent.getRelativePath());
					 }
					 else {
						 relativePath = getRelativePath(rootPath, """");
						 relativePathCalculated = true;
					 }
				 }
				 return relativePath;
			 }
			 private String getRelativePath(String currentPath, String currentRelativePath) {
				 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), remoteFileSep);
				 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath, remoteFileSep);
				 String relPath = currentRelativePath;
				 for (int pcount = pathElements2.size();
				 pcount < pathElements.size();
				 pcount++) {
					 String currentElement = (String) pathElements.elementAt(pcount);
					 FTPFile[] theFiles = listFiles(currentPath);
					 FTPFile theFile = null;
					 if (theFiles != null) {
						 theFile = getFile(theFiles, currentElement);
					 }
					 if (!relPath.equals("""")) {
						 relPath = relPath + remoteFileSep;
					 }
					 if (theFile == null) {
						 relPath = relPath + currentElement;
						 currentPath = currentPath + remoteFileSep + currentElement;
						 log(""Hidden file "" + relPath + "" assumed to not be a symlink."", Project.MSG_VERBOSE);
					 }
					 else {
						 traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
						 relPath = relPath + theFile.getName();
						 currentPath = currentPath + remoteFileSep + theFile.getName();
					 }
				 }
				 return relPath;
			 }
			 public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
				 if (theFiles == null) {
					 return null;
				 }
				 for (int fcount = 0;
				 fcount < theFiles.length;
				 fcount++) {
					 if (theFiles[fcount] != null) {
						 if (theFiles[fcount].getName().equals(lastpathelement)) {
							 return theFiles[fcount];
						 }
						 else if (!isCaseSensitive() && theFiles[fcount].getName().equalsIgnoreCase( lastpathelement)) {
							 return theFiles[fcount];
						 }
					 }
				 }
				 return null;
			 }
			 public boolean isDirectory() {
				 return ftpFile.isDirectory();
			 }
			 public boolean isSymbolicLink() {
				 return ftpFile.isSymbolicLink();
			 }
			 protected FTPClient getClient() {
				 return client;
			 }
			 protected void setCurpwd(String curpwd) {
				 this.curpwd = curpwd;
			 }
			 public String getCurpwd() {
				 return curpwd;
			 }
			 public boolean isTraverseSymlinks() throws IOException, BuildException {
				 if (!relativePathCalculated) {
					 getRelativePath();
				 }
				 return traversesSymlinks;
			 }
			 public String toString() {
				 return ""AntFtpFile: "" + curpwd + ""%"" + ftpFile;
			 }
		 }
		 protected class AntFTPRootFile extends AntFTPFile {
			 private String remotedir;
			 public AntFTPRootFile(FTPClient aclient, String remotedir) {
				 super(aclient, null, remotedir);
				 this.remotedir = remotedir;
				 try {
					 this.getClient().changeWorkingDirectory(this.remotedir);
					 this.setCurpwd(this.getClient().printWorkingDirectory());
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, getLocation());
				 }
			 }
			 public String getAbsolutePath() {
				 return this.getCurpwd();
			 }
			 public String getRelativePath() throws BuildException, IOException {
				 return """";
			 }
		 }
	 }
	 private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
		 boolean result = false;
		 String currentWorkingDir = null;
		 if (file.isDirectory()) {
			 return true;
		 }
		 else if (file.isFile()) {
			 return false;
		 }
		 try {
			 currentWorkingDir = ftp.printWorkingDirectory();
		 }
		 catch (IOException ioe) {
			 getProject().log(""could not find current working directory "" + dir + "" while checking a symlink"", Project.MSG_DEBUG);
		 }
		 if (currentWorkingDir != null) {
			 try {
				 result = ftp.changeWorkingDirectory(file.getLink());
			 }
			 catch (IOException ioe) {
				 getProject().log(""could not cd to "" + file.getLink() + "" while checking a symlink"", Project.MSG_DEBUG);
			 }
			 if (result) {
				 boolean comeback = false;
				 try {
					 comeback = ftp.changeWorkingDirectory(currentWorkingDir);
				 }
				 catch (IOException ioe) {
					 getProject().log(""could not cd back to "" + dir + "" while checking a symlink"", Project.MSG_ERR);
				 }
				 finally {
					 if (!comeback) {
						 throw new BuildException(""could not cd back to "" + dir + "" while checking a symlink"");
					 }
				 }
			 }
		 }
		 return result;
	 }
	 private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
		 if (file.isDirectory()) {
			 return false;
		 }
		 else if (file.isFile()) {
			 return true;
		 }
		 return !isFunctioningAsDirectory(ftp, dir, file);
	 }
	 public void setRemotedir(String dir) {
		 this.remotedir = dir;
	 }
	 public void setServer(String server) {
		 this.server = server;
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public void setUserid(String userid) {
		 this.userid = userid;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public void setAccount(String pAccount) {
		 this.account = pAccount;
	 }
	 public void setBinary(boolean binary) {
		 this.binary = binary;
	 }
	 public void setPassive(boolean passive) {
		 this.passive = passive;
	 }
	 public void setVerbose(boolean verbose) {
		 this.verbose = verbose;
	 }
	 public void setNewer(boolean newer) {
		 this.newerOnly = newer;
	 }
	 public void setTimeDiffMillis(long timeDiffMillis) {
		 this.timeDiffMillis = timeDiffMillis;
	 }
	 public void setTimeDiffAuto(boolean timeDiffAuto) {
		 this.timeDiffAuto = timeDiffAuto;
	 }
	 public void setPreserveLastModified(boolean preserveLastModified) {
		 this.preserveLastModified = preserveLastModified;
	 }
	 public void setDepends(boolean depends) {
		 this.newerOnly = depends;
	 }
	 public void setSeparator(String separator) {
		 remoteFileSep = separator;
	 }
	 public void setChmod(String theMode) {
		 this.chmod = theMode;
	 }
	 public void setUmask(String theUmask) {
		 this.umask = theUmask;
	 }
	 public void addFileset(FileSet set) {
		 filesets.addElement(set);
	 }
	 public void setAction(String action) throws BuildException {
		 log(""DEPRECATED - The setAction(String) method has been deprecated."" + "" Use setAction(FTP.Action) instead."");
		 Action a = new Action();
		 a.setValue(action);
		 this.action = a.getAction();
	 }
	 public void setAction(Action action) throws BuildException {
		 this.action = action.getAction();
	 }
	 public void setListing(File listing) {
		 this.listing = listing;
	 }
	 public void setSkipFailedTransfers(boolean skipFailedTransfers) {
		 this.skipFailedTransfers = skipFailedTransfers;
	 }
	 public void setIgnoreNoncriticalErrors(boolean ignoreNoncriticalErrors) {
		 this.ignoreNoncriticalErrors = ignoreNoncriticalErrors;
	 }
	 private void configurationHasBeenSet() {
		 this.isConfigurationSet = true;
	 }
	 public void setSystemTypeKey(FTPSystemType systemKey) {
		 if (systemKey != null && !systemKey.getValue().equals("""")) {
			 this.systemTypeKey = systemKey;
			 configurationHasBeenSet();
		 }
	 }
	 public void setDefaultDateFormatConfig(String defaultDateFormat) {
		 if (defaultDateFormat != null && !defaultDateFormat.equals("""")) {
			 this.defaultDateFormatConfig = defaultDateFormat;
			 configurationHasBeenSet();
		 }
	 }
	 public void setRecentDateFormatConfig(String recentDateFormat) {
		 if (recentDateFormat != null && !recentDateFormat.equals("""")) {
			 this.recentDateFormatConfig = recentDateFormat;
			 configurationHasBeenSet();
		 }
	 }
	 public void setServerLanguageCodeConfig(LanguageCode serverLanguageCode) {
		 if (serverLanguageCode != null && !serverLanguageCode.equals("""")) {
			 this.serverLanguageCodeConfig = serverLanguageCode;
			 configurationHasBeenSet();
		 }
	 }
	 public void setServerTimeZoneConfig(String serverTimeZoneId) {
		 if (serverTimeZoneId != null && !serverTimeZoneId.equals("""")) {
			 this.serverTimeZoneConfig = serverTimeZoneId;
			 configurationHasBeenSet();
		 }
	 }
	 public void setShortMonthNamesConfig(String shortMonthNames) {
		 if (shortMonthNames != null && !shortMonthNames.equals("""")) {
			 this.shortMonthNamesConfig = shortMonthNames;
			 configurationHasBeenSet();
		 }
	 }
	 public void setRetriesAllowed(String retriesAllowed) {
		 if (""FOREVER"".equalsIgnoreCase(retriesAllowed)) {
			 this.retriesAllowed = Retryable.RETRY_FOREVER;
		 }
		 else {
			 try {
				 int retries = Integer.parseInt(retriesAllowed);
				 if (retries < Retryable.RETRY_FOREVER) {
					 throw new BuildException( ""Invalid value for retriesAllowed attribute: "" + retriesAllowed);
				 }
				 this.retriesAllowed = retries;
			 }
			 catch (NumberFormatException px) {
				 throw new BuildException( ""Invalid value for retriesAllowed attribute: "" + retriesAllowed);
			 }
		 }
	 }
	 String getSystemTypeKey() {
		 return systemTypeKey.getValue();
	 }
	 String getDefaultDateFormatConfig() {
		 return defaultDateFormatConfig;
	 }
	 String getRecentDateFormatConfig() {
		 return recentDateFormatConfig;
	 }
	 String getServerLanguageCodeConfig() {
		 return serverLanguageCodeConfig.getValue();
	 }
	 String getServerTimeZoneConfig() {
		 return serverTimeZoneConfig;
	 }
	 String getShortMonthNamesConfig() {
		 return shortMonthNamesConfig;
	 }
	 Granularity getTimestampGranularity() {
		 return timestampGranularity;
	 }
	 public void setTimestampGranularity(Granularity timestampGranularity) {
		 if (null == timestampGranularity || """".equals(timestampGranularity)) {
			 return;
		 }
		 this.timestampGranularity = timestampGranularity;
	 }
	 public void setSiteCommand(String siteCommand) {
		 this.siteCommand = siteCommand;
	 }
	 public void setInitialSiteCommand(String initialCommand) {
		 this.initialSiteCommand = initialCommand;
	 }
	 protected void checkAttributes() throws BuildException {
		 if (server == null) {
			 throw new BuildException(""server attribute must be set!"");
		 }
		 if (userid == null) {
			 throw new BuildException(""userid attribute must be set!"");
		 }
		 if (password == null) {
			 throw new BuildException(""password attribute must be set!"");
		 }
		 if ((action == LIST_FILES) && (listing == null)) {
			 throw new BuildException(""listing attribute must be set for list "" + ""action!"");
		 }
		 if (action == MK_DIR && remotedir == null) {
			 throw new BuildException(""remotedir attribute must be set for "" + ""mkdir action!"");
		 }
		 if (action == CHMOD && chmod == null) {
			 throw new BuildException(""chmod attribute must be set for chmod "" + ""action!"");
		 }
		 if (action == SITE_CMD && siteCommand == null) {
			 throw new BuildException(""sitecommand attribute must be set for site "" + ""action!"");
		 }
		 if (this.isConfigurationSet) {
			 try {
				 Class.forName(""org.apache.commons.net.ftp.FTPClientConfig"");
			 }
			 catch (ClassNotFoundException e) {
				 throw new BuildException( ""commons-net.jar >= 1.4.0 is required for at least one"" + "" of the attributes specified."");
			 }
		 }
	 }
	 protected void executeRetryable(RetryHandler h, Retryable r, String descr) throws IOException {
		 h.execute(r, descr);
	 }
	 protected int transferFiles(final FTPClient ftp, FileSet fs) throws IOException, BuildException {
		 DirectoryScanner ds;
		 if (action == SEND_FILES) {
			 ds = fs.getDirectoryScanner(getProject());
		 }
		 else {
			 if (fs.getSelectors(getProject()).length != 0) {
				 getProject().log(""selectors are not supported in remote filesets"", Project.MSG_WARN);
			 }
			 ds = new FTPDirectoryScanner(ftp);
			 fs.setupDirectoryScanner(ds, getProject());
			 ds.setFollowSymlinks(fs.isFollowSymlinks());
			 ds.scan();
		 }
		 String[] dsfiles = null;
		 if (action == RM_DIR) {
			 dsfiles = ds.getIncludedDirectories();
		 }
		 else {
			 dsfiles = ds.getIncludedFiles();
		 }
		 String dir = null;
		 if ((ds.getBasedir() == null) && ((action == SEND_FILES) || (action == GET_FILES))) {
			 throw new BuildException(""the dir attribute must be set for send "" + ""and get actions"");
		 }
		 else {
			 if ((action == SEND_FILES) || (action == GET_FILES)) {
				 dir = ds.getBasedir().getAbsolutePath();
			 }
		 }
		 BufferedWriter bw = null;
		 try {
			 if (action == LIST_FILES) {
				 File pd = listing.getParentFile();
				 if (!pd.exists()) {
					 pd.mkdirs();
				 }
				 bw = new BufferedWriter(new FileWriter(listing));
			 }
			 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
			 if (action == RM_DIR) {
				 for (int i = dsfiles.length - 1;
				 i >= 0;
				 i--) {
					 final String dsfile = dsfiles[i];
					 executeRetryable(h, new Retryable() {
						 public void execute() throws IOException {
							 rmDir(ftp, dsfile);
						 }
					 }
					, dsfile);
				 }
			 }
			 else {
				 final BufferedWriter fbw = bw;
				 final String fdir = dir;
				 if (this.newerOnly) {
					 this.granularityMillis = this.timestampGranularity.getMilliseconds(action);
				 }
				 for (int i = 0;
				 i < dsfiles.length;
				 i++) {
					 final String dsfile = dsfiles[i];
					 executeRetryable(h, new Retryable() {
						 public void execute() throws IOException {
							 switch (action) {
								 case SEND_FILES: sendFile(ftp, fdir, dsfile);
								 break;
								 case GET_FILES: getFile(ftp, fdir, dsfile);
								 break;
								 case DEL_FILES: delFile(ftp, dsfile);
								 break;
								 case LIST_FILES: listFile(ftp, fbw, dsfile);
								 break;
								 case CHMOD: doSiteCommand(ftp, ""chmod "" + chmod + "" "" + resolveFile(dsfile));
								 transferred++;
								 break;
								 default: throw new BuildException(""unknown ftp action "" + action);
							 }
						 }
					 }
					, dsfile);
				 }
			 }
		 }
		 finally {
			 if (bw != null) {
				 bw.close();
			 }
		 }
		 return dsfiles.length;
	 }
	 protected void transferFiles(FTPClient ftp) throws IOException, BuildException {
		 transferred = 0;
		 skipped = 0;
		 if (filesets.size() == 0) {
			 throw new BuildException(""at least one fileset must be specified."");
		 }
		 else {
			 for (int i = 0;
			 i < filesets.size();
			 i++) {
				 FileSet fs = (FileSet) filesets.elementAt(i);
				 if (fs != null) {
					 transferFiles(ftp, fs);
				 }
			 }
		 }
		 log(transferred + "" "" + ACTION_TARGET_STRS[action] + "" "" + COMPLETED_ACTION_STRS[action]);
		 if (skipped != 0) {
			 log(skipped + "" "" + ACTION_TARGET_STRS[action] + "" were not successfully "" + COMPLETED_ACTION_STRS[action]);
		 }
	 }
	 protected String resolveFile(String file) {
		 return file.replace(System.getProperty(""file.separator"").charAt(0), remoteFileSep.charAt(0));
	 }
	 protected void createParents(FTPClient ftp, String filename) throws IOException, BuildException {
		 File dir = new File(filename);
		 if (dirCache.contains(dir)) {
			 return;
		 }
		 Vector parents = new Vector();
		 String dirname;
		 while ((dirname = dir.getParent()) != null) {
			 File checkDir = new File(dirname);
			 if (dirCache.contains(checkDir)) {
				 break;
			 }
			 dir = checkDir;
			 parents.addElement(dir);
		 }
		 int i = parents.size() - 1;
		 if (i >= 0) {
			 String cwd = ftp.printWorkingDirectory();
			 String parent = dir.getParent();
			 if (parent != null) {
				 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
					 throw new BuildException(""could not change to "" + ""directory: "" + ftp.getReplyString());
				 }
			 }
			 while (i >= 0) {
				 dir = (File) parents.elementAt(i--);
				 if (!ftp.changeWorkingDirectory(dir.getName())) {
					 log(""creating remote directory "" + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
					 if (!ftp.makeDirectory(dir.getName())) {
						 handleMkDirFailure(ftp);
					 }
					 if (!ftp.changeWorkingDirectory(dir.getName())) {
						 throw new BuildException(""could not change to "" + ""directory: "" + ftp.getReplyString());
					 }
				 }
				 dirCache.addElement(dir);
			 }
			 ftp.changeWorkingDirectory(cwd);
		 }
	 }
	 private long getTimeDiff(FTPClient ftp) {
		 long returnValue = 0;
		 File tempFile = findFileName(ftp);
		 try {
			 FILE_UTILS.createNewFile(tempFile);
			 long localTimeStamp = tempFile.lastModified();
			 BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
			 ftp.storeFile(tempFile.getName(), instream);
			 instream.close();
			 boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
			 if (success) {
				 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
				 if (ftpFiles.length == 1) {
					 long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
					 returnValue = localTimeStamp - remoteTimeStamp;
				 }
				 ftp.deleteFile(ftpFiles[0].getName());
			 }
			 Delete mydelete = new Delete();
			 mydelete.bindToOwner(this);
			 mydelete.setFile(tempFile.getCanonicalFile());
			 mydelete.execute();
		 }
		 catch (Exception e) {
			 throw new BuildException(e, getLocation());
		 }
		 return returnValue;
	 }
	 private File findFileName(FTPClient ftp) {
		 FTPFile [] theFiles = null;
		 final int maxIterations = 1000;
		 for (int counter = 1;
		 counter < maxIterations;
		 counter++) {
			 File localFile = FILE_UTILS.createTempFile( ""ant"" + Integer.toString(counter), "".tmp"", null, false, false);
			 String fileName = localFile.getName();
			 boolean found = false;
			 try {
				 if (theFiles == null) {
					 theFiles = ftp.listFiles();
				 }
				 for (int counter2 = 0;
				 counter2 < theFiles.length;
				 counter2++) {
					 if (theFiles[counter2] != null && theFiles[counter2].getName().equals(fileName)) {
						 found = true;
						 break;
					 }
				 }
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, getLocation());
			 }
			 if (!found) {
				 localFile.deleteOnExit();
				 return localFile;
			 }
		 }
		 return null;
	 }
	 private static final SimpleDateFormat TIMESTAMP_LOGGING_SDF = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
	 protected boolean isUpToDate(FTPClient ftp, File localFile, String remoteFile) throws IOException, BuildException {
		 log(""checking date for "" + remoteFile, Project.MSG_VERBOSE);
		 FTPFile[] files = ftp.listFiles(remoteFile);
		 if (files == null || files.length == 0) {
			 if (action == SEND_FILES) {
				 log(""Could not date test remote file: "" + remoteFile + ""assuming out of date."", Project.MSG_VERBOSE);
				 return false;
			 }
			 else {
				 throw new BuildException(""could not date test remote file: "" + ftp.getReplyString());
			 }
		 }
		 long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
		 long localTimestamp = localFile.lastModified();
		 long adjustedRemoteTimestamp = remoteTimestamp + this.timeDiffMillis + this.granularityMillis;
		 StringBuffer msg = new StringBuffer("" ["") .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))) .append(""] local"");
		 log(msg.toString(), Project.MSG_VERBOSE);
		 msg = new StringBuffer("" ["") .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp))) .append(""] remote"");
		 if (remoteTimestamp != adjustedRemoteTimestamp) {
			 msg.append("" - (raw: "") .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp))) .append("")"");
		 }
		 log(msg.toString(), Project.MSG_VERBOSE);
		 if (this.action == SEND_FILES) {
			 return adjustedRemoteTimestamp >= localTimestamp;
		 }
		 else {
			 return localTimestamp >= adjustedRemoteTimestamp;
		 }
	 }
	 protected void doSiteCommand(FTPClient ftp, String theCMD) throws IOException, BuildException {
		 boolean rc;
		 String[] myReply = null;
		 log(""Doing Site Command: "" + theCMD, Project.MSG_VERBOSE);
		 rc = ftp.sendSiteCommand(theCMD);
		 if (!rc) {
			 log(""Failed to issue Site Command: "" + theCMD, Project.MSG_WARN);
		 }
		 else {
			 myReply = ftp.getReplyStrings();
			 for (int x = 0;
			 x < myReply.length;
			 x++) {
				 if (myReply[x].indexOf(""200"") == -1) {
					 log(myReply[x], Project.MSG_WARN);
				 }
			 }
		 }
	 }
	 protected void sendFile(FTPClient ftp, String dir, String filename) throws IOException, BuildException {
		 InputStream instream = null;
		 try {
			 File file = getProject().resolveFile(new File(dir, filename).getPath());
			 if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
				 return;
			 }
			 if (verbose) {
				 log(""transferring "" + file.getAbsolutePath());
			 }
			 instream = new BufferedInputStream(new FileInputStream(file));
			 createParents(ftp, filename);
			 ftp.storeFile(resolveFile(filename), instream);
			 boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
			 if (!success) {
				 String s = ""could not put file: "" + ftp.getReplyString();
				 if (skipFailedTransfers) {
					 log(s, Project.MSG_WARN);
					 skipped++;
				 }
				 else {
					 throw new BuildException(s);
				 }
			 }
			 else {
				 if (chmod != null) {
					 doSiteCommand(ftp, ""chmod "" + chmod + "" "" + resolveFile(filename));
				 }
				 log(""File "" + file.getAbsolutePath() + "" copied to "" + server, Project.MSG_VERBOSE);
				 transferred++;
			 }
		 }
		 finally {
			 if (instream != null) {
				 try {
					 instream.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 protected void delFile(FTPClient ftp, String filename) throws IOException, BuildException {
		 if (verbose) {
			 log(""deleting "" + filename);
		 }
		 if (!ftp.deleteFile(resolveFile(filename))) {
			 String s = ""could not delete file: "" + ftp.getReplyString();
			 if (skipFailedTransfers) {
				 log(s, Project.MSG_WARN);
				 skipped++;
			 }
			 else {
				 throw new BuildException(s);
			 }
		 }
		 else {
			 log(""File "" + filename + "" deleted from "" + server, Project.MSG_VERBOSE);
			 transferred++;
		 }
	 }
	 protected void rmDir(FTPClient ftp, String dirname) throws IOException, BuildException {
		 if (verbose) {
			 log(""removing "" + dirname);
		 }
		 if (!ftp.removeDirectory(resolveFile(dirname))) {
			 String s = ""could not remove directory: "" + ftp.getReplyString();
			 if (skipFailedTransfers) {
				 log(s, Project.MSG_WARN);
				 skipped++;
			 }
			 else {
				 throw new BuildException(s);
			 }
		 }
		 else {
			 log(""Directory "" + dirname + "" removed from "" + server, Project.MSG_VERBOSE);
			 transferred++;
		 }
	 }
	 protected void getFile(FTPClient ftp, String dir, String filename) throws IOException, BuildException {
		 OutputStream outstream = null;
		 try {
			 File file = getProject().resolveFile(new File(dir, filename).getPath());
			 if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
				 return;
			 }
			 if (verbose) {
				 log(""transferring "" + filename + "" to "" + file.getAbsolutePath());
			 }
			 File pdir = file.getParentFile();
			 if (!pdir.exists()) {
				 pdir.mkdirs();
			 }
			 outstream = new BufferedOutputStream(new FileOutputStream(file));
			 ftp.retrieveFile(resolveFile(filename), outstream);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 String s = ""could not get file: "" + ftp.getReplyString();
				 if (skipFailedTransfers) {
					 log(s, Project.MSG_WARN);
					 skipped++;
				 }
				 else {
					 throw new BuildException(s);
				 }
			 }
			 else {
				 log(""File "" + file.getAbsolutePath() + "" copied from "" + server, Project.MSG_VERBOSE);
				 transferred++;
				 if (preserveLastModified) {
					 outstream.close();
					 outstream = null;
					 FTPFile[] remote = ftp.listFiles(resolveFile(filename));
					 if (remote.length > 0) {
						 FILE_UTILS.setFileLastModified(file, remote[0].getTimestamp() .getTime().getTime());
					 }
				 }
			 }
		 }
		 finally {
			 if (outstream != null) {
				 try {
					 outstream.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 protected void listFile(FTPClient ftp, BufferedWriter bw, String filename) throws IOException, BuildException {
		 if (verbose) {
			 log(""listing "" + filename);
		 }
		 FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
		 if (ftpfiles != null && ftpfiles.length > 0) {
			 bw.write(ftpfiles[0].toString());
			 bw.newLine();
			 transferred++;
		 }
	 }
	 protected void makeRemoteDir(FTPClient ftp, String dir) throws IOException, BuildException {
		 String workingDirectory = ftp.printWorkingDirectory();
		 if (verbose) {
			 log(""Creating directory: "" + dir);
		 }
		 if (dir.indexOf(""/"") == 0) {
			 ftp.changeWorkingDirectory(""/"");
		 }
		 String subdir = """";
		 StringTokenizer st = new StringTokenizer(dir, ""/"");
		 while (st.hasMoreTokens()) {
			 subdir = st.nextToken();
			 log(""Checking "" + subdir, Project.MSG_DEBUG);
			 if (!ftp.changeWorkingDirectory(subdir)) {
				 if (!ftp.makeDirectory(subdir)) {
					 int rc = ftp.getReplyCode();
					 if (!(ignoreNoncriticalErrors && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553 || rc == CODE_521))) {
						 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
					 }
					 if (verbose) {
						 log(""Directory already exists"");
					 }
				 }
				 else {
					 if (verbose) {
						 log(""Directory created OK"");
					 }
					 ftp.changeWorkingDirectory(subdir);
				 }
			 }
		 }
		 if (workingDirectory != null) {
			 ftp.changeWorkingDirectory(workingDirectory);
		 }
	 }
	 private void handleMkDirFailure(FTPClient ftp) throws BuildException {
		 int rc = ftp.getReplyCode();
		 if (!(ignoreNoncriticalErrors && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553 || rc == CODE_521))) {
			 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
		 }
	 }
	 public void execute() throws BuildException {
		 checkAttributes();
		 FTPClient ftp = null;
		 try {
			 log(""Opening FTP connection to "" + server, Project.MSG_VERBOSE);
			 ftp = new FTPClient();
			 if (this.isConfigurationSet) {
				 ftp = FTPConfigurator.configure(ftp, this);
			 }
			 ftp.connect(server, port);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 throw new BuildException(""FTP connection failed: "" + ftp.getReplyString());
			 }
			 log(""connected"", Project.MSG_VERBOSE);
			 log(""logging in to FTP server"", Project.MSG_VERBOSE);
			 if ((this.account != null && !ftp.login(userid, password, account)) || (this.account == null && !ftp.login(userid, password))) {
				 throw new BuildException(""Could not login to FTP server"");
			 }
			 log(""login succeeded"", Project.MSG_VERBOSE);
			 if (binary) {
				 ftp.setFileType(org.apache.commons.net.ftp.FTP.IMAGE_FILE_TYPE);
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
				 }
			 }
			 else {
				 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
				 }
			 }
			 if (passive) {
				 log(""entering passive mode"", Project.MSG_VERBOSE);
				 ftp.enterLocalPassiveMode();
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not enter into passive "" + ""mode: "" + ftp.getReplyString());
				 }
			 }
			 if (this.initialSiteCommand != null) {
				 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 doSiteCommand(lftp, FTP.this.initialSiteCommand);
					 }
				 }
				, ""initial site command: "" + this.initialSiteCommand);
			 }
			 if (umask != null) {
				 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 doSiteCommand(lftp, ""umask "" + umask);
					 }
				 }
				, ""umask "" + umask);
			 }
			 if (action == MK_DIR) {
				 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 makeRemoteDir(lftp, remotedir);
					 }
				 }
				, remotedir);
			 }
			 else if (action == SITE_CMD) {
				 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 doSiteCommand(lftp, FTP.this.siteCommand);
					 }
				 }
				, ""Site Command: "" + this.siteCommand);
			 }
			 else {
				 if (remotedir != null) {
					 log(""changing the remote directory"", Project.MSG_VERBOSE);
					 ftp.changeWorkingDirectory(remotedir);
					 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
						 throw new BuildException(""could not change remote "" + ""directory: "" + ftp.getReplyString());
					 }
				 }
				 if (newerOnly && timeDiffAuto) {
					 timeDiffMillis = getTimeDiff(ftp);
				 }
				 log(ACTION_STRS[action] + "" "" + ACTION_TARGET_STRS[action]);
				 transferFiles(ftp);
			 }
		 }
		 catch (IOException ex) {
			 throw new BuildException(""error during FTP transfer: "" + ex, ex);
		 }
		 finally {
			 if (ftp != null && ftp.isConnected()) {
				 try {
					 log(""disconnecting"", Project.MSG_VERBOSE);
					 ftp.logout();
					 ftp.disconnect();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 public static class Action extends EnumeratedAttribute {
		 private static final String[] VALID_ACTIONS = {
		 ""send"", ""put"", ""recv"", ""get"", ""del"", ""delete"", ""list"", ""mkdir"", ""chmod"", ""rmdir"", ""site"" }
		;
		 public String[] getValues() {
			 return VALID_ACTIONS;
		 }
		 public int getAction() {
			 String actionL = getValue().toLowerCase(Locale.US);
			 if (actionL.equals(""send"") || actionL.equals(""put"")) {
				 return SEND_FILES;
			 }
			 else if (actionL.equals(""recv"") || actionL.equals(""get"")) {
				 return GET_FILES;
			 }
			 else if (actionL.equals(""del"") || actionL.equals(""delete"")) {
				 return DEL_FILES;
			 }
			 else if (actionL.equals(""list"")) {
				 return LIST_FILES;
			 }
			 else if (actionL.equals(""chmod"")) {
				 return CHMOD;
			 }
			 else if (actionL.equals(""mkdir"")) {
				 return MK_DIR;
			 }
			 else if (actionL.equals(""rmdir"")) {
				 return RM_DIR;
			 }
			 else if (actionL.equals(""site"")) {
				 return SITE_CMD;
			 }
			 return SEND_FILES;
		 }
	 }
	 public static class Granularity extends EnumeratedAttribute {
		 private static final String[] VALID_GRANULARITIES = {
		 """", ""MINUTE"", ""NONE"" }
		;
		 public String[] getValues() {
			 return VALID_GRANULARITIES;
		 }
		 public long getMilliseconds(int action) {
			 String granularityU = getValue().toUpperCase(Locale.US);
			 if ("""".equals(granularityU)) {
				 if (action == SEND_FILES) {
					 return GRANULARITY_MINUTE;
				 }
			 }
			 else if (""MINUTE"".equals(granularityU)) {
				 return GRANULARITY_MINUTE;
			 }
			 return 0L;
		 }
		 static final Granularity getDefault() {
			 Granularity g = new Granularity();
			 g.setValue("""");
			 return g;
		 }
	 }
	 public static class FTPSystemType extends EnumeratedAttribute {
		 private static final String[] VALID_SYSTEM_TYPES = {
		 """", ""UNIX"", ""VMS"", ""WINDOWS"", ""OS/2"", ""OS/400"", ""MVS"" }
		;
		 public String[] getValues() {
			 return VALID_SYSTEM_TYPES;
		 }
		 static final FTPSystemType getDefault() {
			 FTPSystemType ftpst = new FTPSystemType();
			 ftpst.setValue("""");
			 return ftpst;
		 }
	 }
	 public static class LanguageCode extends EnumeratedAttribute {
		 private static final String[] VALID_LANGUAGE_CODES = getValidLanguageCodes();
		 private static String[] getValidLanguageCodes() {
			 Collection c = FTPClientConfig.getSupportedLanguageCodes();
			 String[] ret = new String[c.size() + 1];
			 int i = 0;
			 ret[i++] = """";
			 for (Iterator it = c.iterator();
			 it.hasNext();
			 i++) {
				 ret[i] = (String) it.next();
			 }
			 return ret;
		 }
		 public String[] getValues() {
			 return VALID_LANGUAGE_CODES;
		 }
		 static final LanguageCode getDefault() {
			 LanguageCode lc = new LanguageCode();
			 lc.setValue("""");
			 return lc;
		 }
	 }
}",0,0,0,0
"static class Aggregations implements Iterable<Aggregation> {
	 private final List<? extends Aggregation> aggregations;
	 private Map<String, Aggregation> aggregationsAsMap;
	 Aggregations(List<? extends Aggregation> aggregations) {
		 this.aggregations = Objects.requireNonNull(aggregations, ""aggregations"");
	 }
	 public final Iterator<Aggregation> iterator() {
		 return asList().iterator();
	 }
	 final List<Aggregation> asList() {
		 return Collections.unmodifiableList(aggregations);
	 }
	 final Map<String, Aggregation> asMap() {
		 if (aggregationsAsMap == null) {
			 Map<String, Aggregation> map = new LinkedHashMap<>(aggregations.size());
			 for (Aggregation aggregation : aggregations) {
				 map.put(aggregation.getName(), aggregation);
			 }
			 this.aggregationsAsMap = unmodifiableMap(map);
		 }
		 return aggregationsAsMap;
	 }
	 public final <A extends Aggregation> A get(String name) {
		 return (A) asMap().get(name);
	 }
	 public final boolean equals(Object obj) {
		 if (obj == null || getClass() != obj.getClass()) {
			 return false;
		 }
		 return aggregations.equals(((Aggregations) obj).aggregations);
	 }
	 public final int hashCode() {
		 return Objects.hash(getClass(), aggregations);
	 }
 }",0,1,0,0
"public class ZlibDecompressor implements Decompressor {
	 private static final int DEFAULT_DIRECT_BUFFER_SIZE = 1*1024;
	 private long stream;
	 private CompressionHeader header;
	 private int directBufferSize;
	 private Buffer compressedDirectBuf = null;
	 private int compressedDirectBufOff, compressedDirectBufLen;
	 private Buffer uncompressedDirectBuf = null;
	 private byte[] userBuf = null;
	 private int userBufOff = 0, userBufLen = 0;
	 private boolean finished;
	 private boolean needDict;
	 public static enum CompressionHeader {
		 NO_HEADER (-15), DEFAULT_HEADER (15), GZIP_FORMAT (31), AUTODETECT_GZIP_ZLIB (47);
		 private final int windowBits;
		 CompressionHeader(int windowBits) {
			 this.windowBits = windowBits;
		 }
		 public int windowBits() {
			 return windowBits;
		 }
	 }
	 private static boolean nativeZlibLoaded = false;
	 static {
		 if (NativeCodeLoader.isNativeCodeLoaded()) {
			 try {
				 initIDs();
				 nativeZlibLoaded = true;
			 }
			 catch (Throwable t) {
			 }
		 }
	 }
	 static boolean isNativeZlibLoaded() {
		 return nativeZlibLoaded;
	 }
	 public ZlibDecompressor(CompressionHeader header, int directBufferSize) {
		 this.header = header;
		 this.directBufferSize = directBufferSize;
		 compressedDirectBuf = ByteBuffer.allocateDirect(directBufferSize);
		 uncompressedDirectBuf = ByteBuffer.allocateDirect(directBufferSize);
		 uncompressedDirectBuf.position(directBufferSize);
		 stream = init(this.header.windowBits());
	 }
	 public ZlibDecompressor() {
		 this(CompressionHeader.DEFAULT_HEADER, DEFAULT_DIRECT_BUFFER_SIZE);
	 }
	 public synchronized void setInput(byte[] b, int off, int len) {
		 if (b == null) {
			 throw new NullPointerException();
		 }
		 if (off < 0 || len < 0 || off > b.length - len) {
			 throw new ArrayIndexOutOfBoundsException();
		 }
		 this.userBuf = b;
		 this.userBufOff = off;
		 this.userBufLen = len;
		 setInputFromSavedData();
		 uncompressedDirectBuf.limit(directBufferSize);
		 uncompressedDirectBuf.position(directBufferSize);
	 }
	 synchronized void setInputFromSavedData() {
		 compressedDirectBufOff = 0;
		 compressedDirectBufLen = userBufLen;
		 if (compressedDirectBufLen > directBufferSize) {
			 compressedDirectBufLen = directBufferSize;
		 }
		 compressedDirectBuf.rewind();
		 ((ByteBuffer)compressedDirectBuf).put(userBuf, userBufOff, compressedDirectBufLen);
		 userBufOff += compressedDirectBufLen;
		 userBufLen -= compressedDirectBufLen;
	 }
	 public synchronized void setDictionary(byte[] b, int off, int len) {
		 if (stream == 0 || b == null) {
			 throw new NullPointerException();
		 }
		 if (off < 0 || len < 0 || off > b.length - len) {
			 throw new ArrayIndexOutOfBoundsException();
		 }
		 setDictionary(stream, b, off, len);
		 needDict = false;
	 }
	 public synchronized boolean needsInput() {
		 if (uncompressedDirectBuf.remaining() > 0) {
			 return false;
		 }
		 if (compressedDirectBufLen <= 0) {
			 if (userBufLen <= 0) {
				 return true;
			 }
			 else {
				 setInputFromSavedData();
			 }
		 }
		 return false;
	 }
	 public synchronized boolean needsDictionary() {
		 return needDict;
	 }
	 public synchronized boolean finished() {
		 return (finished && uncompressedDirectBuf.remaining() == 0);
	 }
	 public synchronized int decompress(byte[] b, int off, int len) throws IOException {
		 if (b == null) {
			 throw new NullPointerException();
		 }
		 if (off < 0 || len < 0 || off > b.length - len) {
			 throw new ArrayIndexOutOfBoundsException();
		 }
		 int n = 0;
		 n = uncompressedDirectBuf.remaining();
		 if(n > 0) {
			 n = Math.min(n, len);
			 ((ByteBuffer)uncompressedDirectBuf).get(b, off, n);
			 return n;
		 }
		 uncompressedDirectBuf.rewind();
		 uncompressedDirectBuf.limit(directBufferSize);
		 n = inflateBytesDirect();
		 uncompressedDirectBuf.limit(n);
		 n = Math.min(n, len);
		 ((ByteBuffer)uncompressedDirectBuf).get(b, off, n);
		 return n;
	 }
	 public synchronized long getBytesWritten() {
		 checkStream();
		 return getBytesWritten(stream);
	 }
	 public synchronized long getBytesRead() {
		 checkStream();
		 return getBytesRead(stream);
	 }
	 public synchronized void reset() {
		 checkStream();
		 reset(stream);
		 finished = false;
		 needDict = false;
		 compressedDirectBufOff = compressedDirectBufLen = 0;
		 uncompressedDirectBuf.limit(directBufferSize);
		 uncompressedDirectBuf.position(directBufferSize);
		 userBufOff = userBufLen = 0;
	 }
	 public synchronized void end() {
		 if (stream != 0) {
			 end(stream);
			 stream = 0;
		 }
	 }
	 protected void finalize() {
		 end();
	 }
	 private void checkStream() {
		 if (stream == 0) throw new NullPointerException();
	 }
	 private native static void initIDs();
	 private native static long init(int windowBits);
	 private native static void setDictionary(long strm, byte[] b, int off, int len);
	 private native int inflateBytesDirect();
	 private native static long getBytesRead(long strm);
	 private native static long getBytesWritten(long strm);
	 private native static void reset(long strm);
	 private native static void end(long strm);
}",0,0,0,0
"public class ByteStore implements Serializable {
	 byte[] bytes;
	 String content_type=null;
	 String content_encoding=null;
	 String name;
	 String description="""";
	 public ByteStore(byte[] b) {
		bytes=b;
	 }
	 public void setDescription(String s) {
		description=s;
	 }
	 public String getDescription() {
		return description;
	 }
	 public void setContentType(String s) {
		content_type=s;
	 }
	 public String getContentType() {
		if(content_type != null) {
			 return content_type;
		}
		 else {
			 content_type=WebMailServer.getStorage().getMimeType(name);
			 return content_type;
		}
	 }
	 public void setContentEncoding(String s) {
		content_encoding=s;
	 }
	 public String getContentEncoding() {
		return content_encoding;
	 }
	 public byte[] getBytes() {
		return bytes;
	 }
	 public void setName(String s) {
		name=s;
	 }
	 public String getName() {
		return name;
	 }
	 public int getSize() {
		return bytes.length;
	 }
	 public static ByteStore getBinaryFromIS(InputStream in, int nr_bytes_to_read) {
		byte[] s=new byte[nr_bytes_to_read+100];
		int count=0;
		int lastread=0;
		if(in != null) {
			 synchronized(in) {
				while(count < s.length) {
					 try {
						lastread=in.read(s,count,nr_bytes_to_read-count);
					 }
					 catch(EOFException ex) {
						System.err.println(ex.getMessage());
						lastread=0;
					 }
					 catch(Exception z) {
						System.err.println(z.getMessage());
						lastread=0;
					 }
					 count+=lastread;
					 if(lastread < 1) break;
				}
			 }
			 byte[] s2=new byte[count+1];
			 for(int i=0;
			 i<count+1;
			i++) {
				s2[i]=s[i];
			 }
			 ByteStore d=new ByteStore(s2);
			 return d;
		}
		 else {
			 return null;
		}
	 }
}",0,1,0,0
"public class ArithmeticColumnFixture extends ColumnFixture {
	 public int x;
	 public int y;
	 public int plus () {
		 return x + y;
	 }
	 public int minus() {
		 return x - y;
	 }
	 public int times () {
		 return x * y;
	 }
	 public int divide () {
		 return x / y;
	 }
	 public float floating () {
		 return (float)x / (float)y;
	 }
	 public ScientificDouble sin () {
		 return new ScientificDouble(Math.sin(Math.toRadians(x)));
	 }
	 public ScientificDouble cos () {
		 return new ScientificDouble(Math.cos(Math.toRadians(x)));
	 }
}",1,0,0,0
"public class Mina2Configuration implements Cloneable {
	 private String protocol;
	 private String host;
	 private int port;
	 private boolean sync = true;
	 private boolean textline;
	 private Mina2TextLineDelimiter textlineDelimiter;
	 private ProtocolCodecFactory codec;
	 private String encoding;
	 private long writeTimeout = 10000;
	 private long timeout = 30000;
	 private boolean lazySessionCreation = true;
	 private boolean transferExchange;
	 private boolean minaLogger;
	 private int encoderMaxLineLength = -1;
	 private int decoderMaxLineLength = 1024;
	 private List<IoFilter> filters;
	 private boolean allowDefaultCodec = true;
	 private boolean disconnect;
	 private boolean disconnectOnNoReply = true;
	 private LoggingLevel noReplyLogLevel = LoggingLevel.WARN;
	 private SSLContextParameters sslContextParameters;
	 private boolean autoStartTls = true;
	 private int maximumPoolSize = 16;
	 private boolean orderedThreadPoolExecutor = true;
	 private boolean cachedAddress = true;
	 private boolean clientMode;
	 public Mina2Configuration copy() {
		 try {
			 return (Mina2Configuration) clone();
		 }
		 catch (CloneNotSupportedException e) {
			 throw new RuntimeCamelException(e);
		 }
	 }
	 public String getCharsetName() {
		 if (encoding == null) {
			 return null;
		 }
		 if (!Charset.isSupported(encoding)) {
			 throw new IllegalArgumentException(""The encoding: "" + encoding + "" is not supported"");
		 }
		 return Charset.forName(encoding).name();
	 }
	 public String getProtocol() {
		 return protocol;
	 }
	 public void setProtocol(String protocol) {
		 this.protocol = protocol;
	 }
	 public String getHost() {
		 return host;
	 }
	 public void setHost(String host) {
		 this.host = host;
	 }
	 public int getPort() {
		 return port;
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public boolean isSync() {
		 return sync;
	 }
	 public void setSync(boolean sync) {
		 this.sync = sync;
	 }
	 public boolean isTextline() {
		 return textline;
	 }
	 public void setTextline(boolean textline) {
		 this.textline = textline;
	 }
	 public Mina2TextLineDelimiter getTextlineDelimiter() {
		 return textlineDelimiter;
	 }
	 public void setTextlineDelimiter(Mina2TextLineDelimiter textlineDelimiter) {
		 this.textlineDelimiter = textlineDelimiter;
	 }
	 public ProtocolCodecFactory getCodec() {
		 return codec;
	 }
	 public void setCodec(ProtocolCodecFactory codec) {
		 this.codec = codec;
	 }
	 public String getEncoding() {
		 return encoding;
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public long getWriteTimeout() {
		 return writeTimeout;
	 }
	 public void setWriteTimeout(long writeTimeout) {
		 this.writeTimeout = writeTimeout;
	 }
	 public long getTimeout() {
		 return timeout;
	 }
	 public void setTimeout(long timeout) {
		 this.timeout = timeout;
	 }
	 public boolean isLazySessionCreation() {
		 return lazySessionCreation;
	 }
	 public void setLazySessionCreation(boolean lazySessionCreation) {
		 this.lazySessionCreation = lazySessionCreation;
	 }
	 public boolean isTransferExchange() {
		 return transferExchange;
	 }
	 public void setTransferExchange(boolean transferExchange) {
		 this.transferExchange = transferExchange;
	 }
	 public void setEncoderMaxLineLength(int encoderMaxLineLength) {
		 this.encoderMaxLineLength = encoderMaxLineLength;
	 }
	 public int getEncoderMaxLineLength() {
		 return encoderMaxLineLength;
	 }
	 public void setDecoderMaxLineLength(int decoderMaxLineLength) {
		 this.decoderMaxLineLength = decoderMaxLineLength;
	 }
	 public int getDecoderMaxLineLength() {
		 return decoderMaxLineLength;
	 }
	 public boolean isMinaLogger() {
		 return minaLogger;
	 }
	 public void setMinaLogger(boolean minaLogger) {
		 this.minaLogger = minaLogger;
	 }
	 public List<IoFilter> getFilters() {
		 return filters;
	 }
	 public void setFilters(List<IoFilter> filters) {
		 this.filters = filters;
	 }
	 public boolean isDatagramProtocol() {
		 return protocol.equals(""udp"");
	 }
	 public void setAllowDefaultCodec(boolean allowDefaultCodec) {
		 this.allowDefaultCodec = allowDefaultCodec;
	 }
	 public boolean isAllowDefaultCodec() {
		 return allowDefaultCodec;
	 }
	 public boolean isDisconnect() {
		 return disconnect;
	 }
	 public void setDisconnect(boolean disconnect) {
		 this.disconnect = disconnect;
	 }
	 public boolean isDisconnectOnNoReply() {
		 return disconnectOnNoReply;
	 }
	 public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {
		 this.disconnectOnNoReply = disconnectOnNoReply;
	 }
	 public LoggingLevel getNoReplyLogLevel() {
		 return noReplyLogLevel;
	 }
	 public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {
		 this.noReplyLogLevel = noReplyLogLevel;
	 }
	 public SSLContextParameters getSslContextParameters() {
		 return sslContextParameters;
	 }
	 public void setSslContextParameters(SSLContextParameters sslContextParameters) {
		 this.sslContextParameters = sslContextParameters;
	 }
	 public boolean isAutoStartTls() {
		 return autoStartTls;
	 }
	 public void setAutoStartTls(boolean autoStartTls) {
		 this.autoStartTls = autoStartTls;
	 }
	 public int getMaximumPoolSize() {
		 return maximumPoolSize;
	 }
	 public void setMaximumPoolSize(int maximumPoolSize) {
		 this.maximumPoolSize = maximumPoolSize;
	 }
	 public boolean isOrderedThreadPoolExecutor() {
		 return orderedThreadPoolExecutor;
	 }
	 public void setOrderedThreadPoolExecutor(boolean orderedThreadPoolExecutor) {
		 this.orderedThreadPoolExecutor = orderedThreadPoolExecutor;
	 }
	 public void setCachedAddress(boolean shouldCacheAddress) {
		 this.cachedAddress = shouldCacheAddress;
	 }
	 public boolean isCachedAddress() {
		 return cachedAddress;
	 }
	 public void setClientMode(boolean clientMode) {
		 this.clientMode = clientMode;
	 }
	 public boolean isClientMode() {
		 return clientMode;
	 }
	 public String getUriString() {
		 return ""mina2:"" + getProtocol() + "":"" + getHost() + "":"" + getPort();
	 }
}",1,1,0,0
"public class DropKeyspaceStatement extends SchemaAlteringStatement{
	 private final String keyspace;
	 public DropKeyspaceStatement(String keyspace) {
		 super();
		 this.keyspace = keyspace;
	 }
	 public void validate(ClientState state) throws InvalidRequestException, SchemaDisagreementException {
		 super.validate(state);
		 ThriftValidation.validateKeyspaceNotSystem(keyspace);
	 }
	 public void announceMigration() throws ConfigurationException {
		 MigrationManager.announceKeyspaceDrop(keyspace);
	 }
}",0,0,0,0
"public class Javadoc extends Task {
	 public class DocletParam {
		 private String name;
		 private String value;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setValue(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
	 }
	 public static class ExtensionInfo extends ProjectComponent {
		 private String name;
		 private Path path;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setPath(Path path) {
			 if (this.path == null) {
				 this.path = path;
			 }
			 else {
				 this.path.append(path);
			 }
		 }
		 public Path getPath() {
			 return path;
		 }
		 public Path createPath() {
			 if (path == null) {
				 path = new Path(getProject());
			 }
			 return path.createPath();
		 }
		 public void setPathRef(Reference r) {
			 createPath().setRefid(r);
		 }
	 }
	 public class DocletInfo extends ExtensionInfo {
		 private Vector params = new Vector();
		 public DocletParam createParam() {
			 DocletParam param = new DocletParam();
			 params.addElement(param);
			 return param;
		 }
		 public Enumeration getParams() {
			 return params.elements();
		 }
	 }
	 public static class PackageName {
		 private String name;
		 public void setName(String name) {
			 this.name = name.trim();
		 }
		 public String getName() {
			 return name;
		 }
		 public String toString() {
			 return getName();
		 }
	 }
	 public static class SourceFile {
		 private File file;
		 public SourceFile() {
		}
		 public SourceFile(File file) {
			 this.file = file;
		 }
		 public void setFile(File file) {
			 this.file = file;
		 }
		 public File getFile() {
			 return file;
		 }
	 }
	 public static class Html {
		 private StringBuffer text = new StringBuffer();
		 public void addText(String t) {
			 text.append(t);
		 }
		 public String getText() {
			 return text.toString();
		 }
	 }
	 public static class AccessType extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""protected"", ""public"", ""package"", ""private""}
			;
		 }
	 }
	 private Commandline cmd = new Commandline();
	 private static boolean javadoc1 = JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1);
	 private static boolean javadoc4 = (!JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1) && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2) && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3));
	 private void addArgIf(boolean b, String arg) {
		 if (b) {
			 cmd.createArgument().setValue(arg);
		 }
	 }
	 private void add12ArgIfNotEmpty(String key, String value) {
		 if (!javadoc1) {
			 if (value != null && value.length() != 0) {
				 cmd.createArgument().setValue(key);
				 cmd.createArgument().setValue(value);
			 }
			 else {
				 log(""Warning: Leaving out empty argument '"" + key + ""'"", Project.MSG_WARN);
			 }
		 }
	 }
	 private void add12ArgIf(boolean b, String arg) {
		 if (!javadoc1 && b) {
			 cmd.createArgument().setValue(arg);
		 }
	 }
	 private boolean failOnError = false;
	 private Path sourcePath = null;
	 private File destDir = null;
	 private Vector sourceFiles = new Vector();
	 private Vector packageNames = new Vector(5);
	 private Vector excludePackageNames = new Vector(1);
	 private boolean author = true;
	 private boolean version = true;
	 private DocletInfo doclet = null;
	 private Path classpath = null;
	 private Path bootclasspath = null;
	 private String group = null;
	 private String packageList = null;
	 private Vector links = new Vector(2);
	 private Vector groups = new Vector(2);
	 private Vector tags = new Vector(5);
	 private boolean useDefaultExcludes = true;
	 private Html doctitle = null;
	 private Html header = null;
	 private Html footer = null;
	 private Html bottom = null;
	 private boolean useExternalFile = false;
	 private FileUtils fileUtils = FileUtils.newFileUtils();
	 private String source = null;
	 private Vector fileSets = new Vector();
	 private Vector packageSets = new Vector();
	 public void setUseExternalFile(boolean b) {
		 if (!javadoc1) {
			 useExternalFile = b;
		 }
	 }
	 public void setDefaultexcludes(boolean useDefaultExcludes) {
		 this.useDefaultExcludes = useDefaultExcludes;
	 }
	 public void setMaxmemory(String max){
		 if (javadoc1) {
			 cmd.createArgument().setValue(""-J-mx"" + max);
		 }
		 else {
			 cmd.createArgument().setValue(""-J-Xmx"" + max);
		 }
	 }
	 public void setAdditionalparam(String add){
		 cmd.createArgument().setLine(add);
	 }
	 public void setSourcepath(Path src) {
		 if (sourcePath == null) {
			 sourcePath = src;
		 }
		 else {
			 sourcePath.append(src);
		 }
	 }
	 public Path createSourcepath() {
		 if (sourcePath == null) {
			 sourcePath = new Path(project);
		 }
		 return sourcePath.createPath();
	 }
	 public void setSourcepathRef(Reference r) {
		 createSourcepath().setRefid(r);
	 }
	 public void setDestdir(File dir) {
		 destDir = dir;
		 cmd.createArgument().setValue(""-d"");
		 cmd.createArgument().setFile(destDir);
	 }
	 public void setSourcefiles(String src) {
		 StringTokenizer tok = new StringTokenizer(src, "","");
		 while (tok.hasMoreTokens()) {
			 String f = tok.nextToken();
			 SourceFile sf = new SourceFile();
			 sf.setFile(project.resolveFile(f));
			 addSource(sf);
		 }
	 }
	 public void addSource(SourceFile sf) {
		 sourceFiles.addElement(sf);
	 }
	 public void setPackagenames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addPackage(pn);
		 }
	 }
	 public void addPackage(PackageName pn) {
		 packageNames.addElement(pn);
	 }
	 public void setExcludePackageNames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addExcludePackage(pn);
		 }
	 }
	 public void addExcludePackage(PackageName pn) {
		 excludePackageNames.addElement(pn);
	 }
	 public void setOverview(File f) {
		 if (!javadoc1) {
			 cmd.createArgument().setValue(""-overview"");
			 cmd.createArgument().setFile(f);
		 }
	 }
	 public void setPublic(boolean b) {
		 addArgIf(b, ""-public"");
	 }
	 public void setProtected(boolean b) {
		 addArgIf(b, ""-protected"");
	 }
	 public void setPackage(boolean b) {
		 addArgIf(b, ""-package"");
	 }
	 public void setPrivate(boolean b) {
		 addArgIf(b, ""-private"");
	 }
	 public void setAccess(AccessType at) {
		 cmd.createArgument().setValue(""-"" + at.getValue());
	 }
	 public void setDoclet(String docletName) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setName(docletName);
	 }
	 public void setDocletPath(Path docletPath) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setPath(docletPath);
	 }
	 public void setDocletPathRef(Reference r) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.createPath().setRefid(r);
	 }
	 public DocletInfo createDoclet() {
		 doclet = new DocletInfo();
		 return doclet;
	 }
	 public void addTaglet(ExtensionInfo tagletInfo) {
		 tags.addElement(tagletInfo);
	 }
	 public void setOld(boolean b) {
		 if (b) {
			 if (javadoc1) {
				 log(""Javadoc 1.1 doesn't support the -1.1 switch"", Project.MSG_WARN);
			 }
			 else if (javadoc4) {
				 log(""Javadoc 1.4 doesn't support the -1.1 switch anymore"", Project.MSG_WARN);
			 }
			 else {
				 cmd.createArgument().setValue(""-1.1"");
			 }
		 }
	 }
	 public void setClasspath(Path path) {
		 if (classpath == null) {
			 classpath = path;
		 }
		 else {
			 classpath.append(path);
		 }
	 }
	 public Path createClasspath() {
		 if (classpath == null) {
			 classpath = new Path(project);
		 }
		 return classpath.createPath();
	 }
	 public void setClasspathRef(Reference r) {
		 createClasspath().setRefid(r);
	 }
	 public void setBootclasspath(Path path) {
		 if (bootclasspath == null) {
			 bootclasspath = path;
		 }
		 else {
			 bootclasspath.append(path);
		 }
	 }
	 public Path createBootclasspath() {
		 if (bootclasspath == null) {
			 bootclasspath = new Path(project);
		 }
		 return bootclasspath.createPath();
	 }
	 public void setBootClasspathRef(Reference r) {
		 createBootclasspath().setRefid(r);
	 }
	 public void setExtdirs(String path) {
		 if (!javadoc1) {
			 cmd.createArgument().setValue(""-extdirs"");
			 cmd.createArgument().setValue(path);
		 }
	 }
	 public void setExtdirs(Path path) {
		 if (!javadoc1) {
			 cmd.createArgument().setValue(""-extdirs"");
			 cmd.createArgument().setPath(path);
		 }
	 }
	 public void setVerbose(boolean b) {
		 add12ArgIf(b, ""-verbose"");
	 }
	 public void setLocale(String locale) {
		 if (!javadoc1) {
			 cmd.createArgument(true).setValue(locale);
			 cmd.createArgument(true).setValue(""-locale"");
		 }
	 }
	 public void setEncoding(String enc) {
		 cmd.createArgument().setValue(""-encoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setVersion(boolean b) {
		 this.version = b;
	 }
	 public void setUse(boolean b) {
		 add12ArgIf(b, ""-use"");
	 }
	 public void setAuthor(boolean b) {
		 author = b;
	 }
	 public void setSplitindex(boolean b) {
		 add12ArgIf(b, ""-splitindex"");
	 }
	 public void setWindowtitle(String title) {
		 add12ArgIfNotEmpty(""-windowtitle"", title);
	 }
	 public void setDoctitle(String doctitle) {
		 Html h = new Html();
		 h.addText(doctitle);
		 addDoctitle(h);
	 }
	 public void addDoctitle(Html text) {
		 if (!javadoc1) {
			 doctitle = text;
		 }
	 }
	 public void setHeader(String header) {
		 Html h = new Html();
		 h.addText(header);
		 addHeader(h);
	 }
	 public void addHeader(Html text) {
		 if (!javadoc1) {
			 header = text;
		 }
	 }
	 public void setFooter(String footer) {
		 Html h = new Html();
		 h.addText(footer);
		 addFooter(h);
	 }
	 public void addFooter(Html text) {
		 if (!javadoc1) {
			 footer = text;
		 }
	 }
	 public void setBottom(String bottom) {
		 Html h = new Html();
		 h.addText(bottom);
		 addBottom(h);
	 }
	 public void addBottom(Html text) {
		 if (!javadoc1) {
			 bottom = text;
		 }
	 }
	 public void setLinkoffline(String src) {
		 if (!javadoc1) {
			 LinkArgument le = createLink();
			 le.setOffline(true);
			 String linkOfflineError = ""The linkoffline attribute must include"" + "" a URL and a package-list file location separated by a"" + "" space"";
			 if (src.trim().length() == 0) {
				 throw new BuildException(linkOfflineError);
			 }
			 StringTokenizer tok = new StringTokenizer(src, "" "", false);
			 le.setHref(tok.nextToken());
			 if (!tok.hasMoreTokens()) {
				 throw new BuildException(linkOfflineError);
			 }
			 le.setPackagelistLoc(project.resolveFile(tok.nextToken()));
		 }
	 }
	 public void setGroup(String src) {
		 group = src;
	 }
	 public void setLink(String src) {
		 if (!javadoc1) {
			 createLink().setHref(src);
		 }
	 }
	 public void setNodeprecated(boolean b) {
		 addArgIf(b, ""-nodeprecated"");
	 }
	 public void setNodeprecatedlist(boolean b) {
		 add12ArgIf(b, ""-nodeprecatedlist"");
	 }
	 public void setNotree(boolean b) {
		 addArgIf(b, ""-notree"");
	 }
	 public void setNoindex(boolean b) {
		 addArgIf(b, ""-noindex"");
	 }
	 public void setNohelp(boolean b) {
		 add12ArgIf(b, ""-nohelp"");
	 }
	 public void setNonavbar(boolean b) {
		 add12ArgIf(b, ""-nonavbar"");
	 }
	 public void setSerialwarn(boolean b) {
		 add12ArgIf(b, ""-serialwarn"");
	 }
	 public void setStylesheetfile(File f) {
		 if (!javadoc1) {
			 cmd.createArgument().setValue(""-stylesheetfile"");
			 cmd.createArgument().setFile(f);
		 }
	 }
	 public void setHelpfile(File f) {
		 if (!javadoc1) {
			 cmd.createArgument().setValue(""-helpfile"");
			 cmd.createArgument().setFile(f);
		 }
	 }
	 public void setDocencoding(String enc) {
		 cmd.createArgument().setValue(""-docencoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setPackageList(String src) {
		 if (!javadoc1) {
			 packageList = src;
		 }
	 }
	 public LinkArgument createLink() {
		 LinkArgument la = new LinkArgument();
		 links.addElement(la);
		 return la;
	 }
	 public class LinkArgument {
		 private String href;
		 private boolean offline = false;
		 private File packagelistLoc;
		 public LinkArgument() {
		 }
		 public void setHref(String hr) {
			 href = hr;
		 }
		 public String getHref() {
			 return href;
		 }
		 public void setPackagelistLoc(File src) {
			 packagelistLoc = src;
		 }
		 public File getPackagelistLoc() {
			 return packagelistLoc;
		 }
		 public void setOffline(boolean offline) {
			 this.offline = offline;
		 }
		 public boolean isLinkOffline() {
			 return offline;
		 }
	 }
	 public TagArgument createTag() {
		 if (!javadoc4) {
			 log (""-tag option not supported on JavaDoc < 1.4"", Project.MSG_VERBOSE);
		 }
		 TagArgument ta = new TagArgument();
		 tags.addElement (ta);
		 return ta;
	 }
	 static final String[] SCOPE_ELEMENTS = {
	 ""overview"", ""packages"", ""types"", ""constructors"", ""methods"", ""fields"" }
	;
	 public class TagArgument {
		 private String name = null;
		 private String description = null;
		 private boolean enabled = true;
		 private String scope = ""a"";
		 public TagArgument () {
		 }
		 public void setName (String name) {
			 this.name = name;
		 }
		 public void setDescription (String description) {
			 this.description = description;
		 }
		 public void setScope (String verboseScope) throws BuildException {
			 verboseScope = verboseScope.toLowerCase(Locale.US);
			 boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
			 boolean gotAll = false;
			 boolean gotNotAll = false;
			 StringTokenizer tok = new StringTokenizer (verboseScope, "","");
			 while (tok.hasMoreTokens()) {
				 String next = tok.nextToken().trim();
				 if (next.equals(""all"")) {
					 if (gotAll) {
						 getProject().log (""Repeated tag scope element: all"", Project.MSG_VERBOSE);
					 }
					 gotAll = true;
				 }
				 else {
					 int i;
					 for (i = 0;
					 i < SCOPE_ELEMENTS.length;
					 i++) {
						 if (next.equals (SCOPE_ELEMENTS[i])) break;
					 }
					 if (i == SCOPE_ELEMENTS.length) {
						 throw new BuildException (""Unrecognised scope element: "" + next);
					 }
					 else {
						 if (elements[i]) {
							 getProject().log (""Repeated tag scope element: "" + next, Project.MSG_VERBOSE);
						 }
						 elements[i] = true;
						 gotNotAll = true;
					 }
				 }
			 }
			 if (gotNotAll && gotAll) {
				 throw new BuildException (""Mixture of \""all\"" and other scope "" + ""elements in tag parameter."");
			 }
			 if (!gotNotAll && !gotAll) {
				 throw new BuildException (""No scope elements specified in tag "" + ""parameter."");
			 }
			 if (gotAll) {
				 this.scope = ""a"";
			 }
			 else {
				 StringBuffer buff = new StringBuffer (elements.length);
				 for (int i = 0;
				 i < elements.length;
				 i++) {
					 if (elements[i]) {
						 buff.append (SCOPE_ELEMENTS[i].charAt(0));
					 }
				 }
				 this.scope = buff.toString();
			 }
		 }
		 public void setEnabled (boolean enabled) {
			 this.enabled = enabled;
		 }
		 public String getParameter () throws BuildException {
			 if (name == null || name.equals("""")) {
				 throw new BuildException (""No name specified for custom tag."");
			 }
			 if (description == null || description.equals("""")){
				 throw new BuildException (""No description specified for custom tag "" + name);
			 }
			 return name + "":"" + (enabled ? """" : ""X"") + scope + "":"" + description;
		 }
	 }
	 public GroupArgument createGroup() {
		 GroupArgument ga = new GroupArgument();
		 groups.addElement(ga);
		 return ga;
	 }
	 public class GroupArgument {
		 private Html title;
		 private Vector packages = new Vector(3);
		 public GroupArgument() {
		 }
		 public void setTitle(String src) {
			 Html h = new Html();
			 h.addText(src);
			 addTitle(h);
		 }
		 public void addTitle(Html text) {
			 title = text;
		 }
		 public String getTitle() {
			 return title != null ? title.getText() : null;
		 }
		 public void setPackages(String src) {
			 StringTokenizer tok = new StringTokenizer(src, "","");
			 while (tok.hasMoreTokens()) {
				 String p = tok.nextToken();
				 PackageName pn = new PackageName();
				 pn.setName(p);
				 addPackage(pn);
			 }
		 }
		 public void addPackage(PackageName pn) {
			 packages.addElement(pn);
		 }
		 public String getPackages() {
			 StringBuffer p = new StringBuffer();
			 for (int i = 0;
			 i < packages.size();
			 i++) {
				 if (i > 0) {
					 p.append("":"");
				 }
				 p.append(packages.elementAt(i).toString());
			 }
			 return p.toString();
		 }
	 }
	 public void setCharset(String src) {
		 this.add12ArgIfNotEmpty(""-charset"", src);
	 }
	 public void setFailonerror(boolean b) {
		 failOnError = b;
	 }
	 public void setSource(String source) {
		 this.source = source;
	 }
	 public void addPackageset(DirSet packageSet) {
		 packageSets.addElement(packageSet);
	 }
	 public void addFileset(FileSet fs) {
		 fileSets.addElement(fs);
	 }
	 public void execute() throws BuildException {
		 if (""javadoc2"".equals(taskType)) {
			 log(""!! javadoc2 is deprecated. Use javadoc instead. !!"");
		 }
		 Vector packagesToDoc = new Vector();
		 Path sourceDirs = new Path(getProject());
		 if (packageList != null && sourcePath == null) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying packagelist."";
			 throw new BuildException(msg);
		 }
		 if (sourcePath != null) {
			 sourceDirs.addExisting(sourcePath);
		 }
		 parsePackages(packagesToDoc, sourceDirs);
		 if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying package names."";
			 throw new BuildException(msg);
		 }
		 Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
		 addFileSets(sourceFilesToDoc);
		 if (packageList == null && packagesToDoc.size() == 0 && sourceFilesToDoc.size() == 0) {
			 throw new BuildException(""No source files and no packages have "" + ""been specified."");
		 }
		 log(""Generating Javadoc"", Project.MSG_INFO);
		 Commandline toExecute = (Commandline) cmd.clone();
		 toExecute.setExecutable(JavaEnvUtils.getJdkExecutable(""javadoc""));
		 if (doctitle != null) {
			 toExecute.createArgument().setValue(""-doctitle"");
			 toExecute.createArgument().setValue(expand(doctitle.getText()));
		 }
		 if (header != null) {
			 toExecute.createArgument().setValue(""-header"");
			 toExecute.createArgument().setValue(expand(header.getText()));
		 }
		 if (footer != null) {
			 toExecute.createArgument().setValue(""-footer"");
			 toExecute.createArgument().setValue(expand(footer.getText()));
		 }
		 if (bottom != null) {
			 toExecute.createArgument().setValue(""-bottom"");
			 toExecute.createArgument().setValue(expand(bottom.getText()));
		 }
		 if (classpath == null) {
			 classpath = Path.systemClasspath;
		 }
		 else {
			 classpath = classpath.concatSystemClasspath(""ignore"");
		 }
		 if (!javadoc1) {
			 if (classpath.size() > 0) {
				 toExecute.createArgument().setValue(""-classpath"");
				 toExecute.createArgument().setPath(classpath);
			 }
			 if (sourceDirs.size() > 0) {
				 toExecute.createArgument().setValue(""-sourcepath"");
				 toExecute.createArgument().setPath(sourceDirs);
			 }
		 }
		 else {
			 sourceDirs.append(classpath);
			 if (sourceDirs.size() > 0) {
				 toExecute.createArgument().setValue(""-classpath"");
				 toExecute.createArgument().setPath(sourceDirs);
			 }
		 }
		 if (version && doclet == null) {
			 toExecute.createArgument().setValue(""-version"");
		 }
		 if (author && doclet == null) {
			 toExecute.createArgument().setValue(""-author"");
		 }
		 if (javadoc1 || doclet == null) {
			 if (destDir == null) {
				 String msg = ""destDir attribute must be set!"";
				 throw new BuildException(msg);
			 }
		 }
		 if (!javadoc1) {
			 if (doclet != null) {
				 if (doclet.getName() == null) {
					 throw new BuildException(""The doclet name must be "" + ""specified."", location);
				 }
				 else {
					 toExecute.createArgument().setValue(""-doclet"");
					 toExecute.createArgument().setValue(doclet.getName());
					 if (doclet.getPath() != null) {
						 Path docletPath = doclet.getPath().concatSystemClasspath(""ignore"");
						 if (docletPath.size() != 0) {
							 toExecute.createArgument().setValue(""-docletpath"");
							 toExecute.createArgument().setPath(docletPath);
						 }
					 }
					 for (Enumeration e = doclet.getParams();
					 e.hasMoreElements();
					) {
						 DocletParam param = (DocletParam) e.nextElement();
						 if (param.getName() == null) {
							 throw new BuildException(""Doclet parameters must "" + ""have a name"");
						 }
						 toExecute.createArgument().setValue(param.getName());
						 if (param.getValue() != null) {
							 toExecute.createArgument() .setValue(param.getValue());
						 }
					 }
				 }
			 }
			 if (bootclasspath != null && bootclasspath.size() > 0) {
				 toExecute.createArgument().setValue(""-bootclasspath"");
				 toExecute.createArgument().setPath(bootclasspath);
			 }
			 if (links.size() != 0) {
				 for (Enumeration e = links.elements();
				 e.hasMoreElements();
				) {
					 LinkArgument la = (LinkArgument) e.nextElement();
					 if (la.getHref() == null || la.getHref().length() == 0) {
						 log(""No href was given for the link - skipping"", Project.MSG_VERBOSE);
						 continue;
					 }
					 else {
						 try {
							 URL base = new URL(""file: URL testHref = new URL(base, la.getHref());
						 }
						 catch (MalformedURLException mue) {
							 log(""Link href \"""" + la.getHref() + ""\"" is not a valid url - skipping link"", Project.MSG_WARN);
							 continue;
						 }
					 }
					 if (la.isLinkOffline()) {
						 File packageListLocation = la.getPackagelistLoc();
						 if (packageListLocation == null) {
							 throw new BuildException(""The package list "" + "" location for link "" + la.getHref() + "" must be provided because the link is "" + ""offline"");
						 }
						 File packageListFile = new File(packageListLocation, ""package-list"");
						 if (packageListFile.exists()) {
							 toExecute.createArgument().setValue(""-linkoffline"");
							 toExecute.createArgument().setValue(la.getHref());
							 toExecute.createArgument() .setValue(packageListLocation .getAbsolutePath());
						 }
						 else {
							 log(""Warning: No package list was found at "" + packageListLocation, Project.MSG_VERBOSE);
						 }
					 }
					 else {
						 toExecute.createArgument().setValue(""-link"");
						 toExecute.createArgument().setValue(la.getHref());
					 }
				 }
			 }
			 if (group != null) {
				 StringTokenizer tok = new StringTokenizer(group, "","", false);
				 while (tok.hasMoreTokens()) {
					 String grp = tok.nextToken().trim();
					 int space = grp.indexOf("" "");
					 if (space > 0){
						 String name = grp.substring(0, space);
						 String pkgList = grp.substring(space + 1);
						 toExecute.createArgument().setValue(""-group"");
						 toExecute.createArgument().setValue(name);
						 toExecute.createArgument().setValue(pkgList);
					 }
				 }
			 }
			 if (groups.size() != 0) {
				 for (Enumeration e = groups.elements();
				 e.hasMoreElements();
				) {
					 GroupArgument ga = (GroupArgument) e.nextElement();
					 String title = ga.getTitle();
					 String packages = ga.getPackages();
					 if (title == null || packages == null) {
						 throw new BuildException(""The title and packages must "" + ""be specified for group "" + ""elements."");
					 }
					 toExecute.createArgument().setValue(""-group"");
					 toExecute.createArgument().setValue(expand(title));
					 toExecute.createArgument().setValue(packages);
				 }
			 }
			 if (javadoc4) {
				 for (Enumeration e = tags.elements();
				 e.hasMoreElements();
				) {
					 Object element = e.nextElement();
					 if (element instanceof TagArgument) {
						 TagArgument ta = (TagArgument) element;
						 toExecute.createArgument().setValue (""-tag"");
						 toExecute.createArgument().setValue (ta.getParameter());
					 }
					 else {
						 ExtensionInfo tagletInfo = (ExtensionInfo) element;
						 toExecute.createArgument().setValue(""-taglet"");
						 toExecute.createArgument().setValue(tagletInfo .getName());
						 if (tagletInfo.getPath() != null) {
							 Path tagletPath = tagletInfo.getPath() .concatSystemClasspath(""ignore"");
							 if (tagletPath.size() != 0) {
								 toExecute.createArgument() .setValue(""-tagletpath"");
								 toExecute.createArgument().setPath(tagletPath);
							 }
						 }
					 }
				 }
				 if (source != null) {
					 if (doclet != null) {
						 log(""ignoring source option for custom doclet"", Project.MSG_WARN);
					 }
					 else {
						 toExecute.createArgument().setValue(""-source"");
						 toExecute.createArgument().setValue(source);
					 }
				 }
			 }
		 }
		 File tmpList = null;
		 PrintWriter srcListWriter = null;
		 try {
			 if (useExternalFile) {
				 if (tmpList == null) {
					 tmpList = fileUtils.createTempFile(""javadoc"", """", null);
					 toExecute.createArgument() .setValue(""@"" + tmpList.getAbsolutePath());
				 }
				 srcListWriter = new PrintWriter( new FileWriter(tmpList.getAbsolutePath(), true));
			 }
			 Enumeration enum = packagesToDoc.elements();
			 while (enum.hasMoreElements()) {
				 String packageName = (String) enum.nextElement();
				 if (useExternalFile) {
					 srcListWriter.println(packageName);
				 }
				 else {
					 toExecute.createArgument().setValue(packageName);
				 }
			 }
			 enum = sourceFilesToDoc.elements();
			 while (enum.hasMoreElements()) {
				 SourceFile sf = (SourceFile) enum.nextElement();
				 String sourceFileName = sf.getFile().getAbsolutePath();
				 if (useExternalFile) {
					 srcListWriter.println(sourceFileName);
				 }
				 else {
					 toExecute.createArgument().setValue(sourceFileName);
				 }
			 }
		 }
		 catch (IOException e) {
			 tmpList.delete();
			 throw new BuildException(""Error creating temporary file"", e, location);
		 }
		 finally {
			 if (srcListWriter != null) {
				 srcListWriter.close();
			 }
		 }
		 if (packageList != null) {
			 toExecute.createArgument().setValue(""@"" + packageList);
		 }
		 log(toExecute.describeCommand(), Project.MSG_VERBOSE);
		 log(""Javadoc execution"", Project.MSG_INFO);
		 JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
		 JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
		 Execute exe = new Execute(new PumpStreamHandler(out, err));
		 exe.setAntRun(project);
		 exe.setWorkingDirectory(null);
		 try {
			 exe.setCommandline(toExecute.getCommandline());
			 int ret = exe.execute();
			 if (ret != 0 && failOnError) {
				 throw new BuildException(""Javadoc returned "" + ret, location);
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(""Javadoc failed: "" + e, e, location);
		 }
		 finally {
			 if (tmpList != null) {
				 tmpList.delete();
				 tmpList = null;
			 }
			 out.logFlush();
			 err.logFlush();
			 try {
				 out.close();
				 err.close();
			 }
			 catch (IOException e) {
			}
		 }
	 }
	 private void addFileSets(Vector sf) {
		 Enumeration enum = fileSets.elements();
		 while (enum.hasMoreElements()) {
			 FileSet fs = (FileSet) enum.nextElement();
			 if (!fs.hasPatterns() && !fs.hasSelectors()) {
				 fs = (FileSet) fs.clone();
				 fs.createInclude().setName(""** private void parsePackages(Vector pn, Path sp) {
					 Vector addedPackages = new Vector();
					 Vector dirSets = (Vector) packageSets.clone();
					 if (sourcePath != null && packageNames.size() > 0) {
						 PatternSet ps = new PatternSet();
						 Enumeration enum = packageNames.elements();
						 while (enum.hasMoreElements()) {
							 PackageName p = (PackageName) enum.nextElement();
							 String pkg = p.getName().replace('.', '/');
							 if (pkg.endsWith(""*"")) {
								 pkg += ""*"";
							 }
							 ps.createInclude().setName(pkg);
						 }
						 enum = excludePackageNames.elements();
						 while (enum.hasMoreElements()) {
							 PackageName p = (PackageName) enum.nextElement();
							 String pkg = p.getName().replace('.', '/');
							 if (pkg.endsWith(""*"")) {
								 pkg += ""*"";
							 }
							 ps.createExclude().setName(pkg);
						 }
						 String[] pathElements = sourcePath.list();
						 for (int i = 0;
						 i < pathElements.length;
						 i++) {
							 DirSet ds = new DirSet();
							 ds.setDefaultexcludes(useDefaultExcludes);
							 ds.setDir(new File(pathElements[i]));
							 ds.createPatternSet().addConfiguredPatternset(ps);
							 dirSets.addElement(ds);
						 }
					 }
					 Enumeration enum = dirSets.elements();
					 while (enum.hasMoreElements()) {
						 DirSet ds = (DirSet) enum.nextElement();
						 File baseDir = ds.getDir(getProject());
						 log(""scanning "" + baseDir + "" for packages."", Project.MSG_DEBUG);
						 DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
						 String[] dirs = dsc.getIncludedDirectories();
						 boolean containsPackages = false;
						 for (int i = 0;
						 i < dirs.length;
						 i++) {
							 File pd = new File(baseDir, dirs[i]);
							 String[] files = pd.list(new FilenameFilter () {
								 public boolean accept(File dir1, String name) {
									 if (name.endsWith("".java"")) {
										 return true;
									 }
									 return false;
								 }
							 }
							);
							 if (files.length > 0) {
								 containsPackages = true;
								 String packageName = dirs[i].replace(File.separatorChar, '.');
								 if (!addedPackages.contains(packageName)) {
									 addedPackages.addElement(packageName);
									 pn.addElement(packageName);
								 }
							 }
						 }
						 if (containsPackages) {
							 sp.createPathElement().setLocation(baseDir);
						 }
						 else {
							 log(baseDir + "" doesn\'t contain any packages, dropping it."", Project.MSG_VERBOSE);
						 }
					 }
				 }
				 private class JavadocOutputStream extends LogOutputStream {
					 JavadocOutputStream(int level) {
						 super(Javadoc.this, level);
					 }
					 private String queuedLine = null;
					 protected void processLine(String line, int messageLevel) {
						 if (messageLevel == Project.MSG_INFO && line.startsWith(""Generating "")) {
							 if (queuedLine != null) {
								 super.processLine(queuedLine, Project.MSG_VERBOSE);
							 }
							 queuedLine = line;
						 }
						 else {
							 if (queuedLine != null) {
								 if (line.startsWith(""Building "")) {
									 super.processLine(queuedLine, Project.MSG_VERBOSE);
								 }
								 else {
									 super.processLine(queuedLine, Project.MSG_INFO);
								 }
								 queuedLine = null;
							 }
							 super.processLine(line, messageLevel);
						 }
					 }
					 protected void logFlush() {
						 if (queuedLine != null) {
							 super.processLine(queuedLine, Project.MSG_VERBOSE);
							 queuedLine = null;
						 }
					 }
				 }
				 protected String expand(String content) {
					 return project.replaceProperties(content);
				 }
			}",1,0,0,0
"public int size() {
	 return DBConstants.shortSize + name.remaining() + 1 + DBConstants.tsSize + DBConstants.intSize + value.remaining();
 }",0,0,0,0
"public class IncomingReferrer {
	 private String referrerUrl = null;
	 private String requestUrl = null;
	 private String weblogHandle = null;
	 private String weblogAnchor = null;
	 private String weblogDateString = null;
	 public IncomingReferrer() {
	}
	 public String getReferrerUrl() {
		 return referrerUrl;
	 }
	 public void setReferrerUrl(String referrerUrl) {
		 this.referrerUrl = referrerUrl;
	 }
	 public String getRequestUrl() {
		 return requestUrl;
	 }
	 public void setRequestUrl(String requestUrl) {
		 this.requestUrl = requestUrl;
	 }
	 public String getWeblogHandle() {
		 return weblogHandle;
	 }
	 public void setWeblogHandle(String weblogHandle) {
		 this.weblogHandle = weblogHandle;
	 }
	 public String getWeblogAnchor() {
		 return weblogAnchor;
	 }
	 public void setWeblogAnchor(String weblogAnchor) {
		 this.weblogAnchor = weblogAnchor;
	 }
	 public String getWeblogDateString() {
		 return weblogDateString;
	 }
	 public void setWeblogDateString(String weblogDateString) {
		 this.weblogDateString = weblogDateString;
	 }
}",0,1,0,0
"public class ThriftValidation{
	 public static void validateKey(CFMetaData metadata, ByteBuffer key) throws InvalidRequestException {
		 if (key == null || key.remaining() == 0) {
			 throw new InvalidRequestException(""Key may not be empty"");
		 }
		 if (key.remaining() > FBUtilities.MAX_UNSIGNED_SHORT) {
			 throw new InvalidRequestException(""Key length of "" + key.remaining() + "" is longer than maximum of "" + FBUtilities.MAX_UNSIGNED_SHORT);
		 }
		 try {
			 metadata.getKeyValidator().validate(key);
		 }
		 catch (MarshalException e) {
			 throw new InvalidRequestException(e.getMessage());
		 }
	 }
	 public static void validateTable(String tablename) throws KeyspaceNotDefinedException {
		 if (!DatabaseDescriptor.getTables().contains(tablename)) {
			 throw new KeyspaceNotDefinedException(""Keyspace "" + tablename + "" does not exist"");
		 }
	 }
	 public static void validateConsistencyLevel(String table, ConsistencyLevel cl) throws InvalidRequestException {
		 switch (cl) {
			 case LOCAL_QUORUM: case EACH_QUORUM: AbstractReplicationStrategy strategy = Table.open(table).getReplicationStrategy();
			 if (!(strategy instanceof NetworkTopologyStrategy)) throw new InvalidRequestException(""consistency level "" + cl + "" not compatible with replication strategy ("" + strategy.getClass().getName() + "")"");
		 }
	 }
	 public static CFMetaData validateColumnFamily(String tablename, String cfName, boolean isCommutativeOp) throws InvalidRequestException {
		 CFMetaData metadata = validateColumnFamily(tablename, cfName);
		 if (isCommutativeOp) {
			 if (!metadata.getDefaultValidator().isCommutative()) throw new InvalidRequestException(""invalid operation for non commutative columnfamily "" + cfName);
		 }
		 else {
			 if (metadata.getDefaultValidator().isCommutative()) throw new InvalidRequestException(""invalid operation for commutative columnfamily "" + cfName);
		 }
		 return metadata;
	 }
	 public static CFMetaData validateColumnFamily(String tablename, String cfName) throws InvalidRequestException {
		 validateTable(tablename);
		 if (cfName.isEmpty()) throw new InvalidRequestException(""non-empty columnfamily is required"");
		 CFMetaData metadata = DatabaseDescriptor.getCFMetaData(tablename, cfName);
		 if (metadata == null) throw new InvalidRequestException(""unconfigured columnfamily "" + cfName);
		 return metadata;
	 }
	 public static void validateColumnPath(CFMetaData metadata, ColumnPath column_path) throws InvalidRequestException {
		 if (metadata.cfType == ColumnFamilyType.Standard) {
			 if (column_path.super_column != null) {
				 throw new InvalidRequestException(""supercolumn parameter is invalid for standard CF "" + metadata.cfName);
			 }
			 if (column_path.column == null) {
				 throw new InvalidRequestException(""column parameter is not optional for standard CF "" + metadata.cfName);
			 }
		 }
		 else {
			 if (column_path.super_column == null) throw new InvalidRequestException(""supercolumn parameter is not optional for super CF "" + metadata.cfName);
		 }
		 if (column_path.column != null) {
			 validateColumnNames(metadata, column_path.super_column, Arrays.asList(column_path.column));
		 }
		 if (column_path.super_column != null) {
			 validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(column_path.super_column));
		 }
	 }
	 public static void validateColumnParent(CFMetaData metadata, ColumnParent column_parent) throws InvalidRequestException {
		 if (metadata.cfType == ColumnFamilyType.Standard) {
			 if (column_parent.super_column != null) {
				 throw new InvalidRequestException(""columnfamily alone is required for standard CF "" + metadata.cfName);
			 }
		 }
		 if (column_parent.super_column != null) {
			 validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(column_parent.super_column));
		 }
	 }
	 static void validateColumnPathOrParent(CFMetaData metadata, ColumnPath column_path_or_parent) throws InvalidRequestException {
		 if (metadata.cfType == ColumnFamilyType.Standard) {
			 if (column_path_or_parent.super_column != null) {
				 throw new InvalidRequestException(""supercolumn may not be specified for standard CF "" + metadata.cfName);
			 }
		 }
		 if (metadata.cfType == ColumnFamilyType.Super) {
			 if (column_path_or_parent.super_column == null && column_path_or_parent.column != null) {
				 throw new InvalidRequestException(""A column cannot be specified without specifying a super column for removal on super CF "" + metadata.cfName);
			 }
		 }
		 if (column_path_or_parent.column != null) {
			 validateColumnNames(metadata, column_path_or_parent.super_column, Arrays.asList(column_path_or_parent.column));
		 }
		 if (column_path_or_parent.super_column != null) {
			 validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(column_path_or_parent.super_column));
		 }
	 }
	 private static void validateColumnNames(CFMetaData metadata, ByteBuffer superColumnName, Iterable<ByteBuffer> column_names) throws InvalidRequestException {
		 if (superColumnName != null) {
			 if (superColumnName.remaining() > IColumn.MAX_NAME_LENGTH) throw new InvalidRequestException(""supercolumn name length must not be greater than "" + IColumn.MAX_NAME_LENGTH);
			 if (superColumnName.remaining() == 0) throw new InvalidRequestException(""supercolumn name must not be empty"");
			 if (metadata.cfType == ColumnFamilyType.Standard) throw new InvalidRequestException(""supercolumn specified to ColumnFamily "" + metadata.cfName + "" containing normal columns"");
		 }
		 AbstractType comparator = metadata.getComparatorFor(superColumnName);
		 for (ByteBuffer name : column_names) {
			 if (name.remaining() > IColumn.MAX_NAME_LENGTH) throw new InvalidRequestException(""column name length must not be greater than "" + IColumn.MAX_NAME_LENGTH);
			 if (name.remaining() == 0) throw new InvalidRequestException(""column name must not be empty"");
			 try {
				 comparator.validate(name);
			 }
			 catch (MarshalException e) {
				 throw new InvalidRequestException(e.getMessage());
			 }
		 }
	 }
	 public static void validateColumnNames(CFMetaData metadata, ColumnParent column_parent, Iterable<ByteBuffer> column_names) throws InvalidRequestException {
		 validateColumnNames(metadata, column_parent.super_column, column_names);
	 }
	 public static void validateRange(CFMetaData metadata, ColumnParent column_parent, SliceRange range) throws InvalidRequestException {
		 AbstractType comparator = metadata.getComparatorFor(column_parent.super_column);
		 try {
			 comparator.validate(range.start);
			 comparator.validate(range.finish);
		 }
		 catch (MarshalException e) {
			 throw new InvalidRequestException(e.getMessage());
		 }
		 if (range.count < 0) throw new InvalidRequestException(""get_slice requires non-negative count"");
		 Comparator<ByteBuffer> orderedComparator = range.isReversed() ? comparator.reverseComparator : comparator;
		 if (range.start.remaining() > 0 && range.finish.remaining() > 0 && orderedComparator.compare(range.start, range.finish) > 0) {
			 throw new InvalidRequestException(""range finish must come after start in the order of traversal"");
		 }
	 }
	 public static void validateColumnOrSuperColumn(CFMetaData metadata, ColumnOrSuperColumn cosc) throws InvalidRequestException {
		 boolean isCommutative = metadata.getDefaultValidator().isCommutative();
		 int nulls = 0;
		 if (cosc.column == null) nulls++;
		 if (cosc.super_column == null) nulls++;
		 if (cosc.counter_column == null) nulls++;
		 if (cosc.counter_super_column == null) nulls++;
		 if (nulls != 3) throw new InvalidRequestException(""ColumnOrSuperColumn must have one (and only one) of column, super_column, counter and counter_super_column"");
		 if (cosc.column != null) {
			 if (isCommutative) throw new InvalidRequestException(""invalid operation for commutative columnfamily "" + metadata.cfName);
			 validateTtl(cosc.column);
			 validateColumnPath(metadata, new ColumnPath(metadata.cfName).setSuper_column((ByteBuffer)null).setColumn(cosc.column.name));
			 validateColumnData(metadata, cosc.column);
		 }
		 if (cosc.super_column != null) {
			 if (isCommutative) throw new InvalidRequestException(""invalid operation for commutative columnfamily "" + metadata.cfName);
			 for (Column c : cosc.super_column.columns) {
				 validateColumnPath(metadata, new ColumnPath(metadata.cfName).setSuper_column(cosc.super_column.name).setColumn(c.name));
				 validateColumnData(metadata, c);
			 }
		 }
		 if (cosc.counter_column != null) {
			 if (!isCommutative) throw new InvalidRequestException(""invalid operation for non commutative columnfamily "" + metadata.cfName);
			 validateColumnPath(metadata, new ColumnPath(metadata.cfName).setSuper_column((ByteBuffer)null).setColumn(cosc.counter_column.name));
		 }
		 if (cosc.counter_super_column != null) {
			 if (!isCommutative) throw new InvalidRequestException(""invalid operation for non commutative columnfamily "" + metadata.cfName);
			 for (CounterColumn c : cosc.counter_super_column.columns) validateColumnPath(metadata, new ColumnPath(metadata.cfName).setSuper_column(cosc.counter_super_column.name).setColumn(c.name));
		 }
	 }
	 private static void validateTtl(Column column) throws InvalidRequestException {
		 if (column.isSetTtl() && column.ttl <= 0) {
			 throw new InvalidRequestException(""ttl must be positive"");
		 }
		 assert column.isSetTtl() || column.ttl == 0;
	 }
	 public static void validateMutation(CFMetaData metadata, Mutation mut) throws InvalidRequestException {
		 ColumnOrSuperColumn cosc = mut.column_or_supercolumn;
		 Deletion del = mut.deletion;
		 int nulls = 0;
		 if (cosc == null) nulls++;
		 if (del == null) nulls++;
		 if (nulls != 1) {
			 throw new InvalidRequestException(""mutation must have one and only one of column_or_supercolumn or deletion"");
		 }
		 if (cosc != null) {
			 validateColumnOrSuperColumn(metadata, cosc);
		 }
		 else {
			 validateDeletion(metadata, del);
		 }
	 }
	 public static void validateDeletion(CFMetaData metadata, Deletion del) throws InvalidRequestException {
		 if (del.super_column != null) validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(del.super_column));
		 if (del.predicate != null) {
			 validateSlicePredicate(metadata, del.super_column, del.predicate);
			 if (del.predicate.slice_range != null) throw new InvalidRequestException(""Deletion does not yet support SliceRange predicates."");
		 }
		 if (metadata.cfType == ColumnFamilyType.Standard && del.super_column != null) {
			 String msg = String.format(""Deletion of super columns is not possible on a standard ColumnFamily (KeySpace=%s ColumnFamily=%s Deletion=%s)"", metadata.ksName, metadata.cfName, del);
			 throw new InvalidRequestException(msg);
		 }
		 if (metadata.getDefaultValidator().isCommutative()) {
			 del.timestamp = System.currentTimeMillis();
		 }
		 else if (!del.isSetTimestamp()) {
			 throw new InvalidRequestException(""Deletion timestamp is not optional for non commutative column family "" + metadata.cfName);
		 }
	 }
	 public static void validateSlicePredicate(CFMetaData metadata, ByteBuffer scName, SlicePredicate predicate) throws InvalidRequestException {
		 if (predicate.column_names == null && predicate.slice_range == null) throw new InvalidRequestException(""A SlicePredicate must be given a list of Columns, a SliceRange, or both"");
		 if (predicate.slice_range != null) validateRange(metadata, new ColumnParent(metadata.cfName).setSuper_column(scName), predicate.slice_range);
		 if (predicate.column_names != null) validateColumnNames(metadata, scName, predicate.column_names);
	 }
	 public static void validateColumnData(CFMetaData metadata, Column column) throws InvalidRequestException {
		 validateTtl(column);
		 if (!column.isSetValue()) throw new InvalidRequestException(""Column value is required"");
		 if (!column.isSetTimestamp()) throw new InvalidRequestException(""Column timestamp is required"");
		 try {
			 AbstractType validator = metadata.getValueValidator(column.name);
			 if (validator != null) validator.validate(column.value);
		 }
		 catch (MarshalException me) {
			 throw new InvalidRequestException(String.format(""[%s][%s][%s] = [%s] failed validation (%s)"", metadata.ksName, metadata.cfName, ByteBufferUtil.bytesToHex(column.name), ByteBufferUtil.bytesToHex(column.value), me.getMessage()));
		 }
	 }
	 public static void validatePredicate(CFMetaData metadata, ColumnParent column_parent, SlicePredicate predicate) throws InvalidRequestException {
		 if (predicate.column_names == null && predicate.slice_range == null) throw new InvalidRequestException(""predicate column_names and slice_range may not both be null"");
		 if (predicate.column_names != null && predicate.slice_range != null) throw new InvalidRequestException(""predicate column_names and slice_range may not both be present"");
		 if (predicate.getSlice_range() != null) validateRange(metadata, column_parent, predicate.slice_range);
		 else validateColumnNames(metadata, column_parent, predicate.column_names);
	 }
	 public static void validateKeyRange(KeyRange range) throws InvalidRequestException {
		 if ((range.start_key == null) != (range.end_key == null)) {
			 throw new InvalidRequestException(""start key and end key must either both be non-null, or both be null"");
		 }
		 if ((range.start_token == null) != (range.end_token == null)) {
			 throw new InvalidRequestException(""start token and end token must either both be non-null, or both be null"");
		 }
		 if ((range.start_key == null) == (range.start_token == null)) {
			 throw new InvalidRequestException(""exactly one of {
			start key, end key}
			 or {
			start token, end token}
			 must be specified"");
		 }
		 if (range.start_key != null) {
			 IPartitioner p = StorageService.getPartitioner();
			 Token startToken = p.getToken(range.start_key);
			 Token endToken = p.getToken(range.end_key);
			 if (startToken.compareTo(endToken) > 0 && !endToken.equals(p.getMinimumToken())) {
				 if (p instanceof RandomPartitioner) throw new InvalidRequestException(""start key's md5 sorts after end key's md5. this is not allowed;
				 you probably should not specify end key at all, under RandomPartitioner"");
				 else throw new InvalidRequestException(""start key must sort before (or equal to) finish key in your partitioner!"");
			 }
		 }
		 if (range.count <= 0) {
			 throw new InvalidRequestException(""maxRows must be positive"");
		 }
	 }
	 public static void validateIndexClauses(CFMetaData metadata, IndexClause index_clause) throws InvalidRequestException {
		 if (index_clause.expressions.isEmpty()) throw new InvalidRequestException(""index clause list may not be empty"");
		 Set<ByteBuffer> indexedColumns = Table.open(metadata.ksName).getColumnFamilyStore(metadata.cfName).getIndexedColumns();
		 AbstractType nameValidator = ColumnFamily.getComparatorFor(metadata.ksName, metadata.cfName, null);
		 boolean isIndexed = false;
		 for (IndexExpression expression : index_clause.expressions) {
			 try {
				 nameValidator.validate(expression.column_name);
			 }
			 catch (MarshalException me) {
				 throw new InvalidRequestException(String.format(""[%s]=[%s] failed name validation (%s)"", ByteBufferUtil.bytesToHex(expression.column_name), ByteBufferUtil.bytesToHex(expression.value), me.getMessage()));
			 }
			 AbstractType valueValidator = DatabaseDescriptor.getValueValidator(metadata.ksName, metadata.cfName, expression.column_name);
			 try {
				 valueValidator.validate(expression.value);
			 }
			 catch (MarshalException me) {
				 throw new InvalidRequestException(String.format(""[%s]=[%s] failed value validation (%s)"", ByteBufferUtil.bytesToHex(expression.column_name), ByteBufferUtil.bytesToHex(expression.value), me.getMessage()));
			 }
			 isIndexed |= expression.op.equals(IndexOperator.EQ) && indexedColumns.contains(expression.column_name);
		 }
		 if (!isIndexed) throw new InvalidRequestException(""No indexed columns present in index clause with operator EQ"");
	 }
	 public static void validateCfDef(CfDef cf_def, CFMetaData old) throws InvalidRequestException {
		 try {
			 if (cf_def.key_alias != null) {
				 if (!cf_def.key_alias.hasRemaining()) throw new InvalidRequestException(""key_alias may not be empty"");
				 try {
					 AsciiType.instance.validate(cf_def.key_alias);
				 }
				 catch (MarshalException e) {
					 throw new InvalidRequestException(""Key aliases must be ascii"");
				 }
			 }
			 if (cf_def.key_alias != null) {
				 if (!cf_def.key_alias.hasRemaining()) throw new InvalidRequestException(""key_alias may not be empty"");
				 try {
					 AsciiType.instance.validate(cf_def.key_alias);
				 }
				 catch (MarshalException e) {
					 throw new InvalidRequestException(""Key aliases must be ascii"");
				 }
			 }
			 ColumnFamilyType cfType = ColumnFamilyType.create(cf_def.column_type);
			 if (cfType == null) throw new InvalidRequestException(""invalid column type "" + cf_def.column_type);
			 TypeParser.parse(cf_def.comparator_type);
			 TypeParser.parse(cf_def.subcomparator_type);
			 TypeParser.parse(cf_def.default_validation_class);
			 if (cfType != ColumnFamilyType.Super && cf_def.subcomparator_type != null) throw new InvalidRequestException(""subcomparator_type is invalid for standard columns"");
			 if (cf_def.column_metadata == null) return;
			 AbstractType comparator = cfType == ColumnFamilyType.Standard ? TypeParser.parse(cf_def.comparator_type) : TypeParser.parse(cf_def.subcomparator_type);
			 Set<String> indexNames = new HashSet<String>();
			 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
				 if (!cfs.getColumnFamilyName().equals(cf_def.name)) for (ColumnDefinition cd : cfs.metadata.getColumn_metadata().values()) indexNames.add(cd.getIndexName());
			 }
			 for (ColumnDef c : cf_def.column_metadata) {
				 TypeParser.parse(c.validation_class);
				 try {
					 comparator.validate(c.name);
				 }
				 catch (MarshalException e) {
					 throw new InvalidRequestException(String.format(""Column name %s is not valid for comparator %s"", ByteBufferUtil.bytesToHex(c.name), cf_def.comparator_type));
				 }
				 if (c.index_type == null) {
					 if (c.index_name != null) throw new ConfigurationException(""index_name cannot be set without index_type"");
				 }
				 else {
					 if (cfType == ColumnFamilyType.Super) throw new InvalidRequestException(""Secondary indexes are not supported on supercolumns"");
					 assert c.index_name != null;
					 if (!Migration.isLegalName(c.index_name)) throw new InvalidRequestException(""Illegal index name "" + c.index_name);
					 if (indexNames.contains(c.index_name)) throw new InvalidRequestException(""Duplicate index name "" + c.index_name);
					 indexNames.add(c.index_name);
					 ColumnDefinition oldCd = old == null ? null : old.getColumnDefinition(c.name);
					 if (oldCd != null && oldCd.getIndexType() != null) {
						 assert oldCd.getIndexName() != null;
						 if (!oldCd.getIndexName().equals(c.index_name)) throw new InvalidRequestException(""Cannot modify index name"");
					 }
				 }
			 }
			 validateMinMaxCompactionThresholds(cf_def);
			 validateMemtableSettings(cf_def);
		 }
		 catch (ConfigurationException e) {
			 throw new InvalidRequestException(e.getMessage());
		 }
	 }
	 public static void validateCommutativeForWrite(CFMetaData metadata, ConsistencyLevel consistency) throws InvalidRequestException {
		 if (!metadata.getReplicateOnWrite() && consistency != ConsistencyLevel.ONE) {
			 throw new InvalidRequestException(""cannot achieve CL > CL.ONE without replicate_on_write on columnfamily "" + metadata.cfName);
		 }
	 }
	 public static void validateKsDef(KsDef ks_def) throws ConfigurationException {
		 Map<String, String> options = KSMetaData.forwardsCompatibleOptions(ks_def);
		 TokenMetadata tmd = StorageService.instance.getTokenMetadata();
		 IEndpointSnitch eps = DatabaseDescriptor.getEndpointSnitch();
		 Class<? extends AbstractReplicationStrategy> cls = AbstractReplicationStrategy.getClass(ks_def.strategy_class);
		 AbstractReplicationStrategy.createReplicationStrategy(ks_def.name, cls, tmd, eps, options);
	 }
	 public static void validateMinMaxCompactionThresholds(org.apache.cassandra.thrift.CfDef cf_def) throws ConfigurationException {
		 if (cf_def.isSetMin_compaction_threshold() && cf_def.isSetMax_compaction_threshold()) {
			 if ((cf_def.min_compaction_threshold > cf_def.max_compaction_threshold) && cf_def.max_compaction_threshold != 0) {
				 throw new ConfigurationException(""min_compaction_threshold cannot be greater than max_compaction_threshold"");
			 }
		 }
		 else if (cf_def.isSetMin_compaction_threshold()) {
			 if (cf_def.min_compaction_threshold > CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD) {
				 throw new ConfigurationException(String.format(""min_compaction_threshold cannot be greather than max_compaction_threshold (default %d)"", CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD));
			 }
		 }
		 else if (cf_def.isSetMax_compaction_threshold()) {
			 if (cf_def.max_compaction_threshold < CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD && cf_def.max_compaction_threshold != 0) {
				 throw new ConfigurationException(""max_compaction_threshold cannot be less than min_compaction_threshold"");
			 }
		 }
		 else {
		 }
	 }
	 public static void validateMemtableSettings(org.apache.cassandra.thrift.CfDef cf_def) throws ConfigurationException {
		 if (cf_def.isSetMemtable_flush_after_mins()) DatabaseDescriptor.validateMemtableFlushPeriod(cf_def.memtable_flush_after_mins);
		 if (cf_def.isSetMemtable_throughput_in_mb()) DatabaseDescriptor.validateMemtableThroughput(cf_def.memtable_throughput_in_mb);
		 if (cf_def.isSetMemtable_operations_in_millions()) DatabaseDescriptor.validateMemtableOperations(cf_def.memtable_operations_in_millions);
	 }
}",0,0,0,0
"public abstract class AbstractJdbcUUID extends AbstractJdbcType<UUID>{
	 public String toString(UUID obj) {
		 return obj.toString();
	 }
	 public boolean isCaseSensitive() {
		 return false;
	 }
	 public int getScale(UUID obj) {
		 return -1;
	 }
	 public int getPrecision(UUID obj) {
		 return -1;
	 }
	 public boolean isCurrency() {
		 return false;
	 }
	 public boolean isSigned() {
		 return false;
	 }
	 public boolean needsQuotes() {
		 return false;
	 }
	 public Class<UUID> getType() {
		 return UUID.class;
	 }
	 public int getJdbcType() {
		 return Types.OTHER;
	 }
}",0,0,0,0
"public Map<String, ExchangeSession.Contact> galFind(Condition condition, Set<String> returningAttributes, int sizeLimit) throws IOException {
	 Map<String, ExchangeSession.Contact> contacts = new HashMap<String, ExchangeSession.Contact>();
	 if (disableGalFind) {
	 }
	 else if (condition instanceof MultiCondition) {
		 List<Condition> conditions = ((ExchangeSession.MultiCondition) condition).getConditions();
		 Operator operator = ((ExchangeSession.MultiCondition) condition).getOperator();
		 if (operator == Operator.Or) {
			 for (Condition innerCondition : conditions) {
				 contacts.putAll(galFind(innerCondition, returningAttributes, sizeLimit));
			 }
		 }
		 else if (operator == Operator.And && !conditions.isEmpty()) {
			 Map<String, ExchangeSession.Contact> innerContacts = galFind(conditions.get(0), returningAttributes, sizeLimit);
			 for (ExchangeSession.Contact contact : innerContacts.values()) {
				 if (condition.isMatch(contact)) {
					 contacts.put(contact.getName().toLowerCase(), contact);
				 }
			 }
		 }
	 }
	 else if (condition instanceof AttributeCondition) {
		 String searchAttributeName = ((ExchangeSession.AttributeCondition) condition).getAttributeName();
		 String searchAttribute = GALFIND_CRITERIA_MAP.get(searchAttributeName);
		 if (searchAttribute != null) {
			 String searchValue = ((ExchangeSession.AttributeCondition) condition).getValue();
			 StringBuilder query = new StringBuilder();
			 if (""EM"".equals(searchAttribute)) {
				 int atIndex = searchValue.indexOf('@');
				 if (atIndex >= 0) {
					 searchValue = searchValue.substring(0, atIndex);
				 }
				 int dotIndex = searchValue.indexOf('.');
				 if (dotIndex >= 0) {
					 query.append(""&FN="").append(URIUtil.encodeWithinQuery(searchValue.substring(0, dotIndex)));
					 query.append(""&LN="").append(URIUtil.encodeWithinQuery(searchValue.substring(dotIndex + 1)));
				 }
				 else {
					 query.append(""&FN="").append(URIUtil.encodeWithinQuery(searchValue));
				 }
			 }
			 else {
				 query.append('&').append(searchAttribute).append('=').append(URIUtil.encodeWithinQuery(searchValue));
			 }
			 Map<String, Map<String, String>> results = galFind(query.toString());
			 for (Map<String, String> result : results.values()) {
				 Contact contact = new Contact();
				 contact.setName(result.get(""AN""));
				 contact.put(""imapUid"", result.get(""AN""));
				 buildGalfindContact(contact, result);
				 if (needGalLookup(searchAttributeName, returningAttributes)) {
					 galLookup(contact);
				 }
				 else if (returningAttributes.contains(""apple-serviceslocator"")) {
					 if (contact.get(""cn"") != null && returningAttributes.contains(""sn"")) {
						 contact.put(""sn"", contact.get(""cn""));
						 contact.remove(""cn"");
					 }
				 }
				 if (condition.isMatch(contact)) {
					 contacts.put(contact.getName().toLowerCase(), contact);
				 }
			 }
		 }
	 }
	 return contacts;
 }",0,0,1,0
"public abstract class StatelessLink extends Link<Void>{
	private static final long serialVersionUID = 1L;
	public StatelessLink(String id){
		super(id);
	}
	protected boolean getStatelessHint(){
		return true;
	}
}",0,0,0,0
"public void genCppCode(FileWriter hh, FileWriter cc) throws IOException {
	 String[] ns = getCppNameSpace().split(""::"");
	 for (int i = 0;
	 i < ns.length;
	 i++) {
		 hh.write(""namespace ""+ns[i]+"" {
			\n"");
		 }
		 hh.write(""class ""+getName()+"" : public ::hadoop::Record {
			\n"");
			 hh.write(""private:\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			) {
				 JField jf = (JField) i.next();
				 hh.write(jf.genCppDecl());
			 }
			 hh.write("" mutable std::bitset<""+mFields.size()+""> bs_;
			\n"");
			 hh.write(""public:\n"");
			 hh.write("" virtual void serialize(::hadoop::OArchive& a_, const char* tag) const;
			\n"");
			 hh.write("" virtual void deserialize(::hadoop::IArchive& a_, const char* tag);
			\n"");
			 hh.write("" virtual const ::std::string& type() const;
			\n"");
			 hh.write("" virtual const ::std::string& signature() const;
			\n"");
			 hh.write("" virtual bool validate() const;
			\n"");
			 hh.write("" virtual bool operator<(const ""+getName()+""& peer_) const;
			\n"");
			 hh.write("" virtual bool operator==(const ""+getName()+""& peer_) const;
			\n"");
			 hh.write("" virtual ~""+getName()+""() {
			}
			;
			\n"");
			 int fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 hh.write(jf.genCppGetSet(fIdx));
			 }
		 hh.write(""}
		;
		 for (int i=ns.length-1;
		 i>=0;
		 i--) {
		 hh.write(""}
	 }
	 cc.write(""void ""+getCppFQName()+""::serialize(::hadoop::OArchive& a_, const char* tag) const {
		\n"");
		 cc.write("" if (!validate()) throw new ::hadoop::IOException(\""All fields not set.\"");
		\n"");
		 cc.write("" a_.startRecord(*this,tag);
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 if (jf.getType() instanceof JBuffer) {
				 cc.write("" a_.serialize(""+name+"",""+name+"".length(),\""""+jf.getTag()+""\"");
				\n"");
			 }
			 else {
				 cc.write("" a_.serialize(""+name+"",\""""+jf.getTag()+""\"");
				\n"");
			 }
			 cc.write("" bs_.reset(""+fIdx+"");
			\n"");
		 }
		 cc.write("" a_.endRecord(*this,tag);
		\n"");
		 cc.write("" return;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""void ""+getCppFQName()+""::deserialize(::hadoop::IArchive& a_, const char* tag) {
		\n"");
		 cc.write("" a_.startRecord(*this,tag);
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 if (jf.getType() instanceof JBuffer) {
				 cc.write("" {
					 size_t len=0;
					 a_.deserialize(""+name+"",len,\""""+jf.getTag()+""\"");
				}
				\n"");
			 }
			 else {
				 cc.write("" a_.deserialize(""+name+"",\""""+jf.getTag()+""\"");
				\n"");
			 }
			 cc.write("" bs_.set(""+fIdx+"");
			\n"");
		 }
		 cc.write("" a_.endRecord(*this,tag);
		\n"");
		 cc.write("" return;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::validate() const {
		\n"");
		 cc.write("" if (bs_.size() != bs_.count()) return false;
		\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 JType type = jf.getType();
			 if (type instanceof JRecord) {
				 cc.write("" if (!""+jf.getName()+"".validate()) return false;
				\n"");
			 }
		 }
		 cc.write("" return true;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::operator< (const ""+getCppFQName()+""& peer_) const {
		\n"");
		 cc.write("" return (1\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 cc.write("" && (""+name+"" < peer_.""+name+"")\n"");
		 }
		 cc.write("" );
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::operator== (const ""+getCppFQName()+""& peer_) const {
		\n"");
		 cc.write("" return (1\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 cc.write("" && (""+name+"" == peer_.""+name+"")\n"");
		 }
		 cc.write("" );
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""const ::std::string&""+getCppFQName()+""::type() const {
		\n"");
		 cc.write("" static const ::std::string type_(\""""+mName+""\"");
		\n"");
		 cc.write("" return type_;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""const ::std::string&""+getCppFQName()+""::signature() const {
		\n"");
		 cc.write("" static const ::std::string sig_(\""""+getSignature()+""\"");
		\n"");
		 cc.write("" return sig_;
		\n"");
	 cc.write(""}
	\n"");
 }",0,0,1,0
"private void executeAssumeStatement(Tree statement) {
	 if (!CliMain.isConnected() || !hasKeySpace()) return;
	 String cfName = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
	 CfDef columnFamily = getCfDef(cfName);
	 String assumptionElement = statement.getChild(1).getText().toUpperCase();
	 AbstractType comparator;
	 String defaultType = statement.getChild(2).getText();
	 try {
		 comparator = Function.valueOf(defaultType.toUpperCase()).getValidator();
	 }
	 catch (Exception e) {
		 String functions = Function.getFunctionNames();
		 sessionState.out.println(""Type '"" + defaultType + ""' was not found. Available: "" + functions);
		 return;
	 }
	 if (assumptionElement.equals(""COMPARATOR"")) {
		 columnFamily.setComparator_type(defaultType);
	 }
	 else if (assumptionElement.equals(""SUB_COMPARATOR"")) {
		 columnFamily.setSubcomparator_type(defaultType);
	 }
	 else if (assumptionElement.equals(""VALIDATOR"")) {
		 columnFamily.setDefault_validation_class(defaultType);
	 }
	 else if (assumptionElement.equals(""KEYS"")) {
		 this.cfKeysComparators.put(columnFamily.getName(), comparator);
	 }
	 else {
		 String elements = ""VALIDATOR, COMPARATOR, KEYS, SUB_COMPARATOR."";
		 sessionState.out.println(String.format(""'%s' is invalid. Available: %s"", assumptionElement, elements));
		 return;
	 }
	 sessionState.out.println(String.format(""Assumption for column family '%s' added successfully."", columnFamily.getName()));
 }",0,0,0,0
"protected void transform(XtendConstructor source, JvmGenericType container) {
	JvmConstructor constructor = typesFactory.createJvmConstructor();
	container.getMembers().add(constructor);
	associator.associatePrimary(source, constructor);
	JvmVisibility visibility = source.getVisibility();
	constructor.setSimpleName(container.getSimpleName());
	constructor.setVisibility(visibility);
	for (XtendParameter parameter : source.getParameters()) {
		translateParameter(constructor, parameter);
	}
	copyAndFixTypeParameters(source.getTypeParameters(), constructor);
	for (JvmTypeReference exception : source.getExceptions()) {
		constructor.getExceptions().add(jvmTypesBuilder.cloneWithProxies(exception));
	}
	translateAnnotationsTo(source.getAnnotations(), constructor);
	setBody(constructor, source.getExpression());
	jvmTypesBuilder.copyDocumentationTo(source, constructor);
}",0,0,1,0
"public class JarFileList implements java.io.FileFilter {
	public boolean accept(File file) {
		if(file.getName().toLowerCase().endsWith("".jar""))return true;
		elsereturn false;
	}
}",0,0,0,0
"public class FsShellWritingMessageHandler extendsAbstractReplyProducingMessageHandler {
	private volatile FileExistsMode fileExistsMode = FileExistsMode.REPLACE;
	private static final Log log = LogFactory.getLog(FsShellWritingMessageHandler.class);
	private volatile FileNameGenerator fileNameGenerator = new DefaultFileNameGenerator();
	private final StandardEvaluationContext evaluationContext = new StandardEvaluationContext();
	private final Expression destinationDirectoryExpression;
	private volatile boolean autoCreateDirectory = true;
	private volatile boolean deleteSourceFiles;
	private volatile boolean expectReply = false;
	private Configuration configuration;
	private FsShell fsShell;
	private volatile boolean generateDestinationDirectory = true;
	private volatile String destinationDirectoryFormat = ""%1$tY/%1$tm/%1$td/%1$tH/%1$tM/%1$tS"";
	public FsShellWritingMessageHandler(String destinationDirectory,Configuration configuration) {
		Assert.notNull(destinationDirectory,""Destination directory must not be null."");
		this.destinationDirectoryExpression = new LiteralExpression(destinationDirectory);
		createFsShell(configuration);
	}
	public FsShellWritingMessageHandler(Expression destinationDirectoryExpression) {
		Assert.notNull(destinationDirectoryExpression,""Destination directory expression must not be null."");
		this.destinationDirectoryExpression = destinationDirectoryExpression;
		createFsShell(configuration);
	}
	private void createFsShell(Configuration configuration) {
		Assert.notNull(configuration, ""Hadoop Configuration must not be null."");
		this.configuration = configuration;
		fsShell = new FsShell(configuration);
	}
	public void setFileNameGenerator(FileNameGenerator fileNameGenerator) {
		Assert.notNull(fileNameGenerator, ""FileNameGenerator must not be null"");
		this.fileNameGenerator = fileNameGenerator;
	}
	public void setDeleteSourceFiles(boolean deleteSourceFiles) {
		this.deleteSourceFiles = deleteSourceFiles;
	}
	public void setFileExistsMode(FileExistsMode fileExistsMode) {
		Assert.notNull(fileExistsMode, ""'fileExistsMode' must not be null."");
		this.fileExistsMode = fileExistsMode;
	}
	public void setExpectReply(boolean expectReply) {
		this.expectReply = expectReply;
	}
	public void setGenerateDestinationDirectory(boolean generateDestinationDirectory) {
		this.generateDestinationDirectory = generateDestinationDirectory;
	}
	public void setDestinationDirectoryFormat(String destinationDirectoryFormat) {
		this.destinationDirectoryFormat = destinationDirectoryFormat;
	}
	public final void onInit() {
		Assert.notNull(configuration, ""Hadoop configuration must not be null"");
		fsShell = new FsShell(configuration);
		this.evaluationContext.addPropertyAccessor(new MapAccessor());
		final BeanFactory beanFactory = this.getBeanFactory();
		if (beanFactory != null) {
			this.evaluationContext.setBeanResolver(new BeanFactoryResolver(beanFactory));
		}
		if (this.destinationDirectoryExpression instanceof LiteralExpression) {
			final Path directory = new Path(this.destinationDirectoryExpression.getValue(this.evaluationContext, null, String.class));
			validateDestinationDirectory(directory, this.autoCreateDirectory);
		}
	}
	private void validateDestinationDirectory(Path destinationDirectory,boolean autoCreateDirectory) {
	}
	protected Object handleRequestMessage(Message<?> requestMessage) {
		Assert.notNull(requestMessage, ""message must not be null"");
		Object payload = requestMessage.getPayload();
		Assert.notNull(payload, ""message payload must not be null"");
		String generatedFileName = this.fileNameGenerator.generateFileName(requestMessage);
		File originalFileFromHeader = this.retrieveOriginalFileFromHeader(requestMessage);
		final Path destinationDirectoryToUse = evaluateDestinationDirectoryExpression(requestMessage);
		Path resultFile = new Path(destinationDirectoryToUse, generatedFileName);
		boolean resultFileExists = fsShell.test(resultFile.toUri().toString());
		if (FileExistsMode.FAIL.equals(this.fileExistsMode) && resultFileExists) {
			throw new MessageHandlingException(requestMessage,""The destination file already exists at '""+ resultFile.toString() + ""'."");
		}
		final boolean ignore = FileExistsMode.IGNORE.equals(this.fileExistsMode) && resultFileExists;
		if (!ignore) {
			try {
				if (payload instanceof File) {
					resultFile = this.handleFileMessage((File) payload,resultFile, resultFileExists);
				}
				 else {
					throw new IllegalArgumentException(""unsupported Message payload type [""+ payload.getClass().getName() + ""]"");
				}
			}
			 catch (Exception e) {
				throw new MessageHandlingException(requestMessage,""failed to write Message payload to file"", e);
			}
		}
		if (!this.expectReply) {
			return null;
		}
		if (resultFile != null) {
			if (originalFileFromHeader == null && payload instanceof File) {
				return MessageBuilder.withPayload(resultFile).setHeader(FileHeaders.ORIGINAL_FILE, payload);
			}
		}
		return resultFile;
	}
	private File retrieveOriginalFileFromHeader(Message<?> message) {
		Object value = message.getHeaders().get(FileHeaders.ORIGINAL_FILE);
		if (value instanceof File) {
			return (File) value;
		}
		if (value instanceof String) {
			return new File((String) value);
		}
		return null;
	}
	private Path handleFileMessage(final File sourceFile, Path resultFile,boolean resultFileExists) {
		if (FileExistsMode.REPLACE.equals(this.fileExistsMode)&& resultFileExists) {
			fsShell.rm(resultFile.toString());
		}
		log.info(""sourceFile = "" + sourceFile.getAbsolutePath());
		log.info(""resultFile = "" + resultFile.toString());
		fsShell.copyFromLocal(sourceFile.getAbsolutePath(),resultFile.toString());
		cleanUpAfterCopy(sourceFile);
		return resultFile;
	}
	private void cleanUpAfterCopy(File originalFile) {
		if (this.deleteSourceFiles && originalFile != null) {
			originalFile.delete();
		}
	}
	private Path evaluateDestinationDirectoryExpression(Message<?> message) {
		final Path destinationDirectory;
		final Object destinationDirectoryToUse = this.destinationDirectoryExpression.getValue(this.evaluationContext, message);
		if (destinationDirectoryToUse == null) {
			throw new IllegalStateException(String.format(""The provided ""+ ""destinationDirectoryExpression (%s) must not resolve to null."",this.destinationDirectoryExpression.getExpressionString()));
		}
		 else if (destinationDirectoryToUse instanceof String) {
			String destinationDirectoryPath = (String) destinationDirectoryToUse;
			Assert.hasText(destinationDirectoryPath,String.format(""Unable to resolve destination directory name for the provided Expression '%s'."",this.destinationDirectoryExpression.getExpressionString()));
			if (this.generateDestinationDirectory) {
				destinationDirectoryPath = destinationDirectoryPath + ""/"" + PathUtils.format(this.destinationDirectoryFormat);
			}
			destinationDirectory = new Path(destinationDirectoryPath);
		}
		 else if (destinationDirectoryToUse instanceof Path) {
			destinationDirectory = (Path) destinationDirectoryToUse;
		}
		 else {
			throw new IllegalStateException(String.format(""The provided ""+ ""destinationDirectoryExpression (%s) must be of type ""+ ""java.io.File or be a String."",this.destinationDirectoryExpression.getExpressionString()));
		}
		validateDestinationDirectory(destinationDirectory,this.autoCreateDirectory);
		return destinationDirectory;
	}
}",1,0,0,0
"public class ErrorDataException extends Exception {
	 private static final long serialVersionUID = -9052741930614009382L;
	 private RpcDataPackage rpcDataPackage;
	 private int errorCode;
	 public int getErrorCode() {
		 return errorCode;
	 }
	 public void setErrorCode(int errorCode) {
		 this.errorCode = errorCode;
	 }
	 public RpcDataPackage getRpcDataPackage() {
		 return rpcDataPackage;
	 }
	 public void setRpcDataPackage(RpcDataPackage rpcDataPackage) {
		 this.rpcDataPackage = rpcDataPackage;
	 }
	 public ErrorDataException() {
		 super();
	 }
	 public ErrorDataException(String message, Throwable cause) {
		 super(message, cause);
	 }
	 public ErrorDataException(String message, Throwable cause, int errorCode) {
		 super(message, cause);
		 this.errorCode = errorCode;
	 }
	 public ErrorDataException(String message) {
		 super(message);
	 }
	 public ErrorDataException(String message, int errorCode) {
		 super(message);
		 this.errorCode = errorCode;
	 }
	 public ErrorDataException(Throwable cause) {
		 super(cause);
	 }
	 public ErrorDataException(Throwable cause, int errorCode) {
		 super(cause);
		 this.errorCode = errorCode;
	 }
}",0,1,0,0
"public class AddParentsCommand {
	public static final String ACTION_SEARCH = ""Search"";
	public static final String ACTION_CANCEL = ""Cancel"";
	public static final String ACTION_ADD_PARENTS = ""Add"";
	private String search = null;
	private int pageNumber = 0;
	private String selectedPageSize;
	private String actionCmd = null;
	private long[] parentOids = null;
	private int parentIndex = 0;
	private int selectedCount = 0;
	public AddParentsCommand(){
		parentOids = new long[0];
	}
	public String getActionCmd() {
		return actionCmd;
	}
	public void setActionCmd(String action) {
		this.actionCmd = action;
	}
	public int getPageNumber() {
		return pageNumber;
	}
	public void setPageNumber(int pageNumber) {
		this.pageNumber = pageNumber;
	}
	public String getSelectedPageSize() {
		return selectedPageSize;
	}
	public void setSelectedPageSize(String selectedPageSize) {
		this.selectedPageSize = selectedPageSize;
	}
	public String getSearch() {
		return search;
	}
	public void setSearch(String search) {
		this.search = search;
	}
	public long[] getParentOids() {
		return parentOids;
	}
	public void setParentOids(long[] parentOids) {
		this.parentOids = parentOids;
	}
	public int getParentIndex() {
		return parentIndex;
	}
	public void setParentIndex(int parentIndex) {
		this.parentIndex = parentIndex;
	}
	public int getSelectedCount() {
		return selectedCount;
	}
	public void setSelectedCount(int selectedCount) {
		this.selectedCount = selectedCount;
	}
}",0,1,0,0
"public class JEditBuffer{
	public static final String LINESEP = ""lineSeparator"";
	public static final String ENCODING = ""encoding"";
	public JEditBuffer(Map props){
		bufferListeners = new Vector<Listener>();
		lock = new ReentrantReadWriteLock();
		contentMgr = new ContentManager();
		lineMgr = new LineManager();
		positionMgr = new PositionManager(this);
		undoMgr = new UndoManager(this);
		integerArray = new IntegerArray();
		propertyLock = new Object();
		properties = new HashMap<Object, PropValue>();
		Set<Map.Entry> set = props.entrySet();
		for (Map.Entry entry : set){
			properties.put(entry.getKey(),new PropValue(entry.getValue(),false));
		}
		 if(getProperty(ENCODING) == null)properties.put(ENCODING,new PropValue(System.getProperty(""file.encoding""),false));
		if(getProperty(LINESEP) == null)properties.put(LINESEP,new PropValue(System.getProperty(""line.separator""),false));
	}
	public JEditBuffer(){
		bufferListeners = new Vector<Listener>();
		lock = new ReentrantReadWriteLock();
		contentMgr = new ContentManager();
		lineMgr = new LineManager();
		positionMgr = new PositionManager(this);
		undoMgr = new UndoManager(this);
		integerArray = new IntegerArray();
		propertyLock = new Object();
		properties = new HashMap<Object, PropValue>();
		properties.put(""wrap"",new PropValue(""none"",false));
		properties.put(""folding"",new PropValue(""none"",false));
		tokenMarker = new TokenMarker();
		tokenMarker.addRuleSet(new ParserRuleSet(""text"",""MAIN""));
		setTokenMarker(tokenMarker);
		loadText(null,null);
		if(getProperty(ENCODING) == null)properties.put(ENCODING,new PropValue(System.getProperty(""file.encoding""),false));
		if(getProperty(LINESEP) == null)properties.put(LINESEP,new PropValue(System.getProperty(""line.separator""),false));
		setFoldHandler(new DummyFoldHandler());
	}
	 public boolean isDirty(){
		return dirty;
	}
	 public boolean isLoading(){
		return loading;
	}
	 public void setLoading(boolean loading){
		this.loading = loading;
	}
	 public boolean isPerformingIO(){
		return isLoading() || io;
	}
	 public void setPerformingIO(boolean io){
		this.io = io;
	}
	 public boolean isEditable(){
		return !(isReadOnly() || isPerformingIO());
	}
	 public boolean isReadOnly(){
		return readOnly || readOnlyOverride;
	}
	 public void setReadOnly(boolean readOnly){
		readOnlyOverride = readOnly;
	}
	 public void setDirty(boolean d){
		boolean editable = isEditable();
		if(d){
			if(editable)dirty = true;
		}
		else{
			dirty = false;
			if(!isUndoInProgress()){
				undoMgr.resetClearDirty();
			}
		}
	}
	 public void readLock(){
		lock.readLock().lock();
	}
	 public void readUnlock(){
		lock.readLock().unlock();
	}
	 public void writeLock(){
		lock.writeLock().lock();
	}
	 public void writeUnlock(){
		lock.writeLock().unlock();
	}
	 public int getLength(){
		return contentMgr.getLength();
	}
	 public int getLineCount(){
		return lineMgr.getLineCount();
	}
	 public int getLineOfOffset(int offset){
		try{
			readLock();
			if(offset < 0 || offset > getLength())throw new ArrayIndexOutOfBoundsException(offset);
			return lineMgr.getLineOfOffset(offset);
		}
		finally{
			readUnlock();
		}
	}
	 public int getLineStartOffset(int line){
		try{
			readLock();
			if(line < 0 || line >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(line);
			else if(line == 0)return 0;
			return lineMgr.getLineEndOffset(line - 1);
		}
		finally{
			readUnlock();
		}
	}
	 public int getLineEndOffset(int line){
		try{
			readLock();
			if(line < 0 || line >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(line);
			return lineMgr.getLineEndOffset(line);
		}
		finally{
			readUnlock();
		}
	}
	 public int getLineLength(int line){
		try{
			readLock();
			return getLineEndOffset(line)- getLineStartOffset(line) - 1;
		}
		finally{
			readUnlock();
		}
	}
	 public int getPriorNonEmptyLine(int lineIndex){
		int returnValue = -1;
		if (!mode.getIgnoreWhitespace()){
			return lineIndex - 1;
		}
		for(int i = lineIndex - 1;
		 i >= 0;
		 i--){
			Segment seg = new Segment();
			getLineText(i,seg);
			if(seg.count != 0)returnValue = i;
			for(int j = 0;
			 j < seg.count;
			 j++){
				char ch = seg.array[seg.offset + j];
				if(!Character.isWhitespace(ch))return i;
			}
		}
		return returnValue;
	}
	 public String getLineText(int line){
		if(line < 0 || line >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(line);
		try{
			readLock();
			int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);
			int end = lineMgr.getLineEndOffset(line);
			return getText(start,end - start - 1);
		}
		finally{
			readUnlock();
		}
	}
	 public void getLineText(int line, Segment segment){
		if(line < 0 || line >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(line);
		try{
			readLock();
			int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);
			int end = lineMgr.getLineEndOffset(line);
			getText(start,end - start - 1,segment);
		}
		finally{
			readUnlock();
		}
	}
	 public CharSequence getLineSegment(int line){
		if(line < 0 || line >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(line);
		try{
			readLock();
			int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);
			int end = lineMgr.getLineEndOffset(line);
			return getSegment(start,end - start - 1);
		}
		finally{
			readUnlock();
		}
	}
	 public String getText(int start, int length){
		try{
			readLock();
			if(start < 0 || length < 0|| start + length > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(start + "":"" + length);
			return contentMgr.getText(start,length);
		}
		finally{
			readUnlock();
		}
	}
	public void getText(int start, int length, Segment seg){
		try{
			readLock();
			if(start < 0 || length < 0|| start + length > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(start + "":"" + length);
			contentMgr.getText(start,length,seg);
		}
		finally{
			readUnlock();
		}
	}
	 public CharSequence getSegment(int start, int length){
		try{
			readLock();
			if(start < 0 || length < 0|| start + length > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(start + "":"" + length);
			return contentMgr.getSegment(start,length);
		}
		finally{
			readUnlock();
		}
	}
	 public void insert(int offset, String str){
		if(str == null)return;
		int len = str.length();
		if(len == 0)return;
		if(isReadOnly())throw new RuntimeException(""buffer read-only"");
		try{
			writeLock();
			if(offset < 0 || offset > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(offset);
			contentMgr.insert(offset,str);
			integerArray.clear();
			for(int i = 0;
			 i < len;
			 i++){
				if(str.charAt(i) == '\n')integerArray.add(i + 1);
			}
			if(!undoInProgress){
				undoMgr.contentInserted(offset,len,str,!dirty);
			}
			contentInserted(offset,len,integerArray);
		}
		finally{
			writeUnlock();
		}
	}
	public void insert(int offset, Segment seg){
		if(seg.count == 0)return;
		if(isReadOnly())throw new RuntimeException(""buffer read-only"");
		try{
			writeLock();
			if(offset < 0 || offset > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(offset);
			contentMgr.insert(offset,seg);
			integerArray.clear();
			for(int i = 0;
			 i < seg.count;
			 i++){
				if(seg.array[seg.offset + i] == '\n')integerArray.add(i + 1);
			}
			if(!undoInProgress){
				undoMgr.contentInserted(offset,seg.count,seg.toString(),!dirty);
			}
			contentInserted(offset,seg.count,integerArray);
		}
		finally{
			writeUnlock();
		}
	}
	 public void remove(int offset, int length){
		if(length == 0)return;
		if(isReadOnly())throw new RuntimeException(""buffer read-only"");
		try{
			transaction = true;
			writeLock();
			if(offset < 0 || length < 0|| offset + length > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(offset + "":"" + length);
			int startLine = lineMgr.getLineOfOffset(offset);
			int endLine = lineMgr.getLineOfOffset(offset + length);
			int numLines = endLine - startLine;
			if(!undoInProgress && !loading){
				undoMgr.contentRemoved(offset,length,getText(offset,length),!dirty);
			}
			firePreContentRemoved(startLine,offset,numLines,length);
			contentMgr.remove(offset,length);
			lineMgr.contentRemoved(startLine,offset,numLines,length);
			positionMgr.contentRemoved(offset,length);
			setDirty(true);
			fireContentRemoved(startLine,offset,numLines,length);
			if(!undoInProgress && !insideCompoundEdit())fireTransactionComplete();
		}
		finally{
			transaction = false;
			writeUnlock();
		}
	}
	 public void removeTrailingWhiteSpace(int[] lines){
		try{
			beginCompoundEdit();
			for(int i = 0;
			 i < lines.length;
			 i++){
				int pos, lineStart, lineEnd, tail;
				Segment seg = new Segment();
				getLineText(lines[i],seg);
				if (seg.count == 0) continue;
				lineStart = seg.offset;
				lineEnd = seg.offset + seg.count - 1;
				for (pos = lineEnd;
				 pos >= lineStart;
				 pos--){
					if (!Character.isWhitespace(seg.array[pos]))break;
				}
				tail = lineEnd - pos;
				if (tail == 0) continue;
				remove(getLineEndOffset(lines[i]) - 1 - tail,tail);
			}
		}
		finally{
			endCompoundEdit();
		}
	}
	 public void shiftIndentLeft(int[] lines){
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");
		try{
			beginCompoundEdit();
			for(int i = 0;
			 i < lines.length;
			 i++){
				int lineStart = getLineStartOffset(lines[i]);
				CharSequence line = getLineSegment(lines[i]);
				int whiteSpace = StandardUtilities.getLeadingWhiteSpace(line);
				if(whiteSpace == 0)continue;
				int whiteSpaceWidth = Math.max(0,StandardUtilities.getLeadingWhiteSpaceWidth(line,tabSize)- indentSize);
				insert(lineStart + whiteSpace,StandardUtilities.createWhiteSpace(whiteSpaceWidth,noTabs ? 0 : tabSize));
				remove(lineStart,whiteSpace);
			}
		}
		finally{
			endCompoundEdit();
		}
	}
	 public void shiftIndentRight(int[] lines){
		try{
			beginCompoundEdit();
			int tabSize = getTabSize();
			int indentSize = getIndentSize();
			boolean noTabs = getBooleanProperty(""noTabs"");
			for(int i = 0;
			 i < lines.length;
			 i++){
				int lineStart = getLineStartOffset(lines[i]);
				CharSequence line = getLineSegment(lines[i]);
				int whiteSpace = StandardUtilities.getLeadingWhiteSpace(line);
				int whiteSpaceWidth = StandardUtilities.getLeadingWhiteSpaceWidth(line,tabSize) + indentSize;
				insert(lineStart + whiteSpace,StandardUtilities.createWhiteSpace(whiteSpaceWidth,noTabs ? 0 : tabSize));
				remove(lineStart,whiteSpace);
			}
		}
		finally{
			endCompoundEdit();
		}
	}
	 public void indentLines(int start, int end){
		try{
			beginCompoundEdit();
			for(int i = start;
			 i <= end;
			 i++)indentLine(i,true);
		}
		finally{
			endCompoundEdit();
		}
	}
	public void indentLines(int[] lines){
		try{
			beginCompoundEdit();
			for(int i = 0;
			 i < lines.length;
			 i++)indentLine(lines[i],true);
		}
		finally{
			endCompoundEdit();
		}
	}
	 public boolean indentLine(int lineIndex, boolean canIncreaseIndent,boolean canDecreaseIndent){
		return indentLine(lineIndex,canDecreaseIndent);
	}
	public boolean indentLine(int lineIndex, boolean canDecreaseIndent){
		int[] whitespaceChars = new int[1];
		int currentIndent = getCurrentIndentForLine(lineIndex,whitespaceChars);
		int prevLineIndex = getPriorNonEmptyLine(lineIndex);
		int prevLineIndent = (prevLineIndex == -1) ? 0 :StandardUtilities.getLeadingWhiteSpaceWidth(getLineSegment(prevLineIndex), getTabSize());
		int idealIndent = getIdealIndentForLine(lineIndex, prevLineIndex,prevLineIndent);
		if (idealIndent == -1 || idealIndent == currentIndent ||(!canDecreaseIndent && idealIndent < currentIndent))return false;
		try{
			beginCompoundEdit();
			int start = getLineStartOffset(lineIndex);
			remove(start,whitespaceChars[0]);
			String prevIndentString = (prevLineIndex >= 0) ?StandardUtilities.getIndentString(getLineText(prevLineIndex)) : null;
			String indentString;
			if (prevIndentString == null){
				indentString = StandardUtilities.createWhiteSpace(idealIndent,getBooleanProperty(""noTabs"") ? 0 : getTabSize());
			}
			else if (idealIndent == prevLineIndent)indentString = prevIndentString;
			else if (idealIndent < prevLineIndent)indentString = StandardUtilities.truncateWhiteSpace(idealIndent, getTabSize(), prevIndentString);
			elseindentString = prevIndentString +StandardUtilities.createWhiteSpace(idealIndent - prevLineIndent,getBooleanProperty(""noTabs"") ? 0 : getTabSize(),prevLineIndent);
			insert(start, indentString);
		}
		finally{
			endCompoundEdit();
		}
		return true;
	}
	 public int getCurrentIndentForLine(int lineIndex, int[] whitespaceChars){
		Segment seg = new Segment();
		getLineText(lineIndex,seg);
		int tabSize = getTabSize();
		int currentIndent = 0;
		loop:for(int i = 0;
		 i < seg.count;
		 i++){
			char c = seg.array[seg.offset + i];
			switch(c){
				case ' ':currentIndent++;
				if(whitespaceChars != null)whitespaceChars[0]++;
				break;
				case '\t':currentIndent += tabSize - (currentIndent% tabSize);
				if(whitespaceChars != null)whitespaceChars[0]++;
				break;
				default:break loop;
			}
		}
		return currentIndent;
	}
	 public int getIdealIndentForLine(int lineIndex){
		int prevLineIndex = getPriorNonEmptyLine(lineIndex);
		int oldIndent = prevLineIndex == -1 ? 0 :StandardUtilities.getLeadingWhiteSpaceWidth(getLineSegment(prevLineIndex),getTabSize());
		return getIdealIndentForLine(lineIndex, prevLineIndex,oldIndent);
	}
	 private int getIdealIndentForLine(int lineIndex, int prevLineIndex,int oldIndent){
		int prevPrevLineIndex = prevLineIndex < 0 ? -1: getPriorNonEmptyLine(prevLineIndex);
		int newIndent = oldIndent;
		List<IndentRule> indentRules = getIndentRules(lineIndex);
		List<IndentAction> actions = new LinkedList<IndentAction>();
		for (int i = 0;
		i<indentRules.size();
		i++){
			IndentRule rule = indentRules.get(i);
			rule.apply(this,lineIndex,prevLineIndex,prevPrevLineIndex,actions);
		}
		for (IndentAction action : actions){
			newIndent = action.calculateIndent(this, lineIndex,oldIndent, newIndent);
			if (!action.keepChecking())break;
		}
		if (newIndent < 0)newIndent = 0;
		return newIndent;
	}
	 public int getVirtualWidth(int line, int column){
		try{
			readLock();
			int start = getLineStartOffset(line);
			Segment seg = new Segment();
			getText(start,column,seg);
			return StandardUtilities.getVirtualWidth(seg,getTabSize());
		}
		finally{
			readUnlock();
		}
	}
	 public int getOffsetOfVirtualColumn(int line, int column,int[] totalVirtualWidth){
		try{
			readLock();
			Segment seg = new Segment();
			getLineText(line,seg);
			return StandardUtilities.getOffsetOfVirtualColumn(seg,getTabSize(),column,totalVirtualWidth);
		}
		finally{
			readUnlock();
		}
	}
	 public void insertAtColumn(int line, int col, String str){
		try{
			writeLock();
			int[] total = new int[1];
			int offset = getOffsetOfVirtualColumn(line,col,total);
			if(offset == -1){
				offset = getLineEndOffset(line) - 1;
				str = StandardUtilities.createWhiteSpace(col - total[0],0) + str;
			}
			elseoffset += getLineStartOffset(line);
			insert(offset,str);
		}
		finally{
			writeUnlock();
		}
	}
	 public int insertIndented(int offset, String text){
		try{
			beginCompoundEdit();
			int firstLine = getLineOfOffset(offset);
			CharSequence lineText = getLineSegment(firstLine);
			int leadingIndent= StandardUtilities.getLeadingWhiteSpaceWidth(lineText,getTabSize());
			String whiteSpace = StandardUtilities.createWhiteSpace(leadingIndent,getBooleanProperty(""noTabs"")? 0 : getTabSize());
			insert(offset,text);
			int lastLine = getLineOfOffset(offset + text.length());
			for(int i = firstLine + 1;
			 i <= lastLine;
			 i++){
				insert(getLineStartOffset(i),whiteSpace);
			}
			return whiteSpace.length();
		}
		finally{
			endCompoundEdit();
		}
	}
	 public boolean isElectricKey(char ch){
		return mode.isElectricKey(ch);
	}
	public boolean isElectricKey(char ch, int line){
		TokenMarker.LineContext ctx = lineMgr.getLineContext(line);
		Mode mode = ModeProvider.instance.getMode(ctx.rules.getModeName());
		if (mode == null)return false;
		return mode.isElectricKey(ch);
	}
	 public void markTokens(int lineIndex, TokenHandler tokenHandler){
		Segment seg = new Segment();
		if(lineIndex < 0 || lineIndex >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(lineIndex);
		int firstInvalidLineContext = lineMgr.getFirstInvalidLineContext();
		int start;
		if(textMode || firstInvalidLineContext == -1){
			start = lineIndex;
		}
		else{
			start = Math.min(firstInvalidLineContext,lineIndex);
		}
		if(Debug.TOKEN_MARKER_DEBUG)Log.log(Log.DEBUG,this,""tokenize from "" + start + "" to "" + lineIndex);
		TokenMarker.LineContext oldContext = null;
		TokenMarker.LineContext context = null;
		for(int i = start;
		 i <= lineIndex;
		 i++){
			getLineText(i,seg);
			oldContext = lineMgr.getLineContext(i);
			TokenMarker.LineContext prevContext = ((i == 0 || textMode) ? null: lineMgr.getLineContext(i - 1));
			context = tokenMarker.markTokens(prevContext,(i == lineIndex ? tokenHandler: DummyTokenHandler.INSTANCE), seg);
			lineMgr.setLineContext(i,context);
		}
		int lineCount = lineMgr.getLineCount();
		if(lineCount - 1 == lineIndex)lineMgr.setFirstInvalidLineContext(-1);
		else if(oldContext != context)lineMgr.setFirstInvalidLineContext(lineIndex + 1);
		else if(firstInvalidLineContext == -1);
		else{
			lineMgr.setFirstInvalidLineContext(Math.max(firstInvalidLineContext,lineIndex + 1));
		}
	}
	 public TokenMarker getTokenMarker(){
		return tokenMarker;
	}
	 public void setTokenMarker(TokenMarker tokenMarker){
		TokenMarker oldTokenMarker = this.tokenMarker;
		this.tokenMarker = tokenMarker;
		if(oldTokenMarker != null && tokenMarker != oldTokenMarker){
			lineMgr.setFirstInvalidLineContext(0);
		}
	}
	 public Position createPosition(int offset){
		try{
			readLock();
			if(offset < 0 || offset > contentMgr.getLength())throw new ArrayIndexOutOfBoundsException(offset);
			return positionMgr.createPosition(offset);
		}
		finally{
			readUnlock();
		}
	}
	 public void propertiesChanged(){
		String folding = getStringProperty(""folding"");
		FoldHandler handler = FoldHandler.getFoldHandler(folding);
		if(handler != null){
			setFoldHandler(handler);
		}
		else{
			if (folding != null)Log.log(Log.WARNING, this, ""invalid 'folding' property: "" + folding);
			setFoldHandler(new DummyFoldHandler());
		}
	}
	 public int getTabSize(){
		int tabSize = getIntegerProperty(""tabSize"",8);
		if(tabSize <= 0)return 8;
		elsereturn tabSize;
	}
	 public int getIndentSize(){
		int indentSize = getIntegerProperty(""indentSize"",8);
		if(indentSize <= 0)return 8;
		elsereturn indentSize;
	}
	 public Object getProperty(Object name){
		synchronized(propertyLock){
			PropValue o = properties.get(name);
			if(o != null)return o.value;
			if(!(name instanceof String))return null;
			Object retVal = getDefaultProperty((String)name);
			if(retVal == null)return null;
			else{
				properties.put(name,new PropValue(retVal,true));
				return retVal;
			}
		}
	}
	 public Object getDefaultProperty(String key){
		return null;
	}
	 public void setProperty(String name, Object value){
		if(value == null)properties.remove(name);
		else{
			PropValue test = properties.get(name);
			if(test == null)properties.put(name,new PropValue(value,false));
			else if(test.value.equals(value)){
			}
			else{
				test.value = value;
				test.defaultValue = false;
			}
		}
	}
	 public void setDefaultProperty(String name, Object value){
		properties.put(name,new PropValue(value,true));
	}
	 public void unsetProperty(String name){
		properties.remove(name);
	}
	 public void resetCachedProperties(){
		Iterator<PropValue> iter = properties.values().iterator();
		while(iter.hasNext()){
			PropValue value = iter.next();
			if(value.defaultValue)iter.remove();
		}
	}
	 public String getStringProperty(String name){
		Object obj = getProperty(name);
		if(obj != null)return obj.toString();
		elsereturn null;
	}
	 public void setStringProperty(String name, String value){
		setProperty(name,value);
	}
	 public boolean getBooleanProperty(String name){
		return getBooleanProperty(name, false);
	}
	public boolean getBooleanProperty(String name, boolean def){
		Object obj = getProperty(name);
		return StandardUtilities.getBoolean(obj, def);
	}
	 public void setBooleanProperty(String name, boolean value){
		setProperty(name,value ? Boolean.TRUE : Boolean.FALSE);
	}
	 public int getIntegerProperty(String name, int defaultValue){
		boolean defaultValueFlag;
		Object obj;
		PropValue value = properties.get(name);
		if(value != null){
			obj = value.value;
			defaultValueFlag = value.defaultValue;
		}
		else{
			obj = getProperty(name);
			defaultValueFlag = true;
		}
		if(obj == null)return defaultValue;
		else if(obj instanceof Number)return ((Number)obj).intValue();
		else{
			try{
				int returnValue = Integer.parseInt(obj.toString().trim());
				properties.put(name,new PropValue(returnValue,defaultValueFlag));
				return returnValue;
			}
			catch(Exception e){
				return defaultValue;
			}
		}
	}
	 public void setIntegerProperty(String name, int value){
		setProperty(name,value);
	}
	 public Pattern getPatternProperty(String name, int flags){
		synchronized(propertyLock){
			boolean defaultValueFlag;
			Object obj;
			PropValue value = properties.get(name);
			if(value != null){
				obj = value.value;
				defaultValueFlag = value.defaultValue;
			}
			else{
				obj = getProperty(name);
				defaultValueFlag = true;
			}
			if(obj == null)return null;
			else if (obj instanceof Pattern)return (Pattern) obj;
			else{
				Pattern re = Pattern.compile(obj.toString(),flags);
				properties.put(name,new PropValue(re,defaultValueFlag));
				return re;
			}
		}
	}
	 public ParserRuleSet getRuleSetAtOffset(int offset){
		int line = getLineOfOffset(offset);
		offset -= getLineStartOffset(line);
		if(offset != 0)offset--;
		DefaultTokenHandler tokens = new DefaultTokenHandler();
		markTokens(line,tokens);
		Token token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);
		return token.rules;
	}
	 public KeywordMap getKeywordMapAtOffset(int offset){
		return getRuleSetAtOffset(offset).getKeywords();
	}
	 public String getContextSensitiveProperty(int offset, String name){
		ParserRuleSet rules = getRuleSetAtOffset(offset);
		Object value = null;
		Map<String, String> rulesetProps = rules.getProperties();
		if(rulesetProps != null)value = rulesetProps.get(name);
		if(value == null)return null;
		elsereturn String.valueOf(value);
	}
	 public Mode getMode(){
		return mode;
	}
	 public void setMode(String mode){
		setMode(ModeProvider.instance.getMode(mode));
	}
	public void setMode(Mode mode){
		if(mode == null)throw new NullPointerException(""Mode must be non-null"");
		this.mode = mode;
		textMode = ""text"".equals(mode.getName());
		setTokenMarker(mode.getTokenMarker());
		resetCachedProperties();
		propertiesChanged();
	}
	 public boolean isFoldStart(int line){
		return line != getLineCount() - 1&& getFoldLevel(line) < getFoldLevel(line + 1);
	}
	 public boolean isFoldEnd(int line){
		return line != getLineCount() - 1&& getFoldLevel(line) > getFoldLevel(line + 1);
	}
	 public void invalidateCachedFoldLevels(){
		lineMgr.setFirstInvalidFoldLevel(0);
		fireFoldLevelChanged(0,getLineCount());
	}
	 public int getFoldLevel(int line){
		if(line < 0 || line >= lineMgr.getLineCount())throw new ArrayIndexOutOfBoundsException(line);
		if(foldHandler instanceof DummyFoldHandler)return 0;
		int firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel();
		if(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel){
			return lineMgr.getFoldLevel(line);
		}
		else{
			if(Debug.FOLD_DEBUG)Log.log(Log.DEBUG,this,""Invalid fold levels from "" + firstInvalidFoldLevel + "" to "" + line);
			int newFoldLevel = 0;
			boolean changed = false;
			int firstUpdatedFoldLevel = firstInvalidFoldLevel;
			for(int i = firstInvalidFoldLevel;
			 i <= line;
			 i++){
				Segment seg = new Segment();
				newFoldLevel = foldHandler.getFoldLevel(this,i,seg);
				if(newFoldLevel != lineMgr.getFoldLevel(i)){
					if(Debug.FOLD_DEBUG)Log.log(Log.DEBUG,this,i + "" fold level changed"");
					changed = true;
					if (i == firstInvalidFoldLevel){
						List<Integer> precedingFoldLevels =foldHandler.getPrecedingFoldLevels(this,i,seg,newFoldLevel);
						if (precedingFoldLevels != null){
							int j = i;
							for (Integer foldLevel: precedingFoldLevels){
								j--;
								lineMgr.setFoldLevel(j,foldLevel.intValue());
							}
							if (j < firstUpdatedFoldLevel)firstUpdatedFoldLevel = j;
						}
					}
				}
				lineMgr.setFoldLevel(i,newFoldLevel);
			}
			if(line == lineMgr.getLineCount() - 1)lineMgr.setFirstInvalidFoldLevel(-1);
			elselineMgr.setFirstInvalidFoldLevel(line + 1);
			if(changed){
				if(Debug.FOLD_DEBUG)Log.log(Log.DEBUG,this,""fold level changed: "" + firstUpdatedFoldLevel + ',' + line);
				fireFoldLevelChanged(firstUpdatedFoldLevel,line);
			}
			return newFoldLevel;
		}
	}
	 public int[] getFoldAtLine(int line){
		int start, end;
		if(isFoldStart(line)){
			start = line;
			int foldLevel = getFoldLevel(line);
			line++;
			while(getFoldLevel(line) > foldLevel){
				line++;
				if(line == getLineCount())break;
			}
			end = line - 1;
		}
		else{
			start = line;
			int foldLevel = getFoldLevel(line);
			while(getFoldLevel(start) >= foldLevel){
				if(start == 0)break;
				elsestart--;
			}
			end = line;
			while(getFoldLevel(end) >= foldLevel){
				end++;
				if(end == getLineCount())break;
			}
			end--;
		}
		while(getLineLength(end) == 0 && end > start)end--;
		return new int[] {
		 start, end }
		;
	}
	 public FoldHandler getFoldHandler(){
		return foldHandler;
	}
	 public void setFoldHandler(FoldHandler foldHandler){
		FoldHandler oldFoldHandler = this.foldHandler;
		if(foldHandler.equals(oldFoldHandler))return;
		this.foldHandler = foldHandler;
		lineMgr.setFirstInvalidFoldLevel(0);
		fireFoldHandlerChanged();
	}
	 public void undo(TextArea textArea){
		if(undoMgr == null)return;
		if(!isEditable()){
			textArea.getToolkit().beep();
			return;
		}
		try{
			writeLock();
			undoInProgress = true;
			fireBeginUndo();
			int caret = undoMgr.undo();
			if(caret == -1)textArea.getToolkit().beep();
			elsetextArea.setCaretPosition(caret);
			fireEndUndo();
			fireTransactionComplete();
		}
		finally{
			undoInProgress = false;
			writeUnlock();
		}
	}
	 public void redo(TextArea textArea){
		if(undoMgr == null)return;
		if(!isEditable()){
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		try{
			writeLock();
			undoInProgress = true;
			fireBeginRedo();
			int caret = undoMgr.redo();
			if(caret == -1)textArea.getToolkit().beep();
			elsetextArea.setCaretPosition(caret);
			fireEndRedo();
			fireTransactionComplete();
		}
		finally{
			undoInProgress = false;
			writeUnlock();
		}
	}
	 public boolean isTransactionInProgress(){
		return transaction || undoInProgress || insideCompoundEdit();
	}
	 public void beginCompoundEdit(){
		try{
			writeLock();
			undoMgr.beginCompoundEdit();
		}
		finally{
			writeUnlock();
		}
	}
	 public void endCompoundEdit(){
		try{
			writeLock();
			undoMgr.endCompoundEdit();
			if(!insideCompoundEdit())fireTransactionComplete();
		}
		finally{
			writeUnlock();
		}
	}
	public boolean insideCompoundEdit(){
		return undoMgr.insideCompoundEdit();
	}
	 public boolean isUndoInProgress(){
		return undoInProgress;
	}
	 public Object getUndoId(){
		return undoMgr.getUndoId();
	}
	 public static final int NORMAL_PRIORITY = 0;
	public static final int HIGH_PRIORITY = 1;
	static class Listener{
		BufferListener listener;
		int priority;
		Listener(BufferListener listener, int priority){
			this.listener = listener;
			this.priority = priority;
		}
	}
	public void addBufferListener(BufferListener listener,int priority){
		Listener l = new Listener(listener,priority);
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			Listener _l = bufferListeners.get(i);
			if(_l.priority < priority){
				bufferListeners.add(i,l);
				return;
			}
		}
		bufferListeners.add(l);
	}
	public void addBufferListener(BufferListener listener){
		addBufferListener(listener,NORMAL_PRIORITY);
	}
	 public void removeBufferListener(BufferListener listener){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			if(bufferListeners.get(i).listener == listener){
				bufferListeners.remove(i);
				return;
			}
		}
	}
	 public BufferListener[] getBufferListeners(){
		BufferListener[] returnValue= new BufferListener[bufferListeners.size()];
		for(int i = 0;
		 i < returnValue.length;
		 i++){
			returnValue[i] = bufferListeners.get(i).listener;
		}
		return returnValue;
	}
	 public void setUndoLimit(int limit){
		if (undoMgr != null)undoMgr.setLimit(limit);
	}
	 public boolean canUndo(){
		if (undoMgr == null)return false;
		return undoMgr.canUndo();
	}
	 public boolean canRedo(){
		if (undoMgr == null)return false;
		return undoMgr.canRedo();
	}
	 protected Mode mode;
	protected boolean textMode;
	protected UndoManager undoMgr;
	protected void fireFoldLevelChanged(int start, int end){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.foldLevelChanged(this,start,end);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void fireContentInserted(int startLine, int offset,int numLines, int length){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.contentInserted(this,startLine,offset,numLines,length);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void fireContentRemoved(int startLine, int offset,int numLines, int length){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.contentRemoved(this,startLine,offset,numLines,length);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void firePreContentInserted(int startLine, int offset,int numLines, int length){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.preContentInserted(this,startLine,offset,numLines,length);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void firePreContentRemoved(int startLine, int offset,int numLines, int length){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.preContentRemoved(this,startLine,offset,numLines,length);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void fireBeginUndo(){
	}
	 protected void fireEndUndo(){
	}
	 protected void fireBeginRedo(){
	}
	 protected void fireEndRedo(){
	}
	 protected void fireTransactionComplete(){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.transactionComplete(this);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void fireFoldHandlerChanged(){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.foldHandlerChanged(this);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected void fireBufferLoaded(){
		for(int i = 0;
		 i < bufferListeners.size();
		 i++){
			BufferListener listener = getListener(i);
			try{
				listener.bufferLoaded(this);
			}
			catch(Throwable t){
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	}
	 protected boolean isFileReadOnly(){
		return readOnly;
	}
	 protected void setFileReadOnly(boolean readOnly){
		this.readOnly = readOnly;
	}
	 protected void loadText(Segment seg, IntegerArray endOffsets){
		if(seg == null)seg = new Segment(new char[1024],0,0);
		if(endOffsets == null){
			endOffsets = new IntegerArray();
			endOffsets.add(1);
		}
		try{
			writeLock();
			int length = getLength();
			firePreContentRemoved(0,0,getLineCount()- 1,length);
			contentMgr.remove(0,length);
			lineMgr.contentRemoved(0,0,getLineCount()- 1,length);
			positionMgr.contentRemoved(0,length);
			fireContentRemoved(0,0,getLineCount()- 1,length);
			firePreContentInserted(0, 0, endOffsets.getSize() - 1, seg.count - 1);
			contentMgr._setContent(seg.array,seg.count);
			lineMgr._contentInserted(endOffsets);
			positionMgr.contentInserted(0,seg.count);
			fireContentInserted(0,0,endOffsets.getSize() - 1,seg.count - 1);
		}
		finally{
			writeUnlock();
		}
	}
	 protected void invalidateFoldLevels(){
		lineMgr.setFirstInvalidFoldLevel(0);
	}
	 protected void parseBufferLocalProperties(){
		int lastLine = Math.min(9,getLineCount() - 1);
		parseBufferLocalProperties(getSegment(0,getLineEndOffset(lastLine) - 1));
		int firstLine = Math.max(lastLine + 1, getLineCount() - 10);
		if(firstLine < getLineCount()){
			int length = getLineEndOffset(getLineCount() - 1)- (getLineStartOffset(firstLine) + 1);
			parseBufferLocalProperties(getSegment(getLineStartOffset(firstLine),length));
		}
	}
	 protected static class PropValue{
		PropValue(Object value, boolean defaultValue){
			if(value == null)throw new NullPointerException();
			this.value = value;
			this.defaultValue = defaultValue;
		}
		Object value;
		boolean defaultValue;
		public String toString(){
			return value.toString();
		}
	}
	 private List<Listener> bufferListeners;
	private final ReentrantReadWriteLock lock;
	private ContentManager contentMgr;
	private LineManager lineMgr;
	private PositionManager positionMgr;
	private FoldHandler foldHandler;
	private IntegerArray integerArray;
	private TokenMarker tokenMarker;
	private boolean undoInProgress;
	private boolean dirty;
	private boolean readOnly;
	private boolean readOnlyOverride;
	private boolean transaction;
	private boolean loading;
	private boolean io;
	private final Map<Object, PropValue> properties;
	private final Object propertyLock;
	private BufferListener getListener(int index){
		return bufferListeners.get(index).listener;
	}
	 private void contentInserted(int offset, int length,IntegerArray endOffsets){
		try{
			transaction = true;
			int startLine = lineMgr.getLineOfOffset(offset);
			int numLines = endOffsets.getSize();
			if (!loading){
				firePreContentInserted(startLine, offset, numLines, length);
			}
			lineMgr.contentInserted(startLine,offset,numLines,length,endOffsets);
			positionMgr.contentInserted(offset,length);
			setDirty(true);
			if(!loading){
				fireContentInserted(startLine,offset,numLines,length);
				if(!undoInProgress && !insideCompoundEdit())fireTransactionComplete();
			}
		}
		finally{
			transaction = false;
		}
	}
	 private void parseBufferLocalProperties(CharSequence prop){
		StringBuilder buf = new StringBuilder();
		String name = null;
		boolean escape = false;
		for(int i = 0;
		 i < prop.length();
		 i++){
			char c = prop.charAt(i);
			switch(c){
				case ':':if(escape){
					escape = false;
					buf.append(':');
					break;
				}
				if(name != null){
					properties.put(name,new PropValue(buf.toString(),false));
					name = null;
				}
				buf.setLength(0);
				break;
				case '=':if(escape){
					escape = false;
					buf.append('=');
					break;
				}
				name = buf.toString();
				buf.setLength(0);
				break;
				case '\\':if(escape)buf.append('\\');
				escape = !escape;
				break;
				case 'n':if(escape){
					buf.append('\n');
					escape = false;
					break;
				}
				case 'r':if(escape){
					buf.append('\r');
					escape = false;
					break;
				}
				case 't':if(escape){
					buf.append('\t');
					escape = false;
					break;
				}
				default:buf.append(c);
				break;
			}
		}
	}
	 private List<IndentRule> getIndentRules(int line){
		String modeName = null;
		TokenMarker.LineContext ctx = lineMgr.getLineContext(line);
		if (ctx != null && ctx.rules != null)modeName = ctx.rules.getModeName();
		if (modeName == null)modeName = tokenMarker.getMainRuleSet().getModeName();
		return ModeProvider.instance.getMode(modeName).getIndentRules();
	}
 }",1,0,0,0
"public class ExpressionLogical extends Expression {
	 boolean noOptimisation;
	 boolean isQuantified;
	 ExpressionLogical(int type) {
		 super(type);
		 dataType = Type.SQL_BOOLEAN;
	 }
	 ExpressionLogical(boolean b) {
		 super(OpTypes.VALUE);
		 dataType = Type.SQL_BOOLEAN;
		 valueData = b ? Boolean.TRUE : Boolean.FALSE;
	 }
	 ExpressionLogical(RangeVariable leftRangeVar, int colIndexLeft, RangeVariable rightRangeVar, int colIndexRight) {
		 super(OpTypes.EQUAL);
		 ExpressionColumn leftExpression = new ExpressionColumn(leftRangeVar, colIndexLeft);
		 ExpressionColumn rightExpression = new ExpressionColumn(rightRangeVar, colIndexRight);
		 nodes = new Expression[BINARY];
		 dataType = Type.SQL_BOOLEAN;
		 nodes[LEFT] = leftExpression;
		 nodes[RIGHT] = rightExpression;
	 }
	 ExpressionLogical(Expression left, Expression right) {
		 super(OpTypes.EQUAL);
		 nodes = new Expression[BINARY];
		 nodes[LEFT] = left;
		 nodes[RIGHT] = right;
		 if (left.opType == OpTypes.COLUMN && right.opType == OpTypes.COLUMN) {
			 isColumnEqual = true;
		 }
		 dataType = Type.SQL_BOOLEAN;
	 }
	 ExpressionLogical(int type, Expression left, Expression right) {
		 super(type);
		 nodes = new Expression[BINARY];
		 nodes[LEFT] = left;
		 nodes[RIGHT] = right;
		 switch (opType) {
			 case OpTypes.EQUAL : if (left.opType == OpTypes.COLUMN && right.opType == OpTypes.COLUMN) {
				 isColumnEqual = true;
			 }
			 case OpTypes.GREATER_EQUAL : case OpTypes.GREATER : case OpTypes.SMALLER : case OpTypes.SMALLER_EQUAL : case OpTypes.NOT_EQUAL : case OpTypes.OVERLAPS : case OpTypes.NOT_DISTINCT : case OpTypes.IN : case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_UNIQUE_FULL : case OpTypes.AND : case OpTypes.OR : dataType = Type.SQL_BOOLEAN;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
	 }
	 ExpressionLogical(int type, Expression e) {
		 super(type);
		 nodes = new Expression[UNARY];
		 nodes[LEFT] = e;
		 switch (opType) {
			 case OpTypes.UNIQUE : case OpTypes.EXISTS : case OpTypes.IS_NULL : case OpTypes.NOT : dataType = Type.SQL_BOOLEAN;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
	 }
	 ExpressionLogical(ColumnSchema column) {
		 super(OpTypes.NOT);
		 nodes = new Expression[UNARY];
		 dataType = Type.SQL_BOOLEAN;
		 Expression e = new ExpressionColumn(column);
		 e = new ExpressionLogical(OpTypes.IS_NULL, e);
		 nodes[LEFT] = e;
	 }
	 static Expression andExpressions(Expression e1, Expression e2) {
		 if (e1 == null) {
			 return e2;
		 }
		 if (e2 == null) {
			 return e1;
		 }
		 if (ExpressionLogical.EXPR_FALSE.equals(e1) || ExpressionLogical.EXPR_FALSE.equals(e2)) {
			 return ExpressionLogical.EXPR_FALSE;
		 }
		 return new ExpressionLogical(OpTypes.AND, e1, e2);
	 }
	 static Expression orExpressions(Expression e1, Expression e2) {
		 if (e1 == null) {
			 return e2;
		 }
		 if (e2 == null) {
			 return e1;
		 }
		 return new ExpressionLogical(OpTypes.OR, e1, e2);
	 }
	 public void addLeftColumnsForAllAny(RangeVariable range, OrderedIntHashSet set) {
		 if (nodes.length == 0) {
			 return;
		 }
		 for (int j = 0;
		 j < nodes[LEFT].nodes.length;
		 j++) {
			 int index = nodes[LEFT].nodes[j].getColumnIndex();
			 if (index < 0 || nodes[LEFT].nodes[j].getRangeVariable() != range) {
				 set.clear();
				 return;
			 }
			 set.add(index);
		 }
	 }
	 public void setSubType(int type) {
		 exprSubType = type;
		 if (exprSubType == OpTypes.ALL_QUANTIFIED || exprSubType == OpTypes.ANY_QUANTIFIED) {
			 isQuantified = true;
		 }
	 }
	 public String getSQL() {
		 StringBuffer sb = new StringBuffer(64);
		 if (opType == OpTypes.VALUE) {
			 return super.getSQL();
		 }
		 String left = getContextSQL(nodes[LEFT]);
		 String right = getContextSQL(nodes.length > 1 ? nodes[RIGHT] : null);
		 switch (opType) {
			 case OpTypes.NOT : if (nodes[LEFT].opType == OpTypes.IS_NULL) {
				 sb.append(getContextSQL(nodes[LEFT].nodes[LEFT])).append( ' ').append(Tokens.T_IS).append(' ').append( Tokens.T_NOT).append(' ').append(Tokens.T_NULL);
				 return sb.toString();
			 }
			 if (nodes[LEFT].opType == OpTypes.NOT_DISTINCT) {
				 sb.append(getContextSQL(nodes[LEFT].nodes[LEFT])).append( ' ').append(Tokens.T_IS).append(' ').append( Tokens.T_DISTINCT).append(' ').append( Tokens.T_FROM).append(' ').append( getContextSQL(nodes[LEFT].nodes[RIGHT]));
				 return sb.toString();
			 }
			 sb.append(Tokens.T_NOT).append(' ').append(left);
			 return sb.toString();
			 case OpTypes.NOT_DISTINCT : sb.append(Tokens.T_NOT).append(' ').append( getContextSQL(nodes[LEFT].nodes[LEFT])).append(' ').append( Tokens.T_IS).append(' ').append(Tokens.T_DISTINCT).append( ' ').append(Tokens.T_FROM).append(' ').append( getContextSQL(nodes[LEFT].nodes[RIGHT]));
			 return sb.toString();
			 case OpTypes.IS_NULL : sb.append(left).append(' ').append(Tokens.T_IS).append( ' ').append(Tokens.T_NULL);
			 return sb.toString();
			 case OpTypes.UNIQUE : sb.append(' ').append(Tokens.T_UNIQUE).append(' ');
			 break;
			 case OpTypes.EXISTS : sb.append(' ').append(Tokens.T_EXISTS).append(' ');
			 break;
			 case OpTypes.EQUAL : sb.append(left).append('=').append(right);
			 return sb.toString();
			 case OpTypes.GREATER_EQUAL : sb.append(left).append("">="").append(right);
			 return sb.toString();
			 case OpTypes.GREATER : sb.append(left).append('>').append(right);
			 return sb.toString();
			 case OpTypes.SMALLER : sb.append(left).append('<').append(right);
			 return sb.toString();
			 case OpTypes.SMALLER_EQUAL : sb.append(left).append(""<="").append(right);
			 return sb.toString();
			 case OpTypes.NOT_EQUAL : if (Tokens.T_NULL.equals(right)) {
				 sb.append(left).append("" IS NOT "").append(right);
			 }
			 else {
				 sb.append(left).append(""!="").append(right);
			 }
			 return sb.toString();
			 case OpTypes.AND : sb.append(left).append(' ').append(Tokens.T_AND).append( ' ').append(right);
			 return sb.toString();
			 case OpTypes.OR : sb.append(left).append(' ').append(Tokens.T_OR).append( ' ').append(right);
			 return sb.toString();
			 case OpTypes.IN : sb.append(left).append(' ').append(Tokens.T_IN).append( ' ').append(right);
			 return sb.toString();
			 case OpTypes.MATCH_SIMPLE : sb.append(left).append(' ').append(Tokens.T_MATCH).append( ' ').append(right);
			 return sb.toString();
			 case OpTypes.MATCH_PARTIAL : sb.append(left).append(' ').append(Tokens.T_MATCH).append( ' ').append(Tokens.PARTIAL).append(right);
			 return sb.toString();
			 case OpTypes.MATCH_FULL : sb.append(left).append(' ').append(Tokens.T_MATCH).append( ' ').append(Tokens.FULL).append(right);
			 return sb.toString();
			 case OpTypes.MATCH_UNIQUE_SIMPLE : sb.append(left).append(' ').append(Tokens.T_MATCH).append( ' ').append(Tokens.UNIQUE).append(right);
			 return sb.toString();
			 case OpTypes.MATCH_UNIQUE_PARTIAL : sb.append(left).append(' ').append(Tokens.T_MATCH).append( ' ').append(Tokens.UNIQUE).append(' ').append( Tokens.PARTIAL).append(right);
			 return sb.toString();
			 case OpTypes.MATCH_UNIQUE_FULL : sb.append(left).append(' ').append(Tokens.T_MATCH).append( ' ').append(Tokens.UNIQUE).append(' ').append( Tokens.FULL).append(right);
			 return sb.toString();
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
		 return sb.toString();
	 }
	 protected String describe(Session session, int blanks) {
		 StringBuffer sb = new StringBuffer(64);
		 sb.append('\n');
		 for (int i = 0;
		 i < blanks;
		 i++) {
			 sb.append(' ');
		 }
		 switch (opType) {
			 case OpTypes.VALUE : sb.append(""VALUE = "").append(valueData);
			 sb.append("", TYPE = "").append(dataType.getNameString());
			 return sb.toString();
			 case OpTypes.NOT : if (nodes[LEFT].opType == OpTypes.NOT_DISTINCT) {
				 sb.append(Tokens.T_DISTINCT);
				 return sb.toString();
			 }
			 sb.append(Tokens.T_NOT);
			 break;
			 case OpTypes.NOT_DISTINCT : sb.append(Tokens.T_NOT).append(' ').append(Tokens.T_DISTINCT);
			 break;
			 case OpTypes.EQUAL : sb.append(""EQUAL"");
			 break;
			 case OpTypes.GREATER_EQUAL : sb.append(""GREATER_EQUAL"");
			 break;
			 case OpTypes.GREATER : sb.append(""GREATER"");
			 break;
			 case OpTypes.SMALLER : sb.append(""SMALLER"");
			 break;
			 case OpTypes.SMALLER_EQUAL : sb.append(""SMALLER_EQUAL"");
			 break;
			 case OpTypes.NOT_EQUAL : sb.append(""NOT_EQUAL"");
			 break;
			 case OpTypes.AND : sb.append(Tokens.T_AND);
			 break;
			 case OpTypes.OR : sb.append(Tokens.T_OR);
			 break;
			 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_UNIQUE_FULL : sb.append(Tokens.T_MATCH);
			 break;
			 case OpTypes.IS_NULL : sb.append(Tokens.T_IS).append(' ').append(Tokens.T_NULL);
			 break;
			 case OpTypes.UNIQUE : sb.append(Tokens.T_UNIQUE);
			 break;
			 case OpTypes.EXISTS : sb.append(Tokens.T_EXISTS);
			 break;
			 case OpTypes.OVERLAPS : sb.append(Tokens.T_OVERLAPS);
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
		 if (getLeftNode() != null) {
			 sb.append("" arg_left=["");
			 sb.append(nodes[LEFT].describe(session, blanks + 1));
			 sb.append(']');
		 }
		 if (getRightNode() != null) {
			 sb.append("" arg_right=["");
			 sb.append(nodes[RIGHT].describe(session, blanks + 1));
			 sb.append(']');
		 }
		 return sb.toString();
	 }
	 public void resolveTypes(Session session, Expression parent) {
		 if (isQuantified) {
			 if (nodes[RIGHT].opType == OpTypes.TABLE) {
				 if (nodes[RIGHT] instanceof ExpressionTable) {
					 if (nodes[RIGHT].nodes[LEFT].opType == OpTypes.DYNAMIC_PARAM) {
						 nodes[LEFT].resolveTypes(session, this);
						 nodes[RIGHT].nodes[LEFT].dataType = Type.getDefaultArrayType( nodes[LEFT].dataType.typeCode);
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 nodes[i].resolveTypes(session, this);
			 }
		 }
		 switch (opType) {
			 case OpTypes.VALUE : break;
			 case OpTypes.NOT_DISTINCT : case OpTypes.EQUAL : case OpTypes.GREATER_EQUAL : case OpTypes.GREATER : case OpTypes.SMALLER : case OpTypes.SMALLER_EQUAL : case OpTypes.NOT_EQUAL : resolveTypesForComparison(session, parent);
			 break;
			 case OpTypes.AND : {
				 resolveTypesForLogicalOp();
				 if (nodes[LEFT].opType == OpTypes.VALUE) {
					 if (nodes[RIGHT].opType == OpTypes.VALUE) {
						 setAsConstantValue(session);
					 }
					 else {
						 Object value = nodes[LEFT].getValue(session);
						 if (value == null || Boolean.FALSE.equals(value)) {
							 setAsConstantValue(Boolean.FALSE);
						 }
					 }
				 }
				 else if (nodes[RIGHT].opType == OpTypes.VALUE) {
					 Object value = nodes[RIGHT].getValue(session);
					 if (value == null || Boolean.FALSE.equals(value)) {
						 setAsConstantValue(Boolean.FALSE);
					 }
				 }
				 break;
			 }
			 case OpTypes.OR : {
				 resolveTypesForLogicalOp();
				 if (nodes[LEFT].opType == OpTypes.VALUE) {
					 if (nodes[RIGHT].opType == OpTypes.VALUE) {
						 setAsConstantValue(session);
					 }
					 else {
						 Object value = nodes[LEFT].getValue(session);
						 if (Boolean.TRUE.equals(value)) {
							 setAsConstantValue(Boolean.TRUE);
						 }
					 }
				 }
				 else if (nodes[RIGHT].opType == OpTypes.VALUE) {
					 Object value = nodes[RIGHT].getValue(session);
					 if (Boolean.TRUE.equals(value)) {
						 setAsConstantValue(Boolean.TRUE);
					 }
				 }
				 break;
			 }
			 case OpTypes.IS_NULL : if (nodes[LEFT].isUnresolvedParam()) {
				 throw Error.error(ErrorCode.X_42563);
			 }
			 if (nodes[LEFT].opType == OpTypes.VALUE) {
				 setAsConstantValue(session);
			 }
			 break;
			 case OpTypes.NOT : if (nodes[LEFT].isUnresolvedParam()) {
				 nodes[LEFT].dataType = Type.SQL_BOOLEAN;
				 break;
			 }
			 if (nodes[LEFT].opType == OpTypes.VALUE) {
				 if (nodes[LEFT].dataType.isBooleanType()) {
					 setAsConstantValue(session);
					 break;
				 }
				 else {
					 throw Error.error(ErrorCode.X_42563);
				 }
			 }
			 if (nodes[LEFT].dataType == null || !nodes[LEFT].dataType.isBooleanType()) {
				 throw Error.error(ErrorCode.X_42563);
			 }
			 dataType = Type.SQL_BOOLEAN;
			 break;
			 case OpTypes.OVERLAPS : resolveTypesForOverlaps();
			 break;
			 case OpTypes.IN : resolveTypesForIn(session);
			 break;
			 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_UNIQUE_FULL : resolveTypesForAllAny(session);
			 break;
			 case OpTypes.UNIQUE : case OpTypes.EXISTS : break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
	 }
	 private void resolveTypesForLogicalOp() {
		 if (nodes[LEFT].isUnresolvedParam()) {
			 nodes[LEFT].dataType = Type.SQL_BOOLEAN;
		 }
		 if (nodes[RIGHT].isUnresolvedParam()) {
			 nodes[RIGHT].dataType = Type.SQL_BOOLEAN;
		 }
		 if (nodes[LEFT].dataType == null || nodes[RIGHT].dataType == null) {
			 throw Error.error(ErrorCode.X_42571);
		 }
		 if (nodes[LEFT].opType == OpTypes.ROW || nodes[RIGHT].opType == OpTypes.ROW) {
			 throw Error.error(ErrorCode.X_42565);
		 }
		 if (Type.SQL_BOOLEAN != nodes[LEFT].dataType || Type.SQL_BOOLEAN != nodes[RIGHT].dataType) {
			 throw Error.error(ErrorCode.X_42568);
		 }
	 }
	 private void resolveTypesForComparison(Session session, Expression parent) {
		 if (opType == OpTypes.NOT_DISTINCT || exprSubType == OpTypes.ALL_QUANTIFIED || exprSubType == OpTypes.ANY_QUANTIFIED) {
			 resolveTypesForAllAny(session);
			 checkRowComparison();
			 return;
		 }
		 if (nodes[LEFT].opType == OpTypes.ROW || nodes[RIGHT].opType == OpTypes.ROW) {
			 if (nodes[LEFT].opType != OpTypes.ROW || nodes[RIGHT].opType != OpTypes.ROW || nodes[LEFT].nodes.length != nodes[RIGHT].nodes.length) {
				 throw Error.error(ErrorCode.X_42564);
			 }
			 resolveRowTypes();
			 checkRowComparison();
			 return;
		 }
		 else {
			 if (nodes[LEFT].isUnresolvedParam()) {
				 nodes[LEFT].dataType = nodes[RIGHT].dataType;
			 }
			 else if (nodes[RIGHT].isUnresolvedParam()) {
				 nodes[RIGHT].dataType = nodes[LEFT].dataType;
			 }
			 if (nodes[LEFT].dataType == null) {
				 nodes[LEFT].dataType = nodes[RIGHT].dataType;
			 }
			 else if (nodes[RIGHT].dataType == null) {
				 nodes[RIGHT].dataType = nodes[LEFT].dataType;
			 }
			 if (nodes[LEFT].dataType == null || nodes[RIGHT].dataType == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
			 if (nodes[LEFT].dataType.typeComparisonGroup != nodes[RIGHT].dataType.typeComparisonGroup) {
				 if (convertDateTimeLiteral(session, nodes[LEFT], nodes[RIGHT])) {
				 }
				 else if (nodes[LEFT].dataType.isBitType()) {
					 if (nodes[RIGHT].dataType.canConvertFrom( nodes[LEFT].dataType)) {
						 nodes[LEFT] = ExpressionOp.getCastExpression(session, nodes[LEFT], nodes[RIGHT].dataType);
					 }
				 }
				 else if (nodes[RIGHT].dataType.isBitType()) {
					 if (nodes[LEFT].dataType.canConvertFrom( nodes[RIGHT].dataType)) {
						 nodes[RIGHT] = ExpressionOp.getCastExpression(session, nodes[RIGHT], nodes[LEFT].dataType);
					 }
				 }
				 else {
					 throw Error.error(ErrorCode.X_42562);
				 }
			 }
			 else if (nodes[LEFT].dataType.isDateTimeType()) {
				 if (nodes[LEFT].dataType.isDateTimeTypeWithZone() ^ nodes[RIGHT].dataType.isDateTimeTypeWithZone()) {
					 nodes[LEFT] = new ExpressionOp(nodes[LEFT]);
				 }
			 }
			 if (opType == OpTypes.EQUAL || opType == OpTypes.NOT_EQUAL) {
			}
			 else {
				 if (nodes[LEFT].dataType.isArrayType() || nodes[LEFT].dataType.isLobType() || nodes[RIGHT].dataType.isLobType()) {
					 throw Error.error(ErrorCode.X_42534);
				 }
			 }
			 if (nodes[LEFT].opType == OpTypes.VALUE && nodes[RIGHT].opType == OpTypes.VALUE) {
				 setAsConstantValue(session);
			 }
		 }
	 }
	 private void resolveRowTypes() {
		 for (int i = 0;
		 i < nodes[LEFT].nodeDataTypes.length;
		 i++) {
			 Type leftType = nodes[LEFT].nodeDataTypes[i];
			 Type rightType = nodes[RIGHT].nodeDataTypes[i];
			 if (leftType == null) {
				 leftType = nodes[LEFT].nodeDataTypes[i] = rightType;
			 }
			 else if (nodes[RIGHT].dataType == null) {
				 rightType = nodes[RIGHT].nodeDataTypes[i] = leftType;
			 }
			 if (leftType == null || rightType == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
			 if (leftType.typeComparisonGroup != rightType.typeComparisonGroup) {
				 throw Error.error(ErrorCode.X_42562);
			 }
			 else if (leftType.isDateTimeType()) {
				 if (leftType.isDateTimeTypeWithZone() ^ rightType.isDateTimeTypeWithZone()) {
					 nodes[LEFT].nodes[i] = new ExpressionOp(nodes[LEFT].nodes[i]);
					 nodes[LEFT].nodeDataTypes[i] = nodes[LEFT].nodes[i].dataType;
				 }
			 }
		 }
	 }
	 void checkRowComparison() {
		 if (opType == OpTypes.EQUAL || opType == OpTypes.NOT_EQUAL) {
			 return;
		 }
		 for (int i = 0;
		 i < nodes[LEFT].nodeDataTypes.length;
		 i++) {
			 Type leftType = nodes[LEFT].nodeDataTypes[i];
			 Type rightType = nodes[RIGHT].nodeDataTypes[i];
			 if (leftType.isArrayType() || leftType.isLobType() || rightType.isLobType()) {
				 throw Error.error(ErrorCode.X_42534);
			 }
		 }
	 }
	 private boolean convertDateTimeLiteral(Session session, Expression a, Expression b) {
		 if (a.dataType.isDateTimeType()) {
		}
		 else if (b.dataType.isDateTimeType()) {
			 Expression c = a;
			 a = b;
			 b = c;
		 }
		 else {
			 return false;
		 }
		 if (a.dataType.isDateTimeTypeWithZone()) {
			 return false;
		 }
		 if (b.opType == OpTypes.VALUE && b.dataType.isCharacterType()) {
			 b.valueData = a.dataType.castToType(session, b.valueData, b.dataType);
			 b.dataType = a.dataType;
			 return true;
		 }
		 return false;
	 }
	 void resolveTypesForOverlaps() {
		 if (nodes[LEFT].nodes[0].isUnresolvedParam()) {
			 nodes[LEFT].nodes[0].dataType = nodes[RIGHT].nodes[0].dataType;
		 }
		 if (nodes[RIGHT].nodes[0].isUnresolvedParam()) {
			 nodes[RIGHT].nodes[0].dataType = nodes[LEFT].nodes[0].dataType;
		 }
		 if (nodes[LEFT].nodes[0].dataType == null) {
			 nodes[LEFT].nodes[0].dataType = nodes[RIGHT].nodes[0].dataType = Type.SQL_TIMESTAMP;
		 }
		 if (nodes[LEFT].nodes[1].isUnresolvedParam()) {
			 nodes[LEFT].nodes[1].dataType = nodes[RIGHT].nodes[0].dataType;
		 }
		 if (nodes[RIGHT].nodes[1].isUnresolvedParam()) {
			 nodes[RIGHT].nodes[1].dataType = nodes[LEFT].nodes[0].dataType;
		 }
		 if (!DTIType .isValidDatetimeRange(nodes[LEFT].nodes[0] .dataType, nodes[LEFT].nodes[1].dataType) || !DTIType .isValidDatetimeRange(nodes[RIGHT].nodes[0] .dataType, nodes[RIGHT].nodes[1].dataType)) {
			 throw Error.error(ErrorCode.X_42563);
		 }
		 if (!DTIType.isValidDatetimeRange(nodes[LEFT].nodes[0].dataType, nodes[LEFT].nodes[1].dataType)) {
			 throw Error.error(ErrorCode.X_42563);
		 }
		 nodes[LEFT].nodeDataTypes[0] = nodes[LEFT].nodes[0].dataType;
		 nodes[LEFT].nodeDataTypes[1] = nodes[LEFT].nodes[1].dataType;
		 nodes[RIGHT].nodeDataTypes[0] = nodes[RIGHT].nodes[0].dataType;
		 nodes[RIGHT].nodeDataTypes[1] = nodes[RIGHT].nodes[1].dataType;
	 }
	 void resolveTypesForAllAny(Session session) {
		 int degree = nodes[LEFT].getDegree();
		 if (degree == 1 && nodes[LEFT].opType != OpTypes.ROW) {
			 nodes[LEFT] = new Expression(OpTypes.ROW, new Expression[]{
			 nodes[LEFT] }
			);
		 }
		 if (nodes[RIGHT].opType == OpTypes.TABLE) {
			 nodes[RIGHT].prepareTable(session, nodes[LEFT], degree);
			 nodes[RIGHT].subQuery.prepareTable(session);
			 if (nodes[RIGHT].isCorrelated) {
				 nodes[RIGHT].subQuery.setCorrelated();
			 }
		 }
		 if (degree != nodes[RIGHT].nodeDataTypes.length) {
			 throw Error.error(ErrorCode.X_42564);
		 }
		 if (nodes[RIGHT].opType == OpTypes.TABLE) {
		}
		 nodes[LEFT].nodeDataTypes = new Type[nodes[LEFT].nodes.length];
		 for (int i = 0;
		 i < nodes[LEFT].nodeDataTypes.length;
		 i++) {
			 Type type = nodes[LEFT].nodes[i].dataType;
			 if (type == null) {
				 type = nodes[RIGHT].nodeDataTypes[i];
			 }
			 if (type == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
			 nodes[LEFT].nodeDataTypes[i] = type;
			 nodes[LEFT].nodes[i].dataType = type;
		 }
	 }
	 void resolveTypesForIn(Session session) {
		 resolveTypesForAllAny(session);
	 }
	 public Object getValue(Session session) {
		 switch (opType) {
			 case OpTypes.VALUE : return valueData;
			 case OpTypes.SIMPLE_COLUMN : {
				 Object[] data = (Object[]) session.sessionContext .rangeIterators[rangePosition].getCurrent();
				 return data[columnIndex];
			 }
			 case OpTypes.NEGATE : return ((NumberType) dataType).negate( nodes[LEFT].getValue(session, nodes[LEFT].dataType));
			 case OpTypes.IS_NULL : return nodes[LEFT].getValue(session) == null ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.OVERLAPS : {
				 Object[] left = nodes[LEFT].getRowValue(session);
				 Object[] right = nodes[RIGHT].getRowValue(session);
				 return DateTimeType.overlaps(session, left, nodes[LEFT].nodeDataTypes, right, nodes[RIGHT].nodeDataTypes);
			 }
			 case OpTypes.IN : {
				 return testInCondition(session, nodes[LEFT].getRowValue(session));
			 }
			 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_UNIQUE_FULL : {
				 return testMatchCondition(session, nodes[LEFT].getRowValue(session));
			 }
			 case OpTypes.UNIQUE : {
				 nodes[LEFT].materialise(session);
				 return nodes[LEFT].subQuery.hasUniqueNotNullRows(session) ? Boolean.TRUE : Boolean.FALSE;
			 }
			 case OpTypes.EXISTS : {
				 return testExistsCondition(session);
			 }
			 case OpTypes.NOT : {
				 Boolean result = (Boolean) nodes[LEFT].getValue(session);
				 return result == null ? null : result.booleanValue() ? Boolean.FALSE : Boolean.TRUE;
			 }
			 case OpTypes.AND : {
				 Boolean r1 = (Boolean) nodes[LEFT].getValue(session);
				 if (Boolean.FALSE.equals(r1)) {
					 return Boolean.FALSE;
				 }
				 Boolean r2 = (Boolean) nodes[RIGHT].getValue(session);
				 if (Boolean.FALSE.equals(r2)) {
					 return Boolean.FALSE;
				 }
				 if (r1 == null || r2 == null) {
					 return null;
				 }
				 return Boolean.TRUE;
			 }
			 case OpTypes.OR : {
				 Boolean r1 = (Boolean) nodes[LEFT].getValue(session);
				 if (Boolean.TRUE.equals(r1)) {
					 return Boolean.TRUE;
				 }
				 Boolean r2 = (Boolean) nodes[RIGHT].getValue(session);
				 if (Boolean.TRUE.equals(r2)) {
					 return Boolean.TRUE;
				 }
				 if (r1 == null || r2 == null) {
					 return null;
				 }
				 return Boolean.FALSE;
			 }
			 case OpTypes.NOT_DISTINCT : case OpTypes.EQUAL : case OpTypes.GREATER : case OpTypes.GREATER_EQUAL : case OpTypes.SMALLER_EQUAL : case OpTypes.SMALLER : case OpTypes.NOT_EQUAL : {
				 if (exprSubType == OpTypes.ANY_QUANTIFIED || exprSubType == OpTypes.ALL_QUANTIFIED) {
					 return testAllAnyCondition( session, (Object[]) nodes[LEFT].getRowValue(session));
				 }
				 Object o1 = nodes[LEFT].getValue(session);
				 Object o2 = nodes[RIGHT].getValue(session);
				 if (o1 instanceof Object[]) {
					 if (!(o2 instanceof Object[])) {
						 throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
					 }
					 return compareValues(session, (Object[]) o1, (Object[]) o2);
				 }
				 else {
					 if (o2 instanceof Object[]) {
						 o2 = ((Object[]) o2)[0];
					 }
					 return compareValues(session, o1, o2);
				 }
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
	 }
	 private Boolean compareValues(Session session, Object left, Object right) {
		 int result = 0;
		 if (left == null || right == null) {
			 return null;
		 }
		 result = nodes[LEFT].dataType.compare(session, left, right);
		 switch (opType) {
			 case OpTypes.EQUAL : return result == 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.NOT_EQUAL : return result != 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.GREATER : return result > 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.GREATER_EQUAL : return result >= 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.SMALLER_EQUAL : return result <= 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.SMALLER : return result < 0 ? Boolean.TRUE : Boolean.FALSE;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
	 }
	 private Boolean compareValues(Session session, Object[] left, Object[] right) {
		 int result = 0;
		 boolean hasNull = false;
		 if (left == null || right == null) {
			 return null;
		 }
		 Object[] leftList = (Object[]) left;
		 Object[] rightList = (Object[]) right;
		 for (int i = 0;
		 i < nodes[LEFT].nodes.length;
		 i++) {
			 if (leftList[i] == null) {
				 if (opType == OpTypes.MATCH_PARTIAL || opType == OpTypes.MATCH_UNIQUE_PARTIAL) {
					 continue;
				 }
				 hasNull = true;
			 }
			 if (rightList[i] == null) {
				 hasNull = true;
			 }
			 Object leftValue = leftList[i];
			 Object rightValue = rightList[i];
			 Type[] types = nodes[LEFT].nodeDataTypes;
			 result = types[i].compare(session, leftValue, rightValue);
			 if (result != 0) {
				 break;
			 }
		 }
		 switch (opType) {
			 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_FULL : case OpTypes.NOT_DISTINCT : return result == 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.IN : case OpTypes.EQUAL : if (hasNull) {
				 return null;
			 }
			 return result == 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.NOT_EQUAL : if (hasNull) {
				 return null;
			 }
			 return result != 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.GREATER : if (hasNull) {
				 return null;
			 }
			 return result > 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.GREATER_EQUAL : if (hasNull) {
				 return null;
			 }
			 return result >= 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.SMALLER_EQUAL : if (hasNull) {
				 return null;
			 }
			 return result <= 0 ? Boolean.TRUE : Boolean.FALSE;
			 case OpTypes.SMALLER : if (hasNull) {
				 return null;
			 }
			 return result < 0 ? Boolean.TRUE : Boolean.FALSE;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
	 }
	 private Boolean testInCondition(Session session, Object[] data) {
		 if (data == null) {
			 return null;
		 }
		 if (Expression.countNulls(data) != 0) {
			 return null;
		 }
		 if (nodes[RIGHT].opType == OpTypes.TABLE) {
			 final int length = nodes[RIGHT].nodes.length;
			 for (int i = 0;
			 i < length;
			 i++) {
				 Object[] rowData = nodes[RIGHT].nodes[i].getRowValue(session);
				 if (Boolean.TRUE.equals(compareValues(session, data, rowData))) {
					 return Boolean.TRUE;
				 }
			 }
			 return Boolean.FALSE;
		 }
		 throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
	 }
	 private Boolean testMatchCondition(Session session, Object[] data) {
		 int nulls;
		 if (data == null) {
			 return Boolean.TRUE;
		 }
		 nulls = countNulls(data);
		 if (nulls != 0) {
			 switch (opType) {
				 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_UNIQUE_SIMPLE : return Boolean.TRUE;
				 case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_UNIQUE_PARTIAL : if (nulls == data.length) {
					 return Boolean.TRUE;
				 }
				 break;
				 case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_FULL : return nulls == data.length ? Boolean.TRUE : Boolean.FALSE;
			 }
		 }
		 if (nodes[RIGHT].opType == OpTypes.TABLE) {
			 final int length = nodes[RIGHT].nodes.length;
			 boolean hasMatch = false;
			 for (int i = 0;
			 i < length;
			 i++) {
				 Object[] rowData = nodes[RIGHT].nodes[i].getRowValue(session);
				 Boolean result = compareValues(session, data, rowData);
				 if (result == null || !result.booleanValue()) {
					 continue;
				 }
				 switch (opType) {
					 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : return Boolean.TRUE;
					 case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_UNIQUE_FULL : if (hasMatch) {
						 return Boolean.FALSE;
					 }
					 hasMatch = true;
				 }
			 }
			 return hasMatch ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (nodes[RIGHT].opType == OpTypes.TABLE_SUBQUERY) {
			 PersistentStore store = session.sessionData.getRowStore(nodes[RIGHT].getTable());
			 nodes[RIGHT].materialise(session);
			 convertToType(session, data, nodes[LEFT].nodeDataTypes, nodes[RIGHT].nodeDataTypes);
			 if (nulls != 0 && (opType == OpTypes.MATCH_PARTIAL || opType == OpTypes.MATCH_UNIQUE_PARTIAL)) {
				 boolean hasMatch = false;
				 RowIterator it = nodes[RIGHT].getTable().rowIterator(session);
				 while (it.hasNext()) {
					 Object[] rowData = it.getNextRow().getData();
					 Boolean result = compareValues(session, data, rowData);
					 if (result == null) {
						 continue;
					 }
					 if (result.booleanValue()) {
						 if (opType == OpTypes.MATCH_PARTIAL) {
							 return Boolean.TRUE;
						 }
						 if (hasMatch) {
							 return Boolean.FALSE;
						 }
						 hasMatch = true;
					 }
				 }
				 return hasMatch ? Boolean.TRUE : Boolean.FALSE;
			 }
			 RowIterator it = nodes[RIGHT].getTable().getPrimaryIndex().findFirstRow(session, store, data);
			 boolean result = it.hasNext();
			 if (!result) {
				 return Boolean.FALSE;
			 }
			 switch (opType) {
				 case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : return Boolean.TRUE;
			 }
			 it.getNextRow();
			 result = it.hasNext();
			 if (!result) {
				 return Boolean.TRUE;
			 }
			 Object[] rowData = it.getNextRow().getData();
			 Boolean returnValue = Boolean.TRUE.equals(compareValues(session, data, rowData)) ? Boolean.FALSE : Boolean.TRUE;
			 return returnValue;
		 }
		 throw Error.error(ErrorCode.X_42564);
	 }
	 private Boolean testExistsCondition(Session session) {
		 nodes[LEFT].materialise(session);
		 return nodes[LEFT].getTable().isEmpty(session) ? Boolean.FALSE : Boolean.TRUE;
	 }
	 private Boolean testAllAnyCondition(Session session, Object[] o) {
		 SubQuery subquery = nodes[RIGHT].subQuery;
		 subquery.materialiseCorrelated(session);
		 Boolean result = getAllAnyValue(session, o, subquery);
		 return result;
	 }
	 private Boolean getAllAnyValue(Session session, Object[] data, SubQuery subquery) {
		 Table table = subquery.getTable();
		 boolean empty = table.isEmpty(session);
		 Index index = table.getFullIndex();
		 RowIterator it;
		 Row firstrow;
		 PersistentStore store = session.sessionData.getRowStore(table);
		 Row lastrow = index.lastRow(session, store).getNextRow();
		 Object[] lastdata;
		 Object[] firstdata;
		 switch (exprSubType) {
			 case OpTypes.ANY_QUANTIFIED : {
				 if (empty) {
					 return Boolean.FALSE;
				 }
				 if (countNulls(data) == data.length) {
					 return null;
				 }
				 lastdata = lastrow.getData();
				 if (countNulls(lastdata) == data.length) {
					 return null;
				 }
				 convertToType(session, data, nodes[LEFT].nodeDataTypes, nodes[RIGHT].nodeDataTypes);
				 if (opType == OpTypes.EQUAL) {
					 it = index.findFirstRow(session, store, data);
					 return it.hasNext() ? Boolean.TRUE : Boolean.FALSE;
				 }
				 it = index.findFirstRowNotNull(session, store);
				 firstrow = it.getNextRow();
				 firstdata = firstrow.getData();
				 Boolean comparefirst = compareValues(session, data, firstdata);
				 Boolean comparelast = compareValues(session, data, lastdata);
				 switch (opType) {
					 case OpTypes.NOT_EQUAL : return Boolean.TRUE.equals(comparefirst) || Boolean.TRUE.equals( comparelast) ? Boolean.TRUE : Boolean.FALSE;
					 case OpTypes.GREATER : return comparefirst;
					 case OpTypes.GREATER_EQUAL : return comparefirst;
					 case OpTypes.SMALLER : return comparelast;
					 case OpTypes.SMALLER_EQUAL : return comparelast;
				 }
				 break;
			 }
			 case OpTypes.ALL_QUANTIFIED : {
				 if (empty) {
					 return Boolean.TRUE;
				 }
				 if (countNulls(data) == data.length) {
					 return null;
				 }
				 it = index.firstRow(session, store);
				 firstrow = it.getNextRow();
				 firstdata = firstrow.getData();
				 if (countNulls(firstdata) == data.length) {
					 return null;
				 }
				 convertToType(session, data, nodes[LEFT].nodeDataTypes, nodes[RIGHT].nodeDataTypes);
				 it = index.findFirstRow(session, store, data);
				 if (opType == OpTypes.EQUAL) {
					 if (it.hasNext()) {
						 return subquery.getTable().getRowCount(store) == 1 ? Boolean.TRUE : Boolean.FALSE;
					 }
					 else {
						 return Boolean.FALSE;
					 }
				 }
				 if (opType == OpTypes.NOT_EQUAL) {
					 return it.hasNext() ? Boolean.FALSE : Boolean.TRUE;
				 }
				 lastdata = lastrow.getData();
				 Boolean comparefirst = compareValues(session, data, firstdata);
				 Boolean comparelast = compareValues(session, data, lastdata);
				 switch (opType) {
					 case OpTypes.GREATER : return comparelast;
					 case OpTypes.GREATER_EQUAL : return comparelast;
					 case OpTypes.SMALLER : return comparefirst;
					 case OpTypes.SMALLER_EQUAL : return comparefirst;
				 }
				 break;
			 }
		 }
		 return null;
	 }
	 void distributeOr() {
		 if (opType != OpTypes.OR) {
			 return;
		 }
		 if (nodes[LEFT].opType == OpTypes.AND) {
			 opType = OpTypes.AND;
			 Expression temp = new ExpressionLogical(OpTypes.OR, nodes[LEFT].nodes[RIGHT], nodes[RIGHT]);
			 nodes[LEFT].opType = OpTypes.OR;
			 nodes[LEFT].nodes[RIGHT] = nodes[RIGHT];
			 nodes[RIGHT] = temp;
		 }
		 else if (nodes[RIGHT].opType == OpTypes.AND) {
			 Expression temp = nodes[LEFT];
			 nodes[LEFT] = nodes[RIGHT];
			 nodes[RIGHT] = temp;
			 distributeOr();
			 return;
		 }
		 ((ExpressionLogical) nodes[LEFT]).distributeOr();
		 ((ExpressionLogical) nodes[RIGHT]).distributeOr();
	 }
	 public boolean isIndexable(RangeVariable rangeVar) {
		 boolean result;
		 switch (opType) {
			 case OpTypes.AND : {
				 result = nodes[LEFT].isIndexable(rangeVar) || nodes[RIGHT].isIndexable(rangeVar);
				 return result;
			 }
			 case OpTypes.OR : {
				 result = nodes[LEFT].isIndexable(rangeVar) && nodes[RIGHT].isIndexable(rangeVar);
				 return result;
			 }
			 default : {
				 Expression temp = getIndexableExpression(rangeVar);
				 return temp != null;
			 }
		 }
	 }
	 Expression getIndexableExpression(RangeVariable rangeVar) {
		 switch (opType) {
			 case OpTypes.IS_NULL : return nodes[LEFT].opType == OpTypes.COLUMN && nodes[LEFT].isIndexable(rangeVar) ? this : null;
			 case OpTypes.NOT : return nodes[LEFT].opType == OpTypes.IS_NULL && nodes[LEFT].nodes[LEFT].opType == OpTypes.COLUMN && nodes[LEFT].nodes[LEFT].isIndexable(rangeVar) ? this : null;
			 case OpTypes.EQUAL : if (exprSubType == OpTypes.ANY_QUANTIFIED) {
				 if (nodes[RIGHT].isCorrelated) {
					 return null;
				 }
				 for (int node = 0;
				 node < nodes[LEFT].nodes.length;
				 node++) {
					 if (nodes[LEFT].nodes[node].opType == OpTypes.COLUMN && nodes[LEFT].nodes[node].isIndexable( rangeVar)) {
						 return this;
					 }
				 }
				 return null;
			 }
			 case OpTypes.GREATER : case OpTypes.GREATER_EQUAL : case OpTypes.SMALLER : case OpTypes.SMALLER_EQUAL : if (exprSubType != 0) {
				 return null;
			 }
			 if (nodes[LEFT].opType == OpTypes.COLUMN && nodes[LEFT].isIndexable(rangeVar)) {
				 if (nodes[RIGHT].hasReference(rangeVar)) {
					 return null;
				 }
				 return this;
			 }
			 if (nodes[LEFT].hasReference(rangeVar)) {
				 return null;
			 }
			 if (nodes[RIGHT].opType == OpTypes.COLUMN && nodes[RIGHT].isIndexable(rangeVar)) {
				 swapCondition();
				 return this;
			 }
			 return null;
			 case OpTypes.OR : if (isIndexable(rangeVar)) {
				 return this;
			 }
			 return null;
			 default : return null;
		 }
	 }
	 boolean isSimpleBound() {
		 if (opType == OpTypes.IS_NULL) {
			 return true;
		 }
		 if (nodes[RIGHT] != null) {
			 if (nodes[RIGHT].opType == OpTypes.VALUE) {
				 return true;
			 }
			 if (nodes[RIGHT].opType == OpTypes.SQL_FUNCTION) {
				 if (((FunctionSQL) nodes[RIGHT]).isValueFunction()) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 boolean convertToSmaller() {
		 switch (opType) {
			 case OpTypes.GREATER_EQUAL : case OpTypes.GREATER : swapCondition();
			 return true;
			 case OpTypes.SMALLER_EQUAL : case OpTypes.SMALLER : return true;
			 default : return false;
		 }
	 }
	 void swapCondition() {
		 int i = OpTypes.EQUAL;
		 switch (opType) {
			 case OpTypes.GREATER_EQUAL : i = OpTypes.SMALLER_EQUAL;
			 break;
			 case OpTypes.SMALLER_EQUAL : i = OpTypes.GREATER_EQUAL;
			 break;
			 case OpTypes.SMALLER : i = OpTypes.GREATER;
			 break;
			 case OpTypes.GREATER : i = OpTypes.SMALLER;
			 break;
			 case OpTypes.NOT_DISTINCT : i = OpTypes.NOT_DISTINCT;
			 break;
			 case OpTypes.EQUAL : break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""ExpressionLogical"");
		 }
		 opType = i;
		 Expression e = nodes[LEFT];
		 nodes[LEFT] = nodes[RIGHT];
		 nodes[RIGHT] = e;
	 }
	 boolean reorderComparison(Session session) {
		 Expression colExpression = null;
		 Expression nonColExpression = null;
		 boolean left = false;
		 boolean replaceColumn = false;
		 int operation = 0;
		 if (nodes[LEFT].opType == OpTypes.ADD) {
			 operation = OpTypes.SUBTRACT;
			 left = true;
		 }
		 else if (nodes[LEFT].opType == OpTypes.SUBTRACT) {
			 operation = OpTypes.ADD;
			 left = true;
		 }
		 else if (nodes[RIGHT].opType == OpTypes.ADD) {
			 operation = OpTypes.SUBTRACT;
		 }
		 else if (nodes[RIGHT].opType == OpTypes.SUBTRACT) {
			 operation = OpTypes.ADD;
		 }
		 if (operation == 0) {
			 return false;
		 }
		 if (left) {
			 if (nodes[LEFT].nodes[LEFT].opType == OpTypes.COLUMN) {
				 colExpression = nodes[LEFT].nodes[LEFT];
				 nonColExpression = nodes[LEFT].nodes[RIGHT];
			 }
			 else if (nodes[LEFT].nodes[RIGHT].opType == OpTypes.COLUMN) {
				 replaceColumn = operation == OpTypes.ADD;
				 colExpression = nodes[LEFT].nodes[RIGHT];
				 nonColExpression = nodes[LEFT].nodes[LEFT];
			 }
		 }
		 else {
			 if (nodes[RIGHT].nodes[LEFT].opType == OpTypes.COLUMN) {
				 colExpression = nodes[RIGHT].nodes[LEFT];
				 nonColExpression = nodes[RIGHT].nodes[RIGHT];
			 }
			 else if (nodes[RIGHT].nodes[RIGHT].opType == OpTypes.COLUMN) {
				 replaceColumn = operation == OpTypes.ADD;
				 colExpression = nodes[RIGHT].nodes[RIGHT];
				 nonColExpression = nodes[RIGHT].nodes[LEFT];
			 }
		 }
		 if (colExpression == null) {
			 return false;
		 }
		 Expression otherExpression = left ? nodes[RIGHT] : nodes[LEFT];
		 ExpressionArithmetic newArg = null;
		 if (!replaceColumn) {
			 newArg = new ExpressionArithmetic(operation, otherExpression, nonColExpression);
			 newArg.resolveTypesForArithmetic(session);
		 }
		 if (left) {
			 if (replaceColumn) {
				 nodes[RIGHT] = colExpression;
				 nodes[LEFT].nodes[RIGHT] = otherExpression;
				 ((ExpressionArithmetic) nodes[LEFT]).resolveTypesForArithmetic( session);
			 }
			 else {
				 nodes[LEFT] = colExpression;
				 nodes[RIGHT] = newArg;
			 }
		 }
		 else {
			 if (replaceColumn) {
				 nodes[LEFT] = colExpression;
				 nodes[RIGHT].nodes[RIGHT] = otherExpression;
				 ((ExpressionArithmetic) nodes[RIGHT]) .resolveTypesForArithmetic(session);
			 }
			 else {
				 nodes[RIGHT] = colExpression;
				 nodes[LEFT] = newArg;
			 }
		 }
		 return true;
	 }
}",1,0,0,0
"public File getWebinc() {
	 return this.webinc;
 }",0,0,0,0
"private void processArgs(String[] args) {
	 String searchForThis = null;
	 boolean searchForFile = false;
	 PrintStream logTo = null;
	 boolean justPrintUsage = false;
	 boolean justPrintVersion = false;
	 boolean justPrintDiagnostics = false;
	 for (int i = 0;
	 i < args.length;
	 i++) {
		 String arg = args[i];
		 if (arg.equals(""-help"") || arg.equals(""-h"")) {
			 justPrintUsage = true;
		 }
		 else if (arg.equals(""-version"")) {
			 justPrintVersion = true;
		 }
		 else if (arg.equals(""-diagnostics"")) {
			 justPrintDiagnostics = true;
		 }
		 else if (arg.equals(""-quiet"") || arg.equals(""-q"")) {
			 msgOutputLevel = Project.MSG_WARN;
		 }
		 else if (arg.equals(""-verbose"") || arg.equals(""-v"")) {
			 msgOutputLevel = Project.MSG_VERBOSE;
		 }
		 else if (arg.equals(""-debug"") || arg.equals(""-d"")) {
			 msgOutputLevel = Project.MSG_DEBUG;
		 }
		 else if (arg.equals(""-noinput"")) {
			 allowInput = false;
		 }
		 else if (arg.equals(""-logfile"") || arg.equals(""-l"")) {
			 try {
				 File logFile = new File(args[i + 1]);
				 i++;
				 logTo = new PrintStream(new FileOutputStream(logFile));
				 isLogFileUsed = true;
			 }
			 catch (IOException ioe) {
				 String msg = ""Cannot write on the specified log file. "" + ""Make sure the path exists and you have write "" + ""permissions."";
				 throw new BuildException(msg);
			 }
			 catch (ArrayIndexOutOfBoundsException aioobe) {
				 String msg = ""You must specify a log file when "" + ""using the -log argument"";
				 throw new BuildException(msg);
			 }
		 }
		 else if (arg.equals(""-buildfile"") || arg.equals(""-file"") || arg.equals(""-f"")) {
			 i = handleArgBuildFile(args, i);
		 }
		 else if (arg.equals(""-listener"")) {
			 i = handleArgListener(args, i);
		 }
		 else if (arg.startsWith(""-D"")) {
			 i = handleArgDefine(args, i);
		 }
		 else if (arg.equals(""-logger"")) {
			 i = handleArgLogger(args, i);
		 }
		 else if (arg.equals(""-inputhandler"")) {
			 i = handleArgInputHandler(args, i);
		 }
		 else if (arg.equals(""-emacs"") || arg.equals(""-e"")) {
			 emacsMode = true;
		 }
		 else if (arg.equals(""-projecthelp"") || arg.equals(""-p"")) {
			 projectHelp = true;
		 }
		 else if (arg.equals(""-find"") || arg.equals(""-s"")) {
			 searchForFile = true;
			 if (i < args.length - 1) {
				 searchForThis = args[++i];
			 }
		 }
		 else if (arg.startsWith(""-propertyfile"")) {
			 i = handleArgPropertyFile(args, i);
		 }
		 else if (arg.equals(""-k"") || arg.equals(""-keep-going"")) {
			 keepGoingMode = true;
		 }
		 else if (arg.equals(""-nice"")) {
			 i = handleArgNice(args, i);
		 }
		 else if (LAUNCH_COMMANDS.contains(arg)) {
			 String msg = ""Ant's Main method is being handed "" + ""an option "" + arg + "" that is only for the launcher class."" + ""\nThis can be caused by a version mismatch between "" + ""the ant script/.bat file and Ant itself."";
			 throw new BuildException(msg);
		 }
		 else if (arg.equals(""-autoproxy"")) {
			 proxy = true;
		 }
		 else if (arg.startsWith(""-"")) {
			 String msg = ""Unknown argument: "" + arg;
			 System.err.println(msg);
			 printUsage();
			 throw new BuildException("""");
		 }
		 else {
			 targets.addElement(arg);
		 }
	 }
	 if (msgOutputLevel >= Project.MSG_VERBOSE || justPrintVersion) {
		 printVersion(msgOutputLevel);
	 }
	 if (justPrintUsage || justPrintVersion || justPrintDiagnostics) {
		 if (justPrintUsage) {
			 printUsage();
		 }
		 if (justPrintDiagnostics) {
			 Diagnostics.doReport(System.out, msgOutputLevel);
		 }
		 return;
	 }
	 if (buildFile == null) {
		 if (searchForFile) {
			 if (searchForThis != null) {
				 buildFile = findBuildFile(System.getProperty(""user.dir""), searchForThis);
				 if (buildFile == null) {
					 throw new BuildException(""Could not locate a build file!"");
				 }
			 }
			 else {
				 Iterator it = ProjectHelperRepository.getInstance().getHelpers();
				 do {
					 ProjectHelper helper = (ProjectHelper) it.next();
					 searchForThis = helper.getDefaultBuildFile();
					 if (msgOutputLevel >= Project.MSG_VERBOSE) {
						 System.out.println(""Searching the default build file: "" + searchForThis);
					 }
					 buildFile = findBuildFile(System.getProperty(""user.dir""), searchForThis);
				 }
				 while (buildFile == null && it.hasNext());
				 if (buildFile == null) {
					 throw new BuildException(""Could not locate a build file!"");
				 }
			 }
		 }
		 else {
			 Iterator it = ProjectHelperRepository.getInstance().getHelpers();
			 do {
				 ProjectHelper helper = (ProjectHelper) it.next();
				 buildFile = new File(helper.getDefaultBuildFile());
				 if (msgOutputLevel >= Project.MSG_VERBOSE) {
					 System.out.println(""Trying the default build file: "" + buildFile);
				 }
			 }
			 while (!buildFile.exists() && it.hasNext());
		 }
	 }
	 if (!buildFile.exists()) {
		 System.out.println(""Buildfile: "" + buildFile + "" does not exist!"");
		 throw new BuildException(""Build failed"");
	 }
	 if (buildFile.isDirectory()) {
		 File whatYouMeant = new File(buildFile, ""build.xml"");
		 if (whatYouMeant.isFile()) {
			 buildFile = whatYouMeant;
		 }
		 else {
			 System.out.println(""What? Buildfile: "" + buildFile + "" is a dir!"");
			 throw new BuildException(""Build failed"");
		 }
	 }
	 buildFile = FileUtils.getFileUtils().normalize(buildFile.getAbsolutePath());
	 loadPropertyFiles();
	 if (msgOutputLevel >= Project.MSG_INFO) {
		 System.out.println(""Buildfile: "" + buildFile);
	 }
	 if (logTo != null) {
		 out = logTo;
		 err = logTo;
		 System.setOut(out);
		 System.setErr(err);
	 }
	 readyToRun = true;
 }",0,0,1,0
"public int hashCode() {
	 int result = name != null ? name.hashCode() : 0;
	 result = 31 * result + (value != null ? value.hashCode() : 0);
	 result = 31 * result + (int)(timestamp ^ (timestamp >>> 32));
	 return result;
 }",0,0,0,0
"public class StreamRecords {
	public static ByteRecord rawBytes(Map<byte[], byte[]> raw) {
		return new ByteMapBackedRecord(null, RecordId.autoGenerate(), raw);
	}
	public static ByteBufferRecord rawBuffer(Map<ByteBuffer, ByteBuffer> raw) {
		return new ByteBufferMapBackedRecord(null, RecordId.autoGenerate(), raw);
	}
	public static StringRecord string(Map<String, String> raw) {
		return new StringMapBackedRecord(null, RecordId.autoGenerate(), raw);
	}
	public static <S, K, V> MapRecord<S, K, V> mapBacked(Map<K, V> map) {
		return new MapBackedRecord<>(null, RecordId.autoGenerate(), map);
	}
	public static <S, V> ObjectRecord<S, V> objectBacked(V value) {
		return new ObjectBackedRecord<>(null, RecordId.autoGenerate(), value);
	}
	public static RecordBuilder<?> newRecord() {
		return new RecordBuilder<>(null, RecordId.autoGenerate());
	}
	private StreamRecords() {
	}
	public static class RecordBuilder<S> {
		private RecordId id;
		private S stream;
		RecordBuilder( S stream, RecordId recordId) {
			this.stream = stream;
			this.id = recordId;
		}
		public <STREAM_KEY> RecordBuilder<STREAM_KEY> in(STREAM_KEY stream) {
			Assert.notNull(stream, ""Stream key must not be null"");
			return new RecordBuilder<>(stream, id);
		}
		public RecordBuilder<S> withId(String id) {
			return withId(RecordId.of(id));
		}
		public RecordBuilder<S> withId(RecordId id) {
			Assert.notNull(id, ""RecordId must not be null"");
			this.id = id;
			return this;
		}
		public <K, V> MapRecord<S, K, V> ofMap(Map<K, V> map) {
			return new MapBackedRecord<>(stream, id, map);
		}
		public StringRecord ofStrings(Map<String, String> map) {
			return new StringMapBackedRecord(ObjectUtils.nullSafeToString(stream), id, map);
		}
		public <V> ObjectRecord<S, V> ofObject(V value) {
			return new ObjectBackedRecord<>(stream, id, value);
		}
		public ByteRecord ofBytes(Map<byte[], byte[]> value) {
			return new ByteMapBackedRecord((byte[]) stream, id, value);
		}
		public ByteBufferRecord ofBuffer(Map<ByteBuffer, ByteBuffer> value) {
			ByteBuffer streamKey;
			if (stream instanceof ByteBuffer) {
				streamKey = (ByteBuffer) stream;
			}
			 else if (stream instanceof String) {
				streamKey = ByteUtils.getByteBuffer((String) stream);
			}
			 else if (stream instanceof byte[]) {
				streamKey = ByteBuffer.wrap((byte[]) stream);
			}
			 else {
				throw new IllegalArgumentException(String.format(""Stream key %s cannot be converted to byte buffer."", stream));
			}
			return new ByteBufferMapBackedRecord(streamKey, id, value);
		}
	}
	static class MapBackedRecord<S, K, V> implements MapRecord<S, K, V> {
		private S stream;
		private RecordId recordId;
		private final Map<K, V> kvMap;
		MapBackedRecord( S stream, RecordId recordId, Map<K, V> kvMap) {
			this.stream = stream;
			this.recordId = recordId;
			this.kvMap = kvMap;
		}
		public S getStream() {
			return stream;
		}
		public RecordId getId() {
			return recordId;
		}
		public Iterator<Entry<K, V>> iterator() {
			return kvMap.entrySet().iterator();
		}
		public Map<K, V> getValue() {
			return kvMap;
		}
		public MapRecord<S, K, V> withId(RecordId id) {
			return new MapBackedRecord<>(stream, id, this.kvMap);
		}
		public <S1> MapRecord<S1, K, V> withStreamKey(S1 key) {
			return new MapBackedRecord<>(key, recordId, this.kvMap);
		}
		public String toString() {
			return ""MapBackedRecord{
			"" + ""recordId="" + recordId + "", kvMap="" + kvMap + '}
			';
		}
		public boolean equals(Object o) {
			if (o == null) {
				return false;
			}
			if (this == o) {
				return true;
			}
			if (!ClassUtils.isAssignable(MapBackedRecord.class, o.getClass())) {
				return false;
			}
			MapBackedRecord<?, ?, ?> that = (MapBackedRecord<?, ?, ?>) o;
			if (!ObjectUtils.nullSafeEquals(this.stream, that.stream)) {
				return false;
			}
			if (!ObjectUtils.nullSafeEquals(this.recordId, that.recordId)) {
				return false;
			}
			return ObjectUtils.nullSafeEquals(this.kvMap, that.kvMap);
		}
		public int hashCode() {
			int result = stream != null ? stream.hashCode() : 0;
			result = 31 * result + recordId.hashCode();
			result = 31 * result + kvMap.hashCode();
			return result;
		}
	}
	static class ByteMapBackedRecord extends MapBackedRecord<byte[], byte[], byte[]> implements ByteRecord {
		ByteMapBackedRecord(byte[] stream, RecordId recordId, Map<byte[], byte[]> map) {
			super(stream, recordId, map);
		}
		public ByteMapBackedRecord withStreamKey(byte[] key) {
			return new ByteMapBackedRecord(key, getId(), getValue());
		}
		public ByteMapBackedRecord withId(RecordId id) {
			return new ByteMapBackedRecord(getStream(), id, getValue());
		}
	}
	static class ByteBufferMapBackedRecord extends MapBackedRecord<ByteBuffer, ByteBuffer, ByteBuffer>implements ByteBufferRecord {
		ByteBufferMapBackedRecord(ByteBuffer stream, RecordId recordId, Map<ByteBuffer, ByteBuffer> map) {
			super(stream, recordId, map);
		}
		public ByteBufferMapBackedRecord withStreamKey(ByteBuffer key) {
			return new ByteBufferMapBackedRecord(key, getId(), getValue());
		}
		public ByteBufferMapBackedRecord withId(RecordId id) {
			return new ByteBufferMapBackedRecord(getStream(), id, getValue());
		}
	}
	static class StringMapBackedRecord extends MapBackedRecord<String, String, String> implements StringRecord {
		StringMapBackedRecord(String stream, RecordId recordId, Map<String, String> stringStringMap) {
			super(stream, recordId, stringStringMap);
		}
		public StringRecord withStreamKey(String key) {
			return new StringMapBackedRecord(key, getId(), getValue());
		}
		public StringMapBackedRecord withId(RecordId id) {
			return new StringMapBackedRecord(getStream(), id, getValue());
		}
	}
	static class ObjectBackedRecord<S, V> implements ObjectRecord<S, V> {
		private S stream;
		private RecordId recordId;
		private final V value;
		ObjectBackedRecord( S stream, RecordId recordId, V value) {
			this.stream = stream;
			this.recordId = recordId;
			this.value = value;
		}
		public S getStream() {
			return stream;
		}
		public RecordId getId() {
			return recordId;
		}
		public V getValue() {
			return value;
		}
		public ObjectRecord<S, V> withId(RecordId id) {
			return new ObjectBackedRecord<>(stream, id, value);
		}
		public <SK> ObjectRecord<SK, V> withStreamKey(SK key) {
			return new ObjectBackedRecord<>(key, recordId, value);
		}
		public String toString() {
			return ""ObjectBackedRecord{
			"" + ""recordId="" + recordId + "", value="" + value + '}
			';
		}
	}
}",1,0,0,0
"public final static class Builder<A> {
	 private Supplier<A> initialValue;
	 private UnaryOperator<A> splitOperator = null;
	 private BinaryOperator<A> mergeOperator = null;
	 private Builder() {
	 }
	 public Builder initialValue(final Supplier<A> initialValue) {
		 this.initialValue = initialValue;
		 return this;
	 }
	 public Builder splitOperator(final UnaryOperator<A> splitOperator) {
		 this.splitOperator = splitOperator;
		 return this;
	 }
	 public Builder mergeOperator(final BinaryOperator<A> mergeOperator) {
		 this.mergeOperator = mergeOperator;
		 return this;
	 }
	 public SackStrategy create() {
		 return new SackStrategy(this.initialValue, this.splitOperator, this.mergeOperator);
	 }
 }",0,1,0,0
"void addEntry(int key, V value, int bucketIndex){
	table[bucketIndex] = new Entry<V>(key, value, table[bucketIndex]);
	if (size++ >= threshold){
		resize(2 * table.length);
	}
}",0,0,0,0
"public class MSVSSADD extends MSVSS {
	 private String localPath = null;
	 protected Commandline buildCmdLine() {
		 Commandline commandLine = new Commandline();
		 if (getLocalpath() == null) {
			 String msg = ""localPath attribute must be set!"";
			 throw new BuildException(msg, getLocation());
		 }
		 commandLine.setExecutable(getSSCommand());
		 commandLine.createArgument().setValue(COMMAND_ADD);
		 commandLine.createArgument().setValue(getLocalpath());
		 commandLine.createArgument().setValue(getAutoresponse());
		 commandLine.createArgument().setValue(getRecursive());
		 commandLine.createArgument().setValue(getWritable());
		 commandLine.createArgument().setValue(getLogin());
		 commandLine.createArgument().setValue(getComment());
		 return commandLine;
	 }
	 protected String getLocalpath() {
		 return localPath;
	 }
	 public void setRecursive(boolean recursive) {
		 super.setInternalRecursive(recursive);
	 }
	 public final void setWritable(boolean writable) {
		 super.setInternalWritable(writable);
	 }
	 public void setAutoresponse(String response) {
		 super.setInternalAutoResponse(response);
	 }
	 public void setComment(String comment) {
		 super.setInternalComment(comment);
	 }
	 public void setLocalpath(Path localPath) {
		 this.localPath = localPath.toString();
	 }
}",0,0,0,0
"public class TopicSubscription extends AbstractSubscription {
	 private static final Logger LOG = LoggerFactory.getLogger(TopicSubscription.class);
	 private static final AtomicLong CURSOR_NAME_COUNTER = new AtomicLong(0);
	 protected PendingMessageCursor matched;
	 protected final SystemUsage usageManager;
	 boolean singleDestination = true;
	 Destination destination;
	 private final Scheduler scheduler;
	 private int maximumPendingMessages = -1;
	 private MessageEvictionStrategy messageEvictionStrategy = new OldestMessageEvictionStrategy();
	 private int discarded;
	 private final Object matchedListMutex = new Object();
	 private int memoryUsageHighWaterMark = 95;
	 protected int maxProducersToAudit = 1024;
	 protected int maxAuditDepth = 1000;
	 protected boolean enableAudit = false;
	 protected ActiveMQMessageAudit audit;
	 protected boolean active = false;
	 protected boolean discarding = false;
	 private boolean useTopicSubscriptionInflightStats = true;
	 protected final Object dispatchLock = new Object();
	 protected final List<DispatchedNode> dispatched = new ArrayList<>();
	 public TopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {
		 super(broker, context, info);
		 this.usageManager = usageManager;
		 String matchedName = ""TopicSubscription:"" + CURSOR_NAME_COUNTER.getAndIncrement() + ""["" + info.getConsumerId().toString() + ""]"";
		 if (info.getDestination().isTemporary() || broker.getTempDataStore()==null ) {
			 this.matched = new VMPendingMessageCursor(false);
		 }
		 else {
			 this.matched = new FilePendingMessageCursor(broker,matchedName,false);
		 }
		 this.scheduler = broker.getScheduler();
	 }
	 public void init() throws Exception {
		 this.matched.setSystemUsage(usageManager);
		 this.matched.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
		 this.matched.start();
		 if (enableAudit) {
			 audit= new ActiveMQMessageAudit(maxAuditDepth, maxProducersToAudit);
		 }
		 this.active=true;
	 }
	 public void add(MessageReference node) throws Exception {
		 if (isDuplicate(node)) {
			 return;
		 }
		 node = new IndirectMessageReference(node.getMessage());
		 getSubscriptionStatistics().getEnqueues().increment();
		 synchronized (matchedListMutex) {
			 if (discarding) return;
			 if (!isFull() && matched.isEmpty()) {
				 dispatch(node);
				 setSlowConsumer(false);
			 }
			 else {
				 if (info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize()) {
					 if (!isSlowConsumer()) {
						 LOG.warn(""{
						}
						: has twice its prefetch limit pending, without an ack;
						 it appears to be slow"", toString());
						 setSlowConsumer(true);
						 for (Destination dest: destinations) {
							 dest.slowConsumer(getContext(), this);
						 }
					 }
				 }
				 if (maximumPendingMessages != 0) {
					 boolean warnedAboutWait = false;
					 while (active) {
						 while (matched.isFull()) {
							 if (getContext().getStopping().get()) {
								 LOG.warn(""{
								}
								: stopped waiting for space in pendingMessage cursor for: {
								}
								"", toString(), node.getMessageId());
								 getSubscriptionStatistics().getEnqueues().decrement();
								 return;
							 }
							 if (!warnedAboutWait) {
								 LOG.info(""{
								}
								: Pending message cursor [{
								}
								] is full, temp usag ({
								}
								%) or memory usage ({
								}
								%) limit reached, blocking message add() pending the release of resources."", new Object[]{
								 toString(), matched, matched.getSystemUsage().getTempUsage().getPercentUsage(), matched.getSystemUsage().getMemoryUsage().getPercentUsage() }
								);
								 warnedAboutWait = true;
							 }
							 matchedListMutex.wait(20);
						 }
						 if (matched.tryAddMessageLast(node, 10)) {
							 break;
						 }
					 }
					 if (maximumPendingMessages > 0) {
						 int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();
						 if (maximumPendingMessages > 0 && maximumPendingMessages < max) {
							 max = maximumPendingMessages;
						 }
						 if (!matched.isEmpty() && matched.size() > max) {
							 removeExpiredMessages();
						 }
						 while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {
							 int pageInSize = matched.size() - maximumPendingMessages;
							 pageInSize = Math.max(1000, pageInSize);
							 LinkedList<MessageReference> list = null;
							 MessageReference[] oldMessages=null;
							 synchronized(matched){
								 list = matched.pageInList(pageInSize);
								 oldMessages = messageEvictionStrategy.evictMessages(list);
								 for (MessageReference ref : list) {
									 ref.decrementReferenceCount();
								 }
							 }
							 int messagesToEvict = 0;
							 if (oldMessages != null){
								 messagesToEvict = oldMessages.length;
								 for (int i = 0;
								 i < messagesToEvict;
								 i++) {
									 MessageReference oldMessage = oldMessages[i];
									 discard(oldMessage);
								 }
							 }
							 if (messagesToEvict == 0) {
								 LOG.warn(""No messages to evict returned for {
								}
								 from eviction strategy: {
								}
								 out of {
								}
								 candidates"", new Object[]{
								 destination, messageEvictionStrategy, list.size() }
								);
								 break;
							 }
						 }
					 }
					 dispatchMatched();
				 }
			 }
		 }
	 }
	 private boolean isDuplicate(MessageReference node) {
		 boolean duplicate = false;
		 if (enableAudit && audit != null) {
			 duplicate = audit.isDuplicate(node);
			 if (LOG.isDebugEnabled()) {
				 if (duplicate) {
					 LOG.debug(""{
					}
					, ignoring duplicate add: {
					}
					"", this, node.getMessageId());
				 }
			 }
		 }
		 return duplicate;
	 }
	 protected void removeExpiredMessages() throws IOException {
		 try {
			 matched.reset();
			 while (matched.hasNext()) {
				 MessageReference node = matched.next();
				 node.decrementReferenceCount();
				 if (node.isExpired()) {
					 matched.remove();
					 node.decrementReferenceCount();
					 if (broker.isExpired(node)) {
						 ((Destination) node.getRegionDestination()).getDestinationStatistics().getExpired().increment();
						 broker.messageExpired(getContext(), node, this);
					 }
					 break;
				 }
			 }
		 }
		 finally {
			 matched.release();
		 }
	 }
	 public void processMessageDispatchNotification(MessageDispatchNotification mdn) {
		 synchronized (matchedListMutex) {
			 try {
				 matched.reset();
				 while (matched.hasNext()) {
					 MessageReference node = matched.next();
					 node.decrementReferenceCount();
					 if (node.getMessageId().equals(mdn.getMessageId())) {
						 synchronized(dispatchLock) {
							 matched.remove();
							 getSubscriptionStatistics().getDispatched().increment();
							 if (isUseTopicSubscriptionInflightStats()) {
								 dispatched.add(new DispatchedNode(node));
								 getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
							 }
							 node.decrementReferenceCount();
						 }
						 break;
					 }
				 }
			 }
			 finally {
				 matched.release();
			 }
		 }
	 }
	 public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
		 super.acknowledge(context, ack);
		 if (ack.isStandardAck()) {
			 updateStatsOnAck(context, ack);
		 }
		 else if (ack.isPoisonAck()) {
			 if (ack.isInTransaction()) {
				 throw new JMSException(""Poison ack cannot be transacted: "" + ack);
			 }
			 updateStatsOnAck(context, ack);
			 contractPrefetchExtension(ack.getMessageCount());
		 }
		 else if (ack.isIndividualAck()) {
			 updateStatsOnAck(context, ack);
			 if (ack.isInTransaction()) {
				 expandPrefetchExtension(1);
			 }
		 }
		 else if (ack.isExpiredAck()) {
			 updateStatsOnAck(ack);
			 contractPrefetchExtension(ack.getMessageCount());
		 }
		 else if (ack.isDeliveredAck()) {
			 expandPrefetchExtension(ack.getMessageCount());
		 }
		 else if (ack.isRedeliveredAck()) {
			 return;
		 }
		 else {
			 throw new JMSException(""Invalid acknowledgment: "" + ack);
		 }
		 dispatchMatched();
	 }
	 private void updateStatsOnAck(final ConnectionContext context, final MessageAck ack) {
		 if (context.isInTransaction()) {
			 context.getTransaction().addSynchronization(new Synchronization() {
				 public void afterRollback() {
					 contractPrefetchExtension(ack.getMessageCount());
				 }
				 public void afterCommit() throws Exception {
					 contractPrefetchExtension(ack.getMessageCount());
					 updateStatsOnAck(ack);
					 dispatchMatched();
				 }
			 }
			);
		 }
		 else {
			 updateStatsOnAck(ack);
		 }
	 }
	 public Response pullMessage(ConnectionContext context, final MessagePull pull) throws Exception {
		 if (getPrefetchSize() == 0) {
			 final long currentDispatchedCount = getSubscriptionStatistics().getDispatched().getCount();
			 prefetchExtension.set(pull.getQuantity());
			 dispatchMatched();
			 if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || pull.isAlwaysSignalDone()) {
				 if (pull.getTimeout() == -1) {
					 dispatch(null);
					 prefetchExtension.set(0);
				 }
				 if (pull.getTimeout() > 0) {
					 scheduler.executeAfterDelay(new Runnable() {
						 public void run() {
							 pullTimeout(currentDispatchedCount, pull.isAlwaysSignalDone());
						 }
					 }
					, pull.getTimeout());
				 }
			 }
		 }
		 return null;
	 }
	 private final void pullTimeout(long currentDispatchedCount, boolean alwaysSendDone) {
		 synchronized (matchedListMutex) {
			 if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || alwaysSendDone) {
				 try {
					 dispatch(null);
				 }
				 catch (Exception e) {
					 context.getConnection().serviceException(e);
				 }
				 finally {
					 prefetchExtension.set(0);
				 }
			 }
		 }
	 }
	 private void updateStatsOnAck(final MessageAck ack) {
		 if (isUseTopicSubscriptionInflightStats()) {
			 synchronized(dispatchLock) {
				 boolean inAckRange = false;
				 List<DispatchedNode> removeList = new ArrayList<>();
				 for (final DispatchedNode node : dispatched) {
					 MessageId messageId = node.getMessageId();
					 if (ack.getFirstMessageId() == null || ack.getFirstMessageId().equals(messageId)) {
						 inAckRange = true;
					 }
					 if (inAckRange) {
						 removeList.add(node);
						 if (ack.getLastMessageId().equals(messageId)) {
							 break;
						 }
					 }
				 }
				 for (final DispatchedNode node : removeList) {
					 dispatched.remove(node);
					 getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
					 final Destination destination = node.getDestination();
					 incrementStatsOnAck(destination, ack, 1);
					 if (!ack.isInTransaction()) {
						 contractPrefetchExtension(1);
					 }
				 }
			 }
		 }
		 else {
			 if (singleDestination && destination != null) {
				 incrementStatsOnAck(destination, ack, ack.getMessageCount());
			 }
			 if (!ack.isInTransaction()) {
				 contractPrefetchExtension(ack.getMessageCount());
			 }
		 }
	 }
	 private void incrementStatsOnAck(final Destination destination, final MessageAck ack, final int count) {
		 getSubscriptionStatistics().getDequeues().add(count);
		 destination.getDestinationStatistics().getDequeues().add(count);
		 destination.getDestinationStatistics().getInflight().subtract(count);
		 if (info.isNetworkSubscription()) {
			 destination.getDestinationStatistics().getForwards().add(count);
		 }
		 if (ack.isExpiredAck()) {
			 destination.getDestinationStatistics().getExpired().add(count);
		 }
	 }
	 public int countBeforeFull() {
		 return getPrefetchSize() == 0 ? prefetchExtension.get() : info.getPrefetchSize() + prefetchExtension.get() - getDispatchedQueueSize();
	 }
	 public int getPendingQueueSize() {
		 return matched();
	 }
	 public long getPendingMessageSize() {
		 synchronized (matchedListMutex) {
			 return matched.messageSize();
		 }
	 }
	 public int getDispatchedQueueSize() {
		 return (int)(getSubscriptionStatistics().getDispatched().getCount() - getSubscriptionStatistics().getDequeues().getCount());
	 }
	 public int getMaximumPendingMessages() {
		 return maximumPendingMessages;
	 }
	 public long getDispatchedCounter() {
		 return getSubscriptionStatistics().getDispatched().getCount();
	 }
	 public long getEnqueueCounter() {
		 return getSubscriptionStatistics().getEnqueues().getCount();
	 }
	 public long getDequeueCounter() {
		 return getSubscriptionStatistics().getDequeues().getCount();
	 }
	 public int discarded() {
		 synchronized (matchedListMutex) {
			 return discarded;
		 }
	 }
	 public int matched() {
		 synchronized (matchedListMutex) {
			 return matched.size();
		 }
	 }
	 public void setMaximumPendingMessages(int maximumPendingMessages) {
		 this.maximumPendingMessages = maximumPendingMessages;
	 }
	 public MessageEvictionStrategy getMessageEvictionStrategy() {
		 return messageEvictionStrategy;
	 }
	 public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
		 this.messageEvictionStrategy = messageEvictionStrategy;
	 }
	 public int getMaxProducersToAudit() {
		 return maxProducersToAudit;
	 }
	 public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
		 this.maxProducersToAudit = maxProducersToAudit;
		 if (audit != null) {
			 audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
		 }
	 }
	 public int getMaxAuditDepth() {
		 return maxAuditDepth;
	 }
	 public synchronized void setMaxAuditDepth(int maxAuditDepth) {
		 this.maxAuditDepth = maxAuditDepth;
		 if (audit != null) {
			 audit.setAuditDepth(maxAuditDepth);
		 }
	 }
	 public boolean isEnableAudit() {
		 return enableAudit;
	 }
	 public synchronized void setEnableAudit(boolean enableAudit) {
		 this.enableAudit = enableAudit;
		 if (enableAudit && audit == null) {
			 audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
		 }
	 }
	 public boolean isFull() {
		 return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : getDispatchedQueueSize() - prefetchExtension.get() >= info.getPrefetchSize();
	 }
	 public int getInFlightSize() {
		 return getDispatchedQueueSize();
	 }
	 public boolean isLowWaterMark() {
		 return (getDispatchedQueueSize() - prefetchExtension.get()) <= (info.getPrefetchSize() * .4);
	 }
	 public boolean isHighWaterMark() {
		 return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);
	 }
	 public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
		 this.memoryUsageHighWaterMark = memoryUsageHighWaterMark;
	 }
	 public int getMemoryUsageHighWaterMark() {
		 return this.memoryUsageHighWaterMark;
	 }
	 public SystemUsage getUsageManager() {
		 return this.usageManager;
	 }
	 public PendingMessageCursor getMatched() {
		 return this.matched;
	 }
	 public void setMatched(PendingMessageCursor matched) {
		 this.matched = matched;
	 }
	 public void updateConsumerPrefetch(int newPrefetch) {
		 if (context != null && context.getConnection() != null && context.getConnection().isManageable()) {
			 ConsumerControl cc = new ConsumerControl();
			 cc.setConsumerId(info.getConsumerId());
			 cc.setPrefetch(newPrefetch);
			 context.getConnection().dispatchAsync(cc);
		 }
	 }
	 private void dispatchMatched() throws IOException {
		 synchronized (matchedListMutex) {
			 if (!matched.isEmpty() && !isFull()) {
				 try {
					 matched.reset();
					 while (matched.hasNext() && !isFull()) {
						 MessageReference message = matched.next();
						 message.decrementReferenceCount();
						 matched.remove();
						 if (message.isExpired()) {
							 discard(message);
							 continue;
						 }
						 dispatch(message);
					 }
				 }
				 finally {
					 matched.release();
				 }
			 }
		 }
	 }
	 private void dispatch(final MessageReference node) throws IOException {
		 Message message = node != null ? node.getMessage() : null;
		 if (node != null) {
			 node.incrementReferenceCount();
		 }
		 MessageDispatch md = new MessageDispatch();
		 md.setMessage(message);
		 md.setConsumerId(info.getConsumerId());
		 if (node != null) {
			 md.setDestination(((Destination)node.getRegionDestination()).getActiveMQDestination());
			 synchronized(dispatchLock) {
				 getSubscriptionStatistics().getDispatched().increment();
				 if (isUseTopicSubscriptionInflightStats()) {
					 dispatched.add(new DispatchedNode(node));
					 getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
				 }
			 }
			 if (singleDestination) {
				 if (destination == null) {
					 destination = (Destination)node.getRegionDestination();
				 }
				 else {
					 if (destination != node.getRegionDestination()) {
						 singleDestination = false;
					 }
				 }
			 }
			 if (getPrefetchSize() == 0) {
				 decrementPrefetchExtension(1);
			 }
		 }
		 if (info.isDispatchAsync()) {
			 if (node != null) {
				 md.setTransmitCallback(new TransmitCallback() {
					 public void onSuccess() {
						 Destination regionDestination = (Destination) node.getRegionDestination();
						 regionDestination.getDestinationStatistics().getDispatched().increment();
						 regionDestination.getDestinationStatistics().getInflight().increment();
						 node.decrementReferenceCount();
					 }
					 public void onFailure() {
						 Destination regionDestination = (Destination) node.getRegionDestination();
						 regionDestination.getDestinationStatistics().getDispatched().increment();
						 regionDestination.getDestinationStatistics().getInflight().increment();
						 node.decrementReferenceCount();
					 }
				 }
				);
			 }
			 context.getConnection().dispatchAsync(md);
		 }
		 else {
			 context.getConnection().dispatchSync(md);
			 if (node != null) {
				 Destination regionDestination = (Destination) node.getRegionDestination();
				 regionDestination.getDestinationStatistics().getDispatched().increment();
				 regionDestination.getDestinationStatistics().getInflight().increment();
				 node.decrementReferenceCount();
			 }
		 }
	 }
	 private void discard(MessageReference message) {
		 discarding = true;
		 try {
			 message.decrementReferenceCount();
			 matched.remove(message);
			 discarded++;
			 if (destination != null) {
				 destination.getDestinationStatistics().getDequeues().increment();
			 }
			 LOG.debug(""{
			}
			, discarding message {
			}
			"", this, message);
			 Destination dest = (Destination) message.getRegionDestination();
			 if (dest != null) {
				 dest.messageDiscarded(getContext(), this, message);
			 }
			 broker.getRoot().sendToDeadLetterQueue(getContext(), message, this, new Throwable(""TopicSubDiscard. ID:"" + info.getConsumerId()));
		 }
		 finally {
			 discarding = false;
		 }
	 }
	 public String toString() {
		 return ""TopicSubscription:"" + "" consumer="" + info.getConsumerId() + "", destinations="" + destinations.size() + "", dispatched="" + getDispatchedQueueSize() + "", delivered="" + getDequeueCounter() + "", matched="" + matched() + "", discarded="" + discarded() + "", prefetchExtension="" + prefetchExtension.get() + "", usePrefetchExtension="" + isUsePrefetchExtension();
	 }
	 public void destroy() {
		 this.active=false;
		 synchronized (matchedListMutex) {
			 try {
				 matched.destroy();
			 }
			 catch (Exception e) {
				 LOG.warn(""Failed to destroy cursor"", e);
			 }
		 }
		 setSlowConsumer(false);
		 synchronized(dispatchLock) {
			 dispatched.clear();
		 }
	 }
	 public int getPrefetchSize() {
		 return info.getPrefetchSize();
	 }
	 public void setPrefetchSize(int newSize) {
		 info.setPrefetchSize(newSize);
		 try {
			 dispatchMatched();
		 }
		 catch(Exception e) {
			 LOG.trace(""Caught exception on dispatch after prefetch size change."");
		 }
	 }
	 public boolean isUseTopicSubscriptionInflightStats() {
		 return useTopicSubscriptionInflightStats;
	 }
	 public void setUseTopicSubscriptionInflightStats(boolean useTopicSubscriptionInflightStats) {
		 this.useTopicSubscriptionInflightStats = useTopicSubscriptionInflightStats;
	 }
	 private static class DispatchedNode {
		 private final int size;
		 private final MessageId messageId;
		 private final Destination destination;
		 public DispatchedNode(final MessageReference node) {
			 super();
			 this.size = node.getSize();
			 this.messageId = node.getMessageId();
			 this.destination = node.getRegionDestination() instanceof Destination ? ((Destination)node.getRegionDestination()) : null;
		 }
		 public long getSize() {
			 return size;
		 }
		 public MessageId getMessageId() {
			 return messageId;
		 }
		 public Destination getDestination() {
			 return destination;
		 }
	 }
}",1,0,0,0
"private void addShutdownHook() {
	 if (addShutdownHookMethod != null && !running) {
		 destroyProcessThread = new ProcessDestroyerImpl();
		 Object[] args = {
		destroyProcessThread}
		;
		 try {
			 addShutdownHookMethod.invoke(Runtime.getRuntime(), args);
			 added = true;
		 }
		 catch (IllegalAccessException e) {
			 e.printStackTrace();
		 }
		 catch (InvocationTargetException e) {
			 Throwable t = e.getTargetException();
			 if (t != null && t.getClass() == IllegalStateException.class) {
				 running = true;
			 }
			 else {
				 e.printStackTrace();
			 }
		 }
	 }
 }",0,0,0,0
"public void setEncoding(final String encoding) {
	 this.encoding = encoding;
	 this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
	 useUTF8Flag &= ZipEncodingHelper.isUTF8(encoding);
 }",0,0,0,0
"public void createDemoNetwork() {
	int productsCount = 20;
	int typesCount = 3;
	int brandsCount = 3;
	int priceCount = 3;
	int promoCount = 3;
	this.setNetworkType(NeuralNetworkType.RECOMMENDER);
	NeuronProperties neuronProperties = new NeuronProperties();
	neuronProperties.setProperty(""transferFunction"", TransferFunctionType.RAMP);
	neuronProperties.setProperty(""transferFunction.slope"", new Double(1));
	 Layer inputLayer = LayerFactory.createLayer(productsCount,neuronProperties);
	this.addLayer(inputLayer);
	createProductLabels(inputLayer);
	Layer typeLayer = LayerFactory.createLayer(typesCount,neuronProperties);
	createTypeLabels(typeLayer);
	this.addLayer(typeLayer);
	Layer brandLayer = LayerFactory.createLayer(brandsCount,neuronProperties);
	createBrandLabels(brandLayer);
	this.addLayer(brandLayer);
	Layer priceLayer = LayerFactory.createLayer(priceCount, neuronProperties);
	createPriceLabels(priceLayer);
	this.addLayer(priceLayer);
	Layer promoLayer = LayerFactory.createLayer(promoCount, neuronProperties);
	createPromoLabels(promoLayer);
	this.addLayer(promoLayer);
	Layer outputLayer = LayerFactory.createLayer(productsCount,neuronProperties);
	this.addLayer(outputLayer);
	createProductLabels(outputLayer);
	createTypeConnections();
	createBrandConnections();
	createPriceConnections();
	createPromoConnections();
	for(Neuron neuron : this.getLayerAt(outputLayerIdx).getNeurons()) {
		neuron.addInputConnection(neuron, 1);
	}
	NeuralNetworkFactory.setDefaultIO(this);
	this.setLearningRule(new UnsupervisedHebbianLearning());
}",0,0,1,0
"abstract class RTFParser extends AbstractFilter{
	 public int level;
	 private int state;
	 private StringBuffer currentCharacters;
	 private String pendingKeyword;
	 private int pendingCharacter;
	 private long binaryBytesLeft;
	 ByteArrayOutputStream binaryBuf;
	 private boolean[] savedSpecials;
	 protected PrintStream warnings;
	 private final int S_text = 0;
	 private final int S_backslashed = 1;
	 private final int S_token = 2;
	 private final int S_parameter = 3;
	 private final int S_aftertick = 4;
	 private final int S_aftertickc = 5;
	 private final int S_inblob = 6;
	 public abstract boolean handleKeyword(String keyword);
	 public abstract boolean handleKeyword(String keyword, int parameter);
	 public abstract void handleText(String text);
	 public void handleText(char ch) {
		 handleText(String.valueOf(ch));
	 }
	 public abstract void handleBinaryBlob(byte[] data);
	 public abstract void begingroup();
	 public abstract void endgroup();
	 static final boolean[] rtfSpecialsTable;
	 static {
		 rtfSpecialsTable = noSpecialsTable.clone();
		 rtfSpecialsTable['\n'] = true;
		 rtfSpecialsTable['\r'] = true;
		 rtfSpecialsTable['{
			'] = true;
		 rtfSpecialsTable['}
		'] = true;
		 rtfSpecialsTable['\\'] = true;
	 }
	 public RTFParser() {
		 currentCharacters = new StringBuffer();
		 state = S_text;
		 pendingKeyword = null;
		 level = 0;
		 specialsTable = rtfSpecialsTable;
	 }
	 public void writeSpecial(int b) throws IOException {
		 write((char)b);
	 }
	 protected void warning(String s) {
		 if (warnings != null) {
			 warnings.println(s);
		 }
	 }
	 public void write(String s) throws IOException {
		 if (state != S_text) {
			 int index = 0;
			 int length = s.length();
			 while(index < length && state != S_text) {
				 write(s.charAt(index));
				 index ++;
			 }
			 if(index >= length) return;
			 s = s.substring(index);
		 }
		 if (currentCharacters.length() > 0) currentCharacters.append(s);
		 else handleText(s);
	 }
	 public void write(char ch) throws IOException {
		 boolean ok;
		 switch (state) {
			 case S_text: if (ch == '\n' || ch == '\r') {
				 break;
			 }
			 else if (ch == '{
				') {
					 if (currentCharacters.length() > 0) {
						 handleText(currentCharacters.toString());
						 currentCharacters = new StringBuffer();
					 }
					 level ++;
					 begingroup();
				 }
			 else if(ch == '}
			') {
				 if (currentCharacters.length() > 0) {
					 handleText(currentCharacters.toString());
					 currentCharacters = new StringBuffer();
				 }
				 if (level == 0) throw new IOException(""Too many close-groups in RTF text"");
				 endgroup();
				 level --;
			 }
			 else if(ch == '\\') {
				 if (currentCharacters.length() > 0) {
					 handleText(currentCharacters.toString());
					 currentCharacters = new StringBuffer();
				 }
				 state = S_backslashed;
			 }
			 else {
				 currentCharacters.append(ch);
			 }
			 break;
			 case S_backslashed: if (ch == '\'') {
				 state = S_aftertick;
				 break;
			 }
			 if (!Character.isLetter(ch)) {
				 char[] newstring = new char[1];
				 newstring[0] = ch;
				 if (!handleKeyword(new String(newstring))) {
					 warning(""Unknown keyword: "" + newstring + "" ("" + (byte)ch + "")"");
				 }
				 state = S_text;
				 pendingKeyword = null;
				 break;
			 }
			 state = S_token;
			 case S_token: if (Character.isLetter(ch)) {
				 currentCharacters.append(ch);
			 }
			 else {
				 pendingKeyword = currentCharacters.toString();
				 currentCharacters = new StringBuffer();
				 if (Character.isDigit(ch) || (ch == '-')) {
					 state = S_parameter;
					 currentCharacters.append(ch);
				 }
				 else {
					 ok = handleKeyword(pendingKeyword);
					 if (!ok) warning(""Unknown keyword: "" + pendingKeyword);
					 pendingKeyword = null;
					 state = S_text;
					 if (!Character.isWhitespace(ch)) write(ch);
				 }
			 }
			 break;
			 case S_parameter: if (Character.isDigit(ch)) {
				 currentCharacters.append(ch);
			 }
			 else {
				 if (pendingKeyword.equals(""bin"")) {
					 long parameter = Long.parseLong(currentCharacters.toString());
					 pendingKeyword = null;
					 state = S_inblob;
					 binaryBytesLeft = parameter;
					 if (binaryBytesLeft > Integer.MAX_VALUE) binaryBuf = new ByteArrayOutputStream(Integer.MAX_VALUE);
					 else binaryBuf = new ByteArrayOutputStream((int)binaryBytesLeft);
					 savedSpecials = specialsTable;
					 specialsTable = allSpecialsTable;
					 break;
				 }
				 int parameter = Integer.parseInt(currentCharacters.toString());
				 ok = handleKeyword(pendingKeyword, parameter);
				 if (!ok) warning(""Unknown keyword: "" + pendingKeyword + "" (param "" + currentCharacters + "")"");
				 pendingKeyword = null;
				 currentCharacters = new StringBuffer();
				 state = S_text;
				 if (!Character.isWhitespace(ch)) write(ch);
			 }
			 break;
			 case S_aftertick: if (Character.digit(ch, 16) == -1) state = S_text;
			 else {
				 pendingCharacter = Character.digit(ch, 16);
				 state = S_aftertickc;
			 }
			 break;
			 case S_aftertickc: state = S_text;
			 if (Character.digit(ch, 16) != -1) {
				 pendingCharacter = pendingCharacter * 16 + Character.digit(ch, 16);
				 ch = translationTable[pendingCharacter];
				 if (ch != 0) handleText(ch);
			 }
			 break;
			 case S_inblob: binaryBuf.write(ch);
			 binaryBytesLeft --;
			 if (binaryBytesLeft == 0) {
				 state = S_text;
				 specialsTable = savedSpecials;
				 savedSpecials = null;
				 handleBinaryBlob(binaryBuf.toByteArray());
				 binaryBuf = null;
			 }
		 }
	 }
	 public void flush() throws IOException {
		 super.flush();
		 if (state == S_text && currentCharacters.length() > 0) {
			 handleText(currentCharacters.toString());
			 currentCharacters = new StringBuffer();
		 }
	 }
	 public void close() throws IOException {
		 flush();
		 if (state != S_text || level > 0) {
			 warning(""Truncated RTF file."");
			 while (level > 0) {
				 endgroup();
				 level --;
			 }
		 }
		 super.close();
	 }
}",1,0,0,0
"public class ConnectionFactoryLoader {
	 public static final String module = ConnectionFactoryLoader.class.getName();
	 private static final ConnectionFactory connFactory = createConnectionFactory();
	 private static ConnectionFactory createConnectionFactory() {
		 ConnectionFactory instance = null;
		 try {
			 if (EntityConfig.getInstance().getConnectionFactory() == null) {
				 return null;
			 }
			 String className = EntityConfig.getInstance().getConnectionFactory().getClassName();
			 if (className == null) {
				 throw new IllegalStateException(""Could not find connection factory class name definition"");
			 }
			 ClassLoader loader = Thread.currentThread().getContextClassLoader();
			 Class<?> tfClass = loader.loadClass(className);
			 instance = (ConnectionFactory) tfClass.newInstance();
		 }
		 catch (ClassNotFoundException cnfe) {
			 Debug.logError(cnfe, ""Could not find connection factory class"", module);
		 }
		 catch (Exception e) {
			 Debug.logError(e, ""Unable to instantiate the connection factory"", module);
		 }
		 return instance;
	 }
	 public static ConnectionFactory getInstance() {
		 if (connFactory == null) {
			 throw new IllegalStateException(""The Connection Factory is not initialized."");
		 }
		 return connFactory;
	 }
}",0,0,0,0
"public void writeEdge(I srcId, V srcValue, Edge<I, E> edge) throws IOException, InterruptedException {
	 if (txcounter == txsize) {
		 txcounter = 0;
		 isFirstElement = true;
		 stopConnection();
		 startConnection();
	 }
	 try {
		 JSONObject jsonEdge;
		 String suffix;
		 jsonEdge = getEdge(srcId, srcValue, edge);
		 if (isFirstElement) {
			 isFirstElement = false;
			 suffix = """";
		 }
		 else {
			 suffix = "","";
		 }
		 rexsterBufferedStream.write(suffix + jsonEdge);
		 txcounter += 1;
	 }
	 catch (JSONException e) {
		 throw new InterruptedException(""Error writing the edge: "" + e.getMessage());
	 }
 }",0,0,1,0
"public BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {
	this.requestContext = requestContext;
	this.path = path;
	this.htmlEscape = htmlEscape;
	String beanName;
	int dotPos = path.indexOf('.');
	if (dotPos == -1) {
		beanName = path;
		this.expression = null;
	}
	else {
		beanName = path.substring(0, dotPos);
		this.expression = path.substring(dotPos + 1);
	}
	this.errors = requestContext.getErrors(beanName, false);
	if (this.errors != null) {
		if (this.expression != null) {
			if (""*"".equals(this.expression)) {
				this.objectErrors = this.errors.getAllErrors();
			}
			else if (this.expression.endsWith(""*"")) {
				this.objectErrors = this.errors.getFieldErrors(this.expression);
			}
			else {
				this.objectErrors = this.errors.getFieldErrors(this.expression);
				this.value = this.errors.getFieldValue(this.expression);
				this.valueType = this.errors.getFieldType(this.expression);
				if (this.errors instanceof BindingResult) {
					this.bindingResult = (BindingResult) this.errors;
					this.actualValue = this.bindingResult.getRawFieldValue(this.expression);
					this.editor = this.bindingResult.findEditor(this.expression, null);
				}
				else {
					this.actualValue = this.value;
				}
			}
		}
		else {
			this.objectErrors = this.errors.getGlobalErrors();
		}
		this.errorCodes = initErrorCodes(this.objectErrors);
	}
	else {
		Object target = requestContext.getModelObject(beanName);
		if (target == null) {
			throw new IllegalStateException(""Neither BindingResult nor plain target object for bean name '"" +beanName + ""' available as request attribute"");
		}
		if (this.expression != null && !""*"".equals(this.expression) && !this.expression.endsWith(""*"")) {
			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);
			this.value = bw.getPropertyValue(this.expression);
			this.valueType = bw.getPropertyType(this.expression);
			this.actualValue = this.value;
		}
		this.errorCodes = new String[0];
		this.errorMessages = new String[0];
	}
	if (htmlEscape && this.value instanceof String) {
		this.value = HtmlUtils.htmlEscape((String) this.value);
	}
}",0,0,1,0
"public void fetch(Path segment, int threads) throws IOException {
	 checkConfiguration();
	 SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
	 long start = System.currentTimeMillis();
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""Fetcher: starting at "" + sdf.format(start));
		 LOG.info(""Fetcher: segment: "" + segment);
	 }
	 long timelimit = getConf().getLong(""fetcher.timelimit.mins"", -1);
	 if (timelimit != -1) {
		 timelimit = System.currentTimeMillis() + (timelimit * 60 * 1000);
		 LOG.info(""Fetcher Timelimit set for : "" + timelimit);
		 getConf().setLong(""fetcher.timelimit"", timelimit);
	 }
	 JobConf job = new NutchJob(getConf());
	 job.setJobName(""fetch "" + segment);
	 job.setInt(""fetcher.threads.fetch"", threads);
	 job.set(Nutch.SEGMENT_NAME_KEY, segment.getName());
	 job.setSpeculativeExecution(false);
	 FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.GENERATE_DIR_NAME));
	 job.setInputFormat(InputFormat.class);
	 job.setMapRunnerClass(Fetcher.class);
	 FileOutputFormat.setOutputPath(job, segment);
	 job.setOutputFormat(FetcherOutputFormat.class);
	 job.setOutputKeyClass(Text.class);
	 job.setOutputValueClass(NutchWritable.class);
	 JobClient.runJob(job);
	 long end = System.currentTimeMillis();
	 LOG.info(""Fetcher: finished at "" + sdf.format(end) + "", elapsed: "" + TimingUtil.elapsedTime(start, end));
 }",0,0,0,0
"protected void onRequestTargetSet(IRequestTarget requestTarget){
}",0,0,0,0
"public Resource getResource(String name) {
	 return new FileResource(toDir, name);
 }",0,0,0,0
"public class TraversalFieldAccessorFactory implements FieldAccessorFactory<NodeBacked> {
	 public boolean accept(final Neo4JPersistentProperty f) {
		 final GraphTraversal graphEntityTraversal = f.getAnnotation(GraphTraversal.class);
		 return graphEntityTraversal != null && graphEntityTraversal.traversalBuilder() != FieldTraversalDescriptionBuilder.class && f.getType().equals(Iterable.class);
	 }
	 public FieldAccessor<NodeBacked> forField(final Neo4JPersistentProperty property) {
		 return new TraversalFieldAccessor(property);
	 }
	public static class TraversalFieldAccessor implements FieldAccessor<NodeBacked> {
		 protected final Neo4JPersistentProperty property;
		 private final FieldTraversalDescriptionBuilder fieldTraversalDescriptionBuilder;
		 private Class<?> target;
		 protected String[] params;
		 public TraversalFieldAccessor(final Neo4JPersistentProperty property) {
			 this.property = property;
			 final GraphTraversal graphEntityTraversal = property.getAnnotation(GraphTraversal.class);
			 this.target = resolveTarget(graphEntityTraversal,property);
			 this.params = graphEntityTraversal.params();
			 this.fieldTraversalDescriptionBuilder = createTraversalDescription(graphEntityTraversal);
		 }
		 private Class<?> resolveTarget(GraphTraversal graphTraversal, Neo4JPersistentProperty property) {
			 if (!graphTraversal.elementClass().equals(NodeBacked.class)) return graphTraversal.elementClass();
			 final Class<?> result = property.getTypeInformation().getActualType().getType();
			 Class<?>[] allowedTypes={
			NodeBacked.class,RelationshipBacked.class,Node.class,Relationship.class, Path.class}
			;
			 if (!checkTypes(result,allowedTypes)) throw new IllegalArgumentException(""The target result type ""+result+"" of the traversal is no subclass of the allowed types: ""+property+"" ""+allowedTypes);
			 return result;
		 }
		 private boolean checkTypes(Class<?> target, Class<?>...allowedTypes) {
			 for (Class<?> type : allowedTypes) {
				 if (type.isAssignableFrom(target)) return true;
			 }
			 return false;
		 }
		 public boolean isWriteable(NodeBacked nodeBacked) {
			 return false;
		 }
		 public Object setValue(final NodeBacked nodeBacked, final Object newVal) {
			 throw new InvalidDataAccessApiUsageException(""Cannot set readonly traversal description field "" + property);
		 }
		 public Object getValue(final NodeBacked nodeBacked) {
			 final TraversalDescription traversalDescription = fieldTraversalDescriptionBuilder.build(nodeBacked, property,params);
			 return doReturn(nodeBacked.findAllByTraversal(target, traversalDescription));
		 }
		 private FieldTraversalDescriptionBuilder createTraversalDescription(final GraphTraversal graphEntityTraversal) {
			 try {
				 final Class<? extends FieldTraversalDescriptionBuilder> traversalDescriptionClass = graphEntityTraversal.traversalBuilder();
				 final Constructor<? extends FieldTraversalDescriptionBuilder> constructor = traversalDescriptionClass.getDeclaredConstructor();
				 constructor.setAccessible(true);
				 return constructor.newInstance();
			 }
			 catch (Exception e) {
				 throw new RuntimeException(""Error creating TraversalDescription from "" + property,e);
			 }
		 }
		public Object getDefaultImplementation() {
			return null;
		}
	}
}",1,0,0,0
"private void synchronizeHeaderlist() throws Exception, IOException,CommandCancelledException, IMAPException {
	MailboxStatus status = getServer().getStatus(this);
	if( status.getMessages() == 0 ) {
		headerList.clear();
		syncMailboxInfo(status);
		return;
	}
	List localUids = new LinkedList(Arrays.asList(headerList.getUids()));
	Collections.sort(localUids);
	int newMessages = 0;
	int largestLocalUid = localUids.size() > 0 ? ((Integer)localUids.get(localUids.size()-1)).intValue() : -1;
	int largestLocalUidIndex = -1;
	int removedLocalUids = 0;
	int largestRemoteUid = (int)status.getUidNext() - 1;
	if( localUids.size() == status.getMessages() && largestRemoteUid == largestLocalUid) {
		syncMailboxInfo(status);
		return;
	}
	printStatusMessage(MailResourceLoader.getString(""statusbar"", ""message"",""sync_messages""));
	if (status.getMessages() > 0) {
		largestRemoteUid = getServer().fetchUid(new SequenceSet(SequenceEntry.STAR), this);
		if (largestRemoteUid == -1) {
			largestRemoteUid = getServer().fetchUid(new SequenceSet(status.getMessages()), this);
		}
		printStatusMessage(MailResourceLoader.getString(""statusbar"",""message"", ""sync_messages""));
		if (localUids.size() > 0) {
			largestLocalUid = ((Integer) localUids.get(localUids.size() - 1)).intValue();
			int position = localUids.size() - 1;
			while (largestLocalUidIndex == -1&& position >= localUids.size() - 10 && position > 0) {
				largestLocalUidIndex = getServer().getIndex((Integer) localUids.get(position--), this);
			}
			if (largestLocalUidIndex == -1) {
				int a, b, c;
				int index;
				a = 0;
				b = position;
				while (b > a && b - a > 1) {
					c = Math.round((b - a) * 0.5f) + a;
					index = getServer().getIndex((Integer) localUids.get(c), this);
					if (index == -1) {
						b = c;
					}
					 else {
						a = c;
						largestLocalUidIndex = index;
					}
				}
				removedLocalUids = localUids.size() - 1 - position;
			}
			 else {
				removedLocalUids = localUids.size() - 2 - position;
			}
			if (largestLocalUidIndex == -1) {
				newMessages = status.getMessages();
				largestLocalUidIndex = 0;
			}
			 else {
				newMessages = status.getMessages() - largestLocalUidIndex;
			}
		}
		 else {
			newMessages = status.getMessages();
			largestLocalUidIndex = 0;
		}
		if (localUids.size() - status.getMessages() - removedLocalUids + newMessages < 0) {
			LOG.severe(""Folder "" + getName()+ "" is out of sync -> recreating the cache!"");
			headerList.clear();
			newMessages = status.getMessages();
			largestLocalUidIndex = 0;
			largestLocalUid = -1;
			localUids.clear();
		}
		LOG.fine(""Found "" + newMessages + "" new Messages"");
		if (newMessages > 0) {
			printStatusMessage(MailResourceLoader.getString(""statusbar"",""message"", ""fetch_new_headers""));
			IMAPFlags[] newFlags = getServer().fetchFlagsListStartFrom(largestLocalUidIndex + 1, this);
			if (newFlags.length > 0) {
				List newUids = new ArrayList(newFlags.length);
				for (int i = 0;
				 i < newFlags.length;
				 i++) {
					if (((Integer) newFlags[i].getUid()).intValue() <= largestLocalUid) {
						LOG.severe(""Assertion Failed : New UID is smaller"");
					}
					newUids.add(newFlags[i].getUid());
					localUids.add(newFlags[i].getUid());
				}
				getServer().fetchHeaderList(headerList, newUids, this);
				setFlags(newFlags);
				for (int i = 0;
				 i < newFlags.length;
				 i++) {
					fireMessageAdded(newFlags[i]);
				}
				IMAPRootFolder rootFolder = (IMAPRootFolder) getRootFolder();
				AccountItem accountItem = rootFolder.getAccountItem();
				ImapItem item = accountItem.getImapItem();
				boolean applyFilter = item.getBooleanWithDefault(""automatically_apply_filter"", false);
				if (applyFilter) {
					CommandProcessor.getInstance().addOp(new ApplyFilterCommand(new MailFolderCommandReference(this,newUids.toArray())));
				}
			}
		}
	}
	int deletedMessages = localUids.size() - status.getMessages();
	LOG.fine(""Found "" + deletedMessages + "" deleted Messages"");
	if (deletedMessages > 0) {
		int found = 0;
		while (localUids.size() > 0&& found != deletedMessages&& ((Integer) localUids.get(localUids.size() - 1)).intValue() > largestRemoteUid) {
			Flags flags = headerList.remove(localUids.get(localUids.size() - 1)).getFlags();
			fireMessageRemoved(localUids.remove(localUids.size() - 1),flags);
			found++;
		}
		int packSize = Math.min(Math.max(deletedMessages, status.getMessages() / 10), 200);
		int upper = status.getMessages();
		int localPointer = localUids.size() - 1;
		while (upper >= 1 && found != deletedMessages) {
			SequenceSet set = new SequenceSet();
			set.add(Math.max(upper - packSize + 1, 1), upper);
			Integer[] actUids = getServer().fetchUids(set, this);
			for (int i = actUids.length - 1;
			 i >= 0&& found != deletedMessages;
			 i--) {
				while (found != deletedMessages && localPointer >= 0&& !localUids.get(localPointer).equals(actUids[i])) {
					headerList.remove(localUids.get(localPointer));
					found++;
					localPointer--;
				}
				localPointer--;
			}
			upper = upper - packSize;
		}
		while (found < deletedMessages && localPointer >= 0) {
			headerList.remove(localUids.get(localPointer--));
			found++;
		}
		if (found != deletedMessages) {
			LOG.severe(""Assertion failed : found only "" + found + "" of ""+ deletedMessages);
		}
	}
	syncMailboxInfo(status);
}",0,0,1,0
"public String genJavaCompareTo() {
	 return mType.genJavaCompareTo(getName());
 }",0,0,0,0
"public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {
	 if (xArray.length != yArray.length) {
		 throw new DimensionMismatchException(xArray.length, yArray.length);
	 }
	 final int n = xArray.length;
	 final long numPairs = sum(n - 1);
	 Pair<Double, Double>[] pairs = new Pair[n];
	 for (int i = 0;
	 i < n;
	 i++) {
		 pairs[i] = new Pair<>(xArray[i], yArray[i]);
	 }
	 Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {
		 public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {
			 int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());
			 return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());
		 }
	 }
	);
	 long tiedXPairs = 0;
	 long tiedXYPairs = 0;
	 long consecutiveXTies = 1;
	 long consecutiveXYTies = 1;
	 Pair<Double, Double> prev = pairs[0];
	 for (int i = 1;
	 i < n;
	 i++) {
		 final Pair<Double, Double> curr = pairs[i];
		 if (curr.getFirst().equals(prev.getFirst())) {
			 consecutiveXTies++;
			 if (curr.getSecond().equals(prev.getSecond())) {
				 consecutiveXYTies++;
			 }
			 else {
				 tiedXYPairs += sum(consecutiveXYTies - 1);
				 consecutiveXYTies = 1;
			 }
		 }
		 else {
			 tiedXPairs += sum(consecutiveXTies - 1);
			 consecutiveXTies = 1;
			 tiedXYPairs += sum(consecutiveXYTies - 1);
			 consecutiveXYTies = 1;
		 }
		 prev = curr;
	 }
	 tiedXPairs += sum(consecutiveXTies - 1);
	 tiedXYPairs += sum(consecutiveXYTies - 1);
	 long swaps = 0;
	 Pair<Double, Double>[] pairsDestination = new Pair[n];
	 for (int segmentSize = 1;
	 segmentSize < n;
	 segmentSize <<= 1) {
		 for (int offset = 0;
		 offset < n;
		 offset += 2 * segmentSize) {
			 int i = offset;
			 final int iEnd = FastMath.min(i + segmentSize, n);
			 int j = iEnd;
			 final int jEnd = FastMath.min(j + segmentSize, n);
			 int copyLocation = offset;
			 while (i < iEnd || j < jEnd) {
				 if (i < iEnd) {
					 if (j < jEnd) {
						 if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {
							 pairsDestination[copyLocation] = pairs[i];
							 i++;
						 }
						 else {
							 pairsDestination[copyLocation] = pairs[j];
							 j++;
							 swaps += iEnd - i;
						 }
					 }
					 else {
						 pairsDestination[copyLocation] = pairs[i];
						 i++;
					 }
				 }
				 else {
					 pairsDestination[copyLocation] = pairs[j];
					 j++;
				 }
				 copyLocation++;
			 }
		 }
		 final Pair<Double, Double>[] pairsTemp = pairs;
		 pairs = pairsDestination;
		 pairsDestination = pairsTemp;
	 }
	 long tiedYPairs = 0;
	 long consecutiveYTies = 1;
	 prev = pairs[0];
	 for (int i = 1;
	 i < n;
	 i++) {
		 final Pair<Double, Double> curr = pairs[i];
		 if (curr.getSecond().equals(prev.getSecond())) {
			 consecutiveYTies++;
		 }
		 else {
			 tiedYPairs += sum(consecutiveYTies - 1);
			 consecutiveYTies = 1;
		 }
		 prev = curr;
	 }
	 tiedYPairs += sum(consecutiveYTies - 1);
	 final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
	 final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);
	 return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);
 }",0,0,1,0
"void onEnabledStateChanged(){
	super.onEnabledStateChanged();
	visitChildren(new IVisitor<Component>(){
		public Object component(Component component){
			component.clearEnabledInHierarchyCache();
			return CONTINUE_TRAVERSAL;
		}
	}
	);
}",0,0,0,0
"public boolean hasPendingItems() {
	if (!running) {
		return false;
	}
	for (String id : queuedItems) {
		DownloadEntry ent = XDMApp.getInstance().getEntry(id);
		if (ent != null) {
			if (ent.getState() != XDMConstants.FINISHED) {
				return true;
			}
		}
	}
	return false;
}",0,0,0,0
"public class TfsGitBranchJson {
	 private final static String REFS_HEADS = ""refs/heads/"";
	 private final String objectId;
	 private final String fullName;
	 public TfsGitBranchJson( final String objectId, final String fullName) {
		 this.objectId = objectId;
		 this.fullName = fullName;
	 }
	 public String getObjectId() {
		 return objectId;
	 }
	 public String getName() {
		 if (fullName.startsWith(REFS_HEADS)) {
			 return fullName.substring(REFS_HEADS.length());
		 }
		 else {
			 return fullName;
		 }
	 }
	 public String getFullName() {
		 return fullName;
	 }
}",0,1,0,0
"public class IntJGroupsPaletteFactory implements IPaletteFactory {
	public PaletteDrawer createPaletteDrawer(AbstractConfigGraphDiagram diagram, String namespaceUri) {
		PaletteDrawer drawer = new PaletteDrawer("""", IntegrationImages.BADGE_SI_JGROUPS);
		 List<PaletteEntry> entries = new ArrayList<PaletteEntry>();
		CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(IntJGroupsSchemaConstants.ELEM_INBOUND_CHANNEL_ADAPTER,Messages.IntJGroupsPaletteFactory_INBOUND_CHANNEL_ADAPTER_COMPONENT_DESCRIPTION,new ModelElementCreationFactory(InboundChannelAdapterModelElement.class, diagram, namespaceUri),IntegrationImages.INBOUND_ADAPTER_SMALL, IntegrationImages.INBOUND_ADAPTER);
		entries.add(entry);
		entry = new CombinedTemplateCreationEntry(IntJGroupsSchemaConstants.ELEM_OUTBOUND_CHANNEL_ADAPTER,Messages.IntJGroupsPaletteFactory_OUTBOUND_CHANNEL_ADAPTER_COMPONENT_DESCRIPTION,new ModelElementCreationFactory(OutboundChannelAdapterModelElement.class, diagram, namespaceUri),IntegrationImages.OUTBOUND_ADAPTER_SMALL, IntegrationImages.OUTBOUND_ADAPTER);
		entries.add(entry);
		drawer.addAll(entries);
		return drawer;
	}
}",0,0,0,0
"public class CharacterConverter extends AbstractConverter{
	private static final long serialVersionUID = 1L;
	public static final IConverter INSTANCE = new CharacterConverter();
	public Object convertToObject(final String value, Locale locale){
		int length = value.length();
		if (length == 0){
			return null;
		}
		else if (length == 1){
			return new Character(value.charAt(0));
		}
		throw newConversionException(""Cannot convert '"" + value + ""' to Character"", value, locale);
	}
	protected Class<Character> getTargetType(){
		return Character.class;
	}
}",0,0,0,0
"public class DropColumnFamilyStatement extends SchemaAlteringStatement{
	 public DropColumnFamilyStatement(CFName name) {
		 super(name);
	 }
	 public void announceMigration() throws ConfigurationException {
		 MigrationManager.announceColumnFamilyDrop(keyspace(), columnFamily());
	 }
}",0,0,0,0
"public class FileSaveEventHandler implements ActionListener {
	 private final MainFrame main;
	 public FileSaveEventHandler(MainFrame frame) {
		 super();
		 this.main = frame;
	 }
	 public void actionPerformed(ActionEvent event) {
		 this.main.saveFile();
		 this.main.setStatusbarMessage(""Text file "" + this.main.getTextFile().getName() + "" saved."");
	 }
}",0,0,0,0
"protected void connect(RouterStub stub, String group, Address logical_addr);",0,0,0,0
"final class EntrySet extends AbstractSet<Map.Entry<K,V>> {
	 public final int size() {
		 return size;
	 }
	 public final void clear() {
		 HashMap.this.clear();
	 }
	 public final Iterator<Map.Entry<K,V>> iterator() {
		 return new EntryIterator();
	 }
	 public final boolean contains(Object o) {
		 if (!(o instanceof Map.Entry)) return false;
		 Map.Entry<?,?> e = (Map.Entry<?,?>) o;
		 Object key = e.getKey();
		 Node<K,V> candidate = getNode(hash(key), key);
		 return candidate != null && candidate.equals(e);
	 }
	 public final boolean remove(Object o) {
		 if (o instanceof Map.Entry) {
			 Map.Entry<?,?> e = (Map.Entry<?,?>) o;
			 Object key = e.getKey();
			 Object value = e.getValue();
			 return removeNode(hash(key), key, value, true, true) != null;
		 }
		 return false;
	 }
	 public final Spliterator<Map.Entry<K,V>> spliterator() {
		 return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);
	 }
	 public final void forEach(Consumer<? super Map.Entry<K,V>> action) {
		 Node<K,V>[] tab;
		 if (action == null) throw new NullPointerException();
		 if (size > 0 && (tab = table) != null) {
			 int mc = modCount;
			 for (int i = 0;
			 (i < tab.length && modCount == mc);
			 ++i) {
				 for (Node<K,V> e = tab[i];
				 e != null;
				 e = e.next) action.accept(e);
			 }
			 if (modCount != mc) throw new ConcurrentModificationException();
		 }
	 }
 }",1,1,0,0
"public class JavacExternal extends DefaultCompilerAdapter {
	 public boolean execute() throws BuildException {
		 attributes.log(""Using external javac compiler"", Project.MSG_VERBOSE);
		 Commandline cmd = new Commandline();
		 cmd.setExecutable(getJavac().getJavacExecutable());
		 if (!assumeJava11() && !assumeJava12()) {
			 setupModernJavacCommandlineSwitches(cmd);
		 }
		 else {
			 setupJavacCommandlineSwitches(cmd, true);
		 }
		 int firstFileName = assumeJava11() ? -1 : cmd.size();
		 logAndAddFilesToCompile(cmd);
		 if (Os.isFamily(""openvms"")) {
			 return execOnVMS(cmd, firstFileName);
		 }
		 return executeExternalCompile(cmd.getCommandline(), firstFileName, true) == 0;
	 }
	 private boolean execOnVMS(Commandline cmd, int firstFileName) {
		 File vmsFile = null;
		 try {
			 vmsFile = JavaEnvUtils.createVmsJavaOptionFile(cmd.getArguments());
			 String[] commandLine = {
			cmd.getExecutable(), ""-V"", vmsFile.getPath()}
			;
			 return 0 == executeExternalCompile(commandLine, firstFileName, true);
		 }
		 catch (IOException e) {
			 throw new BuildException(""Failed to create a temporary file for \""-V\"" switch"");
		 }
		 finally {
			 FileUtils.delete(vmsFile);
		 }
	 }
}",0,0,0,0
"public abstract class CancelableThread extends Thread {
	 protected boolean running = true;
	 protected boolean canceled = false;
	 public synchronized final boolean isRunning() {
		 return running;
	 }
	 public synchronized final void setRunning(boolean running) {
		 this.running = running;
	 }
	 public synchronized final boolean isCanceled() {
		 return canceled;
	 }
	 public synchronized final void cancel() {
		 this.canceled = true;
	 }
	 public static void cancelThread(CancelableThread thread) {
		 if ( thread != null ) {
			 synchronized ( thread ) {
				 if ( thread.isRunning() ) {
					 thread.cancel();
				 }
			 }
		 }
	 }
}",0,1,0,0
"protected String extractVariablePart(String name) {
	 String var = name.substring(prefixLength, name.length() - postfixLength);
	 if (getHandleDirSep()) {
		 var = name.replace('/', '.').replace('\\', '.');
	 }
	 return var.replace(File.separatorChar, '.');
 }",0,0,0,0
"private void grantOrRevokeRoleOnGroup(List<HivePrincipal> hivePrincipals, List<String> roles, HivePrincipal grantorPrinc, boolean isGrant) throws HiveAuthzPluginException, HiveAccessControlException {
	 try {
		 sentryClient = getSentryClient();
		 Set<String> groups = Sets.newHashSet();
		 for (HivePrincipal principal : hivePrincipals) {
			 if (principal.getType() != HivePrincipalType.GROUP) {
				 String msg = SentryHiveConstants.GRANT_REVOKE_NOT_SUPPORTED_FOR_PRINCIPAL + principal.getType();
				 throw new HiveAuthzPluginException(msg);
			 }
			 groups.add(principal.getName());
		 }
		 for (String roleName : roles) {
			 if (isGrant) {
				 sentryClient.grantRoleToGroups(grantorPrinc.getName(), roleName, groups);
			 }
			 else {
				 sentryClient.revokeRoleFromGroups(grantorPrinc.getName(), roleName, groups);
			 }
		 }
	 }
	 catch (SentryAccessDeniedException e) {
		 HiveOperation hiveOp = isGrant ? HiveOperation.GRANT_ROLE : HiveOperation.REVOKE_ROLE;
		 executeOnFailureHooks(hiveOp, e);
	 }
	 catch (SentryUserException e) {
		 String msg = ""Error when sentryClient grant/revoke role:"" + e.getMessage();
		 executeOnErrorHooks(msg, e);
	 }
	 finally {
		 if (sentryClient != null) {
			 sentryClient.close();
		 }
	 }
 }",0,0,1,0
"private void sessionEnd0( IgniteInternalTx tx, boolean threwEx) throws IgniteCheckedException {
	 try {
		 if (tx == null) {
			 if (sesLsnrs != null && sesHolder.get().contains(store)) {
				 for (CacheStoreSessionListener lsnr : sesLsnrs) lsnr.onSessionEnd(locSes, !threwEx);
			 }
			 if (!sesHolder.get().ended(store)) store.sessionEnd(!threwEx);
		 }
	 }
	 catch (Exception e) {
		 if (!threwEx) throw U.cast(e);
	 }
	 finally {
		 if (sesHolder != null) sesHolder.set(null);
	 }
 }",0,0,1,0
"public class CustomDataImpl implements CustomData {
	 public static final CustomData NONE = new CustomDataImpl(new LinkedHashMap<Object, Object>());
	 private final Map<Object, Object> customData;
	 public CustomDataImpl(final Map<Object, Object> customData) {
		 Validate.notNull(customData, ""Custom data required"");
		 this.customData = Collections.unmodifiableMap(customData);
	 }
	 public boolean equals(final Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 if (obj == null) {
			 return false;
		 }
		 if (getClass() != obj.getClass()) {
			 return false;
		 }
		 final CustomDataImpl other = (CustomDataImpl) obj;
		 if (customData == null) {
			 if (other.customData != null) {
				 return false;
			 }
		 }
		 else if (!customData.equals(other.customData)) {
			 return false;
		 }
		 return true;
	 }
	 public Object get(final Object key) {
		 return customData.get(key);
	 }
	 public int hashCode() {
		 final int prime = 31;
		 final int result = 1;
		 return prime * result + (customData == null ? 0 : customData.hashCode());
	 }
	 public Iterator<Object> iterator() {
		 return customData.keySet().iterator();
	 }
	 public Set<Object> keySet() {
		 return customData.keySet();
	 }
	 public String toString() {
		 return customData.toString();
	 }
}",0,0,0,0
"private void validateArrayStep(String arrStep) throws QueryException {
	 boolean wildAllowed = true;
	 boolean digitAllowed = true;
	 boolean commaAllowed = false;
	 boolean afterDigit = false;
	 boolean toAllowed = false;
	 boolean afterTo = false;
	 boolean toInProgress = false;
	 boolean spaceRequired = false;
	 boolean digitRequired = false;
	 for (int i = 1;
	 i < arrStep.length() - 1;
	 ++i) {
		 char currentChar = arrStep.charAt(i);
		 if (currentChar == '*') {
			 if (!wildAllowed) throwArrayException(arrStep);
			 wildAllowed = false;
			 digitAllowed = false;
		 }
		 else if (currentChar == ',') {
			 if (!commaAllowed) throwArrayException(arrStep);
			 commaAllowed = false;
			 toAllowed = false;
			 afterDigit = false;
			 afterTo = false;
			 digitRequired = true;
		 }
		 else if (""0123456789"".indexOf(currentChar) >= 0) {
			 if (!digitAllowed) throwArrayException(arrStep);
			 wildAllowed = false;
			 commaAllowed = true;
			 afterDigit = true;
			 digitRequired = false;
		 }
		 else if ("" \t\n\r"".indexOf(currentChar) >= 0) {
			 if (toInProgress) throwArrayException(arrStep);
			 if (afterDigit) {
				 digitAllowed = false;
				 toAllowed = !afterTo;
				 commaAllowed = true;
			 }
			 else if (spaceRequired) {
				 digitAllowed = true;
				 spaceRequired = false;
				 digitRequired = true;
			 }
		 }
		 else if (currentChar == 't') {
			 if (!toAllowed) throwArrayException(arrStep);
			 toInProgress = true;
			 commaAllowed = false;
			 afterDigit = false;
		 }
		 else if (currentChar == 'o') {
			 if (!toInProgress) throwArrayException(arrStep);
			 toInProgress = false;
			 toAllowed = false;
			 afterTo = true;
			 spaceRequired = true;
		 }
		 else {
			 throwArrayException(arrStep);
		 }
	 }
	 if (wildAllowed) throwArrayException(arrStep);
	 if (toInProgress || spaceRequired || digitRequired) throwArrayException(arrStep);
 }",0,0,1,0
"private static ThreadPoolExecutor multiThreadedStage(Stage stage, int numThreads) {
	 assert numThreads > 1 : ""multi-threaded stages must have at least 2 threads"";
	 return new JMXEnabledThreadPoolExecutor(numThreads, numThreads, KEEPALIVE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory(stage.getJmxName()), stage.getJmxType());
 }",0,0,0,0
"public class StringHeaderContributor extends AbstractHeaderContributor{
	private static final long serialVersionUID = 1L;
	private final StringContributor contributor;
	private static final class StringContributor implements IHeaderContributor{
		private static final long serialVersionUID = 1L;
		private final IModel<?> contribution;
		public StringContributor(String contribution){
			if (contribution == null){
				throw new IllegalArgumentException(""argument contribition must be not null"");
			}
			this.contribution = new Model<String>(contribution);
		}
		public StringContributor(IModel<?> contribution){
			if (contribution == null){
				throw new IllegalArgumentException(""argument contribition must be not null"");
			}
			this.contribution = contribution;
		}
		public void renderHead(IHeaderResponse response){
			Object object = contribution.getObject();
			if (object != null){
				response.getResponse().println(object.toString());
			}
		}
		public int hashCode(){
			Object object = contribution.getObject();
			return (object != null) ? object.hashCode() : 0;
		}
		public boolean equals(Object obj){
			if (obj instanceof StringContributor){
				Object thisContrib = contribution.getObject();
				Object thatContrib = ((StringContributor)obj).contribution.getObject();
				return Objects.equal(thisContrib, thatContrib);
			}
			return false;
		}
		public String toString(){
			return ""StringContributor[contribution="" + contribution + ""]"";
		}
	}
	public StringHeaderContributor(String contribution){
		contributor = new StringContributor(contribution);
	}
	public StringHeaderContributor(IModel<?> contribution){
		contributor = new StringContributor(contribution);
	}
	public final IHeaderContributor[] getHeaderContributors(){
		return new IHeaderContributor[] {
		 contributor }
		;
	}
	public void detach(Component component){
		contributor.contribution.detach();
	}
	public String toString(){
		Object string = contributor.contribution.getObject();
		return (string != null) ? string.toString() : """";
	}
}",0,0,0,0
"public class GitHubUser implements Serializable {
	private final long id;
	private final String url;
	private final String login;
	private final String avatarUrl;
	private final String gravatarId;
	private String name;
	private String email;
	 public GitHubUser(long id, String url, String login, String avatarUrl, String gravatarId) {
		 this.id = id;
		 this.url = url;
		 this.login = login;
		 this.avatarUrl = avatarUrl;
		 this.gravatarId = gravatarId;
	 }
	 public Long getId() {
		 return id;
	 }
	public String getUrl() {
		 return url;
	 }
	public String getLogin() {
		 return login;
	 }
	public String getAvatarUrl() {
		 return avatarUrl;
	 }
	public String getGravatarId() {
		 return gravatarId;
	 }
	public String getName() {
		 return name;
	 }
	public void setName(String name) {
		 this.name = name;
	 }
	public String getEmail() {
		 return email;
	 }
	public void setEmail(String email) {
		 this.email = email;
	 }
}",0,1,0,0
"public interface ISemanticNodeProvider {
	public interface ISemanticNode {
		INode getNode();
		ISemanticNode getFollower();
		AbstractElement getGrammarElement();
	}
	public interface INodesForEObjectProvider {
		ISemanticNode getSemanticNodeForMultiValue(EStructuralFeature feature, int indexInFeature, int indexInNonTransient, Object value);
		ISemanticNode getSemanticNodeForSingelValue(EStructuralFeature feature, Object value);
		ISemanticNode getFirstSemanticNode();
		INode getNodeForMultiValue(EStructuralFeature feature, int indexInFeature, int indexInNonTransient, Object value);
		INode getNodeForSingelValue(EStructuralFeature feature, Object value);
	}
	public class NullNodesForEObjectProvider implements INodesForEObjectProvider {
		public INode getNodeForMultiValue(EStructuralFeature feature, int indexInFeature, int indexAmongNonTransient,Object value) {
			return null;
		}
		public INode getNodeForSingelValue(EStructuralFeature feature, Object value) {
			return null;
		}
		public ISemanticNode getSemanticNodeForMultiValue(EStructuralFeature feature, int indexInFeature,int indexInNonTransient, Object value) {
			return null;
		}
		public ISemanticNode getSemanticNodeForSingelValue(EStructuralFeature feature, Object value) {
			return null;
		}
		public ISemanticNode getFirstSemanticNode() {
			return null;
		}
	}
	public INodesForEObjectProvider NULL_NODES_PROVIDER = new NullNodesForEObjectProvider();
	INodesForEObjectProvider getNodesForSemanticObject(EObject semanticObject, ICompositeNode suggestedComposite);
}",0,0,0,0
"private void printSliceList(CfDef columnFamilyDef, List<KeySlice> slices) throws NotFoundException, TException, IllegalAccessException, InstantiationException, NoSuchFieldException, CharacterCodingException {
	 AbstractType validator;
	 String columnFamilyName = columnFamilyDef.getName();
	 AbstractType keyComparator = this.cfKeysComparators.get(columnFamilyName);
	 for (KeySlice ks : slices) {
		 String keyName = (keyComparator == null) ? ByteBufferUtil.string(ks.key, Charsets.UTF_8) : keyComparator.getString(ks.key);
		 sessionState.out.printf(""-------------------%n"");
		 sessionState.out.printf(""RowKey: %s%n"", keyName);
		 Iterator<ColumnOrSuperColumn> iterator = ks.getColumnsIterator();
		 while (iterator.hasNext()) {
			 ColumnOrSuperColumn columnOrSuperColumn = iterator.next();
			 if (columnOrSuperColumn.column != null) {
				 Column col = columnOrSuperColumn.column;
				 validator = getValidatorForValue(columnFamilyDef, col.getName());
				 sessionState.out.printf(""=> (column=%s, value=%s, timestamp=%d%s)%n"", formatColumnName(keySpace, columnFamilyName, col), validator.getString(col.value), col.timestamp, col.isSetTtl() ? String.format("", ttl=%d"", col.getTtl()) : """");
			 }
			 else if (columnOrSuperColumn.super_column != null) {
				 SuperColumn superCol = columnOrSuperColumn.super_column;
				 sessionState.out.printf(""=> (super_column=%s,"", formatSuperColumnName(keySpace, columnFamilyName, superCol));
				 for (Column col : superCol.columns) {
					 validator = getValidatorForValue(columnFamilyDef, col.getName());
					 sessionState.out.printf(""%n (column=%s, value=%s, timestamp=%d%s)"", formatSubcolumnName(keySpace, columnFamilyName, col), validator.getString(col.value), col.timestamp, col.isSetTtl() ? String.format("", ttl=%d"", col.getTtl()) : """");
				 }
				 sessionState.out.println("")"");
			 }
		 }
	 }
	 sessionState.out.printf(""%n%d Row%s Returned.%n"", slices.size(), (slices.size() > 1 ? ""s"" : """"));
 }",0,0,0,0
"public interface JUnitResultFormatter extends TestListener, JUnitTaskMirror.JUnitResultFormatterMirror {
	 void startTestSuite(JUnitTest suite) throws BuildException;
	 void endTestSuite(JUnitTest suite) throws BuildException;
	 void setOutput(OutputStream out);
	 void setSystemOutput(String out);
	 void setSystemError(String err);
}",0,0,0,0
"private static ImmutableDictionaryReader loadDictionary(PinotDataBuffer dictionaryBuffer, ColumnMetadata metadata, boolean loadOnHeap) {
	 FieldSpec.DataType dataType = metadata.getDataType();
	 if (loadOnHeap) {
		 String columnName = metadata.getColumnName();
		 LOGGER.info(""Loading on-heap dictionary for column: {
		}
		"", columnName);
	 }
	 int length = metadata.getCardinality();
	 switch (dataType) {
		 case INT: return (loadOnHeap) ? new OnHeapIntDictionary(dictionaryBuffer, length) : new IntDictionary(dictionaryBuffer, length);
		 case LONG: return (loadOnHeap) ? new OnHeapLongDictionary(dictionaryBuffer, length) : new LongDictionary(dictionaryBuffer, length);
		 case FLOAT: return (loadOnHeap) ? new OnHeapFloatDictionary(dictionaryBuffer, length) : new FloatDictionary(dictionaryBuffer, length);
		 case DOUBLE: return (loadOnHeap) ? new OnHeapDoubleDictionary(dictionaryBuffer, length) : new DoubleDictionary(dictionaryBuffer, length);
		 case STRING: int numBytesPerValue = metadata.getColumnMaxLength();
		 byte paddingByte = (byte) metadata.getPaddingCharacter();
		 return loadOnHeap ? new OnHeapStringDictionary(dictionaryBuffer, length, numBytesPerValue, paddingByte) : new StringDictionary(dictionaryBuffer, length, numBytesPerValue, paddingByte);
		 case BYTES: numBytesPerValue = metadata.getColumnMaxLength();
		 return new BytesDictionary(dictionaryBuffer, length, numBytesPerValue);
		 default: throw new IllegalStateException(""Illegal data type for dictionary: "" + dataType);
	 }
 }",0,0,1,0
"public abstract class ProcessManagerWrapper<T, R> implements ProcessManager<R> {
	 private final ProcessManager<T> delegate;
	 public ProcessManagerWrapper(ProcessManager<T> delegate) {
		 assert delegate != null : ""Delegate should not be null"";
		 this.delegate = delegate;
	 }
	 protected abstract T transformSpecification(R spec);
	 public Map<UUID, List<UUID>> start(List<R> specifications) {
		 List<T> transformedSpecifications = new ArrayList<>();
		 for (R spec : specifications) transformedSpecifications.add(transformSpecification(spec));
		 return delegate.start(transformedSpecifications);
	 }
	 public Map<UUID, List<LongRunningProcessStatus>> ping(Map<UUID, List<UUID>> procIds) {
		 return delegate.ping(procIds);
	 }
	 public Map<UUID, List<LongRunningProcessStatus>> stop(Map<UUID, List<UUID>> procIds, boolean clear) {
		 return delegate.stop(procIds, clear);
	 }
	 public Map<UUID, List<LongRunningProcessStatus>> clear(Map<UUID, List<UUID>> procIds) {
		 return delegate.clear(procIds);
	 }
}",0,0,0,0
"public void genJavaCode() throws IOException {
	 String pkg = getJavaPackage();
	 String pkgpath = pkg.replaceAll(""\\."", ""/"");
	 File pkgdir = new File(pkgpath);
	 if (!pkgdir.exists()) {
		 boolean ret = pkgdir.mkdirs();
		 if (!ret) {
			 System.out.println(""Cannnot create directory: ""+pkgpath);
			 System.exit(1);
		 }
	 }
	 else if (!pkgdir.isDirectory()) {
		 System.out.println(pkgpath+"" is not a directory."");
		 System.exit(1);
	 }
	 File jfile = new File(pkgdir, getName()+"".java"");
	 FileWriter jj = new FileWriter(jfile);
	 jj.write("" jj.write(""package ""+getJavaPackage()+"";
	\n\n"");
	 jj.write(""import org.apache.hadoop.io.Text;
	\n\n"");
	 jj.write(""public class ""+getName()+"" implements org.apache.hadoop.record.Record, org.apache.hadoop.io.WritableComparable {
		\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaDecl());
		 }
		 jj.write("" private java.util.BitSet bs_;
		\n"");
		 jj.write("" public ""+getName()+""() {
			\n"");
			 jj.write("" bs_ = new java.util.BitSet(""+(mFields.size()+1)+"");
			\n"");
			 jj.write("" bs_.set(""+mFields.size()+"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public ""+getName()+""(\n"");
		 int fIdx = 0;
		 int fLen = mFields.size();
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaConstructorParam(fIdx));
			 jj.write((fLen-1 == fIdx)?"""":"",\n"");
		 }
		 jj.write("") {
			\n"");
			 jj.write("" bs_ = new java.util.BitSet(""+(mFields.size()+1)+"");
			\n"");
			 jj.write("" bs_.set(""+mFields.size()+"");
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaConstructorSet(fIdx));
			 }
		 jj.write("" }
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaGetSet(fIdx));
		 }
		 jj.write("" public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
			\n"");
			 jj.write("" if (!validate()) throw new java.io.IOException(\""All fields not set:\"");
			\n"");
			 jj.write("" a_.startRecord(this,tag);
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaWriteMethodName());
				 jj.write("" bs_.clear(""+fIdx+"");
				\n"");
			 }
			 jj.write("" a_.endRecord(this,tag);
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
			\n"");
			 jj.write("" a_.startRecord(tag);
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaReadMethodName());
				 jj.write("" bs_.set(""+fIdx+"");
				\n"");
			 }
			 jj.write("" a_.endRecord(tag);
			\n"");
		 jj.write(""}
		\n"");
		 jj.write("" public String toString() {
			\n"");
			 jj.write("" try {
				\n"");
				 jj.write("" java.io.ByteArrayOutputStream s =\n"");
				 jj.write("" new java.io.ByteArrayOutputStream();
				\n"");
				 jj.write("" org.apache.hadoop.record.CsvOutputArchive a_ = \n"");
				 jj.write("" new org.apache.hadoop.record.CsvOutputArchive(s);
				\n"");
				 jj.write("" a_.startRecord(this,\""\"");
				\n"");
				 fIdx = 0;
				 for (Iterator i = mFields.iterator();
				 i.hasNext();
				 fIdx++) {
					 JField jf = (JField) i.next();
					 jj.write(jf.genJavaWriteMethodName());
				 }
				 jj.write("" a_.endRecord(this,\""\"");
				\n"");
				 jj.write("" return new String(s.toByteArray(), \""UTF-8\"");
				\n"");
			 jj.write("" }
			 catch (Throwable ex) {
				\n"");
				 jj.write("" ex.printStackTrace();
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" return \""ERROR\"";
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void write(java.io.DataOutput out) throws java.io.IOException {
			\n"");
			 jj.write("" org.apache.hadoop.record.BinaryOutputArchive archive = new org.apache.hadoop.record.BinaryOutputArchive(out);
			\n"");
			 jj.write("" serialize(archive, \""\"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void readFields(java.io.DataInput in) throws java.io.IOException {
			\n"");
			 jj.write("" org.apache.hadoop.record.BinaryInputArchive archive = new org.apache.hadoop.record.BinaryInputArchive(in);
			\n"");
			 jj.write("" deserialize(archive, \""\"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public boolean validate() {
			\n"");
			 jj.write("" if (bs_.cardinality() != bs_.length()) return false;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 JType type = jf.getType();
				 if (type instanceof JRecord) {
					 jj.write("" if (!""+jf.getName()+"".validate()) return false;
					\n"");
				 }
			 }
			 jj.write("" return true;
			\n"");
		 jj.write(""}
		\n"");
		 jj.write("" public int compareTo (Object peer_) throws ClassCastException {
			\n"");
			 jj.write("" if (!(peer_ instanceof ""+getName()+"")) {
				\n"");
				 jj.write("" throw new ClassCastException(\""Comparing different types of records.\"");
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" ""+getName()+"" peer = (""+getName()+"") peer_;
			\n"");
			 jj.write("" int ret = 0;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaCompareTo());
				 jj.write("" if (ret != 0) return ret;
				\n"");
			 }
			 jj.write("" return ret;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public boolean equals(Object peer_) {
			\n"");
			 jj.write("" if (!(peer_ instanceof ""+getName()+"")) {
				\n"");
				 jj.write("" return false;
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" if (peer_ == this) {
				\n"");
				 jj.write("" return true;
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" ""+getName()+"" peer = (""+getName()+"") peer_;
			\n"");
			 jj.write("" boolean ret = false;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaEquals());
				 jj.write("" if (!ret) return ret;
				\n"");
			 }
			 jj.write("" return ret;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public int hashCode() {
			\n"");
			 jj.write("" int result = 17;
			\n"");
			 jj.write("" int ret;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaHashCode());
				 jj.write("" result = 37*result + ret;
				\n"");
			 }
			 jj.write("" return result;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public static String signature() {
			\n"");
			 jj.write("" return \""""+getSignature()+""\"";
			\n"");
		 jj.write("" }
		\n"");
	 jj.write(""}
	\n"");
	 jj.close();
 }",0,0,1,0
"public interface CloseableIterator<T> extends Iterator<T>, Closeable{
}",0,0,0,0
"public class Sequential extends Task implements TaskContainer {
	 private Vector nestedTasks = new Vector();
	 public void addTask(Task nestedTask) {
		 nestedTasks.addElement(nestedTask);
	 }
	 public void execute() throws BuildException {
		 LocalProperties localProperties = LocalProperties.get(getProject());
		 localProperties.enterScope();
		 try {
			 for (Iterator i = nestedTasks.iterator();
			 i.hasNext();
			) {
				 Task nestedTask = (Task) i.next();
				 nestedTask.perform();
			 }
		 }
		 finally {
			 localProperties.exitScope();
		 }
	 }
}",0,0,0,0
"public abstract class JenaDriver implements Driver {
	 private static final Logger LOGGER = LoggerFactory.getLogger(JenaDriver.class);
	 public static final String DRIVER_PREFIX = ""jdbc:jena:"";
	 public static final String PARAM_JDBC_COMPATIBILITY = ""jdbc-compatibility"";
	 public static final String PARAM_PRE_PROCESSOR = ""pre-processor"";
	 public static final String PARAM_POST_PROCESSOR = ""post-processor"";
	 public static final String PARAM_USERNAME = ""user"";
	 public static final String PARAM_PASSWORD = ""password"";
	 public static final String PARAM_LOGGING = ""logging"";
	 public static final String NO_AUTO_LOGGING_CONFIGURATION = ""no-auto"";
	 public static final String PARAM_CONFIG = ""config"";
	 private int majorVer, minorVer;
	 private String implPrefix;
	 public JenaDriver(int majorVer, int minorVer, String prefix) {
		 this.majorVer = majorVer;
		 this.minorVer = minorVer;
		 if (prefix == null) throw new IllegalArgumentException(""Implementation specific prefix cannot be null"");
		 if (!prefix.endsWith("":"")) throw new IllegalArgumentException(""Implementation specific prefix must end with a :"");
		 if (!prefix.matches(""[A-Za-z\\d\\-_]+:"")) throw new IllegalArgumentException( ""Implementation specific prefix must conform to the regular expression [A-Za-z\\d\\-_]+:"");
		 this.implPrefix = prefix;
	 }
	 public boolean acceptsURL(String url) {
		 if (url.startsWith(DRIVER_PREFIX + this.implPrefix)) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public final Connection connect(String url, Properties props) throws SQLException {
		 if (!this.acceptsURL(url)) return null;
		 Properties ps = this.getEffectiveProperties(url, props);
		 this.modifyProperties(ps);
		 String logConfig = ps.getProperty(PARAM_LOGGING);
		 if (logConfig == null || logConfig.trim().length() == 0) {
			 logConfig = NO_AUTO_LOGGING_CONFIGURATION;
		 }
		 if (!logConfig.equals(NO_AUTO_LOGGING_CONFIGURATION)) {
			 LOGGER.warn(""JenaDriver can no longer configure logging as of Jena 4.x - please configure logging via user code or at the application level"");
		 }
		 int compatibilityLevel = JdbcCompatibility.parseLevel(ps.get(PARAM_JDBC_COMPATIBILITY));
		 JenaConnection conn = null;
		 boolean abort = false;
		 try {
			 conn = this.connect(ps, compatibilityLevel);
			 Properties initProps = new Properties(ps);
			 initProps.remove(PARAM_PASSWORD);
			 Object ppObj = ps.get(PARAM_PRE_PROCESSOR);
			 List<String> preProcessors;
			 if (ppObj != null) {
				 if (ppObj instanceof String) {
					 preProcessors = new ArrayList<String>();
					 preProcessors.add(ppObj.toString());
				 }
				 else if (ppObj instanceof List<?>) {
					 preProcessors = (List<String>) ppObj;
				 }
				 else {
					 LOGGER.error(""Driver Parameter "" + PARAM_PRE_PROCESSOR + "" has unexpected invalid value"");
					 throw new SQLException(""Parameter "" + PARAM_PRE_PROCESSOR + "" was set to a value of unexpected type "" + ppObj.getClass().getCanonicalName() + "", expected either a String or List<String> as the parameter value"");
				 }
				 for (String ppClassName : preProcessors) {
					 if (ppClassName == null) continue;
					 try {
						 LOGGER.info(""Attempting to initialize pre-processor "" + ppClassName);
						 Class<?> c = Class.forName(ppClassName);
						 Object i = c.getDeclaredConstructor().newInstance();
						 if (i instanceof CommandPreProcessor) {
							 CommandPreProcessor pp = (CommandPreProcessor) i;
							 pp.initialize(initProps);
							 conn.addPreProcessor(pp);
							 LOGGER.info(""Initialized pre-processor "" + ppClassName + "" successfully"");
						 }
						 else {
							 LOGGER.error(""Invalid value for "" + PARAM_PRE_PROCESSOR + "" parameter, references a class that exists but does not implement the required interface"");
							 throw new SQLException( ""Parameter "" + PARAM_PRE_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that does not implement the expected CommandPreProcessor interface, please ensure that the class name is corect and that the class implements the required interface"");
						 }
					 }
					 catch (ClassNotFoundException e) {
						 LOGGER.error(""Invalid value for "" + PARAM_PRE_PROCESSOR + "" parameter, references a class that did not exist"", e);
						 throw new SQLException( ""Parameter "" + PARAM_PRE_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that could not be found, please ensure that the class name is correct and the JAR containing this class is on your class path"", e);
					 }
					 catch (InstantiationException e) {
						 LOGGER.error(""Invalid value for "" + PARAM_PRE_PROCESSOR + "" parameter, references a class that exists but does not have an appropriate constructor"", e);
						 throw new SQLException( ""Parameter "" + PARAM_PRE_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that could not be sucessfully instantiated, this class must have an unparameterized constructor to be usable with this parameter. If this is not possible try calling addPreProcessor() on the returned JenaConnection instead"", e);
					 }
					 catch (IllegalAccessException e) {
						 LOGGER.error(""Invalid value for "" + PARAM_PRE_PROCESSOR + "" parameter, references a class that exists but is inaccessible"", e);
						 throw new SQLException( ""Parameter "" + PARAM_PRE_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that could not be sucessfully instantiated, this class must have a publicly accessible unparameterized constructor to be usable with this parameter. If this is not possible try calling addPreProcessor() on the returned JenaConnection instead"", e);
					 }
					 catch (SQLException e) {
						 throw e;
					 }
					 catch (Exception e) {
						 LOGGER.error( ""Invalid value for "" + PARAM_PRE_PROCESSOR + "" parameter, references a class that attempting to initialize produced an unexpected exception"", e);
						 throw new SQLException( ""Parameter "" + PARAM_PRE_PROCESSOR + "" includes the value "" + ppClassName + "" which caused an unexpected exception when trying to instantiate it, see the inner exception for details"", e);
					 }
				 }
			 }
			 ppObj = ps.get(PARAM_POST_PROCESSOR);
			 List<String> postProcessors;
			 if (ppObj != null) {
				 if (ppObj instanceof String) {
					 postProcessors = new ArrayList<String>();
					 postProcessors.add(ppObj.toString());
				 }
				 else if (ppObj instanceof List<?>) {
					 postProcessors = (List<String>) ppObj;
				 }
				 else {
					 LOGGER.error(""Driver Parameter "" + PARAM_POST_PROCESSOR + "" has unexpected invalid value"");
					 throw new SQLException(""Parameter "" + PARAM_POST_PROCESSOR + "" was set to a value of unexpected type "" + ppObj.getClass().getCanonicalName() + "", expected either a String or List<String> as the parameter value"");
				 }
				 for (String ppClassName : postProcessors) {
					 if (ppClassName == null) continue;
					 try {
						 LOGGER.info(""Attempting to initialize post-processor "" + ppClassName);
						 Class<?> c = Class.forName(ppClassName);
						 Object i = c.getDeclaredConstructor().newInstance();
						 if (i instanceof ResultsPostProcessor) {
							 ResultsPostProcessor pp = (ResultsPostProcessor) i;
							 pp.initialize(initProps);
							 conn.addPostProcessor(pp);
							 LOGGER.info(""Initialized post-processor "" + ppClassName + "" successfully"");
						 }
						 else {
							 LOGGER.error(""Invalid value for "" + PARAM_POST_PROCESSOR + "" parameter, references a class that exists but does not implement the required interface"");
							 throw new SQLException( ""Parameter "" + PARAM_POST_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that does not implement the expected ResultsPostProcessor interface, please ensure that the class name is corect and that the class implements the required interface"");
						 }
					 }
					 catch (ClassNotFoundException e) {
						 LOGGER.error(""Invalid value for "" + PARAM_POST_PROCESSOR + "" parameter, references a class that did not exist"", e);
						 throw new SQLException( ""Parameter "" + PARAM_POST_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that could not be found, please ensure that the class name is correct and the JAR containing this class is on your class path"", e);
					 }
					 catch (InstantiationException e) {
						 LOGGER.error(""Invalid value for "" + PARAM_POST_PROCESSOR + "" parameter, references a class that exists but does not have an appropriate constructor"", e);
						 throw new SQLException( ""Parameter "" + PARAM_POST_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that could not be sucessfully instantiated, this class must have an unparameterized constructor to be usable with this parameter. If this is not possible try calling addPostProcessor() on the returned JenaConnection instead"", e);
					 }
					 catch (IllegalAccessException e) {
						 LOGGER.error(""Invalid value for "" + PARAM_POST_PROCESSOR + "" parameter, references a class that exists but is inaccessible"", e);
						 throw new SQLException( ""Parameter "" + PARAM_POST_PROCESSOR + "" includes the value "" + ppClassName + "" which references a class that could not be sucessfully instantiated, this class must have a publicly accessible unparameterized constructor to be usable with this parameter. If this is not possible try calling addPostProcessor() on the returned JenaConnection instead"", e);
					 }
					 catch (SQLException e) {
						 throw e;
					 }
					 catch (Exception e) {
						 LOGGER.error( ""Invalid value for "" + PARAM_POST_PROCESSOR + "" parameter, references a class that attempting to initialize produced an unexpected exception"", e);
						 throw new SQLException( ""Parameter "" + PARAM_POST_PROCESSOR + "" includes the value "" + ppClassName + "" which caused an unexpected exception when trying to instantiate it, see the inner exception for details"", e);
					 }
				 }
			 }
			 return conn;
		 }
		 catch (SQLException e) {
			 abort = true;
			 throw e;
		 }
		 catch (Exception e) {
			 abort = true;
			 LOGGER.error(""Unexpected exception while establishing a connection"", e);
			 throw new SQLException(""Unexpected exception while establishing a connection, see inner exception for details"", e);
		 }
		 finally {
			 if (abort && conn != null) {
				 conn.close();
			 }
		 }
	 }
	 private Properties getEffectiveProperties(String url, Properties props) throws SQLException {
		 Properties ps = new Properties();
		 url = url.substring(DRIVER_PREFIX.length() + this.implPrefix.length());
		 String[] kvps = url.split(""&|;
		"");
		 for ( String kvp : kvps ) {
			 if ( kvp.length() == 0 ) {
				 continue;
			 }
			 String key, value;
			 if ( kvp.contains( ""="" ) ) {
				 String[] temp = kvp.split( ""="", 2 );
				 key = temp[0];
				 value = temp[1];
			 }
			 else {
				 key = kvp;
				 value = null;
			 }
			 key = key.toLowerCase( Locale.ENGLISH );
			 if ( !ps.containsKey( key ) ) {
				 if ( this.allowsMultipleValues( key ) ) {
					 List<String> values = new ArrayList<>();
					 if ( value.contains( "","" ) ) {
						 String[] vs = value.split( "","" );
						 for ( String v : vs ) {
							 values.add( v );
						 }
					 }
					 else {
						 values.add( value );
					 }
					 ps.put( key, values );
				 }
				 else {
					 ps.put( key, value );
				 }
			 }
			 else if ( this.allowsMultipleValues( key ) ) {
				 Object currValue = ps.get( key );
				 if ( currValue instanceof List<?> ) {
					 if ( value.contains( "","" ) ) {
						 String[] vs = value.split( "","" );
						 for ( String v : vs ) {
							 ( (List<Object>) currValue ).add( v );
						 }
					 }
					 else {
						 ( (List<Object>) currValue ).add( value );
					 }
				 }
				 else {
					 List<String> values = new ArrayList<>();
					 values.add( currValue.toString() );
					 if ( value.contains( "","" ) ) {
						 String[] vs = value.split( "","" );
						 for ( String v : vs ) {
							 values.add( v );
						 }
					 }
					 else {
						 values.add( value );
					 }
					 ps.put( key, values );
				 }
			 }
			 else {
				 LOGGER.warn( ""Cannot specify parameter "" + key + "" multiple times in the connection URL"" );
				 throw new SQLException( ""Invalid connection URL parameter "" + kvp + "" encountered, the parameter "" + key + "" may only be specified once"" );
			 }
		 }
		 if (props != null && props.containsKey(PARAM_CONFIG)) {
			 Properties external = this.loadProperties(props.getProperty(PARAM_CONFIG));
			 LOGGER.info(""Merging in external properties file "" + props.getProperty(PARAM_CONFIG));
			 this.mergeProperties(external, ps, false);
		 }
		 else if (ps.containsKey(PARAM_CONFIG)) {
			 Properties external = this.loadProperties(ps.getProperty(PARAM_CONFIG));
			 LOGGER.info(""Merging in external properties file "" + ps.getProperty(PARAM_CONFIG));
			 this.mergeProperties(external, ps, false);
		 }
		 if (props != null) {
			 this.mergeProperties(props, ps, true);
		 }
		 return ps;
	 }
	 private void mergeProperties(Properties source, Properties target, boolean overwriteOrAppendIfExists) {
		 for (Entry<Object, Object> e : source.entrySet()) {
			 String key = e.getKey().toString().toLowerCase(Locale.ENGLISH);
			 Object value = e.getValue();
			 if (target.containsKey(key)) {
				 if (overwriteOrAppendIfExists) {
					 if (this.allowsMultipleValues(key)) {
						 Object currValue = target.get(key);
						 if (currValue instanceof List<?>) {
							 ((List<Object>) currValue).add(value);
						 }
						 else {
							 List<String> values = new ArrayList<>();
							 values.add(currValue.toString());
							 values.add(value.toString());
							 target.put(key, values);
						 }
					 }
					 else {
						 target.put(key, value);
					 }
				 }
			 }
			 else {
				 target.put(key, value);
			 }
		 }
	 }
	 private Properties loadProperties(String resource) throws SQLException {
		 Properties ps = new Properties();
		 File propFile = new File(resource);
		 if (propFile.exists() && propFile.isFile()) {
			 try(FileInputStream input = new FileInputStream(propFile)) {
				 ps.load(input);
			 }
			 catch (FileNotFoundException e) {
				 throw new SQLException(""Located external properties file "" + propFile.getAbsolutePath() + "" on file system but it was removed before it could be read"", e);
			 }
			 catch (IOException e) {
				 throw new SQLException(""IO Error attempting to load external properties file "" + propFile.getAbsolutePath());
			 }
			 LOGGER.info(""Successfully loaded external properties file "" + propFile.getAbsolutePath());
		 }
		 else {
			 URL propURL = this.getClass().getResource(resource);
			 if (propURL != null) {
				 try(InputStream input = propURL.openStream()) {
					 ps.load(input);
				 }
				 catch (IOException e) {
					 throw new SQLException(""IO Error attempting to load class path properties file from resource "" + resource, e);
				 }
				 LOGGER.info(""Successfully loaded class path properties file from resource "" + resource);
			 }
			 else {
				 throw new SQLException( ""Unable to locate the specified external properties file on either the file system or the class path"");
			 }
		 }
		 for (Entry<Object, Object> e : ps.entrySet()) {
			 String key = e.getKey().toString().toLowerCase(Locale.ENGLISH);
			 if (this.allowsMultipleValues(key)) {
				 Object currValue = e.getValue();
				 if (currValue instanceof String) {
					 if (currValue.toString().contains("","")) {
						 String[] values = currValue.toString().split("","");
						 ps.put(e.getKey(), Arrays.asList(values));
					 }
				 }
			 }
		 }
		 return ps;
	 }
	 protected void modifyProperties(Properties props) {
	 }
	 protected boolean allowsMultipleValues(String key) {
		 if (PARAM_PRE_PROCESSOR.equals(key) || PARAM_POST_PROCESSOR.equals(key)) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 protected abstract JenaConnection connect(Properties props, int compatabilityLevel) throws SQLException;
	 public int getMajorVersion() {
		 return this.minorVer;
	 }
	 public int getMinorVersion() {
		 return this.majorVer;
	 }
	 public final DriverPropertyInfo[] getPropertyInfo(String url, Properties props) throws SQLException {
		 Properties ps = this.getEffectiveProperties(url, props);
		 List<DriverPropertyInfo> baseProps = new ArrayList<>();
		 DriverPropertyInfo jdbcCompatLevel = new DriverPropertyInfo(PARAM_JDBC_COMPATIBILITY, ps.getProperty( PARAM_JDBC_COMPATIBILITY, Integer.toString(JdbcCompatibility.DEFAULT)));
		 jdbcCompatLevel.description = ""Configures how compatible the driver will attempt to be with JDBC, primarily affects reported column types for result sets"";
		 jdbcCompatLevel.required = false;
		 String[] choices = new String[9];
		 for (int i = 0;
		 i < choices.length;
		 i++) {
			 choices[i] = Integer.toString(i + 1);
		 }
		 jdbcCompatLevel.choices = choices;
		 baseProps.add(jdbcCompatLevel);
		 DriverPropertyInfo preProcessor = new DriverPropertyInfo(PARAM_PRE_PROCESSOR, String.join("","", this.getValues(ps, PARAM_PRE_PROCESSOR)));
		 preProcessor.description = ""Configures pre-processors which are used to amend SPARQL text, queries or updates before these are passed to the underlying SPARQL engine, multiple fully qualified class names may be specified"";
		 preProcessor.required = false;
		 baseProps.add(preProcessor);
		 DriverPropertyInfo logging = new DriverPropertyInfo(PARAM_LOGGING, ps.getProperty(PARAM_LOGGING));
		 logging.description = ""Sets the path to a log4j properties file for configuring logging, the file system is considered first and then the classpath. If not set defaults to log4j.properties"";
		 logging.required = false;
		 baseProps.add(logging);
		 return this.getPropertyInfo(ps, baseProps);
	 }
	 protected final void copyBaseProperties(DriverPropertyInfo[] finalProps, List<DriverPropertyInfo> baseProps, int start) {
		 for (int i = start, j = 0;
		 i < finalProps.length && j < baseProps.size();
		 i++, j++) {
			 finalProps[i] = baseProps.get(j);
		 }
	 }
	 protected abstract DriverPropertyInfo[] getPropertyInfo(Properties connProps, List<DriverPropertyInfo> baseDriverProps);
	 public final boolean jdbcCompliant() {
		 return false;
	 }
	 protected List<String> getValues(Properties props, String key) throws SQLException {
		 Object obj = props.get(key);
		 if (obj == null) return new ArrayList<>();
		 if (obj instanceof List<?>) return (List<String>) obj;
		 if (obj instanceof String) {
			 List<String> values = new ArrayList<>();
			 values.add(obj.toString());
			 return values;
		 }
		 else {
			 throw new SQLException(""Value given for parameter "" + key + "" was not a string/list of strings"");
		 }
	 }
	 protected boolean isTrue(Properties props, String key) {
		 Object obj = props.get(key);
		 if (obj == null) return false;
		 String value = obj.toString().toLowerCase(Locale.ENGLISH).trim();
		 return ""true"".equals(value);
	 }
	 protected boolean getBoolean(Properties props, String key, boolean defaultValue) {
		 Object obj = props.get(key);
		 if (obj == null) return defaultValue;
		 String value = obj.toString().toLowerCase(Locale.ENGLISH).trim();
		 if (""true"".equals(value)) {
			 return true;
		 }
		 else if (""false"".equals(value)) {
			 return false;
		 }
		 else {
			 return defaultValue;
		 }
	 }
	 protected boolean isSetToValue(Properties props, String key, String value) {
		 Object obj = props.get(key);
		 if (obj == null) return value == null;
		 if (value == null) return false;
		 String actualValue = obj.toString().trim().toLowerCase(Locale.ENGLISH);
		 return value.equals(actualValue);
	 }
	 public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException {
		throw new SQLFeatureNotSupportedException() ;
	}
}",1,0,0,0
"public class MutableManifestElement {
	 private enum ParameterType {
		 DIRECTIVE("":=""), ATTRIBUTE(""="");
		 public final String separator;
		 ParameterType(String separator) {
			 this.separator = separator;
		 }
	 }
	 private static final Pattern OSGI_EXTENDED_PATTERN = Pattern.compile(""([a-zA-Z0-9_-]|\\+)+"");
	 private static final String DIRECTIVE_INDENT = "" "";
	 private static final String VALUE_COMPONENT_INDENT = "" "";
	 private static final int NO_WRAP = Integer.MAX_VALUE;
	 private static final String XFRIENDS_DIRECTIVE = ""x-friends"";
	 private static final int DEFAULT_WRAP_FOR_LONG_DIRECTIVES = 3;
	 private final String value;
	 private final LinkedHashMap<String, List<String>> directives;
	 private final LinkedHashMap<String, List<String>> attributes;
	 public MutableManifestElement(String value, Map<String, String> attributes, Map<String, String> directives) {
		 this.value = value;
		 this.attributes = toMapOfSingletonLists(attributes);
		 this.directives = toMapOfSingletonLists(directives);
	 }
	 private LinkedHashMap<String, List<String>> toMapOfSingletonLists(Map<String, String> params) {
		 LinkedHashMap<String, List<String>> withSingletonLists = new LinkedHashMap<>();
		 for (Map.Entry<String, String> param : params.entrySet()) {
			 withSingletonLists.put(param.getKey(), Collections.singletonList(param.getValue()));
		 }
		 return withSingletonLists;
	 }
	 private MutableManifestElement(ManifestElement manifestElement) {
		 this.value = manifestElement.getValue();
		 this.attributes = new LinkedHashMap<>();
		 this.directives = new LinkedHashMap<>();
		 Enumeration<String> attrKeys = manifestElement.getKeys();
		 if (attrKeys != null) {
			 while (attrKeys.hasMoreElements()) {
				 String attrKey = attrKeys.nextElement();
				 this.attributes.put(attrKey, Arrays.asList(manifestElement.getAttributes(attrKey)));
			 }
		 }
		 Enumeration<String> directiveKeys = manifestElement.getDirectiveKeys();
		 if (directiveKeys != null) {
			 while (directiveKeys.hasMoreElements()) {
				 String directiveName = directiveKeys.nextElement();
				 this.directives.put(directiveName, Arrays.asList(manifestElement.getDirectives(directiveName)));
			 }
		 }
	 }
	 public static List<MutableManifestElement> parseHeader(String name, String value) throws BundleException {
		 ManifestElement[] manifestElements = ManifestElement.parseHeader(name, value);
		 if (manifestElements == null) {
			 return null;
		 }
		 List<MutableManifestElement> mutableManifestElements = new ArrayList<>();
		 for (ManifestElement manifestElement : manifestElements) {
			 mutableManifestElements.add(new MutableManifestElement(manifestElement));
		 }
		 return mutableManifestElements;
	 }
	 public String getValue() {
		 return value;
	 }
	 public boolean setAttribute(String key, String value) {
		 if (value == null) {
			 if (attributes.containsKey(key)) {
				 attributes.remove(key);
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 else {
			 List<String> newValue = Collections.singletonList(value);
			 if (!newValue.equals(attributes.get(key))) {
				 attributes.put(key, Collections.singletonList(value));
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
	 }
	 public String getAttribute(String key) {
		 List<String> values = attributes.get(key);
		 if (values != null && !values.isEmpty()) {
			 return values.get(values.size() - 1);
		 }
		 return null;
	 }
	 public String toString() {
		 return write();
	 }
	 public String write() {
		 if (directives.isEmpty() && attributes.isEmpty()) {
			 return value;
		 }
		 StringBuilder builder = new StringBuilder(value);
		 for (Entry<String, List<String>> attribute : attributes.entrySet()) {
			 for (String attributeValue : attribute.getValue()) {
				 builder.append(writeParameter(attribute.getKey(), attributeValue, ParameterType.ATTRIBUTE, NO_WRAP));
			 }
		 }
		 List<String> uses = directives.get(Constants.USES_DIRECTIVE);
		 List<String> xfriends = directives.get(XFRIENDS_DIRECTIVE);
		 for (Entry<String, List<String>> directive : directives.entrySet()) {
			 String directiveName = directive.getKey();
			 if (!directiveName.equals(Constants.USES_DIRECTIVE) && !directiveName.equals(XFRIENDS_DIRECTIVE)) {
				 for (String directiveValue : directive.getValue()) {
					 builder.append(writeParameter(directiveName, directiveValue, ParameterType.DIRECTIVE, NO_WRAP));
				 }
			 }
		 }
		 int longDirectiveLimit = DEFAULT_WRAP_FOR_LONG_DIRECTIVES;
		 if (uses != null && xfriends != null) {
			 longDirectiveLimit = 1;
		 }
		 if (xfriends != null) {
			 for (String directiveValue : xfriends) {
				 builder.append(writeParameter(XFRIENDS_DIRECTIVE, directiveValue, ParameterType.DIRECTIVE, longDirectiveLimit));
			 }
		 }
		 if (uses != null) {
			 for (String directiveValue : uses) {
				 builder.append(writeParameter(Constants.USES_DIRECTIVE, directiveValue, ParameterType.DIRECTIVE, longDirectiveLimit));
			 }
		 }
		 return builder.toString();
	 }
	 private static String writeParameter(String paramName, String parameterValue, ParameterType paramType, int valueComponentLimit) {
		 String[] valueComponents = ManifestElement.getArrayFromList(parameterValue, "","");
		 boolean breakLines = valueComponents.length >= valueComponentLimit;
		 StringBuilder builder = new StringBuilder();
		 builder.append("";
		"");
		 if (breakLines) {
			 builder.append(""\n"" + DIRECTIVE_INDENT);
		 }
		 builder.append(paramName);
		 builder.append(paramType.separator);
		 if (paramValueNeedsQuotes(parameterValue)) {
			 builder.append('\""');
			 for (int i = 0;
			 i < valueComponents.length;
			 i++) {
				 builder.append(valueComponents[i]);
				 if (i != valueComponents.length - 1) {
					 builder.append("","");
					 if (breakLines) {
						 builder.append(""\n"" + VALUE_COMPONENT_INDENT);
					 }
				 }
			 }
			 builder.append('\""');
		 }
		 else {
			 builder.append(parameterValue);
		 }
		 return builder.toString();
	 }
	 private static boolean paramValueNeedsQuotes(String value) {
		 return !OSGI_EXTENDED_PATTERN.matcher(value).matches();
	 }
}",0,0,0,0
"public final boolean anyErrorMessage(){
	return anyMessage(FeedbackMessage.ERROR);
}",0,0,0,0
"protected void populateTreeItem(WebMarkupContainer item, int level){
	Object node = item.getDefaultModelObject();
	Component junctionLink = newJunctionLink(item, JUNCTION_LINK_ID, node);
	junctionLink.setComponentBorder(new JunctionBorder(node, level));
	item.add(junctionLink);
	Component nodeComponent = newNodeComponent(NODE_COMPONENT_ID,(IModel<Object>)item.getDefaultModel());
	item.add(nodeComponent);
	item.add(new AbstractBehavior(){
		private static final long serialVersionUID = 1L;
		public void onComponentTag(Component component, ComponentTag tag){
			Object node = component.getDefaultModelObject();
			String klass = getItemClass(node);
			if (!Strings.isEmpty(klass)){
				CharSequence oldClass = tag.getString(""class"");
				if (Strings.isEmpty(oldClass)){
					tag.put(""class"", klass);
				}
				else{
					tag.put(""class"", oldClass + "" "" + klass);
				}
			}
		}
	}
	);
}",0,0,0,0
"private void getAndMoveToFrontDecode() throws IOException {
	 this.origPtr = bsR(24);
	 recvDecodingTables();
	 final InputStream inShadow = this.in;
	 final Data dataShadow = this.data;
	 final byte[] ll8 = dataShadow.ll8;
	 final int[] unzftab = dataShadow.unzftab;
	 final byte[] selector = dataShadow.selector;
	 final byte[] seqToUnseq = dataShadow.seqToUnseq;
	 final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;
	 final int[] minLens = dataShadow.minLens;
	 final int[][] limit = dataShadow.limit;
	 final int[][] base = dataShadow.base;
	 final int[][] perm = dataShadow.perm;
	 final int limitLast = this.blockSize100k * 100000;
	 for (int i = 256;
	 --i >= 0;
	) {
		 yy[i] = (char) i;
		 unzftab[i] = 0;
	 }
	 int groupNo = 0;
	 int groupPos = G_SIZE - 1;
	 final int eob = this.nInUse + 1;
	 int nextSym = getAndMoveToFrontDecode0(0);
	 int bsBuffShadow = this.bsBuff;
	 int bsLiveShadow = this.bsLive;
	 int lastShadow = -1;
	 int zt = selector[groupNo] & 0xff;
	 int[] base_zt = base[zt];
	 int[] limit_zt = limit[zt];
	 int[] perm_zt = perm[zt];
	 int minLens_zt = minLens[zt];
	 while (nextSym != eob) {
		 if ((nextSym == RUNA) || (nextSym == RUNB)) {
			 int s = -1;
			 for (int n = 1;
			 true;
			 n <<= 1) {
				 if (nextSym == RUNA) {
					 s += n;
				 }
				 else if (nextSym == RUNB) {
					 s += n << 1;
				 }
				 else {
					 break;
				 }
				 if (groupPos == 0) {
					 groupPos = G_SIZE - 1;
					 zt = selector[++groupNo] & 0xff;
					 base_zt = base[zt];
					 limit_zt = limit[zt];
					 perm_zt = perm[zt];
					 minLens_zt = minLens[zt];
				 }
				 else {
					 groupPos--;
				 }
				 int zn = minLens_zt;
				 while (bsLiveShadow < zn) {
					 final int thech = inShadow.read();
					 if (thech >= 0) {
						 bsBuffShadow = (bsBuffShadow << 8) | thech;
						 bsLiveShadow += 8;
						 continue;
					 }
					 else {
						 throw new IOException(""unexpected end of stream"");
					 }
				 }
				 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);
				 bsLiveShadow -= zn;
				 while (zvec > limit_zt[zn]) {
					 zn++;
					 while (bsLiveShadow < 1) {
						 final int thech = inShadow.read();
						 if (thech >= 0) {
							 bsBuffShadow = (bsBuffShadow << 8) | thech;
							 bsLiveShadow += 8;
							 continue;
						 }
						 else {
							 throw new IOException(""unexpected end of stream"");
						 }
					 }
					 bsLiveShadow--;
					 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);
				 }
				 nextSym = perm_zt[zvec - base_zt[zn]];
			 }
			 final byte ch = seqToUnseq[yy[0]];
			 unzftab[ch & 0xff] += s + 1;
			 while (s-- >= 0) {
				 ll8[++lastShadow] = ch;
			 }
			 if (lastShadow >= limitLast) {
				 throw new IOException(""block overrun"");
			 }
		 }
		 else {
			 if (++lastShadow >= limitLast) {
				 throw new IOException(""block overrun"");
			 }
			 final char tmp = yy[nextSym - 1];
			 unzftab[seqToUnseq[tmp] & 0xff]++;
			 ll8[lastShadow] = seqToUnseq[tmp];
			 if (nextSym <= 16) {
				 for (int j = nextSym - 1;
				 j > 0;
				) {
					 yy[j] = yy[--j];
				 }
			 }
			 else {
				 System.arraycopy(yy, 0, yy, 1, nextSym - 1);
			 }
			 yy[0] = tmp;
			 if (groupPos == 0) {
				 groupPos = G_SIZE - 1;
				 zt = selector[++groupNo] & 0xff;
				 base_zt = base[zt];
				 limit_zt = limit[zt];
				 perm_zt = perm[zt];
				 minLens_zt = minLens[zt];
			 }
			 else {
				 groupPos--;
			 }
			 int zn = minLens_zt;
			 while (bsLiveShadow < zn) {
				 final int thech = inShadow.read();
				 if (thech >= 0) {
					 bsBuffShadow = (bsBuffShadow << 8) | thech;
					 bsLiveShadow += 8;
					 continue;
				 }
				 else {
					 throw new IOException(""unexpected end of stream"");
				 }
			 }
			 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);
			 bsLiveShadow -= zn;
			 while (zvec > limit_zt[zn]) {
				 zn++;
				 while (bsLiveShadow < 1) {
					 final int thech = inShadow.read();
					 if (thech >= 0) {
						 bsBuffShadow = (bsBuffShadow << 8) | thech;
						 bsLiveShadow += 8;
						 continue;
					 }
					 else {
						 throw new IOException(""unexpected end of stream"");
					 }
				 }
				 bsLiveShadow--;
				 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);
			 }
			 nextSym = perm_zt[zvec - base_zt[zn]];
		 }
	 }
	 this.last = lastShadow;
	 this.bsLive = bsLiveShadow;
	 this.bsBuff = bsBuffShadow;
 }",0,0,1,0
"private String rectangleCoordinates(int x1, int y1, int x2, int y2){
	return x1 + "","" + y1 + "","" + x2 + "","" + y2;
}",0,0,0,0
"public static void createTray() {
	if (!SystemTray.isSupported()) {
		Logger.log(""SystemTray is not supported"");
		return;
	}
	if (XDMUtils.detectOS() == XDMUtils.LINUX) {
		return;
	}
	final PopupMenu popup = new PopupMenu();
	final TrayIcon trayIcon = new TrayIcon(ImageResource.get(""icon.png"").getImage());
	trayIcon.setImageAutoSize(true);
	final SystemTray tray = SystemTray.getSystemTray();
	act = new ActionListener() {
		public void actionPerformed(ActionEvent e) {
			MenuItem c = (MenuItem) e.getSource();
			String name = c.getName();
			System.out.println(name);
			if (""ADD_URL"".equals(name)) {
				XDMApp.getInstance().addDownload(null, null);
			}
			 else if (""RESTORE"".equals(name)) {
				XDMApp.getInstance().showMainWindow();
			}
			 else if (""EXIT"".equals(name)) {
				XDMApp.getInstance().exit();
			}
		}
	}
	;
	MenuItem addUrlItem = new MenuItem(StringResource.get(""MENU_ADD_URL""));
	addUrlItem.addActionListener(act);
	addUrlItem.setName(""ADD_URL"");
	MenuItem restoreItem = new MenuItem(StringResource.get(""MSG_RESTORE""));
	restoreItem.addActionListener(act);
	restoreItem.setName(""RESTORE"");
	MenuItem exitItem = new MenuItem(StringResource.get(""MENU_EXIT""));
	exitItem.addActionListener(act);
	exitItem.setName(""EXIT"");
	popup.add(addUrlItem);
	popup.add(restoreItem);
	popup.add(exitItem);
	trayIcon.setPopupMenu(popup);
	try {
		tray.add(trayIcon);
	}
	 catch (AWTException e) {
		Logger.log(""TrayIcon could not be added."");
	}
}",0,0,1,0
"public synchronized void setBackgroundColor(Color backgroundColor){
	backgroundColorRgb = backgroundColor.getRGB();
	invalidate();
}",0,0,0,0
"public abstract class ExternalLoadBalancerDeviceManagerImpl extends AdapterBase implements ExternalLoadBalancerDeviceManager, ResourceStateAdapter {
	 NetworkExternalLoadBalancerDao _networkExternalLBDao;
	 ExternalLoadBalancerDeviceDao _externalLoadBalancerDeviceDao;
	 HostDao _hostDao;
	 DataCenterDao _dcDao;
	 NetworkModel _networkModel;
	 NetworkOrchestrationService _networkMgr;
	 InlineLoadBalancerNicMapDao _inlineLoadBalancerNicMapDao;
	 NicDao _nicDao;
	 AgentManager _agentMgr;
	 ResourceManager _resourceMgr;
	 IPAddressDao _ipAddressDao;
	 VlanDao _vlanDao;
	 NetworkOfferingDao _networkOfferingDao;
	 AccountDao _accountDao;
	 PhysicalNetworkDao _physicalNetworkDao;
	 PhysicalNetworkServiceProviderDao _physicalNetworkServiceProviderDao;
	 AccountManager _accountMgr;
	 UserStatisticsDao _userStatsDao;
	 NetworkDao _networkDao;
	 DomainRouterDao _routerDao;
	 LoadBalancerDao _loadBalancerDao;
	 PortForwardingRulesDao _portForwardingRulesDao;
	 ConfigurationDao _configDao;
	 HostDetailsDao _hostDetailDao;
	 NetworkExternalLoadBalancerDao _networkLBDao;
	 NetworkServiceMapDao _ntwkSrvcProviderDao;
	 NetworkExternalFirewallDao _networkExternalFirewallDao;
	 ExternalFirewallDeviceDao _externalFirewallDeviceDao;
	 protected HostPodDao _podDao = null;
	 IpAddressManager _ipAddrMgr;
	 protected VirtualMachineManager _itMgr;
	 VMInstanceDao _vmDao;
	 VMTemplateDao _templateDao;
	 ServiceOfferingDao _serviceOfferingDao;
	 PhysicalNetworkServiceProviderDao _physicalProviderDao;
	 VirtualRouterProviderDao _vrProviderDao;
	 private long _defaultLbCapacity;
	 private static final org.apache.log4j.Logger s_logger = Logger.getLogger(ExternalLoadBalancerDeviceManagerImpl.class);
	 public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, final String deviceName, ServerResource resource, final boolean gslbProvider, final boolean exclusiveGslbProivider, final String gslbSitePublicIp, final String gslbSitePrivateIp) {
		 PhysicalNetworkVO pNetwork = null;
		 final NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);
		 long zoneId;
		 if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {
			 throw new InvalidParameterValueException(""Atleast one of the required parameters (url, username, password,"" + "" server resource, zone id/physical network id) is not specified or a valid parameter."");
		 }
		 pNetwork = _physicalNetworkDao.findById(physicalNetworkId);
		 if (pNetwork == null) {
			 throw new InvalidParameterValueException(""Could not find phyical network with ID: "" + physicalNetworkId);
		 }
		 zoneId = pNetwork.getDataCenterId();
		 PhysicalNetworkServiceProviderVO ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());
		 ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());
		 if (ntwkSvcProvider == null) {
			 throw new CloudRuntimeException(""Network Service Provider: "" + ntwkDevice.getNetworkServiceProvder() + "" is not enabled in the physical network: "" + physicalNetworkId + ""to add this device"");
		 }
		 else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {
			 throw new CloudRuntimeException(""Network Service Provider: "" + ntwkSvcProvider.getProviderName() + "" is in shutdown state in the physical network: "" + physicalNetworkId + ""to add this device"");
		 }
		 if (gslbProvider) {
			 ExternalLoadBalancerDeviceVO zoneGslbProvider = _externalLoadBalancerDeviceDao.findGslbServiceProvider(physicalNetworkId, ntwkDevice.getNetworkServiceProvder());
			 if (zoneGslbProvider != null) {
				 throw new CloudRuntimeException(""There is a GSLB service provider configured in the zone alredy."");
			 }
		 }
		 URI uri;
		 try {
			 uri = new URI(url);
		 }
		 catch (Exception e) {
			 s_logger.debug(e);
			 throw new InvalidParameterValueException(e.getMessage());
		 }
		 String ipAddress = uri.getHost();
		 Map hostDetails = new HashMap<String, String>();
		 String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);
		 hostDetails.put(""name"", hostName);
		 hostDetails.put(""guid"", UUID.randomUUID().toString());
		 hostDetails.put(""zoneId"", String.valueOf(pNetwork.getDataCenterId()));
		 hostDetails.put(""ip"", ipAddress);
		 hostDetails.put(""physicalNetworkId"", String.valueOf(pNetwork.getId()));
		 hostDetails.put(""username"", username);
		 hostDetails.put(""password"", password);
		 hostDetails.put(""deviceName"", deviceName);
		 Map<String, String> configParams = new HashMap<String, String>();
		 UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);
		 hostDetails.putAll(configParams);
		 try {
			 resource.configure(hostName, hostDetails);
			 final Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);
			 if (host != null) {
				 final boolean dedicatedUse = (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED)) : false;
				 long capacity = NumbersUtil.parseLong(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);
				 if (capacity == 0) {
					 capacity = _defaultLbCapacity;
				 }
				 final long capacityFinal = capacity;
				 final PhysicalNetworkVO pNetworkFinal = pNetwork;
				 return Transaction.execute(new TransactionCallback<ExternalLoadBalancerDeviceVO>() {
					 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {
						 ExternalLoadBalancerDeviceVO lbDeviceVO = new ExternalLoadBalancerDeviceVO(host.getId(), pNetworkFinal.getId(), ntwkDevice.getNetworkServiceProvder(), deviceName, capacityFinal, dedicatedUse, gslbProvider);
						 if (gslbProvider) {
							 lbDeviceVO.setGslbSitePublicIP(gslbSitePublicIp);
							 lbDeviceVO.setGslbSitePrivateIP(gslbSitePrivateIp);
							 lbDeviceVO.setExclusiveGslbProvider(exclusiveGslbProivider);
						 }
						 _externalLoadBalancerDeviceDao.persist(lbDeviceVO);
						 DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));
						 _hostDetailDao.persist(hostDetail);
						 return lbDeviceVO;
					 }
				 }
				);
			 }
			 else {
				 throw new CloudRuntimeException(""Failed to add load balancer device due to internal error."");
			 }
		 }
		 catch (ConfigurationException e) {
			 throw new CloudRuntimeException(e.getMessage());
		 }
	 }
	 public boolean deleteExternalLoadBalancer(long hostId) {
		 HostVO externalLoadBalancer = _hostDao.findById(hostId);
		 if (externalLoadBalancer == null) {
			 throw new InvalidParameterValueException(""Could not find an external load balancer with ID: "" + hostId);
		 }
		 DetailVO lbHostDetails = _hostDetailDao.findDetail(hostId, ApiConstants.LOAD_BALANCER_DEVICE_ID);
		 long lbDeviceId = Long.parseLong(lbHostDetails.getValue());
		 ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);
		 if (lbDeviceVo.getAllocationState() == LBDeviceAllocationState.Provider) {
			 List<ExternalLoadBalancerDeviceVO> lbDevices = _externalLoadBalancerDeviceDao.listAll();
			 if (lbDevices != null) {
				 for (ExternalLoadBalancerDeviceVO lbDevice : lbDevices) {
					 if (lbDevice.getParentHostId() == hostId) {
						 throw new CloudRuntimeException( ""This load balancer device can not be deleted as there are one or more load balancers applainces provisioned by cloudstack on the device."");
					 }
				 }
			 }
		 }
		 else {
			 List<NetworkExternalLoadBalancerVO> networks = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);
			 if ((networks != null) && !networks.isEmpty()) {
				 throw new CloudRuntimeException(""Delete can not be done as there are networks using this load balancer device "");
			 }
		 }
		 try {
			 externalLoadBalancer.setResourceState(ResourceState.Maintenance);
			 _hostDao.update(hostId, externalLoadBalancer);
			 _resourceMgr.deleteHost(hostId, false, false);
			 _externalLoadBalancerDeviceDao.remove(lbDeviceId);
			 return true;
		 }
		 catch (Exception e) {
			 s_logger.debug(e);
			 return false;
		 }
	 }
	 public List<Host> listExternalLoadBalancers(long physicalNetworkId, String deviceName) {
		 List<Host> lbHosts = new ArrayList<Host>();
		 NetworkDevice lbNetworkDevice = NetworkDevice.getNetworkDevice(deviceName);
		 PhysicalNetworkVO pNetwork = null;
		 pNetwork = _physicalNetworkDao.findById(physicalNetworkId);
		 if ((pNetwork == null) || (lbNetworkDevice == null)) {
			 throw new InvalidParameterValueException(""Atleast one of the required parameter physical networkId, device name is invalid."");
		 }
		 PhysicalNetworkServiceProviderVO ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), lbNetworkDevice.getNetworkServiceProvder());
		 if (ntwkSvcProvider == null) {
			 return null;
		 }
		 List<ExternalLoadBalancerDeviceVO> lbDevices = _externalLoadBalancerDeviceDao.listByPhysicalNetworkAndProvider(physicalNetworkId, ntwkSvcProvider.getProviderName());
		 for (ExternalLoadBalancerDeviceVO provderInstance : lbDevices) {
			 lbHosts.add(_hostDao.findById(provderInstance.getHostId()));
		 }
		 return lbHosts;
	 }
	 public ExternalLoadBalancerResponse createExternalLoadBalancerResponse(Host externalLoadBalancer) {
		 Map<String, String> lbDetails = _hostDetailDao.findDetails(externalLoadBalancer.getId());
		 ExternalLoadBalancerResponse response = new ExternalLoadBalancerResponse();
		 response.setId(externalLoadBalancer.getUuid());
		 response.setIpAddress(externalLoadBalancer.getPrivateIpAddress());
		 response.setUsername(lbDetails.get(""username""));
		 response.setPublicInterface(lbDetails.get(""publicInterface""));
		 response.setPrivateInterface(lbDetails.get(""privateInterface""));
		 response.setNumRetries(lbDetails.get(""numRetries""));
		 return response;
	 }
	 public String getExternalLoadBalancerResourceGuid(long physicalNetworkId, String deviceName, String ip) {
		 return physicalNetworkId + ""-"" + deviceName + ""-"" + ip;
	 }
	 public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network) {
		 NetworkExternalLoadBalancerVO lbDeviceForNetwork = _networkExternalLBDao.findByNetworkId(network.getId());
		 if (lbDeviceForNetwork != null) {
			 long lbDeviceId = lbDeviceForNetwork.getExternalLBDeviceId();
			 ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);
			 assert (lbDeviceVo != null);
			 return lbDeviceVo;
		 }
		 return null;
	 }
	 public void setExternalLoadBalancerForNetwork(Network network, long externalLBDeviceID) {
		 NetworkExternalLoadBalancerVO lbDeviceForNetwork = new NetworkExternalLoadBalancerVO(network.getId(), externalLBDeviceID);
		 _networkExternalLBDao.persist(lbDeviceForNetwork);
	 }
	 protected ExternalLoadBalancerDeviceVO allocateLoadBalancerForNetwork(final Network guestConfig) throws InsufficientCapacityException {
		 boolean retry = true;
		 boolean tryLbProvisioning = false;
		 ExternalLoadBalancerDeviceVO lbDevice = null;
		 long physicalNetworkId = guestConfig.getPhysicalNetworkId();
		 NetworkOfferingVO offering = _networkOfferingDao.findById(guestConfig.getNetworkOfferingId());
		 String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(guestConfig.getId(), Service.Lb);
		 while (retry) {
			 GlobalLock deviceMapLock = GlobalLock.getInternLock(""LoadBalancerAllocLock"");
			 try {
				 if (deviceMapLock.lock(120)) {
					 try {
						 final boolean dedicatedLB = offering.isDedicatedLB();
						 try {
							 lbDevice = Transaction.execute(new TransactionCallbackWithException<ExternalLoadBalancerDeviceVO, InsufficientCapacityException>() {
								 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) throws InsufficientCapacityException {
									 ExternalLoadBalancerDeviceVO lbDevice = findSuitableLoadBalancerForNetwork(guestConfig, dedicatedLB);
									 long lbDeviceId = lbDevice.getId();
									 NetworkExternalLoadBalancerVO networkLB = new NetworkExternalLoadBalancerVO(guestConfig.getId(), lbDeviceId);
									 _networkExternalLBDao.persist(networkLB);
									 lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);
									 _externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);
									 return lbDevice;
								 }
							 }
							);
							 tryLbProvisioning = false;
							 retry = false;
						 }
						 catch (InsufficientCapacityException exception) {
							 if (tryLbProvisioning) {
								 retry = false;
								 s_logger.warn(""There are no load balancer device with the capacity for implementing this network"");
								 throw exception;
							 }
							 else {
								 tryLbProvisioning = true;
							 }
						 }
					 }
					 finally {
						 deviceMapLock.unlock();
					 }
				 }
			 }
			 finally {
				 deviceMapLock.releaseRef();
			 }
			 if (tryLbProvisioning) {
				 List<ExternalLoadBalancerDeviceVO> providerLbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Provider);
				 if ((providerLbDevices != null) && (!providerLbDevices.isEmpty())) {
					 for (ExternalLoadBalancerDeviceVO lbProviderDevice : providerLbDevices) {
						 if (lbProviderDevice.getState() == LBDeviceState.Enabled) {
							 DataCenterIpAddressVO dcPrivateIp = _dcDao.allocatePrivateIpAddress(guestConfig.getDataCenterId(), lbProviderDevice.getUuid());
							 if (dcPrivateIp == null) {
								 throw new InsufficientNetworkCapacityException(""failed to acquire a priavate IP in the zone "" + guestConfig.getDataCenterId() + "" needed for management IP of the load balancer appliance"", DataCenter.class, guestConfig.getDataCenterId());
							 }
							 Pod pod = _podDao.findById(dcPrivateIp.getPodId());
							 String lbIP = dcPrivateIp.getIpAddress();
							 String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());
							 String gateway = pod.getGateway();
							 CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);
							 CreateLoadBalancerApplianceAnswer createLbAnswer = null;
							 try {
								 createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);
								 if (createLbAnswer == null || !createLbAnswer.getResult()) {
									 s_logger.error(""Could not provision load balancer instance on the load balancer device "" + lbProviderDevice.getId());
									 continue;
								 }
							 }
							 catch (Exception agentException) {
								 s_logger.error(""Could not provision load balancer instance on the load balancer device "" + lbProviderDevice.getId() + "" due to "" + agentException.getMessage());
								 continue;
							 }
							 String username = createLbAnswer.getUsername();
							 String password = createLbAnswer.getPassword();
							 String publicIf = createLbAnswer.getPublicInterface();
							 String privateIf = createLbAnswer.getPrivateInterface();
							 String dedicatedLb = offering.isDedicatedLB() ? ""true"" : ""false"";
							 String capacity = Long.toString(lbProviderDevice.getCapacity());
							 PublicIp publicIp = _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null, null, false, false);
							 String publicIPNetmask = publicIp.getVlanNetmask();
							 String publicIPgateway = publicIp.getVlanGateway();
							 String publicIP = publicIp.getAddress().toString();
							 String publicIPVlanTag="""";
							 try {
								 publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());
							 }
							 catch (URISyntaxException e) {
								 s_logger.error(""Failed to parse public ip vlan tag"" + e.getMessage());
							 }
							 String url = ""https: ""&cloudmanaged=true"" + ""&publicip="" + publicIP + ""&publicipnetmask="" + publicIPNetmask + ""&lbdevicecapacity="" + capacity + ""&publicipvlan="" + publicIPVlanTag + ""&publicipgateway="" + publicIPgateway;
							 ExternalLoadBalancerDeviceVO lbAppliance = null;
							 try {
								 lbAppliance = addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(), createLbAnswer.getServerResource(), false, false, null, null);
							 }
							 catch (Exception e) {
								 s_logger.error(""Failed to add load balancer appliance in to cloudstack due to "" + e.getMessage() + "". So provisioned load balancer appliance will be destroyed."");
							 }
							 if (lbAppliance != null) {
								 ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());
								 managedLb.setIsManagedDevice(true);
								 managedLb.setParentHostId(lbProviderDevice.getHostId());
								 _externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);
							 }
							 else {
								 DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);
								 DestroyLoadBalancerApplianceAnswer answer = null;
								 try {
									 answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);
									 if (answer == null || !answer.getResult()) {
										 s_logger.warn(""Failed to destroy load balancer appliance created"");
									 }
									 else {
										 _dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);
										 _ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());
									 }
								 }
								 catch (Exception e) {
									 s_logger.warn(""Failed to destroy load balancer appliance created for the network"" + guestConfig.getId() + "" due to "" + e.getMessage());
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return lbDevice;
	 }
	 public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException {
		 long physicalNetworkId = network.getPhysicalNetworkId();
		 List<ExternalLoadBalancerDeviceVO> lbDevices = null;
		 String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(network.getId(), Service.Lb);
		 assert (provider != null);
		 if (dedicatedLb) {
			 lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);
			 if (lbDevices != null && !lbDevices.isEmpty()) {
				 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {
					 if (lbdevice.getState() == LBDeviceState.Enabled && lbdevice.getIsDedicatedDevice()) {
						 return lbdevice;
					 }
				 }
			 }
		 }
		 else {
			 lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Shared);
			 if (lbDevices != null) {
				 ExternalLoadBalancerDeviceVO maxFreeCapacityLbdevice = null;
				 long maxFreeCapacity = 0;
				 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {
					 if (lbdevice.getState() != LBDeviceState.Enabled) {
						 continue;
					 }
					 List<NetworkExternalLoadBalancerVO> mappedNetworks = _networkExternalLBDao.listByLoadBalancerDeviceId(lbdevice.getId());
					 long usedCapacity = ((mappedNetworks == null) || (mappedNetworks.isEmpty())) ? 0 : mappedNetworks.size();
					 long fullCapacity = lbdevice.getCapacity();
					 if (fullCapacity == 0) {
						 fullCapacity = _defaultLbCapacity;
					 }
					 long freeCapacity = fullCapacity - usedCapacity;
					 if (freeCapacity > 0) {
						 if (maxFreeCapacityLbdevice == null) {
							 maxFreeCapacityLbdevice = lbdevice;
							 maxFreeCapacity = freeCapacity;
						 }
						 else if (freeCapacity > maxFreeCapacity) {
							 maxFreeCapacityLbdevice = lbdevice;
							 maxFreeCapacity = freeCapacity;
						 }
					 }
				 }
				 if (maxFreeCapacityLbdevice != null) {
					 return maxFreeCapacityLbdevice;
				 }
			 }
			 lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);
			 if (lbDevices != null && !lbDevices.isEmpty()) {
				 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {
					 if (lbdevice.getState() == LBDeviceState.Enabled && !lbdevice.getIsDedicatedDevice()) {
						 return lbdevice;
					 }
				 }
			 }
		 }
		 throw new InsufficientNetworkCapacityException(""Unable to find a load balancing provider with sufficient capcity "" + "" to implement the network"", Network.class, network.getId());
	 }
	 protected boolean freeLoadBalancerForNetwork(final Network guestConfig) {
		 GlobalLock deviceMapLock = GlobalLock.getInternLock(""LoadBalancerAllocLock"");
		 try {
			 if (deviceMapLock.lock(120)) {
				 ExternalLoadBalancerDeviceVO lbDevice = Transaction.execute(new TransactionCallback<ExternalLoadBalancerDeviceVO>() {
					 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {
						 NetworkExternalLoadBalancerVO networkLBDevice = _networkExternalLBDao.findByNetworkId(guestConfig.getId());
						 long lbDeviceId = networkLBDevice.getExternalLBDeviceId();
						 _networkExternalLBDao.remove(networkLBDevice.getId());
						 List<NetworkExternalLoadBalancerVO> ntwksMapped = _networkExternalLBDao.listByLoadBalancerDeviceId(networkLBDevice.getExternalLBDeviceId());
						 ExternalLoadBalancerDeviceVO lbDevice = _externalLoadBalancerDeviceDao.findById(lbDeviceId);
						 boolean lbInUse = !(ntwksMapped == null || ntwksMapped.isEmpty());
						 boolean lbCloudManaged = lbDevice.getIsManagedDevice();
						 if (!lbInUse && !lbCloudManaged) {
							 lbDevice.setAllocationState(LBDeviceAllocationState.Free);
							 _externalLoadBalancerDeviceDao.update(lbDevice.getId(), lbDevice);
						 }
						 if (!lbInUse && lbCloudManaged) {
							 return lbDevice;
						 }
						 else {
							 return null;
						 }
					 }
				 }
				);
				 if (lbDevice != null) {
					 Host lbHost = _hostDao.findById(lbDevice.getHostId());
					 String lbIP = lbHost.getPrivateIpAddress();
					 DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);
					 DestroyLoadBalancerApplianceAnswer answer = null;
					 try {
						 answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);
						 if (answer == null || !answer.getResult()) {
							 s_logger.warn(""Failed to destoy load balancer appliance used by the network"" + guestConfig.getId() + "" due to "" + answer == null ? ""communication error with agent"" : answer.getDetails());
						 }
					 }
					 catch (Exception e) {
						 s_logger.warn(""Failed to destroy load balancer appliance used by the network"" + guestConfig.getId() + "" due to "" + e.getMessage());
					 }
					 if (s_logger.isDebugEnabled()) {
						 s_logger.debug(""Successfully destroyed load balancer appliance used for the network"" + guestConfig.getId());
					 }
					 deviceMapLock.unlock();
					 deleteExternalLoadBalancer(lbHost.getId());
					 _dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);
					 DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), ""publicip"");
					 IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());
					 _ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());
				 }
				 else {
					 deviceMapLock.unlock();
				 }
				 return true;
			 }
			 else {
				 s_logger.error(""Failed to release load balancer device for the network"" + guestConfig.getId() + ""as failed to acquire lock "");
				 return false;
			 }
		 }
		 catch (Exception exception) {
			 s_logger.error(""Failed to release load balancer device for the network"" + guestConfig.getId() + "" due to "" + exception.getMessage());
		 }
		 finally {
			 deviceMapLock.releaseRef();
		 }
		 return false;
	 }
	 private void applyStaticNatRuleForInlineLBRule(DataCenterVO zone, Network network, boolean revoked, String publicIp, String privateIp) throws ResourceUnavailableException {
		 List<StaticNat> staticNats = new ArrayList<StaticNat>();
		 IPAddressVO ipVO = _ipAddressDao.listByDcIdIpAddress(zone.getId(), publicIp).get(0);
		 StaticNatImpl staticNat = new StaticNatImpl(ipVO.getAllocatedToAccountId(), ipVO.getAllocatedInDomainId(), network.getId(), ipVO.getId(), privateIp, revoked);
		 staticNats.add(staticNat);
		 StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);
		 element.applyStaticNats(network, staticNats);
	 }
	 private enum MappingState {
	 Create, Remove, Unchanged, }
	;
	 private class MappingNic {
		 private Nic nic;
		 private MappingState state;
		 public Nic getNic() {
			 return nic;
		 }
		 public void setNic(Nic nic) {
			 this.nic = nic;
		 }
		 public MappingState getState() {
			 return state;
		 }
		 public void setState(MappingState state) {
			 this.state = state;
		 }
	 }
	;
	 private MappingNic getLoadBalancingIpNic(DataCenterVO zone, Network network, long sourceIpId, boolean revoked, String existedGuestIp) throws ResourceUnavailableException {
		 String srcIp = _networkModel.getIp(sourceIpId).getAddress().addr();
		 InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByPublicIpAddress(srcIp);
		 Nic loadBalancingIpNic = null;
		 MappingNic nic = new MappingNic();
		 nic.setState(MappingState.Unchanged);
		 if (!revoked) {
			 if (mapping == null) {
				 String loadBalancingIpAddress = existedGuestIp;
				 if (loadBalancingIpAddress == null) {
					 if (network.getGuestType() == Network.GuestType.Isolated) {
						 loadBalancingIpAddress = _ipAddrMgr.acquireGuestIpAddress(network, null);
					 }
					 else if (network.getGuestType() == Network.GuestType.Shared) {
						 try {
							 PublicIp directIp = _ipAddrMgr.assignPublicIpAddress(network.getDataCenterId(), null, _accountDao.findById(network.getAccountId()), VlanType.DirectAttached, network.getId(), null, true, false);
							 loadBalancingIpAddress = directIp.getAddress().addr();
						 }
						 catch (InsufficientCapacityException capException) {
							 String msg = ""Ran out of guest IP addresses from the shared network."";
							 s_logger.error(msg);
							 throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());
						 }
					 }
				 }
				 if (loadBalancingIpAddress == null) {
					 String msg = ""Ran out of guest IP addresses."";
					 s_logger.error(msg);
					 throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());
				 }
				 loadBalancingIpNic = _nicDao.findByIp4AddressAndNetworkId(loadBalancingIpAddress, network.getId());
				 if (loadBalancingIpNic == null) {
					 loadBalancingIpNic = _networkMgr.savePlaceholderNic(network, loadBalancingIpAddress, null, null);
				 }
				 mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());
				 _inlineLoadBalancerNicMapDao.persist(mapping);
				 try {
					 applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());
				 }
				 catch (ResourceUnavailableException ex) {
					 _inlineLoadBalancerNicMapDao.expunge(mapping.getId());
					 _nicDao.expunge(loadBalancingIpNic.getId());
					 throw ex;
				 }
				 s_logger.debug(""Created static nat rule for inline load balancer"");
				 nic.setState(MappingState.Create);
			 }
			 else {
				 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());
			 }
		 }
		 else {
			 if (mapping != null) {
				 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());
				 int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);
				 if (count == 0) {
					 applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());
					 _inlineLoadBalancerNicMapDao.expunge(mapping.getId());
					 _nicDao.expunge(loadBalancingIpNic.getId());
					 s_logger.debug(""Revoked static nat rule for inline load balancer"");
					 nic.setState(MappingState.Remove);
				 }
			 }
			 else {
				 s_logger.debug(""Revoking a rule for an inline load balancer that has not been programmed yet."");
				 nic.setNic(null);
				 return nic;
			 }
		 }
		 nic.setNic(loadBalancingIpNic);
		 return nic;
	 }
	 public boolean isNccServiceProvider(Network network) {
		 NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());
		 if(null!= networkOffering && networkOffering.getServicePackage() != null ) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public HostVO getNetScalerControlCenterForNetwork(Network guestConfig) {
		 long zoneId = guestConfig.getDataCenterId();
		 return _hostDao.findByTypeNameAndZoneId(zoneId, ""NetscalerControlCenter"", Type.NetScalerControlCenter);
	 }
	 public boolean applyLoadBalancerRules(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {
		 long zoneId = network.getDataCenterId();
		 DataCenterVO zone = _dcDao.findById(zoneId);
		 if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {
			 return true;
		 }
		 HostVO externalLoadBalancer = null;
		 if(isNccServiceProvider(network)) {
			 externalLoadBalancer = getNetScalerControlCenterForNetwork(network);
		 }
		 else {
			 ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);
			 if (lbDeviceVO == null) {
				 s_logger.warn(""There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning"");
				 return true;
			 }
			 else {
				 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
			 }
		 }
		 boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);
		 if (network.getState() == Network.State.Allocated) {
			 s_logger.debug(""External load balancer was asked to apply LB rules for network with ID "" + network.getId() + "";
			 this network is not implemented. Skipping backend commands."");
			 return true;
		 }
		 List<LoadBalancerTO> loadBalancersToApply = new ArrayList<LoadBalancerTO>();
		 List<MappingState> mappingStates = new ArrayList<MappingState>();
		 for (int i = 0;
		 i < loadBalancingRules.size();
		 i++) {
			 LoadBalancingRule rule = loadBalancingRules.get(i);
			 boolean revoked = (rule.getState().equals(FirewallRule.State.Revoke));
			 String protocol = rule.getProtocol();
			 String algorithm = rule.getAlgorithm();
			 String uuid = rule.getUuid();
			 String srcIp = rule.getSourceIp().addr();
			 String srcIpVlan = null;
			 String srcIpGateway = null;
			 String srcIpNetmask = null;
			 Long vlanid = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getVlanId();
			 if(vlanid != null ) {
				 VlanVO publicVlan = _vlanDao.findById(vlanid);
				 srcIpVlan = publicVlan.getVlanTag();
				 srcIpGateway = publicVlan.getVlanGateway();
				 srcIpNetmask = publicVlan.getVlanNetmask();
			 }
			 int srcPort = rule.getSourcePortStart();
			 List<LbDestination> destinations = rule.getDestinations();
			 if (externalLoadBalancerIsInline) {
				 long ipId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();
				 MappingNic nic = getLoadBalancingIpNic(zone, network, ipId, revoked, null);
				 mappingStates.add(nic.getState());
				 Nic loadBalancingIpNic = nic.getNic();
				 if (loadBalancingIpNic == null) {
					 continue;
				 }
				 srcIp = loadBalancingIpNic.getIPv4Address();
			 }
			 if ((destinations != null && !destinations.isEmpty()) || rule.isAutoScaleConfig()) {
				 boolean inline = _networkMgr.isNetworkInlineMode(network);
				 LoadBalancerTO loadBalancer = new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(), rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());
				 loadBalancer.setNetworkId(network.getId());
				 loadBalancer.setSrcIpVlan(srcIpVlan);
				 loadBalancer.setSrcIpNetmask(srcIpNetmask);
				 loadBalancer.setSrcIpGateway(srcIpGateway);
				 if (rule.isAutoScaleConfig()) {
					 loadBalancer.setAutoScaleVmGroup(rule.getAutoScaleVmGroup());
				 }
				 loadBalancersToApply.add(loadBalancer);
			 }
		 }
		 try {
			 if (loadBalancersToApply.size() > 0) {
				 int numLoadBalancersForCommand = loadBalancersToApply.size();
				 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);
				 LoadBalancerConfigCommand cmd = new LoadBalancerConfigCommand(loadBalancersForCommand, null);
				 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));
				 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));
				 Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);
				 if (answer == null || !answer.getResult()) {
					 String details = (answer != null) ? answer.getDetails() : ""details unavailable"";
					 String msg = ""Unable to apply load balancer rules to the external load balancer appliance in zone "" + zone.getName() + "" due to: "" + details + ""."";
					 s_logger.error(msg);
					 throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());
				 }
			 }
		 }
		 catch (Exception ex) {
			 if (externalLoadBalancerIsInline) {
				 s_logger.error(""Rollbacking static nat operation of inline mode load balancing due to error on applying LB rules!"");
				 String existedGuestIp = loadBalancersToApply.get(0).getSrcIp();
				 for (int i = 0;
				 i < loadBalancingRules.size();
				 i++) {
					 LoadBalancingRule rule = loadBalancingRules.get(i);
					 MappingState state = mappingStates.get(i);
					 boolean revoke;
					 if (state == MappingState.Create) {
						 revoke = true;
					 }
					 else if (state == MappingState.Remove) {
						 revoke = false;
					 }
					 else {
						 continue;
					 }
					 long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();
					 getLoadBalancingIpNic(zone, network, sourceIpId, revoke, existedGuestIp);
				 }
			 }
			 throw new ResourceUnavailableException(ex.getMessage(), DataCenter.class, network.getDataCenterId());
		 }
		 return true;
	 }
	 public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {
		 if (guestConfig.getTrafficType() != TrafficType.Guest) {
			 s_logger.trace(""External load balancer can only be used for guest networks."");
			 return false;
		 }
		 long zoneId = guestConfig.getDataCenterId();
		 DataCenterVO zone = _dcDao.findById(zoneId);
		 HostVO externalLoadBalancer = null;
		 if (add) {
			 ExternalLoadBalancerDeviceVO lbDeviceVO = null;
			 lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);
			 if (lbDeviceVO == null) {
				 lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);
				 if (lbDeviceVO == null) {
					 String msg = ""failed to alloacate a external load balancer for the network "" + guestConfig.getId();
					 s_logger.error(msg);
					 throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());
				 }
			 }
			 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
			 s_logger.debug(""Allocated external load balancer device:"" + lbDeviceVO.getId() + "" for the network: "" + guestConfig.getId());
		 }
		 else {
			 ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);
			 if (lbDeviceVO == null) {
				 s_logger.warn(""Network shutdwon requested on external load balancer element, which did not implement the network."" + "" Either network implement failed half way through or already network shutdown is completed. So just returning."");
				 return true;
			 }
			 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
			 assert (externalLoadBalancer != null) : ""There is no device assigned to this network how did shutdown network ended up here??"";
		 }
		 String guestVlanTag = BroadcastDomainType.getValue(guestConfig.getBroadcastUri());
		 String selfIp = null;
		 String guestVlanNetmask = NetUtils.cidr2Netmask(guestConfig.getCidr());
		 Integer networkRate = _networkModel.getNetworkRate(guestConfig.getId(), null);
		 if (add) {
			 Nic selfipNic = getPlaceholderNic(guestConfig);
			 if (selfipNic != null) {
				 return true;
			 }
			 selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);
			 if (selfIp == null) {
				 String msg = ""failed to acquire guest IP address so not implementing the network on the external load balancer "";
				 s_logger.error(msg);
				 throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());
			 }
		 }
		 else {
			 Nic selfipNic = getPlaceholderNic(guestConfig);
			 if (selfipNic == null) {
				 s_logger.warn(""Network shutdwon requested on external load balancer element, which did not implement the network."" + "" Either network implement failed half way through or already network shutdown is completed. So just returning."");
				 return true;
			 }
			 selfIp = selfipNic.getIPv4Address();
		 }
		 boolean inline = _networkMgr.isNetworkInlineMode(guestConfig);
		 IpAddressTO ip = new IpAddressTO(guestConfig.getAccountId(), null, add, false, true, guestVlanTag, selfIp, guestVlanNetmask, null, networkRate, inline);
		 IpAddressTO[] ips = new IpAddressTO[1];
		 ips[0] = ip;
		 IpAssocCommand cmd = new IpAssocCommand(ips);
		 Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);
		 if (answer == null || !answer.getResult()) {
			 String action = add ? ""implement"" : ""shutdown"";
			 String answerDetails = (answer != null) ? answer.getDetails() : null;
			 answerDetails = (answerDetails != null) ? "" due to "" + answerDetails : """";
			 String msg = ""External load balancer was unable to "" + action + "" the guest network on the external load balancer in zone "" + zone.getName() + answerDetails;
			 s_logger.error(msg);
			 throw new ResourceUnavailableException(msg, Network.class, guestConfig.getId());
		 }
		 if (add) {
			 _networkMgr.savePlaceholderNic(guestConfig, selfIp, null, null);
		 }
		 else {
			 Nic selfipNic = getPlaceholderNic(guestConfig);
			 _nicDao.remove(selfipNic.getId());
			 boolean releasedLB = freeLoadBalancerForNetwork(guestConfig);
			 if (!releasedLB) {
				 String msg = ""Failed to release the external load balancer used for the network: "" + guestConfig.getId();
				 s_logger.error(msg);
			 }
		 }
		 if (s_logger.isDebugEnabled()) {
			 Account account = _accountDao.findByIdIncludingRemoved(guestConfig.getAccountId());
			 String action = add ? ""implemented"" : ""shut down"";
			 s_logger.debug(""External load balancer has "" + action + "" the guest network for account "" + account.getAccountName() + ""(id = "" + account.getAccountId() + "") with VLAN tag "" + guestVlanTag);
		 }
		 return true;
	 }
	 public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
		 super.configure(name, params);
		 _defaultLbCapacity = NumbersUtil.parseLong(_configDao.getValue(Config.DefaultExternalLoadBalancerCapacity.key()), 50);
		 _resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);
		 return true;
	 }
	 public boolean start() {
		 return true;
	 }
	 public boolean stop() {
		 return true;
	 }
	 public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {
		 return null;
	 }
	 public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map<String, String> details, List<String> hostTags) {
		 if (!(startup[0] instanceof StartupExternalLoadBalancerCommand)) {
			 return null;
		 }
		 if(host.getName().equalsIgnoreCase(""NetScalerControlCenter"")) {
			 host.setType(Host.Type.NetScalerControlCenter);
		 }
		 else {
			 host.setType(Host.Type.ExternalLoadBalancer);
		 }
		 return host;
	 }
	 public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {
		 if (host.getType() != com.cloud.host.Host.Type.ExternalLoadBalancer) {
			 return null;
		 }
		 return new DeleteHostAnswer(true);
	 }
	 protected IpDeployer getIpDeployerForInlineMode(Network network) {
		 List<Provider> providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);
		 if (providers == null) {
			 s_logger.error(""Cannot find firewall provider for network "" + network.getId());
			 return null;
		 }
		 if (providers.size() != 1) {
			 s_logger.error(""Found "" + providers.size() + "" firewall provider for network "" + network.getId());
			 return null;
		 }
		 NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());
		 if (!(element instanceof IpDeployer)) {
			 s_logger.error(""The firewall provider for network "" + network.getName() + "" don't have ability to deploy IP address!"");
			 return null;
		 }
		 s_logger.info(""Let "" + element.getName() + "" handle ip association for "" + getName() + "" in network "" + network.getId());
		 return (IpDeployer)element;
	 }
	 public List<LoadBalancerTO> getLBHealthChecks(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {
		 long zoneId = network.getDataCenterId();
		 DataCenterVO zone = _dcDao.findById(zoneId);
		 if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {
			 return null;
		 }
		 HostVO externalLoadBalancer = null;
		 if(isNccServiceProvider(network)) {
			 externalLoadBalancer = getNetScalerControlCenterForNetwork(network);
		 }
		 else {
			 ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);
			 if (lbDeviceVO == null) {
				 s_logger.warn(""There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning"");
				 return null;
			 }
			 else {
				 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
			 }
		 }
		 boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);
		 if (network.getState() == Network.State.Allocated) {
			 s_logger.debug(""External load balancer was asked to apply LB rules for network with ID "" + network.getId() + "";
			 this network is not implemented. Skipping backend commands."");
			 return null;
		 }
		 List<LoadBalancerTO> loadBalancersToApply = new ArrayList<LoadBalancerTO>();
		 List<MappingState> mappingStates = new ArrayList<MappingState>();
		 for (final LoadBalancingRule rule : loadBalancingRules) {
			 boolean revoked = (FirewallRule.State.Revoke.equals(rule.getState()));
			 String protocol = rule.getProtocol();
			 String algorithm = rule.getAlgorithm();
			 String uuid = rule.getUuid();
			 String srcIp = rule.getSourceIp().addr();
			 int srcPort = rule.getSourcePortStart();
			 List<LbDestination> destinations = rule.getDestinations();
			 if (externalLoadBalancerIsInline) {
				 long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();
				 MappingNic nic = getLoadBalancingIpNic(zone, network, sourceIpId, revoked, null);
				 mappingStates.add(nic.getState());
				 Nic loadBalancingIpNic = nic.getNic();
				 if (loadBalancingIpNic == null) {
					 continue;
				 }
				 srcIp = loadBalancingIpNic.getIPv4Address();
			 }
			 if ((destinations != null && !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {
				 boolean inline = _networkMgr.isNetworkInlineMode(network);
				 LoadBalancerTO loadBalancer = new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(), rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());
				 loadBalancersToApply.add(loadBalancer);
			 }
		 }
		 try {
			 if (loadBalancersToApply.size() > 0) {
				 int numLoadBalancersForCommand = loadBalancersToApply.size();
				 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);
				 HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand, network.getId());
				 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));
				 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));
				 HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr.easySend(externalLoadBalancer.getId(), cmd);
				 return answer == null ? null : answer.getLoadBalancers();
			 }
		 }
		 catch (Exception ex) {
			 s_logger.error(""Exception Occured "", ex);
		 }
		 return null;
	 }
	 private NicVO getPlaceholderNic(Network network) {
		 List<NicVO> guestIps = _nicDao.listByNetworkId(network.getId());
		 for (NicVO guestIp : guestIps) {
			 if (guestIp.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) && guestIp.getVmType() == null && guestIp.getReserver() == null && !guestIp.getIPv4Address().equals(network.getGateway())) {
				 return guestIp;
			 }
		 }
		 return null;
	 }
}",1,1,0,0
"protected ExchangeSession.Condition appendSearchParam(StringTokenizer tokens, String token, SearchConditions conditions) throws IOException {
	 if (""NOT"".equals(token)) {
		 String nextToken = tokens.nextToken();
		 if (""DELETED"".equals(nextToken)) {
			 return session.isNull(""deleted"");
		 }
		 else {
			 return session.not(appendSearchParam(tokens, nextToken, conditions));
		 }
	 }
	 else if (token.startsWith(""OR "")) {
		 return appendOrSearchParams(token, conditions);
	 }
	 else if (""SUBJECT"".equals(token)) {
		 return session.contains(""subject"", tokens.nextToken());
	 }
	 else if (""BODY"".equals(token)) {
		 return session.contains(""body"", tokens.nextToken());
	 }
	 else if (""TEXT"".equals(token)) {
		 String value = tokens.nextToken();
		 return session.or(session.contains(""body"", value), session.contains(""subject"", value), session.contains(""from"", value), session.contains(""to"", value), session.contains(""cc"", value));
	 }
	 else if (""KEYWORD"".equals(token)) {
		 return session.isEqualTo(""keywords"", session.convertFlagToKeyword(tokens.nextToken()));
	 }
	 else if (""FROM"".equals(token)) {
		 return session.contains(""from"", tokens.nextToken());
	 }
	 else if (""TO"".equals(token)) {
		 return session.contains(""to"", tokens.nextToken());
	 }
	 else if (""CC"".equals(token)) {
		 return session.contains(""cc"", tokens.nextToken());
	 }
	 else if (""LARGER"".equals(token)) {
		 return session.gte(""messageSize"", tokens.nextToken());
	 }
	 else if (""SMALLER"".equals(token)) {
		 return session.lt(""messageSize"", tokens.nextToken());
	 }
	 else if (token.startsWith(""SENT"") || ""SINCE"".equals(token) || ""BEFORE"".equals(token)) {
		 return appendDateSearchParam(tokens, token);
	 }
	 else if (""SEEN"".equals(token)) {
		 return session.isTrue(""read"");
	 }
	 else if (""UNSEEN"".equals(token) || ""NEW"".equals(token)) {
		 return session.isFalse(""read"");
	 }
	 else if (""DRAFT"".equals(token)) {
		 conditions.draft = Boolean.TRUE;
	 }
	 else if (""UNDRAFT"".equals(token)) {
		 conditions.draft = Boolean.FALSE;
	 }
	 else if (""DELETED"".equals(token)) {
		 return session.isEqualTo(""deleted"", ""1"");
	 }
	 else if (""UNDELETED"".equals(token) || ""NOT DELETED"".equals(token)) {
		 return session.isNull(""deleted"");
	 }
	 else if (""FLAGGED"".equals(token)) {
		 conditions.flagged = Boolean.TRUE;
	 }
	 else if (""UNFLAGGED"".equals(token) || ""NEW"".equals(token)) {
		 conditions.flagged = Boolean.FALSE;
	 }
	 else if (""ANSWERED"".equals(token)) {
		 conditions.answered = Boolean.TRUE;
	 }
	 else if (""UNANSWERED"".equals(token)) {
		 conditions.answered = Boolean.FALSE;
	 }
	 else if (""HEADER"".equals(token)) {
		 String headerName = tokens.nextToken().toLowerCase();
		 String value = tokens.nextToken();
		 if (""message-id"".equals(headerName) && !value.startsWith(""<"")) {
			 value = '<' + value + '>';
		 }
		 return session.headerIsEqualTo(headerName, value);
	 }
	 else if (""UID"".equals(token)) {
		 String range = tokens.nextToken();
		 if (""1:*"".equals(range)) {
		 }
		 else {
			 conditions.uidRange = range;
		 }
	 }
	 else if (""OLD"".equals(token) || ""RECENT"".equals(token) || ""ALL"".equals(token)) {
	 }
	 else if (token.indexOf(':') >= 0 || token.matches(""\\d+"")) {
		 conditions.indexRange = token;
	 }
	 else {
		 throw new DavMailException(""EXCEPTION_INVALID_SEARCH_PARAMETERS"", token);
	 }
	 return null;
 }",0,0,1,0
"public class UDFContextTestEvalFunc extends EvalFunc<Integer> {
	 public UDFContextTestEvalFunc() {
		 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass());
		 p.setProperty(""key1"", ""5"");
	 }
	 public Integer exec(Tuple input) throws IOException {
		 String s = (UDFContext.getUDFContext().getUDFProperties(this.getClass()).getProperty(""key1""));
		 return Integer.valueOf(s);
	 }
}",1,0,0,0
"public final class LithoViewSubComponentDeepExtractor implements Extractor<LithoView, List<InspectableComponent>> {
	 private LithoViewSubComponentDeepExtractor() {
	}
	 public List<InspectableComponent> extract(LithoView lithoView) {
		 final List<InspectableComponent> res = new LinkedList<>();
		 final Stack<InspectableComponent> stack = new Stack<>();
		 final InspectableComponent rootInstance = InspectableComponent.getRootInstance(lithoView);
		 Preconditions.checkNotNull( rootInstance, ""Could not obtain DebugComponent. "" + ""Please ensure that ComponentsConfiguration.IS_INTERNAL_BUILD is enabled."");
		 stack.add(rootInstance);
		 while (!stack.isEmpty()) {
			 final InspectableComponent inspectableComponent = stack.pop();
			 res.add(inspectableComponent);
			 for (InspectableComponent child : inspectableComponent.getChildComponents()) {
				 stack.push(child);
			 }
		 }
		 return res;
	 }
	 public static LithoViewSubComponentDeepExtractor subComponentsDeeply() {
		 return new LithoViewSubComponentDeepExtractor();
	 }
	 public static Condition<LithoView> deepSubComponentWith( final Condition<InspectableComponent> inner) {
		 return new Condition<LithoView>() {
			 public boolean matches(LithoView lithoView) {
				 as(""deep sub component with <%s>"", inner);
				 for (InspectableComponent component : subComponentsDeeply().extract(lithoView)) {
					 if (inner.matches(component)) {
						 return true;
					 }
				 }
				 return false;
			 }
		 }
		;
	 }
}",0,0,0,0
"public class Utils {
	 private Utils() {
	 }
	 static void writeInt(DataOutput stream, int i) throws IOException {
		 if (i >= -120 && i <= 127) {
			 stream.writeByte((byte)i);
			 return;
		 }
		 int len = -120;
		 if (i < 0) {
			 i &= 0x7FFFFFFF;
			 len = -124;
		 }
		 int tmp = i;
		 while (tmp != 0) {
			 tmp = tmp >> 8;
			 len--;
		 }
		 stream.writeByte((byte)len);
		 len = (len < -124) ? -(len + 124) : -(len+120);
		 for (int idx = len;
		 idx != 0;
		 idx--) {
			 int shiftbits = (idx - 1) * 8;
			 int mask = 0xFF << shiftbits;
			 stream.writeByte((byte)((i & mask) >> shiftbits));
		 }
	 }
	 static void writeLong(DataOutput stream, long i) throws IOException {
		 if (i >= -112 && i <= 127) {
			 stream.writeByte((byte)i);
			 return;
		 }
		 int len = -112;
		 if (i < 0) {
			 i &= 0x7FFFFFFFFFFFFFFFL;
			 len = -120;
		 }
		 long tmp = i;
		 while (tmp != 0) {
			 tmp = tmp >> 8;
			 len--;
		 }
		 stream.writeByte((byte)len);
		 len = (len < -120) ? -(len + 120) : -(len + 112);
		 for (int idx = len;
		 idx != 0;
		 idx--) {
			 int shiftbits = (idx - 1) * 8;
			 long mask = 0xFFL << shiftbits;
			 stream.writeByte((byte)((i & mask) >> shiftbits));
		 }
	 }
	 static int readInt(DataInput stream) throws IOException {
		 int len = stream.readByte();
		 if (len >= -120) {
			 return len;
		 }
		 len = (len < -124) ? -(len + 124) : -(len + 120);
		 byte[] barr = new byte[len];
		 stream.readFully(barr);
		 int i = 0;
		 for (int idx = 0;
		 idx < len;
		 idx++) {
			 i = i << 8;
			 i = i | (barr[idx] & 0xFF);
		 }
		 return i;
	 }
	 static long readLong(DataInput stream) throws IOException {
		 int len = stream.readByte();
		 if (len >= -112) {
			 return len;
		 }
		 len = (len < -120) ? -(len + 120) : -(len + 112);
		 byte[] barr = new byte[len];
		 stream.readFully(barr);
		 long i = 0;
		 for (int idx = 0;
		 idx < len;
		 idx++) {
			 i = i << 8;
			 i = i | (barr[idx] & 0xFF);
		 }
		 return i;
	 }
	 public static boolean bufEquals(ByteArrayOutputStream one, ByteArrayOutputStream two) {
		 if (one == two) {
			 return true;
		 }
		 byte[] onearray = one.toByteArray();
		 byte[] twoarray = two.toByteArray();
		 boolean ret = (onearray.length == twoarray.length);
		 if (!ret) {
			 return ret;
		 }
		 for (int idx = 0;
		 idx < onearray.length;
		 idx++) {
			 if (onearray[idx] != twoarray[idx]) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public static final byte[] hexchars = {
	 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }
	;
	 static String toXMLString(Text t) {
		 String s = t.toString();
		 StringBuffer sb = new StringBuffer();
		 for (int idx = 0;
		 idx < s.length();
		 idx++) {
			 char ch = s.charAt(idx);
			 if (ch == '<') {
				 sb.append(""&lt;
				"");
			 }
			 else if (ch == '&') {
				 sb.append(""&amp;
				"");
			 }
			 else if (ch == '%') {
				 sb.append(""%25"");
			 }
			 else if (ch < 0x20) {
				 sb.append(""%"");
				 sb.append(hexchars[ch/16]);
				 sb.append(hexchars[ch%16]);
			 }
			 else {
				 sb.append(ch);
			 }
		 }
		 return sb.toString();
	 }
	 static private int h2c(char ch) {
		 if (ch >= '0' && ch <= '9') {
			 return ch - '0';
		 }
		 else if (ch >= 'A' && ch <= 'F') {
			 return ch - 'A';
		 }
		 else if (ch >= 'a' && ch <= 'f') {
			 return ch - 'a';
		 }
		 return 0;
	 }
	 static Text fromXMLString(String s) {
		 StringBuffer sb = new StringBuffer();
		 for (int idx = 0;
		 idx < s.length();
		) {
			 char ch = s.charAt(idx++);
			 if (ch == '%') {
				 char ch1 = s.charAt(idx++);
				 char ch2 = s.charAt(idx++);
				 char res = (char)(h2c(ch1)*16 + h2c(ch2));
				 sb.append(res);
			 }
			 else {
				 sb.append(ch);
			 }
		 }
		 return new Text(sb.toString());
	 }
	 static String toCSVString(Text t) {
		 String s = t.toString();
		 StringBuffer sb = new StringBuffer(s.length()+1);
		 sb.append('\'');
		 int len = s.length();
		 for (int i = 0;
		 i < len;
		 i++) {
			 char c = s.charAt(i);
			 switch(c) {
				 case '\0': sb.append(""%00"");
				 break;
				 case '\n': sb.append(""%0A"");
				 break;
				 case '\r': sb.append(""%0D"");
				 break;
				 case ',': sb.append(""%2C"");
				 break;
			 case '}
			': sb.append(""%7D"");
			 break;
			 case '%': sb.append(""%25"");
			 break;
			 default: sb.append(c);
		 }
	 }
	 return sb.toString();
 }
 static Text fromCSVString(String s) throws IOException {
	 if (s.charAt(0) != '\'') {
		 throw new IOException(""Error deserializing string."");
	 }
	 int len = s.length();
	 StringBuffer sb = new StringBuffer(len-1);
	 for (int i = 1;
	 i < len;
	 i++) {
		 char c = s.charAt(i);
		 if (c == '%') {
			 char ch1 = s.charAt(i+1);
			 char ch2 = s.charAt(i+2);
			 i += 2;
			 if (ch1 == '0' && ch2 == '0') {
				 sb.append('\0');
			 }
			 else if (ch1 == '0' && ch2 == 'A') {
				 sb.append('\n');
			 }
			 else if (ch1 == '0' && ch2 == 'D') {
				 sb.append('\r');
			 }
			 else if (ch1 == '2' && ch2 == 'C') {
				 sb.append(',');
			 }
			 else if (ch1 == '7' && ch2 == 'D') {
			 sb.append('}
			');
		 }
		 else if (ch1 == '2' && ch2 == '5') {
			 sb.append('%');
		 }
		 else {
			throw new IOException(""Error deserializing string."");
		}
	 }
	 else {
		 sb.append(c);
	 }
 }
 return new Text(sb.toString());
 }
 static String toXMLBuffer(ByteArrayOutputStream s) {
 byte[] barr = s.toByteArray();
 StringBuffer sb = new StringBuffer(2*barr.length);
 for (int idx = 0;
 idx < barr.length;
 idx++) {
	 sb.append(Integer.toHexString((int)barr[idx]));
 }
 return sb.toString();
 }
 static ByteArrayOutputStream fromXMLBuffer(String s) throws IOException {
 ByteArrayOutputStream stream = new ByteArrayOutputStream();
 if (s.length() == 0) {
	 return stream;
 }
 int blen = s.length()/2;
 byte[] barr = new byte[blen];
 for (int idx = 0;
 idx < blen;
 idx++) {
	 char c1 = s.charAt(2*idx);
	 char c2 = s.charAt(2*idx+1);
	 barr[idx] = Byte.parseByte(""""+c1+c2, 16);
 }
 stream.write(barr);
 return stream;
 }
 static String toCSVBuffer(ByteArrayOutputStream buf) {
 byte[] barr = buf.toByteArray();
 StringBuffer sb = new StringBuffer(barr.length+1);
 sb.append('#');
 for(int idx = 0;
 idx < barr.length;
 idx++) {
	 sb.append(Integer.toHexString((int)barr[idx]));
 }
 return sb.toString();
 }
 static ByteArrayOutputStream fromCSVBuffer(String s) throws IOException {
 if (s.charAt(0) != '#') {
	 throw new IOException(""Error deserializing buffer."");
 }
 ByteArrayOutputStream stream = new ByteArrayOutputStream();
 if (s.length() == 1) {
	 return stream;
 }
 int blen = (s.length()-1)/2;
 byte[] barr = new byte[blen];
 for (int idx = 0;
 idx < blen;
 idx++) {
	 char c1 = s.charAt(2*idx+1);
	 char c2 = s.charAt(2*idx+2);
	 barr[idx] = Byte.parseByte(""""+c1+c2, 16);
 }
 stream.write(barr);
 return stream;
 }
}",0,0,0,0
"public static PropertyEditor findEditorByConvention( Class<T> targetType) {
	if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {
		return null;
	}
	ClassLoader cl = targetType.getClassLoader();
	if (cl == null) {
		try {
			cl = ClassLoader.getSystemClassLoader();
			if (cl == null) {
				return null;
			}
		}
		catch (Throwable ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""Could not access system ClassLoader: "" + ex);
			}
			return null;
		}
	}
	String editorName = targetType.getName() + ""Editor"";
	try {
		Class<T> editorClass = cl.loadClass(editorName);
		if (!PropertyEditor.class.isAssignableFrom(editorClass)) {
			if (logger.isInfoEnabled()) {
				logger.info(""Editor class ["" + editorName +""] does not implement [java.beans.PropertyEditor] interface"");
			}
			unknownEditorTypes.add(targetType);
			return null;
		}
		return (PropertyEditor) instantiateClass(editorClass);
	}
	catch (ClassNotFoundException ex) {
		if (logger.isTraceEnabled()) {
			logger.trace(""No property editor ["" + editorName + ""] found for type "" +targetType.getName() + "" according to 'Editor' suffix convention"");
		}
		unknownEditorTypes.add(targetType);
		return null;
	}
}",0,0,1,0
"private String extractClassname(Class c) {
	 return (c == null) ? ""<null>"" : c.getClass().getName();
 }",0,0,0,0
"public class WebServer {
	 public static final Logger LOG = LoggerFactory.getLogger(WebServer.class);
	 private HttpServer2 httpServer;
	 private final HasConfig conf;
	 private InetSocketAddress httpAddress;
	 private InetSocketAddress httpsAddress;
	 protected static final String HAS_SERVER_ATTRIBUTE_KEY = ""hasserver"";
	 public WebServer(HasConfig conf) {
		 this.conf = conf;
	 }
	 public HasConfig getConf() {
		 return conf;
	 }
	 private void init() {
		 final String pathSpec = ""/has/v1 public void start() throws HasException {
			 HttpConfig.Policy policy = getHttpPolicy(conf);
			 final String bindHost = conf.getString(WebConfigKey.HAS_HTTPS_BIND_HOST_KEY);
			 InetSocketAddress httpAddr = null;
			 if (policy.isHttpEnabled()) {
				 final String httpAddrString = conf.getString( WebConfigKey.HAS_HTTP_ADDRESS_KEY, WebConfigKey.HAS_HTTP_ADDRESS_DEFAULT);
				 httpAddr = NetUtils.createSocketAddr(httpAddrString);
				 if (bindHost != null && !bindHost.isEmpty()) {
					 httpAddr = new InetSocketAddress(bindHost, httpAddr.getPort());
				 }
				 LOG.info(""Get the http address: "" + httpAddr);
			 }
			 InetSocketAddress httpsAddr = null;
			 if (policy.isHttpsEnabled()) {
				 final String httpsAddrString = conf.getString( WebConfigKey.HAS_HTTPS_ADDRESS_KEY, WebConfigKey.HAS_HTTPS_ADDRESS_DEFAULT);
				 httpsAddr = NetUtils.createSocketAddr(httpsAddrString);
				 if (bindHost != null && !bindHost.isEmpty()) {
					 httpsAddr = new InetSocketAddress(bindHost, httpsAddr.getPort());
				 }
				 LOG.info(""Get the https address: "" + httpsAddr);
			 }
			 HttpServer2.Builder builder = httpServerTemplateForHAS(conf, httpAddr, httpsAddr, ""has"");
			 try {
				 httpServer = builder.build();
			 }
			 catch (IOException e) {
				 throw new HasException(""Errors occurred when building http server. "" + e.getMessage());
			 }
			 init();
			 try {
				 httpServer.start();
			 }
			 catch (IOException e) {
				 throw new HasException(""Errors occurred when starting http server. "" + e.getMessage());
			 }
			 int connIdx = 0;
			 if (policy.isHttpEnabled()) {
				 httpAddress = httpServer.getConnectorAddress(connIdx++);
				 if (httpAddress != null) {
					 conf.setString(WebConfigKey.HAS_HTTP_ADDRESS_KEY, NetUtils.getHostPortString(httpAddress));
				 }
			 }
			 if (policy.isHttpsEnabled()) {
				 httpsAddress = httpServer.getConnectorAddress(connIdx);
				 if (httpsAddress != null) {
					 conf.setString(WebConfigKey.HAS_HTTPS_ADDRESS_KEY, NetUtils.getHostPortString(httpsAddress));
				 }
			 }
		 }
		 public void setWebServerAttribute(HasServer hasServer) {
			 httpServer.setAttribute(HAS_SERVER_ATTRIBUTE_KEY, hasServer);
		 }
		 public static HasServer getHasServerFromContext(ServletContext context) {
			 return (HasServer) context.getAttribute(HAS_SERVER_ATTRIBUTE_KEY);
		 }
		 public HttpConfig.Policy getHttpPolicy(HasConfig conf) {
			 String policyStr = conf.getString(WebConfigKey.HAS_HTTP_POLICY_KEY, WebConfigKey.HAS_HTTP_POLICY_DEFAULT);
			 HttpConfig.Policy policy = HttpConfig.Policy.fromString(policyStr);
			 if (policy == null) {
				 throw new HadoopIllegalArgumentException(""Unrecognized value '"" + policyStr + ""' for "" + WebConfigKey.HAS_HTTP_POLICY_KEY);
			 }
			 conf.setString(WebConfigKey.HAS_HTTP_POLICY_KEY, policy.name());
			 return policy;
		 }
		 public HttpServer2.Builder httpServerTemplateForHAS( HasConfig conf, final InetSocketAddress httpAddr, final InetSocketAddress httpsAddr, String name) throws HasException {
			 HttpConfig.Policy policy = getHttpPolicy(conf);
			 HttpServer2.Builder builder = new HttpServer2.Builder().setName(name);
			 if (policy.isHttpEnabled()) {
				 if (httpAddr != null && httpAddr.getPort() == 0) {
					 builder.setFindPort(true);
				 }
				 URI uri = URI.create(""http: builder.addEndpoint(uri);
				 LOG.info(""Starting Web-server for "" + name + "" at: "" + uri);
			 }
			 if (policy.isHttpsEnabled() && httpsAddr != null) {
				 HasConfig sslConf = loadSslConfiguration(conf);
				 loadSslConfToHttpServerBuilder(builder, sslConf);
				 if (httpsAddr != null && httpsAddr.getPort() == 0) {
					 builder.setFindPort(true);
				 }
				 URI uri = URI.create(""https: builder.addEndpoint(uri);
				 LOG.info(""Starting Web-server for "" + name + "" at: "" + uri);
			 }
			 return builder;
		 }
		 public HasConfig loadSslConfiguration(HasConfig conf) throws HasException {
			 HasConfig sslConf = new HasConfig();
			 String sslConfigString = conf.getString( WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY, WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT);
			 LOG.info(""Get the ssl config file: "" + sslConfigString);
			 File sslConfig = new File(sslConfigString);
			 if (!sslConfig.exists()) {
				 throw new HasException(""The ssl server config file "" + sslConfigString + "" does not exist."");
			 }
			 try {
				 sslConf.addIniConfig(sslConfig);
			 }
			 catch (IOException e) {
				 throw new HasException(""Errors occurred when adding config. "" + e.getMessage());
			 }
			 final String[] reqSslProps = {
			 WebConfigKey.HAS_SERVER_HTTPS_TRUSTSTORE_LOCATION_KEY, WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_LOCATION_KEY, WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_PASSWORD_KEY, WebConfigKey.HAS_SERVER_HTTPS_KEYPASSWORD_KEY }
			;
			 for (String sslProp : reqSslProps) {
				 if (sslConf.getString(sslProp) == null) {
					 LOG.warn(""SSL config "" + sslProp + "" is missing. If "" + WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY + "" is specified, make sure it is a relative path"");
				 }
			 }
			 boolean requireClientAuth = conf.getBoolean(WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_KEY, WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);
			 sslConf.setBoolean(WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_KEY, requireClientAuth);
			 return sslConf;
		 }
		 public HttpServer2.Builder loadSslConfToHttpServerBuilder(HttpServer2.Builder builder, HasConfig sslConf) {
			 return builder .needsClientAuth( sslConf.getBoolean(WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_KEY, WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_DEFAULT)) .keyPassword(getPassword(sslConf, WebConfigKey.HAS_SERVER_HTTPS_KEYPASSWORD_KEY)) .keyStore(sslConf.getString(""ssl.server.keystore.location""), getPassword(sslConf, WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_PASSWORD_KEY), sslConf.getString(""ssl.server.keystore.type"", ""jks"")) .trustStore(sslConf.getString(""ssl.server.truststore.location""), getPassword(sslConf, WebConfigKey.HAS_SERVER_HTTPS_TRUSTSTORE_PASSWORD_KEY), sslConf.getString(""ssl.server.truststore.type"", ""jks"")) .excludeCiphers( sslConf.getString(""ssl.server.exclude.cipher.list""));
		 }
		 public String getPassword(HasConfig conf, String alias) {
			 return conf.getString(alias);
		 }
		 public void stop() throws Exception {
			 if (httpServer != null) {
				 httpServer.stop();
			 }
		 }
		 public InetSocketAddress getHttpAddress() {
			 return httpAddress;
		 }
		 public InetSocketAddress getHttpsAddress() {
			 return httpsAddress;
		 }
	}",1,0,0,0
"int offerService() throws Exception {
	 long lastHeartbeat = 0;
	 this.fs = FileSystem.getNamed(jobClient.getFilesystemName(), this.fConf);
	 while (running && !shuttingDown) {
		 long now = System.currentTimeMillis();
		 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
		 if (waitTime > 0) {
			 try {
				 synchronized(finishedCount) {
					 if (finishedCount[0] == 0) {
						 finishedCount.wait(waitTime);
					 }
					 finishedCount[0] = 0;
				 }
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 lastHeartbeat = now;
		 Vector taskReports = new Vector();
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 TaskStatus status = tip.createStatus();
				 taskReports.add(status);
				 if (status.getRunState() != TaskStatus.RUNNING) {
					 if (tip.getTask().isMapTask()) {
						 mapTotal--;
					 }
					 else {
						 reduceTotal--;
					 }
					 it.remove();
				 }
			 }
		 }
		 TaskTrackerStatus status = new TaskTrackerStatus(taskTrackerName, localHostname, httpPort, taskReports, failures);
		 int resultCode = jobClient.emitHeartbeat(status, justStarted);
		 justStarted = false;
		 if (resultCode == InterTrackerProtocol.UNKNOWN_TASKTRACKER) {
			 return STALE_STATE;
		 }
		 try {
			 if ((mapTotal < maxCurrentTasks || reduceTotal < maxCurrentTasks) && acceptNewTasks) {
				 checkLocalDirs(fConf.getLocalDirs());
				 if (enoughFreeSpace(minSpaceStart)) {
					 Task t = jobClient.pollForNewTask(taskTrackerName);
					 if (t != null) {
						 startNewTask(t);
					 }
				 }
			 }
		 }
		 catch (DiskErrorException de ) {
			 LOG.warn(""Exiting task tracker because ""+de.getMessage());
			 jobClient.reportTaskTrackerError(taskTrackerName, ""DiskErrorException"", de.getMessage());
			 return STALE_STATE;
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem launching task: "" + StringUtils.stringifyException(ie));
		 }
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 long timeSinceLastReport = System.currentTimeMillis() - tip.getLastProgressReport();
				 if ((tip.getRunState() == TaskStatus.RUNNING) && (timeSinceLastReport > this.taskTimeout) && !tip.wasKilled) {
					 String msg = ""Task failed to report status for "" + (timeSinceLastReport / 1000) + "" seconds. Killing."";
					 LOG.info(tip.getTask().getTaskId() + "": "" + msg);
					 getCallStacks();
					 tip.reportDiagnosticInfo(msg);
					 try {
						 tip.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 try {
			 String[] toCloseIds = jobClient.pollForTaskWithClosedJob(taskTrackerName);
			 if (toCloseIds != null) {
				 synchronized (this) {
					 for (int i = 0;
					 i < toCloseIds.length;
					 i++) {
						 Object tip = tasks.get(toCloseIds[i]);
						 if (tip != null) {
							 tasksToCleanup.put(tip);
						 }
						 else {
							 LOG.info(""Attempt to cleanup unknown tip "" + toCloseIds[i]);
						 }
					 }
				 }
			 }
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem getting closed tasks: "" + StringUtils.stringifyException(ie));
		 }
		 if (!enoughFreeSpace(minSpaceKill)) {
			 acceptNewTasks=false;
			 synchronized (this) {
				 TaskInProgress killMe = null;
				 for (Iterator it = runningTasks.values().iterator();
				 it.hasNext();
				 ) {
					 TaskInProgress tip = (TaskInProgress) it.next();
					 if ((tip.getRunState() == TaskStatus.RUNNING) && !tip.wasKilled) {
						 if (killMe == null) {
							 killMe = tip;
						 }
						 else if (!tip.getTask().isMapTask()) {
							 if (killMe.getTask().isMapTask() || (tip.getTask().getProgress().get() < killMe.getTask().getProgress().get())) {
								 killMe = tip;
							 }
						 }
						 else if (killMe.getTask().isMapTask() && tip.getTask().getProgress().get() < killMe.getTask().getProgress().get()) {
							 killMe = tip;
						 }
					 }
				 }
				 if (killMe!=null) {
					 String msg = ""Tasktracker running out of space. Killing task."";
					 LOG.info(killMe.getTask().getTaskId() + "": "" + msg);
					 killMe.reportDiagnosticInfo(msg);
					 try {
						 killMe.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 if (!acceptNewTasks && tasks.isEmpty()) {
			 acceptNewTasks=true;
		 }
	 }
	 return 0;
 }",0,0,1,0
"private void sendDirectory(Directory current, InputStream in, OutputStream out) throws IOException {
	 for (Iterator fileIt = current.filesIterator();
	 fileIt.hasNext();
	) {
		 sendFileToRemote((File) fileIt.next(), in, out);
	 }
	 for (Iterator dirIt = current.directoryIterator();
	 dirIt.hasNext();
	) {
		 Directory dir = (Directory) dirIt.next();
		 sendDirectoryToRemote(dir, in, out);
	 }
 }",0,0,0,0
"public class TezDagBuilder extends TezOpPlanVisitor {
	 private static final Log log = LogFactory.getLog(TezDagBuilder.class);
	 private static long SHUFFLE_BYTES_PER_REDUCER_GROUPBY_DEFAULT = 384 * 1024 * 1024L;
	 private static long SHUFFLE_BYTES_PER_REDUCER_DEFAULT = 256 * 1024 * 1024L;
	 private DAG dag;
	 private Map<String, LocalResource> localResources;
	 private PigContext pc;
	 private Configuration globalConf;
	 private Configuration pigContextConf;
	 private Configuration shuffleVertexManagerBaseConf;
	 private FileSystem fs;
	 private long intermediateTaskInputSize;
	 private Set<String> inputSplitInDiskVertices;
	 private TezUDFContextSeparator udfContextSeparator;
	 private String serializedTezPlan;
	 private String serializedPigContext;
	 private String serializedUDFImportList;
	 private Resource mapTaskResource;
	 private Resource reduceTaskResource;
	 private Map<String, String> mapTaskEnv = new HashMap<String, String>();
	 private Map<String, String> reduceTaskEnv = new HashMap<String, String>();
	 private String mapTaskLaunchCmdOpts;
	 private String reduceTaskLaunchCmdOpts;
	 private boolean disableDAGRecovery = false;
	 public TezDagBuilder(PigContext pc, TezOperPlan plan, DAG dag, Map<String, LocalResource> localResources) {
		 super(plan, new DependencyOrderWalker<TezOperator, TezOperPlan>(plan));
		 this.pc = pc;
		 this.localResources = localResources;
		 this.dag = dag;
		 this.inputSplitInDiskVertices = new HashSet<String>();
		 try {
			 initialize(pc);
			 udfContextSeparator = new TezUDFContextSeparator(plan, new DependencyOrderWalker<TezOperator, TezOperPlan>(plan));
			 udfContextSeparator.visit();
		 }
		 catch (IOException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public boolean shouldDisableDAGRecovery() {
		 return disableDAGRecovery;
	 }
	 private void initialize(PigContext pc) throws IOException {
		 this.globalConf = ConfigurationUtil.toConfiguration(pc.getProperties(), true);
		 this.pigContextConf = ConfigurationUtil.toConfiguration(pc.getProperties(), false);
		 MRToTezHelper.processMRSettings(pigContextConf, globalConf);
		 pigContextConf.setBoolean(""tez.runtime.transfer.data-via-events.enabled"", false);
		 shuffleVertexManagerBaseConf = new Configuration(false);
		 Iterator<Entry<String, String>> iter = pigContextConf.iterator();
		 while (iter.hasNext()) {
			 Entry<String, String> entry = iter.next();
			 if (entry.getKey().startsWith(""tez.shuffle-vertex-manager"")) {
				 shuffleVertexManagerBaseConf.set(entry.getKey(), entry.getValue());
			 }
		 }
		 String tokenFile = System.getenv(""HADOOP_TOKEN_FILE_LOCATION"");
		 if(tokenFile != null && globalConf.get(MRConfiguration.JOB_CREDENTIALS_BINARY) == null) {
			 globalConf.set(MRConfiguration.JOB_CREDENTIALS_BINARY, tokenFile);
			 globalConf.set(""tez.credentials.path"", tokenFile);
		 }
		 SecurityHelper.populateTokenCache(globalConf, dag.getCredentials());
		 ClientDistributedCacheManager .determineTimestampsAndCacheVisibilities(globalConf);
		 ClientDistributedCacheManager.getDelegationTokens(globalConf, dag.getCredentials());
		 MRApps.setupDistributedCache(globalConf, this.localResources);
		 dag.addTaskLocalFiles(this.localResources);
		 int mapMemoryMB;
		 int reduceMemoryMB;
		 int mapVCores;
		 int reduceVCores;
		 if (globalConf.get(TezConfiguration.TEZ_TASK_RESOURCE_MEMORY_MB) != null) {
			 mapMemoryMB = globalConf.getInt( TezConfiguration.TEZ_TASK_RESOURCE_MEMORY_MB, TezConfiguration.TEZ_TASK_RESOURCE_MEMORY_MB_DEFAULT);
			 reduceMemoryMB = mapMemoryMB;
		 }
		 else {
			 mapMemoryMB = globalConf.getInt(MRJobConfig.MAP_MEMORY_MB, MRJobConfig.DEFAULT_MAP_MEMORY_MB);
			 reduceMemoryMB = globalConf.getInt(MRJobConfig.REDUCE_MEMORY_MB, MRJobConfig.DEFAULT_REDUCE_MEMORY_MB);
		 }
		 if (globalConf.get(TezConfiguration.TEZ_TASK_RESOURCE_CPU_VCORES) != null) {
			 mapVCores = globalConf.getInt( TezConfiguration.TEZ_TASK_RESOURCE_CPU_VCORES, TezConfiguration.TEZ_TASK_RESOURCE_CPU_VCORES_DEFAULT);
			 reduceVCores = mapVCores;
		 }
		 else {
			 mapVCores = globalConf.getInt(MRJobConfig.MAP_CPU_VCORES, MRJobConfig.DEFAULT_MAP_CPU_VCORES);
			 reduceVCores = globalConf.getInt(MRJobConfig.REDUCE_CPU_VCORES, MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);
		 }
		 mapTaskResource = Resource.newInstance(mapMemoryMB, mapVCores);
		 reduceTaskResource = Resource.newInstance(reduceMemoryMB, reduceVCores);
		 if (globalConf.get(TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS) == null) {
			 MRHelpers.updateEnvBasedOnMRTaskEnv(globalConf, mapTaskEnv, true);
			 MRHelpers.updateEnvBasedOnMRTaskEnv(globalConf, reduceTaskEnv, false);
		 }
		 if (globalConf.get(TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS) != null) {
			 mapTaskLaunchCmdOpts = globalConf.get(TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS);
			 reduceTaskLaunchCmdOpts = mapTaskLaunchCmdOpts;
		 }
		 else {
			 mapTaskLaunchCmdOpts = MRHelpers.getJavaOptsForMRMapper(globalConf);
			 reduceTaskLaunchCmdOpts = MRHelpers.getJavaOptsForMRReducer(globalConf);
		 }
		 try {
			 fs = FileSystem.get(globalConf);
			 intermediateTaskInputSize = fs.getDefaultBlockSize(FileLocalizer.getTemporaryResourcePath(pc));
		 }
		 catch (Exception e) {
			 log.warn(""Unable to get the block size for temporary directory, defaulting to 128MB"", e);
			 intermediateTaskInputSize = 134217728L;
		 }
		 intermediateTaskInputSize = Math.max(intermediateTaskInputSize, 134217728L);
		 intermediateTaskInputSize = Math.min(intermediateTaskInputSize, globalConf.getLong( InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, InputSizeReducerEstimator.DEFAULT_BYTES_PER_REDUCER));
		 serializedPigContext = ObjectSerializer.serialize(pc);
		 serializedUDFImportList = ObjectSerializer.serialize(PigContext.getPackageImportList());
	 }
	 private String getSerializedTezPlan() throws IOException {
		 if (serializedTezPlan == null) {
			 serializedTezPlan = ObjectSerializer.serialize(getPlan());
		 }
		 return serializedTezPlan;
	 }
	 public void avoidContainerReuseIfInputSplitInDisk() throws IOException {
		 if (!inputSplitInDiskVertices.isEmpty()) {
			 Path jobSplitFile = new Path(FileLocalizer.getTemporaryPath(pc), MRJobConfig.JOB_SPLIT);
			 FSDataOutputStream out = fs.create(jobSplitFile);
			 out.close();
			 log.info(""Creating empty job.split in "" + jobSplitFile);
			 FileStatus splitFileStatus = fs.getFileStatus(jobSplitFile);
			 LocalResource localResource = LocalResource.newInstance( ConverterUtils.getYarnUrlFromPath(jobSplitFile), LocalResourceType.FILE, LocalResourceVisibility.APPLICATION, splitFileStatus.getLen(), splitFileStatus.getModificationTime());
			 for (Vertex vertex : dag.getVertices()) {
				 if (!inputSplitInDiskVertices.contains(vertex.getName())) {
					 if (vertex.getTaskLocalFiles().containsKey( MRJobConfig.JOB_SPLIT)) {
						 throw new RuntimeException( ""LocalResources already contains a"" + "" resource named "" + MRJobConfig.JOB_SPLIT);
					 }
					 vertex.getTaskLocalFiles().put(MRJobConfig.JOB_SPLIT, localResource);
				 }
			 }
		 }
	 }
	 public void visitTezOp(TezOperator tezOp) throws VisitorException {
		 TezOperPlan tezPlan = getPlan();
		 List<TezOperator> predecessors = tezPlan.getPredecessors(tezOp);
		 Vertex to = null;
		 try {
			 if (!tezOp.isVertexGroup()) {
				 to = newVertex(tezOp);
				 dag.addVertex(to);
			 }
			 else {
			 }
		 }
		 catch (Exception e) {
			 throw new VisitorException(""Cannot create vertex for "" + tezOp.name(), e);
		 }
		 if (predecessors != null) {
			 Vertex[] groupMembers = new Vertex[predecessors.size()];
			 for (int i = 0;
			 i < predecessors.size();
			 i++) {
				 TezOperator pred = predecessors.get(i);
				 try {
					 if (pred.isVertexGroup()) {
						 VertexGroup from = pred.getVertexGroupInfo().getVertexGroup();
						 GroupInputEdge edge = newGroupInputEdge( getPlan().getOperator(pred.getVertexGroupMembers().get(0)), tezOp, from, to);
						 dag.addEdge(edge);
					 }
					 else {
						 Vertex from = dag.getVertex(pred.getOperatorKey().toString());
						 if (tezOp.isVertexGroup()) {
							 groupMembers[i] = from;
						 }
						 else {
							 EdgeProperty prop = newEdge(pred, tezOp, false);
							 Edge edge = Edge.create(from, to, prop);
							 dag.addEdge(edge);
						 }
					 }
				 }
				 catch (IOException e) {
					 throw new VisitorException(""Cannot create edge from "" + pred.name() + "" to "" + tezOp.name(), e);
				 }
			 }
			 if (tezOp.isVertexGroup()) {
				 String groupName = tezOp.getOperatorKey().toString();
				 VertexGroup vertexGroup = dag.createVertexGroup(groupName, groupMembers);
				 tezOp.getVertexGroupInfo().setVertexGroup(vertexGroup);
				 POStore store = tezOp.getVertexGroupInfo().getStore();
				 if (store != null) {
					 String outputKey = store.getOperatorKey().toString();
					 if (store instanceof POStoreTez) {
						 outputKey = ((POStoreTez) store).getOutputKey();
					 }
					 vertexGroup.addDataSink(outputKey, DataSinkDescriptor.create(tezOp.getVertexGroupInfo().getStoreOutputDescriptor(), OutputCommitterDescriptor.create(MROutputCommitter.class.getName()), dag.getCredentials()));
				 }
			 }
		 }
	 }
	 private GroupInputEdge newGroupInputEdge(TezOperator fromOp, TezOperator toOp, VertexGroup from, Vertex to) throws IOException {
		 EdgeProperty edgeProperty = newEdge(fromOp, toOp, true);
		 String groupInputClass = ConcatenatedMergedKeyValueInput.class.getName();
		 if(edgeProperty.getDataMovementType().equals(DataMovementType.SCATTER_GATHER) && edgeProperty.getEdgeDestination().getClassName().equals(OrderedGroupedKVInput.class.getName())) {
			 groupInputClass = OrderedGroupedMergedKVInput.class.getName();
		 }
		 return GroupInputEdge.create(from, to, edgeProperty, InputDescriptor.create(groupInputClass).setUserPayload(edgeProperty.getEdgeDestination().getUserPayload()));
	 }
	 private EdgeProperty newEdge(TezOperator from, TezOperator to, boolean isMergedInput) throws IOException {
		 TezEdgeDescriptor edge = to.inEdges.get(from.getOperatorKey());
		 PhysicalPlan combinePlan = edge.combinePlan;
		 InputDescriptor in = InputDescriptor.create(edge.inputClassName);
		 OutputDescriptor out = OutputDescriptor.create(edge.outputClassName);
		 Configuration conf = new Configuration(pigContextConf);
		 if (edge.needsDistinctCombiner()) {
			 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_COMBINER_CLASS, MRCombiner.class.getName());
			 conf.set(MRJobConfig.COMBINE_CLASS_ATTR, DistinctCombiner.Combine.class.getName());
			 log.info(""Setting distinct combiner class between "" + from.getOperatorKey() + "" and "" + to.getOperatorKey());
		 }
		 else if (!combinePlan.isEmpty()) {
			 udfContextSeparator.serializeUDFContextForEdge(conf, from, to, UDFType.USERFUNC);
			 addCombiner(combinePlan, to, conf, isMergedInput);
		 }
		 List<POLocalRearrangeTez> lrs = PlanHelper.getPhysicalOperators(from.plan, POLocalRearrangeTez.class);
		 for (POLocalRearrangeTez lr : lrs) {
			 if (lr.containsOutputKey(to.getOperatorKey().toString())) {
				 byte keyType = lr.getKeyType();
				 setIntermediateOutputKeyValue(keyType, conf, to, lr.isConnectedToPackage(), isMergedInput);
				 conf.set(""pig.reduce.key.type"", Byte.toString(lr.getMainKeyType()));
				 break;
			 }
		 }
		 conf.setIfUnset(TezRuntimeConfiguration.TEZ_RUNTIME_PARTITIONER_CLASS, MRPartitioner.class.getName());
		 if (edge.getIntermediateOutputKeyClass() != null) {
			 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_CLASS, edge.getIntermediateOutputKeyClass());
		 }
		 if (edge.getIntermediateOutputValueClass() != null) {
			 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_VALUE_CLASS, edge.getIntermediateOutputValueClass());
		 }
		 if (edge.getIntermediateOutputKeyComparatorClass() != null) {
			 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_COMPARATOR_CLASS, edge.getIntermediateOutputKeyComparatorClass());
		 }
		 conf.setBoolean(MRConfiguration.MAPPER_NEW_API, true);
		 conf.setBoolean(MRConfiguration.REDUCER_NEW_API, true);
		 conf.setBoolean(PigImplConstants.PIG_EXECTYPE_MODE_LOCAL, pc.getExecType().isLocal());
		 conf.set(PigImplConstants.PIG_LOG4J_PROPERTIES, ObjectSerializer.serialize(pc.getLog4jProperties()));
		 conf.set(""udf.import.list"", serializedUDFImportList);
		 if(to.isGlobalSort() || to.isLimitAfterSort()){
			 conf.set(""pig.sortOrder"", ObjectSerializer.serialize(to.getSortOrder()));
		 }
		 if (edge.isUseSecondaryKey()) {
			 conf.set(""pig.secondarySortOrder"", ObjectSerializer.serialize(edge.getSecondarySortOrder()));
			 conf.set(org.apache.hadoop.mapreduce.MRJobConfig.PARTITIONER_CLASS_ATTR, SecondaryKeyPartitioner.class.getName());
			 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_COMPARATOR_CLASS, PigSecondaryKeyComparator.class.getName());
			 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_CLASS, NullableTuple.class.getName());
			 setGroupingComparator(conf, PigSecondaryKeyGroupComparator.class.getName());
		 }
		 if (edge.partitionerClass != null) {
			 conf.set(org.apache.hadoop.mapreduce.MRJobConfig.PARTITIONER_CLASS_ATTR, edge.partitionerClass.getName());
		 }
		 UserPayload payLoad = TezUtils.createUserPayloadFromConf(conf);
		 out.setUserPayload(payLoad);
		 in.setUserPayload(payLoad);
		 if (!combinePlan.isEmpty()) {
			 boolean noCombineInReducer = false;
			 boolean noCombineInMapper = edge.getCombinerInMap() == null ? false : !edge.getCombinerInMap();
			 String reducerNoCombiner = globalConf.get(PigConfiguration.PIG_EXEC_NO_COMBINER_REDUCER);
			 if (edge.getCombinerInReducer() != null) {
				 noCombineInReducer = !edge.getCombinerInReducer();
			 }
			 else if (reducerNoCombiner == null || reducerNoCombiner.equals(""auto"")) {
				 noCombineInReducer = TezCompilerUtil.bagDataTypeInCombinePlan(combinePlan);
			 }
			 else {
				 noCombineInReducer = Boolean.parseBoolean(reducerNoCombiner);
			 }
			 if (noCombineInReducer || noCombineInMapper) {
				 log.info(""Turning off combiner in reducer vertex "" + to.getOperatorKey() + "" for edge from "" + from.getOperatorKey());
				 conf.unset(TezRuntimeConfiguration.TEZ_RUNTIME_COMBINER_CLASS);
				 conf.unset(MRJobConfig.COMBINE_CLASS_ATTR);
				 conf.unset(""pig.combinePlan"");
				 conf.unset(""pig.combine.package"");
				 conf.unset(""pig.map.keytype"");
				 UserPayload payLoadWithoutCombiner = TezUtils.createUserPayloadFromConf(conf);
				 if (noCombineInMapper) {
					 out.setUserPayload(payLoadWithoutCombiner);
				 }
				 if (noCombineInReducer) {
					 in.setUserPayload(payLoadWithoutCombiner);
				 }
			 }
		 }
		 if (edge.dataMovementType!=DataMovementType.BROADCAST && to.getEstimatedParallelism()!=-1 && to.getVertexParallelism()==-1 && (to.isGlobalSort()||to.isSkewedJoin())) {
			 return EdgeProperty.create((EdgeManagerPluginDescriptor)null, edge.dataSourceType, edge.schedulingType, out, in);
		 }
		 if (to.isUseGraceParallelism()) {
			 return EdgeProperty.create((EdgeManagerPluginDescriptor)null, edge.dataSourceType, edge.schedulingType, out, in);
		 }
		 return EdgeProperty.create(edge.dataMovementType, edge.dataSourceType, edge.schedulingType, out, in);
	 }
	 private void addCombiner(PhysicalPlan combinePlan, TezOperator pkgTezOp, Configuration conf, boolean isMergedInput) throws IOException {
		 POPackage combPack = (POPackage) combinePlan.getRoots().get(0);
		 POLocalRearrange combRearrange = (POLocalRearrange) combinePlan .getLeaves().get(0);
		 setIntermediateOutputKeyValue(combRearrange.getKeyType(), conf, pkgTezOp, true, isMergedInput);
		 LoRearrangeDiscoverer lrDiscoverer = new LoRearrangeDiscoverer( combinePlan, null, pkgTezOp, combPack);
		 lrDiscoverer.visit();
		 combinePlan.remove(combPack);
		 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_COMBINER_CLASS, MRCombiner.class.getName());
		 conf.set(MRJobConfig.COMBINE_CLASS_ATTR, PigCombiner.Combine.class.getName());
		 conf.set(""pig.combinePlan"", ObjectSerializer.serialize(combinePlan));
		 conf.set(""pig.combine.package"", ObjectSerializer.serialize(combPack));
		 conf.set(""pig.map.keytype"", ObjectSerializer .serialize(new byte[] {
		 combRearrange.getKeyType() }
		));
	 }
	 private Vertex newVertex(TezOperator tezOp) throws IOException, ClassNotFoundException, InterruptedException {
		 ProcessorDescriptor procDesc = ProcessorDescriptor.create( tezOp.getProcessorName());
		 JobConf payloadConf = new JobConf(pigContextConf);
		 payloadConf.setCredentials(dag.getCredentials());
		 Job job = new Job(payloadConf);
		 payloadConf = (JobConf) job.getConfiguration();
		 payloadConf.setBoolean(MRConfiguration.MAPPER_NEW_API, true);
		 payloadConf.setBoolean(MRConfiguration.REDUCER_NEW_API, true);
		 payloadConf.setClass(MRConfiguration.INPUTFORMAT_CLASS, PigInputFormatTez.class, InputFormat.class);
		 setOutputFormat(job);
		 payloadConf.set(""udf.import.list"", serializedUDFImportList);
		 payloadConf.set(""exectype"", ""TEZ"");
		 payloadConf.setBoolean(PigImplConstants.PIG_EXECTYPE_MODE_LOCAL, pc.getExecType().isLocal());
		 payloadConf.set(PigImplConstants.PIG_LOG4J_PROPERTIES, ObjectSerializer.serialize(pc.getLog4jProperties()));
		 DateTimeWritable.setupAvailableZoneIds();
		 LinkedList<POStore> stores = processStores(tezOp, payloadConf, job);
		 processUserFuncs(tezOp, job);
		 Configuration inputPayLoad = null;
		 Configuration outputPayLoad = null;
		 if (!stores.isEmpty()) {
			 outputPayLoad = new Configuration(payloadConf);
			 outputPayLoad.set(JobControlCompiler.PIG_MAP_STORES, ObjectSerializer.serialize(new ArrayList<POStore>()));
		 }
		 if (!(tezOp.getLoaderInfo().getLoads().isEmpty())) {
			 payloadConf.set(PigInputFormat.PIG_LOADS, ObjectSerializer.serialize(tezOp.getLoaderInfo().getLoads()));
			 payloadConf.set(PigInputFormat.PIG_INPUT_SIGNATURES, ObjectSerializer.serialize(tezOp.getLoaderInfo().getInpSignatureLists()));
			 payloadConf.set(PigInputFormat.PIG_INPUT_LIMITS, ObjectSerializer.serialize(tezOp.getLoaderInfo().getInpLimits()));
			 inputPayLoad = new Configuration(payloadConf);
		 }
		 if (tezOp.getSampleOperator() != null) {
			 payloadConf.set(PigProcessor.SAMPLE_VERTEX, tezOp.getSampleOperator().getOperatorKey().toString());
		 }
		 if (tezOp.getSortOperator() != null) {
			 payloadConf.set(PigProcessor.SORT_VERTEX, tezOp.getSortOperator().getOperatorKey().toString());
			 if (tezOp.getSortOperator().getEstimatedParallelism() != -1 && tezOp.getSortOperator().isIntermediateReducer()) {
				 payloadConf.setLong( InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, intermediateTaskInputSize);
			 }
		 }
		 new PhyPlanSetter(tezOp.plan).visit();
		 EndOfAllInputSetter.EndOfAllInputChecker checker = new EndOfAllInputSetter.EndOfAllInputChecker(tezOp.plan);
		 checker.visit();
		 if (checker.isEndOfAllInputPresent()) {
			 payloadConf.set(JobControlCompiler.END_OF_INP_IN_MAP, ""true"");
		 }
		 List<PhysicalOperator> roots = tezOp.plan.getRoots();
		 if (roots.size() == 1 && roots.get(0) instanceof POPackage) {
			 POPackage pack = (POPackage) roots.get(0);
			 List<PhysicalOperator> succsList = tezOp.plan.getSuccessors(pack);
			 if (succsList != null) {
				 succsList = new ArrayList<PhysicalOperator>(succsList);
			 }
			 byte keyType = pack.getPkgr().getKeyType();
			 tezOp.plan.remove(pack);
			 payloadConf.set(""pig.reduce.package"", ObjectSerializer.serialize(pack));
			 POShuffleTezLoad newPack = new POShuffleTezLoad(pack);
			 if (tezOp.isSkewedJoin()) {
				 newPack.setSkewedJoins(true);
			 }
			 tezOp.plan.add(newPack);
			 boolean isMergedInput = false;
			 Map<Integer, String> localRearrangeMap = new TreeMap<Integer, String>();
			 TezOperator from = null;
			 for (TezOperator pred : mPlan.getPredecessors(tezOp)) {
				 if (tezOp.getSampleOperator() != null && tezOp.getSampleOperator() == pred) {
				 }
				 else {
					 String inputKey = pred.getOperatorKey().toString();
					 boolean isVertexGroup = false;
					 if (pred.isVertexGroup()) {
						 isVertexGroup = true;
						 pred = mPlan.getOperator(pred.getVertexGroupMembers().get(0));
					 }
					 LinkedList<POLocalRearrangeTez> lrs = PlanHelper.getPhysicalOperators(pred.plan, POLocalRearrangeTez.class);
					 for (POLocalRearrangeTez lr : lrs) {
						 if (lr.isConnectedToPackage() && lr.containsOutputKey(tezOp.getOperatorKey().toString())) {
							 localRearrangeMap.put((int) lr.getIndex(), inputKey);
							 if (isVertexGroup) {
								 isMergedInput = true;
							 }
							 from = pred;
						 }
					 }
				 }
			 }
			 for (Map.Entry<Integer, String> entry : localRearrangeMap.entrySet()) {
				 newPack.addInputKey(entry.getValue());
			 }
			 if (succsList != null) {
				 for (PhysicalOperator succs : succsList) {
					 tezOp.plan.connect(newPack, succs);
				 }
			 }
			 selectKeyComparator(keyType, payloadConf, tezOp, isMergedInput);
			 if (tezOp.isUseSecondaryKey()) {
				 TezEdgeDescriptor edge = tezOp.inEdges.get(from.getOperatorKey());
				 payloadConf.set(""pig.secondarySortOrder"", ObjectSerializer .serialize(edge.getSecondarySortOrder()));
			 }
		 }
		 new PhyPlanSetter(tezOp.plan).visit();
		 payloadConf.set(PigProcessor.PLAN, ObjectSerializer.serialize(tezOp.plan));
		 udfContextSeparator.serializeUDFContext(payloadConf, tezOp);
		 if (!pc.inIllustrator) {
			 for (POStore store : stores) {
				 store.setInputs(null);
				 store.setParentPlan(null);
			 }
			 payloadConf.set(JobControlCompiler.PIG_MAP_STORES, ObjectSerializer.serialize(new ArrayList<POStore>()));
			 payloadConf.set(JobControlCompiler.PIG_REDUCE_STORES, ObjectSerializer.serialize(stores));
		 }
		 if (tezOp.isNeedEstimateParallelism()) {
			 payloadConf.setBoolean(PigProcessor.ESTIMATE_PARALLELISM, true);
			 log.info(""Estimate quantile for sample aggregation vertex "" + tezOp.getOperatorKey().toString());
		 }
		 payloadConf.setInt(PigImplConstants.REDUCER_DEFAULT_PARALLELISM, pc.defaultParallel);
		 payloadConf.setInt(PigImplConstants.REDUCER_REQUESTED_PARALLELISM, tezOp.getRequestedParallelism());
		 payloadConf.setInt(PigImplConstants.REDUCER_ESTIMATED_PARALLELISM, tezOp.getEstimatedParallelism());
		 TezScriptState ss = TezScriptState.get();
		 ss.addVertexSettingsToConf(dag.getName(), tezOp, payloadConf);
		 UserPayload userPayload = TezUtils.createUserPayloadFromConf(payloadConf);
		 TezDAGScriptInfo dagScriptInfo = TezScriptState.get().getDAGScriptInfo(dag.getName());
		 String alias = dagScriptInfo.getAlias(tezOp);
		 String aliasLocation = dagScriptInfo.getAliasLocation(tezOp);
		 String features = dagScriptInfo.getPigFeatures(tezOp);
		 String vertexInfo = aliasLocation + "" ("" + features + "")"" ;
		 procDesc.setUserPayload(userPayload).setHistoryText(TezUtils.convertToHistoryText(vertexInfo, payloadConf));
		 String vmPluginName = null;
		 Configuration vmPluginConf = null;
		 boolean containScatterGather = false;
		 boolean containCustomPartitioner = false;
		 for (TezEdgeDescriptor edge : tezOp.inEdges.values()) {
			 if (edge.dataMovementType == DataMovementType.SCATTER_GATHER) {
				 containScatterGather = true;
			 }
			 if (edge.partitionerClass != null) {
				 containCustomPartitioner = true;
			 }
		 }
		 if(containScatterGather) {
			 vmPluginName = ShuffleVertexManager.class.getName();
			 vmPluginConf = new Configuration(shuffleVertexManagerBaseConf);
		 }
		 if (tezOp.getEstimatedParallelism() != -1) {
			 boolean autoParallelism = false;
			 if (tezOp.isGlobalSort()||tezOp.isSkewedJoin()) {
				 if (tezOp.getVertexParallelism()==-1 && ( tezOp.isGlobalSort() &&getPlan().getPredecessors(tezOp).size()==1|| tezOp.isSkewedJoin() &&getPlan().getPredecessors(tezOp).size()==2)) {
					 vmPluginName = PartitionerDefinedVertexManager.class.getName();
					 autoParallelism = true;
					 log.info(""Set VertexManagerPlugin to PartitionerDefinedParallelismVertexManager for vertex "" + tezOp.getOperatorKey().toString());
				 }
			 }
			 else {
				 if (containScatterGather && !containCustomPartitioner) {
					 long bytesPerReducer = intermediateTaskInputSize;
					 if (stores.size() > 0) {
						 if (pigContextConf.get(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM) != null) {
							 bytesPerReducer = pigContextConf.getLong( InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, InputSizeReducerEstimator.DEFAULT_BYTES_PER_REDUCER);
						 }
						 else if (tezOp.isGroupBy()) {
							 bytesPerReducer = SHUFFLE_BYTES_PER_REDUCER_GROUPBY_DEFAULT;
						 }
						 else {
							 bytesPerReducer = SHUFFLE_BYTES_PER_REDUCER_DEFAULT;
						 }
					 }
					 if (payloadConf.getBoolean(PigConfiguration.PIG_TEZ_GRACE_PARALLELISM, true) && !TezOperPlan.getGrandParentsForGraceParallelism(getPlan(), tezOp).isEmpty() && tezOp.getCrossKeys() == null) {
						 vmPluginName = PigGraceShuffleVertexManager.class.getName();
						 tezOp.setUseGraceParallelism(true);
						 vmPluginConf.set(""pig.tez.plan"", getSerializedTezPlan());
						 vmPluginConf.set(PigImplConstants.PIG_CONTEXT, serializedPigContext);
						 vmPluginConf.setLong(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, bytesPerReducer);
					 }
					 vmPluginConf.setBoolean(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_ENABLE_AUTO_PARALLEL, true);
					 vmPluginConf.setLong(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_DESIRED_TASK_INPUT_SIZE, bytesPerReducer);
					 autoParallelism = true;
					 log.info(""Set auto parallelism for vertex "" + tezOp.getOperatorKey().toString());
				 }
			 }
			 if (globalConf.getBoolean(PigConfiguration.PIG_TEZ_AUTO_PARALLELISM_DISABLE_DAG_RECOVERY, false) && autoParallelism) {
				 disableDAGRecovery = true;
			 }
		 }
		 if (tezOp.isLimit() && (vmPluginName == null || vmPluginName.equals(PigGraceShuffleVertexManager.class.getName())|| vmPluginName.equals(ShuffleVertexManager.class.getName()))) {
			 if (tezOp.inEdges.values().iterator().next().inputClassName.equals(UnorderedKVInput.class.getName())) {
				 vmPluginConf = (vmPluginConf == null) ? new Configuration(pigContextConf) : vmPluginConf;
				 vmPluginConf.set(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MIN_SRC_FRACTION, ""0.00001"");
				 vmPluginConf.set(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MAX_SRC_FRACTION, ""0.00001"");
				 log.info(""Set "" + ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MIN_SRC_FRACTION + "" to 0.00001 for limit vertex "" + tezOp.getOperatorKey().toString());
			 }
		 }
		 int parallel = tezOp.getVertexParallelism();
		 if (tezOp.isUseGraceParallelism()) {
			 parallel = -1;
		 }
		 Resource resource = tezOp.isUseMRMapSettings() ? mapTaskResource : reduceTaskResource;
		 Vertex vertex = Vertex.create(tezOp.getOperatorKey().toString(), procDesc, parallel, resource);
		 if (tezOp.isUseMRMapSettings()) {
			 vertex.setTaskLaunchCmdOpts(mapTaskLaunchCmdOpts);
			 vertex.setTaskEnvironment(mapTaskEnv);
		 }
		 else {
			 vertex.setTaskLaunchCmdOpts(reduceTaskLaunchCmdOpts);
			 vertex.setTaskEnvironment(reduceTaskEnv);
		 }
		 MRToTezHelper.setVertexConfig(vertex, tezOp.isUseMRMapSettings(), globalConf);
		 log.info(""For vertex - "" + tezOp.getOperatorKey().toString() + "": parallelism="" + tezOp.getVertexParallelism() + "", memory="" + vertex.getTaskResource().getMemory() + "", java opts="" + vertex.getTaskLaunchCmdOpts() );
		 log.info(""Processing aliases: "" + alias);
		 log.info(""Detailed locations: "" + aliasLocation);
		 log.info(""Pig features in the vertex: "" + features);
		 for (POLoad ld : tezOp.getLoaderInfo().getLoads()) {
			 Builder userPayLoadBuilder = MRRuntimeProtos.MRInputUserPayloadProto.newBuilder();
			 InputSplitInfo inputSplitInfo = tezOp.getLoaderInfo().getInputSplitInfo();
			 Map<String, LocalResource> additionalLocalResources = null;
			 int spillThreshold = payloadConf .getInt(PigConfiguration.PIG_TEZ_INPUT_SPLITS_MEM_THRESHOLD, PigConfiguration.PIG_TEZ_INPUT_SPLITS_MEM_THRESHOLD_DEFAULT);
			 if (inputSplitInfo instanceof InputSplitInfoMem) {
				 MRSplitsProto.Builder splitsBuilder = MRSplitsProto.newBuilder();
				 Pair<Long, Boolean> serializationInfo = TezInputHelper.createSplitsProto(inputSplitInfo, pigContextConf, splitsBuilder, spillThreshold);
				 MRSplitsProto splitsProto = splitsBuilder.build();
				 if(!serializationInfo.second) {
					 inputPayLoad.setBoolean( org.apache.tez.mapreduce.hadoop.MRJobConfig.MR_TEZ_SPLITS_VIA_EVENTS, false);
					 Path inputSplitsDir = FileLocalizer.getTemporaryPath(pc);
					 log.info(""Writing input splits to "" + inputSplitsDir + "" for vertex "" + vertex.getName() + "" as the partially serialized size in memory is "" + serializationInfo.first + "". Configured "" + PigConfiguration.PIG_TEZ_INPUT_SPLITS_MEM_THRESHOLD + "" is "" + spillThreshold);
					 inputSplitInfo = MRToTezHelper.writeInputSplitInfoToDisk( (InputSplitInfoMem)inputSplitInfo, inputSplitsDir, payloadConf, fs, splitsProto);
					 additionalLocalResources = new HashMap<String, LocalResource>();
					 MRToTezHelper.updateLocalResourcesForInputSplits( fs, inputSplitInfo, additionalLocalResources);
					 inputSplitInDiskVertices.add(vertex.getName());
				 }
				 else {
					 userPayLoadBuilder.setSplits(splitsProto);
				 }
				 tezOp.getLoaderInfo().setInputSplitInfo(null);
			 }
			 udfContextSeparator.serializeUDFContext(inputPayLoad, tezOp, UDFType.LOADFUNC);
			 userPayLoadBuilder.setConfigurationBytes(TezUtils.createByteStringFromConf(inputPayLoad));
			 vertex.setLocationHint(VertexLocationHint.create(inputSplitInfo.getTaskLocationHints()));
			 vertex.addDataSource(ld.getOperatorKey().toString(), DataSourceDescriptor.create(InputDescriptor.create(MRInput.class.getName()) .setUserPayload(UserPayload.create(userPayLoadBuilder.build().toByteString().asReadOnlyByteBuffer())), InputInitializerDescriptor.create(MRInputSplitDistributor.class.getName()), inputSplitInfo.getNumTasks(), dag.getCredentials(), null, additionalLocalResources));
		 }
		 Set<String> uniqueStoreOutputs = new HashSet<String>();
		 for (POStore store : stores) {
			 ArrayList<POStore> singleStore = new ArrayList<POStore>();
			 singleStore.add(store);
			 Configuration outPayLoad = new Configuration(outputPayLoad);
			 udfContextSeparator.serializeUDFContext(outPayLoad, tezOp, store);
			 outPayLoad.set(JobControlCompiler.PIG_REDUCE_STORES, ObjectSerializer.serialize(singleStore));
			 OutputDescriptor storeOutDescriptor = OutputDescriptor.create( MROutput.class.getName()).setUserPayload(TezUtils .createUserPayloadFromConf(outPayLoad));
			 if (tezOp.getVertexGroupStores() != null) {
				 OperatorKey vertexGroupKey = tezOp.getVertexGroupStores().get(store.getOperatorKey());
				 if (vertexGroupKey != null) {
					 getPlan().getOperator(vertexGroupKey).getVertexGroupInfo() .setStoreOutputDescriptor(storeOutDescriptor);
					 continue;
				 }
			 }
			 String outputKey = ((POStoreTez) store).getOutputKey();
			 if (!uniqueStoreOutputs.contains(outputKey)) {
				 vertex.addDataSink(outputKey.toString(), DataSinkDescriptor.create(storeOutDescriptor, OutputCommitterDescriptor.create(MROutputCommitter.class.getName()), dag.getCredentials()));
				 uniqueStoreOutputs.add(outputKey);
			 }
		 }
		 if (stores.size() > 0) {
			 new PigOutputFormat().checkOutputSpecs(job);
		 }
		 if (vmPluginName != null) {
			 VertexManagerPluginDescriptor vmPluginDescriptor = VertexManagerPluginDescriptor.create(vmPluginName);
			 if (vmPluginConf != null) {
				 vmPluginDescriptor.setUserPayload(TezUtils.createUserPayloadFromConf(vmPluginConf));
			 }
			 vertex.setVertexManagerPlugin(vmPluginDescriptor);
		 }
		 UDFContext.getUDFContext().addJobConf(null);
		 return vertex;
	 }
	 private void processUserFuncs(TezOperator tezOp, Job job) throws VisitorException {
		 List<POUserFunc> userFuncs = PlanHelper.getPhysicalOperators(tezOp.plan, POUserFunc.class);
		 for (POUserFunc userFunc : userFuncs) {
			 userFunc.getFunc().addCredentials(job.getCredentials(), job.getConfiguration());
		 }
	 }
	 private LinkedList<POStore> processStores(TezOperator tezOp, Configuration payloadConf, Job job) throws VisitorException, IOException {
		 LinkedList<POStore> stores = PlanHelper.getPhysicalOperators( tezOp.plan, POStore.class);
		 if (stores.size() > 0) {
			 ArrayList<POStore> storeLocations = new ArrayList<POStore>();
			 for (POStore st : stores) {
				 storeLocations.add(st);
				 StoreFuncInterface sFunc = st.getStoreFunc();
				 Job copyOfJob = new Job(job.getConfiguration());
				 sFunc.setStoreLocation(st.getSFile().getFileName(), copyOfJob);
				 if (job.getCredentials() != copyOfJob.getCredentials()) {
					 job.getCredentials().mergeAll(copyOfJob.getCredentials());
				 }
				 sFunc.addCredentials(job.getCredentials(), job.getConfiguration());
			 }
			 Path tmpLocation = null;
			 if (stores.size() == 1) {
				 POStore st = stores.get(0);
				 String outputPathString = st.getSFile().getFileName();
				 if (!outputPathString.contains("": || outputPathString.startsWith(""hdfs: payloadConf.set(""pig.streaming.log.dir"", new Path( outputPathString, JobControlCompiler.LOG_DIR) .toString());
			 }
			 else {
				 String tmpLocationStr = FileLocalizer.getTemporaryPath(pc) .toString();
				 tmpLocation = new Path(tmpLocationStr);
				 payloadConf.set(""pig.streaming.log.dir"", new Path(tmpLocation, JobControlCompiler.LOG_DIR).toString());
			 }
			 payloadConf.set(""pig.streaming.task.output.dir"", outputPathString);
			 if(tezOp.plan.getLeaves().get(0) instanceof POSplit) {
				 st.setMultiStore(true);
			 }
		 }
		 else {
			 log.info(""Setting up multi store job"");
			 String tmpLocationStr = FileLocalizer.getTemporaryPath(pc) .toString();
			 tmpLocation = new Path(tmpLocationStr);
			 boolean disableCounter = payloadConf.getBoolean( ""pig.disable.counter"", false);
			 if (disableCounter) {
				 log.info(""Disable Pig custom output counters"");
			 }
			 int idx = 0;
			 for (POStore sto : storeLocations) {
				 sto.setDisableCounter(disableCounter);
				 sto.setMultiStore(true);
				 sto.setIndex(idx++);
			 }
			 payloadConf.set(""pig.streaming.log.dir"", new Path(tmpLocation, JobControlCompiler.LOG_DIR).toString());
			 payloadConf.set(""pig.streaming.task.output.dir"", tmpLocation.toString());
		 }
	 }
	 return stores;
 }
 private void setIntermediateOutputKeyValue(byte keyType, Configuration conf, TezOperator tezOp, boolean isConnectedToPackage, boolean isMergedInput) throws JobCreationException, ExecException {
	 if (tezOp != null && tezOp.isUseSecondaryKey() && isConnectedToPackage) {
		 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_CLASS, NullableTuple.class.getName());
	 }
	 else if (tezOp != null && tezOp.isSkewedJoin() && isConnectedToPackage) {
		 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_CLASS, NullablePartitionWritable.class.getName());
	 }
	 else {
		 Class<? extends WritableComparable> keyClass = HDataType .getWritableComparableTypes(keyType).getClass();
		 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_CLASS, keyClass.getName());
	 }
	 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_VALUE_CLASS, NullableTuple.class.getName());
	 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_PARTITIONER_CLASS, MRPartitioner.class.getName());
	 selectKeyComparator(keyType, conf, tezOp, isMergedInput);
 }
 private static Class<? extends WritableComparator> getRawBytesComparator( byte keyType) throws JobCreationException {
	 switch (keyType) {
		 case DataType.BOOLEAN: return PigWritableComparators.PigBooleanRawBytesComparator.class;
		 case DataType.INTEGER: return PigWritableComparators.PigIntRawBytesComparator.class;
		 case DataType.BIGINTEGER: return PigWritableComparators.PigBigIntegerRawBytesComparator.class;
		 case DataType.BIGDECIMAL: return PigWritableComparators.PigBigDecimalRawBytesComparator.class;
		 case DataType.LONG: return PigWritableComparators.PigLongRawBytesComparator.class;
		 case DataType.FLOAT: return PigWritableComparators.PigFloatRawBytesComparator.class;
		 case DataType.DOUBLE: return PigWritableComparators.PigDoubleRawBytesComparator.class;
		 case DataType.DATETIME: return PigWritableComparators.PigDateTimeRawBytesComparator.class;
		 case DataType.CHARARRAY: return PigWritableComparators.PigTextRawBytesComparator.class;
		 case DataType.BYTEARRAY: return PigWritableComparators.PigBytesRawBytesComparator.class;
		 case DataType.MAP: int errCode = 1068;
		 String msg = ""Using Map as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 case DataType.TUPLE: return PigWritableComparators.PigTupleSortBytesComparator.class;
		 case DataType.BAG: errCode = 1068;
		 msg = ""Using Bag as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 default: errCode = 2036;
		 msg = ""Unhandled key type "" + DataType.findTypeName(keyType);
		 throw new JobCreationException(msg, errCode, PigException.BUG);
	 }
 }
 private static Class<? extends WritableComparator> getRawComparator(byte keyType) throws JobCreationException {
	 switch (keyType) {
		 case DataType.BOOLEAN: return PigBooleanRawComparator.class;
		 case DataType.INTEGER: return PigIntRawComparator.class;
		 case DataType.BIGINTEGER: return PigBigIntegerRawComparator.class;
		 case DataType.BIGDECIMAL: return PigBigDecimalRawComparator.class;
		 case DataType.LONG: return PigLongRawComparator.class;
		 case DataType.FLOAT: return PigFloatRawComparator.class;
		 case DataType.DOUBLE: return PigDoubleRawComparator.class;
		 case DataType.DATETIME: return PigDateTimeRawComparator.class;
		 case DataType.CHARARRAY: return PigTextRawComparator.class;
		 case DataType.BYTEARRAY: return PigBytesRawComparator.class;
		 case DataType.MAP: int errCode = 1068;
		 String msg = ""Using Map as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 case DataType.TUPLE: return PigTupleSortComparator.class;
		 case DataType.BAG: errCode = 1068;
		 msg = ""Using Bag as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 default: errCode = 2036;
		 msg = ""Unhandled key type "" + DataType.findTypeName(keyType);
		 throw new JobCreationException(msg, errCode, PigException.BUG);
	 }
 }
 private static Class<? extends WritableComparator> getRawBytesComparatorForSkewedJoin(byte keyType) throws JobCreationException {
	 switch (keyType) {
		 case DataType.BOOLEAN: return PigWritableComparators.PigBooleanRawBytesPartitionComparator.class;
		 case DataType.INTEGER: return PigWritableComparators.PigIntRawBytesPartitionComparator.class;
		 case DataType.BIGINTEGER: return PigWritableComparators.PigBigIntegerRawBytesPartitionComparator.class;
		 case DataType.BIGDECIMAL: return PigWritableComparators.PigBigDecimalRawBytesPartitionComparator.class;
		 case DataType.LONG: return PigWritableComparators.PigLongRawBytesPartitionComparator.class;
		 case DataType.FLOAT: return PigWritableComparators.PigFloatRawBytesPartitionComparator.class;
		 case DataType.DOUBLE: return PigWritableComparators.PigDoubleRawBytesPartitionComparator.class;
		 case DataType.DATETIME: return PigWritableComparators.PigDateTimeRawBytesPartitionComparator.class;
		 case DataType.CHARARRAY: return PigWritableComparators.PigTextRawBytesPartitionComparator.class;
		 case DataType.BYTEARRAY: return PigWritableComparators.PigBytesRawBytesPartitionComparator.class;
		 case DataType.MAP: int errCode = 1068;
		 String msg = ""Using Map as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 case DataType.TUPLE: return PigWritableComparators.PigTupleSortBytesPartitionComparator.class;
		 case DataType.BAG: errCode = 1068;
		 msg = ""Using Bag as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 default: errCode = 2036;
		 msg = ""Unhandled key type "" + DataType.findTypeName(keyType);
		 throw new JobCreationException(msg, errCode, PigException.BUG);
	 }
 }
 private static Class<? extends WritableComparator> getRawComparatorForSkewedJoin(byte keyType) throws JobCreationException {
	 switch (keyType) {
		 case DataType.BOOLEAN: return PigWritableComparators.PigBooleanRawPartitionComparator.class;
		 case DataType.INTEGER: return PigWritableComparators.PigIntRawPartitionComparator.class;
		 case DataType.BIGINTEGER: return PigWritableComparators.PigBigIntegerRawPartitionComparator.class;
		 case DataType.BIGDECIMAL: return PigWritableComparators.PigBigDecimalRawPartitionComparator.class;
		 case DataType.LONG: return PigWritableComparators.PigLongRawPartitionComparator.class;
		 case DataType.FLOAT: return PigWritableComparators.PigFloatRawPartitionComparator.class;
		 case DataType.DOUBLE: return PigWritableComparators.PigDoubleRawPartitionComparator.class;
		 case DataType.DATETIME: return PigWritableComparators.PigDateTimeRawPartitionComparator.class;
		 case DataType.CHARARRAY: return PigWritableComparators.PigTextRawPartitionComparator.class;
		 case DataType.BYTEARRAY: return PigWritableComparators.PigBytesRawPartitionComparator.class;
		 case DataType.MAP: int errCode = 1068;
		 String msg = ""Using Map as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 case DataType.TUPLE: return PigWritableComparators.PigTupleSortPartitionComparator.class;
		 case DataType.BAG: errCode = 1068;
		 msg = ""Using Bag as key not supported."";
		 throw new JobCreationException(msg, errCode, PigException.INPUT);
		 default: errCode = 2036;
		 msg = ""Unhandled key type "" + DataType.findTypeName(keyType);
		 throw new JobCreationException(msg, errCode, PigException.BUG);
	 }
 }
 void selectKeyComparator(byte keyType, Configuration conf, TezOperator tezOp, boolean isMergedInput) throws JobCreationException {
	 if (tezOp == null) {
		 return;
	 }
	 if (tezOp.isUseSecondaryKey()) {
		 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_COMPARATOR_CLASS, PigSecondaryKeyComparator.class.getName());
		 setGroupingComparator(conf, PigSecondaryKeyGroupComparator.class.getName());
	 }
	 else {
		 if (!isMergedInput && (tezOp.isGroupBy() || tezOp.isDistinct())) {
			 conf.setClass( TezRuntimeConfiguration.TEZ_RUNTIME_KEY_COMPARATOR_CLASS, getRawBytesComparator(keyType), RawComparator.class);
		 }
		 else if (tezOp.isSkewedJoin()) {
			 conf.setClass(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_COMPARATOR_CLASS, getRawComparatorForSkewedJoin(keyType), RawComparator.class);
		 }
		 else {
			 conf.setClass( TezRuntimeConfiguration.TEZ_RUNTIME_KEY_COMPARATOR_CLASS, getRawComparator(keyType), RawComparator.class);
		 }
	 }
 }
 private boolean hasOrderby(TezOperator tezOp) {
	 boolean hasOrderBy = tezOp.isGlobalSort() || tezOp.isLimitAfterSort();
	 if (!hasOrderBy) {
		 List<TezOperator> succs = getPlan().getSuccessors(tezOp);
		 if (succs != null && succs.size() == 1) {
			 if (succs.get(0).isGlobalSort()) {
				 hasOrderBy = true;
			 }
		 }
	 }
	 return hasOrderBy;
 }
 private void setGroupingComparator(Configuration conf, String comparatorClass) {
	 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_GROUP_COMPARATOR_CLASS, comparatorClass);
	 conf.set(TezRuntimeConfiguration.TEZ_RUNTIME_KEY_SECONDARY_COMPARATOR_CLASS, comparatorClass);
 }
 private void setOutputFormat(org.apache.hadoop.mapreduce.Job job) {
	 if (""true"".equalsIgnoreCase(job.getConfiguration().get(PigConfiguration.PIG_OUTPUT_LAZY))) {
		 LazyOutputFormat.setOutputFormatClass(job,PigOutputFormatTez.class);
	 }
	 else {
		 job.setOutputFormatClass(PigOutputFormatTez.class);
	 }
 }
}",1,0,0,0
"protected class LeaderListener extends LeaderSelectorListenerAdapter {
	public void takeLeadership(CuratorFramework framework) {
		try {
			LeaderInitiator.this.candidate.onGranted(LeaderInitiator.this.context);
			if (LeaderInitiator.this.leaderEventPublisher != null) {
				try {
					LeaderInitiator.this.leaderEventPublisher.publishOnGranted(LeaderInitiator.this,LeaderInitiator.this.context, LeaderInitiator.this.candidate.getRole());
				}
				catch (Exception e) {
					logger.warn(""Error publishing OnGranted event."", e);
				}
			}
			Thread.sleep(Long.MAX_VALUE);
		}
		catch ( InterruptedException e) {
		}
		finally {
			LeaderInitiator.this.candidate.onRevoked(LeaderInitiator.this.context);
			if (LeaderInitiator.this.leaderEventPublisher != null) {
				try {
					LeaderInitiator.this.leaderEventPublisher.publishOnRevoked(LeaderInitiator.this,LeaderInitiator.this.context, LeaderInitiator.this.candidate.getRole());
				}
				catch (Exception e) {
					logger.warn(""Error publishing OnRevoked event."", e);
				}
			}
		}
	}
}",0,0,0,0
"public class ItemContent{
	private String defaultName = """";
	 private String displayName = """";
	 private String customName = """";
	 private String description = """";
	 public ItemContent( String string ){
		super( );
		this.setCustomName( string );
	}
	public String getDefaultName( ){
		return defaultName;
	}
	public String getDisplayName( ){
		return displayName;
	}
	public void setDefaultName( String string ){
		defaultName = string.trim( );
	}
	public void setDisplayName( String string ){
		displayName = string.trim( );
	}
	public String getCustomName( ){
		return customName;
	}
	public void setCustomName( String string ){
		customName = string.trim( );
	}
	public String getDescription( ){
		return description;
	}
	public void setDescription( String string ){
		description = string.trim( );
	}
}",1,1,0,0
"public class SignatureSupportingConfigProperties {
	 private String sharedSecret;
	 private String keyPath;
	 private long tokenExpirationSeconds = 600L;
	 private String certificatePath;
	 public final String getSharedSecret() {
		 return sharedSecret;
	 }
	 public final void setSharedSecret(final String secret) {
		 if (Objects.requireNonNull(secret).getBytes(StandardCharsets.UTF_8).length < 32) {
			 throw new IllegalArgumentException(""shared secret must be at least 32 bytes"");
		 }
		 this.sharedSecret = secret;
	 }
	 public final void setKeyPath(final String keyPath) {
		 this.keyPath = Objects.requireNonNull(keyPath);
	 }
	 public final String getKeyPath() {
		 return keyPath;
	 }
	 public final long getTokenExpiration() {
		 return tokenExpirationSeconds;
	 }
	 public final void setTokenExpiration(final long seconds) {
		 if (seconds <= 0) {
			 throw new IllegalArgumentException(""token expiration must be > 0"");
		 }
		 this.tokenExpirationSeconds = seconds;
	 }
	 public final void setCertPath(final String certPath) {
		 this.certificatePath = Objects.requireNonNull(certPath);
	 }
	 public final String getCertPath() {
		 return certificatePath;
	 }
	 public final boolean isAppropriateForCreating() {
		 return sharedSecret != null || keyPath != null;
	 }
	 public final boolean isAppropriateForValidating() {
		 return sharedSecret != null || certificatePath != null;
	 }
}",1,1,0,0
"public class CookieUtils {
	 private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
	 private static final String THEME_PARAMETER = ""tobago.theme"";
	 private static final int ONE_YEAR_IN_SECONDS = 365 * 24 * 60 * 60;
	 private CookieUtils() {
	 }
	 public static String getThemeNameFromCookie(final HttpServletRequest request) {
		 String themeName = null;
		 final Cookie[] cookies = request.getCookies();
		 if (cookies != null) {
			 for (final Cookie cookie : cookies) {
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""cookie name ='{
					}
					'"", cookie.getName());
					 LOG.debug(""cookie value ='{
					}
					'"", cookie.getValue());
					 LOG.debug(""cookie path ='{
					}
					'"", cookie.getPath());
				 }
				 if (THEME_PARAMETER.equals(cookie.getName())) {
					 themeName = cookie.getValue();
					 if (LOG.isDebugEnabled()) {
						 LOG.debug(""theme from cookie {
						}
						='{
						}
						'"", THEME_PARAMETER, themeName);
					 }
					 break;
				 }
			 }
		 }
		 return themeName;
	 }
	 public static void setThemeNameToCookie( final HttpServletRequest request, final HttpServletResponse response, final String themeName) {
		 String path = request.getContextPath();
		 path = StringUtils.isBlank(path) ? ""/"" : path;
		 boolean found = false;
		 final Cookie[] cookies = request.getCookies();
		 if (cookies != null) {
			 for (final Cookie cookie : cookies) {
				 if (THEME_PARAMETER.equals(cookie.getName())) {
					 if (found) {
						 if (LOG.isDebugEnabled()) {
							 LOG.debug(""Found more than one cookie {
							}
							, try to remove them..."", THEME_PARAMETER);
						 }
						 cookie.setMaxAge(0);
					 }
					 else {
						 found = true;
						 if (StringUtils.notEquals(cookie.getValue(), themeName)) {
							 if (LOG.isDebugEnabled()) {
								 LOG.debug(""update theme {
								}
								 -> {
								}
								"", cookie.getValue(), themeName);
							 }
							 cookie.setValue(themeName);
						 }
						 if (StringUtils.notEquals(cookie.getPath(), path)) {
							 if (LOG.isDebugEnabled()) {
								 LOG.debug(""update path {
								}
								 -> {
								}
								"", cookie.getPath(), path);
							 }
							 cookie.setPath(path);
						 }
						 cookie.setMaxAge(ONE_YEAR_IN_SECONDS);
					 }
					 response.addCookie(cookie);
				 }
			 }
		 }
		 if (!found) {
			 final Cookie cookie = new Cookie(THEME_PARAMETER, themeName);
			 cookie.setPath(path);
			 cookie.setMaxAge(ONE_YEAR_IN_SECONDS);
			 response.addCookie(cookie);
		 }
	 }
	 public static void removeThemeNameCookie( final HttpServletRequest request, final HttpServletResponse response) {
		 String path = request.getContextPath();
		 path = StringUtils.isBlank(path) ? ""/"" : path;
		 final Cookie[] cookies = request.getCookies();
		 if (cookies != null) {
			 for (final Cookie cookie : cookies) {
				 if (THEME_PARAMETER.equals(cookie.getName())) {
					 cookie.setMaxAge(0);
					 cookie.setValue(null);
					 response.addCookie(cookie);
				 }
			 }
		 }
	 }
}",0,0,0,0
"public int compareTo(Object o) {
	 Block b = (Block) o;
	 if (getBlockId() < b.getBlockId()) {
		 return -1;
	 }
	 else if (getBlockId() == b.getBlockId()) {
		 return 0;
	 }
	 else {
		 return 1;
	 }
 }",0,0,0,0
"public abstract class Pack extends Task {
	 private static final int BUFFER_SIZE = 8 * 1024;
	 protected File zipFile;
	 protected File source;
	 private Resource src;
	 public void setZipfile(File zipFile) {
		 this.zipFile = zipFile;
	 }
	 public void setDestfile(File zipFile) {
		 setZipfile(zipFile);
	 }
	 public void setSrc(File src) {
		 setSrcResource(new FileResource(src));
	 }
	 public void setSrcResource(Resource src) {
		 if (src.isDirectory()) {
			 throw new BuildException(""the source can't be a directory"");
		 }
		 if (src instanceof FileResource) {
			 source = ((FileResource) src).getFile();
		 }
		 else if (!supportsNonFileResources()) {
			 throw new BuildException(""Only FileSystem resources are"" + "" supported."");
		 }
		 this.src = src;
	 }
	 public void addConfigured(ResourceCollection a) {
		 if (a.size() == 0) {
			 throw new BuildException(""No resource selected, "" + getTaskName() + "" needs exactly one resource."");
		 }
		 if (a.size() != 1) {
			 throw new BuildException(getTaskName() + "" cannot handle multiple resources at once. ("" + a.size() + "" resources were selected.)"");
		 }
		 setSrcResource((Resource) a.iterator().next());
	 }
	 private void validate() throws BuildException {
		 if (zipFile == null) {
			 throw new BuildException(""zipfile attribute is required"", getLocation());
		 }
		 if (zipFile.isDirectory()) {
			 throw new BuildException(""zipfile attribute must not "" + ""represent a directory!"", getLocation());
		 }
		 if (getSrcResource() == null) {
			 throw new BuildException(""src attribute or nested resource is"" + "" required"", getLocation());
		 }
	 }
	 public void execute() throws BuildException {
		 validate();
		 Resource s = getSrcResource();
		 if (!s.isExists()) {
			 log(""Nothing to do: "" + s.toString() + "" doesn't exist."");
		 }
		 else if (zipFile.lastModified() < s.getLastModified()) {
			 log(""Building: "" + zipFile.getAbsolutePath());
			 pack();
		 }
		 else {
			 log(""Nothing to do: "" + zipFile.getAbsolutePath() + "" is up to date."");
		 }
	 }
	 private void zipFile(InputStream in, OutputStream zOut) throws IOException {
		 byte[] buffer = new byte[BUFFER_SIZE];
		 int count = 0;
		 do {
			 zOut.write(buffer, 0, count);
			 count = in.read(buffer, 0, buffer.length);
		 }
		 while (count != -1);
	 }
	 protected void zipFile(File file, OutputStream zOut) throws IOException {
		 zipResource(new FileResource(file), zOut);
	 }
	 protected void zipResource(Resource resource, OutputStream zOut) throws IOException {
		 InputStream rIn = resource.getInputStream();
		 try {
			 zipFile(rIn, zOut);
		 }
		 finally {
			 rIn.close();
		 }
	 }
	 protected abstract void pack();
	 public Resource getSrcResource() {
		 return src;
	 }
	 protected boolean supportsNonFileResources() {
		 return false;
	 }
}",0,0,0,0
"public class DataNode implements FSConstants, Runnable {
	 public static final Logger LOG = LogFormatter.getLogger(""org.apache.hadoop.dfs.DataNode"");
	 static {
		 new BlockCommand();
	 }
	 public static InetSocketAddress createSocketAddr(String s) throws IOException {
		 String target = s;
		 int colonIndex = target.indexOf(':');
		 if (colonIndex < 0) {
			 throw new RuntimeException(""Not a host:port pair: "" + s);
		 }
		 String host = target.substring(0, colonIndex);
		 int port = Integer.parseInt(target.substring(colonIndex + 1));
		 return new InetSocketAddress(host, port);
	 }
	 private static Vector subThreadList = null;
	 DatanodeProtocol namenode;
	 FSDataset data;
	 String localName;
	 boolean shouldRun = true;
	 Vector receivedBlockList = new Vector();
	 int xmitsInProgress = 0;
	 Daemon dataXceiveServer = null;
	 long blockReportInterval;
	 public DataNode(Configuration conf, String datadir) throws IOException {
		 this(InetAddress.getLocalHost().getHostName(), new File(datadir), createSocketAddr(conf.get(""fs.default.name"", ""local"")), conf);
	 }
	 public DataNode(String machineName, File datadir, InetSocketAddress nameNodeAddr, Configuration conf) throws IOException {
		 this.namenode = (DatanodeProtocol) RPC.getProxy(DatanodeProtocol.class, nameNodeAddr, conf);
		 this.data = new FSDataset(datadir, conf);
		 ServerSocket ss = null;
		 int tmpPort = conf.getInt(""dfs.datanode.port"", 50010);
		 while (ss == null) {
			 try {
				 ss = new ServerSocket(tmpPort);
				 LOG.info(""Opened server at "" + tmpPort);
			 }
			 catch (IOException ie) {
				 LOG.info(""Could not open server at "" + tmpPort + "", trying new port"");
				 tmpPort++;
			 }
		 }
		 this.localName = machineName + "":"" + tmpPort;
		 this.dataXceiveServer = new Daemon(new DataXceiveServer(ss));
		 this.dataXceiveServer.start();
		 long blockReportIntervalBasis = conf.getLong(""dfs.blockreport.intervalMsec"", BLOCKREPORT_INTERVAL);
		 this.blockReportInterval = blockReportIntervalBasis - new Random().nextInt((int)(blockReportIntervalBasis/10));
	 }
	 public String getNamenode() {
		return ""<namenode>"";
	 }
	 void shutdown() {
		 this.shouldRun = false;
		 ((DataXceiveServer) this.dataXceiveServer.getRunnable()).kill();
		 try {
			 this.dataXceiveServer.join();
		 }
		 catch (InterruptedException ie) {
		 }
	 }
	 public void offerService() throws Exception {
		 long lastHeartbeat = 0, lastBlockReport = 0;
		 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
		 while (shouldRun) {
			 long now = System.currentTimeMillis();
			 if (now - lastHeartbeat > HEARTBEAT_INTERVAL) {
				 BlockCommand cmd = namenode.sendHeartbeat(localName, data.getCapacity(), data.getRemaining(), xmitsInProgress);
				 lastHeartbeat = now;
				 if (cmd != null && cmd.transferBlocks()) {
					 Block blocks[] = cmd.getBlocks();
					 DatanodeInfo xferTargets[][] = cmd.getTargets();
					 for (int i = 0;
					 i < blocks.length;
					 i++) {
						 if (!data.isValidBlock(blocks[i])) {
							 String errStr = ""Can't send invalid block "" + blocks[i];
							 LOG.info(errStr);
							 namenode.errorReport(localName, errStr);
							 break;
						 }
						 else {
							 if (xferTargets[i].length > 0) {
								 LOG.info(""Starting thread to transfer block "" + blocks[i] + "" to "" + xferTargets[i]);
								 new Daemon(new DataTransfer(xferTargets[i], blocks[i])).start();
							 }
						 }
					 }
				 }
				 else if (cmd != null && cmd.invalidateBlocks()) {
					 data.invalidate(cmd.getBlocks());
				 }
			 }
			 if (now - lastBlockReport > blockReportInterval) {
				 Block toDelete[] = namenode.blockReport(localName, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			 }
			 Block [] blockArray=null;
			 synchronized( receivedBlockList ) {
				 if (receivedBlockList.size() > 0) {
					 blockArray = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
					 receivedBlockList.removeAllElements();
				 }
			 }
			 if( blockArray != null ) {
				 namenode.blockReceived(localName, blockArray);
			 }
			 long waitTime = HEARTBEAT_INTERVAL - (System.currentTimeMillis() - lastHeartbeat);
			 synchronized( receivedBlockList ) {
				 if (waitTime > 0 && receivedBlockList.size() == 0) {
					 try {
						 receivedBlockList.wait(waitTime);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
	 }
	 class DataXceiveServer implements Runnable {
		 boolean shouldListen = true;
		 ServerSocket ss;
		 public DataXceiveServer(ServerSocket ss) {
			 this.ss = ss;
		 }
		 public void run() {
			 try {
				 while (shouldListen) {
					 Socket s = ss.accept();
					 new Daemon(new DataXceiver(s)).start();
				 }
				 ss.close();
			 }
			 catch (IOException ie) {
				 LOG.info(""Exiting DataXceiveServer due to "" + ie.toString());
			 }
		 }
		 public void kill() {
			 this.shouldListen = false;
			 try {
				 this.ss.close();
			 }
			 catch (IOException iex) {
			 }
		 }
	 }
	 class DataXceiver implements Runnable {
		 Socket s;
		 public DataXceiver(Socket s) {
			 this.s = s;
		 }
		 public void run() {
			 try {
				 DataInputStream in = new DataInputStream(new BufferedInputStream(s.getInputStream()));
				 try {
					 byte op = (byte) in.read();
					 if (op == OP_WRITE_BLOCK) {
						 writeBlock(in);
					 }
					 else if (op == OP_READ_BLOCK || op == OP_READSKIP_BLOCK) {
						 readBlock(in, op);
					 }
					 else {
						 while (op >= 0) {
							 System.out.println(""Faulty op: "" + op);
							 op = (byte) in.read();
						 }
						 throw new IOException(""Unknown opcode for incoming data stream"");
					 }
				 }
				 finally {
					 in.close();
				 }
			 }
			 catch (IOException ie) {
				 LOG.log(Level.WARNING, ""DataXCeiver"", ie);
			 }
			 finally {
				 try {
					 s.close();
				 }
				 catch (IOException ie2) {
				 }
			 }
		 }
		 private void readBlock(DataInputStream in, byte op) throws IOException {
			 Block b = new Block();
			 b.readFields(in);
			 long toSkip = 0;
			 if (op == OP_READSKIP_BLOCK) {
				 toSkip = in.readLong();
			 }
			 DataOutputStream out = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
			 try {
				 if (! data.isValidBlock(b)) {
					 out.writeLong(-1);
				 }
				 else {
					 long len = data.getLength(b);
					 DataInputStream in2 = new DataInputStream(data.getBlockData(b));
					 out.writeLong(len);
					 if (op == OP_READSKIP_BLOCK) {
						 if (toSkip > len) {
							 toSkip = len;
						 }
						 long amtSkipped = 0;
						 try {
							 amtSkipped = in2.skip(toSkip);
						 }
						 catch (IOException iex) {
							 shutdown();
							 throw iex;
						 }
						 out.writeLong(amtSkipped);
					 }
					 byte buf[] = new byte[BUFFER_SIZE];
					 try {
						 int bytesRead = 0;
						 try {
							 bytesRead = in2.read(buf);
						 }
						 catch (IOException iex) {
							 shutdown();
							 throw iex;
						 }
						 while (bytesRead >= 0) {
							 out.write(buf, 0, bytesRead);
							 len -= bytesRead;
							 try {
								 bytesRead = in2.read(buf);
							 }
							 catch (IOException iex) {
								 shutdown();
								 throw iex;
							 }
						 }
					 }
					 catch (SocketException se) {
					 }
					 finally {
						 try {
							 in2.close();
						 }
						 catch (IOException iex) {
							 shutdown();
							 throw iex;
						 }
					 }
				 }
				 LOG.info(""Served block "" + b + "" to "" + s.getInetAddress());
			 }
			 finally {
				 out.close();
			 }
		 }
		 private void writeBlock(DataInputStream in) throws IOException {
			 DataOutputStream reply = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
			 try {
				 boolean shouldReportBlock = in.readBoolean();
				 Block b = new Block();
				 b.readFields(in);
				 int numTargets = in.readInt();
				 if (numTargets <= 0) {
					 throw new IOException(""Mislabelled incoming datastream."");
				 }
				 DatanodeInfo targets[] = new DatanodeInfo[numTargets];
				 for (int i = 0;
				 i < targets.length;
				 i++) {
					 DatanodeInfo tmp = new DatanodeInfo();
					 tmp.readFields(in);
					 targets[i] = tmp;
				 }
				 byte encodingType = (byte) in.read();
				 long len = in.readLong();
				 DatanodeInfo curTarget = targets[0];
				 Vector mirrors = new Vector();
				 DataOutputStream out = new DataOutputStream(new BufferedOutputStream(data.writeToBlock(b)));
				 InetSocketAddress mirrorTarget = null;
				 String mirrorNode = null;
				 try {
					 DataInputStream in2 = null;
					 DataOutputStream out2 = null;
					 if (targets.length > 1) {
						 mirrorNode = targets[1].getName().toString();
						 mirrorTarget = createSocketAddr(mirrorNode);
						 try {
							 Socket s2 = new Socket();
							 s2.connect(mirrorTarget, READ_TIMEOUT);
							 s2.setSoTimeout(READ_TIMEOUT);
							 out2 = new DataOutputStream(new BufferedOutputStream(s2.getOutputStream()));
							 in2 = new DataInputStream(new BufferedInputStream(s2.getInputStream()));
							 out2.write(OP_WRITE_BLOCK);
							 out2.writeBoolean(shouldReportBlock);
							 b.write(out2);
							 out2.writeInt(targets.length - 1);
							 for (int i = 1;
							 i < targets.length;
							 i++) {
								 targets[i].write(out2);
							 }
							 out2.write(encodingType);
							 out2.writeLong(len);
						 }
						 catch (IOException ie) {
							 if (out2 != null) {
								 LOG.info(""Exception connecting to mirror "" + mirrorNode + ""\n"" + StringUtils.stringifyException(ie));
								 try {
									 out2.close();
									 in2.close();
								 }
								 catch (IOException out2close) {
								 }
								 finally {
									 out2 = null;
									 in2 = null;
								 }
							 }
						 }
					 }
					 boolean anotherChunk = len != 0;
					 byte buf[] = new byte[BUFFER_SIZE];
					 while (anotherChunk) {
						 while (len > 0) {
							 int bytesRead = in.read(buf, 0, (int)Math.min(buf.length, len));
							 if (bytesRead < 0) {
								 throw new EOFException(""EOF reading from ""+s.toString());
							 }
							 if (bytesRead > 0) {
								 try {
									 out.write(buf, 0, bytesRead);
								 }
								 catch (IOException iex) {
									 shutdown();
									 throw iex;
								 }
								 if (out2 != null) {
									 try {
										 out2.write(buf, 0, bytesRead);
									 }
									 catch (IOException out2e) {
										 LOG.info(""Exception writing to mirror "" + mirrorNode + ""\n"" + StringUtils.stringifyException(out2e));
										 try {
											 out2.close();
											 in2.close();
										 }
										 catch (IOException out2close) {
										 }
										 finally {
											 out2 = null;
											 in2 = null;
										 }
									 }
								 }
								 len -= bytesRead;
							 }
						 }
						 if (encodingType == RUNLENGTH_ENCODING) {
							 anotherChunk = false;
						 }
						 else if (encodingType == CHUNKED_ENCODING) {
							 len = in.readLong();
							 if (out2 != null) {
								 try {
									 out2.writeLong(len);
								 }
								 catch (IOException ie) {
									 LOG.info(""Exception writing to mirror "" + mirrorNode + ""\n"" + StringUtils.stringifyException(ie));
									 try {
										 out2.close();
										 in2.close();
									 }
									 catch (IOException ie2) {
									 }
									 finally {
										 out2 = null;
										 in2 = null;
									 }
								 }
							 }
							 if (len == 0) {
								 anotherChunk = false;
							 }
						 }
					 }
					 if (out2 != null) {
						 try {
							 out2.flush();
							 long complete = in2.readLong();
							 if (complete != WRITE_COMPLETE) {
								 LOG.info(""Conflicting value for WRITE_COMPLETE: "" + complete);
							 }
							 LocatedBlock newLB = new LocatedBlock();
							 newLB.readFields(in2);
							 in2.close();
							 out2.close();
							 DatanodeInfo mirrorsSoFar[] = newLB.getLocations();
							 for (int k = 0;
							 k < mirrorsSoFar.length;
							 k++) {
								 mirrors.add(mirrorsSoFar[k]);
							 }
						 }
						 catch (IOException ie) {
							 LOG.info(""Exception writing to mirror "" + mirrorNode + ""\n"" + StringUtils.stringifyException(ie));
							 try {
								 out2.close();
								 in2.close();
							 }
							 catch (IOException ie2) {
							 }
							 finally {
								 out2 = null;
								 in2 = null;
							 }
						 }
					 }
					 if (out2 == null) {
						 LOG.info(""Received block "" + b + "" from "" + s.getInetAddress());
					 }
					 else {
						 LOG.info(""Received block "" + b + "" from "" + s.getInetAddress() + "" and mirrored to "" + mirrorTarget);
					 }
				 }
				 finally {
					 try {
						 out.close();
					 }
					 catch (IOException iex) {
						 shutdown();
						 throw iex;
					 }
				 }
				 data.finalizeBlock(b);
				 if (shouldReportBlock) {
					 synchronized (receivedBlockList) {
						 receivedBlockList.add(b);
						 receivedBlockList.notifyAll();
					 }
				 }
				 reply.writeLong(WRITE_COMPLETE);
				 mirrors.add(curTarget);
				 LocatedBlock newLB = new LocatedBlock(b, (DatanodeInfo[]) mirrors.toArray(new DatanodeInfo[mirrors.size()]));
				 newLB.write(reply);
			 }
			 finally {
				 reply.close();
			 }
		 }
	 }
	 class DataTransfer implements Runnable {
		 InetSocketAddress curTarget;
		 DatanodeInfo targets[];
		 Block b;
		 byte buf[];
		 public DataTransfer(DatanodeInfo targets[], Block b) throws IOException {
			 this.curTarget = createSocketAddr(targets[0].getName().toString());
			 this.targets = targets;
			 this.b = b;
			 this.buf = new byte[BUFFER_SIZE];
		 }
		 public void run() {
			 xmitsInProgress++;
			 try {
				 Socket s = new Socket();
				 s.connect(curTarget, READ_TIMEOUT);
				 s.setSoTimeout(READ_TIMEOUT);
				 DataOutputStream out = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
				 try {
					 long filelen = data.getLength(b);
					 DataInputStream in = new DataInputStream(new BufferedInputStream(data.getBlockData(b)));
					 try {
						 out.write(OP_WRITE_BLOCK);
						 out.writeBoolean(true);
						 b.write(out);
						 out.writeInt(targets.length);
						 for (int i = 0;
						 i < targets.length;
						 i++) {
							 targets[i].write(out);
						 }
						 out.write(RUNLENGTH_ENCODING);
						 out.writeLong(filelen);
						 while (filelen > 0) {
							 int bytesRead = in.read(buf, 0, (int) Math.min(filelen, buf.length));
							 out.write(buf, 0, bytesRead);
							 filelen -= bytesRead;
						 }
					 }
					 finally {
						 in.close();
					 }
				 }
				 finally {
					 out.close();
				 }
				 LOG.info(""Transmitted block "" + b + "" to "" + curTarget);
			 }
			 catch (IOException ie) {
				 LOG.log(Level.WARNING, ""Failed to transfer ""+b+"" to ""+curTarget, ie);
			 }
			 finally {
				xmitsInProgress--;
			 }
		 }
	 }
	 public void run() {
		 LOG.info(""Starting DataNode in: ""+data.data);
		 while (shouldRun) {
			 try {
				 offerService();
			 }
			 catch (Exception ex) {
				 LOG.info(""Exception: "" + ex);
				 if (shouldRun) {
					 LOG.info(""Lost connection to namenode. Retrying..."");
					 try {
						 Thread.sleep(5000);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
		 LOG.info(""Finishing DataNode in: ""+data.data);
	 }
	 public static void run(Configuration conf) throws IOException {
		 String[] dataDirs = conf.getStrings(""dfs.data.dir"");
		 subThreadList = new Vector(dataDirs.length);
		 for (int i = 0;
		 i < dataDirs.length;
		 i++) {
			 DataNode dn = makeInstanceForDir(dataDirs[i], conf);
			 if (dn != null) {
				 Thread t = new Thread(dn, ""DataNode: ""+dataDirs[i]);
				 t.setDaemon(true);
				 t.start();
				 subThreadList.add(t);
			 }
		 }
	 }
	 private static void runAndWait(Configuration conf) throws IOException {
		 run(conf);
		 for (Iterator iterator = subThreadList.iterator();
		 iterator.hasNext();
		) {
			 Thread threadDataNode = (Thread) iterator.next();
			 try {
				 threadDataNode.join();
			 }
			 catch (InterruptedException e) {
				 if (Thread.currentThread().isInterrupted()) {
					 return;
				 }
			 }
		 }
	 }
	 static DataNode makeInstanceForDir(String dataDir, Configuration conf) throws IOException {
		 DataNode dn = null;
		 File data = new File(dataDir);
		 data.mkdirs();
		 if (!data.isDirectory()) {
			 LOG.warning(""Can't start DataNode in non-directory: ""+dataDir);
			 return null;
		 }
		 else {
			 dn = new DataNode(conf, dataDir);
		 }
		 return dn;
	 }
	 public String toString() {
		 return ""DataNode{
		"" + ""data="" + data + "", localName='"" + localName + ""'"" + "", xmitsInProgress="" + xmitsInProgress + ""}
		"";
	 }
	 public static void main(String args[]) throws IOException {
		 Configuration conf = new Configuration();
		 LogFormatter.setShowThreadIDs(true);
		 LogFormatter.initFileHandler(conf, ""datanode"");
		 runAndWait(conf);
	 }
}",0,0,0,0
"public final class AtlasPerfTracer {
	 protected final Logger logger;
	 protected final String tag;
	 private final long startTimeMs;
	 private static long reportingThresholdMs = 0L;
	 public static Logger getPerfLogger(String name) {
		 return LoggerFactory.getLogger(""org.apache.atlas.perf."" + name);
	 }
	 public static Logger getPerfLogger(Class<?> cls) {
		 return AtlasPerfTracer.getPerfLogger(cls.getName());
	 }
	 public static boolean isPerfTraceEnabled(Logger logger) {
		 return logger.isDebugEnabled();
	 }
	 public static AtlasPerfTracer getPerfTracer(Logger logger, String tag) {
		 return new AtlasPerfTracer(logger, tag);
	 }
	 public static void log(AtlasPerfTracer tracer) {
		 if (tracer != null) {
			 tracer.log();
		 }
	 }
	 private AtlasPerfTracer(Logger logger, String tag) {
		 this.logger = logger;
		 this.tag = tag;
		 startTimeMs = System.currentTimeMillis();
	 }
	 public String getTag() {
		 return tag;
	 }
	 public long getStartTime() {
		 return startTimeMs;
	 }
	 public long getElapsedTime() {
		 return System.currentTimeMillis() - startTimeMs;
	 }
	 public void log() {
		 long elapsedTime = getElapsedTime();
		 if (elapsedTime > reportingThresholdMs) {
			 logger.debug(""PERF|{
			}
			|{
			}
			"", tag, elapsedTime);
		 }
	 }
}",0,1,0,0
"public class GraphicsState {
	 Matrix ctm;
	 float characterSpacing;
	 float wordSpacing;
	 float horizontalScaling;
	 float leading;
	 CMapAwareDocumentFont font;
	 float fontSize;
	 int renderMode;
	 float rise;
	 boolean knockout;
	 public GraphicsState(){
		 ctm = new Matrix();
		 characterSpacing = 0;
		 wordSpacing = 0;
		 horizontalScaling = 1.0f;
		 leading = 0;
		 font = null;
		 fontSize = 0;
		 renderMode = 0;
		 rise = 0;
		 knockout = true;
	 }
	 public GraphicsState(GraphicsState source){
		 ctm = source.ctm;
		 characterSpacing = source.characterSpacing;
		 wordSpacing = source.wordSpacing;
		 horizontalScaling = source.horizontalScaling;
		 leading = source.leading;
		 font = source.font;
		 fontSize = source.fontSize;
		 renderMode = source.renderMode;
		 rise = source.rise;
		 knockout = source.knockout;
	 }
	public Matrix getCtm() {
		return ctm;
	}
	public float getCharacterSpacing() {
		return characterSpacing;
	}
	public float getWordSpacing() {
		return wordSpacing;
	}
	public float getHorizontalScaling() {
		return horizontalScaling;
	}
	public float getLeading() {
		return leading;
	}
	public CMapAwareDocumentFont getFont() {
		return font;
	}
	public float getFontSize() {
		return fontSize;
	}
	public int getRenderMode() {
		return renderMode;
	}
	public float getRise() {
		return rise;
	}
	public boolean isKnockout() {
		return knockout;
	}
}",0,1,0,0
"public ByteBuffer packIt(byte[] bytes, boolean compress) {
	 int header = 0;
	 header |= serializerType_.ordinal();
	 if (compress) header |= 4;
	 header |= (version_ << 8);
	 ByteBuffer buffer = ByteBuffer.allocate(4 + 4 + 4 + bytes.length);
	 buffer.putInt(PROTOCOL_MAGIC);
	 buffer.putInt(header);
	 buffer.putInt(bytes.length);
	 buffer.put(bytes);
	 buffer.flip();
	 return buffer;
 }",0,0,0,0
"class ManualImplementationLoaderService<T>{
	 private static final String SERVICE_CONFIG = ""META-INF/services/"";
	 private static final String FILE_ENCODING = ""UTF-8"";
	 protected List<Class<?>> foundServiceClasses = new ArrayList<>();
	 private Class<T> serviceType;
	 private ClassLoader currentClassLoader;
	 ManualImplementationLoaderService(Class<T> serviceType, ClassLoader currentClassLoader) {
		 this.serviceType = serviceType;
		 this.currentClassLoader = currentClassLoader;
	 }
	 List<T> loadServiceImplementations() {
		 List<Class<?>> result = resolveServiceImplementations();
		 if (result == null) {
			 return Collections.emptyList();
		 }
		 List<T> foundServices = new ArrayList<>();
		 for (Class<?> serviceClass : result) {
			 foundServices.add(createInstance(serviceClass));
		 }
		 return foundServices;
	 }
	 private List<Class<?>> resolveServiceImplementations() {
		 for (URL configFile : getConfigFileList()) {
			 loadConfiguredServices(configFile);
		 }
		 return foundServiceClasses;
	 }
	 private List<URL> getConfigFileList() {
		 List<URL> serviceFiles = new ArrayList<>();
		 try {
			 Enumeration<URL> serviceFileEnumerator = currentClassLoader.getResources(getConfigFileLocation());
			 while (serviceFileEnumerator.hasMoreElements()) {
				 serviceFiles.add(serviceFileEnumerator.nextElement());
			 }
		 }
		 catch (Exception e) {
			 throw new IllegalStateException( ""Failed to load "" + serviceType.getName() + "" configured in "" + getConfigFileLocation(), e);
		 }
		 return serviceFiles;
	 }
	 private String getConfigFileLocation() {
		 return SERVICE_CONFIG + serviceType.getName();
	 }
	 private void loadConfiguredServices(URL serviceFile) {
		 InputStream inputStream = null;
		 try {
			 String serviceClassName;
			 inputStream = serviceFile.openStream();
			 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream, FILE_ENCODING));
			 while ((serviceClassName = bufferedReader.readLine()) != null) {
				 serviceClassName = extractConfiguredServiceClassName(serviceClassName);
				 if (!"""".equals(serviceClassName)) {
					 loadService(serviceClassName);
				 }
			 }
		 }
		 catch (Exception e) {
			 throw new IllegalStateException(""Failed to process service-config: "" + serviceFile, e);
		 }
		 finally {
			 if (inputStream != null) {
				 try {
					 inputStream.close();
				 }
				 catch (Exception e) {
					 throw new IllegalStateException(""Failed to close "" + serviceFile, e);
				 }
			 }
		 }
	 }
	 private String extractConfiguredServiceClassName(String currentConfigLine) {
		 int startOfComment = currentConfigLine.indexOf('#');
		 if (startOfComment > -1) {
			 currentConfigLine = currentConfigLine.substring(0, startOfComment);
		 }
		 return currentConfigLine.trim();
	 }
	 private void loadService(String serviceClassName) {
		 Class<T> serviceClass = (Class<T>) loadClass(serviceClassName);
		 if (serviceClass != null && !foundServiceClasses.contains(serviceClass)) {
			 foundServiceClasses.add(serviceClass);
		 }
		 else if (serviceClass == null) {
			 throw new IllegalStateException(serviceClassName + "" couldn't be loaded. "" + ""Please ensure that this class is in the classpath or remove the entry from "" + getConfigFileLocation() + ""."");
		 }
	 }
	 private Class<? extends T> loadClass(String serviceClassName) {
		 Class<?> targetClass = ClassUtil.getClassFromName(serviceClassName);
		 if (targetClass == null) {
			 targetClass = loadClassForName(serviceClassName, currentClassLoader);
			 if (targetClass == null) {
				 return null;
			 }
		 }
		 return targetClass.asSubclass(serviceType);
	 }
	 private static Class<?> loadClassForName(String serviceClassName, ClassLoader classLoader) {
		 if (classLoader == null) {
			 return null;
		 }
		 try {
			 return classLoader.loadClass(serviceClassName);
		 }
		 catch (Exception e) {
			 return loadClassForName(serviceClassName, classLoader.getParent());
		 }
	 }
	 private T createInstance(Class<?> serviceClass) {
		 try {
			 Constructor<?> constructor = serviceClass.getDeclaredConstructor();
			 constructor.setAccessible(true);
			 return (T) constructor.newInstance();
		 }
		 catch (Exception e) {
			 return null;
		 }
	 }
	 public String toString() {
		 return ""Config file: "" + getConfigFileLocation();
	 }
}",1,0,0,0
"public class TestPOCast {
	Random r = new Random();
	final int MAX = 10;
	Tuple dummyTuple = null;
	Map<Object,Object> dummyMap = null;
	DataBag dummyBag = null;
	public void testBooleanToOther() throws IOException {
		 DataBag bag = BagFactory.getInstance().newDefaultBag();
		 for(int i = 0;
		 i < MAX;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple();
			 t.append(r.nextBoolean());
			 bag.add(t);
		 }
		 POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		 LoadFunc load = new TestLoader();
		 op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		 POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		 PhysicalPlan plan = new PhysicalPlan();
		 plan.add(prj);
		 plan.add(op);
		 plan.connect(prj, op);
		 prj.setResultType(DataType.BOOLEAN);
		 POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		 PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Boolean b = (Boolean) t.get(0);
			 Result res = op.getNextBoolean();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Integer i = ((Boolean) t.get(0)) ? Integer.valueOf(1) : Integer.valueOf(0);
			 Result res = op.getNextInteger();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(i, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextInteger();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(i, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Long l = ((Boolean) t.get(0)) ? Long.valueOf(1L) : Long.valueOf(0L);
			 Result res = op.getNextLong();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(l, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextLong();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(l, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Float f = ((Boolean) t.get(0)) ? Float.valueOf(1.0F) : Float.valueOf(0.0F);
			 Result res = op.getNextFloat();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(f, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextFloat();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(f, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Double d = ((Boolean) t.get(0)) ? Double.valueOf(1.0D) : Double.valueOf(0.0D);
			 Result res = op.getNextDouble();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(d, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDouble();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(d, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DateTime dt = null;
			 Result res = op.getNextDateTime();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 String str = ((Boolean)t.get(0)).toString();
			 Result res = op.getNextString();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(str, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextString();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(str, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DataByteArray dba = new DataByteArray(((Boolean)t.get(0)).toString().getBytes());
			 Result res = op.getNextDataByteArray();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dba, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDataByteArray();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dba, res.result);
			 }
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Map map = null;
			 Result res = op.getNextMap();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Result res = op.getNextTuple();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DataBag b = null;
			 Result res = op.getNextDataBag();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	}
	public void testIntegerToOther() throws IOException {
		DataBag bag = BagFactory.getInstance().newDefaultBag();
		for(int i = 0;
		 i < MAX;
		 i++) {
			Tuple t = TupleFactory.getInstance().newTuple();
			t.append(i == 0 ? 0 : r.nextInt());
			bag.add(t);
		}
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		LoadFunc load = new TestLoader();
		op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.INTEGER);
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		 for (Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Boolean b = Boolean.valueOf((Integer) t.get(0) != 0);
			 Result res = op.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Integer i = (Integer) t.get(0);
			Result res = op.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Float f = ((Integer)t.get(0)).floatValue();
			Result res = op.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(f, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(f, res.result);
			}
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Long l = ((Integer)t.get(0)).longValue();
			Result res = op.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(l, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(l, res.result);
			}
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Double d = ((Integer)t.get(0)).doubleValue();
			Result res = op.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(d, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(d, res.result);
			}
		}
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DateTime dt = new DateTime(((Integer)t.get(0)).longValue());
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dt, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dt, res.result);
			 }
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			String str = ((Integer)t.get(0)).toString();
			Result res = op.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataByteArray dba = new DataByteArray(((Integer)t.get(0)).toString().getBytes());
			Result res = op.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(dba, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(dba, res.result);
			}
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	}
	public void testLongToOther() throws IOException {
		DataBag bag = BagFactory.getInstance().newDefaultBag();
		for(int i = 0;
		 i < MAX;
		 i++) {
			Tuple t = TupleFactory.getInstance().newTuple();
			t.append(i == 0 ? 0L : r.nextLong());
			bag.add(t);
		}
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		LoadFunc load = new TestLoader();
		op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.LONG);
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		 for (Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Boolean b = Boolean.valueOf(((Long) t.get(0)) != 0L);
			 Result res = op.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) assertEquals(b, res.result);
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Integer i = ((Long) t.get(0)).intValue();
			Result res = op.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Float f = ((Long)t.get(0)).floatValue();
			Result res = op.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(f, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(f, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Long l = ((Long)t.get(0)).longValue();
			Result res = op.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(l, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(l, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Double d = ((Long)t.get(0)).doubleValue();
			Result res = op.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(d, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(d, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DateTime dt = new DateTime(t.get(0));
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dt, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(dt, res.result);
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			String str = ((Long)t.get(0)).toString();
			Result res = op.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(str, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataByteArray dba = new DataByteArray(((Long)t.get(0)).toString().getBytes());
			Result res = op.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(dba, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(dba, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	}
	public void testFloatToOther() throws IOException {
		DataBag bag = BagFactory.getInstance().newDefaultBag();
		for(int i = 0;
		 i < MAX;
		 i++) {
			Tuple t = TupleFactory.getInstance().newTuple();
			t.append(i == 0 ? 0.0F : r.nextFloat());
			bag.add(t);
		}
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		LoadFunc load = new TestLoader();
		op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.FLOAT);
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Boolean b = Boolean.valueOf(((Float) t.get(0)) != 0.0F);
			 Result res = op.getNextBoolean();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(b, res.result);
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Integer i = ((Float) t.get(0)).intValue();
			Result res = op.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Float f = ((Float)t.get(0)).floatValue();
			Result res = op.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(f, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(f, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Long l = ((Float)t.get(0)).longValue();
			Result res = op.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(l, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(l, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Double d = ((Float)t.get(0)).doubleValue();
			Result res = op.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(d, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(d, res.result);
		}
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DateTime dt = new DateTime(((Float)t.get(0)).longValue());
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dt, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(dt, res.result);
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			String str = ((Float)t.get(0)).toString();
			Result res = op.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(str, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataByteArray dba = new DataByteArray(((Float)t.get(0)).toString().getBytes());
			Result res = op.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(dba, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(dba, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			if(t.get(0) == null) {
				 Float result = (Float) op.getNextFloat().result;
				assertEquals( null, result);
			}
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	}
	public void testDoubleToOther() throws IOException {
		DataBag bag = BagFactory.getInstance().newDefaultBag();
		for(int i = 0;
		 i < MAX;
		 i++) {
			Tuple t = TupleFactory.getInstance().newTuple();
			t.append(i == 0 ? 0.0D : r.nextDouble());
			bag.add(t);
		}
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		LoadFunc load = new TestLoader();
		op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.DOUBLE);
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		 for (Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Boolean b = Boolean.valueOf(((Double) t.get(0)) != 0.0D);
			 Result res = op.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) assertEquals(b, res.result);
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Integer i = ((Double) t.get(0)).intValue();
			Result res = op.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Float f = ((Double)t.get(0)).floatValue();
			Result res = op.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(f, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(f, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Long l = ((Double)t.get(0)).longValue();
			Result res = op.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(l, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(l, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Double d = ((Double)t.get(0)).doubleValue();
			Result res = op.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(d, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(d, res.result);
		}
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DateTime dt = new DateTime(((Double)t.get(0)).longValue());
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dt, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(dt, res.result);
		 }
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			String str = ((Double)t.get(0)).toString();
			Result res = op.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(str, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataByteArray dba = new DataByteArray(((Double)t.get(0)).toString().getBytes());
			Result res = op.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(dba, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(dba, res.result);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	}
	 public void testDateTimeToOther() throws IOException {
		 DataBag bag = BagFactory.getInstance().newDefaultBag();
		 for(int i = 0;
		 i < MAX;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple();
			 t.append(i == 0 ? new DateTime(0L) : new DateTime(r.nextLong()));
			 bag.add(t);
		 }
		 POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		 LoadFunc load = new TestLoader();
		 op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		 POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		 PhysicalPlan plan = new PhysicalPlan();
		 plan.add(prj);
		 plan.add(op);
		 plan.connect(prj, op);
		 prj.setResultType(DataType.DATETIME);
		 POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		 PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		 for (Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Boolean b = null;
			 Result res = op.getNextBoolean();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Integer i = new Long(((DateTime) t.get(0)).getMillis()).intValue();
			 Result res = op.getNextInteger();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(i, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextInteger();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(i, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Float f = new Float(Long.valueOf(((DateTime) t.get(0)).getMillis()).floatValue());
			 Result res = op.getNextFloat();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(f, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextFloat();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(f, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Long l = new Long(((DateTime)t.get(0)).getMillis());
			 Result res = op.getNextLong();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(l, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextLong();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(l, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Double d = new Double(Long.valueOf(((DateTime) t.get(0)).getMillis()).doubleValue());
			 Result res = op.getNextDouble();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(d, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDouble();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(d, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DateTime dt = (DateTime)t.get(0);
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dt, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(dt, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 String str = ((DateTime)t.get(0)).toString();
			 Result res = op.getNextString();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(str, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextString();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(str, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DataByteArray dba = new DataByteArray(((DateTime)t.get(0)).toString().getBytes());
			 Result res = op.getNextDataByteArray();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(dba, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDataByteArray();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(dba, res.result);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Map map = null;
			 Result res = op.getNextMap();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 Result res = op.getNextTuple();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 DataBag b = null;
			 Result res = op.getNextDataBag();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	 }
	public void testStringToOther() throws IOException {
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		LoadFunc load = new TestLoader();
		op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.CHARARRAY);
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		TupleFactory tf = TupleFactory.getInstance();
		 {
			 Tuple t = tf.newTuple();
			 t.append((new Boolean(r.nextBoolean())).toString());
			 plan.attachInput(t);
			 String str = (String) t.get(0);
			 Boolean b = null;
			 if (str.equalsIgnoreCase(""true"")) {
				 b = Boolean.TRUE;
			 }
			 else if (str.equalsIgnoreCase(""false"")) {
				 b = Boolean.FALSE;
			 }
			 Result res = op.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) assertEquals(b, res.result);
			 t = tf.newTuple();
			 t.append(""neither true nor false"");
			 plan.attachInput(t);
			 res = op.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(null, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) assertEquals(null, res.result);
		 }
		{
			Tuple t = tf.newTuple();
			t.append((new Integer(r.nextInt())).toString());
			plan.attachInput(t);
			Integer i = Integer.valueOf(((String) t.get(0)));
			Result res = op.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append((new Float(r.nextFloat())).toString());
			plan.attachInput(t);
			Float i = Float.valueOf(((String) t.get(0)));
			Result res = op.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append((new Long(r.nextLong())).toString());
			plan.attachInput(t);
			Long i = Long.valueOf(((String) t.get(0)));
			Result res = op.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append((new Double(r.nextDouble())).toString());
			plan.attachInput(t);
			Double i = Double.valueOf(((String) t.get(0)));
			Result res = op.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		 {
			 Tuple t = tf.newTuple();
			 t.append((new DateTime(r.nextLong())).toString());
			 plan.attachInput(t);
			 DateTime i = new DateTime(t.get(0));
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(i.getMillis(), ((DateTime) res.result).getMillis());
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(i.getMillis(), ((DateTime) res.result).getMillis());
		 }
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			plan.attachInput(t);
			String str = (String) t.get(0);
			Result res = op.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(str, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			plan.attachInput(t);
			DataByteArray dba = new DataByteArray(((String)t.get(0)).getBytes());
			Result res = op.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(dba, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataByteArray();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(dba, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextMap();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextTuple();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
		 {
			 planToTestBACasts.attachInput(dummyTuple);
			 try{
				 opWithInputTypeAsBA.getNextDataBag();
			 }
			catch (Exception e) {
				 assertEquals(ExecException.class, e.getClass());
			 }
		 }
	}
	public static class TestLoader extends LoadFunc implements LoadCaster{
		 public void bindTo(String fileName, BufferedPositionedInputStream is, long offset, long end) throws IOException {
		 }
		 public Tuple getNext() throws IOException {
			 return null;
		 }
		 public DataBag bytesToBag(byte[] b, ResourceFieldSchema s) throws IOException {
			 return null;
		 }
		 public Boolean bytesToBoolean(byte[] b) throws IOException {
			 DataByteArray dba = new DataByteArray(b);
			 String str = dba.toString();
			 if (str.equalsIgnoreCase(""true"")) {
				 return Boolean.TRUE;
			 }
			 else if (str.equalsIgnoreCase(""false"")) {
				 return Boolean.FALSE;
			 }
			 else {
				 return null;
			 }
		 }
		 public String bytesToCharArray(byte[] b) throws IOException {
			 DataByteArray dba = new DataByteArray(b);
			 return dba.toString();
		 }
		 public Double bytesToDouble(byte[] b) throws IOException {
			 return new Double(Double.valueOf(new DataByteArray(b).toString()));
		 }
		 public Float bytesToFloat(byte[] b) throws IOException {
			 return new Float(Float.valueOf(new DataByteArray(b).toString()));
		 }
		 public Integer bytesToInteger(byte[] b) throws IOException {
			 return new Integer(Integer.valueOf(new DataByteArray(b).toString()));
		 }
		 public Long bytesToLong(byte[] b) throws IOException {
			 return new Long(Long.valueOf(new DataByteArray(b).toString()));
		 }
		 public DateTime bytesToDateTime(byte[] b) throws IOException {
			 return new DateTime(new DataByteArray(b).toString());
		 }
		 public Map<String, Object> bytesToMap(byte[] b, ResourceFieldSchema s) throws IOException {
			 return null;
		 }
		 public Tuple bytesToTuple(byte[] b, ResourceFieldSchema s) throws IOException {
			 return null;
		 }
		 public BigInteger bytesToBigInteger(byte[] b) throws IOException {
			 return new BigInteger(new DataByteArray(b).toString());
		 }
		 public BigDecimal bytesToBigDecimal(byte[] b) throws IOException {
			 return new BigDecimal(new DataByteArray(b).toString());
		 }
		 public byte[] toBytes(DataBag bag) throws IOException {
			 return null;
		 }
		 public byte[] toBytes(String s) throws IOException {
			 return s.getBytes();
		 }
		 public byte[] toBytes(Double d) throws IOException {
			 return d.toString().getBytes();
		 }
		 public byte[] toBytes(Float f) throws IOException {
			 return f.toString().getBytes();
		 }
		 public byte[] toBytes(Integer i) throws IOException {
			 return i.toString().getBytes();
		 }
		 public byte[] toBytes(Long l) throws IOException {
			 return l.toString().getBytes();
		 }
		 public byte[] toBytes(DateTime dt) throws IOException {
			 return dt.toString().getBytes();
		 }
		 public byte[] toBytes(Boolean b) throws IOException {
			 return b.toString().getBytes();
		 }
		 public byte[] toBytes(Map<String, Object> m) throws IOException {
			 return null;
		 }
		 public byte[] toBytes(Tuple t) throws IOException {
			 return null;
		 }
		 public byte[] toBytes(BigInteger bi) throws IOException {
			 return bi.toString().getBytes();
		 }
		 public byte[] toBytes(BigDecimal bd) throws IOException {
			 return bd.toString().getBytes();
		 }
		 public InputFormat getInputFormat() throws IOException {
			 return null;
		 }
		 public LoadCaster getLoadCaster() throws IOException {
			 return this;
		 }
		 public void prepareToRead(RecordReader reader, PigSplit split) throws IOException {
		 }
		 public String relativeToAbsolutePath(String location, Path curDir) throws IOException {
			 return null;
		 }
		 public void setLocation(String location, Job job) throws IOException {
		 }
	}
	public void testByteArrayToOther() throws IOException {
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		LoadFunc load = new TestLoader();
		op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.BYTEARRAY);
		TupleFactory tf = TupleFactory.getInstance();
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		 {
			 Tuple t = tf.newTuple();
			 t.append(new DataByteArray((new Boolean(r.nextBoolean())).toString() .getBytes()));
			 plan.attachInput(t);
			 String str = ((DataByteArray) t.get(0)).toString();
			 Boolean b = null;
			 if (str.equalsIgnoreCase(""true"")) {
				 b = Boolean.TRUE;
			 }
			 else if (str.equalsIgnoreCase(""false"")) {
				 b = Boolean.FALSE;
			 }
			 Result res = op.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) assertEquals(b, res.result);
		 }
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray((new Integer(r.nextInt())).toString().getBytes()));
			plan.attachInput(t);
			Integer i = Integer.valueOf(((DataByteArray) t.get(0)).toString());
			Result res = op.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray((new Float(r.nextFloat())).toString().getBytes()));
			plan.attachInput(t);
			Float i = Float.valueOf(((DataByteArray) t.get(0)).toString());
			Result res = op.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray((new Long(r.nextLong())).toString().getBytes()));
			plan.attachInput(t);
			Long i = Long.valueOf(((DataByteArray) t.get(0)).toString());
			Result res = op.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray((new Double(r.nextDouble())).toString().getBytes()));
			plan.attachInput(t);
			Double i = Double.valueOf(((DataByteArray) t.get(0)).toString());
			Result res = op.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(i, res.result);
		}
		{
			 Tuple t = tf.newTuple();
			 t.append(new DataByteArray((new DateTime(r.nextLong())).toString().getBytes()));
			 plan.attachInput(t);
			 DateTime i = new DateTime(((DataByteArray) t.get(0)).toString());
			 Result res = op.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(i, res.result);
			 }
			 planToTestBACasts.attachInput(t);
			 res = opWithInputTypeAsBA.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) assertEquals(i, res.result);
		 }
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray(GenRandomData.genRandString(r).getBytes()));
			plan.attachInput(t);
			String str = ((DataByteArray) t.get(0)).toString();
			Result res = op.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(str, res.result);
			}
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK)assertEquals(str, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray(GenRandomData.genRandString(r).getBytes()));
			plan.attachInput(t);
			DataByteArray dba = (DataByteArray) t.get(0);
			Result res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataByteArray();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray(GenRandomData.genRandString(r).getBytes()));
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			assertEquals(null, res.result);
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextMap();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			assertEquals(null, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray(GenRandomData.genRandString(r).getBytes()));
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			assertEquals(null, res.result);
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextTuple();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			assertEquals(null, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray(GenRandomData.genRandString(r).getBytes()));
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			assertEquals(null, res.result);
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataBag();
			assertEquals(POStatus.STATUS_OK, res.returnStatus);
			assertEquals(null, res.result);
		}
	}
	private PhysicalPlan constructPlan(POCast op) throws IOException {
		 LoadFunc load = new TestLoader();
		 op.setFuncSpec(new FuncSpec(load.getClass().getName()));
		 POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		 PhysicalPlan plan = new PhysicalPlan();
		 plan.add(prj);
		 plan.add(op);
		 plan.connect(prj, op);
		 prj.setResultType(DataType.BYTEARRAY);
		 return plan;
	}
	public void testByteArrayToOtherNoCast() throws IOException {
		 POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		 PhysicalPlan plan = constructPlan(op);
		 TupleFactory tf = TupleFactory.getInstance();
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 Boolean input = new Boolean(r.nextBoolean());
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextBoolean();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
			 t = tf.newTuple();
			 t.append(""neither true nor false"");
			 plan.attachInput(t);
			 res = newOp.getNextBoolean();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(null, res.result);
			 }
		 }
		 {
			 Tuple t = tf.newTuple();
			 Integer input = new Integer(r.nextInt());
			 t.append(input);
			 plan.attachInput(t);
			 Result res = op.getNextInteger();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 Float input = new Float(r.nextFloat());
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextFloat();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 Long input = new Long(r.nextLong());
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextLong();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 Double input = new Double(r.nextDouble());
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextDouble();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 DateTime input = new DateTime(r.nextLong());
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextDateTime();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 Tuple input = GenRandomData.genRandSmallTuple(""test"", 1);
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextTuple();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 DataBag input = GenRandomData.genRandSmallTupDataBag(r, 10, 100);
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextDataBag();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
		 {
			 POCast newOp = new POCast(new OperatorKey("""", r.nextLong()), -1);
			 plan = constructPlan(newOp);
			 Tuple t = tf.newTuple();
			 Map<String, Object> input = new HashMap<String, Object>();
			 input.put(""key1"", ""value1"");
			 input.put(""key2"", ""value2"");
			 t.append(input);
			 plan.attachInput(t);
			 Result res = newOp.getNextMap();
			 if(res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(input, res.result);
			 }
		 }
	}
	public void testTupleToOther() throws IOException, ParserException {
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		op.setFuncSpec(new FuncSpec(PigStorage.class.getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.TUPLE);
		TupleFactory tf = TupleFactory.getInstance();
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			Result res = op.getNextTuple();
			assertEquals(t, res.result);
			planToTestBACasts.attachInput(tNew);
			res = opWithInputTypeAsBA.getNextTuple();
			assertEquals(t, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			Integer i = null;
			Result res = op.getNextInteger();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			Long i = null;
			Result res = op.getNextLong();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			Float i = null;
			Result res = op.getNextFloat();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			Double i = null;
			Result res = op.getNextDouble();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			 Tuple t = tf.newTuple();
			 t.append(GenRandomData.genRandString(r));
			 Tuple tNew = tf.newTuple();
			 tNew.append(t);
			 plan.attachInput(tNew);
			 DateTime dt = null;
			 Result res = op.getNextDateTime();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			String i = null;
			Result res = op.getNextString();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandString(r));
			Tuple tNew = tf.newTuple();
			tNew.append(t);
			plan.attachInput(tNew);
			DataByteArray i = null;
			Result res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
			op.setFuncSpec(new FuncSpec(BinStorage.class.getName()));
			plan.attachInput(tNew);
			res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 Tuple t = tf.newTuple();
			 Tuple wrappedTuple = tf.newTuple();
			 wrappedTuple.append(GenRandomData.genRandString(r));
			 wrappedTuple.append(GenRandomData.genRandString(r));
			 t.append(wrappedTuple);
			 Schema s = Utils.getSchemaFromString(""t:tuple(a:chararray)"");
			 op.setFieldSchema(new ResourceSchema.ResourceFieldSchema(s.getField(0)));
			 plan.attachInput(t);
			 Tuple tup = null;
			 Result res = op.getNextTuple();
			 assertTrue(res.result==null);
		 }
		 {
			 Tuple t = tf.newTuple();
			 Tuple wrappedTuple = tf.newTuple();
			 wrappedTuple.append(GenRandomData.genRandString(r));
			 wrappedTuple.append(GenRandomData.genRandString(r));
			 t.append(wrappedTuple);
			 Schema s = Utils.getSchemaFromString(""t:tuple(a:chararray, b:chararray)"");
			 op.setFieldSchema(new ResourceSchema.ResourceFieldSchema(s.getField(0)));
			 plan.attachInput(t);
			 Tuple tup = null;
			 Result res = op.getNextTuple();
			 verifyResult(res, POStatus.STATUS_OK, wrappedTuple);
		 }
		 {
			 Tuple t = tf.newTuple();
			 Tuple wrappedTuple = tf.newTuple();
			 wrappedTuple.append(GenRandomData.genRandString(r));
			 wrappedTuple.append(null);
			 t.append(wrappedTuple);
			 Schema s = Utils.getSchemaFromString(""t:tuple(a:chararray, b:chararray)"");
			 op.setFieldSchema(new ResourceSchema.ResourceFieldSchema(s.getField(0)));
			 plan.attachInput(t);
			 Tuple tup = null;
			 Result res = op.getNextTuple();
			 verifyResult(res, POStatus.STATUS_OK, wrappedTuple);
		 }
	}
	private void verifyResult(Result res, byte status, Object result) {
		 assertEquals(""result status"", status, res.returnStatus);
		 assertEquals(""result value"", result, res.result);
	 }
	public void testBagToOther() throws IOException, ParserException {
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		op.setFuncSpec(new FuncSpec(PigStorage.class.getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.BAG);
		TupleFactory tf = TupleFactory.getInstance();
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			Map map = null;
			Result res = op.getNextMap();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			DataBag b = (DataBag) t.get(0);
			Result res = op.getNextDataBag();
			assertEquals(b, res.result);
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextDataBag();
			assertEquals(b, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			Integer i = null;
			Result res = op.getNextInteger();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			Long i = null;
			Result res = op.getNextLong();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			Float i = null;
			Result res = op.getNextFloat();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			Double i = null;
			Result res = op.getNextDouble();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 Tuple t = tf.newTuple();
			 t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			 plan.attachInput(t);
			 DateTime dt = null;
			 Result res = op.getNextDateTime();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			String i = null;
			Result res = op.getNextString();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandSmallTupDataBag(r, 1, 100));
			plan.attachInput(t);
			DataByteArray i = null;
			Result res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
			op.setFuncSpec(new FuncSpec(BinStorage.class.getName()));
			plan.attachInput(t);
			res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 Tuple t = tf.newTuple();
			 t.append(GenRandomData.genRandSmallTupDataBagWithNulls(r, 20, 100));
			 Schema s = Utils.getSchemaFromString(""b:bag{
			t:tuple(a:chararray, b:float)}
			"");
			 op.setFieldSchema(new ResourceSchema.ResourceFieldSchema(s.getField(0)));
			 plan.attachInput(t);
			 DataBag db = null;
			 Result res = op.getNextDataBag();
			 Iterator<Tuple> expectedBagIterator = ((DataBag)(t.get(0))).iterator();
			 Iterator<Tuple> convertedBagIterator = ((DataBag)(res.result)).iterator();
			 while(expectedBagIterator.hasNext()) {
				 Tuple expectedBagTuple = expectedBagIterator.next();
				 Tuple convertedBagTuple = convertedBagIterator.next();
				 if(expectedBagTuple.get(0) != null){
					 assertTrue(convertedBagTuple.get(0) instanceof String);
					 assertTrue(expectedBagTuple.get(0).equals(convertedBagTuple.get(0)));
				 }
				 if(expectedBagTuple.get(1) != null){
					 assertTrue(convertedBagTuple.get(1) instanceof Float);
					 assertTrue(((Float)(expectedBagTuple.get(1))).floatValue()==(Float)(convertedBagTuple.get(1)));
				 }
			 }
		 }
		 {
			 Tuple t = tf.newTuple();
			 t.append(GenRandomData.genRandSmallTupDataBagWithNulls(r, 20, 100));
			 Schema s = Utils.getSchemaFromString(""b:bag{
			}
			"");
			 op.setFieldSchema(new ResourceSchema.ResourceFieldSchema(s.getField(0)));
			 plan.attachInput(t);
			 DataBag db = null;
			 Result res = op.getNextDataBag();
			 Iterator<Tuple> expectedBagIterator = ((DataBag)(t.get(0))).iterator();
			 Iterator<Tuple> convertedBagIterator = ((DataBag)(res.result)).iterator();
			 while(expectedBagIterator.hasNext()) {
				 Tuple expectedBagTuple = expectedBagIterator.next();
				 Tuple convertedBagTuple = convertedBagIterator.next();
				 if(expectedBagTuple.get(0) != null){
					 assertTrue(convertedBagTuple.get(0) instanceof String);
					 assertTrue(expectedBagTuple.get(0).equals(convertedBagTuple.get(0)));
				 }
				 if(expectedBagTuple.get(1) != null){
					 assertTrue(convertedBagTuple.get(1) instanceof Integer);
					 assertTrue(((Integer)(expectedBagTuple.get(1)))==(Integer)(convertedBagTuple.get(1)));
				 }
			 }
		 }
	}
	public void testMapToOther() throws IOException {
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		op.setFuncSpec(new FuncSpec(PigStorage.class.getName()));
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		prj.setResultType(DataType.MAP);
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		TupleFactory tf = TupleFactory.getInstance();
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			plan.attachInput(t);
			Map map = (Map) t.get(0);
			Result res = op.getNextMap();
			assertEquals(map, res.result);
			planToTestBACasts.attachInput(t);
			res = opWithInputTypeAsBA.getNextMap();
			assertEquals(map, res.result);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			plan.attachInput(t);
			Result res = op.getNextTuple();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			plan.attachInput(t);
			DataBag b = null;
			Result res = op.getNextDataBag();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			Integer i = null;
			Result res = op.getNextInteger();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			Long i = null;
			Result res = op.getNextLong();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			Float i = null;
			Result res = op.getNextFloat();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			Double i = null;
			Result res = op.getNextDouble();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		 {
			 Tuple t = tf.newTuple();
			 t.append(GenRandomData.genRandMap(r, 10));
			 DateTime dt = null;
			 Result res = op.getNextDateTime();
			 assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		 }
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			String i = null;
			Result res = op.getNextString();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
		{
			Tuple t = tf.newTuple();
			t.append(GenRandomData.genRandMap(r, 10));
			plan.attachInput(t);
			DataByteArray i = null;
			Result res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
			op.setFuncSpec(new FuncSpec(BinStorage.class.getName()));
			plan.attachInput(t);
			res = op.getNextDataByteArray();
			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
		}
	}
	public void testNullToOther() throws PlanException, ExecException {
		DataBag bag = BagFactory.getInstance().newDefaultBag();
		for(int i = 0;
		 i < MAX;
		 i++) {
			Tuple t = TupleFactory.getInstance().newTuple();
			t.append(r.nextInt());
			bag.add(t);
			if(r.nextInt(3) % 3 == 0) {
				t = TupleFactory.getInstance().newTuple();
				t.append(null);
				bag.add(t);
			}
		}
		POCast op = new POCast(new OperatorKey("""", r.nextLong()), -1);
		POProject prj = new POProject(new OperatorKey("""", r.nextLong()), -1, 0);
		PhysicalPlan plan = new PhysicalPlan();
		plan.add(prj);
		plan.add(op);
		plan.connect(prj, op);
		 prj.setResultType(DataType.BOOLEAN);
		 for (Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 if (t.get(0) == null) {
				 Boolean result = (Boolean) op.getNextBoolean().result;
				 assertEquals(null, result);
			 }
		 }
		 prj.setResultType(DataType.INTEGER);
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			if(t.get(0) == null) {
				Integer result = (Integer)op.getNextInteger().result;
				assertEquals( null, result);
			}
		}
		prj.setResultType(DataType.FLOAT);
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			if(t.get(0) == null) {
				Integer result = (Integer)op.getNextInteger().result;
				assertEquals( null, result);
			}
		}
		prj.setResultType(DataType.DOUBLE);
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			if(t.get(0) == null) {
				Double result = (Double) op.getNextDouble().result;
				assertEquals(null, result);
			}
		}
		 prj.setResultType(DataType.DATETIME);
		 for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			 Tuple t = it.next();
			 plan.attachInput(t);
			 if(t.get(0) == null) {
				 DateTime result = (DateTime)op.getNextDateTime().result;
				 assertEquals( null, result);
			 }
		 }
		prj.setResultType(DataType.CHARARRAY);
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			plan.attachInput(t);
			if(t.get(0) == null) {
				String result = (String)op.getNextString().result;
				assertEquals( null, result);
			}
		}
		prj.setResultType(DataType.BYTEARRAY);
		TupleFactory tf = TupleFactory.getInstance();
		{
			Tuple t = tf.newTuple();
			t.append(new DataByteArray((new Integer(r.nextInt())).toString().getBytes()));
			plan.attachInput(t);
			if(t.get(0) == null) {
				DataByteArray result = (DataByteArray) op.getNextString().result;
				assertEquals(null, result);
			}
		}
	}
	public void testValueTypesChanged() throws IOException {
		POCast opWithInputTypeAsBA = new POCast(new OperatorKey("""", r.nextLong()), -1);
		PhysicalPlan planToTestBACasts = constructPlan(opWithInputTypeAsBA);
		DataBag bag = BagFactory.getInstance().newDefaultBag();
		for(int i = 0;
		 i < MAX;
		 i++) {
			Tuple t = TupleFactory.getInstance().newTuple();
			if (i % 6 == 0) t.append(r.nextBoolean());
			if(i % 6 == 1)t.append(r.nextInt());
			if(i % 6 == 2)t.append(r.nextLong());
			if(i % 6 == 3)t.append(r.nextDouble());
			if(i % 6 == 4)t.append(r.nextFloat());
			if(i % 6 == 5) t.append(r.nextLong());
			bag.add(t);
		}
		for(Iterator<Tuple> it = bag.iterator();
		 it.hasNext();
		 ) {
			Tuple t = it.next();
			planToTestBACasts.attachInput(t);
			Object toCast = t.get(0);
			 Boolean b = DataType.toBoolean(toCast);
			 Result res = opWithInputTypeAsBA.getNextBoolean();
			 if (res.returnStatus == POStatus.STATUS_OK) {
				 assertEquals(b, res.result);
			 }
			Integer i = DataType.toInteger(toCast);
			res = opWithInputTypeAsBA.getNextInteger();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(i, res.result);
			}
			Long l = DataType.toLong(toCast);
			res = opWithInputTypeAsBA.getNextLong();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(l, res.result);
			}
			Float f = DataType.toFloat(toCast);
			res = opWithInputTypeAsBA.getNextFloat();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(f, res.result);
			}
			Double d = DataType.toDouble(toCast);
			res = opWithInputTypeAsBA.getNextDouble();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(d, res.result);
			}
			if (!(toCast instanceof Boolean)) {
				 DateTime dt = DataType.toDateTime(toCast);
				 res = opWithInputTypeAsBA.getNextDateTime();
				 if(res.returnStatus == POStatus.STATUS_OK) {
					 assertEquals(dt, res.result);
				 }
			}
			String s = DataType.toString(toCast);
			res = opWithInputTypeAsBA.getNextString();
			if(res.returnStatus == POStatus.STATUS_OK) {
				assertEquals(s, res.result);
			}
		}
	}
}",1,0,0,0
"public abstract class AbstractRequestCycleProcessor implements IRequestCycleProcessor{
	private IRequestCodingStrategy requestCodingStrategy;
	public AbstractRequestCycleProcessor(){
	}
	public IRequestCodingStrategy getRequestCodingStrategy(){
		if (requestCodingStrategy == null){
			requestCodingStrategy = newRequestCodingStrategy();
		}
		return requestCodingStrategy;
	}
	public void processEvents(RequestCycle requestCycle){
		IRequestTarget target = requestCycle.getRequestTarget();
		if (target instanceof IEventProcessor){
			Application.get().logEventTarget(target);
			((IEventProcessor)target).processEvents(requestCycle);
		}
	}
	public void respond(RequestCycle requestCycle){
		IRequestTarget requestTarget = requestCycle.getRequestTarget();
		if (requestTarget != null){
			Application.get().logResponseTarget(requestTarget);
			requestTarget.respond(requestCycle);
		}
	}
	public void respond(RuntimeException e, RequestCycle requestCycle){
		final Application application = Application.get();
		final IExceptionSettings settings = application.getExceptionSettings();
		final Page responsePage = requestCycle.getResponsePage();
		Page override = onRuntimeException(responsePage, e);
		if (override != null){
			throw new RestartResponseException(override);
		}
		else if (e instanceof AuthorizationException){
			Class<? extends Page> accessDeniedPageClass = application.getApplicationSettings().getAccessDeniedPage();
			throw new RestartResponseAtInterceptPageException(accessDeniedPageClass);
		}
		else if (e instanceof PageExpiredException){
			Class<? extends Page> pageExpiredErrorPageClass = application.getApplicationSettings().getPageExpiredErrorPage();
			boolean mounted = isPageMounted(pageExpiredErrorPageClass);
			RequestCycle.get().setRedirect(mounted);
			throw new RestartResponseException(pageExpiredErrorPageClass);
		}
		else if (settings.getUnexpectedExceptionDisplay() != IExceptionSettings.SHOW_NO_EXCEPTION_PAGE){
			if (!RequestContext.get().isPortletRequest()){
				requestCycle.setRedirect(false);
			}
			Class<? extends Page> internalErrorPageClass = application.getApplicationSettings().getInternalErrorPage();
			Class<? extends Page> responseClass = responsePage != null ? responsePage.getClass(): null;
			if (responseClass != internalErrorPageClass &&settings.getUnexpectedExceptionDisplay() == IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE){
				throw new RestartResponseException(internalErrorPageClass);
			}
			else if (responseClass != ExceptionErrorPage.class){
				throw new RestartResponseException(new ExceptionErrorPage(e, responsePage));
			}
			else{
				throw new WicketRuntimeException(""Internal Error: Could not render error page "" +internalErrorPageClass, e);
			}
		}
		else if (requestCycle.getResponse() instanceof WebResponse){
			requestCycle.setRedirect(false);
			((WebResponse)requestCycle.getResponse()).getHttpServletResponse().setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}
	private boolean isPageMounted(Class<? extends Page> pageClass){
		RequestCycle.get();
		CharSequence path = getRequestCodingStrategy().pathForTarget(new BookmarkablePageRequestTarget(pageClass));
		return path != null;
	}
	protected abstract IRequestCodingStrategy newRequestCodingStrategy();
	protected Page onRuntimeException(final Page page, final RuntimeException e){
		return RequestCycle.get().onRuntimeException(page, e);
	}
	protected IRequestTarget resolveBookmarkablePage(final RequestCycle requestCycle,final RequestParameters requestParameters){
		String bookmarkablePageClass = requestParameters.getBookmarkablePageClass();
		Session session = requestCycle.getSession();
		Class<? extends Page> pageClass;
		try{
			pageClass = (Class<? extends Page>)session.getClassResolver().resolveClass(bookmarkablePageClass);
		}
		catch (ClassNotFoundException e){
			return new WebErrorCodeResponseTarget(HttpServletResponse.SC_NOT_FOUND,""Unable to load Bookmarkable Page"");
		}
		try{
			PageParameters params = new PageParameters(requestParameters.getParameters());
			if (requestParameters.getComponentPath() != null &&requestParameters.getInterfaceName() != null){
				final String componentPath = requestParameters.getComponentPath();
				final Page page = session.getPage(requestParameters.getPageMapName(),componentPath, requestParameters.getVersionNumber());
				if (page != null && page.getClass() == pageClass){
					return resolveListenerInterfaceTarget(requestCycle, page, componentPath,requestParameters.getInterfaceName(), requestParameters);
				}
				else{
					return new BookmarkableListenerInterfaceRequestTarget(requestParameters.getPageMapName(), pageClass, params,requestParameters.getComponentPath(), requestParameters.getInterfaceName(),requestParameters.getVersionNumber());
				}
			}
			else{
				return new BookmarkablePageRequestTarget(requestParameters.getPageMapName(),pageClass, params);
			}
		}
		catch (RuntimeException e){
			throw new WicketRuntimeException(""Unable to instantiate Page class: "" +bookmarkablePageClass + "". See below for details."", e);
		}
	}
	protected IRequestTarget resolveExternalResource(RequestCycle requestCycle){
		String url = requestCycle.getRequest().getURL();
		if ((url.length() > 0 && url.charAt(0) != '/') || url.length() == 0){
			url = '/' + url;
		}
		return new WebExternalResourceRequestTarget(url);
	}
	protected IRequestTarget resolveHomePageTarget(final RequestCycle requestCycle,final RequestParameters requestParameters){
		Session session = requestCycle.getSession();
		Application application = session.getApplication();
		try{
			Class<? extends Page> homePageClass = application.getHomePage();
			PageParameters parameters = new PageParameters(requestParameters.getParameters());
			BookmarkablePageRequestTarget homepageTarget = new BookmarkablePageRequestTarget(homePageClass, parameters);
			IRequestCodingStrategy requestCodingStrategy = requestCycle.getProcessor().getRequestCodingStrategy();
			CharSequence path = requestCodingStrategy.pathForTarget(homepageTarget);
			if (path != null){
				requestCycle.setRedirect(true);
			}
			return homepageTarget;
		}
		catch (MarkupException e){
			throw e;
		}
		catch (WicketRuntimeException e){
			throw new WicketRuntimeException(""Could not create home page"", e);
		}
	}
	protected IRequestTarget resolveListenerInterfaceTarget(final RequestCycle requestCycle,final Page page, final String componentPath, final String interfaceName,final RequestParameters requestParameters){
		if (page == null){
			throw new IllegalArgumentException(""page must not be null"");
		}
		if (interfaceName == null){
			throw new IllegalArgumentException(""interfaceName must not be null"");
		}
		if (interfaceName.equals(IRedirectListener.INTERFACE.getName())){
			return new RedirectPageRequestTarget(page);
		}
		else if (interfaceName.equals(INewBrowserWindowListener.INTERFACE.getName())){
			return INewBrowserWindowListener.INTERFACE.newRequestTarget(page, page,INewBrowserWindowListener.INTERFACE, requestParameters);
		}
		else{
			final RequestListenerInterface listener = RequestListenerInterface.forName(interfaceName);
			if (listener == null){
				throw new WicketRuntimeException(""Attempt to access unknown request listener interface "" + interfaceName);
			}
			Component component;
			final String pageRelativeComponentPath = Strings.afterFirstPathComponent(componentPath,Component.PATH_SEPARATOR);
			if (Strings.isEmpty(pageRelativeComponentPath)){
				component = page;
			}
			else{
				component = page.get(pageRelativeComponentPath);
			}
			if (component == null){
				throw new WicketRuntimeException(""component "" + pageRelativeComponentPath +"" not found on page "" + page.getClass().getName() + ""[id = "" +page.getNumericId() + ""], listener interface = "" + listener);
			}
			if (!component.isEnableAllowed()){
				throw new UnauthorizedActionException(component, Component.ENABLE);
			}
			return listener.newRequestTarget(page, component, listener, requestParameters);
		}
	}
	protected IRequestTarget resolveRenderedPage(final RequestCycle requestCycle,final RequestParameters requestParameters){
		final String componentPath = requestParameters.getComponentPath();
		final Session session = requestCycle.getSession();
		final Page page = session.getPage(requestParameters.getPageMapName(), componentPath,requestParameters.getVersionNumber());
		if (page != null){
			requestCycle.getRequest().setPage(page);
			final String interfaceName = requestParameters.getInterfaceName();
			if (interfaceName != null){
				return resolveListenerInterfaceTarget(requestCycle, page, componentPath,interfaceName, requestParameters);
			}
			else{
				return new PageRequestTarget(page);
			}
		}
		return null;
	}
	protected IRequestTarget resolveSharedResource(final RequestCycle requestCycle,final RequestParameters requestParameters){
		return new SharedResourceRequestTarget(requestParameters);
	}
}",0,0,0,0
"protected void paintIndeterminate(Graphics g, JComponent c) {
	Insets b = progressBar.getInsets();
	 int barRectWidth = progressBar.getWidth() - (b.right + b.left);
	int barRectHeight = progressBar.getHeight() - (b.top + b.bottom);
	if (barRectWidth <= 0 || barRectHeight <= 0) {
		return;
	}
	Graphics2D g2 = (Graphics2D) g;
	boxRect = getBox(boxRect);
	if (boxRect != null) {
		g2.setPaint(ColorResource.getSelectionColor());
		g2.fillRect(boxRect.x, boxRect.y, boxRect.width, boxRect.height);
	}
}",0,0,0,0
"public Object doExecute() throws Exception {
	 Group group = groupManager.findGroupByName(groupName);
	 if (group == null) {
		 System.err.println(""Cluster group "" + groupName + "" doesn't exist"");
		 return null;
	 }
	 CellarSupport support = new CellarSupport();
	 support.setClusterManager(clusterManager);
	 support.setGroupManager(groupManager);
	 support.setConfigurationAdmin(configurationAdmin);
	 if (!in && !out) {
		 in = true;
		 out = true;
	 }
	 if (!whitelist && !blacklist) {
		 whitelist = true;
		 blacklist = true;
	 }
	 if (pid == null || pid.isEmpty()) {
		 if (in) {
			 System.out.println(""INBOUND:"");
			 if (whitelist) {
				 System.out.print(""\twhitelist: "");
				 Set<String> list = support.getListEntries(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.INBOUND);
				 System.out.println(list.toString());
			 }
			 if (blacklist) {
				 System.out.print(""\tblacklist: "");
				 Set<String> list = support.getListEntries(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.INBOUND);
				 System.out.println(list.toString());
			 }
		 }
		 if (out) {
			 System.out.println(""OUTBOUND:"");
			 if (whitelist) {
				 System.out.print(""\twhitelist: "");
				 Set<String> list = support.getListEntries(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.OUTBOUND);
				 System.out.println(list.toString());
			 }
			 if (blacklist) {
				 System.out.print(""\tblacklist: "");
				 Set<String> list = support.getListEntries(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.OUTBOUND);
				 System.out.println(list.toString());
			 }
		 }
	 }
	 else {
		 System.out.println(""Updating blocking policy for "" + pid);
		 if (in) {
			 if (whitelist) {
				 System.out.println(""\tinbound whitelist ..."");
				 support.switchListEntry(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.INBOUND, pid);
			 }
			 if (blacklist) {
				 System.out.println(""\tinbound blacklist ..."");
				 support.switchListEntry(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.INBOUND, pid);
			 }
		 }
		 if (out) {
			 if (whitelist) {
				 System.out.println(""\toutbound whitelist ..."");
				 support.switchListEntry(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.OUTBOUND, pid);
			 }
			 if (blacklist) {
				 System.out.println(""\toutbound blacklist ..."");
				 support.switchListEntry(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.OUTBOUND, pid);
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public boolean equals(Object obj) {
	 if (this == obj) {
		 return true;
	 }
	 if (!super.equals(obj)) {
		 return false;
	 }
	 if (getClass() != obj.getClass()) {
		 return false;
	 }
	 ContextResourceLink other = (ContextResourceLink) obj;
	 if (factory == null) {
		 if (other.factory != null) {
			 return false;
		 }
	 }
	 else if (!factory.equals(other.factory)) {
		 return false;
	 }
	 if (global == null) {
		 if (other.global != null) {
			 return false;
		 }
	 }
	 else if (!global.equals(other.global)) {
		 return false;
	 }
	 return true;
 }",0,0,1,0
"public Properties getProperties() {
	 if (isReference()) {
		 return getRef().getProperties();
	 }
	 dieOnCircularReference();
	 Hashtable props = getEffectiveProperties();
	 Set names = getPropertyNames(props);
	 FileNameMapper m = null;
	 Mapper myMapper = getMapper();
	 if (myMapper != null) {
		 m = myMapper.getImplementation();
	 }
	 Properties properties = new Properties();
	 for (Iterator iter = names.iterator();
	 iter.hasNext();
	) {
		 String name = (String) iter.next();
		 String value = (String) props.get(name);
		 if (value != null) {
			 if (m != null) {
				 String[] newname = m.mapFileName(name);
				 if (newname != null) {
					 name = newname[0];
				 }
			 }
			 properties.setProperty(name, value);
		 }
	 }
	 return properties;
 }",0,0,0,0
"private static class registerDataProduct_resultStandardSchemeFactory implements SchemeFactory {
	 public registerDataProduct_resultStandardScheme getScheme() {
		 return new registerDataProduct_resultStandardScheme();
	 }
 }",0,0,0,0
"public void addAttribute( String uri, String localName, String rawName, String type, String value, boolean XSLAttribute);",0,0,0,1
"public Method(int access_flags, int name_index, int descriptor_index, int attributes_count, Attribute[] attributes);",0,0,0,1
"public class RepositoryImpl extends AbstractRepository implements javax.jcr.Repository, JackrabbitRepository, SessionListener, WorkspaceListener {
	 private static Logger log = LoggerFactory.getLogger(RepositoryImpl.class);
	 public static final NodeId ROOT_NODE_ID = NodeId.valueOf(""cafebabe-cafe-babe-cafe-babecafebabe"");
	 public static final NodeId SYSTEM_ROOT_NODE_ID = NodeId.valueOf(""deadbeef-cafe-babe-cafe-babecafebabe"");
	 public static final NodeId VERSION_STORAGE_NODE_ID = NodeId.valueOf(""deadbeef-face-babe-cafe-babecafebabe"");
	 public static final NodeId ACTIVITIES_NODE_ID = NodeId.valueOf(""deadbeef-face-babe-ac71-babecafebabe"");
	 public static final NodeId CONFIGURATIONS_NODE_ID = NodeId.valueOf(""deadbeef-face-babe-c04f-babecafebabe"");
	 public static final NodeId NODETYPES_NODE_ID = NodeId.valueOf(""deadbeef-cafe-cafe-cafe-babecafebabe"");
	 private static final String PROPERTIES_RESOURCE = ""repository.properties"";
	 public static final String JACKRABBIT_CLUSTER_ID = ""jackrabbit.cluster.id"";
	 private final Map<String, DescriptorValue> repDescriptors = new HashMap<String, DescriptorValue>();
	 protected final RepositoryContext context = new RepositoryContext(this);
	 private final VirtualNodeTypeStateManager virtNTMgr;
	 private JackrabbitSecurityManager securityMgr;
	 private SearchManager systemSearchMgr;
	 protected final RepositoryConfig repConfig;
	 protected NodeIdFactory nodeIdFactory;
	 private final DelegatingObservationDispatcher delegatingDispatcher = new DelegatingObservationDispatcher();
	 private final HashMap<String, WorkspaceInfo> wspInfos = new HashMap<String, WorkspaceInfo>();
	 private final Map<Session, Session> activeSessions = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);
	 private boolean disposed;
	 private RepositoryLockMechanism repLock;
	 private final ReadWriteLock shutdownLock = new WriterPreferenceReadWriteLock();
	 private final CacheManager cacheMgr = new CacheManager();
	 private WorkspaceEventChannel createWorkspaceEventChannel;
	 protected RepositoryImpl(RepositoryConfig repConfig) throws RepositoryException {
		 repLock = repConfig.getRepositoryLockMechanism();
		 repLock.init(repConfig.getHomeDir());
		 repLock.acquire();
		 long t0 = System.currentTimeMillis();
		 log.info(""Starting repository..."");
		 boolean succeeded = false;
		 try {
			 this.repConfig = repConfig;
			 context.setFileSystem(repConfig.getFileSystem());
			 context.setRootNodeId(loadRootNodeId());
			 initRepositoryDescriptors();
			 context.setNamespaceRegistry(createNamespaceRegistry());
			 context.setNodeTypeRegistry(createNodeTypeRegistry());
			 context.setPrivilegeRegistry(new PrivilegeRegistry(context.getNamespaceRegistry(), context.getFileSystem()));
			 context.setItemStateCacheFactory( new ManagedMLRUItemStateCacheFactory(cacheMgr));
			 DataStore dataStore = repConfig.getDataStore();
			 if (dataStore != null) {
				 context.setDataStore(dataStore);
			 }
			 nodeIdFactory = new NodeIdFactory(repConfig.getHomeDir());
			 nodeIdFactory.open();
			 context.setNodeIdFactory(nodeIdFactory);
			 context.setWorkspaceManager(new WorkspaceManager(this));
			 for (WorkspaceConfig config : repConfig.getWorkspaceConfigs()) {
				 WorkspaceInfo info = createWorkspaceInfo(config);
				 wspInfos.put(config.getName(), info);
			 }
			 ClusterNode clusterNode = null;
			 if (repConfig.getClusterConfig() != null) {
				 clusterNode = createClusterNode();
				 context.setClusterNode(clusterNode);
				 context.getNamespaceRegistry().setEventChannel(clusterNode);
				 context.getNodeTypeRegistry().setEventChannel(clusterNode);
				 context.getPrivilegeRegistry().setEventChannel(clusterNode);
				 createWorkspaceEventChannel = clusterNode;
				 clusterNode.setListener(this);
			 }
			 InternalVersionManagerImpl vMgr = createVersionManager( repConfig.getVersioningConfig(), delegatingDispatcher);
			 context.setInternalVersionManager(vMgr);
			 if (clusterNode != null) {
				 vMgr.setEventChannel(clusterNode.createUpdateChannel(null));
			 }
			 virtNTMgr = new VirtualNodeTypeStateManager( context.getNodeTypeRegistry(), delegatingDispatcher, NODETYPES_NODE_ID, SYSTEM_ROOT_NODE_ID);
			 initStartupWorkspaces();
			 getSystemSearchManager(repConfig.getDefaultWorkspaceName());
			 initSecurityManager();
			 virtNTMgr.setSession(getSystemSession(repConfig.getDefaultWorkspaceName()));
			 if (clusterNode != null) {
				 setDescriptor(JACKRABBIT_CLUSTER_ID, repConfig.getClusterConfig().getId());
				 try {
					 clusterNode.start();
				 }
				 catch (ClusterException e) {
					 String msg = ""Unable to start clustered node, forcing shutdown..."";
					 log.error(msg, e);
					 shutdown();
					 throw new RepositoryException(msg, e);
				 }
			 }
			 int maxIdleTime = repConfig.getWorkspaceMaxIdleTime();
			 if (maxIdleTime != 0) {
				 Thread wspJanitor = new Thread(new WorkspaceJanitor(maxIdleTime * 1000));
				 wspJanitor.setName(""WorkspaceJanitor"");
				 wspJanitor.setPriority(Thread.MIN_PRIORITY);
				 wspJanitor.setDaemon(true);
				 wspJanitor.start();
			 }
			 succeeded = true;
			 log.info(""Repository started ("" + (System.currentTimeMillis() - t0) + ""ms)"");
		 }
		 catch (RepositoryException e) {
			 log.error(""failed to start Repository: "" + e.getMessage(), e);
			 throw e;
		 }
		 finally {
			 if (!succeeded) {
				 try {
					 shutdown();
				 }
				 catch (Throwable t) {
					 log.error(""In addition to startup fail, another unexpected problem "" + ""occurred while shutting down the repository again."", t);
					 repLock.release();
				 }
			 }
		 }
	 }
	 protected NamespaceRegistryImpl createNamespaceRegistry() throws RepositoryException {
		 return new NamespaceRegistryImpl(context.getFileSystem());
	 }
	 protected NodeTypeRegistry createNodeTypeRegistry() throws RepositoryException {
		 return new NodeTypeRegistry( context.getNamespaceRegistry(), context.getFileSystem());
	 }
	 RepositoryContext getRepositoryContext() {
		 return context;
	 }
	 public CacheManager getCacheManager() {
		 return cacheMgr;
	 }
	 private synchronized void initSecurityManager() throws RepositoryException {
		 SecurityManagerConfig smc = getConfig().getSecurityConfig().getSecurityManagerConfig();
		 if (smc == null) {
			 log.debug(""No configuration entry for SecurityManager. Using org.apache.jackrabbit.core.security.simple.SimpleSecurityManager"");
			 securityMgr = new SimpleSecurityManager();
		 }
		 else {
			 securityMgr = smc.newInstance(JackrabbitSecurityManager.class);
		 }
		 log.info(""SecurityManager = "" + securityMgr.getClass());
		 context.setSecurityManager(securityMgr);
		 String workspaceName = getConfig().getDefaultWorkspaceName();
		 if (smc != null && smc.getWorkspaceName() != null) {
			 workspaceName = smc.getWorkspaceName();
		 }
		 markWorkspaceActive(workspaceName);
		 SystemSession systemSession = getSystemSession(workspaceName);
		 securityMgr.init(this, systemSession);
		 ValueFactory vf = ValueFactoryImpl.getInstance();
		 boolean hasUserMgt;
		 try {
			 securityMgr.getUserManager(systemSession);
			 hasUserMgt = true;
		 }
		 catch (RepositoryException e) {
			 hasUserMgt = false;
		 }
		 setDescriptor(JackrabbitRepository.OPTION_USER_MANAGEMENT_SUPPORTED, vf.createValue(hasUserMgt));
		 boolean hasPrincipalMgt;
		 try {
			 securityMgr.getPrincipalManager(systemSession);
			 hasPrincipalMgt = true;
		 }
		 catch (RepositoryException e) {
			 hasPrincipalMgt = false;
		 }
		 setDescriptor(JackrabbitRepository.OPTION_PRINCIPAL_MANAGEMENT_SUPPORTED, vf.createValue(hasPrincipalMgt));
		 setDescriptor(JackrabbitRepository.OPTION_PRIVILEGE_MANAGEMENT_SUPPORTED, vf.createValue(true));
	 }
	 protected InternalVersionManagerImpl createVersionManager(VersioningConfig vConfig, DelegatingObservationDispatcher delegatingDispatcher) throws RepositoryException {
		 FileSystem fs = vConfig.getFileSystem();
		 PersistenceManager pm = createPersistenceManager( vConfig.getHomeDir(), fs, vConfig.getPersistenceManagerConfig());
		 ISMLocking ismLocking = vConfig.getISMLocking();
		 return new InternalVersionManagerImpl( pm, fs, context.getNodeTypeRegistry(), delegatingDispatcher, SYSTEM_ROOT_NODE_ID, VERSION_STORAGE_NODE_ID, ACTIVITIES_NODE_ID, context.getItemStateCacheFactory(), ismLocking, context.getNodeIdFactory());
	 }
	 protected void initStartupWorkspaces() throws RepositoryException {
		 String wspName = repConfig.getDefaultWorkspaceName();
		 String secWspName = null;
		 SecurityManagerConfig smc = repConfig.getSecurityConfig().getSecurityManagerConfig();
		 if (smc != null) {
			 secWspName = smc.getWorkspaceName();
		 }
		 try {
			 (wspInfos.get(wspName)).initialize();
			 if (secWspName != null && !wspInfos.containsKey(secWspName)) {
				 createWorkspace(secWspName);
				 log.info(""created system workspace: {
				}
				"", secWspName);
			 }
		 }
		 catch (RepositoryException e) {
			 log.error(""Failed to initialize workspace '"" + wspName + ""'"", e);
			 log.error(""Unable to start repository, forcing shutdown..."");
			 shutdown();
			 throw e;
		 }
	 }
	 private NodeId loadRootNodeId() throws RepositoryException {
		 try {
			 FileSystemResource uuidFile = new FileSystemResource( context.getFileSystem(), ""/meta/rootUUID"");
			 if (uuidFile.exists()) {
				 InputStream in = uuidFile.getInputStream();
				 try {
					 return NodeId.valueOf(IOUtils.toString(in, ""US-ASCII""));
				 }
				 finally {
					 IOUtils.closeQuietly(in);
				 }
			 }
			 else {
				 uuidFile.makeParentDirs();
				 OutputStream out = uuidFile.getOutputStream();
				 try {
					 out.write(ROOT_NODE_ID.toString().getBytes(StandardCharsets.US_ASCII));
					 return ROOT_NODE_ID;
				 }
				 finally {
					 IOUtils.closeQuietly(out);
				 }
			 }
		 }
		 catch (IOException e) {
			 throw new RepositoryException( ""Failed to load or persist the root node identifier"", e);
		 }
		 catch (FileSystemException fse) {
			 throw new RepositoryException( ""Failed to access the root node identifier"", fse);
		 }
	 }
	 public static RepositoryImpl create(RepositoryConfig config) throws RepositoryException {
		 return new RepositoryImpl(config);
	 }
	 protected void sanityCheck() throws RepositoryException {
		 if (disposed) {
			 throw new RepositoryException( ""This repository instance has been shut down."");
		 }
	 }
	 protected SearchManager getSystemSearchManager(String wspName) throws RepositoryException {
		 if (systemSearchMgr == null) {
			 if (repConfig.isSearchEnabled()) {
				 systemSearchMgr = new SearchManager( null, context, repConfig, getWorkspaceInfo(wspName).itemStateMgr, context.getInternalVersionManager().getPersistenceManager(), SYSTEM_ROOT_NODE_ID, null, null);
				 SystemSession defSysSession = getSystemSession(wspName);
				 ObservationManager obsMgr = defSysSession.getWorkspace().getObservationManager();
				 obsMgr.addEventListener(systemSearchMgr, Event.NODE_ADDED | Event.NODE_REMOVED | Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED | Event.PROPERTY_REMOVED, ""/"" + defSysSession.getJCRName(NameConstants.JCR_SYSTEM), true, null, null, false);
			 }
		 }
		 return systemSearchMgr;
	 }
	 protected ClusterNode createClusterNode() throws RepositoryException {
		 try {
			 ClusterNode clusterNode = new ClusterNode();
			 clusterNode.init(new ExternalEventListener());
			 return clusterNode;
		 }
		 catch (Exception e) {
			 throw new RepositoryException(e);
		 }
	 }
	 protected String[] getWorkspaceNames() {
		 synchronized (wspInfos) {
			 return wspInfos.keySet().toArray(new String[wspInfos.keySet().size()]);
		 }
	 }
	 protected WorkspaceInfo getWorkspaceInfo(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 WorkspaceInfo wspInfo;
		 synchronized (wspInfos) {
			 wspInfo = wspInfos.get(workspaceName);
			 if (wspInfo == null) {
				 throw new NoSuchWorkspaceException(workspaceName);
			 }
		 }
		 try {
			 wspInfo.initialize();
		 }
		 catch (RepositoryException e) {
			 log.error(""Unable to initialize workspace '"" + workspaceName + ""'"", e);
			 throw new NoSuchWorkspaceException(workspaceName);
		 }
		 return wspInfo;
	 }
	 protected void createWorkspace(String workspaceName) throws RepositoryException {
		 synchronized (wspInfos) {
			 if (wspInfos.containsKey(workspaceName)) {
				 throw new RepositoryException(""workspace '"" + workspaceName + ""' already exists."");
			 }
			 StringBuffer workspaceConfigContent = null;
			 if (context.getClusterNode() != null) {
				 workspaceConfigContent = new StringBuffer();
			 }
			 WorkspaceConfig config = repConfig.createWorkspaceConfig(workspaceName, workspaceConfigContent);
			 WorkspaceInfo info = createWorkspaceInfo(config);
			 wspInfos.put(workspaceName, info);
			 if (workspaceConfigContent != null && createWorkspaceEventChannel != null) {
				 InputSource s = new InputSource(new StringReader(workspaceConfigContent.toString()));
				 createWorkspaceEventChannel.workspaceCreated(workspaceName, new ClonedInputSource(s));
			 }
		 }
	 }
	 public void externalWorkspaceCreated(String workspaceName, InputSource configTemplate) throws RepositoryException {
		 createWorkspaceInternal(workspaceName, configTemplate);
	 }
	 private void createWorkspaceInternal(String workspaceName, InputSource configTemplate) throws RepositoryException {
		 synchronized (wspInfos) {
			 if (wspInfos.containsKey(workspaceName)) {
				 throw new RepositoryException(""workspace '"" + workspaceName + ""' already exists."");
			 }
			 WorkspaceConfig config = repConfig.createWorkspaceConfig(workspaceName, configTemplate);
			 WorkspaceInfo info = createWorkspaceInfo(config);
			 wspInfos.put(workspaceName, info);
		 }
	 }
	 protected void createWorkspace(String workspaceName, InputSource configTemplate) throws RepositoryException {
		 if (createWorkspaceEventChannel == null) {
			 createWorkspaceInternal(workspaceName, configTemplate);
		 }
		 else {
			 ClonedInputSource template = new ClonedInputSource(configTemplate);
			 createWorkspaceInternal(workspaceName, template.cloneInputSource());
			 createWorkspaceEventChannel.workspaceCreated(workspaceName, template);
		 }
	 }
	 SharedItemStateManager getWorkspaceStateManager(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 return getWorkspaceInfo(workspaceName).getItemStateProvider();
	 }
	 protected void setReferentialIntegrityChecking( String workspace, boolean enabled) throws RepositoryException {
		 SharedItemStateManager manager = getWorkspaceStateManager(workspace);
		 manager.setCheckReferences(enabled);
	 }
	 ObservationDispatcher getObservationDispatcher(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 return getWorkspaceInfo(workspaceName).getObservationDispatcher();
	 }
	 SearchManager getSearchManager(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 return getWorkspaceInfo(workspaceName).getSearchManager();
	 }
	 LockManagerImpl getLockManager(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 return getWorkspaceInfo(workspaceName).getLockManager();
	 }
	 RetentionRegistry getRetentionRegistry(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 return getWorkspaceInfo(workspaceName).getRetentionRegistry();
	 }
	 SystemSession getSystemSession(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 sanityCheck();
		 return getWorkspaceInfo(workspaceName).getSystemSession();
	 }
	 void markWorkspaceActive(String workspaceName) throws RepositoryException {
		 getWorkspaceInfo(workspaceName).setActive(true);
	 }
	 protected final SessionImpl createSession(AuthContext loginContext, String workspaceName) throws NoSuchWorkspaceException, AccessDeniedException, RepositoryException {
		 WorkspaceInfo wspInfo = getWorkspaceInfo(workspaceName);
		 SessionImpl ses = createSessionInstance(loginContext, wspInfo.getConfig());
		 onSessionCreated(ses);
		 wspInfo.setIdleTimestamp(0);
		 return ses;
	 }
	 protected final SessionImpl createSession(Subject subject, String workspaceName) throws NoSuchWorkspaceException, AccessDeniedException, RepositoryException {
		 WorkspaceInfo wspInfo = getWorkspaceInfo(workspaceName);
		 SessionImpl ses = createSessionInstance(subject, wspInfo.getConfig());
		 onSessionCreated(ses);
		 wspInfo.setIdleTimestamp(0);
		 return ses;
	 }
	 protected void onSessionCreated(SessionImpl session) {
		 synchronized (activeSessions) {
			 session.addListener(this);
			 activeSessions.put(session, session);
		 }
	 }
	 private Session extendAuthentication(String workspaceName) throws RepositoryException, AccessDeniedException {
		 Subject subject = null;
		 try {
			 AccessControlContext acc = AccessController.getContext();
			 subject = Subject.getSubject(acc);
		 }
		 catch (SecurityException e) {
			 log.warn(""Can't check for preauthentication. Reason: {
			}
			"", e.getMessage());
		 }
		 if (subject == null) {
			 log.debug(""No preauthenticated subject found -> return null."");
			 return null;
		 }
		 Session s;
		 if (subject.isReadOnly()) {
			 log.debug(""Preauthenticated Subject is read-only -> create Session"");
			 s = createSession(subject, workspaceName);
		 }
		 else {
			 log.debug(""Found preauthenticated Subject, try to extend authentication"");
			 AuthContext authCtx = context.getSecurityManager().getAuthContext( null, subject, workspaceName);
			 try {
				 authCtx.login();
				 s = createSession(authCtx, workspaceName);
			 }
			 catch (javax.security.auth.login.LoginException e) {
				 log.debug(""Preauthentication could not be extended"");
				 s = createSession(subject, workspaceName);
			 }
		 }
		 return s;
	 }
	 public void shutdown() {
		 try {
			 shutdownLock.writeLock().acquire();
		 }
		 catch (InterruptedException e) {
			 throw new RuntimeException(""Shutdown lock could not be acquired"", e);
		 }
		 try {
			 if (!disposed) {
				 doShutdown();
			 }
		 }
		 finally {
			 shutdownLock.writeLock().release();
		 }
	 }
	 protected synchronized void doShutdown() {
		 log.info(""Shutting down repository..."");
		 ClusterNode clusterNode = context.getClusterNode();
		 if (clusterNode != null) {
			 clusterNode.stop();
		 }
		 if (securityMgr != null) {
			 securityMgr.close();
		 }
		 List<Session> sa;
		 synchronized (activeSessions) {
			 sa = new ArrayList<Session>(activeSessions.size());
			 for (Session session : activeSessions.values()) {
				 sa.add(session);
			 }
		 }
		 for (Session session : sa) {
			 if (session != null) {
				 session.logout();
			 }
		 }
		 if (systemSearchMgr != null) {
			 systemSearchMgr.close();
		 }
		 synchronized (wspInfos) {
			 for (WorkspaceInfo wspInfo : wspInfos.values()) {
				 wspInfo.dispose();
			 }
		 }
		 try {
			 InternalVersionManager m = context.getInternalVersionManager();
			 if (m != null) {
				 m.close();
			 }
		 }
		 catch (Exception e) {
			 log.error(""Error while closing Version Manager."", e);
		 }
		 repDescriptors.clear();
		 DataStore dataStore = context.getDataStore();
		 if (dataStore != null) {
			 try {
				 dataStore.close();
			 }
			 catch (DataStoreException e) {
				 log.error(""error while closing datastore"", e);
			 }
		 }
		 try {
			 context.getFileSystem().close();
		 }
		 catch (FileSystemException e) {
			 log.error(""error while closing repository file system"", e);
		 }
		 try {
			 nodeIdFactory.close();
		 }
		 catch (RepositoryException e) {
			 log.error(""error while closing repository file system"", e);
		 }
		 disposed = true;
		 notifyAll();
		 ScheduledExecutorService executor = context.getExecutor();
		 executor.shutdown();
		 try {
			 if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
				 log.warn(""Attempting to forcibly shutdown runaway threads"");
				 executor.shutdownNow();
			 }
		 }
		 catch (InterruptedException e) {
			 log.warn(""Interrupted while waiting for background threads"", e);
		 }
		 repConfig.getConnectionFactory().close();
		 if (repLock != null) {
			 try {
				 repLock.release();
			 }
			 catch (RepositoryException e) {
				 log.error(""failed to release the repository lock"", e);
			 }
		 }
		 log.info(""Repository has been shutdown"");
	 }
	 public RepositoryConfig getConfig() {
		 return repConfig;
	 }
	 protected void initRepositoryDescriptors() throws RepositoryException {
		 ValueFactory valFactory = ValueFactoryImpl.getInstance();
		 Value valTrue = valFactory.createValue(true);
		 Value valFalse = valFactory.createValue(false);
		 setDescriptor(Repository.REP_NAME_DESC, ""Jackrabbit"");
		 setDescriptor(Repository.REP_VENDOR_DESC, ""Apache Software Foundation"");
		 setDescriptor(Repository.REP_VENDOR_URL_DESC, ""http: setDescriptor(Repository.SPEC_NAME_DESC, ""Content Repository API for Java(TM) Technology Specification"");
		 setDescriptor(Repository.SPEC_VERSION_DESC, ""2.0"");
		 setDescriptor(Repository.IDENTIFIER_STABILITY, Repository.IDENTIFIER_STABILITY_INDEFINITE_DURATION);
		 setDescriptor(Repository.LEVEL_1_SUPPORTED, valTrue);
		 setDescriptor(Repository.LEVEL_2_SUPPORTED, valTrue);
		 setDescriptor(Repository.WRITE_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_NODE_TYPE_MANAGEMENT_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_AUTOCREATED_DEFINITIONS_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_INHERITANCE, Repository.NODE_TYPE_MANAGEMENT_INHERITANCE_MULTIPLE);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_MULTIPLE_BINARY_PROPERTIES_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_MULTIVALUED_PROPERTIES_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_ORDERABLE_CHILD_NODES_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_OVERRIDES_SUPPORTED, valFalse);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_PRIMARY_ITEM_NAME_SUPPORTED, valTrue);
		 Value[] types = new Value[] {
		 valFactory.createValue(PropertyType.BINARY), valFactory.createValue(PropertyType.BOOLEAN), valFactory.createValue(PropertyType.DATE), valFactory.createValue(PropertyType.DECIMAL), valFactory.createValue(PropertyType.DOUBLE), valFactory.createValue(PropertyType.LONG), valFactory.createValue(PropertyType.NAME), valFactory.createValue(PropertyType.PATH), valFactory.createValue(PropertyType.REFERENCE), valFactory.createValue(PropertyType.STRING), valFactory.createValue(PropertyType.URI), valFactory.createValue(PropertyType.WEAKREFERENCE), valFactory.createValue(PropertyType.UNDEFINED) }
		;
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_PROPERTY_TYPES, types);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_RESIDUAL_DEFINITIONS_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_SAME_NAME_SIBLINGS_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_VALUE_CONSTRAINTS_SUPPORTED, valTrue);
		 setDescriptor(Repository.NODE_TYPE_MANAGEMENT_UPDATE_IN_USE_SUPORTED, valFalse);
		 setDescriptor(Repository.OPTION_ACCESS_CONTROL_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_JOURNALED_OBSERVATION_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_LIFECYCLE_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_LOCKING_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_OBSERVATION_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_NODE_AND_PROPERTY_WITH_SAME_NAME_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_QUERY_SQL_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_RETENTION_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_SHAREABLE_NODES_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_SIMPLE_VERSIONING_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_TRANSACTIONS_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_UNFILED_CONTENT_SUPPORTED, valFalse);
		 setDescriptor(Repository.OPTION_UPDATE_MIXIN_NODE_TYPES_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_UPDATE_PRIMARY_NODE_TYPE_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_VERSIONING_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_WORKSPACE_MANAGEMENT_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_XML_EXPORT_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_XML_IMPORT_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_ACTIVITIES_SUPPORTED, valTrue);
		 setDescriptor(Repository.OPTION_BASELINES_SUPPORTED, valTrue);
		 setDescriptor(Repository.QUERY_FULL_TEXT_SEARCH_SUPPORTED, valTrue);
		 setDescriptor(Repository.QUERY_JOINS, Repository.QUERY_JOINS_INNER_OUTER);
		 Value[] languages = new Value[] {
		 valFactory.createValue(""javax.jcr.query.JCR-JQOM""), valFactory.createValue(""javax.jcr.query.JCR-SQL2"") }
		;
		 setDescriptor(Repository.QUERY_LANGUAGES, languages);
		 setDescriptor(Repository.QUERY_STORED_QUERIES_SUPPORTED, valTrue);
		 setDescriptor(Repository.QUERY_XPATH_POS_INDEX, valTrue);
		 setDescriptor(Repository.QUERY_XPATH_DOC_ORDER, valFalse);
		 Properties props = getCustomRepositoryDescriptors();
		 if (props != null) {
			 for (Object o : props.keySet()) {
				 String key = (String) o;
				 setDescriptor(key, props.getProperty(key));
			 }
		 }
	 }
	 protected Properties getCustomRepositoryDescriptors() throws RepositoryException {
		 InputStream in = RepositoryImpl.class.getResourceAsStream(PROPERTIES_RESOURCE);
		 if (in != null) {
			 try {
				 Properties props = new Properties();
				 props.load(in);
				 return props;
			 }
			 catch (IOException e) {
				 String msg = ""Failed to load customized repository properties: "" + e.toString();
				 log.error(msg);
				 throw new RepositoryException(msg, e);
			 }
			 finally {
				 IOUtils.closeQuietly(in);
			 }
		 }
		 else {
			 return null;
		 }
	 }
	 protected void setDescriptor(String desc, String value) {
		 setDescriptor(desc, ValueFactoryImpl.getInstance().createValue(value));
	 }
	 protected void setDescriptor(String desc, Value value) {
		 repDescriptors.put(desc, new DescriptorValue(value));
	 }
	 protected void setDescriptor(String desc, Value[] values) {
		 repDescriptors.put(desc, new DescriptorValue(values));
	 }
	 private PersistenceManager createPersistenceManager( File homeDir, FileSystem fs, PersistenceManagerConfig pmConfig) throws RepositoryException {
		 try {
			 PersistenceManager pm = pmConfig .newInstance(PersistenceManager.class);
			 PMContext pmContext = new PMContext( homeDir, fs, context.getRootNodeId(), context.getNamespaceRegistry(), context.getNodeTypeRegistry(), context.getDataStore(), context.getRepositoryStatistics());
			 pm.init(pmContext);
			 return pm;
		 }
		 catch (Exception e) {
			 String msg = ""Cannot instantiate persistence manager "" + pmConfig.getClassName();
			 throw new RepositoryException(msg, e);
		 }
	 }
	 protected SharedItemStateManager createItemStateManager( PersistenceManager persistMgr, boolean usesReferences, ISMLocking locking) throws ItemStateException {
		 return new SharedItemStateManager( persistMgr, context.getRootNodeId(), context.getNodeTypeRegistry(), true, context.getItemStateCacheFactory(), locking, context.getNodeIdFactory());
	 }
	 public GarbageCollector createDataStoreGarbageCollector() throws RepositoryException {
		 ArrayList<PersistenceManager> pmList = new ArrayList<PersistenceManager>();
		 InternalVersionManagerImpl vm = context.getInternalVersionManager();
		 PersistenceManager pm = vm.getPersistenceManager();
		 pmList.add(pm);
		 String[] wspNames = getWorkspaceNames();
		 SessionImpl[] sessions = new SessionImpl[wspNames.length];
		 for (int i = 0;
		 i < wspNames.length;
		 i++) {
			 String wspName = wspNames[i];
			 WorkspaceInfo wspInfo = getWorkspaceInfo(wspName);
			 SessionImpl systemSession = SystemSession.create(context, wspInfo.getConfig());
			 wspInfo.setActive(true);
			 wspInfo.initialize();
			 sessions[i] = systemSession;
			 pm = wspInfo.getPersistenceManager();
			 pmList.add(pm);
		 }
		 IterablePersistenceManager[] ipmList = new IterablePersistenceManager[pmList.size()];
		 for (int i = 0;
		 i < pmList.size();
		 i++) {
			 pm = pmList.get(i);
			 if (!(pm instanceof IterablePersistenceManager)) {
				 ipmList = null;
				 break;
			 }
			 ipmList[i] = (IterablePersistenceManager) pm;
		 }
		 GarbageCollector gc = new GarbageCollector(context, context.getDataStore(), ipmList, sessions);
		 synchronized (this) {
			 if (context.isGcRunning()) {
				 throw new RepositoryException(""Cannot create GC. GC already running"");
			 }
			 context.setGcRunning(true);
		 }
		 return gc;
	 }
	 public Session login(Credentials credentials, String workspaceName) throws LoginException, NoSuchWorkspaceException, RepositoryException {
		 try {
			 shutdownLock.readLock().acquire();
		 }
		 catch (InterruptedException e) {
			 throw new RepositoryException(""Login lock could not be acquired"", e);
		 }
		 try {
			 sanityCheck();
			 if (workspaceName == null) {
				 workspaceName = repConfig.getDefaultWorkspaceName();
			 }
			 getWorkspaceInfo(workspaceName);
			 if (credentials == null) {
				 Session session = extendAuthentication(workspaceName);
				 if (session != null) {
					 return session;
				 }
				 else {
					 log.debug(""Attempt to login without Credentials and Subject -> try login with null credentials."");
				 }
			 }
			 AuthContext authCtx = context.getSecurityManager().getAuthContext( credentials, new Subject(), workspaceName);
			 authCtx.login();
			 SessionImpl session = createSession(authCtx, workspaceName);
			 if (credentials instanceof SimpleCredentials) {
				 SimpleCredentials sc = (SimpleCredentials) credentials;
				 for (String name : sc.getAttributeNames()) {
					 if (!TokenBasedAuthentication.isMandatoryAttribute(name)) {
						 session.setAttribute(name, sc.getAttribute(name));
					 }
				 }
			 }
			 Set<TokenCredentials> tokenCreds = session.getSubject().getPublicCredentials(TokenCredentials.class);
			 if (!tokenCreds.isEmpty()) {
				 TokenCredentials tc = tokenCreds.iterator().next();
				 for (String name : tc.getAttributeNames()) {
					 if (!TokenBasedAuthentication.isMandatoryAttribute(name)) {
						 session.setAttribute(name, tc.getAttribute(name));
					 }
				 }
			 }
			 log.debug(""User {
			}
			 logged in to workspace {
			}
			"", session.getUserID(), workspaceName);
			 return session;
		 }
		 catch (SecurityException se) {
			 throw new LoginException(""Unable to access authentication information"", se);
		 }
		 catch (javax.security.auth.login.LoginException le) {
			 throw new LoginException(le.getMessage(), le);
		 }
		 catch (AccessDeniedException ade) {
			 throw new LoginException(""Workspace access denied"", ade);
		 }
		 finally {
			 shutdownLock.readLock().release();
		 }
	 }
	 public String getDescriptor(String key) {
		 Value v = getDescriptorValue(key);
		 try {
			 return (v == null) ? null : v.getString();
		 }
		 catch (RepositoryException e) {
			 log.error(""corrupt descriptor value: "" + key, e);
			 return null;
		 }
	 }
	 public String[] getDescriptorKeys() {
		 String[] keys = repDescriptors.keySet().toArray(new String[repDescriptors.keySet().size()]);
		 Arrays.sort(keys);
		 return keys;
	 }
	 public Value getDescriptorValue(String key) {
		 DescriptorValue descVal = repDescriptors.get(key);
		 return (descVal != null) ? descVal.getValue() : null;
	 }
	 public Value[] getDescriptorValues(String key) {
		 DescriptorValue descVal = repDescriptors.get(key);
		 return (descVal != null) ? descVal.getValues() : null;
	 }
	 public boolean isSingleValueDescriptor(String key) {
		 DescriptorValue descVal = repDescriptors.get(key);
		 return (descVal != null && descVal.getValue() != null);
	 }
	 public void loggingOut(SessionImpl session) {
	 }
	 public void loggedOut(SessionImpl session) {
		 synchronized (activeSessions) {
			 activeSessions.remove(session);
		 }
	 }
	 protected SessionImpl createSessionInstance(AuthContext loginContext, WorkspaceConfig wspConfig) throws AccessDeniedException, RepositoryException {
		 return new XASessionImpl(context, loginContext, wspConfig);
	 }
	 protected SessionImpl createSessionInstance(Subject subject, WorkspaceConfig wspConfig) throws AccessDeniedException, RepositoryException {
		 return new XASessionImpl(context, subject, wspConfig);
	 }
	 protected WorkspaceInfo createWorkspaceInfo(WorkspaceConfig wspConfig) {
		 return new WorkspaceInfo(wspConfig);
	 }
	 public class WorkspaceInfo implements UpdateEventListener {
		 private final WorkspaceConfig config;
		 private FileSystem fs;
		 private PersistenceManager persistMgr;
		 private SharedItemStateManager itemStateMgr;
		 private ObservationDispatcher dispatcher;
		 private SystemSession systemSession;
		 private SearchManager searchMgr;
		 private LockManagerImpl lockMgr;
		 private RetentionRegistryImpl retentionReg;
		 private boolean initialized;
		 private boolean active;
		 private final ReadWriteLock initLock = new ReentrantWriterPreferenceReadWriteLock();
		 private long idleTimestamp;
		 private final Mutex xaLock = new Mutex();
		 private UpdateEventChannel updateChannel;
		 private LockEventChannel lockChannel;
		 protected WorkspaceInfo(WorkspaceConfig config) {
			 this.config = config;
			 idleTimestamp = 0;
			 initialized = false;
		 }
		 protected String getName() {
			 return config.getName();
		 }
		 public WorkspaceConfig getConfig() {
			 return config;
		 }
		 final long getIdleTimestamp() {
			 return idleTimestamp;
		 }
		 final void setIdleTimestamp(long ts) {
			 idleTimestamp = ts;
		 }
		 protected final boolean isInitialized() {
			 try {
				 if (!initLock.readLock().attempt(0)) {
					 return false;
				 }
			 }
			 catch (InterruptedException e) {
				 return false;
			 }
			 boolean ret = initialized;
			 initLock.readLock().release();
			 return ret;
		 }
		 public boolean isActive() {
			 return active;
		 }
		 public void setActive(boolean active) {
			 this.active = active;
		 }
		 protected FileSystem getFileSystem() {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 return fs;
		 }
		 public PersistenceManager getPersistenceManager() throws RepositoryException {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 return persistMgr;
		 }
		 protected SharedItemStateManager getItemStateProvider() throws RepositoryException {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 return itemStateMgr;
		 }
		 protected ObservationDispatcher getObservationDispatcher() {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 return dispatcher;
		 }
		 protected SearchManager getSearchManager() throws RepositoryException {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 synchronized (this) {
				 if (searchMgr == null && config.isSearchEnabled()) {
					 searchMgr = new SearchManager( getName(), context, config, itemStateMgr, persistMgr, context.getRootNodeId(), getSystemSearchManager(getName()), SYSTEM_ROOT_NODE_ID);
				 }
				 return searchMgr;
			 }
		 }
		 protected LockManagerImpl getLockManager() throws RepositoryException {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 synchronized (this) {
				 if (lockMgr == null) {
					 lockMgr = createLockManager();
					 ClusterNode clusterNode = context.getClusterNode();
					 if (clusterNode != null && config.isClustered()) {
						 lockChannel = clusterNode.createLockChannel(getName());
						 lockMgr.setEventChannel(lockChannel);
					 }
				 }
				 return lockMgr;
			 }
		 }
		 protected LockManagerImpl createLockManager() throws RepositoryException {
			 return new LockManagerImpl( getSystemSession(), fs, context.getExecutor());
		 }
		 protected RetentionRegistry getRetentionRegistry() throws RepositoryException {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 synchronized (this) {
				 if (retentionReg == null) {
					 retentionReg = new RetentionRegistryImpl(getSystemSession(), fs);
				 }
				 return retentionReg;
			 }
		 }
		 protected SystemSession getSystemSession() throws RepositoryException {
			 if (!isInitialized()) {
				 throw new IllegalStateException(""workspace '"" + getName() + ""' not initialized"");
			 }
			 synchronized (this) {
				 if (systemSession == null) {
					 systemSession = SystemSession.create(context, config);
				 }
				 return systemSession;
			 }
		 }
		 final boolean initialize() throws RepositoryException {
			 try {
				 initLock.readLock().acquire();
			 }
			 catch (InterruptedException e) {
				 throw new RepositoryException(""Unable to aquire read lock."", e);
			 }
			 try {
				 if (initialized) {
					 return false;
				 }
			 }
			 finally {
				 initLock.readLock().release();
			 }
			 try {
				 initLock.writeLock().acquire();
			 }
			 catch (InterruptedException e) {
				 throw new RepositoryException(""Unable to aquire write lock."", e);
			 }
			 try {
				 if (initialized) {
					 return false;
				 }
				 log.info(""initializing workspace '"" + getName() + ""'..."");
				 doInitialize();
				 initialized = true;
				 doPostInitialize();
				 log.info(""workspace '"" + getName() + ""' initialized"");
				 return true;
			 }
			 finally {
				 initLock.writeLock().release();
			 }
		 }
		 protected void doInitialize() throws RepositoryException {
			 fs = config.getFileSystem();
			 persistMgr = createPersistenceManager( new File(config.getHomeDir()), fs, config.getPersistenceManagerConfig());
			 doVersionRecovery();
			 ISMLocking ismLocking = config.getISMLocking();
			 try {
				 itemStateMgr = createItemStateManager(persistMgr, true, ismLocking);
				 try {
					 itemStateMgr.addVirtualItemStateProvider( context.getInternalVersionManager().getVirtualItemStateProvider());
					 itemStateMgr.addVirtualItemStateProvider( virtNTMgr.getVirtualItemStateProvider());
				 }
				 catch (Exception e) {
					 log.error(""Unable to add vmgr: "" + e.toString(), e);
				 }
				 ClusterNode clusterNode = context.getClusterNode();
				 if (clusterNode != null && config.isClustered()) {
					 updateChannel = clusterNode.createUpdateChannel(getName());
					 itemStateMgr.setEventChannel(updateChannel);
					 updateChannel.setListener(this);
					 if (persistMgr instanceof ConsistencyChecker) {
						 ((ConsistencyChecker) persistMgr).setEventChannel(updateChannel);
					 }
				 }
			 }
			 catch (ItemStateException ise) {
				 String msg = ""failed to instantiate shared item state manager"";
				 log.debug(msg);
				 throw new RepositoryException(msg, ise);
			 }
			 dispatcher = new ObservationDispatcher();
			 delegatingDispatcher.addDispatcher(dispatcher);
		 }
		 protected void doVersionRecovery() throws RepositoryException {
			 if (Boolean.getBoolean(""org.apache.jackrabbit.version.recovery"")) {
				 RepositoryChecker checker = new RepositoryChecker( persistMgr, context.getInternalVersionManager());
				 checker.check(ROOT_NODE_ID, true, true);
			 }
		 }
		 protected void doPostInitialize() throws RepositoryException {
			 WorkspaceImpl wsp = (WorkspaceImpl) getSystemSession().getWorkspace();
			 log.debug(""initializing SearchManager..."");
			 long t0 = System.currentTimeMillis();
			 SearchManager searchMgr = getSearchManager();
			 if (searchMgr != null) {
				 wsp.getObservationManager().addEventListener(searchMgr, Event.NODE_ADDED | Event.NODE_REMOVED | Event.PROPERTY_ADDED | Event.PROPERTY_REMOVED | Event.PROPERTY_CHANGED, ""/"", true, null, null, false);
			 }
			 log.debug(""SearchManager initialized ("" + (System.currentTimeMillis() - t0) + ""ms)"");
		 }
		 final void disposeIfIdle(long maxIdleTime) {
			 try {
				 initLock.readLock().acquire();
			 }
			 catch (InterruptedException e) {
				 return;
			 }
			 try {
				 if (!initialized || active) {
					 return;
				 }
				 long currentTS = System.currentTimeMillis();
				 if (idleTimestamp == 0) {
					 idleTimestamp = currentTS;
				 }
				 else {
					 if ((currentTS - idleTimestamp) > maxIdleTime) {
						 log.info(""disposing workspace '"" + getName() + ""' which has been idle for "" + (currentTS - idleTimestamp) + "" ms"");
						 dispose();
					 }
				 }
			 }
			 finally {
				 initLock.readLock().release();
			 }
		 }
		 final void dispose() {
			 try {
				 initLock.writeLock().acquire();
			 }
			 catch (InterruptedException e) {
				 throw new IllegalStateException(""Unable to aquire write lock."");
			 }
			 try {
				 if (!initialized) {
					 return;
				 }
				 log.info(""shutting down workspace '"" + getName() + ""'..."");
				 doDispose();
				 idleTimestamp = 0;
				 active = false;
				 initialized = false;
				 log.info(""workspace '"" + getName() + ""' has been shutdown"");
			 }
			 finally {
				 initLock.writeLock().release();
			 }
		 }
		 protected void doDispose() {
			 if (updateChannel != null) {
				 updateChannel.setListener(null);
			 }
			 if (lockChannel != null) {
				 lockChannel.setListener(null);
			 }
			 delegatingDispatcher.removeDispatcher(dispatcher);
			 dispatcher.dispose();
			 dispatcher = null;
			 if (searchMgr != null) {
				 searchMgr.close();
				 searchMgr = null;
			 }
			 if (securityMgr != null) {
				 securityMgr.dispose(getName());
			 }
			 if (systemSession != null) {
				 systemSession.removeListener(RepositoryImpl.this);
				 systemSession.logout();
				 systemSession = null;
			 }
			 itemStateMgr.dispose();
			 itemStateMgr = null;
			 try {
				 persistMgr.close();
			 }
			 catch (Exception e) {
				 log.error(""error while closing persistence manager of workspace "" + config.getName(), e);
			 }
			 persistMgr = null;
			 if (lockMgr != null) {
				 lockMgr.close();
				 lockMgr = null;
			 }
			 if (retentionReg != null) {
				 retentionReg.close();
				 retentionReg = null;
			 }
			 try {
				 fs.close();
			 }
			 catch (FileSystemException fse) {
				 log.error(""error while closing file system of workspace "" + config.getName(), fse);
			 }
			 fs = null;
		 }
		 void lockAcquire() throws TransactionException {
			 try {
				 xaLock.acquire();
			 }
			 catch (InterruptedException e) {
				 throw new TransactionException(""Error while acquiering lock"", e);
			 }
		 }
		 void lockRelease() {
			 xaLock.release();
		 }
		 public void externalUpdate(ChangeLog external, List<EventState> events, long timestamp, String userData) throws RepositoryException {
			 try {
				 EventStateCollection esc = new EventStateCollection( getObservationDispatcher(), null, null);
				 esc.setUserData(userData);
				 esc.addAll(events);
				 esc.setTimestamp(timestamp);
				 getItemStateProvider().externalUpdate(external, esc);
			 }
			 catch (IllegalStateException e) {
				 String msg = ""Unable to deliver events: "" + e.getMessage();
				 throw new RepositoryException(msg, e);
			 }
		 }
	 }
	 private class WorkspaceJanitor implements Runnable {
		 private long maxIdleTime;
		 private long checkInterval;
		 WorkspaceJanitor(long maxIdleTime) {
			 this.maxIdleTime = maxIdleTime;
			 checkInterval = (long) (0.1 * maxIdleTime);
		 }
		 public void run() {
			 while (true) {
				 synchronized (RepositoryImpl.this) {
					 try {
						 RepositoryImpl.this.wait(checkInterval);
					 }
					 catch (InterruptedException e) {
					 }
					 if (disposed) {
						 return;
					 }
				 }
				 Set<String> wspNames;
				 synchronized (wspInfos) {
					 wspNames = new HashSet<String>(wspInfos.keySet());
				 }
				 wspNames.remove(repConfig.getDefaultWorkspaceName());
				 synchronized (activeSessions) {
					 for (Session ses : activeSessions.values()) {
						 wspNames.remove(ses.getWorkspace().getName());
					 }
				 }
				 for (String wspName : wspNames) {
					 WorkspaceInfo wspInfo;
					 synchronized (wspInfos) {
						 wspInfo = wspInfos.get(wspName);
					 }
					 wspInfo.disposeIfIdle(maxIdleTime);
				 }
			 }
		 }
	 }
	 class ExternalEventListener implements ClusterContext {
		 public ClusterConfig getClusterConfig() {
			 return getConfig().getClusterConfig();
		 }
		 public File getRepositoryHome() {
			 return new File(getConfig().getHomeDir());
		 }
		 public NamespaceResolver getNamespaceResolver() {
			 return new RegistryNamespaceResolver(context.getNamespaceRegistry());
		 }
		 public void updateEventsReady(String workspace) throws RepositoryException {
			 getWorkspaceInfo(workspace);
		 }
		 public void lockEventsReady(String workspace) throws RepositoryException {
			 getWorkspaceInfo(workspace).getLockManager();
		 }
	 }
	 protected static final class DescriptorValue {
		 private Value val;
		 private Value[] vals;
		 protected DescriptorValue(Value val) {
			 this.val = val;
		 }
		 protected DescriptorValue(Value[] vals) {
			 this.vals = vals;
		 }
		 protected Value getValue() {
			 return val;
		 }
		 protected Value[] getValues() {
			 return vals != null ? vals : new Value[] {
			val}
			;
		 }
	 }
}",1,0,0,0
"private void setupNoRandPartB() throws IOException {
	 if (this.su_ch2 != this.su_chPrev) {
		 this.su_count = 1;
		 setupNoRandPartA();
	 }
	 else if (++this.su_count >= 4) {
		 this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
		 this.su_tPos = this.data.tt[this.su_tPos];
		 this.su_j2 = 0;
		 setupNoRandPartC();
	 }
	 else {
		 setupNoRandPartA();
	 }
 }",0,0,0,0
"private class AssignmentTask implements Runnable {
	 final Map<Path,List<KeyExtent>> assignmentFailures;
	 HostAndPort location;
	 private Map<KeyExtent,List<PathSize>> assignmentsPerTablet;
	 public AssignmentTask(Map<Path,List<KeyExtent>> assignmentFailures, String location, Map<KeyExtent,List<PathSize>> assignmentsPerTablet) {
		 this.assignmentFailures = assignmentFailures;
		 this.location = HostAndPort.fromString(location);
		 this.assignmentsPerTablet = assignmentsPerTablet;
	 }
	 private void handleFailures(Collection<KeyExtent> failures, String message) {
		 for (KeyExtent ke : failures) {
			 List<PathSize> mapFiles = assignmentsPerTablet.get(ke);
			 synchronized (assignmentFailures) {
				 for (PathSize pathSize : mapFiles) {
					 List<KeyExtent> existingFailures = assignmentFailures.get(pathSize.path);
					 if (existingFailures == null) {
						 existingFailures = new ArrayList<>();
						 assignmentFailures.put(pathSize.path, existingFailures);
					 }
					 existingFailures.add(ke);
				 }
			 }
			 log.info(""Could not assign {
			}
			 map files to tablet {
			}
			 because : {
			}
			. Will retry ..."", mapFiles.size(), ke, message);
		 }
	 }
	 public void run() {
		 HashSet<Path> uniqMapFiles = new HashSet<>();
		 for (List<PathSize> mapFiles : assignmentsPerTablet.values()) for (PathSize ps : mapFiles) uniqMapFiles.add(ps.path);
		 log.debug(""Assigning {
		}
		 map files to {
		}
		 tablets at {
		}
		"", uniqMapFiles.size(), assignmentsPerTablet.size(), location);
		 try {
			 List<KeyExtent> failures = assignMapFiles(context, location, assignmentsPerTablet);
			 handleFailures(failures, ""Not Serving Tablet"");
		 }
		 catch (AccumuloException | AccumuloSecurityException e) {
			 handleFailures(assignmentsPerTablet.keySet(), e.getMessage());
		 }
	 }
 }",1,0,0,0
"public interface ExpressionNode {
	 String evaluateAsString(Context context);
	 Object evaluateAsObject(Context context);
	 long evaluateAsLong(Context context);
	 double evaluateAsDouble(Context context);
	 boolean evaluateAsBoolean(Context context);
}",0,1,0,0
"private void parseMethodAttributes(Method method, ArrayList attributes, LabeledInstructions li, Attribute_Code code, ArrayList codeAttributes);",0,0,0,1
"final class DOMOutputImpl implements LSOutput {
	 private Writer fCharStream = null;
	 private OutputStream fByteStream = null;
	 private String fSystemId = null;
	 private String fEncoding = null;
	 DOMOutputImpl() {
	}
	 public Writer getCharacterStream(){
		 return fCharStream;
	 }
	;
	 public void setCharacterStream(Writer characterStream){
		 fCharStream = characterStream;
	 }
	;
	 public OutputStream getByteStream(){
		 return fByteStream;
	 }
	;
	 public void setByteStream(OutputStream byteStream){
		 fByteStream = byteStream;
	 }
	;
	 public String getSystemId(){
		 return fSystemId;
	 }
	;
	 public void setSystemId(String systemId){
		 fSystemId = systemId;
	 }
	;
	 public String getEncoding(){
		 return fEncoding;
	 }
	;
	 public void setEncoding(String encoding){
		 fEncoding = encoding;
	 }
	;
}",0,1,0,0
"public class Jag2UMLGenerator {
	 static Log log = LogFactory.getLog(Jag2UMLGenerator.class);
	 public final static String stringType = ""java.lang.String"";
	 public final static String intType = ""java.lang.Integer"";
	 public final static String sqlDateType = ""java.sql.Date"";
	 public final static String sqlTimestampType = ""java.sql.Timestamp"";
	 public final static String sqlUtilType = ""java.util.Date"";
	 public final static String byteType = ""java.lang.Byte"";
	 public final static String floatType = ""java.lang.Float"";
	 public final static String doubleType = ""java.lang.Double"";
	 public final static String longType = ""java.lang.Long"";
	 public final static String shortType = ""java.lang.Short"";
	 public final static String bigDecimalType = ""java.math.BigDecimal"";
	 public final static String defaultType = ""DEFAULT"";
	 public final static String stringValue = ""String"";
	 public final static String intValue = ""Integer"";
	 public final static String sqlDateValue = ""Date"";
	 public final static String sqlTimestampValue = ""Timestamp"";
	 public final static String sqlUtilValue = ""Date"";
	 public final static String byteValue = ""Byte"";
	 public final static String floatValue = ""Float"";
	 public final static String doubleValue = ""Double"";
	 public final static String longValue = ""Long"";
	 public final static String shortValue = ""Short"";
	 public final static String bigDecimalValue = ""BigDecimal"";
	 public final static String defaultValue = ""String"";
	 private HashMap typeMappings = null;
	 private SimpleUmlPackage javaLangPackage = null;
	 private SimpleUmlPackage javaUtilPackage = null;
	 private SimpleUmlPackage javaSqlPackage = null;
	 private SimpleUmlPackage javaMathPackage = null;
	 private static ConsoleLogger logger;
	 public Jag2UMLGenerator(ConsoleLogger logger) {
		 this.logger = logger;
	 }
	 public Jag2UMLGenerator() {
	 }
	 public void generateXMI(String skeletFileName) {
		 generateXMI(skeletFileName, null);
	 }
	 public void generateXMI(String skeletFileName, File output) {
		 Root root = null;
		 File skeletFile = null;
		 try {
			 skeletFile = new File(skeletFileName);
			 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			 DocumentBuilder builder = null;
			 Document doc = null;
			 builder = dbf.newDocumentBuilder();
			 doc = builder.parse(skeletFile);
			 root = new Root(doc);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
		 if (output == null) {
			 output = skeletFile.getParentFile();
		 }
		 generateXMI(root, output);
	 }
	 private void generateXMI(Root root, File output) {
		 App app = root.app;
		 Config conf = root.config;
		 ArrayList sessionEJBs = root.getSessionEjbs();
		 String rootPackage = app.rootPackageText.getText();
		 String projectName = app.descriptionText.getText();
		 SimpleModel simpleModel = new SimpleModel();
		 simpleModel.setName(projectName);
		 createBasicTypes(simpleModel);
		 simpleModel.addSimpleUmlPackage(rootPackage);
		 createDataSource(root.datasource, simpleModel);
		 createConfigClass(root.config,root.app,root.paths,simpleModel);
		 HashMap entityEJBMap = createEntityEJBs(root.getEntityEjbs(), simpleModel);
		 HashMap sessionEJBMap = createSessionEJBs(root.getSessionEjbs(), simpleModel);
		 for (int i = 0;
		 i < sessionEJBs.size();
		 i++) {
			 Session s = (Session) sessionEJBs.get(i);
			 String refName = s.getRefName();
			 SimpleUmlClass sessionUMLClass = (SimpleUmlClass) sessionEJBMap.get(refName);
			 ArrayList entityRefs = s.getEntityRefs();
			 for (int j = 0;
			 j < entityRefs.size();
			 j++) {
				 String entityRefName = (String) entityRefs.get(j);
				 SimpleUmlClass entityUMLClass = (SimpleUmlClass) entityEJBMap.get(entityRefName);
				 if (entityUMLClass != null) {
					 SimpleDependency dep = new SimpleDependency();
					 dep.setClient(sessionUMLClass);
					 dep.setSupplier(entityUMLClass);
					 simpleModel.addSimpleDependency(dep);
				 }
			 }
		 }
		 createContainerManagedRelations(root.getEntityEjbs(), entityEJBMap, simpleModel);
		 try {
			 if (output.isDirectory()) {
				 output = new File(output, simpleModel.getName() + "".xmi"");
			 }
			 OutputStream outputStream = new FileOutputStream(output);
			 simpleModel.writeModel(outputStream);
		 }
		 catch (IOException ioe) {
			 log(""Error writing the file."");
		 }
	 }
	 private HashMap createEntityEJBs(ArrayList entityEJBs, SimpleModel simpleModel) {
		 HashMap map = new HashMap();
		 for (int i = 0;
		 i < entityEJBs.size();
		 i++) {
			 Entity e = (Entity) entityEJBs.get(i);
			 String documentation = e.getDescription().toString();
			 String name = e.getName().toString();
			 String refName = e.getRefName();
			 String tableName = e.getTableName();
			 String displayName = e.getDisplayName().toString();
			 String entityRootPackage = e.getRootPackage().toString();
			 simpleModel.addSimpleUmlPackage(entityRootPackage);
			 String isCompositeKey = e.getIsComposite();
			 String isAssocation = e.getIsAssociationEntity();
			 SimpleUmlClass umlClass = new SimpleUmlClass(name, SimpleModelElement.PUBLIC);
			 simpleModel.setStereoType(JagUMLProfile.STEREOTYPE_CLASS_ENTITY, umlClass);
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, documentation, umlClass);
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_TABLE_NAME, tableName, umlClass);
			 if (!"""".equals(displayName)) {
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DISPLAY_NAME, displayName, umlClass);
			 }
			 if (""true"".equals(isCompositeKey)) {
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_COMPOSITE_PRIMARY_KEY, e.getPrimaryKeyType().toString(), umlClass);
			 }
			 if (""true"".equals(isAssocation)) {
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_IS_ASSOCIATION, isAssocation, umlClass);
			 }
			 ArrayList fields = (ArrayList) e.getFields();
			 for (int j = 0;
			 j < fields.size();
			 j++) {
				 Field field = (Field) fields.get(j);
				 String fieldType = field.getType();
				 String fieldName = field.getName().toString();
				 SimpleUmlClass type = (SimpleUmlClass) typeMappings.get(fieldType);
				 if (type == null) {
					 log(""Unknown type: "" + type + "" for field "" + fieldType);
					 type = (SimpleUmlClass) typeMappings.get(this.stringType);
				 }
				 SimpleAttribute theAttribute = new SimpleAttribute(fieldName, SimpleModelElement.PUBLIC, type);
				 umlClass.addSimpleAttribute(theAttribute);
				 String foreignKey = field.getForeignKey().toString();
				 if (field.isPrimaryKey()) {
					 simpleModel.setStereoType(JagUMLProfile.STEREOTYPE_ATTRIBUTE_PRIMARY_KEY, theAttribute);
				 }
				 else if (field.isNullable() == false) {
					 simpleModel.setStereoType(JagUMLProfile.STEREOTYPE_ATTRIBUTE_REQUIRED, theAttribute);
				 }
				 if (field.isForeignKey()) {
					 String stereoTypeForeignKey = JagUMLProfile.STEREOTYPE_ATTRIBUTE_FOREIGN_KEY;
				 }
				 String jdbcType = field.getJdbcType().toString();
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_JDBC_TYPE, jdbcType, theAttribute);
				 String sqlType = field.getSqlType().toString();
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_SQL_TYPE, sqlType, theAttribute);
				 String columnName = field.getColumnName();
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_COLUMN_NAME, columnName, theAttribute);
				 boolean autoGeneratedPrimarykey = field.getHasAutoGenPrimaryKey();
				 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_AUTO_PRIMARY_KEY, """" + autoGeneratedPrimarykey, theAttribute);
			 }
			 SimpleUmlPackage pk = simpleModel.addSimpleUmlPackage(entityRootPackage);
			 pk.addSimpleClassifier(umlClass);
			 map.put(refName, umlClass);
		 }
		 return map;
	 }
	 private HashMap createSessionEJBs(ArrayList sessionEJBs, SimpleModel simpleModel) {
		 HashMap map = new HashMap();
		 for (int i = 0;
		 i < sessionEJBs.size();
		 i++) {
			 Session s = (Session) sessionEJBs.get(i);
			 String sessionPackage = s.getRootPackage().toString();
			 String documentation = s.getDescription().toString();
			 String name = s.getName().toString();
			 String refName = s.getRefName();
			 simpleModel.addSimpleUmlPackage(sessionPackage);
			 SimpleUmlPackage pk = simpleModel.addSimpleUmlPackage(sessionPackage);
			 String sessionStereoType = JagUMLProfile.STEREOTYPE_CLASS_SERVICE;
			 SimpleUmlClass sessionClass = new SimpleUmlClass(name, SimpleModelElement.PUBLIC);
			 simpleModel.setStereoType(JagUMLProfile.STEREOTYPE_CLASS_SERVICE, sessionClass);
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, documentation, sessionClass);
			 pk.addSimpleClassifier(sessionClass);
			 ArrayList methods = s.getBusinessMethods();
			 if (methods != null) {
				 for (int j=0;
				 j< methods.size();
				 j++) {
					 BusinessMethod bm = (BusinessMethod) methods.get(j);
					 SimpleOperation op = new SimpleOperation();
					 op.setName(bm.getMethodName());
					 String desc = bm.getDescription();
					 if (desc == null) {
						 desc = """";
					 }
					 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, desc, op);
					 ArrayList arguments = bm.getArgumentList();
					 if (arguments != null) {
						 for (int k=0;
						 k < arguments.size();
						 k++) {
							 BusinessArgument arg = (BusinessArgument) arguments.get(k);
							 SimpleParameter sp = new SimpleParameter();
							 sp.setName(arg.getName());
							 SimpleUmlClass sc = new SimpleUmlClass(arg.getType(), SimpleModelElement.PUBLIC);
							 simpleModel.addSimpleClassifier(sc);
							 sp.setKind(SimpleParameter.IN);
							 sp.setType(sc);
							 op.addSimpleParameter(sp);
						 }
					 }
					 SimpleParameter sp = new SimpleParameter();
					 sp.setName("""");
					 SimpleUmlClass sc = new SimpleUmlClass(bm.getReturnType(), SimpleModelElement.PUBLIC);
					 simpleModel.addSimpleClassifier(sc);
					 sp.setKind(SimpleParameter.RETURN);
					 sp.setType(sc);
					 op.addSimpleParameter(sp);
					 sessionClass.addSimpleOperation(op);
				 }
			 }
			 map.put(refName, sessionClass);
		 }
		 return map;
	 }
	 private void createContainerManagedRelations(ArrayList entityEJBs, HashMap entityEJBMap, SimpleModel simpleModel) {
		 for (int i = 0;
		 i < entityEJBs.size();
		 i++) {
			 Entity e = (Entity) entityEJBs.get(i);
			 List relationFieldNames = e.getRelations();
			 for (int j = 0;
			 j < relationFieldNames.size();
			 j++) {
				 Relation rel = (Relation) relationFieldNames.get(j);
				 String source = e.getRefName();
				 String destination = rel.getRelatedEntity().getRefName();
				 boolean navigable = rel.isBidirectional();
				 int targetCardinality = -1;
				 if (rel.isTargetMultiple()) {
					 targetCardinality = -1;
				 }
				 else {
					 targetCardinality = 1;
				 }
				 SimpleUmlClass sourceClass = (SimpleUmlClass) entityEJBMap.get(source);
				 SimpleUmlClass destinationClass = (SimpleUmlClass) entityEJBMap.get(destination);
				 if (sourceClass != null && destinationClass != null) {
					 SimpleAssociationEnd sourceEnd = new SimpleAssociationEnd(sourceClass.getName(), sourceClass, 0, 1, navigable);
					 SimpleAssociationEnd destinationEnd = new SimpleAssociationEnd(destinationClass.getName(), destinationClass, 0, targetCardinality, true);
					 SimpleAssociation assoc = new SimpleAssociation(rel.getFieldName().toString(), sourceEnd, destinationEnd);
					 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ASSOCIATION_FOREIGN_FIELD, rel.getForeignPkFieldName().toString(), assoc);
					 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ASSOCIATION_MULTIPLICITY, rel.isTargetMultiple() ? JagUMLProfile.TAGGED_VALUE_ASSOCIATION_MULTIPLICITY_MANY_TO_ONE: JagUMLProfile.TAGGED_VALUE_ASSOCIATION_MULTIPLICITY_ONE_TO_ONE, assoc);
					 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_ASSOCIATION_BIDIRECTIONAL, rel.isBidirectional() ? ""true"":""false"", assoc);
					 simpleModel.addSimpleAssociation(assoc);
				 }
			 }
		 }
	 }
	 private void createConfigClass(Config config, App app, Paths paths, SimpleModel simpleModel) {
		 String rootPackage = app.rootPackageText.getText();
		 String projectName = app.descriptionText.getText();
		 String logging = app.getLogFramework();
		 SimpleUmlClass dsClass = new SimpleUmlClass(""Config"" + projectName, SimpleModelElement.PUBLIC);
		 simpleModel.setStereoType(JagUMLProfile.STEREOTYPE_CLASS_JAG_CONFIG, dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_AUTHOR, config.getAuthorText(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_VERSION, config.getVersionText(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_COMPANY, config.getCompanyText(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_TEMPLATE, config.getTemplate().getTemplateDir().toString(), dsClass);
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_APPLICATION_SERVER) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_APPSERVER, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_APPLICATION_SERVER), dsClass);
		 }
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_RELATIONS) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_USE_RELATIONS, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_RELATIONS), dsClass);
		 }
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_MOCK) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_USE_MOCK, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_MOCK), dsClass);
		 }
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_JAVA5) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_USE_JAVA5, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_USE_JAVA5), dsClass);
		 }
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_WEB_TIER) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_WEB_TIER, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_WEB_TIER), dsClass);
		 }
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_BUSINESS_TIER) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_BUSINESS_TIER, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_BUSINESS_TIER), dsClass);
		 }
		 if (config.getTemplateSettings().get(JagGenerator.TEMPLATE_SERVICE_TIER) != null) {
			 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_SERVICE_TIER, (String) config.getTemplateSettings().get(JagGenerator.TEMPLATE_SERVICE_TIER), dsClass);
		 }
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_APPLICATION_NAME, app.getName().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_DESCRIPTION, projectName, dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_APPLICATION_VERSION, app.getVersion().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_ROOT_PACKAGE, rootPackage, dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_LOGGING, logging, dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_DATE_FORMAT, app.getDateFormat().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_TIMESTAMP_FORMAT, app.getTimestampFormat().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_SERVICE_PATH, paths.getServiceOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_EJB_PATH, paths.getEjbOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_WEB_PATH, paths.getWebOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_JSP_PATH, paths.getJspOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_TEST_PATH, paths.getTestOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_CONFIG_PATH, paths.getConfigOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_SWING_PATH, paths.getSwingOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_MOCK_PATH, paths.getMockOutput(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_HIBERNATE_PATH, paths.getHibernateOutput(), dsClass);
		 simpleModel.addSimpleClassifier(dsClass);
	 }
	 private void createDataSource(Datasource ds, SimpleModel simpleModel) {
		 SimpleUmlClass dsClass = new SimpleUmlClass(""DataSource"" + simpleModel.getName(), SimpleModelElement.PUBLIC);
		 simpleModel.setStereoType(JagUMLProfile.STEREOTYPE_CLASS_DATA_SOURCE, dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_JDBC_URL, ds.getJdbcUrl().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_MAPPING, ds.getDatabase().getTypeMapping(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_USER_NAME, ds.getUserName().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_PASSWORD, ds.getPassword().toString(), dsClass);
		 simpleModel.addTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_JNDI_NAME, ds.getJndiName().toString(), dsClass);
		 simpleModel.addSimpleClassifier(dsClass);
	 }
	 public HashMap createBasicTypes(SimpleModel simpleModel) {
		 if (typeMappings != null) {
			 return typeMappings;
		 }
		 typeMappings = new HashMap();
		 javaLangPackage = simpleModel.addSimpleUmlPackage(""java.lang"");
		 javaUtilPackage = simpleModel.addSimpleUmlPackage(""java.util"");
		 javaSqlPackage = simpleModel.addSimpleUmlPackage(""java.sql"");
		 javaMathPackage = simpleModel.addSimpleUmlPackage(""java.math"");
		 HashMap basicTypes = new HashMap();
		 basicTypes.put(stringType, stringValue);
		 basicTypes.put(intType, intValue);
		 basicTypes.put(byteType, byteValue);
		 basicTypes.put(shortType, shortValue);
		 basicTypes.put(floatType, floatValue);
		 basicTypes.put(doubleType, doubleValue);
		 basicTypes.put(longType, longValue);
		 Set basicTypesSet = basicTypes.keySet();
		 for (Iterator iterator = basicTypesSet.iterator();
		 iterator.hasNext();
		) {
			 String key = (String) iterator.next();
			 SimpleUmlClass simpleUmlClass = new SimpleUmlClass((String) basicTypes.get(key), SimpleModelElement.PUBLIC);
			 javaLangPackage.addSimpleClassifier(simpleUmlClass);
			 typeMappings.put(key, simpleUmlClass);
		 }
		 basicTypes.put(bigDecimalType, bigDecimalValue);
		 basicTypes.put(sqlDateType, sqlDateValue);
		 basicTypes.put(sqlTimestampType, sqlTimestampValue);
		 basicTypes.put(sqlUtilType, sqlUtilValue);
		 typeMappings.put(defaultType, typeMappings.get(stringType));
		 SimpleUmlClass simpleUmlClass = new SimpleUmlClass((String) basicTypes.get(bigDecimalType), SimpleModelElement.PUBLIC);
		 javaMathPackage.addSimpleClassifier(simpleUmlClass);
		 typeMappings.put(bigDecimalType, simpleUmlClass);
		 simpleUmlClass = new SimpleUmlClass((String) basicTypes.get(sqlDateType), SimpleModelElement.PUBLIC);
		 javaSqlPackage.addSimpleClassifier(simpleUmlClass);
		 typeMappings.put(sqlDateType, simpleUmlClass);
		 simpleUmlClass = new SimpleUmlClass((String) basicTypes.get(sqlTimestampType), SimpleModelElement.PUBLIC);
		 javaSqlPackage.addSimpleClassifier(simpleUmlClass);
		 typeMappings.put(sqlTimestampType, simpleUmlClass);
		 simpleUmlClass = new SimpleUmlClass((String) basicTypes.get(sqlUtilType), SimpleModelElement.PUBLIC);
		 javaUtilPackage.addSimpleClassifier(simpleUmlClass);
		 typeMappings.put(sqlUtilType, simpleUmlClass);
		 return typeMappings;
	 }
	 public static void main(String[] args) {
		 if (args.length == 1) {
			 (new Jag2UMLGenerator()).generateXMI(args[0]);
		 }
		 else {
			 log(""Pass a JAG xml file as argument!"");
		 }
	 }
	 private static void log(String message) {
		 log.info(message);
		 if (logger == null) {
			 log.info(message);
		 }
	 }
}",1,0,0,0
"public class HarvestCoordinatorImpl implements HarvestCoordinator {
	 private HashMap<String, HarvestAgentStatusDTO> harvestAgents;
	 private HarvestCoordinatorDAO harvestCoordinatorDao;
	 private TargetInstanceManager targetInstanceManager;
	 private TargetInstanceDAO targetInstanceDao;
	 private HarvestAgentFactory harvestAgentFactory;
	 private DigitalAssetStoreFactory digitalAssetStoreFactory;
	 private HarvestAgentConfig harvestAgentConfig;
	 private TargetManager targetManager;
	 private InTrayManager inTrayManager;
	 private int minimumBandwidth = 1;
	 private int maxBandwidthPercent = 80;
	 private int daysBeforeDASPurge = 14;
	 private int daysBeforeAbortedTargetInstancePurge = 7;
	 private long previousMaxGlobalBandwidth = 0;
	 private Auditor auditor = null;
	 private SipBuilder sipBuilder = null;
	 private Log log;
	 private boolean queuePaused = false;
	 private String autoQAUrl = """";
	 public HarvestCoordinatorImpl() {
		 super();
		 log = LogFactory.getLog(getClass());
		 harvestAgents = new HashMap<String, HarvestAgentStatusDTO>();
	 }
	 public void heartbeat(HarvestAgentStatusDTO aStatus) {
		 if (log.isInfoEnabled()) {
			 if (harvestAgents.containsKey(aStatus.getName())) {
				 if (log.isDebugEnabled()) {
					 log.debug(""Updating status for "" + aStatus.getName());
				 }
			 }
			 else {
				 log.info(""Registering harvest agent "" + aStatus.getName());
			 }
		 }
		 aStatus.setLastUpdated(new Date());
		 harvestAgents.put(aStatus.getName(), aStatus);
		 String key = """";
		 long toid = 0;
		 TargetInstance ti = null;
		 HarvesterStatusDTO sd = null;
		 HashMap hss = null;
		 HarvesterStatus status = null;
		 Iterator it = aStatus.getHarvesterStatus().keySet().iterator();
		 while (it.hasNext()) {
			 key = (String) it.next();
			 toid = Long.parseLong(key.substring(key.lastIndexOf(""-"") + 1));
			 ti = targetInstanceDao.load(toid);
			 hss = aStatus.getHarvesterStatus();
			 sd = (HarvesterStatusDTO) hss.get(key);
			 Environment env = EnvironmentFactory.getEnv();
			 sd.setApplicationVersion(env.getApplicationVersion());
			 sd.setHeritrixVersion(env.getHeritrixVersion());
			 if (ti.getStatus() == null) {
				 status = new HarvesterStatus(sd);
				 ti.setStatus(status);
				 status.setOid(ti.getOid());
			 }
			 else {
				 status = ti.getStatus();
				 status.update(sd);
			 }
			 if (status.getStatus().startsWith(""Paused"")) {
				 if (ti.getState().equals(TargetInstance.STATE_RUNNING)) {
					 ti.setState(TargetInstance.STATE_PAUSED);
				 }
			 }
			 if (status.getStatus().startsWith(""Running"")) {
				 if (ti.getState().equals(TargetInstance.STATE_PAUSED) || ti.getState().equals(TargetInstance.STATE_QUEUED)) {
					 if(ti.getState().equals(TargetInstance.STATE_QUEUED)) {
						 log.info(""HarvestCoordinator: Target Instance state changed from Queued to Running for target instance ""+ti.getOid().toString());
					 }
					 if(ti.getActualStartTime() == null) {
						 Date now = new Date();
						 Date startTime = new Date(now.getTime() - status.getElapsedTime());
						 ti.setActualStartTime(startTime);
						 ti.setHarvestServer(aStatus.getName());
						 log.info(""HarvestCoordinator: Target Instance start time set for target instance ""+ti.getOid().toString());
					 }
					 ti.setState(TargetInstance.STATE_RUNNING);
				 }
			 }
			 if (status.getStatus().startsWith(""Finished"")) {
				 if (ti.getState().equals(TargetInstance.STATE_RUNNING)) {
					 ti.setState(TargetInstance.STATE_STOPPING);
				 }
			 }
			 if (status.getStatus().startsWith(""Could not launch job - Fatal InitializationException"")) {
				 if (ti.getState().equals(TargetInstance.STATE_RUNNING)) {
					 ti.setState(TargetInstance.STATE_ABORTED);
					 HarvestAgentStatusDTO hs = getHarvestAgent(ti.getJobName());
					 if (hs == null) {
						 if (log.isWarnEnabled()) {
							 log.warn(""Forced Abort Failed. Failed to find the Harvest Agent for the Job "" + ti.getJobName() + ""."");
						 }
					 }
					 else {
						 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(hs.getHost(), hs.getPort());
						 agent.abort(ti.getJobName());
					 }
				 }
			 }
			 targetInstanceManager.save(ti);
		 }
	 }
	 public void harvestComplete(HarvestResultDTO aResult) {
		 TargetInstance ti = targetInstanceDao.load(aResult.getTargetInstanceOid());
		 if (ti == null) {
			 throw new WCTRuntimeException(""Unknown TargetInstance oid recieved "" + aResult.getTargetInstanceOid() + "" failed to save HarvestResult."");
		 }
		 if(aResult.getHarvestNumber() == 1 && !ti.getHarvestResults().isEmpty()) {
			 log.warn(""Duplicate 'Harvest Complete' message received for job: ""+ti.getOid()+"". Message ignored."");
			 return;
		 }
		 log.info(""'Harvest Complete' message received for job: ""+ti.getOid()+""."");
		 HarvestResult harvestResult = null;
		 if (aResult instanceof ArcHarvestResultDTO) {
			 harvestResult = new ArcHarvestResult((ArcHarvestResultDTO) aResult, ti);
		 }
		 else {
			 harvestResult = new HarvestResult(aResult, ti);
		 }
		 harvestResult.setState(HarvestResult.STATE_INDEXING);
		 List<HarvestResult> hrs = ti.getHarvestResults();
		 hrs.add(harvestResult);
		 ti.setHarvestResults(hrs);
		 ti.setState(TargetInstance.STATE_HARVESTED);
		 targetInstanceDao.save(harvestResult);
		 targetInstanceDao.save(ti);
		 sendBandWidthRestrictions();
		boolean bActiveSchedules = false;
		for(Schedule schedule: ti.getTarget().getSchedules()) {
			if(schedule.getEndDate() == null) {
				bActiveSchedules = true;
			}
			else if (schedule.getEndDate().after(new Date())){
				bActiveSchedules = true;
			}
		}
		 if (targetInstanceDao.countActiveTIsForTarget(ti.getTarget().getOid()) == 0 && !bActiveSchedules) {
			 Target t = targetManager.load(ti.getTarget().getOid(), true);
			 t.changeState(Target.STATE_COMPLETED);
			 targetManager.save(t);
		 }
		 try {
			 digitalAssetStoreFactory.getDAS().initiateIndexing(new ArcHarvestResultDTO( harvestResult.getOid(), harvestResult.getTargetInstance().getOid(), harvestResult.getCreationDate(), harvestResult.getHarvestNumber(), harvestResult.getProvenanceNote() ));
		 }
		 catch(DigitalAssetStoreException ex) {
			 log.error(""Could not send initiateIndexing message to the DAS"", ex);
		 }
		 inTrayManager.generateNotification(ti.getOwner().getOid(), MessageType.CATEGORY_MISC, MessageType.TARGET_INSTANCE_COMPLETE, ti);
		 inTrayManager.generateTask(Privilege.ENDORSE_HARVEST,MessageType.TARGET_INSTANCE_ENDORSE,ti);
		 log.info(""'Harvest Complete' message processed for job: ""+ti.getOid()+""."");
	 }
	 private void cleanHarvestResult(HarvestResult harvestResult) {
		 if(harvestResult != null) {
			 if(harvestResult.getResources() != null) {
				 targetInstanceDao.deleteHarvestResultResources(harvestResult.getOid());
			 }
			 if(harvestResult instanceof ArcHarvestResult) {
				 targetInstanceDao.deleteHarvestResultFiles(harvestResult.getOid());
			 }
		 }
	 }
	public Boolean reIndexHarvestResult(HarvestResult origHarvestResult) {
		 TargetInstance ti = origHarvestResult.getTargetInstance();
		Boolean reIndex = false;
		try{
			reIndex = !digitalAssetStoreFactory.getDAS().checkIndexing(origHarvestResult.getOid());
		}
		 catch(DigitalAssetStoreException ex) {
			 log.error(""Could not send checkIndexing message to the DAS"", ex);
		 }
		if(reIndex){
			 targetInstanceDao.save(ti);
			cleanHarvestResult(origHarvestResult);
			ti = targetInstanceDao.load(ti.getOid());
			 HarvestResult newHarvestResult = null;
			 if (origHarvestResult instanceof ArcHarvestResult) {
				 ArcHarvestResultDTO ahr = new ArcHarvestResultDTO();
				 ahr.setCreationDate(new Date());
				 ahr.setTargetInstanceOid(ti.getOid());
				 ahr.setProvenanceNote(origHarvestResult.getProvenanceNote());
				 ahr.setHarvestNumber(origHarvestResult.getHarvestNumber());
				 newHarvestResult = new ArcHarvestResult(ahr, ti);
			 }
			 else {
				 HarvestResultDTO hr = new HarvestResultDTO();
				 hr.setCreationDate(new Date());
				 hr.setTargetInstanceOid(ti.getOid());
				 hr.setProvenanceNote(origHarvestResult.getProvenanceNote());
				 hr.setHarvestNumber(origHarvestResult.getHarvestNumber());
				 newHarvestResult = new HarvestResult(hr, ti);
			 }
			 origHarvestResult.setState(HarvestResult.STATE_ABORTED);
			 newHarvestResult.setState(HarvestResult.STATE_INDEXING);
			 List<HarvestResult> hrs = ti.getHarvestResults();
			 hrs.add(newHarvestResult);
			 ti.setHarvestResults(hrs);
			 ti.setState(TargetInstance.STATE_HARVESTED);
			 targetInstanceDao.save(newHarvestResult);
			 targetInstanceDao.save(ti);
			 try {
				 digitalAssetStoreFactory.getDAS().initiateIndexing(new ArcHarvestResultDTO( newHarvestResult.getOid(), newHarvestResult.getTargetInstance().getOid(), newHarvestResult.getCreationDate(), newHarvestResult.getHarvestNumber(), newHarvestResult.getProvenanceNote() ));
				 inTrayManager.generateNotification(ti.getOwner().getOid(), MessageType.CATEGORY_MISC, MessageType.TARGET_INSTANCE_COMPLETE, ti);
				 inTrayManager.generateTask(Privilege.ENDORSE_HARVEST,MessageType.TARGET_INSTANCE_ENDORSE,ti);
			 }
			 catch(DigitalAssetStoreException ex) {
				 log.error(""Could not send initiateIndexing message to the DAS"", ex);
			 }
		}
		return reIndex;
	}
	 public void notification(Long aTargetInstanceOid, int notificationCategory, String aMessageType) {
		 TargetInstance ti = targetInstanceDao.load(aTargetInstanceOid);
		 inTrayManager.generateNotification(ti.getOwner().getOid(), notificationCategory, aMessageType, ti);
	 }
	 public void notification(String aSubject, int notificationCategory, String aMessage) {
		 List<String> privs = new ArrayList<String>();
		 privs.add(Privilege.MANAGE_WEB_HARVESTER);
		 inTrayManager.generateNotification(privs, notificationCategory, aSubject,aMessage);
	 }
	 public void harvest(TargetInstance aTargetInstance, HarvestAgentStatusDTO aHarvestAgent) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the harvest command."");
		 }
		 if (aHarvestAgent == null) {
			 throw new WCTRuntimeException(""A null harvest agent status was provided to the harvest command."");
		 }
		 if (queuePaused || !isTargetApproved(aTargetInstance) || aHarvestAgent.getMemoryWarning()) {
			 return;
		 }
		 prepareHarvest(aTargetInstance);
		 _harvest(aTargetInstance, aHarvestAgent);
	 }
	 private void prepareHarvest(TargetInstance aTargetInstance) {
		 BusinessObjectFactory factory = new BusinessObjectFactory();
		 Set<String> originalSeeds = new HashSet<String>();
		 Set<SeedHistory> seedHistory = new HashSet<SeedHistory>();
		 for(Seed seed : targetManager.getSeeds(aTargetInstance)) {
			 originalSeeds.add(seed.getSeed());
			 if(targetInstanceManager.getStoreSeedHistory()) {
				 SeedHistory history = factory.newSeedHistory(aTargetInstance, seed);
				 seedHistory.add(history);
			 }
		 }
		 aTargetInstance.setOriginalSeeds(originalSeeds);
		 if(targetInstanceManager.getStoreSeedHistory()) {
			 aTargetInstance.setSeedHistory(seedHistory);
		 }
		 Map<String,String> sipParts = sipBuilder.buildSipSections(aTargetInstance);
		 aTargetInstance.setSipParts(sipParts);
		 targetInstanceDao.save(aTargetInstance);
	 }
	 private void _harvest(TargetInstance aTargetInstance, HarvestAgentStatusDTO aHarvestAgent) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the harvest command."");
		 }
		 if (aHarvestAgent == null) {
			 throw new WCTRuntimeException(""A null harvest agent status was provided to the harvest command."");
		 }
		 if (!isTargetApproved(aTargetInstance) || aHarvestAgent.getMemoryWarning()) {
			 return;
		 }
		 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(aHarvestAgent.getHost(), aHarvestAgent.getPort());
		 StringBuffer seeds = new StringBuffer();
		 Set<String> originalSeeds = aTargetInstance.getOriginalSeeds();
		 for(String seed: originalSeeds) {
			 seeds.append(seed);
			 seeds.append(""\n"");
		 }
		 String profile = getHarvestProfileString(aTargetInstance);
		 agent.initiateHarvest(aTargetInstance.getJobName(), profile, seeds.toString());
		 aTargetInstance.setActualStartTime(new Date());
		 aTargetInstance.setState(TargetInstance.STATE_RUNNING);
		 aTargetInstance.setHarvestServer(aHarvestAgent.getName());
		 targetInstanceManager.save(aTargetInstance);
		 log.info(""HarvestCoordinator: Harvest initiated successfully for target instance ""+aTargetInstance.getOid().toString());
		 sendBandWidthRestrictions();
	 }
	 public synchronized void checkForBandwidthTransition() {
		 long currBW = getCurrentGlobalMaxBandwidth();
		 if (log.isDebugEnabled()) {
			 log.debug(""Checking bandwidth. prev = "" + previousMaxGlobalBandwidth + "" curr = "" + currBW);
		 }
		 if (currBW != previousMaxGlobalBandwidth) {
			 if (log.isInfoEnabled()) {
				 log.info(""Found bandwidth transition from "" + previousMaxGlobalBandwidth + "" to "" + currBW + "" re-calulating bandwidth settings."");
			 }
			 sendBandWidthRestrictions();
		 }
		 previousMaxGlobalBandwidth = currBW;
	 }
	 private String getHarvestProfileString(TargetInstance aTargetInstance) {
		String profileString = aTargetInstance.getTarget().getProfile().getProfile();
		profileString = profileString.replace(""${
		TI_OID}
		"", aTargetInstance.getOid().toString());
		HeritrixProfile heritrixProfile = HeritrixProfile.fromString(profileString);
		if (aTargetInstance.getProfileOverrides().hasOverrides()) {
			log.info(""Applying Profile Overrides for ""+aTargetInstance.getOid());
			aTargetInstance.getProfileOverrides().apply(heritrixProfile);
		}
		heritrixProfile.setToeThreads(targetManager.getSeeds(aTargetInstance).size() * 2);
		return heritrixProfile.toString();
	}
	 private void sendBandWidthRestrictions() {
		 HarvestAgent agent = null;
		 HarvestAgentStatusDTO ha = null;
		 TargetInstance ti = null;
		 HashMap<Long, TargetInstance> running = calculateBandwidthAllocation();
		 Iterator it = running.values().iterator();
		 while (it.hasNext()) {
			 ti = (TargetInstance) it.next();
			 ha = getHarvestAgent(ti.getJobName());
			 if (ha != null) {
				 agent = harvestAgentFactory.getHarvestAgent(ha.getHost(), ha.getPort());
				 if (ti.getAllocatedBandwidth() == null || ti.getAllocatedBandwidth().intValue() <= 0) {
					 ti.setAllocatedBandwidth(new Long(1));
				 }
				agent.restrictBandwidth(ti.getJobName(), ti.getAllocatedBandwidth().intValue());
				 targetInstanceDao.save(ti);
			 }
		 }
	 }
	 private HashMap<Long, TargetInstance> calculateBandwidthAllocation(TargetInstance aTargetInstance) {
		 TargetInstanceCriteria tic = new TargetInstanceCriteria();
		 Set<String> states = new HashSet<String>();
		states.add(TargetInstance.STATE_RUNNING);
		states.add(TargetInstance.STATE_PAUSED);
		 tic.setStates(states);
		 List<TargetInstance> runningTIs = targetInstanceDao.findTargetInstances(tic);
		 runningTIs.add(aTargetInstance);
		 return calculateBandwidthAllocation(runningTIs);
	 }
	 private HashMap<Long, TargetInstance> calculateBandwidthAllocation() {
		 TargetInstanceCriteria tic = new TargetInstanceCriteria();
		 Set<String> states = new HashSet<String>();
		states.add(TargetInstance.STATE_RUNNING);
		states.add(TargetInstance.STATE_PAUSED);
		 tic.setStates(states);
		 List<TargetInstance> runningTIs = targetInstanceDao.findTargetInstances(tic);
		 return calculateBandwidthAllocation(runningTIs);
	 }
	 private HashMap<Long, TargetInstance> calculateBandwidthAllocation(List<TargetInstance> aRunningTargetInstances) {
		 HashMap<Long, TargetInstance> results = new HashMap<Long, TargetInstance>();
		 long maxBandwidth = getCurrentGlobalMaxBandwidth();
		 BandwidthCalculator.calculateBandwidthAllocation(aRunningTargetInstances, maxBandwidth, maxBandwidthPercent);
		 return results;
	 }
	 public long getCurrentGlobalMaxBandwidth() {
		 return getGlobalMaxBandwidth(0);
	 }
	 private long getGlobalMaxBandwidth(int aMillisBeforeNow) {
		 try {
			 Calendar now = Calendar.getInstance();
			 now.add(Calendar.MILLISECOND, (aMillisBeforeNow * -1));
			 String time = BandwidthRestriction.TIMEONLY_FORMAT.format(now.getTime());
			 Date date = BandwidthRestriction.FULLDATE_FORMAT.parse(BandwidthRestriction.DEFAULT_DATE + time);
			 String day = BandwidthRestriction.FULLDAY_FORMAT.format(now.getTime()).toUpperCase();
			 BandwidthRestriction br = harvestCoordinatorDao.getBandwidthRestriction(day, date);
			 if (br != null) {
				 return br.getBandwidth();
			 }
		 }
		 catch (ParseException e) {
			 if (log.isErrorEnabled()) {
				 log.error(""Failed to parse the date for the bandwith restriction : "" + e.getMessage(), e);
			 }
		 }
		 return 0;
	 }
	 public HashMap<String, HarvestAgentStatusDTO> getHarvestAgents() {
		 return harvestAgents;
	 }
	 protected HarvestAgentStatusDTO getHarvestAgent(String aJobName) {
		 if (harvestAgents == null || harvestAgents.isEmpty()) {
			 return null;
		 }
		 HarvestAgentStatusDTO agent = null;
		 Iterator it2 = null;
		 HarvesterStatusDTO hs = null;
		 Iterator it = harvestAgents.values().iterator();
		 while (it.hasNext()) {
			 agent = (HarvestAgentStatusDTO) it.next();
			 if (agent.getHarvesterStatus() != null && !agent.getHarvesterStatus().isEmpty()) {
				 it2 = agent.getHarvesterStatus().values().iterator();
				 while (it2.hasNext()) {
					 hs = (HarvesterStatusDTO) it2.next();
					 if (hs.getJobName().equals(aJobName)) {
						 return agent;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 public void setHarvestCoordinatorDao(HarvestCoordinatorDAO aHarvestCoordinatorDao) {
		 this.harvestCoordinatorDao = aHarvestCoordinatorDao;
	 }
	 public HashMap<String, List<BandwidthRestriction>> getBandwidthRestrictions() {
		 return harvestCoordinatorDao.getBandwidthRestrictions();
	 }
	 public BandwidthRestriction getBandwidthRestriction(Long aOid) {
		 return harvestCoordinatorDao.getBandwidthRestriction(aOid);
	 }
	 public BandwidthRestriction getBandwidthRestriction(String aDay, Date aTime) {
		 return harvestCoordinatorDao.getBandwidthRestriction(aDay, aTime);
	 }
	 public void saveOrUpdate(BandwidthRestriction aBandwidthRestriction) {
		 boolean isNew = aBandwidthRestriction.getOid() == null;
		 harvestCoordinatorDao.saveOrUpdate(aBandwidthRestriction);
		 if(isNew) {
			 auditor.audit(BandwidthRestriction.class.getName(), aBandwidthRestriction.getOid(), Auditor.ACTION_NEW_BANDWIDTH_RESTRICTION, ""New bandwidth restriction: "" + aBandwidthRestriction.toString());
		 }
		 else {
			 auditor.audit(BandwidthRestriction.class.getName(), aBandwidthRestriction.getOid(), Auditor.ACTION_CHANGE_BANDWIDTH_RESTRICTION, ""Bandwidth setting changed to: "" + aBandwidthRestriction.toString());
		 }
	 }
	 public void delete(BandwidthRestriction aBandwidthRestriction) {
		 auditor.audit(BandwidthRestriction.class.getName(), null, Auditor.ACTION_DELETE_BANDWIDTH_RESTRICTION, ""Deleted bandwidth restriction: "" + aBandwidthRestriction.toString());
		 harvestCoordinatorDao.delete(aBandwidthRestriction);
	 }
	 public void setMinimumBandwidth(int aMinimumBandwidth) {
		 if (aMinimumBandwidth <= 0) {
			 aMinimumBandwidth = 1;
		 }
		 this.minimumBandwidth = aMinimumBandwidth;
	 }
	 public void setTargetInstanceDao(TargetInstanceDAO targetInstanceDao) {
		 this.targetInstanceDao = targetInstanceDao;
	 }
	 public int getMaxBandwidthPercent() {
		 return maxBandwidthPercent;
	 }
	 public void setMaxBandwidthPercent(int maxBandwidthPercent) {
		 this.maxBandwidthPercent = maxBandwidthPercent;
	 }
	 public void setHarvestAgentFactory(HarvestAgentFactory harvestAgentFactory) {
		 this.harvestAgentFactory = harvestAgentFactory;
	 }
	 public void updateProfileOverrides(TargetInstance aTargetInstance) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided."");
		 }
		 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
		 if (status == null) {
			 if (log.isWarnEnabled()) {
				 log.warn(""Update Profile Overrides Failed. Failed to find the Harvest Agent for the Job "" + aTargetInstance.getJobName() + ""."");
			 }
			 return;
		 }
		 String profile = getHarvestProfileString(aTargetInstance);
		 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(status.getHost(), status.getPort());
		 agent.updateProfileOverrides(aTargetInstance.getJobName(), profile);
	 }
	 public void pause(TargetInstance aTargetInstance) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the harvest command."");
		 }
		 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
		 if (status == null) {
			 if (log.isWarnEnabled()) {
				 log.warn(""PAUSE Failed. Failed to find the Harvest Agent for the Job "" + aTargetInstance.getJobName() + ""."");
			 }
			 return;
		 }
		 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(status.getHost(), status.getPort());
		 aTargetInstance.setState(TargetInstance.STATE_PAUSED);
		 targetInstanceDao.save(aTargetInstance);
		 agent.pause(aTargetInstance.getJobName());
	 }
	 public void resume(TargetInstance aTargetInstance) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the harvest command."");
		 }
		 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
		 if (status == null) {
			 if (log.isWarnEnabled()) {
				 log.warn(""RESUME Failed. Failed to find the Harvest Agent for the Job "" + aTargetInstance.getJobName() + ""."");
			 }
			 return;
		 }
		 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(status.getHost(), status.getPort());
		 aTargetInstance.setState(TargetInstance.STATE_RUNNING);
		 targetInstanceManager.save(aTargetInstance);
		 agent.resume(aTargetInstance.getJobName());
		 sendBandWidthRestrictions();
	 }
	 public void abort(TargetInstance aTargetInstance) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the harvest command."");
		 }
		 aTargetInstance.setState(TargetInstance.STATE_ABORTED);
		 targetInstanceDao.save(aTargetInstance);
		 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
		 if (status == null) {
			 if (log.isWarnEnabled()) {
				 log.warn(""ABORT Failed. Failed to find the Harvest Agent for the Job "" + aTargetInstance.getJobName() + ""."");
			 }
		 }
		 else {
			 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(status.getHost(), status.getPort());
			 try {
				agent.abort(aTargetInstance.getJobName());
			}
			 catch (RuntimeException e) {
				 if (log.isWarnEnabled()) {
					 log.warn(""ABORT Failed. Failed Abort the Job "" + aTargetInstance.getJobName() + "" on the Harvest Agent "" + agent.getName() + ""."");
				 }
			}
		 }
		 sendBandWidthRestrictions();
	 }
	 public void stop(TargetInstance aTargetInstance) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the harvest command."");
		 }
		 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
		 if (status == null) {
			 if (log.isWarnEnabled()) {
				 log.warn(""STOP Failed. Failed to find the Harvest Agent for the Job "" + aTargetInstance.getJobName() + ""."");
			 }
			 return;
		 }
		 HarvestAgent agent = harvestAgentFactory.getHarvestAgent(status.getHost(), status.getPort());
		 agent.stop(aTargetInstance.getJobName());
	 }
	 public void pauseAll() {
		 HarvestAgentStatusDTO agentDTO = null;
		 HarvestAgent agent = null;
		 Iterator it = harvestAgents.values().iterator();
		 while (it.hasNext()) {
			 agentDTO = (HarvestAgentStatusDTO) it.next();
			 if (agentDTO.getHarvesterStatus() != null && !agentDTO.getHarvesterStatus().isEmpty()) {
				 agent = harvestAgentFactory.getHarvestAgent(agentDTO.getHost(), agentDTO.getPort());
				 agent.pauseAll();
			 }
		 }
	}
	public void resumeAll() {
		HarvestAgentStatusDTO agentDTO = null;
		 HarvestAgent agent = null;
		 Iterator it = harvestAgents.values().iterator();
		 while (it.hasNext()) {
			 agentDTO = (HarvestAgentStatusDTO) it.next();
			 if (agentDTO.getHarvesterStatus() != null && !agentDTO.getHarvesterStatus().isEmpty()) {
				 agent = harvestAgentFactory.getHarvestAgent(agentDTO.getHost(), agentDTO.getPort());
				 agent.resumeAll();
			 }
		 }
	}
	 public void pauseQueue() {
		 queuePaused = true;
	 }
	 public void resumeQueue() {
		 queuePaused = false;
	 }
	 public boolean isQueuePaused() {
		 return queuePaused;
	 }
	public void processSchedule() {
		long now = System.currentTimeMillis();
		List<QueuedTargetInstanceDTO> theQueue = targetInstanceDao.getQueue();
		if (log.isDebugEnabled()) {
			log.debug(""Start: Processing "" + theQueue.size() + "" entries from the queue."");
		}
		QueuedTargetInstanceDTO ti = null;
		Iterator<QueuedTargetInstanceDTO> it = theQueue.iterator();
		while (it.hasNext()) {
			ti = it.next();
			harvestOrQueue(ti);
		}
		if (log.isDebugEnabled()) {
			log.debug(""Finished: Processing "" + theQueue.size() + "" entries from the queue. Took "" + (System.currentTimeMillis() - now) + ""ms"");
		}
	}
	public void harvestOrQueue(QueuedTargetInstanceDTO aTargetInstance) {
		TargetInstance ti = null;
		boolean approved = false;
		if (TargetInstance.STATE_SCHEDULED.equals(aTargetInstance.getState())) {
			ti = targetInstanceDao.load(aTargetInstance.getOid());
			ti = targetInstanceDao.populate(ti);
			approved = isTargetApproved(ti);
		}
		else {
			approved = true;
		}
		if (approved) {
			boolean processed = false;
			while (!processed) {
				HarvestAgentStatusDTO agent = getHarvester(aTargetInstance.getAgencyName());
				if (!queuePaused &&isMiniumBandwidthAvailable(aTargetInstance) && agent != null) {
					synchronized (agent) {
						if (ti == null) {
							ti = targetInstanceDao.load(aTargetInstance.getOid());
							ti = targetInstanceDao.populate(ti);
						}
						try {
							if(!TargetInstance.STATE_QUEUED.equals(ti.getState())) {
								prepareHarvest(ti);
							}
							_harvest(ti, agent);
							agent.setInTransition(true);
							processed = true;
						}
						 catch (Throwable e) {
							if (log.isWarnEnabled()) {
								log.warn(""Failed to allocate harvest to agent "" + agent.getName() + "": "" + e.getMessage(), e);
							}
							harvestAgents.remove(agent.getName());
						}
					}
				}
				else {
					processed = true;
					if (!aTargetInstance.getState().equals(TargetInstance.STATE_QUEUED)) {
						if (ti == null) {
							ti = targetInstanceDao.load(aTargetInstance.getOid());
							ti = targetInstanceDao.populate(ti);
						}
						prepareHarvest(ti);
						ti.setState(TargetInstance.STATE_QUEUED);
						targetInstanceDao.save(ti);
						 inTrayManager.generateNotification(ti.getOwner().getOid(), MessageType.CATEGORY_MISC, MessageType.TARGET_INSTANCE_QUEUED, ti);
					 }
				}
			}
		}
	}
	private boolean isTargetApproved(TargetInstance aTargetInstance) {
		if (!targetManager.isTargetHarvestable(aTargetInstance)) {
			Calendar cal = Calendar.getInstance();
			cal.setTime(aTargetInstance.getScheduledTime());
			cal.add(Calendar.DATE, 1);
			aTargetInstance.setScheduledTime(cal.getTime());
			targetInstanceDao.save(aTargetInstance);
			if (log.isInfoEnabled()) {
				log.info(""The target "" + aTargetInstance.getTarget().getName() + "" is not apporoved for harvest and has been defered 24 hours."");
			}
			 inTrayManager.generateNotification(aTargetInstance.getOwner().getOid(), MessageType.CATEGORY_MISC, MessageType.TARGET_INSTANCE_RESCHEDULED, aTargetInstance);
			return false;
		}
		return true;
	}
	private HarvestAgentStatusDTO getHarvester(String aAgencyName) {
		HarvestAgentStatusDTO selectedAgent = null;
		HarvestAgentStatusDTO agent = null;
		Iterator<HarvestAgentStatusDTO> it = harvestAgents.values().iterator();
		while (it.hasNext()) {
			agent = (HarvestAgentStatusDTO) it.next();
			if (agent.getAllowedAgencies() == null || agent.getAllowedAgencies().isEmpty() || agent.getAllowedAgencies().contains(aAgencyName)) {
				if (selectedAgent == null || agent.getHarvesterStatusCount() < selectedAgent.getHarvesterStatusCount()) {
					if ( !agent.getMemoryWarning() && !agent.isInTransition() && agent.getHarvesterStatusCount() < agent.getMaxHarvests()) {
						selectedAgent = agent;
					}
				}
			}
		}
		return selectedAgent;
	}
	private boolean isMiniumBandwidthAvailable(QueuedTargetInstanceDTO aTargetInstance) {
		if (null == aTargetInstance) {
			throw new WCTRuntimeException(""The Target Instance passed in was null."");
		}
		if (getCurrentGlobalMaxBandwidth() < minimumBandwidth) {
			return false;
		}
		TargetInstance ti = targetInstanceDao.load(aTargetInstance.getOid());
		ti = targetInstanceDao.populate(ti);
		 return isMiniumBandwidthAvailable(ti);
	}
	public boolean isMiniumBandwidthAvailable(TargetInstance aTargetInstance) {
		if (null == aTargetInstance) {
			throw new WCTRuntimeException(""The Target Instance passed in was null."");
		}
		if (getCurrentGlobalMaxBandwidth() < minimumBandwidth) {
			return false;
		}
		TargetInstance ti = targetInstanceDao.load(aTargetInstance.getOid());
		ti = targetInstanceDao.populate(ti);
		HashMap targetInstances = null;
		if (TargetInstance.STATE_PAUSED.equals(ti.getState())) {
			targetInstances = calculateBandwidthAllocation();
		}
		else {
			targetInstances = calculateBandwidthAllocation(ti);
		}
		 if (ti.getBandwidthPercent() == null) {
			 if (ti.getAllocatedBandwidth() < minimumBandwidth) {
				 return false;
			 }
		 }
		 else {
			 TargetInstance ati = null;
			 Iterator it = targetInstances.values().iterator();
			 while (it.hasNext()) {
				 ati = (TargetInstance) it.next();
				 if (ati.getBandwidthPercent() == null) {
					 if (ati.getAllocatedBandwidth() < minimumBandwidth) {
						 return false;
					 }
				 }
			 }
		 }
		 return true;
	}
	public List<String> listLogFiles(TargetInstance aTargetInstance) {
		 if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the listLogFiles command."");
		 }
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""list Log Files Failed. Failed to find the Log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return new ArrayList<String>();
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.listLogFiles(aTargetInstance.getJobName());
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.listLogFiles(aTargetInstance.getJobName());
		 }
	}
	public LogFilePropertiesDTO[] listLogFileAttributes(TargetInstance aTargetInstance) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the listLogFileAttributes command."");
		 }
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""listLogFileAttributes Failed. Failed to find the Log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 LogFilePropertiesDTO[] empty = new LogFilePropertiesDTO[0];
				 return empty;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.listLogFileAttributes(aTargetInstance.getJobName());
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.listLogFileAttributes(aTargetInstance.getJobName());
		 }
	}
	public String[] tailLog(TargetInstance aTargetInstance, String aFileName, int aNoOfLines) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the tailLog command."");
		 }
		String[] data = {
		""""}
		;
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Tail Log Files Failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return data;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.tail(aTargetInstance.getJobName(), aFileName, aNoOfLines);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.tail(aTargetInstance.getJobName(), aFileName, aNoOfLines);
		 }
	}
	public Integer countLogLines(TargetInstance aTargetInstance, String aFileName) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the countLogLines command."");
		 }
		Integer count = 0;
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Count Log Lines Failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return count;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.countLines(aTargetInstance.getJobName(), aFileName);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.countLines(aTargetInstance.getJobName(), aFileName);
		 }
	}
	public String[] headLog(TargetInstance aTargetInstance, String aFileName, int aNoOfLines) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the headLog command."");
		 }
		String[] data = {
		""""}
		;
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Head Log Files Failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return data;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.get(aTargetInstance.getJobName(), aFileName, 1, aNoOfLines);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.get(aTargetInstance.getJobName(), aFileName, 1, aNoOfLines);
		 }
	}
	public String[] getLog(TargetInstance aTargetInstance, String aFileName, int aStartLine, int aNoOfLines) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the getLog command."");
		 }
		String[] data = {
		""""}
		;
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Get Log Files Failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return data;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.get(aTargetInstance.getJobName(), aFileName, aStartLine, aNoOfLines);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.get(aTargetInstance.getJobName(), aFileName, aStartLine, aNoOfLines);
		 }
	}
	 public Integer getFirstLogLineBeginning(TargetInstance aTargetInstance, String aFileName, String match) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the getFirstLogLineBeginning command."");
		 }
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Get First Log Line Beginning failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return new Integer(0);
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.findFirstLineBeginning(aTargetInstance.getJobName(), aFileName, match);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.findFirstLineBeginning(aTargetInstance.getJobName(), aFileName, match);
		 }
	}
	 public Integer getFirstLogLineContaining(TargetInstance aTargetInstance, String aFileName, String match) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the getFirstLogLineContaining command."");
		 }
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Get First Log Line Containing failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return new Integer(0);
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.findFirstLineContaining(aTargetInstance.getJobName(), aFileName, match);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.findFirstLineContaining(aTargetInstance.getJobName(), aFileName, match);
		 }
	}
	 public Integer getFirstLogLineAfterTimeStamp(TargetInstance aTargetInstance, String aFileName, Long timestamp) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the getFirstLogLineAfterTimeStamp command."");
		 }
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Get First Log Line After Timestamp failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return new Integer(0);
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.findFirstLineAfterTimeStamp(aTargetInstance.getJobName(), aFileName, timestamp);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.findFirstLineAfterTimeStamp(aTargetInstance.getJobName(), aFileName, timestamp);
		 }
	}
	public String[] getLogLinesByRegex(TargetInstance aTargetInstance, String aFileName, int aNoOfLines, String aRegex, boolean prependLineNumbers) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the regex command."");
		 }
		String[] data = {
		""""}
		;
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Get log lines by regex failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return data;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.getByRegExpr(aTargetInstance.getJobName(), aFileName, aRegex, ""zzzzzzzzz"", prependLineNumbers, 0, aNoOfLines);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.getByRegExpr(aTargetInstance.getJobName(), aFileName, aRegex, ""zzzzzzzz"", prependLineNumbers, 0, aNoOfLines);
		 }
	}
	public String[] getHopPath(TargetInstance aTargetInstance, String aFileName, String aUrl) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the getHopPath command."");
		 }
		String[] data = {
		""""}
		;
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Get Log Files Failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return data;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.getHopPath(aTargetInstance.getJobName(), aTargetInstance.getHarvestResult(1).getOid().toString(), aFileName, aUrl);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.getHopPath(aTargetInstance.getJobName(), aTargetInstance.getHarvestResult(1).getOid().toString(), aFileName, aUrl);
		 }
	}
	public void purgeDigitalAssets() {
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DATE, daysBeforeDASPurge * -1);
		List<TargetInstance> tis = targetInstanceDao.findPurgeableTargetInstances(cal.getTime());
		if (log.isDebugEnabled()) {
			log.debug(""Attempting to purge "" + tis.size() + "" harvests from the digital asset store."");
		}
		if (tis != null && !tis.isEmpty()) {
			int index = 0;
			String[] tiNames = new String[tis.size()];
			for (TargetInstance ti : tis) {
				tiNames[index++] = ti.getJobName();
			}
			try {
				digitalAssetStoreFactory.getDAS().purge(tiNames);
				for (TargetInstance ti : tis) {
					targetInstanceManager.purgeTargetInstance(ti);
				}
			}
			 catch (DigitalAssetStoreException e) {
				if (log.isErrorEnabled()) {
					log.error(""Failed to complete the purge "" + e.getMessage(), e);
				}
			}
		}
	}
	public void purgeAbortedTargetInstances() {
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DATE, daysBeforeAbortedTargetInstancePurge * -1);
		List<TargetInstance> tis = targetInstanceDao.findPurgeableAbortedTargetInstances(cal.getTime());
		if (log.isDebugEnabled()) {
			log.debug(""Attempting to purge "" + tis.size() + "" aborted harvests from the system."");
		}
		if (tis != null && !tis.isEmpty()) {
			int index = 0;
			String[] tiNames = new String[tis.size()];
			for (TargetInstance ti : tis) {
				tiNames[index++] = ti.getJobName();
			}
			HarvestAgentSOAPClient ha = new HarvestAgentSOAPClient();
			ha.setHost(harvestAgentConfig.getHost());
			ha.setPort(harvestAgentConfig.getPort());
			ha.setService(harvestAgentConfig.getHarvestAgentServiceName());
			try {
				ha.purgeAbortedTargetInstances(tiNames);
			}
			 catch (Exception e) {
				if (log.isErrorEnabled()) {
					log.error(""Failed to complete the purge of aborted ti data via HA: "" + e.getMessage(), e);
				}
			}
			try {
				digitalAssetStoreFactory.getDAS().purgeAbortedTargetInstances(tiNames);
			}
			 catch (DigitalAssetStoreException e) {
				if (log.isErrorEnabled()) {
					log.error(""Failed to complete the purge of aborted ti data via DAS: "" + e.getMessage(), e);
				}
			}
			try {
				for (TargetInstance ti : tis) {
					targetInstanceManager.purgeTargetInstance(ti);
				}
			}
			 catch (Exception e) {
				if (log.isErrorEnabled()) {
					log.error(""Failed to set the purged flag on all of the eligible aborted TIs: "" + e.getMessage(), e);
				}
			}
		}
	}
	public void setDigitalAssetStoreFactory( DigitalAssetStoreFactory digitalAssetStoreFactory) {
		this.digitalAssetStoreFactory = digitalAssetStoreFactory;
	}
	public void setHarvestAgentConfig( HarvestAgentConfig harvestAgentConfig) {
		this.harvestAgentConfig = harvestAgentConfig;
	}
	public void setTargetManager(TargetManager targetManager) {
		this.targetManager = targetManager;
	}
	 public void setInTrayManager(InTrayManager inTrayManager) {
		 this.inTrayManager = inTrayManager;
	 }
	public void setDaysBeforeDASPurge(int daysBeforeDASPurge) {
		this.daysBeforeDASPurge = daysBeforeDASPurge;
	}
	public void setDaysBeforeAbortedTargetInstancePurge(int daysBeforeAbortedTargetInstancePurge) {
		this.daysBeforeAbortedTargetInstancePurge = daysBeforeAbortedTargetInstancePurge;
	}
	public void setAuditor(Auditor auditor) {
		this.auditor = auditor;
	}
	public File getLogfile(TargetInstance aTargetInstance, String aFilename) {
		if (aTargetInstance == null) {
			 throw new WCTRuntimeException(""A null target instance was provided to the tail command."");
		 }
		 if (aTargetInstance.getState().equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED)) {
			 HarvestAgentStatusDTO status = getHarvestAgent(aTargetInstance.getJobName());
			 if (status == null) {
				 if (log.isWarnEnabled()) {
					 log.warn(""Tail Log Files Failed. Failed to find the log Reader for the Job "" + aTargetInstance.getJobName() + ""."");
				 }
				 return null;
			 }
			 LogReader logReader = harvestAgentFactory.getLogReader(status.getHost(), status.getPort());
			 return logReader.retrieveLogfile(aTargetInstance.getJobName(), aFilename);
		 }
		 else {
			 LogReader logReader = digitalAssetStoreFactory.getLogReader();
			 return logReader.retrieveLogfile(aTargetInstance.getJobName(), aFilename);
		 }
	}
	public void setSipBuilder(SipBuilder sipBuilder) {
		this.sipBuilder = sipBuilder;
	}
	public void addToHarvestResult(Long harvestResultOid, ArcHarvestFileDTO ahf) {
		ArcHarvestResult ahr = (ArcHarvestResult) targetInstanceDao.getHarvestResult(harvestResultOid, false);
		ArcHarvestFile f = new ArcHarvestFile(ahf, ahr);
		targetInstanceDao.save(f);
	}
	public void addHarvestResources(Long harvestResultOid, Collection<HarvestResourceDTO> dtos) {
		 ArcHarvestResult ahr = (ArcHarvestResult) targetInstanceDao.getHarvestResult(harvestResultOid, false);
		Collection<ArcHarvestResource> resources = new ArrayList<ArcHarvestResource>(dtos.size());
		for(HarvestResourceDTO dto : dtos) {
			 resources.add(new ArcHarvestResource( (ArcHarvestResourceDTO) dto, ahr));
		}
		targetInstanceDao.saveAll(resources);
	}
	public Long createHarvestResult(HarvestResultDTO harvestResultDTO) {
		if(harvestResultDTO instanceof ArcHarvestResultDTO) {
			TargetInstance ti = targetInstanceDao.load(harvestResultDTO.getTargetInstanceOid());
			ArcHarvestResult result = new ArcHarvestResult((ArcHarvestResultDTO)harvestResultDTO, ti);
			ti.getHarvestResults().add(result);
			result.setState(HarvestResult.STATE_INDEXING);
			targetInstanceDao.save(result);
			return result.getOid();
		}
		else {
			throw new IllegalArgumentException(""Only supports ArcHarvestResults"");
		}
	}
	public void finaliseIndex(Long harvestResultOid) {
		ArcHarvestResult ahr = (ArcHarvestResult) targetInstanceDao.getHarvestResult(harvestResultOid, false);
		ahr.setState(0);
		triggerAutoQA(ahr);
		targetInstanceDao.save(ahr);
	}
	public void notifyAQAComplete(String aqaId){
		log.debug(""Received notifyAQAComplete for job(""+aqaId+"")."");
		try{
			String[] ids = aqaId.split(""-"");
			long tiOid = Long.parseLong(ids[0]);
			 TargetInstance ti = targetInstanceDao.load(tiOid);
			int harvestNumber = Integer.parseInt(ids[1]);
			HarvestResult result = ti.getHarvestResult(harvestNumber);
			inTrayManager.generateNotification(ti.getOwner().getOid(), MessageType.CATEGORY_MISC, MessageType.NOTIFICATION_AQA_COMPLETE, result);
		}
		catch(Exception e){
			log.error(""Unable to notify AQA Id: ""+aqaId, e);
		}
	}
	private void triggerAutoQA(ArcHarvestResult ahr){
		 TargetInstance ti = ahr.getTargetInstance();
		 if(autoQAUrl != null && autoQAUrl.length() > 0 && ti.isUseAQA()){
			 GetMethod getMethod = new GetMethod(autoQAUrl);
			 String primarySeed = """";
			 Set<Seed> seeds = ti.getTarget().getSeeds();
			 Iterator<Seed> it = seeds.iterator();
			 while(it.hasNext()) {
				 Seed seed = it.next();
				 if(seed.isPrimary()) {
					 primarySeed = seed.getSeed();
					 break;
				 }
			 }
			 NameValuePair[] params = {
			new NameValuePair(""targetInstanceId"", ti.getOid().toString()), new NameValuePair(""harvestNumber"", Integer.toString(ahr.getHarvestNumber())), new NameValuePair(""primarySeed"", primarySeed)}
			;
			 getMethod.setQueryString(params);
			 HttpClient client = new HttpClient();
			 try {
				 int result = client.executeMethod(getMethod);
				 if(result != HttpURLConnection.HTTP_OK) {
					 log.error(""Unable to initiate Auto QA. Response at ""+autoQAUrl+"" is ""+result);
				 }
			 }
			 catch(Exception e) {
				 log.error(""Unable to initiate Auto QA."", e);
			 }
		}
	}
	public void removeIndexes(TargetInstance ti){
		List<HarvestResult> results = ti.getHarvestResults();
		if(results != null){
			Iterator<HarvestResult> it = results.iterator();
			while(it.hasNext()){
				HarvestResult hr = it.next();
				if(hr.getState() != HarvestResult.STATE_REJECTED){
					removeIndexes(hr);
				}
			}
		}
	}
	public void removeIndexes(HarvestResult hr){
		DigitalAssetStore das = digitalAssetStoreFactory.getDAS();
		try {
			log.info(""Attempting to remove indexes for TargetInstance ""+hr.getTargetInstance().getOid()+"" HarvestNumber ""+hr.getHarvestNumber());
			das.initiateRemoveIndexes(new ArcHarvestResultDTO(hr.getOid(), hr.getTargetInstance().getOid(), hr.getCreationDate(), hr.getHarvestNumber(), hr.getProvenanceNote()));
		}
		 catch (DigitalAssetStoreException e) {
			if (log.isErrorEnabled()) {
				log.error(""Could not send initiateRemoveIndexes message to the DAS for TargetInstance ""+hr.getTargetInstance().getOid()+"" HarvestNumber ""+hr.getHarvestNumber()+"": "" + e.getMessage(), e);
			}
		}
	}
	public void completeArchiving(Long targetInstanceOid, String archiveIID) {
		TargetInstance ti = targetInstanceDao.load(targetInstanceOid);
		ti.setArchiveIdentifier(archiveIID);
		ti.setArchivedTime(new Date());
		ti.setState(TargetInstance.STATE_ARCHIVED);
		targetInstanceManager.save(ti);
		removeIndexes(ti);
		inTrayManager.generateNotification(ti.getOwner().getOid(), MessageType.CATEGORY_MISC, MessageType.NOTIFICATION_ARCHIVE_SUCCESS, ti);
	}
	public void failedArchiving(Long targetInstanceOid, String message) {
		TargetInstance ti = targetInstanceDao.load(targetInstanceOid);
		ti.setState(TargetInstance.STATE_ENDORSED);
		targetInstanceManager.save(ti);
		log.error(""Failed to archive - trying to send message"");
		inTrayManager.generateNotification(ti.getOwner().getOid(), MessageType.CATEGORY_MISC, ""subject.archived.failed"", new Object[] {
		ti.getTarget().getName(), ti.getResourceName()}
		, ""message.archived.failed"", new Object[] {
		ti.getTarget().getName(), ti.getResourceName(), message}
		,ti, true);
	}
	public void setTargetInstanceManager(TargetInstanceManager targetInstanceManager) {
		this.targetInstanceManager = targetInstanceManager;
	}
	public void setAutoQAUrl(String autoQAUrl) {
		this.autoQAUrl = autoQAUrl;
	}
	public String getAutoQAUrl() {
		return autoQAUrl;
	}
}",1,0,0,0
"public final class SwiftUtils {
	 public static final String READ = ""read(buffer, offset, length)"";
	 public static String joinPaths(String path1, String path2) {
		 StringBuilder result = new StringBuilder(path1.length() + path2.length() + 1);
		 result.append(path1);
		 boolean insertSlash = true;
		 if (path1.endsWith(""/"")) {
			 insertSlash = false;
		 }
		 else if (path2.startsWith(""/"")) {
			 insertSlash = false;
		 }
		 if (insertSlash) {
			 result.append(""/"");
		 }
		 result.append(path2);
		 return result.toString();
	 }
	 public static boolean isDirectory(FileStatus fileStatus) {
		 return fileStatus.isDirectory() || isFilePretendingToBeDirectory(fileStatus);
	 }
	 public static boolean isFilePretendingToBeDirectory(FileStatus fileStatus) {
		 return fileStatus.getLen() == 0;
	 }
	 public static boolean isRootDir(SwiftObjectPath swiftObject) {
		 return swiftObject.objectMatches("""") || swiftObject.objectMatches(""/"");
	 }
	 public static void debug(Logger log, String text, Object... args) {
		 if (log.isDebugEnabled()) {
			 log.debug(String.format(text, args));
		 }
	 }
	 public static void debugEx(Logger log, String text, Exception ex) {
		 if (log.isDebugEnabled()) {
			 log.debug(text + ex, ex);
		 }
	 }
	 public static void trace(Logger log, String text, Object... args) {
		 if (log.isTraceEnabled()) {
			 log.trace(String.format(text, args));
		 }
	 }
	 public static String partitionFilenameFromNumber(int partNumber) {
		 return String.format(""%06d"", partNumber);
	 }
	 public static String ls(FileSystem fileSystem, Path path) throws IOException {
		 if (path == null) {
			 return ""/"";
		 }
		 FileStatus[] stats;
		 String pathtext = ""ls "" + path;
		 try {
			 stats = fileSystem.listStatus(path);
		 }
		 catch (FileNotFoundException e) {
			 return pathtext + "" -file not found"";
		 }
		 catch (IOException e) {
			 return pathtext + "" -failed: "" + e;
		 }
		 return pathtext + fileStatsToString(stats, ""\n"");
	 }
	 public static String fileStatsToString(FileStatus[] stats, String separator) {
		 StringBuilder buf = new StringBuilder(stats.length * 128);
		 for (int i = 0;
		 i < stats.length;
		 i++) {
			 buf.append(String.format(""[%02d] %s"", i, stats[i])).append(separator);
		 }
		 return buf.toString();
	 }
	 public static void validateReadArgs(byte[] buffer, int off, int len) {
		 if (buffer == null) {
			 throw new NullPointerException(""Null byte array in""+ READ);
		 }
		 if (off < 0 ) {
			 throw new IndexOutOfBoundsException(""Negative buffer offset "" + off + "" in "" + READ);
		 }
		 if (len < 0 ) {
			 throw new IndexOutOfBoundsException(""Negative read length "" + len + "" in "" + READ);
		 }
		 if (off > buffer.length) {
			 throw new IndexOutOfBoundsException(""Buffer offset of "" + off + ""beyond buffer size of "" + buffer.length + "" in "" + READ);
		 }
	 }
 }",1,0,0,0
"public class StringFunctions {
	 private static Function<String,String> appendOld(final String suffix) {
		 return new Function<String, String>() {
			 public String apply( String input) {
				 if (input==null) return null;
				 return input + suffix;
			 }
		 }
		;
	 }
	 private static Function<String,String> prependOld(final String prefix) {
		 return new Function<String, String>() {
			 public String apply( String input) {
				 if (input==null) return null;
				 return prefix + input;
			 }
		 }
		;
	 }
	 private static Function<Object, String> formatterOld(final String pattern) {
		 return new Function<Object, String>() {
			 public String apply( Object input) {
				 return String.format(pattern, input);
			 }
		 }
		;
	 }
	 private static Function<Object[], String> formatterForArrayOld(final String pattern) {
		 return new Function<Object[], String>() {
			 public String apply( Object[] input) {
				 return String.format(pattern, input);
			 }
		 }
		;
	 }
	 private static Function<Iterable<?>, String> joinerOld(final String separator) {
		 return new Function<Iterable<?>, String>() {
			 public String apply( Iterable<?> input) {
				 return Strings.join(input, separator);
			 }
		 }
		;
	 }
	 private static Function<Object[], String> joinerForArrayOld(final String separator) {
		 return new Function<Object[], String>() {
			 public String apply( Object[] input) {
				 if (input == null) return Strings.EMPTY;
				 return Strings.join(input, separator);
			 }
		 }
		;
	 }
	 private static Function<String,Integer> lengthOld() {
		 return new Function<String,Integer>() {
			 public Integer apply( String input) {
				 if (input == null) return -1;
				 return input.length();
			 }
		 }
		;
	 }
	 private static Function<String,String> surroundOld(final String prefix, final String suffix) {
		 return new Function<String,String>() {
			 public String apply( String input) {
				 if (input == null) return null;
				 return prefix+input+suffix;
			 }
		 }
		;
	 }
	 private static Function<String, String> trimOld() {
		 return new Function<String, String>() {
			 public String apply( String input) {
				 if (input == null) return null;
				 if (Strings.isBlank(input)) return Strings.EMPTY;
				 return CharMatcher.BREAKING_WHITESPACE.trimFrom(input);
			 }
		 }
		;
	 }
	 private static Function<String, String> toLowerCaseOld() {
		 return new Function<String, String>() {
			 public String apply(String input) {
				 return input.toLowerCase();
			 }
		 }
		;
	 }
	 private static Function<String, String> toUpperCaseOld() {
		 return new Function<String, String>() {
			 public String apply(String input) {
				 return input.toUpperCase();
			 }
		 }
		;
	 }
	 private static Function<String, String> convertCaseOld(final CaseFormat src, final CaseFormat target) {
		 return new Function<String, String>() {
			 public String apply(String input) {
				 return src.to(target, input);
			 }
		 }
		;
	 }
	 public static Function<String,String> append(final String suffix) {
		 return new AppendFunction(checkNotNull(suffix, ""suffix""));
	 }
	 private static class AppendFunction implements Function<String, String> {
		 private final String suffix;
		 public AppendFunction(String suffix) {
			 this.suffix = suffix;
		 }
		 public String apply( String input) {
			 if (input==null) return null;
			 return input + suffix;
		 }
	 }
	;
	 public static Function<String,String> prepend(final String prefix) {
		 return new PrependFunction(checkNotNull(prefix, ""prefix""));
	 }
	 protected static class PrependFunction implements Function<String, String> {
		 private final String prefix;
		 public PrependFunction(String prefix) {
			 this.prefix = prefix;
		 }
		 public String apply( String input) {
			 if (input==null) return null;
			 return prefix + input;
		 }
	 }
	 public static Function<Object, String> formatter(final String pattern) {
		 return new FormatterFunction(pattern);
	 }
	 protected static class FormatterFunction implements Function<Object, String> {
		 private final String pattern;
		 FormatterFunction(String pattern) {
			 this.pattern = pattern;
		 }
		 public String apply( Object input) {
			 return String.format(pattern, input);
		 }
	 }
	;
	 public static Function<Object[], String> formatterForArray(final String pattern) {
		 return new FormatterForArrayFunction(checkNotNull(pattern, ""pattern""));
	 }
	 protected static class FormatterForArrayFunction implements Function<Object[], String> {
		 private final String pattern;
		 public FormatterForArrayFunction(String pattern) {
			 this.pattern = pattern;
		 }
		 public String apply( Object[] input) {
			 return String.format(pattern, input);
		 }
	 }
	 public static Function<Iterable<?>, String> formatterForIterable(final String pattern) {
		 return new FormatterForIterableFunction(pattern);
	 }
	 protected static class FormatterForIterableFunction implements Function<Iterable<?>, String> {
		 final String pattern;
		 public FormatterForIterableFunction(String pattern) {
			 this.pattern = pattern;
		 }
		 public String apply( Iterable<?> input) {
			 Object[] arr = (input == null) ? null : Iterables.toArray(input, Object.class);
			 return String.format(pattern, arr);
		 }
	 }
	 public static Function<Iterable<?>, String> joiner(final String separator) {
		 return new JoinerFunction(separator);
	 }
	 private static class JoinerFunction implements Function<Iterable<?>, String> {
		 private final String separator;
		 public JoinerFunction(String separator) {
			 this.separator = separator;
		 }
		 public String apply( Iterable<?> input) {
			 return Strings.join(input, separator);
		 }
	 }
	 public static Function<Object[], String> joinerForArray(final String separator) {
		 return new JoinerForArrayFunction(checkNotNull(separator, ""separator""));
	 }
	 private static class JoinerForArrayFunction implements Function<Object[], String> {
		 private final String separator;
		 protected JoinerForArrayFunction(String separator) {
			 this.separator = separator;
		 }
		 public String apply( Object[] input) {
			 if (input == null) return Strings.EMPTY;
			 return Strings.join(input, separator);
		 }
	 }
	 public static Function<Object,String> toStringFunction() {
		 return Functions.toStringFunction();
	 }
	 public static Function<String,Integer> length() {
		 return new LengthFunction();
	 }
	 protected static class LengthFunction implements Function<String,Integer> {
		 public Integer apply( String input) {
			 if (input == null) return -1;
			 return input.length();
		 }
	 }
	 public static Function<String,String> surround(final String prefix, final String suffix) {
		 Preconditions.checkNotNull(prefix);
		 Preconditions.checkNotNull(suffix);
		 return new SurroundFunction(prefix, suffix);
	 }
	 protected static class SurroundFunction implements Function<String,String> {
		 private final String prefix;
		 private final String suffix;
		 public SurroundFunction(String prefix, String suffix) {
			 this.prefix = prefix;
			 this.suffix = suffix;
		 }
		 public String apply( String input) {
			 if (input == null) return null;
			 return prefix+input+suffix;
		 }
	 }
	 public static Function<String, String> trim() {
		 return new TrimFunction();
	 }
	 protected static class TrimFunction implements Function<String, String> {
		 public String apply( String input) {
			 if (input == null) return null;
			 if (Strings.isBlank(input)) return Strings.EMPTY;
			 return CharMatcher.BREAKING_WHITESPACE.trimFrom(input);
		 }
	 }
	 public static Function<String, String> toLowerCase() {
		 return new LowerCaseFunction();
	 }
	 protected static class LowerCaseFunction implements Function<String, String> {
		 public String apply(String input) {
			 return input.toLowerCase();
		 }
	 }
	 public static Function<String, String> toUpperCase() {
		 return new UpperCaseFunction();
	 }
	 protected static class UpperCaseFunction implements Function<String, String> {
		 public String apply(String input) {
			 return input.toUpperCase();
		 }
	 }
	 public static Function<String, String> convertCase(final CaseFormat src, final CaseFormat target) {
		 return new ConvertCaseFunction(checkNotNull(src, ""src""), checkNotNull(target, ""target""));
	 }
	 protected static class ConvertCaseFunction implements Function<String, String> {
		 private final CaseFormat src;
		 private final CaseFormat target;
		 public ConvertCaseFunction(CaseFormat src, CaseFormat target) {
			 this.src = src;
			 this.target = target;
		 }
		 public String apply(String input) {
			 return src.to(target, input);
		 }
	 }
	 public static class RegexReplacer implements Function<String, String> {
		 private final String pattern;
		 private final String replacement;
		 public RegexReplacer(String pattern, String replacement) {
			 this.pattern = pattern;
			 this.replacement = replacement;
		 }
		 public String apply( String s) {
			 return Strings.replaceAllRegex(s, pattern, replacement);
		 }
	 }
}",1,0,0,0
"public class SortedByFacetOnCollectionFromLayoutProperties extends SortedByFacetAbstract {
	 public static SortedByFacet create(Properties properties, FacetHolder holder) {
		 final Class sortedBy = sortedBy(properties);
		 return sortedBy != null? new SortedByFacetOnCollectionFromLayoutProperties(sortedBy, holder): null;
	 }
	 private SortedByFacetOnCollectionFromLayoutProperties(Class<? extends Comparator<?>> sortedBy, FacetHolder holder) {
		 super(sortedBy, holder);
	 }
	 private static Class<?> sortedBy(Properties properties) {
		 if(properties == null) {
			 return null;
		 }
		 String sortedBy = Strings.emptyToNull(properties.getProperty(""sortedBy""));
		 if (sortedBy == null) {
			 return null;
		 }
		 final Class<?> sortedByClass = ClassUtil.forName(sortedBy);
		 if(sortedByClass == Comparator.class) {
			 return null;
		 }
		 return sortedByClass;
	 }
}",0,0,0,0
"public class DataBinder implements PropertyEditorRegistry, TypeConverter {
	public static final String DEFAULT_OBJECT_NAME = ""target"";
	public static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;
	protected static final Log logger = LogFactory.getLog(DataBinder.class);
	private final Object target;
	private final String objectName;
	private AbstractPropertyBindingResult bindingResult;
	private SimpleTypeConverter typeConverter;
	private boolean ignoreUnknownFields = true;
	private boolean ignoreInvalidFields = false;
	private boolean autoGrowNestedPaths = true;
	private int autoGrowCollectionLimit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;
	private String[] allowedFields;
	private String[] disallowedFields;
	private String[] requiredFields;
	private ConversionService conversionService;
	private MessageCodesResolver messageCodesResolver;
	private BindingErrorProcessor bindingErrorProcessor = new DefaultBindingErrorProcessor();
	private final List<Validator> validators = new ArrayList<>();
	public DataBinder( Object target) {
		this(target, DEFAULT_OBJECT_NAME);
	}
	public DataBinder( Object target, String objectName) {
		this.target = ObjectUtils.unwrapOptional(target);
		this.objectName = objectName;
	}
	public Object getTarget() {
		return this.target;
	}
	public String getObjectName() {
		return this.objectName;
	}
	public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {
		Assert.state(this.bindingResult == null,""DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods"");
		this.autoGrowNestedPaths = autoGrowNestedPaths;
	}
	public boolean isAutoGrowNestedPaths() {
		return this.autoGrowNestedPaths;
	}
	public void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) {
		Assert.state(this.bindingResult == null,""DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods"");
		this.autoGrowCollectionLimit = autoGrowCollectionLimit;
	}
	public int getAutoGrowCollectionLimit() {
		return this.autoGrowCollectionLimit;
	}
	public void initBeanPropertyAccess() {
		Assert.state(this.bindingResult == null,""DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods"");
		this.bindingResult = createBeanPropertyBindingResult();
	}
	protected AbstractPropertyBindingResult createBeanPropertyBindingResult() {
		BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());
		if (this.conversionService != null) {
			result.initConversion(this.conversionService);
		}
		if (this.messageCodesResolver != null) {
			result.setMessageCodesResolver(this.messageCodesResolver);
		}
		return result;
	}
	public void initDirectFieldAccess() {
		Assert.state(this.bindingResult == null,""DataBinder is already initialized - call initDirectFieldAccess before other configuration methods"");
		this.bindingResult = createDirectFieldBindingResult();
	}
	protected AbstractPropertyBindingResult createDirectFieldBindingResult() {
		DirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(),getObjectName(), isAutoGrowNestedPaths());
		if (this.conversionService != null) {
			result.initConversion(this.conversionService);
		}
		if (this.messageCodesResolver != null) {
			result.setMessageCodesResolver(this.messageCodesResolver);
		}
		return result;
	}
	protected AbstractPropertyBindingResult getInternalBindingResult() {
		if (this.bindingResult == null) {
			initBeanPropertyAccess();
		}
		return this.bindingResult;
	}
	protected ConfigurablePropertyAccessor getPropertyAccessor() {
		return getInternalBindingResult().getPropertyAccessor();
	}
	protected SimpleTypeConverter getSimpleTypeConverter() {
		if (this.typeConverter == null) {
			this.typeConverter = new SimpleTypeConverter();
			if (this.conversionService != null) {
				this.typeConverter.setConversionService(this.conversionService);
			}
		}
		return this.typeConverter;
	}
	protected PropertyEditorRegistry getPropertyEditorRegistry() {
		if (getTarget() != null) {
			return getInternalBindingResult().getPropertyAccessor();
		}
		else {
			return getSimpleTypeConverter();
		}
	}
	protected TypeConverter getTypeConverter() {
		if (getTarget() != null) {
			return getInternalBindingResult().getPropertyAccessor();
		}
		else {
			return getSimpleTypeConverter();
		}
	}
	public BindingResult getBindingResult() {
		return getInternalBindingResult();
	}
	public void setIgnoreUnknownFields(boolean ignoreUnknownFields) {
		this.ignoreUnknownFields = ignoreUnknownFields;
	}
	public boolean isIgnoreUnknownFields() {
		return this.ignoreUnknownFields;
	}
	public void setIgnoreInvalidFields(boolean ignoreInvalidFields) {
		this.ignoreInvalidFields = ignoreInvalidFields;
	}
	public boolean isIgnoreInvalidFields() {
		return this.ignoreInvalidFields;
	}
	public void setAllowedFields( String... allowedFields) {
		this.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields);
	}
	public String[] getAllowedFields() {
		return this.allowedFields;
	}
	public void setDisallowedFields( String... disallowedFields) {
		this.disallowedFields = PropertyAccessorUtils.canonicalPropertyNames(disallowedFields);
	}
	public String[] getDisallowedFields() {
		return this.disallowedFields;
	}
	public void setRequiredFields( String... requiredFields) {
		this.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields);
		if (logger.isDebugEnabled()) {
			logger.debug(""DataBinder requires binding of required fields ["" +StringUtils.arrayToCommaDelimitedString(requiredFields) + ""]"");
		}
	}
	public String[] getRequiredFields() {
		return this.requiredFields;
	}
	public void setMessageCodesResolver( MessageCodesResolver messageCodesResolver) {
		Assert.state(this.messageCodesResolver == null, ""DataBinder is already initialized with MessageCodesResolver"");
		this.messageCodesResolver = messageCodesResolver;
		if (this.bindingResult != null && messageCodesResolver != null) {
			this.bindingResult.setMessageCodesResolver(messageCodesResolver);
		}
	}
	public void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) {
		Assert.notNull(bindingErrorProcessor, ""BindingErrorProcessor must not be null"");
		this.bindingErrorProcessor = bindingErrorProcessor;
	}
	public BindingErrorProcessor getBindingErrorProcessor() {
		return this.bindingErrorProcessor;
	}
	public void setValidator( Validator validator) {
		assertValidators(validator);
		this.validators.clear();
		if (validator != null) {
			this.validators.add(validator);
		}
	}
	private void assertValidators(Validator... validators) {
		Object target = getTarget();
		for (Validator validator : validators) {
			if (validator != null && (target != null && !validator.supports(target.getClass()))) {
				throw new IllegalStateException(""Invalid target for Validator ["" + validator + ""]: "" + target);
			}
		}
	}
	public void addValidators(Validator... validators) {
		assertValidators(validators);
		this.validators.addAll(Arrays.asList(validators));
	}
	public void replaceValidators(Validator... validators) {
		assertValidators(validators);
		this.validators.clear();
		this.validators.addAll(Arrays.asList(validators));
	}
	public Validator getValidator() {
		return (!this.validators.isEmpty() ? this.validators.get(0) : null);
	}
	public List<Validator> getValidators() {
		return Collections.unmodifiableList(this.validators);
	}
	public void setConversionService( ConversionService conversionService) {
		Assert.state(this.conversionService == null, ""DataBinder is already initialized with ConversionService"");
		this.conversionService = conversionService;
		if (this.bindingResult != null && conversionService != null) {
			this.bindingResult.initConversion(conversionService);
		}
	}
	public ConversionService getConversionService() {
		return this.conversionService;
	}
	public void addCustomFormatter(Formatter<?> formatter) {
		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);
		getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);
	}
	public void addCustomFormatter(Formatter<?> formatter, String... fields) {
		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);
		Class<?> fieldType = adapter.getFieldType();
		if (ObjectUtils.isEmpty(fields)) {
			getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);
		}
		else {
			for (String field : fields) {
				getPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);
			}
		}
	}
	public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {
		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);
		if (ObjectUtils.isEmpty(fieldTypes)) {
			getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);
		}
		else {
			for (Class<?> fieldType : fieldTypes) {
				getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);
			}
		}
	}
	public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {
		getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);
	}
	public void registerCustomEditor( Class<?> requiredType, String field, PropertyEditor propertyEditor) {
		getPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);
	}
	public PropertyEditor findCustomEditor( Class<?> requiredType, String propertyPath) {
		return getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);
	}
	public <T> T convertIfNecessary( Object value, Class<T> requiredType) throws TypeMismatchException {
		return getTypeConverter().convertIfNecessary(value, requiredType);
	}
	public <T> T convertIfNecessary( Object value, Class<T> requiredType, MethodParameter methodParam) throws TypeMismatchException {
		return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
	}
	public <T> T convertIfNecessary( Object value, Class<T> requiredType, Field field)throws TypeMismatchException {
		return getTypeConverter().convertIfNecessary(value, requiredType, field);
	}
	public <T> T convertIfNecessary( Object value, Class<T> requiredType, TypeDescriptor typeDescriptor) throws TypeMismatchException {
		return getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);
	}
	public void bind(PropertyValues pvs) {
		MutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ?(MutablePropertyValues) pvs : new MutablePropertyValues(pvs));
		doBind(mpvs);
	}
	protected void doBind(MutablePropertyValues mpvs) {
		checkAllowedFields(mpvs);
		checkRequiredFields(mpvs);
		applyPropertyValues(mpvs);
	}
	protected void checkAllowedFields(MutablePropertyValues mpvs) {
		PropertyValue[] pvs = mpvs.getPropertyValues();
		for (PropertyValue pv : pvs) {
			String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName());
			if (!isAllowed(field)) {
				mpvs.removePropertyValue(pv);
				getBindingResult().recordSuppressedField(field);
				if (logger.isDebugEnabled()) {
					logger.debug(""Field ["" + field + ""] has been removed from PropertyValues "" +""and will not be bound, because it has not been found in the list of allowed fields"");
				}
			}
		}
	}
	protected boolean isAllowed(String field) {
		String[] allowed = getAllowedFields();
		String[] disallowed = getDisallowedFields();
		return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &&(ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field)));
	}
	protected void checkRequiredFields(MutablePropertyValues mpvs) {
		String[] requiredFields = getRequiredFields();
		if (!ObjectUtils.isEmpty(requiredFields)) {
			Map<String, PropertyValue> propertyValues = new HashMap<>();
			PropertyValue[] pvs = mpvs.getPropertyValues();
			for (PropertyValue pv : pvs) {
				String canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName());
				propertyValues.put(canonicalName, pv);
			}
			for (String field : requiredFields) {
				PropertyValue pv = propertyValues.get(field);
				boolean empty = (pv == null || pv.getValue() == null);
				if (!empty) {
					if (pv.getValue() instanceof String) {
						empty = !StringUtils.hasText((String) pv.getValue());
					}
					else if (pv.getValue() instanceof String[]) {
						String[] values = (String[]) pv.getValue();
						empty = (values.length == 0 || !StringUtils.hasText(values[0]));
					}
				}
				if (empty) {
					getBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult());
					if (pv != null) {
						mpvs.removePropertyValue(pv);
						propertyValues.remove(field);
					}
				}
			}
		}
	}
	protected void applyPropertyValues(MutablePropertyValues mpvs) {
		try {
			getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());
		}
		catch (PropertyBatchUpdateException ex) {
			for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {
				getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());
			}
		}
	}
	public void validate() {
		Object target = getTarget();
		Assert.state(target != null, ""No target to validate"");
		BindingResult bindingResult = getBindingResult();
		for (Validator validator : getValidators()) {
			validator.validate(target, bindingResult);
		}
	}
	public void validate(Object... validationHints) {
		Object target = getTarget();
		Assert.state(target != null, ""No target to validate"");
		BindingResult bindingResult = getBindingResult();
		for (Validator validator : getValidators()) {
			if (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator) {
				((SmartValidator) validator).validate(target, bindingResult, validationHints);
			}
			else if (validator != null) {
				validator.validate(target, bindingResult);
			}
		}
	}
	public Map<?, ?> close() throws BindException {
		if (getBindingResult().hasErrors()) {
			throw new BindException(getBindingResult());
		}
		return getBindingResult().getModel();
	}
}",1,1,0,0
"public class Interpreter{
	 private static final int Icode_DUP = -1, Icode_DUP2 = -2, Icode_SWAP = -3, Icode_POP = -4, Icode_POP_RESULT = -5, Icode_IFEQ_POP = -6, Icode_VAR_INC_DEC = -7, Icode_NAME_INC_DEC = -8, Icode_PROP_INC_DEC = -9, Icode_ELEM_INC_DEC = -10, Icode_REF_INC_DEC = -11, Icode_SCOPE_LOAD = -12, Icode_SCOPE_SAVE = -13, Icode_TYPEOFNAME = -14, Icode_NAME_AND_THIS = -15, Icode_PROP_AND_THIS = -16, Icode_ELEM_AND_THIS = -17, Icode_VALUE_AND_THIS = -18, Icode_CLOSURE_EXPR = -19, Icode_CLOSURE_STMT = -20, Icode_CALLSPECIAL = -21, Icode_RETUNDEF = -22, Icode_GOSUB = -23, Icode_STARTSUB = -24, Icode_RETSUB = -25, Icode_LINE = -26, Icode_SHORTNUMBER = -27, Icode_INTNUMBER = -28, Icode_LITERAL_NEW = -29, Icode_LITERAL_SET = -30, Icode_SPARE_ARRAYLIT = -31, Icode_REG_IND_C0 = -32, Icode_REG_IND_C1 = -33, Icode_REG_IND_C2 = -34, Icode_REG_IND_C3 = -35, Icode_REG_IND_C4 = -36, Icode_REG_IND_C5 = -37, Icode_REG_IND1 = -38, Icode_REG_IND2 = -39, Icode_REG_IND4 = -40, Icode_REG_STR_C0 = -41, Icode_REG_STR_C1 = -42, Icode_REG_STR_C2 = -43, Icode_REG_STR_C3 = -44, Icode_REG_STR1 = -45, Icode_REG_STR2 = -46, Icode_REG_STR4 = -47, Icode_GETVAR1 = -48, Icode_SETVAR1 = -49, Icode_UNDEF = -50, Icode_ZERO = -51, Icode_ONE = -52, Icode_ENTERDQ = -53, Icode_LEAVEDQ = -54, Icode_TAIL_CALL = -55, Icode_LOCAL_CLEAR = -56, Icode_LITERAL_GETTER = -57, Icode_LITERAL_SETTER = -58, Icode_SETCONST = -59, Icode_SETCONSTVAR = -60, Icode_SETCONSTVAR1 = -61, MIN_ICODE = -61;
	 private CompilerEnvirons compilerEnv;
	 private boolean itsInFunctionFlag;
	 private InterpreterData itsData;
	 private ScriptOrFnNode scriptOrFn;
	 private int itsICodeTop;
	 private int itsStackDepth;
	 private int itsLineNumber;
	 private int itsDoubleTableTop;
	 private ObjToIntMap itsStrings = new ObjToIntMap(20);
	 private int itsLocalTop;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsLiteralIds = new ObjArray();
	 private int itsExceptionTableTop;
	 private static final int EXCEPTION_TRY_START_SLOT = 0;
	 private static final int EXCEPTION_TRY_END_SLOT = 1;
	 private static final int EXCEPTION_HANDLER_SLOT = 2;
	 private static final int EXCEPTION_TYPE_SLOT = 3;
	 private static final int EXCEPTION_LOCAL_SLOT = 4;
	 private static final int EXCEPTION_SCOPE_SLOT = 5;
	 private static final int EXCEPTION_SLOT_SIZE = 6;
	 private static final int ECF_TAIL = 1 << 0;
	 private static class CallFrame implements Cloneable, Serializable {
		 static final long serialVersionUID = -2843792508994958978L;
		 CallFrame parentFrame;
		 int frameIndex;
		 boolean frozen;
		 InterpretedFunction fnOrScript;
		 InterpreterData idata;
		 Object[] stack;
		 int[] stackAttributes;
		 double[] sDbl;
		 CallFrame varSource;
		 int localShift;
		 int emptyStackTop;
		 DebugFrame debuggerFrame;
		 boolean useActivation;
		 Scriptable thisObj;
		 Scriptable[] scriptRegExps;
		 Object result;
		 double resultDbl;
		 int pc;
		 int pcPrevBranch;
		 int pcSourceLineStart;
		 Scriptable scope;
		 int savedStackTop;
		 int savedCallOp;
		 CallFrame cloneFrozen() {
			 if (!frozen) Kit.codeBug();
			 CallFrame copy;
			 try {
				 copy = (CallFrame)clone();
			 }
			 catch (CloneNotSupportedException ex) {
				 throw new IllegalStateException();
			 }
			 copy.stack = (Object[])stack.clone();
			 copy.stackAttributes = (int[])stackAttributes.clone();
			 copy.sDbl = (double[])sDbl.clone();
			 copy.frozen = false;
			 return copy;
		 }
	 }
	 private static final class ContinuationJump implements Serializable {
		 static final long serialVersionUID = 7687739156004308247L;
		 CallFrame capturedFrame;
		 CallFrame branchFrame;
		 Object result;
		 double resultDbl;
		 ContinuationJump(Continuation c, CallFrame current) {
			 this.capturedFrame = (CallFrame)c.getImplementation();
			 if (this.capturedFrame == null || current == null) {
				 this.branchFrame = null;
			 }
			 else {
				 CallFrame chain1 = this.capturedFrame;
				 CallFrame chain2 = current;
				 int diff = chain1.frameIndex - chain2.frameIndex;
				 if (diff != 0) {
					 if (diff < 0) {
						 chain1 = current;
						 chain2 = this.capturedFrame;
						 diff = -diff;
					 }
					 do {
						 chain1 = chain1.parentFrame;
					 }
					 while (--diff != 0);
					 if (chain1.frameIndex != chain2.frameIndex) Kit.codeBug();
				 }
				 while (chain1 != chain2 && chain1 != null) {
					 chain1 = chain1.parentFrame;
					 chain2 = chain2.parentFrame;
				 }
				 this.branchFrame = chain1;
				 if (this.branchFrame != null && !this.branchFrame.frozen) Kit.codeBug();
			 }
		 }
	 }
	 static {
		 if (Token.LAST_BYTECODE_TOKEN > 127) {
			 String str = ""Violation of Token.LAST_BYTECODE_TOKEN <= 127"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
		 if (MIN_ICODE < -128) {
			 String str = ""Violation of Interpreter.MIN_ICODE >= -128"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
	 }
	 private static String bytecodeName(int bytecode) {
		 if (!validBytecode(bytecode)) {
			 throw new IllegalArgumentException(String.valueOf(bytecode));
		 }
		 if (!Token.printICode) {
			 return String.valueOf(bytecode);
		 }
		 if (validTokenCode(bytecode)) {
			 return Token.name(bytecode);
		 }
		 switch (bytecode) {
			 case Icode_DUP: return ""DUP"";
			 case Icode_DUP2: return ""DUP2"";
			 case Icode_SWAP: return ""SWAP"";
			 case Icode_POP: return ""POP"";
			 case Icode_POP_RESULT: return ""POP_RESULT"";
			 case Icode_IFEQ_POP: return ""IFEQ_POP"";
			 case Icode_VAR_INC_DEC: return ""VAR_INC_DEC"";
			 case Icode_NAME_INC_DEC: return ""NAME_INC_DEC"";
			 case Icode_PROP_INC_DEC: return ""PROP_INC_DEC"";
			 case Icode_ELEM_INC_DEC: return ""ELEM_INC_DEC"";
			 case Icode_REF_INC_DEC: return ""REF_INC_DEC"";
			 case Icode_SCOPE_LOAD: return ""SCOPE_LOAD"";
			 case Icode_SCOPE_SAVE: return ""SCOPE_SAVE"";
			 case Icode_TYPEOFNAME: return ""TYPEOFNAME"";
			 case Icode_NAME_AND_THIS: return ""NAME_AND_THIS"";
			 case Icode_PROP_AND_THIS: return ""PROP_AND_THIS"";
			 case Icode_ELEM_AND_THIS: return ""ELEM_AND_THIS"";
			 case Icode_VALUE_AND_THIS: return ""VALUE_AND_THIS"";
			 case Icode_CLOSURE_EXPR: return ""CLOSURE_EXPR"";
			 case Icode_CLOSURE_STMT: return ""CLOSURE_STMT"";
			 case Icode_CALLSPECIAL: return ""CALLSPECIAL"";
			 case Icode_RETUNDEF: return ""RETUNDEF"";
			 case Icode_GOSUB: return ""GOSUB"";
			 case Icode_STARTSUB: return ""STARTSUB"";
			 case Icode_RETSUB: return ""RETSUB"";
			 case Icode_LINE: return ""LINE"";
			 case Icode_SHORTNUMBER: return ""SHORTNUMBER"";
			 case Icode_INTNUMBER: return ""INTNUMBER"";
			 case Icode_LITERAL_NEW: return ""LITERAL_NEW"";
			 case Icode_LITERAL_SET: return ""LITERAL_SET"";
			 case Icode_SPARE_ARRAYLIT: return ""SPARE_ARRAYLIT"";
			 case Icode_REG_IND_C0: return ""REG_IND_C0"";
			 case Icode_REG_IND_C1: return ""REG_IND_C1"";
			 case Icode_REG_IND_C2: return ""REG_IND_C2"";
			 case Icode_REG_IND_C3: return ""REG_IND_C3"";
			 case Icode_REG_IND_C4: return ""REG_IND_C4"";
			 case Icode_REG_IND_C5: return ""REG_IND_C5"";
			 case Icode_REG_IND1: return ""LOAD_IND1"";
			 case Icode_REG_IND2: return ""LOAD_IND2"";
			 case Icode_REG_IND4: return ""LOAD_IND4"";
			 case Icode_REG_STR_C0: return ""REG_STR_C0"";
			 case Icode_REG_STR_C1: return ""REG_STR_C1"";
			 case Icode_REG_STR_C2: return ""REG_STR_C2"";
			 case Icode_REG_STR_C3: return ""REG_STR_C3"";
			 case Icode_REG_STR1: return ""LOAD_STR1"";
			 case Icode_REG_STR2: return ""LOAD_STR2"";
			 case Icode_REG_STR4: return ""LOAD_STR4"";
			 case Icode_GETVAR1: return ""GETVAR1"";
			 case Icode_SETVAR1: return ""SETVAR1"";
			 case Icode_UNDEF: return ""UNDEF"";
			 case Icode_ZERO: return ""ZERO"";
			 case Icode_ONE: return ""ONE"";
			 case Icode_ENTERDQ: return ""ENTERDQ"";
			 case Icode_LEAVEDQ: return ""LEAVEDQ"";
			 case Icode_TAIL_CALL: return ""TAIL_CALL"";
			 case Icode_LOCAL_CLEAR: return ""LOCAL_CLEAR"";
			 case Icode_LITERAL_GETTER: return ""LITERAL_GETTER"";
			 case Icode_LITERAL_SETTER: return ""LITERAL_SETTER"";
			 case Icode_SETCONST: return ""SETCONST"";
			 case Icode_SETCONSTVAR: return ""SETCONSTVAR"";
			 case Icode_SETCONSTVAR1: return ""SETCONSTVAR1"";
		 }
		 throw new IllegalStateException(String.valueOf(bytecode));
	 }
	 private static boolean validIcode(int icode) {
		 return MIN_ICODE <= icode && icode <= -1;
	 }
	 private static boolean validTokenCode(int token) {
		 return Token.FIRST_BYTECODE_TOKEN <= token && token <= Token.LAST_BYTECODE_TOKEN;
	 }
	 private static boolean validBytecode(int bytecode) {
		 return validIcode(bytecode) || validTokenCode(bytecode);
	 }
	 public Object compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, String encodedSource, boolean returnFunction) {
		 this.compilerEnv = compilerEnv;
		 new NodeTransformer().transform(tree);
		 if (Token.printTrees) {
			 System.out.println(tree.toStringTree(tree));
		 }
		 if (returnFunction) {
			 tree = tree.getFunctionNode(0);
		 }
		 scriptOrFn = tree;
		 itsData = new InterpreterData(compilerEnv.getLanguageVersion(), scriptOrFn.getSourceName(), encodedSource);
		 itsData.topLevel = true;
		 if (returnFunction) {
			 generateFunctionICode();
		 }
		 else {
			 generateICodeFromTree(scriptOrFn);
		 }
		 return itsData;
	 }
	 public Script createScriptObject(Object bytecode, Object staticSecurityDomain) {
		 if(bytecode != itsData) {
			 Kit.codeBug();
		 }
		 return InterpretedFunction.createScript(itsData, staticSecurityDomain);
	 }
	 public Function createFunctionObject(Context cx, Scriptable scope, Object bytecode, Object staticSecurityDomain) {
		 if(bytecode != itsData) {
			 Kit.codeBug();
		 }
		 return InterpretedFunction.createFunction(cx, scope, itsData, staticSecurityDomain);
	 }
	 private void generateFunctionICode() {
		 itsInFunctionFlag = true;
		 FunctionNode theFunction = (FunctionNode)scriptOrFn;
		 itsData.itsFunctionType = theFunction.getFunctionType();
		 itsData.itsNeedsActivation = theFunction.requiresActivation();
		 itsData.itsName = theFunction.getFunctionName();
		 if (!theFunction.getIgnoreDynamicScope()) {
			 if (compilerEnv.isUseDynamicScope()) {
				 itsData.useDynamicScope = true;
			 }
		 }
		 generateICodeFromTree(theFunction.getLastChild());
	 }
	 private void generateICodeFromTree(Node tree) {
		 generateNestedFunctions();
		 generateRegExpLiterals();
		 visitStatement(tree);
		 fixLabelGotos();
		 if (itsData.itsFunctionType == 0) {
			 addToken(Token.RETURN_RESULT);
		 }
		 if (itsData.itsICode.length != itsICodeTop) {
			 byte[] tmp = new byte[itsICodeTop];
			 System.arraycopy(itsData.itsICode, 0, tmp, 0, itsICodeTop);
			 itsData.itsICode = tmp;
		 }
		 if (itsStrings.size() == 0) {
			 itsData.itsStringTable = null;
		 }
		 else {
			 itsData.itsStringTable = new String[itsStrings.size()];
			 ObjToIntMap.Iterator iter = itsStrings.newIterator();
			 for (iter.start();
			 !iter.done();
			 iter.next()) {
				 String str = (String)iter.getKey();
				 int index = iter.getValue();
				 if (itsData.itsStringTable[index] != null) Kit.codeBug();
				 itsData.itsStringTable[index] = str;
			 }
		 }
		 if (itsDoubleTableTop == 0) {
			 itsData.itsDoubleTable = null;
		 }
		 else if (itsData.itsDoubleTable.length != itsDoubleTableTop) {
			 double[] tmp = new double[itsDoubleTableTop];
			 System.arraycopy(itsData.itsDoubleTable, 0, tmp, 0, itsDoubleTableTop);
			 itsData.itsDoubleTable = tmp;
		 }
		 if (itsExceptionTableTop != 0 && itsData.itsExceptionTable.length != itsExceptionTableTop) {
			 int[] tmp = new int[itsExceptionTableTop];
			 System.arraycopy(itsData.itsExceptionTable, 0, tmp, 0, itsExceptionTableTop);
			 itsData.itsExceptionTable = tmp;
		 }
		 itsData.itsMaxVars = scriptOrFn.getParamAndVarCount();
		 itsData.itsMaxFrameArray = itsData.itsMaxVars + itsData.itsMaxLocals + itsData.itsMaxStack;
		 itsData.argNames = scriptOrFn.getParamAndVarNames();
		 itsData.argIsConst = scriptOrFn.getParamAndVarConst();
		 itsData.argCount = scriptOrFn.getParamCount();
		 itsData.encodedSourceStart = scriptOrFn.getEncodedSourceStart();
		 itsData.encodedSourceEnd = scriptOrFn.getEncodedSourceEnd();
		 if (itsLiteralIds.size() != 0) {
			 itsData.literalIds = itsLiteralIds.toArray();
		 }
		 if (Token.printICode) dumpICode(itsData);
	 }
	 private void generateNestedFunctions() {
		 int functionCount = scriptOrFn.getFunctionCount();
		 if (functionCount == 0) return;
		 InterpreterData[] array = new InterpreterData[functionCount];
		 for (int i = 0;
		 i != functionCount;
		 i++) {
			 FunctionNode def = scriptOrFn.getFunctionNode(i);
			 Interpreter jsi = new Interpreter();
			 jsi.compilerEnv = compilerEnv;
			 jsi.scriptOrFn = def;
			 jsi.itsData = new InterpreterData(itsData);
			 jsi.generateFunctionICode();
			 array[i] = jsi.itsData;
		 }
		 itsData.itsNestedFunctions = array;
	 }
	 private void generateRegExpLiterals() {
		 int N = scriptOrFn.getRegexpCount();
		 if (N == 0) return;
		 Context cx = Context.getContext();
		 RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);
		 Object[] array = new Object[N];
		 for (int i = 0;
		 i != N;
		 i++) {
			 String string = scriptOrFn.getRegexpString(i);
			 String flags = scriptOrFn.getRegexpFlags(i);
			 array[i] = rep.compileRegExp(cx, string, flags);
		 }
		 itsData.itsRegExpLiterals = array;
	 }
	 private void updateLineNumber(Node node) {
		 int lineno = node.getLineno();
		 if (lineno != itsLineNumber && lineno >= 0) {
			 if (itsData.firstLinePC < 0) {
				 itsData.firstLinePC = lineno;
			 }
			 itsLineNumber = lineno;
			 addIcode(Icode_LINE);
			 addUint16(lineno & 0xFFFF);
		 }
	 }
	 private RuntimeException badTree(Node node) {
		 throw new RuntimeException(node.toString());
	 }
	 private void visitStatement(Node node) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 int fnType = scriptOrFn.getFunctionNode(fnIndex). getFunctionType();
				 if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 addIndexOp(Icode_CLOSURE_STMT, fnIndex);
				 }
				 else {
					 if (fnType != FunctionNode.FUNCTION_STATEMENT) {
						 throw Kit.codeBug();
					 }
				 }
				 if (!itsInFunctionFlag) {
					 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
					 stackChange(1);
					 addIcode(Icode_POP_RESULT);
					 stackChange(-1);
				 }
			 }
			 break;
			 case Token.SCRIPT: case Token.LABEL: case Token.LOOP: case Token.BLOCK: case Token.EMPTY: case Token.WITH: updateLineNumber(node);
			 while (child != null) {
				 visitStatement(child);
				 child = child.getNext();
			 }
			 break;
			 case Token.ENTERWITH: visitExpression(child, 0);
			 addToken(Token.ENTERWITH);
			 stackChange(-1);
			 break;
			 case Token.LEAVEWITH: addToken(Token.LEAVEWITH);
			 break;
			 case Token.LOCAL_BLOCK: {
				 int local = allocLocal();
				 node.putIntProp(Node.LOCAL_PROP, local);
				 updateLineNumber(node);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, local);
				 releaseLocal(local);
			 }
			 break;
			 case Token.SWITCH: updateLineNumber(node);
			 {
				 visitExpression(child, 0);
				 for (Node.Jump caseNode = (Node.Jump)child.getNext();
				 caseNode != null;
				 caseNode = (Node.Jump)caseNode.getNext()) {
					 if (caseNode.getType() != Token.CASE) throw badTree(caseNode);
					 Node test = caseNode.getFirstChild();
					 addIcode(Icode_DUP);
					 stackChange(1);
					 visitExpression(test, 0);
					 addToken(Token.SHEQ);
					 stackChange(-1);
					 addGoto(caseNode.target, Icode_IFEQ_POP);
					 stackChange(-1);
				 }
				 addIcode(Icode_POP);
				 stackChange(-1);
			 }
			 break;
			 case Token.TARGET: markTargetLabel(node);
			 break;
			 case Token.IFEQ : case Token.IFNE : {
				 Node target = ((Node.Jump)node).target;
				 visitExpression(child, 0);
				 addGoto(target, type);
				 stackChange(-1);
			 }
			 break;
			 case Token.GOTO: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, type);
			 }
			 break;
			 case Token.JSR: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, Icode_GOSUB);
			 }
			 break;
			 case Token.FINALLY: {
				 stackChange(1);
				 int finallyRegister = getLocalBlockRef(node);
				 addIndexOp(Icode_STARTSUB, finallyRegister);
				 stackChange(-1);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_RETSUB, finallyRegister);
			 }
			 break;
			 case Token.EXPR_VOID: case Token.EXPR_RESULT: updateLineNumber(node);
			 visitExpression(child, 0);
			 addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);
			 stackChange(-1);
			 break;
			 case Token.TRY: {
				 Node.Jump tryNode = (Node.Jump)node;
				 int exceptionObjectLocal = getLocalBlockRef(tryNode);
				 int scopeLocal = allocLocal();
				 addIndexOp(Icode_SCOPE_SAVE, scopeLocal);
				 int tryStart = itsICodeTop;
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 Node catchTarget = tryNode.target;
				 if (catchTarget != null) {
					 int catchStartPC = itsLabelTable[getTargetLabel(catchTarget)];
					 addExceptionHandler( tryStart, catchStartPC, catchStartPC, false, exceptionObjectLocal, scopeLocal);
				 }
				 Node finallyTarget = tryNode.getFinally();
				 if (finallyTarget != null) {
					 int finallyStartPC = itsLabelTable[getTargetLabel(finallyTarget)];
					 addExceptionHandler( tryStart, finallyStartPC, finallyStartPC, true, exceptionObjectLocal, scopeLocal);
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);
				 releaseLocal(scopeLocal);
			 }
			 break;
			 case Token.CATCH_SCOPE: {
				 int localIndex = getLocalBlockRef(node);
				 int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringPrefix(name);
				 addIndexPrefix(localIndex);
				 addToken(Token.CATCH_SCOPE);
				 addUint8(scopeIndex != 0 ? 1 : 0);
				 stackChange(-1);
			 }
			 break;
			 case Token.THROW: updateLineNumber(node);
			 visitExpression(child, 0);
			 addToken(Token.THROW);
			 addUint16(itsLineNumber & 0xFFFF);
			 stackChange(-1);
			 break;
			 case Token.RETHROW: updateLineNumber(node);
			 addIndexOp(Token.RETHROW, getLocalBlockRef(node));
			 break;
			 case Token.RETURN: updateLineNumber(node);
			 if (child != null) {
				 visitExpression(child, ECF_TAIL);
				 addToken(Token.RETURN);
				 stackChange(-1);
			 }
			 else {
				 addIcode(Icode_RETUNDEF);
			 }
			 break;
			 case Token.RETURN_RESULT: updateLineNumber(node);
			 addToken(Token.RETURN_RESULT);
			 break;
			 case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES : visitExpression(child, 0);
			 addIndexOp(type, getLocalBlockRef(node));
			 stackChange(-1);
			 break;
			 default: throw badTree(node);
		 }
		 if (itsStackDepth != 0) {
			 throw Kit.codeBug();
		 }
	 }
	 private void visitExpression(Node node, int contextFlags) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 int savedStackDepth = itsStackDepth;
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);
				 if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {
					 throw Kit.codeBug();
				 }
				 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.LOCAL_LOAD: {
				 int localIndex = getLocalBlockRef(node);
				 addIndexOp(Token.LOCAL_LOAD, localIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.COMMA: {
				 Node lastChild = node.getLastChild();
				 while (child != lastChild) {
					 visitExpression(child, 0);
					 addIcode(Icode_POP);
					 stackChange(-1);
					 child = child.getNext();
				 }
				 visitExpression(child, contextFlags & ECF_TAIL);
			 }
			 break;
			 case Token.USE_STACK: stackChange(1);
			 break;
			 case Token.REF_CALL: case Token.CALL: case Token.NEW: {
				 if (type == Token.NEW) {
					 visitExpression(child, 0);
				 }
				 else {
					 generateCallFunAndThis(child);
				 }
				 int argCount = 0;
				 while ((child = child.getNext()) != null) {
					 visitExpression(child, 0);
					 ++argCount;
				 }
				 int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL);
				 if (callType != Node.NON_SPECIALCALL) {
					 addIndexOp(Icode_CALLSPECIAL, argCount);
					 addUint8(callType);
					 addUint8(type == Token.NEW ? 1 : 0);
					 addUint16(itsLineNumber & 0xFFFF);
				 }
				 else {
					 if (type == Token.CALL) {
						 if ((contextFlags & ECF_TAIL) != 0) {
							 type = Icode_TAIL_CALL;
						 }
					 }
					 addIndexOp(type, argCount);
				 }
				 if (type == Token.NEW) {
					 stackChange(-argCount);
				 }
				 else {
					 stackChange(-1 - argCount);
				 }
				 if (argCount > itsData.itsMaxCalleeArgs) {
					 itsData.itsMaxCalleeArgs = argCount;
				 }
			 }
			 break;
			 case Token.AND: case Token.OR: {
				 visitExpression(child, 0);
				 addIcode(Icode_DUP);
				 stackChange(1);
				 int afterSecondJumpStart = itsICodeTop;
				 int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;
				 addGotoOp(jump);
				 stackChange(-1);
				 addIcode(Icode_POP);
				 stackChange(-1);
				 child = child.getNext();
				 visitExpression(child, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterSecondJumpStart);
			 }
			 break;
			 case Token.HOOK: {
				 Node ifThen = child.getNext();
				 Node ifElse = ifThen.getNext();
				 visitExpression(child, 0);
				 int elseJumpStart = itsICodeTop;
				 addGotoOp(Token.IFNE);
				 stackChange(-1);
				 visitExpression(ifThen, contextFlags & ECF_TAIL);
				 int afterElseJumpStart = itsICodeTop;
				 addGotoOp(Token.GOTO);
				 resolveForwardGoto(elseJumpStart);
				 itsStackDepth = savedStackDepth;
				 visitExpression(ifElse, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterElseJumpStart);
			 }
			 break;
			 case Token.GETPROP: visitExpression(child, 0);
			 child = child.getNext();
			 addStringOp(Token.GETPROP, child.getString());
			 break;
			 case Token.GETELEM: case Token.DELPROP: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 addToken(type);
			 stackChange(-1);
			 break;
			 case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0);
			 if (type == Token.VOID) {
				 addIcode(Icode_POP);
				 addIcode(Icode_UNDEF);
			 }
			 else {
				 addToken(type);
			 }
			 break;
			 case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0);
			 addToken(type);
			 break;
			 case Token.SETPROP: case Token.SETPROP_OP: {
				 visitExpression(child, 0);
				 child = child.getNext();
				 String property = child.getString();
				 child = child.getNext();
				 if (type == Token.SETPROP_OP) {
					 addIcode(Icode_DUP);
					 stackChange(1);
					 addStringOp(Token.GETPROP, property);
					 stackChange(-1);
				 }
				 visitExpression(child, 0);
				 addStringOp(Token.SETPROP, property);
				 stackChange(-1);
			 }
			 break;
			 case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SETELEM_OP) {
				 addIcode(Icode_DUP2);
				 stackChange(2);
				 addToken(Token.GETELEM);
				 stackChange(-1);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SETELEM);
			 stackChange(-2);
			 break;
			 case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SET_REF_OP) {
				 addIcode(Icode_DUP);
				 stackChange(1);
				 addToken(Token.GET_REF);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SET_REF);
			 stackChange(-1);
			 break;
			 case Token.SETNAME: {
				 String name = child.getString();
				 visitExpression(child, 0);
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringOp(Token.SETNAME, name);
				 stackChange(-1);
			 }
			 break;
			 case Token.SETCONST: {
				 String name = child.getString();
				 visitExpression(child, 0);
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringOp(Icode_SETCONST, name);
				 stackChange(-1);
			 }
			 break;
			 case Token.TYPEOFNAME: {
				 String name = node.getString();
				 int index = -1;
				 if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getParamOrVarIndex(name);
				 if (index == -1) {
					 addStringOp(Icode_TYPEOFNAME, name);
					 stackChange(1);
				 }
				 else {
					 addVarOp(Token.GETVAR, index);
					 stackChange(1);
					 addToken(Token.TYPEOF);
				 }
			 }
			 break;
			 case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString());
			 stackChange(1);
			 break;
			 case Token.INC: case Token.DEC: visitIncDec(node, child);
			 break;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 int inum = (int)num;
				 if (inum == num) {
					 if (inum == 0) {
						 addIcode(Icode_ZERO);
						 if (1.0 / num < 0.0) {
							 addToken(Token.NEG);
						 }
					 }
					 else if (inum == 1) {
						 addIcode(Icode_ONE);
					 }
					 else if ((short)inum == inum) {
						 addIcode(Icode_SHORTNUMBER);
						 addUint16(inum & 0xFFFF);
					 }
					 else {
						 addIcode(Icode_INTNUMBER);
						 addInt(inum);
					 }
				 }
				 else {
					 int index = getDoubleIndex(num);
					 addIndexOp(Token.NUMBER, index);
				 }
				 stackChange(1);
			 }
			 break;
			 case Token.GETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = node.getString();
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.GETVAR, index);
				 stackChange(1);
			 }
			 break;
			 case Token.SETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.SETVAR, index);
			 }
			 break;
			 case Token.SETCONSTVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.SETCONSTVAR, index);
			 }
			 break;
			 case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type);
			 stackChange(1);
			 break;
			 case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node));
			 stackChange(1);
			 break;
			 case Token.REGEXP: {
				 int index = node.getExistingIntProp(Node.REGEXP_PROP);
				 addIndexOp(Token.REGEXP, index);
				 stackChange(1);
			 }
			 break;
			 case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child);
			 break;
			 case Token.REF_SPECIAL: visitExpression(child, 0);
			 addStringOp(type, (String)node.getProp(Node.NAME_PROP));
			 break;
			 case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: {
				 int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);
				 int childCount = 0;
				 do {
					 visitExpression(child, 0);
					 ++childCount;
					 child = child.getNext();
				 }
				 while (child != null);
				 addIndexOp(type, memberTypeFlags);
				 stackChange(1 - childCount);
			 }
			 break;
			 case Token.DOTQUERY: {
				 int queryPC;
				 updateLineNumber(node);
				 visitExpression(child, 0);
				 addIcode(Icode_ENTERDQ);
				 stackChange(-1);
				 queryPC = itsICodeTop;
				 visitExpression(child.getNext(), 0);
				 addBackwardGoto(Icode_LEAVEDQ, queryPC);
			 }
			 break;
			 case Token.DEFAULTNAMESPACE : case Token.ESCXMLATTR : case Token.ESCXMLTEXT : visitExpression(child, 0);
			 addToken(type);
			 break;
			 default: throw badTree(node);
		 }
		 if (savedStackDepth + 1 != itsStackDepth) {
			 Kit.codeBug();
		 }
	 }
	 private void generateCallFunAndThis(Node left) {
		 int type = left.getType();
		 switch (type) {
			 case Token.NAME: {
				 String name = left.getString();
				 addStringOp(Icode_NAME_AND_THIS, name);
				 stackChange(2);
				 break;
			 }
			 case Token.GETPROP: case Token.GETELEM: {
				 Node target = left.getFirstChild();
				 visitExpression(target, 0);
				 Node id = target.getNext();
				 if (type == Token.GETPROP) {
					 String property = id.getString();
					 addStringOp(Icode_PROP_AND_THIS, property);
					 stackChange(1);
				 }
				 else {
					 visitExpression(id, 0);
					 addIcode(Icode_ELEM_AND_THIS);
				 }
				 break;
			 }
			 default: visitExpression(left, 0);
			 addIcode(Icode_VALUE_AND_THIS);
			 stackChange(1);
			 break;
		 }
	 }
	 private void visitIncDec(Node node, Node child) {
		 int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);
		 int childType = child.getType();
		 switch (childType) {
			 case Token.GETVAR : {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 int i = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Icode_VAR_INC_DEC, i);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.NAME : {
				 String name = child.getString();
				 addStringOp(Icode_NAME_INC_DEC, name);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.GETPROP : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 String property = object.getNext().getString();
				 addStringOp(Icode_PROP_INC_DEC, property);
				 addUint8(incrDecrMask);
				 break;
			 }
			 case Token.GETELEM : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 Node index = object.getNext();
				 visitExpression(index, 0);
				 addIcode(Icode_ELEM_INC_DEC);
				 addUint8(incrDecrMask);
				 stackChange(-1);
				 break;
			 }
			 case Token.GET_REF : {
				 Node ref = child.getFirstChild();
				 visitExpression(ref, 0);
				 addIcode(Icode_REF_INC_DEC);
				 addUint8(incrDecrMask);
				 break;
			 }
			 default : {
				 throw badTree(node);
			 }
		 }
	 }
	 private void visitLiteral(Node node, Node child) {
		 int type = node.getType();
		 int count;
		 Object[] propertyIds = null;
		 if (type == Token.ARRAYLIT) {
			 count = 0;
			 for (Node n = child;
			 n != null;
			 n = n.getNext()) {
				 ++count;
			 }
		 }
		 else if (type == Token.OBJECTLIT) {
			 propertyIds = (Object[])node.getProp(Node.OBJECT_IDS_PROP);
			 count = propertyIds.length;
		 }
		 else {
			 throw badTree(node);
		 }
		 addIndexOp(Icode_LITERAL_NEW, count);
		 stackChange(2);
		 while (child != null) {
			 int childType = child.getType();
			 if (childType == Token.GET) {
				 visitExpression(child.getFirstChild(), 0);
				 addIcode(Icode_LITERAL_GETTER);
			 }
			 else if (childType == Token.SET) {
				 visitExpression(child.getFirstChild(), 0);
				 addIcode(Icode_LITERAL_SETTER);
			 }
			 else {
				 visitExpression(child, 0);
				 addIcode(Icode_LITERAL_SET);
			 }
			 stackChange(-1);
			 child = child.getNext();
		 }
		 if (type == Token.ARRAYLIT) {
			 int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);
			 if (skipIndexes == null) {
				 addToken(Token.ARRAYLIT);
			 }
			 else {
				 int index = itsLiteralIds.size();
				 itsLiteralIds.add(skipIndexes);
				 addIndexOp(Icode_SPARE_ARRAYLIT, index);
			 }
		 }
		 else {
			 int index = itsLiteralIds.size();
			 itsLiteralIds.add(propertyIds);
			 addIndexOp(Token.OBJECTLIT, index);
		 }
		 stackChange(-1);
	 }
	 private int getLocalBlockRef(Node node) {
		 Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
		 return localBlock.getExistingIntProp(Node.LOCAL_PROP);
	 }
	 private int getTargetLabel(Node target) {
		 int label = target.labelId();
		 if (label != -1) {
			 return label;
		 }
		 label = itsLabelTableTop;
		 if (itsLabelTable == null || label == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, label);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = label + 1;
		 itsLabelTable[label] = -1;
		 target.labelId(label);
		 return label;
	 }
	 private void markTargetLabel(Node target) {
		 int label = getTargetLabel(target);
		 if (itsLabelTable[label] != -1) {
			 Kit.codeBug();
		 }
		 itsLabelTable[label] = itsICodeTop;
	 }
	 private void addGoto(Node target, int gotoOp) {
		 int label = getTargetLabel(target);
		 if (!(label < itsLabelTableTop)) Kit.codeBug();
		 int targetPC = itsLabelTable[label];
		 if (targetPC != -1) {
			 addBackwardGoto(gotoOp, targetPC);
		 }
		 else {
			 int gotoPC = itsICodeTop;
			 addGotoOp(gotoOp);
			 int top = itsFixupTableTop;
			 if (itsFixupTable == null || top == itsFixupTable.length) {
				 if (itsFixupTable == null) {
					 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
				 }
				 else {
					 long[] tmp = new long[itsFixupTable.length * 2];
					 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
					 itsFixupTable = tmp;
				 }
			 }
			 itsFixupTableTop = top + 1;
			 itsFixupTable[top] = ((long)label << 32) | gotoPC;
		 }
	 }
	 private void fixLabelGotos() {
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int jumpSource = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw Kit.codeBug();
			 }
			 resolveGoto(jumpSource, pc);
		 }
		 itsFixupTableTop = 0;
	 }
	 private void addBackwardGoto(int gotoOp, int jumpPC) {
		 int fromPC = itsICodeTop;
		 if (fromPC <= jumpPC) throw Kit.codeBug();
		 addGotoOp(gotoOp);
		 resolveGoto(fromPC, jumpPC);
	 }
	 private void resolveForwardGoto(int fromPC) {
		 if (itsICodeTop < fromPC + 3) throw Kit.codeBug();
		 resolveGoto(fromPC, itsICodeTop);
	 }
	 private void resolveGoto(int fromPC, int jumpPC) {
		 int offset = jumpPC - fromPC;
		 if (0 <= offset && offset <= 2) throw Kit.codeBug();
		 int offsetSite = fromPC + 1;
		 if (offset != (short)offset) {
			 if (itsData.longJumps == null) {
				 itsData.longJumps = new UintMap();
			 }
			 itsData.longJumps.put(offsetSite, jumpPC);
			 offset = 0;
		 }
		 byte[] array = itsData.itsICode;
		 array[offsetSite] = (byte)(offset >> 8);
		 array[offsetSite + 1] = (byte)offset;
	 }
	 private void addToken(int token) {
		 if (!validTokenCode(token)) throw Kit.codeBug();
		 addUint8(token);
	 }
	 private void addIcode(int icode) {
		 if (!validIcode(icode)) throw Kit.codeBug();
		 addUint8(icode & 0xFF);
	 }
	 private void addUint8(int value) {
		 if ((value & ~0xFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top == array.length) {
			 array = increaseICodeCapasity(1);
		 }
		 array[top] = (byte)value;
		 itsICodeTop = top + 1;
	 }
	 private void addUint16(int value) {
		 if ((value & ~0xFFFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 2 > array.length) {
			 array = increaseICodeCapasity(2);
		 }
		 array[top] = (byte)(value >>> 8);
		 array[top + 1] = (byte)value;
		 itsICodeTop = top + 2;
	 }
	 private void addInt(int i) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 4 > array.length) {
			 array = increaseICodeCapasity(4);
		 }
		 array[top] = (byte)(i >>> 24);
		 array[top + 1] = (byte)(i >>> 16);
		 array[top + 2] = (byte)(i >>> 8);
		 array[top + 3] = (byte)i;
		 itsICodeTop = top + 4;
	 }
	 private int getDoubleIndex(double num) {
		 int index = itsDoubleTableTop;
		 if (index == 0) {
			 itsData.itsDoubleTable = new double[64];
		 }
		 else if (itsData.itsDoubleTable.length == index) {
			 double[] na = new double[index * 2];
			 System.arraycopy(itsData.itsDoubleTable, 0, na, 0, index);
			 itsData.itsDoubleTable = na;
		 }
		 itsData.itsDoubleTable[index] = num;
		 itsDoubleTableTop = index + 1;
		 return index;
	 }
	 private void addGotoOp(int gotoOp) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 3 > array.length) {
			 array = increaseICodeCapasity(3);
		 }
		 array[top] = (byte)gotoOp;
		 itsICodeTop = top + 1 + 2;
	 }
	 private void addVarOp(int op, int varIndex) {
		 switch (op) {
			 case Token.SETCONSTVAR: if (varIndex < 128) {
				 addIcode(Icode_SETCONSTVAR1);
				 addUint8(varIndex);
				 return;
			 }
			 addIndexOp(Icode_SETCONSTVAR, varIndex);
			 return;
			 case Token.GETVAR: case Token.SETVAR: if (varIndex < 128) {
				 addIcode(op == Token.GETVAR ? Icode_GETVAR1 : Icode_SETVAR1);
				 addUint8(varIndex);
				 return;
			 }
			 case Icode_VAR_INC_DEC: addIndexOp(op, varIndex);
			 return;
		 }
		 throw Kit.codeBug();
	 }
	 private void addStringOp(int op, String str) {
		 addStringPrefix(str);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addIndexOp(int op, int index) {
		 addIndexPrefix(index);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addStringPrefix(String str) {
		 int index = itsStrings.get(str, -1);
		 if (index == -1) {
			 index = itsStrings.size();
			 itsStrings.put(str, index);
		 }
		 if (index < 4) {
			 addIcode(Icode_REG_STR_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_STR1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_STR2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_STR4);
			 addInt(index);
		 }
	 }
	 private void addIndexPrefix(int index) {
		 if (index < 0) Kit.codeBug();
		 if (index < 6) {
			 addIcode(Icode_REG_IND_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_IND1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_IND2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_IND4);
			 addInt(index);
		 }
	 }
	 private void addExceptionHandler(int icodeStart, int icodeEnd, int handlerStart, boolean isFinally, int exceptionObjectLocal, int scopeLocal) {
		 int top = itsExceptionTableTop;
		 int[] table = itsData.itsExceptionTable;
		 if (table == null) {
			 if (top != 0) Kit.codeBug();
			 table = new int[EXCEPTION_SLOT_SIZE * 2];
			 itsData.itsExceptionTable = table;
		 }
		 else if (table.length == top) {
			 table = new int[table.length * 2];
			 System.arraycopy(itsData.itsExceptionTable, 0, table, 0, top);
			 itsData.itsExceptionTable = table;
		 }
		 table[top + EXCEPTION_TRY_START_SLOT] = icodeStart;
		 table[top + EXCEPTION_TRY_END_SLOT] = icodeEnd;
		 table[top + EXCEPTION_HANDLER_SLOT] = handlerStart;
		 table[top + EXCEPTION_TYPE_SLOT] = isFinally ? 1 : 0;
		 table[top + EXCEPTION_LOCAL_SLOT] = exceptionObjectLocal;
		 table[top + EXCEPTION_SCOPE_SLOT] = scopeLocal;
		 itsExceptionTableTop = top + EXCEPTION_SLOT_SIZE;
	 }
	 private byte[] increaseICodeCapasity(int extraSize) {
		 int capacity = itsData.itsICode.length;
		 int top = itsICodeTop;
		 if (top + extraSize <= capacity) throw Kit.codeBug();
		 capacity *= 2;
		 if (top + extraSize > capacity) {
			 capacity = top + extraSize;
		 }
		 byte[] array = new byte[capacity];
		 System.arraycopy(itsData.itsICode, 0, array, 0, top);
		 itsData.itsICode = array;
		 return array;
	 }
	 private void stackChange(int change) {
		 if (change <= 0) {
			 itsStackDepth += change;
		 }
		 else {
			 int newDepth = itsStackDepth + change;
			 if (newDepth > itsData.itsMaxStack) {
				 itsData.itsMaxStack = newDepth;
			 }
			 itsStackDepth = newDepth;
		 }
	 }
	 private int allocLocal() {
		 int localSlot = itsLocalTop;
		 ++itsLocalTop;
		 if (itsLocalTop > itsData.itsMaxLocals) {
			 itsData.itsMaxLocals = itsLocalTop;
		 }
		 return localSlot;
	 }
	 private void releaseLocal(int localSlot) {
		 --itsLocalTop;
		 if (localSlot != itsLocalTop) Kit.codeBug();
	 }
	 private static int getShort(byte[] iCode, int pc) {
		 return (iCode[pc] << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getIndex(byte[] iCode, int pc) {
		 return ((iCode[pc] & 0xFF) << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getInt(byte[] iCode, int pc) {
		 return (iCode[pc] << 24) | ((iCode[pc + 1] & 0xFF) << 16) | ((iCode[pc + 2] & 0xFF) << 8) | (iCode[pc + 3] & 0xFF);
	 }
	 private static int getExceptionHandler(CallFrame frame, boolean onlyFinally) {
		 int[] exceptionTable = frame.idata.itsExceptionTable;
		 if (exceptionTable == null) {
			 return -1;
		 }
		 int pc = frame.pc - 1;
		 int best = -1, bestStart = 0, bestEnd = 0;
		 for (int i = 0;
		 i != exceptionTable.length;
		 i += EXCEPTION_SLOT_SIZE) {
			 int start = exceptionTable[i + EXCEPTION_TRY_START_SLOT];
			 int end = exceptionTable[i + EXCEPTION_TRY_END_SLOT];
			 if (!(start <= pc && pc < end)) {
				 continue;
			 }
			 if (onlyFinally && exceptionTable[i + EXCEPTION_TYPE_SLOT] != 1) {
				 continue;
			 }
			 if (best >= 0) {
				 if (bestEnd < end) {
					 continue;
				 }
				 if (bestStart > start) Kit.codeBug();
				 if (bestEnd == end) Kit.codeBug();
			 }
			 best = i;
			 bestStart = start;
			 bestEnd = end;
		 }
		 return best;
	 }
	 private static void dumpICode(InterpreterData idata) {
		 if (!Token.printICode) {
			 return;
		 }
		 byte iCode[] = idata.itsICode;
		 int iCodeLength = iCode.length;
		 String[] strings = idata.itsStringTable;
		 PrintStream out = System.out;
		 out.println(""ICode dump, for "" + idata.itsName + "", length = "" + iCodeLength);
		 out.println(""MaxStack = "" + idata.itsMaxStack);
		 int indexReg = 0;
		 for (int pc = 0;
		 pc < iCodeLength;
		 ) {
			 out.flush();
			 out.print("" ["" + pc + ""] "");
			 int token = iCode[pc];
			 int icodeLength = bytecodeSpan(token);
			 String tname = bytecodeName(token);
			 int old_pc = pc;
			 ++pc;
			 switch (token) {
				 default: if (icodeLength != 1) Kit.codeBug();
				 out.println(tname);
				 break;
				 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : {
					 int newPC = pc + getShort(iCode, pc) - 1;
					 out.println(tname + "" "" + newPC);
					 pc += 2;
					 break;
				 }
				 case Icode_VAR_INC_DEC : case Icode_NAME_INC_DEC : case Icode_PROP_INC_DEC : case Icode_ELEM_INC_DEC : case Icode_REF_INC_DEC: {
					 int incrDecrType = iCode[pc];
					 out.println(tname + "" "" + incrDecrType);
					 ++pc;
					 break;
				 }
				 case Icode_CALLSPECIAL : {
					 int callType = iCode[pc] & 0xFF;
					 boolean isNew = (iCode[pc + 1] != 0);
					 int line = getIndex(iCode, pc+2);
					 out.println(tname+"" ""+callType+"" ""+isNew+"" ""+indexReg+"" ""+line);
					 pc += 4;
					 break;
				 }
				 case Token.CATCH_SCOPE: {
					 boolean afterFisrtFlag = (iCode[pc] != 0);
					 out.println(tname+"" ""+afterFisrtFlag);
					 ++pc;
				 }
				 break;
				 case Token.REGEXP : out.println(tname+"" ""+idata.itsRegExpLiterals[indexReg]);
				 break;
				 case Token.OBJECTLIT : case Icode_SPARE_ARRAYLIT : out.println(tname+"" ""+idata.literalIds[indexReg]);
				 break;
				 case Icode_CLOSURE_EXPR : case Icode_CLOSURE_STMT : out.println(tname+"" ""+idata.itsNestedFunctions[indexReg]);
				 break;
				 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : case Token.NEW : out.println(tname+' '+indexReg);
				 break;
				 case Token.THROW : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_SHORTNUMBER : {
					 int value = getShort(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_INTNUMBER : {
					 int value = getInt(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 4;
					 break;
				 }
				 case Token.NUMBER : {
					 double value = idata.itsDoubleTable[indexReg];
					 out.println(tname + "" "" + value);
					 break;
				 }
				 case Icode_LINE : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR1: {
					 String str = strings[0xFF & iCode[pc]];
					 out.println(tname + "" \"""" + str + '""');
					 ++pc;
					 break;
				 }
				 case Icode_REG_STR2: {
					 String str = strings[getIndex(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR4: {
					 String str = strings[getInt(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 4;
					 break;
				 }
				 case Icode_REG_IND_C0: indexReg = 0;
				 out.println(tname);
				 break;
				 case Icode_REG_IND_C1: indexReg = 1;
				 out.println(tname);
				 break;
				 case Icode_REG_IND_C2: indexReg = 2;
				 out.println(tname);
				 break;
				 case Icode_REG_IND_C3: indexReg = 3;
				 out.println(tname);
				 break;
				 case Icode_REG_IND_C4: indexReg = 4;
				 out.println(tname);
				 break;
				 case Icode_REG_IND_C5: indexReg = 5;
				 out.println(tname);
				 break;
				 case Icode_REG_IND1: {
					 indexReg = 0xFF & iCode[pc];
					 out.println(tname+"" ""+indexReg);
					 ++pc;
					 break;
				 }
				 case Icode_REG_IND2: {
					 indexReg = getIndex(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_IND4: {
					 indexReg = getInt(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 4;
					 break;
				 }
				 case Icode_GETVAR1: case Icode_SETVAR1: case Icode_SETCONSTVAR1: indexReg = iCode[pc];
				 out.println(tname+"" ""+indexReg);
				 ++pc;
				 break;
			 }
			 if (old_pc + icodeLength != pc) Kit.codeBug();
		 }
		 int[] table = idata.itsExceptionTable;
		 if (table != null) {
			 out.println(""Exception handlers: "" +table.length / EXCEPTION_SLOT_SIZE);
			 for (int i = 0;
			 i != table.length;
			 i += EXCEPTION_SLOT_SIZE) {
				 int tryStart = table[i + EXCEPTION_TRY_START_SLOT];
				 int tryEnd = table[i + EXCEPTION_TRY_END_SLOT];
				 int handlerStart = table[i + EXCEPTION_HANDLER_SLOT];
				 int type = table[i + EXCEPTION_TYPE_SLOT];
				 int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];
				 int scopeLocal = table[i + EXCEPTION_SCOPE_SLOT];
				 out.println("" tryStart=""+tryStart+"" tryEnd=""+tryEnd +"" handlerStart=""+handlerStart +"" type=""+(type == 0 ? ""catch"" : ""finally"") +"" exceptionLocal=""+exceptionLocal);
			 }
		 }
		 out.flush();
	 }
	 private static int bytecodeSpan(int bytecode) {
		 switch (bytecode) {
			 case Token.THROW : return 1 + 2;
			 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : return 1 + 2;
			 case Icode_CALLSPECIAL : return 1 + 1 + 1 + 2;
			 case Token.CATCH_SCOPE: return 1 + 1;
			 case Icode_VAR_INC_DEC: case Icode_NAME_INC_DEC: case Icode_PROP_INC_DEC: case Icode_ELEM_INC_DEC: case Icode_REF_INC_DEC: return 1 + 1;
			 case Icode_SHORTNUMBER : return 1 + 2;
			 case Icode_INTNUMBER : return 1 + 4;
			 case Icode_REG_IND1: return 1 + 1;
			 case Icode_REG_IND2: return 1 + 2;
			 case Icode_REG_IND4: return 1 + 4;
			 case Icode_REG_STR1: return 1 + 1;
			 case Icode_REG_STR2: return 1 + 2;
			 case Icode_REG_STR4: return 1 + 4;
			 case Icode_GETVAR1: case Icode_SETVAR1: case Icode_SETCONSTVAR1: return 1 + 1;
			 case Icode_LINE : return 1 + 2;
		 }
		 if (!validBytecode(bytecode)) throw Kit.codeBug();
		 return 1;
	 }
	 static int[] getLineNumbers(InterpreterData data) {
		 UintMap presentLines = new UintMap();
		 byte[] iCode = data.itsICode;
		 int iCodeLength = iCode.length;
		 for (int pc = 0;
		 pc != iCodeLength;
		) {
			 int bytecode = iCode[pc];
			 int span = bytecodeSpan(bytecode);
			 if (bytecode == Icode_LINE) {
				 if (span != 3) Kit.codeBug();
				 int line = getIndex(iCode, pc + 1);
				 presentLines.put(line, 0);
			 }
			 pc += span;
		 }
		 return presentLines.getKeys();
	 }
	 static void captureInterpreterStackInfo(RhinoException ex) {
		 Context cx = Context.getCurrentContext();
		 if (cx == null || cx.lastInterpreterFrame == null) {
			 ex.interpreterStackInfo = null;
			 ex.interpreterLineData = null;
			 return;
		 }
		 CallFrame[] array;
		 if (cx.previousInterpreterInvocations == null || cx.previousInterpreterInvocations.size() == 0) {
			 array = new CallFrame[1];
		 }
		 else {
			 int previousCount = cx.previousInterpreterInvocations.size();
			 if (cx.previousInterpreterInvocations.peek() == cx.lastInterpreterFrame) {
				 --previousCount;
			 }
			 array = new CallFrame[previousCount + 1];
			 cx.previousInterpreterInvocations.toArray(array);
		 }
		 array[array.length - 1] = (CallFrame)cx.lastInterpreterFrame;
		 int interpreterFrameCount = 0;
		 for (int i = 0;
		 i != array.length;
		 ++i) {
			 interpreterFrameCount += 1 + array[i].frameIndex;
		 }
		 int[] linePC = new int[interpreterFrameCount];
		 int linePCIndex = interpreterFrameCount;
		 for (int i = array.length;
		 i != 0;
		) {
			 --i;
			 CallFrame frame = array[i];
			 while (frame != null) {
				 --linePCIndex;
				 linePC[linePCIndex] = frame.pcSourceLineStart;
				 frame = frame.parentFrame;
			 }
		 }
		 if (linePCIndex != 0) Kit.codeBug();
		 ex.interpreterStackInfo = array;
		 ex.interpreterLineData = linePC;
	 }
	 static String getSourcePositionFromStack(Context cx, int[] linep) {
		 CallFrame frame = (CallFrame)cx.lastInterpreterFrame;
		 InterpreterData idata = frame.idata;
		 if (frame.pcSourceLineStart >= 0) {
			 linep[0] = getIndex(idata.itsICode, frame.pcSourceLineStart);
		 }
		 else {
			 linep[0] = 0;
		 }
		 return idata.itsSourceFile;
	 }
	 static String getPatchedStack(RhinoException ex, String nativeStackTrace) {
		 String tag = ""org.mozilla.javascript.Interpreter.interpretLoop"";
		 StringBuffer sb = new StringBuffer(nativeStackTrace.length() + 1000);
		 String lineSeparator = SecurityUtilities.getSystemProperty(""line.separator"");
		 CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;
		 int[] linePC = ex.interpreterLineData;
		 int arrayIndex = array.length;
		 int linePCIndex = linePC.length;
		 int offset = 0;
		 while (arrayIndex != 0) {
			 --arrayIndex;
			 int pos = nativeStackTrace.indexOf(tag, offset);
			 if (pos < 0) {
				 break;
			 }
			 pos += tag.length();
			 for (;
			 pos != nativeStackTrace.length();
			 ++pos) {
				 char c = nativeStackTrace.charAt(pos);
				 if (c == '\n' || c == '\r') {
					 break;
				 }
			 }
			 sb.append(nativeStackTrace.substring(offset, pos));
			 offset = pos;
			 CallFrame frame = array[arrayIndex];
			 while (frame != null) {
				 if (linePCIndex == 0) Kit.codeBug();
				 --linePCIndex;
				 InterpreterData idata = frame.idata;
				 sb.append(lineSeparator);
				 sb.append(""\tat script"");
				 if (idata.itsName != null && idata.itsName.length() != 0) {
					 sb.append('.');
					 sb.append(idata.itsName);
				 }
				 sb.append('(');
				 sb.append(idata.itsSourceFile);
				 int pc = linePC[linePCIndex];
				 if (pc >= 0) {
					 sb.append(':');
					 sb.append(getIndex(idata.itsICode, pc));
				 }
				 sb.append(')');
				 frame = frame.parentFrame;
			 }
		 }
		 sb.append(nativeStackTrace.substring(offset));
		 return sb.toString();
	 }
	 static List getScriptStack(RhinoException ex) {
		 if (ex.interpreterStackInfo == null) {
			 return null;
		 }
		 List list = new ArrayList();
		 String lineSeparator = SecurityUtilities.getSystemProperty(""line.separator"");
		 CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;
		 int[] linePC = ex.interpreterLineData;
		 int arrayIndex = array.length;
		 int linePCIndex = linePC.length;
		 while (arrayIndex != 0) {
			 --arrayIndex;
			 StringBuffer sb = new StringBuffer();
			 CallFrame frame = array[arrayIndex];
			 while (frame != null) {
				 if (linePCIndex == 0) Kit.codeBug();
				 --linePCIndex;
				 InterpreterData idata = frame.idata;
				 sb.append(""\tat "");
				 sb.append(idata.itsSourceFile);
				 int pc = linePC[linePCIndex];
				 if (pc >= 0) {
					 sb.append(':');
					 sb.append(getIndex(idata.itsICode, pc));
				 }
				 if (idata.itsName != null && idata.itsName.length() != 0) {
					 sb.append("" ("");
					 sb.append(idata.itsName);
					 sb.append(')');
				 }
				 sb.append(lineSeparator);
				 frame = frame.parentFrame;
			 }
			 list.add(sb.toString());
		 }
		 return list;
	 }
	 static String getEncodedSource(InterpreterData idata) {
		 if (idata.encodedSource == null) {
			 return null;
		 }
		 return idata.encodedSource.substring(idata.encodedSourceStart, idata.encodedSourceEnd);
	 }
	 private static void initFunction(Context cx, Scriptable scope, InterpretedFunction parent, int index) {
		 InterpretedFunction fn;
		 fn = InterpretedFunction.createFunction(cx, scope, parent, index);
		 ScriptRuntime.initFunction(cx, scope, fn, fn.idata.itsFunctionType, parent.idata.evalScriptFlag);
	 }
	 static Object interpret(InterpretedFunction ifun, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) Kit.codeBug();
		 if (cx.interpreterSecurityDomain != ifun.securityDomain) {
			 Object savedDomain = cx.interpreterSecurityDomain;
			 cx.interpreterSecurityDomain = ifun.securityDomain;
			 try {
				 return ifun.securityController.callWithDomain( ifun.securityDomain, cx, ifun, scope, thisObj, args);
			 }
			 finally {
				 cx.interpreterSecurityDomain = savedDomain;
			 }
		 }
		 CallFrame frame = new CallFrame();
		 initFrame(cx, scope, thisObj, args, null, 0, args.length, ifun, null, frame);
		 return interpretLoop(cx, frame, null);
	 }
	 public static Object restartContinuation(Continuation c, Context cx, Scriptable scope, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) {
			 return ScriptRuntime.doTopCall(c, cx, scope, null, args);
		 }
		 Object arg;
		 if (args.length == 0) {
			 arg = Undefined.instance;
		 }
		 else {
			 arg = args[0];
		 }
		 CallFrame capturedFrame = (CallFrame)c.getImplementation();
		 if (capturedFrame == null) {
			 return arg;
		 }
		 ContinuationJump cjump = new ContinuationJump(c, null);
		 cjump.result = arg;
		 return interpretLoop(cx, null, cjump);
	 }
	 private static Object interpretLoop(Context cx, CallFrame frame, Object throwable) {
		 final Object DBL_MRK = UniqueTag.DOUBLE_MARK;
		 final Object undefined = Undefined.instance;
		 final boolean instructionCounting = (cx.instructionThreshold != 0);
		 final int INVOCATION_COST = 100;
		 final int EXCEPTION_COST = 100;
		 String stringReg = null;
		 int indexReg = -1;
		 if (cx.lastInterpreterFrame != null) {
			 if (cx.previousInterpreterInvocations == null) {
				 cx.previousInterpreterInvocations = new ObjArray();
			 }
			 cx.previousInterpreterInvocations.push(cx.lastInterpreterFrame);
		 }
		 if (throwable != null) {
			 if (!(throwable instanceof ContinuationJump)) {
				 Kit.codeBug();
			 }
		 }
		 Object interpreterResult = null;
		 double interpreterResultDbl = 0.0;
		 StateLoop: for (;
		;
		) {
			 withoutExceptions: try {
				 if (throwable != null) {
					 if (indexReg >= 0) {
						 if (frame.frozen) {
							 frame = frame.cloneFrozen();
						 }
						 int[] table = frame.idata.itsExceptionTable;
						 frame.pc = table[indexReg + EXCEPTION_HANDLER_SLOT];
						 if (instructionCounting) {
							 frame.pcPrevBranch = frame.pc;
						 }
						 frame.savedStackTop = frame.emptyStackTop;
						 int scopeLocal = frame.localShift + table[indexReg + EXCEPTION_SCOPE_SLOT];
						 int exLocal = frame.localShift + table[indexReg + EXCEPTION_LOCAL_SLOT];
						 frame.scope = (Scriptable)frame.stack[scopeLocal];
						 frame.stack[exLocal] = throwable;
						 throwable = null;
					 }
					 else {
						 ContinuationJump cjump = (ContinuationJump)throwable;
						 throwable = null;
						 if (cjump.branchFrame != frame) Kit.codeBug();
						 if (cjump.capturedFrame == null) Kit.codeBug();
						 int rewindCount = cjump.capturedFrame.frameIndex + 1;
						 if (cjump.branchFrame != null) {
							 rewindCount -= cjump.branchFrame.frameIndex;
						 }
						 int enterCount = 0;
						 CallFrame[] enterFrames = null;
						 CallFrame x = cjump.capturedFrame;
						 for (int i = 0;
						 i != rewindCount;
						 ++i) {
							 if (!x.frozen) Kit.codeBug();
							 if (isFrameEnterExitRequired(x)) {
								 if (enterFrames == null) {
									 enterFrames = new CallFrame[rewindCount - i];
								 }
								 enterFrames[enterCount] = x;
								 ++enterCount;
							 }
							 x = x.parentFrame;
						 }
						 while (enterCount != 0) {
							 --enterCount;
							 x = enterFrames[enterCount];
							 enterFrame(cx, x, ScriptRuntime.emptyArgs, true);
						 }
						 frame = cjump.capturedFrame.cloneFrozen();
						 setCallResult(frame, cjump.result, cjump.resultDbl);
					 }
				 }
				 else {
					 if (frame.frozen) Kit.codeBug();
				 }
				 Object[] stack = frame.stack;
				 double[] sDbl = frame.sDbl;
				 Object[] vars = frame.varSource.stack;
				 double[] varDbls = frame.varSource.sDbl;
				 int[] varAttributes = frame.varSource.stackAttributes;
				 byte[] iCode = frame.idata.itsICode;
				 String[] strings = frame.idata.itsStringTable;
				 int stackTop = frame.savedStackTop;
				 cx.lastInterpreterFrame = frame;
				 Loop: for (;
				;
				) {
					 int op = iCode[frame.pc++];
					 jumplessRun: {
						switch (op) {
							 case Token.THROW: {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int sourceLine = getIndex(iCode, frame.pc);
								 throwable = new JavaScriptException(value, frame.idata.itsSourceFile, sourceLine);
								 break withoutExceptions;
							 }
							 case Token.RETHROW: {
								 indexReg += frame.localShift;
								 throwable = stack[indexReg];
								 break withoutExceptions;
							 }
							 case Token.GE : case Token.LE : case Token.GT : case Token.LT : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 object_compare: {
									 number_compare: {
										 double rDbl, lDbl;
										 if (rhs == DBL_MRK) {
											 rDbl = sDbl[stackTop + 1];
											 lDbl = stack_double(frame, stackTop);
										 }
										 else if (lhs == DBL_MRK) {
											 rDbl = ScriptRuntime.toNumber(rhs);
											 lDbl = sDbl[stackTop];
										 }
										 else {
											 break number_compare;
										 }
										 switch (op) {
											 case Token.GE: valBln = (lDbl >= rDbl);
											 break object_compare;
											 case Token.LE: valBln = (lDbl <= rDbl);
											 break object_compare;
											 case Token.GT: valBln = (lDbl > rDbl);
											 break object_compare;
											 case Token.LT: valBln = (lDbl < rDbl);
											 break object_compare;
											 default: throw Kit.codeBug();
										 }
									 }
									 switch (op) {
										 case Token.GE: valBln = ScriptRuntime.cmp_LE(rhs, lhs);
										 break;
										 case Token.LE: valBln = ScriptRuntime.cmp_LE(lhs, rhs);
										 break;
										 case Token.GT: valBln = ScriptRuntime.cmp_LT(rhs, lhs);
										 break;
										 case Token.LT: valBln = ScriptRuntime.cmp_LT(lhs, rhs);
										 break;
										 default: throw Kit.codeBug();
									 }
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IN : case Token.INSTANCEOF : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 boolean valBln;
								 if (op == Token.IN) {
									 valBln = ScriptRuntime.in(lhs, rhs, cx);
								 }
								 else {
									 valBln = ScriptRuntime.instanceOf(lhs, rhs, cx);
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.EQ : case Token.NE : {
								 --stackTop;
								 boolean valBln;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 if (rhs == DBL_MRK) {
									 if (lhs == DBL_MRK) {
										 valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
									 }
									 else {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
									 }
								 }
								 else {
									 if (lhs == DBL_MRK) {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
									 }
									 else {
										 valBln = ScriptRuntime.eq(lhs, rhs);
									 }
								 }
								 valBln ^= (op == Token.NE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.SHEQ : case Token.SHNE : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 shallow_compare: {
									 double rdbl, ldbl;
									 if (rhs == DBL_MRK) {
										 rdbl = sDbl[stackTop + 1];
										 if (lhs == DBL_MRK) {
											 ldbl = sDbl[stackTop];
										 }
										 else if (lhs instanceof Number) {
											 ldbl = ((Number)lhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else if (lhs == DBL_MRK) {
										 ldbl = sDbl[stackTop];
										 if (rhs == DBL_MRK) {
											 rdbl = sDbl[stackTop + 1];
										 }
										 else if (rhs instanceof Number) {
											 rdbl = ((Number)rhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else {
										 valBln = ScriptRuntime.shallowEq(lhs, rhs);
										 break shallow_compare;
									 }
									 valBln = (ldbl == rdbl);
								 }
								 valBln ^= (op == Token.SHNE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IFNE : if (stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Token.IFEQ : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Icode_IFEQ_POP : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 stack[stackTop--] = null;
							 break jumplessRun;
							 case Token.GOTO : break jumplessRun;
							 case Icode_GOSUB : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.pc + 2;
							 break jumplessRun;
							 case Icode_STARTSUB : if (stackTop == frame.emptyStackTop + 1) {
								 indexReg += frame.localShift;
								 stack[indexReg] = stack[stackTop];
								 sDbl[indexReg] = sDbl[stackTop];
								 --stackTop;
							 }
							 else {
								 if (stackTop != frame.emptyStackTop) Kit.codeBug();
							 }
							 continue Loop;
							 case Icode_RETSUB : {
								 if (instructionCounting) {
									 addInstructionCount(cx, frame, 0);
								 }
								 indexReg += frame.localShift;
								 Object value = stack[indexReg];
								 if (value != DBL_MRK) {
									 throwable = value;
									 break withoutExceptions;
								 }
								 frame.pc = (int)sDbl[indexReg];
								 if (instructionCounting) {
									 frame.pcPrevBranch = frame.pc;
								 }
								 continue Loop;
							 }
							 case Icode_POP : stack[stackTop] = null;
							 stackTop--;
							 continue Loop;
							 case Icode_POP_RESULT : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 stack[stackTop] = null;
							 --stackTop;
							 continue Loop;
							 case Icode_DUP : stack[stackTop + 1] = stack[stackTop];
							 sDbl[stackTop + 1] = sDbl[stackTop];
							 stackTop++;
							 continue Loop;
							 case Icode_DUP2 : stack[stackTop + 1] = stack[stackTop - 1];
							 sDbl[stackTop + 1] = sDbl[stackTop - 1];
							 stack[stackTop + 2] = stack[stackTop];
							 sDbl[stackTop + 2] = sDbl[stackTop];
							 stackTop += 2;
							 continue Loop;
							 case Icode_SWAP : {
								 Object o = stack[stackTop];
								 stack[stackTop] = stack[stackTop - 1];
								 stack[stackTop - 1] = o;
								 double d = sDbl[stackTop];
								 sDbl[stackTop] = sDbl[stackTop - 1];
								 sDbl[stackTop - 1] = d;
								 continue Loop;
							 }
							 case Token.RETURN : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 --stackTop;
							 break Loop;
							 case Token.RETURN_RESULT : break Loop;
							 case Icode_RETUNDEF : frame.result = undefined;
							 break Loop;
							 case Token.BITNOT : {
								 int rIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ~rIntValue;
								 continue Loop;
							 }
							 case Token.BITAND : case Token.BITOR : case Token.BITXOR : case Token.LSH : case Token.RSH : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.BITAND: lIntValue &= rIntValue;
									 break;
									 case Token.BITOR: lIntValue |= rIntValue;
									 break;
									 case Token.BITXOR: lIntValue ^= rIntValue;
									 break;
									 case Token.LSH: lIntValue <<= rIntValue;
									 break;
									 case Token.RSH: lIntValue >>= rIntValue;
									 break;
								 }
								 sDbl[stackTop] = lIntValue;
								 continue Loop;
							 }
							 case Token.URSH : {
								 int rIntValue = stack_int32(frame, stackTop) & 0x1F;
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;
								 continue Loop;
							 }
							 case Token.NEG : case Token.POS : {
								 double rDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 if (op == Token.NEG) {
									 rDbl = -rDbl;
								 }
								 sDbl[stackTop] = rDbl;
								 continue Loop;
							 }
							 case Token.ADD : --stackTop;
							 do_add(stack, sDbl, stackTop, cx);
							 continue Loop;
							 case Token.SUB : case Token.MUL : case Token.DIV : case Token.MOD : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.SUB: lDbl -= rDbl;
									 break;
									 case Token.MUL: lDbl *= rDbl;
									 break;
									 case Token.DIV: lDbl /= rDbl;
									 break;
									 case Token.MOD: lDbl %= rDbl;
									 break;
								 }
								 sDbl[stackTop] = lDbl;
								 continue Loop;
							 }
							 case Token.NOT : stack[stackTop] = ScriptRuntime.wrapBoolean( !stack_boolean(frame, stackTop));
							 continue Loop;
							 case Token.BINDNAME : stack[++stackTop] = ScriptRuntime.bind(cx, frame.scope, stringReg);
							 continue Loop;
							 case Token.SETNAME : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable lhs = (Scriptable)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx, frame.scope, stringReg);
								 continue Loop;
							 }
							 case Icode_SETCONST: {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable lhs = (Scriptable)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.setConst(lhs, rhs, cx, stringReg);
								 continue Loop;
							 }
							 case Token.DELPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.delete(lhs, rhs, cx);
								 continue Loop;
							 }
							 case Token.GETPROP : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getObjectProp(lhs, stringReg, cx);
								 continue Loop;
							 }
							 case Token.SETPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setObjectProp(lhs, stringReg, rhs, cx);
								 continue Loop;
							 }
							 case Icode_PROP_INC_DEC : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.propIncrDecr(lhs, stringReg, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GETELEM : {
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.getObjectElem(lhs, id, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.getObjectIndex(lhs, d, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Token.SETELEM : {
								 stackTop -= 2;
								 Object rhs = stack[stackTop + 2];
								 if (rhs == DBL_MRK) {
									 rhs = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);
								 }
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.setObjectElem(lhs, id, rhs, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.setObjectIndex(lhs, d, rhs, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Icode_ELEM_INC_DEC: {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.elemIncrDecr(lhs, rhs, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GET_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refGet(ref, cx);
								 continue Loop;
							 }
							 case Token.SET_REF : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refSet(ref, value, cx);
								 continue Loop;
							 }
							 case Token.DEL_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refDel(ref, cx);
								 continue Loop;
							 }
							 case Icode_REF_INC_DEC : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refIncrDecr(ref, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.LOCAL_LOAD : ++stackTop;
							 indexReg += frame.localShift;
							 stack[stackTop] = stack[indexReg];
							 sDbl[stackTop] = sDbl[indexReg];
							 continue Loop;
							 case Icode_LOCAL_CLEAR : indexReg += frame.localShift;
							 stack[indexReg] = null;
							 continue Loop;
							 case Icode_NAME_AND_THIS : ++stackTop;
							 stack[stackTop] = ScriptRuntime.getNameFunctionAndThis(stringReg, cx, frame.scope);
							 ++stackTop;
							 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
							 continue Loop;
							 case Icode_PROP_AND_THIS: {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getPropFunctionAndThis(obj, stringReg, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_ELEM_AND_THIS: {
								 Object obj = stack[stackTop - 1];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop - 1]);
								 Object id = stack[stackTop];
								 if (id == DBL_MRK) id = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop - 1] = ScriptRuntime.getElemFunctionAndThis(obj, id, cx);
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_VALUE_AND_THIS : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getValueFunctionAndThis(value, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_CALLSPECIAL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 int callType = iCode[frame.pc] & 0xFF;
								 boolean isNew = (iCode[frame.pc + 1] != 0);
								 int sourceLine = getIndex(iCode, frame.pc + 2);
								 if (isNew) {
									 stackTop -= indexReg;
									 Object function = stack[stackTop];
									 if (function == DBL_MRK) function = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 1, indexReg);
									 stack[stackTop] = ScriptRuntime.newSpecial( cx, function, outArgs, frame.scope, callType);
								 }
								 else {
									 stackTop -= 1 + indexReg;
									 Scriptable functionThis = (Scriptable)stack[stackTop + 1];
									 Callable function = (Callable)stack[stackTop];
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callSpecial( cx, function, functionThis, outArgs, frame.scope, frame.thisObj, callType, frame.idata.itsSourceFile, sourceLine);
								 }
								 frame.pc += 4;
								 continue Loop;
							 }
							 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= 1 + indexReg;
								 Callable fun = (Callable)stack[stackTop];
								 Scriptable funThisObj = (Scriptable)stack[stackTop + 1];
								 if (op == Token.REF_CALL) {
									 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callRef(fun, funThisObj, outArgs, cx);
									 continue Loop;
								 }
								 Scriptable calleeScope = frame.scope;
								 if (frame.useActivation) {
									 calleeScope = ScriptableObject.getTopLevelScope(frame.scope);
								 }
								 if (fun instanceof InterpretedFunction) {
									 InterpretedFunction ifun = (InterpretedFunction)fun;
									 if (frame.fnOrScript.securityDomain == ifun.securityDomain) {
										 CallFrame callParentFrame = frame;
										 CallFrame calleeFrame = new CallFrame();
										 if (op == Icode_TAIL_CALL) {
											 callParentFrame = frame.parentFrame;
											 exitFrame(cx, frame, null);
										 }
										 initFrame(cx, calleeScope, funThisObj, stack, sDbl, stackTop + 2, indexReg, ifun, callParentFrame, calleeFrame);
										 if (op != Icode_TAIL_CALL) {
											 frame.savedStackTop = stackTop;
											 frame.savedCallOp = op;
										 }
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (fun instanceof Continuation) {
									 ContinuationJump cjump;
									 cjump = new ContinuationJump((Continuation)fun, frame);
									 if (indexReg == 0) {
										 cjump.result = undefined;
									 }
									 else {
										 cjump.result = stack[stackTop + 2];
										 cjump.resultDbl = sDbl[stackTop + 2];
									 }
									 throwable = cjump;
									 break withoutExceptions;
								 }
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
								 stack[stackTop] = fun.call(cx, calleeScope, funThisObj, outArgs);
								 continue Loop;
							 }
							 case Token.NEW : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= indexReg;
								 Object lhs = stack[stackTop];
								 if (lhs instanceof InterpretedFunction) {
									 InterpretedFunction f = (InterpretedFunction)lhs;
									 if (frame.fnOrScript.securityDomain == f.securityDomain) {
										 Scriptable newInstance = f.createObject(cx, frame.scope);
										 CallFrame calleeFrame = new CallFrame();
										 initFrame(cx, frame.scope, newInstance, stack, sDbl, stackTop + 1, indexReg, f, frame, calleeFrame);
										 stack[stackTop] = newInstance;
										 frame.savedStackTop = stackTop;
										 frame.savedCallOp = op;
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (!(lhs instanceof Function)) {
									 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 throw ScriptRuntime.notFunctionError(lhs);
								 }
								 Function fun = (Function)lhs;
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 1, indexReg);
								 stack[stackTop] = fun.construct(cx, frame.scope, outArgs);
								 continue Loop;
							 }
							 case Token.TYPEOF : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.typeof(lhs);
								 continue Loop;
							 }
							 case Icode_TYPEOFNAME : stack[++stackTop] = ScriptRuntime.typeofName(frame.scope, stringReg);
							 continue Loop;
							 case Token.STRING : stack[++stackTop] = stringReg;
							 continue Loop;
							 case Icode_SHORTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getShort(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_INTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Token.NUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.idata.itsDoubleTable[indexReg];
							 continue Loop;
							 case Token.NAME : stack[++stackTop] = ScriptRuntime.name(cx, frame.scope, stringReg);
							 continue Loop;
							 case Icode_NAME_INC_DEC : stack[++stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, stringReg, cx, iCode[frame.pc]);
							 ++frame.pc;
							 continue Loop;
							 case Icode_SETCONSTVAR1: indexReg = iCode[frame.pc++];
							 case Token.SETCONSTVAR : if (!frame.useActivation) {
								 if ((varAttributes[indexReg] & ScriptableObject.READONLY) == 0) {
									 throw Context.reportRuntimeError1(""msg.var.redecl"", frame.idata.argNames[indexReg]);
								 }
								 if ((varAttributes[indexReg] & ScriptableObject.UNINITIALIZED_CONST) != 0) {
									 vars[indexReg] = stack[stackTop];
									 varAttributes[indexReg] &= ~ScriptableObject.UNINITIALIZED_CONST;
									 varDbls[indexReg] = sDbl[stackTop];
								 }
							 }
							 else {
								 Object val = stack[stackTop];
								 if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stringReg = frame.idata.argNames[indexReg];
								 if (frame.scope instanceof ConstProperties) {
									 ConstProperties cp = (ConstProperties)frame.scope;
									 cp.putConst(stringReg, frame.scope, val);
								 }
								 else throw Kit.codeBug();
							 }
							 continue Loop;
							 case Icode_SETVAR1: indexReg = iCode[frame.pc++];
							 case Token.SETVAR : if (!frame.useActivation) {
								 if ((varAttributes[indexReg] & ScriptableObject.READONLY) == 0) {
									 vars[indexReg] = stack[stackTop];
									 varDbls[indexReg] = sDbl[stackTop];
								 }
							 }
							 else {
								 Object val = stack[stackTop];
								 if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stringReg = frame.idata.argNames[indexReg];
								 frame.scope.put(stringReg, frame.scope, val);
							 }
							 continue Loop;
							 case Icode_GETVAR1: indexReg = iCode[frame.pc++];
							 case Token.GETVAR : ++stackTop;
							 if (!frame.useActivation) {
								 stack[stackTop] = vars[indexReg];
								 sDbl[stackTop] = varDbls[indexReg];
							 }
							 else {
								 stringReg = frame.idata.argNames[indexReg];
								 stack[stackTop] = frame.scope.get(stringReg, frame.scope);
							 }
							 continue Loop;
							 case Icode_VAR_INC_DEC : {
								 ++stackTop;
								 int incrDecrMask = iCode[frame.pc];
								 if (!frame.useActivation) {
									 stack[stackTop] = DBL_MRK;
									 Object varValue = vars[indexReg];
									 double d;
									 if (varValue == DBL_MRK) {
										 d = varDbls[indexReg];
									 }
									 else {
										 d = ScriptRuntime.toNumber(varValue);
										 vars[indexReg] = DBL_MRK;
									 }
									 double d2 = ((incrDecrMask & Node.DECR_FLAG) == 0) ? d + 1.0 : d - 1.0;
									 varDbls[indexReg] = d2;
									 sDbl[stackTop] = ((incrDecrMask & Node.POST_FLAG) == 0) ? d2 : d;
								 }
								 else {
									 String varName = frame.idata.argNames[indexReg];
									 stack[stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, varName, cx, incrDecrMask);
								 }
								 ++frame.pc;
								 continue Loop;
							 }
							 case Icode_ZERO : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_ONE : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 1;
							 continue Loop;
							 case Token.NULL : stack[++stackTop] = null;
							 continue Loop;
							 case Token.THIS : stack[++stackTop] = frame.thisObj;
							 continue Loop;
							 case Token.THISFN : stack[++stackTop] = frame.fnOrScript;
							 continue Loop;
							 case Token.FALSE : stack[++stackTop] = Boolean.FALSE;
							 continue Loop;
							 case Token.TRUE : stack[++stackTop] = Boolean.TRUE;
							 continue Loop;
							 case Icode_UNDEF : stack[++stackTop] = undefined;
							 continue Loop;
							 case Token.ENTERWITH : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterWith(lhs, cx, frame.scope);
								 continue Loop;
							 }
							 case Token.LEAVEWITH : frame.scope = ScriptRuntime.leaveWith(frame.scope);
							 continue Loop;
							 case Token.CATCH_SCOPE : {
								 --stackTop;
								 indexReg += frame.localShift;
								 boolean afterFirstScope = (frame.idata.itsICode[frame.pc] != 0);
								 Throwable caughtException = (Throwable)stack[stackTop + 1];
								 Scriptable lastCatchScope;
								 if (!afterFirstScope) {
									 lastCatchScope = null;
								 }
								 else {
									 lastCatchScope = (Scriptable)stack[indexReg];
								 }
								 stack[indexReg] = ScriptRuntime.newCatchScope(caughtException, lastCatchScope, stringReg, cx, frame.scope);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.ENUM_INIT_KEYS : case Token.ENUM_INIT_VALUES : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 indexReg += frame.localShift;
								 stack[indexReg] = ScriptRuntime.enumInit( lhs, cx, (op == Token.ENUM_INIT_VALUES));
								 continue Loop;
							 }
							 case Token.ENUM_NEXT : case Token.ENUM_ID : {
								 indexReg += frame.localShift;
								 Object val = stack[indexReg];
								 ++stackTop;
								 stack[stackTop] = (op == Token.ENUM_NEXT) ? (Object)ScriptRuntime.enumNext(val) : (Object)ScriptRuntime.enumId(val, cx);
								 continue Loop;
							 }
							 case Token.REF_SPECIAL : {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.specialRef(obj, stringReg, cx);
								 continue Loop;
							 }
							 case Token.REF_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, ns, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(ns, name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Icode_SCOPE_LOAD : indexReg += frame.localShift;
							 frame.scope = (Scriptable)stack[indexReg];
							 continue Loop;
							 case Icode_SCOPE_SAVE : indexReg += frame.localShift;
							 stack[indexReg] = frame.scope;
							 continue Loop;
							 case Icode_CLOSURE_EXPR : stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Icode_CLOSURE_STMT : initFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Token.REGEXP : stack[++stackTop] = frame.scriptRegExps[indexReg];
							 continue Loop;
							 case Icode_LITERAL_NEW : ++stackTop;
							 stack[stackTop] = new int[indexReg];
							 ++stackTop;
							 stack[stackTop] = new Object[indexReg];
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_LITERAL_SET : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Icode_LITERAL_GETTER : {
								 Object value = stack[stackTop];
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 ((int[])stack[stackTop - 1])[i] = -1;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Icode_LITERAL_SETTER : {
								 Object value = stack[stackTop];
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 ((int[])stack[stackTop - 1])[i] = +1;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Token.ARRAYLIT : case Icode_SPARE_ARRAYLIT : case Token.OBJECTLIT : {
								 Object[] data = (Object[])stack[stackTop];
								 --stackTop;
								 int[] getterSetters = (int[])stack[stackTop];
								 Object val;
								 if (op == Token.OBJECTLIT) {
									 Object[] ids = (Object[])frame.idata.literalIds[indexReg];
									 val = ScriptRuntime.newObjectLiteral(ids, data, getterSetters, cx, frame.scope);
								 }
								 else {
									 int[] skipIndexces = null;
									 if (op == Icode_SPARE_ARRAYLIT) {
										 skipIndexces = (int[])frame.idata.literalIds[indexReg];
									 }
									 val = ScriptRuntime.newArrayLiteral(data, skipIndexces, cx, frame.scope);
								 }
								 stack[stackTop] = val;
								 continue Loop;
							 }
							 case Icode_ENTERDQ : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterDotQuery(lhs, frame.scope);
								 continue Loop;
							 }
							 case Icode_LEAVEDQ : {
								 boolean valBln = stack_boolean(frame, stackTop);
								 Object x = ScriptRuntime.updateDotQuery(valBln, frame.scope);
								 if (x != null) {
									 stack[stackTop] = x;
									 frame.scope = ScriptRuntime.leaveDotQuery(frame.scope);
									 frame.pc += 2;
									 continue Loop;
								 }
								 --stackTop;
								 break jumplessRun;
							 }
							 case Token.DEFAULTNAMESPACE : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setDefaultNamespace(value, cx);
								 continue Loop;
							 }
							 case Token.ESCXMLATTR : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeAttributeValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Token.ESCXMLTEXT : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeTextValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Icode_LINE : frame.pcSourceLineStart = frame.pc;
							 if (frame.debuggerFrame != null) {
								 int line = getIndex(iCode, frame.pc);
								 frame.debuggerFrame.onLineChange(cx, line);
							 }
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND_C0: indexReg = 0;
							 continue Loop;
							 case Icode_REG_IND_C1: indexReg = 1;
							 continue Loop;
							 case Icode_REG_IND_C2: indexReg = 2;
							 continue Loop;
							 case Icode_REG_IND_C3: indexReg = 3;
							 continue Loop;
							 case Icode_REG_IND_C4: indexReg = 4;
							 continue Loop;
							 case Icode_REG_IND_C5: indexReg = 5;
							 continue Loop;
							 case Icode_REG_IND1: indexReg = 0xFF & iCode[frame.pc];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_IND2: indexReg = getIndex(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND4: indexReg = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Icode_REG_STR_C0: stringReg = strings[0];
							 continue Loop;
							 case Icode_REG_STR_C1: stringReg = strings[1];
							 continue Loop;
							 case Icode_REG_STR_C2: stringReg = strings[2];
							 continue Loop;
							 case Icode_REG_STR_C3: stringReg = strings[3];
							 continue Loop;
							 case Icode_REG_STR1: stringReg = strings[0xFF & iCode[frame.pc]];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_STR2: stringReg = strings[getIndex(iCode, frame.pc)];
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_STR4: stringReg = strings[getInt(iCode, frame.pc)];
							 frame.pc += 4;
							 continue Loop;
							 default : dumpICode(frame.idata);
							 throw new RuntimeException( ""Unknown icode : ""+op+"" @ pc : ""+(frame.pc-1));
						}
					 }
					 if (instructionCounting) {
						 addInstructionCount(cx, frame, 2);
					 }
					 int offset = getShort(iCode, frame.pc);
					 if (offset != 0) {
						 frame.pc += offset - 1;
					 }
					 else {
						 frame.pc = frame.idata.longJumps. getExistingInt(frame.pc);
					 }
					 if (instructionCounting) {
						 frame.pcPrevBranch = frame.pc;
					 }
					 continue Loop;
				 }
				 exitFrame(cx, frame, null);
				 interpreterResult = frame.result;
				 interpreterResultDbl = frame.resultDbl;
				 if (frame.parentFrame != null) {
					 frame = frame.parentFrame;
					 if (frame.frozen) {
						 frame = frame.cloneFrozen();
					 }
					 setCallResult( frame, interpreterResult, interpreterResultDbl);
					 interpreterResult = null;
					 continue StateLoop;
				 }
				 break StateLoop;
			 }
			 catch (Throwable ex) {
				 if (throwable != null) {
					 ex.printStackTrace(System.err);
					 throw new IllegalStateException();
				 }
				 throwable = ex;
			 }
			 if (throwable == null) Kit.codeBug();
			 final int EX_CATCH_STATE = 2;
			 final int EX_FINALLY_STATE = 1;
			 final int EX_NO_JS_STATE = 0;
			 int exState;
			 ContinuationJump cjump = null;
			 if (throwable instanceof JavaScriptException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EcmaError) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EvaluatorException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof RuntimeException) {
				 exState = EX_FINALLY_STATE;
			 }
			 else if (throwable instanceof Error) {
				 exState = EX_NO_JS_STATE;
			 }
			 else {
				 exState = EX_FINALLY_STATE;
				 cjump = (ContinuationJump)throwable;
			 }
			 if (instructionCounting) {
				 try {
					 addInstructionCount(cx, frame, EXCEPTION_COST);
				 }
				 catch (RuntimeException ex) {
					 throwable = ex;
					 exState = EX_FINALLY_STATE;
				 }
				 catch (Error ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 if (frame.debuggerFrame != null && throwable instanceof RuntimeException) {
				 RuntimeException rex = (RuntimeException)throwable;
				 try {
					 frame.debuggerFrame.onExceptionThrown(cx, rex);
				 }
				 catch (Throwable ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 for (;
			;
			) {
				 if (exState != EX_NO_JS_STATE) {
					 boolean onlyFinally = (exState != EX_CATCH_STATE);
					 indexReg = getExceptionHandler(frame, onlyFinally);
					 if (indexReg >= 0) {
						 continue StateLoop;
					 }
				 }
				 exitFrame(cx, frame, throwable);
				 frame = frame.parentFrame;
				 if (frame == null) {
					 break;
				 }
				 if (cjump != null && cjump.branchFrame == frame) {
					 indexReg = -1;
					 continue StateLoop;
				 }
			 }
			 if (cjump != null) {
				 if (cjump.branchFrame != null) {
					 Kit.codeBug();
				 }
				 if (cjump.capturedFrame != null) {
					 indexReg = -1;
					 continue StateLoop;
				 }
				 interpreterResult = cjump.result;
				 interpreterResultDbl = cjump.resultDbl;
				 throwable = null;
			 }
			 break StateLoop;
		 }
		 if (cx.previousInterpreterInvocations != null && cx.previousInterpreterInvocations.size() != 0) {
			 cx.lastInterpreterFrame = cx.previousInterpreterInvocations.pop();
		 }
		 else {
			 cx.lastInterpreterFrame = null;
			 cx.previousInterpreterInvocations = null;
		 }
		 if (throwable != null) {
			 if (throwable instanceof RuntimeException) {
				 throw (RuntimeException)throwable;
			 }
			 else {
				 throw (Error)throwable;
			 }
		 }
		 return (interpreterResult != DBL_MRK) ? interpreterResult : ScriptRuntime.wrapNumber(interpreterResultDbl);
	 }
	 private static void initFrame(Context cx, Scriptable callerScope, Scriptable thisObj, Object[] args, double[] argsDbl, int argShift, int argCount, InterpretedFunction fnOrScript, CallFrame parentFrame, CallFrame frame) {
		 InterpreterData idata = fnOrScript.idata;
		 boolean useActivation = idata.itsNeedsActivation;
		 DebugFrame debuggerFrame = null;
		 if (cx.debugger != null) {
			 debuggerFrame = cx.debugger.getFrame(cx, idata);
			 if (debuggerFrame != null) {
				 useActivation = true;
			 }
		 }
		 if (useActivation) {
			 if (argsDbl != null) {
				 args = getArgsArray(args, argsDbl, argShift, argCount);
			 }
			 argShift = 0;
			 argsDbl = null;
		 }
		 Scriptable scope;
		 if (idata.itsFunctionType != 0) {
			 if (!idata.useDynamicScope) {
				 scope = fnOrScript.getParentScope();
			 }
			 else {
				 scope = callerScope;
			 }
			 if (useActivation) {
				 scope = ScriptRuntime.createFunctionActivation( fnOrScript, scope, args);
			 }
		 }
		 else {
			 scope = callerScope;
			 ScriptRuntime.initScript(fnOrScript, thisObj, cx, scope, fnOrScript.idata.evalScriptFlag);
		 }
		 if (idata.itsNestedFunctions != null) {
			 if (idata.itsFunctionType != 0 && !idata.itsNeedsActivation) Kit.codeBug();
			 for (int i = 0;
			 i < idata.itsNestedFunctions.length;
			 i++) {
				 InterpreterData fdata = idata.itsNestedFunctions[i];
				 if (fdata.itsFunctionType == FunctionNode.FUNCTION_STATEMENT) {
					 initFunction(cx, scope, fnOrScript, i);
				 }
			 }
		 }
		 Scriptable[] scriptRegExps = null;
		 if (idata.itsRegExpLiterals != null) {
			 if (idata.itsFunctionType != 0) {
				 scriptRegExps = fnOrScript.functionRegExps;
			 }
			 else {
				 scriptRegExps = fnOrScript.createRegExpWraps(cx, scope);
			 }
		 }
		 int emptyStackTop = idata.itsMaxVars + idata.itsMaxLocals - 1;
		 int maxFrameArray = idata.itsMaxFrameArray;
		 if (maxFrameArray != emptyStackTop + idata.itsMaxStack + 1) Kit.codeBug();
		 Object[] stack;
		 int[] stackAttributes;
		 double[] sDbl;
		 boolean stackReuse;
		 if (frame.stack != null && maxFrameArray <= frame.stack.length) {
			 stackReuse = true;
			 stack = frame.stack;
			 stackAttributes = frame.stackAttributes;
			 sDbl = frame.sDbl;
		 }
		 else {
			 stackReuse = false;
			 stack = new Object[maxFrameArray];
			 stackAttributes = new int[maxFrameArray];
			 sDbl = new double[maxFrameArray];
		 }
		 int varCount = idata.getParamAndVarCount();
		 for (int i = 0;
		 i < varCount;
		 i++) {
			 if (idata.getParamOrVarConst(i)) stackAttributes[i] = ScriptableObject.CONST;
		 }
		 int definedArgs = idata.argCount;
		 if (definedArgs > argCount) {
			 definedArgs = argCount;
		 }
		 frame.parentFrame = parentFrame;
		 frame.frameIndex = (parentFrame == null) ? 0 : parentFrame.frameIndex + 1;
		 if(frame.frameIndex > cx.getMaximumInterpreterStackDepth()) {
			 throw Context.reportRuntimeError(""Exceeded maximum stack depth"");
		 }
		 frame.frozen = false;
		 frame.fnOrScript = fnOrScript;
		 frame.idata = idata;
		 frame.stack = stack;
		 frame.stackAttributes = stackAttributes;
		 frame.sDbl = sDbl;
		 frame.varSource = frame;
		 frame.localShift = idata.itsMaxVars;
		 frame.emptyStackTop = emptyStackTop;
		 frame.debuggerFrame = debuggerFrame;
		 frame.useActivation = useActivation;
		 frame.thisObj = thisObj;
		 frame.scriptRegExps = scriptRegExps;
		 frame.result = Undefined.instance;
		 frame.pc = 0;
		 frame.pcPrevBranch = 0;
		 frame.pcSourceLineStart = idata.firstLinePC;
		 frame.scope = scope;
		 frame.savedStackTop = emptyStackTop;
		 frame.savedCallOp = 0;
		 System.arraycopy(args, argShift, stack, 0, definedArgs);
		 if (argsDbl != null) {
			 System.arraycopy(argsDbl, argShift, sDbl, 0, definedArgs);
		 }
		 for (int i = definedArgs;
		 i != idata.itsMaxVars;
		 ++i) {
			 stack[i] = Undefined.instance;
		 }
		 if (stackReuse) {
			 for (int i = emptyStackTop + 1;
			 i != stack.length;
			 ++i) {
				 stack[i] = null;
			 }
		 }
		 enterFrame(cx, frame, args, false);
	 }
	 private static boolean isFrameEnterExitRequired(CallFrame frame) {
		 return frame.debuggerFrame != null || frame.idata.itsNeedsActivation;
	 }
	 private static void enterFrame(Context cx, CallFrame frame, Object[] args, boolean continuationRestart) {
		 boolean usesActivation = frame.idata.itsNeedsActivation;
		 boolean isDebugged = frame.debuggerFrame != null;
		 if(usesActivation || isDebugged) {
			 Scriptable scope = frame.scope;
			 if(scope == null) {
				 Kit.codeBug();
			 }
			 else if(continuationRestart) {
				 for(;
				;
				) {
					 if(scope instanceof NativeCall) {
						 break;
					 }
					 else {
						 scope = scope.getParentScope();
						 if(scope == null || (frame.parentFrame != null && frame.parentFrame.scope == scope)) {
							 Kit.codeBug();
							 break;
						 }
					 }
				 }
			 }
			 if (isDebugged) {
				 frame.debuggerFrame.onEnter(cx, scope, frame.thisObj, args);
			 }
			 if (usesActivation) {
				 ScriptRuntime.enterActivationFunction(cx, scope);
			 }
		 }
	 }
	 private static void exitFrame(Context cx, CallFrame frame, Object throwable) {
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.exitActivationFunction(cx);
		 }
		 if (frame.debuggerFrame != null) {
			 try {
				 if (throwable instanceof Throwable) {
					 frame.debuggerFrame.onExit(cx, true, throwable);
				 }
				 else {
					 Object result;
					 ContinuationJump cjump = (ContinuationJump)throwable;
					 if (cjump == null) {
						 result = frame.result;
					 }
					 else {
						 result = cjump.result;
					 }
					 if (result == UniqueTag.DOUBLE_MARK) {
						 double resultDbl;
						 if (cjump == null) {
							 resultDbl = frame.resultDbl;
						 }
						 else {
							 resultDbl = cjump.resultDbl;
						 }
						 result = ScriptRuntime.wrapNumber(resultDbl);
					 }
					 frame.debuggerFrame.onExit(cx, false, result);
				 }
			 }
			 catch (Throwable ex) {
				 System.err.println(""RHINO USAGE WARNING: onExit terminated with exception"");
				 ex.printStackTrace(System.err);
			 }
		 }
	 }
	 private static void setCallResult(CallFrame frame, Object callResult, double callResultDbl) {
		 if (frame.savedCallOp == Token.CALL) {
			 frame.stack[frame.savedStackTop] = callResult;
			 frame.sDbl[frame.savedStackTop] = callResultDbl;
		 }
		 else if (frame.savedCallOp == Token.NEW) {
			 if (callResult instanceof Scriptable) {
				 frame.stack[frame.savedStackTop] = callResult;
			 }
		 }
		 else {
			 Kit.codeBug();
		 }
		 frame.savedCallOp = 0;
	 }
	 private static void captureContinuation(Context cx, CallFrame frame, int stackTop) {
		 Continuation c = new Continuation();
		 ScriptRuntime.setObjectProtoAndParent( c, ScriptRuntime.getTopCallScope(cx));
		 CallFrame x = frame.parentFrame;
		 while (x != null && !x.frozen) {
			 x.frozen = true;
			 for (int i = x.savedStackTop + 1;
			 i != x.stack.length;
			 ++i) {
				 x.stack[i] = null;
				 x.stackAttributes[i] = ScriptableObject.EMPTY;
			 }
			 if (x.savedCallOp == Token.CALL) {
				 x.stack[x.savedStackTop] = null;
			 }
			 else {
				 if (x.savedCallOp != Token.NEW) Kit.codeBug();
			 }
			 x = x.parentFrame;
		 }
		 c.initImplementation(frame.parentFrame);
		 frame.stack[stackTop] = c;
	 }
	 private static int stack_int32(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 double value;
		 if (x == UniqueTag.DOUBLE_MARK) {
			 value = frame.sDbl[i];
		 }
		 else {
			 value = ScriptRuntime.toNumber(x);
		 }
		 return ScriptRuntime.toInt32(value);
	 }
	 private static double stack_double(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x != UniqueTag.DOUBLE_MARK) {
			 return ScriptRuntime.toNumber(x);
		 }
		 else {
			 return frame.sDbl[i];
		 }
	 }
	 private static boolean stack_boolean(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x == Boolean.TRUE) {
			 return true;
		 }
		 else if (x == Boolean.FALSE) {
			 return false;
		 }
		 else if (x == UniqueTag.DOUBLE_MARK) {
			 double d = frame.sDbl[i];
			 return d == d && d != 0.0;
		 }
		 else if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 double d = ((Number)x).doubleValue();
			 return (d == d && d != 0.0);
		 }
		 else if (x instanceof Boolean) {
			 return ((Boolean)x).booleanValue();
		 }
		 else {
			 return ScriptRuntime.toBoolean(x);
		 }
	 }
	 private static void do_add(Object[] stack, double[] sDbl, int stackTop, Context cx) {
		 Object rhs = stack[stackTop + 1];
		 Object lhs = stack[stackTop];
		 double d;
		 boolean leftRightOrder;
		 if (rhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop + 1];
			 if (lhs == UniqueTag.DOUBLE_MARK) {
				 sDbl[stackTop] += d;
				 return;
			 }
			 leftRightOrder = true;
		 }
		 else if (lhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop];
			 lhs = rhs;
			 leftRightOrder = false;
		 }
		 else {
			 if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
				 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
			 }
			 else if (lhs instanceof String) {
				 String lstr = (String)lhs;
				 String rstr = ScriptRuntime.toString(rhs);
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else if (rhs instanceof String) {
				 String lstr = ScriptRuntime.toString(lhs);
				 String rstr = (String)rhs;
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
				 double rDbl = (rhs instanceof Number) ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
				 stack[stackTop] = UniqueTag.DOUBLE_MARK;
				 sDbl[stackTop] = lDbl + rDbl;
			 }
			 return;
		 }
		 if (lhs instanceof Scriptable) {
			 rhs = ScriptRuntime.wrapNumber(d);
			 if (!leftRightOrder) {
				 Object tmp = lhs;
				 lhs = rhs;
				 rhs = tmp;
			 }
			 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
		 }
		 else if (lhs instanceof String) {
			 String lstr = (String)lhs;
			 String rstr = ScriptRuntime.toString(d);
			 if (leftRightOrder) {
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 stack[stackTop] = rstr.concat(lstr);
			 }
		 }
		 else {
			 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
			 stack[stackTop] = UniqueTag.DOUBLE_MARK;
			 sDbl[stackTop] = lDbl + d;
		 }
	 }
	 private static Object[] getArgsArray(Object[] stack, double[] sDbl, int shift, int count) {
		 if (count == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] args = new Object[count];
		 for (int i = 0;
		 i != count;
		 ++i, ++shift) {
			 Object val = stack[shift];
			 if (val == UniqueTag.DOUBLE_MARK) {
				 val = ScriptRuntime.wrapNumber(sDbl[shift]);
			 }
			 args[i] = val;
		 }
		 return args;
	 }
	 private static void addInstructionCount(Context cx, CallFrame frame, int extra) {
		 cx.instructionCount += frame.pc - frame.pcPrevBranch + extra;
		 if (cx.instructionCount > cx.instructionThreshold) {
			 cx.observeInstructionCount(cx.instructionCount);
			 cx.instructionCount = 0;
		 }
	 }
}",1,0,0,0
"public class Form<T> extends WebMarkupContainer implements IFormSubmitListener, IHeaderContributor{
	private static final String HIDDEN_DIV_START = ""<div style=\""width:0px;
	height:0px;
	position:absolute;
	left:-100px;
	top:-100px;
	overflow:hidden\"">"";
	public static abstract class ValidationVisitor implements FormComponent.IVisitor{
		public Object formComponent(IFormVisitorParticipant component){
			if (component instanceof FormComponent){
				FormComponent<?> formComponent = (FormComponent<?>)component;
				Form<?> form = formComponent.getForm();
				if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()){
					return Component.IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
				}
				if (formComponent.isVisibleInHierarchy() && formComponent.isValid() &&formComponent.isEnabledInHierarchy()){
					validate(formComponent);
				}
			}
			if (component.processChildren()){
				return Component.IVisitor.CONTINUE_TRAVERSAL;
			}
			else{
				return Component.IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		}
		public abstract void validate(FormComponent<?> formComponent);
	}
	private static class FormModelUpdateVisitor implements Component.IVisitor<Component>{
		private final Form<?> formFilter;
		public FormModelUpdateVisitor(Form<?> formFilter){
			this.formFilter = formFilter;
		}
		public Object component(Component component){
			if (component instanceof IFormModelUpdateListener){
				final Form<?> form = Form.findForm(component);
				if (form != null){
					if (this.formFilter == null || this.formFilter == form){
						if (form.isEnabledInHierarchy()){
							if (component.isVisibleInHierarchy() &&component.isEnabledInHierarchy()){
								((IFormModelUpdateListener)component).updateModel();
							}
						}
					}
				}
			}
			return Component.IVisitor.CONTINUE_TRAVERSAL;
		}
	}
	class FormDispatchRequest extends Request{
		private final Map<String, String[]> params = new HashMap<String, String[]>();
		private final Request realRequest;
		private final String url;
		public FormDispatchRequest(final Request realRequest, final String url){
			this.realRequest = realRequest;
			this.url = realRequest.decodeURL(url);
			String queryString = this.url.substring(this.url.indexOf(""?"") + 1);
			RequestUtils.decodeUrlParameters(queryString, params);
		}
		public Locale getLocale(){
			return realRequest.getLocale();
		}
		public String getParameter(String key){
			String p[] = params.get(key);
			return p != null && p.length > 0 ? p[0] : null;
		}
		public Map<String, String[]> getParameterMap(){
			return params;
		}
		public String[] getParameters(String key){
			String[] param = params.get(key);
			if (param != null){
				return param;
			}
			return new String[0];
		}
		public String getPath(){
			return realRequest.getPath();
		}
		public String getRelativePathPrefixToContextRoot(){
			return realRequest.getRelativePathPrefixToContextRoot();
		}
		public String getRelativePathPrefixToWicketHandler(){
			return realRequest.getRelativePathPrefixToWicketHandler();
		}
		public String getURL(){
			return url;
		}
		public String getQueryString(){
			return realRequest.getQueryString();
		}
	}
	public static final String METHOD_GET = ""get"";
	public static final String METHOD_POST = ""post"";
	private static final short FLAG_SUBMITTED = FLAG_RESERVED1;
	private static final Logger log = LoggerFactory.getLogger(Form.class);
	private static final long serialVersionUID = 1L;
	private static final String UPLOAD_FAILED_RESOURCE_KEY = ""uploadFailed"";
	private static final String UPLOAD_TOO_LARGE_RESOURCE_KEY = ""uploadTooLarge"";
	private IFormSubmittingComponent defaultSubmittingComponent;
	private Object formValidators = null;
	private Bytes maxSize = null;
	private short multiPart = 0;
	private static final short MULTIPART_HARD = 0x01;
	private static final short MULTIPART_HINT = 0x02;
	public Form(final String id){
		super(id);
		setOutputMarkupId(true);
	}
	public Form(final String id, IModel<T> model){
		super(id, model);
		setOutputMarkupId(true);
	}
	public void add(IFormValidator validator){
		if (validator == null){
			throw new IllegalArgumentException(""Argument `validator` cannot be null"");
		}
		formValidators_add(validator);
		if (validator instanceof IValidatorAddListener){
			((IValidatorAddListener)validator).onAdded(this);
		}
	}
	public void remove(IFormValidator validator){
		if (validator == null){
			throw new IllegalArgumentException(""Argument `validator` cannot be null"");
		}
		IFormValidator removed = formValidators_remove(validator);
		if (removed == null){
			throw new IllegalStateException(""Tried to remove form validator that was not previously added. ""+ ""Make sure your validator's equals() implementation is sufficient"");
		}
		addStateChange(new FormValidatorRemovedChange(removed));
	}
	private final int formValidators_indexOf(IFormValidator validator){
		if (formValidators != null){
			if (formValidators instanceof IFormValidator){
				final IFormValidator v = (IFormValidator)formValidators;
				if (v == validator || v.equals(validator)){
					return 0;
				}
			}
			else{
				final IFormValidator[] validators = (IFormValidator[])formValidators;
				for (int i = 0;
				 i < validators.length;
				 i++){
					final IFormValidator v = validators[i];
					if (v == validator || v.equals(validator)){
						return i;
					}
				}
			}
		}
		return -1;
	}
	private final IFormValidator formValidators_remove(IFormValidator validator){
		int index = formValidators_indexOf(validator);
		if (index != -1){
			return formValidators_remove(index);
		}
		return null;
	}
	private final IFormValidator formValidators_remove(int index){
		if (formValidators instanceof IFormValidator){
			if (index == 0){
				final IFormValidator removed = (IFormValidator)formValidators;
				formValidators = null;
				return removed;
			}
			else{
				throw new IndexOutOfBoundsException();
			}
		}
		else{
			final IFormValidator[] validators = (IFormValidator[])formValidators;
			final IFormValidator removed = validators[index];
			if (validators.length == 2){
				formValidators = validators[1 - index];
			}
			else{
				IFormValidator[] newValidators = new IFormValidator[validators.length - 1];
				int j = 0;
				for (int i = 0;
				 i < validators.length;
				 i++){
					if (i != index){
						newValidators[j++] = validators[i];
					}
				}
				formValidators = newValidators;
			}
			return removed;
		}
	}
	public final void clearInput(){
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.isVisibleInHierarchy()){
					formComponent.clearInput();
				}
			}
		}
		);
	}
	public final void error(String error, Map<String, Object> args){
		error(new MapVariableInterpolator(error, args).toString());
	}
	public final IFormSubmittingComponent findSubmittingButton(){
		IFormSubmittingComponent submittingComponent = (IFormSubmittingComponent)getPage().visitChildren(IFormSubmittingComponent.class, new IVisitor<Component>(){
			public Object component(final Component component){
				final IFormSubmittingComponent submittingComponent = (IFormSubmittingComponent)component;
				final Form<?> form = submittingComponent.getForm();
				if ((form != null) && (form.getRootForm() == Form.this)){
					String name = submittingComponent.getInputName();
					if ((getRequest().getParameter(name) != null) ||(getRequest().getParameter(name + "".x"") != null)){
						if (!component.isVisibleInHierarchy()){
							throw new WicketRuntimeException(""Submit Button "" +submittingComponent.getInputName() + "" (path="" +component.getPageRelativePath() + "") is not visible"");
						}
						if (!component.isEnabledInHierarchy()){
							throw new WicketRuntimeException(""Submit Button "" +submittingComponent.getInputName() + "" (path="" +component.getPageRelativePath() + "") is not enabled"");
						}
						return submittingComponent;
					}
				}
				return CONTINUE_TRAVERSAL;
			}
		}
		);
		return submittingComponent;
	}
	public final IFormSubmittingComponent getDefaultButton(){
		if (isRootForm()){
			return defaultSubmittingComponent;
		}
		else{
			return getRootForm().getDefaultButton();
		}
	}
	public final Collection<IFormValidator> getFormValidators(){
		final int size = formValidators_size();
		List<IFormValidator> validators = null;
		if (size == 0){
			validators = Collections.emptyList();
		}
		else{
			validators = new ArrayList<IFormValidator>(size);
			for (int i = 0;
			 i < size;
			 i++){
				validators.add(formValidators_get(i));
			}
		}
		return Collections.unmodifiableCollection(validators);
	}
	public final CharSequence getJsForInterfaceUrl(CharSequence url){
		Form<?> root = getRootForm();
		return new AppendingStringBuffer(""document.getElementById('"").append(root.getHiddenFieldId()).append(""').value='"").append(url).append(""';
		document.getElementById('"").append(root.getMarkupId()).append(""').submit();
		"");
	}
	public Bytes getMaxSize(){
		Bytes maxSize = this.maxSize;
		if (maxSize == null){
			maxSize = (Bytes)visitChildren(Form.class, new IVisitor<Form<?>>(){
				public Object component(Form<?> component){
					Bytes maxSize = component.getMaxSize();
					if (maxSize != null){
						return maxSize;
					}
					return CONTINUE_TRAVERSAL;
				}
			}
			);
		}
		if (maxSize == null){
			return getApplication().getApplicationSettings().getDefaultMaximumUploadSize();
		}
		return maxSize;
	}
	public Form<?> getRootForm(){
		Form<?> form;
		Form<?> parent = this;
		do{
			form = parent;
			parent = form.findParent(Form.class);
		}
		while (parent != null);
		return form;
	}
	public String getValidatorKeyPrefix(){
		return null;
	}
	public final boolean hasError(){
		if (hasErrorMessage()){
			return true;
		}
		return anyFormComponentError();
	}
	public boolean isRootForm(){
		return findParent(Form.class) == null;
	}
	public final boolean isSubmitted(){
		return getFlag(FLAG_SUBMITTED);
	}
	public boolean isVersioned(){
		return super.isVersioned();
	}
	public final void loadPersistentFormComponentValues(){
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.isPersistent() && formComponent.isVisibleInHierarchy()){
					final IValuePersister persister = getValuePersister();
					persister.load(formComponent);
				}
			}
		}
		);
	}
	public final void onFormSubmitted(){
		markFormsSubmitted();
		if (handleMultiPart()){
			inputChanged();
			String url = getRequest().getParameter(getHiddenFieldId());
			if (!Strings.isEmpty(url)){
				dispatchEvent(getPage(), url);
			}
			else{
				final IFormSubmittingComponent submittingComponent = findSubmittingButton();
				if (submittingComponent != null && !submittingComponent.getDefaultFormProcessing()){
					submittingComponent.onSubmit();
				}
				else{
					Form<?> formToProcess = this;
					if (submittingComponent != null){
						formToProcess = submittingComponent.getForm();
					}
					formToProcess.process(submittingComponent);
				}
			}
		}
		else if (hasError()){
			callOnError();
		}
	}
	public void process(IFormSubmittingComponent submittingComponent){
		final Page page = getPage();
		String hiddenFieldId = getHiddenFieldId();
		if (process()){
			delegateSubmit(submittingComponent);
		}
		final PageParameters parameters = page.getPageParameters();
		if (parameters != null){
			visitFormComponents(new FormComponent.IVisitor(){
				public Object formComponent(IFormVisitorParticipant formComponent){
					if (formComponent instanceof FormComponent){
						parameters.remove(((FormComponent<?>)formComponent).getInputName());
					}
					return Component.IVisitor.CONTINUE_TRAVERSAL;
				}
			}
			);
			parameters.remove(hiddenFieldId);
			if (submittingComponent instanceof AbstractSubmitLink){
				AbstractSubmitLink submitLink = (AbstractSubmitLink)submittingComponent;
				parameters.remove(submitLink.getInputName());
			}
		}
	}
	protected void onValidateModelObjects(){
	}
	public boolean process(){
		if (!isEnabledInHierarchy() || !isVisibleInHierarchy()){
			return false;
		}
		validate();
		if (hasError()){
			markFormComponentsInvalid();
			callOnError();
			return false;
		}
		else{
			markFormComponentsValid();
			beforeUpdateFormComponentModels();
			updateFormComponentModels();
			onValidateModelObjects();
			if (hasError()){
				callOnError();
				return false;
			}
			persistFormComponentData();
			return true;
		}
	}
	protected void callOnError(){
		onError();
		visitChildren(Form.class, new IVisitor<Component>(){
			public Object component(Component component){
				final Form<?> form = (Form<?>)component;
				if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()){
					return IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
				}
				if (form.hasError()){
					form.onError();
				}
				return IVisitor.CONTINUE_TRAVERSAL;
			}
		}
		);
	}
	private void markFormsSubmitted(){
		setFlag(FLAG_SUBMITTED, true);
		visitChildren(Form.class, new IVisitor<Component>(){
			public Object component(Component component){
				Form<?> form = (Form<?>)component;
				if (form.isEnabledInHierarchy() && isVisibleInHierarchy()){
					form.setFlag(FLAG_SUBMITTED, true);
					return IVisitor.CONTINUE_TRAVERSAL;
				}
				return IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		}
		);
	}
	public void removePersistentFormComponentValues(final boolean disablePersistence){
		final IValuePersister persister = getValuePersister();
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.isVisibleInHierarchy()){
					persister.clear(formComponent);
					if (formComponent.isPersistent() && disablePersistence){
						formComponent.setPersistent(false);
					}
				}
			}
		}
		);
	}
	public final void setDefaultButton(IFormSubmittingComponent submittingComponent){
		if (isRootForm()){
			defaultSubmittingComponent = submittingComponent;
		}
		else{
			getRootForm().setDefaultButton(submittingComponent);
		}
	}
	public void setMaxSize(final Bytes maxSize){
		this.maxSize = maxSize;
	}
	public void setMultiPart(boolean multiPart){
		if (multiPart){
			this.multiPart |= MULTIPART_HARD;
		}
		else{
			this.multiPart &= ~MULTIPART_HARD;
		}
	}
	public final Component setVersioned(final boolean isVersioned){
		super.setVersioned(isVersioned);
		visitFormComponents(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				formComponent.setVersioned(isVersioned);
			}
		}
		);
		return this;
	}
	public final void visitFormComponents(final FormComponent.IVisitor visitor){
		visitChildren(FormComponent.class, new IVisitor<Component>(){
			public Object component(final Component component){
				visitor.formComponent((FormComponent<?>)component);
				return CONTINUE_TRAVERSAL;
			}
		}
		);
		visitChildrenInContainingBorder(visitor);
	}
	public final void visitFormComponentsPostOrder(final FormComponent.IVisitor visitor){
		FormComponent.visitFormComponentsPostOrder(this, visitor);
		if (getParent() instanceof Border){
			FormComponent.visitFormComponentsPostOrder(getParent(), visitor);
		}
	}
	private void visitChildrenInContainingBorder(final FormComponent.IVisitor visitor){
		if (getParent() instanceof Border){
			MarkupContainer border = getParent();
			Iterator<? extends Component> iter = border.iterator();
			while (iter.hasNext()){
				Component child = iter.next();
				if (child instanceof FormComponent){
					visitor.formComponent((FormComponent<?>)child);
				}
			}
		}
	}
	private boolean anyFormComponentError(){
		final boolean[] error = new boolean[] {
		 false }
		;
		final IVisitor<Component> visitor = new IVisitor<Component>(){
			public Object component(final Component component){
				if (component.hasErrorMessage()){
					error[0] = true;
					return Component.IVisitor.STOP_TRAVERSAL;
				}
				return Component.IVisitor.CONTINUE_TRAVERSAL;
			}
		}
		;
		visitChildren(Component.class, new IVisitor<Component>(){
			public Object component(final Component component){
				return visitor.component(component);
			}
		}
		);
		if (!error[0] && (getParent() instanceof Border)){
			MarkupContainer border = getParent();
			border.visitChildren(Component.class, new IVisitor<Component>(){
				public Object component(final Component component){
					if ((component == Form.this) || !(component instanceof FormComponent)){
						return Component.IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
					}
					return visitor.component(component);
				}
			}
			);
		}
		return error[0];
	}
	private void dispatchEvent(final Page page, final String url){
		RequestCycle rc = RequestCycle.get();
		IRequestCycleProcessor processor = rc.getProcessor();
		final RequestParameters requestParameters = processor.getRequestCodingStrategy().decode(new FormDispatchRequest(rc.getRequest(), url));
		IRequestTarget rt = processor.resolve(rc, requestParameters);
		if (rt instanceof IListenerInterfaceRequestTarget){
			IListenerInterfaceRequestTarget interfaceTarget = ((IListenerInterfaceRequestTarget)rt);
			interfaceTarget.getRequestListenerInterface().invoke(page, interfaceTarget.getTarget());
		}
		else{
			throw new WicketRuntimeException(""Attempt to access unknown request listener interface "" +requestParameters.getInterfaceName());
		}
	}
	private void formValidators_add(final IFormValidator validator){
		if (formValidators == null){
			formValidators = validator;
		}
		else{
			final int size = formValidators_size();
			final IFormValidator[] validators = new IFormValidator[size + 1];
			for (int i = 0;
			 i < size;
			 i++){
				validators[i] = formValidators_get(i);
			}
			validators[size] = validator;
			formValidators = validators;
		}
	}
	private IFormValidator formValidators_get(int index){
		if (formValidators == null){
			throw new IndexOutOfBoundsException();
		}
		if (formValidators instanceof IFormValidator[]){
			return ((IFormValidator[])formValidators)[index];
		}
		return (IFormValidator)formValidators;
	}
	private int formValidators_size(){
		if (formValidators == null){
			return 0;
		}
		if (formValidators instanceof IFormValidator[]){
			return ((IFormValidator[])formValidators).length;
		}
		return 1;
	}
	private void inputChanged(){
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.isVisibleInHierarchy()){
					formComponent.inputChanged();
				}
			}
		}
		);
	}
	private void persistFormComponentData(){
		if (getRequestCycle() instanceof WebRequestCycle){
			final IValuePersister persister = getValuePersister();
			visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
				public void onFormComponent(final FormComponent<?> formComponent){
					if (formComponent.isVisibleInHierarchy()){
						if (formComponent.isPersistent()){
							persister.save(formComponent);
						}
						else{
							persister.clear(formComponent);
						}
					}
				}
			}
			);
		}
	}
	protected void appendDefaultButtonField(final MarkupStream markupStream,final ComponentTag openTag){
		AppendingStringBuffer buffer = new AppendingStringBuffer();
		buffer.append(HIDDEN_DIV_START);
		buffer.append(""<input type=\""text\"" autocomplete=\""false\""/>"");
		final Component submittingComponent = (Component)defaultSubmittingComponent;
		buffer.append(""<input type=\""submit\"" name=\"""");
		buffer.append(defaultSubmittingComponent.getInputName());
		buffer.append(""\"" onclick=\"" var b=document.getElementById('"");
		buffer.append(submittingComponent.getMarkupId());
		buffer.append(""');
		 if (b!=null&amp;
		&amp;
		b.onclick!=null&amp;
		&amp;
		typeof(b.onclick) != 'undefined') {
			 var r = b.onclick.bind(b)();
			 if (r != false) b.click();
		 }
		 else {
			 b.click();
		 }
		;
		 return false;
		\"" "");
		buffer.append("" />"");
		buffer.append(""</div>"");
		getResponse().write(buffer);
	}
	protected void beforeUpdateFormComponentModels(){
	}
	protected void delegateSubmit(IFormSubmittingComponent submittingComponent){
		Form<?> formToProcess = this;
		if (submittingComponent != null){
			formToProcess = submittingComponent.getForm();
			submittingComponent.onSubmit();
		}
		formToProcess.onSubmit();
		formToProcess.visitChildren(Form.class, new IVisitor<Form<?>>(){
			public Object component(Form<?> component){
				Form<?> form = component;
				if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()){
					form.onSubmit();
					return IVisitor.CONTINUE_TRAVERSAL;
				}
				return IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		}
		);
	}
	public final String getHiddenFieldId(){
		String formId;
		if (!getPage().isPageStateless()){
			formId = getMarkupId();
		}
		else{
			formId = Form.getRootFormRelativeId(this).replace("":"", ""_"");
		}
		return getInputNamePrefix() + formId + ""_hf_0"";
	}
	protected final String getJavascriptId(){
		return getMarkupId();
	}
	protected String getMethod(){
		String method = getMarkupAttributes().getString(""method"");
		return (method != null) ? method : METHOD_POST;
	}
	protected boolean getStatelessHint(){
		return false;
	}
	protected IValuePersister getValuePersister(){
		return new CookieValuePersister();
	}
	private boolean isMultiPart(){
		if (multiPart != 0){
			return true;
		}
		final boolean[] anyEmbeddedMultipart = new boolean[] {
		 false }
		;
		visitChildren(Component.class, new IVisitor<Component>(){
			public Object component(Component component){
				boolean isMultiPart = false;
				if (component instanceof Form){
					Form<?> form = (Form<?>)component;
					if (form.isVisibleInHierarchy() && form.isEnabledInHierarchy()){
						isMultiPart = (form.multiPart != 0);
					}
				}
				else if (component instanceof FormComponent){
					FormComponent<?> fc = (FormComponent<?>)component;
					if (fc.isVisibleInHierarchy() && fc.isEnabledInHierarchy()){
						isMultiPart = fc.isMultiPart();
					}
				}
				if (isMultiPart == true){
					anyEmbeddedMultipart[0] = true;
					return STOP_TRAVERSAL;
				}
				return CONTINUE_TRAVERSAL;
			}
		}
		);
		if (anyEmbeddedMultipart[0]){
			multiPart |= MULTIPART_HINT;
		}
		return anyEmbeddedMultipart[0];
	}
	protected boolean handleMultiPart(){
		if (isMultiPart()){
			try{
				final WebRequest multipartWebRequest = ((WebRequest)getRequest()).newMultipartWebRequest(getMaxSize());
				getRequestCycle().setRequest(multipartWebRequest);
			}
			catch (WicketRuntimeException wre){
				if (wre.getCause() == null || !(wre.getCause() instanceof FileUploadException)){
					throw wre;
				}
				FileUploadException e = (FileUploadException)wre.getCause();
				final Map<String, Object> model = new HashMap<String, Object>();
				model.put(""exception"", e);
				model.put(""maxSize"", getMaxSize());
				onFileUploadException((FileUploadException)wre.getCause(), model);
				return false;
			}
		}
		return true;
	}
	protected void onFileUploadException(final FileUploadException e,final Map<String, Object> model){
		if (e instanceof SizeLimitExceededException){
			final String defaultValue = ""Upload must be less than "" + getMaxSize();
			String msg = getString(getId() + ""."" + UPLOAD_TOO_LARGE_RESOURCE_KEY,Model.ofMap(model), defaultValue);
			error(msg);
		}
		else{
			final String defaultValue = ""Upload failed: "" + e.getLocalizedMessage();
			String msg = getString(getId() + ""."" + UPLOAD_FAILED_RESOURCE_KEY, Model.ofMap(model),defaultValue);
			error(msg);
			log.warn(msg, e);
		}
	}
	protected void internalOnModelChanged(){
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.sameInnermostModel(Form.this)){
					formComponent.modelChanged();
				}
			}
		}
		);
	}
	protected final void markFormComponentsInvalid(){
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.isVisibleInHierarchy()){
					formComponent.invalid();
				}
			}
		}
		);
	}
	protected final void markFormComponentsValid(){
		internalMarkFormComponentsValid();
		markNestedFormComponentsValid();
	}
	private void markNestedFormComponentsValid(){
		visitChildren(Form.class, new IVisitor<Form<?>>(){
			public Object component(Form<?> component){
				Form<?> form = component;
				if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()){
					form.internalMarkFormComponentsValid();
					return CONTINUE_TRAVERSAL;
				}
				return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		}
		);
	}
	private void internalMarkFormComponentsValid(){
		visitFormComponentsPostOrder(new FormComponent.AbstractVisitor(){
			public void onFormComponent(final FormComponent<?> formComponent){
				if (formComponent.getForm() == Form.this && formComponent.isVisibleInHierarchy()){
					formComponent.valid();
				}
			}
		}
		);
	}
	protected void onComponentTag(final ComponentTag tag){
		super.onComponentTag(tag);
		checkComponentTag(tag, ""form"");
		if (isRootForm()){
			String method = getMethod().toLowerCase();
			tag.put(""method"", method);
			String url = urlFor(IFormSubmitListener.INTERFACE).toString();
			if (encodeUrlInHiddenFields()){
				int i = url.indexOf('?');
				String action = (i > -1) ? url.substring(0, i) : """";
				tag.put(""action"", action);
			}
			else{
				tag.put(""action"", Strings.escapeMarkup(url));
			}
			if (isMultiPart()){
				tag.put(""enctype"", ""multipart/form-data"");
			}
			else{
				String enctype = (String)tag.getAttributes().get(""enctype"");
				if (""multipart/form-data"".equalsIgnoreCase(enctype)){
					setMultiPart(true);
				}
			}
		}
		else{
			tag.setName(""div"");
			tag.remove(""method"");
			tag.remove(""action"");
			tag.remove(""enctype"");
		}
	}
	protected void renderPlaceholderTag(ComponentTag tag, Response response){
		if (isRootForm()){
			super.renderPlaceholderTag(tag, response);
		}
		else{
			response.write(""<div style=\""display:none\"""");
			if (getOutputMarkupId()){
				response.write("" id=\"""");
				response.write(getMarkupId());
				response.write(""\"""");
			}
			response.write(""></div>"");
		}
	}
	protected boolean encodeUrlInHiddenFields(){
		String method = getMethod().toLowerCase();
		return method.equals(""get"");
	}
	protected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag){
		if (isRootForm()){
			String nameAndId = getHiddenFieldId();
			AppendingStringBuffer buffer = new AppendingStringBuffer(HIDDEN_DIV_START).append(""<input type=\""hidden\"" name=\"""").append(nameAndId).append(""\"" id=\"""").append(nameAndId).append(""\"" />"");
			if (encodeUrlInHiddenFields()){
				String url = urlFor(IFormSubmitListener.INTERFACE).toString();
				int i = url.indexOf('?');
				String[] params = ((i > -1) ? url.substring(i + 1) : url).split(""&"");
				writeParamsAsHiddenFields(params, buffer);
			}
			buffer.append(""</div>"");
			getResponse().write(buffer);
			if (defaultSubmittingComponent instanceof Component){
				final Component submittingComponent = (Component)defaultSubmittingComponent;
				if (submittingComponent.isVisibleInHierarchy() &&submittingComponent.isEnabledInHierarchy()){
					appendDefaultButtonField(markupStream, openTag);
				}
			}
		}
		super.onComponentTagBody(markupStream, openTag);
	}
	protected void writeParamsAsHiddenFields(String[] params, AppendingStringBuffer buffer){
		for (int j = 0;
		 j < params.length;
		 j++){
			String[] pair = params[j].split(""="");
			buffer.append(""<input type=\""hidden\"" name=\"""").append(recode(pair[0])).append(""\"" value=\"""").append(pair.length > 1 ? recode(pair[1]) : """").append(""\"" />"");
		}
	}
	private String recode(String s){
		String un = WicketURLDecoder.QUERY_INSTANCE.decode(s);
		return Strings.escapeMarkup(un).toString();
	}
	protected void onDetach(){
		super.internalOnDetach();
		setFlag(FLAG_SUBMITTED, false);
		for (IFormValidator validator : getFormValidators()){
			if (validator != null && (validator instanceof IDetachable)){
				((IDetachable)validator).detach();
			}
		}
		super.onDetach();
	}
	protected void onError(){
	}
	protected void onBeforeRender(){
		this.multiPart &= ~MULTIPART_HINT;
		super.onBeforeRender();
	}
	protected void onSubmit(){
	}
	protected final void updateFormComponentModels(){
		internalUpdateFormComponentModels();
		updateNestedFormComponentModels();
	}
	private final void updateNestedFormComponentModels(){
		visitChildren(Form.class, new IVisitor<Form<?>>(){
			public Object component(Form<?> form){
				if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()){
					form.internalUpdateFormComponentModels();
					return CONTINUE_TRAVERSAL;
				}
				return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		}
		);
	}
	private void internalUpdateFormComponentModels(){
		FormComponent.visitComponentsPostOrder(this, new FormModelUpdateVisitor(this));
		MarkupContainer border = findParent(Border.class);
		if (border != null){
			FormComponent.visitComponentsPostOrder(border, new FormModelUpdateVisitor(this));
		}
	}
	protected final void validate(){
		if (isEnabledInHierarchy() && isVisibleInHierarchy()){
			validateComponents();
			validateFormValidators();
			onValidate();
			validateNestedForms();
		}
	}
	protected void onValidate(){
	}
	protected final void validateComponents(){
		visitFormComponentsPostOrder(new ValidationVisitor(){
			public void validate(final FormComponent<?> formComponent){
				final Form<?> form = formComponent.getForm();
				if (form == Form.this && form.isEnabledInHierarchy() && form.isVisibleInHierarchy()){
					formComponent.validate();
				}
			}
		}
		);
	}
	private boolean isFormComponentVisibleInPage(FormComponent<?> fc){
		if (fc == null){
			throw new IllegalArgumentException(""Argument `fc` cannot be null"");
		}
		return fc.isVisibleInHierarchy();
	}
	protected final void validateFormValidator(final IFormValidator validator){
		if (validator == null){
			throw new IllegalArgumentException(""Argument [[validator]] cannot be null"");
		}
		final FormComponent<?>[] dependents = validator.getDependentFormComponents();
		boolean validate = true;
		if (dependents != null){
			for (int j = 0;
			 j < dependents.length;
			 j++){
				final FormComponent<?> dependent = dependents[j];
				if (!dependent.isValid()){
					validate = false;
					break;
				}
				else if (!isFormComponentVisibleInPage(dependent)){
					if (log.isWarnEnabled()){
						log.warn(""IFormValidator in form `"" +getPageRelativePath() +""` depends on a component that has been removed from the page or is no longer visible. "" +""Offending component id `"" + dependent.getId() + ""`."");
					}
					validate = false;
					break;
				}
			}
		}
		if (validate){
			validator.validate(this);
		}
	}
	protected final void validateFormValidators(){
		final int count = formValidators_size();
		for (int i = 0;
		 i < count;
		 i++){
			validateFormValidator(formValidators_get(i));
		}
	}
	private void validateNestedForms(){
		visitChildren(Form.class, new IVisitor<Form<?>>(){
			public Object component(Form<?> form){
				if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()){
					form.validateComponents();
					form.validateFormValidators();
					form.onValidate();
					return CONTINUE_TRAVERSAL;
				}
				return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		}
		);
	}
	private class FormValidatorRemovedChange extends Change{
		private static final long serialVersionUID = 1L;
		private final IFormValidator removed;
		public FormValidatorRemovedChange(final IFormValidator removed){
			super();
			this.removed = removed;
		}
		public void undo(){
			add(removed);
		}
	}
	protected String getInputNamePrefix(){
		return """";
	}
	public final IModel<T> getModel(){
		return (IModel<T>)getDefaultModel();
	}
	public final void setModel(IModel<T> model){
		setDefaultModel(model);
	}
	public final T getModelObject(){
		return (T)getDefaultModelObject();
	}
	public final void setModelObject(T object){
		setDefaultModelObject(object);
	}
	public static Form<?> findForm(Component component){
		class FindFormVisitor implements Component.IVisitor<Form<?>>{
			Form<?> form = null;
			public Object component(Form<?> component){
				form = component;
				return Component.IVisitor.STOP_TRAVERSAL;
			}
		}
		Form<?> form = component.findParent(Form.class);
		if (form == null){
			Border border = component.findParent(Border.class);
			while ((form == null) && (border != null)){
				FindFormVisitor formVisitor = new FindFormVisitor();
				border.visitChildren(Form.class, formVisitor);
				form = formVisitor.form;
				if (form == null){
					border = border.findParent(Border.class);
				}
			}
		}
		return form;
	}
	public void renderHead(IHeaderResponse response){
		if (!isRootForm() && isMultiPart()){
			registerJavascriptNamespaces(response);
			response.renderJavascript(""Wicket.Forms[\"""" + getMarkupId() + ""\""]={
			multipart:true}
			;
			"",Form.class.getName() + ""."" + getMarkupId() + "".metadata"");
		}
	}
	protected void registerJavascriptNamespaces(IHeaderResponse response){
		response.renderJavascript(""if (typeof(Wicket)=='undefined') {
			 Wicket={
			}
			;
		 }
		 if (typeof(Wicket.Forms)=='undefined') {
			 Wicket.Forms={
			}
			;
		 }
		"",Form.class.getName());
	}
	public static String getRootFormRelativeId(Component component){
		String id = component.getId();
		final PrependingStringBuffer inputName = new PrependingStringBuffer(id.length());
		Component c = component;
		while (true){
			inputName.prepend(id);
			c = c.getParent();
			if (c == null || (c instanceof Form<?> && ((Form<?>)c).isRootForm()) ||c instanceof Page){
				break;
			}
			inputName.prepend(Component.PATH_SEPARATOR);
			id = c.getId();
		}
		if (inputName.equals(""submit"")){
			inputName.prepend(Component.PATH_SEPARATOR);
		}
		return inputName.toString();
	}
}",1,0,0,0
"private class PutFileAction implements SshAction<Void> {
	 private SFTPClient sftp;
	 private final String path;
	 private final int permissionsMask;
	 private final long lastModificationDate;
	 private final long lastAccessDate;
	 private final int uid;
	 private final Supplier<InputStream> contentsSupplier;
	 private final Integer length;
	 PutFileAction(Map<String,?> props, String path, Supplier<InputStream> contentsSupplier, long length) {
		 String permissions = getOptionalVal(props, PROP_PERMISSIONS);
		 long lastModificationDateVal = getOptionalVal(props, PROP_LAST_MODIFICATION_DATE);
		 long lastAccessDateVal = getOptionalVal(props, PROP_LAST_ACCESS_DATE);
		 if (lastAccessDateVal <= 0 ^ lastModificationDateVal <= 0) {
			 lastAccessDateVal = Math.max(lastAccessDateVal, lastModificationDateVal);
			 lastModificationDateVal = Math.max(lastAccessDateVal, lastModificationDateVal);
		 }
		 this.permissionsMask = Integer.parseInt(permissions, 8);
		 this.lastAccessDate = lastAccessDateVal;
		 this.lastModificationDate = lastModificationDateVal;
		 this.uid = getOptionalVal(props, PROP_OWNER_UID);
		 this.path = checkNotNull(path, ""path"");
		 this.contentsSupplier = checkNotNull(contentsSupplier, ""contents"");
		 this.length = Ints.checkedCast(checkNotNull((long)length, ""size""));
	 }
	 public void clear() {
		 closeWhispering(sftp, this);
		 sftp = null;
	 }
	 public Void create() throws Exception {
		 final AtomicReference<InputStream> inputStreamRef = new AtomicReference<InputStream>();
		 sftp = acquire(sftpConnection);
		 try {
			 sftp.put(new InMemorySourceFile() {
				 public String getName() {
					 return path;
				 }
				 public long getLength() {
					 return length;
				 }
				 public InputStream getInputStream() throws IOException {
					 InputStream contents = contentsSupplier.get();
					 inputStreamRef.set(contents);
					 return contents;
				 }
			 }
			, path);
			 sftp.chmod(path, permissionsMask);
			 if (uid != -1) {
				 sftp.chown(path, uid);
			 }
			 if (lastAccessDate > 0) {
				 sftp.setattr(path, new FileAttributes.Builder() .withAtimeMtime(lastAccessDate, lastModificationDate) .build());
			 }
		 }
		 finally {
			 closeWhispering(inputStreamRef.get(), this);
		 }
		 return null;
	 }
	 public String toString() {
		 return ""Put(path=["" + path + "" ""+length+""])"";
	 }
 }",1,1,0,0
"public class OnFailureInterceptor implements InstanceMethodsAroundInterceptor {
	 public void beforeMethod(EnhancedInstance objInst, Method method, Object[] allArguments, Class<?>[] argumentsTypes, MethodInterceptResult result) throws Throwable {
		 ContextManager.activeSpan().errorOccurred();
	 }
	 public Object afterMethod(EnhancedInstance objInst, Method method, Object[] allArguments, Class<?>[] argumentsTypes, Object ret) throws Throwable {
		 return ret;
	 }
	 public void handleMethodException(EnhancedInstance objInst, Method method, Object[] allArguments, Class<?>[] argumentsTypes, Throwable t) {
		 ContextManager.activeSpan().errorOccurred().log(t);
	 }
}",0,0,0,0
"public class DFSck {
	 private static final Logger LOG = Logger.getLogger(DFSck.class.getName());
	 public static final int FIXING_NONE = 0;
	 public static final int FIXING_MOVE = 1;
	 public static final int FIXING_DELETE = 2;
	 private DFSClient dfs;
	 private UTF8 lostFound = null;
	 private boolean lfInited = false;
	 private boolean lfInitedOk = false;
	 private Configuration conf;
	 private boolean showFiles = false;
	 private boolean showBlocks = false;
	 private boolean showLocations = false;
	 private int fixing;
	 public DFSck(Configuration conf, int fixing, boolean showFiles, boolean showBlocks, boolean showLocations) throws Exception {
		 this.conf = conf;
		 this.fixing = fixing;
		 this.showFiles = showFiles;
		 this.showBlocks = showBlocks;
		 this.showLocations = showLocations;
		 String fsName = conf.get(""fs.default.name"", ""local"");
		 if (fsName.equals(""local"")) {
			 throw new Exception(""This tool only checks DFS, but your config uses 'local' FS."");
		 }
		 this.dfs = new DFSClient(DataNode.createSocketAddr(fsName), conf);
	 }
	 public Result fsck(String path) throws Exception {
		 DFSFileInfo[] files = dfs.listPaths(new UTF8(path));
		 Result res = new Result();
		 res.setReplication(conf.getInt(""dfs.replication"", 3));
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 check(files[i], res);
		 }
		 return res;
	 }
	 private void check(DFSFileInfo file, Result res) throws Exception {
		 if (file.isDir()) {
			 if (showFiles) System.out.println(file.getPath() + "" <dir>"");
			 res.totalDirs++;
			 DFSFileInfo[] files = dfs.listPaths(new UTF8(file.getPath()));
			 for (int i = 0;
			 i < files.length;
			 i++) {
				 check(files[i], res);
			 }
			 return;
		 }
		 res.totalFiles++;
		 res.totalSize += file.getLen();
		 LocatedBlock[] blocks = dfs.namenode.open(file.getPath());
		 res.totalBlocks += blocks.length;
		 if (showFiles) {
			 System.out.print(file.getPath() + "" "" + file.getLen() + "", "" + blocks.length + "" block(s): "");
		 }
		 else {
			 System.out.print('.');
			 System.out.flush();
			 if (res.totalFiles % 100 == 0) System.out.println();
		 }
		 int missing = 0;
		 long missize = 0;
		 StringBuffer report = new StringBuffer();
		 for (int i = 0;
		 i < blocks.length;
		 i++) {
			 Block block = blocks[i].getBlock();
			 long id = block.getBlockId();
			 DatanodeInfo[] locs = blocks[i].getLocations();
			 if (locs.length > res.replication) res.overReplicatedBlocks += (locs.length - res.replication);
			 if (locs.length < res.replication && locs.length > 0) res.underReplicatedBlocks += (res.replication - locs.length);
			 report.append(i + "". "" + id + "" len="" + block.getNumBytes());
			 if (locs == null || locs.length == 0) {
				 report.append("" MISSING!"");
				 res.addMissing(block.getBlockName(), block.getNumBytes());
				 missing++;
				 missize += block.getNumBytes();
			 }
			 else {
				 report.append("" repl="" + locs.length);
				 if (showLocations) {
					 StringBuffer sb = new StringBuffer(""["");
					 for (int j = 0;
					 j < locs.length;
					 j++) {
						 if (j > 0) sb.append("", "");
						 sb.append(locs[j]);
					 }
					 sb.append(']');
					 report.append("" "" + sb.toString());
				 }
			 }
			 report.append('\n');
		 }
		 if (missing > 0) {
			 if (!showFiles) System.out.println(""\nMISSING "" + missing + "" blocks of total size "" + missize + "" B"");
			 res.corruptFiles++;
			 switch (fixing) {
				 case FIXING_NONE: System.err.println(""\n - ignoring corrupted "" + file.getPath());
				 break;
				 case FIXING_MOVE: System.err.println(""\n - moving to /lost+found: "" + file.getPath());
				 lostFoundMove(file, blocks);
				 break;
				 case FIXING_DELETE: System.err.println(""\n - deleting corrupted "" + file.getPath());
				 dfs.delete(new UTF8(file.getPath()));
			 }
		 }
		 if (showFiles) {
			 if (missing > 0) {
				 System.out.println("" MISSING "" + missing + "" blocks of total size "" + missize + "" B"");
			 }
			 else System.out.println("" OK"");
			 if (showBlocks) System.out.println(report.toString());
		 }
	 }
	 private void lostFoundMove(DFSFileInfo file, LocatedBlock[] blocks) {
		 if (!lfInited) {
			 lostFoundInit();
		 }
		 if (!lfInitedOk) {
			 return;
		 }
		 UTF8 target = new UTF8(lostFound.toString() + file.getPath());
		 String errmsg = ""Failed to move "" + file.getPath() + "" to /lost+found"";
		 try {
			 if (!dfs.mkdirs(target)) {
				 System.err.println(errmsg);
				 return;
			 }
			 int chain = 0;
			 FSOutputStream fos = null;
			 for (int i = 0;
			 i < blocks.length;
			 i++) {
				 LocatedBlock lblock = blocks[i];
				 DatanodeInfo[] locs = lblock.getLocations();
				 if (locs == null || locs.length == 0) {
					 if (fos != null) {
						 fos.flush();
						 fos.close();
						 fos = null;
					 }
					 continue;
				 }
				 if (fos == null) {
					 fos = dfs.create(new UTF8(target.toString() + ""/"" + chain), true);
					 if (fos != null) chain++;
				 }
				 if (fos == null) {
					 System.err.println(errmsg + "": could not store chain "" + chain);
					 continue;
				 }
				 try {
					 copyBlock(lblock, fos);
				 }
				 catch (Exception e) {
					 e.printStackTrace();
					 System.err.println("" - could not copy block "" + lblock.getBlock().getBlockName() + "" to "" + target);
					 fos.flush();
					 fos.close();
					 fos = null;
				 }
			 }
			 if (fos != null) fos.close();
			 System.err.println(""\n - moved corrupted file "" + file.getPath() + "" to /lost+found"");
			 dfs.delete(new UTF8(file.getPath()));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 System.err.println(errmsg + "": "" + e.getMessage());
		 }
	 }
	 private void copyBlock(LocatedBlock lblock, FSOutputStream fos) throws Exception {
		 int failures = 0;
		 InetSocketAddress targetAddr = null;
		 TreeSet deadNodes = new TreeSet();
		 Socket s = null;
		 DataInputStream in = null;
		 DataOutputStream out = null;
		 while (s == null) {
			 DatanodeInfo chosenNode;
			 try {
				 chosenNode = bestNode(lblock.getLocations(), deadNodes);
				 targetAddr = DataNode.createSocketAddr(chosenNode.getName().toString());
			 }
			 catch (IOException ie) {
				 if (failures >= DFSClient.MAX_BLOCK_ACQUIRE_FAILURES) {
					 throw new IOException(""Could not obtain block "" + lblock);
				 }
				 LOG.info(""Could not obtain block from any node: "" + ie);
				 try {
					 Thread.sleep(10000);
				 }
				 catch (InterruptedException iex) {
				 }
				 deadNodes.clear();
				 failures++;
				 continue;
			 }
			 try {
				 s = new Socket();
				 s.connect(targetAddr, FSConstants.READ_TIMEOUT);
				 s.setSoTimeout(FSConstants.READ_TIMEOUT);
				 out = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
				 out.write(FSConstants.OP_READSKIP_BLOCK);
				 lblock.getBlock().write(out);
				 out.writeLong(0L);
				 out.flush();
				 in = new DataInputStream(new BufferedInputStream(s.getInputStream()));
				 long curBlockSize = in.readLong();
				 long amtSkipped = in.readLong();
				 if (curBlockSize != lblock.getBlock().len) {
					 throw new IOException(""Recorded block size is "" + lblock.getBlock().len + "", but datanode reports size of "" + curBlockSize);
				 }
				 if (amtSkipped != 0L) {
					 throw new IOException(""Asked for offset of "" + 0L + "", but only received offset of "" + amtSkipped);
				 }
			 }
			 catch (IOException ex) {
				 LOG.info(""Failed to connect to "" + targetAddr + "":"" + ex);
				 deadNodes.add(chosenNode);
				 if (s != null) {
					 try {
						 s.close();
					 }
					 catch (IOException iex) {
					 }
				 }
				 s = null;
			 }
		 }
		 if (in == null) {
			 throw new Exception(""Could not open data stream for "" + lblock.getBlock().getBlockName());
		 }
		 byte[] buf = new byte[1024];
		 int cnt = 0;
		 boolean success = true;
		 try {
			 while ((cnt = in.read(buf)) > 0) {
				 fos.write(buf, 0, cnt);
			 }
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 success = false;
		 }
		 finally {
			 try {
				in.close();
			 }
			 catch (Exception e1) {
			}
			 try {
				out.close();
			 }
			 catch (Exception e1) {
			}
			 try {
				s.close();
			 }
			 catch (Exception e1) {
			}
		 }
		 if (!success) throw new Exception(""Could not copy block data for "" + lblock.getBlock().getBlockName());
	 }
	 Random r = new Random();
	 private DatanodeInfo bestNode(DatanodeInfo nodes[], TreeSet deadNodes) throws IOException {
		 if ((nodes == null) || (nodes.length - deadNodes.size() < 1)) {
			 throw new IOException(""No live nodes contain current block"");
		 }
		 DatanodeInfo chosenNode = null;
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (deadNodes.contains(nodes[i])) {
				 continue;
			 }
			 String nodename = nodes[i].getName().toString();
			 int colon = nodename.indexOf(':');
			 if (colon >= 0) {
				 nodename = nodename.substring(0, colon);
			 }
			 if (dfs.localName.equals(nodename)) {
				 chosenNode = nodes[i];
				 break;
			 }
		 }
		 if (chosenNode == null) {
			 do {
				 chosenNode = nodes[Math.abs(r.nextInt()) % nodes.length];
			 }
			 while (deadNodes.contains(chosenNode));
		 }
		 return chosenNode;
	 }
	 private void lostFoundInit() {
		 lfInited = true;
		 try {
			 UTF8 lfName = new UTF8(""/lost+found"");
			 if (!dfs.exists(lfName)) {
				 lfInitedOk = dfs.mkdirs(lfName);
				 lostFound = lfName;
			 }
			 else if (!dfs.isDirectory(lfName)) {
				 System.err.println(""Cannot use /lost+found : a regular file with this name exists."");
				 lfInitedOk = false;
			 }
			 else {
				 lostFound = lfName;
				 lfInitedOk = true;
			 }
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 lfInitedOk = false;
		 }
		 if (lostFound == null) {
			 System.err.println(""Cannot initialize /lost+found ."");
			 lfInitedOk = false;
		 }
	 }
	 public static void main(String[] args) throws Exception {
		 if (args.length == 0) {
			 System.err.println(""Usage: DFSck <path> [-move | -delete] [-files] [-blocks [-locations]]"");
			 System.err.println(""\t<path>\tstart checking from this path"");
			 System.err.println(""\t-move\tmove corrupted files to /lost+found"");
			 System.err.println(""\t-delete\tdelete corrupted files"");
			 System.err.println(""\t-files\tprint out files being checked"");
			 System.err.println(""\t-blocks\tprint out block report"");
			 System.err.println(""\t-locations\tprint out locations for every block"");
			 return;
		 }
		 Configuration conf = new Configuration();
		 String path = args[0];
		 boolean showFiles = false;
		 boolean showBlocks = false;
		 boolean showLocations = false;
		 int fixing = FIXING_NONE;
		 for (int i = 1;
		 i < args.length;
		 i++) {
			 if (args[i].equals(""-files"")) showFiles = true;
			 if (args[i].equals(""-blocks"")) showBlocks = true;
			 if (args[i].equals(""-locations"")) showLocations = true;
			 if (args[i].equals(""-move"")) fixing = FIXING_MOVE;
			 if (args[i].equals(""-delete"")) fixing = FIXING_DELETE;
		 }
		 DFSck fsck = new DFSck(conf, fixing, showFiles, showBlocks, showLocations);
		 Result res = fsck.fsck(path);
		 System.out.println();
		 System.out.println(res);
		 if (res.isHealthy()) {
			 System.out.println(""\n\nThe filesystem under path '"" + args[0] + ""' is HEALTHY"");
		 }
		 else {
			 System.out.println(""\n\nThe filesystem under path '"" + args[0] + ""' is CORRUPT"");
		 }
	 }
	 public static class Result {
		 private ArrayList missingIds = new ArrayList();
		 private long missingSize = 0L;
		 private long corruptFiles = 0L;
		 private long overReplicatedBlocks = 0L;
		 private long underReplicatedBlocks = 0L;
		 private int replication = 0;
		 private long totalBlocks = 0L;
		 private long totalFiles = 0L;
		 private long totalDirs = 0L;
		 private long totalSize = 0L;
		 public boolean isHealthy() {
			 return missingIds.size() == 0;
		 }
		 public void addMissing(String id, long size) {
			 missingIds.add(id);
			 missingSize += size;
		 }
		 public ArrayList getMissingIds() {
			 return missingIds;
		 }
		 public long getMissingSize() {
			 return missingSize;
		 }
		 public void setMissingSize(long missingSize) {
			 this.missingSize = missingSize;
		 }
		 public long getOverReplicatedBlocks() {
			 return overReplicatedBlocks;
		 }
		 public void setOverReplicatedBlocks(long overReplicatedBlocks) {
			 this.overReplicatedBlocks = overReplicatedBlocks;
		 }
		 public float getReplicationFactor() {
			 if (totalBlocks != 0) return (float)(totalBlocks * replication + overReplicatedBlocks - underReplicatedBlocks) / (float)totalBlocks;
			 else return 0.0f;
		 }
		 public long getUnderReplicatedBlocks() {
			 return underReplicatedBlocks;
		 }
		 public void setUnderReplicatedBlocks(long underReplicatedBlocks) {
			 this.underReplicatedBlocks = underReplicatedBlocks;
		 }
		 public long getTotalDirs() {
			 return totalDirs;
		 }
		 public void setTotalDirs(long totalDirs) {
			 this.totalDirs = totalDirs;
		 }
		 public long getTotalFiles() {
			 return totalFiles;
		 }
		 public void setTotalFiles(long totalFiles) {
			 this.totalFiles = totalFiles;
		 }
		 public long getTotalSize() {
			 return totalSize;
		 }
		 public void setTotalSize(long totalSize) {
			 this.totalSize = totalSize;
		 }
		 public int getReplication() {
			 return replication;
		 }
		 public void setReplication(int replication) {
			 this.replication = replication;
		 }
		 public long getTotalBlocks() {
			 return totalBlocks;
		 }
		 public void setTotalBlocks(long totalBlocks) {
			 this.totalBlocks = totalBlocks;
		 }
		 public String toString() {
			 StringBuffer res = new StringBuffer();
			 res.append(""Status: "" + (isHealthy() ? ""HEALTHY"" : ""CORRUPT""));
			 res.append(""\n Total size:\t"" + totalSize + "" B"");
			 res.append(""\n Total blocks:\t"" + totalBlocks);
			 if (totalBlocks > 0) res.append("" (avg. block size "" + (totalSize / totalBlocks) + "" B)"");
			 res.append(""\n Total dirs:\t"" + totalDirs);
			 res.append(""\n Total files:\t"" + totalFiles);
			 if (missingSize > 0) {
				 res.append(""\n ********************************"");
				 res.append(""\n CORRUPT FILES:\t"" + corruptFiles);
				 res.append(""\n MISSING BLOCKS:\t"" + missingIds.size());
				 res.append(""\n MISSING SIZE:\t\t"" + missingSize + "" B"");
				 res.append(""\n ********************************"");
			 }
			 res.append(""\n Over-replicated blocks:\t"" + overReplicatedBlocks);
			 if (totalBlocks > 0) res.append("" ("" + ((float)(overReplicatedBlocks * 100) / (float)totalBlocks) + "" %)"");
			 res.append(""\n Under-replicated blocks:\t"" + underReplicatedBlocks);
			 if (totalBlocks > 0) res.append("" ("" + ((float)(underReplicatedBlocks * 100) / (float)totalBlocks) + "" %)"");
			 res.append(""\n Target replication factor:\t"" + replication);
			 res.append(""\n Real replication factor:\t"" + getReplicationFactor());
			 return res.toString();
		 }
		 public long getCorruptFiles() {
			 return corruptFiles;
		 }
		 public void setCorruptFiles(long corruptFiles) {
			 this.corruptFiles = corruptFiles;
		 }
	 }
}",0,0,0,0
abstract void rehash(int newCapacity);,0,0,0,0
"protected void buildMenu() {
	 JMenu menu = new JMenu(BundleMessage.format(""UI_DAVMAIL_GATEWAY""));
	 JMenuBar menuBar = new JMenuBar();
	 menuBar.add(menu);
	 mainFrame.setJMenuBar(menuBar);
	 ActionListener aboutListener = new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 about();
		 }
	 }
	;
	 JMenuItem aboutItem = new JMenuItem(BundleMessage.format(""UI_ABOUT""));
	 aboutItem.addActionListener(aboutListener);
	 menu.add(aboutItem);
	 ActionListener settingsListener = new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 preferences();
		 }
	 }
	;
	 JMenuItem defaultItem = new JMenuItem(BundleMessage.format(""UI_SETTINGS""));
	 defaultItem.addActionListener(settingsListener);
	 menu.add(defaultItem);
	 JMenuItem logItem = new JMenuItem(BundleMessage.format(""UI_SHOW_LOGS""));
	 logItem.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 showLogs();
		 }
	 }
	);
	 menu.add(logItem);
	 ActionListener exitListener = new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 try {
				 DavGateway.stop();
			 }
			 catch (Exception exc) {
				 DavGatewayTray.error(exc);
			 }
			 System.exit(0);
		 }
	 }
	;
	 JMenuItem exitItem = new JMenuItem(BundleMessage.format(""UI_EXIT""));
	 exitItem.addActionListener(exitListener);
	 menu.add(exitItem);
 }",0,0,1,0
"public class DoubleNumericColumnSupplier implements Supplier<NumericColumn>{
	 private final Supplier<ColumnarDoubles> column;
	 private final ImmutableBitmap nullValueBitmap;
	 DoubleNumericColumnSupplier(Supplier<ColumnarDoubles> column, ImmutableBitmap nullValueBitmap) {
		 this.column = column;
		 this.nullValueBitmap = nullValueBitmap;
	 }
	 public NumericColumn get() {
		 return DoublesColumn.create(column.get(), nullValueBitmap);
	 }
}",0,0,0,0
"final static class TypeList {
	 Hashtable types;
	 TypeList() {
	 }
	 TypeList(Vector typeNames) {
		 types = new Hashtable();
		 for ( int i = 0;
		 i < typeNames.size();
		 i++ ) {
			 String t = ((String) typeNames.elementAt(i)).toLowerCase();
			 types.put(t, t);
		 }
	 }
	 final boolean contains(String type) {
		 if ( types == null ) {
			 return true;
		 }
		 return types.containsKey(type);
	 }
 }",0,1,0,0
"boolean increaseConnectionWindow(int amount) {
	 List<Stream<T>> candidates = null;
	 controllerLock.lock();
	 try {
		 int size = connectionWindowSize;
		 size += amount;
		 if (size < 0) return false;
		 connectionWindowSize = size;
		 if (debug.on()) debug.log(""Connection window size is now %d (amount added %d)"", size, amount);
		 Iterator<Map.Entry<Integer,Map.Entry<Stream<T>,Integer>>> iter = pending.entrySet().iterator();
		 while (iter.hasNext() && size > 0) {
			 Map.Entry<Integer,Map.Entry<Stream<T>,Integer>> item = iter.next();
			 Integer streamSize = streams.get(item.getKey());
			 if (streamSize == null) {
				 iter.remove();
			 }
			 else {
				 Map.Entry<Stream<T>,Integer> e = item.getValue();
				 int requestedAmount = e.getValue();
				 int minAmount = 1;
				 if (size >= minAmount && streamSize >= minAmount) {
					 size -= Math.min(streamSize, requestedAmount);
					 iter.remove();
					 if (candidates == null) candidates = new ArrayList<>();
					 candidates.add(e.getKey());
				 }
			 }
		 }
	 }
	 finally {
		 controllerLock.unlock();
	 }
	 if (candidates != null) {
		 candidates.forEach(Stream::signalWindowUpdate);
	 }
	 return true;
 }",0,0,1,0
"public static AbstractType getSubComparator(String tableName, String cfName) {
	 assert tableName != null;
	 return getCFMetaData(tableName, cfName).subcolumnComparator;
 }",0,0,0,0
"public synchronized void setPattern(String p) {
	 pattern = p;
 }",0,0,0,0
"public <T> Page getPage(String sessionId, String pagemap, int id, int versionNumber,int ajaxVersionNumber){
	SessionEntry entry = getSessionEntry(sessionId, false);
	if (entry != null){
		byte[] data;
		if (isSynchronous()){
			data = entry.loadPage(pagemap, id, versionNumber, ajaxVersionNumber);
		}
		else{
			List<SerializedPage> pages = getPagesToSaveList(sessionId);
			synchronized (pages){
				flushPagesToSaveList(sessionId, pages);
				data = entry.loadPage(pagemap, id, versionNumber, ajaxVersionNumber);
			}
		}
		if (data != null){
			final Page ret = deserializePage(data, versionNumber);
			return ret;
		}
	}
	return null;
}",0,0,0,0
"public void setFailOnError(final boolean failOnError) {
	 this.failOnError = failOnError;
 }",0,0,0,0
"class FloatFilterFunction extends AbstractFloatValue {
	 private final FloatValue baseExpr;
	 private final BooleanValue filterExpr;
	 public static final String name = FilterFunction.name;
	 private final String exprStr;
	 private final ExpressionType funcType;
	 public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {
		 this.baseExpr = baseExpr;
		 this.filterExpr = filterExpr;
		 this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
		 this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
	 }
	 boolean exists = false;
	 public float getFloat() {
		 float value = baseExpr.getFloat();
		 exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
		 return value;
	 }
	 public boolean exists() {
		 return exists;
	 }
	 public String getName() {
		 return name;
	 }
	 public String getExpressionStr() {
		 return exprStr;
	 }
	 public ExpressionType getExpressionType() {
		 return funcType;
	 }
}",0,1,0,0
"class LocatedBlock implements Writable {
	 static {
		 WritableFactories.setFactory (LocatedBlock.class, new WritableFactory() {
			 public Writable newInstance() {
				 return new LocatedBlock();
			 }
		 }
		);
	 }
	 Block b;
	 DatanodeInfo locs[];
	 public LocatedBlock() {
		 this.b = new Block();
		 this.locs = new DatanodeInfo[0];
	 }
	 public LocatedBlock(Block b, DatanodeInfo[] locs) {
		 this.b = b;
		 this.locs = locs;
	 }
	 public Block getBlock() {
		 return b;
	 }
	 DatanodeInfo[] getLocations() {
		 return locs;
	 }
	 public void write(DataOutput out) throws IOException {
		 b.write(out);
		 out.writeInt(locs.length);
		 for (int i = 0;
		 i < locs.length;
		 i++) {
			 locs[i].write(out);
		 }
	 }
	 public void readFields(DataInput in) throws IOException {
		 this.b = new Block();
		 b.readFields(in);
		 int count = in.readInt();
		 this.locs = new DatanodeInfo[count];
		 for (int i = 0;
		 i < locs.length;
		 i++) {
			 locs[i] = new DatanodeInfo();
			 locs[i].readFields(in);
		 }
	 }
}",0,0,0,0
"public class Callout implements Comparable {
	 private int callout = 0;
	 private Element area = null;
	 private int line = 0;
	 private int col = 0;
	 private int type = 0;
	 private String otherType = null;
	 public static final int CALS_PAIR = 1;
	 public static final int LINE_COLUMN = 2;
	 public static final int LINE_COLUMN_PAIR = 3;
	 public static final int LINE_RANGE = 4;
	 public static final int OTHER = 5;
	 public Callout(int callout, Element area, int line, int col, int type) {
		 this.callout = callout;
		 this.area = area;
		 this.line = line;
		 this.col = col;
		 this.type = type;
		 this.otherType = null;
	 }
	 public Callout(int callout, Element area, int line, int col, String otherType) {
		 this.callout = callout;
		 this.area = area;
		 this.line = line;
		 this.col = col;
		 this.type = Callout.OTHER;
		 this.otherType = otherType;
	 }
	 public int compareTo (Object o) {
		 Callout c = (Callout) o;
		 if (line == c.getLine()) {
			 if (col > c.getColumn()) {
				return 1;
			 }
			 else if (col < c.getColumn()) {
				return -1;
			 }
			 else {
				if (callout < c.getCallout()) {
					 return -1;
				}
				 else if (callout > c.getCallout()) {
					 return 1;
				}
				 else {
					 return 0;
				}
			 }
		 }
		 else {
			 if (line > c.getLine()) {
				return 1;
			 }
			 else {
				return -1;
			 }
		 }
	 }
	 public Element getArea() {
		 return area;
	 }
	 public int getLine() {
		 return line;
	 }
	 public int getColumn() {
		 return col;
	 }
	 public int getCallout() {
		 return callout;
	 }
	 public int getType() {
		 return type;
	 }
	 public String getOtherType() {
		 return otherType;
	 }
}",0,1,0,0
"public class QuartzGFXCMD extends GFXCMD2{
	private native long createNSViewLong0();
	public void setVideoBounds(java.awt.Rectangle srcRect, java.awt.Rectangle destRect){
		super.setVideoBounds(srcRect, destRect);
		if (srcRect != null && destRect != null){
			java.awt.geom.Rectangle2D.Float srcRectf = new java.awt.geom.Rectangle2D.Float(srcRect.x, srcRect.y, srcRect.width, srcRect.height);
			java.awt.geom.Rectangle2D.Float destRectf = new java.awt.geom.Rectangle2D.Float(destRect.x, destRect.y, destRect.width, destRect.height);
			setVideoRects0(srcRectf, destRectf, new java.awt.Color(0, true));
		}
	}
	private class McFont {
		private java.awt.Font awtFont = null;
		private java.awt.font.FontRenderContext frc = null;
		public long nativeFont = 0;
		public McFont(String name, int style, int size) {
			frc = new java.awt.font.FontRenderContext(null, true, false);
			awtFont = new java.awt.Font(name, style, size);
			nativeFont = loadFont0(name, style, size);
		}
		public void unload() {
			if(nativeFont != 0) unloadFont0(nativeFont);
			nativeFont = 0;
			awtFont = null;
		}
		public java.awt.Dimension getStringSize(String s) {
			java.awt.geom.Rectangle2D bounds = awtFont.getStringBounds(s, frc);
			return new java.awt.Dimension((int)bounds.getWidth(), (int)bounds.getHeight());
		}
		public float[] getGlyphPositions(String s) {
			java.awt.font.GlyphVector gvec = awtFont.createGlyphVector(frc, s);
			if(gvec != null) {
				float[] positions = gvec.getGlyphPositions(0, gvec.getNumGlyphs(), null);
				return positions;
			}
			return null;
		}
	}
	private class QuartzRendererView extends com.apple.eawt.CocoaComponent {
		public long nativeView = 0;
		public long createNSViewLong() {
			nativeView = createNSViewLong0();
			return nativeView;
		}
		public int createNSView() {
			return (int)createNSViewLong();
		}
		final java.awt.Dimension PREF_SIZE = new java.awt.Dimension(720,480);
		final java.awt.Dimension MIN_SIZE = new java.awt.Dimension(20,20);
		final java.awt.Dimension MAX_SIZE = new java.awt.Dimension(4096,4096);
		 public java.awt.Dimension getPreferredSize() {
			return PREF_SIZE;
		}
		public java.awt.Dimension getMinimumSize() {
			return MIN_SIZE;
		}
		public java.awt.Dimension getMaximumSize() {
			return MAX_SIZE;
		}
		public void update(java.awt.Graphics g) {
		}
		public void paint(java.awt.Graphics g) {
		}
	}
	public QuartzGFXCMD(MiniClientConnection myConn){
		super(myConn);
		imageCacheLimit = 32000000;
		try{
			imageCacheLimit = Integer.parseInt(MiniClient.myProperties.getProperty(""image_cache_size"", ""32000000""));
		}
		catch (Exception e){
			System.out.println(""Invalid image_cache_size property:"" + e);
		}
	}
	private QuartzRendererView c;
	private java.awt.Graphics2D g2;
	private java.awt.Graphics2D primaryG2;
	private java.util.Map imageMap = new java.util.HashMap();
	private java.util.Map layerMap = new java.util.HashMap();
	private int handleCount = 2;
	private long hideTime = 0;
	private java.util.TimerTask hideTimer;
	private long currentLayer = 0;
	public void close(){
		if (f != null)f.dispose();
		c = null;
		cancelHideTimer();
		cleanupRenderer();
	}
	public void refresh(){
		c.invalidate();
		f.invalidate();
		f.validate();
	}
	private void cleanupRenderer(){
		java.util.Iterator iter;
		if(!imageMap.isEmpty()) {
			iter = imageMap.values().iterator();
			while(iter.hasNext()) {
				Long imagePtr = (Long)iter.next();
				if(imagePtr != null) freeNativeImage0(imagePtr.longValue());
			}
			imageMap.clear();
		}
		if(!layerMap.isEmpty()) {
			iter = layerMap.values().iterator();
			while(iter.hasNext()) {
				Long layerPtr = (Long)iter.next();
				if(layerPtr != null) freeLayer0(layerPtr.longValue());
			}
			layerMap.clear();
		}
		if(!fontMap.isEmpty()) {
			iter = fontMap.values().iterator();
			while(iter.hasNext()) {
				McFont f = (McFont)iter.next();
				if(f != null) f.unload();
			}
			fontMap.clear();
		}
		cleanupRenderer0();
	}
	public MiniClientWindow getWindow(){
		return f;
	}
	private java.awt.GradientPaint getGradient(float x, float y, float width, float height, int argbTL, int argbTR, int argbBL, int argbBR){
		float x2 = x + width;
		float y2 = y + height;
		if (argbTL != argbTR || argbTL != argbBL || argbTL != argbBR){
			if (Math.abs(argbTL - argbTR) >= Math.abs(argbTL - argbBL) &&Math.abs(argbTL - argbTR) >= Math.abs(argbTL - argbBR))return new java.awt.GradientPaint(x, y, new java.awt.Color(argbTL, true), x2, y, new java.awt.Color(argbTR, true));
			else if (Math.abs(argbTL - argbBL) < Math.abs(argbTL - argbBR))return new java.awt.GradientPaint(x, y, new java.awt.Color(argbTL, true), x2, y2, new java.awt.Color(argbBR, true));
			elsereturn new java.awt.GradientPaint(x, y, new java.awt.Color(argbTL, true), x, y2, new java.awt.Color(argbBL, true));
		}
		return null;
	}
	public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret){
		len -= 4;
		 hasret[0] = 0;
		 if((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT)){
			if((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {
				while((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {
					try {
						Thread.sleep(10);
					}
					 catch(InterruptedException ex) {
					}
				}
			}
		}
		if (c != null){
			switch(cmd){
				case GFXCMD_INIT:case GFXCMD_DEINIT:case GFXCMD_STARTFRAME:case GFXCMD_FLIPBUFFER:c.setCursor(null);
				break;
				case GFXCMD_DRAWRECT:case GFXCMD_FILLRECT:case GFXCMD_CLEARRECT:case GFXCMD_DRAWOVAL:case GFXCMD_FILLOVAL:case GFXCMD_DRAWROUNDRECT:case GFXCMD_FILLROUNDRECT:case GFXCMD_DRAWTEXT:case GFXCMD_DRAWTEXTURED:case GFXCMD_DRAWLINE:case GFXCMD_LOADIMAGE:case GFXCMD_LOADIMAGETARGETED:case GFXCMD_UNLOADIMAGE:case GFXCMD_LOADFONT:case GFXCMD_UNLOADFONT:case GFXCMD_SETTARGETSURFACE:case GFXCMD_CREATESURFACE:break;
				case GFXCMD_PREPIMAGE:case GFXCMD_LOADIMAGELINE:case GFXCMD_LOADIMAGECOMPRESSED:case GFXCMD_XFMIMAGE:case GFXCMD_LOADCACHEDIMAGE:case GFXCMD_PREPIMAGETARGETED:if (!cursorHidden)c.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));
				break;
			}
		}
		switch(cmd){
			case GFXCMD_INIT:hasret[0] = 1;
			init0();
			int windowTitleStyle = 0;
			try{
				windowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(""window_title_style"", ""0""));
			}
			catch (NumberFormatException e){
			}
			if (!""true"".equals(MiniClient.myProperties.getProperty(""enable_custom_title_bar"", MiniClient.MAC_OS_X ? ""false"" : ""true"")))windowTitleStyle = 10;
			 f = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);
			java.awt.LayoutManager layer = new java.awt.LayoutManager(){
				public void addLayoutComponent(String name, java.awt.Component comp){
				}
				public java.awt.Dimension minimumLayoutSize(java.awt.Container parent){
					return preferredLayoutSize(parent);
				}
				public java.awt.Dimension preferredLayoutSize(java.awt.Container parent){
					return parent.getPreferredSize();
				}
				public void removeLayoutComponent(java.awt.Component comp){
				}
				public void layoutContainer(java.awt.Container parent){
					c.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,parent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);
				}
			}
			;
			f.getContentPane().setLayout(layer);
			try{
				bgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(""images/Background.jpg""));
				ensureImageIsLoaded(bgImage);
				logoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(""images/SageLogo256.png""));
				ensureImageIsLoaded(logoImage);
			}
			catch (Exception e){
				System.out.println(""ERROR:"" + e);
				e.printStackTrace();
			}
			f.setFocusTraversalKeysEnabled(false);
			java.awt.Dimension panelSize = f.getContentPane().getSize();
			c = new QuartzRendererView();
			c.setSize(panelSize);
			c.setFocusTraversalKeysEnabled(false);
			f.getContentPane().add(c);
			try{
				java.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(""images/tvicon.gif""));
				ensureImageIsLoaded(frameIcon);
				f.setIconImage(frameIcon);
			}
			catch (Exception e){
				System.out.println(""ERROR:"" + e);
				e.printStackTrace();
			}
			f.addWindowListener(new java.awt.event.WindowAdapter(){
				public void windowClosing(java.awt.event.WindowEvent evt){
					if (!f.isFullScreen() || System.getProperty(""os.name"").toLowerCase().indexOf(""windows"") != -1){
						MiniClient.myProperties.setProperty(""main_window_width"", Integer.toString(f.getWidth()));
						MiniClient.myProperties.setProperty(""main_window_height"", Integer.toString(f.getHeight()));
						MiniClient.myProperties.setProperty(""main_window_x"", Integer.toString(f.getX()));
						MiniClient.myProperties.setProperty(""main_window_y"", Integer.toString(f.getY()));
					}
					myConn.close();
					close();
				}
			}
			);
			c.addComponentListener(new java.awt.event.ComponentAdapter(){
				public void componentResized(java.awt.event.ComponentEvent evt){
					myConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));
				}
			}
			);
			f.addKeyListener(this);
			c.addKeyListener(this);
			f.addMouseWheelListener(this);
			c.addMouseListener(this);
			if (ENABLE_MOUSE_MOTION_EVENTS){
				c.addMouseMotionListener(this);
			}
			int frameX = 100;
			int frameY = 100;
			int frameW = 720;
			int frameH = 480;
			try{
				frameW = Integer.parseInt(MiniClient.myProperties.getProperty(""main_window_width"", ""720""));
				frameH = Integer.parseInt(MiniClient.myProperties.getProperty(""main_window_height"", ""480""));
				frameX = Integer.parseInt(MiniClient.myProperties.getProperty(""main_window_x"", ""100""));
				frameY = Integer.parseInt(MiniClient.myProperties.getProperty(""main_window_y"", ""100""));
			}
			catch (NumberFormatException e){
			}
			java.awt.Point newPos = new java.awt.Point(frameX, frameY);
			boolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);
			if (!foundScreen){
				newPos.x = 150;
				newPos.y = 150;
			}
			f.setVisible(true);
			f.setSize(1,1);
			f.setSize(Math.max(frameW, 320), Math.max(frameH, 240));
			f.setLocation(newPos);
			if (MiniClient.fsStartup)f.setFullScreen(true);
			MiniClient.hideSplash();
			return 1;
			case GFXCMD_DEINIT:close();
			break;
			case GFXCMD_DRAWRECT:if(len==36){
				float x, y, width, height;
				int thickness, argbTL, argbTR, argbBR, argbBL;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				thickness=readInt(16, cmddata);
				argbTL=readInt(20, cmddata);
				argbTR=readInt(24, cmddata);
				argbBR=readInt(28, cmddata);
				argbBL=readInt(32, cmddata);
				drawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null, 0, new java.awt.Color(argbTL, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_DRAWRECT : "" + len);
			}
			break;
			case GFXCMD_FILLRECT:if(len==32){
				float x, y, width, height;
				int argbTL, argbTR, argbBR, argbBL;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				argbTL=readInt(16, cmddata);
				argbTR=readInt(20, cmddata);
				argbBR=readInt(24, cmddata);
				argbBL=readInt(28, cmddata);
				java.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);
				java.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
				if(gp != null) {
					drawRect0(bounds, null, 0, null, 0, gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(), gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(), 1.0f);
				 }
				 else {
					drawRect0(bounds, null, 0, null, 0, new java.awt.Color(argbTL, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f);
				}
			}
			else{
				System.out.println(""Invalid len for GFXCMD_FILLRECT : "" + len);
			}
			break;
			case GFXCMD_CLEARRECT:if(len==32){
				int x, y, width, height,argbTL, argbTR, argbBR, argbBL;
				x=readInt(0, cmddata);
				y=readInt(4, cmddata);
				width=readInt(8, cmddata);
				height=readInt(12, cmddata);
				argbTL=readInt(16, cmddata);
				argbTR=readInt(20, cmddata);
				argbBR=readInt(24, cmddata);
				argbBL=readInt(28, cmddata);
				java.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
				clearRect0(destRect);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_CLEARRECT : "" + len);
			}
			break;
			case GFXCMD_DRAWOVAL:if(len==52){
				float x, y, width, height, clipX, clipY, clipW, clipH;
				int thickness, argbTL, argbTR, argbBR, argbBL;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				thickness=readInt(16, cmddata);
				argbTL=readInt(20, cmddata);
				argbTR=readInt(24, cmddata);
				argbBR=readInt(28, cmddata);
				argbBL=readInt(32, cmddata);
				clipX=(float)readInt(36, cmddata);
				clipY=(float)readInt(40, cmddata);
				clipW=(float)readInt(44, cmddata);
				clipH=(float)readInt(48, cmddata);
				java.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
				java.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);
				drawOval0(bounds, clipRect, new java.awt.Color(argbTL, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_DRAWOVAL : "" + len);
			}
			break;
			case GFXCMD_FILLOVAL:if(len==48){
				float x, y, width, height,clipX, clipY, clipW, clipH;
				int argbTL, argbTR, argbBR, argbBL;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				argbTL=readInt(16, cmddata);
				argbTR=readInt(20, cmddata);
				argbBR=readInt(24, cmddata);
				argbBL=readInt(28, cmddata);
				clipX=(float)readInt(32, cmddata);
				clipY=(float)readInt(36, cmddata);
				clipW=(float)readInt(40, cmddata);
				clipH=(float)readInt(44, cmddata);
				java.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);
				java.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
				java.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);
				if(gp != null) {
					drawOval0(bounds, clipRect, null, 0, gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(), gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(), 1.0f);
				}
				 else {
					drawOval0(bounds, clipRect, null, 0, new java.awt.Color(argbTL, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f);
				}
			}
			else{
				System.out.println(""Invalid len for GFXCMD_FILLOVAL : "" + len);
			}
			break;
			case GFXCMD_DRAWROUNDRECT:if(len==56){
				float x, y, width, height,clipX, clipY, clipW, clipH;
				int thickness, arcRadius,argbTL, argbTR, argbBR, argbBL;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				thickness=readInt(16, cmddata);
				arcRadius=readInt(20, cmddata);
				argbTL=readInt(24, cmddata);
				argbTR=readInt(28, cmddata);
				argbBR=readInt(32, cmddata);
				argbBL=readInt(36, cmddata);
				clipX=(float)readInt(40, cmddata);
				clipY=(float)readInt(44, cmddata);
				clipW=(float)readInt(48, cmddata);
				clipH=(float)readInt(52, cmddata);
				java.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
				java.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);
				drawRect0(bounds, clipRect, arcRadius, new java.awt.Color(argbTL, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_DRAWROUNDRECT : "" + len);
			}
			break;
			case GFXCMD_FILLROUNDRECT:if(len==52){
				float x, y, width, height,clipX, clipY, clipW, clipH;
				int arcRadius, argbTL, argbTR, argbBR, argbBL;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				arcRadius=readInt(16, cmddata);
				argbTL=readInt(20, cmddata);
				argbTR=readInt(24, cmddata);
				argbBR=readInt(28, cmddata);
				argbBL=readInt(32, cmddata);
				clipX=(float)readInt(36, cmddata);
				clipY=(float)readInt(40, cmddata);
				clipW=(float)readInt(44, cmddata);
				clipH=(float)readInt(48, cmddata);
				java.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);
				java.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);
				java.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);
				if(gp != null) {
					drawRect0(bounds, clipRect, arcRadius, null, 0, gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(), gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(), 1.0f);
				}
				 else {
					drawRect0(bounds, clipRect, arcRadius, null, 0, new java.awt.Color(argbTL, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f);
				}
			}
			else{
				System.out.println(""Invalid len for GFXCMD_FILLROUNDRECT : "" + len);
			}
			break;
			case GFXCMD_DRAWTEXT:if(len>=36 && len>=(36+readInt(8, cmddata)*2)){
				float x, y, clipX, clipY, clipW, clipH;
				int textlen, fontHandle, argb;
				StringBuffer text = new StringBuffer();
				int i;
				x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				textlen=readInt(8, cmddata);
				for(i=0;
				i<textlen;
				i++){
					text.append((char)readShort(12+i*2, cmddata));
				}
				fontHandle=readInt(textlen*2+12, cmddata);
				argb=readInt(textlen*2+16, cmddata);
				clipX=(float)readInt(textlen*2+20, cmddata);
				clipY=(float)readInt(textlen*2+24, cmddata);
				clipW=(float)readInt(textlen*2+28, cmddata);
				clipH=(float)readInt(textlen*2+32, cmddata);
				McFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));
				if(fontPtr != null) {
					String theString = text.toString();
					float[] positions = fontPtr.getGlyphPositions(theString);
					drawTextWithPositions0(theString, fontPtr.nativeFont,x, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),new java.awt.Color(argb, true));
				}
			}
			else{
				System.out.println(""Invalid len for GFXCMD_DRAWTEXT : "" + len);
			}
			break;
			case GFXCMD_DRAWTEXTURED:if(len==40){
				float x, y, width, height,srcx, srcy, srcwidth, srcheight;
				int handle, blend;
				 x=(float)readInt(0, cmddata);
				y=(float)readInt(4, cmddata);
				width=(float)readInt(8, cmddata);
				height=(float)readInt(12, cmddata);
				handle=readInt(16, cmddata);
				srcx=(float)readInt(20, cmddata);
				srcy=(float)readInt(24, cmddata);
				srcwidth=(float)readInt(28, cmddata);
				srcheight=(float)readInt(32, cmddata);
				blend=readInt(36, cmddata);
				boolean doBlend = true;
				if(height < 0) {
					doBlend = false;
					height *= -1;
				}
				if(width < 0) {
					width *= -1;
				}
				 else {
					if(doBlend)blend |= 0x00ffffff;
				 }
				Long imagePtr = (Long)imageMap.get(new Integer(handle));
				java.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);
				java.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);
				if(imagePtr != null) {
					myConn.registerImageAccess(handle);
					drawImage1(imagePtr.longValue(), destRect, srcRect, (doBlend) ? new java.awt.Color(blend, true) : null);
				}
				 else {
					imagePtr = (Long)layerMap.get(new Integer(handle));
					if(imagePtr != null) {
						myConn.registerImageAccess(handle);
						float alpha = (doBlend ? (float)(((blend >> 24)&0xff))/255.0f : 1.0f);
						composite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);
					}
					else{
						System.out.println(""ERROR invalid handle passed for texture rendering of: "" + handle);
						abortRenderCycle = true;
					}
				}
			}
			else{
				System.out.println(""Invalid len for GFXCMD_DRAWTEXTURED : "" + len);
			}
			break;
			case GFXCMD_DRAWLINE:if(len==24){
				float x1, y1, x2, y2;
				int argb1, argb2;
				x1=readInt(0, cmddata);
				y1=readInt(4, cmddata);
				x2=readInt(8, cmddata);
				y2=readInt(12, cmddata);
				argb1=readInt(16, cmddata);
				argb2=readInt(20, cmddata);
				drawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));
			}
			else{
				System.out.println(""Invalid len for GFXCMD_DRAWLINE : "" + len);
			}
			break;
			case GFXCMD_LOADIMAGE:if(len>=8){
				int width, height;
				int imghandle = 0;
				width=readInt(0, cmddata);
				height=readInt(4, cmddata);
				if (width * height * 4 + imageCacheSize > imageCacheLimit){
					imghandle = 0;
				}
				else{
					long imagePtr = createNewImage0(width, height);
					imghandle = handleCount++;
					imageMap.put(new Integer(imghandle), new Long(imagePtr));
					imageCacheSize += width * height * 4;
				}
				hasret[0]=1;
				return imghandle;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_LOADIMAGE : "" + len);
			}
			break;
			case GFXCMD_LOADIMAGETARGETED:if(len>=12){
				int width, height;
				int imghandle = readInt(0, cmddata);
				width=readInt(4, cmddata);
				height=readInt(8, cmddata);
				while (width * height * 4 + imageCacheSize > imageCacheLimit){
					int oldestImage = myConn.getOldestImage();
					if (oldestImage != 0){
						System.out.println(""Freeing image to make room in cache"");
						unloadImage(oldestImage);
						myConn.postImageUnload(oldestImage);
					}
					else{
						System.out.println(""ERROR cannot free enough from the cache to support loading a new image!!!"");
						break;
					}
				}
				long imagePtr = createNewImage0(width, height);
				imageMap.put(new Integer(imghandle), new Long(imagePtr));
				imageCacheSize += width * height * 4;
				myConn.registerImageAccess(imghandle);
				hasret[0]=0;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_LOADIMAGETARGETED : "" + len);
			}
			break;
			case GFXCMD_CREATESURFACE:if(len>=8){
				int width, height;
				int handle = handleCount++;
				;
				width=readInt(0, cmddata);
				height=readInt(4, cmddata);
				long layerPtr = createLayer0(c.getSize());
				layerMap.put(new Integer(handle), new Long(layerPtr));
				hasret[0]=1;
				return handle;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_CREATESURFACE : "" + len);
			}
			break;
			case GFXCMD_PREPIMAGE:if(len>=8){
				int width, height;
				width=readInt(0, cmddata);
				height=readInt(4, cmddata);
				int imghandle = 1;
				if (width * height * 4 + imageCacheSize > imageCacheLimit)imghandle = 0;
				else if (len >= 12){
					int strlen = readInt(8, cmddata);
					if (strlen > 1){
						String rezName = new String(cmddata, 16, strlen - 1);
						lastImageResourceID = rezName;
						lastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());
						java.io.File cachedFile = myConn.getCachedImageFile(rezName);
						if (cachedFile != null){
							long imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());
							if(imagePtr != 0){
								java.awt.Dimension imgSize = getImageDimensions0(imagePtr);
								if(imgSize != null){
									if(imgSize.getWidth() == width && imgSize.getHeight() == height){
										imghandle = handleCount++;
										imageMap.put(new Integer(imghandle), new Long(imagePtr));
										imageCacheSize += getImageSize0(imagePtr);
										hasret[0] = 1;
										return -1 * imghandle;
									}
									elsefreeNativeImage0(imagePtr);
								}
								elsefreeNativeImage0(imagePtr);
							}
						}
					}
				}
				hasret[0]=1;
				return imghandle;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_PREPIMAGE : "" + len);
			}
			break;
			case GFXCMD_PREPIMAGETARGETED:if(len>=12){
				int imghandle, width, height;
				imghandle = readInt(0, cmddata);
				width=readInt(4, cmddata);
				height=readInt(8, cmddata);
				int strlen = readInt(12, cmddata);
				while (width * height * 4 + imageCacheSize > imageCacheLimit){
					int oldestImage = myConn.getOldestImage();
					if (oldestImage != 0){
						System.out.println(""Freeing image to make room in cache"");
						unloadImage(oldestImage);
						myConn.postImageUnload(oldestImage);
					}
					else{
						System.out.println(""ERROR cannot free enough from the cache to support loading a new image!!!"");
						break;
					}
				}
				if (len >= 16){
					String rezName = new String(cmddata, 20, strlen - 1);
					lastImageResourceID = rezName;
					lastImageResourceIDHandle = imghandle;
					System.out.println(""Prepped targeted image with handle "" + imghandle + "" resource="" + rezName);
				}
				myConn.registerImageAccess(imghandle);
				hasret[0]=0;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_PREPIMAGE : "" + len);
			}
			break;
			case GFXCMD_LOADCACHEDIMAGE:if(len>=18){
				int width, height, imghandle;
				imghandle = readInt(0, cmddata);
				width = readInt(4, cmddata);
				height = readInt(8, cmddata);
				int strlen = readInt(12, cmddata);
				String rezName = new String(cmddata, 20, strlen - 1);
				System.out.println(""imghandle="" + imghandle + "" width="" + width + "" height="" + height + "" strlen="" + strlen + "" rezName="" + rezName);
				while (width * height * 4 + imageCacheSize > imageCacheLimit){
					int oldestImage = myConn.getOldestImage();
					if (oldestImage != 0){
						System.out.println(""Freeing image to make room in cache"");
						unloadImage(oldestImage);
						myConn.postImageUnload(oldestImage);
					}
					else{
						System.out.println(""ERROR cannot free enough from the cache to support loading a new image!!!"");
						break;
					}
				}
				myConn.registerImageAccess(imghandle);
				try{
					System.out.println(""Loading resource from cache: "" + rezName);
					java.io.File cachedFile = myConn.getCachedImageFile(rezName);
					if (cachedFile != null){
						System.out.println(""Image found in cache!"");
						long imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());
						if(imagePtr != 0){
							java.awt.Dimension imgSize = getImageDimensions0(imagePtr);
							if(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height){
								imageMap.put(new Integer(imghandle), new Long(imagePtr));
								imageCacheSize += getImageSize0(imagePtr);
							}
							else{
								if (imgSize != null){
									System.out.println(""CACHE ID verification failed for rezName="" + rezName + "" target="" + width + ""x"" + height + "" actual="" + imgSize.getWidth() + ""x"" + imgSize.getHeight());
								}
								elseSystem.out.println(""CACHE Load failed for rezName="" + rezName);
								cachedFile.delete();
								freeNativeImage0(imagePtr);
								myConn.postImageUnload(imghandle);
								myConn.postOfflineCacheChange(false, rezName);
							}
						}
						else{
							cachedFile.delete();
							myConn.postImageUnload(imghandle);
							myConn.postOfflineCacheChange(false, rezName);
						}
					}
					else{
						System.out.println(""ERROR Image not found in cache that should be there! rezName="" + rezName);
						myConn.postImageUnload(imghandle);
						myConn.postOfflineCacheChange(false, rezName);
					}
				}
				catch (java.io.IOException e){
					System.out.println(""ERROR loading compressed image: "" + e);
				}
				hasret[0]=0;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_PREPIMAGE : "" + len);
			}
			break;
			case GFXCMD_UNLOADIMAGE:if(len==4){
				int handle;
				handle=readInt(0, cmddata);
				unloadImage(handle);
				myConn.clearImageAccess(handle);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_UNLOADIMAGE : "" + len);
			}
			break;
			case GFXCMD_SETTARGETSURFACE:if(len==4){
				int handle;
				handle=readInt(0, cmddata);
				Long layerPtr = (Long)layerMap.get(new Integer(handle));
				currentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;
				java.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());
				setLayer0(currentLayer, c.getSize(), clipRect);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_SETTARGETSURFACE : "" + len);
			}
			break;
			case GFXCMD_LOADFONT:if(len>=12 && len>=(12+readInt(0, cmddata))){
				int namelen, style, size;
				StringBuffer name = new StringBuffer();
				int i;
				int fonthandle = handleCount++;
				namelen=readInt(0, cmddata);
				for(i=0;
				i<namelen-1;
				i++) {
					name.append((char) cmddata[8 + i]);
				 }
				style=readInt(namelen+4, cmddata);
				size=readInt(namelen+8, cmddata);
				McFont fontPtr = new McFont(name.toString(), style, size);
				if(fontPtr == null) {
					hasret[0] = 1;
					return 0;
				}
				fontMap.put(new Integer(fonthandle), fontPtr);
				hasret[0] = 1;
				return fonthandle;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_LOADFONT : "" + len);
			}
			break;
			case GFXCMD_UNLOADFONT:if(len==4){
				int handle;
				handle=readInt(0, cmddata);
				McFont fontPtr = (McFont)fontMap.get(new Integer(handle));
				if(fontPtr != null) fontPtr.unload();
				fontMap.remove(new Integer(handle));
			}
			else{
				System.out.println(""Invalid len for GFXCMD_UNLOADFONT : "" + len);
			}
			break;
			case GFXCMD_LOADFONTSTREAM:if (len>=8){
				StringBuffer name = new StringBuffer();
				int namelen = readInt(0, cmddata);
				for(int i=0;
				i<namelen-1;
				i++) {
					name.append((char) cmddata[8 + i]);
				 }
				int datalen = readInt(4 + namelen, cmddata);
				if (len >= datalen + 8 + namelen){
					myConn.saveCacheData(name.toString() + ""-"" + myConn.getServerName(), cmddata, 12 + namelen, datalen);
				}
			}
			else{
				System.out.println(""Invalid len for GFXCMD_LOADFONTSTREAM : "" + len);
			}
			break;
			case GFXCMD_FLIPBUFFER:if (abortRenderCycle){
				System.out.println(""ERROR in painting cycle, ABORT was set...send full repaint command"");
				myConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());
			}
			else{
				present0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));
			}
			hasret[0] = 1;
			firstFrameDone = true;
			return 0;
			case GFXCMD_STARTFRAME:setTargetView0(c.nativeView);
			setLayer0(0, c.getSize(), null);
			 abortRenderCycle = false;
			break;
			case GFXCMD_LOADIMAGELINE:if(len>=12 && len>=(12+readInt(8, cmddata))){
				int handle, line, len2;
				handle=readInt(0, cmddata);
				line=readInt(4, cmddata);
				len2=readInt(8, cmddata);
				Long imagePtr = (Long)imageMap.get(new Integer(handle));
				if(imagePtr != null)loadImageLine0(imagePtr.longValue(), line, cmddata, 16, len2);
				myConn.registerImageAccess(handle);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_LOADIMAGELINE : "" + len);
			}
			break;
			case GFXCMD_LOADIMAGECOMPRESSED:if(len>=8 && len>=(8+readInt(4, cmddata))){
				int handle, len2;
				handle=readInt(0, cmddata);
				len2=readInt(4, cmddata);
				if (lastImageResourceID != null && lastImageResourceIDHandle == handle){
					myConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);
					myConn.postOfflineCacheChange(true, lastImageResourceID);
				}
				if (!myConn.doesUseAdvancedImageCaching()){
					handle = handleCount++;
					hasret[0] = 1;
				}
				elsehasret[0] = 0;
				myConn.registerImageAccess(handle);
				long imagePtr = createImageFromBytes0(cmddata, 12, len2, null);
				 imageMap.put(new Integer(handle), new Long(imagePtr));
				imageCacheSize += getImageSize0(imagePtr);
				return handle;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_LOADIMAGECOMPRESSED : "" + len);
			}
			break;
			case GFXCMD_XFMIMAGE:if (len >= 20){
				int srcHandle, destHandle, destWidth, destHeight, maskCornerArc;
				srcHandle = readInt(0, cmddata);
				destHandle = readInt(4, cmddata);
				destWidth = readInt(8, cmddata);
				destHeight = readInt(12, cmddata);
				maskCornerArc = readInt(16, cmddata);
				int rvHandle = destHandle;
				if (!myConn.doesUseAdvancedImageCaching()){
					rvHandle = handleCount++;
					hasret[0] = 1;
				}
				elsehasret[0] = 0;
				Long srcImg = (Long)imageMap.get(new Integer(srcHandle));
				if(srcImg != null) {
					long newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);
					if(newImage != 0) {
						imageMap.put(new Integer(rvHandle), new Long(newImage));
					}
				}
				return rvHandle;
			}
			else{
				System.out.println(""Invalid len for GFXCMD_XFMIMAGE : "" + len);
			}
			break;
			case GFXCMD_SETVIDEOPROP:if (len >= 40){
				java.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),readInt(12, cmddata), readInt(16, cmddata));
				java.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),readInt(28, cmddata), readInt(32, cmddata));
				System.out.println(""SETVIDEOPROP: srcRect=""+srcRect+"" dstRect=""+destRect);
				setVideoBounds(srcRect, destRect);
			}
			else{
				System.out.println(""Invalid len for GFXCMD_SETVIDEOPROP: "" + len);
			}
			break;
			default:return -1;
		}
		return 0;
	}
	private boolean lastWasPressed;
	private boolean ignoreNextTyped;
	private int lastKeyCode;
	private int lastModifiers;
	public void keyPressed(java.awt.event.KeyEvent evt){
		lastWasPressed = true;
		lastKeyCode = evt.getKeyCode();
		lastModifiers = evt.getModifiers();
		setHidden0(false, false);
		if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_SHIFT ||evt.getKeyCode() == java.awt.event.KeyEvent.VK_CONTROL ||evt.getKeyCode() == java.awt.event.KeyEvent.VK_ALT ||evt.getKeyCode() == java.awt.event.KeyEvent.VK_ALT_GRAPH ||evt.getKeyCode() == java.awt.event.KeyEvent.VK_META){
			ignoreNextTyped = false;
		}
		else if (evt.getKeyChar() == 0 || evt.getKeyChar() == java.awt.event.KeyEvent.CHAR_UNDEFINED){
			myConn.postKeyEvent(lastKeyCode, lastModifiers, (char) 0);
			lastWasPressed = false;
			ignoreNextTyped = false;
		}
		else{
			lastWasPressed = false;
			myConn.postKeyEvent(lastKeyCode, lastModifiers, evt.getKeyChar());
			ignoreNextTyped = true;
		}
	}
	public void keyTyped(java.awt.event.KeyEvent evt){
		setHidden0(false, false);
		if (lastWasPressed){
			lastWasPressed = false;
			myConn.postKeyEvent(lastKeyCode, lastModifiers, evt.getKeyChar());
		}
		else if (!ignoreNextTyped && evt.getKeyCode() == 0 && evt.getKeyChar() != 0 && evt.getKeyChar() != java.awt.event.KeyEvent.CHAR_UNDEFINED){
			myConn.postKeyEvent(0, 0, evt.getKeyChar());
		}
		ignoreNextTyped = false;
	}
	public void keyReleased(java.awt.event.KeyEvent evt){
		setHidden0(false, false);
		if (lastWasPressed){
			lastWasPressed = false;
			myConn.postKeyEvent(lastKeyCode, lastModifiers, (char)0);
		}
		ignoreNextTyped = false;
	}
	public void sendMouseMoved(int x, int y, int modifiers, long when){
		int awtModifiers = 0;
		if((modifiers & (1<<17)) != 0) awtModifiers |= java.awt.event.InputEvent.SHIFT_DOWN_MASK;
		 if((modifiers & (1<<18)) != 0) awtModifiers |= java.awt.event.InputEvent.CTRL_DOWN_MASK;
		 if((modifiers & (1<<19)) != 0) awtModifiers |= java.awt.event.InputEvent.ALT_DOWN_MASK;
		 if((modifiers & (1<<20)) != 0) awtModifiers |= java.awt.event.InputEvent.META_DOWN_MASK;
		 java.awt.event.MouseEvent evt = new java.awt.event.MouseEvent(c, java.awt.event.MouseEvent.MOUSE_MOVED, when, awtModifiers, x, y, 1, false);
		mouseMoved(evt);
	}
	public void sendMouseWheel(int x, int y, int modifiers, long when, int amount){
		int awtModifiers = 0;
		if((modifiers & (1<<17)) != 0) awtModifiers |= java.awt.event.InputEvent.SHIFT_DOWN_MASK;
		 if((modifiers & (1<<18)) != 0) awtModifiers |= java.awt.event.InputEvent.CTRL_DOWN_MASK;
		 if((modifiers & (1<<19)) != 0) awtModifiers |= java.awt.event.InputEvent.ALT_DOWN_MASK;
		 if((modifiers & (1<<20)) != 0) awtModifiers |= java.awt.event.InputEvent.META_DOWN_MASK;
		 java.awt.event.MouseWheelEvent evt = new java.awt.event.MouseWheelEvent(c, java.awt.event.MouseEvent.MOUSE_WHEEL, when, awtModifiers, x, y, 1, false, java.awt.event.MouseWheelEvent.WHEEL_BLOCK_SCROLL, 0, amount);
		mouseWheelMoved(evt);
	}
	public void mouseClicked(java.awt.event.MouseEvent e){
		setHidden0(false, true);
		myConn.postMouseEvent(e);
	}
	public void mouseEntered(java.awt.event.MouseEvent e){
	}
	public void mouseExited(java.awt.event.MouseEvent e){
	}
	public void mousePressed(java.awt.event.MouseEvent e){
		setHidden0(false, true);
		myConn.postMouseEvent(e);
	}
	public void mouseReleased(java.awt.event.MouseEvent e){
		setHidden0(false, true);
		myConn.postMouseEvent(e);
	}
	public void mouseDragged(java.awt.event.MouseEvent e){
		setHidden0(false, true);
		myConn.postMouseEvent(e);
	}
	public void mouseMoved(java.awt.event.MouseEvent e){
		setHidden0(false, true);
		if (e.getSource() == c)f.setCursor(null);
		myConn.postMouseEvent(e);
	}
	public void mouseWheelMoved(java.awt.event.MouseWheelEvent e){
		myConn.postMouseEvent(e);
	}
	public native boolean setHidden0(boolean x, boolean fromMouseAction);
	private Object timerLocks = new Object();
	private void cancelHideTimer(){
		synchronized (timerLocks){
			if (hideTimer != null)hideTimer.cancel();
		}
	}
	public void resetHideTimer(){
		synchronized (timerLocks){
			if (hideTimer != null)hideTimer.cancel();
			myConn.addTimerTask(hideTimer = new HideTimerTask(), 5000, 0);
		}
	}
	private class HideTimerTask extends java.util.TimerTask{
		public void run(){
			hideTime = System.currentTimeMillis();
			setHidden0(true, false);
		}
	}
	public boolean createVideo(int width, int height, int format){
		System.out.println(""QuartzGFXCMD.createVideo(""+width+"",""+height+"",""+format);
		return true;
	}
	public boolean updateVideo(int frametype, java.nio.ByteBuffer buf){
		System.out.println(""QuartzGFXCMD.updateVideo()"");
		return true;
	}
	private void unloadImage(int handle){
		Long imagePtr = (Long)imageMap.get(new Integer(handle));
		if(imagePtr != null) {
			imageCacheSize -= getImageSize0(imagePtr.longValue());
			freeNativeImage0(imagePtr.longValue());
		}
		imageMap.remove(new Integer(handle));
		myConn.clearImageAccess(handle);
	}
	private native void init0();
	private native boolean canLoadCompressed0(String extension);
	private native long createNewImage0(int width, int height);
	private native void loadImageLine0(long imagePtr, int line, byte[] lineData, int dataOffset, int dataLen);
	private native long createImageFromPath0(String path);
	private native long createImageFromURL0(String absoluteURL);
	private native long createImageFromBytes0(byte[] data, int offset, int length, String extension);
	private native long transformImage0(long sourceImagePtr, int width, int height, int arcRadius);
	private native int getImageSize0(long nativePtr);
	private native java.awt.Dimension getImageDimensions0(long nativePtr);
	private native void freeNativeImage0(long nativePointer);
	private native void setTargetView0(long view);
	private native long createLayer0(java.awt.Dimension size);
	private native void freeLayer0(long layerPtr);
	private native void setLayer0(long layerPtr, java.awt.Dimension size, java.awt.Rectangle clipRect);
	private native void composite0(long srcLayer, long destLayer, java.awt.geom.Rectangle2D.Float srcRect, java.awt.geom.Rectangle2D.Float dstRect, float alphaFactor, boolean enableBlend);
	private native long loadFont0(String name, int style, int size);
	 private native long loadCachedFont0(String cacheDir, String cacheFile, int style, int size);
	private native void unloadFont0(long fontPtr);
	private native void present0(long view, java.awt.Rectangle clipRect);
	private native void setVideoRects0(java.awt.geom.Rectangle2D.Float srcRect, java.awt.geom.Rectangle2D.Float destRect, java.awt.Color backColor);
	private native void drawLine0(float sx, float sy, float dx, float dy, int thickness, java.awt.Color lineColor);
	private native void clearRect0(java.awt.geom.Rectangle2D.Float rect);
	private native void drawRect0(java.awt.geom.Rectangle2D.Float bounds, java.awt.geom.Rectangle2D.Float clipRect, int arcRadius, java.awt.Color strokeColor, int strokeWidth, java.awt.Color gc1, float gc1x, float gc1y, java.awt.Color gc2, float gc2x, float gc2y, float alphaFactor );
	private native void drawOval0(java.awt.geom.Rectangle2D.Float bounds, java.awt.geom.Rectangle2D.Float clipRect, java.awt.Color strokeColor, int strokeWidth, java.awt.Color gc1, float gc1x, float gc1y, java.awt.Color gc2, float gc2x, float gc2y, float alphaFactor );
	private native void drawImage0(long nativePtr, java.awt.geom.Rectangle2D.Float destRect, java.awt.geom.Rectangle2D.Float clipRect, float alphaFactor);
	private native void drawImage1(long nativePtr, java.awt.geom.Rectangle2D.Float destRect, java.awt.geom.Rectangle2D.Float sourceRect, java.awt.Color blendColor);
	private native void drawImageWithInsets0(long nativePtr, java.awt.geom.Rectangle2D.Float destRect, java.awt.geom.Rectangle2D.Float clipRect, float alphaFactor, int []insets);
	private native void drawText0(String theString, long nsFont, java.awt.geom.Rectangle2D.Float destRect, java.awt.geom.Rectangle2D.Float clipRect, java.awt.Color color);
	private native void drawTextWithPositions0(String theString, long nsFont, float x, float y, float[] positions, java.awt.geom.Rectangle2D.Float clipRect, java.awt.Color color);
	private native void cleanupRenderer0();
	private native void setWaitIndicatorImage(long viewPtr, long imagePtr, java.awt.geom.Rectangle2D.Float destRect, java.awt.geom.Rectangle2D.Float clipRect, float alphaFactor);
	public native String getServerVideoOutParams();
}",1,0,0,0
"public abstract class AbstractSelectorContainer extends DataType implements Cloneable, SelectorContainer {
	 private Vector selectorsList = new Vector();
	 public boolean hasSelectors() {
		 if (isReference()) {
			 return ((AbstractSelectorContainer) getCheckedRef()).hasSelectors();
		 }
		 dieOnCircularReference();
		 return !(selectorsList.isEmpty());
	 }
	 public int selectorCount() {
		 if (isReference()) {
			 return ((AbstractSelectorContainer) getCheckedRef()).selectorCount();
		 }
		 dieOnCircularReference();
		 return selectorsList.size();
	 }
	 public FileSelector[] getSelectors(Project p) {
		 if (isReference()) {
			 return ((AbstractSelectorContainer) getCheckedRef(p)) .getSelectors(p);
		 }
		 dieOnCircularReference(p);
		 FileSelector[] result = new FileSelector[selectorsList.size()];
		 selectorsList.copyInto(result);
		 return result;
	 }
	 public Enumeration selectorElements() {
		 if (isReference()) {
			 return ((AbstractSelectorContainer) getCheckedRef()) .selectorElements();
		 }
		 dieOnCircularReference();
		 return selectorsList.elements();
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 Enumeration e = selectorElements();
		 if (e.hasMoreElements()) {
			 while (e.hasMoreElements()) {
				 buf.append(e.nextElement().toString());
				 if (e.hasMoreElements()) {
					 buf.append("", "");
				 }
			 }
		 }
		 return buf.toString();
	 }
	 public void appendSelector(FileSelector selector) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 selectorsList.addElement(selector);
		 setChecked(false);
	 }
	 public void validate() {
		 if (isReference()) {
			 ((AbstractSelectorContainer) getCheckedRef()).validate();
		 }
		 dieOnCircularReference();
		 Enumeration e = selectorElements();
		 while (e.hasMoreElements()) {
			 Object o = e.nextElement();
			 if (o instanceof BaseSelector) {
				 ((BaseSelector) o).validate();
			 }
		 }
	 }
	 public void addSelector(SelectSelector selector) {
		 appendSelector(selector);
	 }
	 public void addAnd(AndSelector selector) {
		 appendSelector(selector);
	 }
	 public void addOr(OrSelector selector) {
		 appendSelector(selector);
	 }
	 public void addNot(NotSelector selector) {
		 appendSelector(selector);
	 }
	 public void addNone(NoneSelector selector) {
		 appendSelector(selector);
	 }
	 public void addMajority(MajoritySelector selector) {
		 appendSelector(selector);
	 }
	 public void addDate(DateSelector selector) {
		 appendSelector(selector);
	 }
	 public void addSize(SizeSelector selector) {
		 appendSelector(selector);
	 }
	 public void addFilename(FilenameSelector selector) {
		 appendSelector(selector);
	 }
	 public void addCustom(ExtendSelector selector) {
		 appendSelector(selector);
	 }
	 public void addContains(ContainsSelector selector) {
		 appendSelector(selector);
	 }
	 public void addPresent(PresentSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDepth(DepthSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDepend(DependSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDifferent(DifferentSelector selector) {
		 appendSelector(selector);
	 }
	 public void addType(TypeSelector selector) {
		 appendSelector(selector);
	 }
	 public void addContainsRegexp(ContainsRegexpSelector selector) {
		 appendSelector(selector);
	 }
	 public void addModified(ModifiedSelector selector) {
		 appendSelector(selector);
	 }
	 public void addReadable(ReadableSelector r) {
		 appendSelector(r);
	 }
	 public void addWritable(WritableSelector w) {
		 appendSelector(w);
	 }
	 public void add(FileSelector selector) {
		 appendSelector(selector);
	 }
	 protected synchronized void dieOnCircularReference(Stack stk, Project p) {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 for (Iterator i = selectorsList.iterator();
			 i.hasNext();
			 ) {
				 Object o = i.next();
				 if (o instanceof DataType) {
					 pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
				 }
			 }
			 setChecked(true);
		 }
	 }
	 public synchronized Object clone() {
		 if (isReference()) {
			 return ((AbstractSelectorContainer) getCheckedRef()).clone();
		 }
		 try {
			 AbstractSelectorContainer sc = (AbstractSelectorContainer) super.clone();
			 sc.selectorsList = new Vector(selectorsList);
			 return sc;
		 }
		 catch (CloneNotSupportedException e) {
			 throw new BuildException(e);
		 }
	 }
}",0,0,0,0
"private static void updateColumnFamily(CFMetaData newState) throws IOException {
	 CFMetaData cfm = Schema.instance.getCFMetaData(newState.ksName, newState.cfName);
	 assert cfm != null;
	 cfm.reload();
	 if (!StorageService.instance.isClientMode()) {
		 Table table = Table.open(cfm.ksName);
		 table.getColumnFamilyStore(cfm.cfName).reload();
	 }
 }",0,0,0,0
"public class TargetInfos extends HashMap<String, HashMap<String, String>> {
	 private static final String ACCESS_TOKEN_KEY = "":token"";
	 private static final String ORG_KEY = "":organization"";
	 private static final String REFRESH_TOKEN_KEY = "":refresh_token"";
	 private static final String SPACE_KEY = "":space"";
	 private static final String VERSION_KEY = "":version"";
	 public HashMap<String, String> get(URI target) {
		 return get(target.toString());
	 }
	 public String getOrganization(HashMap<String, String> target) {
		 return target.get(ORG_KEY);
	 }
	 public DefaultOAuth2RefreshToken getRefreshToken(HashMap<String, String> target) {
		 final String token = target.get(REFRESH_TOKEN_KEY);
		 return new DefaultOAuth2RefreshToken(token);
	 }
	 public String getSpace(HashMap<String, String> target) {
		 return target.get(SPACE_KEY);
	 }
	 public DefaultOAuth2AccessToken getToken(HashMap<String, String> target) {
		 final String token = target.get(ACCESS_TOKEN_KEY);
		 final String[] tokens = token.split("" "");
		 return new DefaultOAuth2AccessToken(tokens[1]);
	 }
	 public String getVersion(HashMap<String, String> target) {
		 return target.get(VERSION_KEY);
	 }
	 public void put(URI target, HashMap<String, String> targetInfo) {
		 put(target.toString(), targetInfo);
	 }
	 public void putOrganization(HashMap<String, String> target, String org) {
		 target.put(ORG_KEY, org);
	 }
	 public void putRefreshToken(HashMap<String, String> target, OAuth2RefreshToken token) {
		 target.put(REFRESH_TOKEN_KEY, token.getValue());
	 }
	 public void putSpace(HashMap<String, String> target, String space) {
		 target.put(SPACE_KEY, space);
	 }
	 public void putToken(HashMap<String, String> target, OAuth2AccessToken token) {
		 target.put(ACCESS_TOKEN_KEY, String.format(""%s %s"", token.getTokenType() .toLowerCase(), token.getValue()));
	 }
	 public void putVersion(HashMap<String, String> target, String version) {
		 target.put(VERSION_KEY, version);
	 }
	 public HashMap<String, String> remove(URI target) {
		 return remove(target.toString());
	 }
}",0,0,0,0
"public class OkHttpDataSource extends BaseDataSource implements HttpDataSource {
	 static {
		 ExoPlayerLibraryInfo.registerModule(""goog.exo.okhttp"");
	 }
	 private static final byte[] SKIP_BUFFER = new byte[4096];
	 private final Call.Factory callFactory;
	 private final RequestProperties requestProperties;
	 private final String userAgent;
	 private final Predicate<String> contentTypePredicate;
	 private final CacheControl cacheControl;
	 private final RequestProperties defaultRequestProperties;
	 private DataSpec dataSpec;
	 private Response response;
	 private InputStream responseByteStream;
	 private boolean opened;
	 private long bytesToSkip;
	 private long bytesToRead;
	 private long bytesSkipped;
	 private long bytesRead;
	 public OkHttpDataSource( Call.Factory callFactory, String userAgent, Predicate<String> contentTypePredicate) {
		 this( callFactory, userAgent, contentTypePredicate, null, null);
	 }
	 public OkHttpDataSource( Call.Factory callFactory, String userAgent, Predicate<String> contentTypePredicate, CacheControl cacheControl, RequestProperties defaultRequestProperties) {
		 super( true);
		 this.callFactory = Assertions.checkNotNull(callFactory);
		 this.userAgent = userAgent;
		 this.contentTypePredicate = contentTypePredicate;
		 this.cacheControl = cacheControl;
		 this.defaultRequestProperties = defaultRequestProperties;
		 this.requestProperties = new RequestProperties();
	 }
	 public Uri getUri() {
		 return response == null ? null : Uri.parse(response.request().url().toString());
	 }
	 public Map<String, List<String>> getResponseHeaders() {
		 return response == null ? Collections.emptyMap() : response.headers().toMultimap();
	 }
	 public void setRequestProperty(String name, String value) {
		 Assertions.checkNotNull(name);
		 Assertions.checkNotNull(value);
		 requestProperties.set(name, value);
	 }
	 public void clearRequestProperty(String name) {
		 Assertions.checkNotNull(name);
		 requestProperties.remove(name);
	 }
	 public void clearAllRequestProperties() {
		 requestProperties.clear();
	 }
	 public long open(DataSpec dataSpec) throws HttpDataSourceException {
		 this.dataSpec = dataSpec;
		 this.bytesRead = 0;
		 this.bytesSkipped = 0;
		 transferInitializing(dataSpec);
		 Request request = makeRequest(dataSpec);
		 Response response;
		 ResponseBody responseBody;
		 try {
			 this.response = callFactory.newCall(request).execute();
			 response = this.response;
			 responseBody = Assertions.checkNotNull(response.body());
			 responseByteStream = responseBody.byteStream();
		 }
		 catch (IOException e) {
			 throw new HttpDataSourceException( ""Unable to connect to "" + dataSpec.uri, e, dataSpec, HttpDataSourceException.TYPE_OPEN);
		 }
		 int responseCode = response.code();
		 if (!response.isSuccessful()) {
			 Map<String, List<String>> headers = response.headers().toMultimap();
			 closeConnectionQuietly();
			 InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode, response.message(), headers, dataSpec);
			 if (responseCode == 416) {
				 exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
			 }
			 throw exception;
		 }
		 MediaType mediaType = responseBody.contentType();
		 String contentType = mediaType != null ? mediaType.toString() : """";
		 if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
			 closeConnectionQuietly();
			 throw new InvalidContentTypeException(contentType, dataSpec);
		 }
		 bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
		 if (dataSpec.length != C.LENGTH_UNSET) {
			 bytesToRead = dataSpec.length;
		 }
		 else {
			 long contentLength = responseBody.contentLength();
			 bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
		 }
		 opened = true;
		 transferStarted(dataSpec);
		 return bytesToRead;
	 }
	 public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
		 try {
			 skipInternal();
			 return readInternal(buffer, offset, readLength);
		 }
		 catch (IOException e) {
			 throw new HttpDataSourceException( e, Assertions.checkNotNull(dataSpec), HttpDataSourceException.TYPE_READ);
		 }
	 }
	 public void close() throws HttpDataSourceException {
		 if (opened) {
			 opened = false;
			 transferEnded();
			 closeConnectionQuietly();
		 }
	 }
	 protected final long bytesSkipped() {
		 return bytesSkipped;
	 }
	 protected final long bytesRead() {
		 return bytesRead;
	 }
	 protected final long bytesRemaining() {
		 return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
	 }
	 private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {
		 long position = dataSpec.position;
		 long length = dataSpec.length;
		 boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
		 HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
		 if (url == null) {
			 throw new HttpDataSourceException( ""Malformed URL"", dataSpec, HttpDataSourceException.TYPE_OPEN);
		 }
		 Request.Builder builder = new Request.Builder().url(url);
		 if (cacheControl != null) {
			 builder.cacheControl(cacheControl);
		 }
		 if (defaultRequestProperties != null) {
			 for (Map.Entry<String, String> property : defaultRequestProperties.getSnapshot().entrySet()) {
				 builder.header(property.getKey(), property.getValue());
			 }
		 }
		 for (Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {
			 builder.header(property.getKey(), property.getValue());
		 }
		 if (!(position == 0 && length == C.LENGTH_UNSET)) {
			 String rangeRequest = ""bytes="" + position + ""-"";
			 if (length != C.LENGTH_UNSET) {
				 rangeRequest += (position + length - 1);
			 }
			 builder.addHeader(""Range"", rangeRequest);
		 }
		 if (userAgent != null) {
			 builder.addHeader(""User-Agent"", userAgent);
		 }
		 if (!allowGzip) {
			 builder.addHeader(""Accept-Encoding"", ""identity"");
		 }
		 RequestBody requestBody = null;
		 if (dataSpec.httpBody != null) {
			 requestBody = RequestBody.create(null, dataSpec.httpBody);
		 }
		 else if (dataSpec.httpMethod == DataSpec.HTTP_METHOD_POST) {
			 requestBody = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
		 }
		 builder.method(dataSpec.getHttpMethodString(), requestBody);
		 return builder.build();
	 }
	 private void skipInternal() throws IOException {
		 if (bytesSkipped == bytesToSkip) {
			 return;
		 }
		 while (bytesSkipped != bytesToSkip) {
			 int readLength = (int) Math.min(bytesToSkip - bytesSkipped, SKIP_BUFFER.length);
			 int read = castNonNull(responseByteStream).read(SKIP_BUFFER, 0, readLength);
			 if (Thread.currentThread().isInterrupted()) {
				 throw new InterruptedIOException();
			 }
			 if (read == -1) {
				 throw new EOFException();
			 }
			 bytesSkipped += read;
			 bytesTransferred(read);
		 }
	 }
	 private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
		 if (readLength == 0) {
			 return 0;
		 }
		 if (bytesToRead != C.LENGTH_UNSET) {
			 long bytesRemaining = bytesToRead - bytesRead;
			 if (bytesRemaining == 0) {
				 return C.RESULT_END_OF_INPUT;
			 }
			 readLength = (int) Math.min(readLength, bytesRemaining);
		 }
		 int read = castNonNull(responseByteStream).read(buffer, offset, readLength);
		 if (read == -1) {
			 if (bytesToRead != C.LENGTH_UNSET) {
				 throw new EOFException();
			 }
			 return C.RESULT_END_OF_INPUT;
		 }
		 bytesRead += read;
		 bytesTransferred(read);
		 return read;
	 }
	 private void closeConnectionQuietly() {
		 if (response != null) {
			 Assertions.checkNotNull(response.body()).close();
			 response = null;
		 }
		 responseByteStream = null;
	 }
}",1,1,0,0
"public void skipChildren() {
	 int childLen = (currentChildren != null) ? currentChildren.getLength() : 0;
	 for (int i = 0 ;
	 i < childLen ;
	 i++) {
		 Node child = nodes.peek();
		 if (child.equals(currentChildren.item(i))) {
			 nodes.pop();
		 }
	 }
 }",0,0,0,0
"public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer);",0,0,0,1
"public static int getMaxStreamingRetries() {
	 return conf.max_streaming_retries;
 }",0,0,0,0
"private void handleChainFromFilter( StreamTypeRecord streamType, MethodInvocationTree observableDotFilter, Tree filterMethodOrLambda, VisitorState state) {
	 MethodInvocationTree outerCallInChain = observableDotFilter;
	 if (outerCallInChain == null) {
		 return;
	 }
	 do {
		 outerCallInChain = observableOuterCallInChain.get(outerCallInChain);
		 MethodInvocationTree mapCallsite = observableOuterCallInChain.get(observableDotFilter);
		 if (observableCallToInnerMethodOrLambda.containsKey(outerCallInChain)) {
			 Symbol.MethodSymbol mapMethod = ASTHelpers.getSymbol(outerCallInChain);
			 if (streamType.isMapMethod(mapMethod)) {
				 MaplikeToFilterInstanceRecord record = new MaplikeToFilterInstanceRecord( streamType.getMaplikeMethodRecord(mapMethod), filterMethodOrLambda);
				 mapToFilterMap.put(observableCallToInnerMethodOrLambda.get(outerCallInChain), record);
			 }
		 }
	 }
	 while (outerCallInChain != null && streamType.matchesType(ASTHelpers.getReceiverType(outerCallInChain), state) && streamType.isPassthroughMethod(ASTHelpers.getSymbol(outerCallInChain)));
 }",0,0,1,0
"public abstract class AttributeHandler extends ParseSax.HandlerForGeneratedRequestWithResult<String> {
	 public static class PoolName extends AttributeHandler {
		 public PoolName() {
			 super(""PoolName"");
		 }
	 }
	 private final String attributeName;
	 private String attribute = null;
	 private AttributeHandler(String attributeName) {
		 this.attributeName = checkNotNull(attributeName, ""attributeName"");
	 }
	 public String getResult() {
		 return checkNotNull(attribute, ""%s not present in the response"", attributeName);
	 }
	 public void startElement(String uri, String localName, String qName, Attributes attrs) {
		 Map<String, String> attributes = cleanseAttributes(attrs);
		 if (attribute == null && attributes.containsKey(attributeName)) {
			 attribute = attributes.get(attributeName);
		 }
	 }
}",0,0,0,0
"public class XPathimplements XPathTreeConstants, XPathConstants {
	 protected JJTXPathState jjtree = new JJTXPathState();
	 boolean m_isMatchPattern = false;
	 boolean isStep = false;
	 Stack binaryTokenStack = new Stack();
	 public Node createNode(int id) {
		 return null;
	 }
	 public static void main(String args[]) throws Exception {
		 int numberArgsLeft = args.length;
		 int argsStart = 0;
		 boolean isMatchParser = false;
		 if(numberArgsLeft > 0) {
			 if(args[argsStart].equals(""-match"")) {
				 isMatchParser = true;
				 System.out.println(""Match Pattern Parser"");
				 argsStart++;
				 numberArgsLeft--;
			 }
		 }
		 if(numberArgsLeft > 0) {
			 try {
				 final boolean dumpTree = true;
				 if(args[0].endsWith("".xquery"")) {
					 System.out.println(""Running test for: ""+args[0]);
					 File file = new File(args[0]);
					 FileInputStream fis = new FileInputStream(file);
					 XPath parser = new XPath(fis);
					 SimpleNode tree = parser.XPath2();
					 if(dumpTree) tree.dump(""|"") ;
				 }
				 else {
					 for(int i = argsStart;
					 i < args.length;
					 i++) {
						 System.out.println();
						 System.out.println(""Test[""+i+""]: ""+args[i]);
						 XPath parser = new XPath(new java.io.StringBufferInputStream(args[i]));
						 SimpleNode tree;
						 if(isMatchParser) {
							 tree = parser.XPath2();
						 }
						 else {
							 tree = parser.XPath2();
						 }
						 ((SimpleNode)tree.jjtGetChild(0)).dump(""|"") ;
					 }
					 System.out.println(""Success!!!!"");
				 }
			 }
			 catch(ParseException pe) {
				 System.err.println(pe.getMessage());
			 }
			 return;
		 }
		 java.io.DataInputStream dinput = new java.io.DataInputStream(System.in);
		 while(true) {
			 try {
				 System.err.println(""Type Expression: "");
				 String input = dinput.readLine();
				 if(null == input || input.trim().length() == 0) break;
				 XPath parser = new XPath(new java.io.StringBufferInputStream(input));
				 SimpleNode tree;
				 if(isMatchParser) {
					 tree = parser.XPath2();
				 }
				 else {
					 tree = parser.XPath2();
				 }
				 ((SimpleNode)tree.jjtGetChild(0)).dump(""|"") ;
			 }
			 catch(ParseException pe) {
				 System.err.println(pe.getMessage());
			 }
			 catch(Exception e) {
				 System.err.println(e.getMessage());
			 }
		 }
	 }
	 final public SimpleNode XPath2() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTXPATH2);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 QueryList();
			 jj_consume_token(0);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return jjtn000 ;
			}
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void QueryList() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTQUERYLIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 Module();
			 label_1: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case QuerySeparator: ;
					 break;
					 default: jj_la1[0] = jj_gen;
					 break label_1;
				 }
				 jj_consume_token(QuerySeparator);
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case XQueryVersion: case ModuleNamespace: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case DefineFunction: case DeclareOrdering: case DeclareDefaultOrderingEmpty: case DeclareInheritNamespaces: case VariableIndicator: case DeclareConstruction: case DeclareXMLSpace: case DeclareBaseURI: case DeclareNamespace: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case DeclareCollation: case DeclareDefaultElement: case DeclareDefaultFunction: case ImportSchemaToken: case ImportModuleToken: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case DefineVariable: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: Module();
					 break;
					 default: jj_la1[1] = jj_gen;
					 ;
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Module() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTMODULE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case XQueryVersion: VersionDecl();
				 break;
				 default: jj_la1[2] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case DefineFunction: case DeclareOrdering: case DeclareDefaultOrderingEmpty: case DeclareInheritNamespaces: case VariableIndicator: case DeclareConstruction: case DeclareXMLSpace: case DeclareBaseURI: case DeclareNamespace: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case DeclareCollation: case DeclareDefaultElement: case DeclareDefaultFunction: case ImportSchemaToken: case ImportModuleToken: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case DefineVariable: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: MainModule();
				 break;
				 case ModuleNamespace: LibraryModule();
				 break;
				 default: jj_la1[3] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void VersionDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTVERSIONDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(XQueryVersion);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTXQUERYVERSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(StringLiteralForVersion);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTSTRINGLITERALFORVERSION);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case XQueryEncoding: jj_consume_token(XQueryEncoding);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTXQUERYENCODING);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 jj_consume_token(StringLiteralForVersion);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTSTRINGLITERALFORVERSION);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[4] = jj_gen;
				 ;
			 }
			 Separator();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void MainModule() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTMAINMODULE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 Prolog();
			 QueryBody();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void LibraryModule() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTLIBRARYMODULE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 ModuleDecl();
			 Prolog();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ModuleDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTMODULEDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(ModuleNamespace);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTMODULENAMESPACE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(NCNameForPrefix);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 jj_consume_token(AssignEquals);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTASSIGNEQUALS);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
			 Separator();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Prolog() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPROLOG);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_2: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DeclareOrdering: case DeclareDefaultOrderingEmpty: case DeclareInheritNamespaces: case DeclareConstruction: case DeclareXMLSpace: case DeclareBaseURI: case DeclareCollation: ;
					 break;
					 default: jj_la1[5] = jj_gen;
					 break label_2;
				 }
				 Setter();
				 Separator();
			 }
			 label_3: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DeclareNamespace: case DeclareDefaultElement: case DeclareDefaultFunction: case ImportSchemaToken: case ImportModuleToken: ;
					 break;
					 default: jj_la1[6] = jj_gen;
					 break label_3;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case ImportSchemaToken: case ImportModuleToken: Import();
					 break;
					 case DeclareNamespace: NamespaceDecl();
					 break;
					 case DeclareDefaultElement: case DeclareDefaultFunction: DefaultNamespaceDecl();
					 break;
					 default: jj_la1[7] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 Separator();
			 }
			 label_4: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DefineFunction: case DefineVariable: ;
					 break;
					 default: jj_la1[8] = jj_gen;
					 break label_4;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DefineVariable: VarDecl();
					 break;
					 case DefineFunction: FunctionDecl();
					 break;
					 default: jj_la1[9] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 Separator();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Setter() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSETTER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case DeclareXMLSpace: XMLSpaceDecl();
				 break;
				 case DeclareCollation: DefaultCollationDecl();
				 break;
				 case DeclareBaseURI: BaseURIDecl();
				 break;
				 case DeclareConstruction: ConstructionDecl();
				 break;
				 case DeclareOrdering: OrderingModeDecl();
				 break;
				 case DeclareDefaultOrderingEmpty: EmptyOrderingDecl();
				 break;
				 case DeclareInheritNamespaces: InheritNamespacesDecl();
				 break;
				 default: jj_la1[10] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Import() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTIMPORT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ImportSchemaToken: SchemaImport();
				 break;
				 case ImportModuleToken: ModuleImport();
				 break;
				 default: jj_la1[11] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Separator() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSEPARATOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(SemiColon);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void NamespaceDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTNAMESPACEDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareNamespace);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLARENAMESPACE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(NCNameForPrefix);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 jj_consume_token(AssignEquals);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTASSIGNEQUALS);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void XMLSpaceDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTXMLSPACEDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareXMLSpace);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREXMLSPACE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case XMLSpacePreserve: jj_consume_token(XMLSpacePreserve);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTXMLSPACEPRESERVE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case XMLSpaceStrip: jj_consume_token(XMLSpaceStrip);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTXMLSPACESTRIP);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[12] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DefaultNamespaceDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDEFAULTNAMESPACEDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case DeclareDefaultElement: jj_consume_token(DeclareDefaultElement);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREDEFAULTELEMENT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case DeclareDefaultFunction: jj_consume_token(DeclareDefaultFunction);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTDECLAREDEFAULTFUNCTION);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[13] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(Namespace);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTNAMESPACE);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OrderingModeDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTORDERINGMODEDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareOrdering);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREORDERING);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Ordered: jj_consume_token(Ordered);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTORDERED);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case Unordered: jj_consume_token(Unordered);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTUNORDERED);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[14] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void EmptyOrderingDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTEMPTYORDERINGDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareDefaultOrderingEmpty);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREDEFAULTORDERINGEMPTY);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EmptyGreatest: jj_consume_token(EmptyGreatest);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTEMPTYGREATEST);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case EmptyLeast: jj_consume_token(EmptyLeast);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTEMPTYLEAST);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[15] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void InheritNamespacesDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTINHERITNAMESPACESDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareInheritNamespaces);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREINHERITNAMESPACES);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Yes: jj_consume_token(Yes);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTYES);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case No: jj_consume_token(No);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTNO);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[16] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DefaultCollationDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDEFAULTCOLLATIONDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareCollation);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLARECOLLATION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void BaseURIDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTBASEURIDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareBaseURI);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREBASEURI);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SchemaImport() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAIMPORT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(ImportSchemaToken);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTIMPORTSCHEMATOKEN);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Namespace: case DefaultElement: SchemaPrefix();
				 break;
				 default: jj_la1[17] = jj_gen;
				 ;
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AtStringLiteral: jj_consume_token(AtStringLiteral);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTATSTRINGLITERAL);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 label_5: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case Comma: ;
						 break;
						 default: jj_la1[18] = jj_gen;
						 break label_5;
					 }
					 jj_consume_token(Comma);
					 jj_consume_token(StringLiteral);
					 SimpleNode jjtn004 = new SimpleNode(this, JJTSTRINGLITERAL);
					 boolean jjtc004 = true;
					 jjtree.openNodeScope(jjtn004);
					 try {
						 jjtree.closeNodeScope(jjtn004, true);
						 jjtc004 = false;
						 jjtn004.processToken(token);
					 }
					 finally {
						 if (jjtc004) {
							 jjtree.closeNodeScope(jjtn004, true);
						 }
					 }
				 }
				 break;
				 default: jj_la1[19] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SchemaPrefix() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAPREFIX);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Namespace: jj_consume_token(Namespace);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTNAMESPACE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 jj_consume_token(NCNameForPrefix);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 jj_consume_token(AssignEquals);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTASSIGNEQUALS);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 case DefaultElement: jj_consume_token(DefaultElement);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTDEFAULTELEMENT);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 jj_consume_token(Namespace);
				 SimpleNode jjtn005 = new SimpleNode(this, JJTNAMESPACE);
				 boolean jjtc005 = true;
				 jjtree.openNodeScope(jjtn005);
				 try {
					 jjtree.closeNodeScope(jjtn005, true);
					 jjtc005 = false;
					 jjtn005.processToken(token);
				 }
				 finally {
					 if (jjtc005) {
						 jjtree.closeNodeScope(jjtn005, true);
					 }
				 }
				 break;
				 default: jj_la1[20] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ModuleImport() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTMODULEIMPORT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(ImportModuleToken);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTIMPORTMODULETOKEN);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Namespace: jj_consume_token(Namespace);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTNAMESPACE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 jj_consume_token(NCNameForPrefix);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 jj_consume_token(AssignEquals);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTASSIGNEQUALS);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[21] = jj_gen;
				 ;
			 }
			 jj_consume_token(URLLiteral);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTURLLITERAL);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AtStringLiteral: jj_consume_token(AtStringLiteral);
				 SimpleNode jjtn006 = new SimpleNode(this, JJTATSTRINGLITERAL);
				 boolean jjtc006 = true;
				 jjtree.openNodeScope(jjtn006);
				 try {
					 jjtree.closeNodeScope(jjtn006, true);
					 jjtc006 = false;
					 jjtn006.processToken(token);
				 }
				 finally {
					 if (jjtc006) {
						 jjtree.closeNodeScope(jjtn006, true);
					 }
				 }
				 label_6: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case Comma: ;
						 break;
						 default: jj_la1[22] = jj_gen;
						 break label_6;
					 }
					 jj_consume_token(Comma);
					 jj_consume_token(StringLiteral);
					 SimpleNode jjtn007 = new SimpleNode(this, JJTSTRINGLITERAL);
					 boolean jjtc007 = true;
					 jjtree.openNodeScope(jjtn007);
					 try {
						 jjtree.closeNodeScope(jjtn007, true);
						 jjtc007 = false;
						 jjtn007.processToken(token);
					 }
					 finally {
						 if (jjtc007) {
							 jjtree.closeNodeScope(jjtn007, true);
						 }
					 }
				 }
				 break;
				 default: jj_la1[23] = jj_gen;
				 ;
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void VarDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTVARDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DefineVariable);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDEFINEVARIABLE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(VarName);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case As: TypeDeclaration();
				 break;
				 default: jj_la1[24] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ColonEquals: jj_consume_token(ColonEquals);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTCOLONEQUALS);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 ExprSingle();
				 break;
				 case External: jj_consume_token(External);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTEXTERNAL);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[25] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ConstructionDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTIONDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DeclareConstruction);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLARECONSTRUCTION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(SchemaModeForDeclareConstruction);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTSCHEMAMODEFORDECLARECONSTRUCTION);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void FunctionDecl() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTIONDECL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DefineFunction);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDEFINEFUNCTION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(QNameLpar);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTQNAMELPAR);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case VariableIndicator: ParamList();
				 break;
				 default: jj_la1[26] = jj_gen;
				 ;
			 }
			 jj_consume_token(Rpar);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case As: jj_consume_token(As);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTAS);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 SequenceType();
				 break;
				 default: jj_la1[27] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Lbrace: case LbraceExprEnclosure: EnclosedExpr();
				 break;
				 case External: jj_consume_token(External);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTEXTERNAL);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[28] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ParamList() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPARAMLIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 Param();
			 label_7: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Comma: ;
					 break;
					 default: jj_la1[29] = jj_gen;
					 break label_7;
				 }
				 jj_consume_token(Comma);
				 Param();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Param() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPARAM);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(VariableIndicator);
			 jj_consume_token(VarName);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTVARNAME);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case As: TypeDeclaration();
				 break;
				 default: jj_la1[30] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void EnclosedExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTENCLOSEDEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Lbrace: jj_consume_token(Lbrace);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTLBRACE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case LbraceExprEnclosure: jj_consume_token(LbraceExprEnclosure);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[31] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 Expr();
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void QueryBody() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTQUERYBODY);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 Expr();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Expr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 ExprSingle();
			 label_8: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Comma: ;
					 break;
					 default: jj_la1[32] = jj_gen;
					 break label_8;
				 }
				 jj_consume_token(Comma);
				 ExprSingle();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ExprSingle() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case ForVariable: case LetVariable: FLWORExpr();
			 break;
			 case Some: case Every: QuantifiedExpr();
			 break;
			 case TypeswitchLpar: TypeswitchExpr();
			 break;
			 case IfLpar: IfExpr();
			 break;
			 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: OrExpr();
			 break;
			 default: jj_la1[33] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void FLWORExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTFLWOREXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_9: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case ForVariable: ForClause();
					 break;
					 case LetVariable: LetClause();
					 break;
					 default: jj_la1[34] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case ForVariable: case LetVariable: ;
					 break;
					 default: jj_la1[35] = jj_gen;
					 break label_9;
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Where: WhereClause();
				 break;
				 default: jj_la1[36] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case OrderBy: case OrderByStable: OrderByClause();
				 break;
				 default: jj_la1[37] = jj_gen;
				 ;
			 }
			 jj_consume_token(Return);
			 ExprSingle();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ForClause() throws ParseException {
		 jj_consume_token(ForVariable);
		 jj_consume_token(VarName);
		 SimpleNode jjtn001 = new SimpleNode(this, JJTVARNAME);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, true);
			 jjtc001 = false;
			 jjtn001.processToken(token);
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, true);
			 }
		 }
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case As: TypeDeclaration();
			 break;
			 default: jj_la1[38] = jj_gen;
			 ;
		 }
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AtWord: PositionalVar();
			 break;
			 default: jj_la1[39] = jj_gen;
			 ;
		 }
		 jj_consume_token(In);
		 SimpleNode jjtn002 = new SimpleNode(this, JJTIN);
		 boolean jjtc002 = true;
		 jjtree.openNodeScope(jjtn002);
		 try {
			 jjtree.closeNodeScope(jjtn002, true);
			 jjtc002 = false;
			 jjtn002.processToken(token);
		 }
		 finally {
			 if (jjtc002) {
				 jjtree.closeNodeScope(jjtn002, true);
			 }
		 }
		 ExprSingle();
		 label_10: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Comma: ;
				 break;
				 default: jj_la1[40] = jj_gen;
				 break label_10;
			 }
			 jj_consume_token(Comma);
			 jj_consume_token(VariableIndicator);
			 jj_consume_token(VarName);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTVARNAME);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case As: TypeDeclaration();
				 break;
				 default: jj_la1[41] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AtWord: PositionalVar();
				 break;
				 default: jj_la1[42] = jj_gen;
				 ;
			 }
			 jj_consume_token(In);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTIN);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
			 ExprSingle();
		 }
	 }
	 final public void PositionalVar() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPOSITIONALVAR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(AtWord);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTATWORD);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(VariableIndicator);
			 jj_consume_token(VarName);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void LetClause() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTLETCLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(LetVariable);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTLETVARIABLE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 jj_consume_token(VarName);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case As: TypeDeclaration();
				 break;
				 default: jj_la1[43] = jj_gen;
				 ;
			 }
			 jj_consume_token(ColonEquals);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTCOLONEQUALS);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 ExprSingle();
			 label_11: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Comma: ;
					 break;
					 default: jj_la1[44] = jj_gen;
					 break label_11;
				 }
				 jj_consume_token(Comma);
				 jj_consume_token(VariableIndicator);
				 jj_consume_token(VarName);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTVARNAME);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case As: TypeDeclaration();
					 break;
					 default: jj_la1[45] = jj_gen;
					 ;
				 }
				 jj_consume_token(ColonEquals);
				 SimpleNode jjtn005 = new SimpleNode(this, JJTCOLONEQUALS);
				 boolean jjtc005 = true;
				 jjtree.openNodeScope(jjtn005);
				 try {
					 jjtree.closeNodeScope(jjtn005, true);
					 jjtc005 = false;
					 jjtn005.processToken(token);
				 }
				 finally {
					 if (jjtc005) {
						 jjtree.closeNodeScope(jjtn005, true);
					 }
				 }
				 ExprSingle();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void WhereClause() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTWHERECLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(Where);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTWHERE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 ExprSingle();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OrderByClause() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTORDERBYCLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case OrderBy: jj_consume_token(OrderBy);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTORDERBY);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case OrderByStable: jj_consume_token(OrderByStable);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTORDERBYSTABLE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[46] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 OrderSpecList();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OrderSpecList() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTORDERSPECLIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 OrderSpec();
			 label_12: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Comma: ;
					 break;
					 default: jj_la1[47] = jj_gen;
					 break label_12;
				 }
				 jj_consume_token(Comma);
				 OrderSpec();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OrderSpec() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTORDERSPEC);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 ExprSingle();
			 OrderModifier();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OrderModifier() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTORDERMODIFIER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Ascending: case Descending: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Ascending: jj_consume_token(Ascending);
					 SimpleNode jjtn001 = new SimpleNode(this, JJTASCENDING);
					 boolean jjtc001 = true;
					 jjtree.openNodeScope(jjtn001);
					 try {
						 jjtree.closeNodeScope(jjtn001, true);
						 jjtc001 = false;
						 jjtn001.processToken(token);
					 }
					 finally {
						 if (jjtc001) {
							 jjtree.closeNodeScope(jjtn001, true);
						 }
					 }
					 break;
					 case Descending: jj_consume_token(Descending);
					 SimpleNode jjtn002 = new SimpleNode(this, JJTDESCENDING);
					 boolean jjtc002 = true;
					 jjtree.openNodeScope(jjtn002);
					 try {
						 jjtree.closeNodeScope(jjtn002, true);
						 jjtc002 = false;
						 jjtn002.processToken(token);
					 }
					 finally {
						 if (jjtc002) {
							 jjtree.closeNodeScope(jjtn002, true);
						 }
					 }
					 break;
					 default: jj_la1[48] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 default: jj_la1[49] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EmptyGreatest: case EmptyLeast: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case EmptyGreatest: jj_consume_token(EmptyGreatest);
					 SimpleNode jjtn003 = new SimpleNode(this, JJTEMPTYGREATEST);
					 boolean jjtc003 = true;
					 jjtree.openNodeScope(jjtn003);
					 try {
						 jjtree.closeNodeScope(jjtn003, true);
						 jjtc003 = false;
						 jjtn003.processToken(token);
					 }
					 finally {
						 if (jjtc003) {
							 jjtree.closeNodeScope(jjtn003, true);
						 }
					 }
					 break;
					 case EmptyLeast: jj_consume_token(EmptyLeast);
					 SimpleNode jjtn004 = new SimpleNode(this, JJTEMPTYLEAST);
					 boolean jjtc004 = true;
					 jjtree.openNodeScope(jjtn004);
					 try {
						 jjtree.closeNodeScope(jjtn004, true);
						 jjtc004 = false;
						 jjtn004.processToken(token);
					 }
					 finally {
						 if (jjtc004) {
							 jjtree.closeNodeScope(jjtn004, true);
						 }
					 }
					 break;
					 default: jj_la1[50] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 default: jj_la1[51] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Collation: jj_consume_token(Collation);
				 SimpleNode jjtn005 = new SimpleNode(this, JJTCOLLATION);
				 boolean jjtc005 = true;
				 jjtree.openNodeScope(jjtn005);
				 try {
					 jjtree.closeNodeScope(jjtn005, true);
					 jjtc005 = false;
					 jjtn005.processToken(token);
				 }
				 finally {
					 if (jjtc005) {
						 jjtree.closeNodeScope(jjtn005, true);
					 }
				 }
				 jj_consume_token(StringLiteral);
				 SimpleNode jjtn006 = new SimpleNode(this, JJTSTRINGLITERAL);
				 boolean jjtc006 = true;
				 jjtree.openNodeScope(jjtn006);
				 try {
					 jjtree.closeNodeScope(jjtn006, true);
					 jjtc006 = false;
					 jjtn006.processToken(token);
				 }
				 finally {
					 if (jjtc006) {
						 jjtree.closeNodeScope(jjtn006, true);
					 }
				 }
				 break;
				 default: jj_la1[52] = jj_gen;
				 ;
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void QuantifiedExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTQUANTIFIEDEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Some: jj_consume_token(Some);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTSOME);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case Every: jj_consume_token(Every);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTEVERY);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[53] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(VarName);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTVARNAME);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case As: TypeDeclaration();
				 break;
				 default: jj_la1[54] = jj_gen;
				 ;
			 }
			 jj_consume_token(In);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTIN);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
			 ExprSingle();
			 label_13: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Comma: ;
					 break;
					 default: jj_la1[55] = jj_gen;
					 break label_13;
				 }
				 jj_consume_token(Comma);
				 jj_consume_token(VariableIndicator);
				 jj_consume_token(VarName);
				 SimpleNode jjtn005 = new SimpleNode(this, JJTVARNAME);
				 boolean jjtc005 = true;
				 jjtree.openNodeScope(jjtn005);
				 try {
					 jjtree.closeNodeScope(jjtn005, true);
					 jjtc005 = false;
					 jjtn005.processToken(token);
				 }
				 finally {
					 if (jjtc005) {
						 jjtree.closeNodeScope(jjtn005, true);
					 }
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case As: TypeDeclaration();
					 break;
					 default: jj_la1[56] = jj_gen;
					 ;
				 }
				 jj_consume_token(In);
				 SimpleNode jjtn006 = new SimpleNode(this, JJTIN);
				 boolean jjtc006 = true;
				 jjtree.openNodeScope(jjtn006);
				 try {
					 jjtree.closeNodeScope(jjtn006, true);
					 jjtc006 = false;
					 jjtn006.processToken(token);
				 }
				 finally {
					 if (jjtc006) {
						 jjtree.closeNodeScope(jjtn006, true);
					 }
				 }
				 ExprSingle();
			 }
			 jj_consume_token(Satisfies);
			 SimpleNode jjtn007 = new SimpleNode(this, JJTSATISFIES);
			 boolean jjtc007 = true;
			 jjtree.openNodeScope(jjtn007);
			 try {
				 jjtree.closeNodeScope(jjtn007, true);
				 jjtc007 = false;
				 jjtn007.processToken(token);
			 }
			 finally {
				 if (jjtc007) {
					 jjtree.closeNodeScope(jjtn007, true);
				 }
			 }
			 ExprSingle();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void TypeswitchExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTTYPESWITCHEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(TypeswitchLpar);
			 Expr();
			 jj_consume_token(Rpar);
			 label_14: while (true) {
				 CaseClause();
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Case: ;
					 break;
					 default: jj_la1[57] = jj_gen;
					 break label_14;
				 }
			 }
			 jj_consume_token(Default);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDEFAULT);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case VariableIndicator: jj_consume_token(VariableIndicator);
				 jj_consume_token(VarName);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[58] = jj_gen;
				 ;
			 }
			 jj_consume_token(Return);
			 ExprSingle();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CaseClause() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCASECLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(Case);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTCASE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case VariableIndicator: jj_consume_token(VariableIndicator);
				 jj_consume_token(VarName);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 jj_consume_token(As);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTAS);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[59] = jj_gen;
				 ;
			 }
			 SequenceType();
			 jj_consume_token(Return);
			 ExprSingle();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void IfExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTIFEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(IfLpar);
			 Expr();
			 jj_consume_token(Rpar);
			 jj_consume_token(Then);
			 ExprSingle();
			 jj_consume_token(Else);
			 ExprSingle();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OperatorExpr() throws ParseException {
		 OrExpr();
	 }
	 final public void OrExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTOREXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 AndExpr();
			 label_15: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Or: ;
					 break;
					 default: jj_la1[60] = jj_gen;
					 break label_15;
				 }
				 jj_consume_token(Or);
				 binaryTokenStack.push(token);
				 AndExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTOREXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void AndExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTANDEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 ComparisonExpr();
			 label_16: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case And: ;
					 break;
					 default: jj_la1[61] = jj_gen;
					 break label_16;
				 }
				 jj_consume_token(And);
				 binaryTokenStack.push(token);
				 ComparisonExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTANDEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void ComparisonExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPARISONEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 RangeExpr();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Equals: case Is: case NotEquals: case LtEquals: case LtLt: case GtEquals: case GtGt: case FortranEq: case FortranNe: case FortranGt: case FortranGe: case FortranLt: case FortranLe: case Lt: case Gt: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case FortranEq: case FortranNe: case FortranGt: case FortranGe: case FortranLt: case FortranLe: ValueComp();
					 break;
					 case Equals: case NotEquals: case LtEquals: case GtEquals: case Lt: case Gt: GeneralComp();
					 break;
					 case Is: case LtLt: case GtGt: NodeComp();
					 break;
					 default: jj_la1[62] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 RangeExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTCOMPARISONEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
				 break;
				 default: jj_la1[63] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void RangeExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTRANGEEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 AdditiveExpr();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case To: jj_consume_token(To);
				 binaryTokenStack.push(token);
				 AdditiveExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTRANGEEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
				 break;
				 default: jj_la1[64] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void AdditiveExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTADDITIVEEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 MultiplicativeExpr();
			 label_17: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Minus: case Plus: ;
					 break;
					 default: jj_la1[65] = jj_gen;
					 break label_17;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Plus: jj_consume_token(Plus);
					 binaryTokenStack.push(token);
					 break;
					 case Minus: jj_consume_token(Minus);
					 binaryTokenStack.push(token);
					 break;
					 default: jj_la1[66] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 MultiplicativeExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTADDITIVEEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void MultiplicativeExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTMULTIPLICATIVEEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 UnionExpr();
			 label_18: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Div: case Idiv: case Mod: case Multiply: ;
					 break;
					 default: jj_la1[67] = jj_gen;
					 break label_18;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Multiply: jj_consume_token(Multiply);
					 binaryTokenStack.push(token);
					 break;
					 case Div: jj_consume_token(Div);
					 binaryTokenStack.push(token);
					 break;
					 case Idiv: jj_consume_token(Idiv);
					 binaryTokenStack.push(token);
					 break;
					 case Mod: jj_consume_token(Mod);
					 binaryTokenStack.push(token);
					 break;
					 default: jj_la1[68] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 UnionExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTMULTIPLICATIVEEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void UnionExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTUNIONEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 IntersectExceptExpr();
			 label_19: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Union: case Vbar: ;
					 break;
					 default: jj_la1[69] = jj_gen;
					 break label_19;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Union: jj_consume_token(Union);
					 binaryTokenStack.push(token);
					 break;
					 case Vbar: jj_consume_token(Vbar);
					 binaryTokenStack.push(token);
					 break;
					 default: jj_la1[70] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 IntersectExceptExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTUNIONEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void IntersectExceptExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTINTERSECTEXCEPTEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 InstanceofExpr();
			 label_20: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Intersect: case Except: ;
					 break;
					 default: jj_la1[71] = jj_gen;
					 break label_20;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Intersect: jj_consume_token(Intersect);
					 binaryTokenStack.push(token);
					 break;
					 case Except: jj_consume_token(Except);
					 binaryTokenStack.push(token);
					 break;
					 default: jj_la1[72] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 InstanceofExpr();
				 SimpleNode jjtn001 = new SimpleNode(this, JJTINTERSECTEXCEPTEXPR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtc001 = false;
					 try {
						 jjtn001.processToken((Token)binaryTokenStack.pop());
					 }
					 catch(java.util.EmptyStackException e) {
						 token_source.printLinePos();
						 e.printStackTrace();
						 {
							if (true) throw e;
						}
					 }
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void InstanceofExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTINSTANCEOFEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 TreatExpr();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Instanceof: jj_consume_token(Instanceof);
				 SequenceType();
				 break;
				 default: jj_la1[73] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void TreatExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTTREATEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 CastableExpr();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case TreatAs: jj_consume_token(TreatAs);
				 SequenceType();
				 break;
				 default: jj_la1[74] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void CastableExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCASTABLEEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 CastExpr();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Castable: jj_consume_token(Castable);
				 SingleType();
				 break;
				 default: jj_la1[75] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void CastExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCASTEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 UnaryExpr();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CastAs: jj_consume_token(CastAs);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTCASTAS);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 SingleType();
				 break;
				 default: jj_la1[76] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void UnaryExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		boolean keepUnary=false;
		 try {
			 label_21: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case UnaryMinus: case UnaryPlus: ;
					 break;
					 default: jj_la1[77] = jj_gen;
					 break label_21;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case UnaryMinus: jj_consume_token(UnaryMinus);
					 SimpleNode jjtn001 = new SimpleNode(this, JJTUNARYMINUS);
					 boolean jjtc001 = true;
					 jjtree.openNodeScope(jjtn001);
					 try {
						 jjtree.closeNodeScope(jjtn001, true);
						 jjtc001 = false;
						 keepUnary=true;
						jjtn001.processToken(token);
					 }
					 finally {
						 if (jjtc001) {
							 jjtree.closeNodeScope(jjtn001, true);
						 }
					 }
					 break;
					 case UnaryPlus: jj_consume_token(UnaryPlus);
					 SimpleNode jjtn002 = new SimpleNode(this, JJTUNARYPLUS);
					 boolean jjtc002 = true;
					 jjtree.openNodeScope(jjtn002);
					 try {
						 jjtree.closeNodeScope(jjtn002, true);
						 jjtc002 = false;
						 keepUnary=true;
						jjtn002.processToken(token);
					 }
					 finally {
						 if (jjtc002) {
							 jjtree.closeNodeScope(jjtn002, true);
						 }
					 }
					 break;
					 default: jj_la1[78] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
			 ValueExpr();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, keepUnary);
			 }
		 }
	 }
	 final public void ValueExpr() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case ValidateLbrace: case ValidateSchemaMode: ValidateExpr();
			 break;
			 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case Lpar: case At: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: PathExpr();
			 break;
			 default: jj_la1[79] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void GeneralComp() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case Equals: jj_consume_token(Equals);
			 binaryTokenStack.push(token);
			 break;
			 case NotEquals: jj_consume_token(NotEquals);
			 binaryTokenStack.push(token);
			 break;
			 case Lt: jj_consume_token(Lt);
			 binaryTokenStack.push(token);
			 break;
			 case LtEquals: jj_consume_token(LtEquals);
			 binaryTokenStack.push(token);
			 break;
			 case Gt: jj_consume_token(Gt);
			 binaryTokenStack.push(token);
			 break;
			 case GtEquals: jj_consume_token(GtEquals);
			 binaryTokenStack.push(token);
			 break;
			 default: jj_la1[80] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ValueComp() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case FortranEq: jj_consume_token(FortranEq);
			 binaryTokenStack.push(token);
			 break;
			 case FortranNe: jj_consume_token(FortranNe);
			 binaryTokenStack.push(token);
			 break;
			 case FortranLt: jj_consume_token(FortranLt);
			 binaryTokenStack.push(token);
			 break;
			 case FortranLe: jj_consume_token(FortranLe);
			 binaryTokenStack.push(token);
			 break;
			 case FortranGt: jj_consume_token(FortranGt);
			 binaryTokenStack.push(token);
			 break;
			 case FortranGe: jj_consume_token(FortranGe);
			 binaryTokenStack.push(token);
			 break;
			 default: jj_la1[81] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void NodeComp() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case Is: jj_consume_token(Is);
			 binaryTokenStack.push(token);
			 break;
			 case LtLt: jj_consume_token(LtLt);
			 binaryTokenStack.push(token);
			 break;
			 case GtGt: jj_consume_token(GtGt);
			 binaryTokenStack.push(token);
			 break;
			 default: jj_la1[82] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ValidateExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTVALIDATEEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ValidateLbrace: jj_consume_token(ValidateLbrace);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTVALIDATELBRACE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case ValidateSchemaMode: jj_consume_token(ValidateSchemaMode);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTVALIDATESCHEMAMODE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 jj_consume_token(LbraceExprEnclosure);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[83] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 Expr();
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void PathExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPATHEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Root: jj_consume_token(Root);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTROOT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Lpar: case At: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: RelativePathExpr();
					 break;
					 default: jj_la1[84] = jj_gen;
					 ;
				 }
				 break;
				 case RootDescendants: jj_consume_token(RootDescendants);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTROOTDESCENDANTS);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 RelativePathExpr();
				 break;
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Lpar: case At: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: RelativePathExpr();
				 break;
				 default: jj_la1[85] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
			 }
		 }
	 }
	 final public void RelativePathExpr() throws ParseException {
		 StepExpr();
		 label_22: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Slash: case SlashSlash: ;
				 break;
				 default: jj_la1[86] = jj_gen;
				 break label_22;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Slash: jj_consume_token(Slash);
				 break;
				 case SlashSlash: jj_consume_token(SlashSlash);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTSLASHSLASH);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[87] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 StepExpr();
		 }
	 }
	 final public void StepExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSTEPEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		boolean savedIsStep = isStep;
		 isStep=false;
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case Star: case NCNameColonStar: case StarColonNCName: case At: case DocumentLpar: case DocumentLparForKindTest: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case DotDot: case QName: isStep=true;
				 AxisStep();
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
				 jjtc000 = false;
				 isStep = savedIsStep;
				 break;
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case VariableIndicator: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Lpar: case DocumentLbrace: case Dot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: FilterExpr();
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
				 jjtc000 = false;
				 isStep = savedIsStep;
				 break;
				 default: jj_la1[88] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
			 }
		 }
	 }
	 final public void AxisStep() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AxisChild: case AxisDescendant: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisFollowingSibling: case AxisFollowing: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case Star: case NCNameColonStar: case StarColonNCName: case At: case DocumentLpar: case DocumentLparForKindTest: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case QName: ForwardStep();
			 break;
			 case AxisParent: case AxisAncestor: case AxisPrecedingSibling: case AxisPreceding: case AxisAncestorOrSelf: case DotDot: ReverseStep();
			 break;
			 default: jj_la1[89] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
		 PredicateList();
	 }
	 final public void ForwardStep() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AxisChild: case AxisDescendant: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisFollowingSibling: case AxisFollowing: ForwardAxis();
			 NodeTest();
			 break;
			 case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case Star: case NCNameColonStar: case StarColonNCName: case At: case DocumentLpar: case DocumentLparForKindTest: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case QName: AbbrevForwardStep();
			 break;
			 default: jj_la1[90] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ForwardAxis() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AxisChild: jj_consume_token(AxisChild);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTAXISCHILD);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case AxisDescendant: jj_consume_token(AxisDescendant);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTAXISDESCENDANT);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 case AxisAttribute: jj_consume_token(AxisAttribute);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTAXISATTRIBUTE);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 break;
			 case AxisSelf: jj_consume_token(AxisSelf);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTAXISSELF);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
			 break;
			 case AxisDescendantOrSelf: jj_consume_token(AxisDescendantOrSelf);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTAXISDESCENDANTORSELF);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
			 break;
			 case AxisFollowingSibling: jj_consume_token(AxisFollowingSibling);
			 SimpleNode jjtn006 = new SimpleNode(this, JJTAXISFOLLOWINGSIBLING);
			 boolean jjtc006 = true;
			 jjtree.openNodeScope(jjtn006);
			 try {
				 jjtree.closeNodeScope(jjtn006, true);
				 jjtc006 = false;
				 jjtn006.processToken(token);
			 }
			 finally {
				 if (jjtc006) {
					 jjtree.closeNodeScope(jjtn006, true);
				 }
			 }
			 break;
			 case AxisFollowing: jj_consume_token(AxisFollowing);
			 SimpleNode jjtn007 = new SimpleNode(this, JJTAXISFOLLOWING);
			 boolean jjtc007 = true;
			 jjtree.openNodeScope(jjtn007);
			 try {
				 jjtree.closeNodeScope(jjtn007, true);
				 jjtc007 = false;
				 jjtn007.processToken(token);
			 }
			 finally {
				 if (jjtc007) {
					 jjtree.closeNodeScope(jjtn007, true);
				 }
			 }
			 break;
			 default: jj_la1[91] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void AbbrevForwardStep() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case At: jj_consume_token(At);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTAT);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 default: jj_la1[92] = jj_gen;
			 ;
		 }
		 NodeTest();
	 }
	 final public void ReverseStep() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AxisParent: case AxisAncestor: case AxisPrecedingSibling: case AxisPreceding: case AxisAncestorOrSelf: ReverseAxis();
			 NodeTest();
			 break;
			 case DotDot: AbbrevReverseStep();
			 break;
			 default: jj_la1[93] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ReverseAxis() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AxisParent: jj_consume_token(AxisParent);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTAXISPARENT);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case AxisAncestor: jj_consume_token(AxisAncestor);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTAXISANCESTOR);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 case AxisPrecedingSibling: jj_consume_token(AxisPrecedingSibling);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTAXISPRECEDINGSIBLING);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 break;
			 case AxisPreceding: jj_consume_token(AxisPreceding);
			 SimpleNode jjtn004 = new SimpleNode(this, JJTAXISPRECEDING);
			 boolean jjtc004 = true;
			 jjtree.openNodeScope(jjtn004);
			 try {
				 jjtree.closeNodeScope(jjtn004, true);
				 jjtc004 = false;
				 jjtn004.processToken(token);
			 }
			 finally {
				 if (jjtc004) {
					 jjtree.closeNodeScope(jjtn004, true);
				 }
			 }
			 break;
			 case AxisAncestorOrSelf: jj_consume_token(AxisAncestorOrSelf);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTAXISANCESTORORSELF);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
			 break;
			 default: jj_la1[94] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void AbbrevReverseStep() throws ParseException {
		 jj_consume_token(DotDot);
		 SimpleNode jjtn001 = new SimpleNode(this, JJTDOTDOT);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, true);
			 jjtc001 = false;
			 jjtn001.processToken(token);
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, true);
			 }
		 }
	 }
	 final public void NodeTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTNODETEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case DocumentLpar: case DocumentLparForKindTest: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: KindTest();
				 break;
				 case Star: case NCNameColonStar: case StarColonNCName: case QName: NameTest();
				 break;
				 default: jj_la1[95] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void NameTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTNAMETEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case QName: jj_consume_token(QName);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTQNAME);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case Star: case NCNameColonStar: case StarColonNCName: Wildcard();
				 break;
				 default: jj_la1[96] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Wildcard() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case Star: jj_consume_token(Star);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTSTAR);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case NCNameColonStar: jj_consume_token(NCNameColonStar);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMECOLONSTAR);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 case StarColonNCName: jj_consume_token(StarColonNCName);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTSTARCOLONNCNAME);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 break;
			 default: jj_la1[97] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void FilterExpr() throws ParseException {
		 PrimaryExpr();
		 PredicateList();
	 }
	 final public void PredicateList() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPREDICATELIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_23: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case Lbrack: ;
					 break;
					 default: jj_la1[98] = jj_gen;
					 break label_23;
				 }
				 Predicate();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
			 }
		 }
	 }
	 final public void Predicate() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPREDICATE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(Lbrack);
			 Expr();
			 jj_consume_token(Rbrack);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
			 }
		 }
	 }
	 final public void PrimaryExpr() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: Literal();
			 break;
			 case VariableIndicator: VarRef();
			 break;
			 case Lpar: ParenthesizedExpr();
			 break;
			 case Dot: isStep=true;
			 ContextItemExpr();
			 break;
			 case QNameLpar: FunctionCall();
			 break;
			 case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case DocumentLbrace: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: Constructor();
			 break;
			 case OrderedOpen: OrderedExpr();
			 break;
			 case UnorderedOpen: UnorderedExpr();
			 break;
			 default: jj_la1[99] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void Literal() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: NumericLiteral();
			 break;
			 case StringLiteral: jj_consume_token(StringLiteral);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTSTRINGLITERAL);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 default: jj_la1[100] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void NumericLiteral() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case IntegerLiteral: jj_consume_token(IntegerLiteral);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTINTEGERLITERAL);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case DecimalLiteral: jj_consume_token(DecimalLiteral);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTDECIMALLITERAL);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 case DoubleLiteral: jj_consume_token(DoubleLiteral);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTDOUBLELITERAL);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 break;
			 default: jj_la1[101] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void VarRef() throws ParseException {
		 jj_consume_token(VariableIndicator);
		 jj_consume_token(VarName);
		 SimpleNode jjtn001 = new SimpleNode(this, JJTVARNAME);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, true);
			 jjtc001 = false;
			 jjtn001.processToken(token);
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, true);
			 }
		 }
	 }
	 final public void ParenthesizedExpr() throws ParseException {
		 jj_consume_token(Lpar);
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: Expr();
			 break;
			 default: jj_la1[102] = jj_gen;
			 ;
		 }
		 jj_consume_token(Rpar);
	 }
	 final public void ContextItemExpr() throws ParseException {
		 jj_consume_token(Dot);
		 SimpleNode jjtn001 = new SimpleNode(this, JJTDOT);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, true);
			 jjtc001 = false;
			 jjtn001.processToken(token);
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, true);
			 }
		 }
	 }
	 final public void OrderedExpr() throws ParseException {
		 jj_consume_token(OrderedOpen);
		 SimpleNode jjtn001 = new SimpleNode(this, JJTORDEREDOPEN);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, true);
			 jjtc001 = false;
			 jjtn001.processToken(token);
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, true);
			 }
		 }
		 Expr();
		 jj_consume_token(Rbrace);
		 SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
		 boolean jjtc002 = true;
		 jjtree.openNodeScope(jjtn002);
		 try {
			 jjtree.closeNodeScope(jjtn002, true);
			 jjtc002 = false;
			 jjtn002.processToken(token);
		 }
		 finally {
			 if (jjtc002) {
				 jjtree.closeNodeScope(jjtn002, true);
			 }
		 }
	 }
	 final public void UnorderedExpr() throws ParseException {
		 jj_consume_token(UnorderedOpen);
		 SimpleNode jjtn001 = new SimpleNode(this, JJTUNORDEREDOPEN);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, true);
			 jjtc001 = false;
			 jjtn001.processToken(token);
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, true);
			 }
		 }
		 Expr();
		 jj_consume_token(Rbrace);
		 SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
		 boolean jjtc002 = true;
		 jjtree.openNodeScope(jjtn002);
		 try {
			 jjtree.closeNodeScope(jjtn002, true);
			 jjtc002 = false;
			 jjtn002.processToken(token);
		 }
		 finally {
			 if (jjtc002) {
				 jjtree.closeNodeScope(jjtn002, true);
			 }
		 }
	 }
	 final public void FunctionCall() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTIONCALL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(QNameLpar);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMELPAR);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: ExprSingle();
				 label_24: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case Comma: ;
						 break;
						 default: jj_la1[103] = jj_gen;
						 break label_24;
					 }
					 jj_consume_token(Comma);
					 ExprSingle();
				 }
				 break;
				 default: jj_la1[104] = jj_gen;
				 ;
			 }
			 jj_consume_token(Rpar);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Constructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: DirectConstructor();
				 break;
				 case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case DocumentLbrace: ComputedConstructor();
				 break;
				 default: jj_la1[105] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirectConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRECTCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case StartTagOpen: case StartTagOpenRoot: DirElemConstructor();
				 break;
				 case XmlCommentStart: case XmlCommentStartForElementContent: DirCommentConstructor();
				 break;
				 case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: DirPIConstructor();
				 break;
				 default: jj_la1[106] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirElemConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRELEMCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case StartTagOpenRoot: jj_consume_token(StartTagOpenRoot);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTSTARTTAGOPENROOT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case StartTagOpen: jj_consume_token(StartTagOpen);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTSTARTTAGOPEN);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[107] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(TagQName);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTTAGQNAME);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 DirAttributeList();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EmptyTagClose: jj_consume_token(EmptyTagClose);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTEMPTYTAGCLOSE);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 case StartTagClose: jj_consume_token(StartTagClose);
				 SimpleNode jjtn005 = new SimpleNode(this, JJTSTARTTAGCLOSE);
				 boolean jjtc005 = true;
				 jjtree.openNodeScope(jjtn005);
				 try {
					 jjtree.closeNodeScope(jjtn005, true);
					 jjtc005 = false;
					 jjtn005.processToken(token);
				 }
				 finally {
					 if (jjtc005) {
						 jjtree.closeNodeScope(jjtn005, true);
					 }
				 }
				 label_25: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case CdataSectionStart: case CdataSectionStartForElementContent: case PredefinedEntityRef: case CharRef: case StartTagOpen: case StartTagOpenRoot: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: case ElementContentChar: case XmlCommentStart: case XmlCommentStartForElementContent: ;
						 break;
						 default: jj_la1[108] = jj_gen;
						 break label_25;
					 }
					 DirElemContent();
				 }
				 jj_consume_token(EndTagOpen);
				 SimpleNode jjtn006 = new SimpleNode(this, JJTENDTAGOPEN);
				 boolean jjtc006 = true;
				 jjtree.openNodeScope(jjtn006);
				 try {
					 jjtree.closeNodeScope(jjtn006, true);
					 jjtc006 = false;
					 jjtn006.processToken(token);
				 }
				 finally {
					 if (jjtc006) {
						 jjtree.closeNodeScope(jjtn006, true);
					 }
				 }
				 jj_consume_token(TagQName);
				 SimpleNode jjtn007 = new SimpleNode(this, JJTTAGQNAME);
				 boolean jjtc007 = true;
				 jjtree.openNodeScope(jjtn007);
				 try {
					 jjtree.closeNodeScope(jjtn007, true);
					 jjtc007 = false;
					 jjtn007.processToken(token);
				 }
				 finally {
					 if (jjtc007) {
						 jjtree.closeNodeScope(jjtn007, true);
					 }
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case S: jj_consume_token(S);
					 SimpleNode jjtn008 = new SimpleNode(this, JJTS);
					 boolean jjtc008 = true;
					 jjtree.openNodeScope(jjtn008);
					 try {
						 jjtree.closeNodeScope(jjtn008, true);
						 jjtc008 = false;
						 jjtn008.processToken(token);
					 }
					 finally {
						 if (jjtc008) {
							 jjtree.closeNodeScope(jjtn008, true);
						 }
					 }
					 break;
					 default: jj_la1[109] = jj_gen;
					 ;
				 }
				 jj_consume_token(EndTagClose);
				 SimpleNode jjtn009 = new SimpleNode(this, JJTENDTAGCLOSE);
				 boolean jjtc009 = true;
				 jjtree.openNodeScope(jjtn009);
				 try {
					 jjtree.closeNodeScope(jjtn009, true);
					 jjtc009 = false;
					 jjtn009.processToken(token);
				 }
				 finally {
					 if (jjtc009) {
						 jjtree.closeNodeScope(jjtn009, true);
					 }
				 }
				 break;
				 default: jj_la1[110] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirAttributeList() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRATTRIBUTELIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_26: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case S: ;
					 break;
					 default: jj_la1[111] = jj_gen;
					 break label_26;
				 }
				 jj_consume_token(S);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTS);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case TagQName: jj_consume_token(TagQName);
					 SimpleNode jjtn002 = new SimpleNode(this, JJTTAGQNAME);
					 boolean jjtc002 = true;
					 jjtree.openNodeScope(jjtn002);
					 try {
						 jjtree.closeNodeScope(jjtn002, true);
						 jjtc002 = false;
						 jjtn002.processToken(token);
					 }
					 finally {
						 if (jjtc002) {
							 jjtree.closeNodeScope(jjtn002, true);
						 }
					 }
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case S: jj_consume_token(S);
						 SimpleNode jjtn003 = new SimpleNode(this, JJTS);
						 boolean jjtc003 = true;
						 jjtree.openNodeScope(jjtn003);
						 try {
							 jjtree.closeNodeScope(jjtn003, true);
							 jjtc003 = false;
							 jjtn003.processToken(token);
						 }
						 finally {
							 if (jjtc003) {
								 jjtree.closeNodeScope(jjtn003, true);
							 }
						 }
						 break;
						 default: jj_la1[112] = jj_gen;
						 ;
					 }
					 jj_consume_token(ValueIndicator);
					 SimpleNode jjtn004 = new SimpleNode(this, JJTVALUEINDICATOR);
					 boolean jjtc004 = true;
					 jjtree.openNodeScope(jjtn004);
					 try {
						 jjtree.closeNodeScope(jjtn004, true);
						 jjtc004 = false;
						 jjtn004.processToken(token);
					 }
					 finally {
						 if (jjtc004) {
							 jjtree.closeNodeScope(jjtn004, true);
						 }
					 }
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case S: jj_consume_token(S);
						 SimpleNode jjtn005 = new SimpleNode(this, JJTS);
						 boolean jjtc005 = true;
						 jjtree.openNodeScope(jjtn005);
						 try {
							 jjtree.closeNodeScope(jjtn005, true);
							 jjtc005 = false;
							 jjtn005.processToken(token);
						 }
						 finally {
							 if (jjtc005) {
								 jjtree.closeNodeScope(jjtn005, true);
							 }
						 }
						 break;
						 default: jj_la1[113] = jj_gen;
						 ;
					 }
					 DirAttributeValue();
					 break;
					 default: jj_la1[114] = jj_gen;
					 ;
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirAttributeValue() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRATTRIBUTEVALUE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case OpenQuot: jj_consume_token(OpenQuot);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTOPENQUOT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 label_27: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: case EscapeQuot: case QuotAttrContentChar: ;
						 break;
						 default: jj_la1[115] = jj_gen;
						 break label_27;
					 }
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case EscapeQuot: jj_consume_token(EscapeQuot);
						 SimpleNode jjtn002 = new SimpleNode(this, JJTESCAPEQUOT);
						 boolean jjtc002 = true;
						 jjtree.openNodeScope(jjtn002);
						 try {
							 jjtree.closeNodeScope(jjtn002, true);
							 jjtc002 = false;
							 jjtn002.processToken(token);
						 }
						 finally {
							 if (jjtc002) {
								 jjtree.closeNodeScope(jjtn002, true);
							 }
						 }
						 break;
						 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: case QuotAttrContentChar: QuotAttrValueContent();
						 break;
						 default: jj_la1[116] = jj_gen;
						 jj_consume_token(-1);
						 throw new ParseException();
					 }
				 }
				 jj_consume_token(CloseQuot);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTCLOSEQUOT);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 case OpenApos: jj_consume_token(OpenApos);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTOPENAPOS);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 label_28: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: case EscapeApos: case AposAttrContentChar: ;
						 break;
						 default: jj_la1[117] = jj_gen;
						 break label_28;
					 }
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case EscapeApos: jj_consume_token(EscapeApos);
						 SimpleNode jjtn005 = new SimpleNode(this, JJTESCAPEAPOS);
						 boolean jjtc005 = true;
						 jjtree.openNodeScope(jjtn005);
						 try {
							 jjtree.closeNodeScope(jjtn005, true);
							 jjtc005 = false;
							 jjtn005.processToken(token);
						 }
						 finally {
							 if (jjtc005) {
								 jjtree.closeNodeScope(jjtn005, true);
							 }
						 }
						 break;
						 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: case AposAttrContentChar: AposAttrValueContent();
						 break;
						 default: jj_la1[118] = jj_gen;
						 jj_consume_token(-1);
						 throw new ParseException();
					 }
				 }
				 jj_consume_token(CloseApos);
				 SimpleNode jjtn006 = new SimpleNode(this, JJTCLOSEAPOS);
				 boolean jjtc006 = true;
				 jjtree.openNodeScope(jjtn006);
				 try {
					 jjtree.closeNodeScope(jjtn006, true);
					 jjtc006 = false;
					 jjtn006.processToken(token);
				 }
				 finally {
					 if (jjtc006) {
						 jjtree.closeNodeScope(jjtn006, true);
					 }
				 }
				 break;
				 default: jj_la1[119] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void QuotAttrValueContent() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTQUOTATTRVALUECONTENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case QuotAttrContentChar: jj_consume_token(QuotAttrContentChar);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTQUOTATTRCONTENTCHAR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: CommonContent();
				 break;
				 default: jj_la1[120] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void AposAttrValueContent() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTAPOSATTRVALUECONTENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AposAttrContentChar: jj_consume_token(AposAttrContentChar);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTAPOSATTRCONTENTCHAR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: CommonContent();
				 break;
				 default: jj_la1[121] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirElemContent() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRELEMCONTENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: DirectConstructor();
				 break;
				 case ElementContentChar: jj_consume_token(ElementContentChar);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTELEMENTCONTENTCHAR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case CdataSectionStart: case CdataSectionStartForElementContent: CDataSection();
				 break;
				 case PredefinedEntityRef: case CharRef: case Lbrace: case LbraceExprEnclosure: case LCurlyBraceEscape: case RCurlyBraceEscape: CommonContent();
				 break;
				 default: jj_la1[122] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CommonContent() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMMONCONTENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PredefinedEntityRef: jj_consume_token(PredefinedEntityRef);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTPREDEFINEDENTITYREF);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case CharRef: jj_consume_token(CharRef);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTCHARREF);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case LCurlyBraceEscape: jj_consume_token(LCurlyBraceEscape);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTLCURLYBRACEESCAPE);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 case RCurlyBraceEscape: jj_consume_token(RCurlyBraceEscape);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTRCURLYBRACEESCAPE);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 case Lbrace: case LbraceExprEnclosure: EnclosedExpr();
				 break;
				 default: jj_la1[123] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirCommentConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRCOMMENTCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case XmlCommentStartForElementContent: jj_consume_token(XmlCommentStartForElementContent);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTXMLCOMMENTSTARTFORELEMENTCONTENT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case XmlCommentStart: jj_consume_token(XmlCommentStart);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTXMLCOMMENTSTART);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[124] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 DirCommentContents();
			 jj_consume_token(XmlCommentEnd);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTXMLCOMMENTEND);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirCommentContents() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRCOMMENTCONTENTS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_29: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CommentContentChar: case CommentContentCharDash: ;
					 break;
					 default: jj_la1[125] = jj_gen;
					 break label_29;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CommentContentChar: jj_consume_token(CommentContentChar);
					 SimpleNode jjtn001 = new SimpleNode(this, JJTCOMMENTCONTENTCHAR);
					 boolean jjtc001 = true;
					 jjtree.openNodeScope(jjtn001);
					 try {
						 jjtree.closeNodeScope(jjtn001, true);
						 jjtc001 = false;
						 jjtn001.processToken(token);
					 }
					 finally {
						 if (jjtc001) {
							 jjtree.closeNodeScope(jjtn001, true);
						 }
					 }
					 break;
					 case CommentContentCharDash: jj_consume_token(CommentContentCharDash);
					 SimpleNode jjtn002 = new SimpleNode(this, JJTCOMMENTCONTENTCHARDASH);
					 boolean jjtc002 = true;
					 jjtree.openNodeScope(jjtn002);
					 try {
						 jjtree.closeNodeScope(jjtn002, true);
						 jjtc002 = false;
						 jjtn002.processToken(token);
					 }
					 finally {
						 if (jjtc002) {
							 jjtree.closeNodeScope(jjtn002, true);
						 }
					 }
					 break;
					 default: jj_la1[126] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirPIConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRPICONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ProcessingInstructionStartForElementContent: jj_consume_token(ProcessingInstructionStartForElementContent);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONSTARTFORELEMENTCONTENT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case ProcessingInstructionStart: jj_consume_token(ProcessingInstructionStart);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONSTART);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[127] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(PITarget);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTPITARGET);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case SForPI: jj_consume_token(SForPI);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTSFORPI);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 DirPIContents();
				 break;
				 default: jj_la1[128] = jj_gen;
				 ;
			 }
			 jj_consume_token(ProcessingInstructionEnd);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONEND);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DirPIContents() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDIRPICONTENTS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_30: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case PIContentChar: ;
					 break;
					 default: jj_la1[129] = jj_gen;
					 break label_30;
				 }
				 jj_consume_token(PIContentChar);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTPICONTENTCHAR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CDataSection() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCDATASECTION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CdataSectionStartForElementContent: jj_consume_token(CdataSectionStartForElementContent);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTCDATASECTIONSTARTFORELEMENTCONTENT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case CdataSectionStart: jj_consume_token(CdataSectionStart);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTCDATASECTIONSTART);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[130] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 CDataSectionContents();
			 jj_consume_token(CdataSectionEnd);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTCDATASECTIONEND);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CDataSectionContents() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCDATASECTIONCONTENTS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_31: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CDataSectionChar: ;
					 break;
					 default: jj_la1[131] = jj_gen;
					 break label_31;
				 }
				 jj_consume_token(CDataSectionChar);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTCDATASECTIONCHAR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ComputedConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPUTEDCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case DocumentLbrace: CompDocConstructor();
				 break;
				 case ElementQNameLbrace: case ElementLbrace: CompElemConstructor();
				 break;
				 case AttributeQNameLbrace: case AttributeLbrace: CompAttrConstructor();
				 break;
				 case TextLbrace: CompTextConstructor();
				 break;
				 case CommentLbrace: CompCommentConstructor();
				 break;
				 case PINCNameLbrace: case PILbrace: CompPIConstructor();
				 break;
				 default: jj_la1[132] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CompDocConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPDOCCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DocumentLbrace);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTDOCUMENTLBRACE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 Expr();
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CompElemConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPELEMCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ElementQNameLbrace: jj_consume_token(ElementQNameLbrace);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTELEMENTQNAMELBRACE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case ElementLbrace: jj_consume_token(ElementLbrace);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTELEMENTLBRACE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 Expr();
				 jj_consume_token(Rbrace);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 jj_consume_token(LbraceExprEnclosure);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[133] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: ContentExpr();
				 break;
				 default: jj_la1[134] = jj_gen;
				 ;
			 }
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ContentExpr() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCONTENTEXPR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 Expr();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CompAttrConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPATTRCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AttributeQNameLbrace: jj_consume_token(AttributeQNameLbrace);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTATTRIBUTEQNAMELBRACE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case AttributeLbrace: jj_consume_token(AttributeLbrace);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTATTRIBUTELBRACE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 Expr();
				 jj_consume_token(Rbrace);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 jj_consume_token(LbraceExprEnclosure);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[135] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: Expr();
				 break;
				 default: jj_la1[136] = jj_gen;
				 ;
			 }
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CompTextConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPTEXTCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(TextLbrace);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTTEXTLBRACE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 Expr();
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CompCommentConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPCOMMENTCONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(CommentLbrace);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTCOMMENTLBRACE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 Expr();
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CompPIConstructor() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPPICONSTRUCTOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PINCNameLbrace: jj_consume_token(PINCNameLbrace);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTPINCNAMELBRACE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case PILbrace: jj_consume_token(PILbrace);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTPILBRACE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 Expr();
				 jj_consume_token(Rbrace);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 jj_consume_token(LbraceExprEnclosure);
				 SimpleNode jjtn004 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 jjtree.closeNodeScope(jjtn004, true);
					 jjtc004 = false;
					 jjtn004.processToken(token);
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, true);
					 }
				 }
				 break;
				 default: jj_la1[137] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IntegerLiteral: case DecimalLiteral: case DoubleLiteral: case StringLiteral: case ProcessingInstructionStart: case ProcessingInstructionStartForElementContent: case AxisChild: case AxisDescendant: case AxisParent: case AxisAttribute: case AxisSelf: case AxisDescendantOrSelf: case AxisAncestor: case AxisFollowingSibling: case AxisPrecedingSibling: case AxisFollowing: case AxisPreceding: case AxisAncestorOrSelf: case VariableIndicator: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case OrderedOpen: case UnorderedOpen: case ElementQNameLbrace: case AttributeQNameLbrace: case PINCNameLbrace: case PILbrace: case CommentLbrace: case ElementLbrace: case AttributeLbrace: case TextLbrace: case Star: case NCNameColonStar: case StarColonNCName: case Root: case RootDescendants: case UnaryMinus: case UnaryPlus: case Lpar: case At: case Some: case Every: case ForVariable: case LetVariable: case ValidateLbrace: case ValidateSchemaMode: case DocumentLpar: case DocumentLparForKindTest: case DocumentLbrace: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case IfLpar: case TypeswitchLpar: case Dot: case DotDot: case QNameLpar: case StartTagOpen: case StartTagOpenRoot: case XmlCommentStart: case XmlCommentStartForElementContent: case QName: Expr();
				 break;
				 default: jj_la1[138] = jj_gen;
				 ;
			 }
			 jj_consume_token(Rbrace);
			 SimpleNode jjtn005 = new SimpleNode(this, JJTRBRACE);
			 boolean jjtc005 = true;
			 jjtree.openNodeScope(jjtn005);
			 try {
				 jjtree.closeNodeScope(jjtn005, true);
				 jjtc005 = false;
				 jjtn005.processToken(token);
			 }
			 finally {
				 if (jjtc005) {
					 jjtree.closeNodeScope(jjtn005, true);
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SingleType() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSINGLETYPE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 AtomicType();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case OccurrenceZeroOrOne: jj_consume_token(OccurrenceZeroOrOne);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTOCCURRENCEZEROORONE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[139] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void TypeDeclaration() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(As);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTAS);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 SequenceType();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SequenceType() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSEQUENCETYPE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case Item: case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case DocumentLpar: case DocumentLparForKindTest: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: case QNameForSequenceType: case QNameForAtomicType: ItemType();
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case OccurrenceZeroOrOne: case OccurrenceZeroOrMore: case OccurrenceOneOrMore: OccurrenceIndicator();
					 break;
					 default: jj_la1[140] = jj_gen;
					 ;
				 }
				 break;
				 case EmptyTok: jj_consume_token(EmptyTok);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTEMPTYTOK);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[141] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OccurrenceIndicator() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case OccurrenceZeroOrOne: jj_consume_token(OccurrenceZeroOrOne);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTOCCURRENCEZEROORONE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case OccurrenceZeroOrMore: jj_consume_token(OccurrenceZeroOrMore);
			 SimpleNode jjtn002 = new SimpleNode(this, JJTOCCURRENCEZEROORMORE);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jjtree.closeNodeScope(jjtn002, true);
				 jjtc002 = false;
				 jjtn002.processToken(token);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 case OccurrenceOneOrMore: jj_consume_token(OccurrenceOneOrMore);
			 SimpleNode jjtn003 = new SimpleNode(this, JJTOCCURRENCEONEORMORE);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 jjtree.closeNodeScope(jjtn003, true);
				 jjtc003 = false;
				 jjtn003.processToken(token);
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 break;
			 default: jj_la1[142] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ItemType() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case QNameForSequenceType: case QNameForAtomicType: AtomicType();
			 break;
			 case ElementType: case AttributeType: case SchemaElementType: case SchemaAttributeType: case DocumentLpar: case DocumentLparForKindTest: case NodeLpar: case CommentLpar: case TextLpar: case ProcessingInstructionLpar: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case AttributeTypeForKindTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: case SchemaAttributeTypeForKindTest: case ProcessingInstructionLparForKindTest: case TextLparForKindTest: case CommentLparForKindTest: case NodeLparForKindTest: KindTest();
			 break;
			 case Item: jj_consume_token(Item);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTITEM);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 default: jj_la1[143] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void AtomicType() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTATOMICTYPE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case QNameForAtomicType: jj_consume_token(QNameForAtomicType);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORATOMICTYPE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case QNameForSequenceType: jj_consume_token(QNameForSequenceType);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTQNAMEFORSEQUENCETYPE);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[144] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void KindTest() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case DocumentLpar: case DocumentLparForKindTest: DocumentTest();
			 break;
			 case ElementType: case ElementTypeForKindTest: case ElementTypeForDocumentTest: ElementTest();
			 break;
			 case AttributeType: case AttributeTypeForKindTest: AttributeTest();
			 break;
			 case SchemaElementType: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: SchemaElementTest();
			 break;
			 case SchemaAttributeType: case SchemaAttributeTypeForKindTest: SchemaAttributeTest();
			 break;
			 case ProcessingInstructionLpar: case ProcessingInstructionLparForKindTest: PITest();
			 break;
			 case CommentLpar: case CommentLparForKindTest: CommentTest();
			 break;
			 case TextLpar: case TextLparForKindTest: TextTest();
			 break;
			 case NodeLpar: case NodeLparForKindTest: AnyKindTest();
			 break;
			 default: jj_la1[145] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void AnyKindTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTANYKINDTEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case NodeLpar: jj_consume_token(NodeLpar);
				 break;
				 case NodeLparForKindTest: jj_consume_token(NodeLparForKindTest);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTNODELPARFORKINDTEST);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[146] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DocumentTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTDOCUMENTTEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case DocumentLpar: jj_consume_token(DocumentLpar);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTDOCUMENTLPAR);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case DocumentLparForKindTest: jj_consume_token(DocumentLparForKindTest);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTDOCUMENTLPARFORKINDTEST);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[147] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ElementType: case SchemaElementType: case ElementTypeForKindTest: case ElementTypeForDocumentTest: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case ElementType: case ElementTypeForKindTest: case ElementTypeForDocumentTest: ElementTest();
					 break;
					 case SchemaElementType: case SchemaElementTypeForKindTest: case SchemaElementTypeForDocumentTest: SchemaElementTest();
					 break;
					 default: jj_la1[148] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 default: jj_la1[149] = jj_gen;
				 ;
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void TextTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTTEXTTEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case TextLpar: jj_consume_token(TextLpar);
				 break;
				 case TextLparForKindTest: jj_consume_token(TextLparForKindTest);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTTEXTLPARFORKINDTEST);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[150] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void CommentTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTCOMMENTTEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CommentLpar: jj_consume_token(CommentLpar);
				 break;
				 case CommentLparForKindTest: jj_consume_token(CommentLparForKindTest);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTCOMMENTLPARFORKINDTEST);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[151] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void PITest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTPITEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ProcessingInstructionLpar: jj_consume_token(ProcessingInstructionLpar);
				 break;
				 case ProcessingInstructionLparForKindTest: jj_consume_token(ProcessingInstructionLparForKindTest);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONLPARFORKINDTEST);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[152] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case StringLiteralForKindTest: case NCNameForPI: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case NCNameForPI: jj_consume_token(NCNameForPI);
					 SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPI);
					 boolean jjtc002 = true;
					 jjtree.openNodeScope(jjtn002);
					 try {
						 jjtree.closeNodeScope(jjtn002, true);
						 jjtc002 = false;
						 jjtn002.processToken(token);
					 }
					 finally {
						 if (jjtc002) {
							 jjtree.closeNodeScope(jjtn002, true);
						 }
					 }
					 break;
					 case StringLiteralForKindTest: jj_consume_token(StringLiteralForKindTest);
					 SimpleNode jjtn003 = new SimpleNode(this, JJTSTRINGLITERALFORKINDTEST);
					 boolean jjtc003 = true;
					 jjtree.openNodeScope(jjtn003);
					 try {
						 jjtree.closeNodeScope(jjtn003, true);
						 jjtc003 = false;
						 jjtn003.processToken(token);
					 }
					 finally {
						 if (jjtc003) {
							 jjtree.closeNodeScope(jjtn003, true);
						 }
					 }
					 break;
					 default: jj_la1[153] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 default: jj_la1[154] = jj_gen;
				 ;
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void AttributeTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBUTETEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AttributeType: jj_consume_token(AttributeType);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTATTRIBUTETYPE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case AttributeTypeForKindTest: jj_consume_token(AttributeTypeForKindTest);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTATTRIBUTETYPEFORKINDTEST);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[155] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AnyName: case QNameForItemType: AttribNameOrWildcard();
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CommaForKindTest: jj_consume_token(CommaForKindTest);
					 SimpleNode jjtn003 = new SimpleNode(this, JJTCOMMAFORKINDTEST);
					 boolean jjtc003 = true;
					 jjtree.openNodeScope(jjtn003);
					 try {
						 jjtree.closeNodeScope(jjtn003, true);
						 jjtc003 = false;
						 jjtn003.processToken(token);
					 }
					 finally {
						 if (jjtc003) {
							 jjtree.closeNodeScope(jjtn003, true);
						 }
					 }
					 TypeName();
					 break;
					 default: jj_la1[156] = jj_gen;
					 ;
				 }
				 break;
				 default: jj_la1[157] = jj_gen;
				 ;
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void AttribNameOrWildcard() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBNAMEORWILDCARD);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case QNameForItemType: AttributeName();
				 break;
				 case AnyName: jj_consume_token(AnyName);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTANYNAME);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[158] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SchemaAttributeTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAATTRIBUTETEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case SchemaAttributeType: jj_consume_token(SchemaAttributeType);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTSCHEMAATTRIBUTETYPE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case SchemaAttributeTypeForKindTest: jj_consume_token(SchemaAttributeTypeForKindTest);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTSCHEMAATTRIBUTETYPEFORKINDTEST);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 default: jj_la1[159] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 AttributeDeclaration();
			 jj_consume_token(RparForKindTest);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void AttributeDeclaration() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBUTEDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 AttributeName();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ElementTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTTEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ElementType: jj_consume_token(ElementType);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTELEMENTTYPE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case ElementTypeForKindTest: jj_consume_token(ElementTypeForKindTest);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTELEMENTTYPEFORKINDTEST);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case ElementTypeForDocumentTest: jj_consume_token(ElementTypeForDocumentTest);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTELEMENTTYPEFORDOCUMENTTEST);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[160] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AnyName: case QNameForItemType: ElementNameOrWildcard();
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CommaForKindTest: jj_consume_token(CommaForKindTest);
					 SimpleNode jjtn004 = new SimpleNode(this, JJTCOMMAFORKINDTEST);
					 boolean jjtc004 = true;
					 jjtree.openNodeScope(jjtn004);
					 try {
						 jjtree.closeNodeScope(jjtn004, true);
						 jjtc004 = false;
						 jjtn004.processToken(token);
					 }
					 finally {
						 if (jjtc004) {
							 jjtree.closeNodeScope(jjtn004, true);
						 }
					 }
					 TypeName();
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case Nillable: jj_consume_token(Nillable);
						 SimpleNode jjtn005 = new SimpleNode(this, JJTNILLABLE);
						 boolean jjtc005 = true;
						 jjtree.openNodeScope(jjtn005);
						 try {
							 jjtree.closeNodeScope(jjtn005, true);
							 jjtc005 = false;
							 jjtn005.processToken(token);
						 }
						 finally {
							 if (jjtc005) {
								 jjtree.closeNodeScope(jjtn005, true);
							 }
						 }
						 break;
						 default: jj_la1[161] = jj_gen;
						 ;
					 }
					 break;
					 default: jj_la1[162] = jj_gen;
					 ;
				 }
				 break;
				 default: jj_la1[163] = jj_gen;
				 ;
			 }
			 jj_consume_token(RparForKindTest);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ElementNameOrWildcard() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTNAMEORWILDCARD);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case QNameForItemType: ElementName();
				 break;
				 case AnyName: jj_consume_token(AnyName);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTANYNAME);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 default: jj_la1[164] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SchemaElementTest() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAELEMENTTEST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case SchemaElementType: jj_consume_token(SchemaElementType);
				 SimpleNode jjtn001 = new SimpleNode(this, JJTSCHEMAELEMENTTYPE);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 jjtree.closeNodeScope(jjtn001, true);
					 jjtc001 = false;
					 jjtn001.processToken(token);
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, true);
					 }
				 }
				 break;
				 case SchemaElementTypeForKindTest: jj_consume_token(SchemaElementTypeForKindTest);
				 SimpleNode jjtn002 = new SimpleNode(this, JJTSCHEMAELEMENTTYPEFORKINDTEST);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 jjtree.closeNodeScope(jjtn002, true);
					 jjtc002 = false;
					 jjtn002.processToken(token);
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, true);
					 }
				 }
				 break;
				 case SchemaElementTypeForDocumentTest: jj_consume_token(SchemaElementTypeForDocumentTest);
				 SimpleNode jjtn003 = new SimpleNode(this, JJTSCHEMAELEMENTTYPEFORDOCUMENTTEST);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 jjtree.closeNodeScope(jjtn003, true);
					 jjtc003 = false;
					 jjtn003.processToken(token);
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, true);
					 }
				 }
				 break;
				 default: jj_la1[165] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 ElementDeclaration();
			 jj_consume_token(RparForKindTest);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ElementDeclaration() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 ElementName();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void AttributeName() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBUTENAME);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(QNameForItemType);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORITEMTYPE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ElementName() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTNAME);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(QNameForItemType);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORITEMTYPE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void TypeName() throws ParseException {
		 SimpleNode jjtn000 = new SimpleNode(this, JJTTYPENAME);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(QNameForItemType);
			 SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORITEMTYPE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, true);
				 jjtc001 = false;
				 jjtn001.processToken(token);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 public XPathTokenManager token_source;
	 SimpleCharStream jj_input_stream;
	 public Token token, jj_nt;
	 private int jj_ntk;
	 private int jj_gen;
	 final private int[] jj_la1 = new int[166];
	 static private int[] jj_la1_0;
	 static private int[] jj_la1_1;
	 static private int[] jj_la1_2;
	 static private int[] jj_la1_3;
	 static private int[] jj_la1_4;
	 static private int[] jj_la1_5;
	 static private int[] jj_la1_6;
	 static private int[] jj_la1_7;
	 static {
		 jj_la1_0();
		 jj_la1_1();
		 jj_la1_2();
		 jj_la1_3();
		 jj_la1_4();
		 jj_la1_5();
		 jj_la1_6();
		 jj_la1_7();
	 }
	 private static void jj_la1_0() {
		 jj_la1_0 = new int[] {
		0x0,0xfffd885e,0x40,0xfffd881e,0x100,0x80000000,0x0,0x0,0x40000000,0x40000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffd801e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffd801e,0x0,0x0,0x0,0x0,0x3ffd801e,0x3ffd801e,0x0,0x0,0x3ffd801e,0x3ffc0000,0xaec0000,0xaec0000,0x0,0x35100000,0x35100000,0x0,0x0,0x0,0x0,0x1801e,0x1e,0xe,0x3ffd801e,0x0,0x3ffd801e,0x18000,0x18000,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffd801e,0x0,0x3ffd801e,0x0,0x3ffd801e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,}
		;
	 }
	 private static void jj_la1_1() {
		 jj_la1_1 = new int[] {
		0x0,0x3042000c,0x0,0x3042000c,0x0,0x3040000c,0x0,0x0,0x0,0x0,0x3040000c,0x0,0xc0000000,0x0,0x3,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x20000,0x0,0x40,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x80,0x100,0x0,0x0,0x0,0x0,0x0,0x1e00,0x1e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x20000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,}
		;
	 }
	 private static void jj_la1_2() {
		 jj_la1_2 = new int[] {
		0x0,0xdfffc002,0x0,0xdfffc002,0x0,0x10000000,0xc0000002,0xc0000002,0x0,0x0,0x10000000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x20000001,0x0,0x0,0x20000001,0x1,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x0,0xfffc000,0x0,0x0,0x8,0x0,0x100,0x200,0x0,0x100,0x200,0x100,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x100,0x0,0x100,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x40,0x40,0xa0,0xa0,0x800,0x0,0x1000,0x0,0x0,0x0,0xfffc000,0x0,0x0,0x0,0x0,0xfffc000,0xfffc000,0x0,0x0,0xfffc000,0x3c000,0x3c000,0x0,0x0,0x0,0x0,0x3c000,0x0,0x0,0x0,0xffc0000,0x0,0x0,0xfffc000,0x0,0xfffc000,0xff00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff00000,0x2100000,0xfffc000,0x4200000,0xfffc000,0xc00000,0xfffc000,0x0,0x0,0x3e000,0x0,0x3e000,0x0,0x3c000,0x0,0x0,0x14000,0x14000,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x20000,0x4000,0x0,0x0,0x0,0x0,0x10000,}
		;
	 }
	 private static void jj_la1_3() {
		 jj_la1_3 = new int[] {
		0x0,0x7a6,0x0,0x7a6,0x0,0x0,0x6,0x6,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7a0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x37ffa000,0x37ffa000,0x0,0xc0000000,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7a0,0x300b2000,0x7e00000,0x148000,0x0,0x1a0,0x7a0,0x1800,0x1800,0x1a0,0x1a0,0x1a0,0x0,0x0,0x0,0x0,0x1a0,0x1a0,0x1a0,0x0,0x0,0x0,0x0,0x7a0,0x0,0x7a0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7a0,0x0,0x7a0,0x0,0x7a0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x40,0x40,0x0,}
		;
	 }
	 private static void jj_la1_4() {
		 jj_la1_4 = new int[] {
		0x0,0xffecf0c3,0x0,0xffecf0c3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffecf0c3,0xc000,0xc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x20000,0x0,0x10000,0x3,0x3,0xffec00c0,0x0,0x0,0x0,0xc0000,0xffe000c0,0xffe000c0,0x0,0x0,0xffe000c0,0xff600080,0xff600080,0x0,0x80,0x0,0x0,0xff600000,0x0,0x0,0x100,0x800040,0x0,0x0,0xffecf0c3,0x0,0xffecf0c3,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0xffecf0c3,0x0,0xffecf0c3,0x0,0xffecf0c3,0x4,0x1c,0xff600000,0x1c,0xff600000,0x0,0xff600000,0x1000000,0x600000,0xb0000000,0xb0000000,0x4000000,0x2000000,0x8000000,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x80000000,}
		;
	 }
	 private static void jj_la1_5() {
		 jj_la1_5 = new int[] {
		0x800,0x840c0ff,0x0,0x840c0ff,0x0,0x0,0x0,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x300000,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x800c0ff,0x0,0x0,0x0,0x30000,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x0,0x30000,0x100,0xc0000,0xc0000,0x300000,0x300000,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800c03f,0x0,0x0,0x0,0x0,0x800c03f,0x800c03f,0x0,0x0,0x800c03f,0x803f,0x3f,0x0,0x0,0x8000,0x0,0x3f,0x0,0x0,0x0,0x8004000,0x0,0x0,0x800c0ff,0x100,0x800c0ff,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x800c0ff,0x0,0x800c0ff,0x0,0x800c0ff,0x0,0x0,0x180003f,0x0,0x180003f,0x1800000,0x3f,0x20,0x0,0x1,0x1,0x8,0x10,0x4,0x20000000,0x20000000,0x0,0x200,0x2000000,0x2000000,0x2,0x0,0x0,0x200,0x2000000,0x2000000,0x1,}
		;
	 }
	 private static void jj_la1_6() {
		 jj_la1_6 = new int[] {
		0x0,0x30,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x0,0x0,0x3000,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x30,0x30,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30,0x0,0x0,0x30,0x0,0x30,0x30,0x30,0x30,0x4f036,0x0,0xc0,0x0,0x0,0x0,0x800,0x9f006,0x9f006,0x12f006,0x12f006,0x2000000,0x8f006,0x10f006,0x4f036,0xf006,0x0,0x600000,0x600000,0x0,0x0,0x800000,0x0,0x1000000,0x0,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,}
		;
	 }
	 private static void jj_la1_7() {
		 jj_la1_7 = new int[] {
		0x0,0xb00,0x0,0xb00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb00,0x0,0x0,0x0,0x0,0xb00,0xb00,0x0,0x0,0xb00,0x800,0x800,0x0,0x0,0x0,0x0,0x800,0x800,0x0,0x0,0x300,0x0,0x0,0xb00,0x0,0xb00,0x300,0x300,0x0,0x300,0x2000,0x0,0x2000,0x2000,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300,0x0,0x300,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0xb00,0x0,0xb00,0x0,0xb00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,}
		;
	 }
	 public XPath(java.io.InputStream stream) {
		 this(stream, null);
	 }
	 public XPath(java.io.InputStream stream, String encoding) {
		 try {
			 jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		 }
		 catch(java.io.UnsupportedEncodingException e) {
			 throw new RuntimeException(e);
		 }
		 token_source = new XPathTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 166;
		 i++) jj_la1[i] = -1;
	 }
	 public void ReInit(java.io.InputStream stream) {
		 ReInit(stream, null);
	 }
	 public void ReInit(java.io.InputStream stream, String encoding) {
		 try {
			 jj_input_stream.ReInit(stream, encoding, 1, 1);
		 }
		 catch(java.io.UnsupportedEncodingException e) {
			 throw new RuntimeException(e);
		 }
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 166;
		 i++) jj_la1[i] = -1;
	 }
	 public XPath(java.io.Reader stream) {
		 jj_input_stream = new SimpleCharStream(stream, 1, 1);
		 token_source = new XPathTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 166;
		 i++) jj_la1[i] = -1;
	 }
	 public void ReInit(java.io.Reader stream) {
		 jj_input_stream.ReInit(stream, 1, 1);
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 166;
		 i++) jj_la1[i] = -1;
	 }
	 public XPath(XPathTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 166;
		 i++) jj_la1[i] = -1;
	 }
	 public void ReInit(XPathTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 166;
		 i++) jj_la1[i] = -1;
	 }
	 final private Token jj_consume_token(int kind) throws ParseException {
		 Token oldToken;
		 if ((oldToken = token).next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 if (token.kind == kind) {
			 jj_gen++;
			 return token;
		 }
		 token = oldToken;
		 jj_kind = kind;
		 throw generateParseException();
	 }
	 final public Token getNextToken() {
		 if (token.next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 jj_gen++;
		 return token;
	 }
	 final public Token getToken(int index) {
		 Token t = token;
		 for (int i = 0;
		 i < index;
		 i++) {
			 if (t.next != null) t = t.next;
			 else t = t.next = token_source.getNextToken();
		 }
		 return t;
	 }
	 final private int jj_ntk() {
		 if ((jj_nt=token.next) == null) return (jj_ntk = (token.next=token_source.getNextToken()).kind);
		 else return (jj_ntk = jj_nt.kind);
	 }
	 private java.util.Vector jj_expentries = new java.util.Vector();
	 private int[] jj_expentry;
	 private int jj_kind = -1;
	 public ParseException generateParseException() {
		 jj_expentries.removeAllElements();
		 boolean[] la1tokens = new boolean[251];
		 for (int i = 0;
		 i < 251;
		 i++) {
			 la1tokens[i] = false;
		 }
		 if (jj_kind >= 0) {
			 la1tokens[jj_kind] = true;
			 jj_kind = -1;
		 }
		 for (int i = 0;
		 i < 166;
		 i++) {
			 if (jj_la1[i] == jj_gen) {
				 for (int j = 0;
				 j < 32;
				 j++) {
					 if ((jj_la1_0[i] & (1<<j)) != 0) {
						 la1tokens[j] = true;
					 }
					 if ((jj_la1_1[i] & (1<<j)) != 0) {
						 la1tokens[32+j] = true;
					 }
					 if ((jj_la1_2[i] & (1<<j)) != 0) {
						 la1tokens[64+j] = true;
					 }
					 if ((jj_la1_3[i] & (1<<j)) != 0) {
						 la1tokens[96+j] = true;
					 }
					 if ((jj_la1_4[i] & (1<<j)) != 0) {
						 la1tokens[128+j] = true;
					 }
					 if ((jj_la1_5[i] & (1<<j)) != 0) {
						 la1tokens[160+j] = true;
					 }
					 if ((jj_la1_6[i] & (1<<j)) != 0) {
						 la1tokens[192+j] = true;
					 }
					 if ((jj_la1_7[i] & (1<<j)) != 0) {
						 la1tokens[224+j] = true;
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < 251;
		 i++) {
			 if (la1tokens[i]) {
				 jj_expentry = new int[1];
				 jj_expentry[0] = i;
				 jj_expentries.addElement(jj_expentry);
			 }
		 }
		 int[][] exptokseq = new int[jj_expentries.size()][];
		 for (int i = 0;
		 i < jj_expentries.size();
		 i++) {
			 exptokseq[i] = (int[])jj_expentries.elementAt(i);
		 }
		 return new ParseException(token, exptokseq, tokenImage);
	 }
	 final public void enable_tracing() {
	 }
	 final public void disable_tracing() {
	 }
 }",1,0,0,0
"public boolean run() {
	 System.out.println(""[DEBUG] Running exe..."");
	 JSmoothApplication app = getApplication();
	 if (!app.hasProjectFile()) {
		 app.consoleMessage(""Cannot run without a project file. Please save the project or load a new one, then try again."");
		 return false;
	 }
	 JSmoothModelBean jsmodel = app.getModelBean();
	 String basedir = app.getProjectFile().getParent();
	 File exe = new File (basedir, jsmodel.getExecutableName());
	 app.consoleMessage(""Running exe "" + exe.getAbsolutePath());
	 return Program.launch(exe.getAbsolutePath());
 }",0,0,0,0
"public CreatePreauthenticatedRequestResponse createPreauthenticatedRequest( CreatePreauthenticatedRequestRequest request) {
	 LOG.trace(""Called createPreauthenticatedRequest"");
	 request = CreatePreauthenticatedRequestConverter.interceptRequest(request);
	 com.oracle.bmc.http.internal.WrappedInvocationBuilder ib = CreatePreauthenticatedRequestConverter.fromRequest(client, request);
	 com.google.common.base.Function< javax.ws.rs.core.Response, CreatePreauthenticatedRequestResponse> transformer = CreatePreauthenticatedRequestConverter.fromResponse();
	 int attempts = 0;
	 while (true) {
		 try {
			 javax.ws.rs.core.Response response = client.post(ib, request.getCreatePreauthenticatedRequestDetails(), request);
			 return transformer.apply(response);
		 }
		 catch (com.oracle.bmc.model.BmcException e) {
			 if (++attempts < MAX_IMMEDIATE_RETRIES_IF_USING_INSTANCE_PRINCIPALS && canRetryRequestIfRefreshableAuthTokenUsed(e)) {
				 continue;
			 }
			 else {
				 throw e;
			 }
		 }
	 }
 }",0,0,1,0
"public abstract class AbstractEndpointSnitch implements IEndpointSnitch{
	 public abstract int compareEndpoints(InetAddress target, InetAddress a1, InetAddress a2);
	 public List<InetAddress> getSortedListByProximity(InetAddress address, Collection<InetAddress> unsortedAddress) {
		 List<InetAddress> preferred = new ArrayList<InetAddress>(unsortedAddress);
		 sortByProximity(address, preferred);
		 return preferred;
	 }
	 public void sortByProximity(final InetAddress address, List<InetAddress> addresses) {
		 Collections.sort(addresses, new Comparator<InetAddress>() {
			 public int compare(InetAddress a1, InetAddress a2) {
				 return compareEndpoints(address, a1, a2);
			 }
		 }
		);
	 }
	 public void gossiperStarting() {
	 }
}",0,0,0,0
"public class Javadoc extends Task {
	 private static final boolean JAVADOC_5 = !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4);
	 public class DocletParam {
		 private String name;
		 private String value;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setValue(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
	 }
	 public static class ExtensionInfo extends ProjectComponent {
		 private String name;
		 private Path path;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setPath(Path path) {
			 if (this.path == null) {
				 this.path = path;
			 }
			 else {
				 this.path.append(path);
			 }
		 }
		 public Path getPath() {
			 return path;
		 }
		 public Path createPath() {
			 if (path == null) {
				 path = new Path(getProject());
			 }
			 return path.createPath();
		 }
		 public void setPathRef(Reference r) {
			 createPath().setRefid(r);
		 }
	 }
	 public class DocletInfo extends ExtensionInfo {
		 private Vector params = new Vector();
		 public DocletParam createParam() {
			 DocletParam param = new DocletParam();
			 params.addElement(param);
			 return param;
		 }
		 public Enumeration getParams() {
			 return params.elements();
		 }
	 }
	 public static class PackageName {
		 private String name;
		 public void setName(String name) {
			 this.name = name.trim();
		 }
		 public String getName() {
			 return name;
		 }
		 public String toString() {
			 return getName();
		 }
	 }
	 public static class SourceFile {
		 private File file;
		 public SourceFile() {
		 }
		 public SourceFile(File file) {
			 this.file = file;
		 }
		 public void setFile(File file) {
			 this.file = file;
		 }
		 public File getFile() {
			 return file;
		 }
	 }
	 public static class Html {
		 private StringBuffer text = new StringBuffer();
		 public void addText(String t) {
			 text.append(t);
		 }
		 public String getText() {
			 return text.substring(0);
		 }
	 }
	 public static class AccessType extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""protected"", ""public"", ""package"", ""private""}
			;
		 }
	 }
	 public class ResourceCollectionContainer {
		 private ArrayList rcs = new ArrayList();
		 public void add(ResourceCollection rc) {
			 rcs.add(rc);
		 }
		 private Iterator iterator() {
			 return rcs.iterator();
		 }
	 }
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private Commandline cmd = new Commandline();
	 private void addArgIf(boolean b, String arg) {
		 if (b) {
			 cmd.createArgument().setValue(arg);
		 }
	 }
	 private void addArgIfNotEmpty(String key, String value) {
		 if (value != null && value.length() != 0) {
			 cmd.createArgument().setValue(key);
			 cmd.createArgument().setValue(value);
		 }
		 else {
			 log(""Warning: Leaving out empty argument '"" + key + ""'"", Project.MSG_WARN);
		 }
	 }
	 private boolean failOnError = false;
	 private Path sourcePath = null;
	 private File destDir = null;
	 private Vector sourceFiles = new Vector();
	 private Vector packageNames = new Vector();
	 private Vector excludePackageNames = new Vector(1);
	 private boolean author = true;
	 private boolean version = true;
	 private DocletInfo doclet = null;
	 private Path classpath = null;
	 private Path bootclasspath = null;
	 private String group = null;
	 private String packageList = null;
	 private Vector links = new Vector();
	 private Vector groups = new Vector();
	 private Vector tags = new Vector();
	 private boolean useDefaultExcludes = true;
	 private Html doctitle = null;
	 private Html header = null;
	 private Html footer = null;
	 private Html bottom = null;
	 private boolean useExternalFile = false;
	 private String source = null;
	 private boolean linksource = false;
	 private boolean breakiterator = false;
	 private String noqualifier;
	 private boolean includeNoSourcePackages = false;
	 private String executable = null;
	 private boolean docFilesSubDirs = false;
	 private String excludeDocFilesSubDir = null;
	 private ResourceCollectionContainer nestedSourceFiles = new ResourceCollectionContainer();
	 private Vector packageSets = new Vector();
	 public void setUseExternalFile(boolean b) {
		 useExternalFile = b;
	 }
	 public void setDefaultexcludes(boolean useDefaultExcludes) {
		 this.useDefaultExcludes = useDefaultExcludes;
	 }
	 public void setMaxmemory(String max) {
		 cmd.createArgument().setValue(""-J-Xmx"" + max);
	 }
	 public void setAdditionalparam(String add) {
		 cmd.createArgument().setLine(add);
	 }
	 public Commandline.Argument createArg() {
		 return cmd.createArgument();
	 }
	 public void setSourcepath(Path src) {
		 if (sourcePath == null) {
			 sourcePath = src;
		 }
		 else {
			 sourcePath.append(src);
		 }
	 }
	 public Path createSourcepath() {
		 if (sourcePath == null) {
			 sourcePath = new Path(getProject());
		 }
		 return sourcePath.createPath();
	 }
	 public void setSourcepathRef(Reference r) {
		 createSourcepath().setRefid(r);
	 }
	 public void setDestdir(File dir) {
		 destDir = dir;
		 cmd.createArgument().setValue(""-d"");
		 cmd.createArgument().setFile(destDir);
	 }
	 public void setSourcefiles(String src) {
		 StringTokenizer tok = new StringTokenizer(src, "","");
		 while (tok.hasMoreTokens()) {
			 String f = tok.nextToken();
			 SourceFile sf = new SourceFile();
			 sf.setFile(getProject().resolveFile(f.trim()));
			 addSource(sf);
		 }
	 }
	 public void addSource(SourceFile sf) {
		 sourceFiles.addElement(sf);
	 }
	 public void setPackagenames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addPackage(pn);
		 }
	 }
	 public void addPackage(PackageName pn) {
		 packageNames.addElement(pn);
	 }
	 public void setExcludePackageNames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addExcludePackage(pn);
		 }
	 }
	 public void addExcludePackage(PackageName pn) {
		 excludePackageNames.addElement(pn);
	 }
	 public void setOverview(File f) {
		 cmd.createArgument().setValue(""-overview"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setPublic(boolean b) {
		 addArgIf(b, ""-public"");
	 }
	 public void setProtected(boolean b) {
		 addArgIf(b, ""-protected"");
	 }
	 public void setPackage(boolean b) {
		 addArgIf(b, ""-package"");
	 }
	 public void setPrivate(boolean b) {
		 addArgIf(b, ""-private"");
	 }
	 public void setAccess(AccessType at) {
		 cmd.createArgument().setValue(""-"" + at.getValue());
	 }
	 public void setDoclet(String docletName) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setName(docletName);
	 }
	 public void setDocletPath(Path docletPath) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setPath(docletPath);
	 }
	 public void setDocletPathRef(Reference r) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.createPath().setRefid(r);
	 }
	 public DocletInfo createDoclet() {
		 if (doclet == null) {
			 doclet = new DocletInfo();
		 }
		 return doclet;
	 }
	 public void addTaglet(ExtensionInfo tagletInfo) {
		 tags.addElement(tagletInfo);
	 }
	 public void setOld(boolean b) {
		 log(""Javadoc 1.4 doesn't support the -1.1 switch anymore"", Project.MSG_WARN);
	 }
	 public void setClasspath(Path path) {
		 if (classpath == null) {
			 classpath = path;
		 }
		 else {
			 classpath.append(path);
		 }
	 }
	 public Path createClasspath() {
		 if (classpath == null) {
			 classpath = new Path(getProject());
		 }
		 return classpath.createPath();
	 }
	 public void setClasspathRef(Reference r) {
		 createClasspath().setRefid(r);
	 }
	 public void setBootclasspath(Path path) {
		 if (bootclasspath == null) {
			 bootclasspath = path;
		 }
		 else {
			 bootclasspath.append(path);
		 }
	 }
	 public Path createBootclasspath() {
		 if (bootclasspath == null) {
			 bootclasspath = new Path(getProject());
		 }
		 return bootclasspath.createPath();
	 }
	 public void setBootClasspathRef(Reference r) {
		 createBootclasspath().setRefid(r);
	 }
	 public void setExtdirs(String path) {
		 cmd.createArgument().setValue(""-extdirs"");
		 cmd.createArgument().setValue(path);
	 }
	 public void setExtdirs(Path path) {
		 cmd.createArgument().setValue(""-extdirs"");
		 cmd.createArgument().setPath(path);
	 }
	 public void setVerbose(boolean b) {
		 addArgIf(b, ""-verbose"");
	 }
	 public void setLocale(String locale) {
		 cmd.createArgument(true).setValue(locale);
		 cmd.createArgument(true).setValue(""-locale"");
	 }
	 public void setEncoding(String enc) {
		 cmd.createArgument().setValue(""-encoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setVersion(boolean b) {
		 this.version = b;
	 }
	 public void setUse(boolean b) {
		 addArgIf(b, ""-use"");
	 }
	 public void setAuthor(boolean b) {
		 author = b;
	 }
	 public void setSplitindex(boolean b) {
		 addArgIf(b, ""-splitindex"");
	 }
	 public void setWindowtitle(String title) {
		 addArgIfNotEmpty(""-windowtitle"", title);
	 }
	 public void setDoctitle(String doctitle) {
		 Html h = new Html();
		 h.addText(doctitle);
		 addDoctitle(h);
	 }
	 public void addDoctitle(Html text) {
		 doctitle = text;
	 }
	 public void setHeader(String header) {
		 Html h = new Html();
		 h.addText(header);
		 addHeader(h);
	 }
	 public void addHeader(Html text) {
		 header = text;
	 }
	 public void setFooter(String footer) {
		 Html h = new Html();
		 h.addText(footer);
		 addFooter(h);
	 }
	 public void addFooter(Html text) {
		 footer = text;
	 }
	 public void setBottom(String bottom) {
		 Html h = new Html();
		 h.addText(bottom);
		 addBottom(h);
	 }
	 public void addBottom(Html text) {
		 bottom = text;
	 }
	 public void setLinkoffline(String src) {
		 LinkArgument le = createLink();
		 le.setOffline(true);
		 String linkOfflineError = ""The linkoffline attribute must include"" + "" a URL and a package-list file location separated by a"" + "" space"";
		 if (src.trim().length() == 0) {
			 throw new BuildException(linkOfflineError);
		 }
		 StringTokenizer tok = new StringTokenizer(src, "" "", false);
		 le.setHref(tok.nextToken());
		 if (!tok.hasMoreTokens()) {
			 throw new BuildException(linkOfflineError);
		 }
		 le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
	 }
	 public void setGroup(String src) {
		 group = src;
	 }
	 public void setLink(String src) {
		 createLink().setHref(src);
	 }
	 public void setNodeprecated(boolean b) {
		 addArgIf(b, ""-nodeprecated"");
	 }
	 public void setNodeprecatedlist(boolean b) {
		 addArgIf(b, ""-nodeprecatedlist"");
	 }
	 public void setNotree(boolean b) {
		 addArgIf(b, ""-notree"");
	 }
	 public void setNoindex(boolean b) {
		 addArgIf(b, ""-noindex"");
	 }
	 public void setNohelp(boolean b) {
		 addArgIf(b, ""-nohelp"");
	 }
	 public void setNonavbar(boolean b) {
		 addArgIf(b, ""-nonavbar"");
	 }
	 public void setSerialwarn(boolean b) {
		 addArgIf(b, ""-serialwarn"");
	 }
	 public void setStylesheetfile(File f) {
		 cmd.createArgument().setValue(""-stylesheetfile"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setHelpfile(File f) {
		 cmd.createArgument().setValue(""-helpfile"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setDocencoding(String enc) {
		 cmd.createArgument().setValue(""-docencoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setPackageList(String src) {
		 packageList = src;
	 }
	 public LinkArgument createLink() {
		 LinkArgument la = new LinkArgument();
		 links.addElement(la);
		 return la;
	 }
	 public class LinkArgument {
		 private String href;
		 private boolean offline = false;
		 private File packagelistLoc;
		 private URL packagelistURL;
		 private boolean resolveLink = false;
		 public LinkArgument() {
		 }
		 public void setHref(String hr) {
			 href = hr;
		 }
		 public String getHref() {
			 return href;
		 }
		 public void setPackagelistLoc(File src) {
			 packagelistLoc = src;
		 }
		 public File getPackagelistLoc() {
			 return packagelistLoc;
		 }
		 public void setPackagelistURL(URL src) {
			 packagelistURL = src;
		 }
		 public URL getPackagelistURL() {
			 return packagelistURL;
		 }
		 public void setOffline(boolean offline) {
			 this.offline = offline;
		 }
		 public boolean isLinkOffline() {
			 return offline;
		 }
		 public void setResolveLink(boolean resolve) {
			 this.resolveLink = resolve;
		 }
		 public boolean shouldResolveLink() {
			 return resolveLink;
		 }
	 }
	 public TagArgument createTag() {
		 TagArgument ta = new TagArgument();
		 tags.addElement (ta);
		 return ta;
	 }
	 static final String[] SCOPE_ELEMENTS = {
	 ""overview"", ""packages"", ""types"", ""constructors"", ""methods"", ""fields"" }
	;
	 public class TagArgument extends FileSet {
		 private String name = null;
		 private boolean enabled = true;
		 private String scope = ""a"";
		 public TagArgument () {
		 }
		 public void setName (String name) {
			 this.name = name;
		 }
		 public void setScope (String verboseScope) throws BuildException {
			 verboseScope = verboseScope.toLowerCase(Locale.ENGLISH);
			 boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
			 boolean gotAll = false;
			 boolean gotNotAll = false;
			 StringTokenizer tok = new StringTokenizer (verboseScope, "","");
			 while (tok.hasMoreTokens()) {
				 String next = tok.nextToken().trim();
				 if (next.equals(""all"")) {
					 if (gotAll) {
						 getProject().log (""Repeated tag scope element: all"", Project.MSG_VERBOSE);
					 }
					 gotAll = true;
				 }
				 else {
					 int i;
					 for (i = 0;
					 i < SCOPE_ELEMENTS.length;
					 i++) {
						 if (next.equals (SCOPE_ELEMENTS[i])) {
							 break;
						 }
					 }
					 if (i == SCOPE_ELEMENTS.length) {
						 throw new BuildException (""Unrecognised scope element: "" + next);
					 }
					 else {
						 if (elements[i]) {
							 getProject().log (""Repeated tag scope element: "" + next, Project.MSG_VERBOSE);
						 }
						 elements[i] = true;
						 gotNotAll = true;
					 }
				 }
			 }
			 if (gotNotAll && gotAll) {
				 throw new BuildException (""Mixture of \""all\"" and other scope "" + ""elements in tag parameter."");
			 }
			 if (!gotNotAll && !gotAll) {
				 throw new BuildException (""No scope elements specified in tag "" + ""parameter."");
			 }
			 if (gotAll) {
				 this.scope = ""a"";
			 }
			 else {
				 StringBuffer buff = new StringBuffer (elements.length);
				 for (int i = 0;
				 i < elements.length;
				 i++) {
					 if (elements[i]) {
						 buff.append (SCOPE_ELEMENTS[i].charAt(0));
					 }
				 }
				 this.scope = buff.toString();
			 }
		 }
		 public void setEnabled (boolean enabled) {
			 this.enabled = enabled;
		 }
		 public String getParameter() throws BuildException {
			 if (name == null || name.equals("""")) {
				 throw new BuildException (""No name specified for custom tag."");
			 }
			 if (getDescription() != null) {
				 return name + "":"" + (enabled ? """" : ""X"") + scope + "":"" + getDescription();
			 }
			 else if (!enabled || !""a"".equals(scope)) {
				 return name + "":"" + (enabled ? """" : ""X"") + scope;
			 }
			 else {
				 return name;
			 }
		 }
	 }
	 public GroupArgument createGroup() {
		 GroupArgument ga = new GroupArgument();
		 groups.addElement(ga);
		 return ga;
	 }
	 public class GroupArgument {
		 private Html title;
		 private Vector packages = new Vector();
		 public GroupArgument() {
		 }
		 public void setTitle(String src) {
			 Html h = new Html();
			 h.addText(src);
			 addTitle(h);
		 }
		 public void addTitle(Html text) {
			 title = text;
		 }
		 public String getTitle() {
			 return title != null ? title.getText() : null;
		 }
		 public void setPackages(String src) {
			 StringTokenizer tok = new StringTokenizer(src, "","");
			 while (tok.hasMoreTokens()) {
				 String p = tok.nextToken();
				 PackageName pn = new PackageName();
				 pn.setName(p);
				 addPackage(pn);
			 }
		 }
		 public void addPackage(PackageName pn) {
			 packages.addElement(pn);
		 }
		 public String getPackages() {
			 StringBuffer p = new StringBuffer();
			 final int size = packages.size();
			 for (int i = 0;
			 i < size;
			 i++) {
				 if (i > 0) {
					 p.append("":"");
				 }
				 p.append(packages.elementAt(i).toString());
			 }
			 return p.toString();
		 }
	 }
	 public void setCharset(String src) {
		 this.addArgIfNotEmpty(""-charset"", src);
	 }
	 public void setFailonerror(boolean b) {
		 failOnError = b;
	 }
	 public void setSource(String source) {
		 this.source = source;
	 }
	 public void setExecutable(String executable) {
		 this.executable = executable;
	 }
	 public void addPackageset(DirSet packageSet) {
		 packageSets.addElement(packageSet);
	 }
	 public void addFileset(FileSet fs) {
		 createSourceFiles().add(fs);
	 }
	 public ResourceCollectionContainer createSourceFiles() {
		 return nestedSourceFiles;
	 }
	 public void setLinksource(boolean b) {
		 this.linksource = b;
	 }
	 public void setBreakiterator(boolean b) {
		 this.breakiterator = b;
	 }
	 public void setNoqualifier(String noqualifier) {
		 this.noqualifier = noqualifier;
	 }
	 public void setIncludeNoSourcePackages(boolean b) {
		 this.includeNoSourcePackages = b;
	 }
	 public void setDocFilesSubDirs(boolean b) {
		 docFilesSubDirs = b;
	 }
	 public void setExcludeDocFilesSubDir(String s) {
		 excludeDocFilesSubDir = s;
	 }
	 public void execute() throws BuildException {
		 checkTaskName();
		 Vector packagesToDoc = new Vector();
		 Path sourceDirs = new Path(getProject());
		 checkPackageAndSourcePath();
		 if (sourcePath != null) {
			 sourceDirs.addExisting(sourcePath);
		 }
		 parsePackages(packagesToDoc, sourceDirs);
		 checkPackages(packagesToDoc, sourceDirs);
		 Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
		 addSourceFiles(sourceFilesToDoc);
		 checkPackagesToDoc(packagesToDoc, sourceFilesToDoc);
		 log(""Generating Javadoc"", Project.MSG_INFO);
		 Commandline toExecute = (Commandline) cmd.clone();
		 if (executable != null) {
			 toExecute.setExecutable(executable);
		 }
		 else {
			 toExecute.setExecutable(JavaEnvUtils.getJdkExecutable(""javadoc""));
		 }
		 generalJavadocArguments(toExecute);
		 doSourcePath(toExecute, sourceDirs);
		 doDoclet(toExecute);
		 doBootPath(toExecute);
		 doLinks(toExecute);
		 doGroup(toExecute);
		 doGroups(toExecute);
		 doDocFilesSubDirs(toExecute);
		 doJava14(toExecute);
		 if (breakiterator && (doclet == null || JAVADOC_5)) {
			 toExecute.createArgument().setValue(""-breakiterator"");
		 }
		 if (useExternalFile) {
			 writeExternalArgs(toExecute);
		 }
		 File tmpList = null;
		 BufferedWriter srcListWriter = null;
		 try {
			 if (useExternalFile) {
				 tmpList = FILE_UTILS.createTempFile(""javadoc"", """", null, true, true);
				 toExecute.createArgument() .setValue(""@"" + tmpList.getAbsolutePath());
				 srcListWriter = new BufferedWriter( new FileWriter(tmpList.getAbsolutePath(), true));
			 }
			 doSourceAndPackageNames( toExecute, packagesToDoc, sourceFilesToDoc, useExternalFile, tmpList, srcListWriter);
		 }
		 catch (IOException e) {
			 tmpList.delete();
			 throw new BuildException(""Error creating temporary file"", e, getLocation());
		 }
		 finally {
			 FileUtils.close(srcListWriter);
		 }
		 if (packageList != null) {
			 toExecute.createArgument().setValue(""@"" + packageList);
		 }
		 log(toExecute.describeCommand(), Project.MSG_VERBOSE);
		 log(""Javadoc execution"", Project.MSG_INFO);
		 JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
		 JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
		 Execute exe = new Execute(new PumpStreamHandler(out, err));
		 exe.setAntRun(getProject());
		 exe.setWorkingDirectory(null);
		 try {
			 exe.setCommandline(toExecute.getCommandline());
			 int ret = exe.execute();
			 if (ret != 0 && failOnError) {
				 throw new BuildException(""Javadoc returned "" + ret, getLocation());
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(""Javadoc failed: "" + e, e, getLocation());
		 }
		 finally {
			 if (tmpList != null) {
				 tmpList.delete();
				 tmpList = null;
			 }
			 out.logFlush();
			 err.logFlush();
			 try {
				 out.close();
				 err.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 private void checkTaskName() {
		 if (""javadoc2"".equals(getTaskType())) {
			 log(""Warning: the task name <javadoc2> is deprecated."" + "" Use <javadoc> instead."", Project.MSG_WARN);
		 }
	 }
	 private void checkPackageAndSourcePath() {
		 if (packageList != null && sourcePath == null) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying packagelist."";
			 throw new BuildException(msg);
		 }
	 }
	 private void checkPackages(Vector packagesToDoc, Path sourceDirs) {
		 if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying package names."";
			 throw new BuildException(msg);
		 }
	 }
	 private void checkPackagesToDoc( Vector packagesToDoc, Vector sourceFilesToDoc) {
		 if (packageList == null && packagesToDoc.size() == 0 && sourceFilesToDoc.size() == 0) {
			 throw new BuildException(""No source files and no packages have "" + ""been specified."");
		 }
	 }
	 private void doSourcePath(Commandline toExecute, Path sourceDirs) {
		 if (sourceDirs.size() > 0) {
			 toExecute.createArgument().setValue(""-sourcepath"");
			 toExecute.createArgument().setPath(sourceDirs);
		 }
	 }
	 private void generalJavadocArguments(Commandline toExecute) {
		 if (doctitle != null) {
			 toExecute.createArgument().setValue(""-doctitle"");
			 toExecute.createArgument().setValue(expand(doctitle.getText()));
		 }
		 if (header != null) {
			 toExecute.createArgument().setValue(""-header"");
			 toExecute.createArgument().setValue(expand(header.getText()));
		 }
		 if (footer != null) {
			 toExecute.createArgument().setValue(""-footer"");
			 toExecute.createArgument().setValue(expand(footer.getText()));
		 }
		 if (bottom != null) {
			 toExecute.createArgument().setValue(""-bottom"");
			 toExecute.createArgument().setValue(expand(bottom.getText()));
		 }
		 if (classpath == null) {
			 classpath = (new Path(getProject())).concatSystemClasspath(""last"");
		 }
		 else {
			 classpath = classpath.concatSystemClasspath(""ignore"");
		 }
		 if (classpath.size() > 0) {
			 toExecute.createArgument().setValue(""-classpath"");
			 toExecute.createArgument().setPath(classpath);
		 }
		 if (version && doclet == null) {
			 toExecute.createArgument().setValue(""-version"");
		 }
		 if (author && doclet == null) {
			 toExecute.createArgument().setValue(""-author"");
		 }
		 if (doclet == null && destDir == null) {
			 throw new BuildException(""destdir attribute must be set!"");
		 }
	 }
	 private void doDoclet(Commandline toExecute) {
		 if (doclet != null) {
			 if (doclet.getName() == null) {
				 throw new BuildException(""The doclet name must be "" + ""specified."", getLocation());
			 }
			 else {
				 toExecute.createArgument().setValue(""-doclet"");
				 toExecute.createArgument().setValue(doclet.getName());
				 if (doclet.getPath() != null) {
					 Path docletPath = doclet.getPath().concatSystemClasspath(""ignore"");
					 if (docletPath.size() != 0) {
						 toExecute.createArgument().setValue(""-docletpath"");
						 toExecute.createArgument().setPath(docletPath);
					 }
				 }
				 for (Enumeration e = doclet.getParams();
				 e.hasMoreElements();
				) {
					 DocletParam param = (DocletParam) e.nextElement();
					 if (param.getName() == null) {
						 throw new BuildException(""Doclet parameters must "" + ""have a name"");
					 }
					 toExecute.createArgument().setValue(param.getName());
					 if (param.getValue() != null) {
						 toExecute.createArgument() .setValue(param.getValue());
					 }
				 }
			 }
		 }
	 }
	 private void writeExternalArgs(Commandline toExecute) {
		 File optionsTmpFile = null;
		 BufferedWriter optionsListWriter = null;
		 try {
			 optionsTmpFile = FILE_UTILS.createTempFile( ""javadocOptions"", """", null, true, true);
			 String[] listOpt = toExecute.getArguments();
			 toExecute.clearArgs();
			 toExecute.createArgument().setValue( ""@"" + optionsTmpFile.getAbsolutePath());
			 optionsListWriter = new BufferedWriter( new FileWriter(optionsTmpFile.getAbsolutePath(), true));
			 for (int i = 0;
			 i < listOpt.length;
			 i++) {
				 String string = listOpt[i];
				 if (string.startsWith(""-J-"")) {
					 toExecute.createArgument().setValue(string);
				 }
				 else {
					 if (string.startsWith(""-"")) {
						 optionsListWriter.write(string);
						 optionsListWriter.write("" "");
					 }
					 else {
						 optionsListWriter.write(quoteString(string));
						 optionsListWriter.newLine();
					 }
				 }
			 }
			 optionsListWriter.close();
		 }
		 catch (IOException ex) {
			 if (optionsTmpFile != null) {
				 optionsTmpFile.delete();
			 }
			 throw new BuildException( ""Error creating or writing temporary file for javadoc options"", ex, getLocation());
		 }
		 finally {
			 FileUtils.close(optionsListWriter);
		 }
	 }
	 private void doBootPath(Commandline toExecute) {
		 Path bcp = new Path(getProject());
		 if (bootclasspath != null) {
			 bcp.append(bootclasspath);
		 }
		 bcp = bcp.concatSystemBootClasspath(""ignore"");
		 if (bcp.size() > 0) {
			 toExecute.createArgument().setValue(""-bootclasspath"");
			 toExecute.createArgument().setPath(bcp);
		 }
	 }
	 private void doLinks(Commandline toExecute) {
		 if (links.size() != 0) {
			 for (Enumeration e = links.elements();
			 e.hasMoreElements();
			) {
				 LinkArgument la = (LinkArgument) e.nextElement();
				 if (la.getHref() == null || la.getHref().length() == 0) {
					 log(""No href was given for the link - skipping"", Project.MSG_VERBOSE);
					 continue;
				 }
				 String link = null;
				 if (la.shouldResolveLink()) {
					 File hrefAsFile = getProject().resolveFile(la.getHref());
					 if (hrefAsFile.exists()) {
						 try {
							 link = FILE_UTILS.getFileURL(hrefAsFile) .toExternalForm();
						 }
						 catch (MalformedURLException ex) {
							 log(""Warning: link location was invalid "" + hrefAsFile, Project.MSG_WARN);
						 }
					 }
				 }
				 if (link == null) {
					 try {
						 URL base = new URL(""file: new URL(base, la.getHref());
						 link = la.getHref();
					 }
					 catch (MalformedURLException mue) {
						 log(""Link href \"""" + la.getHref() + ""\"" is not a valid url - skipping link"", Project.MSG_WARN);
						 continue;
					 }
				 }
				 if (la.isLinkOffline()) {
					 File packageListLocation = la.getPackagelistLoc();
					 URL packageListURL = la.getPackagelistURL();
					 if (packageListLocation == null && packageListURL == null) {
						 throw new BuildException(""The package list"" + "" location for link "" + la.getHref() + "" must be provided "" + ""because the link is "" + ""offline"");
					 }
					 if (packageListLocation != null) {
						 File packageListFile = new File(packageListLocation, ""package-list"");
						 if (packageListFile.exists()) {
							 try {
								 packageListURL = FILE_UTILS.getFileURL(packageListLocation);
							 }
							 catch (MalformedURLException ex) {
								 log(""Warning: Package list location was "" + ""invalid "" + packageListLocation, Project.MSG_WARN);
							 }
						 }
						 else {
							 log(""Warning: No package list was found at "" + packageListLocation, Project.MSG_VERBOSE);
						 }
					 }
					 if (packageListURL != null) {
						 toExecute.createArgument().setValue(""-linkoffline"");
						 toExecute.createArgument().setValue(link);
						 toExecute.createArgument() .setValue(packageListURL.toExternalForm());
					 }
				 }
				 else {
					 toExecute.createArgument().setValue(""-link"");
					 toExecute.createArgument().setValue(link);
				 }
			 }
		 }
	 }
	 private void doGroup(Commandline toExecute) {
		 if (group != null) {
			 StringTokenizer tok = new StringTokenizer(group, "","", false);
			 while (tok.hasMoreTokens()) {
				 String grp = tok.nextToken().trim();
				 int space = grp.indexOf("" "");
				 if (space > 0) {
					 String name = grp.substring(0, space);
					 String pkgList = grp.substring(space + 1);
					 toExecute.createArgument().setValue(""-group"");
					 toExecute.createArgument().setValue(name);
					 toExecute.createArgument().setValue(pkgList);
				 }
			 }
		 }
	 }
	 private void doGroups(Commandline toExecute) {
		 if (groups.size() != 0) {
			 for (Enumeration e = groups.elements();
			 e.hasMoreElements();
			) {
				 GroupArgument ga = (GroupArgument) e.nextElement();
				 String title = ga.getTitle();
				 String packages = ga.getPackages();
				 if (title == null || packages == null) {
					 throw new BuildException(""The title and packages must "" + ""be specified for group "" + ""elements."");
				 }
				 toExecute.createArgument().setValue(""-group"");
				 toExecute.createArgument().setValue(expand(title));
				 toExecute.createArgument().setValue(packages);
			 }
		 }
	 }
	 private void doJava14(Commandline toExecute) {
		 for (Enumeration e = tags.elements();
		 e.hasMoreElements();
		) {
			 Object element = e.nextElement();
			 if (element instanceof TagArgument) {
				 TagArgument ta = (TagArgument) element;
				 File tagDir = ta.getDir(getProject());
				 if (tagDir == null) {
					 toExecute.createArgument().setValue (""-tag"");
					 toExecute.createArgument() .setValue (ta.getParameter());
				 }
				 else {
					 DirectoryScanner tagDefScanner = ta.getDirectoryScanner(getProject());
					 String[] files = tagDefScanner.getIncludedFiles();
					 for (int i = 0;
					 i < files.length;
					 i++) {
						 File tagDefFile = new File(tagDir, files[i]);
						 try {
							 BufferedReader in = new BufferedReader( new FileReader(tagDefFile) );
							 String line = null;
							 while ((line = in.readLine()) != null) {
								 toExecute.createArgument() .setValue(""-tag"");
								 toExecute.createArgument() .setValue(line);
							 }
							 in.close();
						 }
						 catch (IOException ioe) {
							 throw new BuildException( ""Couldn't read "" + "" tag file from "" + tagDefFile.getAbsolutePath(), ioe);
						 }
					 }
				 }
			 }
			 else {
				 ExtensionInfo tagletInfo = (ExtensionInfo) element;
				 toExecute.createArgument().setValue(""-taglet"");
				 toExecute.createArgument().setValue(tagletInfo .getName());
				 if (tagletInfo.getPath() != null) {
					 Path tagletPath = tagletInfo.getPath() .concatSystemClasspath(""ignore"");
					 if (tagletPath.size() != 0) {
						 toExecute.createArgument() .setValue(""-tagletpath"");
						 toExecute.createArgument().setPath(tagletPath);
					 }
				 }
			 }
		 }
		 String sourceArg = source != null ? source : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
		 if (sourceArg != null) {
			 toExecute.createArgument().setValue(""-source"");
			 toExecute.createArgument().setValue(sourceArg);
		 }
		 if (linksource && doclet == null) {
			 toExecute.createArgument().setValue(""-linksource"");
		 }
		 if (noqualifier != null && doclet == null) {
			 toExecute.createArgument().setValue(""-noqualifier"");
			 toExecute.createArgument().setValue(noqualifier);
		 }
	 }
	 private void doDocFilesSubDirs(Commandline toExecute) {
		 if (docFilesSubDirs) {
			 toExecute.createArgument().setValue(""-docfilessubdirs"");
			 if (excludeDocFilesSubDir != null && excludeDocFilesSubDir.trim().length() > 0) {
				 toExecute.createArgument().setValue(""-excludedocfilessubdir"");
				 toExecute.createArgument().setValue(excludeDocFilesSubDir);
			 }
		 }
	 }
	 private void doSourceAndPackageNames( Commandline toExecute, Vector packagesToDoc, Vector sourceFilesToDoc, boolean useExternalFile, File tmpList, BufferedWriter srcListWriter) throws IOException {
		 Enumeration e = packagesToDoc.elements();
		 while (e.hasMoreElements()) {
			 String packageName = (String) e.nextElement();
			 if (useExternalFile) {
				 srcListWriter.write(packageName);
				 srcListWriter.newLine();
			 }
			 else {
				 toExecute.createArgument().setValue(packageName);
			 }
		 }
		 e = sourceFilesToDoc.elements();
		 while (e.hasMoreElements()) {
			 SourceFile sf = (SourceFile) e.nextElement();
			 String sourceFileName = sf.getFile().getAbsolutePath();
			 if (useExternalFile) {
				 if (sourceFileName.indexOf("" "") > -1) {
					 String name = sourceFileName;
					 if (File.separatorChar == '\\') {
						 name = sourceFileName.replace(File.separatorChar, '/');
					 }
					 srcListWriter.write(""\"""" + name + ""\"""");
				 }
				 else {
					 srcListWriter.write(sourceFileName);
				 }
				 srcListWriter.newLine();
			 }
			 else {
				 toExecute.createArgument().setValue(sourceFileName);
			 }
		 }
	 }
	 private String quoteString(final String str) {
		 if (!containsWhitespace(str) && str.indexOf('\'') == -1 && str.indexOf('""') == -1) {
			 return str;
		 }
		 if (str.indexOf('\'') == -1) {
			 return quoteString(str, '\'');
		 }
		 else {
			 return quoteString(str, '""');
		 }
	 }
	 private boolean containsWhitespace(final String s) {
		 final int len = s.length();
		 for (int i = 0;
		 i < len;
		 i++) {
			 if (Character.isWhitespace(s.charAt(i))) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private String quoteString(final String str, final char delim) {
		 StringBuffer buf = new StringBuffer(str.length() * 2);
		 buf.append(delim);
		 final int len = str.length();
		 boolean lastCharWasCR = false;
		 for (int i = 0;
		 i < len;
		 i++) {
			 char c = str.charAt(i);
			 if (c == delim) {
				 buf.append('\\').append(c);
				 lastCharWasCR = false;
			 }
			 else {
				 switch (c) {
					 case '\\': buf.append(""\\\\"");
					 lastCharWasCR = false;
					 break;
					 case '\r': buf.append(""\\\r"");
					 lastCharWasCR = true;
					 break;
					 case '\n': if (!lastCharWasCR) {
						 buf.append(""\\\n"");
					 }
					 else {
						 buf.append(""\n"");
					 }
					 lastCharWasCR = false;
					 break;
					 default: buf.append(c);
					 lastCharWasCR = false;
					 break;
				 }
			 }
		 }
		 buf.append(delim);
		 return buf.toString();
	 }
	 private void addSourceFiles(Vector sf) {
		 Iterator e = nestedSourceFiles.iterator();
		 while (e.hasNext()) {
			 ResourceCollection rc = (ResourceCollection) e.next();
			 if (!rc.isFilesystemOnly()) {
				 throw new BuildException(""only file system based resources are"" + "" supported by javadoc"");
			 }
			 if (rc instanceof FileSet) {
				 FileSet fs = (FileSet) rc;
				 if (!fs.hasPatterns() && !fs.hasSelectors()) {
					 FileSet fs2 = (FileSet) fs.clone();
					 fs2.createInclude().setName(""**package.html"");
				 }
				 rc = fs2;
			 }
		 }
		 Iterator iter = rc.iterator();
		 while (iter.hasNext()) {
			 Resource r = (Resource) iter.next();
			 sf.addElement(new SourceFile(((FileProvider) r.as(FileProvider.class)) .getFile()));
		 }
	 }
 }
 private void parsePackages(Vector pn, Path sp) {
	 HashSet addedPackages = new HashSet();
	 Vector dirSets = (Vector) packageSets.clone();
	 if (sourcePath != null) {
		 PatternSet ps = new PatternSet();
		 ps.setProject(getProject());
		 if (packageNames.size() > 0) {
			 Enumeration e = packageNames.elements();
			 while (e.hasMoreElements()) {
				 PackageName p = (PackageName) e.nextElement();
				 String pkg = p.getName().replace('.', '/');
				 if (pkg.endsWith(""*"")) {
					 pkg += ""*"";
				 }
				 ps.createInclude().setName(pkg);
			 }
		 }
		 else {
			 ps.createInclude().setName(""**"");
		 }
		 Enumeration e = excludePackageNames.elements();
		 while (e.hasMoreElements()) {
			 PackageName p = (PackageName) e.nextElement();
			 String pkg = p.getName().replace('.', '/');
			 if (pkg.endsWith(""*"")) {
				 pkg += ""*"";
			 }
			 ps.createExclude().setName(pkg);
		 }
		 String[] pathElements = sourcePath.list();
		 for (int i = 0;
		 i < pathElements.length;
		 i++) {
			 File dir = new File(pathElements[i]);
			 if (dir.isDirectory()) {
				 DirSet ds = new DirSet();
				 ds.setProject(getProject());
				 ds.setDefaultexcludes(useDefaultExcludes);
				 ds.setDir(dir);
				 ds.createPatternSet().addConfiguredPatternset(ps);
				 dirSets.addElement(ds);
			 }
			 else {
				 log(""Skipping "" + pathElements[i] + "" since it is no directory."", Project.MSG_WARN);
			 }
		 }
	 }
	 Enumeration e = dirSets.elements();
	 while (e.hasMoreElements()) {
		 DirSet ds = (DirSet) e.nextElement();
		 File baseDir = ds.getDir(getProject());
		 log(""scanning "" + baseDir + "" for packages."", Project.MSG_DEBUG);
		 DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
		 String[] dirs = dsc.getIncludedDirectories();
		 boolean containsPackages = false;
		 for (int i = 0;
		 i < dirs.length;
		 i++) {
			 File pd = new File(baseDir, dirs[i]);
			 String[] files = pd.list(new FilenameFilter () {
				 public boolean accept(File dir1, String name) {
					 return name.endsWith("".java"") || (includeNoSourcePackages && name.equals(""package.html""));
				 }
			 }
			);
			 if (files.length > 0) {
				 if ("""".equals(dirs[i])) {
					 log(baseDir + "" contains source files in the default package,"" + "" you must specify them as source files"" + "" not packages."", Project.MSG_WARN);
				 }
				 else {
					 containsPackages = true;
					 String packageName = dirs[i].replace(File.separatorChar, '.');
					 if (!addedPackages.contains(packageName)) {
						 addedPackages.add(packageName);
						 pn.addElement(packageName);
					 }
				 }
			 }
		 }
		 if (containsPackages) {
			 sp.createPathElement().setLocation(baseDir);
		 }
		 else {
			 log(baseDir + "" doesn\'t contain any packages, dropping it."", Project.MSG_VERBOSE);
		 }
	 }
 }
 private class JavadocOutputStream extends LogOutputStream {
	 JavadocOutputStream(int level) {
		 super(Javadoc.this, level);
	 }
	 private String queuedLine = null;
	 protected void processLine(String line, int messageLevel) {
		 if (messageLevel == Project.MSG_INFO && line.startsWith(""Generating "")) {
			 if (queuedLine != null) {
				 super.processLine(queuedLine, Project.MSG_VERBOSE);
			 }
			 queuedLine = line;
		 }
		 else {
			 if (queuedLine != null) {
				 if (line.startsWith(""Building "")) {
					 super.processLine(queuedLine, Project.MSG_VERBOSE);
				 }
				 else {
					 super.processLine(queuedLine, Project.MSG_INFO);
				 }
				 queuedLine = null;
			 }
			 super.processLine(line, messageLevel);
		 }
	 }
	 protected void logFlush() {
		 if (queuedLine != null) {
			 super.processLine(queuedLine, Project.MSG_VERBOSE);
			 queuedLine = null;
		 }
	 }
 }
 protected String expand(String content) {
	 return getProject().replaceProperties(content);
 }
}",1,0,0,0
"public final class DataOutputBuffer extends DataOutputStream{
	 public DataOutputBuffer() {
		 this(128);
	 }
	 public DataOutputBuffer(int size) {
		 super(new OutputBuffer(size));
	 }
	 private OutputBuffer buffer() {
		 return (OutputBuffer)out;
	 }
	 public byte[] getData() {
		 return buffer().getData();
	 }
	 public int getLength() {
		 return buffer().getLength();
	 }
	 public DataOutputBuffer reset() {
		 this.written = 0;
		 buffer().reset();
		 return this;
	 }
}",0,0,0,0
"public class JSONMaker implements JSONHandler{
	 public JSONMaker() {
	}
	 private JsonValue value = null ;
	 private Deque<JsonArray> arrays = new ArrayDeque<>();
	 private Deque<JsonObject> objects = new ArrayDeque<>();
	 private Deque<String> keys = new ArrayDeque<>();
	 public JsonValue jsonValue() {
		 return value ;
	 }
	 public void startParse(long currLine, long currCol) {
	}
	 public void finishParse(long currLine, long currCol) {
	}
	 public void startObject(long currLine, long currCol) {
		 objects.push(new JsonObject()) ;
	 }
	 public void finishObject(long currLine, long currCol) {
		 value = objects.pop() ;
	 }
	 public void startArray(long currLine, long currCol) {
		 arrays.push(new JsonArray()) ;
	 }
	 public void element(long currLine, long currCol) {
		 arrays.peek().add(value) ;
		 value = null ;
	 }
	 public void finishArray(long currLine, long currCol) {
		 value = arrays.pop() ;
	 }
	 public void startPair(long currLine, long currCol) {
	 }
	 public void keyPair(long currLine, long currCol) {
		 keys.push(value.getAsString().value()) ;
	 }
	 public void finishPair(long currLine, long currCol) {
		 if ( value == null ) throw new InternalErrorException(""null for 'value' (bad finishPair() allignment)"") ;
		 String k = keys.pop();
		 JsonObject obj = objects.peek() ;
		 if ( obj.hasKey(k) ) Log.warn(""JSON"", ""Duplicate key '""+k+""' for object [""+currLine+"",""+currCol+""]"") ;
		 obj.put(k, value) ;
		 value = null ;
	 }
	 public void valueBoolean(boolean b, long currLine, long currCol) {
		 value = new JsonBoolean(b) ;
	 }
	 public void valueDecimal(String image, long currLine, long currCol) {
		 value = JsonNumber.valueDecimal(image) ;
	 }
	 public void valueDouble(String image, long currLine, long currCol) {
		 value = JsonNumber.valueDouble(image) ;
	 }
	 public void valueInteger(String image, long currLine, long currCol) {
		 value = JsonNumber.valueInteger(image) ;
	 }
	 public void valueNull(long currLine, long currCol) {
		 value = JsonNull.instance ;
	 }
	 public void valueString(String image, long currLine, long currCol) {
		 value = new JsonString(image) ;
	 }
}",0,0,0,0
"DOMOutput.java:tabSize=4:indentSize=4:noTabs=true::folding=explicit:collapseFolds=1:Copyright (C) 2002 Ian Lewis (IanLewis)This program is free software;
 you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation;
 either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY;
 without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program;
 if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.Optionally, you may find a copy of the GNU General Public Licensefrom http:public class DOMOutput implements LSOutput {
	 public DOMOutput(OutputStream byteStream, String encoding) {
		 m_byteStream = byteStream;
		 m_encoding = encoding;
	 }
	 public DOMOutput(String systemId, String encoding) {
		 m_systemId = systemId;
		 m_encoding = encoding;
	 }
	 public DOMOutput(Writer characterStream) {
		 m_characterStream = characterStream;
	 }
	 public OutputStream getByteStream() {
		 return m_byteStream;
	 }
	 public Writer getCharacterStream() {
		 return m_characterStream;
	 }
	 public String getEncoding() {
		 return m_encoding;
	 }
	 public String getSystemId() {
		 return m_systemId;
	 }
	 public void setByteStream(OutputStream byteStream) {
		 m_byteStream = byteStream;
	 }
	 public void setCharacterStream(Writer characterStream) {
		 m_characterStream = characterStream;
	 }
	 public void setEncoding(String encoding) {
		 m_encoding = encoding;
	 }
	 public void setSystemId(String systemId) {
		 m_systemId = systemId;
	 }
	 private OutputStream m_byteStream;
	 private Writer m_characterStream;
	 private String m_systemId;
	 private String m_encoding;
}",0,1,0,0
"public String command() {
	 String flags;
	 if (add) {
		 flags = "" +FLAGS "";
	 }
	 else if (subtract) {
		 flags = "" -FLAGS "";
	 }
	 else {
		 flags = "" FLAGS "";
	 }
	 if (silent) {
		 flags = flags + "".SILENT"";
	 }
	 return ""STORE "" + msn + flags + this.flags + "")"";
 }",0,0,1,0
"class FSNamesystem implements FSConstants {
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.fs.FSNamesystem"");
	 FSDirectory dir;
	 Map blocksMap = new HashMap();
	 TreeMap datanodeMap = new TreeMap();
	 TreeMap recentInvalidateSets = new TreeMap();
	 TreeMap excessReplicateMap = new TreeMap();
	 TreeMap pendingCreates = new TreeMap();
	 TreeSet pendingCreateBlocks = new TreeSet();
	 long totalCapacity = 0, totalRemaining = 0;
	 StatusHttpServer infoServer;
	 int infoPort;
	 Date startTime;
	 Random r = new Random();
	 TreeSet heartbeats = new TreeSet(new Comparator() {
		 public int compare(Object o1, Object o2) {
			 DatanodeDescriptor d1 = (DatanodeDescriptor) o1;
			 DatanodeDescriptor d2 = (DatanodeDescriptor) o2;
			 long lu1 = d1.getLastUpdate();
			 long lu2 = d2.getLastUpdate();
			 if (lu1 < lu2) {
				 return -1;
			 }
			 else if (lu1 > lu2) {
				 return 1;
			 }
			 else {
				 return d1.getStorageID().compareTo(d2.getStorageID());
			 }
		 }
	 }
	);
	 private TreeSet neededReplications = new TreeSet();
	 private TreeSet pendingReplications = new TreeSet();
	 private TreeMap leases = new TreeMap();
	 private TreeSet sortedLeases = new TreeSet();
	 HeartbeatMonitor hbmon = null;
	 LeaseMonitor lmon = null;
	 Daemon hbthread = null, lmthread = null;
	 boolean fsRunning = true;
	 long systemStart = 0;
	 private int maxReplication;
	 private int maxReplicationStreams;
	 private int minReplication;
	 private int heartBeatRecheck;
	 public static FSNamesystem fsNamesystemObject;
	 private String localMachine;
	 private int port;
	 public FSNamesystem(File dir, Configuration conf) throws IOException {
		 fsNamesystemObject = this;
		 this.infoPort = conf.getInt(""dfs.info.port"", 50070);
		 this.infoServer = new StatusHttpServer(""dfs"", infoPort, false);
		 this.infoServer.start();
		 InetSocketAddress addr = DataNode.createSocketAddr(conf.get(""fs.default.name"", ""local""));
		 this.localMachine = addr.getHostName();
		 this.port = addr.getPort();
		 this.dir = new FSDirectory(dir);
		 this.dir.loadFSImage( conf );
		 this.hbthread = new Daemon(new HeartbeatMonitor());
		 this.lmthread = new Daemon(new LeaseMonitor());
		 hbthread.start();
		 lmthread.start();
		 this.systemStart = System.currentTimeMillis();
		 this.startTime = new Date(systemStart);
		 this.maxReplication = conf.getInt(""dfs.replication.max"", 512);
		 this.minReplication = conf.getInt(""dfs.replication.min"", 1);
		 if( maxReplication < minReplication ) throw new IOException( ""Unexpected configuration parameters: dfs.replication.min = "" + minReplication + "" must be less than dfs.replication.max = "" + maxReplication );
		 this.maxReplicationStreams = conf.getInt(""dfs.max-repl-streams"", 2);
		 this.heartBeatRecheck= 1000;
	 }
	 public static FSNamesystem getFSNamesystem() {
		 return fsNamesystemObject;
	 }
	 public void close() {
		 synchronized (this) {
			 fsRunning = false;
		 }
		 try {
			 infoServer.stop();
			 hbthread.join(3000);
		 }
		 catch (InterruptedException ie) {
		 }
		 finally {
			 try {
				 lmthread.join(3000);
			 }
			 catch (InterruptedException ie) {
			 }
			 finally {
				 try {
					 dir.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 public Object[] open(UTF8 src) {
		 Object results[] = null;
		 Block blocks[] = dir.getFile(src);
		 if (blocks != null) {
			 results = new Object[2];
			 DatanodeDescriptor machineSets[][] = new DatanodeDescriptor[blocks.length][];
			 for (int i = 0;
			 i < blocks.length;
			 i++) {
				 TreeSet containingNodes = (TreeSet) blocksMap.get(blocks[i]);
				 if (containingNodes == null) {
					 machineSets[i] = new DatanodeDescriptor[0];
				 }
				 else {
					 machineSets[i] = new DatanodeDescriptor[containingNodes.size()];
					 int j = 0;
					 for (Iterator it = containingNodes.iterator();
					 it.hasNext();
					 j++) {
						 machineSets[i][j] = (DatanodeDescriptor) it.next();
					 }
				 }
			 }
			 results[0] = blocks;
			 results[1] = machineSets;
		 }
		 return results;
	 }
	 public boolean setReplication(String src, short replication ) throws IOException {
		 verifyReplication(src, replication, null );
		 Vector oldReplication = new Vector();
		 Block[] fileBlocks;
		 fileBlocks = dir.setReplication( src, replication, oldReplication );
		 if( fileBlocks == null ) return false;
		 int oldRepl = ((Integer)oldReplication.elementAt(0)).intValue();
		 if( oldRepl == replication ) return true;
		 synchronized( neededReplications ) {
			 if( oldRepl < replication ) {
				 LOG.info(""Increasing replication for file "" + src + "". New replication is "" + replication );
				 for( int idx = 0;
				 idx < fileBlocks.length;
				 idx++ ) neededReplications.add( fileBlocks[idx] );
			 }
			 else {
				 LOG.info(""Reducing replication for file "" + src + "". New replication is "" + replication );
				 for( int idx = 0;
				 idx < fileBlocks.length;
				 idx++ ) proccessOverReplicatedBlock( fileBlocks[idx], replication );
			 }
		 }
		 return true;
	 }
	 public long getBlockSize(String filename) throws IOException {
		 return dir.getBlockSize(filename);
	 }
	 private void verifyReplication( String src, short replication, UTF8 clientName ) throws IOException {
		 String text = ""file "" + src + ((clientName != null) ? "" on client "" + clientName : """") + "".\n"" + ""Requested replication "" + replication;
		 if( replication > maxReplication ) throw new IOException( text + "" exceeds maximum "" + maxReplication );
		 if( replication < minReplication ) throw new IOException( text + "" is less than the required minimum "" + minReplication );
	 }
	 public synchronized Object[] startFile( UTF8 src, UTF8 holder, UTF8 clientMachine, boolean overwrite, short replication, long blockSize ) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.startFile: file "" +src+"" for ""+holder+"" at ""+clientMachine);
		 try {
			 if (pendingCreates.get(src) != null) {
				 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because pendingCreates is non-null."");
			 }
			 try {
				 verifyReplication(src.toString(), replication, clientMachine );
			 }
			 catch( IOException e) {
				 throw new IOException( ""failed to create ""+e.getMessage());
			 }
			 if (!dir.isValidToCreate(src)) {
				 if (overwrite) {
					 delete(src);
				 }
				 else {
					 throw new IOException(""failed to create file "" + src +"" on client "" + clientMachine +"" either because the filename is invalid or the file exists"");
				 }
			 }
			 DatanodeDescriptor targets[] = chooseTargets(replication, null, clientMachine, blockSize);
			 if (targets.length < this.minReplication) {
				 throw new IOException(""failed to create file ""+src +"" on client "" + clientMachine +"" because target-length is "" + targets.length +"", below MIN_REPLICATION ("" + minReplication+ "")"");
			 }
			 pendingCreates.put(src, new FileUnderConstruction(replication, blockSize, holder, clientMachine));
			 NameNode.stateChangeLog.debug( ""DIR* NameSystem.startFile: "" +""add ""+src+"" to pendingCreates for ""+holder );
			 synchronized (leases) {
				 Lease lease = (Lease) leases.get(holder);
				 if (lease == null) {
					 lease = new Lease(holder);
					 leases.put(holder, lease);
					 sortedLeases.add(lease);
				 }
				 else {
					 sortedLeases.remove(lease);
					 lease.renew();
					 sortedLeases.add(lease);
				 }
				 lease.startedCreate(src);
			 }
			 Object results[] = new Object[2];
			 results[0] = allocateBlock(src);
			 results[1] = targets;
			 return results;
		 }
		 catch (IOException ie) {
			 NameNode.stateChangeLog.warn(""DIR* NameSystem.startFile: "" +ie.getMessage());
			 throw ie;
		 }
	 }
	 public synchronized Object[] getAdditionalBlock(UTF8 src, UTF8 clientName ) throws IOException {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.getAdditionalBlock: file "" +src+"" for ""+clientName);
		 FileUnderConstruction pendingFile = (FileUnderConstruction) pendingCreates.get(src);
		 if (pendingFile == null) {
			 throw new LeaseExpiredException(""No lease on "" + src);
		 }
		 if (!pendingFile.getClientName().equals(clientName)) {
			 throw new LeaseExpiredException(""Lease mismatch on "" + src + "" owned by "" + pendingFile.getClientName() + "" and appended by "" + clientName);
		 }
		 if (dir.getFile(src) != null) {
			 throw new IOException(""File "" + src + "" created during write"");
		 }
		 if (!checkFileProgress(src)) {
			 throw new NotReplicatedYetException(""Not replicated yet"");
		 }
		 DatanodeDescriptor targets[] = chooseTargets(pendingFile.getReplication(), null, pendingFile.getClientMachine(), pendingFile.getBlockSize());
		 if (targets.length < this.minReplication) {
			 throw new IOException(""File "" + src + "" could only be replicated to "" + targets.length + "" nodes, instead of "" + minReplication);
		 }
		 return new Object[]{
		allocateBlock(src), targets}
		;
	 }
	 public synchronized boolean abandonBlock(Block b, UTF8 src) {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.abandonBlock: "" +b.getBlockName()+""of file ""+src );
		 FileUnderConstruction pendingFile = (FileUnderConstruction) pendingCreates.get(src);
		 if (pendingFile != null) {
			 Vector pendingVector = pendingFile.getBlocks();
			 for (Iterator it = pendingVector.iterator();
			 it.hasNext();
			 ) {
				 Block cur = (Block) it.next();
				 if (cur.compareTo(b) == 0) {
					 pendingCreateBlocks.remove(cur);
					 it.remove();
					 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.abandonBlock: "" +b.getBlockName() +"" is removed from pendingCreateBlock and pendingCreates"");
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 public synchronized void abandonFileInProgress(UTF8 src, UTF8 holder ) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.abandonFileInProgress:"" + src );
		 synchronized (leases) {
			 Lease lease = (Lease) leases.get(holder);
			 if (lease != null) {
				 if (lease.completedCreate(src)) {
					 internalReleaseCreate(src, holder);
				 }
				 else {
					 LOG.info(""Attempt by "" + holder.toString() + "" to release someone else's create lock on "" + src.toString());
				 }
			 }
			 else {
				 LOG.info(""Attempt to release a lock from an unknown lease holder "" + holder.toString() + "" for "" + src.toString());
			 }
		 }
	 }
	 public synchronized int completeFile(UTF8 src, UTF8 holder) {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.completeFile: "" + src + "" for "" + holder );
		 if (dir.getFile(src) != null || pendingCreates.get(src) == null) {
			 NameNode.stateChangeLog.warn( ""DIR* NameSystem.completeFile: "" + ""failed to complete "" + src + "" because dir.getFile()=="" + dir.getFile(src) + "" and "" + pendingCreates.get(src));
			 return OPERATION_FAILED;
		 }
		 else if (! checkFileProgress(src)) {
			 return STILL_WAITING;
		 }
		 FileUnderConstruction pendingFile = (FileUnderConstruction) pendingCreates.get(src);
		 Vector blocks = pendingFile.getBlocks();
		 int nrBlocks = blocks.size();
		 Block pendingBlocks[] = (Block[]) blocks.toArray(new Block[nrBlocks]);
		 for (int i = 0;
		 i < nrBlocks;
		 i++) {
			 Block b = (Block)pendingBlocks[i];
			 TreeSet containingNodes = (TreeSet) blocksMap.get(b);
			 DatanodeDescriptor node = (DatanodeDescriptor) containingNodes.first();
			 for (Iterator it = node.getBlockIterator();
			 it.hasNext();
			 ) {
				 Block cur = (Block) it.next();
				 if (b.getBlockId() == cur.getBlockId()) {
					 b.setNumBytes(cur.getNumBytes());
					 break;
				 }
			 }
		 }
		 if ( ! dir.addFile(src, pendingBlocks, pendingFile.getReplication())) {
			 return OPERATION_FAILED;
		 }
		 pendingCreates.remove(src);
		 NameNode.stateChangeLog.debug( ""DIR* NameSystem.completeFile: "" + src + "" is removed from pendingCreates"");
		 for (int i = 0;
		 i < nrBlocks;
		 i++) {
			 pendingCreateBlocks.remove(pendingBlocks[i]);
		 }
		 synchronized (leases) {
			 Lease lease = (Lease) leases.get(holder);
			 if (lease != null) {
				 lease.completedCreate(src);
				 if (! lease.hasLocks()) {
					 leases.remove(holder);
					 sortedLeases.remove(lease);
				 }
			 }
		 }
		 for (int i = 0;
		 i < nrBlocks;
		 i++) {
			 TreeSet containingNodes = (TreeSet) blocksMap.get(pendingBlocks[i]);
			 if (containingNodes.size() < pendingFile.getReplication()) {
				 NameNode.stateChangeLog.debug( ""DIR* NameSystem.completeFile:"" + pendingBlocks[i].getBlockName()+"" has only ""+containingNodes.size() +"" replicas so is added to neededReplications"");
				 synchronized (neededReplications) {
					 neededReplications.add(pendingBlocks[i]);
				 }
			 }
		 }
		 return COMPLETE_SUCCESS;
	 }
	 static Random randBlockId = new Random();
	 synchronized Block allocateBlock(UTF8 src) {
		 Block b = null;
		 do {
			 b = new Block(FSNamesystem.randBlockId.nextLong(), 0);
		 }
		 while (dir.isValidBlock(b));
		 FileUnderConstruction v = (FileUnderConstruction) pendingCreates.get(src);
		 v.getBlocks().add(b);
		 pendingCreateBlocks.add(b);
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.allocateBlock: "" +src+ "". ""+b.getBlockName()+ "" is created and added to pendingCreates and pendingCreateBlocks"" );
		 return b;
	 }
	 synchronized boolean checkFileProgress(UTF8 src) {
		 FileUnderConstruction v = (FileUnderConstruction) pendingCreates.get(src);
		 for (Iterator it = v.getBlocks().iterator();
		 it.hasNext();
		 ) {
			 Block b = (Block) it.next();
			 TreeSet containingNodes = (TreeSet) blocksMap.get(b);
			 if (containingNodes == null || containingNodes.size() < this.minReplication) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public boolean renameTo(UTF8 src, UTF8 dst) {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.renameTo: "" + src + "" to "" + dst );
		 return dir.renameTo(src, dst);
	 }
	 public synchronized boolean delete(UTF8 src) {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.delete: "" + src );
		 Block deletedBlocks[] = (Block[]) dir.delete(src);
		 if (deletedBlocks != null) {
			 for (int i = 0;
			 i < deletedBlocks.length;
			 i++) {
				 Block b = deletedBlocks[i];
				 TreeSet containingNodes = (TreeSet) blocksMap.get(b);
				 if (containingNodes != null) {
					 for (Iterator it = containingNodes.iterator();
					 it.hasNext();
					 ) {
						 DatanodeDescriptor node = (DatanodeDescriptor) it.next();
						 Vector invalidateSet = (Vector) recentInvalidateSets.get(node.getStorageID());
						 if (invalidateSet == null) {
							 invalidateSet = new Vector();
							 recentInvalidateSets.put(node.getStorageID(), invalidateSet);
						 }
						 invalidateSet.add(b);
						 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.delete: "" + b.getBlockName() + "" is added to invalidSet of "" + node.getName() );
					 }
				 }
			 }
		 }
		 return (deletedBlocks != null);
	 }
	 public boolean exists(UTF8 src) {
		 if (dir.getFile(src) != null || dir.isDir(src)) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public boolean isDir(UTF8 src) {
		 return dir.isDir(src);
	 }
	 public boolean mkdirs(UTF8 src) {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.mkdirs: "" + src );
		 return dir.mkdirs(src);
	 }
	 public UTF8[][] getDatanodeHints(UTF8 src, long start, long len) {
		 if (start < 0 || len < 0) {
			 return new UTF8[0][];
		 }
		 int startBlock = -1;
		 int endBlock = -1;
		 Block blocks[] = dir.getFile(src);
		 if (blocks == null) {
			 return new UTF8[0][];
		 }
		 long startpos = start;
		 long endpos = start + len;
		 for (int i = 0;
		 i < blocks.length;
		 i++) {
			 if (startpos >= 0) {
				 startpos -= blocks[i].getNumBytes();
				 if (startpos <= 0) {
					 startBlock = i;
				 }
			 }
			 if (endpos >= 0) {
				 endpos -= blocks[i].getNumBytes();
				 if (endpos <= 0) {
					 endBlock = i;
					 break;
				 }
			 }
		 }
		 if (startBlock < 0 || endBlock < 0) {
			 return new UTF8[0][];
		 }
		 else {
			 UTF8 hosts[][] = new UTF8[(endBlock - startBlock) + 1][];
			 for (int i = startBlock;
			 i <= endBlock;
			 i++) {
				 TreeSet containingNodes = (TreeSet) blocksMap.get(blocks[i]);
				 Vector v = new Vector();
				 if (containingNodes != null) {
					 for (Iterator it =containingNodes.iterator();
					 it.hasNext();
					) {
						 DatanodeDescriptor cur = (DatanodeDescriptor) it.next();
						 v.add(new UTF8( cur.getHost() ));
					 }
				 }
				 hosts[i-startBlock] = (UTF8[]) v.toArray(new UTF8[v.size()]);
			 }
			 return hosts;
		 }
	 }
	 class Lease implements Comparable {
		 public UTF8 holder;
		 public long lastUpdate;
		 private TreeSet locks = new TreeSet();
		 private TreeSet creates = new TreeSet();
		 public Lease(UTF8 holder) {
			 this.holder = holder;
			 renew();
		 }
		 public void renew() {
			 this.lastUpdate = System.currentTimeMillis();
		 }
		 public boolean expired() {
			 if (System.currentTimeMillis() - lastUpdate > LEASE_PERIOD) {
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 public void obtained(UTF8 src) {
			 locks.add(src);
		 }
		 public void released(UTF8 src) {
			 locks.remove(src);
		 }
		 public void startedCreate(UTF8 src) {
			 creates.add(src);
		 }
		 public boolean completedCreate(UTF8 src) {
			 return creates.remove(src);
		 }
		 public boolean hasLocks() {
			 return (locks.size() + creates.size()) > 0;
		 }
		 public void releaseLocks() {
			 for (Iterator it = locks.iterator();
			 it.hasNext();
			 ) {
				 UTF8 src = (UTF8) it.next();
				 internalReleaseLock(src, holder);
			 }
			 locks.clear();
			 for (Iterator it = creates.iterator();
			 it.hasNext();
			 ) {
				 UTF8 src = (UTF8) it.next();
				 internalReleaseCreate(src, holder);
			 }
			 creates.clear();
		 }
		 public String toString() {
			 return ""[Lease. Holder: "" + holder.toString() + "", heldlocks: "" + locks.size() + "", pendingcreates: "" + creates.size() + ""]"";
		 }
		 public int compareTo(Object o) {
			 Lease l1 = (Lease) this;
			 Lease l2 = (Lease) o;
			 long lu1 = l1.lastUpdate;
			 long lu2 = l2.lastUpdate;
			 if (lu1 < lu2) {
				 return -1;
			 }
			 else if (lu1 > lu2) {
				 return 1;
			 }
			 else {
				 return l1.holder.compareTo(l2.holder);
			 }
		 }
	 }
	 class LeaseMonitor implements Runnable {
		 public void run() {
			 while (fsRunning) {
				 synchronized (FSNamesystem.this) {
					 synchronized (leases) {
						 Lease top;
						 while ((sortedLeases.size() > 0) && ((top = (Lease) sortedLeases.first()) != null)) {
							 if (top.expired()) {
								 top.releaseLocks();
								 leases.remove(top.holder);
								 LOG.info(""Removing lease "" + top + "", leases remaining: "" + sortedLeases.size());
								 if (!sortedLeases.remove(top)) {
									 LOG.info(""Unknown failure trying to remove "" + top + "" from lease set."");
								 }
							 }
							 else {
								 break;
							 }
						 }
					 }
				 }
				 try {
					 Thread.sleep(2000);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 public synchronized int obtainLock(UTF8 src, UTF8 holder, boolean exclusive) {
		 int result = dir.obtainLock(src, holder, exclusive);
		 if (result == COMPLETE_SUCCESS) {
			 synchronized (leases) {
				 Lease lease = (Lease) leases.get(holder);
				 if (lease == null) {
					 lease = new Lease(holder);
					 leases.put(holder, lease);
					 sortedLeases.add(lease);
				 }
				 else {
					 sortedLeases.remove(lease);
					 lease.renew();
					 sortedLeases.add(lease);
				 }
				 lease.obtained(src);
			 }
		 }
		 return result;
	 }
	 public synchronized int releaseLock(UTF8 src, UTF8 holder) {
		 int result = internalReleaseLock(src, holder);
		 if (result == COMPLETE_SUCCESS) {
			 synchronized (leases) {
				 Lease lease = (Lease) leases.get(holder);
				 if (lease != null) {
					 lease.released(src);
					 if (! lease.hasLocks()) {
						 leases.remove(holder);
						 sortedLeases.remove(lease);
					 }
				 }
			 }
		 }
		 return result;
	 }
	 private int internalReleaseLock(UTF8 src, UTF8 holder) {
		 return dir.releaseLock(src, holder);
	 }
	 private void internalReleaseCreate(UTF8 src, UTF8 holder) {
		 FileUnderConstruction v = (FileUnderConstruction) pendingCreates.remove(src);
		 if (v != null) {
			 NameNode.stateChangeLog.debug( ""DIR* NameSystem.internalReleaseCreate: "" + src + "" is removed from pendingCreates for "" + holder + "" (failure)"");
			 for (Iterator it2 = v.getBlocks().iterator();
			 it2.hasNext();
			 ) {
				 Block b = (Block) it2.next();
				 pendingCreateBlocks.remove(b);
			 }
		 }
		 else {
			 NameNode.stateChangeLog.warn(""DIR* NameSystem.internalReleaseCreate: "" + ""attempt to release a create lock on ""+ src.toString() + "" that was not in pedingCreates"");
		 }
	 }
	 public void renewLease(UTF8 holder) {
		 synchronized (leases) {
			 Lease lease = (Lease) leases.get(holder);
			 if (lease != null) {
				 sortedLeases.remove(lease);
				 lease.renew();
				 sortedLeases.add(lease);
			 }
		 }
	 }
	 public DFSFileInfo[] getListing(UTF8 src) {
		 return dir.getListing(src);
	 }
	 public synchronized void registerDatanode( DatanodeRegistration nodeReg ) throws IOException {
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""node registration from "" + nodeReg.getName() + "" storage "" + nodeReg.getStorageID() );
		 nodeReg.registrationID = getRegistrationID();
		 DatanodeDescriptor nodeS = (DatanodeDescriptor)datanodeMap.get(nodeReg.getStorageID());
		 DatanodeDescriptor nodeN = getDatanodeByName( nodeReg.getName() );
		 if( nodeN != null && nodeS != null && nodeN == nodeS ) {
			 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""node restarted."" );
			 return;
		 }
		 if( nodeN != null ) {
			 removeDatanode( nodeN );
			 wipeDatanode( nodeN );
			 getEditLog().logRemoveDatanode( nodeN );
			 nodeN = null;
		 }
		 if( nodeS != null ) {
			 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""node "" + nodeS.name + "" is replaced by "" + nodeReg.getName() + ""."" );
			 nodeS.name = nodeReg.getName();
			 return;
		 }
		 if( nodeReg.getStorageID().equals("""") ) {
			 nodeReg.storageID = newStorageID();
			 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""new storageID "" + nodeReg.getStorageID() + "" assigned."" );
		 }
		 DatanodeDescriptor nodeDescr = new DatanodeDescriptor( nodeReg );
		 unprotectedAddDatanode( nodeDescr );
		 getEditLog().logAddDatanode( nodeDescr );
		 return;
	 }
	 public String getRegistrationID() {
		 return ""NS"" + Integer.toString( dir.namespaceID );
	 }
	 private String newStorageID() {
		 String newID = null;
		 while( newID == null ) {
			 newID = ""DS"" + Integer.toString( r.nextInt() );
			 if( datanodeMap.get( newID ) != null ) newID = null;
		 }
		 return newID;
	 }
	 public synchronized void gotHeartbeat(DatanodeID nodeID, long capacity, long remaining, int xceiverCount) throws IOException {
		 synchronized (heartbeats) {
			 synchronized (datanodeMap) {
				 DatanodeDescriptor nodeinfo = getDatanode( nodeID );
				 if (nodeinfo == null) throw new UnregisteredDatanodeException( nodeID );
				 removeHeartbeat(nodeinfo);
				 nodeinfo.updateHeartbeat(capacity, remaining, xceiverCount);
				 addHeartbeat(nodeinfo);
			 }
		 }
	 }
	 class HeartbeatMonitor implements Runnable {
		 public void run() {
			 while (fsRunning) {
				 heartbeatCheck();
				 try {
					 Thread.sleep(heartBeatRecheck);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 synchronized public void removeDatanode( DatanodeID nodeID ) throws IOException {
		 DatanodeDescriptor nodeInfo = getDatanode( nodeID );
		 if (nodeInfo != null) {
			 removeDatanode( nodeInfo );
		 }
		 else {
			 NameNode.stateChangeLog.warn(""BLOCK* NameSystem.removeDatanode: "" + nodeInfo.getName() + "" does not exist"");
		 }
	 }
	 private void removeDatanode( DatanodeDescriptor nodeInfo ) {
		 removeHeartbeat(nodeInfo);
		 Block deadblocks[] = nodeInfo.getBlocks();
		 if( deadblocks != null ) for( int i = 0;
		 i < deadblocks.length;
		 i++ ) removeStoredBlock(deadblocks[i], nodeInfo);
		 unprotectedRemoveDatanode(nodeInfo);
	 }
	 void unprotectedRemoveDatanode( DatanodeDescriptor nodeDescr ) {
		 nodeDescr.resetBlocks();
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.unprotectedRemoveDatanode: "" + nodeDescr.getName() + "" is out of service now."");
	 }
	 void unprotectedAddDatanode( DatanodeDescriptor nodeDescr ) {
		 datanodeMap.put( nodeDescr.getStorageID(), nodeDescr );
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.unprotectedAddDatanode: "" + ""node "" + nodeDescr.getName() + "" is added to datanodeMap."" );
	 }
	 private void addHeartbeat( DatanodeDescriptor nodeDescr ) {
		 heartbeats.add(nodeDescr);
		 totalCapacity += nodeDescr.capacity;
		 totalRemaining += nodeDescr.remaining;
	 }
	 private void removeHeartbeat( DatanodeDescriptor nodeDescr ) {
		 totalCapacity -= nodeDescr.getCapacity();
		 totalRemaining -= nodeDescr.getRemaining();
		 heartbeats.remove(nodeDescr);
	 }
	 void wipeDatanode( DatanodeID nodeID ) {
		 datanodeMap.remove(nodeID.getStorageID());
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.wipeDatanode: "" + nodeID.getName() + "" storage "" + nodeID.getStorageID() + "" is removed from datanodeMap."");
	 }
	 private FSEditLog getEditLog() {
		 return dir.fsImage.getEditLog();
	 }
	 synchronized void heartbeatCheck() {
		 synchronized (heartbeats) {
			 DatanodeDescriptor nodeInfo = null;
			 while ((heartbeats.size() > 0) && ((nodeInfo = (DatanodeDescriptor) heartbeats.first()) != null) && (nodeInfo.isDead())) {
				 NameNode.stateChangeLog.info(""BLOCK* NameSystem.heartbeatCheck: "" + ""lost heartbeat from "" + nodeInfo.getName());
				 removeDatanode( nodeInfo );
			 }
		 }
	 }
	 public synchronized Block[] processReport(DatanodeID nodeID, Block newReport[] ) throws IOException {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.processReport: "" +""from ""+nodeID.getName()+"" ""+newReport.length+"" blocks"" );
		 DatanodeDescriptor node = getDatanode( nodeID );
		 int oldPos = 0, newPos = 0;
		 Block oldReport[] = node.getBlocks();
		 while (oldReport != null && newReport != null && oldPos < oldReport.length && newPos < newReport.length) {
			 int cmp = oldReport[oldPos].compareTo(newReport[newPos]);
			 if (cmp == 0) {
				 oldPos++;
				 newPos++;
			 }
			 else if (cmp < 0) {
				 removeStoredBlock(oldReport[oldPos], node);
				 oldPos++;
			 }
			 else {
				 addStoredBlock(newReport[newPos], node);
				 newPos++;
			 }
		 }
		 while (oldReport != null && oldPos < oldReport.length) {
			 removeStoredBlock(oldReport[oldPos], node);
			 oldPos++;
		 }
		 while (newReport != null && newPos < newReport.length) {
			 addStoredBlock(newReport[newPos], node);
			 newPos++;
		 }
		 node.updateBlocks(newReport);
		 Vector obsolete = new Vector();
		 for (Iterator it = node.getBlockIterator();
		 it.hasNext();
		 ) {
			 Block b = (Block) it.next();
			 if (! dir.isValidBlock(b) && ! pendingCreateBlocks.contains(b)) {
				 obsolete.add(b);
				 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.processReport: "" +""ask ""+nodeID.getName()+"" to delete ""+b.getBlockName() );
			 }
		 }
		 return (Block[]) obsolete.toArray(new Block[obsolete.size()]);
	 }
	 synchronized void addStoredBlock(Block block, DatanodeDescriptor node) {
		 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
		 if (containingNodes == null) {
			 containingNodes = new TreeSet();
			 blocksMap.put(block, containingNodes);
		 }
		 if (! containingNodes.contains(node)) {
			 containingNodes.add(node);
			 NameNode.stateChangeLog.trace(""BLOCK* NameSystem.addStoredBlock: "" +""blockMap updated: ""+node.getName()+"" is added to ""+block.getBlockName() );
		 }
		 else {
			 NameNode.stateChangeLog.warn(""BLOCK* NameSystem.addStoredBlock: "" + ""Redundant addStoredBlock request received for "" + block.getBlockName() + "" on "" + node.getName());
		 }
		 synchronized (neededReplications) {
			 FSDirectory.INode fileINode = dir.getFileByBlock(block);
			 if( fileINode == null ) return;
			 short fileReplication = fileINode.getReplication();
			 if (containingNodes.size() >= fileReplication ) {
				 neededReplications.remove(block);
				 pendingReplications.remove(block);
				 NameNode.stateChangeLog.trace(""BLOCK* NameSystem.addStoredBlock: "" +block.getBlockName()+"" has ""+containingNodes.size() +"" replicas so is removed from neededReplications and pendingReplications"" );
			 }
			 else {
				 neededReplications.add(block);
				 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.addStoredBlock: "" +block.getBlockName()+"" has only ""+containingNodes.size() +"" replicas so is added to neededReplications"" );
			 }
			 proccessOverReplicatedBlock( block, fileReplication );
		 }
	 }
	 private void proccessOverReplicatedBlock( Block block, short replication ) {
		 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
		 if( containingNodes == null ) return;
		 Vector nonExcess = new Vector();
		 for (Iterator it = containingNodes.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor cur = (DatanodeDescriptor) it.next();
			 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get(cur.getStorageID());
			 if (excessBlocks == null || ! excessBlocks.contains(block)) {
				 nonExcess.add(cur);
			 }
		 }
		 chooseExcessReplicates(nonExcess, block, replication);
	 }
	 void chooseExcessReplicates(Vector nonExcess, Block b, short replication) {
		 while (nonExcess.size() - replication > 0) {
			 DatanodeInfo cur = null;
			 long minSpace = Long.MAX_VALUE;
			 for (Iterator iter = nonExcess.iterator();
			 iter.hasNext();
			) {
				 DatanodeInfo node = (DatanodeInfo) iter.next();
				 long free = node.getRemaining();
				 if(minSpace > free) {
					 minSpace = free;
					 cur = node;
				 }
			 }
			 nonExcess.remove(cur);
			 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get(cur.getStorageID());
			 if (excessBlocks == null) {
				 excessBlocks = new TreeSet();
				 excessReplicateMap.put(cur.getStorageID(), excessBlocks);
			 }
			 excessBlocks.add(b);
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.chooseExcessReplicates: "" +""(""+cur.getName()+"", ""+b.getBlockName()+"") is added to excessReplicateMap"" );
			 Vector invalidateSet = (Vector) recentInvalidateSets.get(cur.getStorageID());
			 if (invalidateSet == null) {
				 invalidateSet = new Vector();
				 recentInvalidateSets.put(cur.getStorageID(), invalidateSet);
			 }
			 invalidateSet.add(b);
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.chooseExcessReplicates: "" +""(""+cur.getName()+"", ""+b.getBlockName()+"") is added to recentInvalidateSets"" );
		 }
	 }
	 synchronized void removeStoredBlock(Block block, DatanodeDescriptor node) {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName() + "" from ""+node.getName() );
		 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
		 if (containingNodes == null || ! containingNodes.contains(node)) {
			 throw new IllegalArgumentException(""No machine mapping found for block "" + block + "", which should be at node "" + node);
		 }
		 containingNodes.remove(node);
		 FSDirectory.INode fileINode = dir.getFileByBlock(block);
		 if( fileINode != null && (containingNodes.size() < fileINode.getReplication())) {
			 synchronized (neededReplications) {
				 neededReplications.add(block);
			 }
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName()+"" has only ""+containingNodes.size() +"" replicas so is added to neededReplications"" );
		 }
		 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get(node.getStorageID());
		 if (excessBlocks != null) {
			 excessBlocks.remove(block);
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName()+"" is removed from excessBlocks"" );
			 if (excessBlocks.size() == 0) {
				 excessReplicateMap.remove(node.getStorageID());
			 }
		 }
	 }
	 public synchronized void blockReceived( DatanodeID nodeID, Block block ) throws IOException {
		 DatanodeDescriptor node = getDatanode( nodeID );
		 if (node == null) {
			 NameNode.stateChangeLog.warn(""BLOCK* NameSystem.blockReceived: "" + block.getBlockName() + "" is received from an unrecorded node "" + nodeID.getName() );
			 throw new IllegalArgumentException( ""Unexpected exception. Got blockReceived message from node "" + block.getBlockName() + "", but there is no info for it"");
		 }
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.blockReceived: "" +block.getBlockName()+"" is received from "" + nodeID.getName() );
		 addStoredBlock(block, node);
		 node.addBlock(block);
	 }
	 public long totalCapacity() {
		 return totalCapacity;
	 }
	 public long totalRemaining() {
		 return totalRemaining;
	 }
	 public DatanodeInfo[] datanodeReport() {
		 DatanodeInfo results[] = null;
		 synchronized (heartbeats) {
			 synchronized (datanodeMap) {
				 results = new DatanodeInfo[datanodeMap.size()];
				 int i = 0;
				 for(Iterator it = datanodeMap.values().iterator();
				 it.hasNext();
				 ) results[i++] = new DatanodeInfo( (DatanodeDescriptor)it.next() );
			 }
		 }
		 return results;
	 }
	 public void DFSNodesStatus(Vector live, Vector dead) {
		 synchronized (heartbeats) {
			 synchronized (datanodeMap) {
				 for(Iterator it = datanodeMap.values().iterator();
				 it.hasNext();
				 ) {
					 DatanodeDescriptor node = (DatanodeDescriptor)it.next();
					 if( node.isDead() ) dead.add( node );
					 else live.add( node );
				 }
			 }
		 }
	 }
	 public DatanodeInfo getDataNodeInfo(String name) {
		 return (DatanodeDescriptor)datanodeMap.get(name);
	 }
	 public String getDFSNameNodeMachine() {
		 return localMachine;
	 }
	 public int getDFSNameNodePort() {
		 return port;
	 }
	 public Date getStartTime() {
		 return startTime;
	 }
	 public synchronized Block[] blocksToInvalidate( DatanodeID nodeID ) {
		 Vector invalidateSet = (Vector) recentInvalidateSets.remove( nodeID.getStorageID() );
		 if (invalidateSet == null ) return null;
		 if(NameNode.stateChangeLog.isInfoEnabled()) {
			 StringBuffer blockList = new StringBuffer();
			 for( int i=0;
			 i<invalidateSet.size();
			 i++ ) {
				 blockList.append(' ');
				 blockList.append(((Block)invalidateSet.elementAt(i)).getBlockName());
			 }
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.blockToInvalidate: "" +""ask ""+nodeID.getName()+"" to delete "" + blockList );
		 }
		 return (Block[]) invalidateSet.toArray(new Block[invalidateSet.size()]);
	 }
	 public synchronized Object[] pendingTransfers(DatanodeID srcNode, int xmitsInProgress) {
		 synchronized (neededReplications) {
			 Object results[] = null;
			 int scheduledXfers = 0;
			 if (neededReplications.size() > 0) {
				 Vector replicateBlocks = new Vector();
				 Vector replicateTargetSets = new Vector();
				 for (Iterator it = neededReplications.iterator();
				 it.hasNext();
				) {
					 if (scheduledXfers >= this.maxReplicationStreams - xmitsInProgress) {
						 break;
					 }
					 Block block = (Block) it.next();
					 long blockSize = block.getNumBytes();
					 FSDirectory.INode fileINode = dir.getFileByBlock(block);
					 if (fileINode == null) {
						 it.remove();
					 }
					 else {
						 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
						 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get( srcNode.getStorageID() );
						 if (containingNodes.contains(srcNode) && (excessBlocks == null || ! excessBlocks.contains(block))) {
							 DatanodeDescriptor targets[] = chooseTargets( Math.min( fileINode.getReplication() - containingNodes.size(), this.maxReplicationStreams - xmitsInProgress), containingNodes, null, blockSize);
							 if (targets.length > 0) {
								 replicateBlocks.add(block);
								 replicateTargetSets.add(targets);
								 scheduledXfers += targets.length;
							 }
						 }
					 }
				 }
				 if (replicateBlocks.size() > 0) {
					 int i = 0;
					 for (Iterator it = replicateBlocks.iterator();
					 it.hasNext();
					 i++) {
						 Block block = (Block) it.next();
						 DatanodeDescriptor targets[] = (DatanodeDescriptor[]) replicateTargetSets.elementAt(i);
						 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
						 if (containingNodes.size() + targets.length >= dir.getFileByBlock( block).getReplication() ) {
							 neededReplications.remove(block);
							 pendingReplications.add(block);
							 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.pendingTransfer: "" + block.getBlockName() + "" is removed from neededReplications to pendingReplications"");
						 }
						 if (NameNode.stateChangeLog.isInfoEnabled()) {
							 StringBuffer targetList = new StringBuffer(""datanode(s)"");
							 for (int k = 0;
							 k < targets.length;
							 k++) {
								 targetList.append(' ');
								 targetList.append(targets[k].getName());
							 }
							 NameNode.stateChangeLog.info( ""BLOCK* NameSystem.pendingTransfer: "" + ""ask "" + srcNode.getName() + "" to replicate "" + block.getBlockName() + "" to "" + targetList);
						 }
					 }
					 DatanodeDescriptor targetMatrix[][] = new DatanodeDescriptor[replicateTargetSets.size()][];
					 for (i = 0;
					 i < targetMatrix.length;
					 i++) {
						 targetMatrix[i] = (DatanodeDescriptor[]) replicateTargetSets.elementAt(i);
					 }
					 results = new Object[2];
					 results[0] = replicateBlocks.toArray(new Block[replicateBlocks.size()]);
					 results[1] = targetMatrix;
				 }
			 }
			 return results;
		 }
	 }
	 DatanodeDescriptor[] chooseTargets(int desiredReplicates, TreeSet forbiddenNodes, UTF8 clientMachine, long blockSize) {
		 if (desiredReplicates > heartbeats.size()) {
			 LOG.warn(""Replication requested of ""+desiredReplicates +"" is larger than cluster size (""+heartbeats.size() +""). Using cluster size."");
			 desiredReplicates = heartbeats.size();
		 }
		 TreeSet alreadyChosen = new TreeSet();
		 Vector targets = new Vector();
		 for (int i = 0;
		 i < desiredReplicates;
		 i++) {
			 DatanodeDescriptor target = chooseTarget(forbiddenNodes, alreadyChosen, clientMachine, blockSize);
			 if (target == null) break;
			 targets.add(target);
			 alreadyChosen.add(target);
		 }
		 return (DatanodeDescriptor[]) targets.toArray(new DatanodeDescriptor[targets.size()]);
	 }
	 DatanodeDescriptor chooseTarget(TreeSet forbidden1, TreeSet forbidden2, UTF8 clientMachine, long blockSize) {
		 int totalMachines = heartbeats.size();
		 if (totalMachines == 0) {
			 LOG.warn(""While choosing target, totalMachines is "" + totalMachines);
			 return null;
		 }
		 TreeSet forbiddenMachines = new TreeSet();
		 if (forbidden1 != null) {
			 for (Iterator it = forbidden1.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor cur = (DatanodeDescriptor) it.next();
				 forbiddenMachines.add(cur.getHost());
			 }
		 }
		 if (forbidden2 != null) {
			 for (Iterator it = forbidden2.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor cur = (DatanodeDescriptor) it.next();
				 forbiddenMachines.add(cur.getHost());
			 }
		 }
		 double avgLoad = 0.0;
		 Vector targetList = new Vector();
		 for (Iterator it = heartbeats.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor node = (DatanodeDescriptor) it.next();
			 if (! forbiddenMachines.contains(node.getHost())) {
				 targetList.add(node);
				 avgLoad += node.getXceiverCount();
			 }
		 }
		 if (targetList.size() > 0) {
			 avgLoad = avgLoad/targetList.size();
		 }
		 Collections.shuffle(targetList);
		 if (targetList.size() > 0) {
			 if (clientMachine != null && clientMachine.getLength() > 0) {
				 for (Iterator it = targetList.iterator();
				 it.hasNext();
				 ) {
					 DatanodeDescriptor node = (DatanodeDescriptor) it.next();
					 if (clientMachine.equals(node.getHost())) {
						 if ((node.getRemaining() > blockSize * MIN_BLOCKS_FOR_WRITE) && (node.getXceiverCount() < (2.0 * avgLoad))) {
							 return node;
						 }
					 }
				 }
			 }
			 for (Iterator it = targetList.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor node = (DatanodeDescriptor) it.next();
				 if ((node.getRemaining() > blockSize * MIN_BLOCKS_FOR_WRITE) && (node.getXceiverCount() < (2.0 * avgLoad))) {
					 return node;
				 }
			 }
			 for (Iterator it = targetList.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor node = (DatanodeDescriptor) it.next();
				 if (node.getRemaining() > blockSize) {
					 return node;
				 }
			 }
			 LOG.warn(""Could not find any nodes with sufficient capacity"");
			 return null;
		 }
		 else {
			 LOG.warn(""Zero targets found, forbidden1.size="" + ( forbidden1 != null ? forbidden1.size() : 0 ) + "" forbidden2.size()="" + ( forbidden2 != null ? forbidden2.size() : 0 ));
			 return null;
		 }
	 }
	 private class FileUnderConstruction {
		 private short blockReplication;
		 private long blockSize;
		 private Vector blocks;
		 private UTF8 clientName;
		 private UTF8 clientMachine;
		 FileUnderConstruction(short replication, long blockSize, UTF8 clientName, UTF8 clientMachine) throws IOException {
			 this.blockReplication = replication;
			 this.blockSize = blockSize;
			 this.blocks = new Vector();
			 this.clientName = clientName;
			 this.clientMachine = clientMachine;
		 }
		 public short getReplication() {
			 return this.blockReplication;
		 }
		 public long getBlockSize() {
			 return blockSize;
		 }
		 public Vector getBlocks() {
			 return blocks;
		 }
		 public UTF8 getClientName() {
			 return clientName;
		 }
		 public UTF8 getClientMachine() {
			 return clientMachine;
		 }
	 }
	 public DatanodeDescriptor getDatanode( DatanodeID nodeID ) throws IOException {
		 UnregisteredDatanodeException e = null;
		 DatanodeDescriptor node = (DatanodeDescriptor) datanodeMap.get(nodeID.getStorageID());
		 if (node == null) return null;
		 if (!node.getName().equals(nodeID.getName())) {
			 e = new UnregisteredDatanodeException( nodeID, node );
			 NameNode.stateChangeLog.fatal(""BLOCK* NameSystem.getDatanode: "" + e.getLocalizedMessage() );
			 throw e;
		 }
		 return node;
	 }
	 public DatanodeDescriptor getDatanodeByName( String name ) throws IOException {
		 for (Iterator it = datanodeMap.values().iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor node = (DatanodeDescriptor) it.next();
			 if( node.getName().equals(name) ) return node;
		 }
		 return null;
	 }
	 private DatanodeInfo getDatanodeByIndex( int index ) {
		 int i = 0;
		 for (Iterator it = datanodeMap.values().iterator();
		 it.hasNext();
		 ) {
			 DatanodeInfo node = (DatanodeInfo) it.next();
			 if( i == index ) return node;
			 i++;
		 }
		 return null;
	 }
	 public String randomDataNode() {
		 int size = datanodeMap.size();
		 int index = 0;
		 if (size != 0) {
			 index = r.nextInt(size);
			 DatanodeInfo d = getDatanodeByIndex(index);
			 if (d != null) {
				 return d.getHost() + "":"" + d.getInfoPort();
			 }
		 }
		 return null;
	 }
	 public int getNameNodeInfoPort() {
		 return infoPort;
	 }
}",0,0,0,0
"public interface MessageReader extends Closeable {
	 public void init(DrillBuf buf, List<SchemaPath> columns, VectorContainerWriter writer, boolean allTextMode, boolean readNumbersAsDouble);
	 public void readMessage(ConsumerRecord<?, ?> message);
	 public void ensureAtLeastOneField();
	 public KafkaConsumer<byte[], byte[]> getConsumer(KafkaStoragePlugin plugin);
}",0,0,0,0
"protected JRFillSubreportReturnValue(JRSubreportReturnValue returnValue, JRFillObjectFactory factory, JRBaseFiller filler);",0,0,0,0
