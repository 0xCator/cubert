code,godclass,dataclass,longmethod,longparamlist
"public interface ServletConstants {
	 String PAGE_HEADER = ""<!DOCTYPE html>\n"" + ""<html lang=\""en\"">\n"" + ""<head>\n"" + "" <meta charset=\""UTF-8\"">\n"" + "" <title>Weblogic Monitoring Exporter</title>\n"" + ""</head>\n"" + ""<body>"";
	 String MAIN_PAGE = """";
	 String METRICS_PAGE = ""metrics"";
	 String CONFIGURATION_PAGE = ""configure"";
	 String AUTHENTICATION_HEADER = ""Authorization"";
	 String COOKIE_HEADER = ""Cookie"";
	 String EFFECT_OPTION = ""effect"";
	 String DEFAULT_ACTION = ServletConstants.REPLACE_ACTION;
	 String REPLACE_ACTION = ""replace"";
	 String APPEND_ACTION = ""append"";
}",0,1,0,0
"public class MetricsAssignmentManagerSourceImpl extends BaseSourceImpl implements MetricsAssignmentManagerSource {
	 private MutableGaugeLong ritGauge;
	 private MutableGaugeLong ritCountOverThresholdGauge;
	 private MutableGaugeLong ritOldestAgeGauge;
	 private MetricHistogram ritDurationHisto;
	 private MutableFastCounter operationCounter;
	 private OperationMetrics assignMetrics;
	 private OperationMetrics unassignMetrics;
	 private OperationMetrics moveMetrics;
	 private OperationMetrics reopenMetrics;
	 private OperationMetrics openMetrics;
	 private OperationMetrics closeMetrics;
	 private OperationMetrics splitMetrics;
	 private OperationMetrics mergeMetrics;
	 public MetricsAssignmentManagerSourceImpl() {
		 this(METRICS_NAME, METRICS_DESCRIPTION, METRICS_CONTEXT, METRICS_JMX_CONTEXT);
	 }
	 public MetricsAssignmentManagerSourceImpl(String metricsName, String metricsDescription, String metricsContext, String metricsJmxContext) {
		 super(metricsName, metricsDescription, metricsContext, metricsJmxContext);
	 }
	 public void init() {
		 ritGauge = metricsRegistry.newGauge(RIT_COUNT_NAME, RIT_COUNT_DESC, 0L);
		 ritCountOverThresholdGauge = metricsRegistry.newGauge(RIT_COUNT_OVER_THRESHOLD_NAME, RIT_COUNT_OVER_THRESHOLD_DESC,0L);
		 ritOldestAgeGauge = metricsRegistry.newGauge(RIT_OLDEST_AGE_NAME, RIT_OLDEST_AGE_DESC, 0L);
		 ritDurationHisto = metricsRegistry.newTimeHistogram(RIT_DURATION_NAME, RIT_DURATION_DESC);
		 operationCounter = metricsRegistry.getCounter(OPERATION_COUNT_NAME, 0L);
		 assignMetrics = new OperationMetrics(registry, ASSIGN_METRIC_PREFIX);
		 unassignMetrics = new OperationMetrics(registry, UNASSIGN_METRIC_PREFIX);
		 moveMetrics = new OperationMetrics(registry, MOVE_METRIC_PREFIX);
		 reopenMetrics = new OperationMetrics(registry, REOPEN_METRIC_PREFIX);
		 openMetrics = new OperationMetrics(registry, OPEN_METRIC_PREFIX);
		 closeMetrics = new OperationMetrics(registry, CLOSE_METRIC_PREFIX);
		 splitMetrics = new OperationMetrics(registry, SPLIT_METRIC_PREFIX);
		 mergeMetrics = new OperationMetrics(registry, MERGE_METRIC_PREFIX);
	 }
	 public void setRIT(final int ritCount) {
		 ritGauge.set(ritCount);
	 }
	 public void setRITCountOverThreshold(final int ritCount) {
		 ritCountOverThresholdGauge.set(ritCount);
	 }
	 public void setRITOldestAge(final long ritOldestAge) {
		 ritOldestAgeGauge.set(ritOldestAge);
	 }
	 public void incrementOperationCounter() {
		 operationCounter.incr();
	 }
	 public void updateRitDuration(long duration) {
		 ritDurationHisto.add(duration);
	 }
	 public OperationMetrics getAssignMetrics() {
		 return assignMetrics;
	 }
	 public OperationMetrics getUnassignMetrics() {
		 return unassignMetrics;
	 }
	 public OperationMetrics getSplitMetrics() {
		 return splitMetrics;
	 }
	 public OperationMetrics getMergeMetrics() {
		 return mergeMetrics;
	 }
	 public OperationMetrics getMoveMetrics() {
		 return moveMetrics;
	 }
	 public OperationMetrics getReopenMetrics() {
		 return reopenMetrics;
	 }
	 public OperationMetrics getOpenMetrics() {
		 return openMetrics;
	 }
	 public OperationMetrics getCloseMetrics() {
		 return closeMetrics;
	 }
}",1,1,0,0
"private void closeQuietly() {
	 if (!isAutocommit() && getConnection() != null && onError.equals(""abort"")) {
		 try {
			 getConnection().rollback();
		 }
		 catch (SQLException ex) {
		 }
	 }
 }",0,0,0,0
"public LegendItem(String label, String description, String toolTipText, String urlText, Shape shape, Paint fillPaint, Stroke outlineStroke, Paint outlinePaint);",0,0,0,1
"public boolean equals(Object o) {
	 if (!(o instanceof CrawlDatum)) return false;
	 CrawlDatum other = (CrawlDatum)o;
	 boolean res = (this.status == other.status) && (this.fetchTime == other.fetchTime) && (this.modifiedTime == other.modifiedTime) && (this.retries == other.retries) && (this.fetchInterval == other.fetchInterval) && (SignatureComparator._compare(this.signature, other.signature) == 0) && (this.score == other.score);
	 if (!res) return res;
	 if (this.metaData == null) {
		 if (other.metaData != null && other.metaData.size() > 0) return false;
		 else return true;
	 }
	 else {
		 if (other.metaData == null) {
			 if (this.metaData.size() == 0) return true;
			 else return false;
		 }
		 else {
			 return this.metaData.equals(other.metaData);
		 }
	 }
 }",0,0,0,0
"public class PageIdRequestTarget extends PageReferenceRequestTarget{
	public PageIdRequestTarget(Page page){
		super(page);
	}
	public PageIdRequestTarget(PageReference reference){
		super(reference);
	}
}",0,0,0,0
"public class ExtensionEvent {
	public static final int DEFAULT_CONSTRUCTOR = 0;
	public static final int METHOD = 1;
	public static final int CONSTRUCTOR = 2;
	public final int m_callType;
	 public final TransformerImpl m_transformer;
	public final Object m_method;
	public final Object m_instance;
	public final Object[] m_arguments;
	public ExtensionEvent(TransformerImpl transformer, Method method, Object instance, Object[] arguments) {
		m_transformer = transformer;
		m_method = method;
		m_instance = instance;
		m_arguments = arguments;
		m_callType = METHOD;
	}
	public ExtensionEvent(TransformerImpl transformer, Constructor constructor, Object[] arguments) {
		m_transformer = transformer;
		m_instance = null;
		m_arguments = arguments;
		m_method = constructor;
		m_callType = CONSTRUCTOR;
	}
	public ExtensionEvent(TransformerImpl transformer, Class clazz) {
		m_transformer = transformer;
		m_instance = null;
		m_arguments = null;
		m_method = clazz;
		m_callType = DEFAULT_CONSTRUCTOR;
	}
}",0,0,0,0
"public class WriteResponseHandler extends AbstractWriteResponseHandler{
	 protected static final Logger logger = LoggerFactory.getLogger(WriteResponseHandler.class);
	 protected final AtomicInteger responses;
	 protected WriteResponseHandler(Collection<InetAddress> writeEndpoints, Multimap<InetAddress, InetAddress> hintedEndpoints, ConsistencyLevel consistencyLevel, String table) {
		 super(writeEndpoints, hintedEndpoints, consistencyLevel);
		 responses = new AtomicInteger(determineBlockFor(table));
	 }
	 protected WriteResponseHandler(InetAddress endpoint) {
		 super(Arrays.asList(endpoint), ImmutableMultimap.<InetAddress, InetAddress>builder().put(endpoint, endpoint).build(), ConsistencyLevel.ALL);
		 responses = new AtomicInteger(1);
	 }
	 public static IWriteResponseHandler create(Collection<InetAddress> writeEndpoints, Multimap<InetAddress, InetAddress> hintedEndpoints, ConsistencyLevel consistencyLevel, String table) {
		 return new WriteResponseHandler(writeEndpoints, hintedEndpoints, consistencyLevel, table);
	 }
	 public static IWriteResponseHandler create(InetAddress endpoint) {
		 return new WriteResponseHandler(endpoint);
	 }
	 public void response(Message m) {
		 if (responses.decrementAndGet() == 0) condition.signal();
	 }
	 protected int determineBlockFor(String table) {
		 switch (consistencyLevel) {
			 case ONE: return 1;
			 case ANY: return 1;
			 case TWO: return 2;
			 case THREE: return 3;
			 case QUORUM: return (Table.open(table).getReplicationStrategy().getReplicationFactor() / 2) + 1;
			 case ALL: return Table.open(table).getReplicationStrategy().getReplicationFactor();
			 default: throw new UnsupportedOperationException(""invalid consistency level: "" + consistencyLevel.toString());
		 }
	 }
	 public void assureSufficientLiveNodes() throws UnavailableException {
		 if (consistencyLevel == ConsistencyLevel.ANY) {
			 if (hintedEndpoints.keySet().size() < responses.get()) throw new UnavailableException();
			 return;
		 }
		 int liveNodes = 0;
		 for (InetAddress destination : hintedEndpoints.keySet()) {
			 if (writeEndpoints.contains(destination)) liveNodes++;
		 }
		 if (liveNodes < responses.get()) {
			 throw new UnavailableException();
		 }
	 }
	 public boolean isLatencyForSnitch() {
		 return false;
	 }
}",0,0,0,0
"public void flush() throws IOException {
	 flushInternal();
 }",0,0,0,0
"public void decide(Authentication authentication, Object object,Collection<ConfigAttribute> configAttributes) throws AccessDeniedException {
	int deny = 0;
	for (AccessDecisionVoter voter : getDecisionVoters()) {
		int result = voter.vote(authentication, object, configAttributes);
		if (logger.isDebugEnabled()) {
			logger.debug(""Voter: "" + voter + "", returned: "" + result);
		}
		switch (result) {
			case AccessDecisionVoter.ACCESS_GRANTED:return;
			case AccessDecisionVoter.ACCESS_DENIED:deny++;
			break;
			default:break;
		}
	}
	if (deny > 0) {
		throw new AccessDeniedException(messages.getMessage(""AbstractAccessDecisionManager.accessDenied"", ""Access is denied""));
	}
	checkAllowIfAllAbstainDecisions();
}",0,0,1,0
"public short getDefaultReplication() {
	 return 1;
 }",0,0,0,0
"static void accumQuad(double bounds[], double t, double curx, double cury, double cpx0, double cpy0, double endx, double endy);",0,0,0,1
"public class JSAMDEmitter extends JSEmitter implements IJSAMDEmitter{
	 private Map<String, IDefinitionNode> foundAccessors = new HashMap<String, IDefinitionNode>();
	 private int inheritenceLevel = -1;
	 private ExportWriter exportWriter;
	 private boolean initializingFieldsInConstructor;
	 private List<IDefinition> baseClassCalls = new ArrayList<IDefinition>();
	 StringBuilder builder() {
		 return getBuilder();
	 }
	 IJSAMDDocEmitter getDoc() {
		 return (IJSAMDDocEmitter) getDocEmitter();
	 }
	 public JSAMDEmitter(FilterWriter out) {
		 super(out);
		 exportWriter = new ExportWriter(this);
	 }
	 public void emitPackageHeader(IPackageDefinition definition) {
		 setBufferWrite(true);
		 write(JSAMDEmitterTokens.DEFINE);
		 write(ASEmitterTokens.PAREN_OPEN);
		 IASScope containedScope = definition.getContainedScope();
		 ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());
		 if (type == null) return;
		 exportWriter.addFrameworkDependencies();
		 exportWriter.addImports(type);
		 exportWriter.queueExports(type, true);
		 writeToken(ASEmitterTokens.COMMA);
	 }
	 public void emitPackageHeaderContents(IPackageDefinition definition) {
	 }
	 public void emitPackageContents(IPackageDefinition definition) {
		 IASScope containedScope = definition.getContainedScope();
		 ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());
		 if (type == null) return;
		 write(""function($exports"");
		 exportWriter.queueExports(type, false);
		 write("") {
			"");
			 indentPush();
			 writeNewline();
			 write(""\""use strict\"";
			 "");
			 writeNewline();
			 ITypeNode tnode = findTypeNode(definition.getNode());
			 if (tnode != null) {
				 getWalker().walk(tnode);
			 }
			 indentPop();
			 writeNewline();
		 write(""}
		"");
	 }
	 public void emitPackageFooter(IPackageDefinition definition) {
		 IASScope containedScope = definition.getContainedScope();
		 ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());
		 if (type == null) return;
		 exportWriter.writeExports(type, true);
		 exportWriter.writeExports(type, false);
		 write("");
		"");
		 flushBuilder();
	 }
	 private void emitConstructor(IFunctionNode node) {
		 FunctionNode fn = (FunctionNode) node;
		 fn.parseFunctionBody(getProblems());
		 write(""function "");
		 write(node.getName());
		 emitParameters(node.getParametersContainerNode());
		 if (!isImplicit((IContainerNode) node.getScopedNode())) {
			 emitMethodScope(node.getScopedNode());
		 }
		 else {
		 }
	 }
	 public void emitInterface(IInterfaceNode node) {
		 final IInterfaceDefinition definition = node.getDefinition();
		 final String interfaceName = definition.getBaseName();
		 write(""AS3.interface_($exports, {
			"");
			 indentPush();
			 writeNewline();
			 write(""package_: \"""");
			 write(definition.getPackageName());
			 write(""\"","");
			 writeNewline();
			 write(""interface_: \"""");
			 write(interfaceName);
			 write(""\"""");
			 IReference[] references = definition.getExtendedInterfaceReferences();
			 final int len = references.length;
			 if (len > 0) {
				 writeNewline();
				 write(""extends_: ["");
				 indentPush();
				 writeNewline();
				 int i = 0;
				 for (IReference reference : references) {
					 write(reference.getName());
					 if (i < len - 1) {
						 write("","");
						 writeNewline();
					 }
					 i++;
				 }
				 indentPop();
				 writeNewline();
				 write(""]"");
			 }
			 indentPop();
			 writeNewline();
		 write(""}
		);
		"");
	 }
	 public void emitClass(IClassNode node) {
		 IClassDefinition definition = node.getDefinition();
		 getModel().setCurrentClass(definition);
		 final String className = definition.getBaseName();
		 write(""AS3.compilationUnit($exports, function($primaryDeclaration){
			"");
			 indentPush();
			 writeNewline();
			 emitConstructor((IFunctionNode) definition.getConstructor().getNode());
			 writeNewline();
			 IReference baseClassReference = definition.getBaseClassReference();
			 boolean hasSuper = baseClassReference != null && !baseClassReference.getName().equals(""Object"");
			 if (hasSuper) {
				 String baseName = baseClassReference.getName();
				 write(""var Super = ("" + baseName + ""._ || "" + baseName + ""._$get());
				"");
				 writeNewline();
				 write(""var super$ = Super.prototype;
				"");
				 writeNewline();
			 }
			 write(""$primaryDeclaration(AS3.class_({
				"");
				 indentPush();
				 writeNewline();
				 write(""package_: \"""" + definition.getPackageName() + ""\"","");
				 writeNewline();
				 write(""class_: \"""" + definition.getBaseName() + ""\"","");
				 writeNewline();
				 if (hasSuper) {
					 write(""extends_: Super,"");
					 writeNewline();
				 }
				 IReference[] references = definition .getImplementedInterfaceReferences();
				 int len = references.length;
				 write(""implements_:"");
				 write("" ["");
				 if (len > 0) {
					 indentPush();
					 writeNewline();
				 }
				 int i = 0;
				 for (IReference reference : references) {
					 write(reference.getName());
					 exportWriter.addDependency(reference.getName(), reference.getDisplayString(), false, false);
					 if (i < len - 1) {
						 write("","");
						 writeNewline();
					 }
					 i++;
				 }
				 if (len > 0) {
					 indentPop();
					 writeNewline();
				 }
				 write(""],"");
				 writeNewline();
				 final IDefinitionNode[] members = node.getAllMemberNodes();
				 write(""members: {
					"");
					 indentPush();
					 writeNewline();
					 write(""constructor: "" + className);
					 if (members.length > 0) {
						 write("","");
						 writeNewline();
					 }
					 List<IDefinitionNode> instanceMembers = new ArrayList<IDefinitionNode>();
					 List<IDefinitionNode> staticMembers = new ArrayList<IDefinitionNode>();
					 List<IASNode> staticStatements = new ArrayList<IASNode>();
					 TempTools.fillInstanceMembers(members, instanceMembers);
					 TempTools.fillStaticMembers(members, staticMembers, true, false);
					 TempTools.fillStaticStatements(node, staticStatements, false);
					 len = instanceMembers.size();
					 i = 0;
					 for (IDefinitionNode mnode : instanceMembers) {
						 if (mnode instanceof IAccessorNode) {
							 if (foundAccessors.containsKey(mnode.getName())) {
								 len--;
								 continue;
							 }
							 getWalker().walk(mnode);
						 }
						 else if (mnode instanceof IFunctionNode) {
							 getWalker().walk(mnode);
						 }
						 else if (mnode instanceof IVariableNode) {
							 getWalker().walk(mnode);
						 }
						 else {
							 write(mnode.getName());
						 }
						 if (i < len - 1) {
							 write("","");
							 writeNewline();
						 }
						 i++;
					 }
					 len = baseClassCalls.size();
					 i = 0;
					 if (len > 0) {
						 write("","");
						 writeNewline();
					 }
					 for (IDefinition baseCall : baseClassCalls) {
						 write(baseCall.getBaseName() + ""$"" + inheritenceLevel + "": super$."" + baseCall.getBaseName());
						 if (i < len - 1) {
							 write("","");
							 writeNewline();
						 }
					 }
					 indentPop();
					 writeNewline();
				 write(""}
				,"");
				 writeNewline();
				 len = staticMembers.size();
				 write(""staticMembers: {
					"");
					 indentPush();
					 writeNewline();
					 i = 0;
					 for (IDefinitionNode mnode : staticMembers) {
						 if (mnode instanceof IAccessorNode) {
							 if (foundAccessors.containsKey(mnode.getName())) continue;
							 foundAccessors.put(mnode.getName(), mnode);
							 getWalker().walk(mnode);
						 }
						 else if (mnode instanceof IFunctionNode) {
							 getWalker().walk(mnode);
						 }
						 else if (mnode instanceof IVariableNode) {
							 getWalker().walk(mnode);
						 }
						 if (i < len - 1) {
							 write("","");
							 writeNewline();
						 }
						 i++;
					 }
					 indentPop();
					 if (len > 0) writeNewline();
				 write(""}
				"");
				 indentPop();
				 writeNewline();
			 write(""}
			));
			"");
			 len = staticStatements.size();
			 if (len > 0) writeNewline();
			 i = 0;
			 for (IASNode statement : staticStatements) {
				 getWalker().walk(statement);
				 if (!(statement instanceof IBlockNode)) write("";
				"");
				 if (i < len - 1) writeNewline();
				 i++;
			 }
			 indentPop();
			 writeNewline();
		 write(""}
		);
		"");
	 }
	 public void emitField(IVariableNode node) {
		 IVariableDefinition definition = (IVariableDefinition) node .getDefinition();
		 if (definition.isStatic()) {
			 IClassDefinition parent = (IClassDefinition) definition.getParent();
			 write(parent.getBaseName());
			 write(""."");
			 write(definition.getBaseName());
			 write("" = "");
			 emitFieldInitialValue(node);
			 return;
		 }
		 String name = toPrivateName(definition);
		 write(name);
		 write("": "");
		 write(""{
			"");
			 indentPush();
			 writeNewline();
			 write(""value:"");
			 emitFieldInitialValue(node);
			 write("","");
			 writeNewline();
			 write(""writable:"");
			 write(!(definition instanceof IConstantDefinition) ? ""true"" : ""false"");
			 indentPop();
			 writeNewline();
		 write(""}
		"");
	 }
	 private void emitFieldInitialValue(IVariableNode node) {
		 ICompilerProject project = getWalker().getProject();
		 IVariableDefinition definition = (IVariableDefinition) node .getDefinition();
		 IExpressionNode valueNode = node.getAssignedValueNode();
		 if (valueNode != null) getWalker().walk(valueNode);
		 else write(TempTools.toInitialValue(definition, project));
	 }
	 public void emitGetAccessor(IGetterNode node) {
		 if (foundAccessors.containsKey(node.getName())) return;
		 foundAccessors.put(node.getName(), node);
		 ICompilerProject project = getWalker().getProject();
		 IAccessorDefinition getter = (IAccessorDefinition) node.getDefinition();
		 IAccessorDefinition setter = getter .resolveCorrespondingAccessor(project);
		 emitGetterSetterPair(getter, setter);
	 }
	 public void emitSetAccessor(ISetterNode node) {
		 if (foundAccessors.containsKey(node.getName())) return;
		 foundAccessors.put(node.getName(), node);
		 ICompilerProject project = getWalker().getProject();
		 IAccessorDefinition setter = (IAccessorDefinition) node.getDefinition();
		 IAccessorDefinition getter = setter .resolveCorrespondingAccessor(project);
		 emitGetterSetterPair(getter, setter);
	 }
	 private void emitGetterSetterPair(IAccessorDefinition getter, IAccessorDefinition setter) {
		 write(getter.getBaseName());
		 write("": {
			"");
			 indentPush();
			 writeNewline();
			 if (getter != null) {
				 emitAccessor(""get"", getter);
			 }
			 if (setter != null) {
				 write("","");
				 writeNewline();
				 emitAccessor(""set"", setter);
			 }
			 indentPop();
			 writeNewline();
		 write(""}
		"");
	 }
	 protected void emitAccessor(String kind, IAccessorDefinition definition) {
		 IFunctionNode fnode = definition.getFunctionNode();
		 FunctionNode fn = (FunctionNode) fnode;
		 fn.parseFunctionBody(new ArrayList<ICompilerProblem>());
		 write(kind + "": function "");
		 write(definition.getBaseName() + ""$"" + kind);
		 emitParameters(fnode.getParametersContainerNode());
		 emitMethodScope(fnode.getScopedNode());
	 }
	 public void emitMethod(IFunctionNode node) {
		 if (node.isConstructor()) {
			 emitConstructor(node);
			 return;
		 }
		 FunctionNode fn = (FunctionNode) node;
		 fn.parseFunctionBody(new ArrayList<ICompilerProblem>());
		 IFunctionDefinition definition = node.getDefinition();
		 String name = toPrivateName(definition);
		 write(name);
		 write("":"");
		 write("" function "");
		 write(node.getName());
		 emitParameters(node.getParametersContainerNode());
		 emitMethodScope(node.getScopedNode());
	 }
	 public void emitFunctionBlockHeader(IFunctionNode node) {
		 IFunctionDefinition definition = node.getDefinition();
		 if (node.isConstructor()) {
			 initializingFieldsInConstructor = true;
			 IClassDefinition type = (IClassDefinition) definition .getAncestorOfType(IClassDefinition.class);
			 List<IVariableDefinition> fields = TempTools.getFields(type, true);
			 for (IVariableDefinition field : fields) {
				 if (TempTools.isVariableAParameter(field, definition.getParameters())) continue;
				 write(""this."");
				 write(field.getBaseName());
				 write("" = "");
				 emitFieldInitialValue((IVariableNode) field.getNode());
				 write("";
				"");
				 writeNewline();
			 }
			 initializingFieldsInConstructor = false;
		 }
		 emitDefaultParameterCodeBlock(node);
	 }
	 private void emitDefaultParameterCodeBlock(IFunctionNode node) {
		 IParameterNode[] pnodes = node.getParameterNodes();
		 Map<Integer, IParameterNode> defaults = TempTools.getDefaults(pnodes);
		 if (pnodes.length == 0) return;
		 if (defaults != null) {
			 boolean hasBody = node.getScopedNode().getChildCount() > 0;
			 if (!hasBody) {
				 indentPush();
				 write(ASEmitterTokens.INDENT);
			 }
			 final StringBuilder code = new StringBuilder();
			 List<IParameterNode> parameters = new ArrayList<IParameterNode>( defaults.values());
			 Collections.reverse(parameters);
			 int len = defaults.size();
			 for (IParameterNode pnode : parameters) {
				 if (pnode != null) {
					 code.setLength(0);
					 code.append(ASEmitterTokens.IF.getToken());
					 code.append(ASEmitterTokens.SPACE.getToken());
					 code.append(ASEmitterTokens.PAREN_OPEN.getToken());
					 code.append(JSEmitterTokens.ARGUMENTS.getToken());
					 code.append(ASEmitterTokens.MEMBER_ACCESS.getToken());
					 code.append(JSAMDEmitterTokens.LENGTH.getToken());
					 code.append(ASEmitterTokens.SPACE.getToken());
					 code.append(ASEmitterTokens.LESS_THAN.getToken());
					 code.append(ASEmitterTokens.SPACE.getToken());
					 code.append(len);
					 code.append(ASEmitterTokens.PAREN_CLOSE.getToken());
					 code.append(ASEmitterTokens.SPACE.getToken());
					 code.append(ASEmitterTokens.BLOCK_OPEN.getToken());
					 write(code.toString());
					 indentPush();
					 writeNewline();
				 }
				 len--;
			 }
			 Collections.reverse(parameters);
			 for (int i = 0, n = parameters.size();
			 i < n;
			 i++) {
				 IParameterNode pnode = parameters.get(i);
				 if (pnode != null) {
					 code.setLength(0);
					 code.append(pnode.getName());
					 code.append(ASEmitterTokens.SPACE.getToken());
					 code.append(ASEmitterTokens.EQUAL.getToken());
					 code.append(ASEmitterTokens.SPACE.getToken());
					 code.append(pnode.getDefaultValue());
					 code.append(ASEmitterTokens.SEMICOLON.getToken());
					 write(code.toString());
					 indentPop();
					 writeNewline();
					 write(ASEmitterTokens.BLOCK_CLOSE);
					 if (i == n - 1 && !hasBody) indentPop();
					 writeNewline();
				 }
			 }
		 }
	 }
	 public void emitParameter(IParameterNode node) {
		 getWalker().walk(node.getNameExpressionNode());
	 }
	 public void emitMemberAccessExpression(IMemberAccessExpressionNode node) {
		 getWalker().walk(node.getLeftOperandNode());
		 if (!(node.getLeftOperandNode() instanceof ILanguageIdentifierNode)) write(node.getOperator().getOperatorText());
		 getWalker().walk(node.getRightOperandNode());
	 }
	 public void emitFunctionCall(IFunctionCallNode node) {
		 if (node.isNewExpression()) {
			 write(ASEmitterTokens.NEW);
			 write(ASEmitterTokens.SPACE);
		 }
		 getWalker().walk(node.getNameNode());
		 emitArguments(node.getArgumentsNode());
	 }
	 public void emitArguments(IContainerNode node) {
		 IContainerNode newNode = node;
		 FunctionCallNode fnode = (FunctionCallNode) node.getParent();
		 if (TempTools.injectThisArgument(fnode, false)) {
			 IdentifierNode thisNode = new IdentifierNode(""this"");
			 newNode = EmitterUtils.insertArgumentsBefore(node, thisNode);
		 }
		 int len = newNode.getChildCount();
		 write(ASEmitterTokens.PAREN_OPEN);
		 for (int i = 0;
		 i < len;
		 i++) {
			 IExpressionNode inode = (IExpressionNode) newNode.getChild(i);
			 if (inode.getNodeID() == ASTNodeID.IdentifierID) {
				 emitArgumentIdentifier((IIdentifierNode) inode);
			 }
			 else {
				 getWalker().walk(inode);
			 }
			 if (i < len - 1) {
				 writeToken(ASEmitterTokens.COMMA);
			 }
		 }
		 write(ASEmitterTokens.PAREN_CLOSE);
	 }
	 private void emitArgumentIdentifier(IIdentifierNode node) {
		 ITypeDefinition type = node.resolveType(getWalker().getProject());
		 if (type instanceof ClassTraitsDefinition) {
			 String qualifiedName = type.getQualifiedName();
			 write(qualifiedName);
		 }
		 else {
			 getWalker().walk(node);
		 }
	 }
	 public void emitIdentifier(IIdentifierNode node) {
		 ICompilerProject project = getWalker().getProject();
		 IDefinition resolve = node.resolve(project);
		 if (TempTools.isBinding(node, project)) {
			 write(""AS3.bind(this, \"""" + toPrivateName(resolve) + ""\"")"");
		 }
		 else {
			 IExpressionNode leftBase = TempTools.getNode(node, false, project);
			 if (leftBase == node) {
				 if (TempTools.isValidThis(node, project)) write(""this."");
				 if (initializingFieldsInConstructor && resolve instanceof IClassDefinition) {
					 String name = resolve.getBaseName();
					 write(""("" + name + ""._ || "" + name + ""._$get())"");
					 return;
				 }
			 }
			 if (resolve != null) {
				 String name = toPrivateName(resolve);
				 if (NativeUtils.isNative(name)) exportWriter.addDependency(name, name, true, false);
				 if (node.getParent() instanceof IMemberAccessExpressionNode) {
					 IMemberAccessExpressionNode mnode = (IMemberAccessExpressionNode) node .getParent();
					 if (mnode.getLeftOperandNode().getNodeID() == ASTNodeID.SuperID) {
						 IIdentifierNode lnode = (IIdentifierNode) mnode .getRightOperandNode();
						 IClassNode cnode = (IClassNode) node .getAncestorOfType(IClassNode.class);
						 initializeInheritenceLevel(cnode.getDefinition());
						 write(""this."");
						 write(lnode.getName() + ""$"" + inheritenceLevel);
						 baseClassCalls.add(resolve);
						 return;
					 }
				 }
				 write(name);
			 }
			 else {
				 write(node.getName());
			 }
		 }
	 }
	 protected void emitType(IExpressionNode node) {
	 }
	 public void emitLanguageIdentifier(ILanguageIdentifierNode node) {
		 if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.ANY_TYPE) {
			 write("""");
		 }
		 else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.REST) {
			 write("""");
		 }
		 else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.SUPER) {
			 IIdentifierNode inode = (IIdentifierNode) node;
			 if (inode.getParent() instanceof IMemberAccessExpressionNode) {
			 }
			 else {
				 write(""Super.call"");
			 }
		 }
		 else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.THIS) {
			 write("""");
		 }
		 else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.VOID) {
			 write("""");
		 }
	 }
	 private String toPrivateName(IDefinition definition) {
		 if (definition instanceof ITypeDefinition) return definition.getBaseName();
		 if (!definition.isPrivate()) return definition.getBaseName();
		 initializeInheritenceLevel(definition);
		 return definition.getBaseName() + ""$"" + inheritenceLevel;
	 }
	 void initializeInheritenceLevel(IDefinition definition) {
		 if (inheritenceLevel != -1) return;
		 IClassDefinition cdefinition = null;
		 if (definition instanceof IClassDefinition) cdefinition = (IClassDefinition) definition;
		 else cdefinition = (IClassDefinition) definition .getAncestorOfType(IClassDefinition.class);
		 ICompilerProject project = getWalker().getProject();
		 IClassDefinition[] ancestry = cdefinition.resolveAncestry(project);
		 inheritenceLevel = ancestry.length - 1;
	 }
}",1,0,0,0
"public class RowRepairResolver extends AbstractRowResolver{
	 protected int maxLiveColumns = 0;
	 public List<IAsyncResult> repairResults = Collections.emptyList();
	 public RowRepairResolver(String table, ByteBuffer key) {
		 super(key, table);
	 }
	 public Row resolve() throws DigestMismatchException, IOException {
		 if (logger.isDebugEnabled()) logger.debug(""resolving "" + replies.size() + "" responses"");
		 long startTime = System.currentTimeMillis();
		 ColumnFamily resolved;
		 if (replies.size() > 1) {
			 List<ColumnFamily> versions = new ArrayList<ColumnFamily>(replies.size());
			 List<InetAddress> endpoints = new ArrayList<InetAddress>(replies.size());
			 for (Map.Entry<Message, ReadResponse> entry : replies.entrySet()) {
				 Message message = entry.getKey();
				 ReadResponse response = entry.getValue();
				 ColumnFamily cf = response.row().cf;
				 assert !response.isDigestQuery() : ""Received digest response to repair read from "" + entry.getKey().getFrom();
				 versions.add(cf);
				 endpoints.add(message.getFrom());
				 int liveColumns = cf == null ? 0 : cf.getLiveColumnCount();
				 if (liveColumns > maxLiveColumns) maxLiveColumns = liveColumns;
			 }
			 resolved = resolveSuperset(versions);
			 if (logger.isDebugEnabled()) logger.debug(""versions merged"");
			 if (resolved != null) repairResults = scheduleRepairs(resolved, table, key, versions, endpoints);
		 }
		 else {
			 resolved = replies.values().iterator().next().row().cf;
		 }
		 if (logger.isDebugEnabled()) logger.debug(""resolve: "" + (System.currentTimeMillis() - startTime) + "" ms."");
		 return new Row(key, resolved);
	 }
	 public static List<IAsyncResult> scheduleRepairs(ColumnFamily resolved, String table, DecoratedKey<?> key, List<ColumnFamily> versions, List<InetAddress> endpoints) {
		 List<IAsyncResult> results = new ArrayList<IAsyncResult>(versions.size());
		 for (int i = 0;
		 i < versions.size();
		 i++) {
			 ColumnFamily diffCf = ColumnFamily.diff(versions.get(i), resolved);
			 if (diffCf == null) continue;
			 RowMutation rowMutation = new RowMutation(table, key.key);
			 rowMutation.add(diffCf);
			 Message repairMessage;
			 try {
				 repairMessage = rowMutation.getMessage(StorageService.Verb.READ_REPAIR, Gossiper.instance.getVersion(endpoints.get(i)));
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
			 results.add(MessagingService.instance().sendRR(repairMessage, endpoints.get(i)));
		 }
		 return results;
	 }
	 static ColumnFamily resolveSuperset(Iterable<ColumnFamily> versions) {
		 assert Iterables.size(versions) > 0;
		 ColumnFamily resolved = null;
		 for (ColumnFamily cf : versions) {
			 if (cf == null) continue;
			 if (resolved == null) resolved = cf.cloneMeShallow();
			 else resolved.delete(cf);
		 }
		 if (resolved == null) return null;
		 QueryFilter filter = new QueryFilter(null, new QueryPath(resolved.metadata().cfName), new IdentityQueryFilter());
		 List<CloseableIterator<IColumn>> iters = new ArrayList<CloseableIterator<IColumn>>();
		 for (ColumnFamily version : versions) {
			 if (version == null) continue;
			 iters.add(FBUtilities.closeableIterator(version.iterator()));
		 }
		 filter.collateColumns(resolved, iters, Integer.MIN_VALUE);
		 return ColumnFamilyStore.removeDeleted(resolved, Integer.MIN_VALUE);
	 }
	 public Row getData() throws IOException {
		 throw new UnsupportedOperationException();
	 }
	 public boolean isDataPresent(){
		 throw new UnsupportedOperationException();
	 }
	 public int getMaxLiveColumns() {
		 return maxLiveColumns;
	 }
}",0,0,0,0
"public int hashCode() {
	 return name.hashCode();
 }",0,0,0,0
"public static class Statement extends RoleElt {
	 public String sid = newSid();
	 public Effects effect;
	 public List<String> action = new ArrayList<>(1);
	 public List<String> resource = new ArrayList<>(1);
	 public Statement(final Effects effect) {
		 this.effect = effect;
	 }
	 public void validate() {
		 requireNonNull(sid, ""Sid"");
		 requireNonNull(effect, ""Effect"");
		 checkState(!(action.isEmpty()), ""Empty Action"");
		 checkState(!(resource.isEmpty()), ""Empty Resource"");
	 }
	 public Statement setAllowed(boolean f) {
		 effect = effect(f);
		 return this;
	 }
	 public Statement addActions(String... actions) {
		 Collections.addAll(action, actions);
		 return this;
	 }
	 public Statement addActions(Collection<String> actions) {
		 action.addAll(actions);
		 return this;
	 }
	 public Statement addResources(String... resources) {
		 Collections.addAll(resource, resources);
		 return this;
	 }
	 public Statement addResources(Collection<String> resources) {
		 resource.addAll(resources);
		 return this;
	 }
 }",0,1,0,0
"public interface Connection extends ShutdownNotifier, Closeable {
	 InetAddress getAddress();
	 int getPort();
	 int getChannelMax();
	 int getFrameMax();
	 int getHeartbeat();
	 Map<String, Object> getClientProperties();
	 String getClientProvidedName();
	 Map<String, Object> getServerProperties();
	 Channel createChannel() throws IOException;
	 Channel createChannel(int channelNumber) throws IOException;
	 default Optional<Channel> openChannel() throws IOException {
		 return Optional.ofNullable(createChannel());
	 }
	 default Optional<Channel> openChannel(int channelNumber) throws IOException {
		 return Optional.ofNullable(createChannel(channelNumber));
	 }
	 void close() throws IOException;
	 void close(int closeCode, String closeMessage) throws IOException;
	 void close(int timeout) throws IOException;
	 void close(int closeCode, String closeMessage, int timeout) throws IOException;
	 void abort();
	 void abort(int closeCode, String closeMessage);
	 void abort(int timeout);
	 void abort(int closeCode, String closeMessage, int timeout);
	 void addBlockedListener(BlockedListener listener);
	 BlockedListener addBlockedListener(BlockedCallback blockedCallback, UnblockedCallback unblockedCallback);
	 boolean removeBlockedListener(BlockedListener listener);
	 void clearBlockedListeners();
	 ExceptionHandler getExceptionHandler();
	 String getId();
	 void setId(String id);
}",0,0,0,0
"public static int reconfigureNetworking() {
	 if (Sage.getBoolean(NET_CONFIG_WIRED, true)) {
		 bringDownWireless();
		 setupNetworking(Sage.get(""linux/wired_network_port"", ""eth0""));
	 }
	 else {
		 if (Sage.getBoolean(""linux/disable_wired_when_wireless_is_enabled"", false)) bringDownWired();
		 IOUtils.exec2(""ifconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" up"");
		 IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" essid "" + Sage.get(NET_CONFIG_SSID, ""any""));
		 String crypto = Sage.get(NET_CONFIG_ENCRYPTION, ""WPA"");
		 if (""None"".equals(crypto)) {
			 IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key off"");
		 }
		 else {
			 String key = Sage.get(NET_CONFIG_ENCRYPTION_KEY, """");
			 boolean hexKey = true;
			 for (int i = 0;
			 i < key.length();
			 i++) {
				 if (Character.digit(key.charAt(i), 16) < 0) {
					 hexKey = false;
					 break;
				 }
			 }
			 if (""WEP"".equals(crypto)) {
				 IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key on"");
				 if (hexKey) IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key "" + Sage.get(NET_CONFIG_ENCRYPTION_KEY, """"));
				 else IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key s:"" + Sage.get(NET_CONFIG_ENCRYPTION_KEY, """"));
			 }
			 else {
			 }
		 }
		 setupNetworking(Sage.get(""linux/wireless_network_port"", ""eth1""));
	 }
	 return 0;
 }",0,0,1,0
"public class EObject {
	protected List<Extension> extensions;
	protected String id;
	protected QName type;
	protected String version;
	protected String href;
	protected Object idref;
	protected String label;
	protected String uuid;
	public List<Extension> getExtensions() {
		if (extensions == null) {
			extensions = new ArrayList<Extension>();
		}
		return this.extensions;
	}
	public String getId() {
		return id;
	}
	public void setId(String value) {
		this.id = value;
	}
	public QName getType() {
		return type;
	}
	public void setType(QName value) {
		this.type = value;
	}
	public String getVersion() {
		if (version == null) {
			return ""2.0"";
		}
		 else {
			return version;
		}
	}
	public void setVersion(String value) {
		this.version = value;
	}
	public String getHref() {
		return href;
	}
	public void setHref(String value) {
		this.href = value;
	}
	public Object getIdref() {
		return idref;
	}
	public void setIdref(Object value) {
		this.idref = value;
	}
	public String getLabel() {
		return label;
	}
	public void setLabel(String value) {
		this.label = value;
	}
	public String getUuid() {
		return uuid;
	}
	public void setUuid(String value) {
		this.uuid = value;
	}
}",1,1,0,0
"public ConnectionTableNIO(Receiver r, InetAddress bind_addr, InetAddress external_addr, int srv_port, int max_port, long reaper_interval, long conn_expire_time ) throws Exception;",0,0,0,1
"public String toString(){
	return input;
}",0,0,0,0
"public class SliceQueryFilter implements IFilter{
	 private static Logger logger = LoggerFactory.getLogger(SliceQueryFilter.class);
	 public volatile ByteBuffer start;
	 public volatile ByteBuffer finish;
	 public final boolean reversed;
	 public volatile int count;
	 public SliceQueryFilter(ByteBuffer start, ByteBuffer finish, boolean reversed, int count) {
		 this.start = start;
		 this.finish = finish;
		 this.reversed = reversed;
		 this.count = count;
	 }
	 public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey<?> key) {
		 return Memtable.getSliceIterator(key, cf, this);
	 }
	 public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key) {
		 return new SSTableSliceIterator(sstable, key, start, finish, reversed);
	 }
	 public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key) {
		 return new SSTableSliceIterator(sstable, file, key, start, finish, reversed);
	 }
	 public SuperColumn filterSuperColumn(SuperColumn superColumn, int gcBefore) {
		 SuperColumn scFiltered = superColumn.cloneMeShallow();
		 Iterator<IColumn> subcolumns;
		 if (reversed) {
			 List<IColumn> columnsAsList = new ArrayList<IColumn>(superColumn.getSubColumns());
			 subcolumns = Lists.reverse(columnsAsList).iterator();
		 }
		 else {
			 subcolumns = superColumn.getSubColumns().iterator();
		 }
		 Comparator<ByteBuffer> comparator = reversed ? superColumn.getComparator().reverseComparator : superColumn.getComparator();
		 while (subcolumns.hasNext()) {
			 IColumn column = subcolumns.next();
			 if (comparator.compare(column.name(), start) >= 0) {
				 subcolumns = Iterators.concat(Iterators.singletonIterator(column), subcolumns);
				 break;
			 }
		 }
		 collectReducedColumns(scFiltered, subcolumns, gcBefore);
		 return scFiltered;
	 }
	 public Comparator<IColumn> getColumnComparator(AbstractType<?> comparator) {
		 return reversed ? comparator.columnReverseComparator : comparator.columnComparator;
	 }
	 public void collectReducedColumns(IColumnContainer container, Iterator<IColumn> reducedColumns, int gcBefore) {
		 int liveColumns = 0;
		 AbstractType<?> comparator = container.getComparator();
		 while (reducedColumns.hasNext()) {
			 if (liveColumns >= count) break;
			 IColumn column = reducedColumns.next();
			 if (logger.isDebugEnabled()) logger.debug(String.format(""collecting %s of %s: %s"", liveColumns, count, column.getString(comparator)));
			 if (finish.remaining() > 0 && ((!reversed && comparator.compare(column.name(), finish) > 0)) || (reversed && comparator.compare(column.name(), finish) < 0)) break;
			 if (column.isLive() && (!container.isMarkedForDelete() || column.mostRecentLiveChangeAt() > container.getMarkedForDeleteAt())) {
				 liveColumns++;
			 }
			 if (QueryFilter.isRelevant(column, container, gcBefore)) container.addColumn(column);
		 }
	 }
	 public String toString() {
		 return getClass().getSimpleName() + ""("" + ""start="" + start + "", finish="" + finish + "", reversed="" + reversed + "", count="" + count + ""]"";
	 }
	 public boolean isReversed() {
		 return reversed;
	 }
	 public void updateColumnsLimit(int newLimit) {
		 count = newLimit;
	 }
}",0,0,0,0
"public static Predicate<OperatingSystem> isUnix() {
	 return new Predicate<OperatingSystem>() {
		 public boolean apply(OperatingSystem os) {
			 if (os.getFamily() != null) {
				 switch (os.getFamily()) {
					 case WINDOWS: return false;
				 }
			 }
			 for (String toMatch : searchStrings(os)) if (toMatch != null && toMatch.toLowerCase().indexOf(""windows"") != -1) return false;
			 return true;
		 }
		 public String toString() {
			 return ""isUnix()"";
		 }
	 }
	;
 }",0,0,1,0
"public class GruntParser extends org.apache.pig.tools.grunt.GruntParser {
	 private final Map<String, String> aliasOverride;
	 public GruntParser(Reader stream, Map<String, String> aliasOverride) {
		 this(stream, null, aliasOverride);
	 }
	 public GruntParser(Reader stream, PigServer pigServer, Map<String, String> aliasOverride) {
		 super(stream, pigServer);
		 this.aliasOverride = aliasOverride;
	 }
	 protected void processPig(String cmd) throws IOException {
		 String command = override(cmd);
		 if (!command.equals("""")) {
			 super.processPig(command);
		 }
	 }
	 public String override(String query) {
		 String fsRoot = System.getProperty(""pigunit.filesystem.prefix"");
		 if (fsRoot != null) {
		 query = Pattern.compile(""(LOAD\\s+'(([^:/?#]+): query = Pattern.compile(""(STORE\\s+([^']+)\\s+INTO\\s+'(([^:/?#]+): }
		 Map<String, String> metaData = new HashMap<String, String>();
		 for (Entry<String, String> alias : aliasOverride.entrySet()) {
			 saveLastStoreAlias(query, metaData);
			 if (query.toLowerCase().startsWith(alias.getKey().toLowerCase() + "" "")) {
				 System.out.println(String.format(""%s\n--> %s"", query, alias.getValue() == """" ? ""none"" : alias.getValue()));
				 query = alias.getValue();
			 }
		 }
		 aliasOverride.putAll(metaData);
		 return query;
	 }
	 void saveLastStoreAlias(String cmd, Map<String, String> metaData) {
		 if (cmd.toUpperCase().startsWith(""STORE"")) {
			 Pattern outputFile = Pattern.compile(""STORE +([^']+) INTO.*"", Pattern.CASE_INSENSITIVE);
			 Matcher matcher = outputFile.matcher(cmd);
			 if (matcher.matches()) {
				 metaData.put(""LAST_STORE_ALIAS"", matcher.group(1));
			 }
		 }
	 }
}",1,0,0,0
"public class CommandSubscription {
	 private static final Logger LOG = LoggerFactory.getLogger(CommandSubscription.class);
	 private String endpoint;
	 private String req;
	 private String tenant;
	 private String deviceId;
	 private MqttQoS qos;
	 private String clientId;
	 private String topic;
	 private boolean isAuthenticated;
	 private CommandSubscription(final String topic) {
		 Objects.requireNonNull(topic);
		 this.topic = topic;
		 final String[] parts = topic.split(""\\/"");
		 if (parts.length != 5 || !""#"".equals(parts[4])) {
			 throw new IllegalArgumentException(""topic filter does not match pattern: control|c/+/+/req|q/#"");
		 }
		 endpoint = parts[0];
		 if (!CommandConstants.isCommandEndpoint(endpoint)) {
			 throw new IllegalArgumentException( ""the endpoint needs to be '"" + CommandConstants.COMMAND_ENDPOINT + ""' or '"" + CommandConstants.COMMAND_ENDPOINT_SHORT + ""'"");
		 }
		 req = parts[3];
		 if (!CommandConstants.COMMAND_RESPONSE_REQUEST_PART.equals(req) && !CommandConstants.COMMAND_RESPONSE_REQUEST_PART_SHORT.equals(req)) {
			 throw new IllegalArgumentException( ""the request part needs to be '"" + CommandConstants.COMMAND_RESPONSE_REQUEST_PART + ""' or '"" + CommandConstants.COMMAND_RESPONSE_REQUEST_PART_SHORT + ""'"");
		 }
		 if (!""+"".equals(parts[1])) {
			 tenant = parts[1];
		 }
		 if (!""+"".equals(parts[2])) {
			 deviceId = parts[2];
		 }
	 }
	 private CommandSubscription(final String topic, final Device authenticatedDevice) {
		 this(topic);
		 if (authenticatedDevice == null) {
			 isAuthenticated = false;
			 if (tenant == null || tenant.isEmpty()) {
				 throw new IllegalArgumentException( ""for unauthenticated devices the tenant needs to be given in the subscription"");
			 }
			 if (deviceId == null || deviceId.isEmpty()) {
				 throw new IllegalArgumentException( ""for unauthenticated devices the device-id needs to be given in the subscription"");
			 }
		 }
		 else {
			 isAuthenticated = true;
			 if ((tenant != null && !authenticatedDevice.getTenantId().equals(tenant)) || (deviceId != null && !authenticatedDevice.getDeviceId().equals(deviceId))) {
				 throw new IllegalArgumentException( ""for authenticated devices the given device-id and tenant need to match the authentication or be undefined ('+')"");
			 }
			 else {
				 tenant = authenticatedDevice.getTenantId();
				 deviceId = authenticatedDevice.getDeviceId();
			 }
		 }
	 }
	 private CommandSubscription(final String topic, final Device authenticatedDevice, final MqttQoS qos, final String clientId) {
		 this(topic, authenticatedDevice);
		 this.qos = qos;
		 this.clientId = clientId;
	 }
	 public String getTenant() {
		 return tenant;
	 }
	 public String getDeviceId() {
		 return deviceId;
	 }
	 public String getEndpoint() {
		 return endpoint;
	 }
	 public MqttQoS getQos() {
		 return qos;
	 }
	 public String getClientId() {
		 return clientId;
	 }
	 public String getTopic() {
		 return topic;
	 }
	 public String getRequestPart() {
		 return req;
	 }
	 public boolean isAuthenticated() {
		 return isAuthenticated;
	 }
	 public static CommandSubscription fromTopic(final String topic, final Device authenticatedDevice) {
		 try {
			 return new CommandSubscription(topic, authenticatedDevice);
		 }
		 catch (final IllegalArgumentException e) {
			 LOG.debug(e.getMessage());
			 return null;
		 }
	 }
	 public static CommandSubscription fromTopic(final MqttTopicSubscription mqttTopicSub, final Device authenticatedDevice, final String clientId) {
		 try {
			 return new CommandSubscription(mqttTopicSub.topicName(), authenticatedDevice, mqttTopicSub.qualityOfService(), clientId);
		 }
		 catch (final IllegalArgumentException e) {
			 LOG.debug(e.getMessage());
			 return null;
		 }
	 }
}",0,0,0,0
"public class MetricTest {
	 private String testName = """";
	 private Random random = new Random();
	 public void testGetMetricName() {
		 Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, 0.0);
		 assertEquals(testName, IUT.getMetricName());
	 }
	 public void testGetCount() {
		 int count = random.nextInt();
		 Metric IUT = new Metric(testName, count, 0.0, 0.0, 0.0, 0.0, 0.0);
		 assertEquals(count, IUT.getCount());
	 }
	 public void testGetTotal() {
		 double total = random.nextDouble();
		 Metric IUT = new Metric(testName, 0, total, 0.0, 0.0, 0.0, 0.0);
		 assertEquals(total, IUT.getTotal(), 0.05);
	 }
	 public void testGetLowValue() {
		 double low = random.nextDouble();
		 Metric IUT = new Metric(testName, 0, 0.0, low, 0.0, 0.0, 0.0);
		 assertEquals(low, IUT.getLowValue(), 0.05);
	 }
	 public void testGetHighValue() {
		 double high = random.nextDouble();
		 Metric IUT = new Metric(testName, 0, 0.0, 0.0, high, 0.0, 0.0);
		 assertEquals(high, IUT.getHighValue(), 0.05);
	 }
	 public void testGetAverage() {
		 double mean = random.nextDouble();
		 Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, mean, 0.0);
		 assertEquals(mean, IUT.getAverage(), 0.05);
	 }
	 public void testGetStandardDeviation() {
		 double stdev = random.nextDouble();
		 Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, stdev);
		 assertEquals(stdev, IUT.getStandardDeviation(), 0.05);
	 }
	 public static junit.framework.Test suite() {
		 return new junit.framework.JUnit4TestAdapter(MetricTest.class);
	 }
}",0,1,0,0
"public void setVersions(final VersionTag versionTag) {
	 this.memberId = versionTag.getMemberID();
	 int eVersion = versionTag.getEntryVersion();
	 this.entryVersionLowBytes = (short) (eVersion & 0xffff);
	 this.entryVersionHighByte = (byte) ((eVersion & 0xff0000) >> 16);
	 this.regionVersionHighBytes = versionTag.getRegionVersionHighBytes();
	 this.regionVersionLowBytes = versionTag.getRegionVersionLowBytes();
	 if (!versionTag.isGatewayTag() && this.distributedSystemId == versionTag.getDistributedSystemId()) {
		 if (getVersionTimeStamp() <= versionTag.getVersionTimeStamp()) {
			 setVersionTimeStamp(versionTag.getVersionTimeStamp());
		 }
		 else {
			 versionTag.setVersionTimeStamp(getVersionTimeStamp());
		 }
	 }
	 else {
		 setVersionTimeStamp(versionTag.getVersionTimeStamp());
	 }
	 this.distributedSystemId = (byte) (versionTag.getDistributedSystemId() & 0xff);
 }",0,0,1,0
"public final class OgnlHelper {
	 private static final Pattern INDEX_PATTERN = Pattern.compile(""^(.*)\\[(.*)\\]$"");
	 private OgnlHelper() {
	 }
	 public static boolean isValidOgnlExpression(String expression) {
		 if (ObjectHelper.isEmpty(expression)) {
			 return false;
		 }
		 int bracketBegin = StringHelper.countChar(expression, '[');
		 int bracketEnd = StringHelper.countChar(expression, ']');
		 if (bracketBegin > 0 && bracketEnd > 0) {
			 return bracketBegin == bracketEnd;
		 }
		 return expression.contains(""."");
	 }
	 public static boolean isInvalidValidOgnlExpression(String expression) {
		 if (ObjectHelper.isEmpty(expression)) {
			 return false;
		 }
		 if (!expression.contains(""."") && !expression.contains(""["") && !expression.contains(""]"")) {
			 return false;
		 }
		 int bracketBegin = StringHelper.countChar(expression, '[');
		 int bracketEnd = StringHelper.countChar(expression, ']');
		 if (bracketBegin > 0 || bracketEnd > 0) {
			 return bracketBegin != bracketEnd;
		 }
		 if (expression.contains("".."")) {
			 return true;
		 }
		 return false;
	 }
	 public static void validateMethodName(String method) {
		 if (ObjectHelper.isEmpty(method)) {
			 return;
		 }
		 for (int i = 0;
		 i < method.length();
		 i++) {
			 char ch = method.charAt(i);
			 if (i == 0 && '.' == ch) {
				 continue;
			 }
			 if (ch == '(' || ch == '[' || ch == '.' || ch == '?') {
				 break;
			 }
			 if (i == 0 && !Character.isJavaIdentifierStart(ch)) {
				 throw new IllegalArgumentException(""Method name must start with a valid java identifier at position: 0 in method: "" + method);
			 }
			 else if (!Character.isJavaIdentifierPart(ch)) {
				 throw new IllegalArgumentException(""Method name must be valid java identifier at position: "" + i + "" in method: "" + method);
			 }
		 }
	 }
	 public static boolean isNullSafeOperator(String ognlExpression) {
		 if (ObjectHelper.isEmpty(ognlExpression)) {
			 return false;
		 }
		 return ognlExpression.startsWith(""?"");
	 }
	 public static String removeLeadingOperators(String ognlExpression) {
		 if (ObjectHelper.isEmpty(ognlExpression)) {
			 return ognlExpression;
		 }
		 if (ognlExpression.startsWith(""?"")) {
			 ognlExpression = ognlExpression.substring(1);
		 }
		 if (ognlExpression.startsWith(""."")) {
			 ognlExpression = ognlExpression.substring(1);
		 }
		 return ognlExpression;
	 }
	 public static String removeTrailingOperators(String ognlExpression) {
		 if (ObjectHelper.isEmpty(ognlExpression)) {
			 return ognlExpression;
		 }
		 if (ognlExpression.contains(""["")) {
			 return StringHelper.before(ognlExpression, ""["");
		 }
		 return ognlExpression;
	 }
	 public static String removeOperators(String ognlExpression) {
		 return removeLeadingOperators(removeTrailingOperators(ognlExpression));
	 }
	 public static KeyValueHolder<String, String> isOgnlIndex(String ognlExpression) {
		 Matcher matcher = INDEX_PATTERN.matcher(ognlExpression);
		 if (matcher.matches()) {
			 String key = matcher.group(1);
			 if (ObjectHelper.isEmpty(key)) {
				 key = null;
			 }
			 String value = matcher.group(2);
			 if (ObjectHelper.isEmpty(value)) {
				 value = null;
			 }
			 return new KeyValueHolder<>(key, value);
		 }
		 return null;
	 }
	 public static List<String> splitOgnl(String ognl) {
		 List<String> methods = new ArrayList<>();
		 if (ObjectHelper.isEmpty(ognl)) {
			 return methods;
		 }
		 StringBuilder sb = new StringBuilder();
		 int j = 0;
		 boolean squareBracket = false;
		 boolean parenthesisBracket = false;
		 for (int i = 0;
		 i < ognl.length();
		 i++) {
			 char ch = ognl.charAt(i);
			 if (j == 0 || (j == 1 && ognl.charAt(i - 1) == '?') || (ch != '.' && ch != '?' && ch != ']')) {
				 sb.append(ch);
				 if (ch == '[' && !parenthesisBracket) {
					 squareBracket = true;
				 }
				 else if (ch == '(') {
					 parenthesisBracket = true;
				 }
				 else if (ch == ')') {
					 parenthesisBracket = false;
				 }
				 j++;
			 }
			 else {
				 if (ch == '.' && !squareBracket && !parenthesisBracket) {
					 String s = sb.toString();
					 sb.setLength(0);
					 if (s.endsWith(""?"")) {
						 sb.append(""?"");
						 s = s.substring(0, s.length() - 1);
					 }
					 methods.add(s);
					 j = 0;
				 }
				 else if (ch == ']' && !parenthesisBracket) {
					 sb.append(ch);
					 String s = sb.toString();
					 sb.setLength(0);
					 methods.add(s);
					 j = 0;
					 squareBracket = false;
				 }
				 if (ch != ']' || parenthesisBracket) {
					 sb.append(ch);
				 }
				 if (j > 0) {
					 j++;
				 }
			 }
		 }
		 if (sb.length() > 0) {
			 methods.add(sb.toString());
		 }
		 String last = methods.isEmpty() ? null : methods.get(methods.size() - 1);
		 if (parenthesisBracket && last != null) {
			 if (last.contains(""("") && !last.endsWith("")"")) {
				 throw new IllegalArgumentException(""Method should end with parenthesis, was "" + last);
			 }
		 }
		 return methods;
	 }
}",1,0,0,0
"private void executeGetWithConditions(Tree statement) {
	 if (!CliMain.isConnected() || !hasKeySpace()) return;
	 long startTime = System.currentTimeMillis();
	 IndexClause clause = new IndexClause();
	 String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
	 Tree conditions = statement.getChild(1);
	 CfDef columnFamilyDef = getCfDef(columnFamily);
	 SlicePredicate predicate = new SlicePredicate();
	 SliceRange sliceRange = new SliceRange();
	 sliceRange.setStart(new byte[0]).setFinish(new byte[0]);
	 predicate.setSlice_range(sliceRange);
	 for (int i = 0;
	 i < conditions.getChildCount();
	 i++) {
		 Tree condition = conditions.getChild(i);
		 String operator = condition.getChild(0).getText();
		 String columnNameString = CliUtils.unescapeSQLString(condition.getChild(1).getText());
		 Tree valueTree = condition.getChild(2);
		 try {
			 ByteBuffer value;
			 ByteBuffer columnName = columnNameAsBytes(columnNameString, columnFamily);
			 if (valueTree.getType() == CliParser.FUNCTION_CALL) {
				 value = convertValueByFunction(valueTree, columnFamilyDef, columnName);
			 }
			 else {
				 String valueString = CliUtils.unescapeSQLString(valueTree.getText());
				 value = columnValueAsBytes(columnName, columnFamily, valueString);
			 }
			 IndexOperator idxOperator = CliUtils.getIndexOperator(operator);
			 clause.addToExpressions(new IndexExpression(columnName, idxOperator, value));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 List<KeySlice> slices;
	 clause.setStart_key(new byte[] {
	}
	);
	 if (statement.getChildCount() == 3) {
		 Tree limitNode = statement.getChild(2);
		 int limitValue = Integer.parseInt(limitNode.getChild(0).getText());
		 if (limitValue == 0) {
			 throw new IllegalArgumentException(""LIMIT should be greater than zero."");
		 }
		 clause.setCount(limitValue);
	 }
	 try {
		 ColumnParent parent = new ColumnParent(columnFamily);
		 slices = thriftClient.get_indexed_slices(parent, clause, predicate, consistencyLevel);
		 printSliceList(columnFamilyDef, slices);
	 }
	 catch (InvalidRequestException e) {
		 throw new RuntimeException(e);
	 }
	 catch (Exception e) {
		 throw new RuntimeException(e);
	 }
	 elapsedTime(startTime);
 }",0,0,0,0
"private static void writeFinalRule(Writer writer, boolean isDst, AnnualTimeZoneRule rule, int fromRawOffset, int fromDSTSavings, long startTime) throws IOException{
	 DateTimeRule dtrule = toWallTimeRule(rule.getRule(), fromRawOffset, fromDSTSavings);
	 int timeInDay = dtrule.getRuleMillisInDay();
	 if (timeInDay < 0) {
		 startTime = startTime + (0 - timeInDay);
	 }
	 else if (timeInDay >= Grego.MILLIS_PER_DAY) {
		 startTime = startTime - (timeInDay - (Grego.MILLIS_PER_DAY - 1));
	 }
	 int toOffset = rule.getRawOffset() + rule.getDSTSavings();
	 switch (dtrule.getDateRuleType()) {
		 case DateTimeRule.DOM: writeZonePropsByDOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), startTime, MAX_TIME);
		 break;
		 case DateTimeRule.DOW: writeZonePropsByDOW(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleWeekInMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);
		 break;
		 case DateTimeRule.DOW_GEQ_DOM: writeZonePropsByDOW_GEQ_DOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);
		 break;
		 case DateTimeRule.DOW_LEQ_DOM: writeZonePropsByDOW_LEQ_DOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);
		 break;
	 }
 }",0,0,1,0
"public class FakeErrorBoxWidget implements IErrorBox {
	private boolean observed;
	private boolean displayed;
	private String errorMsg = null;
	public boolean widgetDisplayed() {
		return this.displayed;
	}
	public void display() {
		this.displayed = true;
		return;
	}
	public void setErrorString(String error) {
		errorMsg = error;
		return;
	}
	public String getErrorString() {
		return errorMsg;
	}
}",0,1,0,0
"public class DecimalType extends AbstractType<BigDecimal>{
	 public static final DecimalType instance = new DecimalType();
	 DecimalType() {
	}
	 public int compare(ByteBuffer bb0, ByteBuffer bb1) {
		 if (bb0.remaining() == 0) {
			 return bb1.remaining() == 0 ? 0 : -1;
		 }
		 if (bb1.remaining() == 0) {
			 return 1;
		 }
		 return compose(bb0).compareTo(compose(bb1));
	 }
	 public BigDecimal compose(ByteBuffer bytes) {
		 return JdbcDecimal.instance.compose(bytes);
	 }
	 public ByteBuffer decompose(BigDecimal value) {
		 return JdbcDecimal.instance.decompose(value);
	 }
	 public String getString(ByteBuffer bytes) {
		 return JdbcDecimal.instance.getString(bytes);
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
		 BigDecimal decimal;
		 try {
			 decimal = new BigDecimal(source);
		 }
		 catch (Exception e) {
			 throw new MarshalException(String.format(""unable to make BigDecimal from '%s'"", source), e);
		 }
		 return decompose(decimal);
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
	 }
}",0,0,0,0
"public class IncreasingKeyMatcher implements NodeMatcher<Operator,OperatorPlan<Operator>> {
	 public Map<OperatorKey, OperatorKey> match(OperatorPlan plan1, OperatorPlan plan2, StringBuilder messages) {
		 List<OperatorKey> keyList1 = getSortedKeyList(plan1) ;
		 List<OperatorKey> keyList2 = getSortedKeyList(plan2) ;
		 if (keyList1.size() != keyList2.size()) {
			 messages.append(""Two plans have different size"") ;
			 return null ;
		 }
		 Map<OperatorKey, OperatorKey> outputMap = new HashMap<OperatorKey, OperatorKey>() ;
		 for(int i=0;
		 i< keyList1.size() ;
		 i++) {
			 outputMap.put(keyList1.get(i), keyList2.get(i)) ;
		 }
		 return outputMap ;
	 }
	 private List<OperatorKey> getSortedKeyList(OperatorPlan plan) {
		 List<OperatorKey> keyList = new ArrayList<OperatorKey>(plan.getKeys().keySet()) ;
		 Collections.sort(keyList);
		 return keyList ;
	 }
}",1,0,0,0
"public static DataSet convertJMLToNeurophDataset(Dataset jmlDataset, int numInputs, int numOutputs) {
	 if (numInputs <= 0) {
		 throw new IllegalArgumentException(""Number of inputs in DataSet cannot be zero or negative!"");
	 }
	 if (numOutputs < 0) {
		 throw new IllegalArgumentException(""Number of outputs in DataSet cannot be negative!"");
	 }
	 int rowSize = jmlDataset.noAttributes() + 1;
	 if (numOutputs + numInputs < rowSize) {
		 throw new IllegalArgumentException(""Number of outputs and inputs should be equal to number of attributes from data set!"");
	 }
	 DataSet neurophDataset;
	 if (numOutputs == 0) {
		 neurophDataset = new DataSet(rowSize);
	 }
	 else {
		 neurophDataset = new DataSet(numInputs, numOutputs);
	 }
	 List<String> outputClasses = new ArrayList<String>();
	 for (int i = 0;
	 i < jmlDataset.size();
	 i++) {
		 if (!outputClasses.contains(jmlDataset.get(i).classValue().toString())) {
			 outputClasses.add(jmlDataset.get(i).classValue().toString());
		 }
	 }
	 for (int i = 0;
	 i < jmlDataset.size();
	 i++) {
		 Iterator attributeIterator = jmlDataset.get(i).iterator();
		 double[] values = new double[rowSize];
		 int index = 0;
		 while (attributeIterator.hasNext()) {
			 Double attrValue = (Double) attributeIterator.next();
			 values[index] = attrValue.doubleValue();
			 index++;
		 }
		 DataSetRow row = null;
		 if (numOutputs == 0) {
			 row = new DataSetRow(values);
		 }
		 else {
			 double[] inputs = new double[numInputs];
			 double[] outputs = new double[outputClasses.size()];
			 int k = 0;
			 int j = 0;
			 for (int v = 0;
			 v < values.length;
			 v++) {
				 if (v < numInputs) {
					 inputs[j] = values[v];
					 j++;
				 }
			 }
			 for(String cla:outputClasses){
				 if(cla.equals(jmlDataset.get(i).classValue().toString())){
					 outputs[k] = 1;
				 }
				else{
					 outputs[k] = 0;
				 }
				 k++;
			 }
			 row = new DataSetRow(inputs, outputs);
		 }
		 row.setLabel(jmlDataset.get(i).classValue().toString());
		 neurophDataset.addRow(row);
	 }
	 return neurophDataset;
 }",0,0,1,0
"private static List<Row> fetchRows(List<ReadCommand> initialCommands, ConsistencyLevel consistency_level) throws IOException, UnavailableException, TimeoutException {
	 List<Row> rows = new ArrayList<Row>(initialCommands.size());
	 List<ReadCommand> commandsToRetry = Collections.emptyList();
	 do {
		 List<ReadCommand> commands = commandsToRetry.isEmpty() ? initialCommands : commandsToRetry;
		 ReadCallback<Row>[] readCallbacks = new ReadCallback[commands.size()];
		 if (!commandsToRetry.isEmpty()) logger.debug(""Retrying {
		}
		 commands"", commandsToRetry.size());
		 for (int i = 0;
		 i < commands.size();
		 i++) {
			 ReadCommand command = commands.get(i);
			 assert !command.isDigestQuery();
			 logger.debug(""Command/ConsistencyLevel is {
			}
			/{
			}
			"", command, consistency_level);
			 List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table, command.key);
			 DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(), endpoints);
			 RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
			 ReadCallback<Row> handler = getReadCallback(resolver, command, consistency_level, endpoints);
			 handler.assureSufficientLiveNodes();
			 assert !handler.endpoints.isEmpty();
			 readCallbacks[i] = handler;
			 InetAddress dataPoint = handler.endpoints.get(0);
			 if (dataPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS) {
				 logger.debug(""reading data locally"");
				 StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
			 }
			 else {
				 logger.debug(""reading data from {
				}
				"", dataPoint);
				 MessagingService.instance().sendRR(command, dataPoint, handler);
			 }
			 if (handler.endpoints.size() == 1) continue;
			 ReadCommand digestCommand = command.copy();
			 digestCommand.setDigestQuery(true);
			 MessageProducer producer = null;
			 for (InetAddress digestPoint : handler.endpoints.subList(1, handler.endpoints.size())) {
				 if (digestPoint.equals(FBUtilities.getBroadcastAddress())) {
					 logger.debug(""reading digest locally"");
					 StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
				 }
				 else {
					 logger.debug(""reading digest from {
					}
					"", digestPoint);
					 if (producer == null) producer = new CachingMessageProducer(digestCommand);
					 MessagingService.instance().sendRR(producer, digestPoint, handler);
				 }
			 }
		 }
		 List<ReadCommand> repairCommands = null;
		 List<RepairCallback> repairResponseHandlers = null;
		 for (int i = 0;
		 i < commands.size();
		 i++) {
			 ReadCallback<Row> handler = readCallbacks[i];
			 ReadCommand command = commands.get(i);
			 try {
				 long startTime2 = System.currentTimeMillis();
				 Row row = handler.get();
				 if (row != null) {
					 command.maybeTrim(row);
					 rows.add(row);
				 }
				 if (logger.isDebugEnabled()) logger.debug(""Read: "" + (System.currentTimeMillis() - startTime2) + "" ms."");
			 }
			 catch (TimeoutException ex) {
				 if (logger.isDebugEnabled()) logger.debug(""Read timeout: {
				}
				"", ex.toString());
				 throw ex;
			 }
			 catch (DigestMismatchException ex) {
				 if (logger.isDebugEnabled()) logger.debug(""Digest mismatch: {
				}
				"", ex.toString());
				 RowRepairResolver resolver = new RowRepairResolver(command.table, command.key);
				 RepairCallback repairHandler = new RepairCallback(resolver, handler.endpoints);
				 if (repairCommands == null) {
					 repairCommands = new ArrayList<ReadCommand>();
					 repairResponseHandlers = new ArrayList<RepairCallback>();
				 }
				 repairCommands.add(command);
				 repairResponseHandlers.add(repairHandler);
				 MessageProducer producer = new CachingMessageProducer(command);
				 for (InetAddress endpoint : handler.endpoints) MessagingService.instance().sendRR(producer, endpoint, repairHandler);
			 }
		 }
		 if (commandsToRetry != Collections.EMPTY_LIST) commandsToRetry.clear();
		 if (repairResponseHandlers != null) {
			 for (int i = 0;
			 i < repairCommands.size();
			 i++) {
				 ReadCommand command = repairCommands.get(i);
				 RepairCallback handler = repairResponseHandlers.get(i);
				 FBUtilities.waitOnFutures(handler.resolver.repairResults, DatabaseDescriptor.getRpcTimeout());
				 Row row;
				 try {
					 row = handler.get();
				 }
				 catch (DigestMismatchException e) {
					 throw new AssertionError(e);
				 }
				 ReadCommand retryCommand = command.maybeGenerateRetryCommand(handler, row);
				 if (retryCommand != null) {
					 logger.debug(""issuing retry for read command"");
					 if (commandsToRetry == Collections.EMPTY_LIST) commandsToRetry = new ArrayList<ReadCommand>();
					 commandsToRetry.add(retryCommand);
					 continue;
				 }
				 if (row != null) {
					 command.maybeTrim(row);
					 rows.add(row);
				 }
			 }
		 }
	 }
	 while (!commandsToRetry.isEmpty());
	 return rows;
 }",0,0,1,0
"public class ScpFromMessage extends AbstractSshMessage {
	 private static final int HUNDRED_KILOBYTES = 102400;
	 private static final byte LINE_FEED = 0x0a;
	 private static final int BUFFER_SIZE = 1024;
	 private String remoteFile;
	 private File localFile;
	 private boolean isRecursive = false;
	 public ScpFromMessage(Session session) {
		 super(session);
	 }
	 public ScpFromMessage(boolean verbose, Session session) {
		 super(verbose, session);
	 }
	 public ScpFromMessage(boolean verbose, Session session, String aRemoteFile, File aLocalFile, boolean recursive) {
		 super(verbose, session);
		 this.remoteFile = aRemoteFile;
		 this.localFile = aLocalFile;
		 this.isRecursive = recursive;
	 }
	 public ScpFromMessage(Session session, String aRemoteFile, File aLocalFile, boolean recursive) {
		 this(false, session, aRemoteFile, aLocalFile, recursive);
	 }
	 public void execute() throws IOException, JSchException {
		 String command = ""scp -f "";
		 if (isRecursive) {
			 command += ""-r "";
		 }
		 command += remoteFile;
		 Channel channel = openExecChannel(command);
		 try {
			 OutputStream out = channel.getOutputStream();
			 InputStream in = channel.getInputStream();
			 channel.connect();
			 sendAck(out);
			 startRemoteCpProtocol(in, out, localFile);
		 }
		 finally {
			 if (channel != null) {
				 channel.disconnect();
			 }
		 }
		 log(""done\n"");
	 }
	 private void startRemoteCpProtocol(InputStream in, OutputStream out, File localFile) throws IOException {
		 File startFile = localFile;
		 while (true) {
			 ByteArrayOutputStream stream = new ByteArrayOutputStream();
			 while (true) {
				 int read = in.read();
				 if (read < 0) {
					 return;
				 }
				 if ((byte) read == LINE_FEED) {
					 break;
				 }
				 stream.write(read);
			 }
			 String serverResponse = stream.toString(""UTF-8"");
			 if (serverResponse.charAt(0) == 'C') {
				 parseAndFetchFile(serverResponse, startFile, out, in);
			 }
			 else if (serverResponse.charAt(0) == 'D') {
				 startFile = parseAndCreateDirectory(serverResponse, startFile);
				 sendAck(out);
			 }
			 else if (serverResponse.charAt(0) == 'E') {
				 startFile = startFile.getParentFile();
				 sendAck(out);
			 }
			 else if (serverResponse.charAt(0) == '\01' || serverResponse.charAt(0) == '\02') {
				 throw new IOException(serverResponse.substring(1));
			 }
		 }
	 }
	 private File parseAndCreateDirectory(String serverResponse, File localFile) {
		 int start = serverResponse.indexOf("" "");
		 start = serverResponse.indexOf("" "", start + 1);
		 String directoryName = serverResponse.substring(start + 1);
		 if (localFile.isDirectory()) {
			 File dir = new File(localFile, directoryName);
			 dir.mkdir();
			 log(""Creating: "" + dir);
			 return dir;
		 }
		 return null;
	 }
	 private void parseAndFetchFile(String serverResponse, File localFile, OutputStream out, InputStream in) throws IOException {
		 int start = 0;
		 int end = serverResponse.indexOf("" "", start + 1);
		 start = end + 1;
		 end = serverResponse.indexOf("" "", start + 1);
		 long filesize = Long.parseLong(serverResponse.substring(start, end));
		 String filename = serverResponse.substring(end + 1);
		 log(""Receiving: "" + filename + "" : "" + filesize);
		 File transferFile = (localFile.isDirectory()) ? new File(localFile, filename) : localFile;
		 fetchFile(transferFile, filesize, out, in);
		 waitForAck(in);
		 sendAck(out);
	 }
	 private void fetchFile(File localFile, long filesize, OutputStream out, InputStream in) throws IOException {
		 byte[] buf = new byte[BUFFER_SIZE];
		 sendAck(out);
		 FileOutputStream fos = new FileOutputStream(localFile);
		 int length;
		 long totalLength = 0;
		 long startTime = System.currentTimeMillis();
		 boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;
		 long initFilesize = filesize;
		 int percentTransmitted = 0;
		 try {
			 while (true) {
				 length = in.read(buf, 0, (BUFFER_SIZE < filesize) ? BUFFER_SIZE : (int) filesize);
				 if (length < 0) {
					 throw new EOFException(""Unexpected end of stream."");
				 }
				 fos.write(buf, 0, length);
				 filesize -= length;
				 totalLength += length;
				 if (filesize == 0) {
					 break;
				 }
				 if (trackProgress) {
					 percentTransmitted = trackProgress(initFilesize, totalLength, percentTransmitted);
				 }
			 }
		 }
		 finally {
			 long endTime = System.currentTimeMillis();
			 logStats(startTime, endTime, totalLength);
			 fos.flush();
			 fos.close();
		 }
	 }
}",0,0,0,0
"XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT, boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2, String k3, int v3, String k4, int v4);",0,0,0,1
"public static class beginBlobDownload_args implements org.apache.storm.thrift.TBase<beginBlobDownload_args, beginBlobDownload_args._Fields>, java.io.Serializable, Cloneable, Comparable<beginBlobDownload_args> {
	 private static final org.apache.storm.thrift.protocol.TStruct STRUCT_DESC = new org.apache.storm.thrift.protocol.TStruct(""beginBlobDownload_args"");
	 private static final org.apache.storm.thrift.protocol.TField KEY_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""key"", org.apache.storm.thrift.protocol.TType.STRING, (short)1);
	 private static final org.apache.storm.thrift.scheme.SchemeFactory STANDARD_SCHEME_FACTORY = new beginBlobDownload_argsStandardSchemeFactory();
	 private static final org.apache.storm.thrift.scheme.SchemeFactory TUPLE_SCHEME_FACTORY = new beginBlobDownload_argsTupleSchemeFactory();
	 private java.lang.String key;
	 public enum _Fields implements org.apache.storm.thrift.TFieldIdEnum {
		 KEY((short)1, ""key"");
		 private static final java.util.Map<java.lang.String, _Fields> byName = new java.util.HashMap<java.lang.String, _Fields>();
		 static {
			 for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {
				 byName.put(field.getFieldName(), field);
			 }
		 }
		 public static _Fields findByThriftId(int fieldId) {
			 switch(fieldId) {
				 case 1: return KEY;
				 default: return null;
			 }
		 }
		 public static _Fields findByThriftIdOrThrow(int fieldId) {
			 _Fields fields = findByThriftId(fieldId);
			 if (fields == null) throw new java.lang.IllegalArgumentException(""Field "" + fieldId + "" doesn't exist!"");
			 return fields;
		 }
		 public static _Fields findByName(java.lang.String name) {
			 return byName.get(name);
		 }
		 private final short _thriftId;
		 private final java.lang.String _fieldName;
		 _Fields(short thriftId, java.lang.String fieldName) {
			 _thriftId = thriftId;
			 _fieldName = fieldName;
		 }
		 public short getThriftFieldId() {
			 return _thriftId;
		 }
		 public java.lang.String getFieldName() {
			 return _fieldName;
		 }
	 }
	 public static final java.util.Map<_Fields, org.apache.storm.thrift.meta_data.FieldMetaData> metaDataMap;
	 static {
		 java.util.Map<_Fields, org.apache.storm.thrift.meta_data.FieldMetaData> tmpMap = new java.util.EnumMap<_Fields, org.apache.storm.thrift.meta_data.FieldMetaData>(_Fields.class);
		 tmpMap.put(_Fields.KEY, new org.apache.storm.thrift.meta_data.FieldMetaData(""key"", org.apache.storm.thrift.TFieldRequirementType.DEFAULT, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING)));
		 metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);
		 org.apache.storm.thrift.meta_data.FieldMetaData.addStructMetaDataMap(beginBlobDownload_args.class, metaDataMap);
	 }
	 public beginBlobDownload_args() {
	 }
	 public beginBlobDownload_args( java.lang.String key) {
		 this();
		 this.key = key;
	 }
	 public beginBlobDownload_args(beginBlobDownload_args other) {
		 if (other.is_set_key()) {
			 this.key = other.key;
		 }
	 }
	 public beginBlobDownload_args deepCopy() {
		 return new beginBlobDownload_args(this);
	 }
	 public void clear() {
		 this.key = null;
	 }
	 public java.lang.String get_key() {
		 return this.key;
	 }
	 public void set_key( java.lang.String key) {
		 this.key = key;
	 }
	 public void unset_key() {
		 this.key = null;
	 }
	 public boolean is_set_key() {
		 return this.key != null;
	 }
	 public void set_key_isSet(boolean value) {
		 if (!value) {
			 this.key = null;
		 }
	 }
	 public void setFieldValue(_Fields field, java.lang.Object value) {
		 switch (field) {
			 case KEY: if (value == null) {
				 unset_key();
			 }
			 else {
				 set_key((java.lang.String)value);
			 }
			 break;
		 }
	 }
	 public java.lang.Object getFieldValue(_Fields field) {
		 switch (field) {
			 case KEY: return get_key();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean isSet(_Fields field) {
		 if (field == null) {
			 throw new java.lang.IllegalArgumentException();
		 }
		 switch (field) {
			 case KEY: return is_set_key();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean equals(java.lang.Object that) {
		 if (that == null) return false;
		 if (that instanceof beginBlobDownload_args) return this.equals((beginBlobDownload_args)that);
		 return false;
	 }
	 public boolean equals(beginBlobDownload_args that) {
		 if (that == null) return false;
		 if (this == that) return true;
		 boolean this_present_key = true && this.is_set_key();
		 boolean that_present_key = true && that.is_set_key();
		 if (this_present_key || that_present_key) {
			 if (!(this_present_key && that_present_key)) return false;
			 if (!this.key.equals(that.key)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 int hashCode = 1;
		 hashCode = hashCode * 8191 + ((is_set_key()) ? 131071 : 524287);
		 if (is_set_key()) hashCode = hashCode * 8191 + key.hashCode();
		 return hashCode;
	 }
	 public int compareTo(beginBlobDownload_args other) {
		 if (!getClass().equals(other.getClass())) {
			 return getClass().getName().compareTo(other.getClass().getName());
		 }
		 int lastComparison = 0;
		 lastComparison = java.lang.Boolean.valueOf(is_set_key()).compareTo(other.is_set_key());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_key()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.key, other.key);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 return 0;
	 }
	 public _Fields fieldForId(int fieldId) {
		 return _Fields.findByThriftId(fieldId);
	 }
	 public void read(org.apache.storm.thrift.protocol.TProtocol iprot) throws org.apache.storm.thrift.TException {
		 scheme(iprot).read(iprot, this);
	 }
	 public void write(org.apache.storm.thrift.protocol.TProtocol oprot) throws org.apache.storm.thrift.TException {
		 scheme(oprot).write(oprot, this);
	 }
	 public java.lang.String toString() {
		 java.lang.StringBuilder sb = new java.lang.StringBuilder(""beginBlobDownload_args("");
		 boolean first = true;
		 sb.append(""key:"");
		 if (this.key == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.key);
		 }
		 first = false;
		 sb.append("")"");
		 return sb.toString();
	 }
	 public void validate() throws org.apache.storm.thrift.TException {
	 }
	 private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		 try {
			 write(new org.apache.storm.thrift.protocol.TCompactProtocol(new org.apache.storm.thrift.transport.TIOStreamTransport(out)));
		 }
		 catch (org.apache.storm.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {
		 try {
			 read(new org.apache.storm.thrift.protocol.TCompactProtocol(new org.apache.storm.thrift.transport.TIOStreamTransport(in)));
		 }
		 catch (org.apache.storm.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private static class beginBlobDownload_argsStandardSchemeFactory implements org.apache.storm.thrift.scheme.SchemeFactory {
		 public beginBlobDownload_argsStandardScheme getScheme() {
			 return new beginBlobDownload_argsStandardScheme();
		 }
	 }
	 private static class beginBlobDownload_argsStandardScheme extends org.apache.storm.thrift.scheme.StandardScheme<beginBlobDownload_args> {
		 public void read(org.apache.storm.thrift.protocol.TProtocol iprot, beginBlobDownload_args struct) throws org.apache.storm.thrift.TException {
			 org.apache.storm.thrift.protocol.TField schemeField;
			 iprot.readStructBegin();
			 while (true) {
				 schemeField = iprot.readFieldBegin();
				 if (schemeField.type == org.apache.storm.thrift.protocol.TType.STOP) {
					 break;
				 }
				 switch (schemeField.id) {
					 case 1: if (schemeField.type == org.apache.storm.thrift.protocol.TType.STRING) {
						 struct.key = iprot.readString();
						 struct.set_key_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 default: org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 iprot.readFieldEnd();
			 }
			 iprot.readStructEnd();
			 struct.validate();
		 }
		 public void write(org.apache.storm.thrift.protocol.TProtocol oprot, beginBlobDownload_args struct) throws org.apache.storm.thrift.TException {
			 struct.validate();
			 oprot.writeStructBegin(STRUCT_DESC);
			 if (struct.key != null) {
				 oprot.writeFieldBegin(KEY_FIELD_DESC);
				 oprot.writeString(struct.key);
				 oprot.writeFieldEnd();
			 }
			 oprot.writeFieldStop();
			 oprot.writeStructEnd();
		 }
	 }
	 private static class beginBlobDownload_argsTupleSchemeFactory implements org.apache.storm.thrift.scheme.SchemeFactory {
		 public beginBlobDownload_argsTupleScheme getScheme() {
			 return new beginBlobDownload_argsTupleScheme();
		 }
	 }
	 private static class beginBlobDownload_argsTupleScheme extends org.apache.storm.thrift.scheme.TupleScheme<beginBlobDownload_args> {
		 public void write(org.apache.storm.thrift.protocol.TProtocol prot, beginBlobDownload_args struct) throws org.apache.storm.thrift.TException {
			 org.apache.storm.thrift.protocol.TTupleProtocol oprot = (org.apache.storm.thrift.protocol.TTupleProtocol) prot;
			 java.util.BitSet optionals = new java.util.BitSet();
			 if (struct.is_set_key()) {
				 optionals.set(0);
			 }
			 oprot.writeBitSet(optionals, 1);
			 if (struct.is_set_key()) {
				 oprot.writeString(struct.key);
			 }
		 }
		 public void read(org.apache.storm.thrift.protocol.TProtocol prot, beginBlobDownload_args struct) throws org.apache.storm.thrift.TException {
			 org.apache.storm.thrift.protocol.TTupleProtocol iprot = (org.apache.storm.thrift.protocol.TTupleProtocol) prot;
			 java.util.BitSet incoming = iprot.readBitSet(1);
			 if (incoming.get(0)) {
				 struct.key = iprot.readString();
				 struct.set_key_isSet(true);
			 }
		 }
	 }
	 private static <S extends org.apache.storm.thrift.scheme.IScheme> S scheme(org.apache.storm.thrift.protocol.TProtocol proto) {
		 return (org.apache.storm.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();
	 }
 }",1,1,0,0
"public abstract class XMLScanner implements XMLComponent {
	 protected static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
	 protected static final String NAMESPACES = Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
	 protected static final String NOTIFY_CHAR_REFS = Constants.XERCES_FEATURE_PREFIX + Constants.NOTIFY_CHAR_REFS_FEATURE;
	protected static final String PARSER_SETTINGS = Constants.XERCES_FEATURE_PREFIX + Constants.PARSER_SETTINGS;
	 protected static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
	 protected static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
	 protected static final String ENTITY_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY;
	 protected static final boolean DEBUG_ATTR_NORMALIZATION = false;
	 protected boolean fValidation = false;
	 protected boolean fNamespaces;
	 protected boolean fNotifyCharRefs = false;
	protected boolean fParserSettings = true;
	 protected SymbolTable fSymbolTable;
	 protected XMLErrorReporter fErrorReporter;
	 protected XMLEntityManager fEntityManager;
	 protected XMLEntityScanner fEntityScanner;
	 protected int fEntityDepth;
	 protected String fCharRefLiteral = null;
	 protected boolean fScanningAttribute;
	 protected boolean fReportEntity;
	 protected final static String fVersionSymbol = ""version"".intern();
	 protected final static String fEncodingSymbol = ""encoding"".intern();
	 protected final static String fStandaloneSymbol = ""standalone"".intern();
	 protected final static String fAmpSymbol = ""amp"".intern();
	 protected final static String fLtSymbol = ""lt"".intern();
	 protected final static String fGtSymbol = ""gt"".intern();
	 protected final static String fQuotSymbol = ""quot"".intern();
	 protected final static String fAposSymbol = ""apos"".intern();
	 private final XMLString fString = new XMLString();
	 private final XMLStringBuffer fStringBuffer = new XMLStringBuffer();
	 private final XMLStringBuffer fStringBuffer2 = new XMLStringBuffer();
	 private final XMLStringBuffer fStringBuffer3 = new XMLStringBuffer();
	 protected final XMLResourceIdentifierImpl fResourceIdentifier = new XMLResourceIdentifierImpl();
	 public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
		try {
			fParserSettings = componentManager.getFeature(PARSER_SETTINGS);
		}
		 catch (XMLConfigurationException e) {
			fParserSettings = true;
		}
		if (!fParserSettings) {
			init();
			return;
		}
		 fSymbolTable = (SymbolTable)componentManager.getProperty(SYMBOL_TABLE);
		 fErrorReporter = (XMLErrorReporter)componentManager.getProperty(ERROR_REPORTER);
		 fEntityManager = (XMLEntityManager)componentManager.getProperty(ENTITY_MANAGER);
		 try {
			 fValidation = componentManager.getFeature(VALIDATION);
		 }
		 catch (XMLConfigurationException e) {
			 fValidation = false;
		 }
		 try {
			 fNamespaces = componentManager.getFeature(NAMESPACES);
		 }
		 catch (XMLConfigurationException e) {
			 fNamespaces = true;
		 }
		 try {
			 fNotifyCharRefs = componentManager.getFeature(NOTIFY_CHAR_REFS);
		 }
		 catch (XMLConfigurationException e) {
			 fNotifyCharRefs = false;
		 }
		 init();
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
		 if (propertyId.startsWith(Constants.XERCES_PROPERTY_PREFIX)) {
			 final int suffixLength = propertyId.length() - Constants.XERCES_PROPERTY_PREFIX.length();
			 if (suffixLength == Constants.SYMBOL_TABLE_PROPERTY.length() && propertyId.endsWith(Constants.SYMBOL_TABLE_PROPERTY)) {
				 fSymbolTable = (SymbolTable)value;
			 }
			 else if (suffixLength == Constants.ERROR_REPORTER_PROPERTY.length() && propertyId.endsWith(Constants.ERROR_REPORTER_PROPERTY)) {
				 fErrorReporter = (XMLErrorReporter)value;
			 }
			 else if (suffixLength == Constants.ENTITY_MANAGER_PROPERTY.length() && propertyId.endsWith(Constants.ENTITY_MANAGER_PROPERTY)) {
				 fEntityManager = (XMLEntityManager)value;
			 }
		 }
	 }
	 public void setFeature(String featureId, boolean value) throws XMLConfigurationException {
		 if (VALIDATION.equals(featureId)) {
			 fValidation = value;
		 }
		 else if (NOTIFY_CHAR_REFS.equals(featureId)) {
			 fNotifyCharRefs = value;
		 }
	 }
	 public boolean getFeature(String featureId) throws XMLConfigurationException {
		 if (VALIDATION.equals(featureId)) {
			 return fValidation;
		 }
		 else if (NOTIFY_CHAR_REFS.equals(featureId)) {
			 return fNotifyCharRefs;
		 }
		 throw new XMLConfigurationException(XMLConfigurationException.NOT_RECOGNIZED, featureId);
	 }
	 protected void reset() {
		 init();
		 fValidation = true;
		 fNotifyCharRefs = false;
	 }
	 protected void scanXMLDeclOrTextDecl(boolean scanningTextDecl, String[] pseudoAttributeValues) throws IOException, XNIException {
		 String version = null;
		 String encoding = null;
		 String standalone = null;
		 final int STATE_VERSION = 0;
		 final int STATE_ENCODING = 1;
		 final int STATE_STANDALONE = 2;
		 final int STATE_DONE = 3;
		 int state = STATE_VERSION;
		 boolean dataFoundForTarget = false;
		 boolean sawSpace = fEntityScanner.skipDeclSpaces();
		 XMLEntityManager.ScannedEntity currEnt = fEntityManager.getCurrentEntity();
		 boolean currLiteral = currEnt.literal;
		 currEnt.literal = false;
		 while (fEntityScanner.peekChar() != '?') {
			 dataFoundForTarget = true;
			 String name = scanPseudoAttribute(scanningTextDecl, fString);
			 switch (state) {
				 case STATE_VERSION: {
					 if (name == fVersionSymbol) {
						 if (!sawSpace) {
							 reportFatalError(scanningTextDecl ? ""SpaceRequiredBeforeVersionInTextDecl"" : ""SpaceRequiredBeforeVersionInXMLDecl"", null);
						 }
						 version = fString.toString();
						 state = STATE_ENCODING;
						 if (!versionSupported(version)) {
							 reportFatalError(getVersionNotSupportedKey(), new Object[]{
							version}
							);
						 }
					 }
					 else if (name == fEncodingSymbol) {
						 if (!scanningTextDecl) {
							 reportFatalError(""VersionInfoRequired"", null);
						 }
						 if (!sawSpace) {
							 reportFatalError(scanningTextDecl ? ""SpaceRequiredBeforeEncodingInTextDecl"" : ""SpaceRequiredBeforeEncodingInXMLDecl"", null);
						 }
						 encoding = fString.toString();
						 state = scanningTextDecl ? STATE_DONE : STATE_STANDALONE;
					 }
					 else {
						 if (scanningTextDecl) {
							 reportFatalError(""EncodingDeclRequired"", null);
						 }
						 else {
							 reportFatalError(""VersionInfoRequired"", null);
						 }
					 }
					 break;
				 }
				 case STATE_ENCODING: {
					 if (name == fEncodingSymbol) {
						 if (!sawSpace) {
							 reportFatalError(scanningTextDecl ? ""SpaceRequiredBeforeEncodingInTextDecl"" : ""SpaceRequiredBeforeEncodingInXMLDecl"", null);
						 }
						 encoding = fString.toString();
						 state = scanningTextDecl ? STATE_DONE : STATE_STANDALONE;
					 }
					 else if (!scanningTextDecl && name == fStandaloneSymbol) {
						 if (!sawSpace) {
							 reportFatalError(""SpaceRequiredBeforeStandalone"", null);
						 }
						 standalone = fString.toString();
						 state = STATE_DONE;
						 if (!standalone.equals(""yes"") && !standalone.equals(""no"")) {
							 reportFatalError(""SDDeclInvalid"", new Object[] {
							standalone}
							);
						 }
					 }
					 else {
						 reportFatalError(""EncodingDeclRequired"", null);
					 }
					 break;
				 }
				 case STATE_STANDALONE: {
					 if (name == fStandaloneSymbol) {
						 if (!sawSpace) {
							 reportFatalError(""SpaceRequiredBeforeStandalone"", null);
						 }
						 standalone = fString.toString();
						 state = STATE_DONE;
						 if (!standalone.equals(""yes"") && !standalone.equals(""no"")) {
							 reportFatalError(""SDDeclInvalid"", new Object[] {
							standalone}
							);
						 }
					 }
					 else {
						 reportFatalError(""EncodingDeclRequired"", null);
					 }
					 break;
				 }
				 default: {
					 reportFatalError(""NoMorePseudoAttributes"", null);
				 }
			 }
			 sawSpace = fEntityScanner.skipDeclSpaces();
		 }
		 if(currLiteral) currEnt.literal = true;
		 if (scanningTextDecl && state != STATE_DONE) {
			 reportFatalError(""MorePseudoAttributes"", null);
		 }
		 if (scanningTextDecl) {
			 if (!dataFoundForTarget && encoding == null) {
				 reportFatalError(""EncodingDeclRequired"", null);
			 }
		 }
		 else {
			 if (!dataFoundForTarget && version == null) {
				 reportFatalError(""VersionInfoRequired"", null);
			 }
		 }
		 if (!fEntityScanner.skipChar('?')) {
			 reportFatalError(""XMLDeclUnterminated"", null);
		 }
		 if (!fEntityScanner.skipChar('>')) {
			 reportFatalError(""XMLDeclUnterminated"", null);
		 }
		 pseudoAttributeValues[0] = version;
		 pseudoAttributeValues[1] = encoding;
		 pseudoAttributeValues[2] = standalone;
	 }
	 public String scanPseudoAttribute(boolean scanningTextDecl, XMLString value) throws IOException, XNIException {
		 String name = fEntityScanner.scanName();
		 XMLEntityManager.print(fEntityManager.getCurrentEntity());
		 if (name == null) {
			 reportFatalError(""PseudoAttrNameExpected"", null);
		 }
		 fEntityScanner.skipDeclSpaces();
		 if (!fEntityScanner.skipChar('=')) {
			 reportFatalError(scanningTextDecl ? ""EqRequiredInTextDecl"" : ""EqRequiredInXMLDecl"", new Object[]{
			name}
			);
		 }
		 fEntityScanner.skipDeclSpaces();
		 int quote = fEntityScanner.peekChar();
		 if (quote != '\'' && quote != '""') {
			 reportFatalError(scanningTextDecl ? ""QuoteRequiredInTextDecl"" : ""QuoteRequiredInXMLDecl"" , new Object[]{
			name}
			);
		 }
		 fEntityScanner.scanChar();
		 int c = fEntityScanner.scanLiteral(quote, value);
		 if (c != quote) {
			 fStringBuffer2.clear();
			 do {
				 fStringBuffer2.append(value);
				 if (c != -1) {
					 if (c == '&' || c == '%' || c == '<' || c == ']') {
						 fStringBuffer2.append((char)fEntityScanner.scanChar());
					 }
					 else if (XMLChar.isHighSurrogate(c)) {
						 scanSurrogates(fStringBuffer2);
					 }
					 else if (isInvalidLiteral(c)) {
						 String key = scanningTextDecl ? ""InvalidCharInTextDecl"" : ""InvalidCharInXMLDecl"";
						 reportFatalError(key, new Object[] {
						Integer.toString(c, 16)}
						);
						 fEntityScanner.scanChar();
					 }
				 }
				 c = fEntityScanner.scanLiteral(quote, value);
			 }
			 while (c != quote);
			 fStringBuffer2.append(value);
			 value.setValues(fStringBuffer2);
		 }
		 if (!fEntityScanner.skipChar(quote)) {
			 reportFatalError(scanningTextDecl ? ""CloseQuoteMissingInTextDecl"" : ""CloseQuoteMissingInXMLDecl"", new Object[]{
			name}
			);
		 }
		 return name;
	 }
	 protected void scanPI() throws IOException, XNIException {
		 fReportEntity = false;
		 String target = null;
		 if(fNamespaces) {
			 target = fEntityScanner.scanNCName();
		 }
		 else {
			 target = fEntityScanner.scanName();
		 }
		 if (target == null) {
			 reportFatalError(""PITargetRequired"", null);
		 }
		 scanPIData(target, fString);
		 fReportEntity = true;
	 }
	 protected void scanPIData(String target, XMLString data) throws IOException, XNIException {
		 if (target.length() == 3) {
			 char c0 = Character.toLowerCase(target.charAt(0));
			 char c1 = Character.toLowerCase(target.charAt(1));
			 char c2 = Character.toLowerCase(target.charAt(2));
			 if (c0 == 'x' && c1 == 'm' && c2 == 'l') {
				 reportFatalError(""ReservedPITarget"", null);
			 }
		 }
		 if (!fEntityScanner.skipSpaces()) {
			 if (fEntityScanner.skipString(""?>"")) {
				 data.clear();
				 return;
			 }
			 else {
				 if(fNamespaces && fEntityScanner.peekChar() == ':') {
					 fEntityScanner.scanChar();
					 XMLStringBuffer colonName = new XMLStringBuffer(target);
					 colonName.append("":"");
					 String str = fEntityScanner.scanName();
					 if (str != null) colonName.append(str);
					 reportFatalError(""ColonNotLegalWithNS"", new Object[] {
					colonName.toString()}
					);
					 fEntityScanner.skipSpaces();
				 }
				 else {
					 reportFatalError(""SpaceRequiredInPI"", null);
				 }
			 }
		 }
		 fStringBuffer.clear();
		 if (fEntityScanner.scanData(""?>"", fStringBuffer)) {
			 do {
				 int c = fEntityScanner.peekChar();
				 if (c != -1) {
					 if (XMLChar.isHighSurrogate(c)) {
						 scanSurrogates(fStringBuffer);
					 }
					 else if (isInvalidLiteral(c)) {
						 reportFatalError(""InvalidCharInPI"", new Object[]{
						Integer.toHexString(c)}
						);
						 fEntityScanner.scanChar();
					 }
				 }
			 }
			 while (fEntityScanner.scanData(""?>"", fStringBuffer));
		 }
		 data.setValues(fStringBuffer);
	 }
	 protected void scanComment(XMLStringBuffer text) throws IOException, XNIException {
		 text.clear();
		 while (fEntityScanner.scanData(""--"", text)) {
			 int c = fEntityScanner.peekChar();
			 if (c != -1) {
				 if (XMLChar.isHighSurrogate(c)) {
					 scanSurrogates(text);
				 }
				 else if (isInvalidLiteral(c)) {
					 reportFatalError(""InvalidCharInComment"", new Object[] {
					 Integer.toHexString(c) }
					);
					 fEntityScanner.scanChar();
				 }
			 }
		 }
		 if (!fEntityScanner.skipChar('>')) {
			 reportFatalError(""DashDashInComment"", null);
		 }
	 }
	 protected boolean scanAttributeValue(XMLString value, XMLString nonNormalizedValue, String atName, boolean checkEntities,String eleName) throws IOException, XNIException {
		 int quote = fEntityScanner.peekChar();
		 if (quote != '\'' && quote != '""') {
			reportFatalError(""OpenQuoteExpected"", new Object[]{
			eleName,atName}
			);
		 }
		 fEntityScanner.scanChar();
		 int entityDepth = fEntityDepth;
		 int c = fEntityScanner.scanLiteral(quote, value);
		 if (DEBUG_ATTR_NORMALIZATION) {
			 System.out.println(""** scanLiteral -> \"""" + value.toString() + ""\"""");
		 }
		 int fromIndex = 0;
		 if (c == quote && (fromIndex = isUnchangedByNormalization(value)) == -1) {
			 nonNormalizedValue.setValues(value);
			 int cquote = fEntityScanner.scanChar();
			 if (cquote != quote) {
				 reportFatalError(""CloseQuoteExpected"", new Object[]{
				eleName,atName}
				);
			 }
			 return true;
		 }
		 fStringBuffer2.clear();
		 fStringBuffer2.append(value);
		 normalizeWhitespace(value, fromIndex);
		 if (DEBUG_ATTR_NORMALIZATION) {
			 System.out.println(""** normalizeWhitespace -> \"""" + value.toString() + ""\"""");
		 }
		 if (c != quote) {
			 fScanningAttribute = true;
			 fStringBuffer.clear();
			 do {
				 fStringBuffer.append(value);
				 if (DEBUG_ATTR_NORMALIZATION) {
					 System.out.println(""** value2: \"""" + fStringBuffer.toString() + ""\"""");
				 }
				 if (c == '&') {
					 fEntityScanner.skipChar('&');
					 if (entityDepth == fEntityDepth) {
						 fStringBuffer2.append('&');
					 }
					 if (fEntityScanner.skipChar('#')) {
						 if (entityDepth == fEntityDepth) {
							 fStringBuffer2.append('#');
						 }
						 int ch = scanCharReferenceValue(fStringBuffer, fStringBuffer2);
						 if (ch != -1) {
							 if (DEBUG_ATTR_NORMALIZATION) {
								 System.out.println(""** value3: \"""" + fStringBuffer.toString() + ""\"""");
							 }
						 }
					 }
					 else {
						 String entityName = fEntityScanner.scanName();
						 if (entityName == null) {
							 reportFatalError(""NameRequiredInReference"", null);
						 }
						 else if (entityDepth == fEntityDepth) {
							 fStringBuffer2.append(entityName);
						 }
						 if (!fEntityScanner.skipChar(';
						')) {
							 reportFatalError(""SemicolonRequiredInReference"", new Object []{
							entityName}
							);
						 }
						 else if (entityDepth == fEntityDepth) {
							 fStringBuffer2.append(';
							');
						 }
						 if (entityName == fAmpSymbol) {
							 fStringBuffer.append('&');
							 if (DEBUG_ATTR_NORMALIZATION) {
								 System.out.println(""** value5: \"""" + fStringBuffer.toString() + ""\"""");
							 }
						 }
						 else if (entityName == fAposSymbol) {
							 fStringBuffer.append('\'');
							 if (DEBUG_ATTR_NORMALIZATION) {
								 System.out.println(""** value7: \"""" + fStringBuffer.toString() + ""\"""");
							 }
						 }
						 else if (entityName == fLtSymbol) {
							 fStringBuffer.append('<');
							 if (DEBUG_ATTR_NORMALIZATION) {
								 System.out.println(""** value9: \"""" + fStringBuffer.toString() + ""\"""");
							 }
						 }
						 else if (entityName == fGtSymbol) {
							 fStringBuffer.append('>');
							 if (DEBUG_ATTR_NORMALIZATION) {
								 System.out.println(""** valueB: \"""" + fStringBuffer.toString() + ""\"""");
							 }
						 }
						 else if (entityName == fQuotSymbol) {
							 fStringBuffer.append('""');
							 if (DEBUG_ATTR_NORMALIZATION) {
								 System.out.println(""** valueD: \"""" + fStringBuffer.toString() + ""\"""");
							 }
						 }
						 else {
							 if (fEntityManager.isExternalEntity(entityName)) {
								 reportFatalError(""ReferenceToExternalEntity"", new Object[] {
								 entityName }
								);
							 }
							 else {
								 if (!fEntityManager.isDeclaredEntity(entityName)) {
									 if (checkEntities) {
										 if (fValidation) {
											 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""EntityNotDeclared"", new Object[]{
											entityName}
											, XMLErrorReporter.SEVERITY_ERROR);
										 }
									 }
									 else {
										 reportFatalError(""EntityNotDeclared"", new Object[]{
										entityName}
										);
									 }
								 }
								 fEntityManager.startEntity(entityName, true);
							 }
						 }
					 }
				 }
				 else if (c == '<') {
					 reportFatalError(""LessthanInAttValue"", new Object[] {
					 eleName, atName }
					);
					 fEntityScanner.scanChar();
					 if (entityDepth == fEntityDepth) {
						 fStringBuffer2.append((char)c);
					 }
				 }
				 else if (c == '%' || c == ']') {
					 fEntityScanner.scanChar();
					 fStringBuffer.append((char)c);
					 if (entityDepth == fEntityDepth) {
						 fStringBuffer2.append((char)c);
					 }
					 if (DEBUG_ATTR_NORMALIZATION) {
						 System.out.println(""** valueF: \"""" + fStringBuffer.toString() + ""\"""");
					 }
				 }
				 else if (c == '\n' || c == '\r') {
					 fEntityScanner.scanChar();
					 fStringBuffer.append(' ');
					 if (entityDepth == fEntityDepth) {
						 fStringBuffer2.append('\n');
					 }
				 }
				 else if (c != -1 && XMLChar.isHighSurrogate(c)) {
					 fStringBuffer3.clear();
					 if (scanSurrogates(fStringBuffer3)) {
						 fStringBuffer.append(fStringBuffer3);
						 if (entityDepth == fEntityDepth) {
							 fStringBuffer2.append(fStringBuffer3);
						 }
						 if (DEBUG_ATTR_NORMALIZATION) {
							 System.out.println(""** valueI: \"""" + fStringBuffer.toString() + ""\"""");
						 }
					 }
				 }
				 else if (c != -1 && isInvalidLiteral(c)) {
					 reportFatalError(""InvalidCharInAttValue"",new Object[] {
					eleName, atName, Integer.toString(c, 16)}
					);
					 fEntityScanner.scanChar();
					 if (entityDepth == fEntityDepth) {
						 fStringBuffer2.append((char)c);
					 }
				 }
				 c = fEntityScanner.scanLiteral(quote, value);
				 if (entityDepth == fEntityDepth) {
					 fStringBuffer2.append(value);
				 }
				 normalizeWhitespace(value);
			 }
			 while (c != quote || entityDepth != fEntityDepth);
			 fStringBuffer.append(value);
			 if (DEBUG_ATTR_NORMALIZATION) {
				 System.out.println(""** valueN: \"""" + fStringBuffer.toString() + ""\"""");
			 }
			 value.setValues(fStringBuffer);
			 fScanningAttribute = false;
		 }
		 nonNormalizedValue.setValues(fStringBuffer2);
		 int cquote = fEntityScanner.scanChar();
		 if (cquote != quote) {
			reportFatalError(""CloseQuoteExpected"", new Object[]{
			eleName,atName}
			);
		 }
		 return nonNormalizedValue.equals(value.ch, value.offset, value.length);
	 }
	 protected void scanExternalID(String[] identifiers, boolean optionalSystemId) throws IOException, XNIException {
		 String systemId = null;
		 String publicId = null;
		 if (fEntityScanner.skipString(""PUBLIC"")) {
			 if (!fEntityScanner.skipSpaces()) {
				 reportFatalError(""SpaceRequiredAfterPUBLIC"", null);
			 }
			 scanPubidLiteral(fString);
			 publicId = fString.toString();
			 if (!fEntityScanner.skipSpaces() && !optionalSystemId) {
				 reportFatalError(""SpaceRequiredBetweenPublicAndSystem"", null);
			 }
		 }
		 if (publicId != null || fEntityScanner.skipString(""SYSTEM"")) {
			 if (publicId == null && !fEntityScanner.skipSpaces()) {
				 reportFatalError(""SpaceRequiredAfterSYSTEM"", null);
			 }
			 int quote = fEntityScanner.peekChar();
			 if (quote != '\'' && quote != '""') {
				 if (publicId != null && optionalSystemId) {
					 identifiers[0] = null;
					 identifiers[1] = publicId;
					 return;
				 }
				 reportFatalError(""QuoteRequiredInSystemID"", null);
			 }
			 fEntityScanner.scanChar();
			 XMLString ident = fString;
			 if (fEntityScanner.scanLiteral(quote, ident) != quote) {
				 fStringBuffer.clear();
				 do {
					 fStringBuffer.append(ident);
					 int c = fEntityScanner.peekChar();
					 if (XMLChar.isMarkup(c) || c == ']') {
						 fStringBuffer.append((char)fEntityScanner.scanChar());
					 }
					 else if (XMLChar.isHighSurrogate(c)) {
						 scanSurrogates(fStringBuffer);
					 }
					 else if (isInvalidLiteral(c)) {
						 reportFatalError(""InvalidCharInSystemID"", new Object[] {
						 Integer.toHexString(c) }
						);
						 fEntityScanner.scanChar();
					 }
				 }
				 while (fEntityScanner.scanLiteral(quote, ident) != quote);
				 fStringBuffer.append(ident);
				 ident = fStringBuffer;
			 }
			 systemId = ident.toString();
			 if (!fEntityScanner.skipChar(quote)) {
				 reportFatalError(""SystemIDUnterminated"", null);
			 }
		 }
		 identifiers[0] = systemId;
		 identifiers[1] = publicId;
	 }
	 protected boolean scanPubidLiteral(XMLString literal) throws IOException, XNIException {
		 int quote = fEntityScanner.scanChar();
		 if (quote != '\'' && quote != '""') {
			 reportFatalError(""QuoteRequiredInPublicID"", null);
			 return false;
		 }
		 fStringBuffer.clear();
		 boolean skipSpace = true;
		 boolean dataok = true;
		 while (true) {
			 int c = fEntityScanner.scanChar();
			 if (c == ' ' || c == '\n' || c == '\r') {
				 if (!skipSpace) {
					 fStringBuffer.append(' ');
					 skipSpace = true;
				 }
			 }
			 else if (c == quote) {
				 if (skipSpace) {
					 fStringBuffer.length--;
				 }
				 literal.setValues(fStringBuffer);
				 break;
			 }
			 else if (XMLChar.isPubid(c)) {
				 fStringBuffer.append((char)c);
				 skipSpace = false;
			 }
			 else if (c == -1) {
				 reportFatalError(""PublicIDUnterminated"", null);
				 return false;
			 }
			 else {
				 dataok = false;
				 reportFatalError(""InvalidCharInPublicID"", new Object[]{
				Integer.toHexString(c)}
				);
			 }
		 }
		 return dataok;
	 }
	 protected void normalizeWhitespace(XMLString value) {
		 int end = value.offset + value.length;
		 for (int i = value.offset;
		 i < end;
		 ++i) {
			 int c = value.ch[i];
			 if (c < 0x20) {
				 value.ch[i] = ' ';
			 }
		 }
	 }
	 protected void normalizeWhitespace(XMLString value, int fromIndex) {
		 int end = value.offset + value.length;
		 for (int i = value.offset + fromIndex;
		 i < end;
		 ++i) {
			 int c = value.ch[i];
			 if (c < 0x20) {
				 value.ch[i] = ' ';
			 }
		 }
	 }
	 protected int isUnchangedByNormalization(XMLString value) {
		 int end = value.offset + value.length;
		 for (int i = value.offset;
		 i < end;
		 ++i) {
			 int c = value.ch[i];
			 if (c < 0x20) {
				 return i - value.offset;
			 }
		 }
		 return -1;
	 }
	 public void startEntity(String name, XMLResourceIdentifier identifier, String encoding, Augmentations augs) throws XNIException {
		 fEntityDepth++;
		 fEntityScanner = fEntityManager.getEntityScanner();
	 }
	 public void endEntity(String name, Augmentations augs) throws XNIException {
		 fEntityDepth--;
	 }
	 protected int scanCharReferenceValue(XMLStringBuffer buf, XMLStringBuffer buf2) throws IOException, XNIException {
		 boolean hex = false;
		 if (fEntityScanner.skipChar('x')) {
			 if (buf2 != null) {
				 buf2.append('x');
			 }
			 hex = true;
			 fStringBuffer3.clear();
			 boolean digit = true;
			 int c = fEntityScanner.peekChar();
			 digit = (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
			 if (digit) {
				 if (buf2 != null) {
					 buf2.append((char)c);
				 }
				 fEntityScanner.scanChar();
				 fStringBuffer3.append((char)c);
				 do {
					 c = fEntityScanner.peekChar();
					 digit = (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
					 if (digit) {
						 if (buf2 != null) {
							 buf2.append((char)c);
						 }
						 fEntityScanner.scanChar();
						 fStringBuffer3.append((char)c);
					 }
				 }
				 while (digit);
			 }
			 else {
				 reportFatalError(""HexdigitRequiredInCharRef"", null);
			 }
		 }
		 else {
			 fStringBuffer3.clear();
			 boolean digit = true;
			 int c = fEntityScanner.peekChar();
			 digit = c >= '0' && c <= '9';
			 if (digit) {
				 if (buf2 != null) {
					 buf2.append((char)c);
				 }
				 fEntityScanner.scanChar();
				 fStringBuffer3.append((char)c);
				 do {
					 c = fEntityScanner.peekChar();
					 digit = c >= '0' && c <= '9';
					 if (digit) {
						 if (buf2 != null) {
							 buf2.append((char)c);
						 }
						 fEntityScanner.scanChar();
						 fStringBuffer3.append((char)c);
					 }
				 }
				 while (digit);
			 }
			 else {
				 reportFatalError(""DigitRequiredInCharRef"", null);
			 }
		 }
		 if (!fEntityScanner.skipChar(';
		')) {
			 reportFatalError(""SemicolonRequiredInCharRef"", null);
		 }
		 if (buf2 != null) {
			 buf2.append(';
			');
		 }
		 int value = -1;
		 try {
			 value = Integer.parseInt(fStringBuffer3.toString(), hex ? 16 : 10);
			 if (isInvalid(value)) {
				 StringBuffer errorBuf = new StringBuffer(fStringBuffer3.length + 1);
				 if (hex) errorBuf.append('x');
				 errorBuf.append(fStringBuffer3.ch, fStringBuffer3.offset, fStringBuffer3.length);
				 reportFatalError(""InvalidCharRef"", new Object[]{
				errorBuf.toString()}
				);
			 }
		 }
		 catch (NumberFormatException e) {
			 StringBuffer errorBuf = new StringBuffer(fStringBuffer3.length + 1);
			 if (hex) errorBuf.append('x');
			 errorBuf.append(fStringBuffer3.ch, fStringBuffer3.offset, fStringBuffer3.length);
			 reportFatalError(""InvalidCharRef"", new Object[]{
			errorBuf.toString()}
			);
		 }
		 if (!XMLChar.isSupplemental(value)) {
			 buf.append((char) value);
		 }
		 else {
			 buf.append(XMLChar.highSurrogate(value));
			 buf.append(XMLChar.lowSurrogate(value));
		 }
		 if (fNotifyCharRefs && value != -1) {
			 String literal = ""#"" + (hex ? ""x"" : """") + fStringBuffer3.toString();
			 if (!fScanningAttribute) {
				 fCharRefLiteral = literal;
			 }
		 }
		 return value;
	 }
	 protected boolean isInvalid(int value) {
		 return (XMLChar.isInvalid(value));
	 }
	 protected boolean isInvalidLiteral(int value) {
		 return (XMLChar.isInvalid(value));
	 }
	 protected boolean isValidNameChar(int value) {
		 return (XMLChar.isName(value));
	 }
	 protected boolean isValidNameStartChar(int value) {
		 return (XMLChar.isNameStart(value));
	 }
	 protected boolean isValidNCName(int value) {
		 return (XMLChar.isNCName(value));
	 }
	 protected boolean isValidNameStartHighSurrogate(int value) {
		 return false;
	 }
	 protected boolean versionSupported(String version ) {
		 return version.equals(""1.0"");
	 }
	 protected String getVersionNotSupportedKey () {
		 return ""VersionNotSupported"";
	 }
	 protected boolean scanSurrogates(XMLStringBuffer buf) throws IOException, XNIException {
		 int high = fEntityScanner.scanChar();
		 int low = fEntityScanner.peekChar();
		 if (!XMLChar.isLowSurrogate(low)) {
			 reportFatalError(""InvalidCharInContent"", new Object[] {
			Integer.toString(high, 16)}
			);
			 return false;
		 }
		 fEntityScanner.scanChar();
		 int c = XMLChar.supplemental((char)high, (char)low);
		 if (isInvalid(c)) {
			 reportFatalError(""InvalidCharInContent"", new Object[]{
			Integer.toString(c, 16)}
			);
			 return false;
		 }
		 buf.append((char)high);
		 buf.append((char)low);
		 return true;
	 }
	 protected void reportFatalError(String msgId, Object[] args) throws XNIException {
		 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, msgId, args, XMLErrorReporter.SEVERITY_FATAL_ERROR);
	 }
	 private void init() {
		 fEntityScanner = null;
		 fEntityDepth = 0;
		 fReportEntity = true;
		 fResourceIdentifier.clear();
	 }
 }",1,0,0,0
"class PdfStamperImp extends PdfWriter {
	 HashMap<PdfReader, IntHashtable> readers2intrefs = new HashMap<PdfReader, IntHashtable>();
	 HashMap<PdfReader, RandomAccessFileOrArray> readers2file = new HashMap<PdfReader, RandomAccessFileOrArray>();
	 RandomAccessFileOrArray file;
	 PdfReader reader;
	 IntHashtable myXref = new IntHashtable();
	 HashMap<PdfDictionary, PageStamp> pagesToContent = new HashMap<PdfDictionary, PageStamp>();
	 boolean closed = false;
	 private boolean rotateContents = true;
	 protected AcroFields acroFields;
	 protected boolean flat = false;
	 protected boolean flatFreeText = false;
	 protected int namePtr[] = {
	0}
	;
	 protected HashSet<String> partialFlattening = new HashSet<String>();
	 protected boolean useVp = false;
	 protected PdfViewerPreferencesImp viewerPreferences = new PdfViewerPreferencesImp();
	 protected HashSet<PdfTemplate> fieldTemplates = new HashSet<PdfTemplate>();
	 protected boolean fieldsAdded = false;
	 protected int sigFlags = 0;
	 protected boolean append;
	 protected IntHashtable marked;
	 protected int initialXrefSize;
	 protected PdfAction openAction;
	 PdfStamperImp(PdfReader reader, OutputStream os, char pdfVersion, boolean append) throws DocumentException, IOException {
		 super(new PdfDocument(), os);
		 if (!reader.isOpenedWithFullPermissions()) throw new BadPasswordException(MessageLocalization.getComposedMessage(""pdfreader.not.opened.with.owner.password""));
		 if (reader.isTampered()) throw new DocumentException(MessageLocalization.getComposedMessage(""the.original.document.was.reused.read.it.again.from.file""));
		 reader.setTampered(true);
		 this.reader = reader;
		 file = reader.getSafeFile();
		 this.append = append;
		 if (append) {
			 if (reader.isRebuilt()) throw new DocumentException(MessageLocalization.getComposedMessage(""append.mode.requires.a.document.without.errors.even.if.recovery.was.possible""));
			 if (reader.isEncrypted()) crypto = new PdfEncryption(reader.getDecrypt());
			 pdf_version.setAppendmode(true);
			 file.reOpen();
			 byte buf[] = new byte[8192];
			 int n;
			 while ((n = file.read(buf)) > 0) this.os.write(buf, 0, n);
			 file.close();
			 prevxref = reader.getLastXref();
			 reader.setAppendable(true);
		 }
		 else {
			 if (pdfVersion == 0) super.setPdfVersion(reader.getPdfVersion());
			 else super.setPdfVersion(pdfVersion);
		 }
		 super.open();
		 pdf.addWriter(this);
		 if (append) {
			 body.setRefnum(reader.getXrefSize());
			 marked = new IntHashtable();
			 if (reader.isNewXrefType()) fullCompression = true;
			 if (reader.isHybridXref()) fullCompression = false;
		 }
		 initialXrefSize = reader.getXrefSize();
	 }
	 void close(HashMap<String, String> moreInfo) throws IOException {
		 if (closed) return;
		 if (useVp) {
			 reader.setViewerPreferences(viewerPreferences);
			 markUsed(reader.getTrailer().get(PdfName.ROOT));
		 }
		 if (flat) flatFields();
		 if (flatFreeText) flatFreeTextFields();
		 addFieldResources();
		 PdfDictionary catalog = reader.getCatalog();
		 PdfDictionary pages = (PdfDictionary)PdfReader.getPdfObject(catalog.get(PdfName.PAGES));
		 pages.put(PdfName.ITXT, new PdfString(Document.getRelease()));
		 markUsed(pages);
		 PdfDictionary acroForm = (PdfDictionary)PdfReader.getPdfObject(catalog.get(PdfName.ACROFORM), reader.getCatalog());
		 if (acroFields != null && acroFields.getXfa().isChanged()) {
			 markUsed(acroForm);
			 if (!flat) acroFields.getXfa().setXfa(this);
		 }
		 if (sigFlags != 0) {
			 if (acroForm != null) {
				 acroForm.put(PdfName.SIGFLAGS, new PdfNumber(sigFlags));
				 markUsed(acroForm);
				 markUsed(catalog);
			 }
		 }
		 closed = true;
		 addSharedObjectsToBody();
		 setOutlines();
		 setJavaScript();
		 addFileAttachments();
		 if (openAction != null) {
			 catalog.put(PdfName.OPENACTION, openAction);
		 }
		 if (pdf.pageLabels != null) catalog.put(PdfName.PAGELABELS, pdf.pageLabels.getDictionary(this));
		 if (!documentOCG.isEmpty()) {
			 fillOCProperties(false);
			 PdfDictionary ocdict = catalog.getAsDict(PdfName.OCPROPERTIES);
			 if (ocdict == null) {
				 reader.getCatalog().put(PdfName.OCPROPERTIES, OCProperties);
			 }
			 else {
				 ocdict.put(PdfName.OCGS, OCProperties.get(PdfName.OCGS));
				 PdfDictionary ddict = ocdict.getAsDict(PdfName.D);
				 if (ddict == null) {
					 ddict = new PdfDictionary();
					 ocdict.put(PdfName.D, ddict);
				 }
				 ddict.put(PdfName.ORDER, OCProperties.getAsDict(PdfName.D).get(PdfName.ORDER));
				 ddict.put(PdfName.RBGROUPS, OCProperties.getAsDict(PdfName.D).get(PdfName.RBGROUPS));
				 ddict.put(PdfName.OFF, OCProperties.getAsDict(PdfName.D).get(PdfName.OFF));
				 ddict.put(PdfName.AS, OCProperties.getAsDict(PdfName.D).get(PdfName.AS));
			 }
		 }
		 int skipInfo = -1;
		 PRIndirectReference iInfo = (PRIndirectReference)reader.getTrailer().get(PdfName.INFO);
		 PdfDictionary oldInfo = (PdfDictionary)PdfReader.getPdfObject(iInfo);
		 String producer = null;
		 if (iInfo != null) skipInfo = iInfo.getNumber();
		 if (oldInfo != null && oldInfo.get(PdfName.PRODUCER) != null) producer = oldInfo.getAsString(PdfName.PRODUCER).toUnicodeString();
		 if (producer == null) {
			 producer = Document.getVersion();
		 }
		 else if (producer.indexOf(Document.getProduct()) == -1) {
			 StringBuffer buf = new StringBuffer(producer);
			 buf.append("";
			 modified using "");
			 buf.append(Document.getVersion());
			 producer = buf.toString();
		 }
		 byte[] altMetadata = null;
		 PdfObject xmpo = PdfReader.getPdfObject(catalog.get(PdfName.METADATA));
		 if (xmpo != null && xmpo.isStream()) {
			 altMetadata = PdfReader.getStreamBytesRaw((PRStream)xmpo);
			 PdfReader.killIndirect(catalog.get(PdfName.METADATA));
		 }
		 if (xmpMetadata != null) {
			 altMetadata = xmpMetadata;
		 }
		 PdfDate date = new PdfDate();
		 if (altMetadata != null) {
			 PdfStream xmp;
			 try {
				 XmpReader xmpr = new XmpReader(altMetadata);
			 if (!(xmpr.replaceNode(""http: || xmpr.replaceDescriptionAttribute(""http: xmpr.add(""rdf:Description"", ""http: if (!(xmpr.replaceNode(""http: || xmpr.replaceDescriptionAttribute(""http: xmpr.add(""rdf:Description"", ""http: if (!(xmpr.replaceNode(""http: || xmpr.replaceDescriptionAttribute(""http: }
			 xmp = new PdfStream(xmpr.serializeDoc());
		 }
		 catch(SAXException e) {
			 xmp = new PdfStream(altMetadata);
		 }
		 catch(IOException e) {
			 xmp = new PdfStream(altMetadata);
		 }
		 xmp.put(PdfName.TYPE, PdfName.METADATA);
		 xmp.put(PdfName.SUBTYPE, PdfName.XML);
		 if (crypto != null && !crypto.isMetadataEncrypted()) {
			 PdfArray ar = new PdfArray();
			 ar.add(PdfName.CRYPT);
			 xmp.put(PdfName.FILTER, ar);
		 }
		 if (append && xmpo != null) {
			 body.add(xmp, xmpo.getIndRef());
		 }
		 else {
			 catalog.put(PdfName.METADATA, body.add(xmp).getIndirectReference());
			 markUsed(catalog);
		 }
	 }
	 try {
		 file.reOpen();
		 alterContents();
		 int rootN = ((PRIndirectReference)reader.trailer.get(PdfName.ROOT)).getNumber();
		 if (append) {
			 int keys[] = marked.getKeys();
			 for (int k = 0;
			 k < keys.length;
			 ++k) {
				 int j = keys[k];
				 PdfObject obj = reader.getPdfObjectRelease(j);
				 if (obj != null && skipInfo != j && j < initialXrefSize) {
					 addToBody(obj, j, j != rootN);
				 }
			 }
			 for (int k = initialXrefSize;
			 k < reader.getXrefSize();
			 ++k) {
				 PdfObject obj = reader.getPdfObject(k);
				 if (obj != null) {
					 addToBody(obj, getNewObjectNumber(reader, k, 0));
				 }
			 }
		 }
		 else {
			 for (int k = 1;
			 k < reader.getXrefSize();
			 ++k) {
				 PdfObject obj = reader.getPdfObjectRelease(k);
				 if (obj != null && skipInfo != k) {
					 addToBody(obj, getNewObjectNumber(reader, k, 0), k != rootN);
				 }
			 }
		 }
	 }
	 finally {
		 try {
			 file.close();
		 }
		 catch (Exception e) {
		 }
	 }
	 PdfIndirectReference encryption = null;
	 PdfObject fileID = null;
	 if (crypto != null) {
		 if (append) {
			 encryption = reader.getCryptoRef();
		 }
		 else {
			 PdfIndirectObject encryptionObject = addToBody(crypto.getEncryptionDictionary(), false);
			 encryption = encryptionObject.getIndirectReference();
		 }
		 fileID = crypto.getFileID();
	 }
	 else fileID = PdfEncryption.createInfoId(PdfEncryption.createDocumentId());
	 PRIndirectReference iRoot = (PRIndirectReference)reader.trailer.get(PdfName.ROOT);
	 PdfIndirectReference root = new PdfIndirectReference(0, getNewObjectNumber(reader, iRoot.getNumber(), 0));
	 PdfIndirectReference info = null;
	 PdfDictionary newInfo = new PdfDictionary();
	 if (oldInfo != null) {
		 for (Object element : oldInfo.getKeys()) {
			 PdfName key = (PdfName)element;
			 PdfObject value = PdfReader.getPdfObject(oldInfo.get(key));
			 newInfo.put(key, value);
		 }
	 }
	 if (moreInfo != null) {
		 for (Map.Entry<String, String> entry: moreInfo.entrySet()) {
			 String key = entry.getKey();
			 PdfName keyName = new PdfName(key);
			 String value = entry.getValue();
			 if (value == null) newInfo.remove(keyName);
			 else newInfo.put(keyName, new PdfString(value, PdfObject.TEXT_UNICODE));
		 }
	 }
	 newInfo.put(PdfName.MODDATE, date);
	 newInfo.put(PdfName.PRODUCER, new PdfString(producer));
	 if (append) {
		 if (iInfo == null) info = addToBody(newInfo, false).getIndirectReference();
		 else info = addToBody(newInfo, iInfo.getNumber(), false).getIndirectReference();
	 }
	 else {
		 info = addToBody(newInfo, false).getIndirectReference();
	 }
	 body.writeCrossReferenceTable(os, root, info, encryption, fileID, prevxref);
	 if (fullCompression) {
		 os.write(getISOBytes(""startxref\n""));
		 os.write(getISOBytes(String.valueOf(body.offset())));
		 os.write(getISOBytes(""\n%%EOF\n""));
	 }
	 else {
		 PdfTrailer trailer = new PdfTrailer(body.size(), body.offset(), root, info, encryption, fileID, prevxref);
		 trailer.toPdf(this, os);
	 }
	 os.flush();
	 if (isCloseStream()) os.close();
	 reader.close();
 }
 void applyRotation(PdfDictionary pageN, ByteBuffer out) {
	 if (!rotateContents) return;
	 Rectangle page = reader.getPageSizeWithRotation(pageN);
	 int rotation = page.getRotation();
	 switch (rotation) {
		 case 90: out.append(PdfContents.ROTATE90);
		 out.append(page.getTop());
		 out.append(' ').append('0').append(PdfContents.ROTATEFINAL);
		 break;
		 case 180: out.append(PdfContents.ROTATE180);
		 out.append(page.getRight());
		 out.append(' ');
		 out.append(page.getTop());
		 out.append(PdfContents.ROTATEFINAL);
		 break;
		 case 270: out.append(PdfContents.ROTATE270);
		 out.append('0').append(' ');
		 out.append(page.getRight());
		 out.append(PdfContents.ROTATEFINAL);
		 break;
	 }
 }
 void alterContents() throws IOException {
	 for (Object element : pagesToContent.values()) {
		 PageStamp ps = (PageStamp)element;
		 PdfDictionary pageN = ps.pageN;
		 markUsed(pageN);
		 PdfArray ar = null;
		 PdfObject content = PdfReader.getPdfObject(pageN.get(PdfName.CONTENTS), pageN);
		 if (content == null) {
			 ar = new PdfArray();
			 pageN.put(PdfName.CONTENTS, ar);
		 }
		 else if (content.isArray()) {
			 ar = (PdfArray)content;
			 markUsed(ar);
		 }
		 else if (content.isStream()) {
			 ar = new PdfArray();
			 ar.add(pageN.get(PdfName.CONTENTS));
			 pageN.put(PdfName.CONTENTS, ar);
		 }
		 else {
			 ar = new PdfArray();
			 pageN.put(PdfName.CONTENTS, ar);
		 }
		 ByteBuffer out = new ByteBuffer();
		 if (ps.under != null) {
			 out.append(PdfContents.SAVESTATE);
			 applyRotation(pageN, out);
			 out.append(ps.under.getInternalBuffer());
			 out.append(PdfContents.RESTORESTATE);
		 }
		 if (ps.over != null) out.append(PdfContents.SAVESTATE);
		 PdfStream stream = new PdfStream(out.toByteArray());
		 stream.flateCompress(compressionLevel);
		 ar.addFirst(addToBody(stream).getIndirectReference());
		 out.reset();
		 if (ps.over != null) {
			 out.append(' ');
			 out.append(PdfContents.RESTORESTATE);
			 ByteBuffer buf = ps.over.getInternalBuffer();
			 out.append(buf.getBuffer(), 0, ps.replacePoint);
			 out.append(PdfContents.SAVESTATE);
			 applyRotation(pageN, out);
			 out.append(buf.getBuffer(), ps.replacePoint, buf.size() - ps.replacePoint);
			 out.append(PdfContents.RESTORESTATE);
			 stream = new PdfStream(out.toByteArray());
			 stream.flateCompress(compressionLevel);
			 ar.add(addToBody(stream).getIndirectReference());
		 }
		 alterResources(ps);
	 }
 }
 void alterResources(PageStamp ps) {
	 ps.pageN.put(PdfName.RESOURCES, ps.pageResources.getResources());
 }
 protected int getNewObjectNumber(PdfReader reader, int number, int generation) {
	 IntHashtable ref = readers2intrefs.get(reader);
	 if (ref != null) {
		 int n = ref.get(number);
		 if (n == 0) {
			 n = getIndirectReferenceNumber();
			 ref.put(number, n);
		 }
		 return n;
	 }
	 if (currentPdfReaderInstance == null) {
		 if (append && number < initialXrefSize) return number;
		 int n = myXref.get(number);
		 if (n == 0) {
			 n = getIndirectReferenceNumber();
			 myXref.put(number, n);
		 }
		 return n;
	 }
	 else return currentPdfReaderInstance.getNewObjectNumber(number, generation);
 }
 RandomAccessFileOrArray getReaderFile(PdfReader reader) {
	 if (readers2intrefs.containsKey(reader)) {
		 RandomAccessFileOrArray raf = readers2file.get(reader);
		 if (raf != null) return raf;
		 return reader.getSafeFile();
	 }
	 if (currentPdfReaderInstance == null) return file;
	 else return currentPdfReaderInstance.getReaderFile();
 }
 public void registerReader(PdfReader reader, boolean openFile) throws IOException {
	 if (readers2intrefs.containsKey(reader)) return;
	 readers2intrefs.put(reader, new IntHashtable());
	 if (openFile) {
		 RandomAccessFileOrArray raf = reader.getSafeFile();
		 readers2file.put(reader, raf);
		 raf.reOpen();
	 }
 }
 public void unRegisterReader(PdfReader reader) {
	 if (!readers2intrefs.containsKey(reader)) return;
	 readers2intrefs.remove(reader);
	 RandomAccessFileOrArray raf = readers2file.get(reader);
	 if (raf == null) return;
	 readers2file.remove(reader);
	 try{
		raf.close();
	}
	catch(Exception e){
	}
 }
 static void findAllObjects(PdfReader reader, PdfObject obj, IntHashtable hits) {
	 if (obj == null) return;
	 switch (obj.type()) {
		 case PdfObject.INDIRECT: PRIndirectReference iref = (PRIndirectReference)obj;
		 if (reader != iref.getReader()) return;
		 if (hits.containsKey(iref.getNumber())) return;
		 hits.put(iref.getNumber(), 1);
		 findAllObjects(reader, PdfReader.getPdfObject(obj), hits);
		 return;
		 case PdfObject.ARRAY: PdfArray a = (PdfArray)obj;
		 for (int k = 0;
		 k < a.size();
		 ++k) {
			 findAllObjects(reader, a.getPdfObject(k), hits);
		 }
		 return;
		 case PdfObject.DICTIONARY: case PdfObject.STREAM: PdfDictionary dic = (PdfDictionary)obj;
		 for (Object element : dic.getKeys()) {
			 PdfName name = (PdfName)element;
			 findAllObjects(reader, dic.get(name), hits);
		 }
		 return;
	 }
 }
 public void addComments(FdfReader fdf) throws IOException{
	 if (readers2intrefs.containsKey(fdf)) return;
	 PdfDictionary catalog = fdf.getCatalog();
	 catalog = catalog.getAsDict(PdfName.FDF);
	 if (catalog == null) return;
	 PdfArray annots = catalog.getAsArray(PdfName.ANNOTS);
	 if (annots == null || annots.size() == 0) return;
	 registerReader(fdf, false);
	 IntHashtable hits = new IntHashtable();
	 HashMap<String, PdfObject> irt = new HashMap<String, PdfObject>();
	 ArrayList<PdfObject> an = new ArrayList<PdfObject>();
	 for (int k = 0;
	 k < annots.size();
	 ++k) {
		 PdfObject obj = annots.getPdfObject(k);
		 PdfDictionary annot = (PdfDictionary)PdfReader.getPdfObject(obj);
		 PdfNumber page = annot.getAsNumber(PdfName.PAGE);
		 if (page == null || page.intValue() >= reader.getNumberOfPages()) continue;
		 findAllObjects(fdf, obj, hits);
		 an.add(obj);
		 if (obj.type() == PdfObject.INDIRECT) {
			 PdfObject nm = PdfReader.getPdfObject(annot.get(PdfName.NM));
			 if (nm != null && nm.type() == PdfObject.STRING) irt.put(nm.toString(), obj);
		 }
	 }
	 int arhits[] = hits.getKeys();
	 for (int k = 0;
	 k < arhits.length;
	 ++k) {
		 int n = arhits[k];
		 PdfObject obj = fdf.getPdfObject(n);
		 if (obj.type() == PdfObject.DICTIONARY) {
			 PdfObject str = PdfReader.getPdfObject(((PdfDictionary)obj).get(PdfName.IRT));
			 if (str != null && str.type() == PdfObject.STRING) {
				 PdfObject i = irt.get(str.toString());
				 if (i != null) {
					 PdfDictionary dic2 = new PdfDictionary();
					 dic2.merge((PdfDictionary)obj);
					 dic2.put(PdfName.IRT, i);
					 obj = dic2;
				 }
			 }
		 }
		 addToBody(obj, getNewObjectNumber(fdf, n, 0));
	 }
	 for (int k = 0;
	 k < an.size();
	 ++k) {
		 PdfObject obj = an.get(k);
		 PdfDictionary annot = (PdfDictionary)PdfReader.getPdfObject(obj);
		 PdfNumber page = annot.getAsNumber(PdfName.PAGE);
		 PdfDictionary dic = reader.getPageN(page.intValue() + 1);
		 PdfArray annotsp = (PdfArray)PdfReader.getPdfObject(dic.get(PdfName.ANNOTS), dic);
		 if (annotsp == null) {
			 annotsp = new PdfArray();
			 dic.put(PdfName.ANNOTS, annotsp);
			 markUsed(dic);
		 }
		 markUsed(annotsp);
		 annotsp.add(obj);
	 }
 }
 PageStamp getPageStamp(int pageNum) {
	 PdfDictionary pageN = reader.getPageN(pageNum);
	 PageStamp ps = pagesToContent.get(pageN);
	 if (ps == null) {
		 ps = new PageStamp(this, reader, pageN);
		 pagesToContent.put(pageN, ps);
	 }
	 return ps;
 }
 PdfContentByte getUnderContent(int pageNum) {
	 if (pageNum < 1 || pageNum > reader.getNumberOfPages()) return null;
	 PageStamp ps = getPageStamp(pageNum);
	 if (ps.under == null) ps.under = new StampContent(this, ps);
	 return ps.under;
 }
 PdfContentByte getOverContent(int pageNum) {
	 if (pageNum < 1 || pageNum > reader.getNumberOfPages()) return null;
	 PageStamp ps = getPageStamp(pageNum);
	 if (ps.over == null) ps.over = new StampContent(this, ps);
	 return ps.over;
 }
 void correctAcroFieldPages(int page) {
	 if (acroFields == null) return;
	 if (page > reader.getNumberOfPages()) return;
	 HashMap<String, Item> fields = acroFields.getFields();
	 for (AcroFields.Item item: fields.values()) {
		 for (int k = 0;
		 k < item.size();
		 ++k) {
			 int p = item.getPage(k).intValue();
			 if (p >= page) item.forcePage(k, p + 1);
		 }
	 }
 }
 private static void moveRectangle(PdfDictionary dic2, PdfReader r, int pageImported, PdfName key, String name) {
	 Rectangle m = r.getBoxSize(pageImported, name);
	 if (m == null) dic2.remove(key);
	 else dic2.put(key, new PdfRectangle(m));
 }
 void replacePage(PdfReader r, int pageImported, int pageReplaced) {
	 PdfDictionary pageN = reader.getPageN(pageReplaced);
	 if (pagesToContent.containsKey(pageN)) throw new IllegalStateException(MessageLocalization.getComposedMessage(""this.page.cannot.be.replaced.new.content.was.already.added""));
	 PdfImportedPage p = getImportedPage(r, pageImported);
	 PdfDictionary dic2 = reader.getPageNRelease(pageReplaced);
	 dic2.remove(PdfName.RESOURCES);
	 dic2.remove(PdfName.CONTENTS);
	 moveRectangle(dic2, r, pageImported, PdfName.MEDIABOX, ""media"");
	 moveRectangle(dic2, r, pageImported, PdfName.CROPBOX, ""crop"");
	 moveRectangle(dic2, r, pageImported, PdfName.TRIMBOX, ""trim"");
	 moveRectangle(dic2, r, pageImported, PdfName.ARTBOX, ""art"");
	 moveRectangle(dic2, r, pageImported, PdfName.BLEEDBOX, ""bleed"");
	 dic2.put(PdfName.ROTATE, new PdfNumber(r.getPageRotation(pageImported)));
	 PdfContentByte cb = getOverContent(pageReplaced);
	 cb.addTemplate(p, 0, 0);
	 PageStamp ps = pagesToContent.get(pageN);
	 ps.replacePoint = ps.over.getInternalBuffer().size();
 }
 void insertPage(int pageNumber, Rectangle mediabox) {
	 Rectangle media = new Rectangle(mediabox);
	 int rotation = media.getRotation() % 360;
	 PdfDictionary page = new PdfDictionary(PdfName.PAGE);
	 PdfDictionary resources = new PdfDictionary();
	 PdfArray procset = new PdfArray();
	 procset.add(PdfName.PDF);
	 procset.add(PdfName.TEXT);
	 procset.add(PdfName.IMAGEB);
	 procset.add(PdfName.IMAGEC);
	 procset.add(PdfName.IMAGEI);
	 resources.put(PdfName.PROCSET, procset);
	 page.put(PdfName.RESOURCES, resources);
	 page.put(PdfName.ROTATE, new PdfNumber(rotation));
	 page.put(PdfName.MEDIABOX, new PdfRectangle(media, rotation));
	 PRIndirectReference pref = reader.addPdfObject(page);
	 PdfDictionary parent;
	 PRIndirectReference parentRef;
	 if (pageNumber > reader.getNumberOfPages()) {
		 PdfDictionary lastPage = reader.getPageNRelease(reader.getNumberOfPages());
		 parentRef = (PRIndirectReference)lastPage.get(PdfName.PARENT);
		 parentRef = new PRIndirectReference(reader, parentRef.getNumber());
		 parent = (PdfDictionary)PdfReader.getPdfObject(parentRef);
		 PdfArray kids = (PdfArray)PdfReader.getPdfObject(parent.get(PdfName.KIDS), parent);
		 kids.add(pref);
		 markUsed(kids);
		 reader.pageRefs.insertPage(pageNumber, pref);
	 }
	 else {
		 if (pageNumber < 1) pageNumber = 1;
		 PdfDictionary firstPage = reader.getPageN(pageNumber);
		 PRIndirectReference firstPageRef = reader.getPageOrigRef(pageNumber);
		 reader.releasePage(pageNumber);
		 parentRef = (PRIndirectReference)firstPage.get(PdfName.PARENT);
		 parentRef = new PRIndirectReference(reader, parentRef.getNumber());
		 parent = (PdfDictionary)PdfReader.getPdfObject(parentRef);
		 PdfArray kids = (PdfArray)PdfReader.getPdfObject(parent.get(PdfName.KIDS), parent);
		 int len = kids.size();
		 int num = firstPageRef.getNumber();
		 for (int k = 0;
		 k < len;
		 ++k) {
			 PRIndirectReference cur = (PRIndirectReference)kids.getPdfObject(k);
			 if (num == cur.getNumber()) {
				 kids.add(k, pref);
				 break;
			 }
		 }
		 if (len == kids.size()) throw new RuntimeException(MessageLocalization.getComposedMessage(""internal.inconsistence""));
		 markUsed(kids);
		 reader.pageRefs.insertPage(pageNumber, pref);
		 correctAcroFieldPages(pageNumber);
	 }
	 page.put(PdfName.PARENT, parentRef);
	 while (parent != null) {
		 markUsed(parent);
		 PdfNumber count = (PdfNumber)PdfReader.getPdfObjectRelease(parent.get(PdfName.COUNT));
		 parent.put(PdfName.COUNT, new PdfNumber(count.intValue() + 1));
		 parent = parent.getAsDict(PdfName.PARENT);
	 }
 }
 boolean isRotateContents() {
	 return this.rotateContents;
 }
 void setRotateContents(boolean rotateContents) {
	 this.rotateContents = rotateContents;
 }
 boolean isContentWritten() {
	 return body.size() > 1;
 }
 AcroFields getAcroFields() {
	 if (acroFields == null) {
		 acroFields = new AcroFields(reader, this);
	 }
	 return acroFields;
 }
 void setFormFlattening(boolean flat) {
	 this.flat = flat;
 }
void setFreeTextFlattening(boolean flat) {
	this.flatFreeText = flat;
 }
 boolean partialFormFlattening(String name) {
	 getAcroFields();
	 if (acroFields.getXfa().isXfaPresent()) throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""partial.form.flattening.is.not.supported.with.xfa.forms""));
	 if (!acroFields.getFields().containsKey(name)) return false;
	 partialFlattening.add(name);
	 return true;
 }
 void flatFields() {
	 if (append) throw new IllegalArgumentException(MessageLocalization.getComposedMessage(""field.flattening.is.not.supported.in.append.mode""));
	 getAcroFields();
	 HashMap<String, Item> fields = acroFields.getFields();
	 if (fieldsAdded && partialFlattening.isEmpty()) {
		 for (String s: fields.keySet()) {
			 partialFlattening.add(s);
		 }
	 }
	 PdfDictionary acroForm = reader.getCatalog().getAsDict(PdfName.ACROFORM);
	 PdfArray acroFds = null;
	 if (acroForm != null) {
		 acroFds = (PdfArray)PdfReader.getPdfObject(acroForm.get(PdfName.FIELDS), acroForm);
	 }
	 for (Map.Entry<String, Item> entry: fields.entrySet()) {
		 String name = entry.getKey();
		 if (!partialFlattening.isEmpty() && !partialFlattening.contains(name)) continue;
		 AcroFields.Item item = entry.getValue();
		 for (int k = 0;
		 k < item.size();
		 ++k) {
			 PdfDictionary merged = item.getMerged(k);
			 PdfNumber ff = merged.getAsNumber(PdfName.F);
			 int flags = 0;
			 if (ff != null) flags = ff.intValue();
			 int page = item.getPage(k).intValue();
			 PdfDictionary appDic = merged.getAsDict(PdfName.AP);
			 if (appDic != null && (flags & PdfFormField.FLAGS_PRINT) != 0 && (flags & PdfFormField.FLAGS_HIDDEN) == 0) {
				 PdfObject obj = appDic.get(PdfName.N);
				 PdfAppearance app = null;
				 if (obj != null) {
					 PdfObject objReal = PdfReader.getPdfObject(obj);
					 if (obj instanceof PdfIndirectReference && !obj.isIndirect()) app = new PdfAppearance((PdfIndirectReference)obj);
					 else if (objReal instanceof PdfStream) {
						 ((PdfDictionary)objReal).put(PdfName.SUBTYPE, PdfName.FORM);
						 app = new PdfAppearance((PdfIndirectReference)obj);
					 }
					 else {
						 if (objReal != null && objReal.isDictionary()) {
							 PdfName as = merged.getAsName(PdfName.AS);
							 if (as != null) {
								 PdfIndirectReference iref = (PdfIndirectReference)((PdfDictionary)objReal).get(as);
								 if (iref != null) {
									 app = new PdfAppearance(iref);
									 if (iref.isIndirect()) {
										 objReal = PdfReader.getPdfObject(iref);
										 ((PdfDictionary)objReal).put(PdfName.SUBTYPE, PdfName.FORM);
									 }
								 }
							 }
						 }
					 }
				 }
				 if (app != null) {
					 Rectangle box = PdfReader.getNormalizedRectangle(merged.getAsArray(PdfName.RECT));
					 PdfContentByte cb = getOverContent(page);
					 cb.setLiteral(""Q "");
					 cb.addTemplate(app, box.getLeft(), box.getBottom());
					 cb.setLiteral(""q "");
				 }
			 }
			 if (partialFlattening.isEmpty()) continue;
			 PdfDictionary pageDic = reader.getPageN(page);
			 PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);
			 if (annots == null) continue;
			 for (int idx = 0;
			 idx < annots.size();
			 ++idx) {
				 PdfObject ran = annots.getPdfObject(idx);
				 if (!ran.isIndirect()) continue;
				 PdfObject ran2 = item.getWidgetRef(k);
				 if (!ran2.isIndirect()) continue;
				 if (((PRIndirectReference)ran).getNumber() == ((PRIndirectReference)ran2).getNumber()) {
					 annots.remove(idx--);
					 PRIndirectReference wdref = (PRIndirectReference)ran2;
					 while (true) {
						 PdfDictionary wd = (PdfDictionary)PdfReader.getPdfObject(wdref);
						 PRIndirectReference parentRef = (PRIndirectReference)wd.get(PdfName.PARENT);
						 PdfReader.killIndirect(wdref);
						 if (parentRef == null) {
							 for (int fr = 0;
							 fr < acroFds.size();
							 ++fr) {
								 PdfObject h = acroFds.getPdfObject(fr);
								 if (h.isIndirect() && ((PRIndirectReference)h).getNumber() == wdref.getNumber()) {
									 acroFds.remove(fr);
									 --fr;
								 }
							 }
							 break;
						 }
						 PdfDictionary parent = (PdfDictionary)PdfReader.getPdfObject(parentRef);
						 PdfArray kids = parent.getAsArray(PdfName.KIDS);
						 for (int fr = 0;
						 fr < kids.size();
						 ++fr) {
							 PdfObject h = kids.getPdfObject(fr);
							 if (h.isIndirect() && ((PRIndirectReference)h).getNumber() == wdref.getNumber()) {
								 kids.remove(fr);
								 --fr;
							 }
						 }
						 if (!kids.isEmpty()) break;
						 wdref = parentRef;
					 }
				 }
			 }
			 if (annots.isEmpty()) {
				 PdfReader.killIndirect(pageDic.get(PdfName.ANNOTS));
				 pageDic.remove(PdfName.ANNOTS);
			 }
		 }
	 }
	 if (!fieldsAdded && partialFlattening.isEmpty()) {
		 for (int page = 1;
		 page <= reader.getNumberOfPages();
		 ++page) {
			 PdfDictionary pageDic = reader.getPageN(page);
			 PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);
			 if (annots == null) continue;
			 for (int idx = 0;
			 idx < annots.size();
			 ++idx) {
				 PdfObject annoto = annots.getDirectObject(idx);
				 if (annoto instanceof PdfIndirectReference && !annoto.isIndirect()) continue;
				 if (!annoto.isDictionary() || PdfName.WIDGET.equals(((PdfDictionary)annoto).get(PdfName.SUBTYPE))) {
					 annots.remove(idx);
					 --idx;
				 }
			 }
			 if (annots.isEmpty()) {
				 PdfReader.killIndirect(pageDic.get(PdfName.ANNOTS));
				 pageDic.remove(PdfName.ANNOTS);
			 }
		 }
		 eliminateAcroformObjects();
	 }
 }
 void eliminateAcroformObjects() {
	 PdfObject acro = reader.getCatalog().get(PdfName.ACROFORM);
	 if (acro == null) return;
	 PdfDictionary acrodic = (PdfDictionary)PdfReader.getPdfObject(acro);
	 reader.killXref(acrodic.get(PdfName.XFA));
	 acrodic.remove(PdfName.XFA);
	 PdfObject iFields = acrodic.get(PdfName.FIELDS);
	 if (iFields != null) {
		 PdfDictionary kids = new PdfDictionary();
		 kids.put(PdfName.KIDS, iFields);
		 sweepKids(kids);
		 PdfReader.killIndirect(iFields);
		 acrodic.put(PdfName.FIELDS, new PdfArray());
	 }
	 acrodic.remove(PdfName.SIGFLAGS);
 }
 void sweepKids(PdfObject obj) {
	 PdfObject oo = PdfReader.killIndirect(obj);
	 if (oo == null || !oo.isDictionary()) return;
	 PdfDictionary dic = (PdfDictionary)oo;
	 PdfArray kids = (PdfArray)PdfReader.killIndirect(dic.get(PdfName.KIDS));
	 if (kids == null) return;
	 for (int k = 0;
	 k < kids.size();
	 ++k) {
		 sweepKids(kids.getPdfObject(k));
	 }
 }
 private void flatFreeTextFields(){
	if (append)throw new IllegalArgumentException(MessageLocalization.getComposedMessage(""freetext.flattening.is.not.supported.in.append.mode""));
	for (int page = 1;
	 page <= reader.getNumberOfPages();
	 ++page){
		PdfDictionary pageDic = reader.getPageN(page);
		PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);
		if (annots == null)continue;
		for (int idx = 0;
		 idx < annots.size();
		 ++idx){
			PdfObject annoto = annots.getDirectObject(idx);
			if (annoto instanceof PdfIndirectReference && !annoto.isIndirect())continue;
			PdfDictionary annDic = (PdfDictionary)annoto;
			 if (!((PdfName)annDic.get(PdfName.SUBTYPE)).equals(PdfName.FREETEXT))continue;
			PdfNumber ff = annDic.getAsNumber(PdfName.F);
			 int flags = ff != null ? ff.intValue() : 0;
			if ( (flags & PdfFormField.FLAGS_PRINT) != 0 && (flags & PdfFormField.FLAGS_HIDDEN) == 0){
				PdfObject obj1 = annDic.get(PdfName.AP);
				if (obj1 == null)continue;
				PdfDictionary appDic = obj1 instanceof PdfIndirectReference ?(PdfDictionary) PdfReader.getPdfObject(obj1) : (PdfDictionary) obj1;
				PdfObject obj = appDic.get(PdfName.N);
				PdfAppearance app = null;
				PdfObject objReal = PdfReader.getPdfObject(obj);
				if (obj instanceof PdfIndirectReference && !obj.isIndirect())app = new PdfAppearance((PdfIndirectReference)obj);
				else if (objReal instanceof PdfStream){
					((PdfDictionary)objReal).put(PdfName.SUBTYPE, PdfName.FORM);
					app = new PdfAppearance((PdfIndirectReference)obj);
				}
				else{
					if (objReal.isDictionary()){
						PdfName as_p = appDic.getAsName(PdfName.AS);
						if (as_p != null){
							PdfIndirectReference iref = (PdfIndirectReference)((PdfDictionary)objReal).get(as_p);
							if (iref != null){
								app = new PdfAppearance(iref);
								if (iref.isIndirect()){
									objReal = PdfReader.getPdfObject(iref);
									((PdfDictionary)objReal).put(PdfName.SUBTYPE, PdfName.FORM);
								}
							}
						}
					}
				}
				if (app != null){
					Rectangle box = PdfReader.getNormalizedRectangle(annDic.getAsArray(PdfName.RECT));
					PdfContentByte cb = getOverContent(page);
					cb.setLiteral(""Q "");
					cb.addTemplate(app, box.getLeft(), box.getBottom());
					cb.setLiteral(""q "");
				}
			}
		}
		for (int idx = 0;
		 idx < annots.size();
		 ++idx){
			 PdfDictionary annot = annots.getAsDict(idx);
			if (annot != null){
				if (PdfName.FREETEXT.equals(annot.get(PdfName.SUBTYPE))){
					 annots.remove(idx);
					--idx;
				}
			}
		}
		if (annots.isEmpty()){
			PdfReader.killIndirect(pageDic.get(PdfName.ANNOTS));
			pageDic.remove(PdfName.ANNOTS);
		}
	}
}
 public PdfIndirectReference getPageReference(int page) {
	 PdfIndirectReference ref = reader.getPageOrigRef(page);
	 if (ref == null) throw new IllegalArgumentException(MessageLocalization.getComposedMessage(""invalid.page.number.1"", page));
	 return ref;
 }
 public void addAnnotation(PdfAnnotation annot) {
	 throw new RuntimeException(MessageLocalization.getComposedMessage(""unsupported.in.this.context.use.pdfstamper.addannotation""));
 }
 void addDocumentField(PdfIndirectReference ref) {
	 PdfDictionary catalog = reader.getCatalog();
	 PdfDictionary acroForm = (PdfDictionary)PdfReader.getPdfObject(catalog.get(PdfName.ACROFORM), catalog);
	 if (acroForm == null) {
		 acroForm = new PdfDictionary();
		 catalog.put(PdfName.ACROFORM, acroForm);
		 markUsed(catalog);
	 }
	 PdfArray fields = (PdfArray)PdfReader.getPdfObject(acroForm.get(PdfName.FIELDS), acroForm);
	 if (fields == null) {
		 fields = new PdfArray();
		 acroForm.put(PdfName.FIELDS, fields);
		 markUsed(acroForm);
	 }
	 if (!acroForm.contains(PdfName.DA)) {
		 acroForm.put(PdfName.DA, new PdfString(""/Helv 0 Tf 0 g ""));
		 markUsed(acroForm);
	 }
	 fields.add(ref);
	 markUsed(fields);
 }
 void addFieldResources() throws IOException {
	 if (fieldTemplates.isEmpty()) return;
	 PdfDictionary catalog = reader.getCatalog();
	 PdfDictionary acroForm = (PdfDictionary)PdfReader.getPdfObject(catalog.get(PdfName.ACROFORM), catalog);
	 if (acroForm == null) {
		 acroForm = new PdfDictionary();
		 catalog.put(PdfName.ACROFORM, acroForm);
		 markUsed(catalog);
	 }
	 PdfDictionary dr = (PdfDictionary)PdfReader.getPdfObject(acroForm.get(PdfName.DR), acroForm);
	 if (dr == null) {
		 dr = new PdfDictionary();
		 acroForm.put(PdfName.DR, dr);
		 markUsed(acroForm);
	 }
	 markUsed(dr);
	 for (PdfTemplate template: fieldTemplates) {
		 PdfFormField.mergeResources(dr, (PdfDictionary)template.getResources(), this);
	 }
	 PdfDictionary fonts = dr.getAsDict(PdfName.FONT);
	 if (fonts == null) {
		 fonts = new PdfDictionary();
		 dr.put(PdfName.FONT, fonts);
	 }
	 if (!fonts.contains(PdfName.HELV)) {
		 PdfDictionary dic = new PdfDictionary(PdfName.FONT);
		 dic.put(PdfName.BASEFONT, PdfName.HELVETICA);
		 dic.put(PdfName.ENCODING, PdfName.WIN_ANSI_ENCODING);
		 dic.put(PdfName.NAME, PdfName.HELV);
		 dic.put(PdfName.SUBTYPE, PdfName.TYPE1);
		 fonts.put(PdfName.HELV, addToBody(dic).getIndirectReference());
	 }
	 if (!fonts.contains(PdfName.ZADB)) {
		 PdfDictionary dic = new PdfDictionary(PdfName.FONT);
		 dic.put(PdfName.BASEFONT, PdfName.ZAPFDINGBATS);
		 dic.put(PdfName.NAME, PdfName.ZADB);
		 dic.put(PdfName.SUBTYPE, PdfName.TYPE1);
		 fonts.put(PdfName.ZADB, addToBody(dic).getIndirectReference());
	 }
	 if (acroForm.get(PdfName.DA) == null) {
		 acroForm.put(PdfName.DA, new PdfString(""/Helv 0 Tf 0 g ""));
		 markUsed(acroForm);
	 }
 }
 void expandFields(PdfFormField field, ArrayList<PdfAnnotation> allAnnots) {
	 allAnnots.add(field);
	 ArrayList<PdfFormField> kids = field.getKids();
	 if (kids != null) {
		 for (int k = 0;
		 k < kids.size();
		 ++k) expandFields(kids.get(k), allAnnots);
	 }
 }
 void addAnnotation(PdfAnnotation annot, PdfDictionary pageN) {
	 try {
		 ArrayList<PdfAnnotation> allAnnots = new ArrayList<PdfAnnotation>();
		 if (annot.isForm()) {
			 fieldsAdded = true;
			 getAcroFields();
			 PdfFormField field = (PdfFormField)annot;
			 if (field.getParent() != null) return;
			 expandFields(field, allAnnots);
		 }
		 else allAnnots.add(annot);
		 for (int k = 0;
		 k < allAnnots.size();
		 ++k) {
			 annot = allAnnots.get(k);
			 if (annot.getPlaceInPage() > 0) pageN = reader.getPageN(annot.getPlaceInPage());
			 if (annot.isForm()) {
				 if (!annot.isUsed()) {
					 HashSet<PdfTemplate> templates = annot.getTemplates();
					 if (templates != null) fieldTemplates.addAll(templates);
				 }
				 PdfFormField field = (PdfFormField)annot;
				 if (field.getParent() == null) addDocumentField(field.getIndirectReference());
			 }
			 if (annot.isAnnotation()) {
				 PdfObject pdfobj = PdfReader.getPdfObject(pageN.get(PdfName.ANNOTS), pageN);
				 PdfArray annots = null;
				 if (pdfobj == null || !pdfobj.isArray()) {
					 annots = new PdfArray();
					 pageN.put(PdfName.ANNOTS, annots);
					 markUsed(pageN);
				 }
				 else annots = (PdfArray)pdfobj;
				 annots.add(annot.getIndirectReference());
				 markUsed(annots);
				 if (!annot.isUsed()) {
					 PdfRectangle rect = (PdfRectangle)annot.get(PdfName.RECT);
					 if (rect != null && (rect.left() != 0 || rect.right() != 0 || rect.top() != 0 || rect.bottom() != 0)) {
						 int rotation = reader.getPageRotation(pageN);
						 Rectangle pageSize = reader.getPageSizeWithRotation(pageN);
						 switch (rotation) {
							 case 90: annot.put(PdfName.RECT, new PdfRectangle( pageSize.getTop() - rect.top(), rect.right(), pageSize.getTop() - rect.bottom(), rect.left()));
							 break;
							 case 180: annot.put(PdfName.RECT, new PdfRectangle( pageSize.getRight() - rect.left(), pageSize.getTop() - rect.bottom(), pageSize.getRight() - rect.right(), pageSize.getTop() - rect.top()));
							 break;
							 case 270: annot.put(PdfName.RECT, new PdfRectangle( rect.bottom(), pageSize.getRight() - rect.left(), rect.top(), pageSize.getRight() - rect.right()));
							 break;
						 }
					 }
				 }
			 }
			 if (!annot.isUsed()) {
				 annot.setUsed();
				 addToBody(annot, annot.getIndirectReference());
			 }
		 }
	 }
	 catch (IOException e) {
		 throw new ExceptionConverter(e);
	 }
 }
 void addAnnotation(PdfAnnotation annot, int page) {
	 annot.setPage(page);
	 addAnnotation(annot, reader.getPageN(page));
 }
 private void outlineTravel(PRIndirectReference outline) {
	 while (outline != null) {
		 PdfDictionary outlineR = (PdfDictionary)PdfReader.getPdfObjectRelease(outline);
		 PRIndirectReference first = (PRIndirectReference)outlineR.get(PdfName.FIRST);
		 if (first != null) {
			 outlineTravel(first);
		 }
		 PdfReader.killIndirect(outlineR.get(PdfName.DEST));
		 PdfReader.killIndirect(outlineR.get(PdfName.A));
		 PdfReader.killIndirect(outline);
		 outline = (PRIndirectReference)outlineR.get(PdfName.NEXT);
	 }
 }
 void deleteOutlines() {
	 PdfDictionary catalog = reader.getCatalog();
	 PRIndirectReference outlines = (PRIndirectReference)catalog.get(PdfName.OUTLINES);
	 if (outlines == null) return;
	 outlineTravel(outlines);
	 PdfReader.killIndirect(outlines);
	 catalog.remove(PdfName.OUTLINES);
	 markUsed(catalog);
 }
 void setJavaScript() throws IOException {
	 HashMap<String, PdfObject> djs = pdf.getDocumentLevelJS();
	 if (djs.isEmpty()) return;
	 PdfDictionary catalog = reader.getCatalog();
	 PdfDictionary names = (PdfDictionary)PdfReader.getPdfObject(catalog.get(PdfName.NAMES), catalog);
	 if (names == null) {
		 names = new PdfDictionary();
		 catalog.put(PdfName.NAMES, names);
		 markUsed(catalog);
	 }
	 markUsed(names);
	 PdfDictionary tree = PdfNameTree.writeTree(djs, this);
	 names.put(PdfName.JAVASCRIPT, addToBody(tree).getIndirectReference());
 }
 void addFileAttachments() throws IOException {
	 HashMap<String, PdfObject> fs = pdf.getDocumentFileAttachment();
	 if (fs.isEmpty()) return;
	 PdfDictionary catalog = reader.getCatalog();
	 PdfDictionary names = (PdfDictionary)PdfReader.getPdfObject(catalog.get(PdfName.NAMES), catalog);
	 if (names == null) {
		 names = new PdfDictionary();
		 catalog.put(PdfName.NAMES, names);
		 markUsed(catalog);
	 }
	 markUsed(names);
	 HashMap<String, PdfObject> old = PdfNameTree.readTree((PdfDictionary)PdfReader.getPdfObjectRelease(names.get(PdfName.EMBEDDEDFILES)));
	 for (Map.Entry<String, PdfObject> entry: fs.entrySet()) {
		 String name = entry.getKey();
		 int k = 0;
		 String nn = name;
		 while (old.containsKey(nn)) {
			 ++k;
			 nn += "" "" + k;
		 }
		 old.put(nn, entry.getValue());
	 }
	 PdfDictionary tree = PdfNameTree.writeTree(old, this);
	 PdfObject oldEmbeddedFiles = names.get(PdfName.EMBEDDEDFILES);
	 if (oldEmbeddedFiles != null) {
		 PdfReader.killIndirect(oldEmbeddedFiles);
	 }
	 names.put(PdfName.EMBEDDEDFILES, addToBody(tree).getIndirectReference());
 }
 void makePackage( PdfCollection collection ) {
	 PdfDictionary catalog = reader.getCatalog();
	 catalog.put( PdfName.COLLECTION, collection );
 }
 void setOutlines() throws IOException {
	 if (newBookmarks == null) return;
	 deleteOutlines();
	 if (newBookmarks.isEmpty()) return;
	 PdfDictionary catalog = reader.getCatalog();
	 boolean namedAsNames = catalog.get(PdfName.DESTS) != null;
	 writeOutlines(catalog, namedAsNames);
	 markUsed(catalog);
 }
 public void setViewerPreferences(int preferences) {
	 useVp = true;
	 this.viewerPreferences.setViewerPreferences(preferences);
 }
 public void addViewerPreference(PdfName key, PdfObject value) {
	 useVp = true;
	 this.viewerPreferences.addViewerPreference(key, value);
 }
 public void setSigFlags(int f) {
	 sigFlags |= f;
 }
 public void setPageAction(PdfName actionType, PdfAction action) throws PdfException {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""use.setpageaction.pdfname.actiontype.pdfaction.action.int.page""));
 }
 void setPageAction(PdfName actionType, PdfAction action, int page) throws PdfException {
	 if (!actionType.equals(PAGE_OPEN) && !actionType.equals(PAGE_CLOSE)) throw new PdfException(MessageLocalization.getComposedMessage(""invalid.page.additional.action.type.1"", actionType.toString()));
	 PdfDictionary pg = reader.getPageN(page);
	 PdfDictionary aa = (PdfDictionary)PdfReader.getPdfObject(pg.get(PdfName.AA), pg);
	 if (aa == null) {
		 aa = new PdfDictionary();
		 pg.put(PdfName.AA, aa);
		 markUsed(pg);
	 }
	 aa.put(actionType, action);
	 markUsed(aa);
 }
 public void setDuration(int seconds) {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""use.setpageaction.pdfname.actiontype.pdfaction.action.int.page""));
 }
 public void setTransition(PdfTransition transition) {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""use.setpageaction.pdfname.actiontype.pdfaction.action.int.page""));
 }
 void setDuration(int seconds, int page) {
	 PdfDictionary pg = reader.getPageN(page);
	 if (seconds < 0) pg.remove(PdfName.DUR);
	 else pg.put(PdfName.DUR, new PdfNumber(seconds));
	 markUsed(pg);
 }
 void setTransition(PdfTransition transition, int page) {
	 PdfDictionary pg = reader.getPageN(page);
	 if (transition == null) pg.remove(PdfName.TRANS);
	 else pg.put(PdfName.TRANS, transition.getTransitionDictionary());
	 markUsed(pg);
 }
 protected void markUsed(PdfObject obj) {
	 if (append && obj != null) {
		 PRIndirectReference ref = null;
		 if (obj.type() == PdfObject.INDIRECT) ref = (PRIndirectReference)obj;
		 else ref = obj.getIndRef();
		 if (ref != null) marked.put(ref.getNumber(), 1);
	 }
 }
 protected void markUsed(int num) {
	 if (append) marked.put(num, 1);
 }
 boolean isAppend() {
	 return append;
 }
 public void setAdditionalAction(PdfName actionType, PdfAction action) throws PdfException {
	 if (!(actionType.equals(DOCUMENT_CLOSE) || actionType.equals(WILL_SAVE) || actionType.equals(DID_SAVE) || actionType.equals(WILL_PRINT) || actionType.equals(DID_PRINT))) {
		 throw new PdfException(MessageLocalization.getComposedMessage(""invalid.additional.action.type.1"", actionType.toString()));
	 }
	 PdfDictionary aa = reader.getCatalog().getAsDict(PdfName.AA);
	 if (aa == null) {
		 if (action == null) return;
		 aa = new PdfDictionary();
		 reader.getCatalog().put(PdfName.AA, aa);
	 }
	 markUsed(aa);
	 if (action == null) aa.remove(actionType);
	 else aa.put(actionType, action);
 }
 public void setOpenAction(PdfAction action) {
	 openAction = action;
 }
 public void setOpenAction(String name) {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""open.actions.by.name.are.not.supported""));
 }
 public void setThumbnail(com.itextpdf.text.Image image) {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""use.pdfstamper.setthumbnail""));
 }
 void setThumbnail(Image image, int page) throws PdfException, DocumentException {
	 PdfIndirectReference thumb = getImageReference(addDirectImageSimple(image));
	 reader.resetReleasePage();
	 PdfDictionary dic = reader.getPageN(page);
	 dic.put(PdfName.THUMB, thumb);
	 reader.resetReleasePage();
 }
 public PdfContentByte getDirectContentUnder() {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""use.pdfstamper.getundercontent.or.pdfstamper.getovercontent""));
 }
 public PdfContentByte getDirectContent() {
	 throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(""use.pdfstamper.getundercontent.or.pdfstamper.getovercontent""));
 }
 protected void readOCProperties() {
	 if (!documentOCG.isEmpty()) {
		 return;
	 }
	 PdfDictionary dict = reader.getCatalog().getAsDict(PdfName.OCPROPERTIES);
	 if (dict == null) {
		 return;
	 }
	 PdfArray ocgs = dict.getAsArray(PdfName.OCGS);
	 PdfIndirectReference ref;
	 PdfLayer layer;
	 HashMap<String, PdfLayer> ocgmap = new HashMap<String, PdfLayer>();
	 for (Iterator<PdfObject> i = ocgs.listIterator();
	 i.hasNext();
	 ) {
		 ref = (PdfIndirectReference)i.next();
		 layer = new PdfLayer(null);
		 layer.setRef(ref);
		 layer.setOnPanel(false);
		layer.merge((PdfDictionary)PdfReader.getPdfObject(ref));
		 ocgmap.put(ref.toString(), layer);
	 }
	 PdfDictionary d = dict.getAsDict(PdfName.D);
	 PdfArray off = d.getAsArray(PdfName.OFF);
	 if (off != null) {
		 for (Iterator<PdfObject> i = off.listIterator();
		 i.hasNext();
		 ) {
			 ref = (PdfIndirectReference)i.next();
			 layer = ocgmap.get(ref.toString());
			 layer.setOn(false);
		 }
	 }
	 PdfArray order = d.getAsArray(PdfName.ORDER);
	 if (order != null) {
		 addOrder(null, order, ocgmap);
	 }
	 documentOCG.addAll(ocgmap.values());
	 OCGRadioGroup = d.getAsArray(PdfName.RBGROUPS);
	 OCGLocked = d.getAsArray(PdfName.LOCKED);
	 if (OCGLocked == null) OCGLocked = new PdfArray();
 }
 private void addOrder(PdfLayer parent, PdfArray arr, Map<String, PdfLayer> ocgmap) {
	 PdfObject obj;
	 PdfLayer layer;
	 for (int i = 0;
	 i < arr.size();
	 i++) {
		 obj = arr.getPdfObject(i);
		 if (obj.isIndirect()) {
			 layer = ocgmap.get(obj.toString());
			 layer.setOnPanel(true);
			 registerLayer(layer);
			 if (parent != null) {
				 parent.addChild(layer);
			 }
			 if (arr.size() > i + 1 && arr.getPdfObject(i + 1).isArray()) {
				 i++;
				 addOrder(layer, (PdfArray)arr.getPdfObject(i), ocgmap);
			 }
		 }
		 else if (obj.isArray()) {
			 PdfArray sub = (PdfArray)obj;
			 if (sub.isEmpty()) return;
			 obj = sub.getPdfObject(0);
			 if (obj.isString()) {
				 layer = new PdfLayer(obj.toString());
				 layer.setOnPanel(true);
				 registerLayer(layer);
				 if (parent != null) {
					 parent.addChild(layer);
				 }
				 PdfArray array = new PdfArray();
				 for (Iterator<PdfObject> j = sub.listIterator();
				 j.hasNext();
				 ) {
					 array.add(j.next());
				 }
				 addOrder(layer, array, ocgmap);
			 }
			 else {
				 addOrder(parent, (PdfArray)obj, ocgmap);
			 }
		 }
	 }
 }
 public Map<String, PdfLayer> getPdfLayers() {
	 if (documentOCG.isEmpty()) {
		 readOCProperties();
	 }
	 HashMap<String, PdfLayer> map = new HashMap<String, PdfLayer>();
	 PdfLayer layer;
	 String key;
	 for (PdfOCG pdfOCG : documentOCG) {
		 layer = (PdfLayer)pdfOCG;
		 if (layer.getTitle() == null) {
			 key = layer.getAsString(PdfName.NAME).toString();
		 }
		 else {
			 key = layer.getTitle();
		 }
		 if (map.containsKey(key)) {
			 int seq = 2;
			 String tmp = key + ""("" + seq + "")"";
			 while (map.containsKey(tmp)) {
				 seq++;
				 tmp = key + ""("" + seq + "")"";
			 }
			 key = tmp;
		 }
		map.put(key, layer);
	 }
	 return map;
 }
 static class PageStamp {
	 PdfDictionary pageN;
	 StampContent under;
	 StampContent over;
	 PageResources pageResources;
	 int replacePoint = 0;
	 PageStamp(PdfStamperImp stamper, PdfReader reader, PdfDictionary pageN) {
		 this.pageN = pageN;
		 pageResources = new PageResources();
		 PdfDictionary resources = pageN.getAsDict(PdfName.RESOURCES);
		 pageResources.setOriginalResources(resources, stamper.namePtr);
	 }
 }
}",1,0,0,0
"public static class ShopPolicy extends AbstractResponse<ShopPolicy> implements Node {
	 public ShopPolicy() {
	 }
	 public ShopPolicy(JsonObject fields) throws SchemaViolationError {
		 for (Map.Entry<String, JsonElement> field : fields.entrySet()) {
			 String key = field.getKey();
			 String fieldName = getFieldName(key);
			 switch (fieldName) {
				 case ""body"": {
					 responseData.put(key, jsonAsString(field.getValue(), key));
					 break;
				 }
				 case ""handle"": {
					 responseData.put(key, jsonAsString(field.getValue(), key));
					 break;
				 }
				 case ""id"": {
					 responseData.put(key, new ID(jsonAsString(field.getValue(), key)));
					 break;
				 }
				 case ""title"": {
					 responseData.put(key, jsonAsString(field.getValue(), key));
					 break;
				 }
				 case ""url"": {
					 responseData.put(key, jsonAsString(field.getValue(), key));
					 break;
				 }
				 case ""__typename"": {
					 responseData.put(key, jsonAsString(field.getValue(), key));
					 break;
				 }
				 default: {
					 throw new SchemaViolationError(this, key, field.getValue());
				 }
			 }
		 }
	 }
	 public ShopPolicy(ID id) {
		 this();
		 optimisticData.put(""id"", id);
	 }
	 public String getGraphQlTypeName() {
		 return ""ShopPolicy"";
	 }
	 public String getBody() {
		 return (String) get(""body"");
	 }
	 public ShopPolicy setBody(String arg) {
		 optimisticData.put(getKey(""body""), arg);
		 return this;
	 }
	 public String getHandle() {
		 return (String) get(""handle"");
	 }
	 public ShopPolicy setHandle(String arg) {
		 optimisticData.put(getKey(""handle""), arg);
		 return this;
	 }
	 public ID getId() {
		 return (ID) get(""id"");
	 }
	 public String getTitle() {
		 return (String) get(""title"");
	 }
	 public ShopPolicy setTitle(String arg) {
		 optimisticData.put(getKey(""title""), arg);
		 return this;
	 }
	 public String getUrl() {
		 return (String) get(""url"");
	 }
	 public ShopPolicy setUrl(String arg) {
		 optimisticData.put(getKey(""url""), arg);
		 return this;
	 }
	 public boolean unwrapsToObject(String key) {
		 switch (getFieldName(key)) {
			 case ""body"": return false;
			 case ""handle"": return false;
			 case ""id"": return false;
			 case ""title"": return false;
			 case ""url"": return false;
			 default: return false;
		 }
	 }
 }",0,0,0,0
"public class ImportHandler extends DefaultHandler {
	 private static Logger log = LoggerFactory.getLogger(ImportHandler.class);
	 private final Importer importer;
	 private final NamespaceRegistry nsReg;
	 private final NamespaceResolver nsResolver;
	 private final NameFactory nameFactory;
	 private ContentHandler targetHandler;
	 private boolean systemViewXML;
	 private boolean initialized;
	 private final NamespaceContext nsContext;
	 private final NamePathResolver resolver;
	 protected boolean nsContextStarted;
	 public ImportHandler(Importer importer, NamespaceResolver nsResolver, NamespaceRegistry nsReg, NameFactory nameFactory, PathFactory pathFactory) {
		 this.importer = importer;
		 this.nsResolver = nsResolver;
		 this.nsReg = nsReg;
		 this.nameFactory = nameFactory;
		 nsContext = new NamespaceContext();
		 NameResolver nr = new ParsingNameResolver(nameFactory, nsContext);
		 resolver = new DefaultNamePathResolver(nr, new ParsingPathResolver(pathFactory, nr));
	 }
	 public void warning(SAXParseException e) throws SAXException {
		 log.warn(""warning encountered at line: "" + e.getLineNumber() + "", column: "" + e.getColumnNumber() + "" while parsing XML stream"", e);
	 }
	 public void error(SAXParseException e) throws SAXException {
		 log.error(""error encountered at line: "" + e.getLineNumber() + "", column: "" + e.getColumnNumber() + "" while parsing XML stream: "" + e.toString());
	 }
	 public void fatalError(SAXParseException e) throws SAXException {
		 log.error(""fatal error encountered at line: "" + e.getLineNumber() + "", column: "" + e.getColumnNumber() + "" while parsing XML stream: "" + e.toString());
		 throw e;
	 }
	 public void startDocument() throws SAXException {
		 systemViewXML = false;
		 initialized = false;
		 targetHandler = null;
		 nsContext.reset();
		 nsContext.pushContext();
		 try {
			 String[] uris = nsReg.getURIs();
			 for (int i = 0;
			 i < uris.length;
			 i++) {
				 nsContext.declarePrefix(nsResolver.getPrefix(uris[i]), uris[i]);
			 }
		 }
		 catch (RepositoryException re) {
			 throw new SAXException(re);
		 }
		 nsContextStarted = false;
	 }
	 public void endDocument() throws SAXException {
		 targetHandler.endDocument();
		 nsContext.reset();
	 }
	 public void startPrefixMapping(String prefix, String uri) throws SAXException {
		 if (!nsContextStarted) {
			 nsContext.pushContext();
			 nsContextStarted = true;
		 }
		 try {
			 nsContext.getPrefix(uri);
		 }
		 catch (NamespaceException nse) {
			 try {
				 String newPrefix;
				 if ("""".equals(prefix)) {
					 newPrefix = getUniquePrefix(uri);
				 }
				 else {
					 newPrefix = prefix;
				 }
				 nsReg.registerNamespace(newPrefix, uri);
			 }
			 catch (RepositoryException re) {
				 throw new SAXException(re);
			 }
		 }
		 nsContext.declarePrefix(prefix, uri);
	 }
	 public void endPrefixMapping(String prefix) throws SAXException {
	 }
	 public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
		 if (!nsContextStarted) {
			 nsContext.pushContext();
		 }
		 else {
			 nsContextStarted = false;
		 }
		 if (!initialized) {
			 systemViewXML = Name.NS_SV_URI.equals(namespaceURI);
			 if (systemViewXML) {
				 targetHandler = new SysViewImportHandler(importer, resolver);
			 }
			 else {
				 targetHandler = new DocViewImportHandler(importer, resolver, nameFactory);
			 }
			 targetHandler.startDocument();
			 initialized = true;
		 }
		 targetHandler.startElement(namespaceURI, localName, qName, atts);
	 }
	 public void characters(char[] ch, int start, int length) throws SAXException {
		 targetHandler.characters(ch, start, length);
	 }
	 public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
		 nsContext.popContext();
		 targetHandler.endElement(namespaceURI, localName, qName);
	 }
	 class NamespaceContext implements NamespaceResolver {
		 private final NamespaceSupport nsContext;
		 private static final String DUMMY_DEFAULT_URI = "" "";
		 NamespaceContext() {
			 nsContext = new NamespaceSupport();
		 }
		 void popContext() {
			 nsContext.popContext();
		 }
		 void pushContext() {
			 nsContext.pushContext();
		 }
		 void reset() {
			 nsContext.reset();
		 }
		 boolean declarePrefix(String prefix, String uri) {
			 if (Name.NS_DEFAULT_URI.equals(uri)) {
				 uri = DUMMY_DEFAULT_URI;
			 }
			 return nsContext.declarePrefix(prefix, uri);
		 }
		 public String getURI(String prefix) throws NamespaceException {
			 String uri = nsContext.getURI(prefix);
			 if (uri == null) {
				 throw new NamespaceException(""unknown prefix"");
			 }
			 else if (DUMMY_DEFAULT_URI.equals(uri)) {
				 return Name.NS_DEFAULT_URI;
			 }
			 else {
				 return uri;
			 }
		 }
		 public String getPrefix(String uri) throws NamespaceException {
			 if (Name.NS_DEFAULT_URI.equals(uri)) {
				 uri = DUMMY_DEFAULT_URI;
			 }
			 String prefix = nsContext.getPrefix(uri);
			 if (prefix == null) {
				 if (uri.equals(nsContext.getURI(Name.NS_EMPTY_PREFIX))) {
					 return Name.NS_EMPTY_PREFIX;
				 }
				 throw new NamespaceException(""unknown uri"");
			 }
			 return prefix;
		 }
	 }
	 public String getUniquePrefix(String uriHint) throws RepositoryException {
		 return ""_pre"" + (nsReg.getPrefixes().length + 1);
	 }
}",0,0,0,0
"public MessageDigest get() {
	 MessageDigest digest = super.get();
	 digest.reset();
	 return digest;
 }",0,0,0,0
"public class Zip extends MatchingTask {
	 protected File zipFile;
	 private ZipScanner zs;
	 private File baseDir;
	 protected Hashtable entries = new Hashtable();
	 private Vector groupfilesets = new Vector();
	 private Vector filesetsFromGroupfilesets = new Vector();
	 protected String duplicate = ""add"";
	 private boolean doCompress = true;
	 private boolean doUpdate = false;
	 private boolean savedDoUpdate = false;
	 private boolean doFilesonly = false;
	 protected String archiveType = ""zip"";
	 private static final long EMPTY_CRC = new CRC32 ().getValue ();
	 protected String emptyBehavior = ""skip"";
	 private Vector resources = new Vector();
	 protected Hashtable addedDirs = new Hashtable();
	 private Vector addedFiles = new Vector();
	 protected boolean doubleFilePass = false;
	 protected boolean skipWriting = false;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private boolean addingNewFiles = false;
	 private String encoding;
	 private boolean keepCompression = false;
	 private boolean roundUp = true;
	 private String comment = """";
	 private int level = ZipOutputStream.DEFAULT_COMPRESSION;
	 public void setZipfile(File zipFile) {
		 setDestFile(zipFile);
	 }
	 public void setFile(File file) {
		 setDestFile(file);
	 }
	 public void setDestFile(File destFile) {
		 this.zipFile = destFile;
	 }
	 public File getDestFile() {
		 return zipFile;
	 }
	 public void setBasedir(File baseDir) {
		 this.baseDir = baseDir;
	 }
	 public void setCompress(boolean c) {
		 doCompress = c;
	 }
	 public boolean isCompress() {
		 return doCompress;
	 }
	 public void setFilesonly(boolean f) {
		 doFilesonly = f;
	 }
	 public void setUpdate(boolean c) {
		 doUpdate = c;
		 savedDoUpdate = c;
	 }
	 public boolean isInUpdateMode() {
		 return doUpdate;
	 }
	 public void addFileset(FileSet set) {
		 add(set);
	 }
	 public void addZipfileset(ZipFileSet set) {
		 add(set);
	 }
	 public void add(ResourceCollection a) {
		 resources.add(a);
	 }
	 public void addZipGroupFileset(FileSet set) {
		 groupfilesets.addElement(set);
	 }
	 public void setDuplicate(Duplicate df) {
		 duplicate = df.getValue();
	 }
	 public static class WhenEmpty extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""fail"", ""skip"", ""create""}
			;
		 }
	 }
	 public void setWhenempty(WhenEmpty we) {
		 emptyBehavior = we.getValue();
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public String getEncoding() {
		 return encoding;
	 }
	 public void setKeepCompression(boolean keep) {
		 keepCompression = keep;
	 }
	 public void setComment(String comment) {
		 this.comment = comment;
	 }
	 public String getComment() {
		 return comment;
	 }
	 public void setLevel(int level) {
		 this.level = level;
	 }
	 public int getLevel() {
		 return level;
	 }
	 public void setRoundUp(boolean r) {
		 roundUp = r;
	 }
	 public void execute() throws BuildException {
		 if (doubleFilePass) {
			 skipWriting = true;
			 executeMain();
			 skipWriting = false;
			 executeMain();
		 }
		 else {
			 executeMain();
		 }
	 }
	 public void executeMain() throws BuildException {
		 if (baseDir == null && resources.size() == 0 && groupfilesets.size() == 0 && ""zip"".equals(archiveType)) {
			 throw new BuildException(""basedir attribute must be set, "" + ""or at least one "" + ""resource collection must be given!"");
		 }
		 if (zipFile == null) {
			 throw new BuildException(""You must specify the "" + archiveType + "" file to create!"");
		 }
		 if (zipFile.exists() && !zipFile.isFile()) {
			 throw new BuildException(zipFile + "" is not a file."");
		 }
		 if (zipFile.exists() && !zipFile.canWrite()) {
			 throw new BuildException(zipFile + "" is read-only."");
		 }
		 File renamedFile = null;
		 addingNewFiles = true;
		 if (doUpdate && !zipFile.exists()) {
			 doUpdate = false;
			 log(""ignoring update attribute as "" + archiveType + "" doesn't exist."", Project.MSG_DEBUG);
		 }
		 for (int i = 0;
		 i < groupfilesets.size();
		 i++) {
			 log(""Processing groupfileset "", Project.MSG_VERBOSE);
			 FileSet fs = (FileSet) groupfilesets.elementAt(i);
			 FileScanner scanner = fs.getDirectoryScanner(getProject());
			 String[] files = scanner.getIncludedFiles();
			 File basedir = scanner.getBasedir();
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 log(""Adding file "" + files[j] + "" to fileset"", Project.MSG_VERBOSE);
				 ZipFileSet zf = new ZipFileSet();
				 zf.setProject(getProject());
				 zf.setSrc(new File(basedir, files[j]));
				 add(zf);
				 filesetsFromGroupfilesets.addElement(zf);
			 }
		 }
		 Vector vfss = new Vector();
		 if (baseDir != null) {
			 FileSet fs = (FileSet) getImplicitFileSet().clone();
			 fs.setDir(baseDir);
			 vfss.addElement(fs);
		 }
		 for (int i = 0;
		 i < resources.size();
		 i++) {
			 ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
			 vfss.addElement(rc);
		 }
		 ResourceCollection[] fss = new ResourceCollection[vfss.size()];
		 vfss.copyInto(fss);
		 boolean success = false;
		 try {
			 ArchiveState state = getResourcesToAdd(fss, zipFile, false);
			 if (!state.isOutOfDate()) {
				 return;
			 }
			 if (!zipFile.exists() && state.isWithoutAnyResources()) {
				 createEmptyZip(zipFile);
				 return;
			 }
			 Resource[][] addThem = state.getResourcesToAdd();
			 if (doUpdate) {
				 renamedFile = FILE_UTILS.createTempFile(""zip"", "".tmp"", zipFile.getParentFile());
				 renamedFile.deleteOnExit();
				 try {
					 FILE_UTILS.rename(zipFile, renamedFile);
				 }
				 catch (SecurityException e) {
					 throw new BuildException( ""Not allowed to rename old file ("" + zipFile.getAbsolutePath() + "") to temporary file"");
				 }
				 catch (IOException e) {
					 throw new BuildException( ""Unable to rename old file ("" + zipFile.getAbsolutePath() + "") to temporary file"");
				 }
			 }
			 String action = doUpdate ? ""Updating "" : ""Building "";
			 log(action + archiveType + "": "" + zipFile.getAbsolutePath());
			 ZipOutputStream zOut = null;
			 try {
				 if (!skipWriting) {
					 zOut = new ZipOutputStream(zipFile);
					 zOut.setEncoding(encoding);
					 zOut.setMethod(doCompress ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
					 zOut.setLevel(level);
				 }
				 initZipOutputStream(zOut);
				 for (int i = 0;
				 i < fss.length;
				 i++) {
					 if (addThem[i].length != 0) {
						 addResources(fss[i], addThem[i], zOut);
					 }
				 }
				 if (doUpdate) {
					 addingNewFiles = false;
					 ZipFileSet oldFiles = new ZipFileSet();
					 oldFiles.setProject(getProject());
					 oldFiles.setSrc(renamedFile);
					 oldFiles.setDefaultexcludes(false);
					 for (int i = 0;
					 i < addedFiles.size();
					 i++) {
						 PatternSet.NameEntry ne = oldFiles.createExclude();
						 ne.setName((String) addedFiles.elementAt(i));
					 }
					 DirectoryScanner ds = oldFiles.getDirectoryScanner(getProject());
					 ((ZipScanner) ds).setEncoding(encoding);
					 String[] f = ds.getIncludedFiles();
					 Resource[] r = new Resource[f.length];
					 for (int i = 0;
					 i < f.length;
					 i++) {
						 r[i] = ds.getResource(f[i]);
					 }
					 if (!doFilesonly) {
						 String[] d = ds.getIncludedDirectories();
						 Resource[] dr = new Resource[d.length];
						 for (int i = 0;
						 i < d.length;
						 i++) {
							 dr[i] = ds.getResource(d[i]);
						 }
						 Resource[] tmp = r;
						 r = new Resource[tmp.length + dr.length];
						 System.arraycopy(dr, 0, r, 0, dr.length);
						 System.arraycopy(tmp, 0, r, dr.length, tmp.length);
					 }
					 addResources(oldFiles, r, zOut);
				 }
				 if (zOut != null) {
					 zOut.setComment(comment);
				 }
				 finalizeZipOutputStream(zOut);
				 if (doUpdate) {
					 if (!renamedFile.delete()) {
						 log (""Warning: unable to delete temporary file "" + renamedFile.getName(), Project.MSG_WARN);
					 }
				 }
				 success = true;
			 }
			 finally {
				 try {
					 if (zOut != null) {
						 zOut.close();
					 }
				 }
				 catch (IOException ex) {
					 if (success) {
						 throw ex;
					 }
				 }
			 }
		 }
		 catch (IOException ioe) {
			 String msg = ""Problem creating "" + archiveType + "": "" + ioe.getMessage();
			 if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
				 msg += "" (and the archive is probably corrupt but I could not "" + ""delete it)"";
			 }
			 if (doUpdate && renamedFile != null) {
				 try {
					 FILE_UTILS.rename(renamedFile, zipFile);
				 }
				 catch (IOException e) {
					 msg += "" (and I couldn't rename the temporary file "" + renamedFile.getName() + "" back)"";
				 }
			 }
			 throw new BuildException(msg, ioe, getLocation());
		 }
		 finally {
			 cleanUp();
		 }
	 }
	 protected final boolean isAddingNewFiles() {
		 return addingNewFiles;
	 }
	 protected final void addResources(FileSet fileset, Resource[] resources, ZipOutputStream zOut) throws IOException {
		 String prefix = """";
		 String fullpath = """";
		 int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
		 int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
		 ArchiveFileSet zfs = null;
		 if (fileset instanceof ArchiveFileSet) {
			 zfs = (ArchiveFileSet) fileset;
			 prefix = zfs.getPrefix(getProject());
			 fullpath = zfs.getFullpath(getProject());
			 dirMode = zfs.getDirMode(getProject());
			 fileMode = zfs.getFileMode(getProject());
		 }
		 if (prefix.length() > 0 && fullpath.length() > 0) {
			 throw new BuildException(""Both prefix and fullpath attributes must"" + "" not be set on the same fileset."");
		 }
		 if (resources.length != 1 && fullpath.length() > 0) {
			 throw new BuildException(""fullpath attribute may only be specified"" + "" for filesets that specify a single"" + "" file."");
		 }
		 if (prefix.length() > 0) {
			 if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
				 prefix += ""/"";
			 }
			 addParentDirs(null, prefix, zOut, """", dirMode);
		 }
		 ZipFile zf = null;
		 try {
			 boolean dealingWithFiles = false;
			 File base = null;
			 if (zfs == null || zfs.getSrc(getProject()) == null) {
				 dealingWithFiles = true;
				 base = fileset.getDir(getProject());
			 }
			 else if (zfs instanceof ZipFileSet) {
				 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
			 }
			 for (int i = 0;
			 i < resources.length;
			 i++) {
				 String name = null;
				 if (fullpath.length() > 0) {
					 name = fullpath;
				 }
				 else {
					 name = resources[i].getName();
				 }
				 name = name.replace(File.separatorChar, '/');
				 if ("""".equals(name)) {
					 continue;
				 }
				 if (resources[i].isDirectory() && !name.endsWith(""/"")) {
					 name = name + ""/"";
				 }
				 if (!doFilesonly && !dealingWithFiles && resources[i].isDirectory() && !zfs.hasDirModeBeenSet()) {
					 int nextToLastSlash = name.lastIndexOf(""/"", name.length() - 2);
					 if (nextToLastSlash != -1) {
						 addParentDirs(base, name.substring(0, nextToLastSlash + 1), zOut, prefix, dirMode);
					 }
					 if (zf != null) {
						 ZipEntry ze = zf.getEntry(resources[i].getName());
						 addParentDirs(base, name, zOut, prefix, ze.getUnixMode());
					 }
					 else {
						 ArchiveResource tr = (ArchiveResource) resources[i];
						 addParentDirs(base, name, zOut, prefix, tr.getMode());
					 }
				 }
				 else {
					 addParentDirs(base, name, zOut, prefix, dirMode);
				 }
				 if (!resources[i].isDirectory() && dealingWithFiles) {
					 File f = FILE_UTILS.resolveFile(base, resources[i].getName());
					 zipFile(f, zOut, prefix + name, fileMode);
				 }
				 else if (!resources[i].isDirectory()) {
					 if (zf != null) {
						 ZipEntry ze = zf.getEntry(resources[i].getName());
						 if (ze != null) {
							 boolean oldCompress = doCompress;
							 if (keepCompression) {
								 doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
							 }
							 try {
								 zipFile(zf.getInputStream(ze), zOut, prefix + name, ze.getTime(), zfs.getSrc(getProject()), zfs.hasFileModeBeenSet() ? fileMode : ze.getUnixMode());
							 }
							 finally {
								 doCompress = oldCompress;
							 }
						 }
					 }
					 else {
						 ArchiveResource tr = (ArchiveResource) resources[i];
						 InputStream is = null;
						 try {
							 is = tr.getInputStream();
							 zipFile(is, zOut, prefix + name, resources[i].getLastModified(), zfs.getSrc(getProject()), zfs.hasFileModeBeenSet() ? fileMode : tr.getMode());
						 }
						 finally {
							 FileUtils.close(is);
						 }
					 }
				 }
			 }
		 }
		 finally {
			 if (zf != null) {
				 zf.close();
			 }
		 }
	 }
	 protected final void addResources(ResourceCollection rc, Resource[] resources, ZipOutputStream zOut) throws IOException {
		 if (rc instanceof FileSet) {
			 addResources((FileSet) rc, resources, zOut);
			 return;
		 }
		 for (int i = 0;
		 i < resources.length;
		 i++) {
			 String name = resources[i].getName().replace(File.separatorChar, '/');
			 if ("""".equals(name)) {
				 continue;
			 }
			 if (resources[i].isDirectory() && doFilesonly) {
				 continue;
			 }
			 File base = null;
			 if (resources[i] instanceof FileResource) {
				 base = ((FileResource) resources[i]).getBaseDir();
			 }
			 if (resources[i].isDirectory()) {
				 if (!name.endsWith(""/"")) {
					 name = name + ""/"";
				 }
			 }
			 addParentDirs(base, name, zOut, """", ArchiveFileSet.DEFAULT_DIR_MODE);
			 if (!resources[i].isDirectory()) {
				 if (resources[i] instanceof FileResource) {
					 File f = ((FileResource) resources[i]).getFile();
					 zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
				 }
				 else {
					 InputStream is = null;
					 try {
						 is = resources[i].getInputStream();
						 zipFile(is, zOut, name, resources[i].getLastModified(), null, ArchiveFileSet.DEFAULT_FILE_MODE);
					 }
					 finally {
						 FileUtils.close(is);
					 }
				 }
			 }
		 }
	 }
	 protected void initZipOutputStream(ZipOutputStream zOut) throws IOException, BuildException {
	 }
	 protected void finalizeZipOutputStream(ZipOutputStream zOut) throws IOException, BuildException {
	 }
	 protected boolean createEmptyZip(File zipFile) throws BuildException {
		 log(""Note: creating empty "" + archiveType + "" archive "" + zipFile, Project.MSG_INFO);
		 OutputStream os = null;
		 try {
			 os = new FileOutputStream(zipFile);
			 byte[] empty = new byte[22];
			 empty[0] = 80;
			 empty[1] = 75;
			 empty[2] = 5;
			 empty[3] = 6;
			 os.write(empty);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Could not create empty ZIP archive "" + ""("" + ioe.getMessage() + "")"", ioe, getLocation());
		 }
		 finally {
			 if (os != null) {
				 try {
					 os.close();
				 }
				 catch (IOException e) {
				 }
			 }
		 }
		 return true;
	 }
	 private synchronized ZipScanner getZipScanner() {
		 if (zs == null) {
			 zs = new ZipScanner();
			 zs.setEncoding(encoding);
			 zs.setSrc(zipFile);
		 }
		 return zs;
	 }
	 protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs, File zipFile, boolean needsUpdate) throws BuildException {
		 ArrayList filesets = new ArrayList();
		 ArrayList rest = new ArrayList();
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (rcs[i] instanceof FileSet) {
				 filesets.add(rcs[i]);
			 }
			 else {
				 rest.add(rcs[i]);
			 }
		 }
		 ResourceCollection[] rc = (ResourceCollection[]) rest.toArray(new ResourceCollection[rest.size()]);
		 ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile, needsUpdate);
		 FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets .size()]);
		 ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
		 if (!as.isOutOfDate() && as2.isOutOfDate()) {
			 as = getNonFileSetResourcesToAdd(rc, zipFile, true);
		 }
		 Resource[][] toAdd = new Resource[rcs.length][];
		 int fsIndex = 0;
		 int restIndex = 0;
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (rcs[i] instanceof FileSet) {
				 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
			 }
			 else {
				 toAdd[i] = as.getResourcesToAdd()[restIndex++];
			 }
		 }
		 return new ArchiveState(as2.isOutOfDate(), toAdd);
	 }
	 protected ArchiveState getResourcesToAdd(FileSet[] filesets, File zipFile, boolean needsUpdate) throws BuildException {
		 Resource[][] initialResources = grabResources(filesets);
		 if (isEmpty(initialResources)) {
			 if (needsUpdate && doUpdate) {
				 return new ArchiveState(true, initialResources);
			 }
			 if (emptyBehavior.equals(""skip"")) {
				 if (doUpdate) {
					 log(archiveType + "" archive "" + zipFile + "" not updated because no new files were included."", Project.MSG_VERBOSE);
				 }
				 else {
					 log(""Warning: skipping "" + archiveType + "" archive "" + zipFile + "" because no files were included."", Project.MSG_WARN);
				 }
			 }
			 else if (emptyBehavior.equals(""fail"")) {
				 throw new BuildException(""Cannot create "" + archiveType + "" archive "" + zipFile + "": no files were included."", getLocation());
			 }
			 else {
				 if (!zipFile.exists()) {
					 needsUpdate = true;
				 }
			 }
			 return new ArchiveState(needsUpdate, initialResources);
		 }
		 if (!zipFile.exists()) {
			 return new ArchiveState(true, initialResources);
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 Resource[][] newerResources = new Resource[filesets.length][];
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 if (!(fileset instanceof ZipFileSet) || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
				 File base = filesets[i].getDir(getProject());
				 for (int j = 0;
				 j < initialResources[i].length;
				 j++) {
					 File resourceAsFile = FILE_UTILS.resolveFile(base, initialResources[i][j].getName());
					 if (resourceAsFile.equals(zipFile)) {
						 throw new BuildException(""A zip file cannot include "" + ""itself"", getLocation());
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 if (initialResources[i].length == 0) {
				 newerResources[i] = new Resource[] {
				}
				;
				 continue;
			 }
			 FileNameMapper myMapper = new IdentityMapper();
			 if (filesets[i] instanceof ZipFileSet) {
				 ZipFileSet zfs = (ZipFileSet) filesets[i];
				 if (zfs.getFullpath(getProject()) != null && !zfs.getFullpath(getProject()).equals("""")) {
					 MergingMapper fm = new MergingMapper();
					 fm.setTo(zfs.getFullpath(getProject()));
					 myMapper = fm;
				 }
				 else if (zfs.getPrefix(getProject()) != null && !zfs.getPrefix(getProject()).equals("""")) {
					 GlobPatternMapper gm = new GlobPatternMapper();
					 gm.setFrom(""*"");
					 String prefix = zfs.getPrefix(getProject());
					 if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
						 prefix += ""/"";
					 }
					 gm.setTo(prefix + ""*"");
					 myMapper = gm;
				 }
			 }
			 Resource[] resources = initialResources[i];
			 if (doFilesonly) {
				 resources = selectFileResources(resources);
			 }
			 newerResources[i] = ResourceUtils.selectOutOfDateSources(this, resources, myMapper, getZipScanner());
			 needsUpdate = needsUpdate || (newerResources[i].length > 0);
			 if (needsUpdate && !doUpdate) {
				 break;
			 }
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 return new ArchiveState(needsUpdate, newerResources);
	 }
	 protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs, File zipFile, boolean needsUpdate) throws BuildException {
		 Resource[][] initialResources = grabNonFileSetResources(rcs);
		 if (isEmpty(initialResources)) {
			 return new ArchiveState(needsUpdate, initialResources);
		 }
		 if (!zipFile.exists()) {
			 return new ArchiveState(true, initialResources);
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 Resource[][] newerResources = new Resource[rcs.length][];
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (initialResources[i].length == 0) {
				 newerResources[i] = new Resource[] {
				}
				;
				 continue;
			 }
			 for (int j = 0;
			 j < initialResources[i].length;
			 j++) {
				 if (initialResources[i][j] instanceof FileResource && zipFile.equals(((FileResource) initialResources[i][j]).getFile())) {
					 throw new BuildException(""A zip file cannot include "" + ""itself"", getLocation());
				 }
			 }
			 Resource[] rs = initialResources[i];
			 if (doFilesonly) {
				 rs = selectFileResources(rs);
			 }
			 newerResources[i] = ResourceUtils.selectOutOfDateSources(this, rs, new IdentityMapper(), getZipScanner());
			 needsUpdate = needsUpdate || (newerResources[i].length > 0);
			 if (needsUpdate && !doUpdate) {
				 break;
			 }
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 return new ArchiveState(needsUpdate, newerResources);
	 }
	 protected Resource[][] grabResources(FileSet[] filesets) {
		 Resource[][] result = new Resource[filesets.length][];
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 boolean skipEmptyNames = true;
			 if (filesets[i] instanceof ZipFileSet) {
				 ZipFileSet zfs = (ZipFileSet) filesets[i];
				 skipEmptyNames = zfs.getPrefix(getProject()).equals("""") && zfs.getFullpath(getProject()).equals("""");
			 }
			 DirectoryScanner rs = filesets[i].getDirectoryScanner(getProject());
			 if (rs instanceof ZipScanner) {
				 ((ZipScanner) rs).setEncoding(encoding);
			 }
			 Vector resources = new Vector();
			 if (!doFilesonly) {
				 String[] directories = rs.getIncludedDirectories();
				 for (int j = 0;
				 j < directories.length;
				 j++) {
					 if (!"""".equals(directories[j]) || !skipEmptyNames) {
						 resources.addElement(rs.getResource(directories[j]));
					 }
				 }
			 }
			 String[] files = rs.getIncludedFiles();
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 if (!"""".equals(files[j]) || !skipEmptyNames) {
					 resources.addElement(rs.getResource(files[j]));
				 }
			 }
			 result[i] = new Resource[resources.size()];
			 resources.copyInto(result[i]);
		 }
		 return result;
	 }
	 protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
		 Resource[][] result = new Resource[rcs.length][];
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 Iterator iter = rcs[i].iterator();
			 ArrayList rs = new ArrayList();
			 int lastDir = 0;
			 while (iter.hasNext()) {
				 Resource r = (Resource) iter.next();
				 if (r.isExists()) {
					 if (r.isDirectory()) {
						 rs.add(lastDir++, r);
					 }
					 else {
						 rs.add(r);
					 }
				 }
			 }
			 result[i] = (Resource[]) rs.toArray(new Resource[rs.size()]);
		 }
		 return result;
	 }
	 protected void zipDir(File dir, ZipOutputStream zOut, String vPath, int mode) throws IOException {
		 zipDir(dir, zOut, vPath, mode, null);
	 }
	 protected void zipDir(File dir, ZipOutputStream zOut, String vPath, int mode, ZipExtraField[] extra) throws IOException {
		 if (doFilesonly) {
			 log(""skipping directory "" + vPath + "" for file-only archive"", Project.MSG_VERBOSE);
			 return;
		 }
		 if (addedDirs.get(vPath) != null) {
			 return;
		 }
		 log(""adding directory "" + vPath, Project.MSG_VERBOSE);
		 addedDirs.put(vPath, vPath);
		 if (!skipWriting) {
			 ZipEntry ze = new ZipEntry (vPath);
			 if (dir != null && dir.exists()) {
				 ze.setTime(dir.lastModified() + (roundUp ? 1999 : 0));
			 }
			 else {
				 ze.setTime(System.currentTimeMillis() + (roundUp ? 1999 : 0));
			 }
			 ze.setSize (0);
			 ze.setMethod (ZipEntry.STORED);
			 ze.setCrc (EMPTY_CRC);
			 ze.setUnixMode(mode);
			 if (extra != null) {
				 ze.setExtraFields(extra);
			 }
			 zOut.putNextEntry(ze);
		 }
	 }
	 protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath, long lastModified, File fromArchive, int mode) throws IOException {
		 if (entries.contains(vPath)) {
			 if (duplicate.equals(""preserve"")) {
				 log(vPath + "" already added, skipping"", Project.MSG_INFO);
				 return;
			 }
			 else if (duplicate.equals(""fail"")) {
				 throw new BuildException(""Duplicate file "" + vPath + "" was found and the duplicate "" + ""attribute is 'fail'."");
			 }
			 else {
				 log(""duplicate file "" + vPath + "" found, adding."", Project.MSG_VERBOSE);
			 }
		 }
		 else {
			 log(""adding entry "" + vPath, Project.MSG_VERBOSE);
		 }
		 entries.put(vPath, vPath);
		 if (!skipWriting) {
			 ZipEntry ze = new ZipEntry(vPath);
			 ze.setTime(lastModified);
			 ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
			 if (!zOut.isSeekable() && !doCompress) {
				 long size = 0;
				 CRC32 cal = new CRC32();
				 if (!in.markSupported()) {
					 ByteArrayOutputStream bos = new ByteArrayOutputStream();
					 byte[] buffer = new byte[8 * 1024];
					 int count = 0;
					 do {
						 size += count;
						 cal.update(buffer, 0, count);
						 bos.write(buffer, 0, count);
						 count = in.read(buffer, 0, buffer.length);
					 }
					 while (count != -1);
					 in = new ByteArrayInputStream(bos.toByteArray());
				 }
				 else {
					 in.mark(Integer.MAX_VALUE);
					 byte[] buffer = new byte[8 * 1024];
					 int count = 0;
					 do {
						 size += count;
						 cal.update(buffer, 0, count);
						 count = in.read(buffer, 0, buffer.length);
					 }
					 while (count != -1);
					 in.reset();
				 }
				 ze.setSize(size);
				 ze.setCrc(cal.getValue());
			 }
			 ze.setUnixMode(mode);
			 zOut.putNextEntry(ze);
			 byte[] buffer = new byte[8 * 1024];
			 int count = 0;
			 do {
				 if (count != 0) {
					 zOut.write(buffer, 0, count);
				 }
				 count = in.read(buffer, 0, buffer.length);
			 }
			 while (count != -1);
		 }
		 addedFiles.addElement(vPath);
	 }
	 protected void zipFile(File file, ZipOutputStream zOut, String vPath, int mode) throws IOException {
		 if (file.equals(zipFile)) {
			 throw new BuildException(""A zip file cannot include itself"", getLocation());
		 }
		 FileInputStream fIn = new FileInputStream(file);
		 try {
			 zipFile(fIn, zOut, vPath, file.lastModified() + (roundUp ? 1999 : 0), null, mode);
		 }
		 finally {
			 fIn.close();
		 }
	 }
	 protected final void addParentDirs(File baseDir, String entry, ZipOutputStream zOut, String prefix, int dirMode) throws IOException {
		 if (!doFilesonly) {
			 Stack directories = new Stack();
			 int slashPos = entry.length();
			 while ((slashPos = entry.lastIndexOf('/', slashPos - 1)) != -1) {
				 String dir = entry.substring(0, slashPos + 1);
				 if (addedDirs.get(prefix + dir) != null) {
					 break;
				 }
				 directories.push(dir);
			 }
			 while (!directories.isEmpty()) {
				 String dir = (String) directories.pop();
				 File f = null;
				 if (baseDir != null) {
					 f = new File(baseDir, dir);
				 }
				 else {
					 f = new File(dir);
				 }
				 zipDir(f, zOut, prefix + dir, dirMode);
			 }
		 }
	 }
	 protected void cleanUp() {
		 addedDirs.clear();
		 addedFiles.removeAllElements();
		 entries.clear();
		 addingNewFiles = false;
		 doUpdate = savedDoUpdate;
		 Enumeration e = filesetsFromGroupfilesets.elements();
		 while (e.hasMoreElements()) {
			 ZipFileSet zf = (ZipFileSet) e.nextElement();
			 resources.removeElement(zf);
		 }
		 filesetsFromGroupfilesets.removeAllElements();
	 }
	 public void reset() {
		 resources.removeAllElements();
		 zipFile = null;
		 baseDir = null;
		 groupfilesets.removeAllElements();
		 duplicate = ""add"";
		 archiveType = ""zip"";
		 doCompress = true;
		 emptyBehavior = ""skip"";
		 doUpdate = false;
		 doFilesonly = false;
		 encoding = null;
	 }
	 protected static final boolean isEmpty(Resource[][] r) {
		 for (int i = 0;
		 i < r.length;
		 i++) {
			 if (r[i].length > 0) {
				 return false;
			 }
		 }
		 return true;
	 }
	 protected Resource[] selectFileResources(Resource[] orig) {
		 if (orig.length == 0) {
			 return orig;
		 }
		 Vector v = new Vector(orig.length);
		 for (int i = 0;
		 i < orig.length;
		 i++) {
			 if (!orig[i].isDirectory()) {
				 v.addElement(orig[i]);
			 }
			 else {
				 log(""Ignoring directory "" + orig[i].getName() + "" as only files will be added."", Project.MSG_VERBOSE);
			 }
		 }
		 if (v.size() != orig.length) {
			 Resource[] r = new Resource[v.size()];
			 v.copyInto(r);
			 return r;
		 }
		 return orig;
	 }
	 public static class Duplicate extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""add"", ""preserve"", ""fail""}
			;
		 }
	 }
	 public static class ArchiveState {
		 private boolean outOfDate;
		 private Resource[][] resourcesToAdd;
		 ArchiveState(boolean state, Resource[][] r) {
			 outOfDate = state;
			 resourcesToAdd = r;
		 }
		 public boolean isOutOfDate() {
			 return outOfDate;
		 }
		 public Resource[][] getResourcesToAdd() {
			 return resourcesToAdd;
		 }
		 public boolean isWithoutAnyResources() {
			 if (resourcesToAdd == null) {
				 return true;
			 }
			 for (int counter = 0;
			 counter < resourcesToAdd.length;
			 counter++) {
				 if (resourcesToAdd[counter] != null) {
					 if (resourcesToAdd[counter].length > 0) {
						 return false;
					 }
				 }
			 }
			 return true;
		 }
	 }
}",1,0,0,0
"public class PartitionDescriptor extends Descriptor {
	 private static final Type DESCRIPTOR_LIST_TYPE = new TypeToken<ArrayList<PartitionDescriptor>>(){
	}
	.getType();
	 private final DatasetDescriptor dataset;
	 public PartitionDescriptor(String name, DatasetDescriptor dataset) {
		 super(name);
		 this.dataset = dataset;
	 }
	 public PartitionDescriptor copy() {
		 return new PartitionDescriptor(getName(), dataset);
	 }
	 public PartitionDescriptor copyWithNewDataset(DatasetDescriptor dataset) {
		 return new PartitionDescriptor(getName(), dataset);
	 }
	 public boolean equals(Object o) {
		 if (this == o) {
			 return true;
		 }
		 if (o == null || getClass() != o.getClass()) {
			 return false;
		 }
		 PartitionDescriptor that = (PartitionDescriptor) o;
		 return dataset.equals(that.dataset) && getName().equals(that.getName());
	 }
	 public int hashCode() {
		 int result = dataset.hashCode();
		 result = 31 * result + getName().hashCode();
		 return result;
	 }
	 public static String toPartitionJsonList(List<PartitionDescriptor> descriptors) {
		 return Descriptor.GSON.toJson(descriptors, DESCRIPTOR_LIST_TYPE);
	 }
	 public static List<PartitionDescriptor> fromPartitionJsonList(String jsonList) {
		 return Descriptor.GSON.fromJson(jsonList, DESCRIPTOR_LIST_TYPE);
	 }
}",1,1,0,0
"public class SchemaCheckVerbHandler implements IVerbHandler{
	 private final Logger logger = LoggerFactory.getLogger(SchemaCheckVerbHandler.class);
	 public void doVerb(Message message, String id) {
		 logger.debug(""Received schema check request."");
		 Message response = message.getInternalReply(Schema.instance.getVersion().toString().getBytes(), message.getVersion());
		 MessagingService.instance().sendReply(response, id, message.getFrom());
	 }
}",0,0,0,0
"public String getColumnText(Object element, int columnIndex) {
	 if (element instanceof HadoopServer) {
		 HadoopServer server = (HadoopServer) element;
		 switch (columnIndex) {
			 case 0: return server.getLocationName();
			 case 1: return server.getMasterHostName().toString();
			 case 2: return server.getState();
			 case 3: return """";
		 }
	 }
	 else if (element instanceof HadoopJob) {
		 HadoopJob job = (HadoopJob) element;
		 switch (columnIndex) {
			 case 0: return job.getJobID().toString();
			 case 1: return """";
			 case 2: return job.getState().toString();
			 case 3: return job.getStatus();
		 }
	 }
	 else if (element instanceof JarModule) {
		 JarModule jar = (JarModule) element;
		 switch (columnIndex) {
			 case 0: return jar.toString();
			 case 1: return ""Publishing jar to server.."";
			 case 2: return """";
		 }
	 }
	 return null;
 }",0,0,1,0
"public HashMap<String, BufferedImage> extractCharImagesToLearn(BufferedImage imageWithText, List<String> chars, Dimension dim) {
	 this.imageWithChars = imageWithText;
	 HashMap<String, BufferedImage> charImages = new HashMap<String, BufferedImage>();
	 int i = 0;
	 while (endOfImage == false) {
		 endOfRow = false;
		 boolean foundTop = findCropTopY();
		 boolean foundBottom = false;
		 if (foundTop == true) {
			 foundBottom = findCropBottomY();
			 if (foundBottom == true) {
				 while (endOfRow == false) {
					 boolean foundLeft = false;
					 boolean foundRight = false;
					 foundLeft = findCropLeftX();
					 if (foundLeft == true) {
						 foundRight = findCropRightX();
						 if (foundRight == true) {
							 BufferedImage charImage = ImageUtilities.cropImage(imageWithText, cropLeftX, cropTopY, cropRightX, cropBottomY);
							 charImage = ImageUtilities.trimImage(charImage);
							 charImage = ImageUtilities.resizeImage(charImage, dim.getWidth(), dim.getHeight());
							 charImages.put(chars.get(i), charImage);
							 i++;
						 }
					 }
				 }
				 cropLeftX = 0;
				 cropRightX = 0;
			 }
		 }
	 }
	 cropTopY = 0;
	 cropBottomY = 0;
	 endOfImage = false;
	 return charImages;
 }",0,0,1,0
"public class SimpleFontFamily implements FontFamily{
	private String name = null;
	private FontFace normalFace = null;
	private FontFace boldFace = null;
	private FontFace italicFace = null;
	private FontFace boldItalicFace = null;
	private String normalPdfFont = null;
	private String boldPdfFont = null;
	private String italicPdfFont = null;
	private String boldItalicPdfFont = null;
	private String pdfEncoding = null;
	private Boolean isPdfEmbedded = null;
	private String defaultExportFont = null;
	private Map exportFonts = null;
	private Set locales = null;
	public String getName(){
		return name;
	}
	public void setName(String name){
		this.name = name;
	}
	public void setNormal(String normal){
		normalFace = createFontFace(normal);
	}
	public void setBold(String bold){
		boldFace = createFontFace(bold);
	}
	public void setItalic(String italic){
		italicFace = createFontFace(italic);
	}
	public void setBoldItalic(String boldItalic){
		boldItalicFace = createFontFace(boldItalic);
	}
	public FontFace getNormalFace(){
		return normalFace;
	}
	public FontFace getBoldFace(){
		return boldFace;
	}
	public FontFace getItalicFace(){
		return italicFace;
	}
	public FontFace getBoldItalicFace(){
		return boldItalicFace;
	}
	public String getNormalPdfFont(){
		return normalPdfFont;
	}
	public void setNormalPdfFont(String normalPdfFont){
		this.normalPdfFont = normalPdfFont;
	}
	public String getBoldPdfFont(){
		return boldPdfFont;
	}
	public void setBoldPdfFont(String boldPdfFont){
		this.boldPdfFont = boldPdfFont;
	}
	public String getItalicPdfFont(){
		return italicPdfFont;
	}
	public void setItalicPdfFont(String italicPdfFont){
		this.italicPdfFont = italicPdfFont;
	}
	public String getBoldItalicPdfFont(){
		return boldItalicPdfFont;
	}
	public void setBoldItalicPdfFont(String boldItalicPdfFont){
		this.boldItalicPdfFont = boldItalicPdfFont;
	}
	public String getPdfEncoding(){
		return pdfEncoding;
	}
	public void setPdfEncoding(String pdfEncoding){
		this.pdfEncoding = pdfEncoding;
	}
	public Boolean isPdfEmbedded(){
		return isPdfEmbedded;
	}
	public void setPdfEmbedded(Boolean isPdfEmbedded){
		this.isPdfEmbedded = isPdfEmbedded;
	}
	public String getDefaultExportFont(){
		return defaultExportFont;
	}
	public void setDefaultExportFont(String defaultExportFont){
		this.defaultExportFont = defaultExportFont;
	}
	public Map getExportFonts(){
		return exportFonts;
	}
	public void setExportFonts(Map exportFonts){
		this.exportFonts = exportFonts;
	}
	public String getExportFont(String key){
		String exportFont = exportFonts == null ? null : (String)exportFonts.get(key);
		return exportFont == null ? defaultExportFont : exportFont;
	}
	public Set getLocales(){
		return locales;
	}
	public void setLocales(Set locales){
		this.locales = locales;
	}
	public boolean supportsLocale(Locale locale){
		return locales == null || locales.contains(JRDataUtils.getLocaleCode(locale));
	}
	private static SimpleFontFace createFontFace(String value){
		SimpleFontFace fontFace = null;
		if (value != null){
			if (value.trim().toUpperCase().endsWith("".TTF"")){
				fontFace = new SimpleFontFace(value);
			}
			else{
				JRFontUtil.checkAwtFont(value, JRProperties.getBooleanProperty(JRStyledText.PROPERTY_AWT_IGNORE_MISSING_FONT));
				fontFace = new SimpleFontFace(new Font(value, Font.PLAIN, JRProperties.getIntegerProperty(JRFont.DEFAULT_FONT_SIZE)));
			}
		}
		return fontFace;
	}
}",0,1,0,0
"protected void parseOutput(BufferedReader reader) throws IOException {
	 if (emacsMode) {
		 parseEmacsOutput(reader);
	 }
	 else {
		 parseStandardOutput(reader);
	 }
 }",0,0,0,0
"public class SSTableImport{
	 private static final String KEYSPACE_OPTION = ""K"";
	 private static final String COLUMN_FAMILY_OPTION = ""c"";
	 private static final String KEY_COUNT_OPTION = ""n"";
	 private static final String IS_SORTED_OPTION = ""s"";
	 private static Options options;
	 private static CommandLine cmd;
	 private static Integer keyCountToImport = null;
	 private static boolean isSorted = false;
	 private static JsonFactory factory = new MappingJsonFactory();
	 static {
		 options = new Options();
		 Option optKeyspace = new Option(KEYSPACE_OPTION, true, ""Keyspace name."");
		 optKeyspace.setRequired(true);
		 options.addOption(optKeyspace);
		 Option optColfamily = new Option(COLUMN_FAMILY_OPTION, true, ""Column Family name."");
		 optColfamily.setRequired(true);
		 options.addOption(optColfamily);
		 options.addOption(new Option(KEY_COUNT_OPTION, true, ""Number of keys to import (Optional).""));
		 options.addOption(new Option(IS_SORTED_OPTION, false, ""Assume JSON file as already sorted (e.g. created by sstable2json tool) (Optional).""));
	 }
	 private static class JsonColumn<T> {
		 private ByteBuffer name;
		 private ByteBuffer value;
		 private long timestamp;
		 private String kind;
		 private int ttl;
		 private int localExpirationTime;
		 private long timestampOfLastDelete;
		 public JsonColumn(T json, CFMetaData meta, boolean isSubColumn) {
			 AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;
			 if (json instanceof List) {
				 List fields = (List<?>) json;
				 assert fields.size() >= 3 : ""Column definition should have at least 3"";
				 name = stringAsType((String) fields.get(0), comparator);
				 value = stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));
				 timestamp = (Long) fields.get(2);
				 kind = """";
				 if (fields.size() > 3) {
					 if (fields.get(3) instanceof Boolean) {
						 if (fields.size() == 6) {
							 kind = ""e"";
							 ttl = (Integer) fields.get(4);
							 localExpirationTime = (int) (long) ((Long) fields.get(5));
						 }
						 else {
							 kind = ((Boolean) fields.get(3)) ? ""d"" : """";
						 }
					 }
					 else {
						 kind = (String) fields.get(3);
						 if (isExpiring()) {
							 ttl = (Integer) fields.get(4);
							 localExpirationTime = (int) (long) ((Long) fields.get(5));
						 }
						 else if (isCounter()) {
							 timestampOfLastDelete = (long) ((Integer) fields.get(4));
						 }
					 }
				 }
			 }
		 }
		 public boolean isDeleted() {
			 return kind.equals(""d"");
		 }
		 public boolean isExpiring() {
			 return kind.equals(""e"");
		 }
		 public boolean isCounter() {
			 return kind.equals(""c"");
		 }
		 public ByteBuffer getName() {
			 return name.duplicate();
		 }
		 public ByteBuffer getValue() {
			 return value.duplicate();
		 }
	 }
	 private static void addToStandardCF(List<?> row, ColumnFamily cfamily) {
		 addColumnsToCF(row, null, cfamily);
	 }
	 private static void addColumnsToCF(List<?> row, ByteBuffer superName, ColumnFamily cfamily) {
		 CFMetaData cfm = cfamily.metadata();
		 assert cfm != null;
		 for (Object c : row) {
			 JsonColumn col = new JsonColumn<List>((List) c, cfm, (superName != null));
			 QueryPath path = new QueryPath(cfm.cfName, superName, col.getName());
			 if (col.isExpiring()) {
				 cfamily.addColumn(null, new ExpiringColumn(col.getName(), col.getValue(), col.timestamp, col.ttl, col.localExpirationTime));
			 }
			 else if (col.isCounter()) {
				 cfamily.addColumn(null, new CounterColumn(col.getName(), col.getValue(), col.timestamp, col.timestampOfLastDelete));
			 }
			 else if (col.isDeleted()) {
				 cfamily.addTombstone(path, col.getValue(), col.timestamp);
			 }
			 else {
				 cfamily.addColumn(path, col.getValue(), col.timestamp);
			 }
		 }
	 }
	 private static void addToSuperCF(Map<?, ?> row, ColumnFamily cfamily) {
		 CFMetaData metaData = cfamily.metadata();
		 assert metaData != null;
		 AbstractType comparator = metaData.comparator;
		 for (Map.Entry<?, ?> entry : row.entrySet()) {
			 Map<?, ?> data = (Map<?, ?>) entry.getValue();
			 addColumnsToCF((List<?>) data.get(""subColumns""), stringAsType((String) entry.getKey(), comparator), cfamily);
		 }
	 }
	 public static void importJson(String jsonFile, String keyspace, String cf, String ssTablePath) throws IOException {
		 ColumnFamily columnFamily = ColumnFamily.create(keyspace, cf);
		 IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
		 int importedKeys = (isSorted) ? importSorted(jsonFile, columnFamily, ssTablePath, partitioner) : importUnsorted(getParser(jsonFile), columnFamily, ssTablePath, partitioner);
		 if (importedKeys != -1) System.out.printf(""%d keys imported successfully.%n"", importedKeys);
	 }
	 private static int importUnsorted(JsonParser parser, ColumnFamily columnFamily, String ssTablePath, IPartitioner<?> partitioner) throws IOException {
		 int importedKeys = 0;
		 long start = System.currentTimeMillis();
		 Map<?, ?> data = parser.readValueAs(new TypeReference<Map<?, ?>>() {
		}
		);
		 keyCountToImport = (keyCountToImport == null) ? data.size() : keyCountToImport;
		 SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);
		 System.out.printf(""Importing %s keys...%n"", keyCountToImport);
		 SortedMap<DecoratedKey,String> decoratedKeys = new TreeMap<DecoratedKey,String>();
		 for (Object keyObject : data.keySet()) {
			 String key = (String) keyObject;
			 decoratedKeys.put(partitioner.decorateKey(hexToBytes(key)), key);
		 }
		 for (Map.Entry<DecoratedKey, String> rowKey : decoratedKeys.entrySet()) {
			 if (columnFamily.getType() == ColumnFamilyType.Super) {
				 addToSuperCF((Map<?, ?>) data.get(rowKey.getValue()), columnFamily);
			 }
			 else {
				 addToStandardCF((List<?>) data.get(rowKey.getValue()), columnFamily);
			 }
			 writer.append(rowKey.getKey(), columnFamily);
			 columnFamily.clear();
			 importedKeys++;
			 long current = System.currentTimeMillis();
			 if (current - start >= 5000) {
				 System.out.printf(""Currently imported %d keys.%n"", importedKeys);
				 start = current;
			 }
			 if (keyCountToImport == importedKeys) break;
		 }
		 writer.closeAndOpenReader();
		 return importedKeys;
	 }
	 public static int importSorted(String jsonFile, ColumnFamily columnFamily, String ssTablePath, IPartitioner<?> partitioner) throws IOException {
		 int importedKeys = 0;
		 long start = System.currentTimeMillis();
		 JsonParser parser = getParser(jsonFile);
		 if (keyCountToImport == null) {
			 keyCountToImport = 0;
			 System.out.println(""Counting keys to import, please wait... (NOTE: to skip this use -n <num_keys>)"");
			 parser.nextToken();
			 while (parser.nextToken() != null) {
				 parser.nextToken();
				 parser.skipChildren();
				 if (parser.getCurrentName() == null) continue;
				 keyCountToImport++;
			 }
		 }
		 System.out.printf(""Importing %s keys...%n"", keyCountToImport);
		 parser = getParser(jsonFile);
		 SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);
		 int lineNumber = 1;
		 DecoratedKey prevStoredKey = null;
		 while (parser.nextToken() != null) {
			 String key = parser.getCurrentName();
			 if (key != null) {
				 String tokenName = parser.nextToken().name();
				 if (tokenName.equals(""START_ARRAY"")) {
					 if (columnFamily.getType() == ColumnFamilyType.Super) {
						 throw new RuntimeException(""Can't write Standard columns to the Super Column Family."");
					 }
					 List<?> columns = parser.readValueAs(new TypeReference<List<?>>() {
					}
					);
					 addToStandardCF(columns, columnFamily);
				 }
				 else if (tokenName.equals(""START_OBJECT"")) {
					 if (columnFamily.getType() == ColumnFamilyType.Standard) {
						 throw new RuntimeException(""Can't write Super columns to the Standard Column Family."");
					 }
					 Map<?, ?> columns = parser.readValueAs(new TypeReference<Map<?, ?>>() {
					}
					);
					 addToSuperCF(columns, columnFamily);
				 }
				 else {
					 throw new UnsupportedOperationException(""Only Array or Hash allowed as row content."");
				 }
				 DecoratedKey currentKey = partitioner.decorateKey(hexToBytes(key));
				 if (prevStoredKey != null && prevStoredKey.compareTo(currentKey) != -1) {
					 System.err.printf(""Line %d: Key %s is greater than previous, collection is not sorted properly. Aborting import. You might need to delete SSTables manually.%n"", lineNumber, key);
					 return -1;
				 }
				 writer.append(currentKey, columnFamily);
				 columnFamily.clear();
				 prevStoredKey = currentKey;
				 importedKeys++;
				 lineNumber++;
				 long current = System.currentTimeMillis();
				 if (current - start >= 5000) {
					 System.out.printf(""Currently imported %d keys.%n"", importedKeys);
					 start = current;
				 }
				 if (keyCountToImport == importedKeys) break;
			 }
		 }
		 writer.closeAndOpenReader();
		 return importedKeys;
	 }
	 private static JsonParser getParser(String fileName) throws IOException {
		 return factory.createJsonParser(new File(fileName)).configure(JsonParser.Feature.INTERN_FIELD_NAMES, false);
	 }
	 public static void main(String[] args) throws IOException, ParseException, ConfigurationException {
		 CommandLineParser parser = new PosixParser();
		 try {
			 cmd = parser.parse(options, args);
		 }
		 catch (org.apache.commons.cli.ParseException e) {
			 System.err.println(e.getMessage());
			 printProgramUsage();
			 System.exit(1);
		 }
		 if (cmd.getArgs().length != 2) {
			 printProgramUsage();
			 System.exit(1);
		 }
		 String json = cmd.getArgs()[0];
		 String ssTable = cmd.getArgs()[1];
		 String keyspace = cmd.getOptionValue(KEYSPACE_OPTION);
		 String cfamily = cmd.getOptionValue(COLUMN_FAMILY_OPTION);
		 if (cmd.hasOption(KEY_COUNT_OPTION)) {
			 keyCountToImport = Integer.valueOf(cmd.getOptionValue(KEY_COUNT_OPTION));
		 }
		 if (cmd.hasOption(IS_SORTED_OPTION)) {
			 isSorted = true;
		 }
		 DatabaseDescriptor.loadSchemas();
		 if (DatabaseDescriptor.getNonSystemTables().size() < 1) {
			 String msg = ""no non-system tables are defined"";
			 System.err.println(msg);
			 throw new ConfigurationException(msg);
		 }
		 try {
			 importJson(json, keyspace, cfamily, ssTable);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 System.err.println(""ERROR: "" + e.getMessage());
			 System.exit(-1);
		 }
		 System.exit(0);
	 }
	 private static void printProgramUsage() {
		 System.out.printf(""Usage: %s -s -K <keyspace> -c <column_family> -n <num_keys> <json> <sstable>%n%n"", SSTableImport.class.getName());
		 System.out.println(""Options:"");
		 for (Object o : options.getOptions()) {
			 Option opt = (Option) o;
			 System.out.println("" -"" +opt.getOpt() + "" - "" + opt.getDescription());
		 }
	 }
	 public static void setKeyCountToImport(Integer keyCount) {
		 keyCountToImport = keyCount;
	 }
	 private static ByteBuffer stringAsType(String content, AbstractType type) {
		 try {
			 return (type == BytesType.instance) ? hexToBytes(content) : type.fromString(content);
		 }
		 catch (MarshalException e) {
			 throw new RuntimeException(e.getMessage());
		 }
	 }
}",0,0,0,0
"public class EJBQLTrimSpecification extends SimpleNode {
	 public EJBQLTrimSpecification(int id) {
		 super(id);
	 }
}",0,0,0,0
"public class LargeSupportTankMapSet implements DisplayMapSet {
	 private static final String IMAGE_DIR = ""data/images/widgets"";
	 private Component comp;
	 private PMSimplePolygonArea[] areas = new PMSimplePolygonArea[15];
	 private PMSimpleLabel[] labels = new PMSimpleLabel[16];
	 private PMValueLabel[] vLabels = new PMValueLabel[16];
	 private Vector<BackGroundDrawer> bgDrawers = new Vector<BackGroundDrawer>();
	 private PMAreasGroup content = new PMAreasGroup();
	 private Polygon frontArmor = new Polygon( new int[] {
	 0, 23, 157, 180, 157, 118, 62, 23 }
	, new int[] {
	 30, 7, 7, 30, 41, 25, 25, 41 }
	, 8);
	 private Polygon frontIS = new Polygon( new int[] {
	 23, 62, 118, 157, 93, 93, 87, 87 }
	, new int[] {
	 41, 25, 25, 41, 73, 42, 42, 73 }
	, 8);
	 private Polygon leftFrontArmor = new Polygon( new int[] {
	 0, 0, 23, 23 }
	, new int[] {
	 30, 109, 109, 41 }
	, 4);
	 private Polygon leftFrontIS = new Polygon( new int[] {
	23, 87, 87, 84, 80, 71, 59, 23}
	, new int[] {
	41, 73, 80, 80, 87, 87, 109, 109}
	, 8);
	 private Polygon leftRearArmor = new Polygon( new int[] {
	 0, 0, 23, 23 }
	, new int[] {
	 109, 187, 175, 109 }
	, 4);
	 private Polygon leftRearIS = new Polygon( new int[] {
	23, 23, 66, 59, 59}
	, new int[] {
	109, 175, 161, 149, 109}
	, 5);
	 private Polygon rightFrontArmor = new Polygon( new int[] {
	 157, 180, 180, 157 }
	, new int[] {
	 41, 30, 109, 109 }
	, 4);
	 private Polygon rightFrontIS = new Polygon( new int[] {
	 93, 157, 157, 121, 109, 100, 96, 93 }
	, new int[] {
	 73, 41, 109, 109, 87, 87, 80, 80 }
	, 8);
	 private Polygon rightRearArmor = new Polygon( new int[] {
	 157, 180, 180, 157 }
	, new int[] {
	 109, 109, 187, 175 }
	, 4);
	 private Polygon rightRearIS = new Polygon( new int[] {
	 121, 157, 157, 114, 121, 121 }
	, new int[] {
	 109, 109, 175, 161, 149, 109 }
	, 6);
	 private Polygon rearArmor = new Polygon( new int[] {
	 180, 152, 26, 0, 23, 59, 121, 157 }
	, new int[] {
	 187, 208, 208, 187, 175, 192, 192, 175 }
	, 8);
	 private Polygon rearIS = new Polygon( new int[] {
	 157, 121, 59, 23, 66, 76, 105, 114 }
	, new int[] {
	 175, 192, 192, 175, 161, 177, 177, 161 }
	, 8);
	 private Polygon turretArmor = new Polygon( new int[] {
	 87, 87, 84, 80, 71, 59, 59, 75, 90, 90, 80, 65, 65, 115, 115, 100, 90, 90, 105, 121, 121, 109, 100, 96, 93, 93 }
	, new int[] {
	 42, 80, 80, 87, 87, 109, 149, 177, 177, 165, 165, 142, 125, 125, 142, 165, 165, 177, 177, 149, 109, 87, 87 , 80, 80, 42 }
	, 26);
	 private Polygon turretIS = new Polygon( new int[] {
	 65, 65, 80, 100, 115, 115 }
	, new int[] {
	 125, 142, 165, 165, 142, 125 }
	, 6);
	 private static final Font FONT_LABEL = new Font( ""SansSerif"", Font.PLAIN, GUIPreferences.getInstance().getInt(""AdvancedMechDisplayArmorSmallFontSize""));
	 private static final Font FONT_VALUE = new Font( ""SansSerif"", Font.PLAIN, GUIPreferences.getInstance().getInt(""AdvancedMechDisplayArmorLargeFontSize""));
	 public LargeSupportTankMapSet(Component c) {
		 comp = c;
		 setAreas();
		 setLabels();
		 setBackGround();
		 setContent();
	 }
	 public void setRest() {
	 }
	 public PMAreasGroup getContentGroup() {
		 return content;
	 }
	 public Vector<BackGroundDrawer> getBackgroundDrawers() {
		 return bgDrawers;
	 }
	 public void setEntity(Entity e) {
		 LargeSupportTank t = (LargeSupportTank) e;
		 int a = 1;
		 int a0 = 1;
		 for (int i = 1;
		 i < 8;
		 i++) {
			 a = t.getArmor(i);
			 a0 = t.getOArmor(i);
			 vLabels[i].setValue(t.getArmorString(i));
			 WidgetUtils.setAreaColor(areas[i], vLabels[i], (double) a / (double) a0);
		 }
		 for (int i = 8;
		 i < 15;
		 i++) {
			 a = t.getInternal(i - 8);
			 a0 = t.getOInternal(i - 8);
			 vLabels[i].setValue(t.getInternalString(i - 8));
			 WidgetUtils.setAreaColor(areas[i], vLabels[i], (double) a / (double) a0);
		 }
		 vLabels[15].setValue(String.valueOf(((SupportTank)t).getBARRating()));
	 }
	 private void setContent() {
		 for (int i = 1;
		 i < 15;
		 i++) {
			 content.addArea(areas[i]);
			 content.addArea(labels[i]);
			 content.addArea(vLabels[i]);
		 }
		 content.addArea(labels[15]);
		 content.addArea(vLabels[15]);
	 }
	 private void setAreas() {
		 areas[1] = new PMSimplePolygonArea(frontArmor);
		 areas[2] = new PMSimplePolygonArea(rightFrontArmor);
		 areas[3] = new PMSimplePolygonArea(leftFrontArmor);
		 areas[4] = new PMSimplePolygonArea(rightRearArmor);
		 areas[5] = new PMSimplePolygonArea(leftRearArmor);
		 areas[6] = new PMSimplePolygonArea(rearArmor);
		 areas[7] = new PMSimplePolygonArea(turretArmor);
		 areas[8] = new PMSimplePolygonArea(frontIS);
		 areas[9] = new PMSimplePolygonArea(rightFrontIS);
		 areas[10] = new PMSimplePolygonArea(leftFrontIS);
		 areas[11] = new PMSimplePolygonArea(rightRearIS);
		 areas[12] = new PMSimplePolygonArea(leftRearIS);
		 areas[13] = new PMSimplePolygonArea(rearIS);
		 areas[14] = new PMSimplePolygonArea(turretIS);
	 }
	 private void setLabels() {
		 FontMetrics fm = comp.getFontMetrics(FONT_LABEL);
		 labels[1] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.FrontArmor""), fm, Color.black, 85, 15);
		 labels[2] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.FRS""), fm, Color.black, 170, 80);
		 labels[3] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.FLS""), fm, Color.black, 10, 80);
		 labels[4] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.RRS""), fm, Color.black, 170, 155);
		 labels[5] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.RLS""), fm, Color.black, 10, 155);
		 labels[6] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.RearArmor""), fm, Color.black, 85, 200);
		 labels[7] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.TurretArmor""), fm, Color.black, 90, 104);
		 labels[8] = WidgetUtils .createLabel( Messages.getString(""LargeSupportTankMapSet.FrontIS""), fm, Color.black, 80, 30);
		 labels[9] = WidgetUtils.createLabel( Messages.getString(""LargeSupportTankMapSet.FRIS""), fm, Color.black, 120, 80);
		 labels[10] = WidgetUtils.createLabel( Messages.getString(""LargeSupportTankMapSet.FLIS""), fm, Color.black, 43, 80);
		 labels[11] = WidgetUtils.createLabel( Messages.getString(""LargeSupportTankMapSet.RRIS""), fm, Color.black, 140, 155);
		 labels[12] = WidgetUtils.createLabel( Messages.getString(""LargeSupportTankMapSet.RLIS""), fm, Color.black, 43, 155);
		 labels[13] = WidgetUtils .createLabel( Messages.getString(""LargeSupportTankMapSet.RearIS""), fm, Color.black, 85, 185);
		 labels[14] = WidgetUtils .createLabel( Messages.getString(""LargeSupportTankMapSet.TurretIS""), fm, Color.black, 90, 140);
		 labels[15] = WidgetUtils.createLabel(Messages .getString(""LargeSupportTankMapSet.BARRating""), fm, Color.white, 80, 220);
		 fm = comp.getFontMetrics(FONT_VALUE);
		 vLabels[1] = WidgetUtils.createValueLabel(115, 17, """", fm);
		 vLabels[2] = WidgetUtils .createValueLabel(164, 70, """", fm);
		 vLabels[3] = WidgetUtils.createValueLabel(6, 70, """", fm);
		 vLabels[4] = WidgetUtils.createValueLabel( 164, 140, """", fm);
		 vLabels[5] = WidgetUtils .createValueLabel(6, 140, """", fm);
		 vLabels[6] = WidgetUtils .createValueLabel(113, 202, """", fm);
		 vLabels[7] = WidgetUtils .createValueLabel(93, 115, """", fm);
		 vLabels[8] = WidgetUtils.createValueLabel(93, 151, """", fm);
		 vLabels[9] = WidgetUtils .createValueLabel(140, 65, """", fm);
		 vLabels[10] = WidgetUtils .createValueLabel(43, 65, """", fm);
		 vLabels[11] = WidgetUtils .createValueLabel(145, 140, """", fm);
		 vLabels[12] = WidgetUtils .createValueLabel(43, 140, """", fm);
		 vLabels[13] = WidgetUtils .createValueLabel(113,187, """", fm);
		 vLabels[14] = WidgetUtils .createValueLabel( 110, 32, """", fm);
		 vLabels[15] = WidgetUtils.createValueLabel(110, 222, """", fm);
	 }
	 private void setBackGround() {
		 Image tile = comp.getToolkit().getImage(IMAGE_DIR + ""/tile.gif"");
		 PMUtil.setImage(tile, comp);
		 int b = BackGroundDrawer.TILING_BOTH;
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.TILING_HORIZONTAL | BackGroundDrawer.VALIGN_TOP;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/h_line.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.TILING_HORIZONTAL | BackGroundDrawer.VALIGN_BOTTOM;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/h_line.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.TILING_VERTICAL | BackGroundDrawer.HALIGN_LEFT;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/v_line.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.TILING_VERTICAL | BackGroundDrawer.HALIGN_RIGHT;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/v_line.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.NO_TILING | BackGroundDrawer.VALIGN_TOP | BackGroundDrawer.HALIGN_LEFT;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/tl_corner.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.NO_TILING | BackGroundDrawer.VALIGN_BOTTOM | BackGroundDrawer.HALIGN_LEFT;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/bl_corner.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.NO_TILING | BackGroundDrawer.VALIGN_TOP | BackGroundDrawer.HALIGN_RIGHT;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/tr_corner.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
		 b = BackGroundDrawer.NO_TILING | BackGroundDrawer.VALIGN_BOTTOM | BackGroundDrawer.HALIGN_RIGHT;
		 tile = comp.getToolkit().getImage(IMAGE_DIR + ""/br_corner.gif"");
		 PMUtil.setImage(tile, comp);
		 bgDrawers.addElement(new BackGroundDrawer(tile, b));
	 }
}",1,0,0,0
"private static ArrayList<String> findURL(String keyword, StringBuffer buf) {
	int index1 = 0;
	int index = 0;
	ArrayList<String> urlList = new ArrayList<String>();
	String urlStart = "":"";
	while (true) {
		index = buf.indexOf(keyword, index);
		if (index < 0)break;
		index += keyword.length();
		index = buf.indexOf("":"", index);
		if (index < 0) {
			break;
		}
		index += 1;
		int collonIndex = index;
		while (true) {
			char ch = buf.charAt(index);
			if (ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t')index++;
			elsebreak;
		}
		char ch = buf.charAt(index);
		if (ch == '""') {
			index++;
			int index3 = buf.indexOf(""\"""", index);
			String url = decodeJSONEscape(buf.substring(index, index3).trim().replace(""\"""", """"));
			Logger.log(keyword + "": "" + url);
			urlList.add(url);
		}
	}
	return urlList;
}",0,0,1,0
"public abstract class JenaPreparedStatement extends JenaStatement implements PreparedStatement {
	 private ParameterizedSparqlString sparqlStr = new ParameterizedSparqlString();
	 private ParameterMetaData paramMetadata;
	 public JenaPreparedStatement(String sparql, JenaConnection connection, int type, int fetchDir, int fetchSize, int holdability, boolean autoCommit, int transactionLevel) throws SQLException {
		 super(connection, type, fetchDir, fetchSize, holdability, autoCommit, transactionLevel);
		 this.sparqlStr.setCommandText(sparql);
		 this.paramMetadata = new JenaParameterMetadata(this.sparqlStr);
	 }
	 public void addBatch() {
		 this.addBatch(this.sparqlStr.toString());
	 }
	 public void clearParameters() {
		 this.sparqlStr.clearParams();
	 }
	 public boolean execute() throws SQLException {
		 return this.execute(this.sparqlStr.toString());
	 }
	 public ResultSet executeQuery() throws SQLException {
		 return this.executeQuery(this.sparqlStr.toString());
	 }
	 public int executeUpdate() throws SQLException {
		 return this.executeUpdate(this.sparqlStr.toString());
	 }
	 public ResultSetMetaData getMetaData() {
		 return null;
	 }
	 public ParameterMetaData getParameterMetaData() {
		 return this.paramMetadata;
	 }
	 protected final void setParameter(int parameterIndex, Node n) throws SQLException {
		 if (parameterIndex < 1 || parameterIndex > this.paramMetadata.getParameterCount()) throw new SQLException(""Parameter Index is out of bounds"");
		 this.sparqlStr.setParam(parameterIndex - 1, n);
	 }
	 public void setArray(int parameterIndex, Array value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setAsciiStream(int parameterIndex, InputStream value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setAsciiStream(int parameterIndex, InputStream value, int arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setAsciiStream(int parameterIndex, InputStream value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBigDecimal(int parameterIndex, BigDecimal value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createLiteral(value.toPlainString(), XSDDatatype.XSDdecimal));
	 }
	 public void setBinaryStream(int parameterIndex, InputStream value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBinaryStream(int parameterIndex, InputStream value, int arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBinaryStream(int parameterIndex, InputStream value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBlob(int parameterIndex, Blob value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBlob(int parameterIndex, InputStream value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBlob(int parameterIndex, InputStream value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setBoolean(int parameterIndex, boolean value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createLiteral(Boolean.toString(value), XSDDatatype.XSDboolean));
	 }
	 public void setByte(int parameterIndex, byte value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createLiteral(Byte.toString(value), XSDDatatype.XSDbyte));
	 }
	 public void setBytes(int parameterIndex, byte[] value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setCharacterStream(int parameterIndex, Reader value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setCharacterStream(int parameterIndex, Reader value, int arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setCharacterStream(int parameterIndex, Reader value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setClob(int parameterIndex, Clob value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setClob(int parameterIndex, Reader value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setClob(int parameterIndex, Reader value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setDate(int parameterIndex, Date value) throws SQLException {
		 Calendar c = Calendar.getInstance();
		 c.setTimeInMillis(value.getTime());
		 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode(c));
	 }
	 public void setDate(int parameterIndex, Date value, Calendar arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setDouble(int parameterIndex, double value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactoryExtra.doubleToNode(value));
	 }
	 public void setFloat(int parameterIndex, float value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactoryExtra.floatToNode(value));
	 }
	 public void setInt(int parameterIndex, int value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode(value));
	 }
	 public void setLong(int parameterIndex, long value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode(value));
	 }
	 public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setNCharacterStream(int parameterIndex, Reader value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setNClob(int parameterIndex, NClob value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setNClob(int parameterIndex, Reader value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setNClob(int parameterIndex, Reader value, long arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setNString(int parameterIndex, String value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createLiteral(value));
	 }
	 public void setNull(int parameterIndex, int value) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Parameters for SPARQL statements are not nullable"");
	 }
	 public void setNull(int parameterIndex, int value, String arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Parameters for SPARQL statements are not nullable"");
	 }
	 public void setObject(int parameterIndex, Object value) throws SQLException {
		 if (value == null) throw new SQLException(""Setting a null value is not permitted"");
		 if (value instanceof Node) {
			 this.setParameter(parameterIndex, (Node) value);
		 }
		 else if (value instanceof RDFNode) {
			 this.setParameter(parameterIndex, ((RDFNode) value).asNode());
		 }
		 else if (value instanceof String) {
			 this.setParameter(parameterIndex, NodeFactory.createLiteral((String) value));
		 }
		 else if (value instanceof Boolean) {
			 this.setParameter(parameterIndex, NodeFactory.createLiteral(Boolean.toString((Boolean) value), XSDDatatype.XSDboolean));
		 }
		 else if (value instanceof Long) {
			 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Long) value));
		 }
		 else if (value instanceof Integer) {
			 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Integer) value));
		 }
		 else if (value instanceof Short) {
			 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString((Short) value), XSDDatatype.XSDshort));
		 }
		 else if (value instanceof Byte) {
			 this.setParameter(parameterIndex, NodeFactory.createLiteral(Byte.toString((Byte) value), XSDDatatype.XSDbyte));
		 }
		 else if (value instanceof BigDecimal) {
			 this.setParameter(parameterIndex, NodeFactory.createLiteral(((BigDecimal) value).toPlainString(), XSDDatatype.XSDdecimal));
		 }
		 else if (value instanceof Float) {
			 this.setParameter(parameterIndex, NodeFactoryExtra.floatToNode((Float) value));
		 }
		 else if (value instanceof Double) {
			 this.setParameter(parameterIndex, NodeFactoryExtra.doubleToNode((Double) value));
		 }
		 else if (value instanceof Date) {
			 Calendar c = Calendar.getInstance();
			 c.setTimeInMillis(((Date) value).getTime());
			 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode(c));
		 }
		 else if (value instanceof Time) {
			 Calendar c = Calendar.getInstance();
			 c.setTimeInMillis(((Time) value).getTime());
			 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
		 }
		 else if (value instanceof Calendar) {
			 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode((Calendar) value));
		 }
		 else if (value instanceof URL) {
			 this.setParameter(parameterIndex, NodeFactory.createURI(value.toString()));
		 }
		 else if (value instanceof URI) {
			 this.setParameter(parameterIndex, NodeFactory.createURI(value.toString()));
		 }
		 else if (value instanceof IRI) {
			 this.setParameter(parameterIndex, NodeFactory.createURI(value.toString()));
		 }
		 else if (value instanceof IRIx) {
			 this.setParameter(parameterIndex, NodeFactory.createURI(value.toString()));
		 }
		 else {
			 throw new SQLException( ""setObject() received a value that could not be converted to a RDF node for use in a SPARQL query"");
		 }
	 }
	 public void setObject(int parameterIndex, Object value, int targetSqlType) throws SQLException {
		 if (value == null) throw new SQLException(""Setting a null value is not permitted"");
		 try {
			 switch (targetSqlType) {
				 case Types.ARRAY: case Types.BINARY: case Types.BIT: case Types.BLOB: case Types.CLOB: case Types.DATALINK: case Types.DISTINCT: case Types.LONGNVARCHAR: case Types.LONGVARBINARY: case Types.LONGVARCHAR: case Types.NCHAR: case Types.NCLOB: case Types.NULL: case Types.NUMERIC: case Types.OTHER: case Types.REAL: case Types.REF: case Types.ROWID: case Types.SQLXML: case Types.STRUCT: case Types.VARBINARY: throw new SQLException(""The provided SQL Target Type cannot be translated into an appropriate RDF term type"");
				 case Types.BIGINT: if (value instanceof Long) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Long) value));
				 }
				 else if (value instanceof Integer) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((long)(Integer)value));
				 }
				 else if (value instanceof Short) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((long)(Short)value));
				 }
				 else if (value instanceof Byte) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((long)(Byte)value));
				 }
				 else if (value instanceof Node) {
					 long l = JdbcNodeUtils.toLong((Node) value);
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode(l));
				 }
				 else if (value instanceof String) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode(Long.parseLong((String)value)));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.BOOLEAN: if (value instanceof Boolean) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Boolean.toString((Boolean) value), XSDDatatype.XSDboolean));
				 }
				 else if (value instanceof Node) {
					 boolean b = JdbcNodeUtils.toBoolean((Node) value);
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Boolean.toString(b), XSDDatatype.XSDboolean));
				 }
				 else if (value instanceof String) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Boolean.toString(Boolean.parseBoolean((String)value)), XSDDatatype.XSDboolean));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.DATE: if (value instanceof Date) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(((Date) value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode(c));
				 }
				 else if (value instanceof Node) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(JdbcNodeUtils.toDate((Node)value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode(c));
				 }
				 else if (value instanceof Time) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(((Time) value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
				 }
				 else if (value instanceof Calendar) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode((Calendar) value));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.DECIMAL: if (value instanceof BigDecimal) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(((BigDecimal)value).toPlainString(), XSDDatatype.XSDdecimal));
				 }
				 else if (value instanceof Node) {
					 BigDecimal d = JdbcNodeUtils.toDecimal((Node)value);
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(d.toPlainString(), XSDDatatype.XSDdecimal));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.DOUBLE: if (value instanceof Double) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.doubleToNode((Double)value));
				 }
				 else if (value instanceof Float) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.doubleToNode((Float)value));
				 }
				 else if (value instanceof Node) {
					 Double d = JdbcNodeUtils.toDouble((Node)value);
					 this.setParameter(parameterIndex, NodeFactoryExtra.doubleToNode(d));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.FLOAT: if (value instanceof Float) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.floatToNode((Float)value));
				 }
				 else if (value instanceof Node) {
					 Float f = JdbcNodeUtils.toFloat((Node)value);
					 this.setParameter(parameterIndex, NodeFactoryExtra.floatToNode(f));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.INTEGER: if (value instanceof Integer) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Integer)value));
				 }
				 else if (value instanceof Short) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Short)value));
				 }
				 else if (value instanceof Byte) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Byte)value));
				 }
				 else if (value instanceof Node) {
					 Integer i = JdbcNodeUtils.toInt((Node)value);
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode(i));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired target type"");
				 }
				 break;
				 case Types.JAVA_OBJECT: if (value instanceof Node) {
					 this.setParameter(parameterIndex, (Node) value);
				 }
				 else if (value instanceof RDFNode) {
					 this.setParameter(parameterIndex, ((RDFNode) value).asNode());
				 }
				 else if (value instanceof String) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral((String) value));
				 }
				 else if (value instanceof URL) {
					 this.setParameter(parameterIndex, NodeFactory.createURI(((URL) value).toString()));
				 }
				 else if (value instanceof URI) {
					 this.setParameter(parameterIndex, NodeFactory.createURI(((URI)value).toString()));
				 }
				 else if (value instanceof IRI) {
					 this.setParameter(parameterIndex, NodeFactory.createURI(((IRI)value).toString()));
				 }
				 else if (value instanceof IRIx) {
					 this.setParameter(parameterIndex, NodeFactory.createURI(((IRIx)value).toString()));
				 }
				 else if (value instanceof BigDecimal) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(((BigDecimal)value).toPlainString(), XSDDatatype.XSDdecimal));
				 }
				 else if (value instanceof Boolean) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Boolean.toString(((Boolean)value)), XSDDatatype.XSDboolean));
				 }
				 else if (value instanceof Byte) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Byte.toString((Byte)value), XSDDatatype.XSDbyte));
				 }
				 else if (value instanceof Double) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.doubleToNode((Double)value));
				 }
				 else if (value instanceof Float) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.floatToNode((Float)value));
				 }
				 else if (value instanceof Short) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString((Short)value), XSDDatatype.XSDshort));
				 }
				 else if (value instanceof Integer) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Integer)value));
				 }
				 else if (value instanceof Long) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.intToNode((Long)value));
				 }
				 else if (value instanceof Date) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(((Date)value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode(c));
				 }
				 else if (value instanceof Time) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(((Time)value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
				 }
				 else if (value instanceof Calendar) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.dateTimeToNode((Calendar)value));
				 }
				 else {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(value.toString()));
				 }
				 break;
				 case Types.CHAR: case Types.NVARCHAR: case Types.VARCHAR: this.setParameter(parameterIndex, NodeFactory.createLiteral(value.toString()));
				 break;
				 case Types.SMALLINT: if (value instanceof Short) {
					 Short s = (Short)value;
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString(s), XSDDatatype.XSDshort));
				 }
				 else if (value instanceof Byte) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString((Byte)value), XSDDatatype.XSDshort));
				 }
				 else if (value instanceof Node) {
					 Short s = JdbcNodeUtils.toShort((Node)value);
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString(s), XSDDatatype.XSDshort));
				 }
				 else if (value instanceof String) {
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString(Short.parseShort((String)value)), XSDDatatype.XSDshort));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired type"");
				 }
				 break;
				 case Types.TIME: if (value instanceof Time) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(((Time)value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
				 }
				 else if (value instanceof Node) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(JdbcNodeUtils.toDate((Node)value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
				 }
				 else if (value instanceof Date) {
					 Calendar c = Calendar.getInstance();
					 c.setTimeInMillis(((Date)value).getTime());
					 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
				 }
				 else if (value instanceof Calendar) {
					 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode((Calendar)value));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired type"");
				 }
				 break;
				 case Types.TINYINT: if (value instanceof Byte) {
					 Byte b = (Byte)value;
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Byte.toString(b), XSDDatatype.XSDbyte));
				 }
				 else if (value instanceof Node) {
					 Byte b = JdbcNodeUtils.toByte((Node)value);
					 this.setParameter(parameterIndex, NodeFactory.createLiteral(Byte.toString(b), XSDDatatype.XSDbyte));
				 }
				 else {
					 throw new SQLException(""The given value is not marshallable to the desired type"");
				 }
				 break;
				 default: throw new SQLException(""Cannot translate an unknown SQL Target Type into an appropriate RDF term type"");
			 }
		 }
		 catch (SQLException e) {
			 throw e;
		 }
		 catch (Throwable e) {
			 throw new SQLException(""Unexpected error trying to marshal a value to the desired target type"", e);
		 }
	 }
	 public void setObject(int parameterIndex, Object value, int arg2, int arg3) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setRef(int parameterIndex, Ref value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setRowId(int parameterIndex, RowId value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setSQLXML(int parameterIndex, SQLXML value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setShort(int parameterIndex, short value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createLiteral(Short.toString(value), XSDDatatype.XSDshort));
	 }
	 public void setString(int parameterIndex, String value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createLiteral(value));
	 }
	 public void setTime(int parameterIndex, Time value) throws SQLException {
		 Calendar c = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
		 c.setTimeInMillis(value.getTime());
		 this.setParameter(parameterIndex, NodeFactoryExtra.timeToNode(c));
	 }
	 public void setTime(int parameterIndex, Time value, Calendar arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setTimestamp(int parameterIndex, Timestamp value) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setTimestamp(int parameterIndex, Timestamp value, Calendar arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setURL(int parameterIndex, URL value) throws SQLException {
		 this.setParameter(parameterIndex, NodeFactory.createURI(value.toString()));
	 }
	 public void setUnicodeStream(int parameterIndex, InputStream value, int arg2) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public ParameterizedSparqlString getParameterizedString() {
		 return this.sparqlStr.copy();
	 }
}",1,0,0,0
"public String getNamenode() {
	return ""<namenode>"";
 }",0,0,0,0
"public String authenticate(Credentials credentials, HttpMethod httpMethod) throws AuthenticationException {
	 if (this.state == UNINITIATED) {
		 throw new IllegalStateException(""Negotiate authentication process has not been initiated"");
	 }
	 String host = null;
	 try {
		 host = httpMethod.getURI().getHost();
	 }
	 catch (URIException e) {
	 }
	 if (host == null) {
		 Header header = httpMethod.getRequestHeader(""Host"");
		 if (header != null) {
			 host = header.getValue();
			 if (host.indexOf(':') >= 0) {
				 host = host.substring(0, host.indexOf(':'));
			 }
		 }
	 }
	 if (host == null) {
		 throw new IllegalStateException(""Negotiate authentication failed: empty host"");
	 }
	 String response;
	 try {
		 if (this.state == INITIATED || this.state == FAILED) {
			 response = EncodingUtil.getAsciiString(Base64.encodeBase64(KerberosHelper.initSecurityContext(""HTTP"", host, new byte[0])));
			 this.state = TYPE1_MSG_GENERATED;
		 }
		 else {
			 response = EncodingUtil.getAsciiString(Base64.encodeBase64(KerberosHelper.initSecurityContext(""HTTP"", host, serverToken)));
			 this.state = TYPE3_MSG_GENERATED;
		 }
	 }
	 catch (GSSException gsse) {
		 state = FAILED;
		 if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED) throw new InvalidCredentialsException(gsse.getMessage(), gsse);
		 if (gsse.getMajor() == GSSException.NO_CRED) throw new CredentialsNotAvailableException(gsse.getMessage(), gsse);
		 if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN || gsse.getMajor() == GSSException.OLD_TOKEN) throw new AuthChallengeException(gsse.getMessage(), gsse);
		 throw new AuthenticationException(gsse.getMessage(), gsse);
	 }
	 catch (LoginException e) {
		 state = FAILED;
		 throw new InvalidCredentialsException(e.getMessage(), e);
	 }
	 return ""Negotiate "" + response;
 }",0,0,1,0
"public void invalidateCachedTokenEndpointValues() {
	 clearEndpointCache();
 }",0,0,0,0
"static class ModifierOp extends ChildOp {
	 final int v1;
	 final int v2;
	 ModifierOp(int type, int v1, int v2) {
		 super(type);
		 this.v1 = v1;
		 this.v2 = v2;
	 }
	 int getData() {
		 return this.v1;
	 }
	 int getData2() {
		 return this.v2;
	 }
 }",0,1,0,0
"public static Control createCustomAreaWithLink(final Composite parent, final Dialog dialog, final Binary binary) {
	final String binaryLabel = binary.getLabel();
	final String prefix = ""The requested operation cannot be performed due to invalid '"" + binaryLabel+ ""' settings. Check your '"" + binaryLabel+ ""' configuration and preferences under the corresponding "";
	final String link = ""preference page"";
	final String suffix = ""."";
	final String text = prefix + link + suffix;
	final Composite control = new Composite(parent, NONE);
	control.setLayout(GridLayoutFactory.fillDefaults().create());
	final GridData gridData = GridDataFactory.fillDefaults().align(LEFT, TOP).grab(true, true).create();
	control.setLayoutData(gridData);
	final StyleRange style = new StyleRange();
	style.underline = true;
	style.underlineStyle = UNDERLINE_LINK;
	final StyledText styledText = new StyledText(control, MULTI | READ_ONLY | WRAP);
	styledText.setWordWrap(true);
	styledText.setJustify(true);
	styledText.setText(text);
	final GridData textGridData = GridDataFactory.fillDefaults().align(FILL, FILL).grab(true, true).create();
	textGridData.widthHint = TEXT_WIDTH_HINT;
	textGridData.heightHint = TEXT_HEIGHT_HINT;
	styledText.setLayoutData(textGridData);
	styledText.setEditable(false);
	styledText.setBackground(UIUtils.getSystemColor(COLOR_WIDGET_BACKGROUND));
	final int[] ranges = {
	 text.indexOf(link), link.length() }
	;
	final StyleRange[] styles = {
	 style }
	;
	styledText.setStyleRanges(ranges, styles);
	styledText.addMouseListener(new MouseAdapter() {
		public void mouseDown(final MouseEvent event) {
			try {
				final int offset = styledText.getOffsetAtPoint(new Point(event.x, event.y));
				final StyleRange actualStyle = offset >= 0 ? styledText.getStyleRangeAtOffset(offset) : null;
				if (null != actualStyle && actualStyle.underline&& UNDERLINE_LINK == actualStyle.underlineStyle) {
					dialog.close();
					final PreferenceDialog preferenceDialog = createPreferenceDialogOn(UIUtils.getShell(),BinariesPreferencePage.ID,FILTER_IDS,null);
					if (null != preferenceDialog) {
						preferenceDialog.open();
					}
				}
			}
			 catch (final IllegalArgumentException e) {
			}
		}
	}
	);
	return control;
}",0,0,1,0
"public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer {
	 private Vector selectorsList = new Vector();
	 public BaseSelectorContainer() {
	 }
	 public boolean hasSelectors() {
		 dieOnCircularReference();
		 return !(selectorsList.isEmpty());
	 }
	 public int selectorCount() {
		 dieOnCircularReference();
		 return selectorsList.size();
	 }
	 public FileSelector[] getSelectors(Project p) {
		 dieOnCircularReference();
		 FileSelector[] result = new FileSelector[selectorsList.size()];
		 selectorsList.copyInto(result);
		 return result;
	 }
	 public Enumeration selectorElements() {
		 dieOnCircularReference();
		 return selectorsList.elements();
	 }
	 public String toString() {
		 dieOnCircularReference();
		 StringBuffer buf = new StringBuffer();
		 Enumeration e = selectorElements();
		 if (e.hasMoreElements()) {
			 while (e.hasMoreElements()) {
				 buf.append(e.nextElement().toString());
				 if (e.hasMoreElements()) {
					 buf.append("", "");
				 }
			 }
		 }
		 return buf.toString();
	 }
	 public void appendSelector(FileSelector selector) {
		 selectorsList.addElement(selector);
		 setChecked(false);
	 }
	 public void validate() {
		 verifySettings();
		 dieOnCircularReference();
		 String errmsg = getError();
		 if (errmsg != null) {
			 throw new BuildException(errmsg);
		 }
		 Enumeration e = selectorElements();
		 while (e.hasMoreElements()) {
			 Object o = e.nextElement();
			 if (o instanceof BaseSelector) {
				 ((BaseSelector) o).validate();
			 }
		 }
	 }
	 public abstract boolean isSelected(File basedir, String filename, File file);
	 public void addSelector(SelectSelector selector) {
		 appendSelector(selector);
	 }
	 public void addAnd(AndSelector selector) {
		 appendSelector(selector);
	 }
	 public void addOr(OrSelector selector) {
		 appendSelector(selector);
	 }
	 public void addNot(NotSelector selector) {
		 appendSelector(selector);
	 }
	 public void addNone(NoneSelector selector) {
		 appendSelector(selector);
	 }
	 public void addMajority(MajoritySelector selector) {
		 appendSelector(selector);
	 }
	 public void addDate(DateSelector selector) {
		 appendSelector(selector);
	 }
	 public void addSize(SizeSelector selector) {
		 appendSelector(selector);
	 }
	 public void addFilename(FilenameSelector selector) {
		 appendSelector(selector);
	 }
	 public void addCustom(ExtendSelector selector) {
		 appendSelector(selector);
	 }
	 public void addContains(ContainsSelector selector) {
		 appendSelector(selector);
	 }
	 public void addPresent(PresentSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDepth(DepthSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDepend(DependSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDifferent(DifferentSelector selector) {
		 appendSelector(selector);
	 }
	 public void addType(TypeSelector selector) {
		 appendSelector(selector);
	 }
	 public void addContainsRegexp(ContainsRegexpSelector selector) {
		 appendSelector(selector);
	 }
	 public void addModified(ModifiedSelector selector) {
		 appendSelector(selector);
	 }
	 public void addReadable(ReadableSelector r) {
		 appendSelector(r);
	 }
	 public void addWritable(WritableSelector w) {
		 appendSelector(w);
	 }
	 public void add(FileSelector selector) {
		 appendSelector(selector);
	 }
	 protected synchronized void dieOnCircularReference(Stack stk, Project p) throws BuildException {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 for (Iterator i = selectorsList.iterator();
			 i.hasNext();
			) {
				 Object o = i.next();
				 if (o instanceof DataType) {
					 pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
				 }
			 }
			 setChecked(true);
		 }
	 }
}",0,0,0,0
"public class Strings {
	public static final String[] EMPTY_ARRAY = new String[0];
	public static boolean equalsIgnoreWhitespace(String left, String right) {
		String l = left == null ? """" : left.replaceAll(""\\s"", """");
		String r = right == null ? """" : right.replaceAll(""\\s"", """");
		return l.equals(r);
	}
	public static boolean equal(String literal, String name) {
		return isEmpty(literal) ? isEmpty(name) : literal.equals(name);
	}
	public static String notNull(Object o) {
		return String.valueOf(o);
	}
	public static String emptyIfNull(String s) {
		return (s == null) ? """" : s;
	}
	public static String concat(String separator, List<String> list) {
		return concat(separator, list, 0);
	}
	public static <T> String toString(Collection<T> list, Function<T, String> toString, String delim) {
		StringBuffer buffer = new StringBuffer();
		for (Iterator<T> iterator = list.iterator();
		 iterator.hasNext();
		) {
			T t = iterator.next();
			buffer.append(toString.apply(t));
			if (iterator.hasNext())buffer.append(delim);
		}
		return buffer.toString();
	}
	public static String concat(String separator, List<String> list, int skip) {
		StringBuffer buff = new StringBuffer();
		int lastIndex = list.size() - skip;
		for (int i = 0;
		 i < lastIndex;
		 i++) {
			buff.append(list.get(i));
			if (i + 1 < lastIndex)buff.append(separator);
		}
		String string = buff.toString();
		return string.trim().length() == 0 ? null : string;
	}
	public static String skipLastToken(String value, String separator) {
		int endIndex = value.lastIndexOf(separator);
		if (endIndex > 0)return value.substring(0, endIndex);
		return value;
	}
	public static String lastToken(String value, String separator) {
		int index = value.lastIndexOf(separator) + separator.length();
		if (index < value.length())return value.substring(index, value.length());
		return """";
	}
	public static String toFirstUpper(String s) {
		if (s == null || s.length() == 0 || Character.isUpperCase(s.charAt(0)))return s;
		if (s.length() == 1)return s.toUpperCase();
		return s.substring(0, 1).toUpperCase() + s.substring(1);
	}
	public static boolean isEmpty(String s) {
		return s == null || s.equals("""");
	}
	public static String newLine() {
		return System.getProperty(""line.separator"");
	}
	public static String toPlatformLineSeparator(CharSequence cs) {
		return cs.toString().replaceAll(""\r?\n"", Strings.newLine());
	}
	public static String toUnixLineSeparator(CharSequence cs) {
		return cs.toString().replaceAll(""\r?\n"", ""\n"");
	}
	public static String toFirstLower(String s) {
		if (s == null || s.length() == 0 || Character.isLowerCase(s.charAt(0)))return s;
		if (s.length() == 1)return s.toLowerCase();
		return s.substring(0, 1).toLowerCase() + s.substring(1);
	}
	private static final JavaStringConverter CONVERTER = new JavaStringConverter();
	public static String convertFromJavaString(String string, boolean useUnicode) {
		return CONVERTER.convertFromJavaString(string, useUnicode);
	}
	public static String convertToJavaString(String theString) {
		return CONVERTER.convertToJavaString(theString, true);
	}
	public static String convertToJavaString(String input, boolean useUnicode) {
		return CONVERTER.convertToJavaString(input, useUnicode);
	}
	public static char toHex(int i) {
		return CONVERTER.toHex(i);
	}
	public static List<String> split(String value, String delimiter) {
		List<String> result = new ArrayList<String>();
		int lastIndex = 0;
		int index = value.indexOf(delimiter, lastIndex);
		int pendingEmptyStrings = 0;
		while (index != -1) {
			String addMe = value.substring(lastIndex, index);
			if (addMe.length() == 0)pendingEmptyStrings++;
			else {
				while(pendingEmptyStrings > 0) {
					result.add("""");
					pendingEmptyStrings--;
				}
				result.add(addMe);
			}
			lastIndex = index + delimiter.length();
			index = value.indexOf(delimiter, lastIndex);
		}
		if (lastIndex != value.length()) {
			while(pendingEmptyStrings > 0) {
				result.add("""");
				pendingEmptyStrings--;
			}
			result.add(value.substring(lastIndex));
		}
		return result;
	}
	public static List<String> split(String value, char delimiter) {
		List<String> result = new ArrayList<String>();
		int lastIndex = 0;
		int index = value.indexOf(delimiter, lastIndex);
		int pendingEmptyStrings = 0;
		while (index != -1) {
			String addMe = value.substring(lastIndex, index);
			if (addMe.length() == 0)pendingEmptyStrings++;
			else {
				while(pendingEmptyStrings > 0) {
					result.add("""");
					pendingEmptyStrings--;
				}
				result.add(addMe);
			}
			lastIndex = index + 1;
			index = value.indexOf(delimiter, lastIndex);
		}
		if (lastIndex != value.length()) {
			while(pendingEmptyStrings > 0) {
				result.add("""");
				pendingEmptyStrings--;
			}
			result.add(value.substring(lastIndex));
		}
		return result;
	}
	public static final char SEPARATOR = ':';
	public static String pack(String[] strings) {
		if (strings != null && strings.length > 0) {
			StringBuffer buffer = new StringBuffer();
			for (String s : strings) {
				buffer.append(s.length());
				buffer.append(SEPARATOR);
				buffer.append(s);
			}
			return buffer.toString();
		}
		return null;
	}
	public static String[] unpack(String packed) {
		if (isEmpty(packed)) {
			return null;
		}
		 else {
			List<String> strings = Lists.newArrayList();
			unpack(strings, packed);
			return strings.toArray(new String[strings.size()]);
		}
	}
	private static void unpack(List<String> strings, String packed) {
		int delimiterIndex = packed.indexOf("":"");
		int size = Integer.parseInt(packed.substring(0, delimiterIndex));
		int endIndex = delimiterIndex + 1 + size;
		strings.add(packed.substring(delimiterIndex + 1, endIndex));
		if (endIndex < packed.length()) {
			unpack(strings, packed.substring(endIndex));
		}
	}
	public static String removeLeadingWhitespace(String indentationString) {
		int i = 0;
		while (i<indentationString.length() && Character.isWhitespace(indentationString.charAt(i)))i++;
		return indentationString.substring(i);
	}
	private static final char[] separator = System.getProperty(""line.separator"").toCharArray();
	public static int countLineBreaks(CharSequence text) {
		return countLineBreaks(text, 0, text.length());
	}
	public static int countLineBreaks(CharSequence text, int startInclusive, int endExclusive) {
		int result = 0;
		for (int i = startInclusive;
		 i < endExclusive;
		 i++) {
			char ch= text.charAt(i);
			if (ch == '\r') {
				result++;
				if (i + 1 < endExclusive) {
					if (text.charAt(i + 1) == '\n') {
						i++;
					}
				}
			}
			 else if (ch == '\n') {
				result++;
			}
		}
		return result;
	}
	public static CharSequence trimTrailingLineBreak(CharSequence s) {
		if (s == null)return null;
		if (s.length() == 0)return s;
		if (s.charAt(s.length() - 1) == '\n') {
			if (s.length() > 1 && s.charAt(s.length() - 2) == '\r') {
				return s.subSequence(0, s.length() - 2);
			}
			return s.subSequence(0, s.length() - 1);
		}
		if (s.charAt(s.length() - 1) == '\r') {
			return s.subSequence(0, s.length() - 1);
		}
		return s;
	}
	public static int countLines(String text) {
		return countLines(text, separator);
	}
	public static int countLines(String text, char[] separator) {
		return countLines(text, separator, 0, text.length());
	}
	public static int countLines(String text, char[] separator, int startInclusive, int endExclusive) {
		int line = 0;
		if (separator.length == 1) {
			char c = separator[0];
			for (int i = startInclusive;
			 i < endExclusive;
			 i++) {
				if (text.charAt(i) == c) {
					line++;
				}
			}
		}
		 else if (separator.length == 2) {
			char c1 = separator[0];
			char c2 = separator[1];
			for (int i = startInclusive;
			 i < endExclusive;
			 i++) {
				if (text.charAt(i) == c1 && endExclusive > i + 1 && text.charAt(i + 1) == c2) {
					line++;
					i++;
				}
				 else if (text.charAt(i) == c2) {
					line++;
				}
			}
		}
		 else {
			throw new IllegalArgumentException(""Separators with more than two characters are unexpected"");
		}
		return line;
	}
	public static String getLeadingWhiteSpace(String original) {
		for(int i=0;
		 i < original.length();
		 i++) {
			if (!Character.isWhitespace(original.charAt(i))) {
				return original.substring(0, i);
			}
		}
		return original;
	}
	public static String wordWrap(String string, int maxCharsPerLine) {
		StringBuilder document = new StringBuilder();
		StringBuilder line = new StringBuilder();
		StringBuilder word = new StringBuilder();
		StringBuilder ws = new StringBuilder();
		for (int i = 0;
		 i < string.length();
		 i++) {
			char c = string.charAt(i);
			if (c == '\n') {
				line.append(ws);
				line.append(word);
				line.append(""\n"");
				document.append(line);
				line = new StringBuilder();
				word = new StringBuilder();
				ws = new StringBuilder();
			}
			 else if (Character.isWhitespace(c)) {
				if (line.length() + word.length() + 1 > maxCharsPerLine) {
					line.append(""\n"");
					document.append(line);
					line = new StringBuilder();
					line.append(word);
					word = new StringBuilder();
					ws = new StringBuilder();
					ws.append(c);
				}
				 else if (word.length() == 0) {
					ws.append(c);
				}
				 else {
					line.append(ws);
					line.append(word);
					word = new StringBuilder();
					ws = new StringBuilder();
					ws.append(c);
				}
			}
			 else {
				word.append(c);
			}
		}
		if (line.length() + word.length() + 1 > maxCharsPerLine) {
			document.append(line);
			document.append(""\n"");
			document.append(word);
		}
		 else {
			document.append(line);
			document.append(ws);
			document.append(word);
		}
		return document.toString();
	}
}",1,0,0,0
"public static class LocalDateTimeConverter implements AttributeConverter<LocalDateTime, Date> {
	public Date convertToDatabaseColumn(LocalDateTime date) {
		return LocalDateTimeToDateConverter.INSTANCE.convert(date);
	}
	public LocalDateTime convertToEntityAttribute(Date date) {
		return DateToLocalDateTimeConverter.INSTANCE.convert(date);
	}
}",0,0,0,0
"public final class ParsableByteArray {
	 public byte[] data;
	 private int position;
	 private int limit;
	 public ParsableByteArray() {
		 data = Util.EMPTY_BYTE_ARRAY;
	 }
	 public ParsableByteArray(int limit) {
		 this.data = new byte[limit];
		 this.limit = limit;
	 }
	 public ParsableByteArray(byte[] data) {
		 this.data = data;
		 limit = data.length;
	 }
	 public ParsableByteArray(byte[] data, int limit) {
		 this.data = data;
		 this.limit = limit;
	 }
	 public void reset() {
		 position = 0;
		 limit = 0;
	 }
	 public void reset(int limit) {
		 reset(capacity() < limit ? new byte[limit] : data, limit);
	 }
	 public void reset(byte[] data) {
		 reset(data, data.length);
	 }
	 public void reset(byte[] data, int limit) {
		 this.data = data;
		 this.limit = limit;
		 position = 0;
	 }
	 public int bytesLeft() {
		 return limit - position;
	 }
	 public int limit() {
		 return limit;
	 }
	 public void setLimit(int limit) {
		 Assertions.checkArgument(limit >= 0 && limit <= data.length);
		 this.limit = limit;
	 }
	 public int getPosition() {
		 return position;
	 }
	 public int capacity() {
		 return data.length;
	 }
	 public void setPosition(int position) {
		 Assertions.checkArgument(position >= 0 && position <= limit);
		 this.position = position;
	 }
	 public void skipBytes(int bytes) {
		 setPosition(position + bytes);
	 }
	 public void readBytes(ParsableBitArray bitArray, int length) {
		 readBytes(bitArray.data, 0, length);
		 bitArray.setPosition(0);
	 }
	 public void readBytes(byte[] buffer, int offset, int length) {
		 System.arraycopy(data, position, buffer, offset, length);
		 position += length;
	 }
	 public void readBytes(ByteBuffer buffer, int length) {
		 buffer.put(data, position, length);
		 position += length;
	 }
	 public int peekUnsignedByte() {
		 return (data[position] & 0xFF);
	 }
	 public char peekChar() {
		 return (char) ((data[position] & 0xFF) << 8 | (data[position + 1] & 0xFF));
	 }
	 public int readUnsignedByte() {
		 return (data[position++] & 0xFF);
	 }
	 public int readUnsignedShort() {
		 return (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);
	 }
	 public int readLittleEndianUnsignedShort() {
		 return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8;
	 }
	 public short readShort() {
		 return (short) ((data[position++] & 0xFF) << 8 | (data[position++] & 0xFF));
	 }
	 public short readLittleEndianShort() {
		 return (short) ((data[position++] & 0xFF) | (data[position++] & 0xFF) << 8);
	 }
	 public int readUnsignedInt24() {
		 return (data[position++] & 0xFF) << 16 | (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);
	 }
	 public int readInt24() {
		 return ((data[position++] & 0xFF) << 24) >> 8 | (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);
	 }
	 public int readLittleEndianInt24() {
		 return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF) << 16;
	 }
	 public int readLittleEndianUnsignedInt24() {
		 return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF) << 16;
	 }
	 public long readUnsignedInt() {
		 return (data[position++] & 0xFFL) << 24 | (data[position++] & 0xFFL) << 16 | (data[position++] & 0xFFL) << 8 | (data[position++] & 0xFFL);
	 }
	 public long readLittleEndianUnsignedInt() {
		 return (data[position++] & 0xFFL) | (data[position++] & 0xFFL) << 8 | (data[position++] & 0xFFL) << 16 | (data[position++] & 0xFFL) << 24;
	 }
	 public int readInt() {
		 return (data[position++] & 0xFF) << 24 | (data[position++] & 0xFF) << 16 | (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);
	 }
	 public int readLittleEndianInt() {
		 return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF) << 16 | (data[position++] & 0xFF) << 24;
	 }
	 public long readLong() {
		 return (data[position++] & 0xFFL) << 56 | (data[position++] & 0xFFL) << 48 | (data[position++] & 0xFFL) << 40 | (data[position++] & 0xFFL) << 32 | (data[position++] & 0xFFL) << 24 | (data[position++] & 0xFFL) << 16 | (data[position++] & 0xFFL) << 8 | (data[position++] & 0xFFL);
	 }
	 public long readLittleEndianLong() {
		 return (data[position++] & 0xFFL) | (data[position++] & 0xFFL) << 8 | (data[position++] & 0xFFL) << 16 | (data[position++] & 0xFFL) << 24 | (data[position++] & 0xFFL) << 32 | (data[position++] & 0xFFL) << 40 | (data[position++] & 0xFFL) << 48 | (data[position++] & 0xFFL) << 56;
	 }
	 public int readUnsignedFixedPoint1616() {
		 int result = (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);
		 position += 2;
		 return result;
	 }
	 public int readSynchSafeInt() {
		 int b1 = readUnsignedByte();
		 int b2 = readUnsignedByte();
		 int b3 = readUnsignedByte();
		 int b4 = readUnsignedByte();
		 return (b1 << 21) | (b2 << 14) | (b3 << 7) | b4;
	 }
	 public int readUnsignedIntToInt() {
		 int result = readInt();
		 if (result < 0) {
			 throw new IllegalStateException(""Top bit not zero: "" + result);
		 }
		 return result;
	 }
	 public int readLittleEndianUnsignedIntToInt() {
		 int result = readLittleEndianInt();
		 if (result < 0) {
			 throw new IllegalStateException(""Top bit not zero: "" + result);
		 }
		 return result;
	 }
	 public long readUnsignedLongToLong() {
		 long result = readLong();
		 if (result < 0) {
			 throw new IllegalStateException(""Top bit not zero: "" + result);
		 }
		 return result;
	 }
	 public float readFloat() {
		 return Float.intBitsToFloat(readInt());
	 }
	 public double readDouble() {
		 return Double.longBitsToDouble(readLong());
	 }
	 public String readString(int length) {
		 return readString(length, Charset.forName(C.UTF8_NAME));
	 }
	 public String readString(int length, Charset charset) {
		 String result = new String(data, position, length, charset);
		 position += length;
		 return result;
	 }
	 public String readNullTerminatedString(int length) {
		 if (length == 0) {
			 return """";
		 }
		 int stringLength = length;
		 int lastIndex = position + length - 1;
		 if (lastIndex < limit && data[lastIndex] == 0) {
			 stringLength--;
		 }
		 String result = Util.fromUtf8Bytes(data, position, stringLength);
		 position += length;
		 return result;
	 }
	 public String readNullTerminatedString() {
		 if (bytesLeft() == 0) {
			 return null;
		 }
		 int stringLimit = position;
		 while (stringLimit < limit && data[stringLimit] != 0) {
			 stringLimit++;
		 }
		 String string = Util.fromUtf8Bytes(data, position, stringLimit - position);
		 position = stringLimit;
		 if (position < limit) {
			 position++;
		 }
		 return string;
	 }
	 public String readLine() {
		 if (bytesLeft() == 0) {
			 return null;
		 }
		 int lineLimit = position;
		 while (lineLimit < limit && !Util.isLinebreak(data[lineLimit])) {
			 lineLimit++;
		 }
		 if (lineLimit - position >= 3 && data[position] == (byte) 0xEF && data[position + 1] == (byte) 0xBB && data[position + 2] == (byte) 0xBF) {
			 position += 3;
		 }
		 String line = Util.fromUtf8Bytes(data, position, lineLimit - position);
		 position = lineLimit;
		 if (position == limit) {
			 return line;
		 }
		 if (data[position] == '\r') {
			 position++;
			 if (position == limit) {
				 return line;
			 }
		 }
		 if (data[position] == '\n') {
			 position++;
		 }
		 return line;
	 }
	 public long readUtf8EncodedLong() {
		 int length = 0;
		 long value = data[position];
		 for (int j = 7;
		 j >= 0;
		 j--) {
			 if ((value & (1 << j)) == 0) {
				 if (j < 6) {
					 value &= (1 << j) - 1;
					 length = 7 - j;
				 }
				 else if (j == 7) {
					 length = 1;
				 }
				 break;
			 }
		 }
		 if (length == 0) {
			 throw new NumberFormatException(""Invalid UTF-8 sequence first byte: "" + value);
		 }
		 for (int i = 1;
		 i < length;
		 i++) {
			 int x = data[position + i];
			 if ((x & 0xC0) != 0x80) {
				 throw new NumberFormatException(""Invalid UTF-8 sequence continuation byte: "" + value);
			 }
			 value = (value << 6) | (x & 0x3F);
		 }
		 position += length;
		 return value;
	 }
}",1,0,0,0
"public class SiteEditorContext extends EditorContext {
	private Site site;
	private boolean editMode = false;
	private boolean editAnnotations = false;
	private boolean canEdit = false;
	public SiteEditorContext(Site aSite) {
		site = aSite;
		putObject(site);
		putAllObjects(site.getAuthorisingAgents());
		putAllObjects(site.getUrlPatterns());
		putAllObjects(site.getPermissions());
	}
	public Site getSite() {
		return site;
	}
	public List<AuthorisingAgent> getSortedAuthAgents() {
		List<AuthorisingAgent> agents = new LinkedList<AuthorisingAgent>();
		agents.addAll(site.getAuthorisingAgents());
		 Collections.sort(agents, new AuthorisingAgent.AuthorisingAgentComparator());
		 return agents;
	}
	public List<UrlPattern> getSortedUrlPatterns() {
		List<UrlPattern> urlList = new LinkedList<UrlPattern>();
		urlList.addAll(site.getUrlPatterns());
		Collections.sort(urlList, new UrlPattern.UrlComparator());
		return urlList;
	}
	public boolean isEditMode() {
		return editMode;
	}
	public void setEditMode(boolean editMode) {
		this.editMode = editMode;
	}
	public boolean isEditAnnotations() {
		return editAnnotations;
	}
	public void setEditAnnotations(boolean editAnnotations) {
		this.editAnnotations = editAnnotations;
	}
	public void setCanEdit(boolean canEdit) {
		this.canEdit = canEdit;
	}
	public boolean isCanEdit() {
		return canEdit;
	}
}",0,1,0,0
"public class NativeArray extends IdScriptableObject{
	 static final long serialVersionUID = 7331366857676127338L;
	 private static final Object ARRAY_TAG = new Object();
	 private static final Integer NEGATIVE_ONE = new Integer(-1);
	 static void init(Scriptable scope, boolean sealed) {
		 NativeArray obj = new NativeArray();
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeArray() {
		 dense = null;
		 this.length = 0;
	 }
	 public NativeArray(long length) {
		 int intLength = (int) length;
		 if (intLength == length && intLength > 0) {
			 if (intLength > maximumDenseLength) intLength = maximumDenseLength;
			 dense = new Object[intLength];
			 for (int i=0;
			 i < intLength;
			 i++) dense[i] = NOT_FOUND;
		 }
		 this.length = length;
	 }
	 public NativeArray(Object[] array) {
		 dense = array;
		 this.length = array.length;
	 }
	 public String getClassName() {
		 return ""Array"";
	 }
	 private static final int Id_length = 1, MAX_INSTANCE_ID = 1;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 if (s.equals(""length"")) {
			 return instanceIdInfo(DONTENUM | PERMANENT, Id_length);
		 }
		 return super.findInstanceIdInfo(s);
	 }
	 protected String getInstanceIdName(int id) {
		 if (id == Id_length) {
			 return ""length"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 if (id == Id_length) {
			 return ScriptRuntime.wrapNumber(length);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_length) {
			 setLength(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toLocaleString: arity=1;
			 s=""toLocaleString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_join: arity=1;
			 s=""join"";
			 break;
			 case Id_reverse: arity=0;
			 s=""reverse"";
			 break;
			 case Id_sort: arity=1;
			 s=""sort"";
			 break;
			 case Id_push: arity=1;
			 s=""push"";
			 break;
			 case Id_pop: arity=1;
			 s=""pop"";
			 break;
			 case Id_shift: arity=1;
			 s=""shift"";
			 break;
			 case Id_unshift: arity=1;
			 s=""unshift"";
			 break;
			 case Id_splice: arity=1;
			 s=""splice"";
			 break;
			 case Id_concat: arity=1;
			 s=""concat"";
			 break;
			 case Id_slice: arity=1;
			 s=""slice"";
			 break;
			 case Id_indexOf: arity=1;
			 s=""indexOf"";
			 break;
			 case Id_lastIndexOf: arity=1;
			 s=""lastIndexOf"";
			 break;
			 case Id_every: arity=1;
			 s=""every"";
			 break;
			 case Id_filter: arity=1;
			 s=""filter"";
			 break;
			 case Id_forEach: arity=1;
			 s=""forEach"";
			 break;
			 case Id_map: arity=1;
			 s=""map"";
			 break;
			 case Id_some: arity=1;
			 s=""some"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(ARRAY_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(ARRAY_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: {
				 boolean inNewExpr = (thisObj == null);
				 if (!inNewExpr) {
					 return f.construct(cx, scope, args);
				 }
				 return jsConstructor(cx, scope, args);
			 }
			 case Id_toString: return toStringHelper(cx, scope, thisObj, cx.hasFeature(Context.FEATURE_TO_STRING_AS_SOURCE), false);
			 case Id_toLocaleString: return toStringHelper(cx, scope, thisObj, false, true);
			 case Id_toSource: return toStringHelper(cx, scope, thisObj, true, false);
			 case Id_join: return js_join(cx, thisObj, args);
			 case Id_reverse: return js_reverse(cx, thisObj, args);
			 case Id_sort: return js_sort(cx, scope, thisObj, args);
			 case Id_push: return js_push(cx, thisObj, args);
			 case Id_pop: return js_pop(cx, thisObj, args);
			 case Id_shift: return js_shift(cx, thisObj, args);
			 case Id_unshift: return js_unshift(cx, thisObj, args);
			 case Id_splice: return js_splice(cx, scope, thisObj, args);
			 case Id_concat: return js_concat(cx, scope, thisObj, args);
			 case Id_slice: return js_slice(cx, thisObj, args);
			 case Id_indexOf: return indexOfHelper(cx, thisObj, args, false);
			 case Id_lastIndexOf: return indexOfHelper(cx, thisObj, args, true);
			 case Id_every: case Id_filter: case Id_forEach: case Id_map: case Id_some: return iterativeMethod(cx, id, scope, thisObj, args);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 public Object get(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index];
		 return super.get(index, start);
	 }
	 public boolean has(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index] != NOT_FOUND;
		 return super.has(index, start);
	 }
	 private static long toArrayIndex(String id) {
		 double d = ScriptRuntime.toNumber(id);
		 if (d == d) {
			 long index = ScriptRuntime.toUint32(d);
			 if (index == d && index != 4294967295L) {
				 if (Long.toString(index).equals(id)) {
					 return index;
				 }
			 }
		 }
		 return -1;
	 }
	 public void put(String id, Scriptable start, Object value) {
		 super.put(id, start, value);
		 if (start == this) {
			 long index = toArrayIndex(id);
			 if (index >= length) {
				 length = index + 1;
			 }
		 }
	 }
	 public void put(int index, Scriptable start, Object value) {
		 if (start == this && !isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = value;
		 }
		 else {
			 super.put(index, start, value);
		 }
		 if (start == this) {
			 if (this.length <= index) {
				 this.length = (long)index + 1;
			 }
		 }
	 }
	 public void delete(int index) {
		 if (!isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = NOT_FOUND;
		 }
		 else {
			 super.delete(index);
		 }
	 }
	 public Object[] getIds() {
		 Object[] superIds = super.getIds();
		 if (dense == null) {
			 return superIds;
		 }
		 int N = dense.length;
		 long currentLength = length;
		 if (N > currentLength) {
			 N = (int)currentLength;
		 }
		 if (N == 0) {
			 return superIds;
		 }
		 int superLength = superIds.length;
		 Object[] ids = new Object[N + superLength];
		 System.arraycopy(dense, 0, ids, 0, N);
		 int presentCount = 0;
		 for (int i = 0;
		 i != N;
		 ++i) {
			 if (ids[i] != NOT_FOUND) {
				 ids[presentCount] = new Integer(i);
				 ++presentCount;
			 }
		 }
		 if (presentCount != N) {
			 Object[] tmp = new Object[presentCount + superLength];
			 System.arraycopy(ids, 0, tmp, 0, presentCount);
			 ids = tmp;
		 }
		 System.arraycopy(superIds, 0, ids, presentCount, superLength);
		 return ids;
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == ScriptRuntime.NumberClass) {
			 Context cx = Context.getContext();
			 if (cx.getLanguageVersion() == Context.VERSION_1_2) return new Long(length);
		 }
		 return super.getDefaultValue(hint);
	 }
	 private static Object jsConstructor(Context cx, Scriptable scope, Object[] args) {
		 if (args.length == 0) return new NativeArray();
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 return new NativeArray(args);
		 }
		 else {
			 Object arg0 = args[0];
			 if (args.length > 1 || !(arg0 instanceof Number)) {
				 return new NativeArray(args);
			 }
			 else {
				 long len = ScriptRuntime.toUint32(arg0);
				 if (len != ((Number)arg0).doubleValue()) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
				 return new NativeArray(len);
			 }
		 }
	 }
	 public long getLength() {
		 return length;
	 }
	 public long jsGet_length() {
		 return getLength();
	 }
	 private void setLength(Object val) {
		 double d = ScriptRuntime.toNumber(val);
		 long longVal = ScriptRuntime.toUint32(d);
		 if (longVal != d) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
		 if (longVal < length) {
			 if (length - longVal > 0x1000) {
				 Object[] e = getIds();
				 for (int i=0;
				 i < e.length;
				 i++) {
					 Object id = e[i];
					 if (id instanceof String) {
						 String strId = (String)id;
						 long index = toArrayIndex(strId);
						 if (index >= longVal) delete(strId);
					 }
					 else {
						 int index = ((Integer)id).intValue();
						 if (index >= longVal) delete(index);
					 }
				 }
			 }
			 else {
				 for (long i = longVal;
				 i < length;
				 i++) {
					 deleteElem(this, i);
				 }
			 }
		 }
		 length = longVal;
	 }
	 static long getLengthProperty(Context cx, Scriptable obj) {
		 if (obj instanceof NativeString) {
			 return ((NativeString)obj).getLength();
		 }
		 else if (obj instanceof NativeArray) {
			 return ((NativeArray)obj).getLength();
		 }
		 return ScriptRuntime.toUint32( ScriptRuntime.getObjectProp(obj, ""length"", cx));
	 }
	 private static Object setLengthProperty(Context cx, Scriptable target, long length) {
		 return ScriptRuntime.setObjectProp( target, ""length"", ScriptRuntime.wrapNumber(length), cx);
	 }
	 private static void deleteElem(Scriptable target, long index) {
		 int i = (int)index;
		 if (i == index) {
			 target.delete(i);
		 }
		 else {
			 target.delete(Long.toString(index));
		 }
	 }
	 private static Object getElem(Context cx, Scriptable target, long index) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 return ScriptRuntime.getObjectProp(target, id, cx);
		 }
		 else {
			 return ScriptRuntime.getObjectIndex(target, (int)index, cx);
		 }
	 }
	 private static void setElem(Context cx, Scriptable target, long index, Object value) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 ScriptRuntime.setObjectProp(target, id, value, cx);
		 }
		 else {
			 ScriptRuntime.setObjectIndex(target, (int)index, value, cx);
		 }
	 }
	 private static String toStringHelper(Context cx, Scriptable scope, Scriptable thisObj, boolean toSource, boolean toLocale) {
		 long length = getLengthProperty(cx, thisObj);
		 StringBuffer result = new StringBuffer(256);
		 String separator;
		 if (toSource) {
			 result.append('[');
			 separator = "", "";
		 }
		 else {
			 separator = "","";
		 }
		 boolean haslast = false;
		 long i = 0;
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 try {
			 if (!iterating) {
				 cx.iterating.put(thisObj, 0);
				 for (i = 0;
				 i < length;
				 i++) {
					 if (i > 0) result.append(separator);
					 Object elem = getElem(cx, thisObj, i);
					 if (elem == null || elem == Undefined.instance) {
						 haslast = false;
						 continue;
					 }
					 haslast = true;
					 if (toSource) {
						 result.append(ScriptRuntime.uneval(cx, scope, elem));
					 }
					 else if (elem instanceof String) {
						 String s = (String)elem;
						 if (toSource) {
							 result.append('\""');
							 result.append(ScriptRuntime.escapeString(s));
							 result.append('\""');
						 }
						 else {
							 result.append(s);
						 }
					 }
					 else {
						 if (toLocale) {
							 Callable fun;
							 Scriptable funThis;
							 fun = ScriptRuntime.getPropFunctionAndThis( elem, ""toLocaleString"", cx);
							 funThis = ScriptRuntime.lastStoredScriptable(cx);
							 elem = fun.call(cx, scope, funThis, ScriptRuntime.emptyArgs);
						 }
						 result.append(ScriptRuntime.toString(elem));
					 }
				 }
			 }
		 }
		 finally {
			 if (toplevel) {
				 cx.iterating = null;
			 }
		 }
		 if (toSource) {
			 if (!haslast && i > 0) result.append("", ]"");
			 else result.append(']');
		 }
		 return result.toString();
	 }
	 private static String js_join(Context cx, Scriptable thisObj, Object[] args) {
		 String separator;
		 long llength = getLengthProperty(cx, thisObj);
		 int length = (int)llength;
		 if (llength != length) {
			 throw Context.reportRuntimeError1( ""msg.arraylength.too.big"", String.valueOf(llength));
		 }
		 if (args.length < 1 || args[0] == Undefined.instance) {
			 separator = "","";
		 }
		 else {
			 separator = ScriptRuntime.toString(args[0]);
		 }
		 if (length == 0) {
			 return """";
		 }
		 String[] buf = new String[length];
		 int total_size = 0;
		 for (int i = 0;
		 i != length;
		 i++) {
			 Object temp = getElem(cx, thisObj, i);
			 if (temp != null && temp != Undefined.instance) {
				 String str = ScriptRuntime.toString(temp);
				 total_size += str.length();
				 buf[i] = str;
			 }
		 }
		 total_size += (length - 1) * separator.length();
		 StringBuffer sb = new StringBuffer(total_size);
		 for (int i = 0;
		 i != length;
		 i++) {
			 if (i != 0) {
				 sb.append(separator);
			 }
			 String str = buf[i];
			 if (str != null) {
				 sb.append(str);
			 }
		 }
		 return sb.toString();
	 }
	 private static Scriptable js_reverse(Context cx, Scriptable thisObj, Object[] args) {
		 long len = getLengthProperty(cx, thisObj);
		 long half = len / 2;
		 for(long i=0;
		 i < half;
		 i++) {
			 long j = len - i - 1;
			 Object temp1 = getElem(cx, thisObj, i);
			 Object temp2 = getElem(cx, thisObj, j);
			 setElem(cx, thisObj, i, temp2);
			 setElem(cx, thisObj, j, temp1);
		 }
		 return thisObj;
	 }
	 private static Scriptable js_sort(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 if (length <= 1) {
			 return thisObj;
		 }
		 Object compare;
		 Object[] cmpBuf;
		 if (args.length > 0 && Undefined.instance != args[0]) {
			 compare = args[0];
			 cmpBuf = new Object[2];
		 }
		 else {
			 compare = null;
			 cmpBuf = null;
		 }
		 if (length >= Integer.MAX_VALUE) {
			 heapsort_extended(cx, scope, thisObj, length, compare, cmpBuf);
		 }
		 else {
			 int ilength = (int)length;
			 Object[] working = new Object[ilength];
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 working[i] = getElem(cx, thisObj, i);
			 }
			 heapsort(cx, scope, working, ilength, compare, cmpBuf);
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 setElem(cx, thisObj, i, working[i]);
			 }
		 }
		 return thisObj;
	 }
	 private static boolean isBigger(Context cx, Scriptable scope, Object x, Object y, Object cmp, Object[] cmpBuf) {
		 if (cmp == null) {
			 if (cmpBuf != null) Kit.codeBug();
		 }
		 else {
			 if (cmpBuf == null || cmpBuf.length != 2) Kit.codeBug();
		 }
		 Object undef = Undefined.instance;
		 if (undef == y) {
			 return false;
		 }
		 else if (undef == x) {
			 return true;
		 }
		 if (cmp == null) {
			 String a = ScriptRuntime.toString(x);
			 String b = ScriptRuntime.toString(y);
			 return a.compareTo(b) > 0;
		 }
		 else {
			 cmpBuf[0] = x;
			 cmpBuf[1] = y;
			 Callable fun = ScriptRuntime.getValueFunctionAndThis(cmp, cx);
			 Scriptable funThis = ScriptRuntime.lastStoredScriptable(cx);
			 Object ret = fun.call(cx, scope, funThis, cmpBuf);
			 double d = ScriptRuntime.toNumber(ret);
			 return d > 0;
		 }
	 }
	 private static void heapsort(Context cx, Scriptable scope, Object[] array, int length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (int i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = array[i];
			 heapify(cx, scope, pivot, array, i, length, cmp, cmpBuf);
		 }
		 for (int i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = array[i];
			 array[i] = array[0];
			 heapify(cx, scope, pivot, array, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify(Context cx, Scriptable scope, Object pivot, Object[] array, int i, int end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 int child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = array[child];
			 if (child + 1 < end) {
				 Object nextVal = array[child + 1];
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 array[i] = childVal;
			 i = child;
		 }
		 array[i] = pivot;
	 }
	 private static void heapsort_extended(Context cx, Scriptable scope, Scriptable target, long length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (long i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 heapify_extended(cx, scope, pivot, target, i, length, cmp, cmpBuf);
		 }
		 for (long i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 setElem(cx, target, i, getElem(cx, target, 0));
			 heapify_extended(cx, scope, pivot, target, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify_extended(Context cx, Scriptable scope, Object pivot, Scriptable target, long i, long end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 long child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = getElem(cx, target, child);
			 if (child + 1 < end) {
				 Object nextVal = getElem(cx, target, child + 1);
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 setElem(cx, target, i, childVal);
			 i = child;
		 }
		 setElem(cx, target, i, pivot);
	 }
	 private static Object js_push(Context cx, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 setElem(cx, thisObj, length + i, args[i]);
		 }
		 length += args.length;
		 Object lengthObj = setLengthProperty(cx, thisObj, length);
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) return args.length == 0 ? Undefined.instance : args[args.length - 1];
		 else return lengthObj;
	 }
	 private static Object js_pop(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 length--;
			 result = getElem(cx, thisObj, length);
		 }
		 else {
			 result = Undefined.instance;
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_shift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 long i = 0;
			 length--;
			 result = getElem(cx, thisObj, i);
			 if (length > 0) {
				 for (i = 1;
				 i <= length;
				 i++) {
					 Object temp = getElem(cx, thisObj, i);
					 setElem(cx, thisObj, i - 1, temp);
				 }
			 }
		 }
		 else {
			 result = Undefined.instance;
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_unshift(Context cx, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 int argc = args.length;
		 if (args.length > 0) {
			 if (length > 0) {
				 for (long last = length - 1;
				 last >= 0;
				 last--) {
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, thisObj, last + argc, temp);
				 }
			 }
			 for (int i = 0;
			 i < args.length;
			 i++) {
				 setElem(cx, thisObj, i, args[i]);
			 }
			 length += args.length;
			 return setLengthProperty(cx, thisObj, length);
		 }
		 return ScriptRuntime.wrapNumber(length);
	 }
	 private static Object js_splice(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Object result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 int argc = args.length;
		 if (argc == 0) return result;
		 long length = getLengthProperty(cx, thisObj);
		 long begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
		 argc--;
		 long count;
		 if (args.length == 1) {
			 count = length - begin;
		 }
		 else {
			 double dcount = ScriptRuntime.toInteger(args[1]);
			 if (dcount < 0) {
				 count = 0;
			 }
			 else if (dcount > (length - begin)) {
				 count = length - begin;
			 }
			 else {
				 count = (long)dcount;
			 }
			 argc--;
		 }
		 long end = begin + count;
		 if (count != 0) {
			 if (count == 1 && (cx.getLanguageVersion() == Context.VERSION_1_2)) {
				 result = getElem(cx, thisObj, begin);
			 }
			 else {
				 for (long last = begin;
				 last != end;
				 last++) {
					 Scriptable resultArray = (Scriptable)result;
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, resultArray, last - begin, temp);
				 }
			 }
		 }
		 else if (count == 0 && cx.getLanguageVersion() == Context.VERSION_1_2) {
			 result = Undefined.instance;
		 }
		 long delta = argc - count;
		 if (delta > 0) {
			 for (long last = length - 1;
			 last >= end;
			 last--) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 else if (delta < 0) {
			 for (long last = end;
			 last < length;
			 last++) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 int argoffset = args.length - argc;
		 for (int i = 0;
		 i < argc;
		 i++) {
			 setElem(cx, thisObj, begin + i, args[i + argoffset]);
		 }
		 setLengthProperty(cx, thisObj, length + delta);
		 return result;
	 }
	 private static Scriptable js_concat(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(cx, scope, ""Array"");
		 Scriptable result = ctor.construct(cx, scope, ScriptRuntime.emptyArgs);
		 long length;
		 long slot = 0;
		 if (ScriptRuntime.instanceOf(thisObj, ctor, cx)) {
			 length = getLengthProperty(cx, thisObj);
			 for (slot = 0;
			 slot < length;
			 slot++) {
				 Object temp = getElem(cx, thisObj, slot);
				 setElem(cx, result, slot, temp);
			 }
		 }
		 else {
			 setElem(cx, result, slot++, thisObj);
		 }
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (ScriptRuntime.instanceOf(args[i], ctor, cx)) {
				 Scriptable arg = (Scriptable)args[i];
				 length = getLengthProperty(cx, arg);
				 for (long j = 0;
				 j < length;
				 j++, slot++) {
					 Object temp = getElem(cx, arg, j);
					 setElem(cx, result, slot, temp);
				 }
			 }
			 else {
				 setElem(cx, result, slot++, args[i]);
			 }
		 }
		 return result;
	 }
	 private Scriptable js_slice(Context cx, Scriptable thisObj, Object[] args) {
		 Scriptable scope = getTopLevelScope(this);
		 Scriptable result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 long length = getLengthProperty(cx, thisObj);
		 long begin, end;
		 if (args.length == 0) {
			 begin = 0;
			 end = length;
		 }
		 else {
			 begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
			 if (args.length == 1) {
				 end = length;
			 }
			 else {
				 end = toSliceIndex(ScriptRuntime.toInteger(args[1]), length);
			 }
		 }
		 for (long slot = begin;
		 slot < end;
		 slot++) {
			 Object temp = getElem(cx, thisObj, slot);
			 setElem(cx, result, slot - begin, temp);
		 }
		 return result;
	 }
	 private static long toSliceIndex(double value, long length) {
		 long result;
		 if (value < 0.0) {
			 if (value + length < 0.0) {
				 result = 0;
			 }
			 else {
				 result = (long)(value + length);
			 }
		 }
		 else if (value > length) {
			 result = length;
		 }
		 else {
			 result = (long)value;
		 }
		 return result;
	 }
	 private Object indexOfHelper(Context cx, Scriptable thisObj, Object[] args, boolean isLast) {
		 Object compareTo = args.length > 0 ? args[0] : Undefined.instance;
		 long length = getLengthProperty(cx, thisObj);
		 long start = args.length > 1 ? ScriptRuntime.toInt32(ScriptRuntime.toNumber(args[1])) : (isLast ? length : 0);
		 if (start < 0) {
			 start += length;
			 if (start < 0) start = 0;
		 }
		 if (isLast) {
			 for (long i=start;
			 i >= 0 ;
			 i--) {
				 if (ScriptRuntime.shallowEq(getElem(cx, thisObj, i), compareTo)) {
					 return new Long(i);
				 }
			 }
		 }
		 else {
			 for (long i=start;
			 i < length;
			 i++) {
				 if (ScriptRuntime.shallowEq(getElem(cx, thisObj, i), compareTo)) {
					 return new Long(i);
				 }
			 }
		 }
		 return NEGATIVE_ONE;
	 }
	 private Object iterativeMethod(Context cx, int id, Scriptable scope, Scriptable thisObj, Object[] args) {
		 Object callbackArg = args.length > 0 ? args[0] : Undefined.instance;
		 if (callbackArg == null || !(callbackArg instanceof Function)) {
			 throw ScriptRuntime.notFunctionError( ScriptRuntime.toString(callbackArg));
		 }
		 Function f = (Function) callbackArg;
		 Scriptable parent = ScriptableObject.getTopLevelScope(f);
		 Scriptable thisArg = args.length > 1 && args[1] instanceof Scriptable ? (Scriptable) args[1] : parent;
		 long length = getLengthProperty(cx, thisObj);
		 Scriptable array = null;
		 if (id == Id_filter) {
			 array = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 }
		 else if (id == Id_map) {
			 Object[] ctorArgs = {
			 new Long(length) }
			;
			 array = ScriptRuntime.newObject(cx, scope, ""Array"", ctorArgs);
		 }
		 Object[] innerArgs = new Object[3];
		 long j=0;
		 for (long i=0;
		 i < length;
		 i++) {
			 innerArgs[0] = getElem(cx, thisObj, i);
			 innerArgs[1] = new Long(i);
			 innerArgs[2] = thisObj;
			 Object result = f.call(cx, parent, thisArg, innerArgs);
			 switch (id) {
				 case Id_every: if (!ScriptRuntime.toBoolean(result)) return Boolean.FALSE;
				 break;
				 case Id_filter: if (ScriptRuntime.toBoolean(result)) setElem(cx, array, j++, innerArgs[0]);
				 break;
				 case Id_forEach: break;
				 case Id_map: setElem(cx, array, j++, result);
				 break;
				 case Id_some: if (ScriptRuntime.toBoolean(result)) return Boolean.TRUE;
				 break;
			 }
		 }
		 switch (id) {
			 case Id_every: return Boolean.TRUE;
			 case Id_filter: case Id_map: return array;
			 case Id_some: return Boolean.FALSE;
			 case Id_forEach: default: return Undefined.instance;
		 }
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 3: c=s.charAt(0);
				 if (c=='m') {
					 if (s.charAt(2)=='p' && s.charAt(1)=='a') {
						id=Id_map;
						 break L0;
					}
				 }
				 else if (c=='p') {
					 if (s.charAt(2)=='p' && s.charAt(1)=='o') {
						id=Id_pop;
						 break L0;
					}
				 }
				 break L;
				 case 4: switch (s.charAt(2)) {
					 case 'i': X=""join"";
					id=Id_join;
					 break L;
					 case 'm': X=""some"";
					id=Id_some;
					 break L;
					 case 'r': X=""sort"";
					id=Id_sort;
					 break L;
					 case 's': X=""push"";
					id=Id_push;
					 break L;
				 }
				 break L;
				 case 5: c=s.charAt(1);
				 if (c=='h') {
					 X=""shift"";
					id=Id_shift;
				 }
				 else if (c=='l') {
					 X=""slice"";
					id=Id_slice;
				 }
				 else if (c=='v') {
					 X=""every"";
					id=Id_every;
				 }
				 break L;
				 case 6: c=s.charAt(0);
				 if (c=='c') {
					 X=""concat"";
					id=Id_concat;
				 }
				 else if (c=='f') {
					 X=""filter"";
					id=Id_filter;
				 }
				 else if (c=='s') {
					 X=""splice"";
					id=Id_splice;
				 }
				 break L;
				 case 7: switch (s.charAt(0)) {
					 case 'f': X=""forEach"";
					id=Id_forEach;
					 break L;
					 case 'i': X=""indexOf"";
					id=Id_indexOf;
					 break L;
					 case 'r': X=""reverse"";
					id=Id_reverse;
					 break L;
					 case 'u': X=""unshift"";
					id=Id_unshift;
					 break L;
				 }
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
				 case 11: c=s.charAt(0);
				 if (c=='c') {
					 X=""constructor"";
					id=Id_constructor;
				 }
				 else if (c=='l') {
					 X=""lastIndexOf"";
					id=Id_lastIndexOf;
				 }
				 break L;
				 case 14: X=""toLocaleString"";
				id=Id_toLocaleString;
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toLocaleString = 3, Id_toSource = 4, Id_join = 5, Id_reverse = 6, Id_sort = 7, Id_push = 8, Id_pop = 9, Id_shift = 10, Id_unshift = 11, Id_splice = 12, Id_concat = 13, Id_slice = 14, Id_indexOf = 15, Id_lastIndexOf = 16, Id_every = 17, Id_filter = 18, Id_forEach = 19, Id_map = 20, Id_some = 21, MAX_PROTOTYPE_ID = 21;
	 private long length;
	 private Object[] dense;
	 private static final int maximumDenseLength = 10000;
}",1,0,0,0
"void build(String namespace, String name, String nameAlias, XSLTElementDef[] elements, XSLTAttributeDef[] attributes, XSLTElementProcessor contentHandler, Class classObject);",0,0,0,1
"public class InteractionsPaneOptions extends Options {
	 private volatile boolean _enforceAllAccess = false;
	 public boolean enforceAllAccess() {
		 return _enforceAllAccess;
	 }
	 public void setEnforceAllAccess(boolean enforce) {
		 _enforceAllAccess = enforce;
	 }
	 private volatile boolean _enforcePrivateAccess = false;
	 public boolean enforcePrivateAccess() {
		 return _enforcePrivateAccess;
	 }
	 public void setEnforcePrivateAccess(boolean enforce) {
		 _enforcePrivateAccess = enforce;
	 }
	 private volatile boolean _requireSemicolon = false;
	 public boolean requireSemicolon() {
		 return _requireSemicolon;
	 }
	 public void setRequireSemicolon(boolean require) {
		 _requireSemicolon = require;
	 }
	 private volatile boolean _requireVariableType = false;
	 public boolean requireVariableType() {
		 return _requireVariableType;
	 }
	 public void setRequireVariableType(boolean require) {
		 _requireVariableType = require;
	 }
}",0,1,0,0
"public class NoOpJavascriptCompressor implements IJavascriptCompressor{
	public String compress(String original){
		return original;
	}
}",0,0,0,0
"static class CompositeConversionService implements ConversionService {
	private final List<ConversionService> delegates;
	CompositeConversionService(List<ConversionService> delegates) {
		this.delegates = delegates;
	}
	public boolean canConvert(Class<?> sourceType, Class<?> targetType) {
		Assert.notNull(targetType, ""Target type to convert to cannot be null"");
		return canConvert((sourceType != null) ? TypeDescriptor.valueOf(sourceType) : null,TypeDescriptor.valueOf(targetType));
	}
	public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {
		for (ConversionService service : this.delegates) {
			if (service.canConvert(sourceType, targetType)) {
				return true;
			}
		}
		return false;
	}
	public <T> T convert(Object source, Class<T> targetType) {
		Assert.notNull(targetType, ""Target type to convert to cannot be null"");
		return (T) convert(source, TypeDescriptor.forObject(source),TypeDescriptor.valueOf(targetType));
	}
	public Object convert(Object source, TypeDescriptor sourceType,TypeDescriptor targetType) {
		for (int i = 0;
		 i < this.delegates.size() - 1;
		 i++) {
			try {
				ConversionService delegate = this.delegates.get(i);
				if (delegate.canConvert(sourceType, targetType)) {
					return delegate.convert(source, sourceType, targetType);
				}
			}
			catch (ConversionException ex) {
			}
		}
		return this.delegates.get(this.delegates.size() - 1).convert(source,sourceType, targetType);
	}
}",0,0,0,0
"final class ColumnFamilyRecordWriter extends RecordWriter<ByteBuffer,List<Mutation>>implements org.apache.hadoop.mapred.RecordWriter<ByteBuffer,List<Mutation>>{
	 private final Configuration conf;
	 private final RingCache ringCache;
	 private final int queueSize;
	 private final Map<Range,RangeClient> clients;
	 private final long batchThreshold;
	 private final ConsistencyLevel consistencyLevel;
	 private Progressable progressable;
	 ColumnFamilyRecordWriter(TaskAttemptContext context) throws IOException {
		 this(context.getConfiguration());
		 this.progressable = new Progressable(context);
	 }
	 ColumnFamilyRecordWriter(Configuration conf, Progressable progressable) throws IOException {
		 this(conf);
		 this.progressable = progressable;
	 }
	 ColumnFamilyRecordWriter(Configuration conf) throws IOException {
		 this.conf = conf;
		 this.ringCache = new RingCache(conf);
		 this.queueSize = conf.getInt(ColumnFamilyOutputFormat.QUEUE_SIZE, 32 * Runtime.getRuntime().availableProcessors());
		 this.clients = new HashMap<Range,RangeClient>();
		 batchThreshold = conf.getLong(ColumnFamilyOutputFormat.BATCH_THRESHOLD, 32);
		 consistencyLevel = ConsistencyLevel.valueOf(ConfigHelper.getWriteConsistencyLevel(conf));
	 }
	 public void write(ByteBuffer keybuff, List<Mutation> value) throws IOException {
		 Range<Token> range = ringCache.getRange(keybuff);
		 RangeClient client = clients.get(range);
		 if (client == null) {
			 client = new RangeClient(ringCache.getEndpoint(range));
			 client.start();
			 clients.put(range, client);
		 }
		 for (Mutation amut : value) client.put(new Pair<ByteBuffer,Mutation>(keybuff, amut));
		 progressable.progress();
	 }
	 public void close(TaskAttemptContext context) throws IOException, InterruptedException {
		 close();
	 }
	 public void close(org.apache.hadoop.mapred.Reporter reporter) throws IOException {
		 close();
	 }
	 private void close() throws IOException {
		 IOException clientException = null;
		 for (RangeClient client : clients.values()) {
			 try {
				 client.close();
			 }
			 catch (IOException e) {
				 clientException = e;
			 }
		 }
		 if (clientException != null) throw clientException;
	 }
	 public class RangeClient extends Thread {
		 private final List<InetAddress> endpoints;
		 private final String columnFamily = ConfigHelper.getOutputColumnFamily(conf);
		 private final BlockingQueue<Pair<ByteBuffer, Mutation>> queue = new ArrayBlockingQueue<Pair<ByteBuffer,Mutation>>(queueSize);
		 private volatile boolean run = true;
		 private volatile IOException lastException;
		 private Cassandra.Client thriftClient;
		 private TSocket thriftSocket;
		 public RangeClient(List<InetAddress> endpoints) {
			 super(""client-"" + endpoints);
			 this.endpoints = endpoints;
		 }
		 public void put(Pair<ByteBuffer,Mutation> value) throws IOException {
			 while (true) {
				 if (lastException != null) throw lastException;
				 try {
					 if (queue.offer(value, 100, TimeUnit.MILLISECONDS)) break;
				 }
				 catch (InterruptedException e) {
					 throw new AssertionError(e);
				 }
			 }
		 }
		 public void close() throws IOException {
			 run = false;
			 interrupt();
			 try {
				 this.join();
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
			 if (lastException != null) throw lastException;
		 }
		 private void closeInternal() {
			 if (thriftSocket != null) {
				 thriftSocket.close();
				 thriftSocket = null;
				 thriftClient = null;
			 }
		 }
		 public void run() {
			 outer: while (run || !queue.isEmpty()) {
				 Pair<ByteBuffer, Mutation> mutation;
				 try {
					 mutation = queue.take();
				 }
				 catch (InterruptedException e) {
					 continue;
				 }
				 Map<ByteBuffer, Map<String, List<Mutation>>> batch = new HashMap<ByteBuffer, Map<String, List<Mutation>>>();
				 while (mutation != null) {
					 Map<String, List<Mutation>> subBatch = batch.get(mutation.left);
					 if (subBatch == null) {
						 subBatch = Collections.singletonMap(columnFamily, (List<Mutation>) new ArrayList<Mutation>());
						 batch.put(mutation.left, subBatch);
					 }
					 subBatch.get(columnFamily).add(mutation.right);
					 if (batch.size() >= batchThreshold) break;
					 mutation = queue.poll();
				 }
				 Iterator<InetAddress> iter = endpoints.iterator();
				 while (true) {
					 try {
						 thriftClient.batch_mutate(batch, consistencyLevel);
						 break;
					 }
					 catch (Exception e) {
						 closeInternal();
						 if (!iter.hasNext()) {
							 lastException = new IOException(e);
							 break outer;
						 }
					 }
					 try {
						 InetAddress address = iter.next();
						 thriftSocket = new TSocket(address.getHostName(), ConfigHelper.getOutputRpcPort(conf));
						 thriftClient = ColumnFamilyOutputFormat.createAuthenticatedClient(thriftSocket, conf);
					 }
					 catch (Exception e) {
						 closeInternal();
						 if ((!(e instanceof TException)) || !iter.hasNext()) {
							 lastException = new IOException(e);
							 break outer;
						 }
					 }
				 }
			 }
		 }
		 public String toString() {
			 return ""#<Client for "" + endpoints.toString() + "">"";
		 }
	 }
}",0,0,0,0
public String getKeywords();,0,0,0,0
"public class RowDigestResolver extends AbstractRowResolver{
	 public RowDigestResolver(String table, ByteBuffer key) {
		 super(key, table);
	 }
	 public Row getData() throws IOException {
		 for (Map.Entry<Message, ReadResponse> entry : replies.entrySet()) {
			 ReadResponse result = entry.getValue();
			 if (!result.isDigestQuery()) return result.row();
		 }
		 throw new AssertionError(""getData should not be invoked when no data is present"");
	 }
	 public Row resolve() throws DigestMismatchException, IOException {
		 if (logger.isDebugEnabled()) logger.debug(""resolving "" + replies.size() + "" responses"");
		 long startTime = System.currentTimeMillis();
		ColumnFamily data = null;
		 ByteBuffer digest = null;
		 for (Map.Entry<Message, ReadResponse> entry : replies.entrySet()) {
			 ReadResponse response = entry.getValue();
			 if (response.isDigestQuery()) {
				 if (digest == null) {
					 digest = response.digest();
				 }
				 else {
					 ByteBuffer digest2 = response.digest();
					 if (!digest.equals(digest2)) throw new DigestMismatchException(key, digest, digest2);
				 }
			 }
			 else {
				 data = response.row().cf;
			 }
		 }
		 if (digest != null) {
			 ByteBuffer digest2 = ColumnFamily.digest(data);
			 if (!digest.equals(digest2)) throw new DigestMismatchException(key, digest, digest2);
			 if (logger.isDebugEnabled()) logger.debug(""digests verified"");
		 }
		 if (logger.isDebugEnabled()) logger.debug(""resolve: "" + (System.currentTimeMillis() - startTime) + "" ms."");
		return new Row(key, data);
	}
	 public boolean isDataPresent(){
		 for (ReadResponse result : replies.values()) {
			 if (!result.isDigestQuery()) return true;
		 }
		 return false;
	 }
}",0,0,0,0
"protected static final class PersistenceWithIntOffset extends PersistenceWithIntOffsetNoLL {
	 private DiskEntry prev;
	 private DiskEntry next;
	 public DiskEntry getPrev() {
		 return this.prev;
	 }
	 public DiskEntry getNext() {
		 return this.next;
	 }
	 public void setPrev(DiskEntry v) {
		 this.prev = v;
	 }
	 public void setNext(DiskEntry v) {
		 this.next = v;
	 }
 }",0,1,0,0
"private static List<RawKeyspace> readTablesFromXml(XMLUtils xmlUtils) throws ConfigurationException {
	 List<RawKeyspace> keyspaces = new ArrayList<RawKeyspace>();
	 try {
		 String endPointSnitchClassName = null;
		 NodeList tablesxml = xmlUtils.getRequestedNodeList(""/Storage/Keyspaces/Keyspace"");
		 String gcGrace = xmlUtils.getNodeValue(""/Storage/GCGraceSeconds"");
		 int gc_grace_seconds = CFMetaData.DEFAULT_GC_GRACE_SECONDS;
		 if ( gcGrace != null ) gc_grace_seconds = Integer.parseInt(gcGrace);
		 String lifetime = xmlUtils.getNodeValue(""/Storage/MemtableFlushAfterMinutes"");
		 int memtime = CFMetaData.DEFAULT_MEMTABLE_LIFETIME_IN_MINS;
		 if (lifetime != null) memtime = Integer.parseInt(lifetime);
		 String memtableSize = xmlUtils.getNodeValue(""/Storage/MemtableThroughputInMB"");
		 int memsize = CFMetaData.DEFAULT_MEMTABLE_THROUGHPUT_IN_MB;
		 if (memtableSize != null) memsize = Integer.parseInt(memtableSize);
		 String memtableOps = xmlUtils.getNodeValue(""/Storage/MemtableOperationsInMillions"");
		 double memops = CFMetaData.DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS;
		 if (memtableOps != null) memops = Double.parseDouble(memtableOps);
		 int size = tablesxml.getLength();
		 for ( int i = 0;
		 i < size;
		 ++i ) {
			 String value;
			 RawKeyspace ks = new RawKeyspace();
			 Node table = tablesxml.item(i);
			 ks.name = XMLUtils.getAttributeValue(table, ""Name"");
			 value = xmlUtils.getNodeValue(""/Storage/Keyspaces/Keyspace[='"" + ks.name + ""']/EndPointSnitch"");
			 if (endPointSnitchClassName == null) {
				 endPointSnitchClassName = value;
			 }
			 else if (!endPointSnitchClassName.equals(value)) {
				 throw new ConfigurationException(""ERROR : EndPointSnitch is global in 0.7 -- multiple choices present."");
			 }
			 ks.replica_placement_strategy = xmlUtils.getNodeValue(""/Storage/Keyspaces/Keyspace[='"" + ks.name + ""']/ReplicaPlacementStrategy"");
			 value = xmlUtils.getNodeValue(""/Storage/Keyspaces/Keyspace[='"" + ks.name + ""']/ReplicationFactor"");
			 if (value != null) {
				 ks.replication_factor = Integer.parseInt(value);
			 }
			 String xqlTable = ""/Storage/Keyspaces/Keyspace[='"" + ks.name + ""']/"";
			 NodeList columnFamilies = xmlUtils.getRequestedNodeList(xqlTable + ""ColumnFamily"");
			 int size2 = columnFamilies.getLength();
			 ks.column_families = new RawColumnFamily[size2];
			 for ( int j = 0;
			 j < size2;
			 ++j ) {
				 Node columnFamily = columnFamilies.item(j);
				 ks.column_families[j] = new RawColumnFamily();
				 ks.column_families[j].name = XMLUtils.getAttributeValue(columnFamily, ""Name"");
				 String xqlCF = xqlTable + ""ColumnFamily[='"" + ks.column_families[j].name + ""']/"";
				 ks.column_families[j].column_type = ColumnFamilyType.create(XMLUtils.getAttributeValue(columnFamily, ""ColumnType""));
				 ks.column_families[j].compare_with = XMLUtils.getAttributeValue(columnFamily, ""CompareWith"");
				 if (ks.column_families[j].column_type != null && ks.column_families[j].column_type == ColumnFamilyType.Super) ks.column_families[j].compare_subcolumns_with = XMLUtils.getAttributeValue(columnFamily, ""CompareSubcolumnsWith"");
				 if ((value = XMLUtils.getAttributeValue(columnFamily, ""KeysCached"")) != null) {
					 ks.column_families[j].keys_cached = FBUtilities.parseDoubleOrPercent(value);
				 }
				 if ((value = XMLUtils.getAttributeValue(columnFamily, ""RowsCached"")) != null) {
					 ks.column_families[j].rows_cached = FBUtilities.parseDoubleOrPercent(value);
				 }
				 if ((value = XMLUtils.getAttributeValue(columnFamily, ""RowCacheSavePeriodInSeconds"")) != null) {
					 ks.column_families[j].row_cache_save_period_in_seconds = Integer.parseInt(value);
				 }
				 if ((value = XMLUtils.getAttributeValue(columnFamily, ""KeyCacheSavePeriodInSeconds"")) != null) {
					 ks.column_families[j].key_cache_save_period_in_seconds = Integer.parseInt(value);
				 }
				 if ((value = XMLUtils.getAttributeValue(columnFamily, ""ReadRepairChance"")) != null) {
					 ks.column_families[j].read_repair_chance = FBUtilities.parseDoubleOrPercent(value);
				 }
				 ks.column_families[j].gc_grace_seconds = gc_grace_seconds;
				 ks.column_families[j].memtable_flush_after_mins = memtime;
				 ks.column_families[j].memtable_throughput_in_mb = memsize;
				 ks.column_families[j].memtable_operations_in_millions = memops;
				 ks.column_families[j].comment = xmlUtils.getNodeValue(xqlCF + ""Comment"");
			 }
			 keyspaces.add(ks);
		 }
		 if (endPointSnitchClassName.equals(""org.apache.cassandra.locator.EndPointSnitch"")) {
			 endPointSnitchClassName = ""org.apache.cassandra.locator.RackInferringSnitch"";
			 System.out.println(""WARN : org.apache.cassandra.locator.EndPointSnitch has been replaced by org.apache.cassandra.locator.RackInferringSnitch"");
		 }
		 else if (endPointSnitchClassName.equals(""org.apache.cassandra.locator.PropertyFileEndpointSnitch"")) {
			 endPointSnitchClassName = ""org.apache.cassandra.locator.PropertyFileSnitch"";
			 System.out.println(""WARN : org.apache.cassandra.locator.PropertyFileEndpointSnich has been replaced by org.apache.cassandra.locator.PropertyFileSnitch"");
		 }
		 else {
			 System.out.println(""INFO : EndPointSnitch is global in 0.7 and may need to be updated."");
		 }
		 conf.endpoint_snitch = endPointSnitchClassName;
		 return keyspaces;
	 }
	 catch (XPathExpressionException e) {
		 throw new ConfigurationException(""XPath expression error."");
	 }
	 catch (TransformerException e) {
		 throw new ConfigurationException(""Error occurred during the transformation process."");
	 }
 }",0,0,1,0
"private static final class EncryptionData {
	 final Cipher cipher;
	 final ICompressor compressor;
	 final ImmutableMap<String, Object> params;
	 private EncryptionData(Cipher cipher, ICompressor compressor, ImmutableMap<String, Object> params) {
		 this.cipher = cipher;
		 this.compressor = compressor;
		 this.params = params;
	 }
 }",0,0,0,0
"public class JEditTextArea extends JComponent{
	public JEditTextArea(View view){
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);
		this.view = view;
		selectionManager = new SelectionManager(this);
		chunkCache = new ChunkCache(this);
		painter = new TextAreaPainter(this);
		repaintMgr = new FastRepaintManager(this,painter);
		gutter = new Gutter(view,this);
		listenerList = new EventListenerList();
		caretEvent = new MutableCaretEvent();
		blink = true;
		lineSegment = new Segment();
		returnValue = new Point();
		structureMatchers = new LinkedList();
		structureMatchers.add(new StructureMatcher.BracketMatcher());
		setLayout(new ScrollLayout());
		add(ScrollLayout.CENTER,painter);
		add(ScrollLayout.LEFT,gutter);
		verticalBox = new Box(BoxLayout.X_AXIS);
		verticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));
		vertical.setRequestFocusEnabled(false);
		add(ScrollLayout.RIGHT,verticalBox);
		add(ScrollLayout.BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));
		horizontal.setRequestFocusEnabled(false);
		horizontal.setValues(0,0,0,0);
		if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel){
			setBorder(new TextAreaBorder());
			vertical.putClientProperty(""JScrollBar.isFreeStanding"",Boolean.FALSE);
			horizontal.putClientProperty(""JScrollBar.isFreeStanding"",Boolean.FALSE);
		}
		vertical.addAdjustmentListener(new AdjustHandler());
		horizontal.addAdjustmentListener(new AdjustHandler());
		mouseHandler = new MouseHandler(this);
		painter.addMouseListener(mouseHandler);
		painter.addMouseMotionListener(mouseHandler);
		addFocusListener(new FocusHandler());
		addMouseWheelListener(new MouseWheelHandler());
		setTransferHandler(new TextAreaTransferHandler());
		try{
			getDropTarget().addDropTargetListener(new TextAreaDropHandler(this));
		}
		catch(TooManyListenersException e){
			Log.log(Log.ERROR,this,e);
		}
		 focusedComponent = this;
		popupEnabled = true;
	}
	 public void dispose(){
		DisplayManager.textAreaDisposed(this);
	}
	 public View getView(){
		return view;
	}
	 public InputHandler getInputHandler(){
		return view.getInputHandler();
	}
	 public final TextAreaPainter getPainter(){
		return painter;
	}
	 public final Gutter getGutter(){
		return gutter;
	}
	 public DisplayManager getDisplayManager(){
		return displayManager;
	}
	 public final boolean isCaretBlinkEnabled(){
		return caretBlinks;
	}
	 public void setCaretBlinkEnabled(boolean caretBlinks){
		this.caretBlinks = caretBlinks;
		if(!caretBlinks)blink = false;
		if(buffer != null)invalidateLine(caretLine);
	}
	 public final int getElectricScroll(){
		return electricScroll;
	}
	 public final void setElectricScroll(int electricScroll){
		this.electricScroll = electricScroll;
	}
	 public final boolean isQuickCopyEnabled(){
		return quickCopy;
	}
	 public final void setQuickCopyEnabled(boolean quickCopy){
		this.quickCopy = quickCopy;
	}
	 public final JEditBuffer getBuffer(){
		return buffer;
	}
	 public void setBuffer(JEditBuffer buffer){
		if(this.buffer == buffer)return;
		try{
			bufferChanging = true;
			if(this.buffer != null){
				if(!buffer.isLoading())selectNone();
				caretLine = caret = caretScreenLine = 0;
				match = null;
			}
			this.buffer = buffer;
			chunkCache.setBuffer(buffer);
			repaintMgr.setFastScroll(false);
			propertiesChanged();
			if(displayManager != null){
				DisplayManager.releaseDisplayManager(displayManager);
			}
			displayManager = DisplayManager.getDisplayManager(buffer,this);
			displayManager.init();
			if(buffer.isLoading())updateScrollBar();
			repaint();
			fireScrollEvent(true);
		}
		finally{
			bufferChanging = false;
		}
	}
	 public final boolean isEditable(){
		return buffer.isEditable();
	}
	 public boolean isDragInProgress(){
		return dndInProgress;
	}
	 public void setDragInProgress(boolean dndInProgress){
		this.dndInProgress = dndInProgress;
	}
	 public boolean isDragEnabled(){
		return dndEnabled;
	}
	 public void setDragEnabled(boolean dndEnabled){
		this.dndEnabled = dndEnabled;
	}
	 public boolean getJoinNonWordChars(){
		return joinNonWordChars;
	}
	 public void setJoinNonWordChars(boolean joinNonWordChars){
		this.joinNonWordChars = joinNonWordChars;
	}
	 public final int getFirstLine(){
		return displayManager.firstLine.scrollLine+ displayManager.firstLine.skew;
	}
	 public void setFirstLine(int firstLine){
		int max = displayManager.getScrollLineCount() - visibleLines+ (lastLinePartial ? 1 : 0);
		if(firstLine > max)firstLine = max;
		if(firstLine < 0)firstLine = 0;
		if(Debug.SCROLL_DEBUG){
			Log.log(Log.DEBUG,this,""setFirstLine() from ""+ getFirstLine() + "" to "" + firstLine);
		}
		int oldFirstLine = getFirstLine();
		if(firstLine == oldFirstLine)return;
		displayManager.setFirstLine(oldFirstLine,firstLine);
		repaint();
		fireScrollEvent(true);
	}
	 public final int getFirstPhysicalLine(){
		return displayManager.firstLine.physicalLine;
	}
	 public void setFirstPhysicalLine(int physFirstLine){
		setFirstPhysicalLine(physFirstLine,0);
	}
	 public void setFirstPhysicalLine(int physFirstLine, int skew){
		if(Debug.SCROLL_DEBUG){
			Log.log(Log.DEBUG,this,""setFirstPhysicalLine(""+ physFirstLine + "","" + skew + "")"");
		}
		int amount = (physFirstLine - displayManager.firstLine.physicalLine);
		displayManager.setFirstPhysicalLine(amount,skew);
		repaint();
		fireScrollEvent(true);
	}
	 public final int getLastPhysicalLine(){
		return physLastLine;
	}
	 public int getLastScreenLine(){
		return screenLastLine;
	}
	 public final int getVisibleLines(){
		return visibleLines;
	}
	 public final int getHorizontalOffset(){
		return horizontalOffset;
	}
	 public void setHorizontalOffset(int horizontalOffset){
		if(horizontalOffset > 0)horizontalOffset = 0;
		if(horizontalOffset == this.horizontalOffset)return;
		this.horizontalOffset = horizontalOffset;
		painter.repaint();
		fireScrollEvent(false);
	}
	 public void scrollUpLine(){
		setFirstLine(getFirstLine() - 1);
	}
	 public void scrollUpPage(){
		setFirstLine(getFirstLine() - getVisibleLines()+ (lastLinePartial ? 1 : 0));
	}
	 public void scrollDownLine(){
		setFirstLine(getFirstLine() + 1);
	}
	 public void scrollDownPage(){
		setFirstLine(getFirstLine() + getVisibleLines()- (lastLinePartial ? 1 : 0));
	}
	 public void scrollToCaret(boolean doElectricScroll){
		scrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),doElectricScroll);
	}
	 public void scrollTo(int offset, boolean doElectricScroll){
		int line = buffer.getLineOfOffset(offset);
		scrollTo(line,offset - buffer.getLineStartOffset(line),doElectricScroll);
	}
	 public void scrollTo(int line, int offset, boolean doElectricScroll){
		if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,""scrollTo(), lineCount=""+ getLineCount());
		int extraEndVirt;
		int lineLength = buffer.getLineLength(line);
		if(offset > lineLength){
			extraEndVirt = charWidth * (offset - lineLength);
			offset = lineLength;
		}
		elseextraEndVirt = 0;
		int _electricScroll = (doElectricScroll&& visibleLines - 1 > electricScroll * 2? electricScroll : 0);
		 if(visibleLines <= 1){
			if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,""visibleLines <= 0"");
			setFirstPhysicalLine(line,_electricScroll);
			return;
		}
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		int visibleLines = getVisibleLines();
		if(screenLine == -1){
			if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,""screenLine == -1"");
			ChunkCache.LineInfo[] infos = chunkCache.getLineInfosForPhysicalLine(line);
			int subregion = chunkCache.getSubregionOfOffset(offset,infos);
			int prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());
			int nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());
			if(line == getFirstPhysicalLine()){
				if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,line + "" == "" + getFirstPhysicalLine());
				setFirstPhysicalLine(line,subregion- _electricScroll);
			}
			else if(line == prevLine){
				if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,line + "" == "" + prevLine);
				setFirstPhysicalLine(prevLine,subregion- _electricScroll);
			}
			else if(line == getLastPhysicalLine()){
				if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,line + "" == "" + getLastPhysicalLine());
				setFirstPhysicalLine(line,subregion + _electricScroll- visibleLines+ (lastLinePartial ? 2 : 1));
			}
			else if(line == nextLine){
				if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,line + "" == "" + nextLine);
				setFirstPhysicalLine(nextLine,subregion + electricScroll- visibleLines+ (lastLinePartial ? 2 : 1));
			}
			else{
				if(Debug.SCROLL_TO_DEBUG){
					Log.log(Log.DEBUG,this,""neither"");
					Log.log(Log.DEBUG,this,""Last physical line is "" + getLastPhysicalLine());
				}
				setFirstPhysicalLine(line,subregion- visibleLines / 2);
				if(Debug.SCROLL_TO_DEBUG){
					Log.log(Log.DEBUG,this,""Last physical line is "" + getLastPhysicalLine());
				}
			}
		}
		else if(screenLine < _electricScroll){
			if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,""electric up"");
			setFirstLine(getFirstLine() - _electricScroll + screenLine);
		}
		else if(screenLine > visibleLines - _electricScroll- (lastLinePartial ? 2 : 1)){
			if(Debug.SCROLL_TO_DEBUG)Log.log(Log.DEBUG,this,""electric down"");
			setFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));
		}
		 if(!displayManager.isLineVisible(line))return;
		Point point = offsetToXY(line,offset,returnValue);
		if(point == null){
			Log.log(Log.ERROR,this,""BUG: screenLine="" + screenLine+ "",visibleLines="" + visibleLines+ "",physicalLine="" + line+ "",firstPhysicalLine="" + getFirstPhysicalLine()+ "",lastPhysicalLine="" + getLastPhysicalLine());
		}
		point.x += extraEndVirt;
		if(point.x < 0){
			setHorizontalOffset(horizontalOffset- point.x + charWidth + 5);
		}
		else if(point.x >= painter.getWidth() - charWidth - 5){
			setHorizontalOffset(horizontalOffset +(painter.getWidth() - point.x)- charWidth - 5);
		}
	 }
	 public final void addScrollListener(ScrollListener listener){
		listenerList.add(ScrollListener.class,listener);
	}
	 public final void removeScrollListener(ScrollListener listener){
		listenerList.remove(ScrollListener.class,listener);
	}
	 public int getPhysicalLineOfScreenLine(int screenLine){
		return chunkCache.getLineInfo(screenLine).physicalLine;
	}
	 public int getScreenLineOfOffset(int offset){
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		return chunkCache.getScreenLineOfOffset(line,offset);
	}
	 public int getScreenLineStartOffset(int line){
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)return -1;
		return buffer.getLineStartOffset(lineInfo.physicalLine)+ lineInfo.offset;
	}
	 public int getScreenLineEndOffset(int line){
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)return -1;
		return buffer.getLineStartOffset(lineInfo.physicalLine)+ lineInfo.offset + lineInfo.length;
	}
	 public int xyToOffset(int x, int y){
		return xyToOffset(x,y,true);
	}
	 public int xyToOffset(int x, int y, boolean round){
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		int line = y / height;
		if(line < 0 || line >= visibleLines)return -1;
		return xToScreenLineOffset(line,x,round);
	}
	 public int xToScreenLineOffset(int screenLine, int x, boolean round){
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);
		if(lineInfo.physicalLine == -1){
			return getLineEndOffset(displayManager.getLastVisibleLine()) - 1;
		}
		else{
			int offset = Chunk.xToOffset(lineInfo.chunks,x - horizontalOffset,round);
			if(offset == -1 || offset == lineInfo.offset + lineInfo.length)offset = lineInfo.offset + lineInfo.length - 1;
			return getLineStartOffset(lineInfo.physicalLine) + offset;
		}
	}
	 public Point offsetToXY(int offset){
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		Point retVal = new Point();
		return offsetToXY(line,offset,retVal);
	}
	 public Point offsetToXY(int line, int offset){
		return offsetToXY(line,offset,new Point());
	}
	 public Point offsetToXY(int line, int offset, Point retVal){
		if(!displayManager.isLineVisible(line))return null;
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		if(screenLine == -1)return null;
		FontMetrics fm = painter.getFontMetrics();
		retVal.y = screenLine * fm.getHeight();
		ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);
		retVal.x = (int)(horizontalOffset + Chunk.offsetToX(info.chunks,offset));
		return retVal;
	}
	 public void invalidateScreenLineRange(int start, int end){
		if(buffer.isLoading())return;
		if(start > end){
			int tmp = end;
			end = start;
			start = tmp;
		}
		if(chunkCache.needFullRepaint())end = visibleLines;
		FontMetrics fm = painter.getFontMetrics();
		int y = start * fm.getHeight();
		int height = (end - start + 1) * fm.getHeight();
		painter.repaint(0,y,painter.getWidth(),height);
		gutter.repaint(0,y,gutter.getWidth(),height);
	}
	 public void invalidateLine(int line){
		if(!isShowing()|| buffer.isLoading()|| line < getFirstPhysicalLine()|| line > physLastLine|| !displayManager.isLineVisible(line))return;
		int startLine = -1;
		int endLine = -1;
		for(int i = 0;
		 i < visibleLines;
		 i++){
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if((info.physicalLine >= line || info.physicalLine == -1)&& startLine == -1){
				startLine = i;
			}
			if((info.physicalLine >= line && info.lastSubregion)|| info.physicalLine == -1){
				endLine = i;
				break;
			}
		}
		if(chunkCache.needFullRepaint() || endLine == -1)endLine = visibleLines;
		invalidateScreenLineRange(startLine,endLine);
	}
	 public void invalidateLineRange(int start, int end){
		if(!isShowing() || buffer.isLoading())return;
		if(end < start){
			int tmp = end;
			end = start;
			start = tmp;
		}
		if(end < getFirstPhysicalLine() || start > getLastPhysicalLine())return;
		int startScreenLine = -1;
		int endScreenLine = -1;
		for(int i = 0;
		 i < visibleLines;
		 i++){
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if((info.physicalLine >= start || info.physicalLine == -1)&& startScreenLine == -1){
				startScreenLine = i;
			}
			if((info.physicalLine >= end && info.lastSubregion)|| info.physicalLine == -1){
				endScreenLine = i;
				break;
			}
		}
		if(startScreenLine == -1)startScreenLine = 0;
		if(chunkCache.needFullRepaint() || endScreenLine == -1)endScreenLine = visibleLines;
		invalidateScreenLineRange(startScreenLine,endScreenLine);
	}
	 public final int getBufferLength(){
		return buffer.getLength();
	}
	 public final int getLineCount(){
		return buffer.getLineCount();
	}
	 public final int getLineOfOffset(int offset){
		return buffer.getLineOfOffset(offset);
	}
	 public int getLineStartOffset(int line){
		return buffer.getLineStartOffset(line);
	}
	 public int getLineEndOffset(int line){
		return buffer.getLineEndOffset(line);
	}
	 public int getLineLength(int line){
		return buffer.getLineLength(line);
	}
	 public final String getText(int start, int len){
		return buffer.getText(start,len);
	}
	 public final void getText(int start, int len, Segment segment){
		buffer.getText(start,len,segment);
	}
	 public final String getLineText(int lineIndex){
		return buffer.getLineText(lineIndex);
	}
	 public final void getLineText(int lineIndex, Segment segment){
		buffer.getLineText(lineIndex,segment);
	}
	 public String getText(){
		return buffer.getText(0,buffer.getLength());
	}
	 public void setText(String text){
		try{
			buffer.beginCompoundEdit();
			buffer.remove(0,buffer.getLength());
			buffer.insert(0,text);
		}
		finally{
			buffer.endCompoundEdit();
		}
	}
	 public final void selectAll(){
		int firstLine = getFirstLine();
		int horizOffset = getHorizontalOffset();
		setSelection(new Selection.Range(0,buffer.getLength()));
		moveCaretPosition(buffer.getLength(),true);
		setFirstLine(firstLine);
		setHorizontalOffset(horizOffset);
	}
	 public void selectLine(){
		int caretLine = getCaretLine();
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine) - 1;
		Selection s = new Selection.Range(start,end);
		if(multi)addToSelection(s);
		elsesetSelection(s);
		moveCaretPosition(end);
	}
	 public void selectParagraph(){
		int caretLine = getCaretLine();
		if(getLineLength(caretLine) == 0){
			getToolkit().beep();
			return;
		}
		int start = caretLine;
		int end = caretLine;
		while(start >= 0){
			if(getLineLength(start) == 0)break;
			elsestart--;
		}
		while(end < getLineCount()){
			if(getLineLength(end) == 0)break;
			elseend++;
		}
		int selectionStart = getLineStartOffset(start + 1);
		int selectionEnd = getLineEndOffset(end - 1) - 1;
		Selection s = new Selection.Range(selectionStart,selectionEnd);
		if(multi)addToSelection(s);
		elsesetSelection(s);
		moveCaretPosition(selectionEnd);
	}
	 public void selectWord(){
		int line = getCaretLine();
		int lineStart = getLineStartOffset(line);
		int offset = getCaretPosition() - lineStart;
		if(getLineLength(line) == 0)return;
		String lineText = getLineText(line);
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		if(offset == getLineLength(line))offset--;
		int wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);
		int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);
		Selection s = new Selection.Range(lineStart + wordStart,lineStart + wordEnd);
		if(multi)addToSelection(s);
		elsesetSelection(s);
		moveCaretPosition(lineStart + wordEnd);
	}
	 public Selection selectToMatchingBracket(int position,boolean quickCopy){
		int positionLine = buffer.getLineOfOffset(position);
		int lineOffset = position - buffer.getLineStartOffset(positionLine);
		if(getLineLength(positionLine) != 0){
			int bracket = TextUtilities.findMatchingBracket(buffer,positionLine,Math.max(0,lineOffset - 1));
			if(bracket != -1){
				Selection s;
				if(bracket < position){
					if(!quickCopy)moveCaretPosition(position,false);
					s = new Selection.Range(bracket,position);
				}
				else{
					if(!quickCopy)moveCaretPosition(bracket + 1,false);
					s = new Selection.Range(position - 1,bracket + 1);
				}
				if(!multi && !quickCopy)selectNone();
				addToSelection(s);
				return s;
			}
		}
		return null;
	}
	 public void selectToMatchingBracket(){
		selectToMatchingBracket(caret,false);
	}
	 public void selectBlock(){
		String openBrackets = ""([{
			"";
		String closeBrackets = "")]}
		"";
		Selection s = getSelectionAtOffset(caret);
		int start, end;
		if(s == null)start = end = caret;
		else{
			start = s.start;
			end = s.end;
		}
		String text = getText(0,buffer.getLength());
		int count = 1;
		char openBracket = '\0';
		char closeBracket = '\0';
		if(start == 0){
			getToolkit().beep();
			return;
		}
		backward_scan:while(--start > 0){
			char c = text.charAt(start);
			int index = openBrackets.indexOf(c);
			if(index != -1){
				if(--count == 0){
					openBracket = c;
					closeBracket = closeBrackets.charAt(index);
					break backward_scan;
				}
			}
			else if(closeBrackets.indexOf(c) != -1)count++;
		}
		count = 1;
		if(openBracket == '\0'){
			getToolkit().beep();
			return;
		}
		else{
			forward_scan:do{
				char c = text.charAt(end);
				if(c == closeBracket){
					if(--count == 0){
						end++;
						break forward_scan;
					}
				}
				else if(c == openBracket)count++;
			}
			while(++end < buffer.getLength());
		}
		s = new Selection.Range(start,end);
		if(multi)addToSelection(s);
		elsesetSelection(s);
		moveCaretPosition(end);
	}
	 public boolean lineInStructureScope(int line){
		if(match == null)return false;
		if(match.startLine < caretLine)return (line >= match.startLine && line <= caretLine);
		elsereturn (line <= match.endLine && line >= caretLine);
	}
	 public final void invertSelection(){
		selectionManager.invertSelection();
	}
	 public int getSelectionCount(){
		return selectionManager.getSelectionCount();
	}
	 public Selection[] getSelection(){
		return selectionManager.getSelection();
	}
	 public Iterator getSelectionIterator(){
		return selectionManager.selection.iterator();
	}
	 public Selection getSelection(int index){
		return (Selection)selectionManager.selection.get(index);
	}
	 public void selectNone(){
		invalidateSelectedLines();
		setSelection((Selection)null);
	}
	 public void setSelection(Selection[] selection){
		invalidateSelectedLines();
		selectionManager.setSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}
	 public void setSelection(Selection selection){
		invalidateSelectedLines();
		selectionManager.setSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}
	 public void addToSelection(Selection[] selection){
		invalidateSelectedLines();
		selectionManager.addToSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}
	 public void addToSelection(Selection selection){
		invalidateSelectedLines();
		selectionManager.addToSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}
	 public Selection getSelectionAtOffset(int offset){
		return selectionManager.getSelectionAtOffset(offset);
	}
	 public void removeFromSelection(Selection sel){
		invalidateSelectedLines();
		selectionManager.removeFromSelection(sel);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}
	 public void removeFromSelection(int offset){
		Selection sel = getSelectionAtOffset(offset);
		if(sel == null)return;
		invalidateSelectedLines();
		selectionManager.removeFromSelection(sel);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}
	 public void resizeSelection(int offset, int end, int extraEndVirt,boolean rect){
		Selection s = selectionManager.getSelectionAtOffset(offset);
		if(s != null){
			invalidateLineRange(s.startLine,s.endLine);
			selectionManager.removeFromSelection(s);
		}
		selectionManager.resizeSelection(offset,end,extraEndVirt,rect);
		fireCaretEvent();
	}
	 public void extendSelection(int offset, int end){
		extendSelection(offset,end,0,0);
	}
	 public void extendSelection(int offset, int end,int extraStartVirt, int extraEndVirt){
		Selection s = getSelectionAtOffset(offset);
		if(s != null){
			invalidateLineRange(s.startLine,s.endLine);
			selectionManager.removeFromSelection(s);
			if(offset == s.start){
				offset = end;
				end = s.end;
			}
			else if(offset == s.end){
				offset = s.start;
			}
		}
		if(end < offset){
			int tmp = end;
			end = offset;
			offset = tmp;
		}
		if(rectangularSelectionMode){
			s = new Selection.Rect(offset,end);
			((Selection.Rect)s).extraStartVirt = extraStartVirt;
			((Selection.Rect)s).extraEndVirt = extraEndVirt;
		}
		elses = new Selection.Range(offset,end);
		selectionManager.addToSelection(s);
		fireCaretEvent();
		if(rectangularSelectionMode && extraEndVirt != 0){
			int line = getLineOfOffset(end);
			scrollTo(line,getLineLength(line) + extraEndVirt,false);
		}
	}
	 public String getSelectedText(Selection s){
		StringBuffer buf = new StringBuffer();
		s.getText(buffer,buf);
		return buf.toString();
	}
	 public String getSelectedText(String separator){
		Selection[] sel = selectionManager.getSelection();
		if(sel.length == 0)return null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0;
		 i < sel.length;
		 i++){
			if(i != 0)buf.append(separator);
			sel[i].getText(buffer,buf);
		}
		return buf.toString();
	}
	 public String getSelectedText(){
		return getSelectedText(""\n"");
	}
	 public void setSelectedText(Selection s, String selectedText){
		if(!isEditable()){
			throw new InternalError(""Text component""+ "" read only"");
		}
		try{
			buffer.beginCompoundEdit();
			moveCaretPosition(s.setText(buffer,selectedText));
		}
		finally{
			buffer.endCompoundEdit();
		}
	}
	 public void setSelectedText(String selectedText){
		int newCaret = replaceSelection(selectedText);
		if(newCaret != -1)moveCaretPosition(newCaret);
		selectNone();
	}
	 public void setSelectedText(String selectedText, boolean moveCaret){
		int newCaret = replaceSelection(selectedText);
		if(moveCaret && newCaret != -1)moveCaretPosition(newCaret);
		selectNone();
	}
	 public int replaceSelection(String selectedText){
		if(!isEditable())throw new RuntimeException(""Text component read only"");
		int newCaret = -1;
		if(getSelectionCount() == 0){
			buffer.insert(caret,selectedText);
		}
		else{
			try{
				buffer.beginCompoundEdit();
				Selection[] selection = getSelection();
				for(int i = 0;
				 i < selection.length;
				 i++)newCaret = selection[i].setText(buffer,selectedText);
			}
			finally{
				buffer.endCompoundEdit();
			}
		}
		return newCaret;
	}
	 public int[] getSelectedLines(){
		if(selectionManager.getSelectionCount() == 0)return new int[] {
		 caretLine }
		;
		return selectionManager.getSelectedLines();
	}
	 public boolean caretAutoScroll(){
		return (focusedComponent == this);
	}
	 public void addStructureMatcher(StructureMatcher matcher){
		structureMatchers.add(matcher);
	}
	 public void removeStructureMatcher(StructureMatcher matcher){
		structureMatchers.remove(matcher);
	}
	 public StructureMatcher.Match getStructureMatch(){
		return match;
	}
	 public final void blinkCaret(){
		if(caretBlinks){
			blink = !blink;
			invalidateLine(caretLine);
		}
		elseblink = true;
	}
	 public void centerCaret(){
		int offset = getScreenLineStartOffset(visibleLines / 2);
		if(offset == -1)getToolkit().beep();
		elsesetCaretPosition(offset);
	}
	 public void setCaretPosition(int newCaret){
		selectNone();
		moveCaretPosition(newCaret,true);
	}
	 public void setCaretPosition(int newCaret, boolean doElectricScroll){
		selectNone();
		moveCaretPosition(newCaret,doElectricScroll);
	}
	 public void moveCaretPosition(int newCaret){
		moveCaretPosition(newCaret,true);
	}
	 public void moveCaretPosition(int newCaret, boolean doElectricScroll){
		moveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL: NORMAL_SCROLL);
	}
	 public static int NO_SCROLL = 0;
	public static int NORMAL_SCROLL = 1;
	public static int ELECTRIC_SCROLL = 2;
	public void moveCaretPosition(int newCaret, int scrollMode){
		if(newCaret < 0 || newCaret > buffer.getLength()){
			throw new IllegalArgumentException(""caret out of bounds: ""+ newCaret);
		}
		int oldCaretLine = caretLine;
		if(caret == newCaret)finishCaretUpdate(oldCaretLine,scrollMode,false);
		else{
			caret = newCaret;
			caretLine = getLineOfOffset(newCaret);
			magicCaret = -1;
			finishCaretUpdate(oldCaretLine,scrollMode,true);
		}
	}
	 public int getCaretPosition(){
		return caret;
	}
	 public int getCaretLine(){
		return caretLine;
	}
	 public int getMagicCaretPosition(){
		if(magicCaret == -1){
			magicCaret = chunkCache.subregionOffsetToX(caretLine,caret - getLineStartOffset(caretLine));
		}
		return magicCaret;
	}
	 public void setMagicCaretPosition(int magicCaret){
		this.magicCaret = magicCaret;
	}
	 public final void addCaretListener(CaretListener listener){
		listenerList.add(CaretListener.class,listener);
	}
	 public final void removeCaretListener(CaretListener listener){
		listenerList.remove(CaretListener.class,listener);
	}
	 public void goToNextBracket(boolean select){
		int newCaret = -1;
		if(caret != buffer.getLength()){
			String text = getText(caret,buffer.getLength()- caret - 1);
			loop:for(int i = 0;
			 i < text.length();
			 i++){
				switch(text.charAt(i)){
				case ')': case ']': case '}
				':newCaret = caret + i + 1;
				break loop;
			}
		}
	}
	if(newCaret == -1)getToolkit().beep();
	else{
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
	}
}
 public void goToNextCharacter(boolean select){
	Selection s = getSelectionAtOffset(caret);
	if(!select && s instanceof Selection.Range){
		if(multi){
			if(caret != s.end){
				moveCaretPosition(s.end);
				return;
			}
		}
		else{
			setCaretPosition(s.end);
			return;
		}
	}
	int extraStartVirt, extraEndVirt;
	if(s instanceof Selection.Rect){
		extraStartVirt = ((Selection.Rect)s).extraStartVirt;
		extraEndVirt = ((Selection.Rect)s).extraEndVirt;
	}
	else{
		extraStartVirt = 0;
		extraEndVirt = 0;
	}
	int newCaret = caret;
	if(caret == buffer.getLength()){
		if(select && (rectangularSelectionMode || s instanceof Selection.Rect)){
			if(s != null && caret == s.start)extraStartVirt++;
			elseextraEndVirt++;
		}
		else{
			getToolkit().beep();
			return;
		}
	}
	else if(caret == getLineEndOffset(caretLine) - 1){
		if(select && (rectangularSelectionMode || s instanceof Selection.Rect)){
			if(s != null && caret == s.start)extraStartVirt++;
			elseextraEndVirt++;
		}
		else{
			int line = displayManager.getNextVisibleLine(caretLine);
			if(line == -1){
				getToolkit().beep();
				return;
			}
			elsenewCaret = getLineStartOffset(line);
		}
	}
	elsenewCaret = caret + 1;
	if(select)extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
	else if(!multi)selectNone();
	moveCaretPosition(newCaret);
}
 public void goToNextLine(boolean select){
	Selection s = getSelectionAtOffset(caret);
	boolean rectSelect = (s == null ? rectangularSelectionMode: s instanceof Selection.Rect);
	int magic = getMagicCaretPosition();
	int newCaret = chunkCache.getBelowPosition(caretLine,caret - buffer.getLineStartOffset(caretLine),magic + 1,rectSelect && select);
	if(newCaret == -1){
		int end = getLineEndOffset(caretLine) - 1;
		if(caret == end){
			getToolkit().beep();
			return;
		}
		elsenewCaret = end;
	}
	if(select){
		RectParams params = getRectParams(caret,newCaret);
		int extraStartVirt;
		int extraEndVirt;
		if(params == null){
			extraStartVirt = 0;
			extraEndVirt = 0;
		}
		else{
			extraStartVirt = params.extraStartVirt;
			extraEndVirt = params.extraEndVirt;
			newCaret = params.newCaret;
		}
		extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
	}
	else if(!multi)selectNone();
	moveCaretPosition(newCaret);
	setMagicCaretPosition(magic);
}
 public void goToNextPage(boolean select){
	scrollToCaret(false);
	int magic = getMagicCaretPosition();
	if(caretLine < displayManager.getFirstVisibleLine()){
		caretLine = displayManager.getNextVisibleLine(caretLine);
	}
	int newCaret;
	if(getFirstLine() + getVisibleLines() >= displayManager.getScrollLineCount()){
		int lastVisibleLine = displayManager.getLastVisibleLine();
		newCaret = getLineEndOffset(lastVisibleLine) - 1;
	}
	else{
		int caretScreenLine = getScreenLineOfOffset(caret);
		scrollDownPage();
		newCaret = xToScreenLineOffset(caretScreenLine,magic,true);
	}
	if(select)extendSelection(caret,newCaret);
	else if(!multi)selectNone();
	moveCaretPosition(newCaret,false);
	setMagicCaretPosition(magic);
}
 public void goToNextParagraph(boolean select){
	int lineNo = getCaretLine();
	int newCaret = getBufferLength();
	boolean foundBlank = false;
	loop:for(int i = lineNo + 1;
	 i < getLineCount();
	 i++){
		if(!displayManager.isLineVisible(i))continue;
		getLineText(i,lineSegment);
		for(int j = 0;
		 j < lineSegment.count;
		 j++){
			switch(lineSegment.array[lineSegment.offset + j]){
				case ' ':case '\t':break;
				default:if(foundBlank){
					newCaret = getLineStartOffset(i);
					break loop;
				}
				elsecontinue loop;
			}
		}
		foundBlank = true;
	}
	if(select)extendSelection(caret,newCaret);
	else if(!multi)selectNone();
	moveCaretPosition(newCaret);
}
 public void goToNextWord(boolean select){
	goToNextWord(select,false);
}
 public void goToNextWord(boolean select, boolean eatWhitespace){
	int lineStart = getLineStartOffset(caretLine);
	int newCaret = caret - lineStart;
	String lineText = getLineText(caretLine);
	if(newCaret == lineText.length()){
		int nextLine = displayManager.getNextVisibleLine(caretLine);
		if(nextLine == -1){
			getToolkit().beep();
			return;
		}
		newCaret = getLineStartOffset(nextLine);
	}
	else{
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		newCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,noWordSep,true,eatWhitespace);
		newCaret += lineStart;
	}
	if(select)extendSelection(caret,newCaret);
	else if(!multi)selectNone();
	moveCaretPosition(newCaret);
}
 public void goToPrevBracket(boolean select){
	String text = getText(0,caret);
	int newCaret = -1;
	loop:for(int i = getCaretPosition() - 1;
	 i >= 0;
	 i--){
		switch(text.charAt(i)){
			case '(': case '[': case '{
				':newCaret = i;
				break loop;
			}
		}
		if(newCaret == -1)getToolkit().beep();
		else{
			if(select)extendSelection(caret,newCaret);
			else if(!multi)selectNone();
			moveCaretPosition(newCaret);
		}
	}
	 public void goToPrevCharacter(boolean select){
		Selection s = getSelectionAtOffset(caret);
		if(caret == 0){
			getToolkit().beep();
			return;
		}
		if(!select && s instanceof Selection.Range){
			if(multi){
				if(caret != s.start){
					moveCaretPosition(s.start);
					return;
				}
			}
			else{
				setCaretPosition(s.start);
				return;
			}
		}
		int extraStartVirt = 0;
		int extraEndVirt = 0;
		int newCaret = caret;
		if(select && caret == getLineEndOffset(caretLine) - 1){
			if(s instanceof Selection.Rect){
				extraStartVirt = ((Selection.Rect)s).extraStartVirt;
				extraEndVirt = ((Selection.Rect)s).extraEndVirt;
				if(caret == s.start){
					if(extraStartVirt == 0)newCaret = caret - 1;
					elseextraStartVirt--;
				}
				else{
					if(extraEndVirt == 0)newCaret = caret - 1;
					elseextraEndVirt--;
				}
			}
			elsenewCaret = caret - 1;
		}
		else if(caret == getLineStartOffset(caretLine)){
			int line = displayManager.getPrevVisibleLine(caretLine);
			if(line == -1){
				getToolkit().beep();
				return;
			}
			newCaret = getLineEndOffset(line) - 1;
		}
		elsenewCaret = caret - 1;
		if(select)extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
	}
	 public void goToPrevLine(boolean select){
		Selection s = getSelectionAtOffset(caret);
		boolean rectSelect = (s == null ? rectangularSelectionMode: s instanceof Selection.Rect);
		int magic = getMagicCaretPosition();
		int newCaret = chunkCache.getAbovePosition(caretLine,caret - buffer.getLineStartOffset(caretLine),magic + 1,rectSelect && select);
		if(newCaret == -1){
			int start = getLineStartOffset(caretLine);
			if(caret == start){
				getToolkit().beep();
				return;
			}
			elsenewCaret = start;
		}
		if(select){
			RectParams params = getRectParams(caret,newCaret);
			int extraStartVirt;
			int extraEndVirt;
			if(params == null){
				extraStartVirt = 0;
				extraEndVirt = 0;
			}
			else{
				extraStartVirt = params.extraStartVirt;
				extraEndVirt = params.extraEndVirt;
				newCaret = params.newCaret;
			}
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		}
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	 public void goToPrevPage(boolean select){
		scrollToCaret(false);
		int magic = getMagicCaretPosition();
		if(caretLine < displayManager.getFirstVisibleLine()){
			caretLine = displayManager.getNextVisibleLine(caretLine);
		}
		int newCaret;
		if(getFirstLine() == 0){
			int firstVisibleLine = displayManager.getFirstVisibleLine();
			newCaret = getLineStartOffset(firstVisibleLine);
		}
		else{
			int caretScreenLine = getScreenLineOfOffset(caret);
			scrollUpPage();
			newCaret = xToScreenLineOffset(caretScreenLine,magic,true);
		}
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret,false);
		setMagicCaretPosition(magic);
	}
	 public void goToPrevParagraph(boolean select){
		int lineNo = caretLine;
		int newCaret = 0;
		boolean foundBlank = false;
		loop:for(int i = lineNo - 1;
		 i >= 0;
		 i--){
			if(!displayManager.isLineVisible(i))continue;
			getLineText(i,lineSegment);
			for(int j = 0;
			 j < lineSegment.count;
			 j++){
				switch(lineSegment.array[lineSegment.offset + j]){
					case ' ':case '\t':break;
					default:if(foundBlank){
						newCaret = getLineEndOffset(i) - 1;
						break loop;
					}
					elsecontinue loop;
				}
			}
			foundBlank = true;
		}
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
	}
	 public void goToPrevWord(boolean select){
		goToPrevWord(select,false);
	}
	 public void goToPrevWord(boolean select, boolean eatWhitespace){
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(newCaret == 0){
			if(lineStart == 0){
				getToolkit().beep();
				return;
			}
			else{
				int prevLine = displayManager.getPrevVisibleLine(caretLine);
				if(prevLine == -1){
					getToolkit().beep();
					return;
				}
				newCaret = getLineEndOffset(prevLine) - 1;
			}
		}
		else{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordStart(lineText,newCaret - 1,noWordSep,true,eatWhitespace);
			newCaret += lineStart;
		}
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
	}
	 public void smartHome(boolean select){
		Macros.Recorder recorder = view.getMacroRecorder();
		switch(view.getInputHandler().getLastActionCount()){
			case 1:if(recorder != null)recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");
			"");
			goToStartOfWhiteSpace(select);
			break;
			case 2:if(recorder != null)recorder.record(""textArea.goToStartOfLine("" + select + "");
			"");
			goToStartOfLine(select);
			break;
			default: if(recorder != null)recorder.record(""textArea.goToFirstVisibleLine("" + select + "");
			"");
			goToFirstVisibleLine(select);
			break;
		}
	}
	 public void smartEnd(boolean select){
		Macros.Recorder recorder = view.getMacroRecorder();
		switch(view.getInputHandler().getLastActionCount()){
			case 1:if(recorder != null)recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");
			"");
			goToEndOfWhiteSpace(select);
			break;
			case 2:if(recorder != null)recorder.record(""textArea.goToEndOfLine("" + select + "");
			"");
			goToEndOfLine(select);
			break;
			default: if(recorder != null)recorder.record(""textArea.goToLastVisibleLine("" + select + "");
			"");
			goToLastVisibleLine(select);
			break;
		}
	}
	 public void goToStartOfLine(boolean select){
		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null? caretLine : s.startLine);
		int newCaret = getLineStartOffset(line);
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
	}
	 public void goToEndOfLine(boolean select){
		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null? caretLine : s.endLine);
		int newCaret = getLineEndOffset(line) - 1;
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
	}
	 public void goToStartOfWhiteSpace(boolean select){
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null){
			line = caretLine;
			offset = caret - buffer.getLineStartOffset(line);
		}
		else{
			line = s.startLine;
			offset = s.start - buffer.getLineStartOffset(line);
		}
		int firstIndent = chunkCache.getSubregionStartOffset(line,offset);
		if(firstIndent == getLineStartOffset(line)){
			firstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));
			if(firstIndent == getLineLength(line))firstIndent = 0;
			firstIndent += getLineStartOffset(line);
		}
		if(select)extendSelection(caret,firstIndent);
		else if(!multi)selectNone();
		moveCaretPosition(firstIndent);
	}
	 public void goToEndOfWhiteSpace(boolean select){
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null){
			line = caretLine;
			offset = caret - getLineStartOffset(line);
		}
		else{
			line = s.endLine;
			offset = s.end - getLineStartOffset(line);
		}
		int lastIndent = chunkCache.getSubregionEndOffset(line,offset);
		if(lastIndent == getLineEndOffset(line)){
			lastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));
			if(lastIndent == 0)lastIndent = getLineLength(line);
			lastIndent += getLineStartOffset(line);
		}
		else{
			lastIndent--;
		}
		if(select)extendSelection(caret,lastIndent);
		else if(!multi)selectNone();
		moveCaretPosition(lastIndent);
	}
	 public void goToFirstVisibleLine(boolean select){
		int firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;
		int firstVisible = getScreenLineStartOffset(firstVisibleLine);
		if(firstVisible == -1){
			firstVisible = getLineStartOffset(displayManager.getFirstVisibleLine());
		}
		if(select)extendSelection(caret,firstVisible);
		else if(!multi)selectNone();
		moveCaretPosition(firstVisible);
	}
	 public void goToLastVisibleLine(boolean select){
		int lastVisible;
		if(getFirstLine() + visibleLines >=displayManager.getScrollLineCount()){
			lastVisible = getLineEndOffset(displayManager.getLastVisibleLine()) - 1;
		}
		else{
			lastVisible = visibleLines - electricScroll - 1;
			if(lastLinePartial)lastVisible--;
			if(lastVisible < 0)lastVisible = 0;
			lastVisible = getScreenLineEndOffset(lastVisible) - 1;
			if(lastVisible == -1){
				lastVisible = getLineEndOffset(displayManager.getLastVisibleLine()) - 1;
			}
		}
		if(select)extendSelection(caret,lastVisible);
		else if(!multi)selectNone();
		moveCaretPosition(lastVisible);
	}
	 public void goToBufferStart(boolean select){
		int start = buffer.getLineStartOffset(displayManager.getFirstVisibleLine());
		if(select)extendSelection(caret,start);
		else if(!multi)selectNone();
		moveCaretPosition(start);
	}
	 public void goToBufferEnd(boolean select){
		int end = buffer.getLineEndOffset(displayManager.getLastVisibleLine()) - 1;
		if(select)extendSelection(caret,end);
		else if(!multi)selectNone();
		moveCaretPosition(end);
	}
	 public void goToMatchingBracket(){
		if(getLineLength(caretLine) != 0){
			int dot = caret - getLineStartOffset(caretLine);
			int bracket = TextUtilities.findMatchingBracket(buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1){
				selectNone();
				moveCaretPosition(bracket + 1,false);
				return;
			}
		}
		getToolkit().beep();
	}
	 public void showGoToLineDialog(){
		String line = GUIUtilities.input(view,""goto-line"",null);
		if(line == null)return;
		try{
			int lineNumber = Integer.parseInt(line) - 1;
			setCaretPosition(getLineStartOffset(lineNumber));
		}
		catch(Exception e){
			getToolkit().beep();
		}
	}
	 public void userInput(char ch){
		if(!isEditable()){
			getToolkit().beep();
			return;
		}
		if(hiddenCursor != null)getPainter().setCursor(hiddenCursor);
		if(ch == ' ' && Abbrevs.getExpandOnInput()&& Abbrevs.expandAbbrev(view,false))return;
		if(ch == '\t')userInputTab();
		else{
			boolean indent = buffer.isElectricKey(ch);
			String str = String.valueOf(ch);
			if(getSelectionCount() == 0){
				if(!doWordWrap(ch == ' '))insert(str,indent);
			}
			elsereplaceSelection(str);
		}
	}
	 public final boolean isOverwriteEnabled(){
		return overwrite;
	}
	 public final void setOverwriteEnabled(boolean overwrite){
		blink = true;
		caretTimer.restart();
		this.overwrite = overwrite;
		invalidateLine(caretLine);
		fireStatusChanged(StatusListener.OVERWRITE_CHANGED,overwrite);
	}
	 public final void toggleOverwriteEnabled(){
		setOverwriteEnabled(!overwrite);
	}
	 public void backspace(){
		delete(false);
	}
	 public void backspaceWord(){
		backspaceWord(false);
	}
	 public void backspaceWord(boolean eatWhitespace){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		if(getSelectionCount() != 0){
			setSelectedText("""");
			return;
		}
		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(_caret == 0){
			if(lineStart == 0){
				getToolkit().beep();
				return;
			}
			_caret--;
		}
		else{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep,true,eatWhitespace);
		}
		buffer.remove(_caret + lineStart,caret - (_caret + lineStart));
	}
	 public void delete(){
		delete(true);
	}
	 public void deleteToEndOfLine(){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		buffer.remove(caret,getLineEndOffset(caretLine)- caret - 1);
	}
	 public void deleteLine(){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		int x = chunkCache.subregionOffsetToX(caretLine,caret - getLineStartOffset(caretLine));
		int[] lines = getSelectedLines();
		try{
			buffer.beginCompoundEdit();
			int start,end;
			for (int i = lines.length - 1;
			 i >= 0;
			 i--){
				start = getLineStartOffset(lines[i]);
				end = getLineEndOffset(lines[i]);
				if (end > buffer.getLength()){
					if (start != 0)start--;
					end--;
				}
				buffer.remove(start,end - start);
			}
		}
		finally{
			buffer.endCompoundEdit();
		}
		int lastLine = displayManager.getLastVisibleLine();
		if(caretLine == lastLine){
			int offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);
			setCaretPosition(buffer.getLineStartOffset(lastLine)+ offset);
		}
		else{
			int offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);
			setCaretPosition(getLineStartOffset(caretLine) + offset);
		}
	}
	 public void deleteParagraph(){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		int start = 0, end = buffer.getLength();
		loop:for(int i = caretLine - 1;
		 i >= 0;
		 i--){
			getLineText(i,lineSegment);
			for(int j = 0;
			 j < lineSegment.count;
			 j++){
				switch(lineSegment.array[lineSegment.offset + j]){
					case ' ':case '\t':break;
					default:continue loop;
				}
			}
			start = getLineStartOffset(i);
			break loop;
		}
		loop:for(int i = caretLine + 1;
		 i < getLineCount();
		 i++){
			getLineText(i,lineSegment);
			for(int j = 0;
			 j < lineSegment.count;
			 j++){
				switch(lineSegment.array[lineSegment.offset + j]){
					case ' ':case '\t':break;
					default:continue loop;
				}
			}
			end = getLineEndOffset(i) - 1;
			break loop;
		}
		buffer.remove(start,end - start);
	}
	 public void deleteToStartOfLine(){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		buffer.remove(getLineStartOffset(caretLine),caret - getLineStartOffset(caretLine));
	}
	 public void deleteWord(){
		deleteWord(false);
	}
	 public void deleteWord(boolean eatWhitespace){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		if(getSelectionCount() != 0){
			setSelectedText("""");
			return;
		}
		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(_caret == lineText.length()){
			if(lineStart + _caret == buffer.getLength()){
				getToolkit().beep();
				return;
			}
			_caret++;
		}
		else{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordEnd(lineText,_caret+1,noWordSep,true,eatWhitespace);
		}
		buffer.remove(caret,(_caret + lineStart) - caret);
	}
	 public final boolean isMultipleSelectionEnabled(){
		return multi;
	}
	 public final void toggleMultipleSelectionEnabled(){
		setMultipleSelectionEnabled(!multi);
	}
	 public final void setMultipleSelectionEnabled(boolean multi){
		this.multi = multi;
		fireStatusChanged(StatusListener.MULTI_SELECT_CHANGED,multi);
		painter.repaint();
	}
	 public final boolean isRectangularSelectionEnabled(){
		return rectangularSelectionMode;
	}
	 public final void toggleRectangularSelectionEnabled(){
		setRectangularSelectionEnabled(!rectangularSelectionMode);
		if(getSelectionCount() == 1){
			Selection s = getSelection(0);
			removeFromSelection(s);
			if(rectangularSelectionMode){
				addToSelection(new Selection.Rect(s.getStart(),s.getEnd()));
			}
			else{
				addToSelection(new Selection.Range(s.getStart(),s.getEnd()));
			}
		}
	}
	 public final void setRectangularSelectionEnabled(boolean rectangularSelectionMode){
		this.rectangularSelectionMode = rectangularSelectionMode;
		fireStatusChanged(StatusListener.RECT_SELECT_CHANGED,rectangularSelectionMode);
		painter.repaint();
	}
	 public void goToParentFold(){
		int line = -1;
		int level = buffer.getFoldLevel(caretLine);
		for(int i = caretLine - 1;
		 i >= 0;
		 i--){
			if(buffer.getFoldLevel(i) < level){
				line = i;
				break;
			}
		}
		if(line == -1){
			getToolkit().beep();
			return;
		}
		int magic = getMagicCaretPosition();
		int newCaret = buffer.getLineStartOffset(line)+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);
		if(!multi)selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	 public void goToNextFold(boolean select){
		int nextFold = -1;
		for(int i = caretLine + 1;
		 i < buffer.getLineCount();
		 i++){
			if(buffer.isFoldStart(i)&& displayManager.isLineVisible(i)){
				nextFold = i;
				break;
			}
		}
		if(nextFold == -1){
			getToolkit().beep();
			return;
		}
		int magic = getMagicCaretPosition();
		int newCaret = buffer.getLineStartOffset(nextFold)+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	 public void goToPrevFold(boolean select){
		int prevFold = -1;
		for(int i = caretLine - 1;
		 i >= 0;
		 i--){
			if(buffer.isFoldStart(i)&& displayManager.isLineVisible(i)){
				prevFold = i;
				break;
			}
		}
		if(prevFold == -1){
			getToolkit().beep();
			return;
		}
		int magic = getMagicCaretPosition();
		int newCaret = buffer.getLineStartOffset(prevFold)+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);
		if(select)extendSelection(caret,newCaret);
		else if(!multi)selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	 public void collapseFold(){
		int x = chunkCache.subregionOffsetToX(caretLine,caret - getLineStartOffset(caretLine));
		displayManager.collapseFold(caretLine);
		if(displayManager.isLineVisible(caretLine))return;
		int line = displayManager.getPrevVisibleLine(caretLine);
		if(!multi)selectNone();
		moveCaretPosition(buffer.getLineStartOffset(line)+ chunkCache.xToSubregionOffset(line,0,x,true));
	}
	 public void expandFold(boolean fully){
		int x = chunkCache.subregionOffsetToX(caretLine,caret - getLineStartOffset(caretLine));
		int line = displayManager.expandFold(caretLine,fully);
		if(!fully && line != -1){
			if(!multi)selectNone();
			moveCaretPosition(getLineStartOffset(line)+ chunkCache.xToSubregionOffset(line,0,x,true));
		}
	}
	 public void selectFold(){
		selectFold(caretLine);
	}
	 public void selectFold(int line){
		int[] lines = buffer.getFoldAtLine(line);
		int newCaret = getLineEndOffset(lines[1]) - 1;
		Selection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);
		if(multi)addToSelection(s);
		elsesetSelection(s);
		moveCaretPosition(newCaret);
	}
	 public void narrowToFold(){
		int[] lines = buffer.getFoldAtLine(caretLine);
		if(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)getToolkit().beep();
		elsedisplayManager.narrow(lines[0],lines[1]);
	}
	 public void narrowToSelection(){
		if(getSelectionCount() != 1){
			getToolkit().beep();
			return;
		}
		Selection sel = getSelection(0);
		displayManager.narrow(sel.getStartLine(),sel.getEndLine());
		selectNone();
	}
	 public void addExplicitFold(){
		if(!buffer.getStringProperty(""folding"").equals(""explicit"")){
			GUIUtilities.error(view,""folding-not-explicit"",null);
			return;
		}
		try{
			buffer.beginCompoundEdit();
			if (getSelectionCount() == 0){
				addExplicitFold(caret, caret, caretLine, caretLine);
			}
			else{
				Selection[] selections = getSelection();
				Selection selection = null;
				int caretBack = 0;
				for (int i = 0;
				 i < selections.length;
				 i++){
					selection = selections[i];
					caretBack = addExplicitFold(selection.start, selection.end, selection.startLine,selection.endLine);
				}
				setCaretPosition(selection.start - caretBack, false);
			}
		}
		finally{
			buffer.endCompoundEdit();
		}
	}
	 public void lineComment(){
		String comment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		if(!buffer.isEditable() || comment == null || comment.length() == 0){
			getToolkit().beep();
			return;
		}
		comment = comment + ' ';
		buffer.beginCompoundEdit();
		int[] lines = getSelectedLines();
		try{
			for(int i = 0;
			 i < lines.length;
			 i++){
				String text = getLineText(lines[i]);
				buffer.insert(getLineStartOffset(lines[i])+ MiscUtilities.getLeadingWhiteSpace(text),comment);
			}
		}
		finally{
			buffer.endCompoundEdit();
		}
		selectNone();
	}
	 public void rangeComment(){
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null|| commentStart.length() == 0 || commentEnd.length() == 0){
			getToolkit().beep();
			return;
		}
		commentStart = commentStart + ' ';
		commentEnd = ' ' + commentEnd;
		try{
			buffer.beginCompoundEdit();
			Selection[] selection = getSelection();
			if(selection.length == 0){
				int oldCaret = caret;
				buffer.insert(caret,commentStart);
				buffer.insert(caret,commentEnd);
				setCaretPosition(oldCaret + commentStart.length());
			}
			for(int i = 0;
			 i < selection.length;
			 i++){
				Selection s = selection[i];
				if(s instanceof Selection.Range){
					buffer.insert(s.start,commentStart);
					buffer.insert(s.end,commentEnd);
				}
				else if(s instanceof Selection.Rect){
					Selection.Rect rect = (Selection.Rect)s;
					int start = rect.getStartColumn(buffer);
					int end = rect.getEndColumn(buffer);
					for(int j = s.startLine;
					 j <= s.endLine;
					 j++){
						buffer.insertAtColumn(j,end,commentEnd);
						buffer.insertAtColumn(j,start,commentStart);
					}
				}
			}
			selectNone();
		}
		finally{
			buffer.endCompoundEdit();
		}
	}
	 public void formatParagraph(){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		if(maxLineLen <= 0){
			GUIUtilities.error(view,""format-maxlinelen"",null);
			return;
		}
		Selection[] selection = getSelection();
		if(selection.length != 0){
			buffer.beginCompoundEdit();
			for(int i = 0;
			 i < selection.length;
			 i++){
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.format(getSelectedText(s),maxLineLen,buffer.getTabSize()));
			}
			buffer.endCompoundEdit();
		}
		else{
			int lineNo = getCaretLine();
			int start = 0, end = buffer.getLength();
			loop:for(int i = lineNo - 1;
			 i >= 0;
			 i--){
				getLineText(i,lineSegment);
				for(int j = 0;
				 j < lineSegment.count;
				 j++){
					switch(lineSegment.array[lineSegment.offset + j]){
						case ' ':case '\t':break;
						default:continue loop;
					}
				}
				start = getLineEndOffset(i);
				break loop;
			}
			loop:for(int i = lineNo + 1;
			 i < getLineCount();
			 i++){
				getLineText(i,lineSegment);
				for(int j = 0;
				 j < lineSegment.count;
				 j++){
					switch(lineSegment.array[lineSegment.offset + j]){
						case ' ':case '\t':break;
						default:continue loop;
					}
				}
				end = getLineStartOffset(i) - 1;
				break loop;
			}
			try{
				buffer.beginCompoundEdit();
				String text = buffer.getText(start,end - start);
				int offset = getCaretPosition() - start;
				int noSpaceOffset = TextUtilities.indexIgnoringWhitespace(text,offset);
				buffer.remove(start,end - start);
				text = TextUtilities.format(text,maxLineLen,buffer.getTabSize());
				buffer.insert(start,text);
				moveCaretPosition(start + Math.min(text.length(),TextUtilities.ignoringWhitespaceIndex(text,noSpaceOffset)));
			}
			finally{
				buffer.endCompoundEdit();
			}
		}
	}
	 public void spacesToTabs(){
		Selection[] selection = getSelection();
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		buffer.beginCompoundEdit();
		if(selection.length == 0){
			setText(TextUtilities.spacesToTabs(getText(), buffer.getTabSize()));
		}
		else{
			for(int i = 0;
			 i < selection.length;
			 i++){
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.spacesToTabs(getSelectedText(s),buffer.getTabSize()));
			}
		}
		buffer.endCompoundEdit();
	}
	 public void tabsToSpaces(){
		Selection[] selection = getSelection();
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		buffer.beginCompoundEdit();
		if(selection.length == 0){
			setText(TextUtilities.tabsToSpaces(getText(), buffer.getTabSize()));
		}
		else{
			for(int i = 0;
			 i < selection.length;
			 i++){
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.tabsToSpaces(getSelectedText(s),buffer.getTabSize()));
			}
		}
		buffer.endCompoundEdit();
	}
	 public void toUpperCase(){
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0) {
			 getToolkit().beep();
			 return;
		 }
		buffer.beginCompoundEdit();
		for(int i = 0;
		 i < selection.length;
		 i++){
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toUpperCase());
		}
		buffer.endCompoundEdit();
	}
	 public void toLowerCase(){
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0) {
			 getToolkit().beep();
			 return;
		 }
		buffer.beginCompoundEdit();
		for(int i = 0;
		 i < selection.length;
		 i++){
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toLowerCase());
		}
		buffer.endCompoundEdit();
	}
	 public void removeTrailingWhiteSpace(){
		if(!buffer.isEditable())getToolkit().beep();
		else{
			buffer.removeTrailingWhiteSpace(getSelectedLines());
		}
	}
	 public void insertEnterAndIndent(){
		if(!isEditable())getToolkit().beep();
		else{
			try{
				buffer.beginCompoundEdit();
				setSelectedText(""\n"");
				buffer.indentLine(caretLine,true);
			}
			finally{
				buffer.endCompoundEdit();
			}
		}
	}
	 public void insertTabAndIndent(){
		if(!isEditable()){
			getToolkit().beep();
			return;
		}
		if(getSelectionCount() == 0){
			String text = buffer.getLineText(caretLine);
			int start = buffer.getLineStartOffset(caretLine);
			int whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);
			if(caret - start <= whiteSpace&& buffer.indentLine(caretLine,false))return;
		}
		userInput('\t');
	}
	 public void indentSelectedLines(){
		if(!buffer.isEditable())getToolkit().beep();
		else{
			buffer.indentLines(getSelectedLines());
			selectNone();
		}
	}
	 public void shiftIndentLeft(){
		if(!buffer.isEditable())getToolkit().beep();
		else{
			buffer.shiftIndentLeft(getSelectedLines());
		}
	}
	 public void shiftIndentRight(){
		if(!buffer.isEditable())getToolkit().beep();
		elsebuffer.shiftIndentRight(getSelectedLines());
	}
	 public void joinLines(){
		if (getSelectionCount() == 0){
			int end = getLineEndOffset(caretLine);
			if(!buffer.isEditable() || end > buffer.getLength()){
				getToolkit().beep();
				return;
			}
			try{
				buffer.beginCompoundEdit();
				buffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(buffer.getLineText(caretLine + 1)) + 1);
				buffer.insert(end - 1, "" "");
			}
			finally{
				buffer.endCompoundEdit();
			}
			setCaretPosition(end - 1);
		}
		else{
			try{
				buffer.beginCompoundEdit();
				int[] selectedLines = getSelectedLines();
				int offset = 0;
				for (int i = 0;
				 i < selectedLines.length-1;
				 i++){
					if (selectedLines[i+1] - selectedLines[i] > 1)continue;
					int end = getLineEndOffset(selectedLines[i]-offset);
					buffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(buffer.getLineText(selectedLines[i] + 1 - offset)) + 1);
					buffer.insert(end - 1, "" "");
					offset++;
				}
			}
			finally{
				buffer.endCompoundEdit();
			}
		}
	}
	 public void showWordCountDialog(){
		String selection = getSelectedText();
		if(selection != null){
			doWordCount(view,selection);
			return;
		}
		doWordCount(view,buffer.getText(0,buffer.getLength()));
	}
	 public boolean isRightClickPopupEnabled(){
		return popupEnabled;
	}
	 public void setRightClickPopupEnabled(boolean popupEnabled){
		this.popupEnabled = popupEnabled;
	}
	 public final JPopupMenu getRightClickPopup(){
		return popup;
	}
	 public final void setRightClickPopup(JPopupMenu popup){
		this.popup = popup;
	}
	 public void handlePopupTrigger(MouseEvent evt){
		if(popup.isVisible())popup.setVisible(false);
		else{
			int x = evt.getX();
			int y = evt.getY();
			int dragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()|| isOverwriteEnabled()));
			if(getSelectionCount() == 0 || multi)moveCaretPosition(dragStart,false);
			GUIUtilities.showPopupMenu(popup,painter,x,y);
		}
	}
	 public void addLeftOfScrollBar(Component comp){
		verticalBox.add(comp,verticalBox.getComponentCount() - 1);
	}
	 public void removeLeftOfScrollBar(Component comp){
		verticalBox.remove(comp);
	}
	 public void addNotify(){
		super.addNotify();
		ToolTipManager.sharedInstance().registerComponent(painter);
		ToolTipManager.sharedInstance().registerComponent(gutter);
		recalculateVisibleLines();
		if(!buffer.isLoading())recalculateLastPhysicalLine();
		propertiesChanged();
		hiddenCursor = getToolkit().createCustomCursor(getGraphicsConfiguration().createCompatibleImage(16,16,Transparency.BITMASK),new Point(0,0),""Hidden"");
	}
	 public void removeNotify(){
		super.removeNotify();
		ToolTipManager.sharedInstance().unregisterComponent(painter);
		ToolTipManager.sharedInstance().unregisterComponent(gutter);
		if(focusedComponent == this)focusedComponent = null;
	}
	 public boolean getFocusTraversalKeysEnabled(){
		return false;
	}
	 public boolean getFocusCycleRoot(){
		return true;
	}
	 public void processKeyEvent(KeyEvent evt){
		view.processKeyEvent(evt,View.TEXT_AREA);
		if(!evt.isConsumed())super.processKeyEvent(evt);
	}
	 public void addTopComponent(Component comp){
		add(ScrollLayout.TOP,comp);
	}
	 public void removeTopComponent(Component comp){
		remove(comp);
	}
	 public final void addStatusListener(StatusListener listener){
		listenerList.add(StatusListener.class,listener);
	}
	 public final void removeStatusListener(StatusListener listener){
		listenerList.remove(StatusListener.class,listener);
	}
	 public void propertiesChanged(){
		if(buffer == null)return;
		int _tabSize = buffer.getTabSize();
		char[] foo = new char[_tabSize];
		for(int i = 0;
		 i < foo.length;
		 i++)foo[i] = ' ';
		tabSize = (float)painter.getStringWidth(new String(foo));
		charWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,painter.getFontRenderContext()).getWidth());
		String oldWrap = wrap;
		wrap = buffer.getStringProperty(""wrap"");
		hardWrap = wrap.equals(""hard"");
		softWrap = wrap.equals(""soft"");
		boolean oldWrapToWidth = wrapToWidth;
		int oldWrapMargin = wrapMargin;
		setMaxLineLength(buffer.getIntegerProperty(""maxLineLen"",0));
		boolean wrapSettingsChanged = !(wrap.equals(oldWrap)&& oldWrapToWidth == wrapToWidth&& oldWrapMargin == wrapMargin);
		if(displayManager != null && !bufferChanging&& !buffer.isLoading() && wrapSettingsChanged){
			displayManager.invalidateScreenLineCounts();
			displayManager.notifyScreenLineChanges();
		}
		repaintMgr.setFastScroll(false);
		chunkCache.invalidateAll();
		gutter.repaint();
		painter.repaint();
	}
	 public final int getSelectionStart(){
		if(getSelectionCount() != 1)return caret;
		return getSelection(0).getStart();
	}
	 public int getSelectionStart(int line){
		if(getSelectionCount() != 1)return caret;
		return getSelection(0).getStart(buffer,line);
	}
	 public final int getSelectionStartLine(){
		if(getSelectionCount() != 1)return caret;
		return getSelection(0).getStartLine();
	}
	 public final void setSelectionStart(int selectionStart){
		select(selectionStart,getSelectionEnd(),true);
	}
	 public final int getSelectionEnd(){
		if(getSelectionCount() != 1)return caret;
		return getSelection(0).getEnd();
	}
	 public int getSelectionEnd(int line){
		if(getSelectionCount() != 1)return caret;
		return getSelection(0).getEnd(buffer,line);
	}
	 public final int getSelectionEndLine(){
		if(getSelectionCount() != 1)return caret;
		return getSelection(0).getEndLine();
	}
	 public final void setSelectionEnd(int selectionEnd){
		select(getSelectionStart(),selectionEnd,true);
	}
	 public final int getMarkPosition(){
		Selection s = getSelectionAtOffset(caret);
		if(s == null)return caret;
		if(s.start == caret)return s.end;
		else if(s.end == caret)return s.start;
		elsereturn caret;
	}
	 public final int getMarkLine(){
		if(getSelectionCount() != 1)return caretLine;
		Selection s = getSelection(0);
		if(s.start == caret)return s.endLine;
		else if(s.end == caret)return s.startLine;
		elsereturn caretLine;
	}
	 public void select(int start, int end){
		select(start,end,true);
	}
	 public void select(int start, int end, boolean doElectricScroll){
		selectNone();
		int newStart, newEnd;
		if(start < end){
			newStart = start;
			newEnd = end;
		}
		else{
			newStart = end;
			newEnd = start;
		}
		setSelection(new Selection.Range(newStart,newEnd));
		moveCaretPosition(end,doElectricScroll);
	}
	 public boolean isSelectionRectangular(){
		Selection s = getSelectionAtOffset(caret);
		if(s == null)return false;
		elsereturn (s instanceof Selection.Rect);
	}
	 static JEditTextArea focusedComponent;
	Segment lineSegment;
	MouseHandler mouseHandler;
	ChunkCache chunkCache;
	FastRepaintManager repaintMgr;
	DisplayManager displayManager;
	SelectionManager selectionManager;
	boolean bufferChanging;
	int maxHorizontalScrollWidth;
	String wrap;
	boolean hardWrap;
	boolean softWrap;
	boolean wrapToWidth;
	int maxLineLen;
	int wrapMargin;
	float tabSize;
	int charWidth;
	boolean scrollBarsInitialized;
	Point returnValue;
	boolean lastLinePartial;
	boolean blink;
	final boolean isCaretVisible(){
		return blink && hasFocus();
	}
	 final boolean isStructureHighlightVisible(){
		return match != null&& hasFocus()&& displayManager.isLineVisible(match.startLine)&& displayManager.isLineVisible(match.endLine);
	}
	 void updateMaxHorizontalScrollWidth(){
		int max = chunkCache.getMaxHorizontalScrollWidth();
		if(max != maxHorizontalScrollWidth){
			maxHorizontalScrollWidth = max;
			horizontal.setValues(Math.max(0,Math.min(maxHorizontalScrollWidth + charWidth- painter.getWidth(),-horizontalOffset)),painter.getWidth(),0,maxHorizontalScrollWidth+ charWidth);
			horizontal.setUnitIncrement(10);
			horizontal.setBlockIncrement(painter.getWidth());
		}
	}
	 void recalculateVisibleLines(){
		if(painter == null)return;
		int height = painter.getHeight();
		int lineHeight = painter.getFontMetrics().getHeight();
		if(lineHeight == 0)visibleLines = 0;
		else if(height <= 0){
			visibleLines = 0;
			lastLinePartial = false;
		}
		else{
			visibleLines = height / lineHeight;
			lastLinePartial = (height % lineHeight != 0);
			if(lastLinePartial)visibleLines++;
		}
		chunkCache.recalculateVisibleLines();
		if(displayManager != null && buffer != null && !buffer.isLoading())setFirstLine(getFirstLine());
		updateScrollBar();
	}
	 void foldStructureChanged(){
		repaintMgr.setFastScroll(false);
		chunkCache.invalidateAll();
		recalculateLastPhysicalLine();
		repaint();
	}
	 void updateScrollBar(){
		if(buffer == null)return;
		if(Debug.SCROLL_DEBUG)Log.log(Log.DEBUG,this,""updateScrollBar(), slc=""+ displayManager.getScrollLineCount());
		if(vertical != null && visibleLines != 0){
			if(Debug.SCROLL_DEBUG)Log.log(Log.DEBUG,this,""Vertical ok"");
			int lineCount = displayManager.getScrollLineCount();
			int firstLine = getFirstLine();
			int visible = visibleLines - (lastLinePartial ? 1 : 0);
			vertical.setValues(firstLine,visible,0,lineCount);
			vertical.setUnitIncrement(2);
			vertical.setBlockIncrement(visible);
		}
	}
	 void _finishCaretUpdate(){
		if(!queuedCaretUpdate)return;
		try{
			if(match != null){
				if(oldCaretLine < match.startLine)invalidateLineRange(oldCaretLine,match.endLine);
				elseinvalidateLineRange(match.startLine,oldCaretLine);
				match = null;
			}
			int newCaretScreenLine = chunkCache.getScreenLineOfOffset(caretLine,caret - buffer.getLineStartOffset(caretLine));
			if(caretScreenLine == -1)invalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);
			elseinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);
			caretScreenLine = newCaretScreenLine;
			invalidateSelectedLines();
			blink = true;
			caretTimer.restart();
			if(!displayManager.isLineVisible(caretLine)){
				if(caretLine < displayManager.getFirstVisibleLine()|| caretLine > displayManager.getLastVisibleLine()){
					int collapseFolds = buffer.getIntegerProperty(""collapseFolds"",0);
					if(collapseFolds != 0){
						displayManager.expandFolds(collapseFolds);
						displayManager.expandFold(caretLine,false);
					}
					elsedisplayManager.expandAllFolds();
				}
				elsedisplayManager.expandFold(caretLine,false);
			}
			if(queuedScrollMode == ELECTRIC_SCROLL)scrollToCaret(true);
			else if(queuedScrollMode == NORMAL_SCROLL)scrollToCaret(false);
			updateBracketHighlightWithDelay();
			if(queuedFireCaretEvent)fireCaretEvent();
		}
		finally{
			queuedCaretUpdate = queuedFireCaretEvent = false;
			queuedScrollMode = NO_SCROLL;
		}
	}
	 void invalidateStructureMatch(){
		if(match != null)invalidateLineRange(match.startLine,match.endLine);
	}
	 void startDragAndDrop(InputEvent evt, boolean copy){
		Log.log(Log.DEBUG,this,""Drag and drop callback"");
		getTransferHandler().exportAsDrag(this,evt,copy ? TransferHandler.COPY: TransferHandler.MOVE);
	}
	 void fireNarrowActive(){
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2;
		 i >= 0;
		 i--){
			if(listeners[i] == StatusListener.class){
				try{
					((StatusListener)listeners[i+1]).narrowActive(this);
				}
				catch(Throwable t){
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	}
	 private static Timer caretTimer;
	private static Timer structureTimer;
	private Cursor hiddenCursor;
	private View view;
	private Gutter gutter;
	private TextAreaPainter painter;
	private JPopupMenu popup;
	private boolean popupEnabled;
	private EventListenerList listenerList;
	private MutableCaretEvent caretEvent;
	private boolean caretBlinks;
	private int physLastLine;
	private int screenLastLine;
	private int visibleLines;
	private int electricScroll;
	private int horizontalOffset;
	private boolean quickCopy;
	private Box verticalBox;
	private JScrollBar vertical;
	private JScrollBar horizontal;
	private JEditBuffer buffer;
	private int caret;
	private int caretLine;
	private int caretScreenLine;
	private List structureMatchers;
	private StructureMatcher.Match match;
	private int magicCaret;
	private boolean multi;
	private boolean overwrite;
	private boolean rectangularSelectionMode;
	private boolean dndEnabled;
	private boolean dndInProgress;
	private boolean queuedCaretUpdate;
	private int queuedScrollMode;
	private boolean queuedFireCaretEvent;
	private int oldCaretLine;
	private boolean joinNonWordChars;
	private void invalidateSelectedLines(){
		invalidateLine(caretLine);
		Iterator iter = selectionManager.selection.iterator();
		while(iter.hasNext()){
			Selection s = (Selection)iter.next();
			invalidateLineRange(s.startLine,s.endLine);
		}
	}
	 private void finishCaretUpdate(int oldCaretLine,int scrollMode, boolean fireCaretEvent){
		this.queuedFireCaretEvent |= fireCaretEvent;
		this.queuedScrollMode = Math.max(scrollMode,queuedScrollMode);
		if(queuedCaretUpdate)return;
		this.oldCaretLine = oldCaretLine;
		queuedCaretUpdate = true;
		if(!buffer.isTransactionInProgress())_finishCaretUpdate();
		repaintMgr.setFastScroll(false);
	}
	 private void fireCaretEvent(){
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2;
		 i >= 0;
		 i--){
			if(listeners[i] == CaretListener.class){
				try{
					((CaretListener)listeners[i+1]).caretUpdate(caretEvent);
				}
				catch(Throwable t){
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	}
	 private void fireScrollEvent(boolean vertical){
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2;
		 i >= 0;
		 i--){
			if(listeners[i] == ScrollListener.class){
				try{
					if(vertical)((ScrollListener)listeners[i+1]).scrolledVertically(this);
					else((ScrollListener)listeners[i+1]).scrolledHorizontally(this);
				}
				catch(Throwable t){
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	}
	 private void fireStatusChanged(int flag, boolean value){
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2;
		 i >= 0;
		 i--){
			if(listeners[i] == StatusListener.class){
				try{
					((StatusListener)listeners[i+1]).statusChanged(this,flag,value);
				}
				catch(Throwable t){
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	}
	 private void fireBracketSelected(int line, String text){
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2;
		 i >= 0;
		 i--){
			if(listeners[i] == StatusListener.class){
				try{
					((StatusListener)listeners[i+1]).bracketSelected(this,line,text);
				}
				catch(Throwable t){
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	}
	 private void insert(String str, boolean indent){
		try{
			if(overwrite || indent)buffer.beginCompoundEdit();
			if(overwrite){
				int caretLineEnd = getLineEndOffset(caretLine);
				if(caretLineEnd - caret > 1)buffer.remove(caret,1);
			}
			buffer.insert(caret,str);
			if(indent)buffer.indentLine(caretLine,true);
		}
		finally{
			if(overwrite || indent)buffer.endCompoundEdit();
		}
	}
	 private void insertTab(){
		int tabSize = buffer.getTabSize();
		if(buffer.getBooleanProperty(""noTabs"")){
			int lineStart = getLineStartOffset(caretLine);
			String line = getText(lineStart,caret - lineStart);
			int pos = 0;
			for(int i = 0;
			 i < line.length();
			 i++){
				switch(line.charAt(pos)){
					case '\t':pos = 0;
					break;
					default:if(++pos >= tabSize)pos = 0;
					break;
				}
			}
			replaceSelection(MiscUtilities.createWhiteSpace(tabSize - pos,0));
		}
		elsereplaceSelection(""\t"");
	}
	 private void userInputTab(){
		if(getSelectionCount() == 1){
			Selection sel = getSelection(0);
			if(sel instanceof Selection.Rect ||(sel.startLine == sel.endLine&& (sel.start != buffer.getLineStartOffset(sel.startLine)|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1))){
				insertTab();
			}
			elseshiftIndentRight();
		}
		else if(getSelectionCount() != 0)shiftIndentRight();
		elseinsertTab();
	}
	 private boolean doWordWrap(boolean spaceInserted){
		if(!hardWrap || maxLineLen <= 0)return false;
		buffer.getLineText(caretLine,lineSegment);
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		int len = end - start - 1;
		int caretPos = caret - start;
		for(int i = caretPos;
		 i < len;
		 i++){
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch != ' ' && ch != '\t')return false;
		}
		int tabSize = buffer.getTabSize();
		String wordBreakChars = buffer.getStringProperty(""wordBreakChars"");
		int lastInLine = 0;
		 int logicalLength = 0;
		 int lastWordOffset = -1;
		boolean lastWasSpace = true;
		for(int i = 0;
		 i < caretPos;
		 i++){
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch == '\t'){
				logicalLength += tabSize - (logicalLength % tabSize);
				if(!lastWasSpace && logicalLength <= maxLineLen){
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(ch == ' '){
				logicalLength++;
				if(!lastWasSpace &&logicalLength <= maxLineLen + 1){
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1){
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen){
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else{
				lastInLine = i;
				logicalLength++;
				lastWasSpace = false;
			}
		}
		boolean returnValue;
		int insertNewLineAt;
		if(spaceInserted && logicalLength == maxLineLen&& lastInLine == caretPos - 1){
			insertNewLineAt = caretPos;
			returnValue = true;
		}
		else if(logicalLength >= maxLineLen && lastWordOffset != -1){
			insertNewLineAt = lastWordOffset;
			returnValue = false;
		}
		elsereturn false;
		try{
			buffer.beginCompoundEdit();
			buffer.insert(start + insertNewLineAt,""\n"");
			buffer.indentLine(caretLine,true);
		}
		finally{
			buffer.endCompoundEdit();
		}
		return returnValue;
	}
	 private void doWordCount(View view, String text){
		char[] chars = text.toCharArray();
		int characters = chars.length;
		int words = 0;
		int lines = 1;
		boolean word = true;
		for(int i = 0;
		 i < chars.length;
		 i++){
			switch(chars[i]){
				case '\r': case '\n':lines++;
				case ' ': case '\t':word = true;
				break;
				default:if(word){
					words++;
					word = false;
				}
				break;
			}
		}
		Object[] args = {
		 new Integer(characters), new Integer(words),new Integer(lines) }
		;
		GUIUtilities.message(view,""wordcount"",args);
	}
	 private void updateBracketHighlightWithDelay(){
		structureTimer.stop();
		structureTimer.start();
	}
	 private void updateStructureHighlight(){
		if(!painter.isStructureHighlightEnabled()&& !gutter.isStructureHighlightEnabled())return;
		Iterator iter = structureMatchers.iterator();
		while(iter.hasNext()){
			StructureMatcher matcher = (StructureMatcher)iter.next();
			match = matcher.getMatch(this);
			if(match != null)break;
		}
		if(match != null){
			if(caretLine < match.startLine)invalidateLineRange(caretLine,match.endLine);
			elseinvalidateLineRange(match.startLine,caretLine);
			if(!displayManager.isLineVisible(match.startLine)|| chunkCache.getScreenLineOfOffset(match.startLine,match.start - getLineStartOffset(match.startLine))== -1){
				showStructureStatusMessage(match.startLine < caretLine);
			}
		}
	}
	 private void showStructureStatusMessage(boolean backward){
		String text = buffer.getLineText(match.startLine).trim();
		if(backward && match.startLine != 0 && text.length() == 1){
			switch(text.charAt(0)){
				case '{
				': case '}
				':case '[': case ']':case '(': case ')':text = buffer.getLineText(match.startLine - 1).trim() + "" "" + text;
				break;
			}
		}
		fireBracketSelected(match.startLine + 1,text.replace('\t',' '));
	}
	 void recalculateLastPhysicalLine(){
		int oldScreenLastLine = screenLastLine;
		for(int i = visibleLines - 1;
		 i >= 0;
		 i--){
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if(info.physicalLine != -1){
				physLastLine = info.physicalLine;
				screenLastLine = i;
				break;
			}
		}
		invalidateScreenLineRange(oldScreenLastLine,screenLastLine);
	}
	 static class RectParams{
		int extraStartVirt;
		int extraEndVirt;
		int newCaret;
		RectParams(int extraStartVirt, int extraEndVirt, int newCaret){
			this.extraStartVirt = extraStartVirt;
			this.extraEndVirt = extraEndVirt;
			this.newCaret = newCaret;
		}
	}
	private RectParams getRectParams(int caret, int newCaret){
		Selection s = getSelectionAtOffset(caret);
		int virtualWidth;
		if(s instanceof Selection.Rect){
			if(caret == s.end){
				virtualWidth = buffer.getVirtualWidth(s.endLine,s.end - getLineStartOffset(s.endLine)) + ((Selection.Rect)s).extraEndVirt;
			}
			else{
				virtualWidth = buffer.getVirtualWidth(s.startLine,s.start - getLineStartOffset(s.startLine)) + ((Selection.Rect)s).extraStartVirt;
			}
		}
		else if(rectangularSelectionMode){
			virtualWidth = buffer.getVirtualWidth(caretLine,caret - buffer.getLineStartOffset(caretLine));
		}
		elsereturn null;
		int newLine = getLineOfOffset(newCaret);
		int[] totalVirtualWidth = new int[1];
		int newOffset = buffer.getOffsetOfVirtualColumn(newLine,virtualWidth,totalVirtualWidth);
		if(newOffset == -1){
			int extraVirt = virtualWidth - totalVirtualWidth[0];
			newCaret = getLineEndOffset(newLine) - 1;
			RectParams returnValue;
			boolean bias;
			if(s == null)bias = (newCaret < caret);
			else if(s.start == caret)bias = (newCaret <= s.end);
			else if(s.end == caret)bias = (newCaret <= s.start);
			elsebias = false;
			if(bias)returnValue = new RectParams(extraVirt,0,newCaret);
			elsereturnValue = new RectParams(0,extraVirt,newCaret);
			return returnValue;
		}
		else{
			return new RectParams(0,0,getLineStartOffset(newLine)+ newOffset);
		}
	}
	 private void delete(boolean forward){
		if(!buffer.isEditable()){
			getToolkit().beep();
			return;
		}
		if(getSelectionCount() != 0){
			Selection[] selections = getSelection();
			for(int i = 0;
			 i < selections.length;
			 i++){
				Selection s = selections[i];
				if(s instanceof Selection.Rect){
					Selection.Rect r = (Selection.Rect)s;
					int startColumn = r.getStartColumn(buffer);
					if(startColumn == r.getEndColumn(buffer)){
						if(!forward && startColumn == 0)getToolkit().beep();
						elsetallCaretDelete(r,forward);
					}
					elsesetSelectedText(s,null);
				}
				elsesetSelectedText(s,null);
			}
		}
		else if(forward){
			if(caret == buffer.getLength()){
				getToolkit().beep();
				return;
			}
			buffer.remove(caret,1);
		}
		else{
			if(caret == 0){
				getToolkit().beep();
				return;
			}
			buffer.remove(caret - 1,1);
		}
	}
	 private void tallCaretDelete(Selection.Rect s, boolean forward){
		try{
			buffer.beginCompoundEdit();
			int[] width = new int[1];
			int startCol = s.getStartColumn(buffer);
			int startLine = s.startLine;
			int endLine = s.endLine;
			for(int i = startLine;
			 i <= endLine;
			 i++){
				int offset = buffer.getOffsetOfVirtualColumn(i,startCol,width);
				if(offset == -1){
					if(width[0] == startCol)offset = getLineLength(i);
					else{
						if(i == startLine && !forward)shiftTallCaretLeft(s);
						continue;
					}
				}
				offset += buffer.getLineStartOffset(i);
				if(forward){
					if(offset != buffer.getLineEndOffset(i) - 1)buffer.remove(offset,1);
				}
				elsebuffer.remove(offset-1,1);
			}
		}
		finally{
			buffer.endCompoundEdit();
		}
	}
	 private void shiftTallCaretLeft(Selection.Rect s){
		removeFromSelection(s);
		addToSelection(new Selection.Rect(buffer,s.getStartLine(),s.getStartColumn(buffer) - 1,s.getEndLine(),s.getEndColumn(buffer) - 1));
	}
	 private void setMaxLineLength(int maxLineLen){
		this.maxLineLen = maxLineLen;
		if(maxLineLen <= 0){
			if(softWrap){
				wrapToWidth = true;
				wrapMargin = painter.getWidth() - charWidth * 3;
			}
			else{
				wrapToWidth = false;
				wrapMargin = 0;
			}
		}
		else{
			char[] foo = new char[maxLineLen];
			for(int i = 0;
			 i < foo.length;
			 i++){
				foo[i] = ' ';
			}
			wrapToWidth = false;
			wrapMargin = (int)painter.getFont().getStringBounds(foo,0,foo.length,painter.getFontRenderContext()).getWidth();
		}
	}
	 private int addExplicitFold(int caretStart, int caretEnd, int lineStart, int lineEnd){
		String startLineComment = buffer.getContextSensitiveProperty(caretStart,""lineComment"");
		String endLineComment = buffer.getContextSensitiveProperty(caretEnd,""lineComment"");
		String startCommentStart = buffer.getContextSensitiveProperty(caretStart,""commentStart"");
		String startCommentEnd = buffer.getContextSensitiveProperty(caretStart,""commentEnd"");
		String endCommentStart = buffer.getContextSensitiveProperty(caretEnd,""commentStart"");
		String endCommentEnd = buffer.getContextSensitiveProperty(caretEnd,""commentEnd"");
		String start, end;
		int caretBack = 1;
		if(startLineComment != null)start = startLineComment + ""{
			{
				{
					 \n"";
					else if(startCommentStart != null && startCommentEnd != null){
						start = startCommentStart + ""{
							{
								{
									 "" + startCommentEnd + '\n';
									caretBack = 1 + startCommentStart.length();
								}
								elsestart = ""{
									{
										{
											 \n"";
										if(endLineComment != null)end = endLineComment + ""}
									}
								}
								"";
							else if(endCommentStart != null && endCommentEnd != null)end = endCommentStart + ""}
						}
					}
					"" + endCommentEnd;
				elseend = ""}
			}
		}
		"";
		String line = buffer.getLineText(lineStart);
		String whitespace = line.substring(0,MiscUtilities.getLeadingWhiteSpace(line));
		if(caretEnd == buffer.getLineStartOffset(lineEnd))buffer.insert(caretEnd,end);
		elsebuffer.insert(caretEnd,' ' + end);
		buffer.insert(caretStart,start + whitespace);
		return caretBack;
	}
	 static class CaretBlinker implements ActionListener{
		public void actionPerformed(ActionEvent evt){
			if(focusedComponent != null && focusedComponent.hasFocus())focusedComponent.blinkCaret();
		}
	 }
	 class MutableCaretEvent extends CaretEvent{
		MutableCaretEvent(){
			super(JEditTextArea.this);
		}
		 public int getDot(){
			return getCaretPosition();
		}
		 public int getMark(){
			return getMarkPosition();
		}
	 }
	 class AdjustHandler implements AdjustmentListener{
		public void adjustmentValueChanged(final AdjustmentEvent evt){
			if(!scrollBarsInitialized)return;
			if(evt.getAdjustable() == vertical)setFirstLine(vertical.getValue());
			elsesetHorizontalOffset(-horizontal.getValue());
		}
	 }
	 class FocusHandler implements FocusListener{
		public void focusGained(FocusEvent evt){
			if(bufferChanging)return;
			if(match != null){
				if(caretLine < match.startLine)invalidateLineRange(caretLine,match.endLine);
				elseinvalidateLineRange(match.startLine,caretLine);
			}
			elseinvalidateLine(caretLine);
			focusedComponent = JEditTextArea.this;
		}
		 public void focusLost(FocusEvent evt){
			if(!isShowing())return;
			if(match != null){
				if(caretLine < match.startLine)invalidateLineRange(caretLine,match.endLine);
				elseinvalidateLineRange(match.startLine,caretLine);
			}
			elseinvalidateLine(caretLine);
		}
	 }
	 class MouseWheelHandler implements MouseWheelListener{
		public void mouseWheelMoved(MouseWheelEvent e){
			if(e.isAltDown()){
				boolean select = (e.isShiftDown()|| e.isControlDown());
				if(e.getWheelRotation() < 0)goToPrevLine(select);
				elsegoToNextLine(select);
			}
			else if(e.isShiftDown()){
				if(e.getWheelRotation() > 0)scrollDownPage();
				elsescrollUpPage();
			}
			else if(e.isControlDown()){
				setFirstLine(getFirstLine()+ e.getWheelRotation());
			}
			else if(e.getScrollType()== MouseWheelEvent.WHEEL_UNIT_SCROLL){
				setFirstLine(getFirstLine()+ e.getUnitsToScroll());
			}
			else{
				setFirstLine(getFirstLine()+ 3 * e.getWheelRotation());
			}
		}
	}
	 static{
		caretTimer = new Timer(500,new CaretBlinker());
		caretTimer.setInitialDelay(500);
		caretTimer.start();
		structureTimer = new Timer(100,new ActionListener(){
			public void actionPerformed(ActionEvent evt){
				if(focusedComponent != null)focusedComponent.updateStructureHighlight();
			}
		}
		);
		structureTimer.setInitialDelay(100);
		structureTimer.setRepeats(false);
	}
 }",1,0,0,0
"public class P4Fstat extends P4Base {
	 private int changelist;
	 private String addCmd = """";
	 private Vector filesets = new Vector();
	 private static final int DEFAULT_CMD_LENGTH = 300;
	 private int cmdLength = DEFAULT_CMD_LENGTH;
	 private static final int SHOW_ALL = 0;
	 private static final int SHOW_EXISTING = 1;
	 private static final int SHOW_NON_EXISTING = 2;
	 private int show = SHOW_NON_EXISTING;
	 private FStatP4OutputHandler handler;
	 private StringBuffer filelist;
	 private int fileNum = 0;
	 private int doneFileNum = 0;
	 private boolean debug = false;
	 private static final String EXISTING_HEADER = ""Following files exist in perforce"";
	 private static final String NONEXISTING_HEADER = ""Following files do not exist in perforce"";
	 public void setShowFilter(String filter) {
		 if (filter.equalsIgnoreCase(""all"")) {
			 show = SHOW_ALL;
		 }
		 else if (filter.equalsIgnoreCase(""existing"")) {
			 show = SHOW_EXISTING;
		 }
		 else if (filter.equalsIgnoreCase(""non-existing"")) {
			 show = SHOW_NON_EXISTING;
		 }
		 else {
			 throw new BuildException(""P4Fstat: ShowFilter should be one of: "" + ""all, existing, non-existing"");
		 }
	 }
	 public void setChangelist(int changelist) throws BuildException {
		 if (changelist <= 0) {
			 throw new BuildException(""P4FStat: Changelist# should be a "" + ""positive number"");
		 }
		 this.changelist = changelist;
	 }
	 public void addFileset(FileSet set) {
		 filesets.addElement(set);
	 }
	 public void execute() throws BuildException {
		 handler = new FStatP4OutputHandler(this);
		 if (P4View != null) {
			 addCmd = P4View;
		 }
		 P4CmdOpts = (changelist > 0) ? (""-c "" + changelist) : """";
		 filelist = new StringBuffer();
		 final int size = filesets.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 FileSet fs = (FileSet) filesets.elementAt(i);
			 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
			 String[] srcFiles = ds.getIncludedFiles();
			 if (srcFiles != null) {
				 fileNum = srcFiles.length;
				 for (int j = 0;
				 j < srcFiles.length;
				 j++) {
					 File f = new File(ds.getBasedir(), srcFiles[j]);
					 filelist.append("" "").append('""').append(f.getAbsolutePath()).append('""');
					 doneFileNum++;
					 if (filelist.length() > cmdLength) {
						 execP4Fstat(filelist);
						 filelist = new StringBuffer();
					 }
				 }
				 if (filelist.length() > 0) {
					 execP4Fstat(filelist);
				 }
			 }
			 else {
				 log(""No files specified to query status on!"", Project.MSG_WARN);
			 }
		 }
		 if (show == SHOW_ALL || show == SHOW_EXISTING) {
			 printRes(handler.getExisting(), EXISTING_HEADER);
		 }
		 if (show == SHOW_ALL || show == SHOW_NON_EXISTING) {
			 printRes(handler.getNonExisting(), NONEXISTING_HEADER);
		 }
	 }
	 public int getLengthOfTask() {
		 return fileNum;
	 }
	 int getPasses() {
		 return filesets.size();
	 }
	 private void printRes(ArrayList ar, String header) {
		 log(header, Project.MSG_INFO);
		 final int size = ar.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 log((String) ar.get(i), Project.MSG_INFO);
		 }
	 }
	 private void execP4Fstat(StringBuffer list) {
		 String l = list.substring(0);
		 if (debug) {
			 log(""Executing fstat "" + P4CmdOpts + "" "" + addCmd + l + ""\n"", Project.MSG_INFO);
		 }
		 execP4Command(""fstat "" + P4CmdOpts + "" "" + addCmd + l, handler);
	 }
}",0,0,0,0
"public abstract class SecuredItemImpl implements SecuredItem {
	 private class CacheKey implements Comparable<CacheKey> {
		 private final Action action;
		 private final Node mNode;
		 private final Triple from;
		 private final Triple to;
		 private Integer hashCode;
		 public CacheKey(final Action action, final Node modelNode) {
			 this(action, modelNode, null, null);
		 }
		 public CacheKey(final Action action, final Node modelNode, final Triple to) {
			 this(action, modelNode, to, null);
		 }
		 public CacheKey(final Action action, final Node modelNode, final Triple to, final Triple from) {
			 this.action = action;
			 this.mNode = modelNode;
			 this.to = to;
			 this.from = from;
		 }
		 private int compare(Node n1, Node n2) {
			 if (Node.ANY.equals(n1)) {
				 if (Node.ANY.equals(n2)) {
					 return Expr.CMP_EQUAL;
				 }
				 return Expr.CMP_LESS;
			 }
			 if (Node.ANY.equals(n2)) {
				 return Expr.CMP_GREATER;
			 }
			 return NodeCmp.compareRDFTerms(n1, n2);
		 }
		 private int compare(Triple t1, Triple t2) {
			 if (t1 == null) {
				 if (t2 == null) {
					 return Expr.CMP_EQUAL;
				 }
				 return Expr.CMP_LESS;
			 }
			 if (t2 == null) {
				 return Expr.CMP_GREATER;
			 }
			 int retval = compare(t1.getSubject(), t2.getSubject());
			 if (retval == Expr.CMP_EQUAL) {
				 retval = compare(t1.getPredicate(), t2.getPredicate());
			 }
			 if (retval == Expr.CMP_EQUAL) {
				 retval = compare(t1.getObject(), t2.getObject());
			 }
			 return retval;
		 }
		 public int compareTo(final CacheKey other) {
			 int retval = this.action.compareTo(other.action);
			 if (retval == Expr.CMP_EQUAL) {
				 retval = NodeCmp.compareRDFTerms(this.mNode, other.mNode);
			 }
			 if (retval == Expr.CMP_EQUAL) {
				 retval = compare(this.to, other.to);
			 }
			 if (retval == Expr.CMP_EQUAL) {
				 retval = compare(this.from, other.from);
			 }
			 return retval;
		 }
		 public boolean equals(final Object o) {
			 if (o instanceof CacheKey) {
				 return this.compareTo((CacheKey) o) == 0;
			 }
			 return false;
		 }
		 public int hashCode() {
			 if (hashCode == null) {
				 hashCode = new HashCodeBuilder().append(action).append(mNode).append(from).append(to).toHashCode();
			 }
			 return hashCode;
		 }
	 }
	 public static int MAX_CACHE = 100;
	 public static final ThreadLocal<LRUMap<CacheKey, Boolean>> CACHE = new ThreadLocal<>();
	 public static final ThreadLocal<Integer> COUNT = new ThreadLocal<>();
	 private static Node convert(final Node jenaNode) {
		 if (jenaNode.isVariable()) {
			 return SecurityEvaluator.VARIABLE;
		 }
		 return jenaNode;
	 }
	 private static Triple convert(final Triple jenaTriple) {
		 if (jenaTriple.getSubject().isVariable() || jenaTriple.getPredicate().isVariable() || jenaTriple.getObject().isVariable()) {
			 return Triple.create(SecuredItemImpl.convert(jenaTriple.getSubject()), SecuredItemImpl.convert(jenaTriple.getPredicate()), SecuredItemImpl.convert(jenaTriple.getObject()));
		 }
		 return jenaTriple;
	 }
	 public static void decrementUse() {
		 final Integer i = SecuredItemImpl.COUNT.get();
		 if (i == null) {
			 throw new IllegalStateException(""No count on exit"");
		 }
		 if (i < 1) {
			 throw new IllegalStateException(""No count less than 1"");
		 }
		 if (i == 1) {
			 SecuredItemImpl.CACHE.remove();
			 SecuredItemImpl.COUNT.remove();
		 }
		 else {
			 SecuredItemImpl.COUNT.set(i - 1);
		 }
	 }
	 public static void incrementUse() {
		 final Integer i = SecuredItemImpl.COUNT.get();
		 if (i == null) {
			 SecuredItemImpl.CACHE.set(new LRUMap<CacheKey, Boolean>(Math.max(SecuredItemImpl.MAX_CACHE, 100)));
			 SecuredItemImpl.COUNT.set(1);
		 }
		 else {
			 SecuredItemImpl.COUNT.set(i + 1);
		 }
	 }
	 private final SecurityEvaluator securityEvaluator;
	 private final Node modelNode;
	 private final ItemHolder<?, ?> itemHolder;
	 protected SecuredItemImpl(final SecuredItem securedItem, final ItemHolder<?, ?> holder) {
		 if (securedItem == null) {
			 throw new IllegalArgumentException(""Secured item may not be null"");
		 }
		 if (securedItem.getSecurityEvaluator() == null) {
			 throw new IllegalArgumentException(""Security evaluator in secured item may not be null"");
		 }
		 if (holder == null) {
			 throw new IllegalArgumentException(""ItemHolder may not be null"");
		 }
		 this.securityEvaluator = securedItem.getSecurityEvaluator();
		 this.modelNode = securedItem.getModelNode();
		 this.itemHolder = holder;
	 }
	 protected SecuredItemImpl(final SecurityEvaluator securityEvaluator, final String modelURI, final ItemHolder<?, ?> holder) {
		 if (securityEvaluator == null) {
			 throw new IllegalArgumentException(""Security evaluator may not be null"");
		 }
		 if (StringUtils.isEmpty(modelURI)) {
			 throw new IllegalArgumentException(""ModelURI may not be empty or null"");
		 }
		 if (holder == null) {
			 throw new IllegalArgumentException(""ItemHolder may not be null"");
		 }
		 this.securityEvaluator = securityEvaluator;
		 this.modelNode = NodeFactory.createURI(modelURI);
		 this.itemHolder = holder;
	 }
	 public final String toString() throws AuthenticationRequiredException {
		 Object o = itemHolder.getBaseItem();
		 boolean ok = canRead();
		 if (ok) {
			 if (o instanceof Triple) {
				 ok = canRead((Triple) o);
			 }
			 else if (o instanceof FrontsTriple) {
				 ok = canRead(((FrontsTriple) o).asTriple());
			 }
		 }
		 return (ok) ? itemHolder.getBaseItem().toString() : String.format(""SecuredItem[0x%X]"", itemHolder.getBaseItem().hashCode());
	 }
	 private Boolean cacheGet(final CacheKey key) {
		 final LRUMap<CacheKey, Boolean> cache = SecuredItemImpl.CACHE.get();
		 return (cache == null) ? null : (Boolean) cache.get(key);
	 }
	 private void cachePut(final CacheKey key, final boolean value) {
		 final LRUMap<CacheKey, Boolean> cache = SecuredItemImpl.CACHE.get();
		 if (cache != null) {
			 cache.put(key, value);
			 SecuredItemImpl.CACHE.set(cache);
		 }
	 }
	 public boolean canCreate() throws AuthenticationRequiredException {
		 final CacheKey key = new CacheKey(Action.Create, modelNode);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Create, modelNode);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canCreate(final Triple triple) throws AuthenticationRequiredException {
		 Triple t = convert(triple);
		 final CacheKey key = new CacheKey(Action.Create, modelNode, t);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Create, modelNode, t);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canCreate(final FrontsTriple frontsTriple) throws AuthenticationRequiredException {
		 return canCreate(frontsTriple.asTriple());
	 }
	 public boolean canDelete() throws AuthenticationRequiredException {
		 final CacheKey key = new CacheKey(Action.Delete, modelNode);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Delete, modelNode);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canDelete(final Triple triple) throws AuthenticationRequiredException {
		 Triple t = convert(triple);
		 final CacheKey key = new CacheKey(Action.Delete, modelNode, t);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Delete, modelNode, t);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canDelete(final FrontsTriple frontsTriple) throws AuthenticationRequiredException {
		 return canDelete(frontsTriple.asTriple());
	 }
	 public boolean canRead() throws AuthenticationRequiredException {
		 final CacheKey key = new CacheKey(Action.Read, modelNode);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Read, modelNode);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canRead(final Triple triple) throws AuthenticationRequiredException {
		 Triple t = convert(triple);
		 final CacheKey key = new CacheKey(Action.Read, modelNode, t);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Read, modelNode, t);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canRead(final FrontsTriple frontsTriple) throws AuthenticationRequiredException {
		 return canRead(frontsTriple.asTriple());
	 }
	 public boolean canUpdate() throws AuthenticationRequiredException {
		 final CacheKey key = new CacheKey(Action.Update, modelNode);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluate(securityEvaluator.getPrincipal(), Action.Update, modelNode);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canUpdate(final Triple f, final Triple t) throws AuthenticationRequiredException {
		 Triple from = convert(f);
		 Triple to = convert(t);
		 final CacheKey key = new CacheKey(Action.Update, modelNode, from, to);
		 Boolean retval = cacheGet(key);
		 if (retval == null) {
			 retval = securityEvaluator.evaluateUpdate(securityEvaluator.getPrincipal(), modelNode, from, to);
			 cachePut(key, retval);
		 }
		 return retval;
	 }
	 public boolean canUpdate(final FrontsTriple from, final FrontsTriple to) throws AuthenticationRequiredException {
		 return canUpdate(from.asTriple(), to.asTriple());
	 }
	 protected void checkCreate() throws AddDeniedException, AuthenticationRequiredException {
		 if (!canCreate()) {
			 throw new AddDeniedException(SecuredItem.Util.modelPermissionMsg(modelNode));
		 }
	 }
	 protected void checkCreate(final Triple t) throws AddDeniedException, AuthenticationRequiredException {
		 if (!canCreate(t)) {
			 throw new AddDeniedException(SecuredItem.Util.triplePermissionMsg(modelNode), t);
		 }
	 }
	 protected void checkCreate(final FrontsTriple frontsTriple) throws AddDeniedException, AuthenticationRequiredException {
		 checkCreate(frontsTriple.asTriple());
	 }
	 protected void checkCreateReified(final String uri, final FrontsTriple front) throws AddDeniedException, UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 Triple t = front.asTriple();
		 final Node n = uri == null ? SecurityEvaluator.FUTURE : NodeFactory.createURI(uri);
		 checkCreate(Triple.create(n, RDF.subject.asNode(), t.getSubject()));
		 checkCreate(Triple.create(n, RDF.predicate.asNode(), t.getPredicate()));
		 checkCreate(Triple.create(n, RDF.object.asNode(), t.getObject()));
	 }
	 protected void checkCreate(Supplier<ExtendedIterator<Triple>> supplier) throws AddDeniedException, AuthenticationRequiredException {
		 if (!canCreate(Triple.ANY)) {
			 ExtendedIterator<Triple> iter = supplier.get();
			 try {
				 while (iter.hasNext()) {
					 checkCreate(iter.next());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
	 }
	 protected void checkDelete() throws DeleteDeniedException, AuthenticationRequiredException {
		 if (!canDelete()) {
			 throw new DeleteDeniedException(SecuredItem.Util.modelPermissionMsg(modelNode));
		 }
	 }
	 protected void checkDelete(final Triple triple) throws DeleteDeniedException, AuthenticationRequiredException {
		 if (!canDelete(triple)) {
			 throw new DeleteDeniedException(SecuredItem.Util.triplePermissionMsg(modelNode), triple);
		 }
	 }
	 protected void checkDelete(final FrontsTriple frontsTriple) throws DeleteDeniedException, AuthenticationRequiredException {
		 checkDelete(frontsTriple.asTriple());
	 }
	 protected void checkDeleteFrontsTriples(final ExtendedIterator<? extends FrontsTriple> frontsTriplesIter) throws DeleteDeniedException, AuthenticationRequiredException {
		 if (!canDelete(Triple.ANY)) {
			 try {
				 while (frontsTriplesIter.hasNext()) {
					 checkDelete(frontsTriplesIter.next());
				 }
			 }
			 finally {
				 frontsTriplesIter.close();
			 }
		 }
	 }
	 protected void checkDeleteTriples(final ExtendedIterator<Triple> triples) throws DeleteDeniedException, AuthenticationRequiredException {
		 if (!canDelete(Triple.ANY)) {
			 try {
				 while (triples.hasNext()) {
					 checkDelete(triples.next());
				 }
			 }
			 finally {
				 triples.close();
			 }
		 }
	 }
	 protected void checkRead() throws ReadDeniedException, AuthenticationRequiredException {
		 if (!canRead()) {
			 throw new ReadDeniedException(SecuredItem.Util.modelPermissionMsg(modelNode));
		 }
	 }
	 protected boolean checkSoftRead() throws ReadDeniedException, AuthenticationRequiredException {
		 if (!canRead()) {
			 if (securityEvaluator.isHardReadError()) {
				 throw new ReadDeniedException(SecuredItem.Util.modelPermissionMsg(modelNode));
			 }
			 return false;
		 }
		 return true;
	 }
	 protected boolean checkRead(final Triple triple) throws ReadDeniedException, AuthenticationRequiredException {
		 if (!canRead(triple)) {
			 if (securityEvaluator.isHardReadError()) {
				 throw new ReadDeniedException(SecuredItem.Util.triplePermissionMsg(modelNode), triple);
			 }
			 return false;
		 }
		 return true;
	 }
	 protected boolean checkRead(final FrontsTriple frontsTriple) throws ReadDeniedException, AuthenticationRequiredException {
		 return checkRead(frontsTriple.asTriple());
	 }
	 protected boolean checkReadFrontsTriples(final ExtendedIterator<FrontsTriple> frontsTripleIter) throws ReadDeniedException, AuthenticationRequiredException {
		 try {
			 while (frontsTripleIter.hasNext()) {
				 if (!checkRead(frontsTripleIter.next())) {
					 return false;
				 }
			 }
			 return true;
		 }
		 finally {
			 frontsTripleIter.close();
		 }
	 }
	 protected boolean checkReadTriples(final ExtendedIterator<Triple> triples) throws ReadDeniedException, AuthenticationRequiredException {
		 try {
			 while (triples.hasNext()) {
				 if (!checkRead(triples.next())) {
					 return false;
				 }
			 }
			 return true;
		 }
		 finally {
			 triples.close();
		 }
	 }
	 protected void checkUpdate() throws UpdateDeniedException, AuthenticationRequiredException {
		 if (!canUpdate()) {
			 throw new UpdateDeniedException(SecuredItem.Util.modelPermissionMsg(modelNode));
		 }
	 }
	 protected void checkUpdate(final Triple from, final Triple to) throws UpdateDeniedException, AuthenticationRequiredException {
		 if (!canUpdate(from, to)) {
			 throw new UpdateDeniedException( String.format(""%s: %s to %s"", SecuredItem.Util.modelPermissionMsg(modelNode), from, to));
		 }
	 }
	 public boolean equals(final Object o) {
		 if (Proxy.isProxyClass(o.getClass())) {
			 return o.equals(itemHolder.getSecuredItem());
		 }
		 if (o instanceof SecuredItemImpl) {
			 return itemHolder.getBaseItem().equals(((SecuredItemImpl) o).getBaseItem());
		 }
		 return false;
	 }
	 public int hashCode() {
		 return itemHolder.getBaseItem().hashCode();
	 }
	 public Object getBaseItem() {
		 return itemHolder.getBaseItem();
	 }
	 public String getModelIRI() {
		 return modelNode.getURI();
	 }
	 public Node getModelNode() {
		 return modelNode;
	 }
	 public SecurityEvaluator getSecurityEvaluator() {
		 return securityEvaluator;
	 }
	 public boolean isEquivalent(final SecuredItem securedItem) {
		 return SecuredItem.Util.isEquivalent(this, securedItem);
	 }
	 protected <T> ExtendedIterator<T> createIterator(Supplier<ExtendedIterator<T>> find, Supplier<Predicate<T>> filter) {
		 if (checkSoftRead()) {
			 ExtendedIterator<T> retval = find.get();
			 if (!canRead(Triple.ANY)) {
				 retval = retval.filterKeep(filter.get());
			 }
			 return retval;
		 }
		 return NullIterator.instance();
	 }
}",1,0,0,0
"public class ReportOSGiLaunchDelegate extendsEclipseApplicationLaunchConfiguration implements IReportLaunchConstants{
	ReportLaunchHelper helper;
	public static final String APP_NAME = ""application name"";
	public ReportOSGiLaunchDelegate( ){
		helper = new ReportLaunchHelper( );
	}
	public void launch( ILaunchConfiguration configuration, String mode,ILaunch launch, IProgressMonitor monitor ) throws CoreException{
		helper.init( configuration );
		super.launch( configuration, mode, launch, monitor );
	}
	public String[] getVMArguments( ILaunchConfiguration configuration )throws CoreException{
		String[] args = super.getVMArguments( configuration );
		List arguments = new ArrayList( );
		for ( int i = 0;
		 i < args.length;
		 i++ ){
			arguments.add( args[i] );
		}
		helper.addPortArgs( arguments );
		helper.addUserClassPath( arguments, configuration );
		helper.addFileNameArgs( arguments );
		helper.addEngineHomeArgs( arguments );
		helper.addResourceFolder( arguments );
		helper.addTempFolder( arguments );
		helper.addTypeArgs( arguments );
		helper.addDataLimitArgs(arguments);
		helper.addParameterArgs( arguments );
		return (String[]) arguments.toArray( new String[arguments.size( )] );
	}
	public String[] getProgramArguments( ILaunchConfiguration configuration )throws CoreException{
		String[] args = super.getProgramArguments( configuration );
		List list = new ArrayList( );
		for ( int i = 0;
		 i < args.length;
		 i++ ){
			list.add( args[i] );
		}
		int idx = list.indexOf( ""-application"" );
		 if ( idx != -1 && ( idx + 1 ) < list.size( ) ){
			list.set( idx + 1,getApplicationName( ) );
		 }
		else{
			list.add( ""-application"" );
			 list.add( getApplicationName( ) );
		 }
		list.add( ""-nosplash"" );
		 return (String[]) list.toArray( new String[list.size( )] );
	}
	private String getApplicationName(){
		String name = System.getProperty( APP_NAME );
		if (name == null || name.length( ) == 0){
			name = ""org.eclipse.birt.report.debug.core.ReportDebugger"";
		}
		return name;
	}
	public IVMRunner getVMRunner( ILaunchConfiguration configuration,String mode ) throws CoreException{
		if ( ( helper.debugType & DEBUG_TYPE_JAVA_CLASS ) == DEBUG_TYPE_JAVA_CLASS ){
			mode = ILaunchManager.DEBUG_MODE;
		}
		else{
			mode = ILaunchManager.RUN_MODE;
		}
		return new ReportDebuggerVMRunner( super.getVMRunner( configuration,mode ),( helper.debugType & DEBUG_TYPE_JAVA_SCRIPT ) == DEBUG_TYPE_JAVA_SCRIPT,this );
	}
	protected IProject[] getBuildOrder( ILaunchConfiguration configuration,String mode ) throws CoreException{
		return super.getBuildOrder( configuration, mode );
	}
	public boolean finalLaunchCheck( final ILaunchConfiguration configuration,String mode, IProgressMonitor monitor ) throws CoreException{
		boolean bool = super.finalLaunchCheck( configuration, mode, monitor );
		if ( !bool ){
			return bool;
		}
		return helper.finalLaunchCheck( configuration, mode, monitor );
	}
}",1,1,0,0
"abstract class ElementPropertyChangedEvent extends ElementPropertyEvent {
	 public ElementPropertyChangedEvent(final Element element, final Property oldValue, final Object newValue, final Object... vertexPropertyKeyValues) {
		 super(element, oldValue, newValue, vertexPropertyKeyValues);
	 }
 }",0,0,0,0
"public boolean isEmpty() {
	 return !row.hasNext() && ColumnFamilyStore.removeDeletedCF(row.getColumnFamily(), gcBefore) == null;
 }",0,0,0,0
"public static class ExclamationBolt extends BaseRichBolt {
	 private static final ConcurrentHashMap<String, String> myCrummyCache = new ConcurrentHashMap<>();
	 private static final int CACHE_SIZE = 100_000;
	 OutputCollector _collector;
	 protected static String getFromCache(String key) {
		 return myCrummyCache.get(key);
	 }
	 protected static void addToCache(String key, String value) {
		 myCrummyCache.putIfAbsent(key, value);
		 int numToRemove = myCrummyCache.size() - CACHE_SIZE;
		 if (numToRemove > 0) {
			 Iterator<Entry<String, String>> it = myCrummyCache.entrySet().iterator();
			 for (;
			 numToRemove > 0 && it.hasNext();
			 numToRemove--) {
				 it.next();
				 it.remove();
			 }
		 }
	 }
	 public void prepare(Map<String, Object> conf, TopologyContext context, OutputCollector collector) {
		 _collector = collector;
	 }
	 public void execute(Tuple tuple) {
		 String orig = tuple.getString(0);
		 String ret = getFromCache(orig);
		 if (ret == null) {
			 ret = orig + ""!!!"";
			 addToCache(orig, ret);
		 }
		 _collector.emit(tuple, new Values(ret));
		 _collector.ack(tuple);
	 }
	 public void declareOutputFields(OutputFieldsDeclarer declarer) {
		 declarer.declare(new Fields(""word""));
	 }
 }",0,0,0,0
"public boolean execute(long key, double val);",0,0,0,0
"public void removeObject(Comparable rowKey, Comparable columnKey);",0,0,0,0
"protected void closeInternal(boolean success) {
	 for (PendingFile file : files.values()) file.sstable.releaseReference();
	 streams.remove(context);
 }",0,0,0,0
"public boolean isSuccess() {
	 for(Iterator<Entry<Text, Parse>> i = iterator();
	 i.hasNext();
	) {
		 Entry<Text, Parse> entry = i.next();
		 if (!entry.getValue().getData().getStatus().isSuccess()) {
			 return false;
		 }
	 }
	 return true;
 }",0,0,0,0
"public void setShortMonthNamesConfig(String shortMonthNames) {
	 if (shortMonthNames != null && !shortMonthNames.equals("""")) {
		 this.shortMonthNamesConfig = shortMonthNames;
		 configurationHasBeenSet();
	 }
 }",0,0,0,0
"public static class APIRequestGet extends APIRequest<AdCampaignActivity> {
	 AdCampaignActivity lastResponse = null;
	 public AdCampaignActivity getLastResponse() {
		 return lastResponse;
	 }
	 public static final String[] PARAMS = {
	 }
	;
	 public static final String[] FIELDS = {
	 ""auto_create_lookalike_new"", ""auto_create_lookalike_old"", ""bid_adjustments_spec_new"", ""bid_adjustments_spec_old"", ""bid_amount_new"", ""bid_amount_old"", ""bid_constraints_new"", ""bid_constraints_old"", ""bid_info_new"", ""bid_info_old"", ""bid_strategy_new"", ""bid_strategy_old"", ""bid_type_new"", ""bid_type_old"", ""billing_event_new"", ""billing_event_old"", ""brande_audience_id_new"", ""brande_audience_id_old"", ""budget_limit_new"", ""budget_limit_old"", ""created_time"", ""daily_impressions_new"", ""daily_impressions_old"", ""dco_mode_new"", ""dco_mode_old"", ""delivery_behavior_new"", ""delivery_behavior_old"", ""destination_type_new"", ""destination_type_old"", ""event_time"", ""event_type"", ""id"", ""invoicing_limit_new"", ""invoicing_limit_old"", ""min_spend_target_new"", ""min_spend_target_old"", ""name_new"", ""name_old"", ""optimization_goal_new"", ""optimization_goal_old"", ""pacing_type_new"", ""pacing_type_old"", ""run_status_new"", ""run_status_old"", ""schedule_new"", ""schedule_old"", ""spend_cap_new"", ""spend_cap_old"", ""start_time_new"", ""start_time_old"", ""stop_time_new"", ""stop_time_old"", ""targeting_expansion_new"", ""targeting_expansion_old"", ""updated_time_new"", ""updated_time_old"", }
	;
	 public AdCampaignActivity parseResponse(String response, String header) throws APIException {
		 return AdCampaignActivity.parseResponse(response, getContext(), this, header).head();
	 }
	 public AdCampaignActivity execute() throws APIException {
		 return execute(new HashMap<String, Object>());
	 }
	 public AdCampaignActivity execute(Map<String, Object> extraParams) throws APIException {
		 ResponseWrapper rw = executeInternal(extraParams);
		 lastResponse = parseResponse(rw.getBody(), rw.getHeader());
		 return lastResponse;
	 }
	 public ListenableFuture<AdCampaignActivity> executeAsync() throws APIException {
		 return executeAsync(new HashMap<String, Object>());
	 }
	;
	 public ListenableFuture<AdCampaignActivity> executeAsync(Map<String, Object> extraParams) throws APIException {
		 return Futures.transform( executeAsyncInternal(extraParams), new Function<ResponseWrapper, AdCampaignActivity>() {
			 public AdCampaignActivity apply(ResponseWrapper result) {
				 try {
					 return APIRequestGet.this.parseResponse(result.getBody(), result.getHeader());
				 }
				 catch (Exception e) {
					 throw new RuntimeException(e);
				 }
			 }
		 }
		 );
	 }
	;
	 public APIRequestGet(String nodeId, APIContext context) {
		 super(context, nodeId, ""/"", ""GET"", Arrays.asList(PARAMS));
	 }
	 public APIRequestGet setParam(String param, Object value) {
		 setParamInternal(param, value);
		 return this;
	 }
	 public APIRequestGet setParams(Map<String, Object> params) {
		 setParamsInternal(params);
		 return this;
	 }
	 public APIRequestGet requestAllFields () {
		 return this.requestAllFields(true);
	 }
	 public APIRequestGet requestAllFields (boolean value) {
		 for (String field : FIELDS) {
			 this.requestField(field, value);
		 }
		 return this;
	 }
	 public APIRequestGet requestFields (List<String> fields) {
		 return this.requestFields(fields, true);
	 }
	 public APIRequestGet requestFields (List<String> fields, boolean value) {
		 for (String field : fields) {
			 this.requestField(field, value);
		 }
		 return this;
	 }
	 public APIRequestGet requestField (String field) {
		 this.requestField(field, true);
		 return this;
	 }
	 public APIRequestGet requestField (String field, boolean value) {
		 this.requestFieldInternal(field, value);
		 return this;
	 }
	 public APIRequestGet requestAutoCreateLookalikeNewField () {
		 return this.requestAutoCreateLookalikeNewField(true);
	 }
	 public APIRequestGet requestAutoCreateLookalikeNewField (boolean value) {
		 this.requestField(""auto_create_lookalike_new"", value);
		 return this;
	 }
	 public APIRequestGet requestAutoCreateLookalikeOldField () {
		 return this.requestAutoCreateLookalikeOldField(true);
	 }
	 public APIRequestGet requestAutoCreateLookalikeOldField (boolean value) {
		 this.requestField(""auto_create_lookalike_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBidAdjustmentsSpecNewField () {
		 return this.requestBidAdjustmentsSpecNewField(true);
	 }
	 public APIRequestGet requestBidAdjustmentsSpecNewField (boolean value) {
		 this.requestField(""bid_adjustments_spec_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBidAdjustmentsSpecOldField () {
		 return this.requestBidAdjustmentsSpecOldField(true);
	 }
	 public APIRequestGet requestBidAdjustmentsSpecOldField (boolean value) {
		 this.requestField(""bid_adjustments_spec_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBidAmountNewField () {
		 return this.requestBidAmountNewField(true);
	 }
	 public APIRequestGet requestBidAmountNewField (boolean value) {
		 this.requestField(""bid_amount_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBidAmountOldField () {
		 return this.requestBidAmountOldField(true);
	 }
	 public APIRequestGet requestBidAmountOldField (boolean value) {
		 this.requestField(""bid_amount_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBidConstraintsNewField () {
		 return this.requestBidConstraintsNewField(true);
	 }
	 public APIRequestGet requestBidConstraintsNewField (boolean value) {
		 this.requestField(""bid_constraints_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBidConstraintsOldField () {
		 return this.requestBidConstraintsOldField(true);
	 }
	 public APIRequestGet requestBidConstraintsOldField (boolean value) {
		 this.requestField(""bid_constraints_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBidInfoNewField () {
		 return this.requestBidInfoNewField(true);
	 }
	 public APIRequestGet requestBidInfoNewField (boolean value) {
		 this.requestField(""bid_info_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBidInfoOldField () {
		 return this.requestBidInfoOldField(true);
	 }
	 public APIRequestGet requestBidInfoOldField (boolean value) {
		 this.requestField(""bid_info_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBidStrategyNewField () {
		 return this.requestBidStrategyNewField(true);
	 }
	 public APIRequestGet requestBidStrategyNewField (boolean value) {
		 this.requestField(""bid_strategy_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBidStrategyOldField () {
		 return this.requestBidStrategyOldField(true);
	 }
	 public APIRequestGet requestBidStrategyOldField (boolean value) {
		 this.requestField(""bid_strategy_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBidTypeNewField () {
		 return this.requestBidTypeNewField(true);
	 }
	 public APIRequestGet requestBidTypeNewField (boolean value) {
		 this.requestField(""bid_type_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBidTypeOldField () {
		 return this.requestBidTypeOldField(true);
	 }
	 public APIRequestGet requestBidTypeOldField (boolean value) {
		 this.requestField(""bid_type_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBillingEventNewField () {
		 return this.requestBillingEventNewField(true);
	 }
	 public APIRequestGet requestBillingEventNewField (boolean value) {
		 this.requestField(""billing_event_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBillingEventOldField () {
		 return this.requestBillingEventOldField(true);
	 }
	 public APIRequestGet requestBillingEventOldField (boolean value) {
		 this.requestField(""billing_event_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBrandeAudienceIdNewField () {
		 return this.requestBrandeAudienceIdNewField(true);
	 }
	 public APIRequestGet requestBrandeAudienceIdNewField (boolean value) {
		 this.requestField(""brande_audience_id_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBrandeAudienceIdOldField () {
		 return this.requestBrandeAudienceIdOldField(true);
	 }
	 public APIRequestGet requestBrandeAudienceIdOldField (boolean value) {
		 this.requestField(""brande_audience_id_old"", value);
		 return this;
	 }
	 public APIRequestGet requestBudgetLimitNewField () {
		 return this.requestBudgetLimitNewField(true);
	 }
	 public APIRequestGet requestBudgetLimitNewField (boolean value) {
		 this.requestField(""budget_limit_new"", value);
		 return this;
	 }
	 public APIRequestGet requestBudgetLimitOldField () {
		 return this.requestBudgetLimitOldField(true);
	 }
	 public APIRequestGet requestBudgetLimitOldField (boolean value) {
		 this.requestField(""budget_limit_old"", value);
		 return this;
	 }
	 public APIRequestGet requestCreatedTimeField () {
		 return this.requestCreatedTimeField(true);
	 }
	 public APIRequestGet requestCreatedTimeField (boolean value) {
		 this.requestField(""created_time"", value);
		 return this;
	 }
	 public APIRequestGet requestDailyImpressionsNewField () {
		 return this.requestDailyImpressionsNewField(true);
	 }
	 public APIRequestGet requestDailyImpressionsNewField (boolean value) {
		 this.requestField(""daily_impressions_new"", value);
		 return this;
	 }
	 public APIRequestGet requestDailyImpressionsOldField () {
		 return this.requestDailyImpressionsOldField(true);
	 }
	 public APIRequestGet requestDailyImpressionsOldField (boolean value) {
		 this.requestField(""daily_impressions_old"", value);
		 return this;
	 }
	 public APIRequestGet requestDcoModeNewField () {
		 return this.requestDcoModeNewField(true);
	 }
	 public APIRequestGet requestDcoModeNewField (boolean value) {
		 this.requestField(""dco_mode_new"", value);
		 return this;
	 }
	 public APIRequestGet requestDcoModeOldField () {
		 return this.requestDcoModeOldField(true);
	 }
	 public APIRequestGet requestDcoModeOldField (boolean value) {
		 this.requestField(""dco_mode_old"", value);
		 return this;
	 }
	 public APIRequestGet requestDeliveryBehaviorNewField () {
		 return this.requestDeliveryBehaviorNewField(true);
	 }
	 public APIRequestGet requestDeliveryBehaviorNewField (boolean value) {
		 this.requestField(""delivery_behavior_new"", value);
		 return this;
	 }
	 public APIRequestGet requestDeliveryBehaviorOldField () {
		 return this.requestDeliveryBehaviorOldField(true);
	 }
	 public APIRequestGet requestDeliveryBehaviorOldField (boolean value) {
		 this.requestField(""delivery_behavior_old"", value);
		 return this;
	 }
	 public APIRequestGet requestDestinationTypeNewField () {
		 return this.requestDestinationTypeNewField(true);
	 }
	 public APIRequestGet requestDestinationTypeNewField (boolean value) {
		 this.requestField(""destination_type_new"", value);
		 return this;
	 }
	 public APIRequestGet requestDestinationTypeOldField () {
		 return this.requestDestinationTypeOldField(true);
	 }
	 public APIRequestGet requestDestinationTypeOldField (boolean value) {
		 this.requestField(""destination_type_old"", value);
		 return this;
	 }
	 public APIRequestGet requestEventTimeField () {
		 return this.requestEventTimeField(true);
	 }
	 public APIRequestGet requestEventTimeField (boolean value) {
		 this.requestField(""event_time"", value);
		 return this;
	 }
	 public APIRequestGet requestEventTypeField () {
		 return this.requestEventTypeField(true);
	 }
	 public APIRequestGet requestEventTypeField (boolean value) {
		 this.requestField(""event_type"", value);
		 return this;
	 }
	 public APIRequestGet requestIdField () {
		 return this.requestIdField(true);
	 }
	 public APIRequestGet requestIdField (boolean value) {
		 this.requestField(""id"", value);
		 return this;
	 }
	 public APIRequestGet requestInvoicingLimitNewField () {
		 return this.requestInvoicingLimitNewField(true);
	 }
	 public APIRequestGet requestInvoicingLimitNewField (boolean value) {
		 this.requestField(""invoicing_limit_new"", value);
		 return this;
	 }
	 public APIRequestGet requestInvoicingLimitOldField () {
		 return this.requestInvoicingLimitOldField(true);
	 }
	 public APIRequestGet requestInvoicingLimitOldField (boolean value) {
		 this.requestField(""invoicing_limit_old"", value);
		 return this;
	 }
	 public APIRequestGet requestMinSpendTargetNewField () {
		 return this.requestMinSpendTargetNewField(true);
	 }
	 public APIRequestGet requestMinSpendTargetNewField (boolean value) {
		 this.requestField(""min_spend_target_new"", value);
		 return this;
	 }
	 public APIRequestGet requestMinSpendTargetOldField () {
		 return this.requestMinSpendTargetOldField(true);
	 }
	 public APIRequestGet requestMinSpendTargetOldField (boolean value) {
		 this.requestField(""min_spend_target_old"", value);
		 return this;
	 }
	 public APIRequestGet requestNameNewField () {
		 return this.requestNameNewField(true);
	 }
	 public APIRequestGet requestNameNewField (boolean value) {
		 this.requestField(""name_new"", value);
		 return this;
	 }
	 public APIRequestGet requestNameOldField () {
		 return this.requestNameOldField(true);
	 }
	 public APIRequestGet requestNameOldField (boolean value) {
		 this.requestField(""name_old"", value);
		 return this;
	 }
	 public APIRequestGet requestOptimizationGoalNewField () {
		 return this.requestOptimizationGoalNewField(true);
	 }
	 public APIRequestGet requestOptimizationGoalNewField (boolean value) {
		 this.requestField(""optimization_goal_new"", value);
		 return this;
	 }
	 public APIRequestGet requestOptimizationGoalOldField () {
		 return this.requestOptimizationGoalOldField(true);
	 }
	 public APIRequestGet requestOptimizationGoalOldField (boolean value) {
		 this.requestField(""optimization_goal_old"", value);
		 return this;
	 }
	 public APIRequestGet requestPacingTypeNewField () {
		 return this.requestPacingTypeNewField(true);
	 }
	 public APIRequestGet requestPacingTypeNewField (boolean value) {
		 this.requestField(""pacing_type_new"", value);
		 return this;
	 }
	 public APIRequestGet requestPacingTypeOldField () {
		 return this.requestPacingTypeOldField(true);
	 }
	 public APIRequestGet requestPacingTypeOldField (boolean value) {
		 this.requestField(""pacing_type_old"", value);
		 return this;
	 }
	 public APIRequestGet requestRunStatusNewField () {
		 return this.requestRunStatusNewField(true);
	 }
	 public APIRequestGet requestRunStatusNewField (boolean value) {
		 this.requestField(""run_status_new"", value);
		 return this;
	 }
	 public APIRequestGet requestRunStatusOldField () {
		 return this.requestRunStatusOldField(true);
	 }
	 public APIRequestGet requestRunStatusOldField (boolean value) {
		 this.requestField(""run_status_old"", value);
		 return this;
	 }
	 public APIRequestGet requestScheduleNewField () {
		 return this.requestScheduleNewField(true);
	 }
	 public APIRequestGet requestScheduleNewField (boolean value) {
		 this.requestField(""schedule_new"", value);
		 return this;
	 }
	 public APIRequestGet requestScheduleOldField () {
		 return this.requestScheduleOldField(true);
	 }
	 public APIRequestGet requestScheduleOldField (boolean value) {
		 this.requestField(""schedule_old"", value);
		 return this;
	 }
	 public APIRequestGet requestSpendCapNewField () {
		 return this.requestSpendCapNewField(true);
	 }
	 public APIRequestGet requestSpendCapNewField (boolean value) {
		 this.requestField(""spend_cap_new"", value);
		 return this;
	 }
	 public APIRequestGet requestSpendCapOldField () {
		 return this.requestSpendCapOldField(true);
	 }
	 public APIRequestGet requestSpendCapOldField (boolean value) {
		 this.requestField(""spend_cap_old"", value);
		 return this;
	 }
	 public APIRequestGet requestStartTimeNewField () {
		 return this.requestStartTimeNewField(true);
	 }
	 public APIRequestGet requestStartTimeNewField (boolean value) {
		 this.requestField(""start_time_new"", value);
		 return this;
	 }
	 public APIRequestGet requestStartTimeOldField () {
		 return this.requestStartTimeOldField(true);
	 }
	 public APIRequestGet requestStartTimeOldField (boolean value) {
		 this.requestField(""start_time_old"", value);
		 return this;
	 }
	 public APIRequestGet requestStopTimeNewField () {
		 return this.requestStopTimeNewField(true);
	 }
	 public APIRequestGet requestStopTimeNewField (boolean value) {
		 this.requestField(""stop_time_new"", value);
		 return this;
	 }
	 public APIRequestGet requestStopTimeOldField () {
		 return this.requestStopTimeOldField(true);
	 }
	 public APIRequestGet requestStopTimeOldField (boolean value) {
		 this.requestField(""stop_time_old"", value);
		 return this;
	 }
	 public APIRequestGet requestTargetingExpansionNewField () {
		 return this.requestTargetingExpansionNewField(true);
	 }
	 public APIRequestGet requestTargetingExpansionNewField (boolean value) {
		 this.requestField(""targeting_expansion_new"", value);
		 return this;
	 }
	 public APIRequestGet requestTargetingExpansionOldField () {
		 return this.requestTargetingExpansionOldField(true);
	 }
	 public APIRequestGet requestTargetingExpansionOldField (boolean value) {
		 this.requestField(""targeting_expansion_old"", value);
		 return this;
	 }
	 public APIRequestGet requestUpdatedTimeNewField () {
		 return this.requestUpdatedTimeNewField(true);
	 }
	 public APIRequestGet requestUpdatedTimeNewField (boolean value) {
		 this.requestField(""updated_time_new"", value);
		 return this;
	 }
	 public APIRequestGet requestUpdatedTimeOldField () {
		 return this.requestUpdatedTimeOldField(true);
	 }
	 public APIRequestGet requestUpdatedTimeOldField (boolean value) {
		 this.requestField(""updated_time_old"", value);
		 return this;
	 }
 }",1,1,0,0
"public class IssueCommentsFeed extends BaseFeed<IssueCommentsFeed, IssueCommentsEntry> {
	 public IssueCommentsFeed() {
		 super(IssueCommentsEntry.class);
	 }
	 public IssueCommentsFeed(BaseFeed<?, ?> sourceFeed) {
		 super(IssueCommentsEntry.class, sourceFeed);
	 }
	 public void declareExtensions(ExtensionProfile extProfile) {
		 if (extProfile.isDeclared(IssueCommentsFeed.class)) {
			 return;
		 }
		 super.declareExtensions(extProfile);
		 extProfile.declare(IssueCommentsFeed.class, IssuesLink.getDefaultDescription(true, true));
	 }
	 public String toString() {
		 return ""{
		IssueCommentsFeed "" + super.toString() + ""}
		"";
	 }
}",0,0,0,0
"public String toString() {
	 return ""String Constant Pool Entry for "" + getValue() + ""["" + index + ""]"";
 }",0,0,0,0
"public interface IAopReferenceModel {
	void start();
	void shutdown();
	void removeProject(IJavaProject project);
	void addProject(IJavaProject project, IAopProject aopProject);
	void fireModelChanged();
	List<IAopReference> getAdviceDefinition(IJavaElement je);
	List<IAopReference> getAllReferences();
	List<IAopReference> getAllReferencesForResource(IResource resource);
	IAopProject getProject(IJavaProject project);
	Collection<IAopProject> getProjects();
	boolean isAdvice(IJavaElement je);
	boolean isAdvised(IJavaElement je);
	boolean isAdvised(IBean bean);
	void registerAopModelChangedListener(IAopModelChangedListener listener);
	void unregisterAopModelChangedListener(IAopModelChangedListener listener);
	void clearProjects();
}",1,1,0,0
"private synchronized Map getResourceBundleEntries(final Bundle bundle) {
	 String file = (String) bundle.getHeaders().get(Constants.BUNDLE_LOCALIZATION);
	 if (file == null) {
		 file = Constants.BUNDLE_LOCALIZATION_DEFAULT_BASENAME;
	 }
	 if (file.startsWith(""/"")) {
		 file = file.substring(1);
	 }
	 int slash = file.lastIndexOf('/');
	 String fileName = file.substring(slash + 1);
	 String path = (slash <= 0) ? ""/"" : file.substring(0, slash);
	 HashMap resourceBundleEntries = new HashMap();
	 Enumeration locales = bundle.findEntries(path, fileName + ""*.properties"", false);
	 if (locales != null) {
		 while (locales.hasMoreElements()) {
			 URL entry = (URL) locales.nextElement();
			 String entryPath = entry.getPath();
			 final int start = entryPath.lastIndexOf('/') + 1 + fileName.length();
			 final int end = entryPath.length() - 11;
			 entryPath = entryPath.substring(start, end);
			 if (entryPath.length() == 0) {
				 entryPath = ""_"" + DEFAULT_LOCALE;
			 }
			 if (!resourceBundleEntries.containsKey(entryPath)) {
				 resourceBundleEntries.put(entryPath, entry);
			 }
		 }
	 }
	 return resourceBundleEntries;
 }",0,0,1,0
"public abstract class QueryObjectModelFactoryImpl implements QueryObjectModelFactory {
	 private final NamePathResolver resolver;
	 public QueryObjectModelFactoryImpl(NamePathResolver resolver) {
		 this.resolver = resolver;
	 }
	 protected abstract QueryObjectModel createQuery(QueryObjectModelTree qomTree) throws InvalidQueryException, RepositoryException;
	 public QueryObjectModel createQuery (Selector selector, Constraint constraint, Ordering[] orderings, Column[] columns) throws InvalidQueryException, RepositoryException {
		 return createQuery((Source) selector, constraint, orderings, columns);
	 }
	 public QueryObjectModel createQuery(Source source, Constraint constraint, Ordering[] orderings, Column[] columns) throws InvalidQueryException, RepositoryException {
		 if (source == null) {
			 throw new InvalidQueryException(""source must not be null"");
		 }
		 if (!(source instanceof SourceImpl)) {
			 throw new RepositoryException(""Unknown Source implementation"");
		 }
		 if (constraint != null && !(constraint instanceof ConstraintImpl)) {
			 throw new RepositoryException(""Unknown Constraint implementation"");
		 }
		 OrderingImpl[] ords;
		 if (orderings != null) {
			 ords = new OrderingImpl[orderings.length];
			 for (int i = 0;
			 i < orderings.length;
			 i++) {
				 if (!(orderings[i] instanceof OrderingImpl)) {
					 throw new RepositoryException(""Unknown Ordering implementation"");
				 }
				 ords[i] = (OrderingImpl) orderings[i];
			 }
		 }
		 else {
			 ords = OrderingImpl.EMPTY_ARRAY;
		 }
		 ColumnImpl[] cols;
		 if (columns != null) {
			 cols = new ColumnImpl[columns.length];
			 for (int i = 0;
			 i < columns.length;
			 i++) {
				 if (!(columns[i] instanceof ColumnImpl)) {
					 throw new RepositoryException(""Unknown Column implementation"");
				 }
				 cols[i] = (ColumnImpl) columns[i];
			 }
		 }
		 else {
			 cols = ColumnImpl.EMPTY_ARRAY;
		 }
		 QueryObjectModelTree qomTree = new QueryObjectModelTree( resolver, (SourceImpl) source, (ConstraintImpl) constraint, ords, cols);
		 return createQuery(qomTree);
	 }
	 public Selector selector(String nodeTypeName) throws InvalidQueryException, RepositoryException {
		 Name ntName = checkNodeTypeName(nodeTypeName);
		 return new SelectorImpl(resolver, ntName, ntName);
	 }
	 public Selector selector(String nodeTypeName, String selectorName) throws InvalidQueryException, RepositoryException {
		 return new SelectorImpl(resolver, checkNodeTypeName(nodeTypeName), checkSelectorName(selectorName));
	 }
	 public Join join(Source left, Source right, String joinTypeName, JoinCondition joinCondition) throws InvalidQueryException, RepositoryException {
		 if (!(left instanceof SourceImpl) || !(right instanceof SourceImpl)) {
			 throw new RepositoryException(""Unknown Source implementation"");
		 }
		 if (!(joinCondition instanceof JoinConditionImpl)) {
			 throw new RepositoryException(""Unknown JoinCondition implementation"");
		 }
		 return new JoinImpl( resolver, (SourceImpl) left, (SourceImpl) right, JoinType.getJoinTypeByName(joinTypeName), (JoinConditionImpl) joinCondition);
	 }
	 public EquiJoinCondition equiJoinCondition(String selector1Name, String property1Name, String selector2Name, String property2Name) throws InvalidQueryException, RepositoryException {
		 return new EquiJoinConditionImpl(resolver, checkSelectorName(selector1Name), checkPropertyName(property1Name), checkSelectorName(selector2Name), checkPropertyName(property2Name));
	 }
	 public SameNodeJoinCondition sameNodeJoinCondition(String selector1Name, String selector2Name) throws InvalidQueryException, RepositoryException {
		 return new SameNodeJoinConditionImpl(resolver, checkSelectorName(selector1Name), checkSelectorName(selector2Name), null);
	 }
	 public SameNodeJoinCondition sameNodeJoinCondition(String selector1Name, String selector2Name, String selector2Path) throws InvalidQueryException, RepositoryException {
		 return new SameNodeJoinConditionImpl(resolver, checkSelectorName(selector1Name), checkSelectorName(selector2Name), checkPath(selector2Path));
	 }
	 public ChildNodeJoinCondition childNodeJoinCondition( String childSelectorName, String parentSelectorName) throws InvalidQueryException, RepositoryException {
		 return new ChildNodeJoinConditionImpl(resolver, checkSelectorName(childSelectorName), checkSelectorName(parentSelectorName));
	 }
	 public DescendantNodeJoinCondition descendantNodeJoinCondition( String descendantSelectorName, String ancestorSelectorName) throws InvalidQueryException, RepositoryException {
		 return new DescendantNodeJoinConditionImpl(resolver, checkSelectorName(descendantSelectorName), checkSelectorName(ancestorSelectorName));
	 }
	 public And and(Constraint constraint1, Constraint constraint2) throws InvalidQueryException, RepositoryException {
		 if (constraint1 == null || constraint2 == null) {
			 throw new InvalidQueryException(""Constraints must not be null"");
		 }
		 if (constraint1 instanceof ConstraintImpl && constraint2 instanceof ConstraintImpl) {
			 return new AndImpl(resolver, (ConstraintImpl) constraint1, (ConstraintImpl) constraint2);
		 }
		 else {
			 throw new RepositoryException(""Unknown constraint implementation"");
		 }
	 }
	 public Or or(Constraint constraint1, Constraint constraint2) throws InvalidQueryException, RepositoryException {
		 if (constraint1 == null || constraint2 == null) {
			 throw new InvalidQueryException(""Constraints must not be null"");
		 }
		 if (constraint1 instanceof ConstraintImpl && constraint2 instanceof ConstraintImpl) {
			 return new OrImpl(resolver, (ConstraintImpl) constraint1, (ConstraintImpl) constraint2);
		 }
		 else {
			 throw new RepositoryException(""Unknown constraint implementation"");
		 }
	 }
	 public Not not(Constraint constraint) throws InvalidQueryException, RepositoryException {
		 if (!(constraint instanceof ConstraintImpl)) {
			 throw new RepositoryException(""Unknown Constraint implementation"");
		 }
		 return new NotImpl(resolver, (ConstraintImpl) constraint);
	 }
	 public Comparison comparison( DynamicOperand left, String operatorName, StaticOperand right) throws InvalidQueryException, RepositoryException {
		 if (!(left instanceof DynamicOperandImpl)) {
			 throw new RepositoryException(""Invalid left operand: "" + left);
		 }
		 if (!(right instanceof StaticOperandImpl)) {
			 throw new RepositoryException(""Invalid right operand: "" + right);
		 }
		 return new ComparisonImpl( resolver, (DynamicOperandImpl) left, Operator.getOperatorByName(operatorName), (StaticOperandImpl) right);
	 }
	 public PropertyExistence propertyExistence(String propertyName) throws InvalidQueryException, RepositoryException {
		 return new PropertyExistenceImpl( resolver, null, checkPropertyName(propertyName));
	 }
	 public PropertyExistence propertyExistence(String selectorName, String propertyName) throws InvalidQueryException, RepositoryException {
		 return new PropertyExistenceImpl(resolver, checkSelectorName(selectorName), checkPropertyName(propertyName));
	 }
	 public FullTextSearch fullTextSearch(String propertyName, StaticOperand fullTextSearchExpression) throws InvalidQueryException, RepositoryException {
		 Name propName = null;
		 if (propertyName != null) {
			 propName = checkPropertyName(propertyName);
		 }
		 return new FullTextSearchImpl(resolver, null, propName, checkFullTextSearchExpression(fullTextSearchExpression));
	 }
	 public FullTextSearch fullTextSearch(String selectorName, String propertyName, StaticOperand fullTextSearchExpression) throws InvalidQueryException, RepositoryException {
		 if (fullTextSearchExpression == null) {
			 throw new IllegalArgumentException( ""Full text search expression is null"");
		 }
		 Name propName = null;
		 if (propertyName != null) {
			 propName = checkPropertyName(propertyName);
		 }
		 return new FullTextSearchImpl(resolver, checkSelectorName(selectorName), propName, checkFullTextSearchExpression(fullTextSearchExpression));
	 }
	 public SameNode sameNode(String path) throws InvalidQueryException, RepositoryException {
		 return new SameNodeImpl(resolver, null, checkPath(path));
	 }
	 public SameNode sameNode(String selectorName, String path) throws InvalidQueryException, RepositoryException {
		 return new SameNodeImpl( resolver, checkSelectorName(selectorName), checkPath(path));
	 }
	 public ChildNode childNode(String path) throws InvalidQueryException, RepositoryException {
		 return new ChildNodeImpl(resolver, null, checkPath(path));
	 }
	 public ChildNode childNode(String selectorName, String path) throws InvalidQueryException, RepositoryException {
		 return new ChildNodeImpl( resolver, checkSelectorName(selectorName), checkPath(path));
	 }
	 public DescendantNode descendantNode(String path) throws InvalidQueryException, RepositoryException {
		 return new DescendantNodeImpl(resolver, null, checkPath(path));
	 }
	 public DescendantNode descendantNode(String selectorName, String path) throws InvalidQueryException, RepositoryException {
		 return new DescendantNodeImpl(resolver, checkSelectorName(selectorName), checkPath(path));
	 }
	 public PropertyValue propertyValue(String propertyName) throws InvalidQueryException, RepositoryException {
		 return new PropertyValueImpl(resolver, null, checkPropertyName(propertyName));
	 }
	 public PropertyValue propertyValue(String selectorName, String propertyName) throws InvalidQueryException, RepositoryException {
		 return new PropertyValueImpl(resolver, checkSelectorName(selectorName), checkPropertyName(propertyName));
	 }
	 public Length length(PropertyValue propertyValue) throws InvalidQueryException, RepositoryException {
		 if (!(propertyValue instanceof PropertyValueImpl)) {
			 throw new RepositoryException(""Unknown PropertyValue implementation"");
		 }
		 return new LengthImpl(resolver, (PropertyValueImpl) propertyValue);
	 }
	 public NodeName nodeName() throws InvalidQueryException, RepositoryException {
		 return new NodeNameImpl(resolver, null);
	 }
	 public NodeName nodeName(String selectorName) throws InvalidQueryException, RepositoryException {
		 return new NodeNameImpl(resolver, checkSelectorName(selectorName));
	 }
	 public NodeLocalName nodeLocalName() throws InvalidQueryException, RepositoryException {
		 return new NodeLocalNameImpl(resolver, null);
	 }
	 public NodeLocalName nodeLocalName(String selectorName) throws InvalidQueryException, RepositoryException {
		 return new NodeLocalNameImpl(resolver, checkSelectorName(selectorName));
	 }
	 public FullTextSearchScore fullTextSearchScore() throws InvalidQueryException, RepositoryException {
		 return new FullTextSearchScoreImpl(resolver, null);
	 }
	 public FullTextSearchScore fullTextSearchScore(String selectorName) throws InvalidQueryException, RepositoryException {
		 return new FullTextSearchScoreImpl( resolver, checkSelectorName(selectorName));
	 }
	 public LowerCase lowerCase(DynamicOperand operand) throws InvalidQueryException, RepositoryException {
		 if (!(operand instanceof DynamicOperandImpl)) {
			 throw new RepositoryException(""Unknown DynamicOperand implementation"");
		 }
		 return new LowerCaseImpl(resolver, (DynamicOperandImpl) operand);
	 }
	 public UpperCase upperCase(DynamicOperand operand) throws InvalidQueryException, RepositoryException {
		 if (!(operand instanceof DynamicOperandImpl)) {
			 throw new RepositoryException(""Unknown DynamicOperand implementation"");
		 }
		 return new UpperCaseImpl(resolver, (DynamicOperandImpl) operand);
	 }
	 public BindVariableValue bindVariable(String bindVariableName) throws InvalidQueryException, RepositoryException {
		 if (bindVariableName == null) {
			 throw new InvalidQueryException(""bindVariableName must not be null"");
		 }
		 try {
			 return new BindVariableValueImpl( resolver, resolver.getQName(bindVariableName));
		 }
		 catch (NameException e) {
			 throw new InvalidQueryException(e.getMessage());
		 }
	 }
	 public Literal literal(Value value) throws InvalidQueryException, RepositoryException {
		 if (value == null) {
			 throw new InvalidQueryException(""value must not be null"");
		 }
		 return new LiteralImpl(resolver, value);
	 }
	 public Ordering ascending(DynamicOperand operand) throws InvalidQueryException, RepositoryException {
		 if (!(operand instanceof DynamicOperandImpl)) {
			 throw new RepositoryException(""Unknown DynamicOperand implementation"");
		 }
		 return new OrderingImpl(resolver, (DynamicOperandImpl) operand, QueryObjectModelConstants.JCR_ORDER_ASCENDING);
	 }
	 public Ordering descending(DynamicOperand operand) throws InvalidQueryException, RepositoryException {
		 if (!(operand instanceof DynamicOperandImpl)) {
			 throw new RepositoryException(""Unknown DynamicOperand implementation"");
		 }
		 return new OrderingImpl(resolver, (DynamicOperandImpl) operand, QueryObjectModelConstants.JCR_ORDER_DESCENDING);
	 }
	 public Column column(String propertyName) throws InvalidQueryException, RepositoryException {
		 Name propName = null;
		 if (propertyName != null) {
			 try {
				 propName = resolver.getQName(propertyName);
			 }
			 catch (NameException e) {
				 throw new InvalidQueryException(e.getMessage());
			 }
		 }
		 return new ColumnImpl(resolver, null, propName, propertyName);
	 }
	 public Column column(String propertyName, String columnName) throws InvalidQueryException, RepositoryException {
		 if (propertyName == null && columnName != null) {
			 throw new InvalidQueryException( ""columnName must be null if propertyName is null"");
		 }
		 Name propName = null;
		 if (propertyName != null) {
			 try {
				 propName = resolver.getQName(propertyName);
			 }
			 catch (NameException e) {
				 throw new InvalidQueryException(e.getMessage());
			 }
		 }
		 return new ColumnImpl(resolver, null, propName, columnName);
	 }
	 public Column column(String selectorName, String propertyName, String columnName) throws InvalidQueryException, RepositoryException {
		 if (propertyName == null && columnName != null) {
			 throw new InvalidQueryException( ""columnName must be null if propertyName is null"");
		 }
		 Name propName = null;
		 if (propertyName != null) {
			 try {
				 propName = resolver.getQName(propertyName);
			 }
			 catch (NameException e) {
				 throw new InvalidQueryException(e.getMessage());
			 }
		 }
		 return new ColumnImpl(resolver, checkSelectorName(selectorName), propName, columnName);
	 }
	 private Name checkSelectorName(String selectorName) throws RepositoryException {
		 if (selectorName == null) {
			 throw new InvalidQueryException(""selectorName must not be null"");
		 }
		 try {
			 return resolver.getQName(selectorName);
		 }
		 catch (NameException e) {
			 throw new InvalidQueryException(e.getMessage());
		 }
	 }
	 private Name checkNodeTypeName(String nodeTypeName) throws RepositoryException {
		 if (nodeTypeName == null) {
			 throw new InvalidQueryException(""nodeTypeName must not be null"");
		 }
		 try {
			 return resolver.getQName(nodeTypeName);
		 }
		 catch (NameException e) {
			 throw new InvalidQueryException(e.getMessage());
		 }
	 }
	 private Path checkPath(String path) throws RepositoryException {
		 if (path == null) {
			 throw new InvalidQueryException(""path must not be null"");
		 }
		 try {
			 return resolver.getQPath(path);
		 }
		 catch (NameException e) {
			 throw new InvalidQueryException(e.getMessage());
		 }
	 }
	 private Name checkPropertyName(String propertyName) throws RepositoryException {
		 if (propertyName == null) {
			 throw new InvalidQueryException(""propertyName must not be null"");
		 }
		 try {
			 return resolver.getQName(propertyName);
		 }
		 catch (NameException e) {
			 throw new InvalidQueryException(e.getMessage());
		 }
	 }
	 private StaticOperand checkFullTextSearchExpression(StaticOperand fullTextSearchExpression) throws RepositoryException {
		 if (fullTextSearchExpression == null) {
			 throw new InvalidQueryException( ""fullTextSearchExpression must not be null"");
		 }
		 return fullTextSearchExpression;
	 }
}",1,0,0,0
"public class LogFormatter extends Formatter {
	 private static final String FORMAT = ""yyMMdd HHmmss"";
	 private static final String NEWLINE = System.getProperty(""line.separator"");
	 private final Date date = new Date();
	 private final SimpleDateFormat formatter = new SimpleDateFormat(FORMAT);
	 private static boolean loggedSevere= false;
	 private static boolean showTime = true;
	 private static boolean showThreadIDs = false;
	 static {
		 Handler[] handlers = LogFormatter.getLogger("""").getHandlers();
		 for (int i = 0;
		 i < handlers.length;
		 i++) {
			 handlers[i].setFormatter(new LogFormatter());
			 handlers[i].setLevel(Level.FINEST);
		 }
	 }
	 public static String initFileHandler( Configuration conf, String opName ) throws IOException {
		 String logDir=System.getProperty(""hadoop.log.dir"");
		 String userHome=System.getProperty(""user.dir"");
		 if( logDir==null ) {
			 logDir=System.getProperty(""hadoop.home.dir"");
			 if(logDir==null) {
				 logDir=userHome;
			 }
			 else {
				 logDir+=File.separator+""logs"";
			 }
		 }
		 if(!logDir.equals(userHome)) {
			 File logDirFile = new File( logDir );
			 if(!logDirFile.exists()) {
				 if(!logDirFile.mkdirs()) {
					 logDir=userHome;
				 }
			 }
			 else if( !logDirFile.isDirectory()) {
				 logDir=userHome;
			 }
		 }
		 String hostname;
		 try {
			 hostname=InetAddress.getLocalHost().getHostName();
			 int index=hostname.indexOf('.');
			 if( index != -1 ) {
				 hostname=hostname.substring(0, index);
			 }
		 }
		 catch (java.net.UnknownHostException e) {
			 hostname=""localhost"";
		 }
		 String id = System.getProperty( ""hadoop.id.str"", System.getProperty(""user.name"") );
		 String logFile = logDir+File.separator+""hadoop-""+id +""-""+opName+""-""+hostname+"".log"";
		 int logFileSize = conf.getInt( ""hadoop.logfile.size"", 10000000 );
		 int logFileCount = conf.getInt( ""hadoop.logfile.count"", 10 );
		 FileHandler fh=new FileHandler(logFile, logFileSize, logFileCount, false);
		 fh.setFormatter(new LogFormatter());
		 fh.setLevel(Level.FINEST);
		 Logger rootLogger = LogFormatter.getLogger("""");
		 rootLogger.info( ""directing logs to directory ""+logDir );
		 Handler[] handlers = rootLogger.getHandlers();
		 for( int i=0;
		 i<handlers.length;
		 i++ ) {
			 rootLogger.removeHandler( handlers[i]);
		 }
		 rootLogger.addHandler(fh);
		 return logFile;
	 }
	 public static Logger getLogger(String name) {
		 return Logger.getLogger(name);
	 }
	 public static void showTime(boolean showTime) {
		 LogFormatter.showTime = showTime;
	 }
	 public static void setShowThreadIDs(boolean showThreadIDs) {
		 LogFormatter.showThreadIDs = showThreadIDs;
	 }
	 public synchronized String format(LogRecord record) {
		 StringBuffer buffer = new StringBuffer();
		 if (showTime) {
			 date.setTime(record.getMillis());
			 formatter.format(date, buffer, new FieldPosition(0));
		 }
		 if (showThreadIDs) {
			 buffer.append("" 0x"");
			 String threadID = Integer.toHexString(record.getThreadID());
			 for (int i = 0;
			 i < 8 - threadID.length();
			 i++) buffer.append('0');
			 buffer.append(threadID);
		 }
		 if (record.getLevel() == Level.SEVERE) {
			 buffer.append("" SEVERE"");
			 loggedSevere= true;
		 }
		 buffer.append("" "");
		 buffer.append(formatMessage(record));
		 buffer.append(NEWLINE);
		 if (record.getThrown() != null) {
			 try {
				 StringWriter sw = new StringWriter();
				 PrintWriter pw = new PrintWriter(sw);
				 record.getThrown().printStackTrace(pw);
				 pw.close();
				 buffer.append(sw.toString());
			 }
			 catch (Exception ex) {
			 }
		 }
		 return buffer.toString();
	 }
	 public static boolean hasLoggedSevere() {
		 return loggedSevere;
	 }
	 public static PrintStream getLogStream(final Logger logger, final Level level) {
		 return new PrintStream(new ByteArrayOutputStream() {
			 private int scan = 0;
			 private boolean hasNewline() {
				 for (;
				 scan < count;
				 scan++) {
					 if (buf[scan] == '\n') return true;
				 }
				 return false;
			 }
			 public void flush() throws IOException {
				 if (!hasNewline()) return;
				 logger.log(level, toString().trim());
				 reset();
				 scan = 0;
			 }
		 }
		, true);
	 }
}",0,0,0,0
"static void print(PrintStream out, String msg, String classname, String method_name);",0,0,0,1
"public int run(String[] args) throws Exception {
	 if (args.length < 2) {
		 System.err.println(""Usage: LinkDbReader <linkdb> (-dump <out_dir> | -url <url>)"");
		 System.err.println(""\t-dump <out_dir>\tdump whole link db to a text file in <out_dir>"");
		 System.err.println(""\t-url <url>\tprint information about <url> to System.out"");
		 return -1;
	 }
	 try {
		 if (args[1].equals(""-dump"")) {
			 processDumpJob(args[0], args[2]);
			 return 0;
		 }
		 else if (args[1].equals(""-url"")) {
			 init(new Path(args[0]));
			 Inlinks links = getInlinks(new Text(args[2]));
			 if (links == null) {
				 System.out.println("" - no link information."");
			 }
			 else {
				 Iterator<Inlink> it = links.iterator();
				 while (it.hasNext()) {
					 System.out.println(it.next().toString());
				 }
			 }
			 return 0;
		 }
		 else {
			 System.err.println(""Error: wrong argument "" + args[1]);
			 return -1;
		 }
	 }
	 catch (Exception e) {
		 LOG.error(""LinkDbReader: "" + StringUtils.stringifyException(e));
		 return -1;
	 }
 }",0,0,0,0
"public static class HFileFilter extends AbstractFileStatusFilter {
	 final FileSystem fs;
	 public HFileFilter(FileSystem fs) {
		 this.fs = fs;
	 }
	 protected boolean accept(Path p, Boolean isDir) {
		 if (!StoreFileInfo.isHFile(p)) {
			 return false;
		 }
		 try {
			 return isFile(fs, isDir, p);
		 }
		 catch (IOException ioe) {
			 LOG.warn(""Skipping file "" + p +"" due to IOException"", ioe);
			 return false;
		 }
	 }
 }",0,0,0,0
"public Attribute_Code(int attrLength, int max_stack, int max_locals, int code_length, Opcode[] codes, int exception_table_length,ExceptionTableItem[] exception_Table, int attributes_count, Attribute[] attributes);",0,0,0,1
")public class Trigger extends JPAEntity implements Serializable {
	public static class Serializer extends JsonSerializer<Trigger> {
		public void serialize(Trigger trigger, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			jgen.writeStringField(""id"", trigger.getId().toString());
			jgen.writeStringField(""name"", trigger.getName());
			jgen.writeStringField(""type"", trigger.getType().name());
			jgen.writeNumberField(""threshold"", trigger.getThreshold().doubleValue());
			if(trigger.getSecondaryThreshold() != null) {
				jgen.writeNumberField(""secondaryThreshold"", trigger.getSecondaryThreshold());
			}
			if(trigger.getInertia() != null) {
				jgen.writeNumberField(""inertia"", trigger.getInertia());
			}
			jgen.writeEndObject();
		}
	}
	public static class Deserializer extends JsonDeserializer<Trigger> {
		public Trigger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
			Trigger trigger = new Trigger();
			JsonNode rootNode = jp.getCodec().readTree(jp);
			BigInteger id = new BigInteger(rootNode.get(""id"").asText());
			trigger.id = id;
			String name = rootNode.get(""name"").asText();
			trigger.setName(name);
			TriggerType type = TriggerType.fromString(rootNode.get(""type"").asText());
			trigger.setType(type);
			Double threshold = rootNode.get(""threshold"").asDouble();
			trigger.setThreshold(threshold);
			if(rootNode.get(""secondaryThreshold"") != null) {
				trigger.setSecondaryThreshold(rootNode.get(""secondaryThreshold"").asDouble());
			}
			if(rootNode.get(""inertia"") != null) {
				trigger.setInertia(rootNode.get(""inertia"").asLong());
			}
			return trigger;
		}
	}
	 private TriggerType type;
	 private String name;
	 private Double threshold;
	 private Double secondaryThreshold;
	 private Long inertia;
	 private Alert alert;
	 private List<Notification> notifications = new ArrayList<>(0);
	 public Trigger(Alert alert, TriggerType type, String name, double threshold, long inertiaMillis) {
		 this(alert, type, name, threshold, null, inertiaMillis);
	 }
	 public Trigger(Alert alert, TriggerType type, String name, Double threshold, Double secondaryThreshold, long inertiaMillis) {
		 super(alert.getOwner());
		 setAlert(alert);
		 setType(type);
		 setName(name);
		 setThreshold(threshold);
		 setSecondaryThreshold(secondaryThreshold);
		 setInertia(inertiaMillis);
		 preUpdate();
	 }
	 protected Trigger() {
		 super(null);
	 }
	 public static boolean evaluateTrigger(Trigger trigger, Double actualValue) {
		 requireArgument(trigger != null, ""Trigger cannot be null."");
		 requireArgument(actualValue != null, ""Trigger cannot be evaulated against null."");
		 Double lowThreshold, highThreshold;
		 switch (trigger.type) {
			 case GREATER_THAN: return actualValue.compareTo(trigger.getThreshold()) > 0;
			 case GREATER_THAN_OR_EQ: return actualValue.compareTo(trigger.getThreshold()) >= 0;
			 case LESS_THAN: return actualValue.compareTo(trigger.getThreshold()) < 0;
			 case LESS_THAN_OR_EQ: return actualValue.compareTo(trigger.getThreshold()) <= 0;
			 case EQUAL: return actualValue.compareTo(trigger.getThreshold()) == 0;
			 case NOT_EQUAL: return actualValue.compareTo(trigger.getThreshold()) != 0;
			 case BETWEEN: lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());
			 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());
			 return (actualValue.compareTo(lowThreshold) >= 0 && actualValue.compareTo(highThreshold) <= 0);
			 case NOT_BETWEEN: lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());
			 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());
			 return (actualValue.compareTo(lowThreshold) < 0 || actualValue.compareTo(highThreshold) > 0);
			 case NO_DATA: return actualValue == null;
			 default: throw new SystemException(""Unsupported trigger type "" + trigger.type);
		 }
	 }
	 public List<Notification> getNotifications() {
		 return Collections.unmodifiableList(notifications);
	 }
	 public TriggerType getType() {
		 return type;
	 }
	 public void setType(TriggerType type) {
		 requireArgument(type != null, ""The trigger type cannot be null."");
		 this.type = type;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 requireArgument(name != null && !name.isEmpty(), ""Trigger name cannot be null or empty."");
		 this.name = name;
	 }
	 public Double getThreshold() {
		 return threshold;
	 }
	 public void setThreshold(Double threshold) {
		 requireArgument(threshold != null, ""Trigger threshold cannot be null."");
		 this.threshold = threshold;
	 }
	 public Double getSecondaryThreshold() {
		 return secondaryThreshold;
	 }
	 public void setSecondaryThreshold(Double secondaryThreshold) {
		 this.secondaryThreshold = secondaryThreshold;
	 }
	 public Long getInertia() {
		 return inertia;
	 }
	 public void setInertia(Long inertiaMillis) {
		 if (this.alert == null) {
			 this.inertia = inertiaMillis;
		 }
		 else {
			 requireArgument(inertiaMillis != null && inertiaMillis >= 0, ""Inertia cannot be negative."");
			 Long longestIntervalLength = AlertUtils.getMaximumIntervalLength(this.alert.getExpression());
			 if (inertiaMillis > longestIntervalLength) throw new IllegalArgumentException(String.format(""Inertia %d cannot be more than width of the longest interval %d."", inertiaMillis, longestIntervalLength));
			 this.inertia = inertiaMillis;
		 }
	 }
	 public Alert getAlert() {
		 return alert;
	 }
	 public void setAlert(Alert alert) {
		 requireArgument(alert != null, ""The alert with which a trigger is associated cannot be null."");
		 this.alert = alert;
	 }
	 public int hashCode() {
		 int hash = 7;
		 hash = 97 * hash + Objects.hashCode(this.name);
		 hash = 97 * hash + Objects.hashCode(this.alert);
		 return hash;
	 }
	 public boolean equals(Object obj) {
		 if (obj == null) {
			 return false;
		 }
		 if (getClass() != obj.getClass()) {
			 return false;
		 }
		 final Trigger other = (Trigger) obj;
		 if (!Objects.equals(this.name, other.name)) {
			 return false;
		 }
		 if (!Objects.equals(this.alert, other.alert)) {
			 return false;
		 }
		 return true;
	 }
	 public String toString() {
		 if (type == TriggerType.BETWEEN || type == TriggerType.NOT_BETWEEN) return ""Trigger{
		"" + ""type="" + type + "", name="" + name + "", primaryThreshold="" + threshold + "", secondaryThreshold="" + secondaryThreshold + "", inertia="" + inertia + '}
		';
		 else return ""Trigger{
		"" + ""type="" + type + "", name="" + name + "", threshold="" + threshold + "", inertia="" + inertia + '}
		';
	 }
	 public enum TriggerType {
		 GREATER_THAN, GREATER_THAN_OR_EQ, LESS_THAN, LESS_THAN_OR_EQ, EQUAL, NOT_EQUAL, BETWEEN, NOT_BETWEEN, NO_DATA;
		 public static TriggerType fromString(String name) {
			 for (TriggerType t : TriggerType.values()) {
				 if (t.toString().equalsIgnoreCase(name)) {
					 return t;
				 }
			 }
			 throw new IllegalArgumentException(""Trigger Type does not exist."");
		 }
		 public String value() {
			 return this.toString();
		 }
	 }
}",1,1,0,0
"void chooseExcessReplicates(Vector nonExcess, Block b, short replication) {
	 while (nonExcess.size() - replication > 0) {
		 int chosenNode = r.nextInt(nonExcess.size());
		 DatanodeInfo cur = (DatanodeInfo) nonExcess.elementAt(chosenNode);
		 nonExcess.removeElementAt(chosenNode);
		 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get(cur.getName());
		 if (excessBlocks == null) {
			 excessBlocks = new TreeSet();
			 excessReplicateMap.put(cur.getName(), excessBlocks);
		 }
		 excessBlocks.add(b);
		 NameNode.stateChangeLog.finer(""BLOCK* NameSystem.chooseExcessReplicates: "" +""(""+cur.getName()+"", ""+b.getBlockName()+"") is added to excessReplicateMap"" );
		 Vector invalidateSet = (Vector) recentInvalidateSets.get(cur.getName());
		 if (invalidateSet == null) {
			 invalidateSet = new Vector();
			 recentInvalidateSets.put(cur.getName(), invalidateSet);
		 }
		 invalidateSet.add(b);
		 NameNode.stateChangeLog.finer(""BLOCK* NameSystem.chooseExcessReplicates: "" +""(""+cur.getName()+"", ""+b.getBlockName()+"") is added to recentInvalidateSets"" );
	 }
 }",0,0,0,0
"public int hashCode() {
	 return Objects.hash(id);
 }",0,0,0,0
"public long estimatedKeysForRanges(Collection<Range<Token>> ranges) {
	 long sampleKeyCount = 0;
	 List<Pair<Integer, Integer>> sampleIndexes = getSampleIndexesForRanges(indexSummary.getKeys(), ranges);
	 for (Pair<Integer, Integer> sampleIndexRange : sampleIndexes) sampleKeyCount += (sampleIndexRange.right - sampleIndexRange.left + 1);
	 return Math.max(1, sampleKeyCount * DatabaseDescriptor.getIndexInterval());
 }",0,0,0,0
"public class T5Dashboard extends AbstractInternalPage{
	 private String frameworkVersion;
	 private boolean productionMode;
	 private DashboardManager dashboardManager;
	 private String tabName;
	 private String activeTab;
	 public String getTabClass() {
		 return tabName.equalsIgnoreCase(activeTab) ? ""active"" : null;
	 }
	 public Block getContent() {
		 return dashboardManager.getTabContent(activeTab);
	 }
	 void onActivate() {
		 activeTab = dashboardManager.getTabNames().get(0);
	 }
	 boolean onActivate(String tabName) {
		 activeTab = tabName;
		 return true;
	 }
	 String onPassivate() {
		 return activeTab;
	 }
}",0,1,0,0
"static List<Period> generateSchedule(Calendar startDate,Calendar endDate, int frequencyAmount, int frequencyUnit,StubType stubType, Period prototype, int maxPeriods) throws ScheduleException;",0,0,0,1
"public class LiteralKey {
	 private Object value;
	 private String type;
	 private String lang;
	 public LiteralKey(Object value, String type, String lang) {
		 this.value = value;
		 this.type = type != null ? type.intern() : null;
		 this.lang = lang != null ? lang.intern() : null;
	 }
	 public String getLang() {
		 return lang;
	 }
	 public String getType() {
		 return type;
	 }
	 public Object getValue() {
		 return value;
	 }
	 public boolean equals(Object o) {
		 if (this == o) return true;
		 if (o == null || getClass() != o.getClass()) return false;
		 LiteralKey that = (LiteralKey) o;
		 if (lang != null ? !lang.equals(that.lang) : that.lang != null) return false;
		 if (type != null ? !type.equals(that.type) : that.type != null) return false;
		 return value.equals(that.value);
	 }
	 public int hashCode() {
		 int result = value.hashCode();
		 result = 31 * result + (type != null ? type.hashCode() : 0);
		 result = 31 * result + (lang != null ? lang.hashCode() : 0);
		 return result;
	 }
}",0,1,0,0
"public class POForEach extends PhysicalOperator {
	 private static final long serialVersionUID = 1L;
	 private static final Result UNLIMITED_NULL_RESULT = new Result(POStatus.STATUS_OK, new UnlimitedNullTuple());
	 protected List<PhysicalPlan> inputPlans;
	 protected List<PhysicalOperator> opsToBeReset;
	 protected PhysicalOperator[] planLeafOps;
	 protected byte[] resultTypes;
	 protected boolean[] isToBeFlattenedArray;
	 private int[] flattenNumFields = null;
	 protected int noItems;
	 protected transient boolean processingPlan;
	 protected transient Iterator<Tuple> [] its = null;
	 protected transient Object[] bags ;
	 protected transient Object[] data;
	 protected transient BitSet earlyTermination;
	 protected transient ExampleTuple tIn;
	 protected transient AccumulativeTupleBuffer buffer;
	 protected transient Tuple inpTuple;
	 protected transient boolean endOfAllInputProcessed;
	 protected boolean mapSideOnly = false;
	 protected Boolean endOfAllInputProcessing = false;
	 private Schema schema;
	 public POForEach(OperatorKey k) {
		 this(k,-1,null,null);
	 }
	 public POForEach(OperatorKey k, int rp) {
		 this(k,rp,null,null);
	 }
	 public POForEach(OperatorKey k, List inp) {
		 this(k,-1,inp,null);
	 }
	 public POForEach(OperatorKey k, int rp, List<PhysicalPlan> inp, List<Boolean> isToBeFlattened){
		 super(k, rp);
		 setUpFlattens(isToBeFlattened);
		 this.inputPlans = inp;
		 opsToBeReset = new ArrayList<PhysicalOperator>();
		 getLeaves();
	 }
	 public POForEach(OperatorKey operatorKey, int requestedParallelism, List<PhysicalPlan> innerPlans, List<Boolean> flattenList, Schema schema) {
		 this(operatorKey, requestedParallelism, innerPlans, flattenList);
		 this.schema = schema;
	 }
	 public void visit(PhyPlanVisitor v) throws VisitorException {
		 v.visitPOForEach(this);
	 }
	 public String name() {
		 return getAliasString() + ""New For Each"" + ""("" + getFlatStr() + "")"" + ""["" + DataType.findTypeName(resultType) + ""]"" + "" - "" + mKey.toString();
	 }
	 String getFlatStr() {
		 if(isToBeFlattenedArray ==null) {
			 return """";
		 }
		 StringBuilder sb = new StringBuilder();
		 for (Boolean b : isToBeFlattenedArray) {
			 sb.append(b);
			 sb.append(',');
		 }
		 if(sb.length()>0){
			 sb.deleteCharAt(sb.length()-1);
		 }
		 return sb.toString();
	 }
	 public boolean supportsMultipleInputs() {
		 return false;
	 }
	 public boolean supportsMultipleOutputs() {
		 return false;
	 }
	 public void setAccumulative() {
		 super.setAccumulative();
		 for(PhysicalPlan p : inputPlans) {
			 Iterator<PhysicalOperator> iter = p.iterator();
			 while(iter.hasNext()) {
				 PhysicalOperator po = iter.next();
				 if (po instanceof ExpressionOperator || po instanceof PODistinct) {
					 po.setAccumulative();
				 }
			 }
		 }
	 }
	 public void setAccumStart() {
		 super.setAccumStart();
		 for(PhysicalPlan p : inputPlans) {
			 Iterator<PhysicalOperator> iter = p.iterator();
			 while(iter.hasNext()) {
				 PhysicalOperator po = iter.next();
				 if (po instanceof ExpressionOperator || po instanceof PODistinct) {
					 po.setAccumStart();
				 }
			 }
		 }
	 }
	 public void setAccumEnd() {
		 super.setAccumEnd();
		 for(PhysicalPlan p : inputPlans) {
			 Iterator<PhysicalOperator> iter = p.iterator();
			 while(iter.hasNext()) {
				 PhysicalOperator po = iter.next();
				 if (po instanceof ExpressionOperator || po instanceof PODistinct) {
					 po.setAccumEnd();
				 }
			 }
		 }
	 }
	 public Result getNextTuple() throws ExecException {
		 try {
			 Result res = null;
			 Result inp = null;
			 if(processingPlan){
				 while(true) {
					 res = processPlan();
					 if(res.returnStatus==POStatus.STATUS_OK) {
						 return res;
					 }
					 if(res.returnStatus==POStatus.STATUS_EOP) {
						 processingPlan = false;
						 for(PhysicalPlan plan : inputPlans) {
							 plan.detachInput();
						 }
						 break;
					 }
					 if(res.returnStatus==POStatus.STATUS_ERR) {
						 return res;
					 }
					 if(res.returnStatus==POStatus.STATUS_NULL) {
						 continue;
					 }
				 }
			 }
			 while (true) {
				 inp = processInput();
				 if (inp.returnStatus == POStatus.STATUS_ERR) {
					 return inp;
				 }
				 if (inp.returnStatus == POStatus.STATUS_NULL) {
					 continue;
				 }
				 if (inp.returnStatus == POStatus.STATUS_EOP) {
					 if (parentPlan!=null && parentPlan.endOfAllInput && !endOfAllInputProcessed && endOfAllInputProcessing) {
						 inp = UNLIMITED_NULL_RESULT;
					 }
					 else {
						 return inp;
					 }
				 }
				 attachInputToPlans((Tuple) inp.result);
				 inpTuple = (Tuple)inp.result;
				 for (PhysicalOperator po : opsToBeReset) {
					 po.reset();
				 }
				 if (isAccumulative()) {
					 for(int i=0;
					 i<inpTuple.size();
					 i++) {
						 if (inpTuple.getType(i) == DataType.BAG) {
							 buffer = ((AccumulativeBag)inpTuple.get(i)).getTuplebuffer();
							 break;
						 }
					 }
					 setAccumStart();
					 while(true) {
						 if (!isEarlyTerminated() && buffer.hasNextBatch()) {
							 try {
								 buffer.nextBatch();
							 }
							catch(IOException e) {
								 throw new ExecException(e);
							 }
						 }
						else{
							 if (buffer instanceof POPackage.POPackageTupleBuffer) {
								 inpTuple = ((POPackage.POPackageTupleBuffer) buffer).illustratorMarkup(null, inpTuple, 0);
							 }
							 setAccumEnd();
						 }
						 res = processPlan();
						 if (res.returnStatus == POStatus.STATUS_BATCH_OK) {
							 attachInputToPlans((Tuple) inp.result);
						 }
						 else if (res.returnStatus == POStatus.STATUS_EARLY_TERMINATION) {
							 attachInputToPlans(null);
							 earlyTerminate();
						 }
						 else {
							 break;
						 }
					 }
					 buffer.clear();
				 }
				 else {
					 res = processPlan();
				 }
				 processingPlan = true;
				 return res;
			 }
		 }
		 catch (RuntimeException e) {
			 throw new ExecException(""Error while executing ForEach at "" + this.getOriginalLocations(), e);
		 }
	 }
	 private boolean isEarlyTerminated = false;
	 private TupleMaker<? extends Tuple> tupleMaker;
	 private boolean knownSize = false;
	 private boolean isEarlyTerminated() {
		 return isEarlyTerminated;
	 }
	 private void earlyTerminate() {
		 isEarlyTerminated = true;
	 }
	 protected Result processPlan() throws ExecException{
		 if (schema != null && tupleMaker == null) {
			 tupleMaker = SchemaTupleFactory.getInstance(schema, false, GenContext.FOREACH);
			 if (tupleMaker != null) {
				 knownSize = true;
			 }
		 }
		 if (tupleMaker == null) {
			 tupleMaker = TupleFactory.getInstance();
		 }
		 Result res = new Result();
		 if(its != null) {
			 boolean restartIts = true;
			 for(int i = 0;
			 i < noItems;
			 ++i) {
				 if(its[i] != null && isToBeFlattenedArray[i] == true) {
					 restartIts &= !its[i].hasNext();
				 }
			 }
			 if(restartIts) {
				 its = null;
				 data = null;
			 }
		 }
		 if(its == null) {
			 if (endOfAllInputProcessed) {
				 return RESULT_EOP;
			 }
			 its = new Iterator[noItems];
			 bags = new Object[noItems];
			 earlyTermination = new BitSet(noItems);
			 for(int i = 0;
			 i < noItems;
			 ++i) {
				 Result inputData = null;
				 switch(resultTypes[i]) {
					 case DataType.BAG: case DataType.TUPLE : case DataType.BYTEARRAY : case DataType.MAP : case DataType.BOOLEAN : case DataType.INTEGER : case DataType.DOUBLE : case DataType.LONG : case DataType.FLOAT : case DataType.BIGINTEGER : case DataType.BIGDECIMAL : case DataType.DATETIME : case DataType.CHARARRAY : inputData = planLeafOps[i].getNext(resultTypes[i]);
					 break;
					 default: {
						 int errCode = 2080;
						 String msg = ""Foreach currently does not handle type "" + DataType.findTypeName(resultTypes[i]);
						 throw new ExecException(msg, errCode, PigException.BUG);
					 }
				 }
				 if (inputData.returnStatus == POStatus.STATUS_EARLY_TERMINATION) {
					 if (!earlyTermination.get(i)) earlyTermination.set(i);
					 continue;
				 }
				 if (inputData.returnStatus == POStatus.STATUS_BATCH_OK) {
					 continue;
				 }
				 if(inputData.returnStatus == POStatus.STATUS_EOP) {
					 its = null;
					 bags = null;
					 return inputData;
				 }
				 if(inputData.returnStatus == POStatus.STATUS_ERR) {
					 return inputData;
				 }
				 bags[i] = inputData.result;
				 if(inputData.result instanceof DataBag && isToBeFlattenedArray[i]) {
					 its[i] = ((DataBag)bags[i]).iterator();
				 }
				 else if (inputData.result instanceof Map && isToBeFlattenedArray[i]) {
					 its[i] = ((Map)bags[i]).entrySet().iterator();
				 }
				 else {
					 its[i] = null;
				 }
			 }
			 if (parentPlan!=null && parentPlan.endOfAllInput && endOfAllInputProcessing) {
				 endOfAllInputProcessed = true;
			 }
		 }
		 if (isAccumulative() && isAccumStarted()) {
			 if (earlyTermination.cardinality() < noItems) {
				 res.returnStatus = POStatus.STATUS_BATCH_OK;
			 }
			 else {
				 res.returnStatus = POStatus.STATUS_EARLY_TERMINATION;
			 }
			 return res;
		 }
		 while(true) {
			 if(data == null) {
				 data = new Object[noItems];
				 for(int i = 0;
				 i < noItems;
				 ++i) {
					 if(isToBeFlattenedArray[i] && (bags[i] instanceof DataBag || bags[i] instanceof Map)) {
						 if(its[i].hasNext()) {
							 data[i] = its[i].next();
						 }
						 else {
							 its = null;
							 data = null;
							 res.returnStatus = POStatus.STATUS_NULL;
							 return res;
						 }
					 }
					 else {
						 data[i] = bags[i];
					 }
				 }
				 if(getReporter()!=null) {
					 getReporter().progress();
				 }
				 res.result = createTuple(data);
				 res.returnStatus = POStatus.STATUS_OK;
				 return res;
			 }
			 else {
				 for(int index = noItems - 1;
				 index >= 0;
				 --index) {
					 if(its[index] != null && isToBeFlattenedArray[index]) {
						 if(its[index].hasNext()) {
							 data[index] = its[index].next();
							 res.result = createTuple(data);
							 res.returnStatus = POStatus.STATUS_OK;
							 return res;
						 }
						 else{
							 if(bags[index] instanceof DataBag) {
								 its[index] = ((DataBag)bags[index]).iterator();
							 }
							 else {
								 its[index] = ((Map)bags[index]).entrySet().iterator();
							 }
							 data[index] = its[index].next();
						 }
					 }
				 }
			 }
		 }
	 }
	 protected Tuple createTuple(Object[] data) throws ExecException {
		 Tuple out = tupleMaker.newTuple();
		 int idx = 0;
		 for(int i = 0;
		 i < data.length;
		 ++i) {
			 Object in = data[i];
			 if(!isToBeFlattenedArray[i]) {
				 if (knownSize) {
					 out.set(idx++, in);
				 }
				 else {
					 out.append(in);
				 }
			 }
			 else if(in instanceof Tuple) {
				 Tuple t = (Tuple)in;
				 int size = t.size();
				 for(int j = 0;
				 j < size;
				 ++j) {
					 if (knownSize) {
						 out.set(idx++, t.get(j));
					 }
					 else {
						 out.append(t.get(j));
					 }
				 }
			 }
			 else if (in instanceof Map.Entry) {
				 Map.Entry entry = (Map.Entry)in;
				 if (knownSize) {
					 out.set(idx++, entry.getKey());
					 out.set(idx++, entry.getValue());
				 }
				 else {
					 out.append(entry.getKey());
					 out.append(entry.getValue());
				 }
			 }
			 else if (in == null && flattenNumFields != null && flattenNumFields[i] != 0 ) {
				 for( int j = 0;
				 j < flattenNumFields[i];
				 j++ ) {
					 if (knownSize) {
						 out.set(idx++, null);
					 }
					 else {
						 out.append(null);
					 }
				 }
			 }
			 else {
				 if (knownSize) {
					 out.set(idx++, in);
				 }
				 else {
					 out.append(in);
				 }
			 }
		 }
		 if (inpTuple != null) {
			 return illustratorMarkup(inpTuple, out, 0);
		 }
		 else {
			 return illustratorMarkup2(data, out);
		 }
	 }
	 protected void attachInputToPlans(Tuple t) {
		 for(PhysicalPlan p : inputPlans) {
			 p.attachInput(t);
		 }
	 }
	 public void getLeaves() {
		 if (inputPlans != null) {
			 int i=-1;
			 if(isToBeFlattenedArray == null) {
				 isToBeFlattenedArray = new boolean[inputPlans.size()];
			 }
			 planLeafOps = new PhysicalOperator[inputPlans.size()];
			 for(PhysicalPlan p : inputPlans) {
				 ++i;
				 PhysicalOperator leaf = p.getLeaves().get(0);
				 planLeafOps[i] = leaf;
				 if(leaf instanceof POProject && leaf.getResultType() == DataType.TUPLE && ((POProject)leaf).isProjectToEnd() ) {
					 isToBeFlattenedArray[i] = true;
				 }
			 }
		 }
		 reInitialize();
	 }
	 private void reInitialize() {
		 if(planLeafOps != null) {
			 noItems = planLeafOps.length;
			 resultTypes = new byte[noItems];
			 for (int i = 0;
			 i < resultTypes.length;
			 i++) {
				 resultTypes[i] = planLeafOps[i].getResultType();
			 }
		 }
		 else {
			 noItems = 0;
			 resultTypes = null;
		 }
		 if(inputPlans != null) {
			 for (PhysicalPlan pp : inputPlans) {
				 try {
					 ResetFinder lf = new ResetFinder(pp, opsToBeReset);
					 lf.visit();
				 }
				 catch (VisitorException ve) {
					 String errMsg = ""Internal Error: Unexpected error looking for nested operators which need to be reset in FOREACH"";
					 throw new RuntimeException(errMsg, ve);
				 }
			 }
		 }
	 }
	 public List<PhysicalPlan> getInputPlans() {
		 return inputPlans;
	 }
	 public void setInputPlans(List<PhysicalPlan> plans) {
		 inputPlans = plans;
		 planLeafOps = null;
		 getLeaves();
	 }
	 public void addInputPlan(PhysicalPlan plan, boolean flatten) {
		 inputPlans.add(plan);
		 PhysicalOperator[] newPlanLeafOps = new PhysicalOperator[planLeafOps.length + 1];
		 for (int i = 0;
		 i < planLeafOps.length;
		 i++) {
			 newPlanLeafOps[i] = planLeafOps[i];
		 }
		 newPlanLeafOps[planLeafOps.length] = plan.getLeaves().get(0);
		 planLeafOps = newPlanLeafOps;
		 boolean[] newIsToBeFlattenedArray = new boolean[isToBeFlattenedArray.length + 1];
		 for(int i = 0;
		 i < isToBeFlattenedArray.length;
		 i++) {
			 newIsToBeFlattenedArray[i] = isToBeFlattenedArray[i];
		 }
		 newIsToBeFlattenedArray[isToBeFlattenedArray.length] = flatten;
		 isToBeFlattenedArray = newIsToBeFlattenedArray;
		 reInitialize();
	 }
	 public void setToBeFlattened(List<Boolean> flattens) {
		 setUpFlattens(flattens);
	 }
	 public List<Boolean> getToBeFlattened() {
		 List<Boolean> result = null;
		 if(isToBeFlattenedArray != null) {
			 result = new ArrayList<Boolean>();
			 for (int i = 0;
			 i < isToBeFlattenedArray.length;
			 i++) {
				 result.add(isToBeFlattenedArray[i]);
			 }
		 }
		 return result;
	 }
	 public POForEach clone() throws CloneNotSupportedException {
		 List<PhysicalPlan> plans = new ArrayList<PhysicalPlan>(inputPlans.size());
		 for (PhysicalPlan plan : inputPlans) {
			 plans.add(plan.clone());
		 }
		 List<Boolean> flattens = null;
		 if(isToBeFlattenedArray != null) {
			 flattens = new ArrayList<Boolean>(isToBeFlattenedArray.length);
			 for (boolean b : isToBeFlattenedArray) {
				 flattens.add(b);
			 }
		 }
		 POForEach clone = new POForEach(new OperatorKey(mKey.scope, NodeIdGenerator.getGenerator().getNextNodeId(mKey.scope)), requestedParallelism, plans, flattens);
		 clone.setResultType(getResultType());
		 clone.addOriginalLocation(alias, getOriginalLocations());
		 clone.endOfAllInputProcessing = endOfAllInputProcessing;
		 clone.mapSideOnly = mapSideOnly;
		 clone.flattenNumFields = flattenNumFields;
		 return clone;
	 }
	 public boolean inProcessing() {
		 return processingPlan;
	 }
	 public void setFlattenNumFields (int [] flattenNumFields) {
		 this.flattenNumFields = flattenNumFields;
	 }
	 protected void setUpFlattens(List<Boolean> isToBeFlattened) {
		 if(isToBeFlattened == null) {
			 isToBeFlattenedArray = null;
		 }
		 else {
			 isToBeFlattenedArray = new boolean[isToBeFlattened.size()];
			 int i = 0;
			 for (Iterator<Boolean> it = isToBeFlattened.iterator();
			 it.hasNext();
			) {
				 isToBeFlattenedArray[i++] = it.next();
			 }
		 }
	 }
	 private class ResetFinder extends PhyPlanVisitor {
		 ResetFinder(PhysicalPlan plan, List<PhysicalOperator> toBeReset) {
			 super(plan, new DependencyOrderWalker<PhysicalOperator, PhysicalPlan>(plan));
		 }
		 public void visitDistinct(PODistinct d) throws VisitorException {
			 opsToBeReset.add(d);
		 }
		 public void visitLimit(POLimit limit) throws VisitorException {
			 opsToBeReset.add(limit);
		 }
		 public void visitSort(POSort sort) throws VisitorException {
			 opsToBeReset.add(sort);
		 }
		 public void visitCross(POCross c) throws VisitorException {
			 opsToBeReset.add(c);
		 }
		 public void visitProject(POProject proj) throws VisitorException {
			 if(proj instanceof PORelationToExprProject) {
				 opsToBeReset.add(proj);
			 }
		 }
	 }
	 public List<PhysicalOperator> getOpsToBeReset() {
		 return opsToBeReset;
	 }
	 public void setOpsToBeReset(List<PhysicalOperator> opsToBeReset) {
		 this.opsToBeReset = opsToBeReset;
	 }
	 private Tuple illustratorMarkup2(Object[] in, Object out) {
		 if(illustrator != null) {
			 ExampleTuple tOut = new ExampleTuple((Tuple) out);
			 illustrator.getLineage().insert(tOut);
			 boolean synthetic = false;
			 for (Object tIn : in) {
				 synthetic |= ((ExampleTuple) tIn).synthetic;
				 illustrator.getLineage().union(tOut, (Tuple) tIn);
			 }
			 illustrator.addData(tOut);
			 int i;
			 for (i = 0;
			 i < noItems;
			 ++i) {
				 if (((DataBag)bags[i]).size() < 2) {
					 break;
				 }
			 }
			 if (i >= noItems && !illustrator.getEqClassesShared()) {
				 illustrator.getEquivalenceClasses().get(0).add(tOut);
			 }
			 tOut.synthetic = synthetic;
			 return tOut;
		 }
		 else {
			 return (Tuple) out;
		 }
	 }
	 public Tuple illustratorMarkup(Object in, Object out, int eqClassIndex) {
		 if(illustrator != null) {
			 ExampleTuple tOut = new ExampleTuple((Tuple) out);
			 illustrator.addData(tOut);
			 if (!illustrator.getEqClassesShared()) {
				 illustrator.getEquivalenceClasses().get(0).add(tOut);
			 }
			 LineageTracer lineageTracer = illustrator.getLineage();
			 lineageTracer.insert(tOut);
			 tOut.synthetic = ((ExampleTuple) in).synthetic;
			 lineageTracer.union((ExampleTuple) in , tOut);
			 return tOut;
		 }
		 else {
			 return (Tuple) out;
		 }
	 }
	 public PhysicalOperator[] getPlanLeafOps() {
		 return planLeafOps;
	 }
	 public void setMapSideOnly(boolean mapSideOnly) {
		 this.mapSideOnly = mapSideOnly;
	 }
	 public boolean isMapSideOnly() {
		 return mapSideOnly;
	 }
	 public boolean needEndOfAllInputProcessing() throws ExecException {
		 try {
			 for (PhysicalPlan innerPlan : inputPlans) {
				 UDFEndOfAllInputNeededVisitor endOfAllInputNeededVisitor = new UDFEndOfAllInputNeededVisitor(innerPlan);
				 endOfAllInputNeededVisitor.visit();
				 if (endOfAllInputNeededVisitor.needEndOfAllInputProcessing()) {
					 endOfAllInputProcessing = true;
					 return true;
				 }
			 }
			 return false;
		 }
		 catch (Exception e) {
			 throw new ExecException(e);
		 }
	 }
}",1,0,0,0
"public void updateNeuronWeights(Neuron neuron) {
	 for (Connection connection : neuron.getInputConnections()) {
		 double input = connection.getInput();
		 if (input == 0) {
			 continue;
		 }
		 double neuronDelta = neuron.getError();
		 Weight<MomentumTrainingData> weight = connection.getWeight();
		 MomentumTrainingData weightTrainingData = weight.getTrainingData();
		 double weightChange = -learningRate * neuronDelta * input + momentum * weightTrainingData.previousWeightChange;
		 weightTrainingData.previousWeightChange = weight.weightChange;
		 if (isBatchMode() == false) {
			 weight.weightChange = weightChange;
		 }
		 else {
			 weight.weightChange += weightChange;
		 }
	 }
 }",0,0,0,0
"protected boolean isReferenceOrProxy() {
	 return isReference() || getObjectValue() instanceof Resource;
 }",0,0,0,0
"public Path[] listPathsRaw(Path f) throws IOException {
	 DFSFileInfo info[] = dfs.listPaths(getPath(f));
	 if (info == null) {
		 return new Path[0];
	 }
	 else {
		 Path results[] = new DfsPath[info.length];
		 for (int i = 0;
		 i < info.length;
		 i++) {
			 results[i] = new DfsPath(info[i]);
		 }
		 return results;
	 }
 }",0,0,0,0
"public void unassign(HRegionInfo region, boolean force) {
	 LOG.debug(""Starting unassignment of region "" + region.getRegionNameAsString() + "" (offlining)"");
	 synchronized (this.regions) {
		 if (!regions.containsKey(region)) {
			 LOG.debug(""Attempted to unassign region "" + region.getRegionNameAsString() + "" but it is not "" + ""currently assigned anywhere"");
			 return;
		 }
	 }
	 String encodedName = region.getEncodedName();
	 RegionState state;
	 synchronized (regionsInTransition) {
		 state = regionsInTransition.get(encodedName);
		 if (state == null) {
			 state = new RegionState(region, RegionState.State.PENDING_CLOSE);
			 regionsInTransition.put(encodedName, state);
		 }
		 else if (force && state.isPendingClose()) {
			 LOG.debug(""Attempting to unassign region "" + region.getRegionNameAsString() + "" which is already pending close "" + ""but forcing an additional close"");
			 state.update(RegionState.State.PENDING_CLOSE);
		 }
		 else {
			 LOG.debug(""Attempting to unassign region "" + region.getRegionNameAsString() + "" but it is "" + ""already in transition ("" + state.getState() + "")"");
			 return;
		 }
	 }
	 HServerInfo server = null;
	 synchronized (this.regions) {
		 server = regions.get(region);
	 }
	 try {
		 if (serverManager.sendRegionClose(server, state.getRegion())) {
			 LOG.debug(""Sent CLOSE to "" + server + "" for region "" + region.getRegionNameAsString());
			 return;
		 }
		 LOG.debug(""Server "" + server + "" region CLOSE RPC returned false for "" + region.getEncodedName());
	 }
	 catch (NotServingRegionException nsre) {
		 LOG.info(""Server "" + server + "" returned "" + nsre + "" for "" + region.getEncodedName());
		 return;
	 }
	 catch (ConnectException e) {
		 LOG.info(""Failed connect to "" + server + "", message="" + e.getMessage() + "", region="" + region.getEncodedName());
	 }
	 catch (java.net.SocketTimeoutException e) {
		 LOG.info(""Server "" + server + "" returned "" + e.getMessage() + "" for "" + region.getEncodedName());
	 }
	 catch (EOFException e) {
		 LOG.info(""Server "" + server + "" returned "" + e.getMessage() + "" for "" + region.getEncodedName());
	 }
	 catch (RemoteException re) {
		 IOException ioe = re.unwrapRemoteException();
		 if (ioe instanceof NotServingRegionException) {
			 LOG.debug(""Server "" + server + "" returned "" + ioe + "" for "" + region.getEncodedName());
		 }
		 else if (ioe instanceof EOFException) {
			 LOG.debug(""Server "" + server + "" returned "" + ioe + "" for "" + region.getEncodedName());
		 }
		 else {
			 this.master.abort(""Remote unexpected exception"", ioe);
		 }
	 }
	 catch (Throwable t) {
		 this.master.abort(""Remote unexpected exception"", t);
	 }
 }",0,0,1,0
"protected void makeRemoteDir(FTPClient ftp, String dir) throws IOException, BuildException {
	 String workingDirectory = ftp.printWorkingDirectory();
	 if (task.isVerbose()) {
		 if (dir.indexOf(""/"") == 0 || workingDirectory == null) {
			 task.log(""Creating directory: "" + dir + "" in /"");
		 }
		 else {
			 task.log(""Creating directory: "" + dir + "" in "" + workingDirectory);
		 }
	 }
	 if (dir.indexOf(""/"") == 0) {
		 ftp.changeWorkingDirectory(""/"");
	 }
	 String subdir = """";
	 StringTokenizer st = new StringTokenizer(dir, ""/"");
	 while (st.hasMoreTokens()) {
		 subdir = st.nextToken();
		 task.log(""Checking "" + subdir, Project.MSG_DEBUG);
		 if (!ftp.changeWorkingDirectory(subdir)) {
			 if (!ftp.makeDirectory(subdir)) {
				 int rc = ftp.getReplyCode();
				 if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550 || rc == CODE_553 || rc == CODE_521))) {
					 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
				 }
				 if (task.isVerbose()) {
					 task.log(""Directory already exists"");
				 }
			 }
			 else {
				 if (task.isVerbose()) {
					 task.log(""Directory created OK"");
				 }
				 ftp.changeWorkingDirectory(subdir);
			 }
		 }
	 }
	 if (workingDirectory != null) {
		 ftp.changeWorkingDirectory(workingDirectory);
	 }
 }",0,0,0,0
"public static final boolean validatePage(String document, final Class<T> clazz,final String file, boolean failWithAssert) throws IOException{
	String filename = clazz.getPackage().getName();
	filename = filename.replace('.', '/');
	filename += ""/"" + file;
	InputStream in = clazz.getClassLoader().getResourceAsStream(filename);
	if (in == null){
		throw new IOException(""File not found: "" + filename);
	}
	String reference = Streams.readString(in);
	reference = reference.replaceAll(""\n\r"", ""\n"");
	reference = reference.replaceAll(""\r\n"", ""\n"");
	document = document.replaceAll(""\n\r"", ""\n"");
	document = document.replaceAll(""\r\n"", ""\n"");
	boolean equals = compareMarkup(document, reference);
	if (equals == false){
		if (Boolean.getBoolean(""wicket.replace.expected.results"")){
			in.close();
			in = null;
			replaceExpectedResultFile(document, clazz, file);
			return true;
		}
		log.error(""File name: "" + file);
		log.error(""==================="");
		log.error(reference);
		log.error(""==================="");
		log.error(document);
		log.error(""==================="");
		String[] test1 = StringList.tokenize(reference, ""\n"").toArray();
		String[] test2 = StringList.tokenize(document, ""\n"").toArray();
		Diff df = new Diff(test1);
		Revision r;
		try{
			r = df.diff(test2);
		}
		catch (DifferentiationFailedException e){
			throw new RuntimeException(e);
		}
		System.out.println(r.toString());
		if (failWithAssert){
			Assert.assertEquals(filename, reference, document);
		}
	}
	return equals;
}",0,0,0,0
"public class NamedFacetForActionXml extends NamedFacetAbstract {
	 public static NamedFacet create(final ActionLayoutData actionLayout, final FacetHolder holder) {
		 if(actionLayout == null) {
			 return null;
		 }
		 final String named = Strings.emptyToNull(actionLayout.getNamed());
		 Boolean escaped = actionLayout.getNamedEscaped();
		 return named != null ? new NamedFacetForActionXml(named, (escaped == null || escaped), holder) : null;
	 }
	 private NamedFacetForActionXml(final String value, final boolean escaped, final FacetHolder holder) {
		 super(value, escaped, holder);
	 }
}",0,0,0,0
"private long getSkip() {
	 return skip;
 }",0,0,0,0
"private void init() {
	setUndecorated(true);
	try {
		if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			setOpacity(0.85f);
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	setIconImage(ImageResource.get(""icon.png"").getImage());
	setSize(350, 200);
	setLocationRelativeTo(null);
	setResizable(false);
	getContentPane().setLayout(null);
	getContentPane().setBackground(ColorResource.getDarkestBgColor());
	titlePanel = new TitlePanel(null, this);
	titlePanel.setOpaque(false);
	titlePanel.setBounds(0, 0, 350, 50);
	closeBtn = new CustomButton();
	closeBtn.setBounds(320, 5, 24, 24);
	closeBtn.setIcon(ImageResource.get(""close_btn.png""));
	closeBtn.setBackground(ColorResource.getDarkestBgColor());
	closeBtn.setBorderPainted(false);
	closeBtn.setFocusPainted(false);
	closeBtn.setName(""CLOSE"");
	closeBtn.addActionListener(this);
	minBtn = new CustomButton();
	minBtn.setBounds(296, 5, 24, 24);
	minBtn.setIcon(ImageResource.get(""min_btn.png""));
	minBtn.setBackground(ColorResource.getDarkestBgColor());
	minBtn.setBorderPainted(false);
	minBtn.setFocusPainted(false);
	minBtn.setName(""MIN"");
	minBtn.addActionListener(this);
	titleLbl = new JLabel(StringResource.get(""TITLE_CONVERT""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(25, 15, 250, 30);
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, 55, 400, 2);
	lineLbl.setOpaque(true);
	prg = new JProgressBar();
	prg.setBounds(20, 85, 350 - 40, 5);
	statLbl = new JLabel();
	statLbl.setForeground(Color.WHITE);
	statLbl.setBounds(20, 100, 350 - 40, 25);
	titlePanel.add(titleLbl);
	titlePanel.add(minBtn);
	titlePanel.add(closeBtn);
	add(lineLbl);
	add(titlePanel);
	add(prg);
	add(statLbl);
	panel = new JPanel(null);
	panel.setBounds(0, 150, 350, 50);
	panel.setBackground(Color.DARK_GRAY);
	btnCN = new CustomButton(StringResource.get(""MENU_PAUSE""));
	btnCN.setBounds(0, 1, 350, 50);
	btnCN.setName(""CLOSE"");
	applyStyle(btnCN);
	panel.add(btnCN);
	add(panel);
}",0,0,1,0
"protected InputStream getInputStream() {
	 return System.in;
 }",0,0,0,0
"public class SafeFileOutputStream extends FilterOutputStream {
	 private final Path desiredFile;
	 private Path tempFile;
	 boolean desiredAlreadyExisted;
	 public SafeFileOutputStream(Path file) throws IOException {
		 this(file, tempFile(file));
	 }
	 public SafeFileOutputStream(Path desiredFile, Path tempFile) throws IOException {
		 super(Files.newOutputStream(tempFile));
		 this.desiredFile = desiredFile;
		 this.tempFile = tempFile;
		 desiredAlreadyExisted = Files.exists(desiredFile);
		 Path desiredFolder = this.desiredFile.getParent();
		 if (desiredAlreadyExisted) {
			 if (!Files.isWritable(desiredFile)) {
				 throw new FileNotFoundException(""Can't write to "" + desiredFile);
			 }
		 }
		 else {
			 if (!Files.exists(desiredFolder)) {
				 throw new FileNotFoundException(""Folder does not exist: "" + desiredFolder);
			 }
			 if (!Files.isDirectory(desiredFolder)) {
				 throw new FileNotFoundException(""Not a directory: "" + desiredFolder);
			 }
		 }
		 if (!Files.isWritable(desiredFolder)) {
			 throw new FileNotFoundException(""Can't modify folder "" + desiredFolder);
		 }
	 }
	 private static Path tempFile(Path file) throws IOException {
		 return Files.createTempFile(file.getParent(), file.getFileName() .toString(), "".tmp"");
	 }
	 public void close() throws IOException {
		 super.close();
		 if (!Files.exists(tempFile)) {
			 return;
		 }
		 Path beforeDeletion = null;
		 try {
			 if (desiredAlreadyExisted) {
				 beforeDeletion = tempFile(desiredFile);
				 if (!Files.deleteIfExists(beforeDeletion)) {
					 throw new IOException(""Can't delete temporary file "" + beforeDeletion);
				 }
				 Files.move(desiredFile, beforeDeletion, StandardCopyOption.ATOMIC_MOVE);
			 }
			 try {
				 Files.move(tempFile, desiredFile, StandardCopyOption.ATOMIC_MOVE);
			 }
			 catch (IOException e) {
				 tempFile = null;
				 beforeDeletion = null;
				 if (Files.exists(desiredFile)) {
					 return;
				 }
				 throw e;
			 }
		 }
		 finally {
			 if (beforeDeletion != null) {
				 Files.deleteIfExists(beforeDeletion);
			 }
			 if (tempFile != null) {
				 Files.deleteIfExists(tempFile);
			 }
		 }
	 }
	 public void rollback() throws IOException {
		 super.close();
		 Files.deleteIfExists(tempFile);
	 }
}",1,0,0,0
"protected byte[] generateRequestContent() {
	 try {
		 int currentChar = 'e';
		 final Map<String, Integer> nameSpaceMap = new HashMap<String, Integer>();
		 nameSpaceMap.put(""DAV:"", (int) 'D');
		 if (propertyNameSet != null) {
			 DavPropertyNameIterator propertyNameIterator = propertyNameSet.iterator();
			 while (propertyNameIterator.hasNext()) {
				 DavPropertyName davPropertyName = propertyNameIterator.nextPropertyName();
				 davPropertyName.getName();
				 String namespaceUri = davPropertyName.getNamespace().getURI();
				 if (!nameSpaceMap.containsKey(namespaceUri)) {
					 nameSpaceMap.put(namespaceUri, currentChar++);
				 }
			 }
		 }
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
		 writer.write(""<D:propfind "");
		 for (Map.Entry<String, Integer> mapEntry : nameSpaceMap.entrySet()) {
			 writer.write("" xmlns:"");
			 writer.write((char) mapEntry.getValue().intValue());
			 writer.write(""=\"""");
			 writer.write(mapEntry.getKey());
			 writer.write(""\"""");
		 }
		 writer.write("">"");
		 if (propertyNameSet == null || propertyNameSet.isEmpty()) {
			 writer.write(""<D:allprop/>"");
		 }
		 else {
			 writer.write(""<D:prop>"");
			 DavPropertyNameIterator propertyNameIterator = propertyNameSet.iterator();
			 while (propertyNameIterator.hasNext()) {
				 DavPropertyName davPropertyName = propertyNameIterator.nextPropertyName();
				 char nameSpaceChar = (char) nameSpaceMap.get(davPropertyName.getNamespace().getURI()).intValue();
				 writer.write('<');
				 writer.write(nameSpaceChar);
				 writer.write(':');
				 writer.write(davPropertyName.getName());
				 writer.write(""/>"");
			 }
			 writer.write(""</D:prop>"");
		 }
		 writer.write(""</D:propfind>"");
		 writer.close();
		 return baos.toByteArray();
	 }
	 catch (IOException e) {
		 throw new RuntimeException(e);
	 }
 }",0,0,1,0
"public synchronized void appendSelector(FileSelector selector) {
	 if (isReference()) {
		 throw noChildrenAllowed();
	 }
	 selectors.addElement(selector);
	 directoryScanner = null;
	 setChecked(false);
 }",0,0,0,0
"public synchronized String[] getNotIncludedDirectories() {
	 slowScan();
	 String[] directories = new String[dirsNotIncluded.size()];
	 dirsNotIncluded.copyInto(directories);
	 return directories;
 }",0,0,0,0
"private Iso4217Currency(String fullName, Iso4217Currency replacement, String notes);",0,0,0,0
"public void write(String baseDir) throws IOException {
	 String filename = baseDir + File.separator + CharacterDefinition.class.getName().replace('.', File.separatorChar) + CharacterDefinition.FILENAME_SUFFIX;
	 new File(filename).getParentFile().mkdirs();
	 OutputStream os = new FileOutputStream(filename);
	 try {
		 os = new BufferedOutputStream(os);
		 final DataOutput out = new OutputStreamDataOutput(os);
		 CodecUtil.writeHeader(out, CharacterDefinition.HEADER, CharacterDefinition.VERSION);
		 out.writeBytes(characterCategoryMap, 0, characterCategoryMap.length);
		 for (int i = 0;
		 i < CharacterDefinition.CLASS_COUNT;
		 i++) {
			 final byte b = (byte) ( (invokeMap[i] ? 0x01 : 0x00) | (groupMap[i] ? 0x02 : 0x00) );
			 out.writeByte(b);
		 }
	 }
	 finally {
		 os.close();
	 }
 }",0,0,1,0
"public long bytesOnDisk() {
	 long bytes = 0;
	 for (Component component : components) {
		 bytes += new File(descriptor.filenameFor(component)).length();
	 }
	 return bytes;
 }",0,0,0,0
"private void handleRegion(final RegionTransitionData data) {
	 synchronized(regionsInTransition) {
		 if (data == null || data.getServerName() == null) {
			 LOG.warn(""Unexpected NULL input "" + data);
			 return;
		 }
		 if (data.getServerName().equals(HConstants.HBCK_CODE_NAME)) {
			 handleHBCK(data);
			 return;
		 }
		 if (!serverManager.isServerOnline(data.getServerName()) && !this.master.getServerName().equals(data.getServerName())) {
			 LOG.warn(""Attempted to handle region transition for server but "" + ""server is not online: "" + data.getRegionName());
			 return;
		 }
		 String encodedName = HRegionInfo.encodeRegionName(data.getRegionName());
		 String prettyPrintedRegionName = HRegionInfo.prettyPrint(encodedName);
		 LOG.debug(""Handling transition="" + data.getEventType() + "", server="" + data.getServerName() + "", region="" + prettyPrintedRegionName);
		 RegionState regionState = regionsInTransition.get(encodedName);
		 switch (data.getEventType()) {
			 case M_ZK_REGION_OFFLINE: break;
			 case RS_ZK_REGION_CLOSING: if (regionState == null || (!regionState.isPendingClose() && !regionState.isClosing())) {
				 LOG.warn(""Received CLOSING for region "" + prettyPrintedRegionName + "" from server "" + data.getServerName() + "" but region was in "" + "" the state "" + regionState + "" and not "" + ""in expected PENDING_CLOSE or CLOSING states"");
				 return;
			 }
			 regionState.update(RegionState.State.CLOSING, data.getStamp());
			 break;
			 case RS_ZK_REGION_CLOSED: if (regionState == null || (!regionState.isPendingClose() && !regionState.isClosing())) {
				 LOG.warn(""Received CLOSED for region "" + prettyPrintedRegionName + "" from server "" + data.getServerName() + "" but region was in "" + "" the state "" + regionState + "" and not "" + ""in expected PENDING_CLOSE or CLOSING states"");
				 return;
			 }
			 regionState.update(RegionState.State.CLOSED, data.getStamp());
			 this.executorService.submit(new ClosedRegionHandler(master, this, regionState.getRegion()));
			 break;
			 case RS_ZK_REGION_OPENING: if(regionState == null || (!regionState.isPendingOpen() && !regionState.isOpening())) {
				 LOG.warn(""Received OPENING for region "" + prettyPrintedRegionName + "" from server "" + data.getServerName() + "" but region was in "" + "" the state "" + regionState + "" and not "" + ""in expected PENDING_OPEN or OPENING states"");
				 return;
			 }
			 regionState.update(RegionState.State.OPENING, data.getStamp());
			 break;
			 case RS_ZK_REGION_OPENED: if(regionState == null || (!regionState.isPendingOpen() && !regionState.isOpening())) {
				 LOG.warn(""Received OPENED for region "" + prettyPrintedRegionName + "" from server "" + data.getServerName() + "" but region was in "" + "" the state "" + regionState + "" and not "" + ""in expected PENDING_OPEN or OPENING states"");
				 return;
			 }
			 regionState.update(RegionState.State.OPEN, data.getStamp());
			 this.executorService.submit( new OpenedRegionHandler(master, this, regionState.getRegion(), this.serverManager.getServerInfo(data.getServerName())));
			 break;
		 }
	 }
 }",0,0,1,0
"public BlockBorder(double top, double left, double bottom, double right, Paint paint);",0,0,0,1
"public class GuiceComponentInjector extends org.apache.wicket.injection.InjectorimplementsIComponentInstantiationListener,IBehaviorInstantiationListener{
	private final IFieldValueFactory fieldValueFactory;
	public GuiceComponentInjector(final Application app){
		this(app, new Module[0]);
	}
	public GuiceComponentInjector(final Application app, final Module... modules){
		this(app, Guice.createInjector(app.usesDeploymentConfig() ? Stage.PRODUCTION: Stage.DEVELOPMENT, modules), true);
	}
	public GuiceComponentInjector(final Application app, final Injector injector){
		this(app, injector, true);
	}
	public GuiceComponentInjector(final Application app, final Injector injector,final boolean wrapInProxies){
		app.setMetaData(GuiceInjectorHolder.INJECTOR_KEY, new GuiceInjectorHolder(injector));
		fieldValueFactory = new GuiceFieldValueFactory(wrapInProxies);
		app.getBehaviorInstantiationListeners().add(this);
		bind(app);
	}
	public void inject(final Object object){
		inject(object, fieldValueFactory);
	}
	public void onInstantiation(final Component component){
		inject(component);
	}
	public void onInstantiation(Behavior behavior){
		inject(behavior);
	}
}",0,0,0,0
"public final class EnableHAForHostCmd extends BaseAsyncCmd {
	 public static final String APINAME = ""enableHAForHost"";
	 private HAConfigManager haConfigManager;
	 private Long hostId;
	 public Long getHostId() {
		 return hostId;
	 }
	 public String getCommandName() {
		 return APINAME.toLowerCase() + BaseCmd.RESPONSE_SUFFIX;
	 }
	 public long getEntityOwnerId() {
		 return CallContext.current().getCallingAccountId();
	 }
	 private void setupResponse(final boolean result, final String resourceUuid) {
		 final HostHAResponse response = new HostHAResponse();
		 response.setId(resourceUuid);
		 response.setEnabled(true);
		 response.setStatus(result);
		 response.setResponseName(getCommandName());
		 setResponseObject(response);
	 }
	 public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {
		 final Host host = _resourceService.getHost(getHostId());
		 if (host == null) {
			 throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""Unable to find host by ID: "" + getHostId());
		 }
		 final boolean result = haConfigManager.enableHA(host.getId(), HAResource.ResourceType.Host);
		 CallContext.current().setEventDetails(""Host Id:"" + host.getId() + "" HA enabled: true"");
		 CallContext.current().putContextParameter(Host.class, host.getUuid());
		 setupResponse(result, host.getUuid());
	 }
	 public String getEventType() {
		 return EventTypes.EVENT_HA_RESOURCE_ENABLE;
	 }
	 public String getEventDescription() {
		 return ""enable HA for host: "" + getHostId();
	 }
}",0,0,0,0
"class Result {
	 long theirs;
	 long ours;
	 int iterations;
	 String description;
	 public long getTheirs() {
		 return this.theirs;
	 }
	 public void setTheirs(long argTheirs){
		 this.theirs = argTheirs;
	 }
	 public long getOurs() {
		 return this.ours;
	 }
	 public void setOurs(long argOurs){
		 this.ours = argOurs;
	 }
	 public long getTheirAvg() {
		 return theirs / iterations;
	 }
	 public long getOurAvg() {
		 return ours / iterations;
	 }
	 public int getIterations() {
		 return this.iterations;
	 }
	 public void setIterations(int argIterations){
		 this.iterations = argIterations;
	 }
	 public String getDescription() {
		 return this.description;
	 }
	 public void setDescription(String argDescription){
		 this.description = argDescription;
	 }
	 public String toString() {
		 StringBuilder b = new StringBuilder();
		 b.append(getDescription() + ""\n"");
		 b.append(""Iterations: "" + getIterations() + ""\n"");
		 b.append(""Their total (msec): "" + getTheirs() + ""\n"");
		 b.append(""Our total (msec): "" + getOurs() + ""\n"");
		 b.append(""Their average (msec): "" + getTheirAvg() + ""\n"");
		 b.append(""Our average (msec): "" + getOurAvg() + ""\n"");
		 return b.toString();
	 }
}",0,1,0,0
"public class _LocationWebServiceSoap_Connect implements ElementSerializable{
	 protected int connectOptions;
	 protected int lastChangeId;
	 protected int features;
	 public _LocationWebServiceSoap_Connect() {
		 super();
	 }
	 public _LocationWebServiceSoap_Connect( final int connectOptions, final int lastChangeId, final int features) {
		 setConnectOptions(connectOptions);
		 setLastChangeId(lastChangeId);
		 setFeatures(features);
	 }
	 public int getConnectOptions() {
		 return this.connectOptions;
	 }
	 public void setConnectOptions(int value) {
		 this.connectOptions = value;
	 }
	 public int getLastChangeId() {
		 return this.lastChangeId;
	 }
	 public void setLastChangeId(int value) {
		 this.lastChangeId = value;
	 }
	 public int getFeatures() {
		 return this.features;
	 }
	 public void setFeatures(int value) {
		 this.features = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 XMLStreamWriterHelper.writeElement( writer, ""connectOptions"", this.connectOptions);
		 XMLStreamWriterHelper.writeElement( writer, ""lastChangeId"", this.lastChangeId);
		 XMLStreamWriterHelper.writeElement( writer, ""features"", this.features);
		 writer.writeEndElement();
	 }
}",0,1,0,0
"public interface XMLConstants {
	 String TESTSUITES = ""testsuites"";
	 String TESTSUITE = ""testsuite"";
	 String TESTCASE = ""testcase"";
	 String ERROR = ""error"";
	 String FAILURE = ""failure"";
	 String SYSTEM_ERR = ""system-err"";
	 String SYSTEM_OUT = ""system-out"";
	 String ATTR_PACKAGE = ""package"";
	 String ATTR_NAME = ""name"";
	 String ATTR_TIME = ""time"";
	 String ATTR_ERRORS = ""errors"";
	 String ATTR_FAILURES = ""failures"";
	 String ATTR_TESTS = ""tests"";
	 String ATTR_TYPE = ""type"";
	 String ATTR_MESSAGE = ""message"";
	 String PROPERTIES = ""properties"";
	 String PROPERTY = ""property"";
	 String ATTR_VALUE = ""value"";
	 String ATTR_CLASSNAME = ""classname"";
	 String ATTR_ID = ""id"";
	 String TIMESTAMP = ""timestamp"";
	 String HOSTNAME = ""hostname"";
}",0,0,0,0
"public void readFields(DataInput in) throws IOException {
	 op = in.readByte();
	 switch (op) {
		 case OP_HEARTBEAT: {
			 first = new HeartbeatData();
			 break;
		 }
		 case OP_BLOCKREPORT: {
			 first = new ArrayWritable(Block.class);
			 second = new UTF8();
			 break;
		 }
		 case OP_BLOCKRECEIVED: {
			 first = new ArrayWritable(Block.class);
			 second = new UTF8();
			 break;
		 }
		 case OP_ERROR: {
			 first = new UTF8();
			 second = new UTF8();
			 break;
		 }
		 case OP_CLIENT_OPEN: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_STARTFILE: {
			 first = new ArrayWritable(UTF8.class);
			 second = new BooleanWritable();
			 break;
		 }
		 case OP_CLIENT_ADDBLOCK: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_COMPLETEFILE: {
			 first = new ArrayWritable(UTF8.class);
			 break;
		 }
		 case OP_CLIENT_DATANODE_HINTS: {
			 first = new UTF8();
			 second = new LongWritable();
			 break;
		 }
		 case OP_CLIENT_RENAMETO: {
			 first = new UTF8();
			 second = new UTF8();
			 break;
		 }
		 case OP_CLIENT_DELETE: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_EXISTS: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_ISDIR: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_MKDIRS: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_RENEW_LEASE: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_OBTAINLOCK: {
			 first = new ArrayWritable(UTF8.class);
			 second = new BooleanWritable();
			 break;
		 }
		 case OP_CLIENT_RELEASELOCK: {
			 first = new ArrayWritable(UTF8.class);
			 break;
		 }
		 case OP_CLIENT_LISTING: {
			 first = new UTF8();
			 break;
		 }
		 case OP_CLIENT_ABANDONBLOCK: {
			 first = new Block();
			 second = new UTF8();
			 break;
		 }
		 case OP_CLIENT_RAWSTATS: {
			 break;
		 }
		 case OP_CLIENT_DATANODEREPORT: {
			 break;
		 }
		 default: {
			 throw new IOException(""Unknown opcode: "" + op);
		 }
	 }
	 first.readFields(in);
	 second.readFields(in);
 }",0,0,1,0
"public class RegisterSetLatticeElement implements ILatticeElement<RegisterSetLatticeElement> {
	 private ImmutableSet<String> m_nativeNewlyTaintedRegs = ImmutableSet.<String>builder().build();
	 private ImmutableSet<String> m_nativeUntaintedRegs = ImmutableSet.<String>builder().build();
	 private ImmutableSet<String> m_nativeReadRegs = ImmutableSet.<String>builder().build();
	 private ImmutableSet<String> m_nativeUpdatedRegs = ImmutableSet.<String>builder().build();
	 private final Set<String> m_taintedRegs;
	 private final Set<String> m_newlyTaintedRegs;
	 private final Set<String> m_untaintedRegs;
	 private final Set<String> m_readRegs;
	 private final Set<String> m_updatedRegs;
	 public RegisterSetLatticeElement() {
		 m_taintedRegs = new TreeSet<String>();
		 m_newlyTaintedRegs = new TreeSet<String>();
		 m_untaintedRegs = new TreeSet<String>();
		 m_readRegs = new TreeSet<String>();
		 m_updatedRegs = new TreeSet<String>();
	 }
	 public RegisterSetLatticeElement(final Set<String> taintedRegs, final Set<String> newlyTaintedRegs, final Set<String> untaintedRegs, final Set<String> readRegs, final Set<String> updatedRegs) {
		 Preconditions.checkNotNull(taintedRegs, ""Error: Tainted registers argument can not be null"");
		 Preconditions.checkNotNull(newlyTaintedRegs, ""Error: Newly tainted registers argument can not be null"");
		 Preconditions .checkNotNull(untaintedRegs, ""Error: Untainted registers argument can not be null"");
		 Preconditions.checkNotNull(readRegs, ""Error: Read registers argument can not be null"");
		 Preconditions.checkNotNull(updatedRegs, ""Error: Updated registers argument can not be null"");
		 m_taintedRegs = new TreeSet<String>(taintedRegs);
		 m_newlyTaintedRegs = new TreeSet<String>(newlyTaintedRegs);
		 m_untaintedRegs = new TreeSet<String>(untaintedRegs);
		 m_readRegs = new TreeSet<String>(readRegs);
		 m_updatedRegs = new TreeSet<String>(updatedRegs);
	 }
	 public RegisterSetLatticeElement(final String register) {
		 Preconditions.checkNotNull(register, ""Error: Register argument can not be null"");
		 (m_taintedRegs = new TreeSet<String>()).add(register);
		 (m_newlyTaintedRegs = new TreeSet<String>()).add(register);
		 m_untaintedRegs = new TreeSet<String>();
		 m_readRegs = new TreeSet<String>();
		 m_updatedRegs = new TreeSet<String>();
	 }
	 private static void clearTemporaryRegisters(final Set<String> registerSet) {
		 Sets.filter(registerSet, new Predicate<String>() {
			 public boolean apply(final String register) {
				 return ReilHelpers.isTemporaryRegister(register);
			 }
		 }
		).clear();
	 }
	 public void addAll(final Collection<RegisterSetLatticeElement> inputState) {
		 Preconditions.checkNotNull(inputState, ""Error: Input state argument can not be null"");
		 final Set<String> tempNativeNewlyTaintedRegisters = Sets.newHashSet();
		 final Set<String> tempNativeUntaintedRegisters = Sets.newHashSet();
		 final Set<String> tempNativeReadRegisters = Sets.newHashSet();
		 final Set<String> tempNativeUpdatedRegisters = Sets.newHashSet();
		 for (final RegisterSetLatticeElement element : inputState) {
			 tempNativeNewlyTaintedRegisters.addAll(element.m_nativeNewlyTaintedRegs);
			 tempNativeUntaintedRegisters.addAll(element.m_nativeUntaintedRegs);
			 tempNativeReadRegisters.addAll(element.m_nativeReadRegs);
			 tempNativeUpdatedRegisters.addAll(element.m_nativeUpdatedRegs);
			 m_taintedRegs.addAll(element.m_taintedRegs);
			 m_newlyTaintedRegs.addAll(element.m_newlyTaintedRegs);
			 m_untaintedRegs.addAll(element.m_untaintedRegs);
			 m_readRegs.addAll(element.m_readRegs);
			 m_updatedRegs.addAll(element.m_updatedRegs);
		 }
		 m_nativeNewlyTaintedRegs = ImmutableSet.copyOf(tempNativeNewlyTaintedRegisters);
		 m_nativeUntaintedRegs = ImmutableSet.copyOf(tempNativeUntaintedRegisters);
		 m_nativeReadRegs = ImmutableSet.copyOf(tempNativeReadRegisters);
		 m_nativeUpdatedRegs = ImmutableSet.copyOf(tempNativeUpdatedRegisters);
	 }
	 public void addReadReg(final String reg) {
		 m_readRegs.add(Preconditions.checkNotNull(reg, ""Error: Register argument can not be null""));
	 }
	 public RegisterSetLatticeElement copy() {
		 return new RegisterSetLatticeElement(m_taintedRegs, m_newlyTaintedRegs, m_untaintedRegs, m_readRegs, m_updatedRegs);
	 }
	 public Collection<String> getNewlyTaintedRegisters() {
		 return Collections.unmodifiableCollection(m_nativeNewlyTaintedRegs);
	 }
	 public Collection<String> getReadRegisters() {
		 return Collections.unmodifiableCollection(m_nativeReadRegs);
	 }
	 public Collection<String> getTaintedRegisters() {
		 return Collections.unmodifiableCollection(m_taintedRegs);
	 }
	 public Collection<String> getUntaintedRegisters() {
		 return Collections.unmodifiableCollection(m_nativeUntaintedRegs);
	 }
	 public Collection<String> getUpdatedRegisters() {
		 return Collections.unmodifiableCollection(m_nativeUpdatedRegs);
	 }
	 public boolean isSmallerEqual(final RegisterSetLatticeElement other) {
		 Preconditions.checkNotNull(other, ""Error: Other argument can not be null"");
		 final boolean result = other.m_taintedRegs.containsAll(m_taintedRegs) && other.m_newlyTaintedRegs.containsAll(m_newlyTaintedRegs) && other.m_untaintedRegs.containsAll(m_untaintedRegs) && other.m_readRegs.containsAll(m_readRegs) && other.m_updatedRegs.containsAll(m_updatedRegs) && other.m_nativeNewlyTaintedRegs.containsAll(m_nativeNewlyTaintedRegs) && other.m_nativeReadRegs.containsAll(m_nativeReadRegs) && other.m_nativeUntaintedRegs.containsAll(m_nativeUntaintedRegs) && other.m_nativeUpdatedRegs.containsAll(m_nativeUpdatedRegs);
		 return result;
	 }
	 public boolean isTainted(final Collection<String> registers) {
		 Preconditions.checkNotNull(registers, ""Error: Registers argument can not be null"");
		 for (final String register : registers) {
			 if (m_taintedRegs.contains(register)) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public boolean isTainted(final String register) {
		 return m_taintedRegs.contains(Preconditions.checkNotNull(register, ""Error: Register argument can not be null""));
	 }
	 public void onInstructionExit() {
		 clearTemporaryRegisters(m_taintedRegs);
		 clearTemporaryRegisters(m_newlyTaintedRegs);
		 clearTemporaryRegisters(m_untaintedRegs);
		 clearTemporaryRegisters(m_readRegs);
		 clearTemporaryRegisters(m_updatedRegs);
		 m_nativeNewlyTaintedRegs = ImmutableSet.copyOf(m_newlyTaintedRegs);
		 m_nativeUntaintedRegs = ImmutableSet.copyOf(m_untaintedRegs);
		 m_nativeReadRegs = ImmutableSet.copyOf(m_readRegs);
		 m_nativeUpdatedRegs = ImmutableSet.copyOf(m_updatedRegs);
		 m_newlyTaintedRegs.clear();
		 m_untaintedRegs.clear();
		 m_readRegs.clear();
		 m_updatedRegs.clear();
	 }
	 public void taint(final String register) {
		 Preconditions.checkNotNull(register, ""Error: Register argument can not be null"");
		 if (isTainted(register) || m_untaintedRegs.contains(register)) {
			 m_updatedRegs.add(register);
		 }
		 else {
			 m_newlyTaintedRegs.add(register);
		 }
		 m_taintedRegs.add(register);
		 m_untaintedRegs.remove(register);
	 }
	 public void taintAll(final Collection<String> registers) {
		 Preconditions.checkNotNull(registers, ""Error: State argument can not be null"");
		 for (final String taintedRegister : registers) {
			 taint(taintedRegister);
		 }
	 }
	 public String toString() {
		 final StringBuilder builder = new StringBuilder();
		 builder.append(""Preserved added registers: "" + m_nativeNewlyTaintedRegs + ""\n"");
		 builder.append(""Preserved untainted registers: "" + m_nativeUntaintedRegs + ""\n"");
		 builder.append(""Preserved read registers: "" + m_nativeReadRegs + ""\n"");
		 builder.append(""Preserved updated registers: "" + m_nativeUpdatedRegs + ""\n"");
		 builder.append(""Tainted registers: "" + m_taintedRegs + ""\n"");
		 builder.append(""Added registers: "" + m_newlyTaintedRegs + ""\n"");
		 builder.append(""Untainted registers: "" + m_untaintedRegs + ""\n"");
		 builder.append(""Read registers: "" + m_readRegs + ""\n"");
		 builder.append(""Updated registers: "" + m_updatedRegs + ""\n"");
		 return builder.toString();
	 }
	 public void untaint(final String register) {
		 Preconditions.checkNotNull(register, ""Error: Register argument can not be null"");
		 if (isTainted(register)) {
			 m_untaintedRegs.add(register);
			 m_taintedRegs.remove(register);
		 }
	 }
	 public void untaintAll(final Collection<String> registers) {
		 Preconditions.checkNotNull(registers, ""Error: Registers argument can not be null"");
		 for (final String register : registers) {
			 untaint(register);
		 }
	 }
}",0,0,0,0
"public class HtmlToTextFixture extends ColumnFixture {
	public String HTML;
	public String Text() {
		HTML = HTML.replaceAll(""\\\\u00a0"", ""\u00a0"");
		return escapeAscii(Parse.htmlToText(HTML));
	}
	private String escapeAscii(String text) {
		text = text.replaceAll(""\\x0a"", ""\\\\n"");
		text = text.replaceAll(""\\x0d"", ""\\\\r"");
		text = text.replaceAll(""\\xa0"", ""\\\\u00a0"");
		return text;
	}
}",0,0,0,0
"final class SequenceTermination extends TimerTask {
	 private long maxInactivityTimeout;
	 void updateInactivityTimeout(long timeout) {
		 maxInactivityTimeout = Math.max(maxInactivityTimeout, timeout);
	 }
	 public void run() {
		 synchronized (DestinationSequence.this) {
			 DestinationSequence.this.scheduledTermination = null;
			 RMEndpoint rme = destination.getReliableEndpoint();
			 long lat = Math.max(rme.getLastControlMessage(), rme.getLastApplicationMessage());
			 if (0 == lat) {
				 return;
			 }
			 long now = System.currentTimeMillis();
			 if (now - lat >= maxInactivityTimeout) {
				 LogUtils.log(LOG, Level.WARNING, ""TERMINATING_INACTIVE_SEQ_MSG"", DestinationSequence.this.getIdentifier().getValue());
				 DestinationSequence.this.destination.terminateSequence(DestinationSequence.this, true);
				 Source source = rme.getSource();
				 if (source != null) {
					 SourceSequence ss = source.getAssociatedSequence(DestinationSequence.this.getIdentifier());
					 if (ss != null) {
						 source.removeSequence(ss);
					 }
				 }
			 }
			 else {
				 SequenceTermination st = new SequenceTermination();
				 st.updateInactivityTimeout(maxInactivityTimeout);
				 DestinationSequence.this.destination.getManager().getTimer() .schedule(st, maxInactivityTimeout);
			 }
		 }
	 }
 }",1,0,0,0
"private static class GridMBeanServerData {
	 private Collection<String> igniteInstanceNames = new HashSet<>();
	 private ObjectName mbean;
	 private int cnt;
	 GridMBeanServerData(ObjectName mbean) {
		 assert mbean != null;
		 this.mbean = mbean;
	 }
	 public void addIgniteInstance(String igniteInstanceName) {
		 igniteInstanceNames.add(igniteInstanceName);
	 }
	 public void removeIgniteInstance(String igniteInstanceName) {
		 igniteInstanceNames.remove(igniteInstanceName);
	 }
	 public boolean containsIgniteInstance(String igniteInstanceName) {
		 return igniteInstanceNames.contains(igniteInstanceName);
	 }
	 public ObjectName getMbean() {
		 return mbean;
	 }
	 public int getCounter() {
		 return cnt;
	 }
	 public void setCounter(int cnt) {
		 this.cnt = cnt;
	 }
 }",0,1,0,0
"public void setFiltering(boolean filtering) {
	 this.filtering = filtering;
 }",0,0,0,0
"public class AntVersion extends Task implements Condition {
	 private String atLeast = null;
	 private String exactly = null;
	 private String propertyname = null;
	 public void execute() throws BuildException {
		 if (propertyname == null) {
			 throw new BuildException(""'property' must be set."");
		 }
		 if (atLeast!=null || exactly!=null) {
			 if (eval()) {
				 getProject().setNewProperty(propertyname, getVersion().toString());
			 }
		 }
		 else {
			 getProject().setNewProperty(propertyname, getVersion().toString());
		 }
	 }
	 public boolean eval() throws BuildException {
		 validate();
		 DeweyDecimal actual = getVersion();
		 if (null != atLeast) {
			 return actual.isGreaterThanOrEqual(new DeweyDecimal(atLeast));
		 }
		 if (null != exactly) {
			 return actual.isEqual(new DeweyDecimal(exactly));
		 }
		 return false;
	 }
	 private void validate() throws BuildException {
		 if (atLeast != null && exactly != null) {
			 throw new BuildException(""Only one of atleast or exactly may be set."");
		 }
		 if (null == atLeast && null == exactly) {
			 throw new BuildException(""One of atleast or exactly must be set."");
		 }
		 if (atLeast != null) {
			 try {
				 new DeweyDecimal(atLeast);
			 }
			 catch (NumberFormatException e) {
				 throw new BuildException( ""The 'atleast' attribute is not a Dewey Decimal eg 1.1.0 : "" + atLeast);
			 }
		 }
		 else {
			 try {
				 new DeweyDecimal(exactly);
			 }
			 catch (NumberFormatException e) {
				 throw new BuildException( ""The 'exactly' attribute is not a Dewey Decimal eg 1.1.0 : "" + exactly);
			 }
		 }
	 }
	 private DeweyDecimal getVersion() {
		 Project p = new Project();
		 p.init();
		 char[] versionString = p.getProperty(""ant.version"").toCharArray();
		 StringBuffer sb = new StringBuffer();
		 boolean foundFirstDigit = false;
		 for (int i = 0;
		 i < versionString.length;
		 i++) {
			 if (Character.isDigit(versionString[i])) {
				 sb.append(versionString[i]);
				 foundFirstDigit = true;
			 }
			 if (versionString[i] == '.' && foundFirstDigit) {
				 sb.append(versionString[i]);
			 }
			 if (Character.isLetter(versionString[i]) && foundFirstDigit) {
				 break;
			 }
		 }
		 return new DeweyDecimal(sb.toString());
	 }
	 public String getAtLeast() {
		 return atLeast;
	 }
	 public void setAtLeast(String atLeast) {
		 this.atLeast = atLeast;
	 }
	 public String getExactly() {
		 return exactly;
	 }
	 public void setExactly(String exactly) {
		 this.exactly = exactly;
	 }
	 public String getProperty() {
		 return propertyname;
	 }
	 public void setProperty(String propertyname) {
		 this.propertyname = propertyname;
	 }
}",0,0,0,0
"public long getCreationTime(){
	return creationTime;
}",0,0,0,0
"public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException {
	 for (int i = 0;
	 i < this.filters.length;
	 i++) {
		 initScore = this.filters[i].indexerScore(url, doc, dbDatum, fetchDatum, parse, inlinks, initScore);
	 }
	 return initScore;
 }",0,0,0,0
"public class StringTokenizer extends ProjectComponent implements Tokenizer {
	 private static final int NOT_A_CHAR = -2;
	 private String intraString = """";
	 private int pushed = NOT_A_CHAR;
	 private char[] delims = null;
	 private boolean delimsAreTokens = false;
	 private boolean suppressDelims = false;
	 private boolean includeDelims = false;
	 public void setDelims(String delims) {
		 this.delims = StringUtils.resolveBackSlash(delims).toCharArray();
	 }
	 public void setDelimsAreTokens(boolean delimsAreTokens) {
		 this.delimsAreTokens = delimsAreTokens;
	 }
	 public void setSuppressDelims(boolean suppressDelims) {
		 this.suppressDelims = suppressDelims;
	 }
	 public void setIncludeDelims(boolean includeDelims) {
		 this.includeDelims = includeDelims;
	 }
	 public String getToken(Reader in) throws IOException {
		 int ch = -1;
		 if (pushed != NOT_A_CHAR) {
			 ch = pushed;
			 pushed = NOT_A_CHAR;
		 }
		 else {
			 ch = in.read();
		 }
		 if (ch == -1) {
			 return null;
		 }
		 boolean inToken = true;
		 intraString = """";
		 StringBuffer word = new StringBuffer();
		 StringBuffer padding = new StringBuffer();
		 while (ch != -1) {
			 char c = (char) ch;
			 boolean isDelim = isDelim(c);
			 if (inToken) {
				 if (isDelim) {
					 if (delimsAreTokens) {
						 if (word.length() == 0) {
							 word.append(c);
						 }
						 else {
							 pushed = ch;
						 }
						 break;
					 }
					 padding.append(c);
					 inToken = false;
				 }
				 else {
					 word.append(c);
				 }
			 }
			 else {
				 if (isDelim) {
					 padding.append(c);
				 }
				 else {
					 pushed = ch;
					 break;
				 }
			 }
			 ch = in.read();
		 }
		 intraString = padding.toString();
		 if (includeDelims) {
			 word.append(intraString);
		 }
		 return word.toString();
	 }
	 public String getPostToken() {
		 return suppressDelims || includeDelims ? """" : intraString;
	 }
	 private boolean isDelim(char ch) {
		 if (delims == null) {
			 return Character.isWhitespace(ch);
		 }
		 for (int i = 0;
		 i < delims.length;
		 ++i) {
			 if (delims[i] == ch) {
				 return true;
			 }
		 }
		 return false;
	 }
}",0,0,0,0
"public class ZoomerXmlBean{
	 private double zoom;
	 private double oldZoom;
	 private boolean enabled;
	 private boolean hideScrollbars;
	 public double getZoom() {
		 return zoom;
	 }
	 public void setZoom(double zoom) {
		 this.zoom = zoom;
	 }
	 public double getOldZoom() {
		 return oldZoom;
	 }
	 public void setOldZoom(double oldZoom) {
		 this.oldZoom = oldZoom;
	 }
	 public boolean isEnabled() {
		 return enabled;
	 }
	 public void setEnabled(boolean enabled) {
		 this.enabled = enabled;
	 }
	 public boolean isHideScrollbars() {
		 return hideScrollbars;
	 }
	 public void setHideScrollbars(boolean hideScrollbars) {
		 this.hideScrollbars = hideScrollbars;
	 }
}",0,1,0,0
"public class ActorAddFeature extends AbstractAddShapeFeature {
	 private final static Logger LOGGER = LoggerFactory.getLogger(ActorAddFeature.class);
	 public ActorAddFeature(IFeatureProvider fp) {
		 super(fp);
	 }
	 protected void link(IContext context, PictogramElement pe, Object businessObject, Category... categories) {
		 super.link(pe, businessObject);
		 for (Category category : categories) {
			 category.storeIn(pe);
		 }
		 if (businessObject instanceof NamedObj) {
			 Graphiti.getPeService().setPropertyValue(pe, FeatureConstants.BO_NAME, ((NamedObj) businessObject).getName());
			 String iconResource = (String) context.getProperty(""icon"");
			 if(iconResource!=null) {
				 Graphiti.getPeService().setPropertyValue(pe, FeatureConstants.ICON, iconResource);
			 }
			 String iconType = (String) context.getProperty(""iconType"");
			 if(iconType!=null) {
				 Graphiti.getPeService().setPropertyValue(pe, FeatureConstants.ICON_TYPE, iconType);
			 }
		 }
		 Graphiti.getPeService().setPropertyValue(pe, FeatureConstants.BO_CLASS, businessObject.getClass().getName());
	 }
	 public boolean canAdd(IAddContext context) {
		 return (context.getNewObject() instanceof Actor);
	 }
	 public PictogramElement add(IAddContext context) {
		 Entity addedActor = (Entity) context.getNewObject();
		 ContainerShape targetContainer = context.getTargetContainer();
		 int xLocation = context.getX();
		 int yLocation = context.getY();
		 IPeCreateService peCreateService = Graphiti.getPeCreateService();
		 IGaService gaService = Graphiti.getGaService();
		 ContainerShape containerShape = peCreateService.createContainerShape(targetContainer, true);
		 link(context, containerShape, addedActor, BoCategory.Actor);
		 GraphicsAlgorithm invisibleRectangle = null;
		 invisibleRectangle = gaService.createInvisibleRectangle(containerShape);
		 GraphicsAlgorithm actorShapeGA = null;
		 String iconResource = (String) context.getProperty(""icon"");
		 String iconType = (String) context.getProperty(""iconType"");
		 switch (iconType) {
			 case TriqFeatureProvider.ICONTYPE_SVG: case TriqFeatureProvider.ICONTYPE_PTOLEMY: actorShapeGA = buildExternallyDefinedShape(context, gaService, invisibleRectangle, containerShape, iconType, iconResource);
			 break;
			 default: actorShapeGA = buildDefaultShape(context, gaService, invisibleRectangle, containerShape, addedActor, iconResource);
		 }
		 int width = actorShapeGA.getWidth();
		 int height = actorShapeGA.getHeight();
		 gaService.setLocationAndSize(invisibleRectangle, xLocation, yLocation, width + 2*ACTOR_X_MARGIN, height + 2*ACTOR_Y_MARGIN);
		 Map<Direction, List<Port>> categorizedPorts = addedActor.getPorts().stream().collect(groupingBy(Port::getDirection, mapping(Function.identity(), toList())));
		 categorizedPorts.forEach((direction, ports) -> createAnchorsAndPortShapesForDirection(context, containerShape, direction, ports));
		 layoutPictogramElement(containerShape);
		 return containerShape;
	 }
	 protected GraphicsAlgorithm buildDefaultShape(IAddContext context, IGaService gaService, GraphicsAlgorithm invisibleRectangle, ContainerShape containerShape, Entity addedActor, String iconResource) {
		 IPeCreateService peCreateService = Graphiti.getPeCreateService();
		 int width = ACTOR_VISIBLE_WIDTH;
		 int height = ACTOR_VISIBLE_HEIGHT;
		 RoundedRectangle actorShapeGA = gaService.createRoundedRectangle(invisibleRectangle, 5, 5);
		 actorShapeGA.setForeground(manageColor(ACTOR_FOREGROUND));
		 actorShapeGA.setBackground(manageColor(ACTOR_BACKGROUND));
		 actorShapeGA.setLineWidth(2);
		 gaService.setLocationAndSize(actorShapeGA, ACTOR_X_MARGIN, ACTOR_Y_MARGIN, width, height);
		 if (!StringUtils.isBlank(iconResource)) {
			 try {
				 final Shape shape = peCreateService.createShape(containerShape, false);
				 final Image image = gaService.createImage(shape, iconResource);
				 addedActor.setIconId(iconResource);
				 gaService.setLocationAndSize(image, ACTOR_ICON_X_MARGIN, ACTOR_ICON_Y_MARGIN, ACTOR_ICON_SIZE, ACTOR_ICON_SIZE);
				 link(context, shape, addedActor, BoCategory.Actor);
			 }
			 catch (Exception e) {
				 LOGGER.error(ErrorCode.MODEL_CONFIGURATION_ERROR + "" - Error trying to add actor icon for "" + addedActor, e);
			 }
		 }
		 {
			 Shape shape = peCreateService.createShape(containerShape, false);
			 Polyline polyline = gaService.createPolyline(shape, ACTOR_TEXT_UNDERLINE_SHAPE);
			 polyline.setForeground(manageColor(ACTOR_FOREGROUND));
			 polyline.setLineWidth(2);
			 link(context, shape, addedActor, BoCategory.Actor);
		 }
		 {
			 Shape shape = peCreateService.createShape(containerShape, false);
			 Text text = gaService.createText(shape, addedActor.getName());
			 text.setForeground(manageColor(ACTOR_NAME_FOREGROUND));
			 text.setHorizontalAlignment(Orientation.ALIGNMENT_CENTER);
			 text.setFont(gaService.manageDefaultFont(getDiagram(), false, true));
			 gaService.setLocationAndSize(text, ACTOR_TEXT_X_MARGIN, ACTOR_Y_MARGIN, ACTOR_TEXT_WIDTH, ACTOR_TEXT_HEIGHT);
			 link(context, shape, addedActor, BoCategory.Actor);
			 IDirectEditingInfo directEditingInfo = getFeatureProvider().getDirectEditingInfo();
			 directEditingInfo.setMainPictogramElement(containerShape);
			 directEditingInfo.setPictogramElement(shape);
			 directEditingInfo.setGraphicsAlgorithm(text);
		 }
		 return actorShapeGA;
	 }
	 protected GraphicsAlgorithm buildExternallyDefinedShape(IAddContext context, IGaService gaService, GraphicsAlgorithm invisibleRectangle, ContainerShape containerShape, String iconType, String iconResource) {
		 GraphicsAlgorithm extFigure = Graphiti.getGaCreateService().createPlatformGraphicsAlgorithm(invisibleRectangle, iconType);
		 {
			 Property property = MmFactory.eINSTANCE.createProperty();
			 property.setKey(""iconType"");
			 property.setValue(iconType);
			 extFigure.getProperties().add(property);
		 }
		 {
			 Property property = MmFactory.eINSTANCE.createProperty();
			 property.setKey(""iconResource"");
			 property.setValue(iconResource);
			 extFigure.getProperties().add(property);
		 }
		 gaService.setLocationAndSize(extFigure, ACTOR_X_MARGIN, ACTOR_Y_MARGIN, 40, 40);
		 return extFigure;
	 }
	 private void createAnchorsAndPortShapesForDirection(IAddContext context, ContainerShape containerShape, Direction direction, List<Port> portList) {
		 Map<String, Anchor> anchorMap = (Map<String, Anchor>) context.getProperty(FeatureConstants.ANCHORMAP_NAME);
		 int portCount = portList.size();
		 for (int i = 0;
		 i < portCount;
		 ++i) {
			 Port p = portList.get(i);
			 Anchor anchor = PortShapes.createAnchor(containerShape, direction, p, i, portCount);
			 PortShapes.createPortShape(getDiagram(), anchor, direction, p);
			 link(context, anchor, p, BoCategory.Port, PortCategory.valueOf(direction));
			 if (anchorMap != null) {
				 anchorMap.put(p.getFullName(), anchor);
			 }
		 }
	 }
}",1,0,0,0
"public interface CassandraSieveRepositoryModule {
	 CassandraModule MODULE = CassandraModule.builder() .table(CassandraSieveTable.TABLE_NAME) .comment(""Holds SIEVE scripts."") .options(options -> options) .statement(statement -> statement .addPartitionKey(CassandraSieveTable.USER_NAME, text()) .addClusteringColumn(CassandraSieveTable.SCRIPT_NAME, text()) .addColumn(CassandraSieveTable.SCRIPT_CONTENT, text()) .addColumn(CassandraSieveTable.IS_ACTIVE, cboolean()) .addColumn(CassandraSieveTable.SIZE, bigint())) .table(CassandraSieveSpaceTable.TABLE_NAME) .comment(""Holds per user current space occupied by SIEVE scripts."") .options(options -> options) .statement(statement -> statement .addPartitionKey(CassandraSieveSpaceTable.USER_NAME, text()) .addColumn(CassandraSieveSpaceTable.SPACE_USED, counter())) .table(CassandraSieveQuotaTable.TABLE_NAME) .comment(""Holds per user size limitations for SIEVE script storage."") .options(options -> options) .statement(statement -> statement .addPartitionKey(CassandraSieveQuotaTable.USER_NAME, text()) .addColumn(CassandraSieveQuotaTable.QUOTA, bigint())) .table(CassandraSieveClusterQuotaTable.TABLE_NAME) .comment(""Holds default size limitations for SIEVE script storage."") .options(options -> options) .statement(statement -> statement .addPartitionKey(CassandraSieveClusterQuotaTable.NAME, text()) .addColumn(CassandraSieveClusterQuotaTable.VALUE, bigint())) .table(CassandraSieveActiveTable.TABLE_NAME) .comment(""Denormalisation table. Allows per user direct active SIEVE script retrieval."") .options(options -> options) .statement(statement -> statement .addPartitionKey(CassandraSieveActiveTable.USER_NAME, text()) .addColumn(CassandraSieveActiveTable.SCRIPT_NAME, text()) .addColumn(CassandraSieveActiveTable.DATE, timestamp())) .build();
}",1,0,0,0
"public class BC_dsub extends JTTTest {
	 public static double test(double a, double b) {
		 return a - b;
	 }
	 public void run0() throws Throwable {
		 runTest(""test"", 0.0d, 0.0d);
	 }
	 public void run1() throws Throwable {
		 runTest(""test"", 1.0d, 1.0d);
	 }
	 public void run2() throws Throwable {
		 runTest(""test"", 253.11d, 54.43d);
	 }
}",0,0,0,0
"public class UsageServiceImpl extends ManagerBase implements UsageService, Manager {
	 public static final Logger s_logger = Logger.getLogger(UsageServiceImpl.class);
	 private AccountDao _accountDao;
	 private DomainDao _domainDao;
	 private UsageDao _usageDao;
	 private UsageJobDao _usageJobDao;
	 private ConfigurationDao _configDao;
	 private ProjectManager _projectMgr;
	 private TimeZone _usageTimezone;
	 private AccountService _accountService;
	 private VMInstanceDao _vmDao;
	 private SnapshotDao _snapshotDao;
	 private SecurityGroupDao _sgDao;
	 private VpnUserDao _vpnUserDao;
	 private PortForwardingRulesDao _pfDao;
	 private LoadBalancerDao _lbDao;
	 private VMTemplateDao _vmTemplateDao;
	 private VolumeDao _volumeDao;
	 private IPAddressDao _ipDao;
	 private HostDao _hostDao;
	 public UsageServiceImpl() {
	 }
	 public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
		 super.configure(name, params);
		 String timeZoneStr = _configDao.getValue(Config.UsageAggregationTimezone.toString());
		 if (timeZoneStr == null) {
			 timeZoneStr = ""GMT"";
		 }
		 _usageTimezone = TimeZone.getTimeZone(timeZoneStr);
		 return true;
	 }
	 public boolean generateUsageRecords(GenerateUsageRecordsCmd cmd) {
		 TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);
		 try {
			 UsageJobVO immediateJob = _usageJobDao.getNextImmediateJob();
			 if (immediateJob == null) {
				 UsageJobVO job = _usageJobDao.getLastJob();
				 String host = null;
				 int pid = 0;
				 if (job != null) {
					 host = job.getHost();
					 pid = ((job.getPid() == null) ? 0 : job.getPid().intValue());
				 }
				 _usageJobDao.createNewJob(host, pid, UsageJobVO.JOB_TYPE_SINGLE);
			 }
		 }
		 finally {
			 txn.close();
			 TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);
			 swap.close();
		 }
		 return true;
	 }
	 public Pair<List<? extends Usage>, Integer> getUsageRecords(GetUsageRecordsCmd cmd) {
		 Long accountId = cmd.getAccountId();
		 Long domainId = cmd.getDomainId();
		 String accountName = cmd.getAccountName();
		 Account userAccount = null;
		 Account caller = CallContext.current().getCallingAccount();
		 Long usageType = cmd.getUsageType();
		 Long projectId = cmd.getProjectId();
		 String usageId = cmd.getUsageId();
		 if (projectId != null) {
			 if (accountId != null) {
				 throw new InvalidParameterValueException(""Projectid and accountId can't be specified together"");
			 }
			 Project project = _projectMgr.getProject(projectId);
			 if (project == null) {
				 throw new InvalidParameterValueException(""Unable to find project by id "" + projectId);
			 }
			 accountId = project.getProjectAccountId();
		 }
		 if ((accountId == null) && (accountName != null) && (domainId != null)) {
			 if (_domainDao.isChildDomain(caller.getDomainId(), domainId)) {
				 Filter filter = new Filter(AccountVO.class, ""id"", Boolean.FALSE, null, null);
				 List<AccountVO> accounts = _accountDao.listAccounts(accountName, domainId, filter);
				 if (accounts.size() > 0) {
					 userAccount = accounts.get(0);
				 }
				 if (userAccount != null) {
					 accountId = userAccount.getId();
				 }
				 else {
					 throw new InvalidParameterValueException(""Unable to find account "" + accountName + "" in domain "" + domainId);
				 }
			 }
			 else {
				 throw new PermissionDeniedException(""Invalid Domain Id or Account"");
			 }
		 }
		 boolean isAdmin = false;
		 boolean isDomainAdmin = false;
		 if (accountId == null) {
			 accountId = caller.getId();
			 if (_accountService.isRootAdmin(caller.getId())) {
				 isAdmin = true;
			 }
			 else if (_accountService.isDomainAdmin(caller.getId())) {
				 isDomainAdmin = true;
			 }
			 s_logger.debug(""Account details not available. Using userContext accountId: "" + accountId);
		 }
		 Date startDate = cmd.getStartDate();
		 Date endDate = cmd.getEndDate();
		 if (startDate.after(endDate)) {
			 throw new InvalidParameterValueException(""Incorrect Date Range. Start date: "" + startDate + "" is after end date:"" + endDate);
		 }
		 TimeZone usageTZ = getUsageTimezone();
		 Date adjustedStartDate = computeAdjustedTime(startDate, usageTZ);
		 Date adjustedEndDate = computeAdjustedTime(endDate, usageTZ);
		 if (s_logger.isDebugEnabled()) {
			 s_logger.debug(""getting usage records for account: "" + accountId + "", domainId: "" + domainId + "", between "" + adjustedStartDate + "" and "" + adjustedEndDate + "", using pageSize: "" + cmd.getPageSizeVal() + "" and startIndex: "" + cmd.getStartIndex());
		 }
		 Filter usageFilter = new Filter(UsageVO.class, ""id"", true, cmd.getStartIndex(), cmd.getPageSizeVal());
		 SearchCriteria<UsageVO> sc = _usageDao.createSearchCriteria();
		 if (accountId != -1 && accountId != Account.ACCOUNT_ID_SYSTEM && !isAdmin && !isDomainAdmin) {
			 sc.addAnd(""accountId"", SearchCriteria.Op.EQ, accountId);
		 }
		 if (isDomainAdmin) {
			 SearchCriteria<DomainVO> sdc = _domainDao.createSearchCriteria();
			 sdc.addOr(""path"", SearchCriteria.Op.LIKE, _domainDao.findById(caller.getDomainId()).getPath() + ""%"");
			 List<DomainVO> domains = _domainDao.search(sdc, null);
			 List<Long> domainIds = new ArrayList<Long>();
			 for (DomainVO domain : domains) domainIds.add(domain.getId());
			 sc.addAnd(""domainId"", SearchCriteria.Op.IN, domainIds.toArray());
		 }
		 if (domainId != null) {
			 sc.addAnd(""domainId"", SearchCriteria.Op.EQ, domainId);
		 }
		 if (usageType != null) {
			 sc.addAnd(""usageType"", SearchCriteria.Op.EQ, usageType);
		 }
		 if (usageId != null) {
			 if (usageType == null) {
				 throw new InvalidParameterValueException(""Usageid must be specified together with usageType"");
			 }
			 Long usageDbId = null;
			 switch (usageType.intValue()) {
				 case UsageTypes.NETWORK_BYTES_RECEIVED: case UsageTypes.NETWORK_BYTES_SENT: case UsageTypes.RUNNING_VM: case UsageTypes.ALLOCATED_VM: case UsageTypes.VM_SNAPSHOT: VMInstanceVO vm = _vmDao.findByUuidIncludingRemoved(usageId);
				 if (vm != null) {
					 usageDbId = vm.getId();
				 }
				 if (vm == null && (usageType == UsageTypes.NETWORK_BYTES_RECEIVED || usageType == UsageTypes.NETWORK_BYTES_SENT)) {
					 HostVO host = _hostDao.findByUuidIncludingRemoved(usageId);
					 if (host != null) {
						 usageDbId = host.getId();
					 }
				 }
				 break;
				 case UsageTypes.SNAPSHOT: SnapshotVO snap = _snapshotDao.findByUuidIncludingRemoved(usageId);
				 if (snap != null) {
					 usageDbId = snap.getId();
				 }
				 break;
				 case UsageTypes.TEMPLATE: case UsageTypes.ISO: VMTemplateVO tmpl = _vmTemplateDao.findByUuidIncludingRemoved(usageId);
				 if (tmpl != null) {
					 usageDbId = tmpl.getId();
				 }
				 break;
				 case UsageTypes.LOAD_BALANCER_POLICY: LoadBalancerVO lb = _lbDao.findByUuidIncludingRemoved(usageId);
				 if (lb != null) {
					 usageDbId = lb.getId();
				 }
				 break;
				 case UsageTypes.PORT_FORWARDING_RULE: PortForwardingRuleVO pf = _pfDao.findByUuidIncludingRemoved(usageId);
				 if (pf != null) {
					 usageDbId = pf.getId();
				 }
				 break;
				 case UsageTypes.VOLUME: case UsageTypes.VM_DISK_IO_READ: case UsageTypes.VM_DISK_IO_WRITE: case UsageTypes.VM_DISK_BYTES_READ: case UsageTypes.VM_DISK_BYTES_WRITE: VolumeVO volume = _volumeDao.findByUuidIncludingRemoved(usageId);
				 if (volume != null) {
					 usageDbId = volume.getId();
				 }
				 break;
				 case UsageTypes.VPN_USERS: VpnUserVO vpnUser = _vpnUserDao.findByUuidIncludingRemoved(usageId);
				 if (vpnUser != null) {
					 usageDbId = vpnUser.getId();
				 }
				 break;
				 case UsageTypes.SECURITY_GROUP: SecurityGroupVO sg = _sgDao.findByUuidIncludingRemoved(usageId);
				 if (sg != null) {
					 usageDbId = sg.getId();
				 }
				 break;
				 case UsageTypes.IP_ADDRESS: IPAddressVO ip = _ipDao.findByUuidIncludingRemoved(usageId);
				 if (ip != null) {
					 usageDbId = ip.getId();
				 }
				 break;
				 default: break;
			 }
			 if (usageDbId != null) {
				 sc.addAnd(""usageId"", SearchCriteria.Op.EQ, usageDbId);
			 }
			 else {
				 return new Pair<List<? extends Usage>, Integer>(new ArrayList<Usage>(), new Integer(0));
			 }
		 }
		 if ((adjustedStartDate != null) && (adjustedEndDate != null) && adjustedStartDate.before(adjustedEndDate)) {
			 sc.addAnd(""startDate"", SearchCriteria.Op.BETWEEN, adjustedStartDate, adjustedEndDate);
			 sc.addAnd(""endDate"", SearchCriteria.Op.BETWEEN, adjustedStartDate, adjustedEndDate);
		 }
		 else {
			 return new Pair<List<? extends Usage>, Integer>(new ArrayList<Usage>(), new Integer(0));
		 }
		 Pair<List<UsageVO>, Integer> usageRecords = null;
		 TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);
		 try {
			 usageRecords = _usageDao.searchAndCountAllRecords(sc, usageFilter);
		 }
		 finally {
			 txn.close();
			 TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);
			 swap.close();
		 }
		 return new Pair<List<? extends Usage>, Integer>(usageRecords.first(), usageRecords.second());
	 }
	 public TimeZone getUsageTimezone() {
		 return _usageTimezone;
	 }
	 public boolean removeRawUsageRecords(RemoveRawUsageRecordsCmd cmd) throws InvalidParameterValueException {
		 Integer interval = cmd.getInterval();
		 if (interval != null && interval > 0 ) {
			 String jobExecTime = _configDao.getValue(Config.UsageStatsJobExecTime.toString());
			 if (jobExecTime != null ) {
				 String[] segments = jobExecTime.split("":"");
				 if (segments.length == 2) {
					 String timeZoneStr = _configDao.getValue(Config.UsageExecutionTimezone.toString());
					 if (timeZoneStr == null) {
						 timeZoneStr = ""GMT"";
					 }
					 TimeZone tz = TimeZone.getTimeZone(timeZoneStr);
					 Calendar cal = Calendar.getInstance(tz);
					 cal.setTime(new Date());
					 long curTS = cal.getTimeInMillis();
					 cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(segments[0]));
					 cal.set(Calendar.MINUTE, Integer.parseInt(segments[1]));
					 cal.set(Calendar.SECOND, 0);
					 cal.set(Calendar.MILLISECOND, 0);
					 long execTS = cal.getTimeInMillis();
					 s_logger.debug(""Trying to remove old raw cloud_usage records older than "" + interval + "" day(s), current time="" + curTS + "" next job execution time="" + execTS);
					 if (Math.abs(curTS - execTS) < 15 * 60 * 1000) {
						 return false;
					 }
				 }
			 }
			 _usageDao.removeOldUsageRecords(interval);
		 }
		 else {
			 throw new InvalidParameterValueException(""Invalid interval value. Interval to remove cloud_usage records should be greater than 0"");
		 }
		 return true;
	 }
	 private Date computeAdjustedTime(Date initialDate, TimeZone targetTZ) {
		 Calendar cal = Calendar.getInstance();
		 cal.setTime(initialDate);
		 TimeZone localTZ = cal.getTimeZone();
		 int timezoneOffset = cal.get(Calendar.ZONE_OFFSET);
		 if (localTZ.inDaylightTime(initialDate)) {
			 timezoneOffset += (60 * 60 * 1000);
		 }
		 cal.add(Calendar.MILLISECOND, timezoneOffset);
		 Date newTime = cal.getTime();
		 Calendar calTS = Calendar.getInstance(targetTZ);
		 calTS.setTime(newTime);
		 timezoneOffset = calTS.get(Calendar.ZONE_OFFSET);
		 if (targetTZ.inDaylightTime(initialDate)) {
			 timezoneOffset += (60 * 60 * 1000);
		 }
		 calTS.add(Calendar.MILLISECOND, -1 * timezoneOffset);
		 return calTS.getTime();
	 }
	 public List<UsageTypeResponse> listUsageTypes() {
		 return UsageTypes.listUsageTypes();
	 }
}",1,0,0,0
"public void offerService() throws Exception {
	 long lastHeartbeat = 0, lastBlockReport = 0;
	 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
	 while (shouldRun) {
		 try {
			 long now = System.currentTimeMillis();
			 if (now - lastHeartbeat > heartBeatInterval) {
				 BlockCommand cmd = namenode.sendHeartbeat(dnRegistration, data.getCapacity(), data.getRemaining(), xmitsInProgress, xceiverCount.getValue());
				 lastHeartbeat = now;
				 if( cmd != null ) {
					 data.checkDataDir();
					 switch( cmd.action ) {
						 case DNA_TRANSFER: transferBlocks( cmd.getBlocks(), cmd.getTargets() );
						 break;
						 case DNA_INVALIDATE: Block toDelete[] = cmd.getBlocks();
						 data.invalidate(toDelete);
						 myMetrics.removedBlocks(toDelete.length);
						 break;
						 case DNA_SHUTDOWN: this.shutdown();
						 continue;
						 case DNA_REPORT: lastBlockReport = 0;
						 break;
						 default: LOG.warn( ""Unknown BlockCommand action: "" + cmd.action);
					 }
				 }
			 }
			 if (now - lastBlockReport > blockReportInterval) {
				 data.checkDataDir();
				 Block toDelete[] = namenode.blockReport(dnRegistration, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			 }
			 Block [] blockArray=null;
			 synchronized( receivedBlockList ) {
				 if (receivedBlockList.size() > 0) {
					 blockArray = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
				 }
			 }
			 if( blockArray != null ) {
				 namenode.blockReceived( dnRegistration, blockArray );
				 synchronized (receivedBlockList) {
					 for(Block b: blockArray) {
						 receivedBlockList.remove(b);
					 }
				 }
			 }
			 long waitTime = heartBeatInterval - (System.currentTimeMillis() - lastHeartbeat);
			 synchronized( receivedBlockList ) {
				 if (waitTime > 0 && receivedBlockList.size() == 0) {
					 try {
						 receivedBlockList.wait(waitTime);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
		 catch(DiskErrorException e) {
			 handleDiskError(e.getLocalizedMessage());
			 return;
		 }
		 catch( RemoteException re ) {
			 String reClass = re.getClassName();
			 if( UnregisteredDatanodeException.class.getName().equals( reClass )) {
				 LOG.warn( ""DataNode is shutting down: "" + StringUtils.stringifyException(re));
				 shutdown();
				 return;
			 }
			 LOG.warn(StringUtils.stringifyException(re));
		 }
		 catch (IOException e) {
			 LOG.warn(StringUtils.stringifyException(e));
		 }
	 }
 }",0,0,1,0
"public class RegExpImpl implements RegExpProxy {
	 public boolean isRegExp(Scriptable obj) {
		 return obj instanceof NativeRegExp;
	 }
	 public Object compileRegExp(Context cx, String source, String flags) {
		 return NativeRegExp.compileRE(cx, source, flags, false);
	 }
	 public Scriptable wrapRegExp(Context cx, Scriptable scope, Object compiled) {
		 return new NativeRegExp(scope, compiled);
	 }
	 public Object action(Context cx, Scriptable scope, Scriptable thisObj, Object[] args, int actionType) {
		 GlobData data = new GlobData();
		 data.mode = actionType;
		 switch (actionType) {
			 case RA_MATCH: {
				 Object rval;
				 data.optarg = 1;
				 rval = matchOrReplace(cx, scope, thisObj, args, this, data, false);
				 return data.arrayobj == null ? rval : data.arrayobj;
			 }
			 case RA_SEARCH: data.optarg = 1;
			 return matchOrReplace(cx, scope, thisObj, args, this, data, false);
			 case RA_REPLACE: {
				 Object arg1 = args.length < 2 ? Undefined.instance : args[1];
				 String repstr = null;
				 Function lambda = null;
				 if (arg1 instanceof Function) {
					 lambda = (Function) arg1;
				 }
				 else {
					 repstr = ScriptRuntime.toString(arg1);
				 }
				 data.optarg = 2;
				 data.lambda = lambda;
				 data.repstr = repstr;
				 data.dollar = repstr == null ? -1 : repstr.indexOf('$');
				 data.charBuf = null;
				 data.leftIndex = 0;
				 Object val = matchOrReplace(cx, scope, thisObj, args, this, data, true);
				 SubString rc = this.rightContext;
				 if (data.charBuf == null) {
					 if (data.global || val == null || !val.equals(Boolean.TRUE)) {
						 return data.str;
					 }
					 SubString lc = this.leftContext;
					 replace_glob(data, cx, scope, this, lc.index, lc.length);
				 }
				 data.charBuf.append(rc.charArray, rc.index, rc.length);
				 return data.charBuf.toString();
			 }
			 default: throw Kit.codeBug();
		 }
	 }
	 private static Object matchOrReplace(Context cx, Scriptable scope, Scriptable thisObj, Object[] args, RegExpImpl reImpl, GlobData data, boolean forceFlat) {
		 NativeRegExp re;
		 String str = ScriptRuntime.toString(thisObj);
		 data.str = str;
		 Scriptable topScope = ScriptableObject.getTopLevelScope(scope);
		 if (args.length == 0) {
			 Object compiled = NativeRegExp.compileRE(cx, """", """", false);
			 re = new NativeRegExp(topScope, compiled);
		 }
		 else if (args[0] instanceof NativeRegExp) {
			 re = (NativeRegExp) args[0];
		 }
		 else {
			 String src = ScriptRuntime.toString(args[0]);
			 String opt;
			 if (data.optarg < args.length) {
				 args[0] = src;
				 opt = ScriptRuntime.toString(args[data.optarg]);
			 }
			 else {
				 opt = null;
			 }
			 Object compiled = NativeRegExp.compileRE(cx, src, opt, forceFlat);
			 re = new NativeRegExp(topScope, compiled);
		 }
		 data.regexp = re;
		 data.global = (re.getFlags() & NativeRegExp.JSREG_GLOB) != 0;
		 int[] indexp = {
		 0 }
		;
		 Object result = null;
		 if (data.mode == RA_SEARCH) {
			 result = re.executeRegExp(cx, scope, reImpl, str, indexp, NativeRegExp.TEST);
			 if (result != null && result.equals(Boolean.TRUE)) result = new Integer(reImpl.leftContext.length);
			 else result = new Integer(-1);
		 }
		 else if (data.global) {
			 re.lastIndex = 0;
			 for (int count = 0;
			 indexp[0] <= str.length();
			 count++) {
				 result = re.executeRegExp(cx, scope, reImpl, str, indexp, NativeRegExp.TEST);
				 if (result == null || !result.equals(Boolean.TRUE)) break;
				 if (data.mode == RA_MATCH) {
					 match_glob(data, cx, scope, count, reImpl);
				 }
				 else {
					 if (data.mode != RA_REPLACE) Kit.codeBug();
					 SubString lastMatch = reImpl.lastMatch;
					 int leftIndex = data.leftIndex;
					 int leftlen = lastMatch.index - leftIndex;
					 data.leftIndex = lastMatch.index + lastMatch.length;
					 replace_glob(data, cx, scope, reImpl, leftIndex, leftlen);
				 }
				 if (reImpl.lastMatch.length == 0) {
					 if (indexp[0] == str.length()) break;
					 indexp[0]++;
				 }
			 }
		 }
		 else {
			 result = re.executeRegExp(cx, scope, reImpl, str, indexp, ((data.mode == RA_REPLACE) ? NativeRegExp.TEST : NativeRegExp.MATCH));
		 }
		 return result;
	 }
	 public int find_split(Context cx, Scriptable scope, String target, String separator, Scriptable reObj, int[] ip, int[] matchlen, boolean[] matched, String[][] parensp) {
		 int i = ip[0];
		 int length = target.length();
		 int result;
		 int version = cx.getLanguageVersion();
		 NativeRegExp re = (NativeRegExp) reObj;
		 again: while (true) {
			 int ipsave = ip[0];
			 ip[0] = i;
			 Object ret = re.executeRegExp(cx, scope, this, target, ip, NativeRegExp.TEST);
			 if (ret != Boolean.TRUE) {
				 ip[0] = ipsave;
				 matchlen[0] = 1;
				 matched[0] = false;
				 return length;
			 }
			 i = ip[0];
			 ip[0] = ipsave;
			 matched[0] = true;
			 SubString sep = this.lastMatch;
			 matchlen[0] = sep.length;
			 if (matchlen[0] == 0) {
				 if (i == ip[0]) {
					 if (i == length) {
						 if (version == Context.VERSION_1_2) {
							 matchlen[0] = 1;
							 result = i;
						 }
						 else result = -1;
						 break;
					 }
					 i++;
					 continue again;
				 }
			 }
			 result = i - matchlen[0];
			 break;
		 }
		 int size = (parens == null) ? 0 : parens.length;
		 parensp[0] = new String[size];
		 for (int num = 0;
		 num < size;
		 num++) {
			 SubString parsub = getParenSubString(num);
			 parensp[0][num] = parsub.toString();
		 }
		 return result;
	 }
	 SubString getParenSubString(int i) {
		 if (parens != null && i < parens.length) {
			 SubString parsub = parens[i];
			 if (parsub != null) {
				 return parsub;
			 }
		 }
		 return SubString.emptySubString;
	 }
	 private static void match_glob(GlobData mdata, Context cx, Scriptable scope, int count, RegExpImpl reImpl) {
		 if (mdata.arrayobj == null) {
			 Scriptable s = ScriptableObject.getTopLevelScope(scope);
			 mdata.arrayobj = ScriptRuntime.newObject(cx, s, ""Array"", null);
		 }
		 SubString matchsub = reImpl.lastMatch;
		 String matchstr = matchsub.toString();
		 mdata.arrayobj.put(count, mdata.arrayobj, matchstr);
	 }
	 private static void replace_glob(GlobData rdata, Context cx, Scriptable scope, RegExpImpl reImpl, int leftIndex, int leftlen) {
		 int replen;
		 String lambdaStr;
		 if (rdata.lambda != null) {
			 SubString[] parens = reImpl.parens;
			 int parenCount = (parens == null) ? 0 : parens.length;
			 Object[] args = new Object[parenCount + 3];
			 args[0] = reImpl.lastMatch.toString();
			 for (int i=0;
			 i < parenCount;
			 i++) {
				 SubString sub = parens[i];
				 if (sub != null) {
					 args[i+1] = sub.toString();
				 }
				 else {
					 args[i+1] = Undefined.instance;
				 }
			 }
			 args[parenCount+1] = new Integer(reImpl.leftContext.length);
			 args[parenCount+2] = rdata.str;
			 if (reImpl != ScriptRuntime.getRegExpProxy(cx)) Kit.codeBug();
			 RegExpImpl re2 = new RegExpImpl();
			 re2.multiline = reImpl.multiline;
			 re2.input = reImpl.input;
			 ScriptRuntime.setRegExpProxy(cx, re2);
			 try {
				 Scriptable parent = ScriptableObject.getTopLevelScope(scope);
				 Object result = rdata.lambda.call(cx, parent, parent, args);
				 lambdaStr = ScriptRuntime.toString(result);
			 }
			 finally {
				 ScriptRuntime.setRegExpProxy(cx, reImpl);
			 }
			 replen = lambdaStr.length();
		 }
		 else {
			 lambdaStr = null;
			 replen = rdata.repstr.length();
			 if (rdata.dollar >= 0) {
				 int[] skip = new int[1];
				 int dp = rdata.dollar;
				 do {
					 SubString sub = interpretDollar(cx, reImpl, rdata.repstr, dp, skip);
					 if (sub != null) {
						 replen += sub.length - skip[0];
						 dp += skip[0];
					 }
					 else {
						 ++dp;
					 }
					 dp = rdata.repstr.indexOf('$', dp);
				 }
				 while (dp >= 0);
			 }
		 }
		 int growth = leftlen + replen + reImpl.rightContext.length;
		 StringBuffer charBuf = rdata.charBuf;
		 if (charBuf == null) {
			 charBuf = new StringBuffer(growth);
			 rdata.charBuf = charBuf;
		 }
		 else {
			 charBuf.ensureCapacity(rdata.charBuf.length() + growth);
		 }
		 charBuf.append(reImpl.leftContext.charArray, leftIndex, leftlen);
		 if (rdata.lambda != null) {
			 charBuf.append(lambdaStr);
		 }
		 else {
			 do_replace(rdata, cx, reImpl);
		 }
	 }
	 private static SubString interpretDollar(Context cx, RegExpImpl res, String da, int dp, int[] skip) {
		 char dc;
		 int num, tmp;
		 if (da.charAt(dp) != '$') Kit.codeBug();
		 int version = cx.getLanguageVersion();
		 if (version != Context.VERSION_DEFAULT && version <= Context.VERSION_1_4) {
			 if (dp > 0 && da.charAt(dp - 1) == '\\') return null;
		 }
		 int daL = da.length();
		 if (dp + 1 >= daL) return null;
		 dc = da.charAt(dp + 1);
		 if (NativeRegExp.isDigit(dc)) {
			 int cp;
			 if (version != Context.VERSION_DEFAULT && version <= Context.VERSION_1_4) {
				 if (dc == '0') return null;
				 num = 0;
				 cp = dp;
				 while (++cp < daL && NativeRegExp.isDigit(dc = da.charAt(cp))) {
					 tmp = 10 * num + (dc - '0');
					 if (tmp < num) break;
					 num = tmp;
				 }
			 }
			 else {
				 int parenCount = (res.parens == null) ? 0 : res.parens.length;
				 num = dc - '0';
				 if (num > parenCount) return null;
				 cp = dp + 2;
				 if ((dp + 2) < daL) {
					 dc = da.charAt(dp + 2);
					 if (NativeRegExp.isDigit(dc)) {
						 tmp = 10 * num + (dc - '0');
						 if (tmp <= parenCount) {
							 cp++;
							 num = tmp;
						 }
					 }
				 }
				 if (num == 0) return null;
			 }
			 num--;
			 skip[0] = cp - dp;
			 return res.getParenSubString(num);
		 }
		 skip[0] = 2;
		 switch (dc) {
			 case '$': return new SubString(""$"");
			 case '&': return res.lastMatch;
			 case '+': return res.lastParen;
			 case '`': if (version == Context.VERSION_1_2) {
				 res.leftContext.index = 0;
				 res.leftContext.length = res.lastMatch.index;
			 }
			 return res.leftContext;
			 case '\'': return res.rightContext;
		 }
		 return null;
	 }
	 private static void do_replace(GlobData rdata, Context cx, RegExpImpl regExpImpl) {
		 StringBuffer charBuf = rdata.charBuf;
		 int cp = 0;
		 String da = rdata.repstr;
		 int dp = rdata.dollar;
		 if (dp != -1) {
			 int[] skip = new int[1];
			 do {
				 int len = dp - cp;
				 charBuf.append(da.substring(cp, dp));
				 cp = dp;
				 SubString sub = interpretDollar(cx, regExpImpl, da, dp, skip);
				 if (sub != null) {
					 len = sub.length;
					 if (len > 0) {
						 charBuf.append(sub.charArray, sub.index, len);
					 }
					 cp += skip[0];
					 dp += skip[0];
				 }
				 else {
					 ++dp;
				 }
				 dp = da.indexOf('$', dp);
			 }
			 while (dp >= 0);
		 }
		 int daL = da.length();
		 if (daL > cp) {
			 charBuf.append(da.substring(cp, daL));
		 }
	 }
	 String input;
	 boolean multiline;
	 SubString[] parens;
	 SubString lastMatch;
	 SubString lastParen;
	 SubString leftContext;
	 SubString rightContext;
 }
final class GlobData{
	 int mode;
	 int optarg;
	 boolean global;
	 String str;
	 NativeRegExp regexp;
	 Scriptable arrayobj;
	 Function lambda;
	 String repstr;
	 int dollar = -1;
	 StringBuffer charBuf;
	 int leftIndex;
 }",0,0,0,0
"public class MetricsException extends RuntimeException {
	 public MetricsException() {
	 }
	 public MetricsException(String message) {
		 super(message);
	 }
}",0,0,0,0
"public final class TraceInfo extends com.google.protobuf.GeneratedMessageV3 implements TraceInfoOrBuilder {
	private static final long serialVersionUID = 0L;
	 private TraceInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
		 super(builder);
	 }
	 private TraceInfo() {
		 traceId_ = """";
		 edgeId_ = """";
	 }
	 public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
		 return this.unknownFields;
	 }
	 private TraceInfo( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 this();
		 if (extensionRegistry == null) {
			 throw new java.lang.NullPointerException();
		 }
		 int mutable_bitField0_ = 0;
		 com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder();
		 try {
			 boolean done = false;
			 while (!done) {
				 int tag = input.readTag();
				 switch (tag) {
					 case 0: done = true;
					 break;
					 case 10: {
						 java.lang.String s = input.readStringRequireUtf8();
						 traceId_ = s;
						 break;
					 }
					 case 18: {
						 java.lang.String s = input.readStringRequireUtf8();
						 edgeId_ = s;
						 break;
					 }
					 default: {
						 if (!parseUnknownFieldProto3( input, unknownFields, extensionRegistry, tag)) {
							 done = true;
						 }
						 break;
					 }
				 }
			 }
		 }
		 catch (com.google.protobuf.InvalidProtocolBufferException e) {
			 throw e.setUnfinishedMessage(this);
		 }
		 catch (java.io.IOException e) {
			 throw new com.google.protobuf.InvalidProtocolBufferException( e).setUnfinishedMessage(this);
		 }
		 finally {
			 this.unknownFields = unknownFields.build();
			 makeExtensionsImmutable();
		 }
	 }
	 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
		 return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_descriptor;
	 }
	 protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
		 return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_fieldAccessorTable .ensureFieldAccessorsInitialized( com.facebook.buck.remoteexecution.proto.TraceInfo.class, com.facebook.buck.remoteexecution.proto.TraceInfo.Builder.class);
	 }
	 public static final int TRACE_ID_FIELD_NUMBER = 1;
	 private volatile java.lang.Object traceId_;
	 public java.lang.String getTraceId() {
		 java.lang.Object ref = traceId_;
		 if (ref instanceof java.lang.String) {
			 return (java.lang.String) ref;
		 }
		 else {
			 com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
			 java.lang.String s = bs.toStringUtf8();
			 traceId_ = s;
			 return s;
		 }
	 }
	 public com.google.protobuf.ByteString getTraceIdBytes() {
		 java.lang.Object ref = traceId_;
		 if (ref instanceof java.lang.String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 traceId_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public static final int EDGE_ID_FIELD_NUMBER = 2;
	 private volatile java.lang.Object edgeId_;
	 public java.lang.String getEdgeId() {
		 java.lang.Object ref = edgeId_;
		 if (ref instanceof java.lang.String) {
			 return (java.lang.String) ref;
		 }
		 else {
			 com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
			 java.lang.String s = bs.toStringUtf8();
			 edgeId_ = s;
			 return s;
		 }
	 }
	 public com.google.protobuf.ByteString getEdgeIdBytes() {
		 java.lang.Object ref = edgeId_;
		 if (ref instanceof java.lang.String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 edgeId_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 private byte memoizedIsInitialized = -1;
	 public final boolean isInitialized() {
		 byte isInitialized = memoizedIsInitialized;
		 if (isInitialized == 1) return true;
		 if (isInitialized == 0) return false;
		 memoizedIsInitialized = 1;
		 return true;
	 }
	 public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
		 if (!getTraceIdBytes().isEmpty()) {
			 com.google.protobuf.GeneratedMessageV3.writeString(output, 1, traceId_);
		 }
		 if (!getEdgeIdBytes().isEmpty()) {
			 com.google.protobuf.GeneratedMessageV3.writeString(output, 2, edgeId_);
		 }
		 unknownFields.writeTo(output);
	 }
	 public int getSerializedSize() {
		 int size = memoizedSize;
		 if (size != -1) return size;
		 size = 0;
		 if (!getTraceIdBytes().isEmpty()) {
			 size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, traceId_);
		 }
		 if (!getEdgeIdBytes().isEmpty()) {
			 size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, edgeId_);
		 }
		 size += unknownFields.getSerializedSize();
		 memoizedSize = size;
		 return size;
	 }
	 public boolean equals(final java.lang.Object obj) {
		 if (obj == this) {
			 return true;
		 }
		 if (!(obj instanceof com.facebook.buck.remoteexecution.proto.TraceInfo)) {
			 return super.equals(obj);
		 }
		 com.facebook.buck.remoteexecution.proto.TraceInfo other = (com.facebook.buck.remoteexecution.proto.TraceInfo) obj;
		 boolean result = true;
		 result = result && getTraceId() .equals(other.getTraceId());
		 result = result && getEdgeId() .equals(other.getEdgeId());
		 result = result && unknownFields.equals(other.unknownFields);
		 return result;
	 }
	 public int hashCode() {
		 if (memoizedHashCode != 0) {
			 return memoizedHashCode;
		 }
		 int hash = 41;
		 hash = (19 * hash) + getDescriptor().hashCode();
		 hash = (37 * hash) + TRACE_ID_FIELD_NUMBER;
		 hash = (53 * hash) + getTraceId().hashCode();
		 hash = (37 * hash) + EDGE_ID_FIELD_NUMBER;
		 hash = (53 * hash) + getEdgeId().hashCode();
		 hash = (29 * hash) + unknownFields.hashCode();
		 memoizedHashCode = hash;
		 return hash;
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data, extensionRegistry);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data, extensionRegistry);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data, extensionRegistry);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(java.io.InputStream input) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input, extensionRegistry);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseDelimitedWithIOException(PARSER, input);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseDelimitedFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( com.google.protobuf.CodedInputStream input) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input);
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input, extensionRegistry);
	 }
	 public Builder newBuilderForType() {
		 return newBuilder();
	 }
	 public static Builder newBuilder() {
		 return DEFAULT_INSTANCE.toBuilder();
	 }
	 public static Builder newBuilder(com.facebook.buck.remoteexecution.proto.TraceInfo prototype) {
		 return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
	 }
	 public Builder toBuilder() {
		 return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
	 }
	 protected Builder newBuilderForType( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
		 Builder builder = new Builder(parent);
		 return builder;
	 }
	 public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements com.facebook.buck.remoteexecution.proto.TraceInfoOrBuilder {
		 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
			 return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_descriptor;
		 }
		 protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			 return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_fieldAccessorTable .ensureFieldAccessorsInitialized( com.facebook.buck.remoteexecution.proto.TraceInfo.class, com.facebook.buck.remoteexecution.proto.TraceInfo.Builder.class);
		 }
		 private Builder() {
			 maybeForceBuilderInitialization();
		 }
		 private Builder( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
			 super(parent);
			 maybeForceBuilderInitialization();
		 }
		 private void maybeForceBuilderInitialization() {
			 if (com.google.protobuf.GeneratedMessageV3 .alwaysUseFieldBuilders) {
			 }
		 }
		 public Builder clear() {
			 super.clear();
			 traceId_ = """";
			 edgeId_ = """";
			 return this;
		 }
		 public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
			 return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_descriptor;
		 }
		 public com.facebook.buck.remoteexecution.proto.TraceInfo getDefaultInstanceForType() {
			 return com.facebook.buck.remoteexecution.proto.TraceInfo.getDefaultInstance();
		 }
		 public com.facebook.buck.remoteexecution.proto.TraceInfo build() {
			 com.facebook.buck.remoteexecution.proto.TraceInfo result = buildPartial();
			 if (!result.isInitialized()) {
				 throw newUninitializedMessageException(result);
			 }
			 return result;
		 }
		 public com.facebook.buck.remoteexecution.proto.TraceInfo buildPartial() {
			 com.facebook.buck.remoteexecution.proto.TraceInfo result = new com.facebook.buck.remoteexecution.proto.TraceInfo(this);
			 result.traceId_ = traceId_;
			 result.edgeId_ = edgeId_;
			 onBuilt();
			 return result;
		 }
		 public Builder clone() {
			 return (Builder) super.clone();
		 }
		 public Builder setField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
			 return (Builder) super.setField(field, value);
		 }
		 public Builder clearField( com.google.protobuf.Descriptors.FieldDescriptor field) {
			 return (Builder) super.clearField(field);
		 }
		 public Builder clearOneof( com.google.protobuf.Descriptors.OneofDescriptor oneof) {
			 return (Builder) super.clearOneof(oneof);
		 }
		 public Builder setRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
			 return (Builder) super.setRepeatedField(field, index, value);
		 }
		 public Builder addRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
			 return (Builder) super.addRepeatedField(field, value);
		 }
		 public Builder mergeFrom(com.google.protobuf.Message other) {
			 if (other instanceof com.facebook.buck.remoteexecution.proto.TraceInfo) {
				 return mergeFrom((com.facebook.buck.remoteexecution.proto.TraceInfo)other);
			 }
			 else {
				 super.mergeFrom(other);
				 return this;
			 }
		 }
		 public Builder mergeFrom(com.facebook.buck.remoteexecution.proto.TraceInfo other) {
			 if (other == com.facebook.buck.remoteexecution.proto.TraceInfo.getDefaultInstance()) return this;
			 if (!other.getTraceId().isEmpty()) {
				 traceId_ = other.traceId_;
				 onChanged();
			 }
			 if (!other.getEdgeId().isEmpty()) {
				 edgeId_ = other.edgeId_;
				 onChanged();
			 }
			 this.mergeUnknownFields(other.unknownFields);
			 onChanged();
			 return this;
		 }
		 public final boolean isInitialized() {
			 return true;
		 }
		 public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			 com.facebook.buck.remoteexecution.proto.TraceInfo parsedMessage = null;
			 try {
				 parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
			 }
			 catch (com.google.protobuf.InvalidProtocolBufferException e) {
				 parsedMessage = (com.facebook.buck.remoteexecution.proto.TraceInfo) e.getUnfinishedMessage();
				 throw e.unwrapIOException();
			 }
			 finally {
				 if (parsedMessage != null) {
					 mergeFrom(parsedMessage);
				 }
			 }
			 return this;
		 }
		 private java.lang.Object traceId_ = """";
		 public java.lang.String getTraceId() {
			 java.lang.Object ref = traceId_;
			 if (!(ref instanceof java.lang.String)) {
				 com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
				 java.lang.String s = bs.toStringUtf8();
				 traceId_ = s;
				 return s;
			 }
			 else {
				 return (java.lang.String) ref;
			 }
		 }
		 public com.google.protobuf.ByteString getTraceIdBytes() {
			 java.lang.Object ref = traceId_;
			 if (ref instanceof String) {
				 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
				 traceId_ = b;
				 return b;
			 }
			 else {
				 return (com.google.protobuf.ByteString) ref;
			 }
		 }
		 public Builder setTraceId( java.lang.String value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 traceId_ = value;
			 onChanged();
			 return this;
		 }
		 public Builder clearTraceId() {
			 traceId_ = getDefaultInstance().getTraceId();
			 onChanged();
			 return this;
		 }
		 public Builder setTraceIdBytes( com.google.protobuf.ByteString value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 checkByteStringIsUtf8(value);
			 traceId_ = value;
			 onChanged();
			 return this;
		 }
		 private java.lang.Object edgeId_ = """";
		 public java.lang.String getEdgeId() {
			 java.lang.Object ref = edgeId_;
			 if (!(ref instanceof java.lang.String)) {
				 com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
				 java.lang.String s = bs.toStringUtf8();
				 edgeId_ = s;
				 return s;
			 }
			 else {
				 return (java.lang.String) ref;
			 }
		 }
		 public com.google.protobuf.ByteString getEdgeIdBytes() {
			 java.lang.Object ref = edgeId_;
			 if (ref instanceof String) {
				 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
				 edgeId_ = b;
				 return b;
			 }
			 else {
				 return (com.google.protobuf.ByteString) ref;
			 }
		 }
		 public Builder setEdgeId( java.lang.String value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 edgeId_ = value;
			 onChanged();
			 return this;
		 }
		 public Builder clearEdgeId() {
			 edgeId_ = getDefaultInstance().getEdgeId();
			 onChanged();
			 return this;
		 }
		 public Builder setEdgeIdBytes( com.google.protobuf.ByteString value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 checkByteStringIsUtf8(value);
			 edgeId_ = value;
			 onChanged();
			 return this;
		 }
		 public final Builder setUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) {
			 return super.setUnknownFieldsProto3(unknownFields);
		 }
		 public final Builder mergeUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) {
			 return super.mergeUnknownFields(unknownFields);
		 }
	 }
	 private static final com.facebook.buck.remoteexecution.proto.TraceInfo DEFAULT_INSTANCE;
	 static {
		 DEFAULT_INSTANCE = new com.facebook.buck.remoteexecution.proto.TraceInfo();
	 }
	 public static com.facebook.buck.remoteexecution.proto.TraceInfo getDefaultInstance() {
		 return DEFAULT_INSTANCE;
	 }
	 private static final com.google.protobuf.Parser<TraceInfo> PARSER = new com.google.protobuf.AbstractParser<TraceInfo>() {
		 public TraceInfo parsePartialFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
			 return new TraceInfo(input, extensionRegistry);
		 }
	 }
	;
	 public static com.google.protobuf.Parser<TraceInfo> parser() {
		 return PARSER;
	 }
	 public com.google.protobuf.Parser<TraceInfo> getParserForType() {
		 return PARSER;
	 }
	 public com.facebook.buck.remoteexecution.proto.TraceInfo getDefaultInstanceForType() {
		 return DEFAULT_INSTANCE;
	 }
}",1,1,0,0
"public static void serialize(IIterableColumns columns, DataOutput dos) {
	 try {
		 serializeInternal(columns, dos);
	 }
	 catch (IOException e) {
		 throw new IOError(e);
	 }
 }",0,0,0,0
"public class DebugInfoDecoder {
	 private final byte[] encoded;
	 private final ArrayList<PositionEntry> positions;
	 private final ArrayList<LocalEntry> locals;
	 private final int codesize;
	 private final LocalEntry[] lastEntryForReg;
	 private final Prototype desc;
	 private final boolean isStatic;
	 private final DexFile file;
	 private final int regSize;
	 private int line = 1;
	 private int address = 0;
	 private final int thisStringIdx;
	 DebugInfoDecoder(byte[] encoded, int codesize, int regSize, boolean isStatic, CstMethodRef ref, DexFile file) {
		 if (encoded == null) {
			 throw new NullPointerException(""encoded == null"");
		 }
		 this.encoded = encoded;
		 this.isStatic = isStatic;
		 this.desc = ref.getPrototype();
		 this.file = file;
		 this.regSize = regSize;
		 positions = new ArrayList<PositionEntry>();
		 locals = new ArrayList<LocalEntry>();
		 this.codesize = codesize;
		 lastEntryForReg = new LocalEntry[regSize];
		 int idx = -1;
		 try {
			 idx = file.getStringIds().indexOf(new CstString(""this""));
		 }
		 catch (IllegalArgumentException ex) {
		 }
		 thisStringIdx = idx;
	 }
	 static private class PositionEntry {
		 public int address;
		 public int line;
		 public PositionEntry(int address, int line) {
			 this.address = address;
			 this.line = line;
		 }
	 }
	 static private class LocalEntry {
		 public int address;
		 public boolean isStart;
		 public int reg;
		 public int nameIndex;
		 public int typeIndex;
		 public int signatureIndex;
		 public LocalEntry(int address, boolean isStart, int reg, int nameIndex, int typeIndex, int signatureIndex) {
			 this.address = address;
			 this.isStart = isStart;
			 this.reg = reg;
			 this.nameIndex = nameIndex;
			 this.typeIndex = typeIndex;
			 this.signatureIndex = signatureIndex;
		 }
		 public String toString() {
			 return String.format(""[%x %s v%d %04x %04x %04x]"", address, isStart ? ""start"" : ""end"", reg, nameIndex, typeIndex, signatureIndex);
		 }
	 }
	 public List<PositionEntry> getPositionList() {
		 return positions;
	 }
	 public List<LocalEntry> getLocals() {
		 return locals;
	 }
	 public void decode() {
		 try {
			 decode0();
		 }
		 catch (Exception ex) {
			 throw ExceptionWithContext.withContext(ex, ""...while decoding debug info"");
		 }
	 }
	 private int readStringIndex(ByteInput bs) throws IOException {
		 int offsetIndex = Leb128.readUnsignedLeb128(bs);
		 return offsetIndex - 1;
	 }
	 private int getParamBase() {
		 return regSize - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);
	 }
	 private void decode0() throws IOException {
		 ByteInput bs = new ByteArrayByteInput(encoded);
		 line = Leb128.readUnsignedLeb128(bs);
		 int szParams = Leb128.readUnsignedLeb128(bs);
		 StdTypeList params = desc.getParameterTypes();
		 int curReg = getParamBase();
		 if (szParams != params.size()) {
			 throw new RuntimeException( ""Mismatch between parameters_size and prototype"");
		 }
		 if (!isStatic) {
			 LocalEntry thisEntry = new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);
			 locals.add(thisEntry);
			 lastEntryForReg[curReg] = thisEntry;
			 curReg++;
		 }
		 for (int i = 0;
		 i < szParams;
		 i++) {
			 Type paramType = params.getType(i);
			 LocalEntry le;
			 int nameIdx = readStringIndex(bs);
			 if (nameIdx == -1) {
				 le = new LocalEntry(0, true, curReg, -1, 0, 0);
			 }
			 else {
				 le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);
			 }
			 locals.add(le);
			 lastEntryForReg[curReg] = le;
			 curReg += paramType.getCategory();
		 }
		 for (;
		;
		) {
			 int opcode = bs.readByte() & 0xff;
			 switch (opcode) {
				 case DBG_START_LOCAL: {
					 int reg = Leb128.readUnsignedLeb128(bs);
					 int nameIdx = readStringIndex(bs);
					 int typeIdx = readStringIndex(bs);
					 LocalEntry le = new LocalEntry( address, true, reg, nameIdx, typeIdx, 0);
					 locals.add(le);
					 lastEntryForReg[reg] = le;
				 }
				 break;
				 case DBG_START_LOCAL_EXTENDED: {
					 int reg = Leb128.readUnsignedLeb128(bs);
					 int nameIdx = readStringIndex(bs);
					 int typeIdx = readStringIndex(bs);
					 int sigIdx = readStringIndex(bs);
					 LocalEntry le = new LocalEntry( address, true, reg, nameIdx, typeIdx, sigIdx);
					 locals.add(le);
					 lastEntryForReg[reg] = le;
				 }
				 break;
				 case DBG_RESTART_LOCAL: {
					 int reg = Leb128.readUnsignedLeb128(bs);
					 LocalEntry prevle;
					 LocalEntry le;
					 try {
						 prevle = lastEntryForReg[reg];
						 if (prevle.isStart) {
							 throw new RuntimeException(""nonsensical "" + ""RESTART_LOCAL on live register v"" + reg);
						 }
						 le = new LocalEntry(address, true, reg, prevle.nameIndex, prevle.typeIndex, 0);
					 }
					 catch (NullPointerException ex) {
						 throw new RuntimeException( ""Encountered RESTART_LOCAL on new v"" + reg);
					 }
					 locals.add(le);
					 lastEntryForReg[reg] = le;
				 }
				 break;
				 case DBG_END_LOCAL: {
					 int reg = Leb128.readUnsignedLeb128(bs);
					 LocalEntry prevle;
					 LocalEntry le;
					 try {
						 prevle = lastEntryForReg[reg];
						 if (!prevle.isStart) {
							 throw new RuntimeException(""nonsensical "" + ""END_LOCAL on dead register v"" + reg);
						 }
						 le = new LocalEntry(address, false, reg, prevle.nameIndex, prevle.typeIndex, prevle.signatureIndex);
					 }
					 catch (NullPointerException ex) {
						 throw new RuntimeException( ""Encountered END_LOCAL on new v"" + reg);
					 }
					 locals.add(le);
					 lastEntryForReg[reg] = le;
				 }
				 break;
				 case DBG_END_SEQUENCE: return;
				 case DBG_ADVANCE_PC: address += Leb128.readUnsignedLeb128(bs);
				 break;
				 case DBG_ADVANCE_LINE: line += Leb128.readSignedLeb128(bs);
				 break;
				 case DBG_SET_PROLOGUE_END: break;
				 case DBG_SET_EPILOGUE_BEGIN: break;
				 case DBG_SET_FILE: break;
				 default: if (opcode < DBG_FIRST_SPECIAL) {
					 throw new RuntimeException( ""Invalid extended opcode encountered "" + opcode);
				 }
				 int adjopcode = opcode - DBG_FIRST_SPECIAL;
				 address += adjopcode / DBG_LINE_RANGE;
				 line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);
				 positions.add(new PositionEntry(address, line));
				 break;
			 }
		 }
	 }
	 public static void validateEncode(byte[] info, DexFile file, CstMethodRef ref, DalvCode code, boolean isStatic) {
		 PositionList pl = code.getPositions();
		 LocalList ll = code.getLocals();
		 DalvInsnList insns = code.getInsns();
		 int codeSize = insns.codeSize();
		 int countRegisters = insns.getRegistersSize();
		 try {
			 validateEncode0(info, codeSize, countRegisters, isStatic, ref, file, pl, ll);
		 }
		 catch (RuntimeException ex) {
			 System.err.println(""instructions:"");
			 insns.debugPrint(System.err, "" "", true);
			 System.err.println(""local list:"");
			 ll.debugPrint(System.err, "" "");
			 throw ExceptionWithContext.withContext(ex, ""while processing "" + ref.toHuman());
		 }
	 }
	 private static void validateEncode0(byte[] info, int codeSize, int countRegisters, boolean isStatic, CstMethodRef ref, DexFile file, PositionList pl, LocalList ll) {
		 DebugInfoDecoder decoder = new DebugInfoDecoder(info, codeSize, countRegisters, isStatic, ref, file);
		 decoder.decode();
		 List<PositionEntry> decodedEntries = decoder.getPositionList();
		 if (decodedEntries.size() != pl.size()) {
			 throw new RuntimeException( ""Decoded positions table not same size was "" + decodedEntries.size() + "" expected "" + pl.size());
		 }
		 for (PositionEntry entry : decodedEntries) {
			 boolean found = false;
			 for (int i = pl.size() - 1;
			 i >= 0;
			 i--) {
				 PositionList.Entry ple = pl.get(i);
				 if (entry.line == ple.getPosition().getLine() && entry.address == ple.getAddress()) {
					 found = true;
					 break;
				 }
			 }
			 if (!found) {
				 throw new RuntimeException (""Could not match position entry: "" + entry.address + "", "" + entry.line);
			 }
		 }
		 List<LocalEntry> decodedLocals = decoder.getLocals();
		 int thisStringIdx = decoder.thisStringIdx;
		 int decodedSz = decodedLocals.size();
		 int paramBase = decoder.getParamBase();
		 for (int i = 0;
		 i < decodedSz;
		 i++) {
			 LocalEntry entry = decodedLocals.get(i);
			 int idx = entry.nameIndex;
			 if ((idx < 0) || (idx == thisStringIdx)) {
				 for (int j = i + 1;
				 j < decodedSz;
				 j++) {
					 LocalEntry e2 = decodedLocals.get(j);
					 if (e2.address != 0) {
						 break;
					 }
					 if ((entry.reg == e2.reg) && e2.isStart) {
						 decodedLocals.set(i, e2);
						 decodedLocals.remove(j);
						 decodedSz--;
						 break;
					 }
				 }
			 }
		 }
		 int origSz = ll.size();
		 int decodeAt = 0;
		 boolean problem = false;
		 for (int i = 0;
		 i < origSz;
		 i++) {
			 LocalList.Entry origEntry = ll.get(i);
			 if (origEntry.getDisposition() == LocalList.Disposition.END_REPLACED) {
				 continue;
			 }
			 LocalEntry decodedEntry;
			 do {
				 decodedEntry = decodedLocals.get(decodeAt);
				 if (decodedEntry.nameIndex >= 0) {
					 break;
				 }
				 decodeAt++;
			 }
			 while (decodeAt < decodedSz);
			 int decodedAddress = decodedEntry.address;
			 if (decodedEntry.reg != origEntry.getRegister()) {
				 System.err.println(""local register mismatch at orig "" + i + "" / decoded "" + decodeAt);
				 problem = true;
				 break;
			 }
			 if (decodedEntry.isStart != origEntry.isStart()) {
				 System.err.println(""local start/end mismatch at orig "" + i + "" / decoded "" + decodeAt);
				 problem = true;
				 break;
			 }
			 if ((decodedAddress != origEntry.getAddress()) && !((decodedAddress == 0) && (decodedEntry.reg >= paramBase))) {
				 System.err.println(""local address mismatch at orig "" + i + "" / decoded "" + decodeAt);
				 problem = true;
				 break;
			 }
			 decodeAt++;
		 }
		 if (problem) {
			 System.err.println(""decoded locals:"");
			 for (LocalEntry e : decodedLocals) {
				 System.err.println("" "" + e);
			 }
			 throw new RuntimeException(""local table problem"");
		 }
	 }
}",1,1,0,0
"public boolean isValidLink(HttpMetadata metadata) {
	Logger.log(""Checking refresh link with checking size "" + md.getSize());
	if (md.getType() == metadata.getType()) {
		if (md instanceof DashMetadata) {
			DashMetadata dm1 = (DashMetadata) md;
			DashMetadata dm2 = (DashMetadata) metadata;
			if (dm1.getLen1() == dm2.getLen1() && dm1.getLen2() == dm2.getLen2()) {
				dm1.setUrl(dm2.getUrl());
				dm1.setUrl2(dm2.getUrl2());
				dm1.setHeaders(dm2.getHeaders());
				dm1.setLen1(dm2.getLen1());
				dm1.setLen2(dm2.getLen2());
				dm1.save();
				showOkMsgAndClose();
				return true;
			}
		}
		 else if (md instanceof HlsMetadata) {
			HlsMetadata hm1 = (HlsMetadata) md;
			HlsMetadata hm2 = (HlsMetadata) metadata;
			if (confirmUrl("""")) {
				hm1.setUrl(hm2.getUrl());
				hm1.setHeaders(hm2.getHeaders());
				hm1.save();
				showOkMsgAndClose();
				return true;
			}
		}
		 else if (md instanceof HdsMetadata) {
			HdsMetadata hm1 = (HdsMetadata) md;
			HdsMetadata hm2 = (HdsMetadata) metadata;
			if (confirmUrl("""")) {
				hm1.setUrl(hm2.getUrl());
				hm1.setHeaders(hm2.getHeaders());
				hm1.save();
				showOkMsgAndClose();
				return true;
			}
		}
		 else {
			boolean confirmed = false;
			if (md.getSize() > 0) {
				confirmed = md.getSize() == metadata.getSize();
			}
			 else {
				confirmed = confirmUrl(StringResource.get(""MSG_REF_LINK_QUESTION""));
			}
			if (confirmed) {
				md.setUrl(metadata.getUrl());
				md.setHeaders(metadata.getHeaders());
				md.save();
				showOkMsgAndClose();
				return true;
			}
		}
	}
	return false;
}",0,0,1,0
"static class ChannelConfigException extends ChannelException {
	 private static final long serialVersionUID = 1L;
	 public ChannelConfigException(String message) {
		 super(message);
	 }
 }",0,0,0,0
"public class Input extends java.io.FilterInputStream {
	 public Input(final InputStream in) {
		 super(in);
	 }
	 public void close() throws IOException {
	 }
 }",0,0,0,0
"public class SpecialFoldersItem extends DefaultItem {
	 public static final String UID = ""uid"";
	public static final String USE_DEFAULT_ACCOUNT = ""use_default_account"";
	public static final String INBOX = ""inbox"";
	public static final String SENT = ""sent"";
	public static final String TEMPLATES = ""templates"";
	public static final String DRAFTS = ""drafts"";
	public static final String TRASH = ""trash"";
	public SpecialFoldersItem(XmlElement e) {
		 super(e);
	 }
}",0,0,0,0
"static class OfflineIteratorEnvironment implements IteratorEnvironment {
	 private final Authorizations authorizations;
	 private AccumuloConfiguration conf;
	 private boolean useSample;
	 private SamplerConfiguration sampleConf;
	 public OfflineIteratorEnvironment(Authorizations auths, AccumuloConfiguration acuTableConf, boolean useSample, SamplerConfiguration samplerConf) {
		 this.authorizations = auths;
		 this.conf = acuTableConf;
		 this.useSample = useSample;
		 this.sampleConf = samplerConf;
	 }
	 public AccumuloConfiguration getConfig() {
		 return conf;
	 }
	 public IteratorScope getIteratorScope() {
		 return IteratorScope.scan;
	 }
	 public boolean isFullMajorCompaction() {
		 return false;
	 }
	 public boolean isUserCompaction() {
		 return false;
	 }
	 private ArrayList<SortedKeyValueIterator<Key,Value>> topLevelIterators = new ArrayList<>();
	 public void registerSideChannel(SortedKeyValueIterator<Key,Value> iter) {
		 topLevelIterators.add(iter);
	 }
	 public Authorizations getAuthorizations() {
		 return authorizations;
	 }
	 SortedKeyValueIterator<Key,Value> getTopLevelIterator(SortedKeyValueIterator<Key,Value> iter) {
		 if (topLevelIterators.isEmpty()) return iter;
		 ArrayList<SortedKeyValueIterator<Key,Value>> allIters = new ArrayList<>(topLevelIterators);
		 allIters.add(iter);
		 return new MultiIterator(allIters, false);
	 }
	 public boolean isSamplingEnabled() {
		 return useSample;
	 }
	 public SamplerConfiguration getSamplerConfiguration() {
		 return sampleConf;
	 }
	 public IteratorEnvironment cloneWithSamplingEnabled() {
		 if (sampleConf == null) throw new SampleNotPresentException();
		 return new OfflineIteratorEnvironment(authorizations, conf, true, sampleConf);
	 }
 }",1,1,0,0
"public class SliceQueryFilter implements IFilter{
	 private static Logger logger = LoggerFactory.getLogger(SliceQueryFilter.class);
	 public final ByteBuffer start;
	 public final ByteBuffer finish;
	 public final boolean reversed;
	 public final int count;
	 public SliceQueryFilter(ByteBuffer start, ByteBuffer finish, boolean reversed, int count) {
		 this.start = start;
		 this.finish = finish;
		 this.reversed = reversed;
		 this.count = count;
	 }
	 public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey key, AbstractType comparator) {
		 return Memtable.getSliceIterator(key, cf, this, comparator);
	 }
	 public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey key) {
		 return new SSTableSliceIterator(sstable, key, start, finish, reversed);
	 }
	 public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key) {
		 return new SSTableSliceIterator(sstable, file, key, start, finish, reversed);
	 }
	 public SuperColumn filterSuperColumn(SuperColumn superColumn, int gcBefore) {
		 SuperColumn scFiltered = superColumn.cloneMeShallow();
		 Iterator<IColumn> subcolumns;
		 if (reversed) {
			 List<IColumn> columnsAsList = new ArrayList<IColumn>(superColumn.getSubColumns());
			 subcolumns = new ReverseListIterator(columnsAsList);
		 }
		 else {
			 subcolumns = superColumn.getSubColumns().iterator();
		 }
		 Comparator<ByteBuffer> comparator = reversed ? superColumn.getComparator().reverseComparator : superColumn.getComparator();
		 while (subcolumns.hasNext()) {
			 IColumn column = subcolumns.next();
			 if (comparator.compare(column.name(), start) >= 0) {
				 subcolumns = IteratorUtils.chainedIterator(IteratorUtils.singletonIterator(column), subcolumns);
				 break;
			 }
		 }
		 collectReducedColumns(scFiltered, subcolumns, gcBefore);
		 return scFiltered;
	 }
	 public Comparator<IColumn> getColumnComparator(AbstractType comparator) {
		 return reversed ? comparator.columnReverseComparator : comparator.columnComparator;
	 }
	 public void collectReducedColumns(IColumnContainer container, Iterator<IColumn> reducedColumns, int gcBefore) {
		 int liveColumns = 0;
		 AbstractType comparator = container.getComparator();
		 while (reducedColumns.hasNext()) {
			 if (liveColumns >= count) break;
			 IColumn column = reducedColumns.next();
			 if (logger.isDebugEnabled()) logger.debug(String.format(""collecting %s of %s: %s"", liveColumns, count, column.getString(comparator)));
			 if (finish.remaining() > 0 && ((!reversed && comparator.compare(column.name(), finish) > 0)) || (reversed && comparator.compare(column.name(), finish) < 0)) break;
			 if (column.isLive() && (!container.isMarkedForDelete() || column.mostRecentLiveChangeAt() > container.getMarkedForDeleteAt())) {
				 liveColumns++;
			 }
			 if (QueryFilter.isRelevant(column, container, gcBefore)) container.addColumn(column);
		 }
	 }
	 public String toString() {
		 return getClass().getSimpleName() + ""("" + ""start="" + start + "", finish="" + finish + "", reversed="" + reversed + "", count="" + count + ""]"";
	 }
}",0,0,0,0
"public class VFSBrowser extends JPanel implements EBComponent,DefaultFocusComponent, DockableWindow{
	public static final String NAME = ""vfs.browser"";
	public static final int OPEN_DIALOG = 0;
	public static final int SAVE_DIALOG = 1;
	public static final int BROWSER_DIALOG = 4;
	public static final int CHOOSE_DIRECTORY_DIALOG = 3;
	public static final int BROWSER = 2;
	public static void browseDirectoryInNewWindow(View view, String path){
		DockableWindowManager wm = view.getDockableWindowManager();
		if(path != null){
			jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
		}
		wm.floatDockableWindow(""vfs.browser"");
		jEdit.unsetProperty(""vfs.browser.path.tmp"");
	}
	 public static void browseDirectory(View view, String path){
		DockableWindowManager wm = view.getDockableWindowManager();
		VFSBrowser browser = (VFSBrowser)wm.getDockable(NAME);
		if(browser != null){
			wm.showDockableWindow(NAME);
			browser.setDirectory(path);
		}
		else{
			if(path != null){
				jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
			}
			wm.addDockableWindow(""vfs.browser"");
			jEdit.unsetProperty(""vfs.browser.path.tmp"");
		}
	}
	 public static ActionContext getActionContext(){
		return actionContext;
	}
	 public VFSBrowser(View view, String position){
		this(view,null,BROWSER,true,position);
	}
	 public VFSBrowser(View view, String path, int mode,boolean multipleSelection, String position){
		super(new BorderLayout());
		listenerList = new EventListenerList();
		this.mode = mode;
		this.multipleSelection = multipleSelection;
		this.view = view;
		DockableWindowManager dwm = view.getDockableWindowManager();
		KeyListener keyListener = dwm.closeListener(NAME);
		addKeyListener(keyListener);
		currentEncoding = jEdit.getProperty(""buffer.encoding"",System.getProperty(""file.encoding""));
		autoDetectEncoding = jEdit.getBooleanProperty(""buffer.encodingAutodetect"");
		ActionHandler actionHandler = new ActionHandler();
		topBox = new Box(BoxLayout.Y_AXIS);
		horizontalLayout = (mode != BROWSER|| DockableWindowManager.TOP.equals(position)|| DockableWindowManager.BOTTOM.equals(position));
		toolbarBox = new Box(horizontalLayout? BoxLayout.X_AXIS: BoxLayout.Y_AXIS);
		topBox.add(toolbarBox);
		GridBagLayout layout = new GridBagLayout();
		pathAndFilterPanel = new JPanel(layout);
		if(isHorizontalLayout())pathAndFilterPanel.setBorder(new EmptyBorder(12,12,12,12));
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.EAST;
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.path""),SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		pathAndFilterPanel.add(label);
		pathField = new HistoryTextField(""vfs.browser.path"");
		pathField.setName(""path"");
		pathField.addKeyListener(keyListener);
		pathField.setInstantPopups(true);
		pathField.setEnterAddsToHistory(false);
		pathField.setSelectAllOnFocus(true);
		if (mode == BROWSER){
			pathField.addKeyListener(new KeyAdapter(){
				public void keyReleased(KeyEvent e){
					if (e.getKeyCode() == KeyEvent.VK_ESCAPE){
						pathField.setText(VFSBrowser.this.path);
					}
				}
			}
			);
		}
		Dimension prefSize = pathField.getPreferredSize();
		prefSize.width = 0;
		pathField.setPreferredSize(prefSize);
		pathField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		layout.setConstraints(pathField,cons);
		pathAndFilterPanel.add(pathField);
		filterCheckbox = new JCheckBox(jEdit.getProperty(""vfs.browser.filter""));
		filterCheckbox.setMargin(new Insets(0,0,0,0));
		filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));
		filterCheckbox.setSelected(jEdit.getBooleanProperty(""vfs.browser.filter-enabled""));
		filterCheckbox.addActionListener(actionHandler);
		filterCheckbox.addKeyListener(keyListener);
		filterCheckbox.setName(""filter-checkbox"");
		if(mode != CHOOSE_DIRECTORY_DIALOG){
			cons.gridwidth = 1;
			cons.gridx = 0;
			cons.weightx = 0.0;
			cons.gridy = 1;
			layout.setConstraints(filterCheckbox,cons);
			pathAndFilterPanel.add(filterCheckbox);
		}
		filterField = new JComboBox();
		filterEditor = new HistoryComboBoxEditor(""vfs.browser.filter"");
		filterEditor.setToolTipText(jEdit.getProperty(""glob.tooltip""));
		filterEditor.setInstantPopups(true);
		filterEditor.setSelectAllOnFocus(true);
		filterEditor.addActionListener(actionHandler);
		filterEditor.addKeyListener(keyListener);
		filterField.setName(""filter-field"");
		String filter;
		if(mode == BROWSER || !jEdit.getBooleanProperty(""vfs.browser.currentBufferFilter"")){
			filter = jEdit.getProperty(""vfs.browser.last-filter"");
			if(filter == null)filter = jEdit.getProperty(""vfs.browser.default-filter"");
		}
		else{
			String ext = MiscUtilities.getFileExtension(view.getBuffer().getName());
			if(ext.length() == 0)filter = jEdit.getProperty(""vfs.browser.default-filter"");
			elsefilter = '*' + ext;
		}
		filterEditor.setItem(new GlobVFSFileFilter(filter));
		filterField.addItem(filterEditor.getItem());
		filterField.addItemListener(actionHandler);
		filterField.setRenderer(new VFSFileFilterRenderer());
		String[] _filters = ServiceManager.getServiceNames(VFSFileFilter.SERVICE_NAME);
		for (int i = 0;
		 i < _filters.length;
		 i++){
			VFSFileFilter _filter = (VFSFileFilter)ServiceManager.getService(VFSFileFilter.SERVICE_NAME, _filters[i]);
			filterField.addItem(_filter);
		}
		if(mode != CHOOSE_DIRECTORY_DIALOG){
			cons.gridwidth = GridBagConstraints.REMAINDER;
			cons.fill = GridBagConstraints.HORIZONTAL;
			cons.gridx = 1;
			cons.weightx = 1.0;
			if (filterField.getItemCount() > 1){
				filterField.setEditor(filterEditor);
				filterField.setEditable(true);
				layout.setConstraints(filterField,cons);
				pathAndFilterPanel.add(filterField);
			}
			else{
				layout.setConstraints(filterEditor,cons);
				pathAndFilterPanel.add(filterEditor);
			}
		}
		topBox.add(pathAndFilterPanel);
		add(BorderLayout.NORTH,topBox);
		add(BorderLayout.CENTER,browserView = new BrowserView(this));
		if(isHorizontalLayout())browserView.setBorder(new EmptyBorder(0,12,0,12));
		defaultFocusComponent = browserView.getTable();
		propertiesChanged();
		updateFilterEnabled();
		setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		if(path == null)path = jEdit.getProperty(""vfs.browser.path.tmp"");
		if(path == null || path.length() == 0){
			String userHome = System.getProperty(""user.home"");
			String defaultPath = jEdit.getProperty(""vfs.browser.defaultPath"");
			if(""home"".equals(defaultPath))path = userHome;
			else if(""working"".equals(defaultPath))path = System.getProperty(""user.dir"");
			else if(""buffer"".equals(defaultPath)){
				Buffer buffer = view.getBuffer();
				path = buffer.getDirectory();
			}
			else if(""last"".equals(defaultPath)){
				HistoryModel pathModel = HistoryModel.getModel(""vfs.browser.path"");
				if(pathModel.getSize() == 0)path = ""~"";
				elsepath = pathModel.getItem(0);
			}
			else if(""favorites"".equals(defaultPath))path = ""favorites:"";
			else{
				path = userHome;
			}
		}
		final String _path = path;
		SwingUtilities.invokeLater(new Runnable(){
			public void run(){
				setDirectory(_path);
			}
		}
		);
	}
	 public void focusOnDefaultComponent(){
		defaultFocusComponent.requestFocus();
	}
	 void setDefaultFocusComponent(JComponent c) {
		defaultFocusComponent = c;
	}
	public void addNotify(){
		super.addNotify();
		EditBus.addToBus(this);
	}
	 public void removeNotify(){
		super.removeNotify();
		jEdit.setBooleanProperty(""vfs.browser.filter-enabled"",filterCheckbox.isSelected());
		if(mode == BROWSER || !jEdit.getBooleanProperty(""vfs.browser.currentBufferFilter"")){
			VFSFileFilter selectedFilter =(VFSFileFilter) filterField.getSelectedItem();
			if (selectedFilter instanceof GlobVFSFileFilter)jEdit.setProperty(""vfs.browser.last-filter"",((GlobVFSFileFilter)selectedFilter).getGlob());
		}
		EditBus.removeFromBus(this);
	}
	 public void handleMessage(EBMessage msg){
		if(msg instanceof PropertiesChanged)propertiesChanged();
		else if(msg instanceof BufferUpdate){
			BufferUpdate bmsg = (BufferUpdate)msg;
			if(bmsg.getWhat() == BufferUpdate.CREATED|| bmsg.getWhat() == BufferUpdate.CLOSED)browserView.updateFileView();
		}
		else if(msg instanceof PluginUpdate){
			PluginUpdate pmsg = (PluginUpdate)msg;
			if((pmsg.getWhat() == PluginUpdate.LOADED || pmsg.getWhat() == PluginUpdate.UNLOADED) &&plugins != null ){
				plugins.updatePopupMenu();
			}
		}
		else if(msg instanceof VFSUpdate){
			maybeReloadDirectory(((VFSUpdate)msg).getPath());
		}
	}
	 public View getView(){
		return view;
	}
	 public int getMode(){
		return mode;
	}
	 public boolean isMultipleSelectionEnabled(){
		return multipleSelection;
	}
	 public boolean isHorizontalLayout(){
		return horizontalLayout;
	}
	 public boolean getShowHiddenFiles(){
		return showHiddenFiles;
	}
	 public void setShowHiddenFiles(boolean showHiddenFiles){
		this.showHiddenFiles = showHiddenFiles;
	}
	 public String getFilenameFilter(){
		if(filterCheckbox.isSelected()){
			String filter = filterField.getSelectedItem().toString();
			if(filter.length() == 0)return ""*"";
			elsereturn filter;
		}
		elsereturn ""*"";
	}
	 public VFSFileFilter getVFSFileFilter(){
		if (mode == CHOOSE_DIRECTORY_DIALOG)return new DirectoriesOnlyFilter();
		return (VFSFileFilter) filterField.getSelectedItem();
	}
	 public void addVFSFileFilter(VFSFileFilter filter){
		filterField.addItem(filter);
		if (filterField.getItemCount() == 2){
			filterField.setEditor(filterEditor);
			filterField.setEditable(true);
			GridBagLayout layout = (GridBagLayout) pathAndFilterPanel.getLayout();
			GridBagConstraints cons =layout.getConstraints(filterEditor);
			cons.gridwidth = GridBagConstraints.REMAINDER;
			cons.fill = GridBagConstraints.HORIZONTAL;
			cons.gridx = 1;
			cons.weightx = 1;
			pathAndFilterPanel.remove(filterEditor);
			layout.setConstraints(filterField, cons);
			pathAndFilterPanel.add(filterField);
			pathAndFilterPanel.validate();
			pathAndFilterPanel.repaint();
		}
	}
	 public void setFilenameFilter(String filter){
		if(filter == null || filter.length() == 0 || ""*"".equals(filter))filterCheckbox.setSelected(false);
		else{
			filterCheckbox.setSelected(true);
			filterEditor.setItem(new GlobVFSFileFilter(filter));
		}
	}
	 public HistoryTextField getDirectoryField(){
		return pathField;
	}
	 public String getDirectory(){
		return path;
	}
	 public void previousDirectory() {
		if (historyStack.size() > 1){
			historyStack.pop();
			nextDirectoryStack.push(path);
			setDirectory(historyStack.peek());
			historyStack.pop();
		}
	}
	public void nextDirectory() {
		if (!nextDirectoryStack.isEmpty()){
			setDirectory(nextDirectoryStack.pop());
		}
	}
	public void setDirectory(String path){
		if(path.startsWith(""file:""))path = path.substring(5);
		path = MiscUtilities.expandVariables(path);
		pathField.setText(path);
		if(!startRequest())return;
		historyStack.push(path);
		browserView.saveExpansionState();
		browserView.loadDirectory(null,path,true);
		this.path = path;
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				endRequest();
			}
		}
		);
	}
	 public static String getRootDirectory(){
		if(OperatingSystem.isMacOS() || OperatingSystem.isDOSDerived())return FileRootsVFS.PROTOCOL + ':';
		elsereturn ""/"";
	}
	 public void rootDirectory(){
		setDirectory(getRootDirectory());
	}
	 public void reloadDirectory(){
		VFSManager.getVFSForPath(path).reloadDirectory(path);
		browserView.saveExpansionState();
		browserView.loadDirectory(null,path,false);
	}
	 public void delete(VFSFile[] files){
		String dialogType;
		if(MiscUtilities.isURL(files[0].getDeletePath())&& FavoritesVFS.PROTOCOL.equals(MiscUtilities.getProtocolOfURL(files[0].getDeletePath()))){
			dialogType = ""vfs.browser.delete-favorites"";
		}
		else{
			dialogType = ""vfs.browser.delete-confirm"";
		}
		StringBuilder buf = new StringBuilder();
		String typeStr = ""files"";
		for(int i = 0;
		 i < files.length;
		 i++){
			buf.append(files[i].getPath());
			buf.append('\n');
			if (files[i].getType() == VFSFile.DIRECTORY)typeStr = ""directories and their contents"";
		}
		Object[] args = {
		 buf.toString(), typeStr}
		;
		int result = GUIUtilities.confirm(this,dialogType,args,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
		if(result != JOptionPane.YES_OPTION)return;
		VFS vfs = VFSManager.getVFSForPath(files[0].getDeletePath());
		if(!startRequest())return;
		for(int i = 0;
		 i < files.length;
		 i++){
			Object session = vfs.createVFSSession(files[i].getDeletePath(),this);
			if(session == null)continue;
			VFSManager.runInWorkThread(new BrowserIORequest(BrowserIORequest.DELETE,this,session,vfs,files[i].getDeletePath(),null,null));
		}
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				endRequest();
			}
		}
		);
	}
	 public void rename(String from){
		VFS vfs = VFSManager.getVFSForPath(from);
		String filename = vfs.getFileName(from);
		String[] args = {
		 filename }
		;
		String to = GUIUtilities.input(this,""vfs.browser.rename"",args,filename);
		if(to == null)return;
		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);
		Object session = vfs.createVFSSession(from,this);
		if(session == null)return;
		if(!startRequest())return;
		VFSManager.runInWorkThread(new BrowserIORequest(BrowserIORequest.RENAME,this,session,vfs,from,to,null));
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				endRequest();
			}
		}
		);
	}
	 public void rename(String from, String newname){
		VFS vfs = VFSManager.getVFSForPath(from);
		String filename = vfs.getFileName(from);
		String[] args = {
		 filename }
		;
		String to = newname;
		if(to == null || filename.equals(newname))return;
		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);
		Object session = vfs.createVFSSession(from,this);
		if(session == null)return;
		if(!startRequest())return;
		VFSManager.runInWorkThread(new BrowserIORequest(BrowserIORequest.RENAME,this,session,vfs,from,to,null));
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				endRequest();
			}
		}
		);
	}
	 public void mkdir(){
		String newDirectory = GUIUtilities.input(this,""vfs.browser.mkdir"",null);
		if(newDirectory == null)return;
		final VFSFile[] selected = getSelectedFiles();
		String parent;
		if(selected.length == 0)parent = path;
		else if(selected[0].getType() == VFSFile.FILE){
			parent = selected[0].getPath();
			parent = VFSManager.getVFSForPath(parent).getParentOfPath(parent);
		}
		elseparent = selected[0].getPath();
		VFS vfs = VFSManager.getVFSForPath(parent);
		newDirectory = MiscUtilities.constructPath(parent,newDirectory);
		Object session = vfs.createVFSSession(newDirectory,this);
		if(session == null)return;
		if(!startRequest())return;
		VFSManager.runInWorkThread(new BrowserIORequest(BrowserIORequest.MKDIR,this,session,vfs,newDirectory,null,null));
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				endRequest();
				if (selected.length != 0 && selected[0].getType() != VFSFile.FILE){
					VFSDirectoryEntryTable directoryEntryTable = browserView.getTable();
					int selectedRow = directoryEntryTable.getSelectedRow();
					VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel) directoryEntryTable.getModel();
					VFSDirectoryEntryTableModel.Entry entry = model.files[selectedRow];
					if (!entry.expanded){
						browserView.clearExpansionState();
						browserView.loadDirectory(entry,entry.dirEntry.getPath(),false);
					}
				}
			}
		}
		);
	}
	 public void newFile(){
		VFSFile[] selected = getSelectedFiles();
		if(selected.length >= 1){
			VFSFile file = selected[0];
			if(file.getType() == VFSFile.DIRECTORY)jEdit.newFile(view,file.getPath());
			else{
				VFS vfs = VFSManager.getVFSForPath(file.getPath());
				jEdit.newFile(view,vfs.getParentOfPath(file.getPath()));
			}
		}
		elsejEdit.newFile(view,path);
	}
	 public void fileProperties(VFSFile[] files){
		new FilePropertiesDialog(view, this, files);
	}
	 public void searchInDirectory(){
		VFSFile[] selected = getSelectedFiles();
		if(selected.length >= 1){
			VFSFile file = selected[0];
			searchInDirectory(file.getPath(),file.getType() != VFSFile.FILE);
		}
		else{
			searchInDirectory(path,true);
		}
	}
	 public void searchInDirectory(String path, boolean directory){
		String filter;
		VFSFileFilter vfsff = getVFSFileFilter();
		if (vfsff instanceof GlobVFSFileFilter)filter = ((GlobVFSFileFilter)vfsff).getGlob();
		elsefilter = ""*"";
		if (!directory){
			String name = MiscUtilities.getFileName(path);
			String ext = MiscUtilities.getFileExtension(name);
			filter = (ext == null || ext.length() == 0? filter : '*' + ext);
			path = MiscUtilities.getParentOfPath(path);
		}
		SearchAndReplace.setSearchFileSet(new DirectoryListSet(path,filter,true));
		SearchDialog.showSearchDialog(view,null,SearchDialog.DIRECTORY);
	}
	 BrowserView getBrowserView(){
		return browserView;
	}
	 public VFSFile[] getSelectedFiles(){
		return browserView.getSelectedFiles();
	}
	 public void locateFile(final String path){
		VFSFileFilter filter = getVFSFileFilter();
		if(!filter.accept(MiscUtilities.getFileName(path)))setFilenameFilter(null);
		setDirectory(MiscUtilities.getParentOfPath(path));
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				browserView.getTable().selectFile(path);
			}
		}
		);
	}
	 public JComponent createPluginsMenu(JComponent pluginMenu, boolean showManagerOptions){
		ActionHandler actionHandler = new ActionHandler();
		if(showManagerOptions && getMode() == BROWSER){
			pluginMenu.add(GUIUtilities.loadMenuItem(""plugin-manager"",false));
			pluginMenu.add(GUIUtilities.loadMenuItem(""plugin-options"",false));
			if (pluginMenu instanceof JMenu)((JMenu)pluginMenu).addSeparator();
			else if (pluginMenu instanceof JPopupMenu)((JPopupMenu)pluginMenu).addSeparator();
		}
		else;
		List<JMenuItem> vec = new ArrayList<JMenuItem>();
		Enumeration<VFS> e = VFSManager.getFilesystems();
		while(e.hasMoreElements()){
			VFS vfs = e.nextElement();
			if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)continue;
			JMenuItem menuItem = new JMenuItem(jEdit.getProperty(""vfs."" + vfs.getName() + "".label""));
			menuItem.setActionCommand(vfs.getName());
			menuItem.addActionListener(actionHandler);
			vec.add(menuItem);
		}
		 EditPlugin[] plugins = jEdit.getPlugins();
		for (int i = 0;
		 i < plugins.length;
		 i++){
			JMenuItem menuItem = plugins[i].createBrowserMenuItems();
			if(menuItem != null)vec.add(menuItem);
		}
		 if (!vec.isEmpty()){
			Collections.sort(vec,new MenuItemTextComparator());
			for(int i = 0;
			 i < vec.size();
			 i++)pluginMenu.add(vec.get(i));
		}
		else{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(""vfs.browser.plugins.no-plugins.label""));
			mi.setEnabled(false);
			pluginMenu.add(mi);
		}
		return pluginMenu;
	}
	 public void addBrowserListener(BrowserListener l){
		listenerList.add(BrowserListener.class,l);
	}
	 public void removeBrowserListener(BrowserListener l){
		listenerList.remove(BrowserListener.class,l);
	}
	 public static final int M_OPEN = 0;
	public static final int M_OPEN_NEW_VIEW = 1;
	public static final int M_OPEN_NEW_PLAIN_VIEW = 2;
	public static final int M_OPEN_NEW_SPLIT = 3;
	public static final int M_INSERT = 4;
	public void filesActivated(int mode, boolean canDoubleClickClose){
		VFSFile[] selectedFiles = browserView.getSelectedFiles();
		Buffer buffer = null;
		check_selected: for(int i = 0;
		 i < selectedFiles.length;
		 i++){
			VFSFile file = selectedFiles[i];
			if(file.getType() == VFSFile.DIRECTORY|| file.getType() == VFSFile.FILESYSTEM){
				if(mode == M_OPEN_NEW_VIEW && this.mode == BROWSER)browseDirectoryInNewWindow(view,file.getPath());
				elsesetDirectory(file.getPath());
			}
			else if(this.mode == BROWSER || this.mode == BROWSER_DIALOG){
				if(mode == M_INSERT){
					view.getBuffer().insertFile(view,file.getPath());
					continue check_selected;
				}
				Buffer _buffer = jEdit.getBuffer(file.getPath());
				if(_buffer == null){
					Hashtable<String, Object> props = new Hashtable<String, Object>();
					props.put(JEditBuffer.ENCODING,currentEncoding);
					props.put(Buffer.ENCODING_AUTODETECT, Boolean.valueOf(autoDetectEncoding));
					_buffer = jEdit.openFile(view, null,file.getPath(),false,props);
				}
				else if(doubleClickClose && canDoubleClickClose&& this.mode != BROWSER_DIALOG&& selectedFiles.length == 1){
					EditPane[] editPanes = view.getEditPanes();
					for(int j = 0;
					 j < editPanes.length;
					 j++){
						if(editPanes[j].getBuffer() == _buffer){
							jEdit.closeBuffer(view,_buffer);
							return;
						}
					}
				}
				if(_buffer != null)buffer = _buffer;
			}
			else{
			}
		}
		if(buffer != null){
			switch(mode){
				case M_OPEN:view.setBuffer(buffer);
				break;
				case M_OPEN_NEW_VIEW:jEdit.newView(view,buffer,false);
				break;
				case M_OPEN_NEW_PLAIN_VIEW:jEdit.newView(view,buffer,true);
				break;
				case M_OPEN_NEW_SPLIT:view.splitHorizontally().setBuffer(buffer);
				break;
			}
		}
		Object[] listeners = listenerList.getListenerList();
		for(int i = 0;
		 i < listeners.length;
		 i++){
			if(listeners[i] == BrowserListener.class){
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesActivated(this,selectedFiles);
			}
		}
	}
	 public void move(String newPosition){
		boolean horz = (mode != BROWSER|| DockableWindowManager.TOP.equals(newPosition)|| DockableWindowManager.BOTTOM.equals(newPosition));
		if (horz == horizontalLayout)return;
		horizontalLayout = horz;
		topBox.remove(toolbarBox);
		toolbarBox = new Box(horizontalLayout? BoxLayout.X_AXIS: BoxLayout.Y_AXIS);
		topBox.add(toolbarBox, 0);
		propertiesChanged();
	}
	 String currentEncoding;
	boolean autoDetectEncoding;
	void directoryLoaded(Object node, Object[] loadInfo,boolean addToHistory){
		VFSManager.runInAWTThread(new DirectoryLoadedAWTRequest(node,loadInfo,addToHistory));
	}
	 void filesSelected(){
		VFSFile[] selectedFiles = browserView.getSelectedFiles();
		if(mode == BROWSER){
			for(int i = 0;
			 i < selectedFiles.length;
			 i++){
				VFSFile file = selectedFiles[i];
				Buffer buffer = jEdit.getBuffer(file.getPath());
				if(buffer != null && view != null)view.setBuffer(buffer);
			}
		}
		Object[] listeners = listenerList.getListenerList();
		for(int i = 0;
		 i < listeners.length;
		 i++){
			if(listeners[i] == BrowserListener.class){
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesSelected(this,selectedFiles);
			}
		}
	}
	 void endRequest(){
		requestRunning = false;
	}
	 private static final ActionContext actionContext;
	static{
		actionContext = new BrowserActionContext();
		ActionSet builtInActionSet = new ActionSet(null,null,null,jEdit.class.getResource(""browser.actions.xml""));
		builtInActionSet.setLabel(jEdit.getProperty(""action-set.browser""));
		builtInActionSet.load();
		actionContext.addActionSet(builtInActionSet);
	}
	private EventListenerList listenerList;
	private View view;
	private boolean horizontalLayout;
	private String path;
	private JPanel pathAndFilterPanel;
	private HistoryTextField pathField;
	private JComponent defaultFocusComponent;
	private JCheckBox filterCheckbox;
	private HistoryComboBoxEditor filterEditor;
	private JComboBox filterField;
	private Box toolbarBox;
	private Box topBox;
	private FavoritesMenuButton favorites;
	private PluginsMenuButton plugins;
	private BrowserView browserView;
	private int mode;
	private boolean multipleSelection;
	private boolean showHiddenFiles;
	private boolean sortMixFilesAndDirs;
	private boolean sortIgnoreCase;
	private boolean doubleClickClose;
	private boolean requestRunning;
	private boolean maybeReloadRequestRunning;
	private Stack<String> historyStack = new Stack<String>();
	private Stack<String> nextDirectoryStack = new Stack<String>();
	private Container createMenuBar(){
		JToolBar menuBar = new JToolBar();
		menuBar.setFloatable(false);
		menuBar.add(new CommandsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(plugins = new PluginsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(favorites = new FavoritesMenuButton());
		return menuBar;
	}
	 private Container createToolBar(){
		if(mode == BROWSER)return GUIUtilities.loadToolBar(actionContext,""vfs.browser.toolbar-browser"");
		elsereturn GUIUtilities.loadToolBar(actionContext,""vfs.browser.toolbar-dialog"");
	}
	 private void propertiesChanged(){
		showHiddenFiles = jEdit.getBooleanProperty(""vfs.browser.showHiddenFiles"");
		sortMixFilesAndDirs = jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs"");
		sortIgnoreCase = jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"");
		doubleClickClose = jEdit.getBooleanProperty(""vfs.browser.doubleClickClose"");
		browserView.propertiesChanged();
		toolbarBox.removeAll();
		if(jEdit.getBooleanProperty(""vfs.browser.showToolbar"")){
			Container toolbar = createToolBar();
			if(horizontalLayout)toolbarBox.add(toolbar);
			else{
				toolbarBox.add(toolbar);
			}
		}
		if(jEdit.getBooleanProperty(""vfs.browser.showMenubar"")){
			Container menubar = createMenuBar();
			if(horizontalLayout){
				toolbarBox.add(menubar,0);
			}
			else{
				menubar.add(Box.createGlue());
				toolbarBox.add(menubar);
			}
		}
		else{
			plugins = null;
			favorites = null;
		}
		revalidate();
		if(path != null)reloadDirectory();
	}
	 private boolean startRequest(){
		if(requestRunning){
			Log.log(Log.DEBUG,this,new Throwable(""For debugging purposes""));
			GUIUtilities.error(this,""browser-multiple-io"",null);
			return false;
		}
		else{
			requestRunning = true;
			return true;
		}
	}
	 private void updateFilterEnabled(){
		filterField.setEnabled(filterCheckbox.isSelected());
		filterEditor.setEnabled(filterCheckbox.isSelected());
	}
	 private void maybeReloadDirectory(String dir){
		if(MiscUtilities.isURL(dir)&& MiscUtilities.getProtocolOfURL(dir).equals(FavoritesVFS.PROTOCOL)){
			if(favorites != null)favorites.popup = null;
		}
		if(maybeReloadRequestRunning){
			return;
		}
		if(path != null){
			try{
				maybeReloadRequestRunning = true;
				browserView.maybeReloadDirectory(dir);
			}
			finally{
				VFSManager.runInAWTThread(new Runnable(){
					public void run(){
						maybeReloadRequestRunning = false;
					}
				}
				);
			}
		}
	}
	 class ActionHandler implements ActionListener, ItemListener{
		public void actionPerformed(ActionEvent evt){
			if (isProcessingEvent)return;
			Object source = evt.getSource();
			if (source == pathField || source == filterCheckbox){
				isProcessingEvent = true;
				resetLater();
				updateFilterEnabled();
				String p = pathField.getText();
				if(p != null)setDirectory(p);
				browserView.focusOnFileView();
			}
			else if (source == filterField.getEditor()){
				filterField.getEditor().setItem(filterField.getEditor().getItem());
			}
			else if (source == filterEditor){
				filterEditor.setItem(filterEditor.getItem());
				filterField.setSelectedItem(filterEditor.getItem());
				itemStateChanged(new ItemEvent(filterField,ItemEvent.ITEM_STATE_CHANGED,filterEditor.getItem(),ItemEvent.SELECTED));
			}
		}
		public void itemStateChanged(ItemEvent e){
			if (isProcessingEvent)return;
			if (e.getStateChange() != ItemEvent.SELECTED)return;
			isProcessingEvent = true;
			resetLater();
			filterField.setEditable(e.getItem() instanceof GlobVFSFileFilter);
			updateFilterEnabled();
			String path = pathField.getText();
			if(path != null)setDirectory(path);
			browserView.focusOnFileView();
		}
		private void resetLater(){
			SwingUtilities.invokeLater(new Runnable(){
				public void run(){
					isProcessingEvent = false;
				}
			}
			);
		}
		private boolean isProcessingEvent;
	}
	 class CommandsMenuButton extends RolloverButton{
		CommandsMenuButton(){
			setText(jEdit.getProperty(""vfs.browser.commands.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
			setHorizontalTextPosition(SwingConstants.LEADING);
			setName(""commands"");
			popup = new BrowserCommandsMenu(VFSBrowser.this,null);
			CommandsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			CommandsMenuButton.this.addMouseListener(new MouseHandler());
			if(OperatingSystem.isMacOSLF())CommandsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		}
		 BrowserCommandsMenu popup;
		class MouseHandler extends MouseAdapter{
			public void mousePressed(MouseEvent evt){
				if(!popup.isVisible()){
					popup.update();
					GUIUtilities.showPopupMenu(popup,CommandsMenuButton.this,0,CommandsMenuButton.this.getHeight(),false);
				}
				else{
					popup.setVisible(false);
				}
			}
		}
	 }
	 class PluginsMenuButton extends RolloverButton{
		PluginsMenuButton(){
			setText(jEdit.getProperty(""vfs.browser.plugins.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
			setHorizontalTextPosition(SwingConstants.LEADING);
			setName(""plugins"");
			PluginsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			PluginsMenuButton.this.addMouseListener(new MouseHandler());
			if(OperatingSystem.isMacOSLF())PluginsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		}
		 JPopupMenu popup;
		void updatePopupMenu(){
			popup = null;
		}
		 private void createPopupMenu(){
			if(popup != null)return;
			popup = (JPopupMenu)createPluginsMenu(new JPopupMenu(),true);
		}
		 class MouseHandler extends MouseAdapter{
			public void mousePressed(MouseEvent evt){
				createPopupMenu();
				if(!popup.isVisible()){
					GUIUtilities.showPopupMenu(popup,PluginsMenuButton.this,0,PluginsMenuButton.this.getHeight(),false);
				}
				else{
					popup.setVisible(false);
				}
			}
		}
	 }
	 class FavoritesMenuButton extends RolloverButton{
		FavoritesMenuButton(){
			setText(jEdit.getProperty(""vfs.browser.favorites.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
			setHorizontalTextPosition(SwingConstants.LEADING);
			setName(""favorites"");
			FavoritesMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			FavoritesMenuButton.this.addMouseListener(new MouseHandler());
			if(OperatingSystem.isMacOSLF())FavoritesMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		}
		 JPopupMenu popup;
		void createPopupMenu(){
			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();
			JMenuItem mi = new JMenuItem(jEdit.getProperty(""vfs.browser.favorites""+ "".add-to-favorites.label""));
			mi.setActionCommand(""add-to-favorites"");
			mi.addActionListener(actionHandler);
			popup.add(mi);
			mi = new JMenuItem(jEdit.getProperty(""vfs.browser.favorites""+ "".edit-favorites.label""));
			mi.setActionCommand(""dir:"");
			mi.addActionListener(actionHandler);
			popup.add(mi);
			popup.addSeparator();
			VFSFile[] favorites = FavoritesVFS.getFavorites();
			if(favorites.length == 0){
				mi = new JMenuItem(jEdit.getProperty(""vfs.browser.favorites""+ "".no-favorites.label""));
				mi.setEnabled(false);
				popup.add(mi);
			}
			else{
				Arrays.sort(favorites,new VFS.DirectoryEntryCompare(sortMixFilesAndDirs,sortIgnoreCase));
				for(int i = 0;
				 i < favorites.length;
				 i++){
					VFSFile favorite = favorites[i];
					mi = new JMenuItem(favorite.getPath());
					mi.setIcon(FileCellRenderer.getIconForFile(favorite,false));
					String cmd = (favorite.getType() ==VFSFile.FILE? ""file@"" : ""dir@"")+ favorite.getPath();
					mi.setActionCommand(cmd);
					mi.addActionListener(actionHandler);
					popup.add(mi);
				}
			}
		}
		 class ActionHandler implements ActionListener{
			public void actionPerformed(ActionEvent evt){
				String actionCommand = evt.getActionCommand();
				if(""add-to-favorites"".equals(actionCommand)){
					VFSFile[] selected = getSelectedFiles();
					if(selected == null || selected.length == 0){
						if(path.equals(FavoritesVFS.PROTOCOL + ':')){
							GUIUtilities.error(VFSBrowser.this,""vfs.browser.recurse-favorites"",null);
						}
						else{
							FavoritesVFS.addToFavorites(path,VFSFile.DIRECTORY);
						}
					}
					else{
						for(int i = 0;
						 i < selected.length;
						 i++){
							VFSFile file = selected[i];
							FavoritesVFS.addToFavorites(file.getPath(),file.getType());
						}
					}
				}
				else if(actionCommand.startsWith(""dir@"")){
					setDirectory(actionCommand.substring(4));
				}
				else if(actionCommand.startsWith(""file@"")){
					switch(getMode()){
						case BROWSER:jEdit.openFile(view,actionCommand.substring(5));
						break;
						default:locateFile(actionCommand.substring(5));
						break;
					}
				}
			}
		}
		 class MouseHandler extends MouseAdapter{
			public void mousePressed(MouseEvent evt){
				if(popup != null && popup.isVisible()){
					popup.setVisible(false);
					return;
				}
				if(popup == null)createPopupMenu();
				GUIUtilities.showPopupMenu(popup,FavoritesMenuButton.this,0,FavoritesMenuButton.this.getHeight(),false);
			}
		}
	 }
	 class DirectoryLoadedAWTRequest implements Runnable{
		private Object node;
		private Object[] loadInfo;
		private boolean addToHistory;
		DirectoryLoadedAWTRequest(Object node, Object[] loadInfo,boolean addToHistory){
			this.node = node;
			this.loadInfo = loadInfo;
			this.addToHistory = addToHistory;
		}
		public void run(){
			String path = (String)loadInfo[0];
			if(path == null){
				return;
			}
			VFSFile[] list = (VFSFile[])loadInfo[1];
			if(node == null){
				VFSBrowser.this.path = path;
				if(!pathField.getText().equals(path))pathField.setText(path);
				if(path.endsWith(""/"") ||path.endsWith(File.separator)){
					path = path.substring(0,path.length() - 1);
				}
				if(addToHistory){
					HistoryModel.getModel(""vfs.browser.path"").addItem(path);
				}
			}
			boolean filterEnabled = filterCheckbox.isSelected();
			List<VFSFile> directoryList = new ArrayList<VFSFile>();
			int directories = 0;
			int files = 0;
			int invisible = 0;
			if(list != null){
				VFSFileFilter filter = getVFSFileFilter();
				for(int i = 0;
				 i < list.length;
				 i++){
					VFSFile file = list[i];
					if(file.isHidden() && !showHiddenFiles){
						invisible++;
						continue;
					}
					if (filter != null && (filterEnabled || filter instanceof DirectoriesOnlyFilter) && !filter.accept(file)){
						invisible++;
						continue;
					}
					if(file.getType() == VFSFile.FILE)files++;
					elsedirectories++;
					directoryList.add(file);
				}
				Collections.sort(directoryList,new VFS.DirectoryEntryCompare(sortMixFilesAndDirs,sortIgnoreCase));
			}
			browserView.directoryLoaded(node,path,directoryList);
			if(mode == CHOOSE_DIRECTORY_DIALOG)filesSelected();
		}
		public String toString(){
			return (String)loadInfo[0];
		}
	}
	 static class BrowserActionContext extends ActionContext{
		private static VFSFile[] getSelectedFiles(EventObject evt,VFSBrowser browser){
			Component source = (Component)evt.getSource();
			if(GUIUtilities.getComponentParent(source, BrowserView.ParentDirectoryList.class)!= null){
				Object[] selected = browser.getBrowserView().getParentDirectoryList().getSelectedValues();
				VFSFile[] returnValue = new VFSFile[selected.length];
				System.arraycopy(selected,0,returnValue,0,selected.length);
				return returnValue;
			}
			else{
				return browser.getSelectedFiles();
			}
		}
		public void invokeAction(EventObject evt, EditAction action){
			VFSBrowser browser = (VFSBrowser)GUIUtilities.getComponentParent((Component)evt.getSource(),VFSBrowser.class);
			VFSFile[] files = getSelectedFiles(evt,browser);
			NameSpace global = BeanShell.getNameSpace();
			try{
				global.setVariable(""browser"",browser);
				global.setVariable(""files"",files);
				View view = browser.getView();
				if(view == null)view = jEdit.getActiveView();
				action.invoke(view);
			}
			catch(UtilEvalError err){
				Log.log(Log.ERROR,this,err);
			}
			finally{
				try{
					global.setVariable(""browser"",null);
					global.setVariable(""files"",null);
				}
				catch(UtilEvalError err){
					Log.log(Log.ERROR,this,err);
				}
			}
		}
	}
	 private static class HistoryComboBoxEditorextends HistoryTextFieldimplements ComboBoxEditor{
		HistoryComboBoxEditor(String key){
			super(key);
		}
		public Object getItem(){
			if (current == null){
				current = new GlobVFSFileFilter(getText());
			}
			if (!current.getGlob().equals(getText())){
				current.setGlob(getText());
			}
			return current;
		}
		public void setItem(Object item){
			if (item == current){
				if (item != null){
					GlobVFSFileFilter filter = (GlobVFSFileFilter) item;
					current = new GlobVFSFileFilter(filter.getGlob());
					setText(current.getGlob());
				}
				return;
			}
			if (!(item instanceof GlobVFSFileFilter))return;
			if (item != null){
				GlobVFSFileFilter filter = (GlobVFSFileFilter) item;
				filter = new GlobVFSFileFilter(filter.getGlob());
				setText(filter.getGlob());
				addCurrentToHistory();
				current = filter;
			}
			else{
				setText(""*"");
				current = new GlobVFSFileFilter(""*"");
			}
		}
		protected void processFocusEvent(FocusEvent e){
			if (e.getID() != FocusEvent.FOCUS_LOST)super.processFocusEvent(e);
			else {
				setCaretPosition(0);
				getCaret().setVisible(false);
			}
		}
		public Component getEditorComponent(){
			return this;
		}
		private GlobVFSFileFilter current;
	}
	 private static class VFSFileFilterRenderer extends DefaultListCellRenderer{
		public Component getListCellRendererComponent(JList list,Object value, int index, boolean isSelected,boolean cellHasFocus){
			assert value instanceof VFSFileFilter : ""Filter is not a VFSFileFilter"";
			super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
			setText(((VFSFileFilter)value).getDescription());
			return this;
		}
	}
	 public static class DirectoriesOnlyFilter implements VFSFileFilter{
		public boolean accept(VFSFile file){
			return file.getType() == VFSFile.DIRECTORY|| file.getType() == VFSFile.FILESYSTEM;
		}
		public boolean accept(String url){
			return false;
		}
		public String getDescription(){
			return jEdit.getProperty(""vfs.browser.file_filter.dir_only"");
		}
	}
 }",1,0,0,0
"private Action createAction(final ProjectInfo project, final TeamConfiguration team) {
	 Check.notNull(project, ""project"");
	 Check.notNull(team, ""team"");
	 final String projectGUID = project.getGUID();
	 final String actionName = team.isDefaultTeam() ? project.getName() : MessageFormat.format( Messages.getString(""TeamExplorerControl.ProjectSlashTeamFormat""), project.getName(), team.getTeamName());
	 final Action action = new Action(actionName) {
		 public void run() {
			 final String beforeChangeProjectGUID = context.getCurrentProjectInfo().getGUID();
			 if (!projectGUID.equals(beforeChangeProjectGUID) || !team.equals(context.getCurrentTeam())) {
				 context.setCurrentProject(projectGUID);
				 context.setCurrentTeam(team);
				 TFSCommonUIClientPlugin.getDefault().projectOrTeamChanged();
				 if (!projectGUID.equals(beforeChangeProjectGUID)) {
					 final boolean tfvc = context.getCurrentProjectInfo().getSourceControlCapabilityFlags().contains( SourceControlCapabilityFlags.TFS);
					 TFSCommonUIClientPlugin.getDefault().sourceControlChanged(tfvc);
				 }
			 }
		 }
	 }
	;
	 if (projectGUID.equals(context.getCurrentProjectInfo().getGUID()) && team.equals(context.getCurrentTeam())) {
		 action.setChecked(true);
	 }
	 return action;
 }",0,0,1,0
"public abstract class Response{
	private static final Logger log = LoggerFactory.getLogger(Response.class);
	private String defaultEncoding;
	public void close(){
	}
	public void reset(){
	}
	public CharSequence encodeURL(final CharSequence url){
		return url;
	}
	public final AppendingStringBuffer filter(AppendingStringBuffer responseBuffer){
		List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();
		if (responseFilters == null){
			return responseBuffer;
		}
		for (int i = 0;
		 i < responseFilters.size();
		 i++){
			IResponseFilter filter = responseFilters.get(i);
			responseBuffer = filter.filter(responseBuffer);
		}
		return responseBuffer;
	}
	public String getCharacterEncoding(){
		if (defaultEncoding == null){
			return Application.get().getRequestCycleSettings().getResponseRequestEncoding();
		}
		else{
			return defaultEncoding;
		}
	}
	public abstract OutputStream getOutputStream();
	public boolean isRedirect(){
		return false;
	}
	public void redirect(final String url){
	}
	public void setCharacterEncoding(final String encoding){
		defaultEncoding = encoding;
	}
	public void setContentLength(final long length){
	}
	public void setContentType(final String mimeType){
	}
	public void setLastModifiedTime(Time time){
	}
	public void setLocale(final Locale locale){
	}
	public final void write(final ComponentTag tag){
		write(tag.toString());
	}
	public abstract void write(final CharSequence string);
	private void handleException(Exception e){
		Throwable throwable = e;
		boolean ignoreException = false;
		while (throwable != null){
			if (throwable instanceof SQLException){
				break;
			 }
			else if (throwable instanceof SocketException){
				String message = throwable.getMessage();
				ignoreException = message != null &&(message.indexOf(""Connection reset"") != -1 ||message.indexOf(""Broken pipe"") != -1 ||message.indexOf(""Socket closed"") != -1 || message.indexOf(""connection abort"") != -1);
			}
			else{
				ignoreException = throwable.getClass().getName().indexOf(""ClientAbortException"") >= 0 ||throwable.getClass().getName().indexOf(""EofException"") >= 0;
			}
			if (ignoreException){
				if (log.isDebugEnabled()){
					log.debug(""Socket exception ignored for sending Resource ""+ ""response to client (ClientAbort)"", e);
				}
				break;
			}
			throwable = throwable.getCause();
		}
		if (!ignoreException){
			throw new WicketRuntimeException(""Unable to write the response"", e);
		}
	}
	public void write(InputStream in){
		OutputStream out = getOutputStream();
		try{
			Streams.copy(in, out);
		}
		catch (Exception e){
			handleException(e);
		}
		finally{
			try{
				in.close();
				out.flush();
			}
			catch (IOException e){
				handleException(e);
			}
		}
	}
	public final void println(final CharSequence string){
		write(string);
		write(Strings.LINE_SEPARATOR);
	}
	public void detectContentType(RequestCycle requestCycle, String uri){
		final ServletContext context = ((WebApplication)requestCycle.getApplication()).getServletContext();
		String contentType = context.getMimeType(uri);
		if (contentType == null){
			contentType = URLConnection.getFileNameMap().getContentTypeFor(uri);
		}
		if (contentType != null){
			if (contentType.toLowerCase().indexOf(""text"") != -1){
				setContentType(contentType + "";
				 charset="" + getCharacterEncoding());
			}
			else{
				setContentType(contentType);
			}
		}
	}
}",0,0,0,0
"private static void printAllExcludes(ModuleDescriptor md, PrintWriter out) {
	 ExcludeRule[] excludes = md.getAllExcludeRules();
	 if (excludes.length > 0) {
		 for (ExcludeRule exclude : excludes) {
			 out.print(String.format(""\t\t<exclude org=\""%s\"" module=\""%s\"" artifact=\""%s\"" type=\""%s\"" ext=\""%s\"""", XMLHelper.escape(exclude.getId().getModuleId().getOrganisation()), XMLHelper.escape(exclude.getId().getModuleId().getName()), XMLHelper.escape(exclude.getId().getName()), XMLHelper.escape(exclude.getId().getType()), XMLHelper.escape(exclude.getId().getExt())));
			 String[] ruleConfs = exclude.getConfigurations();
			 if (!Arrays.asList(ruleConfs).equals(Arrays.asList(md.getConfigurationsNames()))) {
				 out.print(listToPrefixedString(ruleConfs, "" conf=\""""));
			 }
			 out.print("" matcher=\"""" + XMLHelper.escape(exclude.getMatcher().getName()) + ""\"""");
			 out.println(""/>"");
		 }
	 }
 }",0,0,1,0
"private void saveNetworkSettings() {
	Config config = Config.getInstance();
	config.setNetworkTimeout(cmbTimeout.getSelectedItem().equals(""N/A"") ? 0 : Integer.parseInt(cmbTimeout.getSelectedItem() + """"));
	config.setMaxSegments(Integer.parseInt(cmbSeg.getSelectedItem() + """"));
	config.setTcpWindowSize(Integer.parseInt(cmbTcp.getSelectedItem() + """"));
	try {
		int speedLimit = Integer.parseInt(txtSpeedLimit.getText());
		config.setSpeedLimit(speedLimit);
	}
	 catch (Exception e) {
	}
	int proxyMode = 0;
	if (chkUsePac.isSelected()) {
		proxyMode = 1;
	}
	 else if (chkUseProxy.isSelected()) {
		proxyMode = 2;
	}
	 else if (chkUseSocks.isSelected()) {
		proxyMode = 3;
	}
	config.setProxyMode(proxyMode);
	config.setProxyPac(txtPACUrl.getText());
	String proxyText = txtProxyHostnPort.getText();
	if (proxyText.length() > 0) {
		String host = null;
		int port = 80;
		if (proxyText.indexOf("":"") != -1) {
			String[] arr = proxyText.split("":"");
			host = arr[0];
			try {
				port = Integer.parseInt(arr[1]);
			}
			 catch (Exception e) {
				host = null;
				port = 0;
			}
		}
		 else {
			host = proxyText;
		}
		if (port > 0 && host != null && host.length() > 0) {
			config.setProxyHost(host);
			config.setProxyPort(port);
		}
	}
	String socksText = txtSocksHostnPort.getText();
	if (socksText.length() > 0) {
		String host = null;
		int port = 1080;
		if (socksText.indexOf("":"") != -1) {
			String[] arr = socksText.split("":"");
			host = arr[0];
			try {
				port = Integer.parseInt(arr[1]);
			}
			 catch (Exception e) {
				host = null;
				port = 0;
			}
		}
		 else {
			host = socksText;
		}
		if (port > 0 && host != null && host.length() > 0) {
			config.setSocksHost(host);
			config.setSocksPort(port);
		}
	}
	config.setProxyUser(txtProxyUser.getText());
	config.setProxyPass(txtProxyPass.getText());
}",0,0,1,0
"public class MatcherTransition extends AbstractNFATransition<MatcherState, MatcherTransition> {
	protected Set<IElementPattern> commonPatterns;
	protected Map<MatcherState, Set<IElementPattern>> guardedPatterns;
	public MatcherTransition(MatcherState source, MatcherState target, boolean ruleCall, AbstractElement loopCenter) {
		super(source, target, ruleCall, loopCenter);
	}
	public void addPattern(IElementPattern pattern) {
		if (commonPatterns == null)commonPatterns = Sets.newHashSet();
		commonPatterns.add(pattern);
	}
	public void addPattern(MatcherState guard, IElementPattern pattern) {
		if (guardedPatterns == null)guardedPatterns = Maps.newHashMap();
		Set<IElementPattern> patterns = guardedPatterns.get(guard);
		if (patterns == null)guardedPatterns.put(guard, patterns = Sets.<IElementPattern> newHashSet());
		patterns.add(pattern);
	}
	public Set<IElementPattern> getCommonPatterns() {
		return commonPatterns == null ? Collections.<IElementPattern> emptySet() : commonPatterns;
	}
	public Map<MatcherState, Set<IElementPattern>> getGuardPatterns() {
		return guardedPatterns == null ? Collections.<MatcherState, Set<IElementPattern>> emptyMap() : guardedPatterns;
	}
	public List<IElementPattern> getPatterns(Collection<MatcherState> from) {
		if (guardedPatterns == null && commonPatterns == null)return Collections.<IElementPattern> emptyList();
		List<IElementPattern> result = Lists.newArrayList();
		if (commonPatterns != null)result.addAll(commonPatterns);
		if (guardedPatterns != null)for (MatcherState state : from) {
			Set<IElementPattern> guard = guardedPatterns.get(state);
			if (guard != null)result.addAll(guard);
		}
		return result;
	}
}",0,0,0,0
"public abstract class AbstractRowResolver implements IResponseResolver<Row>{
	 protected static Logger logger = LoggerFactory.getLogger(AbstractRowResolver.class);
	 private static final Message FAKE_MESSAGE = new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.INTERNAL_RESPONSE, ArrayUtils.EMPTY_BYTE_ARRAY, -1);
	 protected final String table;
	 protected final ConcurrentMap<Message, ReadResponse> replies = new NonBlockingHashMap<Message, ReadResponse>();
	 protected final DecoratedKey<?> key;
	 public AbstractRowResolver(ByteBuffer key, String table) {
		 this.key = StorageService.getPartitioner().decorateKey(key);
		 this.table = table;
	 }
	 public void preprocess(Message message) {
		 byte[] body = message.getMessageBody();
		 FastByteArrayInputStream bufIn = new FastByteArrayInputStream(body);
		 try {
			 ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn), message.getVersion());
			 if (logger.isDebugEnabled()) logger.debug(""Preprocessed {
			}
			 response"", result.isDigestQuery() ? ""digest"" : ""data"");
			 replies.put(message, result);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public void injectPreProcessed(ReadResponse result) {
		 assert replies.get(FAKE_MESSAGE) == null;
		 replies.put(FAKE_MESSAGE, result);
	 }
	 public Iterable<Message> getMessages() {
		 return replies.keySet();
	 }
	 public int getMaxLiveColumns() {
		 throw new UnsupportedOperationException();
	 }
}",0,0,0,0
"public abstract class AbstractOAuth2ApiBinding implements ApiBinding, InitializingBean {
	private final String accessToken;
	private RestTemplate restTemplate;
	protected AbstractOAuth2ApiBinding() {
		accessToken = null;
		restTemplate = createRestTemplateWithCulledMessageConverters();
		configureRestTemplate(restTemplate);
	}
	protected AbstractOAuth2ApiBinding(String accessToken) {
		this(accessToken, TokenStrategy.AUTHORIZATION_HEADER);
	}
	protected AbstractOAuth2ApiBinding(String accessToken, TokenStrategy tokenStrategy) {
		this.accessToken = accessToken;
		restTemplate = createRestTemplate(accessToken, getOAuth2Version(), tokenStrategy);
		configureRestTemplate(restTemplate);
	}
	public void setRequestFactory(ClientHttpRequestFactory requestFactory) {
		restTemplate.setRequestFactory(requestFactory);
	}
	public boolean isAuthorized() {
		return accessToken != null;
	}
	public RestTemplate getRestTemplate() {
		return restTemplate;
	}
	protected OAuth2Version getOAuth2Version() {
		return OAuth2Version.BEARER;
	}
	protected void configureRestTemplate(RestTemplate restTemplate) {
	}
	protected List<HttpMessageConverter<?>> getMessageConverters() {
		List<HttpMessageConverter<?>> messageConverters = new ArrayList<HttpMessageConverter<?>>();
		messageConverters.add(new StringHttpMessageConverter());
		messageConverters.add(getFormMessageConverter());
		messageConverters.add(getJsonMessageConverter());
		messageConverters.add(getByteArrayMessageConverter());
		return messageConverters;
	}
	protected FormHttpMessageConverter getFormMessageConverter() {
		FormHttpMessageConverter converter = new FormHttpMessageConverter();
		converter.setCharset(Charset.forName(""UTF-8""));
		List<HttpMessageConverter<?>> partConverters = new ArrayList<HttpMessageConverter<?>>();
		partConverters.add(new ByteArrayHttpMessageConverter());
		StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName(""UTF-8""));
		stringHttpMessageConverter.setWriteAcceptCharset(false);
		partConverters.add(stringHttpMessageConverter);
		partConverters.add(new ResourceHttpMessageConverter());
		converter.setPartConverters(partConverters);
		return converter;
	}
	protected MappingJackson2HttpMessageConverter getJsonMessageConverter() {
		return new MappingJackson2HttpMessageConverter();
	 }
	protected ByteArrayHttpMessageConverter getByteArrayMessageConverter() {
		ByteArrayHttpMessageConverter converter = new ByteArrayHttpMessageConverter();
		converter.setSupportedMediaTypes(Arrays.asList(MediaType.IMAGE_JPEG, MediaType.IMAGE_GIF, MediaType.IMAGE_PNG));
		return converter;
	}
	private RestTemplate createRestTemplate(String accessToken, OAuth2Version version, TokenStrategy tokenStrategy) {
		RestTemplate client = createRestTemplateWithCulledMessageConverters();
		ClientHttpRequestInterceptor interceptor = tokenStrategy.interceptor(accessToken, version);
		List<ClientHttpRequestInterceptor> interceptors = new LinkedList<ClientHttpRequestInterceptor>();
		interceptors.add(interceptor);
		client.setInterceptors(interceptors);
		return client;
	}
	private RestTemplate createRestTemplateWithCulledMessageConverters() {
		RestTemplate client;
		List<HttpMessageConverter<?>> messageConverters = getMessageConverters();
		try {
			client = new RestTemplate(messageConverters);
		}
		 catch (NoSuchMethodError e) {
			client = new RestTemplate();
			client.setMessageConverters(messageConverters);
		}
		client.setRequestFactory(ClientHttpRequestFactorySelector.getRequestFactory());
		return client;
	}
	public void afterPropertiesSet() throws Exception {
		this.restTemplate = postProcess(this.restTemplate);
		postConstructionConfiguration();
	}
	protected RestTemplate postProcess(RestTemplate restTemplate) {
		return restTemplate;
	}
	protected void postConstructionConfiguration() {
	}
}",1,0,0,0
"private void transpose(int mainLoopIteration, JGraphHierarchyModel model) {
	boolean improved = true;
	int count = 0;
	int maxCount = 10;
	while (improved && count++ < maxCount) {
		boolean nudge = false;
		if (mainLoopIteration % 2 == 1 && count % 2 == 1) {
			nudge = true;
		}
		improved = false;
		for (int i = 0;
		 i < model.ranks.size();
		 i++) {
			JGraphHierarchyRank rank = (JGraphHierarchyRank) model.ranks.get(new Integer(i));
			JGraphAbstractHierarchyCell[] orderedCells = new JGraphAbstractHierarchyCell[rank.size()];
			Iterator iter = rank.iterator();
			for (int j = 0;
			 j < orderedCells.length;
			 j++) {
				JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
				orderedCells[cell.getGeneralPurposeVariable(i)] = cell;
			}
			List leftCellAboveConnections = null;
			List leftCellBelowConnections = null;
			List rightCellAboveConnections = null;
			List rightCellBelowConnections = null;
			int[] leftAbovePositions = null;
			int[] leftBelowPositions = null;
			int[] rightAbovePositions = null;
			int[] rightBelowPositions = null;
			JGraphAbstractHierarchyCell leftCell = null;
			JGraphAbstractHierarchyCell rightCell = null;
			for (int j = 0;
			 j < (rank.size() - 1);
			 j++) {
				if (j == 0) {
					leftCell = orderedCells[j];
					leftCellAboveConnections = leftCell.getNextLayerConnectedCells(i);
					leftCellBelowConnections = leftCell.getPreviousLayerConnectedCells(i);
					leftAbovePositions = new int[leftCellAboveConnections.size()];
					leftBelowPositions = new int[leftCellBelowConnections.size()];
					for (int k = 0;
					 k < leftAbovePositions.length;
					 k++) {
						leftAbovePositions[k] = ((JGraphAbstractHierarchyCell) leftCellAboveConnections.get(k)).getGeneralPurposeVariable(i + 1);
					}
					for (int k = 0;
					 k < leftBelowPositions.length;
					 k++) {
						leftBelowPositions[k] = ((JGraphAbstractHierarchyCell) leftCellBelowConnections.get(k)).getGeneralPurposeVariable(i - 1);
					}
				}
				 else {
					leftCellAboveConnections = rightCellAboveConnections;
					leftCellBelowConnections = rightCellBelowConnections;
					leftAbovePositions = rightAbovePositions;
					leftBelowPositions = rightBelowPositions;
					leftCell = rightCell;
				}
				rightCell = orderedCells[j + 1];
				rightCellAboveConnections = rightCell.getNextLayerConnectedCells(i);
				rightCellBelowConnections = rightCell.getPreviousLayerConnectedCells(i);
				rightAbovePositions = new int[rightCellAboveConnections.size()];
				rightBelowPositions = new int[rightCellBelowConnections.size()];
				for (int k = 0;
				 k < rightAbovePositions.length;
				 k++) {
					rightAbovePositions[k] = ((JGraphAbstractHierarchyCell) rightCellAboveConnections.get(k)).getGeneralPurposeVariable(i + 1);
				}
				for (int k = 0;
				 k < rightBelowPositions.length;
				 k++) {
					rightBelowPositions[k] = ((JGraphAbstractHierarchyCell) rightCellBelowConnections.get(k)).getGeneralPurposeVariable(i - 1);
				}
				int totalCurrentCrossings = 0;
				int totalSwitchedCrossings = 0;
				for (int k = 0;
				 k < leftAbovePositions.length;
				 k++) {
					for (int ik = 0;
					 ik < rightAbovePositions.length;
					 ik++) {
						if (leftAbovePositions[k] > rightAbovePositions[ik]) {
							totalCurrentCrossings++;
						}
						if (leftAbovePositions[k] < rightAbovePositions[ik]) {
							totalSwitchedCrossings++;
						}
					}
				}
				for (int k = 0;
				 k < leftBelowPositions.length;
				 k++) {
					for (int ik = 0;
					 ik < rightBelowPositions.length;
					 ik++) {
						if (leftBelowPositions[k] > rightBelowPositions[ik]) {
							totalCurrentCrossings++;
						}
						if (leftBelowPositions[k] < rightBelowPositions[ik]) {
							totalSwitchedCrossings++;
						}
					}
				}
				if ((totalSwitchedCrossings < totalCurrentCrossings)|| (totalSwitchedCrossings == totalCurrentCrossings && nudge)) {
					int temp = leftCell.getGeneralPurposeVariable(i);
					leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));
					rightCell.setGeneralPurposeVariable(i, temp);
					rightCellAboveConnections = leftCellAboveConnections;
					rightCellBelowConnections = leftCellBelowConnections;
					rightAbovePositions = leftAbovePositions;
					rightBelowPositions = leftBelowPositions;
					rightCell = leftCell;
					if (!nudge) {
						improved = true;
					}
				}
			}
		}
	}
}",0,0,1,0
"public class ModelCom extends EnhGraph implements Model, PrefixMapping, Lock{
	 private static RDFReaderF readerFactory = new RDFReaderFImpl();
	 private static RDFWriterF writerFactory = new RDFWriterFImpl();
	 private Lock modelLock = null;
	 static {
		 JenaSystem.init();
	 }
	 public ModelCom(Graph base) {
		 this(base, BuiltinPersonalities.model);
	 }
	 public ModelCom(Graph base, Personality<RDFNode> personality) {
		 super(base, personality);
	 }
	 public Graph getGraph() {
		 return graph;
	 }
	 protected static Model createWorkModel() {
		 return ModelFactory.createDefaultModel();
	 }
	 public RDFNode asRDFNode( Node n ) {
		 return n.isLiteral() ? (RDFNode) this.getNodeAs( n, Literal.class ) : (RDFNode) this.getNodeAs( n, Resource.class );
	 }
	 public Resource wrapAsResource( Node n ) {
		 if (n.isLiteral()) throw new UnsupportedOperationException( ""literal cannot be converted to Resource"" );
		 return this.getNodeAs( n, Resource.class );
	 }
	 protected ModelReifier modelReifier = new ModelReifier( this );
	 public Resource getResource(String uri, ResourceF f) {
		 try {
			 return f.createResource(getResource(uri));
		 }
		 catch (Exception e) {
			 throw new JenaException(e);
		 }
	 }
	 public Model addLiteral( Resource s, Property p, boolean o ) {
		 return add(s, p, createTypedLiteral( o ) );
	 }
	 public Model addLiteral( Resource s, Property p, long o ) {
		 return add(s, p, createTypedLiteral( o ) );
	 }
	 public Model addLiteral( Resource s, Property p, int o ) {
		 return add(s, p, createTypedLiteral( o ) );
	 }
	 public Model addLiteral( Resource s, Property p, char o ) {
		 return add(s, p, createTypedLiteral( o ) );
	 }
	 public Model addLiteral( Resource s, Property p, float o ) {
		 return add( s, p, createTypedLiteral( o ) );
	 }
	 public Model addLiteral( Resource s, Property p, double o ) {
		 return add(s, p, createTypedLiteral( o ) );
	 }
	 public Model add(Resource s, Property p, String o) {
		 return add( s, p, o, """", false );
	 }
	 public Model add(Resource s, Property p, String o, boolean wellFormed) {
		 add(s, p, literal(o, """", wellFormed));
		 return this;
	 }
	 public Model add(Resource s, Property p, String o, String lang, boolean wellFormed) {
		 add(s, p, literal(o, lang, wellFormed));
		 return this;
	 }
	 public Model add(Resource s, Property p, String lex, RDFDatatype datatype) {
		 add(s, p, literal(lex, datatype));
		 return this;
	 }
	 private Literal literal(String s, String lang, boolean wellFormed) {
		 LiteralLabel ll = LiteralLabelFactory.create(s, lang, wellFormed);
		 Node n = NodeFactory.createLiteral(ll);
		 return new LiteralImpl(n, this);
	 }
	 private Literal literal( String lex, RDFDatatype datatype) {
		 return new LiteralImpl( NodeFactory.createLiteral( lex, datatype), this );
	 }
	 public Model add( Resource s, Property p, String o, String l ) {
		 return add( s, p, o, l, false );
	 }
	 public Model addLiteral( Resource s, Property p, Object o ) {
		 return add( s, p, asObject( o ) );
	 }
	 public Model addLiteral( Resource s, Property p, Literal o ) {
		 return add( s, p, o );
	 }
	 private RDFNode asObject( Object o ) {
		 return o instanceof RDFNode ? (RDFNode) o : createTypedLiteral( o );
	 }
	 public Model add( StmtIterator iter ) {
		 try {
			 GraphUtil.add( getGraph(), asTriples( iter ) );
		 }
		 finally {
			 iter.close();
		 }
		 return this;
	 }
	 public Model add(Model m) {
		 GraphUtil.addInto(getGraph(), m.getGraph());
		 return this;
	 }
	 public RDFReaderI getReader() {
		 return readerFactory.getReader();
	 }
	 public RDFReaderI getReader(String lang) {
		 return readerFactory.getReader(lang);
	 }
	 public Model read(String url) {
		 readerFactory .getReader() .read(this, url);
		 return this;
	 }
	 public Model read(Reader reader, String base) {
		 readerFactory .getReader() .read(this, reader, base);
		 return this;
	 }
	 public Model read(InputStream reader, String base) {
		 readerFactory .getReader() .read(this, reader, base);
		 return this;
	 }
	 public Model read(String url, String lang) {
		 readerFactory. getReader(lang) .read(this, url);
		 return this;
	 }
	 public Model read(String url, String base, String lang) {
		 try (InputStream is = new URL(url).openStream()) {
			 read(is, base, lang);
		 }
		 catch (IOException e) {
			 throw new WrappedIOException(e);
		 }
		 return this;
	 }
	 public Model read(Reader reader, String base, String lang) {
		 readerFactory.getReader(lang).read(this, reader, base);
		 return this;
	 }
	 public Model read(InputStream reader, String base, String lang) {
		 readerFactory.getReader(lang).read(this, reader, base);
		 return this;
	 }
	 public RDFWriterI getWriter() {
		 return writerFactory.getWriter();
	 }
	 public RDFWriterI getWriter(String lang) {
		 return writerFactory.getWriter(lang);
	 }
	 public Model write(Writer writer) {
		 getWriter().write(this, writer, """");
		 return this;
	 }
	 public Model write(Writer writer, String lang) {
		 getWriter(lang).write(this, writer, """");
		 return this;
	 }
	 public Model write(Writer writer, String lang, String base) {
		 getWriter(lang).write(this, writer, base);
		 return this;
	 }
	 public Model write(OutputStream writer) {
		 getWriter().write(this, writer, """");
		 return this;
	 }
	 public Model write(OutputStream writer, String lang) {
		 getWriter(lang).write(this, writer, """");
		 return this;
	 }
	 public Model write(OutputStream writer, String lang, String base) {
		 getWriter(lang).write(this, writer, base);
		 return this;
	 }
	 public Model remove(Statement s) {
		 graph.delete(s.asTriple());
		 return this;
	 }
	 public Model remove(Resource s, Property p, RDFNode o) {
		 graph.delete(Triple.create(s.asNode(), p.asNode(), o.asNode()));
		 return this;
	 }
	 public Model remove(StmtIterator iter) {
		 GraphUtil.delete(getGraph(), asTriples(iter));
		 return this;
	 }
	 public Model remove(Model m) {
		 GraphUtil.deleteFrom(getGraph(), m.getGraph());
		 return this;
	 }
	 public Model removeAll() {
		 getGraph().clear();
		 return this;
	 }
	 public Model removeAll(Resource s, Property p, RDFNode o) {
		 getGraph().remove(asNode(s), asNode(p), asNode(o));
		 return this;
	 }
	 public boolean containsLiteral( Resource s, Property p, boolean o ) {
		 return contains(s, p, createTypedLiteral( o ) );
	 }
	 public boolean containsLiteral( Resource s, Property p, long o ) {
		 return contains(s, p, createTypedLiteral( o ) );
	 }
	 public boolean containsLiteral( Resource s, Property p, int o ) {
		 return contains(s, p, createTypedLiteral( o ) );
	 }
	 public boolean containsLiteral( Resource s, Property p, char o ) {
		 return contains(s, p, createTypedLiteral( o ) );
	 }
	 public boolean containsLiteral( Resource s, Property p, float o ) {
		 return contains(s, p, createTypedLiteral( o ) );
	 }
	 public boolean containsLiteral( Resource s, Property p, double o ) {
		 return contains(s, p, createTypedLiteral( o ) );
	 }
	 public boolean contains( Resource s, Property p, String o ) {
		 return contains( s, p, o, """" );
	 }
	 public boolean contains( Resource s, Property p, String o, String l ) {
		 return contains( s, p, literal( o, l, false ) );
	 }
	 public boolean containsLiteral(Resource s, Property p, Object o) {
		 return contains( s, p, asObject( o ) );
	 }
	 public boolean containsAny( Model model ) {
		 return containsAnyThenClose( model.listStatements() );
	 }
	 public boolean containsAll( Model model ) {
		 return containsAllThenClose( model.listStatements() );
	 }
	 protected boolean containsAnyThenClose( StmtIterator iter ) {
		 try {
			 return containsAny( iter );
		 }
		 finally {
			 iter.close();
		 }
	 }
	 protected boolean containsAllThenClose( StmtIterator iter ) {
		 try {
			 return containsAll( iter );
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public boolean containsAny(StmtIterator iter) {
		 while (iter.hasNext()) if ( contains(iter.nextStatement()) ) return true;
		 return false;
	 }
	 public boolean containsAll(StmtIterator iter) {
		 while (iter.hasNext()) if ( !contains(iter.nextStatement()) ) return false;
		 return true;
	 }
	 protected StmtIterator listStatements(Resource S, Property P, Node O) {
		 return IteratorFactory.asStmtIterator(graph.find(asNode(S), asNode(P), O), this);
	 }
	 public StmtIterator listStatements( Resource S, Property P, RDFNode O ) {
		 return listStatements( S, P, asNode( O ) );
	 }
	 public StmtIterator listStatements( Resource S, Property P, String O ) {
		 return O == null ? listStatements(S, P, Node.ANY) : listStatements( S, P, NodeFactory.createLiteral( O ) );
	 }
	 public StmtIterator listStatements( Resource S, Property P, String O, String L ) {
		 if (O != null) {
			 if (L != null) return listStatements( S, P, NodeFactory.createLiteral( O, L ) );
			 return new StringFilteredStmtIterator(O, listStatements(S, P, Node.ANY));
		 }
		 else {
			 return new LangFilteredStmtIterator(L, listStatements(S, P, Node.ANY));
		 }
	 }
	private class StringFilteredStmtIterator extends FilterIterator<Statement> implements StmtIterator {
		public StringFilteredStmtIterator(final String str, Iterator<Statement> it) {
			super(s -> {
				RDFNode o = s.getObject();
				if (o instanceof Literal) {
					if (str == null)return true;
					 return (str.equals(o.asLiteral().getString()));
				}
				return false;
			}
			, it);
		}
		 public Statement nextStatement() {
			 return next();
		 }
	 }
	 private class LangFilteredStmtIterator extends FilterIterator<Statement> implements StmtIterator {
		public LangFilteredStmtIterator(final String l, Iterator<Statement> it) {
			super(s -> {
				RDFNode o = s.getObject();
				if (o instanceof Literal) {
					if (l == null)return true;
					return (l.equals(o.asLiteral().getLanguage()));
				}
				return false;
			}
			, it);
		}
		 public Statement nextStatement() {
			 return next();
		 }
	 }
	 public StmtIterator listLiteralStatements( Resource S, Property P, boolean O ) {
		 return listStatements( S, P, createTypedLiteral( O ) );
	 }
	 public StmtIterator listLiteralStatements( Resource S, Property P, long O ) {
		 return listStatements( S, P, createTypedLiteral( O ) );
	 }
	 public StmtIterator listLiteralStatements( Resource S, Property P, int O ) {
		 return listStatements( S, P, createTypedLiteral( O ) );
	 }
	 public StmtIterator listLiteralStatements( Resource S, Property P, char O ) {
		 return listStatements( S, P, createTypedLiteral( O ) );
	 }
	 public StmtIterator listLiteralStatements( Resource S, Property P, float O ) {
		 return listStatements( S, P, createTypedLiteral( O ) );
	 }
	 public StmtIterator listLiteralStatements( Resource S, Property P, double O ) {
		 return listStatements( S, P, createTypedLiteral( O ) );
	 }
	 public ResIterator listResourcesWithProperty( Property p, boolean o ) {
		 return listResourcesWithProperty(p, createTypedLiteral( o ) );
	 }
	 public ResIterator listResourcesWithProperty( Property p, char o ) {
		 return listResourcesWithProperty(p, createTypedLiteral( o ) );
	 }
	 public ResIterator listResourcesWithProperty( Property p, long o ) {
		 return listResourcesWithProperty(p, createTypedLiteral( o ) );
	 }
	 public ResIterator listResourcesWithProperty( Property p, float o ) {
		 return listResourcesWithProperty(p, createTypedLiteral( o ) );
	 }
	 public ResIterator listResourcesWithProperty( Property p, double o ) {
		 return listResourcesWithProperty(p, createTypedLiteral( o ) );
	 }
	 public ResIterator listResourcesWithProperty( Property p, Object o ) {
		 return listResourcesWithProperty( p, createTypedLiteral( o ) );
	 }
	 public ResIterator listSubjectsWithProperty( Property p, RDFNode o ) {
		 return listResourcesWithProperty( p, o );
	 }
	 public ResIterator listSubjectsWithProperty( Property p, String o ) {
		 return listSubjectsWithProperty( p, o, """" );
	 }
	 public ResIterator listSubjectsWithProperty( Property p, String o, String l ) {
		 return listResourcesWithProperty(p, literal( o, l, false ) );
	 }
	 public Resource createResource( Resource type ) {
		 return createResource().addProperty( RDF.type, type );
	 }
	 public Resource createResource( String uri,Resource type ) {
		 return getResource( uri ).addProperty( RDF.type, type );
	 }
	 public Resource createResource( ResourceF f ) {
		 return createResource( null, f );
	 }
	 public Resource createResource( AnonId id ) {
		 return new ResourceImpl( id, this );
	 }
	 public Resource createResource( Statement statement ) {
		 return new ResourceImpl( statement, this );
	 }
	 public Resource createResource( String uri, ResourceF f ) {
		 return f.createResource( createResource( uri ) );
	 }
	 public Literal createTypedLiteral( boolean v ) {
		 return createTypedLiteral( Boolean.valueOf( v ) );
	 }
	 public Literal createTypedLiteral(int v) {
		 return createTypedLiteral(Integer.valueOf(v));
	 }
	 public Literal createTypedLiteral(long v) {
		 return createTypedLiteral(Long.valueOf(v));
	 }
	 public Literal createTypedLiteral(char v) {
		 return createTypedLiteral(Character.valueOf(v));
	 }
	 public Literal createTypedLiteral(float v) {
		 return createTypedLiteral(Float.valueOf(v));
	 }
	 public Literal createTypedLiteral(double v) {
		 return createTypedLiteral(Double.valueOf(v));
	 }
	 public Literal createTypedLiteral(String v) {
		 LiteralLabel ll = LiteralLabelFactory.createTypedLiteral(v);
		 return new LiteralImpl(NodeFactory.createLiteral(v), this);
	 }
	 public Literal createTypedLiteral(Calendar cal) {
		 Object value = new XSDDateTime(cal);
		 LiteralLabel ll = LiteralLabelFactory.createByValue(value, """", XSDDatatype.XSDdateTime);
		 Node n = NodeFactory.createLiteral(ll);
		 return new LiteralImpl(n, this);
	 }
	 public Literal createTypedLiteral(String lex, RDFDatatype dtype) throws DatatypeFormatException {
		 return new LiteralImpl( NodeFactory.createLiteral( lex, dtype ), this);
	 }
	 public Literal createTypedLiteral(Object value, RDFDatatype dtype) {
		 LiteralLabel ll = LiteralLabelFactory.createByValue(value, """", dtype);
		 Node n = NodeFactory.createLiteral(ll);
		 return new LiteralImpl( n, this );
	 }
	 public Literal createTypedLiteral(String lex, String typeURI) {
		 RDFDatatype dt = TypeMapper.getInstance().getSafeTypeByName(typeURI);
		 LiteralLabel ll = LiteralLabelFactory.create( lex, dt );
		 Node n = NodeFactory.createLiteral(ll);
		 return new LiteralImpl( n, this );
	 }
	 public Literal createTypedLiteral(Object value, String typeURI) {
		 RDFDatatype dt = TypeMapper.getInstance().getSafeTypeByName(typeURI);
		 LiteralLabel ll = LiteralLabelFactory.createByValue(value, """", dt);
		 Node n = NodeFactory.createLiteral(ll);
		 return new LiteralImpl( n, this );
	 }
	 public Literal createTypedLiteral(Object value) {
		 if (value instanceof Calendar) return createTypedLiteral( (Calendar)value );
		 LiteralLabel ll = LiteralLabelFactory.createTypedLiteral( value );
		 Node n = NodeFactory.createLiteral(ll);
		 return new LiteralImpl( n, this );
	 }
	 public Literal createLiteral( String v ) {
		 return createLiteral( v, """" );
	 }
	 public Literal createLiteral( String v, String l ) {
		 return literal( v, l, false );
	 }
	 public Literal createLiteral( String v, boolean wellFormed ) {
		 return literal( v, """", wellFormed );
	 }
	 public Literal createLiteral(String v, String l, boolean wellFormed) {
		 return literal( v, l, wellFormed );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, boolean o ) {
		 return createStatement( r, p, createTypedLiteral( o ) );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, long o ) {
		 return createStatement( r, p, createTypedLiteral( o ) );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, int o ) {
		 return createStatement( r, p, createTypedLiteral( o ) );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, char o ) {
		 return createStatement( r, p, createTypedLiteral( o ) );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, float o ) {
		 return createStatement( r, p, createTypedLiteral( o ) );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, double o ) {
		 return createStatement( r, p, createTypedLiteral( o ) );
	 }
	 public Statement createStatement( Resource r, Property p, String o ) {
		 return createStatement( r, p, createLiteral( o ) );
	 }
	 public Statement createLiteralStatement( Resource r, Property p, Object o ) {
		 return createStatement( r, p, asObject( o ) );
	 }
	 public Statement createStatement ( Resource r, Property p, String o, boolean wellFormed ) {
		 return createStatement( r, p, o, """", wellFormed );
	 }
	 public Statement createStatement(Resource r, Property p, String o, String l) {
		 return createStatement( r, p, o, l, false );
	 }
	 public Statement createStatement ( Resource r, Property p, String o, String l, boolean wellFormed ) {
		 return createStatement( r, p, literal( o, l, wellFormed ) );
	 }
	 public Bag createBag() {
		 return createBag( null );
	 }
	 public Alt createAlt() {
		 return createAlt( null );
	 }
	 public Seq createSeq() {
		 return createSeq( null );
	 }
	 public RDFList createList() {
		 return getResource( RDF.nil.getURI() ).as( RDFList.class );
	 }
	 public RDFList createList(Iterator<? extends RDFNode> members) {
		 if ( !members.hasNext() ) return createList();
		 Resource root = createResource().addProperty(RDF.first, members.next());
		 Resource last = root;
		 while (members.hasNext()) {
			 Resource rest = createResource().addProperty(RDF.first, members.next());
			 last.addProperty(RDF.rest, rest);
			 last = rest;
		 }
		 last.addProperty(RDF.rest, RDF.nil);
		 return root.as(RDFList.class);
	 }
	 public RDFList createList( RDFNode... members ) {
		 return createList( Arrays.asList( members ).iterator() );
	 }
	 public RDFNode getRDFNode( Node n ) {
		 return asRDFNode( n );
	 }
	 public Resource getResource( String uri ) {
		 return IteratorFactory.asResource(makeURI(uri),this);
	 }
	 public Property getProperty(String uri) {
		 if ( uri == null ) throw new InvalidPropertyURIException(null);
		 return IteratorFactory.asProperty(makeURI(uri), this);
	 }
	 public Property getProperty( String nameSpace,String localName ) {
		 return getProperty( nameSpace + localName );
	 }
	 public Seq getSeq( String uri ) {
		 return (Seq) IteratorFactory.asResource( makeURI( uri ),Seq.class, this);
	 }
	 public Seq getSeq( Resource r ) {
		 return r.inModel( this ).as( Seq.class );
	 }
	 public Bag getBag( String uri ) {
		 return (Bag) IteratorFactory.asResource( makeURI( uri ),Bag.class, this );
	 }
	 public Bag getBag( Resource r ) {
		 return r.inModel( this ).as( Bag.class );
	 }
	 public RDFList getList( String uri ) {
		 return (RDFList)IteratorFactory.asResource( makeURI( uri ), RDFList.class, this );
	 }
	 public RDFList getList( Resource r ) {
		 return r.inModel( this ).as( RDFList.class );
	 }
	 static private Node makeURI(String uri) {
		 return uri == null ? NodeFactory.createBlankNode() : NodeFactory.createURI( uri );
	 }
	 public Alt getAlt( String uri ) {
		 return (Alt) IteratorFactory.asResource( makeURI(uri) ,Alt.class, this );
	 }
	 public Alt getAlt( Resource r ) {
		 return r.inModel( this ).as( Alt.class );
	 }
	 public long size() {
		 return graph.size();
	 }
	 public boolean isEmpty() {
		 return graph.isEmpty();
	 }
	 private void updateNamespace(Set<String> set, Iterator<Node> it) {
		 while (it.hasNext()) {
			 Node node = it.next();
			 if ( node.isURI() ) {
				 String uri = node.getURI();
				 String ns = uri.substring(0, Util.splitNamespaceXML(uri));
				 set.add(ns);
			 }
		 }
	 }
	 private ExtendedIterator<Node> listPredicates() {
		 return GraphUtil.listPredicates(graph, Node.ANY, Node.ANY );
	 }
	 private Iterator<Node> listTypes() {
		 Set<Node> types = CollectionFactory.createHashedSet();
		 ClosableIterator<Triple> it = graph.find(null, RDF.type.asNode(), null);
		 while (it.hasNext()) types.add(it.next().getObject());
		 return types.iterator();
	 }
	 public NsIterator listNameSpaces() {
		 Set<String> nameSpaces = CollectionFactory.createHashedSet();
		 updateNamespace(nameSpaces, listPredicates());
		 updateNamespace(nameSpaces, listTypes());
		 return new NsIteratorImpl(nameSpaces.iterator(), nameSpaces);
	 }
	 private PrefixMapping getPrefixMapping() {
		 return getGraph().getPrefixMapping();
	 }
	 public boolean samePrefixMappingAs( PrefixMapping other ) {
		 return getPrefixMapping().samePrefixMappingAs( other );
	 }
	 public PrefixMapping lock() {
		 getPrefixMapping().lock();
		 return this;
	 }
	 public Model setNsPrefix(String prefix, String uri) {
		 getPrefixMapping().setNsPrefix(prefix, uri);
		 return this;
	 }
	 public Model removeNsPrefix(String prefix) {
		 getPrefixMapping().removeNsPrefix(prefix);
		 return this;
	 }
	 public Model clearNsPrefixMap() {
		 getPrefixMapping().clearNsPrefixMap();
		 return this;
	 }
	 public Model setNsPrefixes(PrefixMapping pm) {
		 getPrefixMapping().setNsPrefixes(pm);
		 return this;
	 }
	 public Model setNsPrefixes(Map<String, String> map) {
		 getPrefixMapping().setNsPrefixes(map);
		 return this;
	 }
	 public Model withDefaultMappings(PrefixMapping other) {
		 getPrefixMapping().withDefaultMappings(other);
		 return this;
	 }
	 public String getNsPrefixURI( String prefix ) {
		 return getPrefixMapping().getNsPrefixURI( prefix );
	 }
	 public String getNsURIPrefix( String uri ) {
		 return getPrefixMapping().getNsURIPrefix( uri );
	 }
	 public Map<String, String> getNsPrefixMap() {
		 return getPrefixMapping().getNsPrefixMap();
	 }
	 public String expandPrefix( String prefixed ) {
		 return getPrefixMapping().expandPrefix( prefixed );
	 }
	 public String qnameFor( String uri ) {
		 return getPrefixMapping().qnameFor( uri );
	 }
	 public String shortForm( String uri ) {
		 return getPrefixMapping().shortForm( uri );
	 }
	 public boolean hasNoMappings() {
		 return getPrefixMapping().hasNoMappings();
	 }
	 public int numPrefixes() {
		 return getPrefixMapping().numPrefixes();
	 }
	 public static void addNamespaces(Model m, Map<String, Set<String>> ns) {
		 PrefixMapping pm = m;
		 for ( Map.Entry<String, Set<String>> e : ns.entrySet() ) {
			 String key = e.getKey();
			 Set<String> values = e.getValue();
			 Set<String> niceValues = CollectionFactory.createHashedSet();
			 for ( String uri : values ) {
				 if ( PrefixMappingImpl.isNiceURI(uri) ) {
					 niceValues.add(uri);
				 }
			 }
			 if ( niceValues.size() == 1 ) {
				 pm.setNsPrefix(key, niceValues.iterator().next());
			 }
		 }
	 }
	 public StmtIterator listStatements() {
		 return IteratorFactory.asStmtIterator( GraphUtil.findAll( graph ), this);
	 }
	 public Model add(Statement s) {
		 add(s.getSubject(), s.getPredicate(), s.getObject());
		 return this;
	 }
	 public Model add(Statement[] statements) {
		 GraphUtil.add(getGraph(), StatementImpl.asTriples(statements));
		 return this;
	 }
	 public Model add(List<Statement> statements) {
		 GraphUtil.add(getGraph(), asTriples(statements));
		 return this;
	 }
	 private List<Triple> asTriples(List<Statement> statements) {
		 List<Triple> L = new ArrayList<>(statements.size());
		 for ( Statement statement : statements ) {
			 L.add(statement.asTriple());
		 }
		 return L;
	 }
	 private Iterator<Triple> asTriples( StmtIterator it ) {
		 return it.mapWith( s -> s.asTriple() );
	 }
	 public Model remove(Statement[] statements) {
		 GraphUtil.delete(getGraph(), StatementImpl.asTriples(statements));
		 return this;
	 }
	 public Model remove(List<Statement> statements) {
		 GraphUtil.delete(getGraph(), asTriples(statements));
		 return this;
	 }
	 public Model add( Resource s, Property p, RDFNode o ) {
		 modelReifier.noteIfReified( s, p, o );
		 graph.add( Triple.create( s.asNode(), p.asNode(), o.asNode() ) );
		 return this;
	 }
	 public RSIterator listReifiedStatements() {
		 return modelReifier.listReifiedStatements();
	 }
	 public RSIterator listReifiedStatements( Statement st ) {
		 return modelReifier.listReifiedStatements( st );
	 }
	 public boolean isReified( Statement s ) {
		 return modelReifier.isReified( s );
	 }
	 public Resource getAnyReifiedStatement(Statement s) {
		 return modelReifier.getAnyReifiedStatement( s );
	 }
	 public void removeAllReifications( Statement s ) {
		 modelReifier.removeAllReifications( s );
	 }
	 public void removeReification( ReifiedStatement rs ) {
		 modelReifier.removeReification( rs );
	 }
	 public ReifiedStatement createReifiedStatement( Statement s ) {
		 return modelReifier.createReifiedStatement( s );
	 }
	 public ReifiedStatement createReifiedStatement( String uri, Statement s ) {
		 return modelReifier.createReifiedStatement( uri, s );
	 }
	 public boolean contains( Statement s ) {
		 return graph.contains( s.asTriple() );
	 }
	 public boolean containsResource( RDFNode r ) {
		 return GraphUtil.containsNode( graph, r.asNode() );
	 }
	 public boolean contains( Resource s, Property p ) {
		 return contains( s, p, (RDFNode) null );
	 }
	 public boolean contains( Resource s, Property p, RDFNode o ) {
		 return graph.contains( asNode( s ), asNode( p ), asNode( o ) );
	 }
	 public Statement getRequiredProperty(Resource s, Property p) {
		 Statement st = getProperty( s, p );
		 if (st == null) throw new PropertyNotFoundException( p );
		 return st;
	 }
	 public Statement getRequiredProperty(Resource s, Property p, String lang) {
		 Statement st = getProperty( s, p , lang );
		 if (st == null) throw new PropertyNotFoundException( p );
		 return st;
	 }
	 public Statement getProperty( Resource s, Property p ) {
		 StmtIterator iter = listStatements( s, p, (RDFNode) null );
		 try {
			 return iter.hasNext() ? iter.nextStatement() : null;
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public Statement getProperty( Resource s, Property p, String lang) {
		 StmtIterator iter = listStatements( s, p, null, lang );
		 try {
			 return iter.hasNext() ? iter.nextStatement() : null;
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public static Node asNode( RDFNode x ) {
		 return x == null ? Node.ANY : x.asNode();
	 }
	 private NodeIterator listObjectsFor( RDFNode s, RDFNode p ) {
		 ClosableIterator<Node> xit = GraphUtil.listObjects(graph, asNode( s ), asNode( p ) );
		 return IteratorFactory.asRDFNodeIterator( xit, this );
	 }
	 private ResIterator listSubjectsFor(RDFNode p, RDFNode o) {
		 ClosableIterator<Node> xit = GraphUtil.listSubjects(graph, asNode(p), asNode(o));
		 return IteratorFactory.asResIterator(xit, this);
	 }
	 public ResIterator listSubjects() {
		 return listSubjectsFor( null, null );
	 }
	 public ResIterator listResourcesWithProperty(Property p) {
		 return listSubjectsFor( p, null );
	 }
	 public ResIterator listSubjectsWithProperty(Property p) {
		 return listResourcesWithProperty( p );
	 }
	 public ResIterator listResourcesWithProperty(Property p, RDFNode o) {
		 return listSubjectsFor( p, o );
	 }
	 public NodeIterator listObjects() {
		 return listObjectsFor( null, null );
	 }
	 public NodeIterator listObjectsOfProperty(Property p) {
		 return listObjectsFor( null, p );
	 }
	 public NodeIterator listObjectsOfProperty(Resource s, Property p) {
		 return listObjectsFor( s, p );
	 }
	 public StmtIterator listStatements(final Selector selector) {
		 StmtIterator sts = IteratorFactory.asStmtIterator( findTriplesFrom( selector ), this );
		 return selector.isSimple() ? sts : new StmtIteratorImpl( sts .filterKeep ( selector ) ) ;
	 }
	 public ExtendedIterator<Triple> findTriplesFrom(Selector s) {
		 return graph.find ( asNode( s.getSubject() ), asNode( s.getPredicate() ), asNode( s.getObject() ) );
	 }
	 public boolean supportsTransactions() {
		 return getTransactionHandler().transactionsSupported();
	 }
	 public Model begin() {
		 getTransactionHandler().begin();
		 return this;
	 }
	 public Model abort() {
		 getTransactionHandler().abort();
		 return this;
	 }
	 public Model commit() {
		 getTransactionHandler().commit();
		 return this;
	 }
	 private TransactionHandler getTransactionHandler() {
		 return getGraph().getTransactionHandler();
	 }
	 public void executeInTxn( Runnable action ) {
		 getTransactionHandler().execute( action );
	 }
	 public <T> T calculateInTxn( Supplier<T> action ) {
		 return getTransactionHandler().calculate( action );
	 }
	 public boolean independent() {
		 return true;
	 }
	 public Resource createResource() {
		 return IteratorFactory.asResource( NodeFactory.createBlankNode(),this );
	 }
	 public Resource createResource( String uri ) {
		 return getResource( uri );
	 }
	 public Property createProperty( String uri ) {
		 return getProperty( uri );
	 }
	 public Property createProperty(String nameSpace, String localName) {
		 return getProperty(nameSpace, localName);
	 }
	 public Statement createStatement(Resource r, Property p, RDFNode o) {
		 return new StatementImpl( r, p, o, this );
	 }
	 public Bag createBag(String uri) {
		 return (Bag) getBag(uri).addProperty( RDF.type, RDF.Bag );
	 }
	 public Alt createAlt( String uri ) {
		 return (Alt) getAlt(uri).addProperty( RDF.type, RDF.Alt );
	 }
	 public Seq createSeq(String uri) {
		 return (Seq) getSeq(uri).addProperty( RDF.type, RDF.Seq );
	 }
	 public Statement asStatement( Triple t ) {
		 return StatementImpl.toStatement( t, this );
	 }
	 public Statement[] asStatements(Triple[] triples) {
		 Statement [] result = new Statement [triples.length];
		 for (int i = 0;
		 i < triples.length;
		 i += 1) result[i] = asStatement( triples[i] );
		 return result;
	 }
	 public List<Statement> asStatements(List<Triple> triples) {
		 List<Statement> L = new ArrayList<>(triples.size());
		 for ( Triple triple : triples ) {
			 L.add(asStatement(triple));
		 }
		 return L;
	 }
	 public Model asModel( Graph g ) {
		 return new ModelCom( g );
	 }
	 public StmtIterator asStatements( final Iterator<Triple> it ) {
		 return new StmtIteratorImpl( new Map1Iterator<>( t -> asStatement( t ), it ) );
	 }
	 public StmtIterator listBySubject( Container cont ) {
		 return listStatements( cont, null, (RDFNode) null );
	 }
	 public void close() {
		 graph.close();
	 }
	 public boolean isClosed() {
		 return graph.isClosed();
	 }
	 public boolean supportsSetOperations() {
		return true;
	}
	 public Model query( Selector selector ) {
		 return createWorkModel() .add( listStatements( selector ) );
	 }
	 public Model union( Model model ) {
		 return createWorkModel() .add(this) .add( model );
	 }
	 public Model intersection( Model other ) {
		 return this.size() < other.size() ? intersect( this, other ) : intersect( other, this );
	 }
	 public static Model intersect(Model smaller, Model larger) {
		 Model result = createWorkModel();
		 StmtIterator it = smaller.listStatements();
		 try {
			 return addCommon( result, it, larger );
		 }
		 finally {
			 it.close();
		 }
	 }
	 protected static Model addCommon(Model result, StmtIterator it, Model other) {
		 while (it.hasNext()) {
			 Statement s = it.nextStatement();
			 if ( other.contains(s) ) result.add(s);
		 }
		 return result;
	 }
	 public Model difference(Model model) {
		 Model resultModel = createWorkModel();
		 StmtIterator iter = null;
		 Statement stmt;
		 try {
			 iter = listStatements();
			 while (iter.hasNext()) {
				 stmt = iter.nextStatement();
				 if (! model.contains(stmt)) {
					 resultModel.add(stmt);
				 }
			 }
			 return resultModel;
		 }
		 finally {
			 if (null != iter) {
				 iter.close();
			 }
		 }
	 }
	 public String toString() {
		 return ""<ModelCom "" + getGraph() + "" | "" + reifiedToString() + "">"";
	 }
	 public String reifiedToString() {
		 return statementsToString( listStatements() );
	 }
	 protected String statementsToString(StmtIterator it) {
		 StringBuilder b = new StringBuilder();
		 while (it.hasNext()) b.append("" "").append(it.nextStatement());
		 return b.toString();
	 }
	 public boolean isIsomorphicWith(Model m) {
		 Graph L = this.getGraph();
		 Graph R = m.getGraph();
		 return L.isIsomorphicWith(R);
	 }
	 public synchronized Lock getModelLock() {
		 if ( modelLock == null ) modelLock = new LockMRSW();
		 return modelLock;
	 }
	 public synchronized Lock getLock() {
		 return getModelLock();
	 }
	 public void enterCriticalSection(boolean requestReadLock) {
		 this.getModelLock().enterCriticalSection(requestReadLock);
	 }
	 public void leaveCriticalSection() {
		 this.getModelLock().leaveCriticalSection();
	 }
	 public Model register(ModelChangedListener listener) {
		 getGraph().getEventManager().register(adapt(listener));
		 return this;
	 }
	 public Model unregister(ModelChangedListener listener) {
		 getGraph().getEventManager().unregister(adapt(listener));
		 return this;
	 }
	 public GraphListener adapt( final ModelChangedListener L ) {
		 return new ModelListenerAdapter( this, L );
	 }
	 public Model notifyEvent(Object e) {
		 getGraph().getEventManager().notifyEvent(getGraph(), e);
		 return this;
	 }
}",1,0,0,0
"public class TestTypeCheckingValidatorNewLP {
	 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
	 private static final String CAST_LOAD_NOT_FOUND = ""Cannot resolve load function to use for casting from bytearray"";
	 public void setUp() throws Exception {
		 pc.connect();
	 }
	 private static final String simpleEchoStreamingCommand;
	 static {
		 if (Util.WINDOWS) simpleEchoStreamingCommand = ""perl -ne 'print \\\""$_\\\""'"";
		 else simpleEchoStreamingCommand = ""perl -ne 'print \""$_\""'"";
	 }
	 public static void setUpBeforeClass() throws Exception {
		 File fileA = new File(""a"");
		 File fileB = new File(""b"");
		 fileA.delete();
		 fileB.delete();
		 if(!fileA.createNewFile() || !fileB.createNewFile()) fail(""Unable to create input files"");
		 fileA.deleteOnExit();
		 fileB.deleteOnExit();
	 }
	 public void testExpressionTypeChecking1() throws Throwable {
		 LogicalExpressionPlan expPlan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(expPlan, 10);
		 ConstantExpression constant2 = new ConstantExpression(expPlan, 20D);
		 ConstantExpression constant3 = new ConstantExpression(expPlan, 123f);
		 AddExpression add1 = new AddExpression(expPlan, constant1, constant2);
		 CastExpression cast1 = new CastExpression(expPlan,constant3, createFS(DataType.DOUBLE));
		 MultiplyExpression mul1 = new MultiplyExpression(expPlan, add1, cast1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(expPlan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.DOUBLE, add1.getType());
		 assertEquals(DataType.DOUBLE, mul1.getType());
		 assertEquals(DataType.DOUBLE, add1.getLhs().getType());
		 assertEquals(DataType.DOUBLE, mul1.getRhs().getType());
	 }
	 private LogicalFieldSchema createFS(byte datatype) {
		 return new LogicalFieldSchema(null, null, datatype);
	 }
	 public void testExpressionTypeCheckingFail1() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20D);
		 ConstantExpression constant3 = new ConstantExpression(plan, ""123"");
		 AddExpression add1 = new AddExpression(plan, constant1, constant2);
		 CastExpression cast1 = new CastExpression(plan, constant3, createFS(DataType.BYTEARRAY));
		 MultiplyExpression mul1 = new MultiplyExpression(plan, add1, cast1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 try {
			 expTypeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
	 }
	 public void testExpressionTypeChecking2() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, new DataByteArray());
		 ConstantExpression constant3 = new ConstantExpression(plan, 123L);
		 ConstantExpression constant4 = new ConstantExpression(plan, true);
		 SubtractExpression sub1 = new SubtractExpression(plan, constant1, constant2);
		 GreaterThanExpression gt1 = new GreaterThanExpression(plan, sub1, constant3);
		 AndExpression and1 = new AndExpression(plan, gt1, constant4);
		 NotExpression not1 = new NotExpression(plan, and1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error not expected during type checking"");
		 }
		 assertEquals(DataType.INTEGER, sub1.getType());
		 assertEquals(DataType.BOOLEAN, gt1.getType());
		 assertEquals(DataType.BOOLEAN, and1.getType());
		 assertEquals(DataType.BOOLEAN, not1.getType());
		 assertEquals(DataType.INTEGER, sub1.getRhs().getType());
		 assertEquals(DataType.LONG, gt1.getLhs().getType());
	 }
	 public void testExpressionTypeChecking3() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 ConstantExpression constant3 = new ConstantExpression(plan, 123);
		 ModExpression mod1 = new ModExpression(plan, constant1, constant2);
		 EqualExpression equal1 = new EqualExpression(plan, mod1, constant3);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 plan.explain(System.out, ""text"", true);
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.LONG, mod1.getType());
		 assertEquals(DataType.BOOLEAN, equal1.getType());
		 assertEquals(DataType.LONG, mod1.getLhs().getType());
		 assertEquals(DataType.LONG, equal1.getRhs().getType());
	 }
	 public void testExpressionTypeChecking4() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20D);
		 ConstantExpression constant3 = new ConstantExpression(plan, 123f);
		 DivideExpression div1 = new DivideExpression(plan, constant1, constant2);
		 CastExpression cast1 = new CastExpression(plan, constant3, createFS(DataType.DOUBLE));
		 NotEqualExpression notequal1 = new NotEqualExpression(plan, div1, cast1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.DOUBLE, div1.getType());
		 assertEquals(DataType.BOOLEAN, notequal1.getType());
		 assertEquals(DataType.DOUBLE, div1.getLhs().getType());
		 assertEquals(DataType.DOUBLE, notequal1.getRhs().getType());
	 }
	 public void testExpressionTypeCheckingFail4() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20D);
		 ConstantExpression constant3 = new ConstantExpression(plan, ""123"");
		 DivideExpression div1 = new DivideExpression(plan, constant1, constant2);
		 CastExpression cast1 = new CastExpression(plan, constant3, createFS(DataType.BYTEARRAY));
		 NotEqualExpression notequal1 = new NotEqualExpression(plan, div1, cast1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 try {
			 expTypeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 fail(""Error during type checking"");
		 }
	 }
	 public void testExpressionTypeChecking5() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10F);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 ConstantExpression constant3 = new ConstantExpression(plan, 123F);
		 ConstantExpression constant4 = new ConstantExpression(plan, 123D);
		 LessThanEqualExpression lesser1 = new LessThanEqualExpression(plan, constant1, constant2);
		 BinCondExpression bincond1 = new BinCondExpression(plan, lesser1, constant3, constant4);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.BOOLEAN, lesser1.getType());
		 assertEquals(DataType.DOUBLE, bincond1.getType());
		 assertEquals(DataType.FLOAT, lesser1.getLhs().getType());
		 assertEquals(DataType.FLOAT, lesser1.getRhs().getType());
		 assertEquals(DataType.DOUBLE, bincond1.getLhs().getType());
		 assertEquals(DataType.DOUBLE, bincond1.getRhs().getType());
	 }
	 public void testExpressionTypeChecking6() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, ""10"");
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 AddExpression add1 = new AddExpression(plan, constant1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 LogicalRelationalOperator dummyRelOp = createDummyRelOpWithAlias();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, dummyRelOp);
		 try {
			 expTypeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
			 String msg = ""In alias dummy, incompatible types in "" + ""Add Operator left hand side:chararray right hand side:long"";
			 checkMessageInException(pve, msg);
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Error expected"");
		 }
	 }
	 private LogicalRelationalOperator createDummyRelOpWithAlias() {
		 class DummyRelOp extends LogicalRelationalOperator{
			 DummyRelOp(){
				 super(""dummy"", new LogicalPlan());
				 this.alias = ""dummy"";
			 }
			 public LogicalSchema getSchema() throws FrontendException {
				 return null;
			 }
			 public void accept(PlanVisitor v) throws FrontendException {
			 }
			 public boolean isEqual(Operator operator) throws FrontendException {
				 return false;
			 }
		 }
		 return new DummyRelOp();
	 }
	 public void testExpressionTypeChecking7() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20D);
		 ConstantExpression constant3 = new ConstantExpression(plan, 123L);
		 GreaterThanExpression gt1 = new GreaterThanExpression(plan, constant1, constant2);
		 EqualExpression equal1 = new EqualExpression(plan, gt1, constant3);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 LogicalRelationalOperator dummyRelOp = createDummyRelOpWithAlias();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, dummyRelOp);
		 try {
			 expTypeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Error expected"");
		 }
	 }
	 public void testExpressionTypeChecking8() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 TupleFactory tupleFactory = TupleFactory.getInstance();
		 ArrayList<Object> innerObjList = new ArrayList<Object>();
		 ArrayList<Object> objList = new ArrayList<Object>();
		 innerObjList.add(10);
		 innerObjList.add(3);
		 innerObjList.add(7);
		 innerObjList.add(17);
		 Tuple innerTuple = tupleFactory.newTuple(innerObjList);
		 objList.add(""World"");
		 objList.add(42);
		 objList.add(innerTuple);
		 Tuple tuple = tupleFactory.newTuple(objList);
		 ArrayList<Schema.FieldSchema> innerFss = new ArrayList<Schema.FieldSchema>();
		 ArrayList<Schema.FieldSchema> fss = new ArrayList<Schema.FieldSchema>();
		 ArrayList<Schema.FieldSchema> castFss = new ArrayList<Schema.FieldSchema>();
		 Schema.FieldSchema stringFs = new Schema.FieldSchema(null, DataType.CHARARRAY);
		 Schema.FieldSchema intFs = new Schema.FieldSchema(null, DataType.INTEGER);
		 for(int i = 0;
		 i < innerObjList.size();
		 ++i) {
			 innerFss.add(intFs);
		 }
		 Schema innerTupleSchema = new Schema(innerFss);
		 fss.add(stringFs);
		 fss.add(intFs);
		 fss.add(new Schema.FieldSchema(null, innerTupleSchema, DataType.TUPLE));
		 Schema tupleSchema = new Schema(fss);
		 Schema.FieldSchema byteArrayFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
		 for(int i = 0;
		 i < 4;
		 ++i) {
			 castFss.add(byteArrayFs);
		 }
		 Schema castSchema = new Schema(castFss);
		 ConstantExpression constant1 = new ConstantExpression(plan, innerTuple);
		 ConstantExpression constant2 = new ConstantExpression(plan, tuple);
		 CastExpression cast1 = new CastExpression(plan, constant1, org.apache.pig.newplan.logical.Util.translateFieldSchema(new FieldSchema(null, castSchema, DataType.TUPLE)));
		 EqualExpression equal1 = new EqualExpression(plan, cast1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 LogicalRelationalOperator dummyRelOp = createDummyRelOpWithAlias();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, dummyRelOp);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.BOOLEAN, equal1.getType());
		 assertEquals(DataType.TUPLE, equal1.getRhs().getType());
		 assertEquals(DataType.TUPLE, equal1.getLhs().getType());
	 }
	 public void testExpressionTypeChecking9() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 TupleFactory tupleFactory = TupleFactory.getInstance();
		 ArrayList<Object> innerObjList = new ArrayList<Object>();
		 ArrayList<Object> objList = new ArrayList<Object>();
		 innerObjList.add(""10"");
		 innerObjList.add(""3"");
		 innerObjList.add(7);
		 innerObjList.add(""17"");
		 Tuple innerTuple = tupleFactory.newTuple(innerObjList);
		 objList.add(""World"");
		 objList.add(42);
		 objList.add(innerTuple);
		 Tuple tuple = tupleFactory.newTuple(objList);
		 ArrayList<Schema.FieldSchema> innerFss = new ArrayList<Schema.FieldSchema>();
		 ArrayList<Schema.FieldSchema> fss = new ArrayList<Schema.FieldSchema>();
		 ArrayList<Schema.FieldSchema> castFss = new ArrayList<Schema.FieldSchema>();
		 Schema.FieldSchema stringFs = new Schema.FieldSchema(null, DataType.CHARARRAY);
		 Schema.FieldSchema intFs = new Schema.FieldSchema(null, DataType.INTEGER);
		 Schema.FieldSchema doubleFs = new Schema.FieldSchema(null, DataType.DOUBLE);
		 innerFss.add(stringFs);
		 innerFss.add(stringFs);
		 innerFss.add(intFs);
		 innerFss.add(stringFs);
		 Schema innerTupleSchema = new Schema(innerFss);
		 fss.add(stringFs);
		 fss.add(intFs);
		 fss.add(new Schema.FieldSchema(null, innerTupleSchema, DataType.TUPLE));
		 Schema tupleSchema = new Schema(fss);
		 castFss.add(stringFs);
		 castFss.add(stringFs);
		 castFss.add(doubleFs);
		 castFss.add(intFs);
		 Schema castSchema = new Schema(castFss);
		 ConstantExpression constant1 = new ConstantExpression(plan, innerTuple);
		 ConstantExpression constant2 = new ConstantExpression(plan, tuple);
		 CastExpression cast1 = new CastExpression(plan, constant1, org.apache.pig.newplan.logical.Util.translateFieldSchema(new FieldSchema(null, castSchema, DataType.TUPLE)));
		 EqualExpression equal1 = new EqualExpression(plan, cast1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 LogicalRelationalOperator dummyRelOp = createDummyRelOpWithAlias();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, dummyRelOp);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error expected"");
		 }
	 }
	 public void testExpressionTypeChecking10() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 ConstantExpression constant3 = new ConstantExpression(plan, Boolean.TRUE);
		 GreaterThanExpression gt1 = new GreaterThanExpression(plan, constant1, constant2);
		 EqualExpression equal1 = new EqualExpression(plan, gt1, constant3);
		 NotEqualExpression nq1 = new NotEqualExpression(plan, gt1, constant3);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor( plan, collector, null);
		 expTypeChecker.visit();
		 plan.explain(System.out, ""text"", true);
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.BOOLEAN, gt1.getType());
		 assertEquals(DataType.BOOLEAN, equal1.getType());
		 assertEquals(DataType.BOOLEAN, nq1.getType());
		 assertEquals(DataType.LONG, gt1.getLhs().getType());
		 assertEquals(DataType.BOOLEAN, equal1.getRhs().getType());
		 assertEquals(DataType.BOOLEAN, nq1.getRhs().getType());
	 }
	 public void testExpressionTypeCheckingFail10() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 ConstantExpression constant3 = new ConstantExpression(plan, ""true"");
		 GreaterThanExpression gt1 = new GreaterThanExpression(plan, constant1, constant2);
		 CastExpression cast1 = new CastExpression(plan, constant3, createFS(DataType.BYTEARRAY));
		 EqualExpression equal1 = new EqualExpression(plan, gt1, cast1);
		 NotEqualExpression nq1 = new NotEqualExpression(plan, gt1, cast1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor( plan, collector, null);
		 try {
			 expTypeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
	 }
	 public void testExpressionTypeChecking11() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant0 = new ConstantExpression(plan, new DateTime(0L));
		 ConstantExpression constant1 = new ConstantExpression(plan, new DateTime(""1970-01-01T00:00:00.000Z""));
		 ConstantExpression constant2 = new ConstantExpression(plan, new DateTime(1L));
		 ConstantExpression constant3 = new ConstantExpression(plan, new DateTime(2L));
		 ConstantExpression constant4 = new ConstantExpression(plan, new DataByteArray(""1970-01-01T00:00:00.003Z""));
		 LessThanExpression lt1 = new LessThanExpression(plan, constant1, constant2);
		 LessThanEqualExpression lte1 = new LessThanEqualExpression(plan, constant1, constant2);
		 GreaterThanExpression gt1 = new GreaterThanExpression(plan, constant3, constant4);
		 GreaterThanEqualExpression gte1 = new GreaterThanEqualExpression(plan, constant3, constant4);
		 EqualExpression eq1 = new EqualExpression(plan, constant0, constant1);
		 NotEqualExpression neq1 = new NotEqualExpression(plan, constant0, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor( plan, collector, null);
		 expTypeChecker.visit();
		 plan.explain(System.out, ""text"", true);
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
		 assertEquals(DataType.BOOLEAN, lt1.getType());
		 assertEquals(DataType.BOOLEAN, lte1.getType());
		 assertEquals(DataType.BOOLEAN, gt1.getType());
		 assertEquals(DataType.BOOLEAN, gte1.getType());
		 assertEquals(DataType.BOOLEAN, eq1.getType());
		 assertEquals(DataType.BOOLEAN, neq1.getType());
		 assertEquals(DataType.DATETIME, gt1.getRhs().getType());
		 assertEquals(DataType.DATETIME, gte1.getRhs().getType());
	 }
	 public void testExpressionTypeCheckingFail11() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant0 = new ConstantExpression(plan, new DateTime(0L));
		 ConstantExpression constant1 = new ConstantExpression(plan, new String(""1970-01-01T00:00:00.000Z""));
		 CastExpression cast1 = new CastExpression(plan, constant1, createFS(DataType.CHARARRAY));
		 EqualExpression eq1 = new EqualExpression(plan, constant0, cast1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor( plan, collector, null);
		 try {
			 expTypeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new Exception(""Error during type checking"");
		 }
	 }
	 public void testArithmeticOpCastInsert1() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20D);
		 MultiplyExpression mul1 = new MultiplyExpression(plan,constant1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 System.out.println(DataType.findTypeName(mul1.getType()));
		 assertEquals(DataType.DOUBLE, mul1.getType());
	 }
	 public void testArithmeticOpCastInsert2() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 NegativeExpression neg1 = new NegativeExpression(plan, constant1);
		 SubtractExpression subtract1 = new SubtractExpression(plan, neg1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 System.out.println(DataType.findTypeName(subtract1.getType()));
		 assertEquals(DataType.LONG, subtract1.getType());
		 assertTrue(subtract1.getLhs() instanceof CastExpression);
		 assertEquals(DataType.LONG, ((CastExpression)subtract1.getLhs()).getType());
		 assertEquals(neg1, ((CastExpression)subtract1.getLhs()).getExpression());
	 }
	 public void testModCastInsert1() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, 20L);
		 ModExpression mod1 = new ModExpression(plan, constant1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 System.out.println(DataType.findTypeName(mod1.getType()));
		 assertEquals(DataType.LONG, mod1.getType());
		 assertTrue(mod1.getLhs() instanceof CastExpression);
		 assertEquals(DataType.LONG, ((CastExpression)mod1.getLhs()).getType());
		 assertEquals(constant1, ((CastExpression)mod1.getLhs()).getExpression());
	 }
	 public void testRegexTypeChecking1() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, ""10"");
		 ConstantExpression constant2 = new ConstantExpression(plan, ""Regex"");
		 RegexExpression regex = new RegexExpression(plan, constant1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 System.out.println(DataType.findTypeName(regex.getType()));
		 assertEquals(DataType.BOOLEAN, regex.getType());
	 }
	 public void testRegexTypeChecking2() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, new DataByteArray());
		 ConstantExpression constant2 = new ConstantExpression(plan, ""Regex"");
		 RegexExpression regex = new RegexExpression(plan, constant1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new Exception(""Error not expected during type checking"");
		 }
		 System.out.println(DataType.findTypeName(regex.getType()));
		 assertEquals(DataType.BOOLEAN, regex.getType());
		 CastExpression cast = (CastExpression) regex.getLhs();
		 assertEquals(cast.getType(), DataType.CHARARRAY);
		 assertEquals(cast.getExpression(), constant1);
	 }
	 public void testRegexTypeChecking3() throws Throwable {
		 LogicalExpressionPlan plan = new LogicalExpressionPlan();
		 ConstantExpression constant1 = new ConstantExpression(plan, 10);
		 ConstantExpression constant2 = new ConstantExpression(plan, ""Regex"");
		 RegexExpression regex = new RegexExpression(plan, constant1, constant2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingExpVisitor expTypeChecker = new TypeCheckingExpVisitor(plan, collector, null);
		 expTypeChecker.visit();
		 printMessageCollector(collector);
	 }
	 public void testUnionCastingInsert1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 LOLoad load2 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 fsList1.add(new FieldSchema(null, DataType.BYTEARRAY));
			 fsList1.add(new FieldSchema(null, DataType.CHARARRAY));
			 inputSchema1 = new Schema(fsList1);
		 }
		 Schema inputSchema2 = null;
		 {
			 List<FieldSchema> fsList2 = new ArrayList<FieldSchema>();
			 fsList2.add(new FieldSchema(""field1b"", DataType.DOUBLE));
			 fsList2.add(new FieldSchema(null, DataType.INTEGER));
			 fsList2.add(new FieldSchema(""field3b"", DataType.FLOAT));
			 fsList2.add(new FieldSchema(""field4b"", DataType.CHARARRAY));
			 inputSchema2 = new Schema(fsList2);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(inputSchema1));
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(inputSchema2));
		 ArrayList<LogicalRelationalOperator> inputList = new ArrayList<LogicalRelationalOperator>();
		 inputList.add(load1);
		 inputList.add(load2);
		 LOUnion union = new LOUnion(plan, false);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(union);
		 plan.connect(load1, union);
		 plan.connect(load2, union);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 Schema outputSchema = org.apache.pig.newplan.logical.Util.translateSchema(union.getSchema());
		 Schema expectedSchema = null;
		 {
			 List<FieldSchema> fsListExpected = new ArrayList<FieldSchema>();
			 fsListExpected.add(new FieldSchema(""field1a"", DataType.DOUBLE));
			 fsListExpected.add(new FieldSchema(""field2a"", DataType.LONG));
			 fsListExpected.add(new FieldSchema(""field3b"", DataType.FLOAT));
			 fsListExpected.add(new FieldSchema(""field4b"", DataType.CHARARRAY));
			 expectedSchema = new Schema(fsListExpected);
		 }
		 assertTrue(Schema.equals(outputSchema, expectedSchema, true, false));
		 {
			 List<Operator> sucList1 = plan.getSuccessors(load1);
			 assertEquals(1, sucList1.size());
			 LOForEach foreach = (LOForEach) sucList1.get(0);
			 assertTrue(foreach instanceof LOForEach);
			 List<Operator> sucList2 = plan.getSuccessors(foreach);
			 assertEquals(1, sucList2.size());
			 assertTrue(sucList2.get(0) instanceof LOUnion);
			 checkForEachCasting(foreach, 0, true, DataType.DOUBLE);
			 checkForEachCasting(foreach, 1, false, DataType.UNKNOWN);
			 checkForEachCasting(foreach, 2, true, DataType.FLOAT);
			 checkForEachCasting(foreach, 3, false, DataType.UNKNOWN);
		 }
		 {
			 List<Operator> sucList1 = plan.getSuccessors(load2);
			 assertEquals(1, sucList1.size());
			 LOForEach foreach = (LOForEach) sucList1.get(0);
			 assertTrue(foreach instanceof LOForEach);
			 List<Operator> sucList2 = plan.getSuccessors(foreach);
			 assertEquals(1, sucList2.size());
			 assertTrue(sucList2.get(0) instanceof LOUnion);
			 checkForEachCasting(foreach, 0, false, DataType.UNKNOWN);
			 checkForEachCasting(foreach, 1, true, DataType.LONG);
			 checkForEachCasting(foreach, 2, false, DataType.UNKNOWN);
			 checkForEachCasting(foreach, 3, false, DataType.UNKNOWN);
		 }
	 }
	 public void testUnionCastingInsert2() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 LOLoad load2 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.BYTEARRAY));
			 inputSchema1 = new Schema(fsList1);
		 }
		 Schema inputSchema2 = null;
		 {
			 List<FieldSchema> fsList2 = new ArrayList<FieldSchema>();
			 fsList2.add(new FieldSchema(""field1b"", DataType.DOUBLE));
			 fsList2.add(new FieldSchema(""field2b"", DataType.DOUBLE));
			 inputSchema2 = new Schema(fsList2);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(inputSchema1));
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(inputSchema2));
		 ArrayList<LogicalRelationalOperator> inputList = new ArrayList<LogicalRelationalOperator>();
		 inputList.add(load1);
		 inputList.add(load2);
		 LOUnion union = new LOUnion(plan, false);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(union);
		 plan.connect(load1, union);
		 plan.connect(load2, union);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 Schema outputSchema = org.apache.pig.newplan.logical.Util.translateSchema(union.getSchema());
		 Schema expectedSchema = null;
		 {
			 List<FieldSchema> fsListExpected = new ArrayList<FieldSchema>();
			 fsListExpected.add(new FieldSchema(""field1a"", DataType.DOUBLE));
			 fsListExpected.add(new FieldSchema(""field2a"", DataType.DOUBLE));
			 expectedSchema = new Schema(fsListExpected);
		 }
		 assertTrue(Schema.equals(outputSchema, expectedSchema, true, false));
		 {
			 List<Operator> sucList1 = plan.getSuccessors(load1);
			 assertEquals(1, sucList1.size());
			 LOForEach foreach = (LOForEach) sucList1.get(0);
			 assertTrue(foreach instanceof LOForEach);
			 List<Operator> sucList2 = plan.getSuccessors(foreach);
			 assertEquals(1, sucList2.size());
			 assertTrue(sucList2.get(0) instanceof LOUnion);
			 checkForEachCasting(foreach, 0, true, DataType.DOUBLE);
			 checkForEachCasting(foreach, 1, true, DataType.DOUBLE);
		 }
		 {
			 List<Operator> sucList1 = plan.getSuccessors(load2);
			 assertEquals(1, sucList1.size());
			 assertTrue(sucList1.get(0) instanceof LOUnion);
		 }
	 }
	 public void testDistinct1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> innerList = new ArrayList<FieldSchema>();
			 innerList.add(new FieldSchema(""innerfield1"", DataType.BAG));
			 innerList.add(new FieldSchema(""innerfield2"", DataType.FLOAT));
			 Schema innerSchema = new Schema(innerList);
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2"", DataType.BYTEARRAY));
			 fsList1.add(new FieldSchema(""field3"", innerSchema));
			 fsList1.add(new FieldSchema(""field4"", DataType.BAG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setSchema(org.apache.pig.newplan.logical.Util.translateSchema(inputSchema1));
		 LODistinct distinct1 = new LODistinct(plan);
		 plan.add(load1);
		 plan.add(distinct1);
		 plan.connect(load1, distinct1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 LogicalSchema outputSchema = distinct1.getSchema();
		 assertTrue(load1.getSchema().isEqual(outputSchema));
	 }
	 public void testFilterWithInnerPlan1() throws Throwable {
		 testFilterWithInnerPlan(DataType.INTEGER, DataType.LONG);
	 }
	 public void testFilterWithInnerPlan2() throws Throwable {
		 testFilterWithInnerPlan(DataType.INTEGER, DataType.BYTEARRAY);
	 }
	 public void testFilterWithInnerPlan(byte field1Type, byte field2Type) throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", field1Type));
			 fsList1.add(new FieldSchema(""field2"", field2Type));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(inputSchema1));
		 LogicalExpressionPlan innerPlan = new LogicalExpressionPlan();
		 LOFilter filter1 = new LOFilter(plan);
		 filter1.setFilterPlan(innerPlan);
		 ProjectExpression project1 = new ProjectExpression(innerPlan, 0, 0, filter1);
		 ProjectExpression project2 = new ProjectExpression(innerPlan, 0, 1, filter1);
		 GreaterThanExpression gt1 = new GreaterThanExpression(innerPlan, project1, project2);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.connect(load1, filter1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = filter1.getSchema();
		 assertEquals(endResultSchema.getField(0).type, field1Type);
		 assertEquals(endResultSchema.getField(1).type, field2Type);
	 }
	 public void testFilterWithInnerPlan3() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2"", DataType.LONG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		 LogicalExpressionPlan innerPlan = new LogicalExpressionPlan();
		 LOFilter filter1 = new LOFilter(plan);
		 filter1.setFilterPlan(innerPlan);
		 ProjectExpression project1 = new ProjectExpression(innerPlan, 0, 0, filter1);
		 ProjectExpression project2 = new ProjectExpression(innerPlan, 0, 1, filter1);
		 AddExpression add1 = new AddExpression(innerPlan, project1, project2);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.connect(load1, filter1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 try {
			 typeChecker.visit();
		 }
		 catch (Exception t) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Expect error"");
		 }
	 }
	 public void testSortWithInnerPlan1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.LONG));
			 fsList1.add(new FieldSchema(""field2"", DataType.INTEGER));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 LOSort sort1 = new LOSort(plan);
		 ProjectExpression project1 = new ProjectExpression(innerPlan1, 0, 1, sort1);
		 innerPlan1.add(project1);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 ProjectExpression project2 = new ProjectExpression(innerPlan2, 0, 0, sort1);
		 innerPlan2.add(project2);
		 List<LogicalExpressionPlan> innerPlans = new ArrayList<LogicalExpressionPlan>();
		 innerPlans.add(innerPlan1);
		 innerPlans.add(innerPlan2);
		 List<Boolean> ascList = new ArrayList<Boolean>();
		 ascList.add(true);
		 ascList.add(true);
		 sort1.setAscendingCols(ascList);
		 sort1.setSortColPlans(innerPlans);
		 plan.add(load1);
		 plan.add(sort1);
		 plan.connect(load1, sort1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = sort1.getSchema();
		 assertEquals(DataType.LONG, endResultSchema.getField(0).type);
		 assertEquals(DataType.INTEGER, endResultSchema.getField(1).type);
		 assertEquals(DataType.INTEGER, getSingleOutput(innerPlan1).getType());
		 assertEquals(DataType.LONG, getSingleOutput(innerPlan2).getType());
	 }
	 private LogicalExpression getSingleOutput(LogicalExpressionPlan innerPlan1) {
		 List<Operator> outputs = innerPlan1.getSources();
		 assertEquals(""number of outputs in exp plan"", outputs.size(),1);
		 return (LogicalExpression)outputs.get(0);
	 }
	 public void testSortWithInnerPlan2() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.BYTEARRAY));
			 fsList1.add(new FieldSchema(""field2"", DataType.INTEGER));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LOSort sort1 = new LOSort(plan);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 0, sort1);
		 ProjectExpression project12 = new ProjectExpression(innerPlan1, 0, 1, sort1);
		 MultiplyExpression mul1 = new MultiplyExpression(innerPlan1, project11, project12);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 0, 0, sort1);
		 ConstantExpression const21 = new ConstantExpression(innerPlan2, 26L);
		 ModExpression mod21 = new ModExpression(innerPlan2, project21, const21);
		 List<LogicalExpressionPlan> innerPlans = new ArrayList<LogicalExpressionPlan>();
		 innerPlans.add(innerPlan1);
		 innerPlans.add(innerPlan2);
		 List<Boolean> ascList = new ArrayList<Boolean>();
		 ascList.add(true);
		 ascList.add(true);
		 sort1.setAscendingCols(ascList);
		 sort1.setSortColPlans(innerPlans);
		 plan.add(load1);
		 plan.add(sort1);
		 plan.connect(load1, sort1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = sort1.getSchema();
		 assertEquals(DataType.BYTEARRAY, endResultSchema.getField(0).type);
		 assertEquals(DataType.INTEGER, endResultSchema.getField(1).type);
		 assertEquals(DataType.INTEGER, getSingleOutput(innerPlan1).getType());
		 assertEquals(DataType.LONG, getSingleOutput(innerPlan2).getType());
	 }
	 public void testSortWithInnerPlan3() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.BYTEARRAY));
			 fsList1.add(new FieldSchema(""field2"", DataType.INTEGER));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LOSort sort1 = new LOSort(plan);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 0, sort1);
		 ProjectExpression project12 = new ProjectExpression(innerPlan1, 0, 1, sort1);
		 MultiplyExpression mul1 = new MultiplyExpression(innerPlan1, project11, project12);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 0, 0, sort1);
		 ConstantExpression const21 = new ConstantExpression(innerPlan2, ""26"");
		 ModExpression mod21 = new ModExpression(innerPlan2, project21, const21);
		 List<LogicalExpressionPlan> innerPlans = new ArrayList<LogicalExpressionPlan>();
		 innerPlans.add(innerPlan1);
		 innerPlans.add(innerPlan2);
		 List<Boolean> ascList = new ArrayList<Boolean>();
		 ascList.add(true);
		 ascList.add(true);
		 sort1.setAscendingCols(ascList);
		 sort1.setSortColPlans(innerPlans);
		 plan.add(load1);
		 plan.add(sort1);
		 plan.connect(load1, sort1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 try {
			 typeChecker.visit();
			 fail(""Error expected"");
		 }
		 catch (Exception t) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Error expected"");
		 }
	 }
	 public void testSplitWithInnerPlan1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.BYTEARRAY));
			 fsList1.add(new FieldSchema(""field2"", DataType.INTEGER));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LOSplit split1 = new LOSplit(plan);
		 LOSplitOutput splitOutput1 = new LOSplitOutput(plan);
		 LOSplitOutput splitOutput2 = new LOSplitOutput(plan);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 0, splitOutput1);
		 ProjectExpression project12 = new ProjectExpression(innerPlan1, 0, 1, splitOutput1);
		 NotEqualExpression notequal1 = new NotEqualExpression(innerPlan1, project11, project12);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 0, 0, splitOutput2);
		 ConstantExpression const21 = new ConstantExpression(innerPlan2, 26L);
		 LessThanEqualExpression lesser21 = new LessThanEqualExpression(innerPlan2, project21, const21);
		 splitOutput1.setFilterPlan(innerPlan1);
		 splitOutput2.setFilterPlan(innerPlan2);
		 plan.add(load1);
		 plan.add(split1);
		 plan.add(splitOutput1);
		 plan.add(splitOutput2);
		 plan.connect(load1, split1);
		 plan.connect(split1, splitOutput1);
		 plan.connect(split1, splitOutput2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 {
			 LogicalSchema endResultSchema1 = split1.getSchema();
			 assertEquals(DataType.BYTEARRAY, endResultSchema1.getField(0).type);
			 assertEquals(DataType.INTEGER, endResultSchema1.getField(1).type);
		 }
		 {
			 LogicalSchema endResultSchema1 = splitOutput1.getSchema();
			 assertEquals(DataType.BYTEARRAY, endResultSchema1.getField(0).type);
			 assertEquals(DataType.INTEGER, endResultSchema1.getField(1).type);
		 }
		 {
			 LogicalSchema endResultSchema2 = splitOutput2.getSchema();
			 assertEquals(DataType.BYTEARRAY, endResultSchema2.getField(0).type);
			 assertEquals(DataType.INTEGER, endResultSchema2.getField(1).type);
		 }
		 assertEquals(DataType.BOOLEAN, getSingleOutput(innerPlan1).getType());
		 assertEquals(DataType.BOOLEAN, getSingleOutput(innerPlan2).getType());
	 }
	 public void testSplitWithInnerPlan2() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1"", DataType.BYTEARRAY));
			 fsList1.add(new FieldSchema(""field2"", DataType.INTEGER));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LOSplit split1 = new LOSplit(plan);
		 LOSplitOutput splitOutput1 = new LOSplitOutput(plan);
		 LOSplitOutput splitOutput2 = new LOSplitOutput(plan);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 0, splitOutput1);
		 ProjectExpression project12 = new ProjectExpression(innerPlan1, 0, 1, splitOutput1);
		 NotEqualExpression notequal1 = new NotEqualExpression(innerPlan1, project11, project12);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 0, 0, splitOutput1);
		 ConstantExpression const21 = new ConstantExpression(innerPlan2, 26L);
		 SubtractExpression subtract21 = new SubtractExpression(innerPlan2, project21, const21);
		 splitOutput1.setFilterPlan(innerPlan1);
		 splitOutput2.setFilterPlan(innerPlan2);
		 plan.add(load1);
		 plan.add(split1);
		 plan.add(splitOutput1);
		 plan.add(splitOutput2);
		 plan.connect(load1, split1);
		 plan.connect(split1, splitOutput1);
		 plan.connect(split1, splitOutput2);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 try {
			 typeChecker.visit();
		 }
		 catch (Exception t) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Error expected"");
		 }
	 }
	 public void testCOGroupWithInnerPlan1GroupByTuple1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 LOLoad load2 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 Schema inputSchema2 = null;
		 {
			 List<FieldSchema> fsList2 = new ArrayList<FieldSchema>();
			 fsList2.add(new FieldSchema(""field1b"", DataType.DOUBLE));
			 fsList2.add(new FieldSchema(null, DataType.INTEGER));
			 inputSchema2 = new Schema(fsList2);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema2)));
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema2)));
		 LOCogroup cogroup1 = new LOCogroup(plan);
		 LogicalExpressionPlan innerPlan11 = new LogicalExpressionPlan();
		 ProjectExpression project111 = new ProjectExpression(innerPlan11, 0, 0, cogroup1);
		 ConstantExpression const111 = new ConstantExpression(innerPlan11, 26F);
		 SubtractExpression subtract111 = new SubtractExpression(innerPlan11, project111, const111);
		 LogicalExpressionPlan innerPlan21 = new LogicalExpressionPlan();
		 ProjectExpression project211 = new ProjectExpression(innerPlan21, 0, 0, cogroup1);
		 ProjectExpression project212 = new ProjectExpression(innerPlan21, 0, 1, cogroup1);
		 AddExpression add211 = new AddExpression(innerPlan21, project211, project212);
		 LogicalExpressionPlan innerPlan12 = new LogicalExpressionPlan();
		 ProjectExpression project121 = new ProjectExpression(innerPlan12, 1, 0, cogroup1);
		 ConstantExpression const121 = new ConstantExpression(innerPlan12, 26);
		 SubtractExpression subtract121 = new SubtractExpression(innerPlan12, project121, const121);
		 LogicalExpressionPlan innerPlan22 = new LogicalExpressionPlan();
		 ConstantExpression const122 = new ConstantExpression(innerPlan22, 26);
		 ArrayList<LogicalRelationalOperator> inputs = new ArrayList<LogicalRelationalOperator>();
		 inputs.add(load1);
		 inputs.add(load2);
		 MultiMap<Integer, LogicalExpressionPlan> maps = new MultiMap<Integer, LogicalExpressionPlan>();
		 maps.put(0, innerPlan11);
		 maps.put(0, innerPlan21);
		 maps.put(1, innerPlan12);
		 maps.put(1, innerPlan22);
		 boolean[] isInner = new boolean[inputs.size()];
		 for (int i=0;
		 i < isInner.length;
		 i++) {
			 isInner[i] = false;
		 }
		 cogroup1.setInnerFlags(isInner);
		 cogroup1.setExpressionPlans(maps);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(cogroup1);
		 plan.connect(load1, cogroup1);
		 plan.connect(load2, cogroup1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = cogroup1.getSchema();
		 assertEquals(DataType.TUPLE, endResultSchema.getField(0).type);
		 assertEquals(DataType.DOUBLE,endResultSchema.getField(0).schema.getField(0).type);
		 assertEquals(DataType.LONG, endResultSchema.getField(0).schema.getField(1).type);
		 assertEquals(DataType.BAG, endResultSchema.getField(1).type);
		 assertEquals(DataType.BAG, endResultSchema.getField(2).type);
		 LogicalSchema innerSchema1 = endResultSchema.getField(1).schema.getField(0).schema;
		 assertEquals(DataType.INTEGER, innerSchema1.getField(0).type);
		 assertEquals(DataType.LONG, innerSchema1.getField(1).type);
		 LogicalSchema innerSchema2 = endResultSchema.getField(2).schema.getField(0).schema;
		 assertEquals(DataType.DOUBLE, innerSchema2.getField(0).type);
		 assertEquals(DataType.INTEGER, innerSchema2.getField(1).type);
		 assertEquals(DataType.DOUBLE, getSingleOutput(innerPlan11).getType());
		 assertEquals(DataType.LONG, getSingleOutput(innerPlan21).getType());
		 assertEquals(DataType.DOUBLE, getSingleOutput(innerPlan12).getType());
		 assertEquals(DataType.LONG, getSingleOutput(innerPlan22).getType());
	 }
	 public void testCOGroupWithInnerPlan1GroupByAtom1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName();
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 LOLoad load2 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 Schema inputSchema2 = null;
		 {
			 List<FieldSchema> fsList2 = new ArrayList<FieldSchema>();
			 fsList2.add(new FieldSchema(""field1b"", DataType.DOUBLE));
			 fsList2.add(new FieldSchema(null, DataType.INTEGER));
			 inputSchema2 = new Schema(fsList2);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema2)));
		 LOCogroup cogroup1 = new LOCogroup(plan);
		 LogicalExpressionPlan innerPlan11 = new LogicalExpressionPlan();
		 ProjectExpression project111 = new ProjectExpression(innerPlan11, 0, 0, cogroup1);
		 ConstantExpression const111 = new ConstantExpression(innerPlan11, 26F);
		 SubtractExpression subtract111 = new SubtractExpression(innerPlan11, project111, const111);
		 LogicalExpressionPlan innerPlan12 = new LogicalExpressionPlan();
		 ProjectExpression project121 = new ProjectExpression(innerPlan12, 1, 0, cogroup1);
		 ConstantExpression const121 = new ConstantExpression(innerPlan12, 26);
		 SubtractExpression subtract121 = new SubtractExpression(innerPlan12, project121, const121);
		 ArrayList<LogicalRelationalOperator> inputs = new ArrayList<LogicalRelationalOperator>();
		 inputs.add(load1);
		 inputs.add(load2);
		 MultiMap<Integer, LogicalExpressionPlan> maps = new MultiMap<Integer, LogicalExpressionPlan>();
		 maps.put(0, innerPlan11);
		 maps.put(1, innerPlan12);
		 boolean[] isInner = new boolean[inputs.size()];
		 for (int i=0;
		 i < isInner.length;
		 i++) {
			 isInner[i] = false;
		 }
		 cogroup1.setInnerFlags(isInner);
		 cogroup1.setExpressionPlans(maps);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(cogroup1);
		 plan.connect(load1, cogroup1);
		 plan.connect(load2, cogroup1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = cogroup1.getSchema();
		 assertEquals(DataType.DOUBLE, endResultSchema.getField(0).type);
		 assertEquals(DataType.BAG, endResultSchema.getField(1).type);
		 assertEquals(DataType.BAG, endResultSchema.getField(2).type);
		 LogicalSchema innerSchema1 = endResultSchema.getField(1).schema.getField(0).schema;
		 assertEquals(DataType.INTEGER, innerSchema1.getField(0).type);
		 assertEquals(DataType.LONG, innerSchema1.getField(1).type);
		 LogicalSchema innerSchema2 = endResultSchema.getField(2).schema.getField(0).schema;
		 assertEquals(DataType.DOUBLE, innerSchema2.getField(0).type);
		 assertEquals(DataType.INTEGER, innerSchema2.getField(1).type);
		 assertEquals(DataType.DOUBLE, getSingleOutput(innerPlan11).getType());
		 assertEquals(DataType.DOUBLE, getSingleOutput(innerPlan12).getType());
	 }
	 public void testCOGroupWithInnerPlan1GroupByIncompatibleAtom1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 String pigStorage = PigStorage.class.getName() + ""('\\t','-noschema')"";
		 LOLoad load1 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 LOLoad load2 = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 Schema inputSchema2 = null;
		 {
			 List<FieldSchema> fsList2 = new ArrayList<FieldSchema>();
			 fsList2.add(new FieldSchema(""field1b"", DataType.DOUBLE));
			 fsList2.add(new FieldSchema(null, DataType.INTEGER));
			 inputSchema2 = new Schema(fsList2);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema2)));
		 LOCogroup cogroup1 = new LOCogroup(plan);
		 LogicalExpressionPlan innerPlan11 = new LogicalExpressionPlan();
		 ProjectExpression project111 = new ProjectExpression(innerPlan11, 0, 0, cogroup1);
		 ConstantExpression const111 = new ConstantExpression(innerPlan11, 26F);
		 SubtractExpression subtract111 = new SubtractExpression(innerPlan11, project111, const111);
		 LogicalExpressionPlan innerPlan12 = new LogicalExpressionPlan();
		 ConstantExpression const121 = new ConstantExpression(innerPlan12, 26);
		 ArrayList<LogicalRelationalOperator> inputs = new ArrayList<LogicalRelationalOperator>();
		 inputs.add(load1);
		 inputs.add(load2);
		 MultiMap<Integer, LogicalExpressionPlan> maps = new MultiMap<Integer, LogicalExpressionPlan>();
		 maps.put(0, innerPlan11);
		 maps.put(1, innerPlan12);
		 boolean[] isInner = new boolean[inputs.size()];
		 for (int i=0;
		 i < isInner.length;
		 i++) {
			 isInner[i] = false;
		 }
		 cogroup1.setInnerFlags(isInner);
		 cogroup1.setExpressionPlans(maps);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(cogroup1);
		 plan.connect(load1, cogroup1);
		 plan.connect(load2, cogroup1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = cogroup1.getSchema();
		 assertEquals(DataType.FLOAT, endResultSchema.getField(0).type);
		 assertEquals(DataType.BAG, endResultSchema.getField(1).type);
		 assertEquals(DataType.BAG, endResultSchema.getField(2).type);
		 LogicalSchema innerSchema1 = endResultSchema.getField(1).schema.getField(0).schema;
		 assertEquals(DataType.INTEGER, innerSchema1.getField(0).type);
		 assertEquals(DataType.LONG, innerSchema1.getField(1).type);
		 LogicalSchema innerSchema2 = endResultSchema.getField(2).schema.getField(0).schema;
		 assertEquals(DataType.DOUBLE, innerSchema2.getField(0).type);
		 assertEquals(DataType.INTEGER, innerSchema2.getField(1).type);
		 assertEquals(DataType.FLOAT, getSingleOutput(innerPlan11).getType());
		 assertEquals(DataType.FLOAT, getSingleOutput(innerPlan12).getType());
	 }
	 public void testForEachGenerate1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 LOLoad load1 = genDummyLOLoadNewLP(plan);
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LogicalPlan innerRelPlan = new LogicalPlan();
		 LOForEach foreach1 = new LOForEach(plan);
		 foreach1.setInnerPlan(innerRelPlan);
		 LOGenerate loGen = new LOGenerate(innerRelPlan);
		 innerRelPlan.add(loGen);
		 LOInnerLoad innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 0);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 0, loGen);
		 ConstantExpression const11 = new ConstantExpression(innerPlan1, 26F);
		 SubtractExpression subtract11 = new SubtractExpression(innerPlan1, project11, const11);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 LOInnerLoad innerLoad2 = new LOInnerLoad(innerRelPlan, foreach1, 0);
		 innerRelPlan.add(innerLoad2);
		 innerRelPlan.connect(innerLoad2, loGen);
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 1, 0, loGen);
		 LOInnerLoad innerLoad3 = new LOInnerLoad(innerRelPlan, foreach1, 1);
		 innerRelPlan.add(innerLoad3);
		 innerRelPlan.connect(innerLoad3, loGen);
		 ProjectExpression project22 = new ProjectExpression(innerPlan2, 2, 0, loGen);
		 AddExpression add21 = new AddExpression(innerPlan2, project21, project22 );
		 ArrayList<LogicalExpressionPlan> generatePlans = new ArrayList<LogicalExpressionPlan>();
		 generatePlans.add(innerPlan1);
		 generatePlans.add(innerPlan2);
		 boolean [] flattens = {
		true, false}
		;
		 loGen.setFlattenFlags(flattens);
		 loGen.setOutputPlans(generatePlans);
		 plan.add(load1);
		 plan.add(foreach1);
		 plan.connect(load1, foreach1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = foreach1.getSchema();
		 assertEquals(DataType.FLOAT, endResultSchema.getField(0).type);
		 assertEquals(DataType.LONG, endResultSchema.getField(1).type);
	 }
	 public void testForEachGenerate2() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 LOLoad load1 = genDummyLOLoadNewLP(plan);
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LogicalPlan innerRelPlan = new LogicalPlan();
		 LOForEach foreach1 = new LOForEach(plan);
		 foreach1.setInnerPlan(innerRelPlan);
		 LOGenerate loGen = new LOGenerate(innerRelPlan);
		 innerRelPlan.add(loGen);
		 LOInnerLoad innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 0);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 0, loGen);
		 ConstantExpression const11 = new ConstantExpression(innerPlan1, ""26F"");
		 SubtractExpression subtract11 = new SubtractExpression(innerPlan1, project11, const11);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 0);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 1, 0, loGen);
		 innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 0);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 ProjectExpression project22 = new ProjectExpression(innerPlan2, 2, 1, loGen);
		 AddExpression add21 = new AddExpression(innerPlan2, project21, project22);
		 ArrayList<LogicalExpressionPlan> generatePlans = new ArrayList<LogicalExpressionPlan>();
		 generatePlans.add(innerPlan1);
		 generatePlans.add(innerPlan2);
		 boolean [] flattens = {
		true, false}
		;
		 loGen.setFlattenFlags(flattens);
		 loGen.setOutputPlans(generatePlans);
		 plan.add(load1);
		 plan.add(foreach1);
		 plan.connect(load1, foreach1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 try {
			 typeChecker.visit();
			 fail(""Exception expected"");
		 }
		 catch (TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Expect error"");
		 }
	 }
	 public void testForEachGenerate4() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 LOLoad load1 = genDummyLOLoadNewLP(plan);
		 String[] aliases = new String[]{
		 ""a"", ""b"", ""c"" }
		;
		 byte[] types = new byte[] {
		 DataType.INTEGER, DataType.LONG, DataType.BYTEARRAY }
		;
		 Schema innerSchema1 = genFlatSchemaInTuple(aliases, types);
		 Schema inputSchema1 = null;
		 {
			 List<FieldSchema> fsList1 = new ArrayList<FieldSchema>();
			 fsList1.add(new FieldSchema(""field1a"", DataType.INTEGER));
			 fsList1.add(new FieldSchema(""field2a"", DataType.LONG));
			 fsList1.add(new FieldSchema(""field3a"", innerSchema1, DataType.BAG));
			 inputSchema1 = new Schema(fsList1);
		 }
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema((inputSchema1)));
		;
		 LogicalPlan innerRelPlan = new LogicalPlan();
		 LOForEach foreach1 = new LOForEach(plan);
		 foreach1.setInnerPlan(innerRelPlan);
		 LOGenerate loGen = new LOGenerate(innerRelPlan);
		 innerRelPlan.add(loGen);
		 LOInnerLoad innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 2);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 LogicalExpressionPlan innerPlan1 = new LogicalExpressionPlan();
		 ProjectExpression project11 = new ProjectExpression(innerPlan1, 0, 2, loGen);
		 List<Integer> projections1 = new ArrayList<Integer>();
		 projections1.add(1);
		 projections1.add(2);
		 DereferenceExpression project12 = new DereferenceExpression(innerPlan1, projections1);
		 innerPlan1.connect(project12, project11);
		 LogicalExpressionPlan innerPlan2 = new LogicalExpressionPlan();
		 innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 0);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 ProjectExpression project21 = new ProjectExpression(innerPlan2, 1, 0, loGen);
		 innerLoad1 = new LOInnerLoad(innerRelPlan, foreach1, 1);
		 innerRelPlan.add(innerLoad1);
		 innerRelPlan.connect(innerLoad1, loGen);
		 ProjectExpression project22 = new ProjectExpression(innerPlan2, 2, 0, loGen);
		 AddExpression add21 = new AddExpression(innerPlan2, project21, project22);
		 ArrayList<LogicalExpressionPlan> generatePlans = new ArrayList<LogicalExpressionPlan>();
		 generatePlans.add(innerPlan1);
		 generatePlans.add(innerPlan2);
		 boolean [] flattens = {
		true, false}
		;
		 loGen.setFlattenFlags(flattens);
		 loGen.setOutputPlans(generatePlans);
		 plan.add(load1);
		 plan.add(foreach1);
		 plan.connect(load1, foreach1);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 LogicalSchema endResultSchema = foreach1.getSchema();
		 assertEquals(DataType.LONG, endResultSchema.getField(0).type);
		 assertEquals(DataType.BYTEARRAY, endResultSchema.getField(1).type);
		 assertEquals(DataType.LONG, endResultSchema.getField(2).type);
	 }
	 public void testCross1() throws Throwable {
		 printCurrentMethodName();
		 LogicalPlan plan = new LogicalPlan();
		 LOLoad load1 = genDummyLOLoadNewLP(plan);
		 LOLoad load2 = genDummyLOLoadNewLP(plan);
		 String[] aliases1 = new String[]{
		 ""a"", ""b"", ""c"" }
		;
		 byte[] types1 = new byte[] {
		 DataType.INTEGER, DataType.LONG, DataType.BYTEARRAY }
		;
		 Schema schema1 = genFlatSchema(aliases1, types1);
		 String[] aliases2 = new String[]{
		 ""e"", ""f"" }
		;
		 byte[] types2 = new byte[] {
		 DataType.FLOAT, DataType.DOUBLE }
		;
		 Schema schema2 = genFlatSchema(aliases2, types2);
		 load1.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(schema1));
		 load2.setScriptSchema(org.apache.pig.newplan.logical.Util.translateSchema(schema2));
		 LOCross cross = new LOCross(plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(cross);
		 plan.connect(load1, cross);
		 plan.connect(load2, cross);
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 printMessageCollector(collector);
		 assertEquals(5, cross.getSchema().size());
		 assertEquals(DataType.INTEGER, cross.getSchema().getField(0).type);
		 assertEquals(DataType.LONG, cross.getSchema().getField(1).type);
		 assertEquals(DataType.BYTEARRAY, cross.getSchema().getField(2).type);
		 assertEquals(DataType.FLOAT, cross.getSchema().getField(3).type);
		 assertEquals(DataType.DOUBLE, cross.getSchema().getField(4).type);
	 }
	 public void testLineage1() throws Throwable {
		 String query = ""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"" + ""b = foreach a generate field1 + 1.0;
		"";
		 CastExpression cast = getCastFromLastForeach(query);
		 assertNull(cast.getFuncSpec());
	 }
	 private CastExpression getCastFromLastForeach(String query) throws FrontendException {
		 return getCastFromLastForeach(query, 0);
	 }
	 private CastExpression getCastFromLastForeach(String query, int expressionNum) throws FrontendException {
		 LOForEach foreach = getForeachFromPlan(query);
		 LogicalExpressionPlan foreachPlan = ((LOGenerate)foreach.getInnerPlan().getSinks().get(0)).getOutputPlans().get(expressionNum);
		 return getCastFromExpPlan(foreachPlan);
	 }
	 private CastExpression getCastFromExpPlan( LogicalExpressionPlan expPlan) {
		 CastExpression castExpr = null;
		 Iterator<Operator> opsIter = expPlan.getOperators();
		 while(opsIter.hasNext()){
			 Operator op = opsIter.next();
			 if(op instanceof CastExpression){
				 if(castExpr != null){
					 fail(""more than one cast found in plan"");
				 }
				 castExpr = (CastExpression) op;
			 }
		 }
		 return castExpr;
	 }
	 private LOForEach getForeachFromPlan(String query) throws FrontendException {
		 LogicalPlan plan = createAndProcessLPlan(query);
		 LOForEach foreach = null;
		 for(Operator op : plan.getSinks()){
			 if(op instanceof LOForEach){
				 if(foreach != null){
					 fail(""more than one sink foreach found in plan"");
				 }
				 foreach = (LOForEach) op;
			 }
		 }
		 return foreach;
	 }
	 private CastExpression getCastFromLastFilter(String query) throws FrontendException {
		 LOFilter filter = getFilterFromPlan(query);
		 LogicalExpressionPlan filterPlan = filter.getFilterPlan();
		 return getCastFromExpPlan(filterPlan);
	 }
	 private LOFilter getFilterFromPlan(String query) throws FrontendException {
		 LogicalPlan plan = createAndProcessLPlan(query);
		 LOFilter filter = null;
		 for(Operator op : plan.getSinks()){
			 if(op instanceof LOFilter){
				 if(filter != null){
					 fail(""more than one sink foreach found in plan"");
				 }
				 filter = (LOFilter) op;
			 }
		 }
		 return filter;
	 }
	 private LogicalPlan createAndProcessLPlan(String query) throws FrontendException {
		 LogicalPlan plan = generateLogicalPlan(query);
		 new ColumnAliasConversionVisitor( plan ).visit();
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 new TypeCheckingRelVisitor( plan, collector).visit();
		 new UnionOnSchemaSetter( plan ).visit();
		 new CastLineageSetter(plan, collector).visit();
		 printMessageCollector(collector);
		 plan.explain(System.out, ""text"", true);
		 if (collector.hasError()) {
			 throw new AssertionError(""Expect no error"");
		 }
		 return plan;
	 }
	 private LogicalPlan generateLogicalPlan(String query) {
		 try {
			 return ParserTestingUtils.generateLogicalPlan( query );
		 }
		 catch(Exception ex) {
			 ex.printStackTrace();
			 Assert.fail( ""Failed to generate logical plan for query ["" + query + ""] due to exception: "" + ex );
		 }
		 return null;
	 }
	 public void testLineage1NoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""b = foreach a generate $1 + 1.0;
		"";
		 CastExpression cast = getCastFromLastForeach(query);
		 assertTrue(cast.getFuncSpec().getClassName().startsWith(""org.apache.pig.builtin.PigStorage""));
	 }
	 public void testLineage2() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""b = foreach a generate field1 + 1.0;
		"";
		 CastExpression cast = getCastFromLastForeach(query);
		 assertTrue(cast.getFuncSpec().getClassName().startsWith(""org.apache.pig.builtin.PigStorage""));
	 }
	 public void testGroupLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1 , field2: float, field3: chararray );
		"" + "" b = group a by field1;
		"" + "" c = foreach b generate flatten(a);
		"" + "" d = foreach c generate field1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 private void checkLastForeachCastLoadFunc(String query, String loadFuncStr) throws FrontendException {
		 checkLastForeachCastLoadFunc(query, loadFuncStr, 0);
	 }
	 private void checkLastForeachCastLoadFunc(String query, String loadFuncStr, int expressionNum) throws FrontendException {
		 CastExpression cast = getCastFromLastForeach(query, expressionNum);
		 checkCastLoadFunc(cast, loadFuncStr);
	 }
	 private void checkCastLoadFunc(CastExpression cast, String loadFuncStr) {
		 assertNotNull(cast);
		 if(loadFuncStr == null) {
			 assertNull(cast.getFuncSpec());
		 }
		 else {
			 assertNotNull(""Expecting cast funcspec to be non null"", cast.getFuncSpec());
			 assertEquals(""Load function string"", loadFuncStr, cast.getFuncSpec().toString());
		 }
	 }
	 public void testGroupLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = group a by $0;
		"" + ""c = foreach b generate flatten(a);
		"" + ""d = foreach c generate $0 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testGroupLineage2() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + "" b = group a by field1;
		"" + "" c = foreach b generate group + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testGroupLineage2NoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = group a by $0;
		"" + ""c = foreach b generate group + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testGroupLineageStar() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (name, age, gpa);
		"" + ""b = group a by *;
		"" + ""c = foreach b generate flatten(group);
		"" + ""d = foreach c generate $0 + 1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testGroupLineageStarNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = group a by *;
		"" + ""c = foreach b generate flatten(group);
		"" + ""d = foreach c generate $0 + 1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testCogroupLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = foreach d generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
	 }
	 public void testCogroupMapLookupLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = foreach d generate group, field1#'key' + 1, field4 + 2.0 ;
		"";
		 LogicalPlan plan = createAndProcessLPlan(query);
		 LOForEach foreach = (LOForEach)plan.getSinks().get(0);
		 LogicalExpressionPlan foreachPlan = ((LOGenerate)foreach.getInnerPlan().getSinks().get(0)).getOutputPlans().get(1);
		 LogicalExpression exOp = (LogicalExpression) foreachPlan.getSinks().get(0);
		 if(! (exOp instanceof ProjectExpression)) exOp = (LogicalExpression) foreachPlan.getSinks().get(1);
		 CastExpression cast1 = (CastExpression)foreachPlan.getPredecessors(exOp).get(0);
		 MapLookupExpression map = (MapLookupExpression)foreachPlan.getPredecessors(cast1).get(0);
		 checkCastLoadFunc(cast1, ""PigStorage('a')"");
		 CastExpression cast2 = (CastExpression)foreachPlan.getPredecessors(map).get(0);
		 checkCastLoadFunc(cast1, ""PigStorage('a')"");
		 foreachPlan = ((LOGenerate)foreach.getInnerPlan().getSinks().get(0)).getOutputPlans().get(2);
		 exOp = (LogicalExpression) foreachPlan.getSinks().get(0);
		 if(! (exOp instanceof ProjectExpression)) exOp = (LogicalExpression) foreachPlan.getSinks().get(1);
		 CastExpression cast = (CastExpression)foreachPlan.getPredecessors(exOp).get(0);
		 checkCastLoadFunc(cast, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"");
	 }
	 public void testCogroupStarLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'b' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by *, b by *;
		"" + ""d = foreach c generate group, flatten($1), flatten($2);
		"" + ""e = foreach d generate group, field1 + 1, field4 + 2.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupStarLineageFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('x') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'b' using PigStorage('x') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by *, b by *;
		"" + ""d = foreach c generate group, flatten($1), flatten($2);
		"" + ""e = foreach d generate group + 1, field1 + 1, field4 + 2.0;
		"";
		 LogicalPlan plan = generateLogicalPlan(query);
		 new ColumnAliasConversionVisitor( plan ).visit();
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 try {
			 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
			 typeChecker.visit();
			 fail(""exception expected"");
		 }
		 catch(TypeCheckerException pve) {
		 }
		 printMessageCollector(collector);
		 if (!collector.hasError()) {
			 throw new AssertionError(""Expect error"");
		 }
	 }
	 public void testCogroupStarLineage1() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('x') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'b' using PigStorage('x') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by *, b by *;
		"" + ""d = foreach c generate flatten(group), flatten($1), flatten($2);
		"" + ""e = foreach d generate $0 + 1, a::field1 + 1, field4 + 2.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('x')"", 0);
		 checkLastForeachCastLoadFunc(query, ""PigStorage('x')"", 1);
		 checkLastForeachCastLoadFunc(query, ""PigStorage('x')"", 2);
	 }
	 public void testCogroupStarLineageNoSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('x');
		"" + ""b = load 'b' using PigStorage('x');
		"" + ""c = cogroup a by *, b by *;
		"";
		 String exMsg= ""Cogroup/Group by '*' or 'x..' "" + ""(range of columns to the end) "" + ""is only allowed if the input has a schema"";
		 checkExceptionMessage(query, ""c"", exMsg);
	 }
	 public void testCogroupMultiColumnProjectLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'b' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, a.(field1, field2), b.(field4);
		"" + ""e = foreach d generate group, flatten($1), flatten($2);
		"" + ""f = foreach e generate group, field1 + 1, field4 + 2.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupProjectStarLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'b' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate *;
		"" + ""f = foreach d generate group, flatten(a), flatten(b) ;
		"" + ""g = foreach f generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupProjectStarLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'b' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate *;
		"" + ""f = foreach d generate group, flatten(a), flatten(b) ;
		"" + ""g = foreach f generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testCogroupProjectStarLineageMixSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'b' using org.apache.pig.test.PigStorageWithDifferentCaster();
		"" + ""c = cogroup a by field1, b by $0;
		"" + ""d = foreach c generate *;
		"" + ""f = foreach d generate group, flatten(a), flatten(b) ;
		"" + ""g = foreach f generate $0, $1 + 1, $4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testCogroupLineageFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = foreach d generate group + 1, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 0);
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupLineage2NoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = foreach d generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testUnionLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = union a , b;
		"" + ""d = foreach c generate field2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null);
	 }
	 public void testUnionLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using PigStorage('a');
		"" + ""c = union a , b;
		"" + ""d = foreach c generate $1 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testUnionLineageNoSchemaDiffLoadFunc() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = union a , b;
		"" + ""d = foreach c generate $1 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null);
	 }
	 public void testUnionLineageDifferentSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('\u0001') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using PigStorage('\u0001') as (field4, field5, field6: chararray, field7 );
		"" + ""c = union a , b;
		"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('\u0001')"");
	 }
	 public void testUnionLineageDifferentSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		\n"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray, field7 );
		\n"" + ""c = union a , b;
		\n"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to double at <line 4,"");
	 }
	 private void checkWarning(String query, String warnMsg) throws FrontendException {
		 LogicalPlan plan = generateLogicalPlan(query);
		 new ColumnAliasConversionVisitor( plan ).visit();
		 CompilationMessageCollector collector = new CompilationMessageCollector();
		 TypeCheckingRelVisitor typeChecker = new TypeCheckingRelVisitor(plan, collector);
		 typeChecker.visit();
		 new CastLineageSetter(plan, collector).visit();
		 printMessageCollector(collector);
		 boolean isWarningSeen = false;
		 assertTrue(""message collector does not have message"", collector.hasMessage());
		 for (Message msg : collector){
			 if (msg.getMessageType() == MessageType.Warning && msg.getMessage().contains(warnMsg)){
				 isWarningSeen = true;
			 }
		 }
		 assertTrue(""Expected warning is not seen"", isWarningSeen);
	 }
	 public void testUnionLineageMixSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('x') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using PigStorage('x');
		"" + ""c = union a , b;
		"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('x')"");
	 }
	 public void testUnionLineageMixSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		\n"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		\n"" + ""c = union a , b;
		\n"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to double at <line 4,"");
	 }
	 public void testFilterLineage() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""b = filter a by field1 > 1.0;
		"";
		 checkLastFilterCast(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 private void checkLastFilterCast(String query, String loadFuncStr) throws FrontendException {
		 LogicalPlan plan = createAndProcessLPlan(query);
		 LOFilter filter = (LOFilter)plan.getSinks().get(0);
		 LogicalExpressionPlan filterPlan = filter.getFilterPlan();
		 LogicalExpression exOp = (LogicalExpression)filterPlan.getSinks().get(0);
		 if(! (exOp instanceof ProjectExpression)) exOp = (LogicalExpression) filterPlan.getSinks().get(1);
		 CastExpression cast = (CastExpression)filterPlan.getPredecessors(exOp).get(0);
		 checkCastLoadFunc(cast, loadFuncStr);
	 }
	 public void testFilterLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""b = filter a by $0 > 1.0;
		"";
		 checkLastFilterCast(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testFilterLineage1() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""b = filter a by field2 > 1.0;
		"" + ""c = foreach b generate field1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testFilterLineage1NoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""b = filter a by $0 > 1.0;
		"" + ""c = foreach b generate $1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testCogroupFilterLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = filter d by field4 > 5;
		"" + ""f = foreach e generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupFilterLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = filter d by $2 > 5;
		"" + ""f = foreach e generate $1, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testSplitLineage() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""split a into b if field1 > 1.0, c if field1 <= 1.0;
		"";
		 checkSplitLineage(query,""org.apache.pig.builtin.PigStorage"", ""org.apache.pig.builtin.PigStorage"");
	 }
	 private void checkSplitLineage(String query, String loadFuncStrA, String loadFuncStrB) throws FrontendException {
		 LogicalPlan plan = createAndProcessLPlan(query);
		 LOSplitOutput splitOutputB = (LOSplitOutput)plan.getSinks().get(0);
		 LogicalExpressionPlan bPlan = splitOutputB.getFilterPlan();
		 LogicalExpression exOp = (LogicalExpression)bPlan.getSinks().get(0);
		 if(! (exOp instanceof ProjectExpression)) exOp = (LogicalExpression) bPlan.getSinks().get(1);
		 CastExpression cast = (CastExpression)bPlan.getPredecessors(exOp).get(0);
		 checkCastLoadFunc(cast, loadFuncStrA);
		 LOSplitOutput splitOutputC = (LOSplitOutput)plan.getSinks().get(0);
		 LogicalExpressionPlan cPlan = splitOutputC.getFilterPlan();
		 exOp = (LogicalExpression) cPlan.getSinks().get(0);
		 if(! (exOp instanceof ProjectExpression)) exOp = (LogicalExpression) cPlan.getSinks().get(1);
		 cast = (CastExpression)cPlan.getPredecessors(exOp).get(0);
		 checkCastLoadFunc(cast, loadFuncStrB);
	 }
	 public void testSplitLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""split a into b if $0 > 1.0, c if $1 <= 1.0;
		"";
		 checkSplitLineage(query,""org.apache.pig.builtin.PigStorage"", ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testSplitLineage1() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2, field3: chararray );
		"" + ""split a into b if field2 > 1.0, c if field2 <= 1.0;
		"" + ""d = foreach b generate field1 + 1.0;
		"" + ""e = foreach c generate field1 + 1.0;
		"";
		 LogicalPlan plan = createAndProcessLPlan(query);
		 checkLoaderInCasts(plan, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testSplitLineage1NoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""split a into b if $0 > 1.0, c if $1 <= 1.0;
		"" + ""d = foreach b generate $1 + 1.0;
		"" + ""e = foreach c generate $1 + 1.0;
		"";
		 LogicalPlan plan = createAndProcessLPlan(query);
		 checkLoaderInCasts(plan, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testCogroupSplitLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""split d into e if field4 > 'm', f if field6 > 'm' ;
		"" + ""g = foreach e generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupSplitLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""split d into e if $1 > 'm', f if $1 > 'm' ;
		"" + ""g = foreach d generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testDistinctLineage() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""b = distinct a;
		"" + ""c = foreach b generate field1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testDistinctLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""b = distinct a;
		"" + ""c = foreach b generate $1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testCogroupDistinctLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = distinct d;
		"" + ""f = foreach e generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupDistinctLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster();
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = distinct d;
		"" + ""f = foreach e generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testSortLineage() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""b = order a by field1;
		"" + ""c = foreach b generate field1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testSortLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""b = order a by $1;
		"" + ""c = foreach b generate $1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testNestedSort() throws Throwable {
		 String query = ""a = load 'x';
		"" + ""b = group a by $0;
		"" + ""c = foreach b "" + "" {
			c1 = order $1 by $1;
			 generate $0 + 1, flatten(c1);
		 }
		;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testNestedDistinct() throws Throwable {
		 String query = ""a = load '/user/pig/tests/data/singlefile/studenttab10k' as (name, age, gpa);
		"" + ""b = group a by name;
		 "" + ""c = foreach b {
			 aa = distinct a.age;
			 generate group + 1, COUNT(aa);
		 }
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"");
	 }
	 public void testCogroupSortLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = order d by field4 desc;
		"" + ""f = foreach e generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupSortLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = order d by $2 desc;
		"" + ""f = foreach e generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testCogroupSortStarLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = order d by * desc;
		"" + ""f = foreach e generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupSortStarLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = order d by * desc;
		"" + ""f = foreach e generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testCrossLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cross a, b;
		"" + ""d = foreach c generate field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"",0);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"",1);
	 }
	 public void testCrossLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using PigStorage('a');
		"" + ""c = cross a , b;
		"" + ""d = foreach c generate $1 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testCrossLineageNoSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		\n"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		\n"" + ""c = cross a , b;
		\n"" + ""d = foreach c generate $1 + 2.0 ;
		"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to double at <line 4,"");
	 }
	 public void testCrossLineageMixSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using PigStorage('a');
		"" + ""c = cross a , b;
		"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testCrossLineageMixSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		\n"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		\n"" + ""c = cross a , b;
		\n"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to double at <line 4,"");
	 }
	 public void testJoinLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = join a by field1, b by field4;
		"" + ""d = foreach c generate field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 0);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 1);
	 }
	 public void testJoinLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using PigStorage('a');
		"" + ""c = join a by $0, b by $0;
		"" + ""d = foreach c generate $1 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 0);
	 }
	 public void testJoinLineageNoSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		\n"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster();
		\n"" + ""c = join a by $0, b by $0;
		\n"" + ""d = foreach c generate $1 + 2.0 ;
		"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to double at <line 4,"");
	 }
	 public void testJoinLineageMixSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage() as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using PigStorage();
		"" + ""c = join a by field1, b by $0;
		"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage"", 0);
	 }
	 public void testJoinLineageMixSchemaFail() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		\n"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster();
		\n"" + ""c = join a by field1, b by $0;
		\n"" + ""d = foreach c generate $3 + 2.0 ;
		"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to double at <line 4,"");
	 }
	 public void testLimitLineage() throws Throwable {
		 String query = ""a = load 'a' as (field1, field2: float, field3: chararray );
		"" + ""b = limit a 100;
		"" + ""c = foreach b generate field1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"", 0);
	 }
	 public void testLimitLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a';
		"" + ""b = limit a 100;
		"" + ""c = foreach b generate $1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"", 0);
	 }
	 public void testCogroupLimitLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = limit d 100;
		"" + ""f = foreach e generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupLimitLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = limit d 100;
		"" + ""f = foreach e generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testCogroupTopKLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b') as (field4, field5, field6: chararray );
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = order d by field1 desc;
		"" + ""f = limit e 100;
		"" + ""g = foreach f generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.test.PigStorageWithDifferentCaster('b')"", 2);
	 }
	 public void testCogroupTopKLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = load 'a' using org.apache.pig.test.PigStorageWithDifferentCaster('b');
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = order d by $2 desc;
		"" + ""f = limit e 100;
		"" + ""g = foreach f generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, null, 1);
		 checkLastForeachCastLoadFunc(query, null, 2);
	 }
	 public void testStreamingLineage1() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1: int, field2: float, field3: chararray );
		"" + ""b = stream a through `"" + simpleEchoStreamingCommand + ""`;
		"" + ""c = foreach b generate $1 + 1.0;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStreaming"", 0);
	 }
	 public void testStreamingLineage2() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1: int, field2: float, field3: chararray );
		"" + ""b = stream a through `"" + simpleEchoStreamingCommand + ""` as (f1, f2: float);
		"" + ""c = foreach b generate f1 + 1.0, f2 + 4;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStreaming"", 0);
	 }
	 public void testCogroupStreamingLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = stream a through `"" + simpleEchoStreamingCommand + ""` as (field4, field5, field6: chararray);
		"" + ""c = cogroup a by field1, b by field4;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = foreach d generate group, field1 + 1, field4 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStreaming"", 2);
	 }
	 public void testCogroupStreamingLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = stream a through `"" + simpleEchoStreamingCommand + ""`;
		"" + ""c = cogroup a by $0, b by $0;
		"" + ""d = foreach c generate group, flatten(a), flatten(b) ;
		"" + ""e = foreach d generate $0, $1 + 1, $2 + 2.0 ;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 1);
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 2);
	 }
	 public void testMapLookupLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );
		"" + ""b = foreach a generate field1#'key1' as map1;
		"" + ""c = foreach b generate map1#'key2' as keyval;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 0);
		 query += ""d = foreach c generate keyval + 1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 0);
	 }
	 public void testMapLookupLineageNoSchema() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a');
		"" + ""b = foreach a generate $0#'key1';
		"" + ""c = foreach b generate $0#'key2';
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 0);
		 query += ""d = foreach c generate $0 + 1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"", 0);
	 }
	 public void testMapLookupLineage2() throws Throwable {
		 String query = ""a = load 'a' as (s, m, l);
		"" + ""b = foreach a generate s#'x' as f1, s#'y' as f2, s#'z' as f3;
		"" + ""c = group b by f1;
		"" + ""d = foreach c {
			fil = filter b by f2 == 1;
			 generate flatten(group), SUM(fil.f3);
		}
		;
		"";
		 LOForEach foreach = getForeachFromPlan(query);
		 LogicalPlan innerPlan = foreach.getInnerPlan();
		 LOFilter filter = null;
		 Iterator<Operator> iter = innerPlan.getOperators();
		 while(iter.hasNext()){
			 Operator op = iter.next();
			 if(op instanceof LOFilter) filter = (LOFilter)op;
		 }
		 LogicalExpressionPlan filterPlan = filter.getFilterPlan();
		 CastExpression cast = getCastFromExpPlan(filterPlan);
		 assertTrue(cast.getFuncSpec().getClassName().startsWith(""org.apache.pig.builtin.PigStorage""));
	 }
	 public void testMapLookupLineage3() throws Throwable {
		 String query = ""a= load 'a' as (s, m, l);
		"" + ""b = foreach a generate flatten(l#'viewinfo') as viewinfo;
		"" + ""c = foreach b generate viewinfo#'pos' as position;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"", 0);
		 query += ""d = foreach c generate (chararray)position;
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"", 0);
	 }
	 public void testTwolevelMapLookupLineage() throws Exception {
		 List<String[]> queries = new ArrayList<String[]>();
		 queries.add(new String[] {
			""sds = LOAD '/my/data/location' "" + ""AS (simpleFields:map[], mapFields:map[], listMapFields:map[]);
			"", ""queries = FILTER sds BY mapFields#'page_params'#'query' "" + ""is NOT NULL;
			"", ""queries_rand = FOREACH queries GENERATE "" + ""(CHARARRAY) (mapFields#'page_params'#'query') AS query_string;
			"", ""queries_limit = LIMIT queries_rand 100;
			"", ""STORE queries_limit INTO 'out';
		""}
		);
		 queries.add(new String[]{
			""sds = LOAD '/my/data/location' "" + ""AS (simpleFields:map[], mapFields:map[], listMapFields:map[]);
			"", ""queries_rand = FOREACH sds GENERATE "" + ""(CHARARRAY) (mapFields#'page_params'#'query') AS query_string;
			"", ""queries = FILTER queries_rand BY query_string IS NOT null;
			"", ""queries_limit = LIMIT queries 100;
			"", ""STORE queries_limit INTO 'out';
		""}
		);
		 queries.add(new String[]{
			""sds = LOAD '/my/data/location' "" + ""AS (simpleFields:map[], mapFields:map[], listMapFields:map[]);
			"", ""params = FOREACH sds GENERATE "" + ""(map[]) (mapFields#'page_params') AS params;
			"", ""queries = FOREACH params "" + ""GENERATE (CHARARRAY) (params#'query') AS query_string;
			"", ""queries_filtered = FILTER queries BY query_string IS NOT null;
			"", ""queries_limit = LIMIT queries_filtered 100;
			"", ""STORE queries_limit INTO 'out';
		""}
		);
		 queries.add(new String[]{
			""sds = LOAD '/my/data/location' "" + ""AS (simpleFields:map[], mapFields:map[], listMapFields:map[]);
			"", ""params = FOREACH sds GENERATE"" + "" (map[]) (mapFields#'page_params') AS params;
			"", ""queries = FOREACH params GENERATE "" + ""(CHARARRAY) (params#'query') AS query_string;
			"", ""queries_limit = LIMIT queries 100;
			"", ""STORE queries_limit INTO 'out';
		""}
		);
		 queries.add(new String[]{
			""sds = LOAD '/my/data/location' "" + ""AS (simpleFields:map[], mapFields:map[], listMapFields:map[]);
			"", ""params = FOREACH sds GENERATE "" + ""(map[]) (mapFields#'page_params') AS params;
			"", ""queries = FOREACH params GENERATE "" + ""(CHARARRAY) (params#'query') AS query_string;
			"", ""rand_queries = FOREACH queries GENERATE query_string as query;
			"", ""queries_limit = LIMIT rand_queries 100;
			"", ""STORE rand_queries INTO 'out';
		""}
		);
		 for (String[] query: queries) {
			 String fullQuery = """";
			 for (String queryLine : query) {
				 fullQuery += "" "" + queryLine;
			 }
			 LogicalPlan lp = createAndProcessLPlan(fullQuery);
			 checkLoaderInCasts(lp, ""org.apache.pig.builtin.PigStorage"");
		 }
	 }
	 public void testMapCastLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1 : map[], field2: float );
		"" + ""b = foreach a generate (map[int])field1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testTupleCastLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1 : tuple(i), field2: float);
		"" + ""b = foreach a generate (tuple(int))field1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 public void testBagCastLineage() throws Throwable {
		 String query = ""a = load 'a' using PigStorage('a') as (field1 : bag{
		 t : tuple (i)}
		, field2: float);
		"" + ""b = foreach a generate (bag{
		tuple(int)}
		)field1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage('a')"");
	 }
	 private void checkLoaderInCasts(LogicalPlan plan, String loaderClassName) throws FrontendException {
		 CastFinder cf = new CastFinder(plan);
		 cf.visit();
		 List<CastExpression> casts = cf.casts;
		 System.out.println(""Casts found : "" + casts.size());
		 for (CastExpression cast : casts) {
			 assertTrue(cast.getFuncSpec().getClassName().startsWith( loaderClassName));
		 }
	 }
	 class CastFinder extends AllExpressionVisitor {
		 List<CastExpression> casts = new ArrayList<CastExpression>();
		 public CastFinder(OperatorPlan plan) throws FrontendException {
			 super(plan, new DependencyOrderWalker(plan));
		 }
		 protected LogicalExpressionVisitor getVisitor( LogicalExpressionPlan exprPlan) throws FrontendException {
			 return new CastExpFinder(exprPlan, new ReverseDependencyOrderWalker(exprPlan));
		 }
		 class CastExpFinder extends LogicalExpressionVisitor{
			 protected CastExpFinder(OperatorPlan p, PlanWalker walker) throws FrontendException {
				 super(p, walker);
			 }
			 public void visit(CastExpression cExp){
				 casts.add(cExp);
			 }
		 }
	 }
	 public void testBincond() throws Throwable {
		 String query = ""a= load 'a' as (name: chararray, age: int, gpa: float);
		"" + ""b = group a by name;
		"" + ""c = foreach b generate (IsEmpty(a) ? "" + TestBinCondFieldSchema.class.getName() + ""(*): a);
		"";
		 LOForEach foreach = getForeachFromPlan(query);
		 Schema.FieldSchema charFs = new FieldSchema(null, DataType.CHARARRAY);
		 Schema.FieldSchema intFs = new FieldSchema(null, DataType.INTEGER);
		 Schema.FieldSchema floatFs = new FieldSchema(null, DataType.FLOAT);
		 Schema tupleSchema= new Schema();
		 tupleSchema.add(charFs);
		 tupleSchema.add(intFs);
		 tupleSchema.add(floatFs);
		 Schema.FieldSchema bagFs = null;
		 Schema bagSchema = new Schema();
		 bagSchema.add(new FieldSchema(null, tupleSchema, DataType.TUPLE));
		 try {
			 bagFs = new Schema.FieldSchema(null, bagSchema, DataType.BAG);
		 }
		 catch (FrontendException fee) {
			 fail(""Did not expect an error"");
		 }
		 Schema expectedSchema = new Schema(bagFs);
		 Schema foreachSch = org.apache.pig.newplan.logical.Util.translateSchema(foreach.getSchema());
		 assertTrue(Schema.equals(foreachSch, expectedSchema, false, true));
	 }
	 public void testBinCondForOuterJoin() throws Throwable {
		 String query = ""a= LOAD 'student_data' AS (name: chararray, age: int, gpa: float);
		"" + ""b = LOAD 'voter_data' AS (name: chararray, age: int, registration: chararray, contributions: float);
		"" + ""c = COGROUP a BY name, b BY name;
		"" + ""d = FOREACH c GENERATE group, "" + ""flatten((not IsEmpty(a) ? a : (bag{
		tuple(chararray, int, float)}
		){
		(null, null, null)}
		)),"" + "" flatten((not IsEmpty(b) ? b : (bag{
		tuple(chararray, int, chararray, float)}
		){
		(null,null,null, null)}
		));
		"";
		 LOForEach foreach = getForeachFromPlan(query);
		 String expectedSchemaString = ""mygroup: chararray,A::name: chararray,A::age: int,"" + ""A::gpa: float,B::name: chararray,B::age: int,"" + ""B::registration: chararray,B::contributions: float"";
		 Schema expectedSchema = Utils.getSchemaFromString(expectedSchemaString);
		 Schema foreachSch = org.apache.pig.newplan.logical.Util.translateSchema(foreach.getSchema());
		 assertTrue(Schema.equals(foreachSch, expectedSchema, false, true));
	 }
	 public void testMapLookupCast() throws Exception {
		 String input[] = {
		 ""[k1#hello,k2#bye]"", ""[k1#good,k2#morning]"" }
		;
		 PigServer ps = new PigServer(ExecType.LOCAL);
		 File f = org.apache.pig.test.Util.createInputFile(""test"", "".txt"", input);
		 String inputFileName = Util.generateURI(f.getAbsolutePath(), ps.getPigContext());
		 String query = ""a= load '"" + inputFileName + ""' as (m);
		"" + "" b = foreach a generate m#'k1';
		"";
		 checkLastForeachCastLoadFunc(query, ""org.apache.pig.builtin.PigStorage"", 0);
		 query = ""a= load '"" + inputFileName + ""' as (m:[]);
		"" + ""b = foreach a generate m#'k1';
		"";
		 LOForEach foreach = getForeachFromPlan(query);
		 LOGenerate loGen = (LOGenerate) foreach.getInnerPlan().getSinks().get(0);
		 Operator outExp = loGen.getOutputPlans().get(0).getSources().get(0);
		 assertFalse(""outExp is not cast"", outExp instanceof CastExpression);
		 ps.registerQuery(""a = load '"" + inputFileName + ""' as (m);
		"");
		 ps.registerQuery(""b = foreach a generate m#'k1';
		"");
		 Iterator<Tuple> it = ps.openIterator(""b"");
		 String[] expectedResults = new String[] {
		""(hello)"", ""(good)""}
		;
		 int i = 0;
		 while(it.hasNext()) {
			 assertEquals(expectedResults[i++], it.next().toString());
		 }
		 ps.registerQuery(""a = load '""+ inputFileName + ""' as (m:[]);
		"");
		 ps.registerQuery(""b = foreach a generate m#'k1';
		"");
		 it = ps.openIterator(""b"");
		 expectedResults = new String[] {
		""(hello)"", ""(good)""}
		;
		 i = 0;
		 while(it.hasNext()) {
			 assertEquals(expectedResults[i++], it.next().toString());
		 }
	 }
	 public static class TestBinCondFieldSchema extends EvalFunc<DataBag> {
		 public DataBag exec(Tuple input) {
			 return null;
		 }
		 public Schema outputSchema(Schema input) {
			 Schema.FieldSchema charFs = new FieldSchema(null, DataType.CHARARRAY);
			 Schema.FieldSchema intFs = new FieldSchema(null, DataType.INTEGER);
			 Schema.FieldSchema floatFs = new FieldSchema(null, DataType.FLOAT);
			 Schema bagSchema = new Schema();
			 bagSchema.add(charFs);
			 bagSchema.add(intFs);
			 bagSchema.add(floatFs);
			 Schema.FieldSchema bagFs;
			 try {
				 bagFs = new Schema.FieldSchema(null, bagSchema, DataType.BAG);
			 }
			 catch (FrontendException fee) {
				 return null;
			 }
			 return new Schema(bagFs);
		 }
	 }
	 private void checkForEachCasting(LOForEach foreach, int idx, boolean isCast, byte toType) throws FrontendException {
		 LOGenerate gen = (LOGenerate) foreach.getInnerPlan().getSinks().get(0);
		 LogicalExpressionPlan plan = gen.getOutputPlans().get(idx);
		 if (isCast) {
			 List<Operator> leaveList = plan.getSources();
			 assertEquals(1, leaveList.size());
			 assertTrue(leaveList.get(0) instanceof CastExpression);
			 assertEquals(toType, ((LogicalExpression)leaveList.get(0)).getType());
		 }
		 else {
			 List<Operator> leaveList = plan.getSources();
			 assertEquals(1, leaveList.size());
			 assertTrue(leaveList.get(0) instanceof ProjectExpression);
		 }
	 }
	 public void testLineageMultipleLoader1() throws FrontendException {
		 String query = ""A = LOAD 'data1' USING PigStorage() AS (u, v, w);
		"" + ""B = LOAD 'data2' USING TextLoader() AS (x, y);
		"" + ""C = JOIN A BY u, B BY x USING 'replicated';
		"" + ""D = GROUP C BY (u, x);
		"" + ""E = FOREACH D GENERATE (chararray)group.u, (int)group.x;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage"", 0);
		 checkLastForeachCastLoadFunc(query, ""TextLoader"", 1);
	 }
	 public void testLineageMultipleLoader2() throws FrontendException {
		 String query = ""A = LOAD 'data1' USING PigStorage() AS (s, m, l);
		"" + ""B = FOREACH A GENERATE s#'k1' as v1, m#'k2' as v2, l#'k3' as v3;
		"" + ""C = FOREACH B GENERATE v1, (v2 == 'v2' ? 1L : 0L) as v2:long, (v3 == 'v3' ? 1 :0) as v3:int;
		"" + ""D = LOAD 'data2' USING TextLoader() AS (a);
		"" + ""E = JOIN C BY v1, D BY a USING 'replicated';
		"" + ""F = GROUP E BY (v1, a);
		"" + ""G = FOREACH F GENERATE (chararray)group.v1, group.a;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage"", 0);
	 }
	 public void testLineageMultipleLoader3() throws FrontendException {
		 String query = ""A = LOAD 'data1' USING PigStorage() AS (u, v, w);
		\n"" + ""B = LOAD 'data2' USING TextLoader() AS (x, y);
		\n"" + ""C = COGROUP A BY u, B by x;
		\n"" + ""D = FOREACH C GENERATE (chararray)group;
		\n"";
		 checkWarning(query, CAST_LOAD_NOT_FOUND + "" to chararray at <line 4,"");
	 }
	 public void testLineageFilterWithTuple() throws FrontendException {
		 String query = ""A= LOAD 'data1' USING PigStorage() AS (u, v, w:tuple(a,b));
		"" + ""B = FOREACH A generate v, w;
		"" + ""C = FILTER B by v < 50;
		"" + ""D = FOREACH C generate (int)w.a;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage"", 0);
	 }
	 public void testLineageExpressionCasting() throws FrontendException {
		 String query = ""A= LOAD 'data1' USING PigStorage() AS (u:int, v);
		"" + ""B = FILTER A by u < 50;
		"" + ""C = FOREACH B generate u + v;
		"";
		 LogicalPlan plan = createAndProcessLPlan(query);
		 checkLoaderInCasts(plan, ""PigStorage"");
	 }
	 public void testBagDereference() throws FrontendException {
		 String query = ""a= load '1.txt' as (a0);
		"" + ""b = foreach a generate flatten((bag{
		tuple(map[])}
		)a0) as b0:map[];
		"" + ""c = foreach b generate (long)b0#'key1';
		"";
		 LogicalPlan plan = createAndProcessLPlan(query);
		 checkLoaderInCasts(plan, PigStorage.class.getName());
	 }
	 public void testColumnWithinNonTupleBag() throws IOException {
		 {
			 String query = "" l = load 'x' as (i : int);
			"" + "" f = foreach l generate i.$0;
			 "";
			 Util.checkExceptionMessage(query, ""f"", ""Referring to column(s) within a column of type "" + ""int is not allowed"" );
		 }
		 {
			 String query = "" l = load 'x' as (i : map[]);
			"" + "" f = foreach l generate i.$0;
			 "";
			 Util.checkExceptionMessage(query, ""f"", ""Referring to column(s) within a column of type "" + ""map is not allowed"" );
		 }
	 }
	 public void testCompareTupleFail() throws Throwable {
		 String query = ""a = load 'a' as (t : (i : int, j : int));
		"" + ""b = filter a by t > (1,2);
		"";
		 String exMsg= ""In alias b, incompatible types in GreaterThan Operator"" + "" left hand side:tuple i:int,j:int "" + "" right hand side:tuple :int,:int"";
		 checkExceptionMessage(query, ""b"", exMsg);
	 }
	 public void testCompareEqualityTupleCast() throws Throwable {
		 String query = ""a = load 'a' as (t : (i : int, j : int), col);
		"" + ""b = filter a by t == col;
		"";
		 CastExpression castExp = getCastFromLastFilter(query);
		 assertNotNull(""cast "", castExp);
		 assertEquals(""cast type"", DataType.TUPLE, castExp.getType());
	 }
	 public void testCompareEqualityMapCast() throws Throwable {
		 String query = ""a = load 'a' as (t : map[], col);
		"" + ""b = filter a by t != col;
		"";
		 CastExpression castExp = getCastFromLastFilter(query);
		 assertNotNull(""cast "", castExp);
		 assertEquals(""cast type"", DataType.MAP, castExp.getType());
	 }
	 public void testCompareEqualityMapIntegerFail() throws Throwable {
		 String query = ""a = load 'a' as (t1 :map[], t2 : int);
		"" + ""b = filter a by t1 == t2;
		"";
		 String exMsg= ""In alias b, incompatible types in Equal "" + ""Operator left hand side:map right hand side:int"";
		 checkExceptionMessage(query, ""b"", exMsg);
	 }
	 public void testCompareMapFail() throws Throwable {
		 String query = ""a = load 'a' as (t1 :map[], t2 : map[]);
		"" + ""b = filter a by t1 <= t2;
		"";
		 String exMsg= ""In alias b, incompatible types in LessThanEqual "" + ""Operator left hand side:map right hand side:map"";
		 checkExceptionMessage(query, ""b"", exMsg);
	 }
	 public void testCompareBagFail() throws Throwable {
		 String query = ""a = load 'a' as (t1 :bag{
		()}
		, t2 : bag{
		()}
		);
		"" + ""b = filter a by t1 <= t2;
		"";
		 String exMsg= ""In alias b, incompatible types in LessThanEqual "" + ""Operator left hand side:bag :tuple() right hand side:bag :tuple()"";
		 checkExceptionMessage(query, ""b"", exMsg);
	 }
	 public void testCompareNULL() throws Throwable {
		 {
			 String query = ""a = load 'a' as (t1 : int);
			"" + ""b = filter a by null == t1;
			"";
			 CastExpression castExp = getCastFromLastFilter(query);
			 assertNotNull(""cast "", castExp);
			 assertEquals(""cast type"", DataType.INTEGER, castExp.getType());
		 }
		 {
			 String query = ""a = load 'a' as (t1 : (i : int));
			"" + ""b = filter a by null == t1;
			"";
			 CastExpression castExp = getCastFromLastFilter(query);
			 assertNotNull(""cast "", castExp);
			 assertEquals(""cast type"", DataType.TUPLE, castExp.getType());
		 }
		 {
			 String query = ""a = load 'a' as (t1 : int);
			"" + ""b = filter a by t1 <= null;
			"";
			 CastExpression castExp = getCastFromLastFilter(query);
			 assertNotNull(""cast "", castExp);
			 assertEquals(""cast type"", DataType.INTEGER, castExp.getType());
		 }
	 }
	 public void testDereferenceTypeSet() throws IOException, ParserException {
		 String query = ""a = load 'a' as (i : int, j : int);
		"" + "" b = foreach a generate i, j/10.1 as jd;
		"" + "" c = group b by i;
		"" + "" d = foreach c generate MAX(b.jd) as mx;
		"";
		 PigServer pig = new PigServer(ExecType.LOCAL);
		 Util.registerMultiLineQuery(pig, query);
		 Schema expectedSch = Utils.getSchemaFromString(""mx: double"");
		 Schema sch = pig.dumpSchema(""d"");
		 assertEquals(""Checking expected schema"", expectedSch, sch);
	 }
	 public static class TestUDFTupleNullInnerSchema extends EvalFunc<Tuple> {
		 public Tuple exec(Tuple input) throws IOException {
			 return null;
		 }
	 }
	 public void testUDFNoInnerSchema() throws FrontendException {
		 String query = ""a= load '1.txt' using PigStorage(':') ;
		"" + ""b = foreach a generate ""+TestUDFTupleNullInnerSchema.class.getName()+""($0);
		"" + ""c = foreach b generate flatten($0);
		"" + ""d = foreach c generate $0 + 1;
		"";
		 checkLastForeachCastLoadFunc(query, ""PigStorage(':')"");
	 }
	 public void testCastEmptyInnerSchema() throws IOException, ParserException{
		 final String INP_FILE = ""testCastEmptyInnerSchema.txt"";
		 PrintWriter w = new PrintWriter(new FileWriter(INP_FILE));
		 w.println(""(1,2)"");
		 w.println(""(2,3)"");
		 w.close();
		 PigServer pigServer = new PigServer(LOCAL);
		 String query = ""a = load '"" + INP_FILE + ""' as (t:tuple());
		"" + ""b = foreach a generate (tuple(int, long))t;
		"" + ""c = foreach b generate t.$0 + t.$1;
		"";
		 Util.registerMultiLineQuery(pigServer, query);
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(3L)"", ""(5L)"", }
		);
		 Iterator<Tuple> it = pigServer.openIterator(""c"");
		 Util.checkQueryOutputs(it, expectedRes);
	 }
	 public void testCoGroupComplex() throws Exception {
		 String query = ""l1 = load 'x' using PigStorage(':') as (a : (i : int),b,c);
		"" + ""l2 = load 'x' as (a,b,c);
		"" + ""cg = cogroup l1 by a, l2 by a;
		"";
		 createAndProcessLPlan(query);
	 }
	 public void testJoinIncompatType() throws IOException {
		 String query = ""a = load '1.txt' as (a0:map [], a1:int);
		"" + ""b = load '2.txt' as (a0:int, a1:int);
		"" + ""c = join a by (a0, a1), b by (a0,a1);
		"";
		 String msg = ""join column no. 1 in relation no. 2 of join statement"" + "" has datatype int which is incompatible with type of"" + "" corresponding column in earlier relation(s) in the statement"";
		 Util.checkExceptionMessage(query, ""c"", msg);
	 }
	 public static class GenericToMap extends EvalFunc<Map<String, Double>> {
		 public Map exec(Tuple input) throws IOException {
			 Map<String, Double> output = new HashMap<String, Double>();
			 output.put((String)input.get(0), (Double)input.get(1));
			 return output;
		 }
	 }
	 public void testBinCondCompatMap() throws Exception {
		 String query = ""a = load 'studenttab10k' as (name:chararray, gpa:double);
		"" + ""b = foreach a generate gpa, TOMAP(name, gpa) as m1, "" + GenericToMap.class.getName() + ""(name, gpa) as m2;
		"" + ""c = foreach b generate (gpa>3? m1 : m2);
		"";
		 createAndProcessLPlan(query);
	 }
	 public static class GenericToTuple extends EvalFunc<Tuple> {
		 public Tuple exec(Tuple input) throws IOException {
			 return input;
		 }
	 }
	 public void testBinCondCompatTuple() throws Exception {
		 String query = ""a = load 'studenttab10k' as (name:chararray, gpa:double);
		"" + ""b = foreach a generate gpa, TOTUPLE(name, gpa) as t1, "" + GenericToTuple.class.getName() + ""(name, gpa) as t2;
		"" + ""c = foreach b generate (gpa>3? t1 : t2);
		"";
		 createAndProcessLPlan(query);
	 }
	 public static class GenericToBag extends EvalFunc<DataBag> {
		 public DataBag exec(Tuple input) throws IOException {
			 DataBag bag = new NonSpillableDataBag(1);
			 Tuple t = new DefaultTuple();
			 t.append(input.get(0));
			 bag.add(t);
			 return bag;
		 }
	 }
	 public void testBinCondCompatBag() throws Exception {
		 String query = ""a = load 'studenttab10k' as (name:chararray, gpa:double);
		"" + ""b = foreach a generate gpa, TOBAG(name) as b1, "" + GenericToBag.class.getName() + ""(name) as b2;
		"" + ""c = foreach b generate (gpa>3? b1 : b2);
		"";
		 createAndProcessLPlan(query);
	 }
	 public void testSplitLineageWithInnerFields() throws Throwable {
		 String query = ""A = load 'a' as (field1, field2);
		"" + "" B = group A by (field1,field2);
		"" + ""split B into C if SIZE(A) > 2, Z otherwise;
		"" + ""D = FOREACH C {
			 "" + "" D1 = FOREACH A generate (chararray) field1;
			"" + "" GENERATE D1;
		"" + ""}
		"";
		 LOForEach outerForeach = getForeachFromPlan(query);
		 LogicalPlan innerPlan = outerForeach.getInnerPlan();
		 LOForEach innerForeach = (LOForEach)innerPlan.getPredecessors(innerPlan.getSinks().get(0)).get(0);
		 LogicalExpressionPlan innerForeachPlan = ((LOGenerate)innerForeach.getInnerPlan().getSinks().get(0)).getOutputPlans().get(0);
		 CastExpression cast = getCastFromExpPlan(innerForeachPlan);
		 checkCastLoadFunc(cast, ""org.apache.pig.builtin.PigStorage"");
	 }
}",1,0,0,0
"public void comment(char[] chars, int offset, int length) throws SAXException {
	 if (_dom == null) {
		 prepareNewDOM();
	 }
	 maybeEmitStartElement();
	 _dom.comment(chars, offset, length);
 }",0,0,0,0
"protected class Users implements TransientComposite {
	 public void signup( Registration registration ) {
		 events.signedup( registration );
	 }
 }",0,0,0,0
"public class UDFContextTestEvalFunc2 extends EvalFunc<String> {
	 public UDFContextTestEvalFunc2() {
		 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass());
		 p.setProperty(""key1"", ""five"");
	 }
	 public String exec(Tuple input) throws IOException {
		 if (UDFContext.getUDFContext().getJobConf() == null) return ""JobConf is null!"";
		 else return UDFContext.getUDFContext().getUDFProperties(this.getClass()).getProperty(""key1"");
	 }
}",1,0,0,0
"public class SparkVersion {
	 private static final Logger logger = LoggerFactory.getLogger(SparkVersion.class);
	 public static final SparkVersion SPARK_1_6_0 = SparkVersion.fromVersionString(""1.6.0"");
	 public static final SparkVersion SPARK_2_0_0 = SparkVersion.fromVersionString(""2.0.0"");
	 public static final SparkVersion SPARK_2_3_0 = SparkVersion.fromVersionString(""2.3.0"");
	 public static final SparkVersion SPARK_2_3_1 = SparkVersion.fromVersionString(""2.3.1"");
	 public static final SparkVersion SPARK_2_4_0 = SparkVersion.fromVersionString(""2.4.0"");
	 public static final SparkVersion SPARK_3_0_0 = SparkVersion.fromVersionString(""3.0.0"");
	 public static final SparkVersion MIN_SUPPORTED_VERSION = SPARK_1_6_0;
	 public static final SparkVersion UNSUPPORTED_FUTURE_VERSION = SPARK_3_0_0;
	 private int version;
	 private int majorVersion;
	 private int minorVersion;
	 private int patchVersion;
	 private String versionString;
	 SparkVersion(String versionString) {
		 this.versionString = versionString;
		 try {
			 int pos = versionString.indexOf('-');
			 String numberPart = versionString;
			 if (pos > 0) {
				 numberPart = versionString.substring(0, pos);
			 }
			 String versions[] = numberPart.split(""\\."");
			 this.majorVersion = Integer.parseInt(versions[0]);
			 this.minorVersion = Integer.parseInt(versions[1]);
			 this.patchVersion = Integer.parseInt(versions[2]);
			 version = Integer.parseInt(String.format(""%d%02d%02d"", majorVersion, minorVersion, patchVersion));
		 }
		 catch (Exception e) {
			 logger.error(""Can not recognize Spark version "" + versionString + "". Assume it's a future release"", e);
			 version = 99999;
		 }
	 }
	 public int toNumber() {
		 return version;
	 }
	 public String toString() {
		 return versionString;
	 }
	 public boolean isUnsupportedVersion() {
		 return olderThan(MIN_SUPPORTED_VERSION) || newerThanEquals(UNSUPPORTED_FUTURE_VERSION);
	 }
	 public static SparkVersion fromVersionString(String versionString) {
		 return new SparkVersion(versionString);
	 }
	 public boolean isSpark2() {
		 return this.newerThanEquals(SPARK_2_0_0);
	 }
	 public boolean isSecretSocketSupported() {
		 return this.newerThanEquals(SparkVersion.SPARK_2_4_0) || this.newerThanEqualsPatchVersion(SPARK_2_3_1) || this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(""2.2.2"")) || this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(""2.1.3""));
	 }
	 public boolean equals(Object versionToCompare) {
		 return version == ((SparkVersion) versionToCompare).version;
	 }
	 public boolean newerThan(SparkVersion versionToCompare) {
		 return version > versionToCompare.version;
	 }
	 public boolean newerThanEquals(SparkVersion versionToCompare) {
		 return version >= versionToCompare.version;
	 }
	 public boolean newerThanEqualsPatchVersion(SparkVersion versionToCompare) {
		 return majorVersion == versionToCompare.majorVersion && minorVersion == versionToCompare.minorVersion && patchVersion >= versionToCompare.patchVersion;
	 }
	 public boolean olderThan(SparkVersion versionToCompare) {
		 return version < versionToCompare.version;
	 }
	 public boolean olderThanEquals(SparkVersion versionToCompare) {
		 return version <= versionToCompare.version;
	 }
}",0,1,0,0
"public abstract class AbstractPageableView<T> extends RefreshingView<T> implements IPageable{
	private static final long serialVersionUID = 1L;
	private int itemsPerPage = Integer.MAX_VALUE;
	private int currentPage;
	private transient int cachedItemCount;
	public AbstractPageableView(String id, IModel<? extends Collection<? extends T>> model){
		super(id, model);
		clearCachedItemCount();
	}
	public AbstractPageableView(String id){
		super(id);
		clearCachedItemCount();
	}
	protected Iterator<IModel<T>> getItemModels(){
		int offset = getViewOffset();
		int size = getViewSize();
		Iterator<IModel<T>> models = getItemModels(offset, size);
		models = new CappedIteratorAdapter<T>(models, size);
		return models;
	}
	protected void onBeforeRender(){
		clearCachedItemCount();
		super.onBeforeRender();
	}
	protected abstract Iterator<IModel<T>> getItemModels(int offset, int size);
	private void clearCachedItemCount(){
		cachedItemCount = -1;
	}
	private void setCachedItemCount(int itemCount){
		cachedItemCount = itemCount;
	}
	private int getCachedItemCount(){
		if (cachedItemCount < 0){
			throw new IllegalStateException(""getItemCountCache() called when cache was not set"");
		}
		return cachedItemCount;
	}
	private boolean isItemCountCached(){
		return cachedItemCount >= 0;
	}
	protected final int internalGetRowsPerPage(){
		return itemsPerPage;
	}
	protected final void internalSetRowsPerPage(int items){
		if (items < 1){
			throw new IllegalArgumentException(""Argument [itemsPerPage] cannot be less than 1"");
		}
		if (itemsPerPage != items){
			if (isVersioned()){
				addStateChange(new Change(){
					private static final long serialVersionUID = 1L;
					final int old = itemsPerPage;
					public void undo(){
						itemsPerPage = old;
					}
					public String toString(){
						return ""ItemsPerPageChange[component: "" + getPath() + "", itemsPerPage: ""+ old + ""]"";
					}
				}
				);
			}
		}
		itemsPerPage = items;
		setCurrentPage(0);
	}
	protected abstract int internalGetItemCount();
	public final int getRowCount(){
		if (!isVisibleInHierarchy()){
			return 0;
		}
		return getItemCount();
	}
	public final int getItemCount(){
		if (isItemCountCached()){
			return getCachedItemCount();
		}
		int count = internalGetItemCount();
		setCachedItemCount(count);
		return count;
	}
	public final int getCurrentPage(){
		int page = currentPage;
		if (page > 0 && page >= getPageCount()){
			page = Math.max(getPageCount() - 1, 0);
			currentPage = page;
			return page;
		}
		return page;
	}
	public final void setCurrentPage(int page){
		if (currentPage != page){
			if (isVersioned()){
				addStateChange(new Change(){
					private static final long serialVersionUID = 1L;
					private final int old = currentPage;
					public void undo(){
						currentPage = old;
					}
					public String toString(){
						return ""CurrentPageChange[component: "" + getPath() + "", currentPage: ""+ old + ""]"";
					}
				}
				);
			}
		}
		currentPage = page;
	}
	public final int getPageCount(){
		int total = getRowCount();
		int page = internalGetRowsPerPage();
		int count = total / page;
		if (page * count < total){
			count++;
		}
		return count;
	}
	protected int getViewOffset(){
		return getCurrentPage() * internalGetRowsPerPage();
	}
	protected int getViewSize(){
		return Math.min(internalGetRowsPerPage(), getRowCount() - getViewOffset());
	}
	private static class CappedIteratorAdapter<T> implements Iterator<IModel<T>>{
		private final int max;
		private int index;
		private final Iterator<IModel<T>> delegate;
		public CappedIteratorAdapter(Iterator<IModel<T>> delegate, int max){
			this.delegate = delegate;
			this.max = max;
		}
		public void remove(){
			throw new UnsupportedOperationException();
		}
		public boolean hasNext(){
			return (index < max) && delegate.hasNext();
		}
		public IModel<T> next(){
			if (index >= max){
				throw new NoSuchElementException();
			}
			index++;
			return delegate.next();
		}
	}
	;
	protected void onDetach(){
		clearCachedItemCount();
		super.onDetach();
	}
	private void readObject(java.io.ObjectInputStream s) throws java.io.IOException,ClassNotFoundException{
		s.defaultReadObject();
		clearCachedItemCount();
	}
}",0,0,0,0
"public static RowIterator getIterator(final Collection<Memtable> memtables, final Collection<SSTableReader> sstables, final DecoratedKey startWith, final DecoratedKey stopAt, final QueryFilter filter, final AbstractType comparator, final ColumnFamilyStore cfs ) {
	 final List<Iterator<IColumnIterator>> iterators = new ArrayList<Iterator<IColumnIterator>>();
	 Predicate<IColumnIterator> p = new Predicate<IColumnIterator>() {
		 public boolean apply(IColumnIterator row) {
			 return startWith.compareTo(row.getKey()) <= 0 && (stopAt.isEmpty() || row.getKey().compareTo(stopAt) <= 0);
		 }
	 }
	;
	 for (Memtable memtable : memtables) {
		 iterators.add(Iterators.filter(Iterators.transform(memtable.getEntryIterator(startWith), new ConvertToColumnIterator(filter, comparator)), p));
	 }
	 for (SSTableReader sstable : sstables) {
		 final SSTableScanner scanner = sstable.getScanner(RANGE_FILE_BUFFER_SIZE, filter);
		 scanner.seekTo(startWith);
		 assert scanner instanceof Closeable;
		 iterators.add(scanner);
	 }
	 Iterator<IColumnIterator> collated = IteratorUtils.collatedIterator(COMPARE_BY_KEY, iterators);
	 final Memtable firstMemtable = memtables.iterator().next();
	 ReducingIterator<IColumnIterator, Row> reduced = new ReducingIterator<IColumnIterator, Row>(collated) {
		 private final int gcBefore = (int) (System.currentTimeMillis() / 1000) - cfs.metadata.getGcGraceSeconds();
		 private final List<IColumnIterator> colIters = new ArrayList<IColumnIterator>();
		 private DecoratedKey key;
		 public void reduce(IColumnIterator current) {
			 this.colIters.add(current);
			 this.key = current.getKey();
		 }
		 protected boolean isEqual(IColumnIterator o1, IColumnIterator o2) {
			 return COMPARE_BY_KEY.compare(o1, o2) == 0;
		 }
		 protected Row getReduced() {
			 Comparator<IColumn> colComparator = filter.filter.getColumnComparator(comparator);
			 Iterator<IColumn> colCollated = IteratorUtils.collatedIterator(colComparator, colIters);
			 ColumnFamily returnCF;
			 ColumnFamily cached = cfs.getRawCachedRow(key);
			 if (cached != null) {
				 QueryFilter keyFilter = new QueryFilter(key, filter.path, filter.filter);
				 returnCF = cfs.filterColumnFamily(cached, keyFilter, gcBefore);
			 }
			 else if (colCollated.hasNext()) {
				 returnCF = firstMemtable.getColumnFamily(key);
				 returnCF = returnCF == null ? ColumnFamily.create(firstMemtable.getTableName(), filter.getColumnFamilyName()) : returnCF.cloneMeShallow();
				 long lastDeletedAt = Long.MIN_VALUE;
				 for (IColumnIterator columns : colIters) {
					 columns.hasNext();
					 try {
						 if (columns.getColumnFamily().isMarkedForDelete()) lastDeletedAt = Math.max(lastDeletedAt, columns.getColumnFamily().getMarkedForDeleteAt());
					 }
					 catch (IOException e) {
						 throw new IOError(e);
					 }
				 }
				 returnCF.markedForDeleteAt.set(lastDeletedAt);
				 filter.collectCollatedColumns(returnCF, colCollated, gcBefore);
			 }
			 else {
				 returnCF = null;
			 }
			 Row rv = new Row(key, returnCF);
			 colIters.clear();
			 key = null;
			 return rv;
		 }
	 }
	;
	 return new RowIterator(reduced, iterators);
 }",0,0,1,0
"private void joinTokenRing(int delay) throws IOException, org.apache.cassandra.config.ConfigurationException {
	 logger_.info(""Starting up server gossip"");
	 joined = true;
	 Gossiper.instance.register(this);
	 Gossiper.instance.register(migrationManager);
	 Gossiper.instance.start(SystemTable.incrementAndGetGeneration());
	 Schema.instance.updateVersionAndAnnounce();
	 Gossiper.instance.addLocalApplicationState(ApplicationState.RPC_ADDRESS, valueFactory.rpcaddress(DatabaseDescriptor.getRpcAddress()));
	 if (null != DatabaseDescriptor.getReplaceToken()) Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.hibernate(true));
	 MessagingService.instance().listen(FBUtilities.getLocalAddress());
	 LoadBroadcaster.instance.startBroadcasting();
	 MigrationManager.passiveAnnounce(Schema.instance.getVersion());
	 Gossiper.instance.addLocalApplicationState(ApplicationState.RELEASE_VERSION, valueFactory.releaseVersion());
	 HintedHandOffManager.instance.start();
	 if (DatabaseDescriptor.isAutoBootstrap() && DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()) && !SystemTable.isBootstrapped()) logger_.info(""This node will not auto bootstrap because it is configured to be a seed node."");
	 InetAddress current = null;
	 Token<T> token;
	 if (DatabaseDescriptor.isAutoBootstrap() && !(SystemTable.isBootstrapped() || DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()) || !Schema.instance.getNonSystemTables().isEmpty())) {
		 setMode(Mode.JOINING, ""waiting for ring and schema information"", true);
		 try {
			 Thread.sleep(delay);
		 }
		 catch (InterruptedException e) {
			 throw new AssertionError(e);
		 }
		 while (!MigrationManager.isReadyForBootstrap()) {
			 setMode(Mode.JOINING, ""waiting for schema information to complete"", true);
			 try {
				 Thread.sleep(delay);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
		 }
		 setMode(Mode.JOINING, ""schema complete, ready to bootstrap"", true);
		 if (logger_.isDebugEnabled()) logger_.debug(""... got ring + schema info"");
		 if (DatabaseDescriptor.getReplaceToken() == null) {
			 if (tokenMetadata_.isMember(FBUtilities.getBroadcastAddress())) {
				 String s = ""This node is already a member of the token ring;
				 bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)"";
				 throw new UnsupportedOperationException(s);
			 }
			 setMode(Mode.JOINING, ""getting bootstrap token"", true);
			 token = BootStrapper.getBootstrapToken(tokenMetadata_, LoadBroadcaster.instance.getLoadInfo());
		 }
		 else {
			 try {
				 Thread.sleep(LoadBroadcaster.BROADCAST_INTERVAL);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
			 token = StorageService.getPartitioner().getTokenFactory().fromString(DatabaseDescriptor.getReplaceToken());
			 current = tokenMetadata_.getEndpoint(token);
			 if (null != current && Gossiper.instance.getEndpointStateForEndpoint(current).getUpdateTimestamp() > (System.currentTimeMillis() - delay)) throw new UnsupportedOperationException(""Cannnot replace a token for a Live node... "");
			 setMode(Mode.JOINING, ""Replacing a node with token: "" + token, true);
		 }
		 bootstrap(token);
		 assert !isBootstrapMode;
	 }
	 else {
		 token = SystemTable.getSavedToken();
		 if (token == null) {
			 String initialToken = DatabaseDescriptor.getInitialToken();
			 if (initialToken == null) {
				 token = getPartitioner().getRandomToken();
				 logger_.warn(""Generated random token "" + token + "". Random tokens will result in an unbalanced ring;
			 see http: }
			 else {
				 token = getPartitioner().getTokenFactory().fromString(initialToken);
				 logger_.info(""Saved token not found. Using "" + token + "" from configuration"");
			 }
		 }
		 else {
			 logger_.info(""Using saved token "" + token);
		 }
	 }
	 if (!isSurveyMode) {
		 SystemTable.setBootstrapped(true);
		 setToken(token);
		 if (current != null) Gossiper.instance.replacedEndpoint(current);
		 logger_.info(""Bootstrap/Replace/Move completed! Now serving reads."");
		 assert tokenMetadata_.sortedTokens().size() > 0;
	 }
	 else {
		 logger_.info(""Bootstrap complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService->joinRing()) to finalize ring joining."");
	 }
 }",0,0,1,0
"public class AtmosFileDownloadResult extends AtmosResult {
	 public void populateExchange(Exchange exchange) {
		 Map<String, ByteArrayOutputStream> map = (Map<String, ByteArrayOutputStream>)resultEntries;
		 if (map.size() == 1) {
			 String pathExtracted = null;
			 ByteArrayOutputStream baosExtracted = null;
			 for (Map.Entry<String, ByteArrayOutputStream> entry : map.entrySet()) {
				 pathExtracted = entry.getKey();
				 baosExtracted = entry.getValue();
			 }
			 exchange.getIn().setHeader(AtmosResultHeader.DOWNLOADED_FILE.name(), pathExtracted);
			 exchange.getIn().setBody(baosExtracted);
		 }
		 else {
			 StringBuffer pathsExtracted = new StringBuffer();
			 for (Map.Entry<String, ByteArrayOutputStream> entry : map.entrySet()) {
				 pathsExtracted.append(entry.getKey() + ""\n"");
			 }
			 exchange.getIn().setHeader(AtmosResultHeader.DOWNLOADED_FILES.name(), pathsExtracted.toString());
			 exchange.getIn().setBody(map);
		 }
	 }
}",0,0,0,0
"public List<? extends Host> discoverHosts(final AddHostCmd cmd) throws IllegalArgumentException, DiscoveryException, InvalidParameterValueException {
	 Long dcId = cmd.getZoneId();
	 final Long podId = cmd.getPodId();
	 final Long clusterId = cmd.getClusterId();
	 String clusterName = cmd.getClusterName();
	 final String url = cmd.getUrl();
	 final String username = cmd.getUsername();
	 final String password = cmd.getPassword();
	 final List<String> hostTags = cmd.getHostTags();
	 dcId = _accountMgr.checkAccessAndSpecifyAuthority(CallContext.current().getCallingAccount(), dcId);
	 if (clusterName == null && clusterId == null) {
		 clusterName = ""Standalone-"" + url;
	 }
	 if (clusterId != null) {
		 final ClusterVO cluster = _clusterDao.findById(clusterId);
		 if (cluster == null) {
			 final InvalidParameterValueException ex = new InvalidParameterValueException(""can not find cluster for specified clusterId"");
			 ex.addProxyObject(clusterId.toString(), ""clusterId"");
			 throw ex;
		 }
		 else {
			 if (cluster.getGuid() == null) {
				 final List<HostVO> hosts = listAllHostsInCluster(clusterId);
				 if (!hosts.isEmpty()) {
					 final CloudRuntimeException ex = new CloudRuntimeException(""Guid is not updated for cluster with specified cluster id;
					 need to wait for hosts in this cluster to come up"");
					 ex.addProxyObject(cluster.getUuid(), ""clusterId"");
					 throw ex;
				 }
			 }
		 }
	 }
	 return discoverHostsFull(dcId, podId, clusterId, clusterName, url, username, password, cmd.getHypervisor(), hostTags, cmd.getFullUrlParams(), false);
 }",0,0,1,0
"public class KafkaZKOptionMixin {
	private String zkconnect = ""localhost:2181"";
	private int zksessionTimeout = 6000;
	private int zkconnectionTimeout = 6000;
	private int zksyncTime = 2000;
	public String getZkconnect() {
		return zkconnect;
	}
	public void setZkconnect(String zkconnect) {
		this.zkconnect = zkconnect;
	}
	public int getZksessionTimeout() {
		return zksessionTimeout;
	}
	public void setZksessionTimeout(int zksessionTimeout) {
		this.zksessionTimeout = zksessionTimeout;
	}
	public int getZkconnectionTimeout() {
		return zkconnectionTimeout;
	}
	public void setZkconnectionTimeout(int zkconnectionTimeout) {
		this.zkconnectionTimeout = zkconnectionTimeout;
	}
	public int getZksyncTime() {
		return zksyncTime;
	}
	public void setZksyncTime(int zksyncTime) {
		this.zksyncTime = zksyncTime;
	}
}",0,0,0,0
"public abstract class AbstractDomainmodelProposalProvider extends XbaseProposalProvider {
	public void completeDomainModel_ImportSection(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeDomainModel_Elements(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completePackageDeclaration_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completePackageDeclaration_Elements(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeEntity_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeEntity_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeEntity_Features(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeProperty_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeProperty_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeOperation_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeOperation_Params(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeOperation_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void completeOperation_Body(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
	}
	public void complete_DomainModel(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
	public void complete_AbstractElement(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
	public void complete_PackageDeclaration(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
	public void complete_Entity(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
	public void complete_Feature(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
	public void complete_Property(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
	public void complete_Operation(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	}
}",0,0,0,0
"private void extractAmount(Entry entry, String line, short factor);",0,0,0,0
"public class Annotate {
	 protected static final Context.Key<Annotate> annotateKey = new Context.Key<>();
	 public static Annotate instance(Context context) {
		 Annotate instance = context.get(annotateKey);
		 if (instance == null) instance = new Annotate(context);
		 return instance;
	 }
	 private final Attr attr;
	 private final Check chk;
	 private final ConstFold cfolder;
	 private final DeferredLintHandler deferredLintHandler;
	 private final Enter enter;
	 private final Lint lint;
	 private final Log log;
	 private final Names names;
	 private final Resolve resolve;
	 private final TreeMaker make;
	 private final Symtab syms;
	 private final TypeEnvs typeEnvs;
	 private final Types types;
	 private final Attribute theUnfinishedDefaultValue;
	 private final boolean allowRepeatedAnnos;
	 private final String sourceName;
	 protected Annotate(Context context) {
		 context.put(annotateKey, this);
		 attr = Attr.instance(context);
		 chk = Check.instance(context);
		 cfolder = ConstFold.instance(context);
		 deferredLintHandler = DeferredLintHandler.instance(context);
		 enter = Enter.instance(context);
		 log = Log.instance(context);
		 lint = Lint.instance(context);
		 make = TreeMaker.instance(context);
		 names = Names.instance(context);
		 resolve = Resolve.instance(context);
		 syms = Symtab.instance(context);
		 typeEnvs = TypeEnvs.instance(context);
		 types = Types.instance(context);
		 theUnfinishedDefaultValue = new Attribute.Error(syms.errType);
		 Source source = Source.instance(context);
		 allowRepeatedAnnos = Feature.REPEATED_ANNOTATIONS.allowedInSource(source);
		 sourceName = source.name;
		 blockCount = 1;
	 }
	 private int blockCount = 0;
	 public void blockAnnotations() {
		 blockCount++;
	 }
	 public void unblockAnnotations() {
		 blockCount--;
		 if (blockCount == 0) flush();
	 }
	 public void unblockAnnotationsNoFlush() {
		 blockCount--;
	 }
	 public boolean annotationsBlocked() {
		return blockCount > 0;
	 }
	 public void enterDone() {
		 unblockAnnotations();
	 }
	 public List<TypeCompound> fromAnnotations(List<JCAnnotation> annotations) {
		 if (annotations.isEmpty()) {
			 return List.nil();
		 }
		 ListBuffer<TypeCompound> buf = new ListBuffer<>();
		 for (JCAnnotation anno : annotations) {
			 Assert.checkNonNull(anno.attribute);
			 buf.append((TypeCompound) anno.attribute);
		 }
		 return buf.toList();
	 }
	 public void normal(Runnable r) {
		 q.append(r);
	 }
	 public void validate(Runnable a) {
		 validateQ.append(a);
	 }
	 public void flush() {
		 if (annotationsBlocked()) return;
		 if (isFlushing()) return;
		 startFlushing();
		 try {
			 while (q.nonEmpty()) {
				 q.next().run();
			 }
			 while (typesQ.nonEmpty()) {
				 typesQ.next().run();
			 }
			 while (afterTypesQ.nonEmpty()) {
				 afterTypesQ.next().run();
			 }
			 while (validateQ.nonEmpty()) {
				 validateQ.next().run();
			 }
		 }
		 finally {
			 doneFlushing();
		 }
	 }
	 private ListBuffer<Runnable> q = new ListBuffer<>();
	 private ListBuffer<Runnable> validateQ = new ListBuffer<>();
	 private int flushCount = 0;
	 private boolean isFlushing() {
		 return flushCount > 0;
	 }
	 private void startFlushing() {
		 flushCount++;
	 }
	 private void doneFlushing() {
		 flushCount--;
	 }
	 ListBuffer<Runnable> typesQ = new ListBuffer<>();
	 ListBuffer<Runnable> afterTypesQ = new ListBuffer<>();
	 public void typeAnnotation(Runnable a) {
		 typesQ.append(a);
	 }
	 public void afterTypes(Runnable a) {
		 afterTypesQ.append(a);
	 }
	 public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv, Symbol s, DiagnosticPosition deferPos) {
		 if (annotations.isEmpty()) {
			 return;
		 }
		 s.resetAnnotations();
		 normal(() -> {
			 Assert.check(s.kind == PCK || s.annotationsPendingCompletion());
			 JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
			 DiagnosticPosition prevLintPos = deferPos != null ? deferredLintHandler.setPos(deferPos) : deferredLintHandler.immediate();
			 Lint prevLint = deferPos != null ? null : chk.setLint(lint);
			 try {
				 if (s.hasAnnotations() && annotations.nonEmpty()) log.error(annotations.head.pos, Errors.AlreadyAnnotated(Kinds.kindName(s), s));
				 Assert.checkNonNull(s, ""Symbol argument to actualEnterAnnotations is null"");
				 annotateNow(s, annotations, localEnv, false, false);
			 }
			 finally {
				 if (prevLint != null) chk.setLint(prevLint);
				 deferredLintHandler.setPos(prevLintPos);
				 log.useSource(prev);
			 }
		 }
		);
		 validate(() -> {
			 JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
			 try {
				 chk.validateAnnotations(annotations, s);
			 }
			 finally {
				 log.useSource(prev);
			 }
		 }
		);
	 }
	 public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m, DiagnosticPosition deferPos) {
		 normal(() -> {
			 JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
			 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);
			 try {
				 enterDefaultValue(defaultValue, localEnv, m);
			 }
			 finally {
				 deferredLintHandler.setPos(prevLintPos);
				 log.useSource(prev);
			 }
		 }
		);
		 validate(() -> {
			 JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
			 try {
				 chk.validateAnnotationTree(defaultValue);
			 }
			 finally {
				 log.useSource(prev);
			 }
		 }
		);
	 }
	 private void enterDefaultValue(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m) {
		 m.defaultValue = attributeAnnotationValue(m.type.getReturnType(), defaultValue, localEnv);
	 }
	 private <T extends Attribute.Compound> void annotateNow(Symbol toAnnotate, List<JCAnnotation> withAnnotations, Env<AttrContext> env, boolean typeAnnotations, boolean isTypeParam) {
		 Map<TypeSymbol, ListBuffer<T>> annotated = new LinkedHashMap<>();
		 Map<T, DiagnosticPosition> pos = new HashMap<>();
		 for (List<JCAnnotation> al = withAnnotations;
		 !al.isEmpty();
		 al = al.tail) {
			 JCAnnotation a = al.head;
			 T c;
			 if (typeAnnotations) {
				 T tmp = (T)attributeTypeAnnotation(a, syms.annotationType, env);
				 c = tmp;
			 }
			 else {
				 T tmp = (T)attributeAnnotation(a, syms.annotationType, env);
				 c = tmp;
			 }
			 Assert.checkNonNull(c, ""Failed to create annotation"");
			 if (a.type.tsym.isAnnotationType()) {
				 if (annotated.containsKey(a.type.tsym)) {
					 if (!allowRepeatedAnnos) {
						 log.error(DiagnosticFlag.SOURCE_LEVEL, a.pos(), Feature.REPEATED_ANNOTATIONS.error(sourceName));
					 }
					 ListBuffer<T> l = annotated.get(a.type.tsym);
					 l = l.append(c);
					 annotated.put(a.type.tsym, l);
					 pos.put(c, a.pos());
				 }
				 else {
					 annotated.put(a.type.tsym, ListBuffer.of(c));
					 pos.put(c, a.pos());
				 }
			 }
			 if (!c.type.isErroneous() && (toAnnotate.kind == MDL || toAnnotate.owner.kind != MTH) && types.isSameType(c.type, syms.deprecatedType)) {
				 toAnnotate.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
				 Attribute fr = c.member(names.forRemoval);
				 if (fr instanceof Attribute.Constant) {
					 Attribute.Constant v = (Attribute.Constant) fr;
					 if (v.type == syms.booleanType && ((Integer) v.value) != 0) {
						 toAnnotate.flags_field |= Flags.DEPRECATED_REMOVAL;
					 }
				 }
			 }
		 }
		 List<T> buf = List.nil();
		 for (ListBuffer<T> lb : annotated.values()) {
			 if (lb.size() == 1) {
				 buf = buf.prepend(lb.first());
			 }
			 else {
				 AnnotationContext<T> ctx = new AnnotationContext<>(env, annotated, pos, typeAnnotations);
				 T res = makeContainerAnnotation(lb.toList(), ctx, toAnnotate, isTypeParam);
				 if (res != null) buf = buf.prepend(res);
			 }
		 }
		 if (typeAnnotations) {
			 List<TypeCompound> attrs = (List<TypeCompound>)buf.reverse();
			 toAnnotate.appendUniqueTypeAttributes(attrs);
		 }
		 else {
			 List<Attribute.Compound> attrs = (List<Attribute.Compound>)buf.reverse();
			 toAnnotate.resetAnnotations();
			 toAnnotate.setDeclarationAttributes(attrs);
		 }
	 }
	 public Attribute.Compound attributeAnnotation(JCAnnotation tree, Type expectedAnnotationType, Env<AttrContext> env) {
		 if (tree.attribute != null && tree.type != null) return tree.attribute;
		 List<Pair<MethodSymbol, Attribute>> elems = attributeAnnotationValues(tree, expectedAnnotationType, env);
		 Attribute.Compound ac = new Attribute.Compound(tree.type, elems);
		 return tree.attribute = ac;
	 }
	 public Attribute.TypeCompound attributeTypeAnnotation(JCAnnotation a, Type expectedAnnotationType, Env<AttrContext> env) {
		 if (a.attribute == null || a.type == null || !(a.attribute instanceof Attribute.TypeCompound)) {
			 List<Pair<MethodSymbol,Attribute>> elems = attributeAnnotationValues(a, expectedAnnotationType, env);
			 Attribute.TypeCompound tc = new Attribute.TypeCompound(a.type, elems, TypeAnnotationPosition.unknown);
			 a.attribute = tc;
			 return tc;
		 }
		 else {
			 return (Attribute.TypeCompound)a.attribute;
		 }
	 }
	 private List<Pair<MethodSymbol, Attribute>> attributeAnnotationValues(JCAnnotation a, Type expected, Env<AttrContext> env) {
		 Type at = (a.annotationType.type != null ? a.annotationType.type : attr.attribType(a.annotationType, env));
		 a.type = chk.checkType(a.annotationType.pos(), at, expected);
		 boolean isError = a.type.isErroneous();
		 if (!a.type.tsym.isAnnotationType() && !isError) {
			 log.error(a.annotationType.pos(), Errors.NotAnnotationType(a.type));
			 isError = true;
		 }
		 List<JCExpression> args = a.args;
		 boolean elidedValue = false;
		 if (args.length() == 1 && !args.head.hasTag(ASSIGN)) {
			 args.head = make.at(args.head.pos). Assign(make.Ident(names.value), args.head);
			 elidedValue = true;
		 }
		 ListBuffer<Pair<MethodSymbol,Attribute>> buf = new ListBuffer<>();
		 for (List<JCExpression> tl = args;
		 tl.nonEmpty();
		 tl = tl.tail) {
			 Pair<MethodSymbol, Attribute> p = attributeAnnotationNameValuePair(tl.head, a.type, isError, env, elidedValue);
			 if (p != null && !p.fst.type.isErroneous()) buf.append(p);
		 }
		 return buf.toList();
	 }
	 private Pair<MethodSymbol, Attribute> attributeAnnotationNameValuePair(JCExpression nameValuePair, Type thisAnnotationType, boolean badAnnotation, Env<AttrContext> env, boolean elidedValue) {
		 if (!nameValuePair.hasTag(ASSIGN)) {
			 log.error(nameValuePair.pos(), Errors.AnnotationValueMustBeNameValue);
			 attributeAnnotationValue(nameValuePair.type = syms.errType, nameValuePair, env);
			 return null;
		 }
		 JCAssign assign = (JCAssign)nameValuePair;
		 if (!assign.lhs.hasTag(IDENT)) {
			 log.error(nameValuePair.pos(), Errors.AnnotationValueMustBeNameValue);
			 attributeAnnotationValue(nameValuePair.type = syms.errType, nameValuePair, env);
			 return null;
		 }
		 JCIdent left = (JCIdent)assign.lhs;
		 Symbol method = resolve.resolveQualifiedMethod(elidedValue ? assign.rhs.pos() : left.pos(), env, thisAnnotationType, left.name, List.nil(), null);
		 left.sym = method;
		 left.type = method.type;
		 if (method.owner != thisAnnotationType.tsym && !badAnnotation) log.error(left.pos(), Errors.NoAnnotationMember(left.name, thisAnnotationType));
		 Type resultType = method.type.getReturnType();
		 Attribute value = attributeAnnotationValue(resultType, assign.rhs, env);
		 nameValuePair.type = resultType;
		 return method.type.isErroneous() ? null : new Pair<>((MethodSymbol)method, value);
	 }
	 private Attribute attributeAnnotationValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
		 try {
			 expectedElementType.tsym.complete();
		 }
		 catch(CompletionFailure e) {
			 log.error(tree.pos(), Errors.CantResolve(Kinds.kindName(e.sym), e.sym.getQualifiedName(), null, null));
			 expectedElementType = syms.errType;
		 }
		 if (expectedElementType.hasTag(ARRAY)) {
			 return getAnnotationArrayValue(expectedElementType, tree, env);
		 }
		 if (tree.hasTag(NEWARRAY)) {
			 if (!expectedElementType.isErroneous()) log.error(tree.pos(), Errors.AnnotationValueNotAllowableType);
			 JCNewArray na = (JCNewArray)tree;
			 if (na.elemtype != null) {
				 log.error(na.elemtype.pos(), Errors.NewNotAllowedInAnnotation);
			 }
			 for (List<JCExpression> l = na.elems;
			 l.nonEmpty();
			 l=l.tail) {
				 attributeAnnotationValue(syms.errType, l.head, env);
			 }
			 return new Attribute.Error(syms.errType);
		 }
		 if (expectedElementType.tsym.isAnnotationType()) {
			 if (tree.hasTag(ANNOTATION)) {
				 return attributeAnnotation((JCAnnotation)tree, expectedElementType, env);
			 }
			 else {
				 log.error(tree.pos(), Errors.AnnotationValueMustBeAnnotation);
				 expectedElementType = syms.errType;
			 }
		 }
		 if (tree.hasTag(ANNOTATION)) {
			 if (!expectedElementType.isErroneous()) log.error(tree.pos(), Errors.AnnotationNotValidForType(expectedElementType));
			 attributeAnnotation((JCAnnotation)tree, syms.errType, env);
			 return new Attribute.Error(((JCAnnotation)tree).annotationType.type);
		 }
		 MemberEnter.InitTreeVisitor initTreeVisitor = new MemberEnter.InitTreeVisitor() {
			 public void visitTypeIdent(JCPrimitiveTypeTree that) {
			}
			 public void visitTypeArray(JCArrayTypeTree that) {
			}
		 }
		;
		 tree.accept(initTreeVisitor);
		 if (!initTreeVisitor.result) {
			 log.error(tree.pos(), Errors.ExpressionNotAllowableAsAnnotationValue);
			 return new Attribute.Error(syms.errType);
		 }
		 if (expectedElementType.isPrimitive() || (types.isSameType(expectedElementType, syms.stringType) && !expectedElementType.hasTag(TypeTag.ERROR))) {
			 return getAnnotationPrimitiveValue(expectedElementType, tree, env);
		 }
		 if (expectedElementType.tsym == syms.classType.tsym) {
			 return getAnnotationClassValue(expectedElementType, tree, env);
		 }
		 if (expectedElementType.hasTag(CLASS) && (expectedElementType.tsym.flags() & Flags.ENUM) != 0) {
			 return getAnnotationEnumValue(expectedElementType, tree, env);
		 }
		 if (!expectedElementType.isErroneous()) log.error(tree.pos(), Errors.AnnotationValueNotAllowableType);
		 return new Attribute.Error(attr.attribExpr(tree, env, expectedElementType));
	 }
	 private Attribute getAnnotationEnumValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
		 Type result = attr.attribTree(tree, env, annotationValueInfo(expectedElementType));
		 Symbol sym = TreeInfo.symbol(tree);
		 if (sym == null || TreeInfo.nonstaticSelect(tree) || sym.kind != VAR || (sym.flags() & Flags.ENUM) == 0) {
			 log.error(tree.pos(), Errors.EnumAnnotationMustBeEnumConstant);
			 return new Attribute.Error(result.getOriginalType());
		 }
		 VarSymbol enumerator = (VarSymbol) sym;
		 return new Attribute.Enum(expectedElementType, enumerator);
	 }
	 private Attribute getAnnotationClassValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
		 Type result = attr.attribTree(tree, env, annotationValueInfo(expectedElementType));
		 if (result.isErroneous()) {
			 if (TreeInfo.name(tree) == names._class && ((JCFieldAccess) tree).selected.type.isErroneous()) {
				 Name n = (((JCFieldAccess) tree).selected).type.tsym.flatName();
				 return new Attribute.UnresolvedClass(expectedElementType, types.createErrorType(n, syms.unknownSymbol, syms.classType));
			 }
			 else {
				 return new Attribute.Error(result.getOriginalType());
			 }
		 }
		 if (TreeInfo.name(tree) != names._class) {
			 log.error(tree.pos(), Errors.AnnotationValueMustBeClassLiteral);
			 return new Attribute.Error(syms.errType);
		 }
		 return new Attribute.Class(types, (((JCFieldAccess) tree).selected).type);
	 }
	 private Attribute getAnnotationPrimitiveValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
		 Type result = attr.attribTree(tree, env, annotationValueInfo(expectedElementType));
		 if (result.isErroneous()) return new Attribute.Error(result.getOriginalType());
		 if (result.constValue() == null) {
			 log.error(tree.pos(), Errors.AttributeValueMustBeConstant);
			 return new Attribute.Error(expectedElementType);
		 }
		 result = cfolder.coerce(result, expectedElementType);
		 return new Attribute.Constant(expectedElementType, result.constValue());
	 }
	 private Attr.ResultInfo annotationValueInfo(Type pt) {
		 return attr.unknownExprInfo.dup(pt, new AnnotationValueContext(attr.unknownExprInfo.checkContext));
	 }
	 class AnnotationValueContext extends Check.NestedCheckContext {
		 AnnotationValueContext(CheckContext enclosingContext) {
			 super(enclosingContext);
		 }
		 public boolean compatible(Type found, Type req, Warner warn) {
			 return found.hasTag(TypeTag.NONE) || super.compatible(found, req, warn);
		 }
	 }
	 private Attribute getAnnotationArrayValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
		 if (!tree.hasTag(NEWARRAY)) {
			 tree = make.at(tree.pos). NewArray(null, List.nil(), List.of(tree));
		 }
		 JCNewArray na = (JCNewArray)tree;
		 if (na.elemtype != null) {
			 log.error(na.elemtype.pos(), Errors.NewNotAllowedInAnnotation);
		 }
		 ListBuffer<Attribute> buf = new ListBuffer<>();
		 for (List<JCExpression> l = na.elems;
		 l.nonEmpty();
		 l=l.tail) {
			 buf.append(attributeAnnotationValue(types.elemtype(expectedElementType), l.head, env));
		 }
		 na.type = expectedElementType;
		 return new Attribute. Array(expectedElementType, buf.toArray(new Attribute[buf.length()]));
	 }
	 private class AnnotationContext<T extends Attribute.Compound> {
		 public final Env<AttrContext> env;
		 public final Map<Symbol.TypeSymbol, ListBuffer<T>> annotated;
		 public final Map<T, JCDiagnostic.DiagnosticPosition> pos;
		 public final boolean isTypeCompound;
		 public AnnotationContext(Env<AttrContext> env, Map<Symbol.TypeSymbol, ListBuffer<T>> annotated, Map<T, JCDiagnostic.DiagnosticPosition> pos, boolean isTypeCompound) {
			 Assert.checkNonNull(env);
			 Assert.checkNonNull(annotated);
			 Assert.checkNonNull(pos);
			 this.env = env;
			 this.annotated = annotated;
			 this.pos = pos;
			 this.isTypeCompound = isTypeCompound;
		 }
	 }
	 private <T extends Attribute.Compound> T processRepeatedAnnotations(List<T> annotations, AnnotationContext<T> ctx, Symbol on, boolean isTypeParam) {
		 T firstOccurrence = annotations.head;
		 List<Attribute> repeated = List.nil();
		 Type origAnnoType = null;
		 Type arrayOfOrigAnnoType = null;
		 Type targetContainerType = null;
		 MethodSymbol containerValueSymbol = null;
		 Assert.check(!annotations.isEmpty() && !annotations.tail.isEmpty());
		 int count = 0;
		 for (List<T> al = annotations;
		 !al.isEmpty();
		 al = al.tail) {
			 count++;
			 Assert.check(count > 1 || !al.tail.isEmpty());
			 T currentAnno = al.head;
			 origAnnoType = currentAnno.type;
			 if (arrayOfOrigAnnoType == null) {
				 arrayOfOrigAnnoType = types.makeArrayType(origAnnoType);
			 }
			 boolean reportError = count > 1;
			 Type currentContainerType = getContainingType(currentAnno, ctx.pos.get(currentAnno), reportError);
			 if (currentContainerType == null) {
				 continue;
			 }
			 Assert.check(targetContainerType == null || currentContainerType == targetContainerType);
			 targetContainerType = currentContainerType;
			 containerValueSymbol = validateContainer(targetContainerType, origAnnoType, ctx.pos.get(currentAnno));
			 if (containerValueSymbol == null) {
				 continue;
			 }
			 repeated = repeated.prepend(currentAnno);
		 }
		 if (!repeated.isEmpty() && targetContainerType == null) {
			 log.error(ctx.pos.get(annotations.head), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
			 return null;
		 }
		 if (!repeated.isEmpty()) {
			 repeated = repeated.reverse();
			 DiagnosticPosition pos = ctx.pos.get(firstOccurrence);
			 TreeMaker m = make.at(pos);
			 Pair<MethodSymbol, Attribute> p = new Pair<MethodSymbol, Attribute>(containerValueSymbol, new Attribute.Array(arrayOfOrigAnnoType, repeated));
			 if (ctx.isTypeCompound) {
				 Attribute.TypeCompound at = new Attribute.TypeCompound(targetContainerType, List.of(p), ((Attribute.TypeCompound)annotations.head).position);
				 JCAnnotation annoTree = m.TypeAnnotation(at);
				 if (!chk.validateAnnotationDeferErrors(annoTree)) log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
				 if (!chk.isTypeAnnotation(annoTree, isTypeParam)) {
					 log.error(pos, isTypeParam ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on) : Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
				 }
				 at.setSynthesized(true);
				 T x = (T) at;
				 return x;
			 }
			 else {
				 Attribute.Compound c = new Attribute.Compound(targetContainerType, List.of(p));
				 JCAnnotation annoTree = m.Annotation(c);
				 if (!chk.annotationApplicable(annoTree, on)) {
					 log.error(annoTree.pos(), Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on));
				 }
				 if (!chk.validateAnnotationDeferErrors(annoTree)) log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
				 c = attributeAnnotation(annoTree, targetContainerType, ctx.env);
				 c.setSynthesized(true);
				 T x = (T) c;
				 return x;
			 }
		 }
		 else {
			 return null;
		 }
	 }
	 private Type getContainingType(Attribute.Compound currentAnno, DiagnosticPosition pos, boolean reportError) {
		 Type origAnnoType = currentAnno.type;
		 TypeSymbol origAnnoDecl = origAnnoType.tsym;
		 Attribute.Compound ca = origAnnoDecl.getAnnotationTypeMetadata().getRepeatable();
		 if (ca == null) {
			 if (reportError) log.error(pos, Errors.DuplicateAnnotationMissingContainer(origAnnoType));
			 return null;
		 }
		 return filterSame(extractContainingType(ca, pos, origAnnoDecl), origAnnoType);
	 }
	 private Type filterSame(Type t, Type s) {
		 if (t == null || s == null) {
			 return t;
		 }
		 return types.isSameType(t, s) ? null : t;
	 }
	 private Type extractContainingType(Attribute.Compound ca, DiagnosticPosition pos, TypeSymbol annoDecl) {
		 if (ca.values.isEmpty()) {
			 log.error(pos, Errors.InvalidRepeatableAnnotation(annoDecl));
			 return null;
		 }
		 Pair<MethodSymbol,Attribute> p = ca.values.head;
		 Name name = p.fst.name;
		 if (name != names.value) {
			 log.error(pos, Errors.InvalidRepeatableAnnotation(annoDecl));
			 return null;
		 }
		 if (!(p.snd instanceof Attribute.Class)) {
			 log.error(pos, Errors.InvalidRepeatableAnnotation(annoDecl));
			 return null;
		 }
		 return ((Attribute.Class)p.snd).getValue();
	 }
	 private MethodSymbol validateContainer(Type targetContainerType, Type originalAnnoType, DiagnosticPosition pos) {
		 MethodSymbol containerValueSymbol = null;
		 boolean fatalError = false;
		 Scope scope = targetContainerType.tsym.members();
		 int nr_value_elems = 0;
		 boolean error = false;
		 for(Symbol elm : scope.getSymbolsByName(names.value)) {
			 nr_value_elems++;
			 if (nr_value_elems == 1 && elm.kind == MTH) {
				 containerValueSymbol = (MethodSymbol)elm;
			 }
			 else {
				 error = true;
			 }
		 }
		 if (error) {
			 log.error(pos, Errors.InvalidRepeatableAnnotationMultipleValues(targetContainerType, nr_value_elems));
			 return null;
		 }
		 else if (nr_value_elems == 0) {
			 log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(targetContainerType));
			 return null;
		 }
		 if (containerValueSymbol.kind != MTH) {
			 log.error(pos, Errors.InvalidRepeatableAnnotationInvalidValue(targetContainerType));
			 fatalError = true;
		 }
		 Type valueRetType = containerValueSymbol.type.getReturnType();
		 Type expectedType = types.makeArrayType(originalAnnoType);
		 if (!(types.isArray(valueRetType) && types.isSameType(expectedType, valueRetType))) {
			 log.error(pos, Errors.InvalidRepeatableAnnotationValueReturn(targetContainerType, valueRetType, expectedType));
			 fatalError = true;
		 }
		 return fatalError ? null : containerValueSymbol;
	 }
	 private <T extends Attribute.Compound> T makeContainerAnnotation(List<T> toBeReplaced, AnnotationContext<T> ctx, Symbol sym, boolean isTypeParam) {
		 T validRepeated = processRepeatedAnnotations(toBeReplaced, ctx, sym, isTypeParam);
		 if (validRepeated != null) {
			 ListBuffer<T> manualContainer = ctx.annotated.get(validRepeated.type.tsym);
			 if (manualContainer != null) {
				 log.error(ctx.pos.get(manualContainer.first()), Errors.InvalidRepeatableAnnotationRepeatedAndContainerPresent(manualContainer.first().type.tsym));
			 }
		 }
		 return validRepeated;
	 }
	 public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env, Symbol s, DiagnosticPosition deferPos, boolean isTypeParam) {
		 Assert.checkNonNull(s, ""Symbol argument to actualEnterTypeAnnotations is nul/"");
		 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
		 DiagnosticPosition prevLintPos = null;
		 if (deferPos != null) {
			 prevLintPos = deferredLintHandler.setPos(deferPos);
		 }
		 try {
			 annotateNow(s, annotations, env, true, isTypeParam);
		 }
		 finally {
			 if (prevLintPos != null) deferredLintHandler.setPos(prevLintPos);
			 log.useSource(prev);
		 }
	 }
	 public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, DiagnosticPosition deferPos) {
		 Assert.checkNonNull(sym);
		 normal(() -> tree.accept(new TypeAnnotate(env, sym, deferPos)));
	 }
	 public void annotateTypeSecondStage(JCTree tree, List<JCAnnotation> annotations, Type storeAt) {
		 typeAnnotation(() -> {
			 List<Attribute.TypeCompound> compounds = fromAnnotations(annotations);
			 Assert.check(annotations.size() == compounds.size());
			 storeAt.getMetadataOfKind(Kind.ANNOTATIONS).combine(new TypeMetadata.Annotations(compounds));
		 }
		);
	 }
	 public void annotateTypeParameterSecondStage(JCTree tree, List<JCAnnotation> annotations) {
		 typeAnnotation(() -> {
			 List<Attribute.TypeCompound> compounds = fromAnnotations(annotations);
			 Assert.check(annotations.size() == compounds.size());
		 }
		);
	 }
	 private class TypeAnnotate extends TreeScanner {
		 private final Env<AttrContext> env;
		 private final Symbol sym;
		 private DiagnosticPosition deferPos;
		 public TypeAnnotate(Env<AttrContext> env, Symbol sym, DiagnosticPosition deferPos) {
			 this.env = env;
			 this.sym = sym;
			 this.deferPos = deferPos;
		 }
		 public void visitAnnotatedType(JCAnnotatedType tree) {
			 enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);
			 scan(tree.underlyingType);
		 }
		 public void visitTypeParameter(JCTypeParameter tree) {
			 enterTypeAnnotations(tree.annotations, env, sym, deferPos, true);
			 scan(tree.bounds);
		 }
		 public void visitNewArray(JCNewArray tree) {
			 enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);
			 for (List<JCAnnotation> dimAnnos : tree.dimAnnotations) enterTypeAnnotations(dimAnnos, env, sym, deferPos, false);
			 scan(tree.elemtype);
			 scan(tree.elems);
		 }
		 public void visitMethodDef(JCMethodDecl tree) {
			 scan(tree.mods);
			 scan(tree.restype);
			 scan(tree.typarams);
			 scan(tree.recvparam);
			 scan(tree.params);
			 scan(tree.thrown);
			 scan(tree.defaultValue);
		 }
		 public void visitVarDef(JCVariableDecl tree) {
			 DiagnosticPosition prevPos = deferPos;
			 deferPos = tree.pos();
			 try {
				 if (sym != null && sym.kind == VAR) {
					 scan(tree.mods);
					 scan(tree.vartype);
				 }
				 scan(tree.init);
			 }
			 finally {
				 deferPos = prevPos;
			 }
		 }
		 public void visitClassDef(JCClassDecl tree) {
		 }
		 public void visitNewClass(JCNewClass tree) {
			 scan(tree.encl);
			 scan(tree.typeargs);
			 if (tree.def == null) {
				 scan(tree.clazz);
			 }
			 scan(tree.args);
		 }
	 }
	 private AnnotationTypeCompleter theSourceCompleter = new AnnotationTypeCompleter() {
		 public void complete(ClassSymbol sym) throws CompletionFailure {
			 Env<AttrContext> context = typeEnvs.get(sym);
			 Annotate.this.attributeAnnotationType(context);
		 }
	 }
	;
	 public AnnotationTypeCompleter annotationTypeSourceCompleter() {
		 return theSourceCompleter;
	 }
	 private void attributeAnnotationType(Env<AttrContext> env) {
		 Assert.check(((JCClassDecl)env.tree).sym.isAnnotationType(), ""Trying to annotation type complete a non-annotation type"");
		 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
		 try {
			 JCClassDecl tree = (JCClassDecl)env.tree;
			 AnnotationTypeVisitor v = new AnnotationTypeVisitor(attr, chk, syms, typeEnvs);
			 v.scanAnnotationType(tree);
			 tree.sym.getAnnotationTypeMetadata().setRepeatable(v.repeatable);
			 tree.sym.getAnnotationTypeMetadata().setTarget(v.target);
		 }
		 finally {
			 log.useSource(prev);
		 }
	 }
	 public Attribute unfinishedDefaultValue() {
		 return theUnfinishedDefaultValue;
	 }
	 public static interface AnnotationTypeCompleter {
		 void complete(ClassSymbol sym) throws CompletionFailure;
	 }
	 public class AnnotationTypeVisitor extends TreeScanner {
		 private Env<AttrContext> env;
		 private final Attr attr;
		 private final Check check;
		 private final Symtab tab;
		 private final TypeEnvs typeEnvs;
		 private Compound target;
		 private Compound repeatable;
		 public AnnotationTypeVisitor(Attr attr, Check check, Symtab tab, TypeEnvs typeEnvs) {
			 this.attr = attr;
			 this.check = check;
			 this.tab = tab;
			 this.typeEnvs = typeEnvs;
		 }
		 public Compound getRepeatable() {
			 return repeatable;
		 }
		 public Compound getTarget() {
			 return target;
		 }
		 public void scanAnnotationType(JCClassDecl decl) {
			 visitClassDef(decl);
		 }
		 public void visitClassDef(JCClassDecl tree) {
			 Env<AttrContext> prevEnv = env;
			 env = typeEnvs.get(tree.sym);
			 try {
				 scan(tree.mods);
			 }
			 finally {
				 env = prevEnv;
			 }
		 }
		 public void visitAnnotation(JCAnnotation tree) {
			 Type t = tree.annotationType.type;
			 if (t == null) {
				 t = attr.attribType(tree.annotationType, env);
				 tree.annotationType.type = t = check.checkType(tree.annotationType.pos(), t, tab.annotationType);
			 }
			 if (t == tab.annotationTargetType) {
				 target = Annotate.this.attributeAnnotation(tree, tab.annotationTargetType, env);
			 }
			 else if (t == tab.repeatableType) {
				 repeatable = Annotate.this.attributeAnnotation(tree, tab.repeatableType, env);
			 }
		 }
	 }
	 public static class AnnotationTypeMetadata {
		 final ClassSymbol metaDataFor;
		 private Compound target;
		 private Compound repeatable;
		 private AnnotationTypeCompleter annotationTypeCompleter;
		 public AnnotationTypeMetadata(ClassSymbol metaDataFor, AnnotationTypeCompleter annotationTypeCompleter) {
			 this.metaDataFor = metaDataFor;
			 this.annotationTypeCompleter = annotationTypeCompleter;
		 }
		 private void init() {
			 while (!metaDataFor.isCompleted()) metaDataFor.complete();
			 if (annotationTypeCompleter != null) {
				 AnnotationTypeCompleter c = annotationTypeCompleter;
				 annotationTypeCompleter = null;
				 c.complete(metaDataFor);
			 }
		 }
		 public void complete() {
			 init();
		 }
		 public Compound getRepeatable() {
			 init();
			 return repeatable;
		 }
		 public void setRepeatable(Compound repeatable) {
			 Assert.checkNull(this.repeatable);
			 this.repeatable = repeatable;
		 }
		 public Compound getTarget() {
			 init();
			 return target;
		 }
		 public void setTarget(Compound target) {
			 Assert.checkNull(this.target);
			 this.target = target;
		 }
		 public Set<MethodSymbol> getAnnotationElements() {
			 init();
			 Set<MethodSymbol> members = new LinkedHashSet<>();
			 WriteableScope s = metaDataFor.members();
			 Iterable<Symbol> ss = s.getSymbols(NON_RECURSIVE);
			 for (Symbol sym : ss) if (sym.kind == MTH && sym.name != sym.name.table.names.clinit && (sym.flags() & SYNTHETIC) == 0) members.add((MethodSymbol)sym);
			 return members;
		 }
		 public Set<MethodSymbol> getAnnotationElementsWithDefault() {
			 init();
			 Set<MethodSymbol> members = getAnnotationElements();
			 Set<MethodSymbol> res = new LinkedHashSet<>();
			 for (MethodSymbol m : members) if (m.defaultValue != null) res.add(m);
			 return res;
		 }
		 public String toString() {
			 return ""Annotation type for: "" + metaDataFor;
		 }
		 public boolean isMetadataForAnnotationType() {
			 return true;
		 }
		 public static AnnotationTypeMetadata notAnAnnotationType() {
			 return NOT_AN_ANNOTATION_TYPE;
		 }
		 private static final AnnotationTypeMetadata NOT_AN_ANNOTATION_TYPE = new AnnotationTypeMetadata(null, null) {
			 public void complete() {
			 }
			 public String toString() {
				 return ""Not an annotation type"";
			 }
			 public Set<MethodSymbol> getAnnotationElements() {
				 return new LinkedHashSet<>(0);
			 }
			 public Set<MethodSymbol> getAnnotationElementsWithDefault() {
				 return new LinkedHashSet<>(0);
			 }
			 public boolean isMetadataForAnnotationType() {
				 return false;
			 }
			 public Compound getTarget() {
				 return null;
			 }
			 public Compound getRepeatable() {
				 return null;
			 }
		 }
		;
	 }
	 public void newRound() {
		 blockCount = 1;
	 }
}",1,0,0,0
"void sendMail_forMember(int memberID, String forumBase, Timestamp lastSent) throws DatabaseException, MessagingException, BadInputException, ObjectNotFoundException, TemplateException, IOException {
	 MemberBean receiver = null;
	 try {
		 receiver = DAOFactory.getMemberDAO().getMember(memberID);
	 }
	 catch (ObjectNotFoundException e) {
		 String message = ""Cannot get member with id = "" + memberID;
		 log.error(message, e);
		 MailMessageStruct mailMessageStruct = new MailMessageStruct();
		 mailMessageStruct.setFrom(MVNForumConfig.getWebMasterEmail());
		 mailMessageStruct.setTo(MVNForumConfig.getWebMasterEmail());
		 mailMessageStruct.setSubject(""Warning of LDAP deleted members"");
		 mailMessageStruct.setMessage(message);
		 MailUtil.sendMail(mailMessageStruct);
		 return;
	 }
	 if ( (receiver.getMemberEmail() == null) || (receiver.getMemberEmail().length() == 0) ) {
		 String message = ""Cannot get email from member with id = "" + receiver.getMemberID() + "" and login name = "" + receiver.getMemberName() + "" in WatchWebHandler.sendMail_forMember()"";
		 log.warn(message);
		 MailMessageStruct mailMessageStruct = new MailMessageStruct();
		 mailMessageStruct.setFrom(MVNForumConfig.getWebMasterEmail());
		 mailMessageStruct.setTo(MVNForumConfig.getWebMasterEmail());
		 mailMessageStruct.setSubject(""Warning of LDAP members missing email"");
		 mailMessageStruct.setMessage(message);
		 MailUtil.sendMail(mailMessageStruct);
		 return;
	 }
	 MVNForumPermission permission = null;
	 try {
		 permission = MVNForumPermissionFactory.getAuthenticatedPermission(receiver);
	 }
	 catch (AssertionError e) {
		 log.error(""Cannot create watch mail for Guest with id = "" + memberID, e);
		 return;
	 }
	 if (permission.isActivated() == false) {
		 return;
	 }
	 Collection watchBeans = DAOFactory.getWatchDAO().getWatches_forMember(memberID);
	 Timestamp now = DateUtil.getCurrentGMTTimestamp();
	 watchBeans = WatchUtil.optimize(watchBeans);
	 WatchMail watchMailDigest = new WatchMail(receiver, permission, forumBase, lastSent, now);
	 SingleWatchMail watchMailSingle = new SingleWatchMail(receiver, permission, forumBase, lastSent, now);
	 for (Iterator watchIterator = watchBeans.iterator();
	 watchIterator.hasNext();
	 ) {
		 WatchBean watchBean = (WatchBean)watchIterator.next();
		 boolean isDigest = false;
		 switch (watchBean.getWatchType()) {
			 case WatchBean.WATCH_TYPE_DIGEST: isDigest = true;
			 break;
			 case WatchBean.WATCH_TYPE_NONDIGEST: isDigest = false;
			 break;
			 case WatchBean.WATCH_TYPE_DEFAULT: switch (MVNForumConfig.getDefaultWatchType()) {
				 case WatchBean.WATCH_TYPE_DIGEST: isDigest = true;
				 break;
				 case WatchBean.WATCH_TYPE_NONDIGEST: isDigest = false;
				 break;
				 default: isDigest = true;
				 break;
			 }
			 break;
			 default: isDigest = true;
			 break;
		 }
		 if (isDigest) {
			 watchMailDigest.appendWatch(watchBean);
		 }
		 else {
			 watchMailSingle.appendWatch(watchBean);
		 }
	 }
	 if ((watchMailDigest.haveAtLeastOneNewThread() == false) && (watchMailSingle.haveAtLeastOneNewThread() == false)) {
		 log.debug(""No new thread in watch mail for MemberID = "" + memberID);
		 return;
	 }
	 if (watchMailDigest.haveAtLeastOneNewThread()) {
		 log.debug(""About to send digest watch mail to member = "" + memberID + "" with email = "" + receiver.getMemberEmail());
		 String from = MVNForumConfig.getWatchEmail();
		 String to = receiver.getMemberEmail();
		 String subject = watchMailDigest.getWatchMailSubject();
		 String content = watchMailDigest.getWatchMailBody();
		 try {
			 MailMessageStruct mailMessageStruct = new MailMessageStruct();
			 mailMessageStruct.setFrom(from);
			 mailMessageStruct.setTo(to);
			 mailMessageStruct.setSubject(subject);
			 mailMessageStruct.setMessage(content);
			 mailMessageStruct.setSendAsHtml(MVNForumConfig.getSendWatchMailAsHTML());
			 MailUtil.sendMail(mailMessageStruct);
		 }
		 catch (UnsupportedEncodingException e) {
			 log.error(""Cannot support encoding"", e);
		 }
	 }
	 if (watchMailSingle.haveAtLeastOneNewThread()) {
		 log.debug(""About to send single watch mail to member = "" + memberID + "" with email = "" + receiver.getMemberEmail());
		 Collection mailMessageStructs = watchMailSingle.getMailMessageStructs(MVNForumConfig.getWatchEmail(), receiver.getMemberEmail());
		 MailUtil.sendMail(mailMessageStructs);
	 }
	 DAOFactory.getWatchDAO().updateLastSentDate_forMember(memberID, now);
 }",0,0,1,0
"INewBrowserWindowListener.class);
void onNewBrowserWindow();
}",0,0,0,0
"public List<CounterColumn> thriftifyCounterSubColumns(Collection<IColumn> columns) {
	 if (columns == null || columns.isEmpty()) {
		 return EMPTY_COUNTER_SUBCOLUMNS;
	 }
	 ArrayList<CounterColumn> thriftColumns = new ArrayList<CounterColumn>(columns.size());
	 for (IColumn column : columns) {
		 if (column.isMarkedForDelete()) {
			 continue;
		 }
		 assert column instanceof org.apache.cassandra.db.CounterColumn;
		 CounterColumn thrift_column = new CounterColumn(column.name(), CounterContext.instance().total(column.value()));
		 thriftColumns.add(thrift_column);
	 }
	 return thriftColumns;
 }",0,0,0,0
"public class PasswordPolicyException extends PolicyException {
	 private static final long serialVersionUID = 8072104484395278469L;
	 public PasswordPolicyException() {
		 super();
	 }
	 public PasswordPolicyException(final String message) {
		 super(message);
	 }
}",0,0,0,0
"public class AndRule implements Rule{
	List<Rule> rules;
	public AndRule(Rule rule1, Rule rule2, Rule ... rules){
		this.rules = new LinkedList<Rule>(Arrays.asList(rules));
		this.rules.add(rule1);
		this.rules.add(rule2);
	}
	public boolean ruleMatches(Product product) throws IllegalArgumentException{
		boolean matches = true;
		for(Rule rule : rules){
			if(! rule.ruleMatches(product)){
				matches = false;
			}
		}
		return matches;
	}
}",0,0,0,0
"public abstract class DocIdSetIterator {
	 public static final DocIdSetIterator empty() {
		 return new DocIdSetIterator() {
			 boolean exhausted = false;
			 public int advance(int target) {
				 assert !exhausted;
				 assert target >= 0;
				 exhausted = true;
				 return NO_MORE_DOCS;
			 }
			 public int docID() {
				 return exhausted ? NO_MORE_DOCS : -1;
			 }
			 public int nextDoc() {
				 assert !exhausted;
				 exhausted = true;
				 return NO_MORE_DOCS;
			 }
			 public long cost() {
				 return 0;
			 }
		 }
		;
	 }
	 public static final DocIdSetIterator all(int maxDoc) {
		 return new DocIdSetIterator() {
			 int doc = -1;
			 public int docID() {
				 return doc;
			 }
			 public int nextDoc() throws IOException {
				 return advance(doc + 1);
			 }
			 public int advance(int target) throws IOException {
				 doc = target;
				 if (doc >= maxDoc) {
					 doc = NO_MORE_DOCS;
				 }
				 return doc;
			 }
			 public long cost() {
				 return maxDoc;
			 }
		 }
		;
	 }
	 public static final DocIdSetIterator range(int minDoc, int maxDoc) {
		 if (minDoc >= maxDoc) {
			 throw new IllegalArgumentException(""minDoc must be < maxDoc but got minDoc="" + minDoc + "" maxDoc="" + maxDoc);
		 }
		 if (minDoc < 0) {
			 throw new IllegalArgumentException(""minDoc must be >= 0 but got minDoc="" + minDoc);
		 }
		 return new DocIdSetIterator() {
			 private int doc = -1;
			 public int docID() {
				 return doc;
			 }
			 public int nextDoc() throws IOException {
				 return advance(doc + 1);
			 }
			 public int advance(int target) throws IOException {
				 if (target < minDoc) {
					 doc = minDoc;
				 }
				 else if (target >= maxDoc) {
					 doc = NO_MORE_DOCS;
				 }
				 else {
					 doc = target;
				 }
				 return doc;
			 }
			 public long cost() {
				 return maxDoc - minDoc;
			 }
		 }
		;
	 }
	 public static final int NO_MORE_DOCS = Integer.MAX_VALUE;
	 public abstract int docID();
	 public abstract int nextDoc() throws IOException;
	 public abstract int advance(int target) throws IOException;
	 protected final int slowAdvance(int target) throws IOException {
		 assert docID() < target;
		 int doc;
		 do {
			 doc = nextDoc();
		 }
		 while (doc < target);
		 return doc;
	 }
	 public abstract long cost();
}",1,0,0,0
"public class Pvcs extends org.apache.tools.ant.Task {
	 private static final int POS_1 = 1;
	 private static final int POS_2 = 2;
	 private static final int POS_3 = 3;
	 private String pvcsbin;
	 private String repository;
	 private String pvcsProject;
	 private Vector pvcsProjects;
	 private String workspace;
	 private String force;
	 private String promotiongroup;
	 private String label;
	 private String revision;
	 private boolean ignorerc;
	 private boolean updateOnly;
	 private String filenameFormat;
	 private String lineStart;
	 private String userId;
	 private String config;
	 private static final String PCLI_EXE = ""pcli"";
	 private static final String GET_EXE = ""get"";
	 protected int runCmd(Commandline cmd, ExecuteStreamHandler out) {
		 try {
			 Project aProj = getProject();
			 Execute exe = new Execute(out);
			 exe.setAntRun(aProj);
			 exe.setWorkingDirectory(aProj.getBaseDir());
			 exe.setCommandline(cmd.getCommandline());
			 return exe.execute();
		 }
		 catch (java.io.IOException e) {
			 String msg = ""Failed executing: "" + cmd.toString() + "". Exception: "" + e.getMessage();
			 throw new BuildException(msg, getLocation());
		 }
	 }
	 private String getExecutable(String exe) {
		 StringBuffer correctedExe = new StringBuffer();
		 if (getPvcsbin() != null) {
			 if (pvcsbin.endsWith(File.separator)) {
				 correctedExe.append(pvcsbin);
			 }
			 else {
				 correctedExe.append(pvcsbin).append(File.separator);
			 }
		 }
		 return correctedExe.append(exe).toString();
	 }
	 public void execute() throws org.apache.tools.ant.BuildException {
		 int result = 0;
		 if (repository == null || repository.trim().equals("""")) {
			 throw new BuildException(""Required argument repository not specified"");
		 }
		 Commandline commandLine = new Commandline();
		 commandLine.setExecutable(getExecutable(PCLI_EXE));
		 commandLine.createArgument().setValue(""lvf"");
		 commandLine.createArgument().setValue(""-z"");
		 commandLine.createArgument().setValue(""-aw"");
		 if (getWorkspace() != null) {
			 commandLine.createArgument().setValue(""-sp"" + getWorkspace());
		 }
		 commandLine.createArgument().setValue(""-pr"" + getRepository());
		 String uid = getUserId();
		 if (uid != null) {
			 commandLine.createArgument().setValue(""-id"" + uid);
		 }
		 if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
			 pvcsProject = ""/"";
		 }
		 if (getPvcsproject() != null) {
			 commandLine.createArgument().setValue(getPvcsproject());
		 }
		 if (!getPvcsprojects().isEmpty()) {
			 Enumeration e = getPvcsprojects().elements();
			 while (e.hasMoreElements()) {
				 String projectName = ((PvcsProject) e.nextElement()).getName();
				 if (projectName == null || (projectName.trim()).equals("""")) {
					 throw new BuildException(""name is a required attribute "" + ""of pvcsproject"");
				 }
				 commandLine.createArgument().setValue(projectName);
			 }
		 }
		 File tmp = null;
		 File tmp2 = null;
		 try {
			 Random rand = new Random(System.currentTimeMillis());
			 tmp = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
			 FileOutputStream fos = new FileOutputStream(tmp);
			 tmp2 = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
			 log(commandLine.describeCommand(), Project.MSG_VERBOSE);
			 try {
				 result = runCmd(commandLine, new PumpStreamHandler(fos, new LogOutputStream(this, Project.MSG_WARN)));
			 }
			 finally {
				 FileUtils.close(fos);
			 }
			 if (Execute.isFailure(result) && !ignorerc) {
				 String msg = ""Failed executing: "" + commandLine.toString();
				 throw new BuildException(msg, getLocation());
			 }
			 if (!tmp.exists()) {
				 throw new BuildException(""Communication between ant and pvcs "" + ""failed. No output generated from executing PVCS "" + ""commandline interface \""pcli\"" and \""get\"""");
			 }
			 log(""Creating folders"", Project.MSG_INFO);
			 createFolders(tmp);
			 massagePCLI(tmp, tmp2);
			 commandLine.clearArgs();
			 commandLine.setExecutable(getExecutable(GET_EXE));
			 if (getConfig() != null && getConfig().length() > 0) {
				 commandLine.createArgument().setValue(""-c"" + getConfig());
			 }
			 if (getForce() != null && getForce().equals(""yes"")) {
				 commandLine.createArgument().setValue(""-Y"");
			 }
			 else {
				 commandLine.createArgument().setValue(""-N"");
			 }
			 if (getPromotiongroup() != null) {
				 commandLine.createArgument().setValue(""-G"" + getPromotiongroup());
			 }
			 else {
				 if (getLabel() != null) {
					 commandLine.createArgument().setValue(""-v"" + getLabel());
				 }
				 else {
					 if (getRevision() != null) {
						 commandLine.createArgument().setValue(""-r"" + getRevision());
					 }
				 }
			 }
			 if (updateOnly) {
				 commandLine.createArgument().setValue(""-U"");
			 }
			 commandLine.createArgument().setValue(""@"" + tmp2.getAbsolutePath());
			 log(""Getting files"", Project.MSG_INFO);
			 log(""Executing "" + commandLine.toString(), Project.MSG_VERBOSE);
			 result = runCmd(commandLine, new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
			 if (result != 0 && !ignorerc) {
				 String msg = ""Failed executing: "" + commandLine.toString() + "". Return code was "" + result;
				 throw new BuildException(msg, getLocation());
			 }
		 }
		 catch (FileNotFoundException e) {
			 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
			 throw new BuildException(msg, getLocation());
		 }
		 catch (IOException e) {
			 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
			 throw new BuildException(msg, getLocation());
		 }
		 catch (ParseException e) {
			 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
			 throw new BuildException(msg, getLocation());
		 }
		 finally {
			 if (tmp != null) {
				 tmp.delete();
			 }
			 if (tmp2 != null) {
				 tmp2.delete();
			 }
		 }
	 }
	 private void createFolders(File file) throws IOException, ParseException {
		 BufferedReader in = null;
		 try {
			 in = new BufferedReader(new FileReader(file));
			 MessageFormat mf = new MessageFormat(getFilenameFormat());
			 String line = in.readLine();
			 while (line != null) {
				 log(""Considering \"""" + line + ""\"""", Project.MSG_VERBOSE);
				 if (line.startsWith(""\""\\"") || line.startsWith(""\""/"") || (line.length() > POS_3 && line.startsWith(""\"""") && Character.isLetter(line.charAt(POS_1)) && String.valueOf(line.charAt(POS_2)).equals("":"") && String.valueOf(line.charAt(POS_3)).equals(""\\""))) {
					 Object[] objs = mf.parse(line);
					 String f = (String) objs[1];
					 int index = f.lastIndexOf(File.separator);
					 if (index > -1) {
						 File dir = new File(f.substring(0, index));
						 if (!dir.exists()) {
							 log(""Creating "" + dir.getAbsolutePath(), Project.MSG_VERBOSE);
							 if (dir.mkdirs()) {
								 log(""Created "" + dir.getAbsolutePath(), Project.MSG_INFO);
							 }
							 else {
								 log(""Failed to create "" + dir.getAbsolutePath(), Project.MSG_INFO);
							 }
						 }
						 else {
							 log(dir.getAbsolutePath() + "" exists. Skipping"", Project.MSG_VERBOSE);
						 }
					 }
					 else {
						 log(""File separator problem with "" + line, Project.MSG_WARN);
					 }
				 }
				 else {
					 log(""Skipped \"""" + line + ""\"""", Project.MSG_VERBOSE);
				 }
				 line = in.readLine();
			 }
		 }
		 finally {
			 FileUtils.close(in);
		 }
	 }
	 private void massagePCLI(File in, File out) throws IOException {
		 BufferedReader inReader = null;
		 BufferedWriter outWriter = null;
		 try {
			 inReader = new BufferedReader(new FileReader(in));
			 outWriter = new BufferedWriter(new FileWriter(out));
			 String s = null;
			 while ((s = inReader.readLine()) != null) {
				 String sNormal = s.replace('\\', '/');
				 outWriter.write(sNormal);
				 outWriter.newLine();
			 }
		 }
		 finally {
			 FileUtils.close(inReader);
			 FileUtils.close(outWriter);
		 }
	 }
	 public String getRepository() {
		 return repository;
	 }
	 public String getFilenameFormat() {
		 return filenameFormat;
	 }
	 public void setFilenameFormat(String f) {
		 filenameFormat = f;
	 }
	 public String getLineStart() {
		 return lineStart;
	 }
	 public void setLineStart(String l) {
		 lineStart = l;
	 }
	 public void setRepository(String repo) {
		 repository = repo;
	 }
	 public String getPvcsproject() {
		 return pvcsProject;
	 }
	 public void setPvcsproject(String prj) {
		 pvcsProject = prj;
	 }
	 public Vector getPvcsprojects() {
		 return pvcsProjects;
	 }
	 public String getWorkspace() {
		 return workspace;
	 }
	 public void setWorkspace(String ws) {
		 workspace = ws;
	 }
	 public String getPvcsbin() {
		 return pvcsbin;
	 }
	 public void setPvcsbin(String bin) {
		 pvcsbin = bin;
	 }
	 public String getForce() {
		 return force;
	 }
	 public void setForce(String f) {
		 if (f != null && f.equalsIgnoreCase(""yes"")) {
			 force = ""yes"";
		 }
		 else {
			 force = ""no"";
		 }
	 }
	 public String getPromotiongroup() {
		 return promotiongroup;
	 }
	 public void setPromotiongroup(String w) {
		 promotiongroup = w;
	 }
	 public String getLabel() {
		 return label;
	 }
	 public void setLabel(String l) {
		 label = l;
	 }
	 public String getRevision() {
		 return revision;
	 }
	 public void setRevision(String r) {
		 revision = r;
	 }
	 public boolean getIgnoreReturnCode() {
		 return ignorerc;
	 }
	 public void setIgnoreReturnCode(boolean b) {
		 ignorerc = b;
	 }
	 public void addPvcsproject(PvcsProject p) {
		 pvcsProjects.addElement(p);
	 }
	 public boolean getUpdateOnly() {
		 return updateOnly;
	 }
	 public void setUpdateOnly(boolean l) {
		 updateOnly = l;
	 }
	 public String getConfig() {
		 return config;
	 }
	 public void setConfig(File f) {
		 config = f.toString();
	 }
	 public String getUserId() {
		 return userId;
	 }
	 public void setUserId(String u) {
		 userId = u;
	 }
	 public Pvcs() {
		 super();
		 pvcsProject = null;
		 pvcsProjects = new Vector();
		 workspace = null;
		 repository = null;
		 pvcsbin = null;
		 force = null;
		 promotiongroup = null;
		 label = null;
		 ignorerc = false;
		 updateOnly = false;
		 lineStart = ""\""P:"";
		 filenameFormat = ""{
		0}
		-arc({
		1}
		)"";
	 }
}",0,0,0,0
public Color getBackcolor();,0,0,0,0
"private JPEGImageMetadataFormat() {
	 super(JPEG.nativeImageMetadataFormatName, CHILD_POLICY_ALL);
	 addElement(""JPEGvariety"", JPEG.nativeImageMetadataFormatName, CHILD_POLICY_CHOICE);
	 addElement(""markerSequence"", JPEG.nativeImageMetadataFormatName, CHILD_POLICY_SEQUENCE);
	 addElement(""app0JFIF"", ""JPEGvariety"", CHILD_POLICY_SOME);
	 addStreamElements(""markerSequence"");
	 addElement(""app14Adobe"", ""markerSequence"", CHILD_POLICY_EMPTY);
	 addElement(""sof"", ""markerSequence"", 1, 4);
	 addElement(""sos"", ""markerSequence"", 1, 4);
	 addElement(""JFXX"", ""app0JFIF"", 1, Integer.MAX_VALUE);
	 addElement(""app0JFXX"", ""JFXX"", CHILD_POLICY_CHOICE);
	 addElement(""app2ICC"", ""app0JFIF"", CHILD_POLICY_EMPTY);
	 addAttribute(""app0JFIF"", ""majorVersion"", DATATYPE_INTEGER, false, ""1"", ""0"", ""255"", true, true);
	 addAttribute(""app0JFIF"", ""minorVersion"", DATATYPE_INTEGER, false, ""2"", ""0"", ""255"", true, true);
	 List<String> resUnits = new ArrayList<>();
	 resUnits.add(""0"");
	 resUnits.add(""1"");
	 resUnits.add(""2"");
	 addAttribute(""app0JFIF"", ""resUnits"", DATATYPE_INTEGER, false, ""0"", resUnits);
	 addAttribute(""app0JFIF"", ""Xdensity"", DATATYPE_INTEGER, false, ""1"", ""1"", ""65535"", true, true);
	 addAttribute(""app0JFIF"", ""Ydensity"", DATATYPE_INTEGER, false, ""1"", ""1"", ""65535"", true, true);
	 addAttribute(""app0JFIF"", ""thumbWidth"", DATATYPE_INTEGER, false, ""0"", ""0"", ""255"", true, true);
	 addAttribute(""app0JFIF"", ""thumbHeight"", DATATYPE_INTEGER, false, ""0"", ""0"", ""255"", true, true);
	 addElement(""JFIFthumbJPEG"", ""app0JFXX"", CHILD_POLICY_SOME);
	 addElement(""JFIFthumbPalette"", ""app0JFXX"", CHILD_POLICY_EMPTY);
	 addElement(""JFIFthumbRGB"", ""app0JFXX"", CHILD_POLICY_EMPTY);
	 List<String> codes = new ArrayList<>();
	 codes.add(""16"");
	 codes.add(""17"");
	 codes.add(""19"");
	 addAttribute(""app0JFXX"", ""extensionCode"", DATATYPE_INTEGER, false, null, codes);
	 addChildElement(""markerSequence"", ""JFIFthumbJPEG"");
	 addAttribute(""JFIFthumbPalette"", ""thumbWidth"", DATATYPE_INTEGER, false, null, ""0"", ""255"", true, true);
	 addAttribute(""JFIFthumbPalette"", ""thumbHeight"", DATATYPE_INTEGER, false, null, ""0"", ""255"", true, true);
	 addAttribute(""JFIFthumbRGB"", ""thumbWidth"", DATATYPE_INTEGER, false, null, ""0"", ""255"", true, true);
	 addAttribute(""JFIFthumbRGB"", ""thumbHeight"", DATATYPE_INTEGER, false, null, ""0"", ""255"", true, true);
	 addObjectValue(""app2ICC"", ICC_Profile.class, false, null);
	 addAttribute(""app14Adobe"", ""version"", DATATYPE_INTEGER, false, ""100"", ""100"", ""255"", true, true);
	 addAttribute(""app14Adobe"", ""flags0"", DATATYPE_INTEGER, false, ""0"", ""0"", ""65535"", true, true);
	 addAttribute(""app14Adobe"", ""flags1"", DATATYPE_INTEGER, false, ""0"", ""0"", ""65535"", true, true);
	 List<String> transforms = new ArrayList<>();
	 transforms.add(""0"");
	 transforms.add(""1"");
	 transforms.add(""2"");
	 addAttribute(""app14Adobe"", ""transform"", DATATYPE_INTEGER, true, null, transforms);
	 addElement(""componentSpec"", ""sof"", CHILD_POLICY_EMPTY);
	 List<String> procs = new ArrayList<>();
	 procs.add(""0"");
	 procs.add(""1"");
	 procs.add(""2"");
	 addAttribute(""sof"", ""process"", DATATYPE_INTEGER, false, null, procs);
	 addAttribute(""sof"", ""samplePrecision"", DATATYPE_INTEGER, false, ""8"");
	 addAttribute(""sof"", ""numLines"", DATATYPE_INTEGER, false, null, ""0"", ""65535"", true, true);
	 addAttribute(""sof"", ""samplesPerLine"", DATATYPE_INTEGER, false, null, ""0"", ""65535"", true, true);
	 List<String> comps = new ArrayList<>();
	 comps.add(""1"");
	 comps.add(""2"");
	 comps.add(""3"");
	 comps.add(""4"");
	 addAttribute(""sof"", ""numFrameComponents"", DATATYPE_INTEGER, false, null, comps);
	 addAttribute(""componentSpec"", ""componentId"", DATATYPE_INTEGER, true, null, ""0"", ""255"", true, true);
	 addAttribute(""componentSpec"", ""HsamplingFactor"", DATATYPE_INTEGER, true, null, ""1"", ""255"", true, true);
	 addAttribute(""componentSpec"", ""VsamplingFactor"", DATATYPE_INTEGER, true, null, ""1"", ""255"", true, true);
	 List<String> tabids = new ArrayList<>();
	 tabids.add(""0"");
	 tabids.add(""1"");
	 tabids.add(""2"");
	 tabids.add(""3"");
	 addAttribute(""componentSpec"", ""QtableSelector"", DATATYPE_INTEGER, true, null, tabids);
	 addElement(""scanComponentSpec"", ""sos"", CHILD_POLICY_EMPTY);
	 addAttribute(""sos"", ""numScanComponents"", DATATYPE_INTEGER, true, null, comps);
	 addAttribute(""sos"", ""startSpectralSelection"", DATATYPE_INTEGER, false, ""0"", ""0"", ""63"", true, true);
	 addAttribute(""sos"", ""endSpectralSelection"", DATATYPE_INTEGER, false, ""63"", ""0"", ""63"", true, true);
	 addAttribute(""sos"", ""approxHigh"", DATATYPE_INTEGER, false, ""0"", ""0"", ""15"", true, true);
	 addAttribute(""sos"", ""approxLow"", DATATYPE_INTEGER, false, ""0"", ""0"", ""15"", true, true);
	 addAttribute(""scanComponentSpec"", ""componentSelector"", DATATYPE_INTEGER, true, null, ""0"", ""255"", true, true);
	 addAttribute(""scanComponentSpec"", ""dcHuffTable"", DATATYPE_INTEGER, true, null, tabids);
	 addAttribute(""scanComponentSpec"", ""acHuffTable"", DATATYPE_INTEGER, true, null, tabids);
 }",0,0,1,0
"public class TestContent {
	public final boolean isError;
	public final String data;
	public TestContent(boolean isError, String data) {
		this.isError = isError;
		this.data = data;
	}
	public String toString() {
		if (isError) {
			return ""Error(""+data+"")"";
		}
		 else {
			return data;
		}
	}
}",1,1,0,0
"public void run() {
	 String line;
	 StringTokenizer tokens;
	 List<String> recipients = new ArrayList<String>();
	 try {
		 ExchangeSessionFactory.checkConfig();
		 sendClient(""220 DavMail "" + DavGateway.getCurrentVersion() + "" SMTP ready at "" + new Date());
		 for (;
		 ;
		) {
			 line = readClient();
			 if (line == null) {
				 break;
			 }
			 tokens = new StringTokenizer(line);
			 if (tokens.hasMoreTokens()) {
				 String command = tokens.nextToken();
				 if (state == State.LOGIN) {
					 userName = IOUtil.decodeBase64AsString(line);
					 sendClient(""334 "" + IOUtil.encodeBase64AsString(""Password:""));
					 state = State.PASSWORD;
				 }
				 else if (state == State.PASSWORD) {
					 password = IOUtil.decodeBase64AsString(line);
					 authenticate();
				 }
				 else if (""QUIT"".equalsIgnoreCase(command)) {
					 sendClient(""221 Closing connection"");
					 break;
				 }
				 else if (""NOOP"".equalsIgnoreCase(command)) {
					 sendClient(""250 OK"");
				 }
				 else if (""EHLO"".equalsIgnoreCase(command)) {
					 sendClient(""250-"" + tokens.nextToken());
					 sendClient(""250-AUTH LOGIN PLAIN"");
					 sendClient(""250-8BITMIME"");
					 sendClient(""250 Hello"");
				 }
				 else if (""HELO"".equalsIgnoreCase(command)) {
					 sendClient(""250 Hello"");
				 }
				 else if (""AUTH"".equalsIgnoreCase(command)) {
					 if (tokens.hasMoreElements()) {
						 String authType = tokens.nextToken();
						 if (""PLAIN"".equalsIgnoreCase(authType) && tokens.hasMoreElements()) {
							 decodeCredentials(tokens.nextToken());
							 authenticate();
						 }
						 else if (""LOGIN"".equalsIgnoreCase(authType)) {
							 if (tokens.hasMoreTokens()) {
								 userName = IOUtil.decodeBase64AsString(tokens.nextToken());
								 sendClient(""334 "" + IOUtil.encodeBase64AsString(""Password:""));
								 state = State.PASSWORD;
							 }
							 else {
								 sendClient(""334 "" + IOUtil.encodeBase64AsString(""Username:""));
								 state = State.LOGIN;
							 }
						 }
						 else {
							 sendClient(""451 Error : unknown authentication type"");
						 }
					 }
					 else {
						 sendClient(""451 Error : authentication type not specified"");
					 }
				 }
				 else if (""MAIL"".equalsIgnoreCase(command)) {
					 if (state == State.AUTHENTICATED) {
						 state = State.STARTMAIL;
						 recipients.clear();
						 sendClient(""250 Sender OK"");
					 }
					 else if (state == State.INITIAL) {
						 sendClient(""503 Authentication required"");
					 }
					 else {
						 state = State.INITIAL;
						 sendClient(""503 Bad sequence of commands"");
					 }
				 }
				 else if (""RCPT"".equalsIgnoreCase(command)) {
					 if (state == State.STARTMAIL || state == State.RECIPIENT) {
						 if (line.toUpperCase().startsWith(""RCPT TO:"")) {
							 state = State.RECIPIENT;
							 try {
								 InternetAddress internetAddress = new InternetAddress(line.substring(""RCPT TO:"".length()));
								 recipients.add(internetAddress.getAddress());
							 }
							 catch (AddressException e) {
								 throw new DavMailException(""EXCEPTION_INVALID_RECIPIENT"", line);
							 }
							 sendClient(""250 Recipient OK"");
						 }
						 else {
							 sendClient(""500 Unrecognized command"");
						 }
					 }
					 else {
						 state = State.AUTHENTICATED;
						 sendClient(""503 Bad sequence of commands"");
					 }
				 }
				 else if (""DATA"".equalsIgnoreCase(command)) {
					 if (state == State.RECIPIENT) {
						 state = State.MAILDATA;
						 sendClient(""354 Start mail input;
						 end with <CRLF>.<CRLF>"");
						 try {
							 ByteArrayOutputStream baos = new ByteArrayOutputStream();
							 DoubleDotInputStream doubleDotInputStream = new DoubleDotInputStream(in);
							 int b;
							 while ((b = doubleDotInputStream.read()) >= 0) {
								 baos.write(b);
							 }
							 MimeMessage mimeMessage = new MimeMessage(null, new SharedByteArrayInputStream(baos.toByteArray()));
							 session.sendMessage(recipients, mimeMessage);
							 state = State.AUTHENTICATED;
							 sendClient(""250 Queued mail for delivery"");
						 }
						 catch (Exception e) {
							 DavGatewayTray.error(e);
							 state = State.AUTHENTICATED;
							 sendClient(""451 Error : "" + e + ' ' + e.getMessage());
						 }
					 }
					 else {
						 state = State.AUTHENTICATED;
						 sendClient(""503 Bad sequence of commands"");
					 }
				 }
				 else if (""RSET"".equalsIgnoreCase(command)) {
					 recipients.clear();
					 if (state == State.STARTMAIL || state == State.RECIPIENT || state == State.MAILDATA || state == State.AUTHENTICATED) {
						 state = State.AUTHENTICATED;
					 }
					 else {
						 state = State.INITIAL;
					 }
					 sendClient(""250 OK Reset"");
				 }
				 else {
					 sendClient(""500 Unrecognized command"");
				 }
			 }
			 else {
				 sendClient(""500 Unrecognized command"");
			 }
			 os.flush();
		 }
	 }
	 catch (SocketException e) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
	 }
	 catch (Exception e) {
		 DavGatewayTray.log(e);
		 try {
			 sendClient(""500 "" + ((e.getMessage() == null) ? e : e.getMessage()));
		 }
		 catch (IOException e2) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
		 }
	 }
	 finally {
		 close();
	 }
	 DavGatewayTray.resetIcon();
 }",0,0,1,0
"public synchronized int getBufferSize() {
	 return bufferSize;
 }",0,0,0,0
"private void processSelectedKeys() {
	 for (Iterator<SelectionKey> i = selector.selectedKeys().iterator();
	 i.hasNext();
	) {
		 SelectionKey key = i.next();
		 i.remove();
		 final SelectableChannel sc = key.channel();
		 if (key.isReadable() && key.attachment() != null) {
			 read(key);
		 }
		 else if (key.isWritable() && key.attachment() != null) {
			 write(key);
		 }
		 else if (key.isAcceptable()) {
			 assert sc == serverSocketChannel;
			 accept();
		 }
		 else if (key.isConnectable()) {
			 finishConnect(key);
		 }
	 }
 }",0,0,1,0
"public class TransparencyFilterTrueColor extends TransparencyFilter {
	 private final int transparentColor;
	 public TransparencyFilterTrueColor(final byte[] bytes) throws IOException {
		 super(bytes);
		 final ByteArrayInputStream is = new ByteArrayInputStream(bytes);
		 final int transparentRed = read2Bytes(""transparentRed"", is, ""tRNS: Missing transparentColor"", getByteOrder());
		 final int transparentGreen = read2Bytes(""transparentGreen"", is, ""tRNS: Missing transparentColor"", getByteOrder());
		 final int transparentBlue = read2Bytes(""transparentBlue"", is, ""tRNS: Missing transparentColor"", getByteOrder());
		 transparentColor = ((0xff & transparentRed) << 16) | ((0xff & transparentGreen) << 8) | ((0xff & transparentBlue) << 0);
	 }
	 public int filter(final int rgb, final int sample) throws ImageReadException, IOException {
		 if ((0x00ffffff & rgb) == transparentColor) {
			 return 0x00;
		 }
		 return rgb;
	 }
}",0,0,0,0
"protected void buildSessionInfo(HttpMethod method) throws DavMailException {
	 if (method != null) {
		 method.releaseConnection();
	 }
	 directEws = method == null || ""/ews/services.wsdl"".equalsIgnoreCase(method.getPath());
	 if (!directEws) {
		 getEmailAndAliasFromOptions();
	 }
	 if (email == null || alias == null) {
		 if (userName.indexOf('@') >= 0) {
			 email = userName;
			 alias = userName.substring(0, userName.indexOf('@'));
		 }
		 else {
			 alias = getAliasFromLogin();
			 resolveEmailAddress(userName);
			 if (email == null) {
				 email = getAliasFromLogin() + getEmailSuffixFromHostname();
			 }
		 }
	 }
	 currentMailboxPath = ""/users/"" + email.toLowerCase();
	 try {
		 checkEndPointUrl(""/ews/exchange.asmx"");
		 internalGetFolder("""");
	 }
	 catch (IOException e) {
		 DavGatewayHttpClientFacade.addNTLM(httpClient);
		 try {
			 checkEndPointUrl(""/ews/exchange.asmx"");
			 internalGetFolder("""");
		 }
		 catch (IOException e2) {
			 LOGGER.debug(e2.getMessage());
			 try {
				 checkEndPointUrl(getEwsUrlFromAutoDiscover());
				 internalGetFolder("""");
			 }
			 catch (IOException e3) {
				 if (e instanceof DavMailAuthenticationException) {
					 throw (DavMailAuthenticationException) e;
				 }
				 LOGGER.error(e2.getMessage());
				 throw new DavMailAuthenticationException(""EXCEPTION_EWS_NOT_AVAILABLE"");
			 }
		 }
	 }
	 if (!DavGatewayHttpClientFacade.hasNTLMorNegotiate(httpClient)) {
		 httpClient.getParams().setParameter(HttpClientParams.PREEMPTIVE_AUTHENTICATION, true);
	 }
	 if (directEws) {
		 try {
			 ResolveNamesMethod resolveNamesMethod = new ResolveNamesMethod(alias);
			 executeMethod(resolveNamesMethod);
			 List<EWSMethod.Item> responses = resolveNamesMethod.getResponseItems();
			 for (EWSMethod.Item response : responses) {
				 if (alias.equalsIgnoreCase(response.get(""Name""))) {
					 email = response.get(""EmailAddress"");
					 currentMailboxPath = ""/users/"" + email.toLowerCase();
				 }
			 }
		 }
		 catch (IOException e) {
			 LOGGER.warn(""Unable to get primary email address with ResolveNames"", e);
		 }
	 }
	 try {
		 folderIdMap = new HashMap<String, String>();
		 folderIdMap.put(internalGetFolder(INBOX).folderId.value, INBOX);
		 folderIdMap.put(internalGetFolder(CALENDAR).folderId.value, CALENDAR);
		 folderIdMap.put(internalGetFolder(CONTACTS).folderId.value, CONTACTS);
		 folderIdMap.put(internalGetFolder(SENT).folderId.value, SENT);
		 folderIdMap.put(internalGetFolder(DRAFTS).folderId.value, DRAFTS);
		 folderIdMap.put(internalGetFolder(TRASH).folderId.value, TRASH);
		 folderIdMap.put(internalGetFolder(JUNK).folderId.value, JUNK);
		 folderIdMap.put(internalGetFolder(UNSENT).folderId.value, UNSENT);
	 }
	 catch (IOException e) {
		 LOGGER.error(e.getMessage(), e);
		 throw new DavMailAuthenticationException(""EXCEPTION_EWS_NOT_AVAILABLE"");
	 }
	 LOGGER.debug(""Current user email is "" + email + "", alias is "" + alias + "" on "" + serverVersion);
 }",0,0,1,0
"public int next() {
	 final int startNode = _startNode;
	 if (_startNode == NULL) {
		 return NULL;
	 }
	 int node = _currentNode;
	 int expType;
	 final int nodeType = _nodeType;
	 if (nodeType != DTM.ELEMENT_NODE) {
		 do {
			 node++;
			 expType = _exptype2(node);
			 if (NULL == expType || _parent2(node) < startNode && startNode != node) {
				 _currentNode = NULL;
				 return END;
			 }
		 }
		 while (expType != nodeType);
	 }
	 else if (startNode == DTMDefaultBase.ROOTNODE) {
		do{
			 node++;
			 expType = _exptype2(node);
			 if (NULL == expType) {
				 _currentNode = NULL;
				 return END;
			 }
		}
		 while (expType < DTM.NTYPES || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);
	 }
	 else {
		 do {
			 node++;
			 expType = _exptype2(node);
			 if (NULL == expType || _parent2(node) < startNode && startNode != node) {
				 _currentNode = NULL;
				 return END;
			 }
		 }
		 while (expType < DTM.NTYPES || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);
	 }
	 _currentNode = node;
	 return returnNode(makeNodeHandle(node));
 }",0,0,1,0
"public class CrossProductInputSplit extends FileSplit {
	private List<Path> inputPortDirectories;
	private Path workingDirectory;
	public CrossProductInputSplit() {
		super(null,0,0,null);
		inputPortDirectories = new ArrayList<Path>();
		System.out.println(""Calling default constructor for cross product split"");
	}
	public CrossProductInputSplit(Path workingDirectory, List<Path> inputPortDirectories) {
		super(workingDirectory, 0, 0, new String[0]);
		this.workingDirectory = workingDirectory;
		this.inputPortDirectories = inputPortDirectories;
		System.out.println(""Calling non-default constructor for cross product split"");
	}
	public void addInputPortDirectory(Path path) {
		inputPortDirectories.add(path);
	}
	public List<Path> getInputPortDirectories() {
		return inputPortDirectories;
	}
	public void write(DataOutput out) throws IOException {
		super.write(out);
		Text.writeString(out, workingDirectory.toString());
		out.writeInt(inputPortDirectories.size());
		for (Path path : inputPortDirectories) {
			Text.writeString(out, path.toString());
		}
	}
	public void readFields(DataInput in) throws IOException {
		super.readFields(in);
		workingDirectory = new Path(Text.readString(in));
		int length = in.readInt();
		for (int i = 0;
		 i < length;
		 i++) {
			inputPortDirectories.add(new Path(Text.readString(in)));
		}
	}
}",0,0,0,0
"private void determineDependencies() throws IOException {
	 affectedClassMap = new Hashtable();
	 classFileInfoMap = new Hashtable();
	 boolean cacheDirty = false;
	 Hashtable dependencyMap = new Hashtable();
	 File cacheFile = null;
	 boolean cacheFileExists = true;
	 long cacheLastModified = Long.MAX_VALUE;
	 if (cache != null) {
		 cacheFile = new File(cache, CACHE_FILE_NAME);
		 cacheFileExists = cacheFile.exists();
		 cacheLastModified = cacheFile.lastModified();
		 if (cacheFileExists) {
			 dependencyMap = readCachedDependencies(cacheFile);
		 }
	 }
	 Enumeration classfileEnum = getClassFiles(destPath).elements();
	 while (classfileEnum.hasMoreElements()) {
		 ClassFileInfo info = (ClassFileInfo) classfileEnum.nextElement();
		 log(""Adding class info for "" + info.className, Project.MSG_DEBUG);
		 classFileInfoMap.put(info.className, info);
		 Vector dependencyList = null;
		 if (cache != null) {
			 if (cacheFileExists && cacheLastModified > info.absoluteFile.lastModified()) {
				 dependencyList = (Vector) dependencyMap.get(info.className);
			 }
		 }
		 if (dependencyList == null) {
			 DependencyAnalyzer analyzer = new AntAnalyzer();
			 analyzer.addRootClass(info.className);
			 analyzer.addClassPath(destPath);
			 analyzer.setClosure(false);
			 dependencyList = new Vector();
			 Enumeration depEnum = analyzer.getClassDependencies();
			 while (depEnum.hasMoreElements()) {
				 Object o = depEnum.nextElement();
				 dependencyList.addElement(o);
				 log(""Class "" + info.className + "" depends on "" + o, Project.MSG_DEBUG);
			 }
			 cacheDirty = true;
			 dependencyMap.put(info.className, dependencyList);
		 }
		 Enumeration depEnum = dependencyList.elements();
		 while (depEnum.hasMoreElements()) {
			 String dependentClass = (String) depEnum.nextElement();
			 Hashtable affectedClasses = (Hashtable) affectedClassMap.get(dependentClass);
			 if (affectedClasses == null) {
				 affectedClasses = new Hashtable();
				 affectedClassMap.put(dependentClass, affectedClasses);
			 }
			 affectedClasses.put(info.className, info);
			 log(dependentClass + "" affects "" + info.className, Project.MSG_DEBUG);
		 }
	 }
	 classpathDependencies = null;
	 Path checkPath = getCheckClassPath();
	 if (checkPath != null) {
		 classpathDependencies = new Hashtable();
		 AntClassLoader loader = null;
		 try {
			 loader = getProject().createClassLoader(checkPath);
			 Hashtable classpathFileCache = new Hashtable();
			 Object nullFileMarker = new Object();
			 for (Enumeration e = dependencyMap.keys();
			 e.hasMoreElements();
			) {
				 String className = (String) e.nextElement();
				 log(""Determining classpath dependencies for "" + className, Project.MSG_DEBUG);
				 Vector dependencyList = (Vector) dependencyMap.get(className);
				 Hashtable dependencies = new Hashtable();
				 classpathDependencies.put(className, dependencies);
				 Enumeration e2 = dependencyList.elements();
				 while (e2.hasMoreElements()) {
					 String dependency = (String) e2.nextElement();
					 log(""Looking for "" + dependency, Project.MSG_DEBUG);
					 Object classpathFileObject = classpathFileCache.get(dependency);
					 if (classpathFileObject == null) {
						 classpathFileObject = nullFileMarker;
						 if (!dependency.startsWith(""java."") && !dependency.startsWith(""javax."")) {
							 URL classURL = loader.getResource(dependency.replace('.', '/') + "".class"");
							 log(""URL is "" + classURL, Project.MSG_DEBUG);
							 if (classURL != null) {
								 if (classURL.getProtocol().equals(""jar"")) {
									 String jarFilePath = classURL.getFile();
									 int classMarker = jarFilePath.indexOf('!');
									 jarFilePath = jarFilePath.substring(0, classMarker);
									 if (jarFilePath.startsWith(""file:"")) {
										 classpathFileObject = new File( FileUtils.getFileUtils().fromURI(jarFilePath));
									 }
									 else {
										 throw new IOException( ""Bizarre nested path in jar: protocol: "" + jarFilePath);
									 }
								 }
								 else if (classURL.getProtocol().equals(""file"")) {
									 classpathFileObject = new File( FileUtils.getFileUtils() .fromURI(classURL.toExternalForm()));
								 }
								 log(""Class "" + className + "" depends on "" + classpathFileObject + "" due to "" + dependency, Project.MSG_DEBUG);
							 }
						 }
						 else {
							 log(""Ignoring base classlib dependency "" + dependency, Project.MSG_DEBUG);
						 }
						 classpathFileCache.put(dependency, classpathFileObject);
					 }
					 if (classpathFileObject != nullFileMarker) {
						 File jarFile = (File) classpathFileObject;
						 log(""Adding a classpath dependency on "" + jarFile, Project.MSG_DEBUG);
						 dependencies.put(jarFile, jarFile);
					 }
				 }
			 }
		 }
		 finally {
			 if (loader != null) {
				 loader.cleanup();
			 }
		 }
	 }
	 else {
		 log(""No classpath to check"", Project.MSG_DEBUG);
	 }
	 if (cache != null && cacheDirty) {
		 writeCachedDependencies(dependencyMap);
	 }
 }",0,0,1,0
"public Comparator<IColumn> getColumnComparator(AbstractType comparator) {
	 return reversed ? new ReverseComparator(QueryFilter.getColumnComparator(comparator)) : QueryFilter.getColumnComparator(comparator);
 }",0,0,0,0
"public CallableStatement prepareCall(String sql) throws SQLException {
	 checkState();
	 PreparedStatementHolder stmtHolder = null;
	 PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.Precall_1);
	 boolean poolPreparedStatements = holder.isPoolPreparedStatements();
	 if (poolPreparedStatements) {
		 stmtHolder = holder.getStatementPool().get(key);
	 }
	 if (stmtHolder == null) {
		 try {
			 stmtHolder = new PreparedStatementHolder(key, conn.prepareCall(sql));
			 holder.getDataSource().incrementPreparedStatementCount();
		 }
		 catch (SQLException ex) {
			 handleException(ex, sql);
		 }
	 }
	 initStatement(stmtHolder);
	 DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
	 holder.addTrace(rtnVal);
	 return rtnVal;
 }",0,0,1,0
"public abstract class Component implements IClusterable, IConverterLocator{
	public class ComponentModelChange extends Change{
		private static final long serialVersionUID = 1L;
		private final IModel<?> model;
		public ComponentModelChange(IModel<?> model){
			super();
			this.model = model;
		}
		public String toString(){
			return getClass().getSimpleName() + ""[component: "" + getPath() + "",model:"" + model +""]"";
		}
		public void undo(){
			setDefaultModel(model);
		}
	}
	public static interface IVisitor<T extends Component>{
		public static final Object CONTINUE_TRAVERSAL = null;
		public static final Object CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER = new Object();
		public static final Object STOP_TRAVERSAL = new Object();
		public Object component(T component);
	}
	private final class AddedBehaviorChange extends Change{
		private static final long serialVersionUID = 1L;
		private final IBehavior behavior;
		public AddedBehaviorChange(IBehavior behavior){
			this.behavior = behavior;
		}
		public String toString(){
			return ""["" + getClass().getName() + "" behavior="" + behavior.toString() + ""]"";
		}
		public void undo(){
			removeBehavior(behavior);
		}
	}
	private class ComponentBorderChange extends Change{
		private static final long serialVersionUID = 1L;
		private final IComponentBorder old = getComponentBorder();
		public void undo(){
			setComponentBorder(old);
		}
		public String toString(){
			return getClass().getSimpleName() + ""[component: "" + getPath() + "",border:"" + old + ""]"";
		}
	}
	private final class RemovedBehaviorChange extends Change{
		private static final long serialVersionUID = 1L;
		private final IBehavior behavior;
		public RemovedBehaviorChange(IBehavior behavior){
			this.behavior = behavior;
		}
		public String toString(){
			return ""["" + getClass().getName() + "" behavior="" + behavior.toString() + ""]"";
		}
		public void undo(){
			addBehavior(behavior);
		}
	}
	protected final static class EnabledChange extends Change{
		private static final long serialVersionUID = 1L;
		private final Component component;
		private final boolean enabled;
		EnabledChange(final Component component){
			this.component = component;
			enabled = component.getFlag(FLAG_ENABLED);
		}
		public String toString(){
			return getClass().getSimpleName() + ""[component: "" + component.getPath() +"",enabled: "" + enabled + ""]"";
		}
		public void undo(){
			component.setEnabled(enabled);
		}
	}
	protected final static class VisibilityChange extends Change{
		private static final long serialVersionUID = 1L;
		private final Component component;
		private final boolean visible;
		VisibilityChange(final Component component){
			this.component = component;
			visible = component.getFlag(FLAG_VISIBLE);
		}
		public String toString(){
			return getClass().getSimpleName() + ""[component: "" + component.getPath() +"",visible: "" + visible + ""]"";
		}
		public void undo(){
			component.setVisible(visible);
		}
	}
	private static final Logger log = LoggerFactory.getLogger(Component.class);
	private static final long serialVersionUID = 1L;
	public static final Action ENABLE = new Action(Action.ENABLE);
	public static final char PATH_SEPARATOR = ':';
	public static final String PARENT_PATH = "".."";
	public static final Action RENDER = new Action(Action.RENDER);
	private static final MetaDataKey<IComponentBorder> BORDER_KEY = new MetaDataKey<IComponentBorder>(){
		private static final long serialVersionUID = 1L;
	}
	;
	private static final MetaDataKey<String> MARKUP_ID_KEY = new MetaDataKey<String>(){
		private static final long serialVersionUID = 1L;
	}
	;
	private static final IModelComparator defaultModelComparator = new IModelComparator(){
		private static final long serialVersionUID = 1L;
		public boolean compare(Component component, Object b){
			final Object a = component.getDefaultModelObject();
			if (a == null && b == null){
				return true;
			}
			if (a == null || b == null){
				return false;
			}
			return a.equals(b);
		}
	}
	;
	private static final int FLAG_AUTO = 0x0001;
	private static final int FLAG_ESCAPE_MODEL_STRINGS = 0x0002;
	static final int FLAG_INHERITABLE_MODEL = 0x0004;
	private static final int FLAG_VERSIONED = 0x0008;
	private static final int FLAG_VISIBLE = 0x0010;
	private static final int FLAG_RENDER_BODY_ONLY = 0x0020;
	private static final int FLAG_IGNORE_ATTRIBUTE_MODIFIER = 0x0040;
	private static final int FLAG_ENABLED = 0x0080;
	protected static final int FLAG_RESERVED1 = 0x0100;
	protected static final int FLAG_RESERVED2 = 0x0200;
	protected static final int FLAG_RESERVED3 = 0x0400;
	protected static final int FLAG_RESERVED4 = 0x0800;
	private static final int FLAG_HAS_BEEN_RENDERED = 0x1000;
	private static final int FLAG_IS_RENDER_ALLOWED = 0x2000;
	private static final int FLAG_OUTPUT_MARKUP_ID = 0x4000;
	private static final int FLAG_PLACEHOLDER = 0x8000;
	protected static final int FLAG_RESERVED5 = 0x10000;
	protected static final int FLAG_RESERVED6 = 0x20000;
	protected static final int FLAG_RESERVED7 = 0x40000;
	protected static final int FLAG_RESERVED8 = 0x80000;
	private static final int FLAG_MODEL_SET = 0x100000;
	protected static final int FLAG_REMOVING_FROM_HIERARCHY = 0x200000;
	protected static final int FLAG_INITIALIZED = 0x400000;
	protected static final int FLAG_CONFIGURED = 0x800000;
	private static final int FLAG_INITIALIZE_SUPER_CALL_VERIFIED = 0x10000000;
	private static final int FLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED = 0x1000000;
	private static final int FLAG_PREPARED_FOR_RENDER = 0x4000000;
	private static final int FLAG_RENDERING = 0x2000000;
	private static final int FLAG_AFTER_RENDERING = 0x8000000;
	private static final int FLAG_VISIBILITY_ALLOWED = 0x40000000;
	private static final int FLAG_ATTACHED = 0x20000000;
	private static final int FLAG_DETACHING = 0x80000000;
	private static final String MARKUP_ID_ATTR_NAME = ""id"";
	static final MetaDataKey<String> ADDED_AT_KEY = new MetaDataKey<String>(){
		private static final long serialVersionUID = 1L;
	}
	;
	static final MetaDataKey<String> CONSTRUCTED_AT_KEY = new MetaDataKey<String>(){
		private static final long serialVersionUID = 1L;
	}
	;
	private static final MetaDataKey<Boolean> ENABLED_IN_HIERARCHY_CACHE_KEY = new MetaDataKey<Boolean>(){
		private static final long serialVersionUID = 1L;
	}
	;
	private int flags = FLAG_VISIBLE | FLAG_ESCAPE_MODEL_STRINGS | FLAG_VERSIONED | FLAG_ENABLED |FLAG_IS_RENDER_ALLOWED | FLAG_VISIBILITY_ALLOWED;
	private String id;
	private MarkupContainer parent;
	int markupIndex = -1;
	int generatedMarkupId = -1;
	Object data = null;
	private final int data_length(){
		if (data == null){
			return 0;
		}
		else if (data instanceof Object[] && !(data instanceof MetaDataEntry<?>[])){
			return ((Object[])data).length;
		}
		else{
			return 1;
		}
	}
	private final Object data_get(int index){
		if (data == null){
			return null;
		}
		else if (data instanceof Object[] && !(data instanceof MetaDataEntry<?>[])){
			Object[] array = (Object[])data;
			return index < array.length ? array[index] : null;
		}
		else if (index == 0){
			return data;
		}
		else{
			return null;
		}
	}
	private final void data_set(int index, Object object){
		if (index > data_length() - 1){
			throw new IndexOutOfBoundsException(""can not set data at "" + index +"" when data_length() is "" + data_length());
		}
		else if (index == 0 && !(data instanceof Object[] && !(data instanceof MetaDataEntry<?>[]))){
			data = object;
		}
		else{
			Object[] array = (Object[])data;
			array[index] = object;
		}
	}
	private final void data_add(Object object){
		data_insert(-1, object);
	}
	private final void data_insert(int position, Object object){
		int currentLength = data_length();
		if (position == -1){
			position = currentLength;
		}
		if (position > currentLength){
			throw new IndexOutOfBoundsException(""can not insert data at "" + position +"" when data_length() is "" + currentLength);
		}
		if (currentLength == 0){
			data = object;
		}
		else if (currentLength == 1){
			Object[] array = new Object[2];
			if (position == 0){
				array[0] = object;
				array[1] = data;
			}
			else{
				array[0] = data;
				array[1] = object;
			}
			data = array;
		}
		else{
			Object[] array = new Object[currentLength + 1];
			Object[] current = (Object[])data;
			int before = position;
			int after = currentLength - position;
			if (before > 0){
				System.arraycopy(current, 0, array, 0, before);
			}
			array[position] = object;
			if (after > 0){
				System.arraycopy(current, position, array, position + 1, after);
			}
			data = array;
		}
	}
	private final void data_remove(int position){
		int currentLength = data_length();
		if (position > currentLength - 1){
			throw new IndexOutOfBoundsException();
		}
		else if (currentLength == 1){
			data = null;
		}
		else if (currentLength == 2){
			Object[] current = (Object[])data;
			if (position == 0){
				data = current[1];
			}
			else{
				data = current[0];
			}
		}
		else{
			Object[] current = (Object[])data;
			data = new Object[currentLength - 1];
			if (position > 0){
				System.arraycopy(current, 0, data, 0, position);
			}
			if (position != currentLength - 1){
				final int left = currentLength - position - 1;
				System.arraycopy(current, position + 1, data, position, left);
			}
		}
	}
	public Component(final String id){
		this(id, null);
	}
	public Component(final String id, final IModel<?> model){
		setId(id);
		getApplication().notifyComponentInstantiationListeners(this);
		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.isLinePreciseReportingOnNewComponentEnabled()){
			setMetaData(CONSTRUCTED_AT_KEY,Strings.toString(this, new MarkupException(""constructed"")));
		}
		if (model != null){
			setModelImpl(wrap(model));
		}
	}
	public Component add(final IBehavior... behaviors){
		if (behaviors == null){
			throw new IllegalArgumentException(""Argument may not be null"");
		}
		for (IBehavior behavior : behaviors){
			if (behavior == null){
				throw new IllegalArgumentException(""Argument may not be null"");
			}
			addBehavior(behavior);
			if (!behavior.isTemporary()){
				addStateChange(new AddedBehaviorChange(behavior));
			}
			behavior.bind(this);
		}
		return this;
	}
	private void addBehavior(final IBehavior behavior){
		data_add(behavior);
	}
	public final List<IBehavior> getBehaviorsRawList(){
		if (data != null){
			final int startIndex = getFlag(FLAG_MODEL_SET) ? 1 : 0;
			int length = data_length();
			if (length > startIndex){
				final ArrayList<IBehavior> result = new ArrayList<IBehavior>();
				for (int i = startIndex;
				 i < length;
				 ++i){
					Object o = data_get(i);
					if (o == null || o instanceof IBehavior){
						result.add((IBehavior)o);
					}
				}
				return result;
			}
		}
		return null;
	}
	public final void afterRender(){
		try{
			setFlag(FLAG_AFTER_RENDERING, true);
			onAfterRender();
			getApplication().notifyComponentOnAfterRenderListeners(this);
			if (getFlag(FLAG_AFTER_RENDERING)){
				throw new IllegalStateException(Component.class.getName() +"" has not been properly detached. Something in the hierarchy of "" +getClass().getName() +"" has not called super.onAfterRender() in the override of onAfterRender() method"");
			}
			onAfterRenderChildren();
		}
		finally{
			setFlag(FLAG_RENDERING, false);
		}
	}
	private final void internalBeforeRender(){
		configure();
		if ((determineVisibility() || callOnBeforeRenderIfNotVisible()) &&!getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)){
			setFlag(FLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);
			getApplication().notifyPreComponentOnBeforeRenderListeners(this);
			clearEnabledInHierarchyCache();
			onBeforeRender();
			getApplication().notifyPostComponentOnBeforeRenderListeners(this);
			if (!getFlag(FLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)){
				throw new IllegalStateException(Component.class.getName() +"" has not been properly rendered. Something in the hierarchy of "" +getClass().getName() +"" has not called super.onBeforeRender() in the override of onBeforeRender() method"");
			}
		}
	}
	private static final MetaDataKey<List<Component>> FEEDBACK_LIST = new MetaDataKey<List<Component>>(){
		private static final long serialVersionUID = 1L;
	}
	;
	public final void beforeRender(){
		if (!(this instanceof IFeedback)){
			internalBeforeRender();
		}
		else{
			List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);
			if (feedbacks == null){
				feedbacks = new ArrayList<Component>();
				getRequestCycle().setMetaData(FEEDBACK_LIST, feedbacks);
			}
			if (this instanceof MarkupContainer){
				((MarkupContainer)this).visitChildren(IFeedback.class, new IVisitor<Component>(){
					public Object component(Component component){
						component.beforeRender();
						return IVisitor.CONTINUE_TRAVERSAL;
					}
				}
				);
			}
			if (!feedbacks.contains(this)){
				feedbacks.add(this);
			}
		}
	}
	public final void configure(){
		if (!getFlag(FLAG_CONFIGURED)){
			onConfigure();
			List<IComponentConfigurationBehavior> behaviors = getBehaviors(IComponentConfigurationBehavior.class);
			for (IComponentConfigurationBehavior behavior : behaviors){
				if (isBehaviorAccepted(behavior)){
					behavior.onConfigure(this);
				}
			}
			setFlag(FLAG_CONFIGURED, true);
		}
	}
	public final boolean continueToOriginalDestination(){
		return getPage().getPageMap().continueToOriginalDestination();
	}
	public final void debug(final String message){
		Session.get().getFeedbackMessages().debug(this, message);
		Session.get().dirty();
	}
	final void internalOnRemove(){
		setFlag(FLAG_REMOVING_FROM_HIERARCHY, true);
		onRemove();
		if (getFlag(FLAG_REMOVING_FROM_HIERARCHY)){
			throw new IllegalStateException(Component.class.getName() +"" has not been properly removed from hierachy. Something in the hierarchy of "" +getClass().getName() +"" has not called super.onRemovalFromHierarchy() in the override of onRemovalFromHierarchy() method"");
		}
		removeChildren();
	}
	public final void detach(){
		setFlag(FLAG_DETACHING, true);
		onDetach();
		if (getFlag(FLAG_DETACHING)){
			throw new IllegalStateException(Component.class.getName() +"" has not been properly detached. Something in the hierarchy of "" +getClass().getName() +"" has not called super.onDetach() in the override of onDetach() method"");
		}
		setFlag(FLAG_ATTACHED, false);
		setFlag(FLAG_CONFIGURED, false);
		detachModels();
		detachBehaviors();
		detachChildren();
		if (getFlag(FLAG_INHERITABLE_MODEL)){
			setModelImpl(null);
			setFlag(FLAG_INHERITABLE_MODEL, false);
		}
		clearEnabledInHierarchyCache();
		IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();
		if (detachListener != null){
			detachListener.onDetach(this);
		}
	}
	public final void detachBehaviors(){
		for (IBehavior behavior : getBehaviors()){
			behavior.detach(this);
			if (behavior.isTemporary()){
				removeBehavior(behavior);
			}
		}
	}
	public void detachModels(){
		detachModel();
	}
	public final void error(final Serializable message){
		Session.get().getFeedbackMessages().error(this, message);
		Session.get().dirty();
	}
	public final void fatal(final String message){
		Session.get().getFeedbackMessages().fatal(this, message);
		Session.get().dirty();
	}
	public final <Z> Z findParent(final Class<Z> c){
		MarkupContainer current = parent;
		while (current != null){
			if (c.isInstance(current)){
				return c.cast(current);
			}
			current = current.getParent();
		}
		return null;
	}
	public final MarkupContainer findParentWithAssociatedMarkup(){
		MarkupContainer container = parent;
		while (container != null){
			if (container.hasAssociatedMarkup()){
				return container;
			}
			container = container.getParent();
		}
		throw new WicketRuntimeException(""Unable to find parent with associated markup"");
	}
	public final Application getApplication(){
		return Application.get();
	}
	public final List<IBehavior> getBehaviors(){
		return getBehaviors(IBehavior.class);
	}
	public final String getClassRelativePath(){
		return getClass().getName() + PATH_SEPARATOR + getPageRelativePath();
	}
	public final IComponentBorder getComponentBorder(){
		return getMetaData(BORDER_KEY);
	}
	public final IConverter getConverter(){
		throw new UnsupportedOperationException(""use #getConverter(Class) instead"");
	}
	public IConverter getConverter(Class<?> type){
		return getApplication().getConverterLocator().getConverter(type);
	}
	public final boolean getEscapeModelStrings(){
		return getFlag(FLAG_ESCAPE_MODEL_STRINGS);
	}
	public final FeedbackMessage getFeedbackMessage(){
		return Session.get().getFeedbackMessages().messageForComponent(this);
	}
	public String getId(){
		return id;
	}
	public final IModel<?> getInnermostModel(){
		return getInnermostModel(getDefaultModel());
	}
	public Locale getLocale(){
		if (parent != null){
			return parent.getLocale();
		}
		return getSession().getLocale();
	}
	public final Localizer getLocalizer(){
		return getApplication().getResourceSettings().getLocalizer();
	}
	public final ValueMap getMarkupAttributes(){
		MarkupStream markupStream = locateMarkupStream();
		ValueMap attrs = new ValueMap(markupStream.getTag().getAttributes());
		attrs.makeImmutable();
		return attrs;
	}
	public final Object getMarkupIdImpl(){
		if (generatedMarkupId != -1){
			return new Integer(generatedMarkupId);
		}
		return getMetaData(MARKUP_ID_KEY);
	}
	private final int nextAutoIndex(){
		Page page = findPage();
		if (page == null){
			throw new WicketRuntimeException(""This component is not (yet) coupled to a page. It has to be able ""+ ""to find the page it is supposed to operate in before you can call ""+ ""this method (Component#getMarkupId)"");
		}
		return page.getAutoIndex();
	}
	public String getMarkupId(boolean createIfDoesNotExist){
		Object storedMarkupId = getMarkupIdImpl();
		if (storedMarkupId instanceof String){
			return (String)storedMarkupId;
		}
		if (storedMarkupId == null && createIfDoesNotExist == false){
			return null;
		}
		final int generatedMarkupId = storedMarkupId instanceof Integer? ((Integer)storedMarkupId).intValue() : Session.get().nextSequenceValue();
		if (storedMarkupId == null){
			setMarkupIdImpl(new Integer(generatedMarkupId));
		}
		String markupIdPrefix = ""id"";
		if (!Application.get().getConfigurationType().equals(Application.DEPLOYMENT)){
			markupIdPrefix = getId();
		}
		String markupIdPostfix = Integer.toHexString(generatedMarkupId).toLowerCase();
		markupIdPostfix = RequestContext.get().encodeMarkupId(markupIdPostfix);
		String markupId = markupIdPrefix + markupIdPostfix;
		char c = markupId.charAt(0);
		if (!Character.isLetter(c)){
			markupId = ""id"" + markupId;
		}
		markupId = Strings.replaceAll(markupId, ""_"", ""__"").toString();
		markupId = markupId.replace('.', '_');
		markupId = markupId.replace('-', '_');
		markupId = markupId.replace(' ', '_');
		return markupId;
	}
	public String getMarkupId(){
		return getMarkupId(true);
	}
	public final <M extends Serializable> M getMetaData(final MetaDataKey<M> key){
		return key.get(getMetaData());
	}
	private MetaDataEntry<?>[] getMetaData(){
		MetaDataEntry<?>[] metaData = null;
		int index = getFlag(FLAG_MODEL_SET) ? 1 : 0;
		int length = data_length();
		if (index < length){
			Object object = data_get(index);
			if (object instanceof MetaDataEntry<?>[]){
				metaData = (MetaDataEntry<?>[])object;
			}
			else if (object instanceof MetaDataEntry){
				metaData = new MetaDataEntry[] {
				 (MetaDataEntry<?>)object }
				;
			}
		}
		return metaData;
	}
	public final IModel<?> getDefaultModel(){
		IModel<?> model = getModelImpl();
		if (model == null){
			model = initModel();
			setModelImpl(model);
		}
		return model;
	}
	public final Object getDefaultModelObject(){
		final IModel<?> model = getDefaultModel();
		if (model != null){
			return model.getObject();
		}
		return null;
	}
	public final String getDefaultModelObjectAsString(){
		return getDefaultModelObjectAsString(getDefaultModelObject());
	}
	public final String getDefaultModelObjectAsString(final Object modelObject){
		if (modelObject != null){
			final Class<?> objectClass = modelObject.getClass();
			final IConverter converter = getConverter(objectClass);
			final String modelString = converter.convertToString(modelObject, getLocale());
			if (modelString != null){
				if (getFlag(FLAG_ESCAPE_MODEL_STRINGS)){
					return Strings.escapeMarkup(modelString, false, false).toString();
				}
				return modelString;
			}
		}
		return """";
	}
	public final boolean getOutputMarkupId(){
		return getFlag(FLAG_OUTPUT_MARKUP_ID);
	}
	public final boolean getOutputMarkupPlaceholderTag(){
		return getFlag(FLAG_PLACEHOLDER);
	}
	public final Page getPage(){
		final Page page = findPage();
		if (page == null){
			throw new IllegalStateException(""No Page found for component "" + this);
		}
		return page;
	}
	public final String getPageRelativePath(){
		return Strings.afterFirstPathComponent(getPath(), PATH_SEPARATOR);
	}
	public final MarkupContainer getParent(){
		return parent;
	}
	public final String getPath(){
		final PrependingStringBuffer buffer = new PrependingStringBuffer(32);
		for (Component c = this;
		 c != null;
		 c = c.getParent()){
			if (buffer.length() > 0){
				buffer.prepend(PATH_SEPARATOR);
			}
			buffer.prepend(c.getId());
		}
		return buffer.toString();
	}
	public final boolean getRenderBodyOnly(){
		return getFlag(FLAG_RENDER_BODY_ONLY);
	}
	public final Request getRequest(){
		RequestCycle requestCycle = getRequestCycle();
		if (requestCycle == null){
			throw new WicketRuntimeException(""No RequestCycle is currently set!"");
		}
		return requestCycle.getRequest();
	}
	public final RequestCycle getRequestCycle(){
		return RequestCycle.get();
	}
	public final Response getResponse(){
		return getRequestCycle().getResponse();
	}
	public Session getSession(){
		return Session.get();
	}
	public long getSizeInBytes(){
		final MarkupContainer originalParent = parent;
		parent = null;
		long size = -1;
		try{
			size = Objects.sizeof(this);
		}
		catch (Exception e){
			log.error(""Exception getting size for component "" + this, e);
		}
		parent = originalParent;
		return size;
	}
	public final String getString(final String key){
		return getString(key, null);
	}
	public final String getString(final String key, final IModel<?> model){
		return getLocalizer().getString(key, this, model);
	}
	public final String getString(final String key, final IModel<?> model, final String defaultValue){
		return getLocalizer().getString(key, this, model, defaultValue);
	}
	public final String getStyle(){
		String variation = getVariation();
		String style = getSession().getStyle();
		if (variation != null && !"""".equals(variation)){
			if (style != null && !"""".equals(style)){
				style = variation + ""_"" + style;
			}
			else{
				style = variation;
			}
		}
		return style;
	}
	public String getVariation(){
		if (parent != null){
			return parent.getVariation();
		}
		return null;
	}
	public final boolean hasBeenRendered(){
		return getFlag(FLAG_HAS_BEEN_RENDERED);
	}
	public final boolean hasErrorMessage(){
		return Session.get().getFeedbackMessages().hasErrorMessageFor(this);
	}
	public final boolean hasFeedbackMessage(){
		return Session.get().getFeedbackMessages().hasMessageFor(this);
	}
	public final void info(final String message){
		Session.get().getFeedbackMessages().info(this, message);
		Session.get().dirty();
	}
	public final void internalAttach(){
		throw new UnsupportedOperationException();
	}
	public final void internalDetach(){
		throw new UnsupportedOperationException();
	}
	public final boolean isActionAuthorized(Action action){
		IAuthorizationStrategy authorizationStrategy = getSession().getAuthorizationStrategy();
		if (authorizationStrategy != null){
			return authorizationStrategy.isActionAuthorized(this, action);
		}
		return true;
	}
	public final boolean isAncestorOf(final Component component){
		return getParent().contains(component, false);
	}
	public final boolean isEnableAllowed(){
		return isActionAuthorized(ENABLE);
	}
	public boolean isEnabled(){
		return getFlag(FLAG_ENABLED);
	}
	public final boolean isRenderAllowed(){
		return getFlag(FLAG_IS_RENDER_ALLOWED);
	}
	public final boolean isStateless(){
		if (!getStatelessHint()){
			return false;
		}
		for (IBehavior behavior : getBehaviors()){
			if (!behavior.getStatelessHint(this)){
				return false;
			}
		}
		return true;
	}
	public boolean isVersioned(){
		if (!getFlag(FLAG_VERSIONED)){
			return false;
		}
		else{
			if (parent != null){
				if (!parent.isVersioned()){
					return false;
				}
			}
			return true;
		}
	}
	public boolean isVisible(){
		return getFlag(FLAG_VISIBLE);
	}
	public final boolean isVisibleInHierarchy(){
		Component parent = getParent();
		if (parent != null && !parent.isVisibleInHierarchy()){
			return false;
		}
		else{
			return determineVisibility();
		}
	}
	public final void markRendering(boolean setRenderingFlag){
		internalMarkRendering(setRenderingFlag);
	}
	public final void modelChanged(){
		internalOnModelChanged();
		onModelChanged();
	}
	public final void modelChanging(){
		checkHierarchyChange(this);
		onModelChanging();
		final Page page = findPage();
		if (page != null){
			page.componentModelChanging(this);
		}
	}
	public void prepareForRender(boolean setRenderingFlag){
		beforeRender();
		if (setRenderingFlag){
			List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);
			if (feedbacks != null){
				for (int i = 0;
				 i < feedbacks.size();
				 i++){
					feedbacks.get(i).internalBeforeRender();
				}
			}
			getRequestCycle().setMetaData(FEEDBACK_LIST, null);
		}
		markRendering(setRenderingFlag);
		setRenderAllowed();
	}
	public final void prepareForRender(){
		prepareForRender(true);
	}
	public final void redirectToInterceptPage(final Page page){
		getPage().getPageMap().redirectToInterceptPage(page);
	}
	public final void remove(){
		if (parent == null){
			throw new IllegalStateException(""Cannot remove "" + this + "" from null parent!"");
		}
		parent.remove(this);
	}
	public Component remove(final IBehavior behavior){
		if (behavior == null){
			throw new IllegalArgumentException(""Argument `behavior` cannot be null"");
		}
		if (removeBehavior(behavior)){
			if (!behavior.isTemporary()){
				addStateChange(new RemovedBehaviorChange(behavior));
			}
		}
		else{
			throw new IllegalStateException(""Tried to remove a behavior that was not added to the component. Behavior: "" +behavior.toString());
		}
		return this;
	}
	private boolean removeBehavior(final IBehavior behavior){
		final int start = getFlag(FLAG_MODEL_SET) ? 1 : 0;
		final int len = data_length();
		for (int i = start;
		 i < len;
		 ++i){
			Object o = data_get(i);
			if (o != null && o.equals(behavior)){
				boolean anyListenersAfter = false;
				for (int j = i + 1;
				 j < len;
				 j++){
					if (data_get(j) instanceof IRequestListener){
						anyListenersAfter = true;
						break;
					}
				}
				if (anyListenersAfter){
					data_set(i, null);
				}
				else{
					data_remove(i);
					if (o instanceof IRequestListener){
						for (int j = i - 1;
						 j >= start;
						 j--){
							if (data_get(j) == null){
								data_remove(j);
							}
							else{
								break;
							}
						}
					}
				}
				return true;
			}
		}
		return false;
	}
	public final void render(){
		MarkupStream markupStream = null;
		if (getParent() != null){
			markupStream = findMarkupStream();
		}
		render(markupStream);
	}
	public final void render(final MarkupStream markupStream){
		if (markupStream != null){
			markupIndex = markupStream.getCurrentIndex();
		}
		markRendering(true);
		setMarkupStream(markupStream);
		if (markupStream != null){
			markupStream.getTag().onBeforeRender(this, markupStream);
		}
		if (determineVisibility()){
			setFlag(FLAG_HAS_BEEN_RENDERED, true);
			if (log.isDebugEnabled()){
				log.debug(""Begin render "" + this);
			}
			try{
				final IComponentBorder border = getComponentBorder();
				if (border != null){
					border.renderBefore(this);
				}
				notifyBehaviorsComponentBeforeRender();
				onRender(markupStream);
				notifyBehaviorsComponentRendered();
				if (border != null){
					border.renderAfter(this);
				}
				rendered();
			}
			catch (RuntimeException ex){
				for (IBehavior behavior : getBehaviors()){
					if (isBehaviorAccepted(behavior)){
						try{
							behavior.exception(this, ex);
						}
						catch (Throwable ex2){
							log.error(""Error while cleaning up after exception"", ex2);
						}
					}
				}
				throw ex;
			}
			if (log.isDebugEnabled()){
				log.debug(""End render "" + this);
			}
		}
		else if (markupStream != null){
			if (getFlag(FLAG_PLACEHOLDER)){
				final ComponentTag tag = markupStream.getTag();
				renderPlaceholderTag(tag, getResponse());
			}
			markupStream.skipComponent();
		}
	}
	protected void renderPlaceholderTag(final ComponentTag tag, final Response response){
		String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + "":"";
		response.write(""<"");
		if (ns != null){
			response.write(ns);
		}
		response.write(tag.getName());
		response.write("" id=\"""");
		response.write(getAjaxRegionMarkupId());
		response.write(""\"" style=\""display:none\""></"");
		if (ns != null){
			response.write(ns);
		}
		response.write(tag.getName());
		response.write("">"");
	}
	public final String getAjaxRegionMarkupId(){
		String markupId = null;
		for (IBehavior behavior : getBehaviors()){
			if (behavior instanceof IAjaxRegionMarkupIdProvider){
				markupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(this);
			}
		}
		if (markupId == null){
			if (this instanceof IAjaxRegionMarkupIdProvider){
				markupId = ((IAjaxRegionMarkupIdProvider)this).getAjaxRegionMarkupId(this);
			}
		}
		if (markupId == null){
			markupId = getMarkupId();
		}
		return markupId;
	}
	public final void renderComponent(){
		if (this instanceof Page){
			((Page)this).renderPage();
		}
		else{
			MarkupContainer parent = getParent();
			MarkupStream originalMarkupStream = parent.getMarkupStream();
			MarkupStream markupStream = locateMarkupStream();
			try{
				parent.setMarkupStream(markupStream);
				prepareForRender();
				render(markupStream);
			}
			finally{
				parent.setMarkupStream(originalMarkupStream);
				afterRender();
			}
		}
	}
	public final void renderComponent(final MarkupStream markupStream){
		markupIndex = markupStream.getCurrentIndex();
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();
		onComponentTag(tag);
		if (!tag.isOpenClose() && !tag.isOpen()){
			markupStream.throwMarkupException(""Method renderComponent called on bad markup element: "" +tag);
		}
		if (tag.isOpenClose() && openTag.isOpen()){
			markupStream.throwMarkupException(""You can not modify a open tag to open-close: "" + tag);
		}
		try{
			if (getRenderBodyOnly() == false){
				renderComponentTag(tag);
			}
			markupStream.next();
			if (tag.isOpen()){
				onComponentTagBody(markupStream, tag);
			}
			if (tag.isOpen()){
				if (openTag.isOpen()){
					renderClosingComponentTag(markupStream, tag, getRenderBodyOnly());
				}
				else{
					if (getRenderBodyOnly() == false){
						final boolean ajaxRequest = getRequest() instanceof WebRequest &&((WebRequest)getRequest()).isAjax();
						final boolean stripWicketTags = ajaxRequest ||Application.get().getMarkupSettings().getStripWicketTags();
						if (!(openTag instanceof WicketTag) || !stripWicketTags){
							getResponse().write(tag.syntheticCloseTagString());
						}
					}
				}
			}
		}
		catch (RuntimeException re){
			if (re instanceof WicketRuntimeException || re instanceof AbortException){
				throw re;
			}
			throw new WicketRuntimeException(""Exception in rendering component: "" + this, re);
		}
	}
	public final void rendered(){
		getPage().componentRendered(this);
	}
	public void renderHead(final HtmlHeaderContainer container){
		if (isVisibleInHierarchy() && isRenderAllowed()){
			if (this instanceof IHeaderContributor){
				((IHeaderContributor)this).renderHead(container.getHeaderResponse());
			}
			for (IBehavior behavior : getBehaviors()){
				if (behavior instanceof IHeaderContributor && isBehaviorAccepted(behavior)){
					((IHeaderContributor)behavior).renderHead(container.getHeaderResponse());
				}
			}
		}
	}
	public void replaceWith(Component replacement){
		if (replacement == null){
			throw new IllegalArgumentException(""Argument [[replacement]] cannot be null."");
		}
		if (!getId().equals(replacement.getId())){
			throw new IllegalArgumentException(""Replacement component must have the same id as the component it will replace. Replacement id [["" +replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null){
			throw new IllegalStateException(""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
	}
	public final boolean sameInnermostModel(final Component component){
		return sameInnermostModel(component.getDefaultModel());
	}
	public final boolean sameInnermostModel(final IModel<?> model){
		IModel<?> thisModel = getDefaultModel();
		IModel<?> thatModel = model;
		if (thisModel != null && thatModel != null){
			return getInnermostModel(thisModel) == getInnermostModel(thatModel);
		}
		return false;
	}
	public final Component setComponentBorder(final IComponentBorder border){
		if (!Objects.equal(getComponentBorder(), border)){
			addStateChange(new ComponentBorderChange());
		}
		setMetaData(BORDER_KEY, border);
		return this;
	}
	public final Component setEnabled(final boolean enabled){
		if (enabled != getFlag(FLAG_ENABLED)){
			if (isVersioned()){
				final Page page = findPage();
				if (page != null){
					addStateChange(new EnabledChange(this));
				}
			}
			setFlag(FLAG_ENABLED, enabled);
			onEnabledStateChanged();
		}
		return this;
	}
	void clearEnabledInHierarchyCache(){
		setMetaData(ENABLED_IN_HIERARCHY_CACHE_KEY, null);
	}
	void onEnabledStateChanged(){
		clearEnabledInHierarchyCache();
	}
	public final Component setEscapeModelStrings(final boolean escapeMarkup){
		setFlag(FLAG_ESCAPE_MODEL_STRINGS, escapeMarkup);
		return this;
	}
	public final void setMarkupIdImpl(Object markupId){
		if (markupId != null && !(markupId instanceof String) && !(markupId instanceof Integer)){
			throw new IllegalArgumentException(""markupId must be String or Integer"");
		}
		if (markupId instanceof Integer){
			generatedMarkupId = ((Integer)markupId).intValue();
			setMetaData(MARKUP_ID_KEY, null);
			return;
		}
		generatedMarkupId = -1;
		setMetaData(MARKUP_ID_KEY, (String)markupId);
	}
	public Component setMarkupId(String markupId){
		if (markupId != null && Strings.isEmpty(markupId)){
			throw new IllegalArgumentException(""Markup id cannot be an empty string"");
		}
		setMarkupIdImpl(markupId);
		return this;
	}
	public final <M> void setMetaData(final MetaDataKey<M> key, final M object){
		MetaDataEntry<?>[] old = getMetaData();
		Object metaData = null;
		MetaDataEntry<?>[] metaDataArray = key.set(getMetaData(), object);
		if (metaDataArray != null && metaDataArray.length > 0){
			metaData = (metaDataArray.length > 1) ? (Object)metaDataArray : metaDataArray[0];
		}
		int index = getFlag(FLAG_MODEL_SET) ? 1 : 0;
		if (old == null && metaData != null){
			data_insert(index, metaData);
		}
		else if (old != null && metaData != null){
			data_set(index, metaData);
		}
		else if (old != null && metaData == null){
			data_remove(index);
		}
	}
	public Component setDefaultModel(final IModel<?> model){
		IModel<?> prevModel = getModelImpl();
		if (prevModel != null){
			prevModel.detach();
		}
		IModel<?> wrappedModel = prevModel;
		if (prevModel instanceof IWrapModel){
			wrappedModel = ((IWrapModel<?>)prevModel).getWrappedModel();
		}
		if (wrappedModel != model){
			if (wrappedModel != null){
				addStateChange(new ComponentModelChange(wrappedModel));
			}
			setModelImpl(wrap(model));
		}
		modelChanged();
		return this;
	}
	IModel<?> getModelImpl(){
		if (getFlag(FLAG_MODEL_SET)){
			return (IModel<?>)data_get(0);
		}
		return null;
	}
	void setModelImpl(IModel<?> model){
		if (getFlag(FLAG_MODEL_SET)){
			if (model != null){
				data_set(0, model);
				if (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel)){
					setFlag(FLAG_INHERITABLE_MODEL, false);
				}
			}
			else{
				data_remove(0);
				setFlag(FLAG_MODEL_SET, false);
			}
		}
		else{
			if (model != null){
				data_insert(0, model);
				setFlag(FLAG_MODEL_SET, true);
			}
		}
	}
	public final Component setDefaultModelObject(final Object object){
		final IModel<Object> model = (IModel<Object>)getDefaultModel();
		if (model == null){
			throw new IllegalStateException(""Attempt to set model object on null model of component: "" + getPageRelativePath());
		}
		if (!isActionAuthorized(ENABLE)){
			throw new UnauthorizedActionException(this, ENABLE);
		}
		if (!getModelComparator().compare(this, object)){
			modelChanging();
			model.setObject(object);
			modelChanged();
		}
		return this;
	}
	public final Component setOutputMarkupId(final boolean output){
		setFlag(FLAG_OUTPUT_MARKUP_ID, output);
		return this;
	}
	public final Component setOutputMarkupPlaceholderTag(final boolean outputTag){
		if (outputTag != getFlag(FLAG_PLACEHOLDER)){
			if (outputTag){
				setOutputMarkupId(true);
				setFlag(FLAG_PLACEHOLDER, true);
			}
			else{
				setFlag(FLAG_PLACEHOLDER, false);
			}
		}
		return this;
	}
	public final void setRedirect(final boolean redirect){
		getRequestCycle().setRedirect(redirect);
	}
	public final Component setRenderBodyOnly(final boolean renderTag){
		this.setFlag(FLAG_RENDER_BODY_ONLY, renderTag);
		return this;
	}
	public final <C extends Page> void setResponsePage(final Class<C> cls){
		getRequestCycle().setResponsePage(cls);
	}
	public final <C extends Page> void setResponsePage(final Class<C> cls, PageParameters parameters){
		getRequestCycle().setResponsePage(cls, parameters);
	}
	public final void setResponsePage(final Page page){
		getRequestCycle().setResponsePage(page);
	}
	public Component setVersioned(boolean versioned){
		setFlag(FLAG_VERSIONED, versioned);
		return this;
	}
	public final Component setVisible(final boolean visible){
		if (visible != getFlag(FLAG_VISIBLE)){
			addStateChange(new VisibilityChange(this));
			setFlag(FLAG_VISIBLE, visible);
		}
		return this;
	}
	public String toString(){
		return toString(false);
	}
	public String toString(final boolean detailed){
		try{
			if (detailed){
				final Page page = findPage();
				if (page == null){
					return new StringBuffer(""[Component id = "").append(getId()).append("", page = <No Page>, path = "").append(getPath()).append(""."").append(Classes.simpleName(getClass())).append(""]"").toString();
				}
				else{
					return new StringBuffer(""[Component id = "").append(getId()).append("", page = "").append(getPage().getClass().getName()).append("", path = "").append(getPath()).append(""."").append(Classes.simpleName(getClass())).append("", isVisible = "").append((determineVisibility())).append("", isVersioned = "").append(isVersioned()).append(""]"").toString();
				}
			}
			else{
				return ""[Component id = "" + getId() + ""]"";
			}
		}
		catch (Exception e){
			log.warn(""Error while building toString()"", e);
			return String.format(""[Component id = %s <attributes are not available because exception %s was thrown during toString()>]"",getId(), e.getClass().getName());
		}
	}
	public final <C extends Page> CharSequence urlFor(final Class<C> pageClass,final PageParameters parameters){
		return getRequestCycle().urlFor(getPage().getPageMap(), pageClass, parameters);
	}
	public final CharSequence urlFor(final IBehavior behaviour,final RequestListenerInterface listener){
		return getRequestCycle().urlFor(this, behaviour, listener);
	}
	public final <C extends Page> CharSequence urlFor(final IPageMap pageMap,final Class<C> pageClass, final PageParameters parameters){
		return getRequestCycle().urlFor(pageMap, pageClass, parameters);
	}
	public final CharSequence urlFor(final IRequestTarget requestTarget){
		return getRequestCycle().urlFor(requestTarget);
	}
	public final CharSequence urlFor(final RequestListenerInterface listener){
		return getRequestCycle().urlFor(this, listener);
	}
	public final CharSequence urlFor(final ResourceReference resourceReference){
		return getRequestCycle().urlFor(resourceReference);
	}
	public final Object visitParents(final Class<?> c, final IVisitor<Component> visitor){
		Component current = getParent();
		while (current != null){
			if (c.isInstance(current)){
				final Object object = visitor.component(current);
				if (object != IVisitor.CONTINUE_TRAVERSAL){
					return object;
				}
			}
			current = current.getParent();
		}
		return null;
	}
	public final void warn(final String message){
		Session.get().getFeedbackMessages().warn(this, message);
		Session.get().dirty();
	}
	private void notifyBehaviorsComponentBeforeRender(){
		for (IBehavior behavior : getBehaviors()){
			if (isBehaviorAccepted(behavior)){
				behavior.beforeRender(this);
			}
		}
	}
	private void notifyBehaviorsComponentRendered(){
		for (IBehavior behavior : getBehaviors()){
			if (isBehaviorAccepted(behavior)){
				behavior.afterRender(this);
			}
		}
	}
	protected final void addStateChange(final Change change){
		checkHierarchyChange(this);
		final Page page = findPage();
		if (page != null){
			page.componentStateChanging(this, change);
		}
	}
	protected final void checkComponentTag(final ComponentTag tag, final String name){
		if (!tag.getName().equalsIgnoreCase(name)){
			String msg = String.format(""Component [%s] (path = [%s]) must be ""+ ""applied to a tag of type [%s], not: %s"", getId(), getPath(), name,tag.toUserDebugString());
			findMarkupStream().throwMarkupException(msg);
		}
	}
	protected final void checkComponentTagAttribute(final ComponentTag tag, final String key,final String value){
		if (key != null){
			final String tagAttributeValue = tag.getAttributes().getString(key);
			if (tagAttributeValue == null || !value.equalsIgnoreCase(tagAttributeValue)){
				String msg = String.format(""Component [%s] (path = [%s]) must be applied to a tag ""+ ""with [%s] attribute matching [%s], not [%s]"", getId(), getPath(), key,value, tagAttributeValue);
				findMarkupStream().throwMarkupException(msg);
			}
		}
	}
	protected void checkHierarchyChange(final Component component){
		if (!component.isAuto() && getFlag(FLAG_RENDERING)){
			throw new WicketRuntimeException(""Cannot modify component hierarchy after render phase has started (page version cant change then anymore)"");
		}
	}
	protected void detachModel(){
		IModel<?> model = getModelImpl();
		if (model != null){
			model.detach();
		}
		if (model instanceof IWrapModel && !getFlag(FLAG_INHERITABLE_MODEL)){
			((IWrapModel<?>)model).getWrappedModel().detach();
		}
	}
	protected final String exceptionMessage(final String message){
		return message + "":\n"" + toString();
	}
	protected MarkupStream findMarkupStream(){
		if (parent == null){
			throw new IllegalStateException(""Cannot find markupstream for "" + this +"" as there is no parent"");
		}
		return parent.findMarkupStream();
	}
	protected final Page findPage(){
		return (Page)(this instanceof Page ? this : findParent(Page.class));
	}
	protected <M extends IBehavior> List<M> getBehaviors(Class<M> type){
		List<IBehavior> behaviors = getBehaviorsRawList();
		if (behaviors == null){
			return Collections.emptyList();
		}
		List<M> subset = new ArrayList<M>(behaviors.size());
		 for (IBehavior behavior : behaviors){
			if (behavior != null){
				if (type == null){
					subset.add((M)behavior);
				}
				else if (type.isAssignableFrom(behavior.getClass())){
					subset.add(type.cast(behavior));
				}
			}
		}
		return Collections.unmodifiableList(subset);
	}
	protected final boolean getFlag(final int flag){
		return (flags & flag) != 0;
	}
	protected final boolean getFlag(final short flag){
		return getFlag((int)flag);
	}
	protected final IModel<?> getInnermostModel(final IModel<?> model){
		IModel<?> nested = model;
		while (nested != null && nested instanceof IWrapModel){
			final IModel<?> next = ((IWrapModel<?>)nested).getWrappedModel();
			if (nested == next){
				throw new WicketRuntimeException(""Model for "" + nested + "" is self-referential"");
			}
			nested = next;
		}
		return nested;
	}
	public IModelComparator getModelComparator(){
		return defaultModelComparator;
	}
	protected boolean getStatelessHint(){
		return true;
	}
	protected IModel<?> initModel(){
		IModel<?> foundModel = null;
		for (Component current = getParent();
		 current != null;
		 current = current.getParent()){
			IModel<?> model = current.getModelImpl();
			if (model instanceof IWrapModel && !(model instanceof IComponentInheritedModel)){
				model = ((IWrapModel<?>)model).getWrappedModel();
			}
			if (model instanceof IComponentInheritedModel){
				foundModel = ((IComponentInheritedModel<?>)model).wrapOnInheritance(this);
				setFlag(FLAG_INHERITABLE_MODEL, true);
				break;
			}
		}
		return foundModel;
	}
	protected final void internalOnAttach(){
	}
	protected final void internalOnDetach(){
	}
	protected void internalOnModelChanged(){
	}
	protected final void markAttached(boolean attached){
		setFlag(FLAG_ATTACHED, attached);
	}
	protected final boolean isAttached(){
		return getFlag(FLAG_ATTACHED);
	}
	protected boolean isBehaviorAccepted(final IBehavior behavior){
		if ((behavior instanceof AttributeModifier) &&(getFlag(FLAG_IGNORE_ATTRIBUTE_MODIFIER) != false)){
			return false;
		}
		return behavior.isEnabled(this);
	}
	protected final boolean isIgnoreAttributeModifier(){
		return this.getFlag(FLAG_IGNORE_ATTRIBUTE_MODIFIER);
	}
	protected MarkupStream locateMarkupStream(){
		return new MarkupFragmentFinder().find(this);
	}
	protected void onAfterRender(){
		setFlag(FLAG_AFTER_RENDERING, false);
	}
	protected final void onAttach(){
	}
	protected void onBeforeRender(){
		setFlag(FLAG_PREPARED_FOR_RENDER, true);
		onBeforeRenderChildren();
		setFlag(FLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, true);
	}
	protected boolean callOnBeforeRenderIfNotVisible(){
		return false;
	}
	protected final void onBeginRequest(){
		throw new UnsupportedOperationException();
	}
	protected void onComponentTag(final ComponentTag tag){
		if (getFlag(FLAG_OUTPUT_MARKUP_ID)){
			tag.put(MARKUP_ID_ATTR_NAME, getMarkupId());
		}
		if (getApplication().getDebugSettings().isOutputComponentPath()){
			String path = getPageRelativePath();
			path = path.replace(""_"", ""__"");
			path = path.replace("":"", ""_"");
			tag.put(""wicketpath"", path);
		}
	}
	protected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag){
	}
	protected void onDetach(){
		setFlag(FLAG_DETACHING, false);
	}
	void initialize(){
		fireInitialize();
	}
	final void fireInitialize(){
		if (!getFlag(FLAG_INITIALIZED)){
			setFlag(FLAG_INITIALIZED, true);
			setFlag(FLAG_INITIALIZE_SUPER_CALL_VERIFIED, false);
			onInitialize();
			if (!getFlag(FLAG_INITIALIZE_SUPER_CALL_VERIFIED)){
				throw new IllegalStateException(Component.class.getName() +"" has not been properly initialized. Something in the hierarchy of "" +getClass().getName() +"" has not called super.onInitialize() in the override of onInitialize() method"");
			}
			setFlag(FLAG_INITIALIZE_SUPER_CALL_VERIFIED, false);
			getApplication().fireComponentInitializationListeners(this);
		}
	}
	protected void onConfigure(){
	}
	protected void onInitialize(){
		setFlag(FLAG_INITIALIZE_SUPER_CALL_VERIFIED, true);
	}
	protected void onRemove(){
		setFlag(FLAG_REMOVING_FROM_HIERARCHY, false);
	}
	protected final void onEndRequest(){
		throw new UnsupportedOperationException();
	}
	protected void onModelChanged(){
	}
	protected void onModelChanging(){
	}
	protected abstract void onRender(final MarkupStream markupStream);
	protected final void renderComponentTag(ComponentTag tag){
		final boolean ajaxRequest = getRequest() instanceof WebRequest &&((WebRequest)getRequest()).isAjax();
		final boolean stripWicketTags = ajaxRequest ||Application.get().getMarkupSettings().getStripWicketTags();
		if ((tag instanceof WicketTag) && !tag.isClose() &&!getFlag(FLAG_IGNORE_ATTRIBUTE_MODIFIER)){
			if (getFlag(FLAG_OUTPUT_MARKUP_ID)){
				log.warn(String.format(""Markup id set on a component that is usually not rendered into markup. ""+ ""Markup id: %s, component id: %s, component tag: %s."", getMarkupId(),getId(), tag.getName()));
			}
			if (getFlag(FLAG_PLACEHOLDER)){
				log.warn(String.format(""Placeholder tag set on a component that is usually not rendered into markup. ""+ ""Component id: %s, component tag: %s."", getId(), tag.getName()));
			}
		}
		if (!(tag instanceof WicketTag) || !stripWicketTags){
			List<IBehavior> behaviors = getBehaviors();
			if ((behaviors != null) && !behaviors.isEmpty() && !tag.isClose() &&(isIgnoreAttributeModifier() == false)){
				tag = tag.mutable();
				for (IBehavior behavior : behaviors){
					if (isBehaviorAccepted(behavior)){
						behavior.onComponentTag(this, tag);
					}
				}
			}
			if (tag.hasBehaviors()){
				Iterator<? extends IBehavior> tagBehaviors = tag.getBehaviors();
				while (tagBehaviors.hasNext()){
					final IBehavior behavior = tagBehaviors.next();
					if (behavior.isEnabled(this)){
						behavior.onComponentTag(this, tag);
					}
					behavior.detach(this);
				}
			}
			tag.writeOutput(getResponse(), stripWicketTags, findMarkupStream().getWicketNamespace());
		}
	}
	protected final void replaceComponentTagBody(final MarkupStream markupStream,final ComponentTag tag, final CharSequence body){
		ComponentTag markupOpenTag = null;
		if (tag.isOpen()){
			markupStream.setCurrentIndex(markupStream.getCurrentIndex() - 1);
			markupOpenTag = markupStream.getTag();
			markupStream.next();
			if (markupOpenTag.isOpen()){
				markupStream.skipRawMarkup();
			}
		}
		if (body != null){
			getResponse().write(body);
		}
		if (tag.isOpen()){
			if ((markupOpenTag != null) && markupOpenTag.isOpen() && !markupStream.atCloseTag()){
				markupStream.throwMarkupException(""Expected close tag for '"" + markupOpenTag +""' Possible attempt to embed component(s) '"" + markupStream.get() +""' in the body of this component which discards its body"");
			}
		}
	}
	protected final void setAuto(final boolean auto){
		setFlag(FLAG_AUTO, auto);
	}
	protected final void setFlag(final int flag, final boolean set){
		if (set){
			flags |= flag;
		}
		else{
			flags &= ~flag;
		}
	}
	protected final void setFlag(final short flag, final boolean set){
		setFlag((int)flag, set);
	}
	protected final Component setIgnoreAttributeModifier(final boolean ignore){
		this.setFlag(FLAG_IGNORE_ATTRIBUTE_MODIFIER, ignore);
		return this;
	}
	protected void setMarkupStream(final MarkupStream markupStream){
	}
	protected final <V> IModel<V> wrap(final IModel<V> model){
		if (model instanceof IComponentAssignedModel){
			return ((IComponentAssignedModel<V>)model).wrapOnAssignment(this);
		}
		return model;
	}
	void detachChildren(){
	}
	void removeChildren(){
	}
	Component get(final String path){
		if (path.equals("""")){
			return this;
		}
		throw new IllegalArgumentException(exceptionMessage(""Component is not a container and so does "" + ""not contain the path "" +path));
	}
	final boolean hasMarkupIdMetaData(){
		return getMarkupId() != null;
	}
	void internalMarkRendering(boolean setRenderingFlag){
		if (setRenderingFlag){
			setFlag(FLAG_PREPARED_FOR_RENDER, false);
			setFlag(FLAG_RENDERING, true);
		}
	}
	final boolean isAuto(){
		for (Component current = this;
		 current != null;
		 current = current.getParent()){
			if (current.getFlag(FLAG_AUTO)){
				return true;
			}
		}
		return false;
	}
	boolean isPreparedForRender(){
		return getFlag(FLAG_PREPARED_FOR_RENDER);
	}
	void onAfterRenderChildren(){
	}
	void onBeforeRenderChildren(){
	}
	final void renderClosingComponentTag(final MarkupStream markupStream,final ComponentTag openTag, final boolean renderTagOnly){
		if (openTag.isOpen()){
			if (markupStream.atCloseTag() && markupStream.getTag().closes(openTag)){
				ComponentTag closeTag = markupStream.getTag();
				if (openTag.getNameChanged()){
					closeTag = closeTag.mutable();
					closeTag.setName(openTag.getName());
					closeTag.setNamespace(openTag.getNamespace());
				}
				if (renderTagOnly == false){
					renderComponentTag(closeTag);
				}
				markupStream.next();
			}
			else{
				if (openTag.requiresCloseTag()){
					markupStream.throwMarkupException(""Expected close tag for "" + openTag);
				}
			}
		}
	}
	final void setId(final String id){
		if (!(this instanceof Page)){
			if (Strings.isEmpty(id)){
				throw new WicketRuntimeException(""Null or empty component ID's are not allowed."");
			}
		}
		if ((id != null) && (id.indexOf(':') != -1)){
			throw new WicketRuntimeException(""The component ID must not contain ':' chars."");
		}
		this.id = id;
	}
	final void setParent(final MarkupContainer parent){
		if (this.parent != null && log.isDebugEnabled()){
			log.debug(""Replacing parent "" + this.parent + "" with "" + parent);
		}
		this.parent = parent;
	}
	final void setRenderAllowed(boolean renderAllowed){
		setFlag(FLAG_IS_RENDER_ALLOWED, renderAllowed);
	}
	void setRenderAllowed(){
		setRenderAllowed(isActionAuthorized(RENDER));
	}
	public final Component setVisibilityAllowed(boolean allowed){
		setFlag(FLAG_VISIBILITY_ALLOWED, allowed);
		return this;
	}
	public final boolean isVisibilityAllowed(){
		return getFlag(FLAG_VISIBILITY_ALLOWED);
	}
	public final boolean determineVisibility(){
		return isVisible() && isRenderAllowed() && isVisibilityAllowed();
	}
	private void writeObject(java.io.ObjectOutputStream s) throws IOException{
		if (this instanceof Page){
			((Page)this).writePageObject(s);
		}
		else{
			s.defaultWriteObject();
		}
	}
	private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException{
		if (this instanceof Page){
			((Page)this).readPageObject(s);
		}
		else{
			s.defaultReadObject();
		}
	}
	public final boolean isEnabledInHierarchy(){
		Boolean state = getMetaData(ENABLED_IN_HIERARCHY_CACHE_KEY);
		if (state == null){
			Component parent = getParent();
			if (parent != null && !parent.isEnabledInHierarchy()){
				state = false;
			}
			else{
				state = isEnabled() && isEnableAllowed();
			}
			setMetaData(ENABLED_IN_HIERARCHY_CACHE_KEY, state);
		}
		return state;
	}
}",0,0,0,0
"public RecordWriter getRecordWriter(FileSystem fs, JobConf job, String name, Progressable progress) throws IOException {
	 this.urlNormalizer = new UrlNormalizerFactory(job).getNormalizer();
	 this.filters = new URLFilters(job);
	 this.scfilters = new ScoringFilters(job);
	 final float interval = job.getFloat(""db.default.fetch.interval"", 30f);
	 final boolean ignoreExternalLinks = job.getBoolean(""db.ignore.external.links"", false);
	 Path text = new Path(new Path(job.getOutputPath(), ParseText.DIR_NAME), name);
	 Path data = new Path(new Path(job.getOutputPath(), ParseData.DIR_NAME), name);
	 Path crawl = new Path(new Path(job.getOutputPath(), CrawlDatum.PARSE_DIR_NAME), name);
	 final MapFile.Writer textOut = new MapFile.Writer(fs, text.toString(), UTF8.class, ParseText.class);
	 final MapFile.Writer dataOut = new MapFile.Writer(fs, data.toString(), UTF8.class,ParseData.class,true);
	 final SequenceFile.Writer crawlOut = new SequenceFile.Writer(fs, crawl, UTF8.class, CrawlDatum.class);
	 return new RecordWriter() {
		 public void write(WritableComparable key, Writable value) throws IOException {
			 Parse parse = (Parse)value;
			 String fromUrl = key.toString();
			 String fromHost = null;
			 String toHost = null;
			 textOut.append(key, new ParseText(parse.getText()));
			 ParseData parseData = parse.getData();
			 String sig = parseData.getContentMeta().get(Fetcher.SIGNATURE_KEY);
			 if (sig != null) {
				 byte[] signature = StringUtil.fromHexString(sig);
				 if (signature != null) {
					 CrawlDatum d = new CrawlDatum(CrawlDatum.STATUS_SIGNATURE, 0.0f);
					 d.setSignature(signature);
					 crawlOut.append(key, d);
				 }
			 }
			 Outlink[] links = parseData.getOutlinks();
			 if (ignoreExternalLinks) {
				 try {
					 fromHost = new URL(fromUrl).getHost().toLowerCase();
				 }
				 catch (MalformedURLException e) {
					 fromHost = null;
				 }
			 }
			 else {
				 fromHost = null;
			 }
			 String[] toUrls = new String[links.length];
			 int validCount = 0;
			 for (int i = 0;
			 i < links.length;
			 i++) {
				 String toUrl = links[i].getToUrl();
				 try {
					 toUrl = urlNormalizer.normalize(toUrl);
					 toUrl = filters.filter(toUrl);
				 }
				 catch (Exception e) {
					 toUrl = null;
				 }
				 if (toUrl != null) validCount++;
				 toUrls[i] = toUrl;
			 }
			 CrawlDatum adjust = null;
			 for (int i = 0;
			 i < toUrls.length;
			 i++) {
				 if (toUrls[i] == null) continue;
				 if (ignoreExternalLinks) {
					 try {
						 toHost = new URL(toUrls[i]).getHost().toLowerCase();
					 }
					 catch (MalformedURLException e) {
						 toHost = null;
					 }
					 if (toHost == null || !toHost.equals(fromHost)) {
						 continue;
					 }
				 }
				 CrawlDatum target = new CrawlDatum(CrawlDatum.STATUS_LINKED, interval);
				 UTF8 targetUrl = new UTF8(toUrls[i]);
				 adjust = null;
				 try {
					 adjust = scfilters.distributeScoreToOutlink((UTF8)key, targetUrl, parseData, target, null, links.length, validCount);
				 }
				 catch (ScoringFilterException e) {
					 if (LOG.isWarnEnabled()) {
						 LOG.warn(""Cannot distribute score from "" + key + "" to "" + targetUrl + "" - skipped ("" + e.getMessage());
					 }
					 continue;
				 }
				 crawlOut.append(targetUrl, target);
				 if (adjust != null) crawlOut.append(key, adjust);
			 }
			 dataOut.append(key, parseData);
		 }
		 public void close(Reporter reporter) throws IOException {
			 textOut.close();
			 dataOut.close();
			 crawlOut.close();
		 }
	 }
	;
 }",0,0,1,0
"public boolean prepare() throws IOException {
	 if (!super.prepare()) {
		 return false;
	 }
	 this.mapOutputFile.removeAll(reduceTask.getTaskId());
	 final int numOutputs = reduceTask.getNumMaps();
	 List neededOutputs = new ArrayList(numOutputs);
	 List knownOutputs = new ArrayList(100);
	 int numInFlight = 0, numCopied = 0;
	 int lowThreshold = numCopiers*2;
	 long bytesTransferred = 0;
	 DecimalFormat mbpsFormat = new DecimalFormat(""0.00"");
	 Random backoff = new Random();
	 final Progress copyPhase = getTask().getProgress().phase();
	 for (int i = 0;
	 i < numOutputs;
	 i++) {
		 neededOutputs.add(new Integer(i));
		 copyPhase.addPhase();
	 }
	 InterTrackerProtocol jobClient = getTracker().getJobClient();
	 copiers = new MapOutputCopier[numCopiers];
	 for (int i=0;
	 i < copiers.length;
	 i++) {
		 copiers[i] = new MapOutputCopier();
		 copiers[i].start();
	 }
	 long startTime = System.currentTimeMillis();
	 long currentTime = startTime;
	 while (!killed && numCopied < numOutputs) {
		 LOG.info(reduceTask.getTaskId() + "" Need "" + (numOutputs-numCopied) + "" map output(s)"");
		 if (!neededOutputs.isEmpty()) {
			 LOG.info(reduceTask.getTaskId() + "" Need "" + neededOutputs.size() + "" map output location(s)"");
			 try {
				 MapOutputLocation[] locs = queryJobTracker(neededOutputs, jobClient);
				 for (int i=0;
				 i < locs.length;
				 i++) {
					 neededOutputs.remove(new Integer(locs[i].getMapId()));
					 knownOutputs.add(locs[i]);
				 }
				 LOG.info(reduceTask.getTaskId() + "" Got "" + (locs == null ? 0 : locs.length) + "" map outputs from jobtracker"");
			 }
			 catch (IOException ie) {
				 LOG.warn(reduceTask.getTaskId() + "" Problem locating map outputs: "" + StringUtils.stringifyException(ie));
			 }
		 }
		 int numKnown = knownOutputs.size(), numScheduled = 0;
		 int numSlow = 0, numDups = 0;
		 LOG.info(reduceTask.getTaskId() + "" Got "" + numKnown + "" known map output location(s);
		 scheduling..."");
		 synchronized (scheduledCopies) {
			 ListIterator locIt = knownOutputs.listIterator();
			 currentTime = System.currentTimeMillis();
			 while (locIt.hasNext()) {
				 MapOutputLocation loc = (MapOutputLocation)locIt.next();
				 Long penaltyEnd = (Long)penaltyBox.get(loc.getHost());
				 boolean penalized = false, duplicate = false;
				 if (penaltyEnd != null && currentTime < penaltyEnd.longValue()) {
					 penalized = true;
					 numSlow++;
				 }
				 if (uniqueHosts.contains(loc.getHost())) {
					 duplicate = true;
					 numDups++;
				 }
				 if (!penalized && !duplicate) {
					 uniqueHosts.add(loc.getHost());
					 scheduledCopies.add(loc);
					 locIt.remove();
					 numInFlight++;
					 numScheduled++;
				 }
			 }
			 scheduledCopies.notifyAll();
		 }
		 LOG.info(reduceTask.getTaskId() + "" Scheduled "" + numScheduled + "" of "" + numKnown + "" known outputs ("" + numSlow + "" slow hosts and "" + numDups + "" dup hosts)"");
		 try {
			 if (numInFlight == 0 && numScheduled == 0) {
				 getTask().reportProgress(getTracker());
				 Thread.sleep(5000);
			 }
		 }
		 catch (InterruptedException e) {
		 }
		 while (!killed && numInFlight > 0) {
			 LOG.debug(reduceTask.getTaskId() + "" numInFlight = "" + numInFlight);
			 CopyResult cr = getCopyResult();
			 if (cr != null) {
				 if (cr.getSuccess()) {
					 numCopied++;
					 bytesTransferred += cr.getSize();
					 long secsSinceStart = (System.currentTimeMillis()-startTime)/1000+1;
					 float mbs = ((float)bytesTransferred)/(1024*1024);
					 float transferRate = mbs/secsSinceStart;
					 copyPhase.startNextPhase();
					 copyPhase.setStatus(""copy ("" + numCopied + "" of "" + numOutputs + "" at "" + mbpsFormat.format(transferRate) + "" MB/s)"");
					 getTask().reportProgress(getTracker());
				 }
				 else {
					 neededOutputs.add(new Integer(cr.getMapId()));
					 currentTime = System.currentTimeMillis();
					 long nextContact = currentTime + 60 * 1000 + backoff.nextInt(maxBackoff*1000);
					 penaltyBox.put(cr.getHost(), new Long(nextContact));
					 LOG.warn(reduceTask.getTaskId() + "" adding host "" + cr.getHost() + "" to penalty box, next contact in "" + ((nextContact-currentTime)/1000) + "" seconds"");
					 ListIterator locIt = knownOutputs.listIterator();
					 while (locIt.hasNext()) {
						 MapOutputLocation loc = (MapOutputLocation)locIt.next();
						 if (cr.getHost().equals(loc.getHost())) {
							 locIt.remove();
							 neededOutputs.add(new Integer(loc.getMapId()));
						 }
					 }
				 }
				 uniqueHosts.remove(cr.getHost());
				 numInFlight--;
			 }
			 if (numInFlight < lowThreshold && (numOutputs-numCopied) > PROBE_SAMPLE_SIZE) {
				 break;
			 }
		 }
	 }
	 synchronized (copiers) {
		 synchronized (scheduledCopies) {
			 for (int i=0;
			 i < copiers.length;
			 i++) {
				 copiers[i].interrupt();
				 copiers[i] = null;
			 }
		 }
	 }
	 return numCopied == numOutputs && !killed;
 }",0,0,1,0
"public class TestNewPlanLogToPhyTranslationVisitor {
	 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
	 private PhysicalPlan translatePlan(OperatorPlan plan) throws IOException {
		 LogToPhyTranslationVisitor visitor = new LogToPhyTranslationVisitor(plan);
		 visitor.visit();
		 return visitor.getPhysicalPlan();
	 }
	 private LogicalPlan buildPlan(String query) throws Exception{
		 PigServer pigServer = new PigServer( pc );
		 return Util.buildLp(pigServer, query);
	 }
	 public void setUp() throws Exception {
		 LogicalExpression.resetNextUid();
	 }
	 public void testSimplePlan() throws Exception {
		 String query = (""a = load 'd.txt';
		"" + ""b = filter a by $0==NULL;
		"" + ""store b into 'empty';
		"");
		 org.apache.pig.newplan.logical.relational.LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals( 3, phyPlan.size() );
		 assertEquals( 1, phyPlan.getRoots().size() );
		 assertEquals( 1, phyPlan.getLeaves().size() );
		 PhysicalOperator load = phyPlan.getRoots().get(0);
		 assertEquals( POLoad.class, load.getClass() );
		 assertTrue( ((POLoad)load).getLFile().getFileName().contains(""d.txt"") );
		 PhysicalOperator fil = phyPlan.getSuccessors(load).get(0);
		 assertEquals( POFilter.class, fil.getClass() );
		 PhysicalPlan filPlan = ((POFilter)fil).getPlan();
		 List<PhysicalOperator> roots = filPlan.getRoots();
		 Collections.sort(roots);
		 assertEquals( 2, roots.size() );
		 assertEquals( 1, filPlan.getLeaves().size() );
		 PhysicalOperator eq = filPlan.getLeaves().get(0);
		 assertEquals( EqualToExpr.class, eq.getClass() );
		 PhysicalOperator prj1 = roots.get(0);
		 assertEquals( POProject.class, prj1.getClass() );
		 assertEquals( 0, ((POProject)prj1).getColumn() );
		 PhysicalOperator constExp = roots.get(1);
		 assertEquals( ConstantExpression.class, constExp.getClass() );
		 assertEquals( null, ((ConstantExpression)constExp).getValue() );
		 PhysicalOperator stor = phyPlan.getSuccessors(fil).get(0);
		 assertEquals( POStore.class, stor.getClass() );
		 assertTrue( ((POStore)stor).getSFile().getFileName().contains(""empty""));
	 }
	 public void testJoinPlan() throws Exception {
		 String query = (""a = load 'd1.txt' as (id, c);
		"" + ""b = load 'd2.txt'as (id, c);
		"" + ""c = join a by id, b by c;
		"" + ""d = filter c by a::id==NULL AND b::c==NULL;
		"" + ""store d into 'empty';
		"");
		 LogicalPlan newPlan = buildPlan(query);
		 PhysicalPlan physicalPlan = translatePlan(newPlan);
		 assertEquals(9, physicalPlan.size());
		 List<PhysicalOperator> roots = physicalPlan.getRoots();
		 Collections.sort(roots);
		 assertEquals(roots.size(), 2);
		 PhysicalOperator LoR = (PhysicalOperator)physicalPlan.getSuccessors(roots.get(0)).get(0);
		 assertEquals( POLocalRearrange.class, LoR.getClass() );
		 POLocalRearrange Lor = (POLocalRearrange) LoR;
		 PhysicalOperator prj3 = Lor.getPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj3.getClass() );
		 assertEquals(0, ((POProject)prj3).getColumn() );
		 PhysicalOperator inp1 = Lor.getInputs().get(0);
		 assertEquals( POLoad.class, inp1.getClass() );
		 assertTrue( ((POLoad)inp1).getLFile().getFileName().contains(""d1.txt"") );
		 PhysicalOperator LoR1 = (PhysicalOperator)physicalPlan.getSuccessors(roots.get(1)).get(0);
		 assertEquals( POLocalRearrange.class, LoR1.getClass() );
		 POLocalRearrange Lor1 = (POLocalRearrange) LoR1;
		 PhysicalOperator prj4 = Lor1.getPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj4.getClass() );
		 assertEquals(1, ((POProject)prj4).getColumn() );
		 PhysicalOperator inp2 = Lor1.getInputs().get(0);
		 assertEquals( POLoad.class, inp2.getClass() );
		 assertTrue( ((POLoad)inp2).getLFile().getFileName().contains(""d2.txt"") );
		 PhysicalOperator GoR = (PhysicalOperator)physicalPlan.getSuccessors(LoR).get(0);
		 assertEquals( POGlobalRearrange.class, GoR.getClass() );
		 PhysicalOperator Pack = (PhysicalOperator)physicalPlan.getSuccessors(GoR).get(0);
		 assertEquals( POPackage.class, Pack.getClass() );
		 PhysicalOperator ForE = (PhysicalOperator)physicalPlan.getSuccessors(Pack).get(0);
		 assertEquals( POForEach.class, ForE.getClass() );
		 PhysicalOperator prj5 = ((POForEach)ForE).getInputPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj5.getClass() );
		 assertEquals( 1, ((POProject)prj5).getColumn() );
		 PhysicalOperator prj6 = ((POForEach)ForE).getInputPlans().get(1).getLeaves().get(0);
		 assertEquals( POProject.class, prj6.getClass() );
		 assertEquals( 2, ((POProject)prj6).getColumn() );
		 PhysicalOperator fil = (PhysicalOperator)physicalPlan.getSuccessors(ForE).get(0);
		 assertEquals( POFilter.class, fil.getClass() );
		 PhysicalPlan filPlan = ((POFilter)fil).getPlan();
		 List<PhysicalOperator> filRoots = filPlan.getRoots();
		 assertEquals(4, filRoots.size());
		 Collections.sort(filRoots);
		 assertEquals( ConstantExpression.class, filRoots.get(1).getClass() );
		 ConstantExpression ce1 = (ConstantExpression) filRoots.get(1);
		 assertEquals( null, ce1.getValue() );
		 assertEquals( ConstantExpression.class, filRoots.get(3).getClass() );
		 ConstantExpression ce2 = (ConstantExpression) filRoots.get(3);
		 assertEquals( null, ce2.getValue() );
		 assertEquals( POProject.class, filRoots.get(0).getClass() );
		 POProject prj1 = (POProject) filRoots.get(0);
		 assertEquals( 0, prj1.getColumn() );
		 assertEquals( POProject.class, filRoots.get(2).getClass() );
		 POProject prj2 = (POProject) filRoots.get(2);
		 assertEquals( 3, prj2.getColumn() );
		 PhysicalOperator stor = (PhysicalOperator)physicalPlan.getSuccessors(fil).get(0);
		 assertEquals( POStore.class, stor.getClass() );
		 assertTrue( ((POStore)stor).getSFile().getFileName().contains(""empty"") );
	 }
	 public void testMultiStore() throws Exception {
		 String query = (""a = load 'd1.txt' as (id, c);
		"" + ""b = load 'd2.txt'as (id, c);
		"" + ""c = load 'd3.txt' as (id, c);
		"" + ""d = join a by id, b by c;
		"" + ""e = filter d by a::id==NULL AND b::c==NULL;
		"" + ""f = join e by b::c, c by id;
		"" + ""g = filter f by b::id==NULL AND c::c==NULL;
		"" + ""store g into 'empty2';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals(16, phyPlan.size());
		 List<PhysicalOperator> phyPlanRoots = phyPlan.getRoots();
		 Collections.sort(phyPlanRoots);
		 assertEquals(phyPlanRoots.size(), 3);
		 assertEquals(phyPlan.getLeaves().size(), 1 );
		 PhysicalOperator LoR = (PhysicalOperator)phyPlan.getSuccessors(phyPlanRoots.get(2)).get(0);
		 assertEquals( POLocalRearrange.class, LoR.getClass() );
		 POLocalRearrange Lor = (POLocalRearrange) LoR;
		 PhysicalOperator prj1 = Lor.getPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj1.getClass() );
		 assertEquals(0, ((POProject)prj1).getColumn() );
		 PhysicalOperator inp1 = Lor.getInputs().get(0);
		 assertEquals( POLoad.class, inp1.getClass() );
		 assertTrue( ((POLoad)inp1).getLFile().getFileName().contains(""d3.txt"") );
		 PhysicalOperator LoR1 = (PhysicalOperator)phyPlan.getSuccessors(phyPlanRoots.get(0)).get(0);
		 assertEquals( POLocalRearrange.class, LoR1.getClass() );
		 POLocalRearrange Lor1 = (POLocalRearrange) LoR1;
		 PhysicalOperator prj2 = Lor1.getPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj2.getClass() );
		 assertEquals(0, ((POProject)prj2).getColumn() );
		 PhysicalOperator inp2 = Lor1.getInputs().get(0);
		 assertEquals( POLoad.class, inp2.getClass() );
		 assertTrue( ((POLoad)inp2).getLFile().getFileName().contains(""d1.txt"") );
		 PhysicalOperator GoR = (PhysicalOperator)phyPlan.getSuccessors(LoR).get(0);
		 assertEquals( POGlobalRearrange.class, GoR.getClass() );
		 PhysicalOperator Pack = (PhysicalOperator)phyPlan.getSuccessors(GoR).get(0);
		 assertEquals( POPackage.class, Pack.getClass() );
		 PhysicalOperator LoR2 = (PhysicalOperator)phyPlan.getSuccessors(phyPlanRoots.get(1)).get(0);
		 assertEquals( POLocalRearrange.class, LoR2.getClass() );
		 POLocalRearrange Lor2 = (POLocalRearrange) LoR2;
		 PhysicalOperator prj3 = Lor2.getPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj3.getClass() );
		 assertEquals(1, ((POProject)prj3).getColumn() );
		 PhysicalOperator inp3 = Lor2.getInputs().get(0);
		 assertEquals( POLoad.class, inp3.getClass() );
		 assertTrue( ((POLoad)inp3).getLFile().getFileName().contains(""d2.txt"") );
		 PhysicalOperator GoR2 = (PhysicalOperator)phyPlan.getSuccessors(LoR2).get(0);
		 assertEquals( POGlobalRearrange.class, GoR2.getClass() );
		 PhysicalOperator Pack2 = (PhysicalOperator)phyPlan.getSuccessors(GoR2).get(0);
		 assertEquals( POPackage.class, Pack2.getClass() );
		 PhysicalOperator ForE = (PhysicalOperator)phyPlan.getSuccessors(Pack).get(0);
		 assertEquals( POForEach.class, ForE.getClass() );
		 PhysicalOperator prj4 = ((POForEach)ForE).getInputPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj4.getClass() );
		 assertEquals( 1, ((POProject)prj4).getColumn() );
		 PhysicalOperator prj5 = ((POForEach)ForE).getInputPlans().get(1).getLeaves().get(0);
		 assertEquals( POProject.class, prj5.getClass() );
		 assertEquals( 2, ((POProject)prj5).getColumn() );
		 PhysicalOperator ForE2 = (PhysicalOperator)phyPlan.getSuccessors(Pack2).get(0);
		 assertEquals( POForEach.class, ForE2.getClass() );
		 PhysicalOperator prj6 = ((POForEach)ForE2).getInputPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj6.getClass() );
		 assertEquals( 1, ((POProject)prj6).getColumn() );
		 PhysicalOperator prj7 = ((POForEach)ForE2).getInputPlans().get(1).getLeaves().get(0);
		 assertEquals( POProject.class, prj7.getClass() );
		 assertEquals( 2, ((POProject)prj7).getColumn() );
		 PhysicalOperator fil = (PhysicalOperator)phyPlan.getSuccessors(ForE).get(0);
		 assertEquals( POFilter.class, fil.getClass() );
		 PhysicalPlan filPlan = ((POFilter)fil).getPlan();
		 List<PhysicalOperator> filRoots = filPlan.getRoots();
		 Collections.sort(filRoots);
		 assertEquals( ConstantExpression.class, filRoots.get(1).getClass() );
		 ConstantExpression ce1 = (ConstantExpression) filRoots.get(1);
		 assertEquals( null, ce1.getValue() );
		 assertEquals( ConstantExpression.class, filRoots.get(3).getClass() );
		 ConstantExpression ce2 = (ConstantExpression) filRoots.get(3);
		 assertEquals( null, ce2.getValue() );
		 assertEquals( POProject.class, filRoots.get(2).getClass() );
		 POProject prj8 = (POProject) filRoots.get(2);
		 assertEquals( 5, prj8.getColumn() );
		 assertEquals( POProject.class, filRoots.get(0).getClass() );
		 POProject prj9 = (POProject) filRoots.get(0);
		 assertEquals( 2, prj9.getColumn() );
		 PhysicalOperator fil2 = (PhysicalOperator)phyPlan.getSuccessors(ForE2).get(0);
		 assertEquals( POFilter.class, fil2.getClass() );
		 PhysicalOperator LoR3 = (PhysicalOperator)phyPlan.getSuccessors(fil2).get(0);
		 assertEquals( POLocalRearrange.class, LoR3.getClass() );
		 POLocalRearrange Lor3 = (POLocalRearrange) LoR3;
		 PhysicalOperator prj12 = Lor3.getPlans().get(0).getLeaves().get(0);
		 assertEquals( POProject.class, prj12.getClass() );
		 assertEquals(3, ((POProject)prj12).getColumn() );
		 PhysicalPlan filPlan2 = ((POFilter)fil2).getPlan();
		 List<PhysicalOperator> filRoots2 = filPlan2.getRoots();
		 Collections.sort(filRoots2);
		 assertEquals( ConstantExpression.class, filRoots2.get(1).getClass() );
		 ConstantExpression ce3 = (ConstantExpression) filRoots2.get(1);
		 assertEquals( null, ce3.getValue() );
		 assertEquals( ConstantExpression.class, filRoots2.get(3).getClass() );
		 ConstantExpression ce4 = (ConstantExpression) filRoots2.get(3);
		 assertEquals( null, ce4.getValue() );
		 assertEquals( POProject.class, filRoots2.get(2).getClass() );
		 POProject prj10 = (POProject) filRoots2.get(2);
		 assertEquals( 3, prj10.getColumn() );
		 assertEquals( POProject.class, filRoots2.get(0).getClass() );
		 POProject prj11 = (POProject) filRoots2.get(0);
		 assertEquals( 0, prj11.getColumn() );
		 PhysicalOperator stor = (PhysicalOperator)phyPlan.getLeaves().get(0);
		 assertEquals( stor, phyPlan.getSuccessors(fil).get(0));
		 assertEquals( POStore.class, stor.getClass() );
		 assertTrue( ((POStore)stor).getSFile().getFileName().contains(""empty"") );
	 }
	 public void testPlanWithCast() throws Exception {
		 String query = (""a = load 'd.txt' as (id, c);
		"" + ""b = filter a by (int)id==10;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals(3, phyPlan.size());
		 assertEquals(phyPlan.getRoots().size(), 1);
		 assertEquals(phyPlan.getLeaves().size(), 1 );
		 PhysicalOperator load = phyPlan.getRoots().get(0);
		 assertEquals( POLoad.class, load.getClass() );
		 assertTrue( ((POLoad)load).getLFile().getFileName().contains(""d.txt""));
		 PhysicalOperator fil = phyPlan.getSuccessors(load).get(0);
		 assertEquals( POFilter.class, fil.getClass() );
		 PhysicalPlan filPlan = ((POFilter)fil).getPlan();
		 PhysicalOperator equal = filPlan.getLeaves().get(0);
		 assertEquals( EqualToExpr.class, equal.getClass() );
		 assertEquals( DataType.BOOLEAN, ((EqualToExpr)equal).getResultType() );
		 PhysicalOperator constExpr = ((EqualToExpr)equal).getRhs();
		 assertEquals( ConstantExpression.class, constExpr.getClass() );
		 assertEquals( 10, ((ConstantExpression)constExpr).getValue() );
		 PhysicalOperator castExpr = ((EqualToExpr)equal).getLhs();
		 assertEquals( POCast.class, castExpr.getClass() );
		 assertEquals( DataType.INTEGER, ((POCast)castExpr).getResultType() );
		 PhysicalOperator prj = ((POCast)castExpr).getInputs().get(0);
		 assertEquals( POProject.class, prj.getClass() );
		 assertEquals( 0, ((POProject)prj).getColumn() );
		 PhysicalOperator stor = phyPlan.getLeaves().get(0);
		 assertEquals( POStore.class, stor.getClass() );
		 assertTrue( ((POStore)stor).getSFile().getFileName().contains( ""empty"" ) );
	 }
	 public void testPlanWithGreaterThan() throws Exception {
		 String query = (""a = load 'd.txt' as (id, c);
		"" + ""b = filter a by (int)id>10;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals(3, phyPlan.size());
		 assertEquals(phyPlan.getRoots().size(), 1);
		 assertEquals(phyPlan.getLeaves().size(), 1 );
		 PhysicalOperator load = phyPlan.getRoots().get(0);
		 assertEquals( POLoad.class, load.getClass() );
		 assertTrue( ((POLoad)load).getLFile().getFileName().contains(""d.txt""));
		 PhysicalOperator fil = phyPlan.getSuccessors(load).get(0);
		 assertEquals( POFilter.class, fil.getClass() );
		 PhysicalPlan filPlan = ((POFilter)fil).getPlan();
		 PhysicalOperator greaterThan = filPlan.getLeaves().get(0);
		 assertEquals( GreaterThanExpr.class, greaterThan.getClass() );
		 assertEquals( DataType.BOOLEAN, ((GreaterThanExpr)greaterThan).getResultType() );
		 PhysicalOperator constExpr = ((GreaterThanExpr)greaterThan).getRhs();
		 assertEquals( ConstantExpression.class, constExpr.getClass() );
		 assertEquals( 10, ((ConstantExpression)constExpr).getValue() );
		 PhysicalOperator castExpr = ((GreaterThanExpr)greaterThan).getLhs();
		 assertEquals( POCast.class, castExpr.getClass() );
		 assertEquals( DataType.INTEGER, ((POCast)castExpr).getResultType() );
		 PhysicalOperator prj = ((POCast)castExpr).getInputs().get(0);
		 assertEquals( POProject.class, prj.getClass() );
		 assertEquals( 0, ((POProject)prj).getColumn() );
		 PhysicalOperator stor = phyPlan.getLeaves().get(0);
		 assertEquals( POStore.class, stor.getClass() );
		 assertTrue( ((POStore)stor).getSFile().getFileName().contains( ""empty"" ) );
	 }
	 public void testPlanWithLessThan() throws Exception {
		 String query = (""a = load 'd.txt' as (id, c);
		"" + ""b = filter a by (int)id<10;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals(3, phyPlan.size());
		 assertEquals(phyPlan.getRoots().size(), 1);
		 assertEquals(phyPlan.getLeaves().size(), 1 );
		 PhysicalOperator load = phyPlan.getRoots().get(0);
		 assertEquals( POLoad.class, load.getClass() );
		 assertTrue( ((POLoad)load).getLFile().getFileName().contains(""d.txt""));
		 PhysicalOperator fil = phyPlan.getSuccessors(load).get(0);
		 assertEquals( POFilter.class, fil.getClass() );
		 PhysicalPlan filPlan = ((POFilter)fil).getPlan();
		 PhysicalOperator lessThan = filPlan.getLeaves().get(0);
		 assertEquals( LessThanExpr.class, lessThan.getClass() );
		 assertEquals( DataType.BOOLEAN, ((LessThanExpr)lessThan).getResultType() );
		 PhysicalOperator constExpr = ((LessThanExpr)lessThan).getRhs();
		 assertEquals( ConstantExpression.class, constExpr.getClass() );
		 assertEquals( 10, ((ConstantExpression)constExpr).getValue() );
		 PhysicalOperator castExpr = ((LessThanExpr)lessThan).getLhs();
		 assertEquals( POCast.class, castExpr.getClass() );
		 assertEquals( DataType.INTEGER, ((POCast)castExpr).getResultType() );
		 PhysicalOperator prj = ((POCast)castExpr).getInputs().get(0);
		 assertEquals( POProject.class, prj.getClass() );
		 assertEquals( 0, ((POProject)prj).getColumn() );
		 PhysicalOperator stor = phyPlan.getLeaves().get(0);
		 assertEquals( POStore.class, stor.getClass() );
		 assertTrue( ((POStore)stor).getSFile().getFileName().contains( ""empty"" ) );
	 }
	 public void testForeachPlan() throws Exception {
		 String query = (""a = load 'd.txt' as (id, c);
		"" + ""b = foreach a generate id, c;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals(phyPlan.size(), 3);
		 assertEquals(phyPlan.getLeaves().get(0).getClass(), POStore.class);
		 POForEach foreach = (POForEach)phyPlan.getSuccessors(phyPlan.getRoots().get(0)).get(0);
		 assertEquals(foreach.getInputPlans().size(), 2);
		 PhysicalPlan inner = foreach.getInputPlans().get(0);
		 assertEquals(inner.size(), 1);
		 POProject prj = (POProject)inner.getRoots().get(0);
		 assertEquals(prj.getColumn(), 0);
		 assertEquals(prj.getInputs(), null);
		 inner = foreach.getInputPlans().get(1);
		 assertEquals(inner.size(), 1);
		 prj = (POProject)inner.getRoots().get(0);
		 assertEquals(prj.getColumn(), 1);
		 assertEquals(prj.getInputs(), null);
		 Boolean[] flat = foreach.getToBeFlattened().toArray(new Boolean[0]);
		 assertFalse(flat[0]);
		 assertFalse(flat[1]);
	 }
	 public void testForeachPlan2() throws Exception {
		 String query = (""a = load 'd.txt' as (id, c:bag{
		t:(s,v)}
		);
		"" + ""b = foreach a generate id, flatten(c);
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator)newLogicalPlan.getSuccessors(ld).get(0);
		 LogicalSchema ls = fe.getSchema();
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(4, ls.getField(1).uid);
		 assertEquals(5, ls.getField(2).uid);
		 LogicalSchema expected = new LogicalSchema();
		 expected.addField(new LogicalFieldSchema(""id"", null, DataType.BYTEARRAY));
		 expected.addField(new LogicalFieldSchema(""s"", null, DataType.BYTEARRAY));
		 expected.addField(new LogicalFieldSchema(""v"", null, DataType.BYTEARRAY));
		 assertTrue(expected.isEqual(ls));
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals(phyPlan.size(), 3);
		 assertEquals(phyPlan.getLeaves().get(0).getClass(), POStore.class);
		 POForEach foreach = (POForEach)phyPlan.getSuccessors(phyPlan.getRoots().get(0)).get(0);
		 assertEquals(foreach.getInputPlans().size(), 2);
		 PhysicalPlan inner = foreach.getInputPlans().get(0);
		 assertEquals(inner.size(), 1);
		 POProject prj = (POProject)inner.getRoots().get(0);
		 assertEquals(prj.getColumn(), 0);
		 assertEquals(prj.getInputs(), null);
		 inner = foreach.getInputPlans().get(1);
		 assertEquals(inner.size(), 1);
		 prj = (POProject)inner.getRoots().get(0);
		 assertEquals(prj.getColumn(), 1);
		 assertEquals(prj.getInputs(), null);
		 Boolean[] flat = foreach.getToBeFlattened().toArray(new Boolean[0]);
		 assertFalse(flat[0]);
		 assertTrue(flat[1]);
	 }
	 public void testPlanwithPlus() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate a+b;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( AddExpression.class, genExp.getSources().get(0).getClass() );
		 AddExpression add = (AddExpression) genExp.getSources().get(0);
		 assertEquals( ls.getField(0).uid, add.getLhs().getFieldSchema().uid );
		 assertEquals( ls.getField(1).uid, add.getRhs().getFieldSchema().uid );
		 assertTrue( ls.getField(0).uid != add.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != add.getFieldSchema().uid );
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( Add.class, inputPln.getLeaves().get(0).getClass() );
		 Add pAdd = (Add) inputPln.getLeaves().get(0);
		 assertEquals( 2, inputPln.getRoots().size() );
		 assertEquals( POProject.class, pAdd.getLhs().getClass() );
		 assertEquals( POProject.class, pAdd.getRhs().getClass() );
	 }
	 public void testPlanwithSubtract() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate a-b;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( SubtractExpression.class, genExp.getSources().get(0).getClass() );
		 SubtractExpression add = (SubtractExpression) genExp.getSources().get(0);
		 assertEquals( ls.getField(0).uid, add.getLhs().getFieldSchema().uid );
		 assertEquals( ls.getField(1).uid, add.getRhs().getFieldSchema().uid );
		 assertTrue( ls.getField(0).uid != add.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != add.getFieldSchema().uid );
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( Subtract.class, inputPln.getLeaves().get(0).getClass() );
		 Subtract pSubtract = (Subtract) inputPln.getLeaves().get(0);
		 assertEquals( 2, inputPln.getRoots().size() );
		 assertEquals( POProject.class, pSubtract.getLhs().getClass() );
		 assertEquals( POProject.class, pSubtract.getRhs().getClass() );
	 }
	 public void testPlanwithMultiply() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate a*b;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( MultiplyExpression.class, genExp.getSources().get(0).getClass() );
		 MultiplyExpression add = (MultiplyExpression) genExp.getSources().get(0);
		 assertEquals( ls.getField(0).uid, add.getLhs().getFieldSchema().uid );
		 assertEquals( ls.getField(1).uid, add.getRhs().getFieldSchema().uid );
		 assertTrue( ls.getField(0).uid != add.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != add.getFieldSchema().uid );
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( Multiply.class, inputPln.getLeaves().get(0).getClass() );
		 Multiply pMultiply = (Multiply) inputPln.getLeaves().get(0);
		 assertEquals( 2, inputPln.getRoots().size() );
		 assertEquals( POProject.class, pMultiply.getLhs().getClass() );
		 assertEquals( POProject.class, pMultiply.getRhs().getClass() );
	 }
	 public void testPlanwithDivide() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate a/b;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( DivideExpression.class, genExp.getSources().get(0).getClass() );
		 DivideExpression add = (DivideExpression) genExp.getSources().get(0);
		 assertEquals( ls.getField(0).uid, add.getLhs().getFieldSchema().uid );
		 assertEquals( ls.getField(1).uid, add.getRhs().getFieldSchema().uid );
		 assertTrue( ls.getField(0).uid != add.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != add.getFieldSchema().uid );
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( Divide.class, inputPln.getLeaves().get(0).getClass() );
		 Divide pDivide = (Divide) inputPln.getLeaves().get(0);
		 assertEquals( 2, inputPln.getRoots().size() );
		 assertEquals( POProject.class, pDivide.getLhs().getClass() );
		 assertEquals( POProject.class, pDivide.getRhs().getClass() );
	 }
	 public void testPlanwithMod() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate a%b;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( ModExpression.class, genExp.getSources().get(0).getClass() );
		 ModExpression add = (ModExpression) genExp.getSources().get(0);
		 assertEquals( ls.getField(0).uid, add.getLhs().getFieldSchema().uid );
		 assertEquals( ls.getField(1).uid, add.getRhs().getFieldSchema().uid );
		 assertTrue( ls.getField(0).uid != add.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != add.getFieldSchema().uid );
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( Mod.class, inputPln.getLeaves().get(0).getClass() );
		 Mod pMod = (Mod) inputPln.getLeaves().get(0);
		 assertEquals( 2, inputPln.getRoots().size() );
		 assertEquals( POProject.class, pMod.getLhs().getClass() );
		 assertEquals( POProject.class, pMod.getRhs().getClass() );
	 }
	 public void testPlanwithNegative() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate -a;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( NegativeExpression.class, genExp.getSources().get(0).getClass() );
		 NegativeExpression add = (NegativeExpression) genExp.getSources().get(0);
		 assertEquals( ls.getField(0).uid, add.getExpression().getFieldSchema().uid );
		 assertTrue( ls.getField(0).uid != add.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != add.getFieldSchema().uid );
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( PONegative.class, inputPln.getLeaves().get(0).getClass() );
		 PONegative pNegative = (PONegative) inputPln.getLeaves().get(0);
		 assertEquals( 1, inputPln.getRoots().size() );
		 assertEquals( POProject.class, pNegative.getInputs().get(0).getClass() );
	 }
	 public void testPlanwithisNull() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = filter a by a is null;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fil = (LogicalRelationalOperator) newLogicalPlan.getSuccessors( newLogicalPlan.getSources().get(0) ).get(0);
		 assertEquals( LOFilter.class, fil.getClass() );
		 LOFilter filter = (LOFilter)fil;
		 LogicalExpressionPlan filPlan = filter.getFilterPlan();
		 assertEquals( 1, filPlan.getSources().size() );
		 assertEquals( 2, filPlan.size() );
		 assertEquals( 1, filPlan.getSinks().size() );
		 assertEquals( IsNullExpression.class, filPlan.getSources().get(0).getClass() );
		 IsNullExpression isNull = (IsNullExpression)filPlan.getSources().get(0);
		 assertTrue( ls.getField(0).uid != isNull.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != isNull.getFieldSchema().uid );
		 assertEquals( ProjectExpression.class, isNull.getExpression().getClass() );
		 ProjectExpression prj = (ProjectExpression) isNull.getExpression();
		 assertEquals( ls.getField(0).uid, prj.getFieldSchema().uid );
	 }
	 public void testPlanwithisNotNull() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = filter a by a is not null;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fil = (LogicalRelationalOperator) newLogicalPlan.getSuccessors( newLogicalPlan.getSources().get(0) ).get(0);
		 assertEquals( LOFilter.class, fil.getClass() );
		 LOFilter filter = (LOFilter)fil;
		 LogicalExpressionPlan filPlan = filter.getFilterPlan();
		 assertEquals( 1, filPlan.getSources().size() );
		 assertEquals( 3, filPlan.size() );
		 assertEquals( 1, filPlan.getSinks().size() );
		 assertEquals( NotExpression.class, filPlan.getSources().get(0).getClass() );
		 NotExpression notExp = (NotExpression)filPlan.getSources().get(0);
		 assertTrue( ls.getField(0).uid != notExp.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != notExp.getFieldSchema().uid );
		 assertEquals( IsNullExpression.class, notExp.getExpression().getClass() );
		 IsNullExpression isNull = (IsNullExpression)notExp.getExpression();
		 assertTrue( ls.getField(0).uid != isNull.getFieldSchema().uid );
		 assertTrue( ls.getField(1).uid != isNull.getFieldSchema().uid );
		 assertEquals( ProjectExpression.class, isNull.getExpression().getClass() );
		 ProjectExpression prj = (ProjectExpression) isNull.getExpression();
		 assertEquals( ls.getField(0).uid, prj.getFieldSchema().uid );
	 }
	 public void testPlanwithBinCond() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:int);
		"" + ""b = foreach a generate ( a < b ? b : a );
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 1, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp.getSources().size() );
		 assertEquals( BinCondExpression.class, genExp.getSources().get(0).getClass() );
		 BinCondExpression add = (BinCondExpression) genExp.getSources().get(0);
		 assertEquals( LessThanExpression.class, add.getCondition().getClass() );
		 LessThanExpression lessThan = (LessThanExpression) add.getCondition();
		 assertEquals( ProjectExpression.class, lessThan.getLhs().getClass() );
		 ProjectExpression prj1 = ((ProjectExpression)lessThan.getLhs());
		 ProjectExpression prj2 = ((ProjectExpression)lessThan.getRhs());
		 assertEquals( ls.getField(0).uid, prj1.getFieldSchema().uid );
		 assertEquals( ProjectExpression.class, lessThan.getRhs().getClass() );
		 assertEquals( ls.getField(1).uid, prj2.getFieldSchema().uid );
		 assertEquals( ProjectExpression.class, add.getLhs().getClass() );
		 ProjectExpression prj3 = ((ProjectExpression)add.getLhs());
		 assertEquals( ls.getField(1).uid, prj3.getFieldSchema().uid );
		 assertEquals( ProjectExpression.class, add.getRhs().getClass() );
		 ProjectExpression prj4 = ((ProjectExpression)add.getRhs());
		 assertEquals( ls.getField(0).uid, prj4.getFieldSchema().uid );
		 assertEquals( 4, inputPln.getRoots().size() );
		 for( PhysicalOperator p : inputPln.getRoots() ) {
			 assertEquals( POProject.class, p.getClass() );
		 }
		 assertEquals( 1, inputPln.getLeaves().size() );
		 assertEquals( POBinCond.class, inputPln.getLeaves().get(0).getClass() );
		 POBinCond binCond = (POBinCond) inputPln.getLeaves().get(0);
		 assertEquals( POProject.class, binCond.getLhs().getClass() );
		 POProject prj_1 = (POProject)binCond.getLhs();
		 assertEquals( 1, prj_1.getColumn() );
		 assertEquals( POProject.class, binCond.getRhs().getClass() );
		 POProject prj_2 = (POProject) binCond.getRhs();
		 assertEquals( 0, prj_2.getColumn() );
		 assertEquals( LessThanExpr.class, binCond.getCond().getClass() );
		 LessThanExpr lessThan_p = (LessThanExpr) binCond.getCond();
		 assertEquals( POProject.class, lessThan_p.getLhs().getClass() );
		 POProject prj_3 = (POProject) lessThan_p.getLhs();
		 assertEquals( 0, prj_3.getColumn() );
		 assertEquals( POProject.class, lessThan_p.getRhs().getClass() );
		 POProject prj_4 = (POProject) lessThan_p.getRhs();
		 assertEquals( 1, prj_4.getColumn() );
	 }
	 public void testPlanwithUserFunc() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:bag{
		t:tuple(b_a:int,b_b:int)}
		);
		"" + ""b = foreach a generate a,COUNT(b);
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln1 = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 2, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp1 = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp1.getSources().size() );
		 assertEquals( ProjectExpression.class, genExp1.getSources().get(0).getClass() );
		 ProjectExpression prj1 = (ProjectExpression) genExp1.getSources().get(0);
		 assertEquals( ls.getField(0).uid, prj1.getFieldSchema().uid );
		 LogicalExpressionPlan genExp2 = gen.getOutputPlans().get(1);
		 assertEquals( UserFuncExpression.class, genExp2.getSources().get(0).getClass() );
		 assertEquals( ProjectExpression.class, genExp2.getSinks().get(0).getClass() );
		 ProjectExpression prj2 = (ProjectExpression)genExp2.getSinks().get(0);
		 assertEquals( ls.getField(1).uid, prj2.getFieldSchema().uid );
		 assertEquals( 1, inputPln1.getLeaves().size() );
		 assertEquals( 1, inputPln1.getRoots().size() );
		 assertEquals( POProject.class, inputPln1.getLeaves().get(0).getClass() );
		 assertEquals( 0, (( POProject) inputPln1.getLeaves().get(0)).getColumn() );
		 PhysicalPlan inputPln2 = pForEach.getInputPlans().get(1);
		 assertEquals( POUserFunc.class, inputPln2.getLeaves().get(0).getClass() );
		 assertEquals( ""org.apache.pig.builtin.COUNT"", ((POUserFunc) inputPln2.getLeaves().get(0)).getFuncSpec().getClassName() );
		 assertEquals( POProject.class, inputPln2.getRoots().get(0).getClass() );
		 assertEquals( 1, ((POProject)inputPln2.getRoots().get(0)).getColumn() );
	 }
	 public void testPlanwithUserFunc2() throws Exception {
		 String query = (""a = load 'd.txt' as (a:int, b:bag{
		t:tuple(b_a:int,b_b:int)}
		);
		"" + ""b = foreach a generate a,COUNT(b.b_a);
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 LogicalRelationalOperator ld = (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
		 assertEquals( LOLoad.class, ld.getClass() );
		 LOLoad load = (LOLoad)ld;
		 LogicalSchema ls = load.getSchema();
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 PhysicalOperator pFE = phyPlan.getSuccessors( phyPlan.getRoots().get(0) ).get(0);
		 assertEquals( POForEach.class, pFE.getClass() );
		 POForEach pForEach = (POForEach)pFE;
		 PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
		 assertEquals(1, ls.getField(0).uid);
		 assertEquals(2, ls.getField(1).uid);
		 LogicalRelationalOperator fe = (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
		 assertEquals( LOForEach.class, fe.getClass() );
		 LOForEach forEach = (LOForEach)fe;
		 LogicalPlan innerPlan = forEach.getInnerPlan();
		 assertEquals( 1, innerPlan.getSinks().size() );
		 assertEquals( LOGenerate.class, innerPlan.getSinks().get(0).getClass() );
		 LOGenerate gen = (LOGenerate)innerPlan.getSinks().get(0);
		 assertEquals( 2, gen.getOutputPlans().size() );
		 LogicalExpressionPlan genExp1 = gen.getOutputPlans().get(0);
		 assertEquals( 1, genExp1.getSources().size() );
		 assertEquals( ProjectExpression.class, genExp1.getSources().get(0).getClass() );
		 ProjectExpression prj1 = (ProjectExpression) genExp1.getSources().get(0);
		 assertEquals( ls.getField(0).uid, prj1.getFieldSchema().uid );
		 LogicalExpressionPlan genExp2 = gen.getOutputPlans().get(1);
		 assertEquals( UserFuncExpression.class, genExp2.getSources().get(0).getClass() );
		 assertEquals( ProjectExpression.class, genExp2.getSinks().get(0).getClass() );
		 ProjectExpression prj2 = (ProjectExpression)genExp2.getSinks().get(0);
		 assertEquals( ls.getField(1).uid, prj2.getFieldSchema().uid );
		 assertEquals( DereferenceExpression.class, genExp2.getPredecessors(prj2).get(0).getClass() );
		 assertEquals( 0, (int)((DereferenceExpression)genExp2.getPredecessors(prj2).get(0)).getBagColumns().get(0) );
		 assertEquals( 1, inputPln.getRoots().size() );
		 assertEquals( POProject.class, inputPln.getRoots().get(0).getClass() );
		 assertEquals( 0, ((POProject)inputPln.getRoots().get(0)).getColumn() );
		 PhysicalPlan inputPln2 = pForEach.getInputPlans().get(1);
		 assertEquals( 1, inputPln2.getRoots().size() );
		 assertEquals( POProject.class, inputPln2.getRoots().get(0).getClass() );
		 assertEquals(1, ((POProject)inputPln2.getRoots().get(0)).getColumn() );
		 assertEquals( POUserFunc.class, inputPln2.getLeaves().get(0).getClass() );
		 assertEquals( ""org.apache.pig.builtin.COUNT"", ((POUserFunc)inputPln2.getLeaves().get(0)).getFuncSpec().getClassName() );
		 POProject prj3 = (POProject)inputPln2.getRoots().get(0);
		 assertEquals( POProject.class, inputPln2.getSuccessors(prj3).get(0).getClass() );
		 assertEquals( 0, ((POProject)inputPln2.getSuccessors(prj3).get(0)).getColumn() );
	 }
	 public void testCogroup() throws Exception {
		 String query = (""a = load 'd.txt' as (name:chararray, age:int, gpa:float);
		"" + ""b = group a by name;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals( 1, phyPlan.getRoots().size() );
		 assertEquals( POLoad.class, phyPlan.getRoots().get(0).getClass() );
		 POLoad load = (POLoad)phyPlan.getRoots().get(0);
		 assertEquals( POLocalRearrange.class, phyPlan.getSuccessors(load).get(0).getClass() );
		 POLocalRearrange localR = (POLocalRearrange)phyPlan.getSuccessors(load).get(0);
		 assertEquals( 1, localR.getInputs().size() );
		 assertEquals( 1, localR.getPlans().size() );
		 PhysicalPlan cogroupPlan = localR.getPlans().get(0);
		 assertEquals( 1, cogroupPlan.getLeaves().size() );
		 assertEquals( POProject.class, cogroupPlan.getLeaves().get(0).getClass() );
		 POProject prj = (POProject)cogroupPlan.getLeaves().get(0);
		 assertEquals( 0, prj.getColumn() );
		 assertEquals( DataType.CHARARRAY, prj.getResultType() );
		 assertEquals( POGlobalRearrange.class, phyPlan.getSuccessors(localR).get(0).getClass() );
		 POGlobalRearrange globalR = (POGlobalRearrange)phyPlan.getSuccessors(localR).get(0);
		 assertEquals( DataType.TUPLE, globalR.getResultType() );
		 assertEquals( POPackage.class, phyPlan.getSuccessors(globalR).get(0).getClass() );
		 POPackage pack = (POPackage)phyPlan.getSuccessors(globalR).get(0);
		 assertEquals( DataType.TUPLE, pack.getResultType() );
	 }
	 public void testCogroup2() throws Exception {
		 String query = (""a = load 'd.txt' as (name:chararray, age:int, gpa:float);
		"" + ""b = group a by ( name, age );
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals( 1, phyPlan.getRoots().size() );
		 assertEquals( POLoad.class, phyPlan.getRoots().get(0).getClass() );
		 POLoad load = (POLoad)phyPlan.getRoots().get(0);
		 assertEquals( POLocalRearrange.class, phyPlan.getSuccessors(load).get(0).getClass() );
		 POLocalRearrange localR = (POLocalRearrange)phyPlan.getSuccessors(load).get(0);
		 assertEquals( 1, localR.getInputs().size() );
		 assertEquals( 2, localR.getPlans().size() );
		 PhysicalPlan cogroupPlan = localR.getPlans().get(0);
		 assertEquals( 1, cogroupPlan.getLeaves().size() );
		 assertEquals( POProject.class, cogroupPlan.getLeaves().get(0).getClass() );
		 POProject prj = (POProject)cogroupPlan.getLeaves().get(0);
		 assertEquals( 0, prj.getColumn() );
		 assertEquals( DataType.CHARARRAY, prj.getResultType() );
		 PhysicalPlan cogroupPlan2 = localR.getPlans().get(1);
		 POProject prj2 = (POProject)cogroupPlan2.getLeaves().get(0);
		 assertEquals( 1, prj2.getColumn() );
		 assertEquals( DataType.INTEGER, prj2.getResultType() );
		 assertEquals( POGlobalRearrange.class, phyPlan.getSuccessors(localR).get(0).getClass() );
		 POGlobalRearrange globalR = (POGlobalRearrange)phyPlan.getSuccessors(localR).get(0);
		 assertEquals( DataType.TUPLE, globalR.getResultType() );
		 assertEquals( POPackage.class, phyPlan.getSuccessors(globalR).get(0).getClass() );
		 POPackage pack = (POPackage)phyPlan.getSuccessors(globalR).get(0);
		 assertEquals( DataType.TUPLE, pack.getResultType() );
	 }
	 public void testCogroup3() throws Exception {
		 String query = ""a = load 'd.txt' as (name:chararray, age:int, gpa:float);
		"" + ""b = load 'e.txt' as (name:chararray, age:int, gpa:float);
		"" + ""c = group a by name, b by name;
		"" + ""store c into 'empty';
		"";
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals( 2, phyPlan.getRoots().size() );
		 assertEquals( POLoad.class, phyPlan.getRoots().get(0).getClass() );
		 POLoad load = (POLoad)phyPlan.getRoots().get(0);
		 assertEquals( POLocalRearrange.class, phyPlan.getSuccessors(load).get(0).getClass() );
		 POLocalRearrange localR = (POLocalRearrange)phyPlan.getSuccessors(load).get(0);
		 assertEquals( 1, localR.getPlans().size() );
		 PhysicalPlan cogroupPlan = localR.getPlans().get(0);
		 assertEquals( 1, cogroupPlan.getLeaves().size() );
		 assertEquals( POProject.class, cogroupPlan.getLeaves().get(0).getClass() );
		 POProject prj = (POProject)cogroupPlan.getLeaves().get(0);
		 assertEquals( 0, prj.getColumn() );
		 assertEquals( DataType.CHARARRAY, prj.getResultType() );
		 assertEquals( POGlobalRearrange.class, phyPlan.getSuccessors(localR).get(0).getClass() );
		 POGlobalRearrange globalR = (POGlobalRearrange)phyPlan.getSuccessors(localR).get(0);
		 assertEquals( DataType.TUPLE, globalR.getResultType() );
		 assertEquals( POLoad.class, phyPlan.getRoots().get(1).getClass() );
		 POLoad load2 = (POLoad)phyPlan.getRoots().get(0);
		 assertEquals( POLocalRearrange.class, phyPlan.getSuccessors(load2).get(0).getClass() );
		 POLocalRearrange localR2 = (POLocalRearrange)phyPlan.getSuccessors(load2).get(0);
		 assertEquals( 1, localR2.getPlans().size() );
		 PhysicalPlan cogroupPlan2 = localR2.getPlans().get(0);
		 POProject prj2 = (POProject)cogroupPlan2.getLeaves().get(0);
		 assertEquals( 0, prj2.getColumn() );
		 assertEquals( DataType.CHARARRAY, prj2.getResultType() );
		 assertEquals( POPackage.class, phyPlan.getSuccessors(globalR).get(0).getClass() );
		 POPackage pack = (POPackage)phyPlan.getSuccessors(globalR).get(0);
		 assertEquals( DataType.TUPLE, pack.getResultType() );
	 }
	 public void testCogroup4() throws Exception {
		 String query = ""a = load 'd.txt' as (name:chararray, age:int, gpa:float);
		"" + ""b = load 'e.txt' as (name:chararray, age:int, gpa:float);
		"" + ""c = group a by ( name, age ), b by ( name, age );
		"" + ""store c into 'empty';
		"";
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 PhysicalPlan phyPlan = translatePlan(newLogicalPlan);
		 assertEquals( 2, phyPlan.getRoots().size() );
		 assertEquals( POLoad.class, phyPlan.getRoots().get(0).getClass() );
		 POLoad load = (POLoad)phyPlan.getRoots().get(0);
		 assertEquals( POLocalRearrange.class, phyPlan.getSuccessors(load).get(0).getClass() );
		 POLocalRearrange localR = (POLocalRearrange)phyPlan.getSuccessors(load).get(0);
		 assertEquals( 2, localR.getPlans().size() );
		 PhysicalPlan cogroupPlan = localR.getPlans().get(0);
		 assertEquals( 1, cogroupPlan.getLeaves().size() );
		 assertEquals( POProject.class, cogroupPlan.getLeaves().get(0).getClass() );
		 POProject prj = (POProject)cogroupPlan.getLeaves().get(0);
		 assertEquals( 0, prj.getColumn() );
		 assertEquals( DataType.CHARARRAY, prj.getResultType() );
		 PhysicalPlan cogroupPlan2 = localR.getPlans().get(1);
		 assertEquals( 1, cogroupPlan2.getLeaves().size() );
		 assertEquals( POProject.class, cogroupPlan2.getLeaves().get(0).getClass() );
		 POProject prj2 = (POProject)cogroupPlan2.getLeaves().get(0);
		 assertEquals( 1, prj2.getColumn() );
		 assertEquals( DataType.INTEGER, prj2.getResultType() );
		 assertEquals( POGlobalRearrange.class, phyPlan.getSuccessors(localR).get(0).getClass() );
		 POGlobalRearrange globalR = (POGlobalRearrange)phyPlan.getSuccessors(localR).get(0);
		 assertEquals( DataType.TUPLE, globalR.getResultType() );
		 assertEquals( POLoad.class, phyPlan.getRoots().get(1).getClass() );
		 POLoad load2 = (POLoad)phyPlan.getRoots().get(0);
		 assertEquals( POLocalRearrange.class, phyPlan.getSuccessors(load2).get(0).getClass() );
		 POLocalRearrange localR3 = (POLocalRearrange)phyPlan.getSuccessors(load2).get(0);
		 assertEquals( 2, localR3.getPlans().size() );
		 PhysicalPlan cogroupPlan3 = localR3.getPlans().get(0);
		 POProject prj3 = (POProject)cogroupPlan3.getLeaves().get(0);
		 assertEquals( 0, prj3.getColumn() );
		 assertEquals( DataType.CHARARRAY, prj3.getResultType() );
		 PhysicalPlan cogroupPlan4 = localR3.getPlans().get(1);
		 POProject prj4 = (POProject)cogroupPlan4.getLeaves().get(0);
		 assertEquals( 1, prj4.getColumn() );
		 assertEquals( DataType.INTEGER, prj4.getResultType() );
		 assertEquals( POPackage.class, phyPlan.getSuccessors(globalR).get(0).getClass() );
		 POPackage pack = (POPackage)phyPlan.getSuccessors(globalR).get(0);
		 assertEquals( DataType.TUPLE, pack.getResultType() );
	 }
	 public void testUserDefinedForEachSchema1() throws Exception {
		 String query = (""a = load 'a.txt';
		"" + ""b = foreach a generate $0 as a0, $1 as a1;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 Operator store = newLogicalPlan.getSinks().get(0);
		 LOForEach foreach = (LOForEach)newLogicalPlan.getPredecessors(store).get(0);
		 foreach.getSchema();
		 assertTrue(foreach.getSchema().size()==2);
		 assertTrue(foreach.getSchema().getField(0).alias.equals(""a0""));
		 assertTrue(foreach.getSchema().getField(1).alias.equals(""a1""));
	 }
	 public void testUserDefinedForEachSchema2() throws Exception {
		 String query = (""a = load 'a.txt' as (b:bag{
		}
		);
		"" + ""b = foreach a generate flatten($0) as (a0, a1);
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 Operator store = newLogicalPlan.getSinks().get(0);
		 LOForEach foreach = (LOForEach)newLogicalPlan.getPredecessors(store).get(0);
		 foreach.getSchema();
		 assertTrue(foreach.getSchema().size()==2);
		 assertTrue(foreach.getSchema().getField(0).alias.equals(""a0""));
		 assertTrue(foreach.getSchema().getField(1).alias.equals(""a1""));
	 }
	 public void testCogroupSchema1() throws Exception {
		 String query = (""a = load '1.txt' as (a0, a1);
		"" + ""b = group a by a0;
		"" + ""store b into 'empty';
		"");
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 Operator store = newLogicalPlan.getSinks().get(0);
		 LOCogroup cogroup = (LOCogroup)newLogicalPlan.getPredecessors(store).get(0);
		 LogicalSchema cogroupSchema = cogroup.getSchema();
		 assertEquals(cogroupSchema.getField(1).type, DataType.BAG);
		 assertTrue(cogroupSchema.getField(1).alias.equals(""a""));
		 LogicalSchema bagSchema = cogroupSchema.getField(1).schema;
		 assertEquals(bagSchema.getField(0).type, DataType.TUPLE);
		 assertEquals(bagSchema.getField(0).alias, null);
		 LogicalSchema tupleSchema = bagSchema.getField(0).schema;
		 assertEquals(tupleSchema.size(), 2);
	 }
	 public void testCogroupSchema2() throws Exception {
		 String query = ""a = load '1.txt' as (a0, a1);
		"" + ""b = group a by a0;
		"" + ""c = foreach b generate a.a1;
		"" + ""store c into 'empty';
		"";
		 LogicalPlan newLogicalPlan = buildPlan(query);
		 Operator store = newLogicalPlan.getSinks().get(0);
		 LOForEach foreach = (LOForEach)newLogicalPlan.getPredecessors(store).get(0);
		 LogicalSchema foreachSchema = foreach.getSchema();
		 assertEquals(foreachSchema.getField(0).type, DataType.BAG);
		 LogicalSchema bagSchema = foreachSchema.getField(0).schema;
		 assertEquals(bagSchema.getField(0).type, DataType.TUPLE);
		 assertEquals(bagSchema.getField(0).alias, null);
		 LogicalSchema tupleSchema = bagSchema.getField(0).schema;
		 assertEquals(tupleSchema.size(), 1);
		 assertTrue(tupleSchema.getField(0).alias.equals(""a1""));
	 }
}",1,0,0,0
"private void processAsSubstitutableExport(boolean isFragment, Requirement requirement, List<Capability> capabilities) {
	String namespace = requirement.getNamespace();
	if (!PackageNamespace.PACKAGE_NAMESPACE.equals(namespace)) {
		return;
	}
	Resource resource = requirement.getResource();
	Wiring wiring = wirings.get(resource);
	if (isFragment) {
		List<Wire> fragmentWires = wiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);
		for (Wire fragmentWire : fragmentWires) {
			Resource host = fragmentWire.getProvider();
			processResourceCapabilities(wirings.get(host).getResourceCapabilities(namespace),requirement,capabilities);
		}
	}
	else {
		List<Capability> resourceCapabilities = wiring.getResourceCapabilities(namespace);
		processResourceCapabilities(resourceCapabilities, requirement, capabilities);
	}
}",0,0,1,0
"public void addPresent(PresentSelector selector) {
	 usedMatchingTask = true;
	 super.addPresent(selector);
 }",0,0,0,0
"public interface SessionPersistenceApi {
	 SessionPersistence get();
	 void create( SessionPersistence sessionPersistence);
	 void delete();
}",0,0,0,0
"public class MRBaseForCommonInstructions extends MapReduceBase{
	protected Class<? extends MatrixValue> valueClass;
	protected CachedValueMap cachedValues=new CachedValueMap();
	public static boolean isJobLocal = false;
	 public static HashMap<Byte, DistributedCacheInput> dcValues = new HashMap<>();
	protected HashMap<Byte, MatrixCharacteristics> dimensions=new HashMap<>();
	protected IndexedMatrixValue tempValue=null;
	protected IndexedMatrixValue zeroInput=null;
	public void configure(JobConf job){
		valueClass=MRJobConfiguration.getMatrixValueClass(job);
		tempValue=new IndexedMatrixValue(valueClass);
		zeroInput=new IndexedMatrixValue(valueClass);
		byte[] inputIX = MRJobConfiguration.getInputIndexesInMapper(job);
		for( byte ix : inputIX )dimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForInput(job, ix));
		byte[] mapOutputIX = MRJobConfiguration.getOutputIndexesInMapper(job);
		for(byte ix : mapOutputIX)dimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForMapOutput(job, ix));
		byte[] outputIX = MRJobConfiguration.getResultIndexes(job);
		for( byte ix : outputIX )dimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForOutput(job, ix));
		byte[] immediateIndexes=MRJobConfiguration.getIntermediateMatrixIndexes(job);
		if(immediateIndexes!=null){
			for(byte index: immediateIndexes)dimensions.put(index, MRJobConfiguration.getIntermediateMatrixCharactristics(job, index));
		}
	}
	protected void collectOutput_N_Increase_Counter(MatrixIndexes indexes, MatrixValue value, int i, Reporter reporter, CollectMultipleConvertedOutputs collectFinalMultipleOutputs, byte[] resultDimsUnknown, long[] resultsNonZeros, long[] resultsMaxRowDims, long[] resultsMaxColDims) throws IOException{
		 collectFinalMultipleOutputs.collectOutput(indexes, value, i, reporter);
		resultsNonZeros[i]+=value.getNonZeros();
		if ( resultDimsUnknown[i] == (byte) 1 ) {
			long maxrow = getMaxDimension(indexes, value, true);
			long maxcol = getMaxDimension(indexes, value, false);
			if ( maxrow > resultsMaxRowDims[i] )resultsMaxRowDims[i] = maxrow;
			if ( maxcol > resultsMaxColDims[i] )resultsMaxColDims[i] = maxcol;
		}
		else if(resultDimsUnknown[i] == (byte) 2){
			if ( indexes.getRowIndex() > resultsMaxRowDims[i] )resultsMaxRowDims[i] = indexes.getRowIndex();
			if ( indexes.getColumnIndex() > resultsMaxColDims[i] )resultsMaxColDims[i] = indexes.getColumnIndex();
		}
	}
	protected void processMixedInstructions(ArrayList<MRInstruction> mixed_instructions) {
		if( mixed_instructions != null )for( MRInstruction ins : mixed_instructions )processOneInstruction(ins, valueClass, cachedValues, tempValue, zeroInput);
	}
	protected void processOneInstruction(MRInstruction ins, Class<? extends MatrixValue> valueClass,CachedValueMap cachedValues, IndexedMatrixValue tempValue, IndexedMatrixValue zeroInput) {
		if ( ins instanceof AggregateBinaryInstruction ) {
			byte input = ((AggregateBinaryInstruction)ins).input1;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)throw new DMLRuntimeException(""dimension for instruction ""+ins+"" is unset!!!"");
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if(ins instanceof ZeroOutInstruction || ins instanceof AggregateUnaryInstruction || ins instanceof RangeBasedReIndexInstruction || ins instanceof CumulativeSplitInstruction){
			byte input=((UnaryMRInstructionBase) ins).input;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)throw new DMLRuntimeException(""dimension for instruction ""+ins+"" is unset!!!"");
			if( ins instanceof CumulativeAggregateInstruction )((CumulativeAggregateInstruction)ins).setMatrixCharacteristics(dim);
			if( ins instanceof CumulativeSplitInstruction )((CumulativeSplitInstruction)ins).setMatrixCharacteristics(dim);
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if( ins instanceof ReorgInstruction ){
			ReorgInstruction rinst = (ReorgInstruction) ins;
			byte input = rinst.input;
			MatrixCharacteristics dim = dimensions.get(input);
			if(dim==null)throw new DMLRuntimeException(""dimension for instruction ""+ins+"" is unset!!!"");
			rinst.setInputMatrixCharacteristics(dim);
			rinst.setOutputEmptyBlocks(!(this instanceof MMCJMRMapper));
			 ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if( ins instanceof MatrixReshapeMRInstruction ){
			MatrixReshapeMRInstruction mrins = (MatrixReshapeMRInstruction) ins;
			byte input = mrins.input;
			byte output = mrins.output;
			 MatrixCharacteristics dimIn=dimensions.get(input);
			MatrixCharacteristics dimOut=dimensions.get(output);
			if(dimIn==null || dimOut==null)throw new DMLRuntimeException(""dimension for instruction ""+ins+"" is unset!!!"");
			mrins.setMatrixCharacteristics(dimIn, dimOut);
			mrins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
		}
		else if(ins instanceof AppendMInstruction){
			byte input=((AppendMInstruction) ins).input1;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)throw new DMLRuntimeException(""dimension for instruction ""+ins+"" is unset!!!"");
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if(ins instanceof BinaryMInstruction || ins instanceof RemoveEmptyMRInstruction ){
			byte input=((BinaryMRInstructionBase) ins).input1;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)throw new DMLRuntimeException(""dimension for instruction ""+ins+"" is unset!!!"");
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if(ins instanceof AppendGInstruction){
			AppendGInstruction arinst = ((AppendGInstruction) ins);
			byte input = arinst.input1;
			MatrixCharacteristics dimIn=dimensions.get(input);
			if( dimIn==null )throw new DMLRuntimeException(""Dimensions for instruction ""+arinst+"" is unset!!!"");
			arinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
		}
		else if(ins instanceof UnaryMRInstructionBase){
			UnaryMRInstructionBase rinst = (UnaryMRInstructionBase) ins;
			MatrixCharacteristics dimIn=dimensions.get(rinst.input);
			if( dimIn==null )throw new DMLRuntimeException(""Dimensions for instruction ""+rinst+"" is unset!!!"");
			rinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
		}
		else if(ins instanceof BinaryMRInstructionBase){
			BinaryMRInstructionBase rinst = (BinaryMRInstructionBase) ins;
			MatrixCharacteristics dimIn=dimensions.get(rinst.input1);
			if( dimIn!=null ) rinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
			elseins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, -1, -1);
		}
		elseins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, -1, -1);
	}
	public static void resetDistCache(){
		for(DistributedCacheInput dcInput : dcValues.values() ) dcInput.reset();
		dcValues.clear();
	}
	protected void setupDistCacheFiles(JobConf job) throws IOException {
		if ( MRJobConfiguration.getDistCacheInputIndices(job) == null )return;
		isJobLocal = InfrastructureAnalyzer.isLocalMode(job);
		String[] inputIndices = MRJobConfiguration.getInputPaths(job);
		String[] dcIndices = MRJobConfiguration.getDistCacheInputIndices(job).split(Instruction.INSTRUCTION_DELIM);
		Path[] dcFiles = DistributedCache.getLocalCacheFiles(job);
		PDataPartitionFormat[] inputPartitionFormats = MRJobConfiguration.getInputPartitionFormats(job);
		DistributedCacheInput[] dcInputs = new DistributedCacheInput[dcIndices.length];
		for(int i=0;
		 i < dcIndices.length;
		 i++) {
			 byte inputIndex = Byte.parseByte(dcIndices[i]);
			 if( !dcValues.containsKey(inputIndex) ) {
				 Path p = null;
				if(isJobLocal)p = new Path(inputIndices[ Byte.parseByte(dcIndices[i]) ]);
				elsep = dcFiles[i];
				dcInputs[i] = new DistributedCacheInput(p, MRJobConfiguration.getNumRows(job, inputIndex), MRJobConfiguration.getNumColumns(job, inputIndex), MRJobConfiguration.getNumRowsPerBlock(job, inputIndex), MRJobConfiguration.getNumColumnsPerBlock(job, inputIndex), inputPartitionFormats[inputIndex]);
				 dcValues.put(inputIndex, dcInputs[i]);
			 }
		}
	}
	private static long getMaxDimension( MatrixIndexes key, MatrixValue value, boolean row ) {
		if( value instanceof MatrixCell )return row ? key.getRowIndex() : key.getColumnIndex();
		else if( value instanceof MatrixBlock )return row ? value.getNumRows() : value.getNumColumns();
		return 0;
	}
}",1,0,0,0
"public class DockerRunDialog extends AzureTitleAreaDialogWrapper {
	 private final String basePath;
	 private static final String MISSING_ARTIFACT = ""A web archive (.war) artifact has not been configured."";
	 private static final String MISSING_IMAGE_WITH_TAG = ""Please specify Image and Tag."";
	 private static final String INVALID_DOCKER_FILE = ""Please specify a valid docker file."";
	 private static final String INVALID_CERT_PATH = ""Please specify a valid certificate path."";
	 private static final String INVALID_ARTIFACT_FILE = ""The artifact name %s is invalid. "" + ""An artifact name may contain only the ASCII letters 'a' through 'z' (case-insensitive), "" + ""and the digits '0' through '9', '.', '-' and '_'."";
	 private static final String REPO_LENGTH_INVALID = ""The length of repository name must be at least one character "" + ""and less than 256 characters"";
	 private static final String CANNOT_END_WITH_SLASH = ""The repository name should not end with '/'"";
	 private static final String REPO_COMPONENT_INVALID = ""Invalid repository component: %s, should follow: %s"";
	 private static final String TAG_LENGTH_INVALID = ""The length of tag name must be no more than 128 characters"";
	 private static final String TAG_INVALID = ""Invalid tag: %s, should follow: %s"";
	 private static final String MISSING_MODEL = ""Configuration data model not initialized."";
	 private static final String ARTIFACT_NAME_REGEX = ""^[.A-Za-z0-9_-]+\\.(war|jar)$"";
	 private static final String REPO_COMPONENTS_REGEX = ""[a-z0-9]+(?:[._-][a-z0-9]+)*"";
	 private static final String TAG_REGEX = ""^[\\w]+[\\w.-]*$"";
	 private static final int TAG_LENGTH = 128;
	 private static final int REPO_LENGTH = 255;
	 private static final String IMAGE_NAME_PREFIX = ""localimage"";
	 private static final String DEFAULT_TAG_NAME = ""latest"";
	 private static final String SELECT_DOCKER_FILE = ""Browse..."";
	 private DockerHostRunSetting dataModel;
	 private Text txtDockerHost;
	 private Text txtImageName;
	 private Text txtTagName;
	 private Button btnTlsEnabled;
	 private FileSelector dockerFileSelector;
	 private FileSelector certPathSelector;
	 public DockerRunDialog(Shell parentShell, String basePath, String targetPath) {
		 super(parentShell);
		 setShellStyle(SWT.RESIZE | SWT.TITLE);
		 this.basePath = basePath;
		 dataModel = new DockerHostRunSetting();
		 dataModel.setTargetPath(targetPath);
		 dataModel.setTargetName(FilenameUtils.getName(targetPath));
	 }
	 protected Control createDialogArea(Composite parent) {
		 Composite area = (Composite) super.createDialogArea(parent);
		 Composite composite = new Composite(area, SWT.NONE);
		 composite.setLayout(new GridLayout(5, false));
		 composite.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true, 1, 1));
		 dockerFileSelector = new FileSelector(composite, SWT.NONE, false, SELECT_DOCKER_FILE, basePath, ""Docker File"");
		 dockerFileSelector.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 5, 1));
		 Label lblDockerHost = new Label(composite, SWT.NONE);
		 lblDockerHost.setText(""Docker Host"");
		 txtDockerHost = new Text(composite, SWT.BORDER);
		 txtDockerHost.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 4, 1));
		 btnTlsEnabled = new Button(composite, SWT.CHECK);
		 btnTlsEnabled.addListener(SWT.Selection, event -> onBtnTlsEnabledSelection());
		 btnTlsEnabled.setText(""Enable TLS"");
		 certPathSelector = new FileSelector(composite, SWT.NONE, true, ""Browse..."", null, ""Cert Path"");
		 certPathSelector.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 4, 1));
		 Label lblImage = new Label(composite, SWT.NONE);
		 lblImage.setText(""Image Name"");
		 txtImageName = new Text(composite, SWT.BORDER);
		 txtImageName.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 2, 1));
		 Label lblTagName = new Label(composite, SWT.NONE);
		 lblTagName.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false, 1, 1));
		 lblTagName.setText(""Tag Name"");
		 txtTagName = new Text(composite, SWT.BORDER);
		 txtTagName.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 1, 1));
		 setTitle(""Run on Docker Host"");
		 setMessage("""");
		 reset();
		 return area;
	 }
	 private void reset() {
		 if (Utils.isEmptyString(txtDockerHost.getText())) {
			 try {
				 txtDockerHost.setText(DefaultDockerClient.fromEnv().uri().toString());
			 }
			 catch (DockerCertificateException e) {
				 e.printStackTrace();
			 }
		 }
		 String defaultDockerFilePath = DockerUtil.getDefaultDockerFilePathIfExist(basePath);
		 dockerFileSelector.setFilePath(defaultDockerFilePath);
		 DateFormat df = new SimpleDateFormat(""yyMMddHHmmss"");
		 String date = df.format(new Date());
		 if (Utils.isEmptyString(txtImageName.getText())) {
			 txtImageName.setText(String.format(""%s-%s"", IMAGE_NAME_PREFIX, date));
		 }
		 if (Utils.isEmptyString(txtTagName.getText())) {
			 txtTagName.setText(DEFAULT_TAG_NAME);
		 }
		 updateCertPathVisibility();
	 }
	 private void onBtnTlsEnabledSelection() {
		 updateCertPathVisibility();
	 }
	 private void updateCertPathVisibility() {
		 certPathSelector.setVisible(btnTlsEnabled.getSelection());
	 }
	 protected void createButtonsForButtonBar(Composite parent) {
		 createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, true);
		 createButton(parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false);
	 }
	 protected Point getInitialSize() {
		 this.getShell().layout(true, true);
		 return this.getShell().computeSize(SWT.DEFAULT, SWT.DEFAULT, true);
	 }
	 protected boolean isResizable() {
		 return true;
	 }
	 public boolean isHelpAvailable() {
		 return false;
	 }
	 protected void okPressed() {
		 apply();
		 try {
			 validate();
			 execute();
			 super.okPressed();
		 }
		 catch (InvalidFormDataException e) {
			 showErrorMessage(""Error"", e.getMessage());
		 }
	 }
	 private void apply() {
		 dataModel.setTlsEnabled(btnTlsEnabled.getSelection());
		 dataModel.setDockerFilePath(dockerFileSelector.getFilePath());
		 dataModel.setDockerCertPath(certPathSelector.getFilePath());
		 dataModel.setDockerHost(txtDockerHost.getText());
		 dataModel.setImageName(txtImageName.getText());
		 dataModel.setTagName(txtTagName.getText());
	 }
	 private void validate() throws InvalidFormDataException {
		 if (dataModel == null) {
			 throw new InvalidFormDataException(MISSING_MODEL);
		 }
		 if (Utils.isEmptyString(dataModel.getDockerFilePath())) {
			 throw new InvalidFormDataException(INVALID_DOCKER_FILE);
		 }
		 File dockerFile = Paths.get(dataModel.getDockerFilePath()).toFile();
		 if (!dockerFile.exists() || !dockerFile.isFile()) {
			 throw new InvalidFormDataException(INVALID_DOCKER_FILE);
		 }
		 if (dataModel.isTlsEnabled()) {
			 if (Utils.isEmptyString(dataModel.getDockerCertPath())) {
				 throw new InvalidFormDataException(INVALID_CERT_PATH);
			 }
			 File certPath = Paths.get(dataModel.getDockerCertPath()).toFile();
			 if (!certPath.exists() || !certPath.isDirectory()) {
				 throw new InvalidFormDataException(INVALID_CERT_PATH);
			 }
		 }
		 String imageName = dataModel.getImageName();
		 String tagName = dataModel.getTagName();
		 if (Utils.isEmptyString(imageName) || Utils.isEmptyString(tagName)) {
			 throw new InvalidFormDataException(MISSING_IMAGE_WITH_TAG);
		 }
		 if (imageName.length() < 1 || imageName.length() > REPO_LENGTH) {
			 throw new InvalidFormDataException(REPO_LENGTH_INVALID);
		 }
		 if (imageName.endsWith(""/"")) {
			 throw new InvalidFormDataException(CANNOT_END_WITH_SLASH);
		 }
		 final String[] repoComponents = imageName.split(""/"");
		 for (String component : repoComponents) {
			 if (!component.matches(REPO_COMPONENTS_REGEX)) {
				 throw new InvalidFormDataException( String.format(REPO_COMPONENT_INVALID, component, REPO_COMPONENTS_REGEX));
			 }
		 }
		 if (tagName.length() > TAG_LENGTH) {
			 throw new InvalidFormDataException(TAG_LENGTH_INVALID);
		 }
		 if (!tagName.matches(TAG_REGEX)) {
			 throw new InvalidFormDataException(String.format(TAG_INVALID, tagName, TAG_REGEX));
		 }
		 if (Utils.isEmptyString(dataModel.getTargetName())) {
			 throw new InvalidFormDataException(MISSING_ARTIFACT);
		 }
		 if (!dataModel.getTargetName().matches(ARTIFACT_NAME_REGEX)) {
			 throw new InvalidFormDataException(String.format(INVALID_ARTIFACT_FILE, dataModel.getTargetName()));
		 }
	 }
	 private void execute() {
		 Observable.fromCallable(() -> {
			 ConsoleLogger.info(""Starting job ... "");
			 if (basePath == null) {
				 ConsoleLogger.error(""Project base path is null."");
				 throw new FileNotFoundException(""Project base path is null."");
			 }
			 String targetFilePath = dataModel.getTargetPath();
			 ConsoleLogger.info(String.format(""Locating artifact ... [%s]"", targetFilePath));
			 Path targetDockerfile = Paths.get(dataModel.getDockerFilePath());
			 ConsoleLogger.info(String.format(""Validating dockerfile ... [%s]"", targetDockerfile));
			 if (!targetDockerfile.toFile().exists()) {
				 throw new FileNotFoundException(""Dockerfile not found."");
			 }
			 String content = new String(Files.readAllBytes(targetDockerfile));
			 content = content.replaceAll(Constant.DOCKERFILE_ARTIFACT_PLACEHOLDER, Paths.get(basePath).toUri().relativize(Paths.get(targetFilePath).toUri()).getPath());
			 Files.write(targetDockerfile, content.getBytes());
			 String imageNameWithTag = String.format(""%s:%s"", dataModel.getImageName(), dataModel.getTagName());
			 ConsoleLogger.info(String.format(""Building image ... [%s]"", imageNameWithTag));
			 DockerClient docker = DockerUtil.getDockerClient(dataModel.getDockerHost(), dataModel.isTlsEnabled(), dataModel.getDockerCertPath());
			 DockerUtil.buildImage(docker, imageNameWithTag, targetDockerfile.getParent(), targetDockerfile.getFileName().toString(), new DockerProgressHandler());
			 ConsoleLogger.info(Constant.MESSAGE_CREATING_CONTAINER);
			 String containerId = DockerUtil.createContainer(docker, String.format(""%s:%s"", dataModel.getImageName(), dataModel.getTagName()));
			 ConsoleLogger.info(String.format(Constant.MESSAGE_CONTAINER_INFO, containerId));
			 ConsoleLogger.info(Constant.MESSAGE_STARTING_CONTAINER);
			 Container container = DockerUtil.runContainer(docker, containerId);
			 DockerRuntime.getInstance().setRunningContainerId(basePath, container.id(), dataModel);
			 String hostname = new URI(dataModel.getDockerHost()).getHost();
			 ImmutableList<PortMapping> ports = container.ports();
			 String publicPort = null;
			 if (ports != null) {
				 for (Container.PortMapping portMapping : ports) {
					 if (Constant.TOMCAT_SERVICE_PORT.equals(String.valueOf(portMapping.privatePort()))) {
						 publicPort = String.valueOf(portMapping.publicPort());
					 }
				 }
			 }
			 ConsoleLogger.info(String.format(Constant.MESSAGE_CONTAINER_STARTED, (hostname != null ? hostname : ""localhost"") + (publicPort != null ? "":"" + publicPort : """")));
			 return null;
		 }
		).subscribeOn(SchedulerProviderFactory.getInstance().getSchedulerProvider().io()).subscribe( ret -> {
			 ConsoleLogger.info(""Container started."");
			 sendTelemetry(true, null);
		 }
		, e -> {
			 e.printStackTrace();
			 ConsoleLogger.error(e.getMessage());
			 sendTelemetry(false, e.getMessage());
		 }
		 );
	 }
	 private void sendTelemetry(boolean success, String errorMsg) {
		 Map<String, String> map = new HashMap<>();
		 map.put(""Success"", String.valueOf(success));
		 if (null != dataModel.getTargetName()) {
			 map.put(""FileType"", FilenameUtils.getExtension(dataModel.getTargetName()));
		 }
		 else {
			 map.put(""FileType"", """");
		 }
		 if (!success) {
			 map.put(""ErrorMsg"", errorMsg);
		 }
		 AppInsightsClient.createByType(AppInsightsClient.EventType.Action, ""Docker"", ""Run"", map);
	 }
	 private void showErrorMessage(String title, String message) {
		 MessageDialog.openError(this.getShell(), title, message);
	 }
}",1,0,0,0
"public class MemoryFileSystem implements FileSystem {
	 private Map<String, MemoryFileSystemEntry> entries = new HashMap<String, MemoryFileSystemEntry>();
	 public void close() {
	 }
	 private MemoryFile getFile(String filePath) throws FileSystemException {
		 MemoryFileSystemEntry entry = getEntry(filePath);
		 assertIsFile(filePath);
		 return (MemoryFile) entry;
	 }
	 public void createFolder(String folderPath) throws FileSystemException {
		 if (exists(folderPath)) {
			 throw new FileSystemException(""Folder or file "" + folderPath + "" already exists"");
		 }
		 if (!exists(FileSystem.SEPARATOR)) {
			 createFolderInternal(""/"");
		 }
		 String relativePath = folderPath.substring(1);
		 String[] pathElements = relativePath.split(FileSystem.SEPARATOR);
		 String currentFolderPath = """";
		 for (int i = 0;
		 i < pathElements.length;
		 i++) {
			 String pathElement = pathElements[i];
			 currentFolderPath += ""/"" + pathElement;
			 createFolderInternal(currentFolderPath);
		 }
	 }
	 private void createFolderInternal(String folderPath) {
		 MemoryFolder folder = new MemoryFolder();
		 entries.put(folderPath, folder);
	 }
	 public void deleteFile(String filePath) throws FileSystemException {
		 assertExistence(filePath);
		 entries.remove(filePath);
	 }
	 public void deleteFolder(String folderPath) throws FileSystemException {
		 assertIsFolder(folderPath);
		 Set<String> selectedNames = new HashSet<String>();
		 for (String name : entries.keySet()) {
			 if (name.equals(folderPath) || name.startsWith(folderPath + SEPARATOR)) {
				 selectedNames.add(name);
			 }
		 }
		 for (String name : selectedNames) {
			 entries.remove(name);
		 }
	 }
	 public boolean exists(String path) throws FileSystemException {
		 return entries.containsKey(path);
	 }
	 public InputStream getInputStream(String filePath) throws FileSystemException {
		 assertExistence(filePath);
		 assertIsFile(filePath);
		 MemoryFile file = getFile(filePath);
		 return new ByteArrayInputStream(file.getData());
	 }
	 private void assertIsFolder(String folderPath) throws FileSystemException {
		 assertExistence(folderPath);
		 if (!getEntry(folderPath).isFolder()) {
			 throw new FileSystemException(""Folder "" + folderPath + "" does not exist"");
		 }
	 }
	 private void assertIsFile(String filePath) throws FileSystemException {
		 if (!isFile(filePath)) {
			 throw new FileSystemException(filePath + "" is a folder"");
		 }
	 }
	 public OutputStream getOutputStream(String filePath) throws FileSystemException {
		 if (isFolder(filePath)) {
			 throw new FileSystemException(""path denotes folder: "" + filePath);
		 }
		 String folderPath = filePath;
		 if (filePath.lastIndexOf(FileSystem.SEPARATOR) > 0) {
			 folderPath = filePath.substring(0, filePath.lastIndexOf(""/""));
		 }
		 else {
			 folderPath = ""/"";
		 }
		 assertIsFolder(folderPath);
		 final MemoryFile file = new MemoryFile();
		 entries.put(filePath, file);
		 return new FilterOutputStream(new ByteArrayOutputStream()) {
			 public void write(byte[] bytes, int off, int len) throws IOException {
				 out.write(bytes, off, len);
			 }
			 public void close() throws IOException {
				 out.close();
				 file.setData(((ByteArrayOutputStream) out).toByteArray());
			 }
		 }
		;
	 }
	 public boolean hasChildren(String path) throws FileSystemException {
		 assertIsFolder(path);
		 return list(path).length > 0;
	 }
	 public void init() {
		 createFolderInternal(""/"");
	 }
	 public boolean isFile(String path) throws FileSystemException {
		 return exists(path) && !getEntry(path).isFolder();
	 }
	 private MemoryFileSystemEntry getEntry(String path) {
		 return entries.get(path);
	 }
	 private void assertExistence(String path) throws FileSystemException {
		 if (!exists(path)) {
			 throw new FileSystemException(""no such file "" + path);
		 }
	 }
	 public boolean isFolder(String path) throws FileSystemException {
		 if (path.equals(""/"")) {
			 return true;
		 }
		 else {
			 return exists(path) && getEntry(path).isFolder();
		 }
	 }
	 public long lastModified(String path) throws FileSystemException {
		 assertExistence(path);
		 return getEntry(path).getLastModified();
	 }
	 public long length(String filePath) throws FileSystemException {
		 assertIsFile(filePath);
		 return getFile(filePath).getData().length;
	 }
	 public String[] list(String folderPath) {
		 if (folderPath.equals(""/"")) {
			 folderPath = """";
		 }
		 Set<String> selectedNames = new HashSet<String>();
		 for (String name : entries.keySet()) {
			 if (name.matches(folderPath + ""/[^/]*"") && !name.equals(""/"")) {
				 selectedNames.add(name.substring(folderPath.length() + 1));
			 }
		 }
		 return selectedNames.toArray(new String[selectedNames.size()]);
	 }
	 public String[] listFiles(String folderPath) {
		 return listInternal(folderPath, false);
	 }
	 public String[] listFolders(String folderPath) {
		 return listInternal(folderPath, true);
	 }
	 private String[] listInternal(String folderPath, boolean isFolder) {
		 String[] names = list(folderPath);
		 if (folderPath.equals(""/"")) {
			 folderPath = """";
		 }
		 Set<String> result = new HashSet<String>();
		 for (String n : names) {
			 if (getEntry(folderPath + ""/"" + n).isFolder() == isFolder) {
				 result.add(n);
			 }
		 }
		 return result.toArray(new String[result.size()]);
	 }
}",0,0,0,0
"public class InterfaceMethodRefCPInfo extends ConstantPoolEntry {
	 private String interfaceMethodClassName;
	 private String interfaceMethodName;
	 private String interfaceMethodType;
	 private int classIndex;
	 private int nameAndTypeIndex;
	 public InterfaceMethodRefCPInfo() {
		 super(CONSTANT_INTERFACEMETHODREF, 1);
	 }
	 public void read(DataInputStream cpStream) throws IOException {
		 classIndex = cpStream.readUnsignedShort();
		 nameAndTypeIndex = cpStream.readUnsignedShort();
	 }
	 public void resolve(ConstantPool constantPool) {
		 ClassCPInfo interfaceMethodClass = (ClassCPInfo) constantPool.getEntry(classIndex);
		 interfaceMethodClass.resolve(constantPool);
		 interfaceMethodClassName = interfaceMethodClass.getClassName();
		 NameAndTypeCPInfo nt = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);
		 nt.resolve(constantPool);
		 interfaceMethodName = nt.getName();
		 interfaceMethodType = nt.getType();
		 super.resolve(constantPool);
	 }
	 public String toString() {
		 String value;
		 if (isResolved()) {
			 value = ""InterfaceMethod : Class = "" + interfaceMethodClassName + "", name = "" + interfaceMethodName + "", type = "" + interfaceMethodType;
		 }
		 else {
			 value = ""InterfaceMethod : Class index = "" + classIndex + "", name and type index = "" + nameAndTypeIndex;
		 }
		 return value;
	 }
	 public String getInterfaceMethodClassName() {
		 return interfaceMethodClassName;
	 }
	 public String getInterfaceMethodName() {
		 return interfaceMethodName;
	 }
	 public String getInterfaceMethodType() {
		 return interfaceMethodType;
	 }
}",0,0,0,0
"public final class FilterRequestContext{
	private HttpServletRequest request;
	private HttpServletResponse response;
	public FilterRequestContext(HttpServletRequest request, HttpServletResponse response){
		this.request = request;
		this.response = response;
	}
	public HttpServletRequest getRequest(){
		return request;
	}
	public void setRequest(HttpServletRequest request){
		this.request = request;
	}
	public HttpServletResponse getResponse(){
		return response;
	}
	public void setResponse(HttpServletResponse response){
		this.response = response;
	}
}",0,0,0,0
"public abstract class BuildTargetException extends BuildFileParseException {
	 public BuildTargetException(String message) {
		 super(message);
	 }
}",0,0,0,0
"public abstract class AbstractAzureMojo extends AbstractMojo implements TelemetryConfiguration, AuthConfiguration {
	 public static final String PLUGIN_NAME_KEY = ""pluginName"";
	 public static final String PLUGIN_VERSION_KEY = ""pluginVersion"";
	 public static final String INSTALLATION_ID_KEY = ""installationId"";
	 public static final String SESSION_ID_KEY = ""sessionId"";
	 public static final String SUBSCRIPTION_ID_KEY = ""subscriptionId"";
	 public static final String AUTH_TYPE = ""authType"";
	 public static final String TELEMETRY_NOT_ALLOWED = ""TelemetryNotAllowed"";
	 public static final String INIT_FAILURE = ""InitFailure"";
	 public static final String AZURE_INIT_FAIL = ""Failed to authenticate with Azure. Please check your configuration."";
	 public static final String FAILURE_REASON = ""failureReason"";
	 private static final String CONFIGURATION_PATH = Paths.get(System.getProperty(""user.home""), "".azure"", ""mavenplugins.properties"").toString();
	 private static final String FIRST_RUN_KEY = ""first.run"";
	 private static final String PRIVACY_STATEMENT = ""\nData/Telemetry\n"" + ""---------\n"" + ""This project collects usage data and sends it to Microsoft to help improve our products and services.\n"" + ""Read Microsoft's privacy statement to learn more: https: ""\n\nYou can change your telemetry configuration through 'allowTelemetry' property.\n"" + ""For more information, please go to https: protected MavenProject project;
	 protected MavenSession session;
	 protected File buildDirectory;
	 protected PluginDescriptor plugin;
	 protected Settings settings;
	 protected MavenResourcesFiltering mavenResourcesFiltering;
	 protected AuthenticationSetting authentication;
	 protected String subscriptionId = """";
	 protected boolean allowTelemetry;
	 protected boolean failsOnError;
	 protected String httpProxyHost;
	 protected int httpProxyPort;
	 private AzureAuthHelper azureAuthHelper = new AzureAuthHelper(this);
	 private Azure azure;
	 private TelemetryProxy telemetryProxy;
	 private String sessionId = UUID.randomUUID().toString();
	 private String installationId = GetHashMac.getHashMac();
	 public MavenProject getProject() {
		 return project;
	 }
	 public MavenSession getSession() {
		 return session;
	 }
	 public String getBuildDirectoryAbsolutePath() {
		 return buildDirectory.getAbsolutePath();
	 }
	 public MavenResourcesFiltering getMavenResourcesFiltering() {
		 return mavenResourcesFiltering;
	 }
	 public Settings getSettings() {
		 return settings;
	 }
	 public AuthenticationSetting getAuthenticationSetting() {
		 return authentication;
	 }
	 public String getSubscriptionId() {
		 return subscriptionId;
	 }
	 public boolean isTelemetryAllowed() {
		 return allowTelemetry;
	 }
	 public boolean isFailingOnError() {
		 return failsOnError;
	 }
	 public String getSessionId() {
		 return sessionId;
	 }
	 public String getInstallationId() {
		 return installationId == null ? """" : installationId;
	 }
	 public String getPluginName() {
		 return plugin.getArtifactId();
	 }
	 public String getPluginVersion() {
		 return plugin.getVersion();
	 }
	 public String getUserAgent() {
		 return isTelemetryAllowed() ? String.format(""%s/%s %s:%s %s:%s"", getPluginName(), getPluginVersion(), INSTALLATION_ID_KEY, getInstallationId(), SESSION_ID_KEY, getSessionId()) : String.format(""%s/%s"", getPluginName(), getPluginVersion());
	 }
	 public String getHttpProxyHost() {
		 return httpProxyHost;
	 }
	 public int getHttpProxyPort() {
		 return httpProxyPort;
	 }
	 public Azure getAzureClient() throws AzureAuthFailureException {
		 if (azure == null) {
			 azure = azureAuthHelper.getAzureClient();
			 if (azure == null) {
				 getTelemetryProxy().trackEvent(INIT_FAILURE);
				 throw new AzureAuthFailureException(AZURE_INIT_FAIL);
			 }
			 else {
				 getTelemetryProxy().addDefaultProperty(SUBSCRIPTION_ID_KEY, azure.subscriptionId());
			 }
		 }
		 return azure;
	 }
	 public TelemetryProxy getTelemetryProxy() {
		 if (telemetryProxy == null) {
			 initTelemetry();
		 }
		 return telemetryProxy;
	 }
	 protected void initTelemetry() {
		 telemetryProxy = new AppInsightsProxy(this);
		 if (!isTelemetryAllowed()) {
			 telemetryProxy.trackEvent(TELEMETRY_NOT_ALLOWED);
			 telemetryProxy.disable();
		 }
	 }
	 public Map<String, String> getTelemetryProperties() {
		 final Map<String, String> map = new HashMap<>();
		 map.put(INSTALLATION_ID_KEY, getInstallationId());
		 map.put(PLUGIN_NAME_KEY, getPluginName());
		 map.put(PLUGIN_VERSION_KEY, getPluginVersion());
		 map.put(SUBSCRIPTION_ID_KEY, getSubscriptionId());
		 map.put(SESSION_ID_KEY, getSessionId());
		 map.put(AUTH_TYPE, getAuthType());
		 return map;
	 }
	 public String getAuthType() {
		 final AuthenticationSetting authSetting = getAuthenticationSetting();
		 if (authSetting == null) {
			 return ""AzureCLI"";
		 }
		 if (StringUtils.isNotEmpty(authSetting.getServerId())) {
			 return ""ServerId"";
		 }
		 if (authSetting.getFile() != null) {
			 return ""AuthFile"";
		 }
		 return ""Unknown"";
	 }
	 public void execute() throws MojoExecutionException {
		 try {
			 Thread.setDefaultUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler());
			 final Properties prop = new Properties();
			 if (isFirstRun(prop)) {
				 infoWithMultipleLines(PRIVACY_STATEMENT);
				 updateConfigurationFile(prop);
			 }
			 if (isSkipMojo()) {
				 info(""Skip execution."");
				 trackMojoSkip();
			 }
			 else {
				 trackMojoStart();
				 doExecute();
				 trackMojoSuccess();
			 }
		 }
		 catch (Exception e) {
			 handleException(e);
		 }
		 finally {
			 ApacheSenderFactory.INSTANCE.create().close();
		 }
	 }
	 protected boolean isSkipMojo() {
		 return false;
	 }
	 protected abstract void doExecute() throws Exception;
	 protected void trackMojoSkip() {
		 getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".skip"");
	 }
	 protected void trackMojoStart() {
		 getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".start"");
	 }
	 protected void trackMojoSuccess() {
		 getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".success"");
	 }
	 protected void trackMojoFailure(final String message) {
		 final HashMap<String, String> failureReason = new HashMap<>();
		 failureReason.put(FAILURE_REASON, message);
		 getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".failure"", failureReason);
	 }
	 protected void handleException(final Exception exception) throws MojoExecutionException {
		 String message = exception.getMessage();
		 if (StringUtils.isEmpty(message)) {
			 message = exception.toString();
		 }
		 trackMojoFailure(message);
		 if (isFailingOnError()) {
			 throw new MojoExecutionException(message, exception);
		 }
		 else {
			 error(message);
		 }
	 }
	 private boolean isFirstRun(Properties prop) {
		 try {
			 final File configurationFile = new File(CONFIGURATION_PATH);
			 if (configurationFile.exists()) {
				 try (InputStream input = new FileInputStream(CONFIGURATION_PATH)) {
					 prop.load(input);
					 final String firstRunValue = prop.getProperty(FIRST_RUN_KEY);
					 if (firstRunValue != null && !firstRunValue.isEmpty() && firstRunValue.equalsIgnoreCase(""false"")) {
						 return false;
					 }
				 }
			 }
			 else {
				 configurationFile.getParentFile().mkdirs();
				 configurationFile.createNewFile();
			 }
		 }
		 catch (Exception e) {
			 debug(e.getMessage());
		 }
		 return true;
	 }
	 private void updateConfigurationFile(Properties prop) {
		 try (OutputStream output = new FileOutputStream(CONFIGURATION_PATH)) {
			 prop.setProperty(FIRST_RUN_KEY, ""false"");
			 prop.store(output, ""Azure Maven Plugin configurations"");
		 }
		 catch (Exception e) {
			 debug(e.getMessage());
		 }
	 }
	 protected class DefaultUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
		 public void uncaughtException(Thread t, Throwable e) {
			 debug(""uncaughtException: "" + e);
		 }
	 }
	 public void debug(final String message) {
		 getLog().debug(message);
	 }
	 public void info(final String message) {
		 getLog().info(message);
	 }
	 public void infoWithMultipleLines(final String messages) {
		 final String[] messageArray = messages.split(""\\n"");
		 for (final String line : messageArray) {
			 getLog().info(line);
		 }
	 }
	 public void warning(final String message) {
		 getLog().warn(message);
	 }
	 public void error(final String message) {
		 getLog().error(message);
	 }
}",1,1,0,0
"public class WLJspc extends MatchingTask {
	 private File destinationDirectory;
	 private File sourceDirectory;
	 private String destinationPackage;
	 private Path compileClasspath;
	 private String pathToPackage = """";
	 private Vector filesToDo = new Vector();
	 public void execute() throws BuildException {
		 if (!destinationDirectory.isDirectory()) {
			 throw new BuildException(""destination directory "" + destinationDirectory.getPath() + "" is not valid"");
		 }
		 if (!sourceDirectory.isDirectory()) {
			 throw new BuildException(""src directory "" + sourceDirectory.getPath() + "" is not valid"");
		 }
		 if (destinationPackage == null) {
			 throw new BuildException(""package attribute must be present."", getLocation());
		 }
		 pathToPackage = this.destinationPackage.replace('.', File.separatorChar);
		 DirectoryScanner ds = super.getDirectoryScanner(sourceDirectory);
		 if (compileClasspath == null) {
			 compileClasspath = new Path(getProject());
		 }
		 compileClasspath = compileClasspath.concatSystemClasspath();
		 String[] files = ds.getIncludedFiles();
		 Java helperTask = new Java(this);
		 helperTask.setFork(true);
		 helperTask.setClassname(""weblogic.jspc"");
		 helperTask.setTaskName(getTaskName());
		 String[] args = new String[12];
		 File jspFile = null;
		 String parents = """";
		 int j = 0;
		 args[j++] = ""-d"";
		 args[j++] = destinationDirectory.getAbsolutePath().trim();
		 args[j++] = ""-docroot"";
		 args[j++] = sourceDirectory.getAbsolutePath().trim();
		 args[j++] = ""-keepgenerated"";
		 args[j++] = ""-compilerclass"";
		 args[j++] = ""sun.tools.javac.Main"";
		 args[j++] = ""-classpath"";
		 args[j++] = compileClasspath.toString();
		 this.scanDir(files);
		 log(""Compiling "" + filesToDo.size() + "" JSP files"");
		 for (int i = 0;
		 i < filesToDo.size();
		 i++) {
			 String filename = (String) filesToDo.elementAt(i);
			 jspFile = new File(filename);
			 args[j] = ""-package"";
			 parents = jspFile.getParent();
			 if ((parents != null) && (!("""").equals(parents))) {
				 parents = this.replaceString(parents, File.separator, ""_."");
				 args[j + 1] = destinationPackage + ""."" + ""_"" + parents;
			 }
			 else {
				 args[j + 1] = destinationPackage;
			 }
			 args[j + 2] = sourceDirectory + File.separator + filename;
			 helperTask.clearArgs();
			 for (int x = 0;
			 x < j + 3;
			 x++) {
				 helperTask.createArg().setValue(args[x]);
			 }
			 helperTask.setClasspath(compileClasspath);
			 if (helperTask.executeJava() != 0) {
				 log(filename + "" failed to compile"", Project.MSG_WARN);
			 }
		 }
	 }
	 public void setClasspath(Path classpath) {
		 if (compileClasspath == null) {
			 compileClasspath = classpath;
		 }
		 else {
			 compileClasspath.append(classpath);
		 }
	 }
	 public Path createClasspath() {
		 if (compileClasspath == null) {
			 compileClasspath = new Path(getProject());
		 }
		 return compileClasspath;
	 }
	 public void setSrc(File dirName) {
		 sourceDirectory = dirName;
	 }
	 public void setDest(File dirName) {
		 destinationDirectory = dirName;
	 }
	 public void setPackage(String packageName) {
		 destinationPackage = packageName;
	 }
	 protected void scanDir(String[] files) {
		 long now = (new Date()).getTime();
		 File jspFile = null;
		 String parents = null;
		 String pack = """";
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 File srcFile = new File(this.sourceDirectory, files[i]);
			 jspFile = new File(files[i]);
			 parents = jspFile.getParent();
			 if ((parents != null) && (!("""").equals(parents))) {
				 parents = this.replaceString(parents, File.separator, ""_/"");
				 pack = pathToPackage + File.separator + ""_"" + parents;
			 }
			 else {
				 pack = pathToPackage;
			 }
			 String filePath = pack + File.separator + ""_"";
			 int startingIndex = files[i].lastIndexOf(File.separator) != -1 ? files[i].lastIndexOf(File.separator) + 1 : 0;
			 int endingIndex = files[i].indexOf("".jsp"");
			 if (endingIndex == -1) {
				 log(""Skipping "" + files[i] + "". Not a JSP"", Project.MSG_VERBOSE);
				 continue;
			 }
			 filePath += files[i].substring(startingIndex, endingIndex);
			 filePath += "".class"";
			 File classFile = new File(this.destinationDirectory, filePath);
			 if (srcFile.lastModified() > now) {
				 log(""Warning: file modified in the future: "" + files[i], Project.MSG_WARN);
			 }
			 if (srcFile.lastModified() > classFile.lastModified()) {
				 filesToDo.addElement(files[i]);
				 log(""Recompiling File "" + files[i], Project.MSG_VERBOSE);
			 }
		 }
	 }
	 protected String replaceString(String inpString, String escapeChars, String replaceChars) {
		 String localString = """";
		 int numTokens = 0;
		 StringTokenizer st = new StringTokenizer(inpString, escapeChars, true);
		 numTokens = st.countTokens();
		 for (int i = 0;
		 i < numTokens;
		 i++) {
			 String test = st.nextToken();
			 test = (test.equals(escapeChars) ? replaceChars : test);
			 localString += test;
		 }
		 return localString;
	 }
}",0,0,0,0
"public class FSDataInputStream extends DataInputStream {
	 private static final Log LOG = LogFactory.getLog(""org.apache.hadoop.fs.DataInputStream"");
	 private static final byte[] VERSION = FSDataOutputStream.CHECKSUM_VERSION;
	 private static final int HEADER_LENGTH = 8;
	 private int bytesPerSum = 1;
	 private class Checker extends FilterInputStream implements Seekable {
		 private FileSystem fs;
		 private Path file;
		 private FSDataInputStream sums;
		 private Checksum sum = new CRC32();
		 private int inSum;
		 public Checker(FileSystem fs, Path file, Configuration conf) throws IOException {
			 super(fs.openRaw(file));
			 this.fs = fs;
			 this.file = file;
			 Path sumFile = FileSystem.getChecksumFile(file);
			 try {
				 this.sums = new FSDataInputStream(fs.openRaw(sumFile), conf);
				 byte[] version = new byte[VERSION.length];
				 sums.readFully(version);
				 if (!Arrays.equals(version, VERSION)) throw new IOException(""Not a checksum file: ""+sumFile);
				 bytesPerSum = sums.readInt();
			 }
			 catch (FileNotFoundException e) {
				 stopSumming();
			 }
			 catch (IOException e) {
				 LOG.warn(""Problem opening checksum file: ""+ file + "". Ignoring exception: "" + StringUtils.stringifyException(e));
				 stopSumming();
			 }
		 }
		 public void seek(long desired) throws IOException {
			 ((Seekable)in).seek(desired);
			 if (sums != null) {
				 if (desired % bytesPerSum != 0) throw new IOException(""Seek to non-checksummed position."");
				 try {
					 sums.seek(HEADER_LENGTH + 4*(desired/bytesPerSum));
				 }
				 catch (IOException e) {
					 LOG.warn(""Problem seeking checksum file: ""+e+"". Ignoring."");
					 stopSumming();
				 }
				 sum.reset();
				 inSum = 0;
			 }
		 }
		 public int read(byte b[], int off, int len) throws IOException {
			 int read = in.read(b, off, len);
			 if (sums != null) {
				 int summed = 0;
				 while (summed < read) {
					 int goal = bytesPerSum - inSum;
					 int inBuf = read - summed;
					 int toSum = inBuf <= goal ? inBuf : goal;
					 try {
						 sum.update(b, off+summed, toSum);
					 }
					 catch (ArrayIndexOutOfBoundsException e) {
						 throw new RuntimeException(""Summer buffer overflow b.len="" + b.length + "", off="" + off + "", summed="" + summed + "", read="" + read + "", bytesPerSum="" + bytesPerSum + "", inSum="" + inSum, e);
					 }
					 summed += toSum;
					 inSum += toSum;
					 if (inSum == bytesPerSum) {
						 verifySum(read-(summed-bytesPerSum));
					 }
				 }
			 }
			 return read;
		 }
		 private void verifySum(int delta) throws IOException {
			 int crc;
			 try {
				 crc = sums.readInt();
			 }
			 catch (IOException e) {
				 LOG.warn(""Problem reading checksum file: ""+e+"". Ignoring."");
				 stopSumming();
				 return;
			 }
			 int sumValue = (int)sum.getValue();
			 sum.reset();
			 inSum = 0;
			 if (crc != sumValue) {
				 long pos = getPos() - delta;
				 fs.reportChecksumFailure(file, (FSInputStream)in, pos, bytesPerSum, crc);
				 throw new ChecksumException(""Checksum error: ""+file+"" at ""+pos);
			 }
		 }
		 public long getPos() throws IOException {
			 return ((FSInputStream)in).getPos();
		 }
		 public void close() throws IOException {
			 super.close();
			 stopSumming();
		 }
		 private void stopSumming() {
			 if (sums != null) {
				 try {
					 sums.close();
				 }
				 catch (IOException f) {
				}
				 sums = null;
				 bytesPerSum = 1;
			 }
		 }
	 }
	 private static class PositionCache extends FilterInputStream {
		 long position;
		 public PositionCache(InputStream in) throws IOException {
			 super(in);
		 }
		 public int read(byte b[], int off, int len) throws IOException {
			 int result;
			 if( (result = in.read(b, off, len)) > 0 ) position += result;
			 return result;
		 }
		 public void seek(long desired) throws IOException {
			 ((Seekable)in).seek(desired);
			 position = desired;
		 }
		 public long getPos() throws IOException {
			 return position;
		 }
	 }
	 private class Buffer extends BufferedInputStream {
		 public Buffer(PositionCache in, int bufferSize) throws IOException {
			 super(in, bufferSize);
		 }
		 public void seek(long desired) throws IOException {
			 long end = ((PositionCache)in).getPos();
			 long start = end - this.count;
			 if (desired >= start && desired < end) {
				 this.pos = (int)(desired - start);
			 }
			 else {
				 this.count = 0;
				 this.pos = 0;
				 long delta = desired % bytesPerSum;
				 ((PositionCache)in).seek(desired - delta);
				 for (int i = 0;
				 i < delta;
				 i++) {
					 read();
				 }
			 }
		 }
		 public long getPos() throws IOException {
			 return ((PositionCache)in).getPos() - (this.count - this.pos);
		 }
		 public int read() throws IOException {
			 if (pos >= count) return super.read();
			 return buf[pos++] & 0xff;
		 }
	}
	 public FSDataInputStream(FileSystem fs, Path file, int bufferSize, Configuration conf) throws IOException {
		 super(null);
		 this.in = new Buffer(new PositionCache(new Checker(fs, file, conf)), bufferSize);
	 }
	 public FSDataInputStream(FileSystem fs, Path file, Configuration conf) throws IOException {
		 super(null);
		 int bufferSize = conf.getInt(""io.file.buffer.size"", 4096);
		 this.in = new Buffer(new PositionCache(new Checker(fs, file, conf)), bufferSize);
	 }
	 public FSDataInputStream(FSInputStream in, Configuration conf) throws IOException {
		 this(in, conf.getInt(""io.file.buffer.size"", 4096));
	 }
	 public FSDataInputStream(FSInputStream in, int bufferSize) throws IOException {
		 super(null);
		 this.in = new Buffer(new PositionCache(in), bufferSize);
	 }
	 public void seek(long desired) throws IOException {
		 ((Buffer)in).seek(desired);
	 }
	 public long getPos() throws IOException {
		 return ((Buffer)in).getPos();
	 }
}",0,0,0,0
"public class TestSchema {
	 private static MiniGenericCluster cluster;
	 private static PigServer pigServer;
	 public static void setupTestCluster() throws Exception {
		 cluster = MiniGenericCluster.buildCluster();
		 pigServer = new PigServer(cluster.getExecType(), cluster.getProperties());
	 }
	 public static void tearDownTestCluster() throws Exception {
		 cluster.shutDown();
	 }
	 public void testSchemaEqual1() {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList1.add(new FieldSchema(""11b"", DataType.LONG));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList2.add(new FieldSchema(""11b"", DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.INTEGER));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""1b"", innerSchema2));
		 list2.add(new FieldSchema(""1c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 assertTrue(Schema.equals(schema1, schema2, false, false));
		 innerList2.get(1).alias = ""pi"";
		 assertFalse(Schema.equals(schema1, schema2, false, false));
		 assertTrue(Schema.equals(schema1, schema2, false, true));
		 innerList2.get(1).alias = ""11b"";
		 innerList2.get(1).type = DataType.BYTEARRAY;
		 assertFalse(Schema.equals(schema1, schema2, false, false));
		 assertTrue(Schema.equals(schema1, schema2, true, false));
		 innerList2.get(1).type = DataType.LONG;
		 assertTrue(Schema.equals(schema1, schema2, false, false));
		 list2.get(0).type = DataType.CHARARRAY;
		 assertFalse(Schema.equals(schema1, schema2, false, false));
	 }
	 public void testSchemaEqualWithNullSchema1() {
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", null));
		 list1.add(new FieldSchema(""1c"", DataType.INTEGER));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""1b"", null));
		 list2.add(new FieldSchema(""1c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 assertTrue(Schema.equals(schema1, schema2, false, false));
		 List<FieldSchema> dummyList = new ArrayList<FieldSchema>();
		 Schema dummySchema = new Schema(dummyList);
		 list2.get(1).schema = dummySchema;
		 assertFalse(Schema.equals(schema1, schema2, false, false));
	 }
	 public void testParsingMapSchemasFromString() throws ParserException {
		 assertNotNull(Utils.getSchemaFromString(""b:[(a:int)]""));
		 assertNotNull(Utils.getSchemaFromString(""b:[someAlias: (b:int)]""));
		 assertNotNull(Utils.getSchemaFromString(""a:map[{
		bag: (a:int)}
		]""));
		 assertNotNull(Utils.getSchemaFromString(""a:map[someAlias: {
		bag: (a:int)}
		]""));
		 assertNotNull(Utils.getSchemaFromString(""a:map[chararray]""));
		 assertNotNull(Utils.getSchemaFromString(""a:map[someAlias: chararray]""));
		 assertNotNull(Utils.getSchemaFromString(""a:map[someAlias: (bar: {
		bag: (a:int)}
		)]""));
	 }
	 public void testMapWithoutAlias() throws FrontendException {
		 List<FieldSchema> innerFields = new ArrayList<FieldSchema>();
		 innerFields.add(new FieldSchema(null, DataType.LONG));
		 List<FieldSchema> fields = new ArrayList<FieldSchema>();
		 fields.add(new FieldSchema(""mapAlias"", new Schema(innerFields), DataType.MAP));
		 Schema inputSchema = new Schema(fields);
		 Schema fromString = Utils.getSchemaFromBagSchemaString(inputSchema.toString());
		 assertTrue(Schema.equals(inputSchema, fromString, false, false));
	 }
	 public void testMapWithAlias() throws FrontendException {
		 List<FieldSchema> innerFields = new ArrayList<FieldSchema>();
		 innerFields.add(new FieldSchema(""valueAlias"", DataType.LONG));
		 List<FieldSchema> fields = new ArrayList<FieldSchema>();
		 fields.add(new FieldSchema(""mapAlias"", new Schema(innerFields), DataType.MAP));
		 Schema inputSchema = new Schema(fields);
		 Schema fromString = Utils.getSchemaFromBagSchemaString(inputSchema.toString());
		 assertTrue(Schema.equals(inputSchema, fromString, false, false));
	 }
	 public void testNormalNestedMerge1() {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.LONG));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = schema1.merge(schema2, true);
		 List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
		 expectedInnerList.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 expectedInnerList.add(new FieldSchema(""11b"", DataType.FLOAT));
		 Schema expectedInner = new Schema(expectedInnerList);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", expectedInner));
		 expectedList.add(new FieldSchema(""2c"", DataType.LONG));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testMergeNullSchemas1() throws Throwable {
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", null));
		 list1.add(new FieldSchema(""1c"", DataType.LONG));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, false, true);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", null));
		 expectedList.add(new FieldSchema(""2c"", DataType.LONG));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testMergeNullSchemas2() throws Throwable {
		 Schema innerInner = new Schema(new ArrayList<FieldSchema>());
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", innerInner));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", null));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.LONG));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, false, true);
		 List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
		 expectedInnerList.add(new FieldSchema(""22a"", null));
		 expectedInnerList.add(new FieldSchema(""11b"", DataType.FLOAT));
		 Schema expectedInner = new Schema(expectedInnerList);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", expectedInner));
		 expectedList.add(new FieldSchema(""2c"", DataType.LONG));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testMergeDifferentSize1() throws Throwable {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 innerList1.add(new FieldSchema(""11c"", DataType.CHARARRAY));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.LONG));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 list2.add(new FieldSchema(""2d"", DataType.MAP));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, true, false);
		 List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
		 expectedInnerList.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 expectedInnerList.add(new FieldSchema(""11b"", DataType.FLOAT));
		 expectedInnerList.add(new FieldSchema(""11c"", DataType.CHARARRAY));
		 Schema expectedInner = new Schema(expectedInnerList);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", expectedInner));
		 expectedList.add(new FieldSchema(""2c"", DataType.LONG));
		 expectedList.add(new FieldSchema(""2d"", DataType.MAP));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testMergeDifferentSize2() throws Throwable {
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1c"", DataType.LONG));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 list2.add(new FieldSchema(""2d"", DataType.MAP));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, false, false);
	 }
	 public void testMergeMismatchType1() throws Throwable {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.CHARARRAY));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.MAP));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, false, true);
		 List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
		 expectedInnerList.add(new FieldSchema(""22a"", DataType.BYTEARRAY));
		 expectedInnerList.add(new FieldSchema(""11b"", DataType.FLOAT));
		 Schema expectedInner = new Schema(expectedInnerList);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", expectedInner));
		 expectedList.add(new FieldSchema(""2c"", DataType.BYTEARRAY));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testMergeMismatchType2() throws Throwable {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.CHARARRAY));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 Schema innerSchema1 = new Schema(innerList1);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.MAP));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, false, true);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", DataType.TUPLE));
		 expectedList.add(new FieldSchema(""2c"", DataType.BYTEARRAY));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testMergeMismatchType3() {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.CHARARRAY));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", DataType.DOUBLE));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.MAP));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.MAP));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 try {
			 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, false, false);
			 fail(""Expect error here!"");
		 }
		 catch (SchemaMergeException e) {
		 }
	 }
	 public void testMergeDifferentSizeAndTypeMismatch1() throws Throwable {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList1.add(new FieldSchema(""11b"", DataType.FLOAT));
		 innerList1.add(new FieldSchema(""11c"", DataType.CHARARRAY));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""22a"", DataType.CHARARRAY));
		 innerList2.add(new FieldSchema(null, DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.INTEGER));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.LONG));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""2a"", DataType.CHARARRAY));
		 list2.add(new FieldSchema(""2b"", innerSchema2));
		 list2.add(new FieldSchema(""2c"", DataType.INTEGER));
		 list2.add(new FieldSchema(""2d"", DataType.MAP));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema mergedSchema = Schema.mergeSchema(schema1, schema2, true, true, true);
		 List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
		 expectedInnerList.add(new FieldSchema(""22a"", DataType.BYTEARRAY));
		 expectedInnerList.add(new FieldSchema(""11b"", DataType.FLOAT));
		 expectedInnerList.add(new FieldSchema(""11c"", DataType.CHARARRAY));
		 Schema expectedInner = new Schema(expectedInnerList);
		 List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
		 expectedList.add(new FieldSchema(""2a"", DataType.BYTEARRAY));
		 expectedList.add(new FieldSchema(""2b"", expectedInner));
		 expectedList.add(new FieldSchema(""2c"", DataType.LONG));
		 expectedList.add(new FieldSchema(""2d"", DataType.MAP));
		 Schema expected = new Schema(expectedList);
		 assertTrue(Schema.equals(mergedSchema, expected, false, false));
	 }
	 public void testSchemaEqualTwoLevelAccess() throws Exception {
		 List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
		 innerList1.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList1.add(new FieldSchema(""11b"", DataType.LONG));
		 List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
		 innerList2.add(new FieldSchema(""11a"", DataType.INTEGER));
		 innerList2.add(new FieldSchema(""11b"", DataType.LONG));
		 Schema innerSchema1 = new Schema(innerList1);
		 Schema innerSchema2 = new Schema(innerList2);
		 List<FieldSchema> list1 = new ArrayList<FieldSchema>();
		 list1.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list1.add(new FieldSchema(""1b"", innerSchema1));
		 list1.add(new FieldSchema(""1c"", DataType.INTEGER));
		 List<FieldSchema> list2 = new ArrayList<FieldSchema>();
		 list2.add(new FieldSchema(""1a"", DataType.BYTEARRAY));
		 list2.add(new FieldSchema(""1b"", innerSchema2));
		 list2.add(new FieldSchema(""1c"", DataType.INTEGER));
		 Schema schema1 = new Schema(list1);
		 Schema schema2 = new Schema(list2);
		 Schema.FieldSchema bagFs1 = new Schema.FieldSchema(""b"", schema1, DataType.BAG);
		 Schema bagSchema1 = new Schema(bagFs1);
		 Schema.FieldSchema tupleFs = new Schema.FieldSchema(""t"", schema2, DataType.TUPLE);
		 Schema bagSchema = new Schema(tupleFs);
		 bagSchema.setTwoLevelAccessRequired(true);
		 Schema.FieldSchema bagFs2 = new Schema.FieldSchema(""b"", bagSchema, DataType.BAG);
		 Schema bagSchema2 = new Schema(bagFs2);
		 assertTrue(Schema.equals(bagSchema1, bagSchema2, false, false));
		 innerList2.get(1).alias = ""pi"";
		 assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false));
		 assertTrue(Schema.equals(bagSchema1, bagSchema2, false, true));
		 innerList2.get(1).alias = ""11b"";
		 innerList2.get(1).type = DataType.BYTEARRAY;
		 assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false));
		 assertTrue(Schema.equals(bagSchema1, bagSchema2, true, false));
		 innerList2.get(1).type = DataType.LONG;
		 assertTrue(Schema.equals(bagSchema1, bagSchema2, false, false));
		 list2.get(0).type = DataType.CHARARRAY;
		 assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false));
	 }
	 public void testCharArray2Numeric(){
		 byte[] numbericTypes=new byte[]{
		DataType.DOUBLE,DataType.FLOAT,DataType.LONG,DataType.INTEGER}
		;
		 Schema.FieldSchema inputFieldSchema=new Schema.FieldSchema("""",DataType.CHARARRAY);
		 for (byte type:numbericTypes){
			 Schema.FieldSchema castFieldSchema=new Schema.FieldSchema("""",type);
			 assertTrue(Schema.FieldSchema.castable(castFieldSchema, inputFieldSchema));
		 }
	 }
	 public void testSchemaSerialization() throws IOException {
		 String inputFileName = ""testSchemaSerialization-input.txt"";
		 String[] inputData = new String[] {
		 ""foo\t1"", ""hello\t2"" }
		;
		 Util.createInputFile(cluster, inputFileName, inputData);
		 String script = ""a = load '""+ inputFileName +""' as (f1:chararray, f2:int);
		"" + "" b = group a all;
		 c = foreach b generate org.apache.pig.test.InputSchemaUDF(a);
		"";
		 Util.registerMultiLineQuery(pigServer, script);
		 Iterator<Tuple> it = pigServer.openIterator(""c"");
		 while(it.hasNext()) {
			 Tuple t = it.next();
			 assertEquals(""{
				a: {
				(f1: chararray,f2: int)}
			}
			"", t.get(0));
		 }
	 }
	 public void testMergeSchemaWithTwoLevelAccess1() throws Exception {
		 Schema s1 = Utils.getSchemaFromString(""a:{
		t:(a0:int, a1:int)}
		"");
		 Schema s2 = Utils.getSchemaFromString(""b:{
		t:(b0:int, b1:int)}
		"");
		 s1.getField(0).schema.setTwoLevelAccessRequired(true);
		 s2.getField(0).schema.setTwoLevelAccessRequired(true);
		 Schema s3 = Schema.mergeSchema(s1, s2, true);
		 assertTrue(s3.getField(0).schema.isTwoLevelAccessRequired());
	 }
	 public void testMergeSchemaWithTwoLevelAccess() throws Exception {
		 Schema s1 = Utils.getSchemaFromString(""a:{
		t:(a0:int, a1:int)}
		"");
		 Schema s2 = Utils.getSchemaFromString(""b:{
		t:(b0:int, b1:int)}
		"");
		 s1.getField(0).schema.setTwoLevelAccessRequired(true);
		 s1.getField(0).schema.setTwoLevelAccessRequired(false);
		 Schema s3 = Schema.mergeSchema(s1, s2, true);
		 assertEquals(s3, s2);
	 }
	 public void testMergeSchemaWithTwoLevelAccess3() throws Exception {
		 LogicalSchema ls1 = Utils.parseSchema(""a:{
		t:(a0:int, a1:int)}
		"");
		 LogicalSchema ls2 = Utils.parseSchema(""b:{
		t:(b0:int, b1:int)}
		"");
		 LogicalSchema ls3 = LogicalSchema.merge(ls1, ls2, MergeMode.LoadForEach);
		 assertEquals(""{
			a: {
			t: (a0: int,a1: int)}
		}
		"", org.apache.pig.newplan.logical.Util.translateSchema(ls3).toString());
	 }
	 public void testNewNormalNestedMerge1() throws Exception {
		 LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:bytearray, b1:(b11:int, b12:float), c1:long""));
		 LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:bytearray, b2:(b21:double, b22:long), c2:int""));
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:bytearray, b1:(), c1:long""));
		 expected.getField(1).schema = new LogicalSchema();
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
		 expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:bytearray, b1:(b11:int, b12:float), c1:long""));
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 mergedSchema = LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
		 expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:bytearray, b2:(b21:double, b22:long), c2:int""));
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
	 }
	 public void testNewNormalNestedMerge2() throws Exception {
		 LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:(a11:chararray, a12:float), b1:(b11:chararray, b12:float), c1:long""));
		 LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:bytearray, b2:(b21:double, b22:long), c2:chararray""));
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:(a11:chararray, a12:float), b1:(), c1:bytearray""));
		 expected.getField(1).schema = new LogicalSchema();
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
		 expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:(a11:chararray, a12:float), b1:(b11:chararray, b12:float), c1:long""));
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 mergedSchema = LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
		 expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:(a11:chararray, a12:float), b2:(b21:double, b22:long), c2:chararray""));
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
	 }
	 public void testNewMergeNullSchemas() throws Throwable {
		 LogicalSchema a = Utils.parseSchema( ""a1:bytearray, b1:(b11:int, b12:float), c1:long"" );
		 LogicalSchema b = Utils.parseSchema( ""a2:bytearray, b2:(), c2:int"" );
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 LogicalSchema expected = Utils.parseSchema( ""a1:bytearray, b1:(), c1:long"" );
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
		 expected = Utils.parseSchema( ""a1:bytearray, b1:(b11:int, b12:float), c1:long"" );
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 mergedSchema = LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
		 expected = Utils.parseSchema( ""a2:bytearray, b2:(b11:int,b12:float), c2:int"" );
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
	 }
	 public void testNewMergeDifferentSize1() throws Throwable {
		 LogicalSchema a = Utils.parseSchema( ""a1:bytearray, b1:long, c1:long"" );
		 LogicalSchema b = Utils.parseSchema( ""a2:bytearray, b2:long"" );
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 assertNull(mergedSchema);
		 try {
			 LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
		 }
		 catch (FrontendException e) {
			 assertEquals(1031, e.getErrorCode());
			 throw e;
		 }
	 }
	 public void testNewMergeDifferentSize2() throws Throwable {
		 LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:bytearray, b1:(b11:int, b12:float, b13:float), c1:long""));
		 LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:bytearray, b2:(b21:double, b22:long), c2:int""));
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:bytearray, b1:(), c1:long""));
		 expected.getField(1).schema = new LogicalSchema();
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 try {
			 LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
		 }
		 catch (FrontendException e) {
			 assertEquals(1031, e.getErrorCode());
			 throw e;
		 }
	 }
	 public void testNewMergeMismatchType1() throws Throwable {
		 LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:chararray, b1:long, c1:long""));
		 LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:bytearray, b2:(b21:double, b22:long), c2:int""));
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:chararray, b1:bytearray, c1:long""));
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 try {
			 LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
			 fail();
		 }
		 catch (FrontendException e) {
			 assertEquals(1031, e.getErrorCode());
		 }
		 try {
			 LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
		 }
		 catch (FrontendException e) {
			 assertEquals(1031, e.getErrorCode());
			 throw e;
		 }
	 }
	 public void testNewMergeMismatchType2() throws Throwable {
		 LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:chararray, b1:(b11:double, b12:(b121:int)), c1:long""));
		 LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a2:bytearray, b2:(b21:double, b22:long), c2:int""));
		 LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
		 LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString( ""a1:chararray, b1:(), c1:long""));
		 expected.getField(1).schema = new LogicalSchema();
		 assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
		 try {
			 LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
			 fail();
		 }
		 catch (FrontendException e) {
			 assertEquals(1031, e.getErrorCode());
		 }
		 try {
			 LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
		 }
		 catch (FrontendException e) {
			 assertEquals(1031, e.getErrorCode());
			 throw e;
		 }
	 }
	 public void testResourceSchemaToSchema() throws ParserException,FrontendException{
		 Schema s1 = Utils.getSchemaFromString(""b:bag{
		t:tuple(name:chararray,age:int)}
		"");
		 Schema s2 = Schema.getPigSchema(new ResourceSchema(s1));
		 assertEquals(s1, s2);
	 }
	 public void testGetStringFromSchema() throws ParserException {
		 String[] schemaStrings = {
			 ""a:int"", ""a:long"", ""a:chararray"", ""a:double"", ""a:float"", ""a:bytearray"", ""b:bag{
			tuple(x:int,y:int,z:int)}
			"", ""b:bag{
			t:tuple(x:int,y:int,z:int)}
			"", ""a:int,b:chararray,c:Map[int]"", ""a:double,b:float,t:tuple(x:int,y:double,z:bytearray)"", ""a:double,b:float,t:tuple(x:int,b:bag{
				t:tuple(a:int,b:float,c:double,x:tuple(z:bag{
				r:tuple(z:bytearray)}
			))}
			,z:bytearray)"", ""a,b,t:tuple(x,b:bag{
				t:tuple(a,b,c,x:tuple(z:bag{
				r:tuple(z)}
			))}
			,z)"", ""a:bag{
				t:tuple(a:bag{
					t:tuple(a:bag{
						t:tuple(a:bag{
							t:tuple(a:bag{
								t:tuple(a:bag{
								t:tuple(a:int,b:float)}
							)}
						)}
					)}
				)}
			)}
			"", ""a:bag{
			}
			"", ""b:{
			null:(a:int)}
			"", ""int,int,int,int,int,int,int,int,int,int"", ""long,long,long,long,long,long,long,long,long,long"", ""float,float,float,float,float,float,float,float,float,float"", ""double,double,double,double,double,double,double,double,double,double"", ""boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean"", ""datetime,datetime,datetime,datetime,datetime,datetime,datetime,datetime,datetime,datetime"", ""{
			}
			,{
			}
			,{
			}
			,{
			}
			,{
			}
			,{
			}
			,{
			}
			,{
			}
			,{
			}
			,{
			}
			"", ""map[],map[],map[],map[],map[],map[],map[],map[],map[],map[]"", ""int,int,long,long,float,float,double,double,boolean,boolean,datetime,datetime,(int,long,float,double,boolean,datetime),{
			(int,long,float,double,boolean,datetime)}
		,map[(int,long,float,double,boolean,datetime)]"" }
		;
		 for (String schemaString : schemaStrings) {
			 Schema s1 = Utils.getSchemaFromString(schemaString);
			 String s=s1.toString();
			 Schema s2 = Utils.getSchemaFromBagSchemaString(s);
			 assertTrue(Schema.equals(s1,s2,false,true));
		 }
	 }
	 public void testGetStringFromSchemaNegative() throws Exception {
		 String schemaString = ""a:int b:long"";
		 Utils.getSchemaFromString(schemaString);
		 fail(""The schema string is invalid, so parsing should fail!"");
	 }
	 public void testGetInitialSchemaStringFromSchema() throws ParserException {
		 String[] schemaStrings = {
			 ""my_list:{
			array:(array_element:(num1:int,num2:int))}
			"", ""my_list:{
			array:(array_element:(num1:int,num2:int),c:chararray)}
			"", ""bag:{
			mytuple3:(mytuple2:(mytuple:(f1:int)))}
			"", ""bag:{
			mytuple:(f1:int)}
			"", ""{
			((num1:int,num2:int))}
		"" }
		;
		 for (String schemaString : schemaStrings) {
			 String s1 = Utils.getSchemaFromString(schemaString).toString();
			 String s2 = s1.substring(1, s1.length() - 1).replaceAll(""\\s|bag_0:|tuple_0:"", """");
			 assertTrue(schemaString.equals(s2));
		 }
	 }
	 public void testDisabledDisambiguationContainsNoColons() throws IOException {
		 resetDisambiguationTestPropertyOverride();
		 String inputFileName = ""testPrepend-input.txt"";
		 String[] inputData = new String[]{
		""apple\t1\tred"", ""orange\t2\torange"", ""kiwi\t3\tgreen"", ""orange\t4\torange""}
		;
		 Util.createInputFile(cluster, inputFileName, inputData);
		 String script = ""A = LOAD '"" + inputFileName + ""' AS (fruit:chararray, foo:int, color: chararray);
		"" + ""B = LOAD '"" + inputFileName + ""' AS (id:chararray, bar:int);
		"" + ""C = GROUP A BY (fruit,color);
		"" + ""D = FOREACH C GENERATE FLATTEN(group), AVG(A.foo);
		"" + ""D2 = FOREACH C GENERATE FLATTEN(group), AVG(A.foo) as avgFoo;
		"" + ""E = JOIN B BY id, D BY group::fruit;
		"" + ""F = UNION ONSCHEMA B, D2;
		"" + ""G = CROSS B, D2;
		"";
		 Util.registerMultiLineQuery(pigServer, script);
		 assertEquals(""{
		B::id: chararray,B::bar: int,D::group::fruit: chararray,D::group::color: chararray,double}
		"", pigServer.dumpSchema(""E"").toString());
		 pigServer.getPigContext().getProperties().setProperty(PigConfiguration.PIG_STORE_SCHEMA_DISAMBIGUATE, ""false"");
		 assertEquals(""{
		id: chararray,bar: int,fruit: chararray,color: chararray,double}
		"", pigServer.dumpSchema(""E"").toString());
		 assertTrue(pigServer.openIterator(""E"").hasNext());
		 assertEquals(""{
		id: chararray,bar: int,fruit: chararray,color: chararray,avgFoo: double}
		"", pigServer.dumpSchema(""F"").toString());
		 assertEquals(""{
		id: chararray,bar: int,fruit: chararray,color: chararray,avgFoo: double}
		"", pigServer.dumpSchema(""G"").toString());
	 }
	 public void testDisabledDisambiguationContainsNoColonsForNestedSchema() throws IOException {
		 resetDisambiguationTestPropertyOverride();
		 String inputFileName = ""testPrepend-nested-input.txt"";
		 String[] inputData = new String[]{
		""apple\t1\tred"", ""orange\t2\torange"", ""kiwi\t3\tgreen"", ""orange\t4\torange""}
		;
		 Util.createInputFile(cluster, inputFileName, inputData);
		 String script = ""A = LOAD '"" + inputFileName + ""' AS (fruit:chararray, foo:int, color: chararray);
		"" + ""B = LOAD '"" + inputFileName + ""' AS (id:chararray, bar:int);
		"" + ""C = JOIN A by fruit, B by id;
		"" + ""D = GROUP C by fruit;
		"" + ""E = LOAD '"" + inputFileName + ""' AS (name:chararray, qwe:int);
		"" + ""F = JOIN E by name, D by group;
		"";
		 Util.registerMultiLineQuery(pigServer, script);
		 assertEquals(""{
			E::name: chararray,E::qwe: int,D::group: chararray,D::C: {
			(A::fruit: chararray,A::foo: int,A::color: chararray,B::id: chararray,B::bar: int)}
		}
		"", pigServer.dumpSchema(""F"").toString());
		 pigServer.getPigContext().getProperties().setProperty(PigConfiguration.PIG_STORE_SCHEMA_DISAMBIGUATE, ""false"");
		 assertEquals(""{
			name: chararray,qwe: int,group: chararray,C: {
			(fruit: chararray,foo: int,color: chararray,id:"" + "" chararray,bar: int)}
		}
		"", pigServer.dumpSchema(""F"").toString());
		 assertTrue(pigServer.openIterator(""F"").hasNext());
	 }
	 public void testEnabledDisambiguationPassesForDupeAliases() throws IOException {
		 resetDisambiguationTestPropertyOverride();
		 checkForDupeAliases();
		 assertEquals(""{
		A::id: chararray,A::val: int,B::id: chararray,B::val: int}
		"", pigServer.dumpSchema(""C"").toString());
		 assertTrue(pigServer.openIterator(""C"").hasNext());
	 }
	 public void testDisabledDisambiguationFailsForDupeAliases() throws IOException {
		 resetDisambiguationTestPropertyOverride();
		 try {
			 checkForDupeAliases();
			 pigServer.getPigContext().getProperties().setProperty(PigConfiguration.PIG_STORE_SCHEMA_DISAMBIGUATE, ""false"");
			 pigServer.dumpSchema(""C"");
		 }
		 catch (FrontendException e){
			 Assert.assertEquals(""Duplicate schema alias: id in \""fake\"""",e.getCause().getMessage());
		 }
	 }
	 private static void checkForDupeAliases() throws IOException {
		 String inputFileName = ""testPrependFail-input"" + UUID.randomUUID().toString() + "".txt"";
		 String[] inputData = new String[]{
		""foo\t1"", ""bar\t2""}
		;
		 Util.createInputFile(cluster, inputFileName, inputData);
		 String script = ""A = LOAD '"" + inputFileName + ""' AS (id:chararray, val:int);
		"" + ""B = LOAD '"" + inputFileName + ""' AS (id:chararray, val:int);
		"" + ""C = JOIN A by id, B by id;
		"";
		 Util.registerMultiLineQuery(pigServer, script);
	 }
	 private static void resetDisambiguationTestPropertyOverride() {
		 pigServer.getPigContext().getProperties().remove(PigConfiguration.PIG_STORE_SCHEMA_DISAMBIGUATE);
	 }
}",1,0,0,0
"public class _BuildWebServiceSoap_UpdateBuildDefinitions implements ElementSerializable{
	 protected _BuildDefinition[] updates;
	 public _BuildWebServiceSoap_UpdateBuildDefinitions() {
		 super();
	 }
	 public _BuildWebServiceSoap_UpdateBuildDefinitions(final _BuildDefinition[] updates) {
		 setUpdates(updates);
	 }
	 public _BuildDefinition[] getUpdates() {
		 return this.updates;
	 }
	 public void setUpdates(_BuildDefinition[] value) {
		 this.updates = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 if (this.updates != null) {
			 writer.writeStartElement(""updates"");
			 for (int iterator0 = 0;
			 iterator0 < this.updates.length;
			 iterator0++) {
				 this.updates[iterator0].writeAsElement( writer, ""BuildDefinition"");
			 }
			 writer.writeEndElement();
		 }
		 writer.writeEndElement();
	 }
}",1,1,0,0
"public class BaseScriptEvalUtil{
	private static Logger logger = Logger.getLogger( BaseScriptEvalUtil.class.getName( ) );
	protected BaseScriptEvalUtil( ){
	}
	public static ExprTextAndValue newExprInfo( Object value ){
		return ExprTextAndValue.newInstance( value );
	}
	public static Object evalConditionalExpr( Object obj, int operator,Object Op1, Object Op2 ) throws DataException{
		return evalConditionalExpr( obj, operator, Op1, Op2, null );
	}
	public static Object evalConditionalExpr( Object obj, int operator,Object Op1, Object Op2, BaseCompareHints compareHints )throws DataException{
		return evalConditionalExpr( obj, operator, new Object[]{
		Op1, Op2}
		, compareHints );
	}
	public static Object evalConditionalExpr( Object obj, int operator,Object[] ops ) throws DataException{
		return evalConditionalExpr( obj, operator, ops, null );
	}
	public static Object evalConditionalExpr( Object obj, int operator,Object[] ops, BaseCompareHints compareHints ) throws DataException{
		ExprTextAndValue[] opTextAndValue = new ExprTextAndValue[ops.length];
		for ( int i = 0;
		 i < ops.length;
		 i++ ){
			opTextAndValue[i] = createExprTextAndValueInstance( ops[i] );
		}
		Object resultObject = obj;
		Object[] resultOp = new Object[ops.length];
		for ( int i = 0;
		 i < ops.length;
		 i++ ){
			resultOp[i] = opTextAndValue[i].value;
			if ( operator != IConditionalExpression.OP_IN && operator != IConditionalExpression.OP_NOT_IN ){
				if ( opTextAndValue[i].value != null && opTextAndValue[i].value.getClass( ).isArray( )){
					if ( Array.getLength( opTextAndValue[i].value ) > 1 ){
						throw new DataException(ResourceConstants.BAD_COMPARE_SINGLE_WITH_MULITI, toStringForMultiValues( opTextAndValue[i].value ) );
					}
					if ( Array.getLength( opTextAndValue[i].value ) == 0 ){
						resultOp[i] = null;
					}
					else if ( Array.getLength( opTextAndValue[i].value ) == 1 ){
						resultOp[i] = Array.get( opTextAndValue[i].value, 0 );
					}
					opTextAndValue[i].value = resultOp[i];
				}
			}
		}
		Object[] obArray = MiscUtil.isComparable( obj, operator, opTextAndValue );
		if ( obArray != null ){
			resultObject = obArray[0];
			for ( int i = 1;
			 i < obArray.length;
			 i++ ){
				resultOp[i - 1] = obArray[i];
			}
		}
		if ( logger.isLoggable( Level.FINER ) ){
			String logStr = """";
			for ( int i = 0;
			 i < ops.length;
			 i++ ){
				logStr += resultOp[i] == null? null: ( "", resultOp"" + i + ""="" + BaseLogUtil.toString( resultOp[i] ) );
			}
			logger.entering( BaseScriptEvalUtil.class.getName( ),""evalConditionalExpr"",""evalConditionalExpr() resultObject=""+ BaseLogUtil.toString( resultObject ) + "", operator=""+ operator + logStr );
		}
		boolean result = false;
		if ( compareHints != null&& IBaseDataSetDesign.NULLS_ORDERING_EXCLUDE_NULLS.equals( compareHints.getNullType( ) ) ){
			if ( resultObject == null )return false;
		}
		switch ( operator ){
			case IConditionalExpression.OP_EQ :result = compare( resultObject, resultOp[0], compareHints ) == 0;
			break;
			case IConditionalExpression.OP_NE :result = compare( resultObject, resultOp[0], compareHints ) != 0;
			break;
			case IConditionalExpression.OP_LT :result = compare( resultObject, resultOp[0], compareHints ) < 0;
			break;
			case IConditionalExpression.OP_LE :result = compare( resultObject, resultOp[0], compareHints ) <= 0;
			break;
			case IConditionalExpression.OP_GE :result = compare( resultObject, resultOp[0], compareHints ) >= 0;
			break;
			case IConditionalExpression.OP_GT :result = compare( resultObject, resultOp[0], compareHints ) > 0;
			break;
			case IConditionalExpression.OP_BETWEEN :result = between( resultObject,resultOp[0],resultOp[1],compareHints );
			break;
			case IConditionalExpression.OP_NOT_BETWEEN :result = !( between( resultObject,resultOp[0],resultOp[1],compareHints ) );
			break;
			case IConditionalExpression.OP_NULL :result = resultObject == null;
			break;
			case IConditionalExpression.OP_NOT_NULL :result = resultObject != null;
			break;
			case IConditionalExpression.OP_TRUE :result = isTrueOrFalse( resultObject, Boolean.TRUE );
			break;
			case IConditionalExpression.OP_FALSE :result = isTrueOrFalse( resultObject, Boolean.FALSE );
			break;
			case IConditionalExpression.OP_LIKE :result = like( resultObject, resultOp[0] );
			break;
			case IConditionalExpression.OP_NOT_LIKE :result = !like( resultObject, resultOp[0] );
			break;
			case IConditionalExpression.OP_TOP_N :case IConditionalExpression.OP_BOTTOM_N :case IConditionalExpression.OP_TOP_PERCENT :case IConditionalExpression.OP_BOTTOM_PERCENT :throw new DataException(ResourceConstants.UNSUPPORTTED_COND_OPERATOR, ""Top/Bottom(N) outside of row filters"" );
			case IConditionalExpression.OP_MATCH :result = match( resultObject, resultOp[0] );
			break;
			case IConditionalExpression.OP_NOT_MATCH :result = !match( resultObject, resultOp[0] );
			break;
			case IConditionalExpression.OP_IN :result = in( resultObject, resultOp );
			break;
			case IConditionalExpression.OP_NOT_IN :result = !in( resultObject, resultOp );
			break;
			case IConditionalExpression.OP_JOINT :result = joint( resultObject, resultOp[0] );
			break;
			default :throw new DataException(ResourceConstants.UNSUPPORTTED_COND_OPERATOR, Integer.valueOf( operator) );
		}
		logger.exiting( BaseScriptEvalUtil.class.getName( ),""evalConditionalExpr"", Boolean.valueOf( result ) );
		return Boolean.valueOf( result );
	}
	private static ExprTextAndValue createExprTextAndValueInstance( Object o ){
		ExprTextAndValue op;
		if(! (o instanceof ExprTextAndValue ))op = ExprTextAndValue.newInstance( o );
		elseop = (ExprTextAndValue)o;
		return op;
	}
	public static int compare( Object obj1, Object obj2,BaseCompareHints compareHints ) throws DataException{
		if ( obj1 == null || obj2 == null ){
			return CompareNullValue( obj1, obj2, compareHints );
		}
		try{
			if ( MiscUtil.isSameType( obj1, obj2 ) ){
				if ( obj1 instanceof String ){
					if ( compareHints == null ) return ( (String)obj1 ).compareTo( (String)obj2 );
					return compareAsString( obj1, obj2, compareHints );
				}
				else if ( obj1 instanceof Boolean ){
					if ( obj1.equals( obj2 ) )return 0;
					Boolean bool = (Boolean) obj1;
					if ( bool.equals( Boolean.TRUE ) )return 1;
					elsereturn -1;
				}
				else if ( obj1 instanceof Comparable ){
					return ( (Comparable) obj1 ).compareTo( obj2 );
				}
				else if ( obj1 instanceof Collection ){
					Collection o1 = (Collection) obj1;
					Collection o2 = (Collection) obj2;
					if ( o1.size( ) != o2.size( ) )return -1;
					Iterator it1 = o1.iterator( );
					Iterator it2 = o2.iterator( );
					while ( it1.hasNext( ) ){
						int result = compare( it1.next( ), it2.next( ) );
						if ( result != 0 )return result;
					}
					return 0;
				}
				else{
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( MiscUtil.isBigDecimal( obj1 )|| MiscUtil.isBigDecimal( obj2 ) ){
				BigDecimal a = DataTypeUtil.toBigDecimal( obj1 );
				BigDecimal b = DataTypeUtil.toBigDecimal( obj2 );
				return a.compareTo( b );
			}
			else if ( MiscUtil.isNumericOrString( obj1 )&& MiscUtil.isNumericOrString( obj2 ) ){
				try{
					return DataTypeUtil.toDouble( obj1 ).compareTo( DataTypeUtil.toDouble( obj2 ) );
				}
				catch ( Exception e ){
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( MiscUtil.isDateOrString( obj1 )&& MiscUtil.isDateOrString( obj2 ) ){
				try{
					return DataTypeUtil.toDate( obj1 ).compareTo( DataTypeUtil.toDate( obj2 ) );
				}
				catch ( Exception e ){
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( MiscUtil.isBooleanOrString( obj1 )&& MiscUtil.isBooleanOrString( obj2 ) ){
				try{
					boolean b1 = DataTypeUtil.toBoolean( obj1 ).booleanValue( );
					boolean b2 = DataTypeUtil.toBoolean( obj2 ).booleanValue( );
					if ( b1 == b2 ){
						return 0;
					}
					else if ( b1 == false && b2 == true ){
						return -1;
					}
					else{
						return 1;
					}
				}
				catch ( Exception e ){
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( obj1 instanceof String || obj2 instanceof String ){
				return compareAsString( obj1, obj2, compareHints );
			}
			elsethrow new DataException( ResourceConstants.BAD_COMPARE_EXPR,new Object[]{
			obj1, obj2}
			 );
		}
		catch ( BirtException e ){
			throw DataException.wrap( e );
		}
	}
	private static String toStringForMultiValues( Object o ){
		if ( o == null ){
			return null;
		}
		if ( o.getClass( ).isArray( ) && Array.getLength( o ) > 1 ){
			StringBuilder buf = new StringBuilder( );
			buf.append(Array.get( o, 0 ));
			buf.append("", "");
			buf.append(Array.get( o, 1));
			buf.append( ""..."");
			return buf.toString( );
		}
		return o.toString( );
	}
	private static int CompareNullValue( Object obj1, Object obj2,BaseCompareHints compareHints ){
		if ( compareHints == null ){
			if ( obj1 == null && obj2 != null )return -1;
			else if ( obj1 != null && obj2 == null )return 1;
			elsereturn 0;
		}
		else{
			String type = compareHints.getNullType( );
			if ( IBaseDataSetDesign.NULLS_ORDERING_NULLS_HIGHEST.equals( type ) ){
				if ( obj1 == null && obj2 != null )return 1;
				else if ( obj1 != null && obj2 == null )return -1;
				elsereturn 0;
			}
			else if ( IBaseDataSetDesign.NULLS_ORDERING_NULLS_LOWEST.equals( type ) ){
				if ( obj1 == null && obj2 != null )return -1;
				else if ( obj1 != null && obj2 == null )return 1;
				elsereturn 0;
			}
			else{
				if ( obj1 == null && obj2 != null )return -1;
				else if ( obj1 != null && obj2 == null )return 1;
				elsereturn 0;
			}
		}
	}
	private static int compareAsString( Object obj1, Object obj2,BaseCompareHints comp ) throws BirtException{
		return ( comp == null || comp.getComparator( ) == null )? DataTypeUtil.toString( obj1 ).compareTo( DataTypeUtil.toString( obj2 ) ): comp.getComparator( ).compare( DataTypeUtil.toString( obj1 ),DataTypeUtil.toString( obj2 ) );
	}
	public static int compare( Object obj1, Object obj2 ) throws DataException{
		return compare( obj1, obj2, null );
	}
	private static boolean between( Object resultObject, Object resultOp1,Object resultOp2, BaseCompareHints compareHints ) throws DataException{
		return compare( resultObject, resultOp1, compareHints ) >= 0&& compare( resultObject, resultOp2, compareHints ) <= 0;
	}
	private static boolean isTrueOrFalse( Object obj, Boolean bln ){
		if ( obj == null )return false;
		try{
			return DataTypeUtil.toBoolean( obj ).equals( bln );
		}
		catch ( BirtException e ){
			return false;
		}
	}
	private static Pattern s_JSReExprPattern;
	private static Matcher getJSReExprPatternMatcher( String patternStr ){
		if ( s_JSReExprPattern == null )s_JSReExprPattern = Pattern.compile(""^/(.*)/([a-zA-Z]*)$"");
		return s_JSReExprPattern.matcher( patternStr );
	}
	private static boolean match( Object source, Object pattern ) throws DataException{
		String sourceStr = null;
		try{
			sourceStr = (source == null)? """": DataTypeUtil.toLocaleNeutralString( source );
		}
		catch ( BirtException e1 ){
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
		String patternStr;
		try{
			patternStr = ( pattern == null )? """" : DataTypeUtil.toLocaleNeutralString( pattern );
		}
		catch ( BirtException e1 ){
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
		Matcher jsReExprMatcher = getJSReExprPatternMatcher( patternStr );
		 int flags = 0;
		if ( jsReExprMatcher.matches() ){
			String flagStr = patternStr.substring( jsReExprMatcher.start(2), jsReExprMatcher.end(2) );
			for ( int i = 0;
			 i < flagStr.length();
			 i++){
				switch ( flagStr.charAt(i) ){
					case 'm': flags |= Pattern.MULTILINE;
					 break;
					case 'i': flags |= Pattern.CASE_INSENSITIVE;
					 break;
					case 'g': break;
					default:throw new DataException( ResourceConstants.MATCH_ERROR, patternStr );
				}
			}
			patternStr = patternStr.substring( jsReExprMatcher.start(1), jsReExprMatcher.end(1) );
		}
		try{
			Matcher m = Pattern.compile( patternStr, flags ).matcher( sourceStr);
			return m.find();
		 }
		catch ( PatternSyntaxException e ){
			throw new DataException( ResourceConstants.MATCH_ERROR, e, patternStr );
		}
	}
	private static boolean like( Object source, Object pattern ) throws DataException{
		String sourceStr = null;
		try{
			sourceStr = (source == null)? """": DataTypeUtil.toLocaleNeutralString( source );
		}
		catch ( BirtException e1 ){
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
		String patternStr;
		try{
			patternStr = ( pattern == null )? """" : DataTypeUtil.toLocaleNeutralString( pattern );
		}
		catch ( BirtException e1 ){
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
		final String reservedChars = ""([{
			^$|)?*+."";
			int patternLen = patternStr.length();
			StringBuffer buffer = new StringBuffer( patternLen * 2 );
			for ( int i = 0;
			 i < patternLen;
			 i++){
				char c = patternStr.charAt(i);
				if ( c == '\\' ){
					++i;
					if ( i < patternLen ){
						c = patternStr.charAt( i );
						if ( c == '%' || c == '_' )buffer.append( c );
						else if ( c == '\\' )buffer.append( ""\\\\"");
					}
					else{
						buffer.append( ""\\\\"" );
					 }
				}
				else if ( c == '%'){
					buffer.append("".*"");
				}
				else if ( c == '_'){
					buffer.append(""."");
				}
				else{
					if ( reservedChars.indexOf(c) >= 0 ){
						buffer.append('\\');
					}
					buffer.append(c);
				}
			}
			try{
				String newPatternStr = buffer.toString();
				Pattern p = Pattern.compile( newPatternStr );
				Matcher m = p.matcher( sourceStr.toString( ) );
				return m.matches( );
			}
			catch ( PatternSyntaxException e ){
				throw new DataException( ResourceConstants.MATCH_ERROR, e, pattern );
			}
		}
		private static boolean in( Object target, Object[] resultObj )throws DataException{
			if ( resultObj == null )return false;
			for ( int i = 0;
			 i < resultObj.length;
			 i++ ){
				if ( compare( target, resultObj[i] ) == 0 )return true;
			}
			return false;
		}
		private static boolean joint( Object target, Object resultObj )throws DataException{
			if ( resultObj == null || target == null )return false;
			return !java.util.Collections.disjoint( Arrays.asList( target.toString( ).split( "","" )),Arrays.asList( resultObj.toString( ).split( "","" ) ) ) ;
		}
		public static Object evalExpr( IBaseExpression expr, ScriptContext cx,String source, int lineNo ) throws DataException{
			try{
				if ( logger.isLoggable( Level.FINER ) )logger.entering( BaseScriptEvalUtil.class.getName( ),""evalExpr"",""evalExpr() expr=""+ BaseLogUtil.toString( expr ) + "", source=""+ source + "", lineNo="" + lineNo );
				Object result;
				if ( expr == null ){
					result = null;
				}
				else if ( expr instanceof IConditionalExpression ){
					Object handle = expr.getHandle( );
					if ( handle instanceof BaseNEvaluator ){
						result = Boolean.valueOf( ( (BaseNEvaluator) handle ).evaluate( cx,( (IDataScriptEngine) cx.getScriptEngine( IDataScriptEngine.ENGINE_NAME ) ).getJSScope( cx ) ) );
					}
					else{
						ConditionalExpression conditionalExpr = (ConditionalExpression) expr;
						Object expression = evalExpr( conditionalExpr.getExpression( ),cx,source,lineNo );
						if ( conditionalExpr.getOperand1( ) instanceof IExpressionCollection ){
							IExpressionCollection combinedExpr = (IExpressionCollection) ( (IConditionalExpression) expr ).getOperand1( );
							Object[] exprs = combinedExpr.getExpressions( ).toArray( );
							Object[] opValues = new Object[exprs.length];
							for ( int i = 0;
							 i < opValues.length;
							 i++ ){
								opValues[i] = evalExpr( (IBaseExpression) exprs[i],cx,source,lineNo );
							}
							result = evalConditionalExpr( expression,conditionalExpr.getOperator( ),MiscUtil.flatternMultipleValues( opValues ),null );
						}
						else{
							Object Op1 = evalExpr( MiscUtil.constructValidScriptExpression( (IScriptExpression) conditionalExpr.getOperand1( ) ),cx,source,lineNo );
							Object Op2 = evalExpr( MiscUtil.constructValidScriptExpression( (IScriptExpression) conditionalExpr.getOperand2( ) ),cx,source,lineNo );
							result = evalConditionalExpr( expression,conditionalExpr.getOperator( ),new Object[]{
							Op1, Op2}
							,null );
						}
					}
				}
				else if ( expr instanceof ICollectionConditionalExpression ){
					Collection<IScriptExpression> testExpr = ((ICollectionConditionalExpression)expr).getExpr( );
					Collection<Collection<IScriptExpression>> operand = ((ICollectionConditionalExpression)expr).getOperand( );
					List<Object> testObj = new ArrayList<Object>( );
					boolean in = false;
					for( IScriptExpression se : testExpr ){
						testObj.add( evalExpr( se, cx, source, lineNo ) );
					}
					for( Collection<IScriptExpression> op : operand ){
						List<Object> targetObj = new ArrayList<Object>( );
						for( IScriptExpression se : op ){
							if( se == null ){
								targetObj.add( null );
							}
							else{
								if( se.getHandle( )== null ){
									se.setHandle( evalExpr( se, cx, source, lineNo ) );
								}
								targetObj.add( se.getHandle( ) );
							}
						}
						if( compareIgnoreNull( testObj, targetObj ) == 0 ){
							in = Boolean.TRUE;
							break;
						}
					}
					result = ( ( (ICollectionConditionalExpression) expr ).getOperator( ) == ICollectionConditionalExpression.OP_IN )? in : ( !in );
				}
				else{
					IScriptExpression jsExpr = (IScriptExpression) expr;
					if( BaseExpression.constantId.equals( jsExpr.getScriptId( ) ) && jsExpr.getHandle( ) != null ){
						result = jsExpr.getHandle( );
					}
					else{
						if( BaseExpression.constantId.equals( jsExpr.getScriptId( ) ) ){
							result = jsExpr.getText( );
							jsExpr.setHandle( result );
						}
						else if ( jsExpr.getText( ) != null && jsExpr.getHandle( ) != null ){
							if ( jsExpr.getHandle( ) instanceof ICompiledScript ){
								result = cx.evaluate( (ICompiledScript) jsExpr.getHandle( ) );
							}
							else{
								result = ( (BaseCompiledExpression) jsExpr.getHandle( ) ).evaluate( cx,( (IDataScriptEngine) cx.getScriptEngine( IDataScriptEngine.ENGINE_NAME ) ).getJSScope( cx ) );
							}
						}
						else{
							result = evaluateJSAsExpr( cx,( (IDataScriptEngine) cx.getScriptEngine( IDataScriptEngine.ENGINE_NAME ) ).getJSScope( cx ),jsExpr.getText( ),source,lineNo );
						}
					}
				}
				if ( logger.isLoggable( Level.FINER ) )logger.exiting( BaseScriptEvalUtil.class.getName( ),""evalExpr"",result );
				return result;
			}
			catch ( BirtException e ){
				throw DataException.wrap( e );
			}
		}
		public static int compareIgnoreNull( List<Object> valueList, List<Object> targetList ) throws DataException{
			for( int i = 0;
			 i < valueList.size( );
			 i++ ){
				if( targetList.get( i ) == null )continue;
				int result = compare( valueList.get( i ), targetList.get( i ) );
				 if( result != 0 )return result;
			}
			return 0;
		}
		public static Object evaluateJSAsExpr( ScriptContext cx, Scriptable scope,String scriptText, String source, int lineNo)throws DataException {
			if ( logger.isLoggable( Level.FINER ) )logger.entering( BaseScriptEvalUtil.class.getName( ),""evaluateJSExpr"",""evaluateJSExpr() scriptText="" + scriptText + "", source="" + source + "", lineNo="" + lineNo);
			Object result;
			try{
				result = JavascriptEvalUtil.evaluateScript( Context.getCurrentContext( ), scope, scriptText, source, 0 );
			}
			catch ( BirtException e ){
				throw DataException.wrap( e );
			}
			return result;
		}
		public static class ExprTextAndValue{
			Object value;
			public static ExprTextAndValue newInstance(Object value ){
				return new ExprTextAndValue( value );
			}
			public ExprTextAndValue( Object value ){
				this.value = value;
			}
		}
		private static class MiscUtil{
			private static boolean isSameType( Object resultExpr, Object resultOp1 ){
				return resultExpr.getClass( ).equals( resultOp1.getClass( ) );
			}
			private static boolean isNumericOrString( Object result ){
				return ( result instanceof Number ) || ( result instanceof String );
			}
			private static boolean isBigDecimal( Object result ){
				return result instanceof BigDecimal;
			}
			private static boolean isDateOrString( Object result ){
				return ( result instanceof Date ) || ( result instanceof String );
			}
			private static boolean isBooleanOrString( Object result ){
				return ( result instanceof Boolean ) || ( result instanceof String );
			}
			private static Object[] isComparable( Object obj, int operator,ExprTextAndValue[] operands ){
				if ( needFormat( obj, operator, operands ) )return formatToComparable( obj, operands );
				return null;
			}
			private static boolean needFormat( Object obj, int operator,ExprTextAndValue[] ops ){
				if ( operator < IConditionalExpression.OP_EQ|| ( operator > IConditionalExpression.OP_NOT_BETWEEN && operator < IConditionalExpression.OP_IN )|| obj == null || ops.length == 0 || ops[0].value == null )return false;
				else if ( ( operator == IConditionalExpression.OP_BETWEEN || operator == IConditionalExpression.OP_NOT_BETWEEN ) &&ops.length < 2 )return false;
				return true;
			}
			private static Object[] formatToComparable( Object obj,ExprTextAndValue[] operands ){
				Object[] obArray = new Object[operands.length + 1];
				obArray[0] = obj;
				for ( int i = 0;
				 i < operands.length;
				 i++ ){
					obArray[i + 1] = operands[i].value;
				}
				boolean isSameType = true;
				if ( isSameType( obj, obArray[1] ) ){
					for ( int i = 1;
					 i < operands.length;
					 i++ ){
						if ( obArray[i + 1] != null &&!isSameType( obj, obArray[i + 1] ) ){
							isSameType = false;
							break;
						}
					}
				}
				else{
					isSameType = false;
				}
				if ( isSameType )return obArray;
				else if ( obj instanceof Boolean )populateObArray( obArray[1], obArray );
				elsepopulateObArray( obj, obArray );
				return obArray;
			}
			private static Object[] populateObArray( Object obj, Object[] obArray ){
				try{
					for ( int i = 0;
					 i < obArray.length;
					 i++ ){
						if( obArray[i] instanceof Object[] )return obArray;
					}
					if ( obj instanceof Number && !( obj instanceof BigDecimal ) ){
						for ( int i = 0;
						 i < obArray.length;
						 i++ ){
							obArray[i] = DataTypeUtil.toDouble( obArray[i] );
						}
					}
					else if ( obj instanceof java.sql.Date ){
						for ( int i = 0;
						 i < obArray.length;
						 i++ ){
							obArray[i] = DataTypeUtil.toSqlDate( obArray[i] );
						}
					}
					else if ( obj instanceof java.sql.Time ){
						for ( int i = 0;
						 i < obArray.length;
						 i++ ){
							obArray[i] = DataTypeUtil.toSqlTime( obArray[i] );
						}
					}
					else if ( obj instanceof Date ){
						for ( int i = 0;
						 i < obArray.length;
						 i++ ){
							obArray[i] = DataTypeUtil.toDate( obArray[i] );
						}
					}
				}
				catch ( BirtException e ){
					try{
						makeObjectArrayStringArray( obArray );
					}
					catch ( BirtException e1 ){
					}
				}
				return obArray;
			}
			private static void makeObjectArrayStringArray( Object[] obArray ) throws BirtException{
				for ( int i = 0;
				 i < obArray.length;
				 i++ ){
					if ( obArray[i] != null )obArray[i] = DataTypeUtil.toString( obArray[i] );
				}
			}
			private static IScriptExpression constructValidScriptExpression(IScriptExpression ise ){
				if( ise != null && BaseExpression.constantId.equals( ise.getScriptId( ) ) )return ise;
				return ise != null&& ise.getText( ) != null&& ise.getText( ).trim( ).length( ) > 0 ? ise: new ScriptExpression( ""null"" );
			}
			private static Object[] flatternMultipleValues( Object[] values ){
				if ( values == null || values.length == 0 )return new Object[0];
				List flattern = new ArrayList( );
				for ( int i = 0;
				 i < values.length;
				 i++ ){
					if ( values[i] instanceof Object[] ){
						Object[] flatternObj = (Object[]) values[i];
						flattern.addAll( Arrays.asList( flatternMultipleValues( flatternObj ) ) );
					}
					else{
						flattern.add( values[i] );
					}
				}
				return flattern.toArray( );
			}
		}
	}",1,0,0,0
"public class RMContainerFinishedEvent extends RMContainerEvent {
	 private final ContainerStatus remoteContainerStatus;
	 public RMContainerFinishedEvent(ContainerId containerId, ContainerStatus containerStatus, RMContainerEventType event) {
		 super(containerId, event);
		 this.remoteContainerStatus = containerStatus;
	 }
	 public ContainerStatus getRemoteContainerStatus() {
		 return this.remoteContainerStatus;
	 }
}",0,0,0,0
"public class MultilevelTotalTableDecorator extends TableDecorator{
	 private boolean containsTotaledColumns = false;
	 private static final int NO_RESET_GROUP = 4200;
	 private Map groupNumberToGroupTotal = new HashMap();
	 private int deepestResetGroup = NO_RESET_GROUP;
	 protected int innermostGroup;
	 private Log logger = LogFactory.getLog(MultilevelTotalTableDecorator.class);
	 protected String grandTotalSum = ""grandtotal-sum"";
	 protected String grandTotalNoSum = ""grandtotal-nosum"";
	 protected String grandTotalLabel = ""grandtotal-label"";
	 protected String grandTotalDescription = ""Grand Total"";
	 private String subtotalHeaderClass = ""subtotal-header"";
	 private String subtotalLabelClass = ""subtotal-label"";
	 private MessageFormat subtotalDesc = new MessageFormat(""{
	0}
	 Total"");
	 private String subtotalValueClass = ""subtotal-sum"";
	 private List headerRows = new ArrayList(5);
	 public void init(PageContext context, Object decorated, TableModel model) {
		 super.init(context, decorated, model);
		 List headerCells = model.getHeaderCellList();
		 for (Iterator iterator = headerCells.iterator();
		 iterator.hasNext();
		) {
			 HeaderCell headerCell = (HeaderCell) iterator.next();
			 containsTotaledColumns = containsTotaledColumns || headerCell.isTotaled();
			 if (headerCell.getGroup() > 0) {
				 groupNumberToGroupTotal.put(new Integer(headerCell.getGroup()), new GroupTotals(headerCell .getColumnNumber()));
				 if (headerCell.getGroup() > innermostGroup) {
					 innermostGroup = headerCell.getGroup();
				 }
			 }
		 }
	 }
	 public String getGrandTotalDescription() {
		 return grandTotalDescription;
	 }
	 public void setGrandTotalDescription(String grandTotalDescription) {
		 this.grandTotalDescription = grandTotalDescription;
	 }
	 public void setSubtotalLabel(String pattern, Locale locale) {
		 this.subtotalDesc = new MessageFormat(pattern, locale);
	 }
	 public String getGrandTotalLabel() {
		 return grandTotalLabel;
	 }
	 public String getGrandTotalSum() {
		 return grandTotalSum;
	 }
	 public String getGrandTotalNoSum() {
		 return grandTotalNoSum;
	 }
	 public void setGrandTotalNoSum(String grandTotalNoSum) {
		 this.grandTotalNoSum = grandTotalNoSum;
	 }
	 public void setGrandTotalSum(String grandTotalSum) {
		 this.grandTotalSum = grandTotalSum;
	 }
	 public void setGrandTotalLabel(String grandTotalLabel) {
		 this.grandTotalLabel = grandTotalLabel;
	 }
	 public String getSubtotalValueClass() {
		 return subtotalValueClass;
	 }
	 public void setSubtotalValueClass(String subtotalValueClass) {
		 this.subtotalValueClass = subtotalValueClass;
	 }
	 public String getSubtotalLabelClass() {
		 return subtotalLabelClass;
	 }
	 public void setSubtotalLabelClass(String subtotalLabelClass) {
		 this.subtotalLabelClass = subtotalLabelClass;
	 }
	 public String getSubtotalHeaderClass() {
		 return subtotalHeaderClass;
	 }
	 public void setSubtotalHeaderClass(String subtotalHeaderClass) {
		 this.subtotalHeaderClass = subtotalHeaderClass;
	 }
	 public void startOfGroup(String value, int group) {
		 if (containsTotaledColumns) {
			 StringBuffer tr = new StringBuffer();
			 tr.append(""<tr>"");
			 GroupTotals groupTotals = (GroupTotals) groupNumberToGroupTotal.get(new Integer(group));
			 int myColumnNumber = groupTotals.columnNumber;
			 for (int i = 0;
			 i < myColumnNumber;
			 i++) {
				 tr.append(""<td></td>\n"");
			 }
			 tr.append(""<td class=\"""").append(getSubtotalHeaderClass()).append("" group-"").append(group).append(""\"" >"");
			 tr.append(value).append(""</td>\n"");
			 List headerCells = tableModel.getHeaderCellList();
			 for (int i = myColumnNumber;
			 i < headerCells.size() - 1;
			 i++) {
				 tr.append(""<td></td>\n"");
			 }
			 tr.append(""</tr>\n"");
			 headerRows.add(tr);
		 }
	 }
	 public String displayGroupedValue(String value, short groupingStatus, int columnNumber) {
		 return """";
	 }
	 public String startRow() {
		 StringBuffer sb = new StringBuffer();
		 for (Iterator iterator = headerRows.iterator();
		 iterator.hasNext();
		) {
			 StringBuffer stringBuffer = (StringBuffer) iterator.next();
			 sb.append(stringBuffer);
		 }
		 return sb.toString();
	 }
	 public void endOfGroup(String value, int groupNumber) {
		 if (deepestResetGroup > groupNumber) {
			 deepestResetGroup = groupNumber;
		 }
	 }
	 public String finishRow() {
		 String returnValue = """";
		 if (containsTotaledColumns) {
			 if (innermostGroup > 0 && deepestResetGroup != NO_RESET_GROUP) {
				 StringBuffer out = new StringBuffer();
				 for (int i = innermostGroup;
				 i >= deepestResetGroup;
				 i--) {
					 Integer groupNumber = new Integer(i);
					 GroupTotals totals = (GroupTotals) groupNumberToGroupTotal.get(groupNumber);
					 if (totals == null) {
						 logger.warn(""There is a gap in the defined groups - no group defined for "" + groupNumber);
						 continue;
					 }
					 totals.printTotals(getListIndex(), out);
					 totals.setStartRow(getListIndex() + 1);
				 }
				 returnValue = out.toString();
			 }
			 else {
				 returnValue = null;
			 }
			 deepestResetGroup = NO_RESET_GROUP;
			 headerRows.clear();
			 if (isLastRow()) {
				 returnValue = StringUtils.defaultString(returnValue);
				 returnValue += totalAllRows();
			 }
		 }
		 return returnValue;
	 }
	 protected String totalAllRows() {
		 if (containsTotaledColumns) {
			 List headerCells = tableModel.getHeaderCellList();
			 StringBuffer output = new StringBuffer();
			 int currentRow = getListIndex();
			 output.append(TagConstants.TAG_OPEN + TagConstants.TAGNAME_ROW + "" class=\""grandtotal-row\"""" + TagConstants.TAG_CLOSE);
			 boolean first = true;
			 for (Iterator iterator = headerCells.iterator();
			 iterator.hasNext();
			) {
				 HeaderCell headerCell = (HeaderCell) iterator.next();
				 if (first) {
					 output.append(getTotalsTdOpen(headerCell, getGrandTotalLabel()));
					 output.append(getGrandTotalDescription());
					 first = false;
				 }
				 else if (headerCell.isTotaled()) {
					 Object total = getTotalForColumn(headerCell.getColumnNumber(), 0, currentRow);
					 output.append(getTotalsTdOpen(headerCell, getGrandTotalSum()));
					 output.append(formatTotal(headerCell, total));
				 }
				 else {
					 output.append(getTotalsTdOpen(headerCell, getGrandTotalNoSum()));
				 }
				 output.append(TagConstants.TAG_OPENCLOSING + TagConstants.TAGNAME_COLUMN + TagConstants.TAG_CLOSE);
			 }
			 output.append(""\n</tr>\n"");
			 return output.toString();
		 }
		 else {
			 return """";
		 }
	 }
	 protected String getCellValue(int columnNumber, int rowNumber) {
		 List fullList = tableModel.getRowListFull();
		 Row row = (Row) fullList.get(rowNumber);
		 ColumnIterator columnIterator = row.getColumnIterator(tableModel.getHeaderCellList());
		 while (columnIterator.hasNext()) {
			 Column column = columnIterator.nextColumn();
			 if (column.getHeaderCell().getColumnNumber() == columnNumber) {
				 try {
					 column.initialize();
					 return column.getChoppedAndLinkedValue();
				 }
				 catch (ObjectLookupException e) {
					 logger.error(""Error: "" + e.getMessage(), e);
					 throw new RuntimeException(""Error: "" + e.getMessage(), e);
				 }
				 catch (DecoratorException e) {
					 logger.error(""Error: "" + e.getMessage(), e);
					 throw new RuntimeException(""Error: "" + e.getMessage(), e);
				 }
			 }
		 }
		 throw new RuntimeException(""Unable to find column "" + columnNumber + "" in the list of columns"");
	 }
	 protected Object getTotalForColumn(int columnNumber, int startRow, int stopRow) {
		 List fullList = tableModel.getRowListFull();
		 List window = fullList.subList(startRow, stopRow + 1);
		 Object total = null;
		 for (Iterator iterator = window.iterator();
		 iterator.hasNext();
		) {
			 Row row = (Row) iterator.next();
			 ColumnIterator columnIterator = row.getColumnIterator(tableModel.getHeaderCellList());
			 while (columnIterator.hasNext()) {
				 Column column = columnIterator.nextColumn();
				 if (column.getHeaderCell().getColumnNumber() == columnNumber) {
					 Object value = null;
					 try {
						 value = column.getValue(false);
					 }
					 catch (ObjectLookupException e) {
						 logger.error(e);
					 }
					 catch (DecoratorException e) {
						 logger.error(e);
					 }
					 if (value != null && ! TagConstants.EMPTY_STRING.equals(value)) {
						 total = add(column, total, value);
					 }
				 }
			 }
		 }
		 return total;
	 }
	 protected Object add(Column column, Object total, Object value) {
		 if (value == null) {
			 return total;
		 }
		 else if (value instanceof Number) {
			 Number oldTotal = new Double(0);
			 if (total != null) {
				 oldTotal = (Number)total;
			 }
			 return new Double(oldTotal.doubleValue() + ((Number) value).doubleValue());
		 }
		 else {
			 throw new UnsupportedOperationException(""Cannot add a value of "" + value + "" in column "" + column.getHeaderCell().getTitle());
		 }
	 }
	 public String getTotalsTdOpen(HeaderCell header, String totalClass) {
		 String cssClass = ObjectUtils.toString(header.getHtmlAttributes().get(""class""));
		 StringBuffer buffer = new StringBuffer();
		 buffer.append(TagConstants.TAG_OPEN);
		 buffer.append(TagConstants.TAGNAME_COLUMN);
		 if (cssClass != null || totalClass != null) {
			 buffer.append("" class=\"""");
			 if (cssClass != null) {
				 buffer.append(cssClass);
				 if (totalClass != null) {
					 buffer.append("" "");
				 }
			 }
			 if (totalClass != null) {
				 buffer.append(totalClass);
			 }
			 buffer.append(""\"""");
		 }
		 buffer.append(TagConstants.TAG_CLOSE);
		 return buffer.toString();
	 }
	 public String getTotalsRowOpen() {
		 return TagConstants.TAG_OPEN + TagConstants.TAGNAME_ROW + "" class=\""subtotal\"""" + TagConstants.TAG_CLOSE;
	 }
	 public String getTotalRowLabel(String groupingValue) {
		 return subtotalDesc.format(new Object[]{
		groupingValue}
		);
	 }
	 public String formatTotal(HeaderCell header, Object total) {
		 Object displayValue = total;
		 if (header.getColumnDecorators().length > 0) {
			 for (int i = 0;
			 i < header.getColumnDecorators().length;
			 i++) {
				 DisplaytagColumnDecorator decorator = header.getColumnDecorators()[i];
				 try {
					 displayValue = decorator.decorate(total, this.getPageContext(), tableModel.getMedia());
				 }
				 catch (DecoratorException e) {
					 logger.warn(e.getMessage(), e);
				 }
			 }
		 }
		 return displayValue != null ? displayValue.toString() : """";
	 }
	 class GroupTotals {
		 protected String totalLabelClass = getSubtotalLabelClass();
		 protected String totalsRowOpen = getTotalsRowOpen();
		 protected String totalValueClass = getSubtotalValueClass();
		 private int columnNumber;
		 private int firstRowOfCurrentSet;
		 public GroupTotals(int headerCellColumn) {
			 this.columnNumber = headerCellColumn;
			 this.firstRowOfCurrentSet = 0;
		 }
		 public void printTotals(int currentRow, StringBuffer out) {
			 List headerCells = tableModel.getHeaderCellList();
			 if (firstRowOfCurrentSet < currentRow) {
				 out.append(totalsRowOpen);
				 for (Iterator iterator = headerCells.iterator();
				 iterator.hasNext();
				) {
					 HeaderCell headerCell = (HeaderCell) iterator.next();
					 if (columnNumber == headerCell.getColumnNumber()) {
						 String currentLabel = getCellValue(columnNumber, firstRowOfCurrentSet);
						 out.append(getTotalsTdOpen(headerCell, getTotalLabelClass() + "" group-"" + (columnNumber + 1)));
						 out.append(getTotalRowLabel(currentLabel));
					 }
					 else if (headerCell.isTotaled()) {
						 Object total = getTotalForColumn(headerCell.getColumnNumber(), firstRowOfCurrentSet, currentRow);
						 out.append(getTotalsTdOpen(headerCell, getTotalValueClass() + "" group-"" + (columnNumber + 1)));
						 out.append(formatTotal(headerCell, total));
					 }
					 else {
						 String style = ""group-"" + (columnNumber + 1);
						 if (headerCell.getColumnNumber() < innermostGroup) {
							 style += "" "" + getTotalLabelClass() + "" "";
						 }
						 out.append(getTotalsTdOpen(headerCell, style));
					 }
					 out.append(TagConstants.TAG_OPENCLOSING + TagConstants.TAGNAME_COLUMN + TagConstants.TAG_CLOSE);
				 }
				 out.append(""\n</tr>\n"");
			 }
		 }
		 public void setStartRow(int i) {
			 firstRowOfCurrentSet = i;
		 }
		 public String getTotalLabelClass() {
			 return totalLabelClass;
		 }
		 public void setTotalsRowOpen(String totalsRowOpen) {
			 this.totalsRowOpen = totalsRowOpen;
		 }
		 public void setTotalLabelClass(String totalLabelClass) {
			 this.totalLabelClass = totalLabelClass;
		 }
		 public String getTotalValueClass() {
			 return totalValueClass;
		 }
		 public void setTotalValueClass(String totalValueClass) {
			 this.totalValueClass = totalValueClass;
		 }
	 }
}",1,0,0,0
"public String[] getPath(final TreeItem swtTreeItem) {
	return Display.syncExec(new ResultRunnable<String[]>() {
		public String[] run() {
			org.eclipse.swt.widgets.TreeItem swttiDummy = swtTreeItem;
			LinkedList<String> items = new LinkedList<String>();
			while (swttiDummy != null) {
				items.addFirst(swttiDummy.getText());
				swttiDummy = swttiDummy.getParentItem();
			}
			return items.toArray(new String[0]);
		}
	}
	);
}",0,0,1,0
"public class TokenCountMapper extends MapReduceBase implements Mapper {
	 public void map(WritableComparable key, Writable value, OutputCollector output, Reporter reporter) throws IOException {
		 String text = ((UTF8)value).toString();
		 StringTokenizer st = new StringTokenizer(text);
		 while (st.hasMoreTokens()) {
			 output.collect(new UTF8(st.nextToken()), new LongWritable(1));
		 }
	 }
}",0,0,0,0
"public class SchemaAndValue {
	 private final Schema schema;
	 private final Object value;
	 public static final SchemaAndValue NULL = new SchemaAndValue(null, null);
	 public SchemaAndValue(Schema schema, Object value) {
		 this.value = value;
		 this.schema = schema;
	 }
	 public Schema schema() {
		 return schema;
	 }
	 public Object value() {
		 return value;
	 }
	 public boolean equals(Object o) {
		 if (this == o) return true;
		 if (o == null || getClass() != o.getClass()) return false;
		 SchemaAndValue that = (SchemaAndValue) o;
		 return Objects.equals(schema, that.schema) && Objects.equals(value, that.value);
	 }
	 public int hashCode() {
		 return Objects.hash(schema, value);
	 }
	 public String toString() {
		 return ""SchemaAndValue{
		"" + ""schema="" + schema + "", value="" + value + '}
		';
	 }
}",0,1,0,0
"private ColumnFamily collectTimeOrderedData() {
	 logger.debug(""collectTimeOrderedData"");
	 ISortedColumns.Factory factory = mutableColumns ? cfs.metadata.cfType == ColumnFamilyType.Super ? ThreadSafeSortedColumns.factory() : AtomicSortedColumns.factory() : TreeMapBackedSortedColumns.factory();
	 ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());
	 List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();
	 ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);
	 try {
		 for (Memtable memtable : view.memtables) {
			 IColumnIterator iter = filter.getMemtableColumnIterator(memtable);
			 if (iter != null) {
				 iterators.add(iter);
				 container.delete(iter.getColumnFamily());
				 while (iter.hasNext()) container.addColumn(iter.next());
			 }
		 }
		 TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(((NamesQueryFilter) filter.filter).columns);
		 QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));
		 Collections.sort(view.sstables, SSTable.maxTimestampComparator);
		 for (SSTableReader sstable : view.sstables) {
			 long currentMaxTs = sstable.getMaxTimestamp();
			 reduceNameFilter(reducedFilter, container, currentMaxTs);
			 if (((NamesQueryFilter) reducedFilter.filter).columns.isEmpty()) break;
			 IColumnIterator iter = reducedFilter.getSSTableColumnIterator(sstable);
			 iterators.add(iter);
			 if (iter.getColumnFamily() != null) {
				 container.delete(iter.getColumnFamily());
				 sstablesIterated++;
				 while (iter.hasNext()) container.addColumn(iter.next());
			 }
		 }
		 if (iterators.isEmpty()) return null;
		 final ColumnFamily c2 = container;
		 CloseableIterator<IColumn> toCollate = new SimpleAbstractColumnIterator() {
			 final Iterator<IColumn> iter = c2.iterator();
			 protected IColumn computeNext() {
				 return iter.hasNext() ? iter.next() : endOfData();
			 }
			 public ColumnFamily getColumnFamily() {
				 return c2;
			 }
			 public DecoratedKey getKey() {
				 return filter.key;
			 }
		 }
		;
		 ColumnFamily returnCF = container.cloneMeShallow();
		 filter.collateColumns(returnCF, Collections.singletonList(toCollate), gcBefore);
		 if (sstablesIterated > cfs.getMinimumCompactionThreshold() && !cfs.isCompactionDisabled() && cfs.getCompactionStrategy() instanceof SizeTieredCompactionStrategy) {
			 RowMutation rm = new RowMutation(cfs.table.name, new Row(filter.key, returnCF.cloneMe()));
			 try {
				 Table.open(rm.getTable()).apply(rm, false, false);
			 }
			 catch (IOException e) {
				 logger.error(""Error re-writing read results"", e);
			 }
		 }
		 return returnCF;
	 }
	 finally {
		 for (IColumnIterator iter : iterators) FileUtils.closeQuietly(iter);
		 SSTableReader.releaseReferences(view.sstables);
	 }
 }",0,0,1,0
"public int getCurrentGenerationNumber(InetAddress endpoint) {
	 return endpointStateMap_.get(endpoint).getHeartBeatState().getGeneration();
 }",0,0,0,0
"public String convertKeywordToFlag(String value) {
	 Properties flagSettings = Settings.getSubProperties(""davmail.imapFlags"");
	 Enumeration flagSettingsEnum = flagSettings.propertyNames();
	 while (flagSettingsEnum.hasMoreElements()) {
		 String key = (String) flagSettingsEnum.nextElement();
		 if (value.equalsIgnoreCase(flagSettings.getProperty(key))) {
			 return key;
		 }
	 }
	 ResourceBundle flagBundle = ResourceBundle.getBundle(""imapflags"");
	 Enumeration<String> flagBundleEnum = flagBundle.getKeys();
	 while (flagBundleEnum.hasMoreElements()) {
		 String key = flagBundleEnum.nextElement();
		 if (value.equalsIgnoreCase(flagBundle.getString(key))) {
			 return key;
		 }
	 }
	 return value;
 }",0,0,0,0
"protected void tarResource(Resource r, TarOutputStream tOut, String vPath, TarFileSet tarFileSet) throws IOException {
	 if (!r.isExists()) {
		 return;
	 }
	 boolean preserveLeadingSlashes = false;
	 if (tarFileSet != null) {
		 String fullpath = tarFileSet.getFullpath(this.getProject());
		 if (fullpath.length() > 0) {
			 vPath = fullpath;
		 }
		 else {
			 if (vPath.length() <= 0) {
				 return;
			 }
			 String prefix = tarFileSet.getPrefix(this.getProject());
			 if (prefix.length() > 0 && !prefix.endsWith(""/"")) {
				 prefix = prefix + ""/"";
			 }
			 vPath = prefix + vPath;
		 }
		 preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();
		 if (vPath.startsWith(""/"") && !preserveLeadingSlashes) {
			 int l = vPath.length();
			 if (l <= 1) {
				 return;
			 }
			 vPath = vPath.substring(1, l);
		 }
	 }
	 if (r.isDirectory() && !vPath.endsWith(""/"")) {
		 vPath += ""/"";
	 }
	 if (vPath.length() >= TarConstants.NAMELEN) {
		 if (longFileMode.isOmitMode()) {
			 log(""Omitting: "" + vPath, Project.MSG_INFO);
			 return;
		 }
		 else if (longFileMode.isWarnMode()) {
			 log(""Entry: "" + vPath + "" longer than "" + TarConstants.NAMELEN + "" characters."", Project.MSG_WARN);
			 if (!longWarningGiven) {
				 log(""Resulting tar file can only be processed "" + ""successfully by GNU compatible tar commands"", Project.MSG_WARN);
				 longWarningGiven = true;
			 }
		 }
		 else if (longFileMode.isFailMode()) {
			 throw new BuildException(""Entry: "" + vPath + "" longer than "" + TarConstants.NAMELEN + ""characters."", getLocation());
		 }
	 }
	 TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);
	 te.setModTime(r.getLastModified());
	 if (r instanceof ArchiveResource) {
		 ArchiveResource ar = (ArchiveResource) r;
		 te.setMode(ar.getMode());
		 if (r instanceof TarResource) {
			 TarResource tr = (TarResource) r;
			 te.setUserName(tr.getUserName());
			 te.setUserId(tr.getUid());
			 te.setGroupName(tr.getGroup());
			 te.setGroupId(tr.getGid());
		 }
	 }
	 if (!r.isDirectory()) {
		 if (r.size() > TarConstants.MAXSIZE) {
			 throw new BuildException( ""Resource: "" + r + "" larger than "" + TarConstants.MAXSIZE + "" bytes."");
		 }
		 te.setSize(r.getSize());
		 if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {
			 te.setMode(tarFileSet.getMode());
		 }
	 }
	 else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {
		 te.setMode(tarFileSet.getDirMode(this.getProject()));
	 }
	 if (tarFileSet != null) {
		 if (tarFileSet.hasUserNameBeenSet()) {
			 te.setUserName(tarFileSet.getUserName());
		 }
		 if (tarFileSet.hasGroupBeenSet()) {
			 te.setGroupName(tarFileSet.getGroup());
		 }
		 if (tarFileSet.hasUserIdBeenSet()) {
			 te.setUserId(tarFileSet.getUid());
		 }
		 if (tarFileSet.hasGroupIdBeenSet()) {
			 te.setGroupId(tarFileSet.getGid());
		 }
	 }
	 InputStream in = null;
	 try {
		 tOut.putNextEntry(te);
		 if (!r.isDirectory()) {
			 in = r.getInputStream();
			 byte[] buffer = new byte[BUFFER_SIZE];
			 int count = 0;
			 do {
				 tOut.write(buffer, 0, count);
				 count = in.read(buffer, 0, buffer.length);
			 }
			 while (count != -1);
		 }
		 tOut.closeEntry();
	 }
	 finally {
		 FileUtils.close(in);
	 }
 }",0,0,1,0
"public abstract class Image extends Rectangle {
	public static final int DEFAULT = 0;
	public static final int RIGHT = 2;
	public static final int LEFT = 0;
	public static final int MIDDLE = 1;
	public static final int TEXTWRAP = 4;
	public static final int UNDERLYING = 8;
	public static final int AX = 0;
	public static final int AY = 1;
	public static final int BX = 2;
	public static final int BY = 3;
	public static final int CX = 4;
	public static final int CY = 5;
	public static final int DX = 6;
	public static final int DY = 7;
	public static final int ORIGINAL_NONE = 0;
	public static final int ORIGINAL_JPEG = 1;
	public static final int ORIGINAL_PNG = 2;
	public static final int ORIGINAL_GIF = 3;
	public static final int ORIGINAL_BMP = 4;
	public static final int ORIGINAL_TIFF = 5;
	public static final int ORIGINAL_WMF = 6;
	 public static final int ORIGINAL_PS = 7;
	public static final int ORIGINAL_JPEG2000 = 8;
	public static final int ORIGINAL_JBIG2 = 9;
	protected int type;
	protected URL url;
	protected byte rawData[];
	protected int bpc = 1;
	protected PdfTemplate template[] = new PdfTemplate[1];
	protected int alignment;
	protected String alt;
	protected float absoluteX = Float.NaN;
	protected float absoluteY = Float.NaN;
	protected float plainWidth;
	protected float plainHeight;
	protected float scaledWidth;
	protected float scaledHeight;
	 protected int compressionLevel = PdfStream.DEFAULT_COMPRESSION;
	protected Long mySerialId = getSerialId();
	public Image(URL url) {
		super(0, 0);
		this.url = url;
		this.alignment = DEFAULT;
		rotationRadians = 0;
	}
	public static Image getInstance(URL url) throws BadElementException,MalformedURLException, IOException {
		InputStream is = null;
		try {
			is = url.openStream();
			int c1 = is.read();
			int c2 = is.read();
			int c3 = is.read();
			int c4 = is.read();
			int c5 = is.read();
			int c6 = is.read();
			int c7 = is.read();
			int c8 = is.read();
			is.close();
			is = null;
			if (c1 == 'G' && c2 == 'I' && c3 == 'F') {
				GifImage gif = new GifImage(url);
				Image img = gif.getImage(1);
				return img;
			}
			if (c1 == 0xFF && c2 == 0xD8) {
				return new Jpeg(url);
			}
			if (c1 == 0x00 && c2 == 0x00 && c3 == 0x00 && c4 == 0x0c) {
				return new Jpeg2000(url);
			}
			if (c1 == 0xff && c2 == 0x4f && c3 == 0xff && c4 == 0x51) {
				return new Jpeg2000(url);
			}
			if (c1 == PngImage.PNGID[0] && c2 == PngImage.PNGID[1]&& c3 == PngImage.PNGID[2] && c4 == PngImage.PNGID[3]) {
				return PngImage.getImage(url);
			}
			if (c1 == 0xD7 && c2 == 0xCD) {
				return new ImgWMF(url);
			}
			if (c1 == 'B' && c2 == 'M') {
				return BmpImage.getImage(url);
			}
			if (c1 == 'M' && c2 == 'M' && c3 == 0 && c4 == 42|| c1 == 'I' && c2 == 'I' && c3 == 42 && c4 == 0) {
				RandomAccessFileOrArray ra = null;
				try {
					if (url.getProtocol().equals(""file"")) {
						String file = url.getFile();
						 file = Utilities.unEscapeURL(file);
						ra = new RandomAccessFileOrArray(file);
					}
					 elsera = new RandomAccessFileOrArray(url);
					Image img = TiffImage.getTiffImage(ra, 1);
					img.url = url;
					return img;
				}
				 finally {
					if (ra != null)ra.close();
				}
			}
			if ( c1 == 0x97 && c2 == 'J' && c3 == 'B' && c4 == '2' &&c5 == '\r' && c6 == '\n' && c7 == 0x1a && c8 == '\n' ) {
				RandomAccessFileOrArray ra = null;
				try {
					if (url.getProtocol().equals(""file"")) {
						String file = url.getFile();
						file = Utilities.unEscapeURL(file);
						 ra = new RandomAccessFileOrArray(file);
					}
					 elsera = new RandomAccessFileOrArray(url);
					Image img = JBIG2Image.getJbig2Image(ra, 1);
					img.url = url;
					return img;
				}
				 finally {
					if (ra != null)ra.close();
				}
			}
			throw new IOException(url.toString()+ "" is not a recognized imageformat."");
		}
		 finally {
			if (is != null) {
				is.close();
			}
		}
	}
	public static Image getInstance(String filename)throws BadElementException, MalformedURLException, IOException {
		return getInstance(Utilities.toURL(filename));
	}
	public static Image getInstance(byte imgb[]) throws BadElementException,MalformedURLException, IOException {
		InputStream is = null;
		try {
			is = new java.io.ByteArrayInputStream(imgb);
			int c1 = is.read();
			int c2 = is.read();
			int c3 = is.read();
			int c4 = is.read();
			is.close();
			is = null;
			if (c1 == 'G' && c2 == 'I' && c3 == 'F') {
				GifImage gif = new GifImage(imgb);
				return gif.getImage(1);
			}
			if (c1 == 0xFF && c2 == 0xD8) {
				return new Jpeg(imgb);
			}
			if (c1 == 0x00 && c2 == 0x00 && c3 == 0x00 && c4 == 0x0c) {
				return new Jpeg2000(imgb);
			}
			if (c1 == 0xff && c2 == 0x4f && c3 == 0xff && c4 == 0x51) {
				return new Jpeg2000(imgb);
			}
			if (c1 == PngImage.PNGID[0] && c2 == PngImage.PNGID[1]&& c3 == PngImage.PNGID[2] && c4 == PngImage.PNGID[3]) {
				return PngImage.getImage(imgb);
			}
			if (c1 == 0xD7 && c2 == 0xCD) {
				return new ImgWMF(imgb);
			}
			if (c1 == 'B' && c2 == 'M') {
				return BmpImage.getImage(imgb);
			}
			if (c1 == 'M' && c2 == 'M' && c3 == 0 && c4 == 42|| c1 == 'I' && c2 == 'I' && c3 == 42 && c4 == 0) {
				RandomAccessFileOrArray ra = null;
				try {
					ra = new RandomAccessFileOrArray(imgb);
					Image img = TiffImage.getTiffImage(ra, 1);
					 if (img.getOriginalData() == null) img.setOriginalData(imgb);
					return img;
				}
				 finally {
					if (ra != null)ra.close();
				}
			}
			if ( c1 == 0x97 && c2 == 'J' && c3 == 'B' && c4 == '2' ) {
				is = new java.io.ByteArrayInputStream(imgb);
				is.skip(4);
				int c5 = is.read();
				int c6 = is.read();
				int c7 = is.read();
				int c8 = is.read();
				if ( c5 == '\r' && c6 == '\n' && c7 == 0x1a && c8 == '\n' ) {
					int file_header_flags = is.read();
					int number_of_pages = -1;
					if ( (file_header_flags & 0x2) == 0x2 ) {
						number_of_pages = is.read() << 24 | is.read() << 16 | is.read() << 8 | is.read();
					}
					is.close();
					RandomAccessFileOrArray ra = null;
					try {
						ra = new RandomAccessFileOrArray(imgb);
						Image img = JBIG2Image.getJbig2Image(ra, 1);
						if (img.getOriginalData() == null)img.setOriginalData(imgb);
						return img;
					}
					 finally {
						if (ra != null)ra.close();
					}
				}
			}
			throw new IOException(MessageLocalization.getComposedMessage(""the.byte.array.is.not.a.recognized.imageformat""));
		}
		 finally {
			if (is != null) {
				is.close();
			}
		}
	}
	public static Image getInstance(int width, int height, int components,int bpc, byte data[]) throws BadElementException {
		return Image.getInstance(width, height, components, bpc, data, null);
	}
	public static Image getInstance(int width, int height, byte[] data, byte[] globals) {
		Image img = new ImgJBIG2(width, height, data, globals);
		return img;
	}
	public static Image getInstance(int width, int height, boolean reverseBits,int typeCCITT, int parameters, byte[] data)throws BadElementException {
		return Image.getInstance(width, height, reverseBits, typeCCITT,parameters, data, null);
	}
	public static Image getInstance(int width, int height, boolean reverseBits,int typeCCITT, int parameters, byte[] data, int transparency[])throws BadElementException {
		if (transparency != null && transparency.length != 2)throw new BadElementException(MessageLocalization.getComposedMessage(""transparency.length.must.be.equal.to.2.with.ccitt.images""));
		Image img = new ImgCCITT(width, height, reverseBits, typeCCITT,parameters, data);
		img.transparency = transparency;
		return img;
	}
	public static Image getInstance(int width, int height, int components,int bpc, byte data[], int transparency[])throws BadElementException {
		if (transparency != null && transparency.length != components * 2)throw new BadElementException(MessageLocalization.getComposedMessage(""transparency.length.must.be.equal.to.componentes.2""));
		if (components == 1 && bpc == 1) {
			byte g4[] = CCITTG4Encoder.compress(data, width, height);
			return Image.getInstance(width, height, false, Image.CCITTG4,Image.CCITT_BLACKIS1, g4, transparency);
		}
		Image img = new ImgRaw(width, height, components, bpc, data);
		img.transparency = transparency;
		return img;
	}
	public static Image getInstance(PdfTemplate template)throws BadElementException {
		return new ImgTemplate(template);
	}
	public static Image getInstance(java.awt.Image image, java.awt.Color color,boolean forceBW) throws BadElementException, IOException {
		if(image instanceof BufferedImage){
			BufferedImage bi = (BufferedImage) image;
			if(bi.getType()==BufferedImage.TYPE_BYTE_BINARY) {
				forceBW=true;
			}
		}
		java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(image,0, 0, -1, -1, true);
		try {
			pg.grabPixels();
		}
		 catch (InterruptedException e) {
			throw new IOException(MessageLocalization.getComposedMessage(""java.awt.image.interrupted.waiting.for.pixels""));
		}
		if ((pg.getStatus() & java.awt.image.ImageObserver.ABORT) != 0) {
			throw new IOException(MessageLocalization.getComposedMessage(""java.awt.image.fetch.aborted.or.errored""));
		}
		int w = pg.getWidth();
		int h = pg.getHeight();
		int[] pixels = (int[]) pg.getPixels();
		if (forceBW) {
			int byteWidth = w / 8 + ((w & 7) != 0 ? 1 : 0);
			byte[] pixelsByte = new byte[byteWidth * h];
			int index = 0;
			int size = h * w;
			int transColor = 1;
			if (color != null) {
				transColor = color.getRed() + color.getGreen()+ color.getBlue() < 384 ? 0 : 1;
			}
			int transparency[] = null;
			int cbyte = 0x80;
			int wMarker = 0;
			int currByte = 0;
			if (color != null) {
				for (int j = 0;
				 j < size;
				 j++) {
					int alpha = pixels[j] >> 24 & 0xff;
					if (alpha < 250) {
						if (transColor == 1)currByte |= cbyte;
					}
					 else {
						if ((pixels[j] & 0x888) != 0)currByte |= cbyte;
					}
					cbyte >>= 1;
					if (cbyte == 0 || wMarker + 1 >= w) {
						pixelsByte[index++] = (byte) currByte;
						cbyte = 0x80;
						currByte = 0;
					}
					++wMarker;
					if (wMarker >= w)wMarker = 0;
				}
			}
			 else {
				for (int j = 0;
				 j < size;
				 j++) {
					if (transparency == null) {
						int alpha = pixels[j] >> 24 & 0xff;
						if (alpha == 0) {
							transparency = new int[2];
							transparency[0] = transparency[1] = (pixels[j] & 0x888) != 0 ? 0xff : 0;
						}
					}
					if ((pixels[j] & 0x888) != 0)currByte |= cbyte;
					cbyte >>= 1;
					if (cbyte == 0 || wMarker + 1 >= w) {
						pixelsByte[index++] = (byte) currByte;
						cbyte = 0x80;
						currByte = 0;
					}
					++wMarker;
					if (wMarker >= w)wMarker = 0;
				}
			}
			return Image.getInstance(w, h, 1, 1, pixelsByte, transparency);
		}
		 else {
			byte[] pixelsByte = new byte[w * h * 3];
			byte[] smask = null;
			int index = 0;
			int size = h * w;
			int red = 255;
			int green = 255;
			int blue = 255;
			if (color != null) {
				red = color.getRed();
				green = color.getGreen();
				blue = color.getBlue();
			}
			int transparency[] = null;
			if (color != null) {
				for (int j = 0;
				 j < size;
				 j++) {
					int alpha = pixels[j] >> 24 & 0xff;
					if (alpha < 250) {
						pixelsByte[index++] = (byte) red;
						pixelsByte[index++] = (byte) green;
						pixelsByte[index++] = (byte) blue;
					}
					 else {
						pixelsByte[index++] = (byte) (pixels[j] >> 16 & 0xff);
						pixelsByte[index++] = (byte) (pixels[j] >> 8 & 0xff);
						pixelsByte[index++] = (byte) (pixels[j] & 0xff);
					}
				}
			}
			 else {
				int transparentPixel = 0;
				smask = new byte[w * h];
				boolean shades = false;
				for (int j = 0;
				 j < size;
				 j++) {
					byte alpha = smask[j] = (byte) (pixels[j] >> 24 & 0xff);
					if (!shades) {
						if (alpha != 0 && alpha != -1) {
							shades = true;
						}
						 else if (transparency == null) {
							if (alpha == 0) {
								transparentPixel = pixels[j] & 0xffffff;
								transparency = new int[6];
								transparency[0] = transparency[1] = transparentPixel >> 16 & 0xff;
								transparency[2] = transparency[3] = transparentPixel >> 8 & 0xff;
								transparency[4] = transparency[5] = transparentPixel & 0xff;
							}
						}
						 else if ((pixels[j] & 0xffffff) != transparentPixel) {
							shades = true;
						}
					}
					pixelsByte[index++] = (byte) (pixels[j] >> 16 & 0xff);
					pixelsByte[index++] = (byte) (pixels[j] >> 8 & 0xff);
					pixelsByte[index++] = (byte) (pixels[j] & 0xff);
				}
				if (shades)transparency = null;
				elsesmask = null;
			}
			Image img = Image.getInstance(w, h, 3, 8, pixelsByte, transparency);
			if (smask != null) {
				Image sm = Image.getInstance(w, h, 1, 8, smask);
				try {
					sm.makeMask();
					img.setImageMask(sm);
				}
				 catch (DocumentException de) {
					throw new ExceptionConverter(de);
				}
			}
			return img;
		}
	}
	public static Image getInstance(java.awt.Image image, java.awt.Color color)throws BadElementException, IOException {
		return Image.getInstance(image, color, false);
	}
	public static Image getInstance(PdfWriter writer, java.awt.Image awtImage, float quality) throws BadElementException, IOException {
		return getInstance(new PdfContentByte(writer), awtImage, quality);
	}
	 public static Image getInstance(PdfContentByte cb, java.awt.Image awtImage, float quality) throws BadElementException, IOException {
		 java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(awtImage, 0, 0, -1, -1, true);
		 try {
			 pg.grabPixels();
		 }
		 catch (InterruptedException e) {
			 throw new IOException(MessageLocalization.getComposedMessage(""java.awt.image.interrupted.waiting.for.pixels""));
		 }
		 if ((pg.getStatus() & java.awt.image.ImageObserver.ABORT) != 0) {
			 throw new IOException(MessageLocalization.getComposedMessage(""java.awt.image.fetch.aborted.or.errored""));
		 }
		 int w = pg.getWidth();
		 int h = pg.getHeight();
		 PdfTemplate tp = cb.createTemplate(w, h);
		 Graphics2D g2d = tp.createGraphics(w, h, true, quality);
		 g2d.drawImage(awtImage, 0, 0, null);
		 g2d.dispose();
		 return getInstance(tp);
	 }
	 private PdfIndirectReference directReference;
	 public PdfIndirectReference getDirectReference() {
		 return this.directReference;
	 }
	 public void setDirectReference(PdfIndirectReference directReference) {
		 this.directReference = directReference;
	 }
	 public static Image getInstance(PRIndirectReference ref) throws BadElementException {
		 PdfDictionary dic = (PdfDictionary)PdfReader.getPdfObjectRelease(ref);
		 int width = ((PdfNumber)PdfReader.getPdfObjectRelease(dic.get(PdfName.WIDTH))).intValue();
		 int height = ((PdfNumber)PdfReader.getPdfObjectRelease(dic.get(PdfName.HEIGHT))).intValue();
		 Image imask = null;
		 PdfObject obj = dic.get(PdfName.SMASK);
		 if (obj != null && obj.isIndirect()) {
			 imask = getInstance((PRIndirectReference)obj);
		 }
		 else {
			 obj = dic.get(PdfName.MASK);
			 if (obj != null && obj.isIndirect()) {
				 PdfObject obj2 = PdfReader.getPdfObjectRelease(obj);
				 if (obj2 instanceof PdfDictionary) imask = getInstance((PRIndirectReference)obj);
			 }
		 }
		 Image img = new ImgRaw(width, height, 1, 1, null);
		 img.imageMask = imask;
		 img.directReference = ref;
		 return img;
	 }
	protected Image(Image image) {
		super(image);
		this.type = image.type;
		this.url = image.url;
		this.rawData = image.rawData;
		this.bpc = image.bpc;
		this.template = image.template;
		this.alignment = image.alignment;
		this.alt = image.alt;
		this.absoluteX = image.absoluteX;
		this.absoluteY = image.absoluteY;
		this.plainWidth = image.plainWidth;
		this.plainHeight = image.plainHeight;
		this.scaledWidth = image.scaledWidth;
		this.scaledHeight = image.scaledHeight;
		this.mySerialId = image.mySerialId;
		 this.directReference = image.directReference;
		this.rotationRadians = image.rotationRadians;
		 this.initialRotation = image.initialRotation;
		 this.indentationLeft = image.indentationLeft;
		 this.indentationRight = image.indentationRight;
		this.spacingBefore = image.spacingBefore;
		this.spacingAfter = image.spacingAfter;
		this.widthPercentage = image.widthPercentage;
		this.annotation = image.annotation;
		this.layer = image.layer;
		this.interpolation = image.interpolation;
		this.originalType = image.originalType;
		this.originalData = image.originalData;
		this.deflated = image.deflated;
		this.dpiX = image.dpiX;
		this.dpiY = image.dpiY;
		this.XYRatio = image.XYRatio;
		this.colorspace = image.colorspace;
		this.invert = image.invert;
		this.profile = image.profile;
		this.additional = image.additional;
		this.mask = image.mask;
		this.imageMask = image.imageMask;
		this.smask = image.smask;
		this.transparency = image.transparency;
	}
	public static Image getInstance(Image image) {
		if (image == null)return null;
		try {
			Class<? extends Image> cs = image.getClass();
			Constructor<? extends Image> constructor = cs.getDeclaredConstructor(new Class[] {
			 Image.class }
			);
			return constructor.newInstance(new Object[] {
			 image }
			);
		}
		 catch (Exception e) {
			throw new ExceptionConverter(e);
		}
	}
	 public int type() {
		return type;
	}
	 public boolean isNestable() {
		return true;
	}
	public boolean isJpeg() {
		return type == JPEG;
	}
	public boolean isImgRaw() {
		return type == IMGRAW;
	}
	public boolean isImgTemplate() {
		return type == IMGTEMPLATE;
	}
	public URL getUrl() {
		return url;
	}
	public void setUrl(URL url) {
		this.url = url;
	}
	public byte[] getRawData() {
		return rawData;
	}
	public int getBpc() {
		return bpc;
	}
	public PdfTemplate getTemplateData() {
		return template[0];
	}
	public void setTemplateData(PdfTemplate template) {
		this.template[0] = template;
	}
	public int getAlignment() {
		return alignment;
	}
	public void setAlignment(int alignment) {
		this.alignment = alignment;
	}
	public String getAlt() {
		return alt;
	}
	public void setAlt(String alt) {
		this.alt = alt;
	}
	public void setAbsolutePosition(float absoluteX, float absoluteY) {
		this.absoluteX = absoluteX;
		this.absoluteY = absoluteY;
	}
	public boolean hasAbsoluteX() {
		return !Float.isNaN(absoluteX);
	}
	public float getAbsoluteX() {
		return absoluteX;
	}
	public boolean hasAbsoluteY() {
		return !Float.isNaN(absoluteY);
	}
	public float getAbsoluteY() {
		return absoluteY;
	}
	public float getScaledWidth() {
		return scaledWidth;
	}
	public float getScaledHeight() {
		return scaledHeight;
	}
	public float getPlainWidth() {
		return plainWidth;
	}
	public float getPlainHeight() {
		return plainHeight;
	}
	public void scaleAbsolute(float newWidth, float newHeight) {
		plainWidth = newWidth;
		plainHeight = newHeight;
		float[] matrix = matrix();
		scaledWidth = matrix[DX] - matrix[CX];
		scaledHeight = matrix[DY] - matrix[CY];
		setWidthPercentage(0);
	}
	public void scaleAbsoluteWidth(float newWidth) {
		plainWidth = newWidth;
		float[] matrix = matrix();
		scaledWidth = matrix[DX] - matrix[CX];
		scaledHeight = matrix[DY] - matrix[CY];
		setWidthPercentage(0);
	}
	public void scaleAbsoluteHeight(float newHeight) {
		plainHeight = newHeight;
		float[] matrix = matrix();
		scaledWidth = matrix[DX] - matrix[CX];
		scaledHeight = matrix[DY] - matrix[CY];
		setWidthPercentage(0);
	}
	public void scalePercent(float percent) {
		scalePercent(percent, percent);
	}
	public void scalePercent(float percentX, float percentY) {
		plainWidth = getWidth() * percentX / 100f;
		plainHeight = getHeight() * percentY / 100f;
		float[] matrix = matrix();
		scaledWidth = matrix[DX] - matrix[CX];
		scaledHeight = matrix[DY] - matrix[CY];
		setWidthPercentage(0);
	}
	public void scaleToFit(float fitWidth, float fitHeight) {
		 scalePercent(100);
		float percentX = fitWidth * 100 / getScaledWidth();
		float percentY = fitHeight * 100 / getScaledHeight();
		scalePercent(percentX < percentY ? percentX : percentY);
		setWidthPercentage(0);
	}
	public float[] matrix() {
		float[] matrix = new float[8];
		float cosX = (float) Math.cos(rotationRadians);
		float sinX = (float) Math.sin(rotationRadians);
		matrix[AX] = plainWidth * cosX;
		matrix[AY] = plainWidth * sinX;
		matrix[BX] = -plainHeight * sinX;
		matrix[BY] = plainHeight * cosX;
		if (rotationRadians < Math.PI / 2f) {
			matrix[CX] = matrix[BX];
			matrix[CY] = 0;
			matrix[DX] = matrix[AX];
			matrix[DY] = matrix[AY] + matrix[BY];
		}
		 else if (rotationRadians < Math.PI) {
			matrix[CX] = matrix[AX] + matrix[BX];
			matrix[CY] = matrix[BY];
			matrix[DX] = 0;
			matrix[DY] = matrix[AY];
		}
		 else if (rotationRadians < Math.PI * 1.5f) {
			matrix[CX] = matrix[AX];
			matrix[CY] = matrix[AY] + matrix[BY];
			matrix[DX] = matrix[BX];
			matrix[DY] = 0;
		}
		 else {
			matrix[CX] = 0;
			matrix[CY] = matrix[AY];
			matrix[DX] = matrix[AX] + matrix[BX];
			matrix[DY] = matrix[BY];
		}
		return matrix;
	}
	static long serialId = 0;
	static protected synchronized Long getSerialId() {
		++serialId;
		return new Long(serialId);
	}
	public Long getMySerialId() {
		return mySerialId;
	}
	protected float rotationRadians;
	 private float initialRotation;
	 public float getImageRotation() {
		double d = 2.0 * Math.PI;
		float rot = (float) ((rotationRadians - initialRotation) % d);
		if (rot < 0) {
			rot += d;
		}
		 return rot;
	 }
	public void setRotation(float r) {
		double d = 2.0 * Math.PI;
		rotationRadians = (float) ((r + initialRotation) % d);
		if (rotationRadians < 0) {
			rotationRadians += d;
		}
		float[] matrix = matrix();
		scaledWidth = matrix[DX] - matrix[CX];
		scaledHeight = matrix[DY] - matrix[CY];
	}
	public void setRotationDegrees(float deg) {
		double d = Math.PI;
		setRotation(deg / 180 * (float) d);
	}
	 public float getInitialRotation() {
		 return this.initialRotation;
	 }
	 public void setInitialRotation(float initialRotation) {
		 float old_rot = rotationRadians - this.initialRotation;
		 this.initialRotation = initialRotation;
		 setRotation(old_rot);
	 }
	protected float indentationLeft = 0;
	protected float indentationRight = 0;
	protected float spacingBefore;
	protected float spacingAfter;
	public float getIndentationLeft() {
		return indentationLeft;
	}
	public void setIndentationLeft(float f) {
		indentationLeft = f;
	}
	public float getIndentationRight() {
		return indentationRight;
	}
	public void setIndentationRight(float f) {
		indentationRight = f;
	}
	public float getSpacingBefore() {
		return spacingBefore;
	}
	public void setSpacingBefore(float spacing) {
		this.spacingBefore = spacing;
	}
	public float getSpacingAfter() {
		return spacingAfter;
	}
	public void setSpacingAfter(float spacing) {
		this.spacingAfter = spacing;
	}
	private float widthPercentage = 100;
	public float getWidthPercentage() {
		return this.widthPercentage;
	}
	public void setWidthPercentage(float widthPercentage) {
		this.widthPercentage = widthPercentage;
	}
	protected Annotation annotation = null;
	public void setAnnotation(Annotation annotation) {
		this.annotation = annotation;
	}
	public Annotation getAnnotation() {
		return annotation;
	}
	protected PdfOCG layer;
	public PdfOCG getLayer() {
		return layer;
	}
	public void setLayer(PdfOCG layer) {
		this.layer = layer;
	}
	protected boolean interpolation;
	public boolean isInterpolation() {
		return interpolation;
	}
	public void setInterpolation(boolean interpolation) {
		this.interpolation = interpolation;
	}
	protected int originalType = ORIGINAL_NONE;
	protected byte[] originalData;
	public int getOriginalType() {
		return this.originalType;
	}
	public void setOriginalType(int originalType) {
		this.originalType = originalType;
	}
	public byte[] getOriginalData() {
		return this.originalData;
	}
	public void setOriginalData(byte[] originalData) {
		this.originalData = originalData;
	}
	protected boolean deflated = false;
	public boolean isDeflated() {
		return this.deflated;
	}
	public void setDeflated(boolean deflated) {
		this.deflated = deflated;
	}
	protected int dpiX = 0;
	protected int dpiY = 0;
	public int getDpiX() {
		return dpiX;
	}
	public int getDpiY() {
		return dpiY;
	}
	public void setDpi(int dpiX, int dpiY) {
		this.dpiX = dpiX;
		this.dpiY = dpiY;
	}
	private float XYRatio = 0;
	public float getXYRatio() {
		return this.XYRatio;
	}
	public void setXYRatio(float XYRatio) {
		this.XYRatio = XYRatio;
	}
	protected int colorspace = -1;
	public int getColorspace() {
		return colorspace;
	}
	protected boolean invert = false;
	public boolean isInverted() {
		return invert;
	}
	public void setInverted(boolean invert) {
		this.invert = invert;
	}
	protected ICC_Profile profile = null;
	public void tagICC(ICC_Profile profile) {
		this.profile = profile;
	}
	public boolean hasICCProfile() {
		return this.profile != null;
	}
	public ICC_Profile getICCProfile() {
		return profile;
	}
	private PdfDictionary additional = null;
	public PdfDictionary getAdditional() {
		return this.additional;
	}
	public void setAdditional(PdfDictionary additional) {
		this.additional = additional;
	}
	 public void simplifyColorspace() {
		 if (additional == null) return;
		 PdfArray value = additional.getAsArray(PdfName.COLORSPACE);
		 if (value == null) return;
		 PdfObject cs = simplifyColorspace(value);
		 PdfObject newValue;
		 if (cs.isName()) newValue = cs;
		 else {
			 newValue = value;
			 PdfName first = value.getAsName(0);
			 if (PdfName.INDEXED.equals(first)) {
				 if (value.size() >= 2) {
					 PdfArray second = value.getAsArray(1);
					 if (second != null) {
						 value.set(1, simplifyColorspace(second));
					 }
				 }
			 }
		 }
		 additional.put(PdfName.COLORSPACE, newValue);
	 }
	 private PdfObject simplifyColorspace(PdfArray obj) {
		 if (obj == null) return obj;
		 PdfName first = obj.getAsName(0);
		 if (PdfName.CALGRAY.equals(first)) return PdfName.DEVICEGRAY;
		 else if (PdfName.CALRGB.equals(first)) return PdfName.DEVICERGB;
		 else return obj;
	 }
	protected boolean mask = false;
	protected Image imageMask;
	private boolean smask;
	public boolean isMask() {
		return mask;
	}
	public void makeMask() throws DocumentException {
		if (!isMaskCandidate())throw new DocumentException(MessageLocalization.getComposedMessage(""this.image.can.not.be.an.image.mask""));
		mask = true;
	}
	public boolean isMaskCandidate() {
		if (type == IMGRAW) {
			if (bpc > 0xff)return true;
		}
		return colorspace == 1;
	}
	public Image getImageMask() {
		return imageMask;
	}
	public void setImageMask(Image mask) throws DocumentException {
		if (this.mask)throw new DocumentException(MessageLocalization.getComposedMessage(""an.image.mask.cannot.contain.another.image.mask""));
		if (!mask.mask)throw new DocumentException(MessageLocalization.getComposedMessage(""the.image.mask.is.not.a.mask.did.you.do.makemask""));
		imageMask = mask;
		smask = mask.bpc > 1 && mask.bpc <= 8;
	}
	public boolean isSmask() {
		return this.smask;
	}
	public void setSmask(boolean smask) {
		this.smask = smask;
	}
	protected int transparency[];
	public int[] getTransparency() {
		return transparency;
	}
	public void setTransparency(int transparency[]) {
		this.transparency = transparency;
	}
	public int getCompressionLevel() {
		return compressionLevel;
	}
	public void setCompressionLevel(int compressionLevel) {
		if (compressionLevel < PdfStream.NO_COMPRESSION || compressionLevel > PdfStream.BEST_COMPRESSION)this.compressionLevel = PdfStream.DEFAULT_COMPRESSION;
		elsethis.compressionLevel = compressionLevel;
	}
}",1,0,0,0
"public interface MapState<K, V> extends State {
	 void put(K key, V value);
	 ReadableState<V> putIfAbsent(K key, V value);
	 void remove(K key);
	 ReadableState<V> get(K key);
	 ReadableState<Iterable<K>> keys();
	 ReadableState<Iterable<V>> values();
	 ReadableState<Iterable<Map.Entry<K, V>>> entries();
}",0,0,0,0
"public class TestNewPlanPushUpFilter {
	 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
	 public static void oneTimeSetup() throws Exception {
		 new File(""dummy"").delete();
	 }
	 public void tearDown() {
	 }
	 static public class MyFilterFunc extends FilterFunc {
		 public Boolean exec(Tuple input) {
			 return false;
		 }
	 }
	 public void testErrorEmptyInput() throws Exception {
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( """" );
		 Assert.assertTrue( !newLogicalPlan.getOperators().hasNext() );
	 }
	 public void testErrorNonFilterInput() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		store A into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get(0);
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
		 Assert.assertTrue( newLogicalPlan.getSuccessors(op) == null );
	 }
	 public void testFilterLoad() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = filter A by $1 < 18;
		"" + ""store B into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get(0);
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterStreaming() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = stream A through `"" + ""ps -u"" + ""`;
		"" + ""C = filter B by $1 < 18;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStream );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
	 }
	 public void testFilterSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = order A by $1, $2;
		"" + ""C = filter B by $1 < 18;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOSort );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterConstantConditionSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = order A by $1, $2;
		"" + ""C = filter B by 1 == 1;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOSort );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUDFSort() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = order A by $1, $2;
		"" + ""C = filter B by "" + MyFilterFunc.class.getName() + ""($1) ;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOSort );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterDistinct() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = distinct A;
		"" + ""C = filter B by $1 < 18;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LODistinct );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterConstantConditionDistinct() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = distinct A;
		"" + ""C = filter B by 1 == 1;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LODistinct );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUDFDistinct() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = distinct A;
		"" + ""C = filter B by "" + MyFilterFunc.class.getName() + ""($1) ;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LODistinct );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterFilter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = filter A by $0 != 'name';
		"" + ""C = filter B by $1 < 18;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 Assert.assertTrue( ((LOFilter)op).getAlias().equals( ""B"" ) );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 Assert.assertTrue( ((LOFilter)op).getAlias().equals( ""C"" ) );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterSplitOutput() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""split A into B if $1 < 18, C if $1 >= 18;
		"" + ""C = filter B by $1 < 10;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOSplit );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOSplitOutput );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterLimit() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = limit A 10;
		"" + ""C = filter B by $1 < 18;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUnion() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = union A, B;
		"" + ""D = filter C by $1 < 18;
		"" + ""E = STORE D into'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator unionA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( unionA instanceof LOUnion );
		 Operator unionB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( unionB instanceof LOUnion );
		 Assert.assertTrue( unionB == unionA );
		 Operator store = newLogicalPlan.getSuccessors(unionA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterConstantConditionUnion() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = union A, B;
		"" + ""D = filter C by 1 == 1;
		"" + ""E = STORE D into'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator unionA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( unionA instanceof LOUnion );
		 Operator unionB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( unionB instanceof LOUnion );
		 Assert.assertTrue( unionB == unionA );
		 Operator store = newLogicalPlan.getSuccessors(unionA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterUDFUnion() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = union A, B;
		"" + ""D = filter C by "" + MyFilterFunc.class.getName() + ""() ;
		"" + ""E = STORE D into'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator unionA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( unionA instanceof LOUnion );
		 Operator unionB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( unionB instanceof LOUnion );
		 Assert.assertTrue( unionB == unionA );
		 Operator store = newLogicalPlan.getSuccessors(unionA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cross A, B;
		"" + ""D = filter C by $5 < 18;
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""B"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testFilterCross1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cross A, B;
		"" + ""D = filter C by $1 < 18;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterCross2() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cross A, B;
		"" + ""D = filter C by $1 < 18 and $5 < 18;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator op = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
	 }
	 public void testFilterConstantConditionCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cross A, B;
		"" + ""D = filter C by 1 == 1;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator op = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
	 }
	 public void testFilterUDFCross() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cross A, B;
		"" + ""D = filter C by "" + MyFilterFunc.class.getName() + ""($0) ;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCross );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterCogroup() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cogroup A by $0, B by $0;
		"" + ""D = filter C by $0 < 'name';
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator cogrpA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( cogrpA instanceof LOCogroup );
		 Operator cogrpB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( cogrpB instanceof LOCogroup );
		 Assert.assertTrue( cogrpB == cogrpA );
		 Operator store = newLogicalPlan.getSuccessors(cogrpA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterConstantConditionCogroup() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cogroup A by $0, B by $0;
		"" + ""D = filter C by 1 == 1;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator cogrpA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( cogrpA instanceof LOCogroup );
		 Operator cogrpB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( cogrpB instanceof LOCogroup );
		 Assert.assertTrue( cogrpB == cogrpA );
		 Operator store = newLogicalPlan.getSuccessors(cogrpA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterUDFCogroup() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cogroup A by $0, B by $0;
		"" + ""D = filter C by "" + MyFilterFunc.class.getName() + ""($1) ;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator cogroupA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( cogroupA instanceof LOCogroup );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator cogroupB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( cogroupB instanceof LOCogroup );
		 Operator filter = newLogicalPlan.getSuccessors( cogroupA ).get( 0 );
		 Assert.assertTrue( filter instanceof LOFilter );
		 filter = newLogicalPlan.getSuccessors( cogroupB ).get( 0 );
		 Assert.assertTrue( cogroupB instanceof LOCogroup );
		 Assert.assertTrue( cogroupB == cogroupA );
		 Operator store = newLogicalPlan.getSuccessors(filter).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterCogroupOuter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cogroup A by $0, B by $0 outer;
		"" + ""D = filter C by $0 < 'name';
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator cogrpA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( cogrpA instanceof LOCogroup );
		 Operator cogrpB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( cogrpB instanceof LOCogroup );
		 Assert.assertTrue( cogrpB == cogrpA );
		 Operator store = newLogicalPlan.getSuccessors(cogrpA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterConstantConditionCogroupOuter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cogroup A by $0, B by $0 outer;
		"" + ""D = filter C by 1 == 1;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator filterA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( filterA instanceof LOFilter );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator filterB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( filterB instanceof LOFilter );
		 Operator cogrpA = newLogicalPlan.getSuccessors( filterA ).get( 0 );
		 Assert.assertTrue( cogrpA instanceof LOCogroup );
		 Operator cogrpB = newLogicalPlan.getSuccessors( filterB ).get( 0 );
		 Assert.assertTrue( cogrpB instanceof LOCogroup );
		 Assert.assertTrue( cogrpB == cogrpA );
		 Operator store = newLogicalPlan.getSuccessors(cogrpA).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterUDFCogroupOuter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = cogroup A by $0, B by $0 outer;
		"" + ""D = filter C by "" + MyFilterFunc.class.getName() + ""() ;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator loadA = null;
		 Operator loadB = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) {
			 loadA = loads.get( 0 );
			 loadB = loads.get( 1 );
		 }
		 else {
			 loadA = loads.get( 1 );
			 loadB = loads.get( 0 );
		 }
		 Operator foreachA = newLogicalPlan.getSuccessors(loadA).get( 0 );
		 Assert.assertTrue( foreachA instanceof LOForEach );
		 Operator cogroupA = newLogicalPlan.getSuccessors(foreachA).get( 0 );
		 Assert.assertTrue( cogroupA instanceof LOCogroup );
		 Operator foreachB = newLogicalPlan.getSuccessors(loadB).get( 0 );
		 Assert.assertTrue( foreachB instanceof LOForEach );
		 Operator cogroupB = newLogicalPlan.getSuccessors(foreachB).get( 0 );
		 Assert.assertTrue( cogroupB instanceof LOCogroup );
		 Operator filter = newLogicalPlan.getSuccessors( cogroupA ).get( 0 );
		 Assert.assertTrue( filter instanceof LOFilter );
		 filter = newLogicalPlan.getSuccessors( cogroupB ).get( 0 );
		 Assert.assertTrue( filter instanceof LOFilter );
		 Assert.assertTrue( cogroupB == cogroupA );
		 Operator store = newLogicalPlan.getSuccessors(filter).get( 0 );
		 Assert.assertTrue( store instanceof LOStore );
	 }
	 public void testFilterGroupBy() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = group A by $0;
		"" + ""C = filter B by $0 < 'name';
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCogroup );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterConstantConditionGroupBy() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = group A by $0;
		"" + ""C = filter B by 1 == 1;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCogroup );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUDFGroupBy() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = group A by $0;
		"" + ""C = filter B by "" + MyFilterFunc.class.getName() + ""($1) ;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCogroup );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterGroupByOuter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = group A by $0 outer;
		"" + ""C = filter B by $0 < 'name';
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCogroup );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterConstantConditionGroupByOuter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = group A by $0 outer;
		"" + ""C = filter B by 1 == 1;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCogroup );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUDFGroupByOuter() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = group A by $0 outer;
		"" + ""C = filter B by "" + MyFilterFunc.class.getName() + ""($1) ;
		"" + ""D = STORE C into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 Operator op = newLogicalPlan.getSources().get( 0 );
		 Assert.assertTrue( op instanceof LOLoad );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOCogroup );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0 using 'replicated';
		"" + ""D = filter C by $0 < 'name';
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testFilterFRJoin1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0 using 'replicated';
		"" + ""D = filter C by $4 < 'name';
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""B"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testFilterConstantConditionFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0 using 'replicated';
		"" + ""D = filter C by 1 == 1;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUDFFRJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0 using 'replicated';
		"" + ""D = filter C by "" + MyFilterFunc.class.getName() + ""();
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testFilterUDFFRJoin1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0 using 'replicated';
		"" + ""D = filter C by TupleSize(*) > 5;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = newLogicalPlan.getSuccessors( loads.get( 0 ) ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( loads.get( 1 ) ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
	 }
	 public void testFilterInnerJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0;
		"" + ""D = filter C by $0 < 'name';
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testFilterInnerJoin1() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0;
		"" + ""D = filter C by $4 < 'name';
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""B"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testFilterInnerJoin2() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0;
		"" + ""D = filter C by $0 < 'jonh' OR $1 > 50;
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOLimit );
	 }
	 public void testFilterInnerJoinNegative() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0;
		"" + ""D = filter C by $4 < 'name' AND $0 == 'joe';
		"" + ""E = limit D 10;
		"" + ""F = STORE E into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = newLogicalPlan.getSuccessors( loads.get( 0 ) ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors( loads.get( 1 ) ).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
	 }
	 public void testFilterUDFInnerJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name, age, preference);
		"" + ""C = join A by $0, B by $0;
		"" + ""D = filter C by "" + MyFilterFunc.class.getName() + ""() ;
		"" + ""E = STORE D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan( query );
		 List<Operator> loads = newLogicalPlan.getSources();
		 Assert.assertTrue( loads.size() == 2 );
		 Assert.assertTrue( loads.get( 0 ) instanceof LOLoad );
		 Assert.assertTrue( loads.get( 1 ) instanceof LOLoad );
		 Operator op = null;
		 if( ((LOLoad)loads.get( 0 )).getAlias().equals( ""A"" ) ) op = loads.get( 0 );
		 else op = loads.get( 1 );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOForEach );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOJoin );
		 op = newLogicalPlan.getSuccessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
	 }
	 public void testOutJoin() throws Exception {
		 String query = ""A = load 'myfile' as (name, age, gpa);
		"" + ""B = load 'anotherfile' as (name);
		"" + ""C = join A by name LEFT OUTER, B by name;
		"" + ""D = filter C by B::name is null;
		"" + ""store D into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan(query);
		 Operator op = newLogicalPlan.getSinks().get(0);
		 Assert.assertTrue( op instanceof LOStore );
		 op = newLogicalPlan.getPredecessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
	 }
	 public void testFullOutJoin() throws Exception {
		 String query = ""A = load 'myfile' as (d1:int);
		"" + ""B = load 'anotherfile' as (d2:int);
		"" + ""c = join A by d1 full outer, B by d2;
		"" + ""d = filter c by d2 is null;
		"" + ""store d into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan(query);
		 Operator op = newLogicalPlan.getSinks().get(0);
		 Assert.assertTrue( op instanceof LOStore );
		 op = newLogicalPlan.getPredecessors(op).get( 0 );
		 Assert.assertTrue( op instanceof LOFilter );
	 }
	 public void testFullOutJoin1() throws Exception {
		 String query = ""A = load 'myfile' as (d1:int);
		"" + ""B = load 'anotherfile' as (d2:int);
		"" + ""C = join A by d1 full outer, B by d2;
		"" + ""D = load 'xxx' as (d3:int);
		"" + ""E = join C by d1, D by d3;
		"" + ""F = filter E by d1 > 5;
		"" + ""G = store F into 'dummy';
		"";
		 LogicalPlan newLogicalPlan = migrateAndOptimizePlan(query);
		 List<Operator> ops = newLogicalPlan.getSinks();
		 Assert.assertTrue( ops.size() == 1 );
		 Operator op = ops.get( 0 );
		 Assert.assertTrue( op instanceof LOStore );
		 Operator join = newLogicalPlan.getPredecessors(op).get( 0 );
		 Assert.assertTrue( join instanceof LOJoin );
		 ops = newLogicalPlan.getPredecessors(join);
		 Assert.assertEquals( 2, ops.size() );
		 Assert.assertTrue( ops.get( 0 ) instanceof LOFilter || ops.get( 1 ) instanceof LOFilter );
	 }
	 private LogicalPlan migrateAndOptimizePlan(String query) throws Exception {
		 PigServer pigServer = new PigServer( pc );
		 LogicalPlan newLogicalPlan = Util.buildLp(pigServer, query);
		 PlanOptimizer optimizer = new MyPlanOptimizer( newLogicalPlan, 3 );
		 optimizer.optimize();
		 return newLogicalPlan;
	 }
	 public class MyPlanOptimizer extends LogicalPlanOptimizer {
		 protected MyPlanOptimizer(OperatorPlan p, int iterations) {
			 super(p, iterations, new HashSet<String>());
		 }
		 public void addPlanTransformListener(PlanTransformListener listener) {
			 super.addPlanTransformListener(listener);
		 }
		 protected List<Set<Rule>> buildRuleSets() {
			 List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
			 Set<Rule> s = new HashSet<Rule>();
			 Rule r = new LoadTypeCastInserter( ""TypeCastInserter"" );
			 s.add(r);
			 ls.add(s);
			 s = new HashSet<Rule>();
			 r = new PushUpFilter( ""PushUpFilter"" );
			 s.add(r);
			 ls.add(s);
			 return ls;
		 }
	 }
}",1,0,0,0
"class CompressorStream extends CompressionOutputStream {
	 Compressor compressor;
	 byte[] buffer;
	 boolean closed = false;
	 OutputStream rawOut;
	 public CompressorStream(OutputStream out, Compressor compressor, int bufferSize) {
		 super(out);
		 rawOut = out;
		 if (out == null || compressor == null) {
			 throw new NullPointerException();
		 }
		 else if (bufferSize <= 0) {
			 throw new IllegalArgumentException(""Illegal bufferSize"");
		 }
		 this.compressor = compressor;
		 buffer = new byte[bufferSize];
	 }
	 public CompressorStream(OutputStream out, Compressor compressor) {
		 this(out, compressor, 512);
	 }
	 protected CompressorStream(OutputStream out) {
		 super(out);
	 }
	 public void write(byte[] b, int off, int len) throws IOException {
		 if (compressor.finished()) {
			 throw new IOException(""write beyond end of stream"");
		 }
		 if ((off | len | (off + len) | (b.length - (off + len))) < 0) {
			 throw new IndexOutOfBoundsException();
		 }
		 else if (len == 0) {
			 return;
		 }
		 if (!compressor.finished()) {
			 compressor.setInput(b, off, len);
			 while (!compressor.needsInput()) {
				 compress();
			 }
		 }
	 }
	 void compress() throws IOException {
		 int len = compressor.compress(buffer, 0, buffer.length);
		 if (len > 0) {
			 out.write(buffer, 0, len);
		 }
	 }
	 public void finish() throws IOException {
		 if (!compressor.finished()) {
			 compressor.finish();
			 while (!compressor.finished()) {
				 compress();
			 }
		 }
	 }
	 public void resetState() throws IOException {
		 compressor.reset();
	 }
	 public void close() throws IOException {
		 if (!closed) {
			 finish();
			 out.close();
			 closed = true;
		 }
	 }
	 byte[] oneByte = new byte[1];
	 public void write(int b) throws IOException {
		 oneByte[0] = (byte)(b & 0xff);
		 write(oneByte, 0, oneByte.length);
	 }
}",0,0,0,0
"final class DelimitedStringToCollectionConverter implements ConditionalGenericConverter {
	private final ConversionService conversionService;
	DelimitedStringToCollectionConverter(ConversionService conversionService) {
		Assert.notNull(conversionService, ""ConversionService must not be null"");
		this.conversionService = conversionService;
	}
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(String.class, Collection.class));
	}
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		return targetType.getElementTypeDescriptor() == null || this.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor());
	}
	public Object convert(Object source, TypeDescriptor sourceType,TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		return convert((String) source, sourceType, targetType);
	}
	private Object convert(String source, TypeDescriptor sourceType,TypeDescriptor targetType) {
		Delimiter delimiter = targetType.getAnnotation(Delimiter.class);
		String[] elements = getElements(source,(delimiter != null) ? delimiter.value() : "","");
		TypeDescriptor elementDescriptor = targetType.getElementTypeDescriptor();
		Collection<Object> target = createCollection(targetType, elementDescriptor,elements.length);
		Stream<Object> stream = Arrays.stream(elements).map(String::trim);
		if (elementDescriptor != null) {
			stream = stream.map((element) -> this.conversionService.convert(element,sourceType, elementDescriptor));
		}
		stream.forEach(target::add);
		return target;
	}
	private Collection<Object> createCollection(TypeDescriptor targetType,TypeDescriptor elementDescriptor, int length) {
		return CollectionFactory.createCollection(targetType.getType(),(elementDescriptor != null) ? elementDescriptor.getType() : null, length);
	}
	private String[] getElements(String source, String delimiter) {
		return StringUtils.delimitedListToStringArray(source,Delimiter.NONE.equals(delimiter) ? null : delimiter);
	}
}",1,1,0,0
"public class ChangeDelta extends Delta{
	ChangeDelta(){
		super();
	}
	public ChangeDelta(Chunk orig, Chunk rev){
		init(orig, rev);
	}
	public void verify(List<Object> target) throws PatchFailedException{
		if (!original.verify(target)){
			throw new PatchFailedException();
		}
		if (original.first() > target.size()){
			throw new PatchFailedException(""original.first() > target.size()"");
		}
	}
	public void applyTo(List<Object> target){
		original.applyDelete(target);
		revised.applyAdd(original.first(), target);
	}
	public void toString(StringBuffer s){
		original.rangeString(s);
		s.append(""c"");
		revised.rangeString(s);
		s.append(Diff.NL);
		original.toString(s, ""< "", ""\n"");
		s.append(""---"");
		s.append(Diff.NL);
		revised.toString(s, ""> "", ""\n"");
	}
	public void toRCSString(StringBuffer s, String EOL){
		s.append(""d"");
		s.append(original.rcsfrom());
		s.append("" "");
		s.append(original.size());
		s.append(EOL);
		s.append(""a"");
		s.append(original.rcsto());
		s.append("" "");
		s.append(revised.size());
		s.append(EOL);
		revised.toString(s, """", EOL);
	}
	public void accept(RevisionVisitor visitor){
		visitor.visit(this);
	}
}",0,0,0,0
"private String readStringBytes(byte[] bytesData, int pos, long len) {
	StringBuilder resultValue = new StringBuilder();
	for (int i = 0;
	 i < len;
	 i++) {
		resultValue.append((char) bytesData[pos + i]);
	}
	return resultValue.toString();
}",0,0,0,0
"class ImmutableMapEntry<K, V> extends ImmutableEntry<K, V> {
	 static <K, V> ImmutableMapEntry<K, V>[] createEntryArray(int size) {
		 return new ImmutableMapEntry[size];
	 }
	 ImmutableMapEntry(K key, V value) {
		 super(key, value);
		 checkEntryNotNull(key, value);
	 }
	 ImmutableMapEntry(ImmutableMapEntry<K, V> contents) {
		 super(contents.getKey(), contents.getValue());
	 }
	 ImmutableMapEntry<K, V> getNextInKeyBucket() {
		 return null;
	 }
	 ImmutableMapEntry<K, V> getNextInValueBucket() {
		 return null;
	 }
	 boolean isReusable() {
		 return true;
	 }
	 static class NonTerminalImmutableMapEntry<K, V> extends ImmutableMapEntry<K, V> {
		 private final transient ImmutableMapEntry<K, V> nextInKeyBucket;
		 NonTerminalImmutableMapEntry(K key, V value, ImmutableMapEntry<K, V> nextInKeyBucket) {
			 super(key, value);
			 this.nextInKeyBucket = nextInKeyBucket;
		 }
		 final ImmutableMapEntry<K, V> getNextInKeyBucket() {
			 return nextInKeyBucket;
		 }
		 final boolean isReusable() {
			 return false;
		 }
	 }
	 static final class NonTerminalImmutableBiMapEntry<K, V> extends NonTerminalImmutableMapEntry<K, V> {
		 private final transient ImmutableMapEntry<K, V> nextInValueBucket;
		 NonTerminalImmutableBiMapEntry( K key, V value, ImmutableMapEntry<K, V> nextInKeyBucket, ImmutableMapEntry<K, V> nextInValueBucket) {
			 super(key, value, nextInKeyBucket);
			 this.nextInValueBucket = nextInValueBucket;
		 }
		 ImmutableMapEntry<K, V> getNextInValueBucket() {
			 return nextInValueBucket;
		 }
	 }
}",0,0,0,0
"public class TestNode extends GraphTestBase{
	 public TestNode( String name ) {
		 super( name );
	 }
	 public static TestSuite suite() {
		 return new TestSuite( TestNode.class );
	 }
	 private static final String U = ""http: private static final String N = ""Alice"";
	 private static final LiteralLabel L = LiteralLabelFactory.create( ""ashes are burning"", ""en"", false );
	 private static final BlankNodeId A = BlankNodeId.create();
	 public void testBlanks() {
		 assertTrue( ""anonymous nodes are blank"", NodeFactory.createBlankNode().isBlank() );
		 assertFalse( ""anonymous nodes aren't literal"", NodeFactory.createBlankNode().isLiteral() );
		 assertFalse( ""anonymous nodes aren't URIs"", NodeFactory.createBlankNode().isURI() );
		 assertFalse( ""anonymous nodes aren't variables"", NodeFactory.createBlankNode().isVariable() );
		 assertEquals( ""anonymous nodes have the right id"", NodeFactory.createBlankNode(A).getBlankNodeId(), A );
	 }
	 public void testLiterals() {
		 assertFalse( ""literal nodes aren't blank"", NodeFactory.createLiteral( L ).isBlank() );
		 assertTrue( ""literal nodes are literal"", NodeFactory.createLiteral( L ).isLiteral() );
		 assertFalse( ""literal nodes aren't variables"", NodeFactory.createLiteral( L ).isVariable() );
		 assertFalse( ""literal nodes aren't URIs"", NodeFactory.createLiteral( L ).isURI() );
		 assertEquals( ""literal nodes preserve value"", NodeFactory.createLiteral( L ).getLiteral(), L );
	 }
	 public void testURIs() {
		 assertFalse( ""URI nodes aren't blank"", NodeFactory.createURI( U ).isBlank() );
		 assertFalse( ""URI nodes aren't literal"", NodeFactory.createURI( U ).isLiteral() );
		 assertFalse( ""URI nodes aren't variables"", NodeFactory.createURI( U ).isVariable() );
		 assertTrue( ""URI nodes are URIs"", NodeFactory.createURI( U ).isURI() );
		 assertEquals( ""URI nodes preserve URI"", NodeFactory.createURI( U ).getURI(), U );
	 }
	 public void testVariables() {
		 assertFalse( ""variable nodes aren't blank"", NodeFactory.createVariable( N ).isBlank() );
		 assertFalse( ""variable nodes aren't literal"", NodeFactory.createVariable( N ).isLiteral() );
		 assertFalse( ""variable nodes aren't URIs"", NodeFactory.createVariable( N ).isURI() );
		 assertTrue( ""variable nodes are variable"", NodeFactory.createVariable( N ).isVariable() );
		 assertEquals( ""variable nodes keep their name"", N, NodeFactory.createVariable( N ).getName() );
		 assertEquals( ""variable nodes keep their name"", N + ""x"", NodeFactory.createVariable( N + ""x"" ).getName() );
	 }
	 public void testANY() {
		 assertFalse( ""ANY nodes aren't blank"", Node.ANY.isBlank() );
		 assertFalse( ""ANY nodes aren't literals"", Node.ANY.isLiteral() );
		 assertFalse( ""ANY nodes aren't URIs"", Node.ANY.isURI() );
		 assertFalse( ""ANY nodes aren't variables"", Node.ANY.isVariable() );
		 assertFalse( ""ANY nodes aren't blank"", Node.ANY.isBlank() );
		 assertFalse( ""ANY nodes aren't blank"", Node.ANY.isBlank() );
	 }
	 public void testNodeVariableConstructor() {
		 assertEquals( NodeFactory.createVariable( ""hello"" ), new Node_Variable( ""hello"" ) );
		 assertEquals( NodeFactory.createVariable( ""world"" ), new Node_Variable( ""world"" ) );
		 assertDiffer( NodeFactory.createVariable( ""hello"" ), new Node_Variable( ""world"" ) );
		 assertEquals( ""myName"", new Node_Variable( ""myName"" ).getName() );
	 }
	 private Object [][] eqTestCases() {
		 BlankNodeId id = BlankNodeId.create();
		 LiteralLabel L2 = LiteralLabelFactory.create( id.toString(), """", false );
		 LiteralLabel LLang1 = LiteralLabelFactory.createByValue( ""xyz"", ""en"", null) ;
		 LiteralLabel LLang2 = LiteralLabelFactory.createByValue( ""xyz"", ""EN"", null) ;
		 String U2 = id.toString();
		 String N2 = id.toString();
		 return new Object [][] {
			 {
			 Node.ANY, ""0"" }
			, {
			 NodeFactory.createBlankNode( id ), ""1"" }
			, {
			 NodeFactory.createBlankNode(), ""2"" }
			, {
			 NodeFactory.createBlankNode( id ), ""1"" }
			, {
			 NodeFactory.createLiteral( L ), ""3"" }
			, {
			 NodeFactory.createLiteral( L2 ), ""4"" }
			, {
			 NodeFactory.createLiteral( L ), ""3"" }
			, {
			 NodeFactory.createURI( U ), ""5"" }
			, {
			 NodeFactory.createURI( U2 ), ""6"" }
			, {
			 NodeFactory.createURI( U ), ""5"" }
			, {
			 NodeFactory.createVariable( N ), ""7"" }
			, {
			 NodeFactory.createVariable( N2 ), ""8"" }
			, {
			 NodeFactory.createVariable( N ), ""7"" }
			 , {
			 NodeFactory.createLiteral( LLang1 ), ""9"" }
			, {
			 NodeFactory.createLiteral( LLang2 ), ""10"" }
		, }
		;
	 }
	 public void testNodeEquals() {
		 Object [][] tests = eqTestCases();
		 for ( Object[] I : tests ) {
			 assertFalse( I[0] + "" should not equal null"", I[0].equals( null ) );
			 assertFalse( I[0] + ""should not equal 'String'"", I[0].equals( ""String"" ) );
			 for ( Object[] J : tests ) {
				 testEquality( I[1].equals( J[1] ), I[0], J[0] );
			 }
		 }
	 }
	 private void testEquality( boolean testEq, Object x, Object y ) {
		 String testName = getType( x ) + "" "" + x + "" and "" + getType( y ) + "" "" + y;
		 if (testEq) assertEquals( testName + ""should be equal"", x, y );
		 else assertDiffer( testName + "" should differ"", x, y );
	 }
	 private String getType( Object x ) {
		 String fullName = x.getClass().getName();
		 return fullName.substring( fullName.lastIndexOf( '.' ) + 1 );
	 }
	 public void testEquals() {
		 assertDiffer( ""different variables"", NodeFactory.createVariable( ""xx"" ), NodeFactory.createVariable( ""yy"" ) );
		 assertEquals( ""same vars"", NodeFactory.createVariable( ""aa"" ), NodeFactory.createVariable( ""aa"" ) );
		 assertEquals( ""same URI"", NodeFactory.createURI( U ), NodeFactory.createURI( U ) );
		 assertEquals( ""same anon"", NodeFactory.createBlankNode( A ), NodeFactory.createBlankNode( A ) );
		 assertEquals( ""same literal"", NodeFactory.createLiteral( L ), NodeFactory.createLiteral( L ) );
		 assertFalse( ""distinct URIs"", NodeFactory.createURI( U ) == NodeFactory.createURI( U ) );
		 assertFalse( ""distinct hyphens"", NodeFactory.createBlankNode( A ) == NodeFactory.createBlankNode( A ) );
		 assertFalse( ""distinct literals"", NodeFactory.createLiteral( L ) == NodeFactory.createLiteral( L ) );
		 assertFalse( ""distinct vars"", NodeFactory.createVariable( ""aa"" ) == NodeFactory.createVariable( ""aa"" ) );
	 }
	 public void testLabels() {
		 BlankNodeId id = BlankNodeId.create();
		 assertEquals( ""get URI value"", U, NodeFactory.createURI( U ).getURI() );
		 assertEquals( ""get blank value"", id, NodeFactory.createBlankNode( id ).getBlankNodeId() );
		 assertEquals( ""get literal value"", L, NodeFactory.createLiteral( L ).getLiteral() );
		 assertEquals( ""get variable name"", N, NodeFactory.createVariable( N ).getName() );
	 }
	 public void testFailingLabels() {
		 Node u = NodeFactory.createURI( U ), b = NodeFactory.createBlankNode();
		 Node l = NodeFactory.createLiteral( L ), v = NodeFactory.createVariable( N );
		 Node a = Node.ANY;
		 testGetURIFails( a );
		 testGetURIFails( b );
		 testGetURIFails( l );
		 testGetURIFails( v );
		 testGetLiteralFails( a );
		 testGetLiteralFails( u );
		 testGetLiteralFails( b );
		 testGetLiteralFails( v );
		 testGetNameFails( a );
		 testGetNameFails( u );
		 testGetNameFails( b );
		 testGetNameFails( l );
		 testGetBlankNodeIdFails( a );
		 testGetBlankNodeIdFails( u );
		 testGetBlankNodeIdFails( l );
		 testGetBlankNodeIdFails( v );
	 }
	 public void testGetBlankNodeIdFails( Node n ) {
		 try {
			 n.getBlankNodeId();
			 fail( n.getClass() + "" should fail getName()"" );
		 }
		 catch (UnsupportedOperationException e) {
		}
	 }
	 public void testGetURIFails( Node n ) {
		 try {
			 n.getURI();
			 fail( n.getClass() + "" should fail getURI()"" );
		 }
		 catch (UnsupportedOperationException e) {
		}
	 }
	 public void testGetNameFails( Node n ) {
		 try {
			 n.getName();
			 fail( n.getClass() + "" should fail getName()"" );
		 }
		 catch (UnsupportedOperationException e) {
		}
	 }
	 public void testGetLiteralFails( Node n ) {
		 try {
			 n.getLiteral();
			 fail( n.getClass() + "" should fail getLiteral()"" );
		 }
		 catch (UnsupportedOperationException e) {
		}
	 }
	 public void testGetBlankNodeLabelString() {
		 Node n = NodeFactory.createBlankNode();
		 assertEquals( n.getBlankNodeId().getLabelString(), n.getBlankNodeLabel() );
	 }
	 public void testVariableSupport() {
		 assertEquals( Node_Variable.variable( ""xxx"" ), Node_Variable.variable( ""xxx"" ) );
		 assertDiffer( Node_Variable.variable( ""xxx"" ), Node_Variable.variable( ""yyy"" ) );
		 assertEquals( Node_Variable.variable( ""aaa"" ), Node_Variable.variable( ""aaa"" ) );
		 assertDiffer( Node_Variable.variable( ""aaa"" ), Node_Variable.variable( ""yyy"" ) );
	 }
	 public void testCreateBadString() {
		 try {
			 NodeCreateUtils.create( null );
			 fail( ""must catch null argument"" );
		 }
		 catch (NullPointerException e) {
		}
		 catch (JenaException e) {
		}
		 try {
			 NodeCreateUtils.create( """" );
			 fail(""must catch empty argument"" );
		 }
		 catch (JenaException e) {
		}
	 }
	 public void testCreateBlankNode() {
		 String idA = ""_xxx"", idB = ""_yyy"";
		 Node a = NodeCreateUtils.create( idA ), b = NodeCreateUtils.create( idB );
		 assertTrue( ""both must be bnodes"", a.isBlank() && b.isBlank() );
		 assertEquals( BlankNodeId.create( idA ), a.getBlankNodeId() );
		 assertEquals( BlankNodeId.create( idB ), b.getBlankNodeId() );
	 }
	 public void testCreateVariable() {
		 String V = ""wobbly"";
		 Node v = NodeCreateUtils.create( ""?"" + V );
		 assertTrue( ""must be a variable"", v.isVariable() );
		 assertEquals( ""name must be correct"", V, v.getName() );
	 }
	 public void testCreateANY() {
		 assertEquals( ""?? must denote ANY"", Node.ANY, NodeCreateUtils.create( ""??"" ) );
	 }
	 public void testCreatePlainLiteralSingleQuotes() {
		 Node n = NodeCreateUtils.create( ""'xxx'"" );
		 assertEquals( ""xxx"", n.getLiteralLexicalForm() );
		 assertString(n);
	 }
	 public void testCreatePlainLiteralDoubleQuotes() {
		 Node n = NodeCreateUtils.create( ""\""xxx\"""" );
		 assertEquals( ""xxx"", n.getLiteralLexicalForm() );
		 assertString(n);
	 }
	 public void testCreateLiteralBackslashEscape() {
		 testStringConversion( ""xx\\x"", ""'xx\\\\x'"" );
		 testStringConversion( ""xx\\x\\y"", ""'xx\\\\x\\\\y'"" );
		 testStringConversion( ""\\xyz\\"", ""'\\\\xyz\\\\'"" );
	 }
	 public void testCreateLiteralQuoteEscapes() {
		 testStringConversion( ""x\'y"", ""'x\\'y'"" );
		 testStringConversion( ""x\""y"", ""'x\\\""y'"" );
		 testStringConversion( ""x\'y\""z"", ""'x\\\'y\\\""z'"" );
	 }
	 public void testCreateLiteralOtherEscapes() {
		 testStringConversion( "" "", ""'\\s'"" );
		 testStringConversion( ""\t"", ""'\\t'"" );
		 testStringConversion( ""\n"", ""'\\n'"" );
	 }
	 protected void testStringConversion(String wanted, String template) {
		 Node n = NodeCreateUtils.create(template) ;
		 assertEquals(wanted, n.getLiteralLexicalForm()) ;
		 assertEquals("""", n.getLiteralLanguage()) ;
		 assertString(n) ;
	 }
	 public void testCreateLanguagedLiteralEN1() {
		 Node n = NodeCreateUtils.create( ""'chat'en-UK"" );
		 assertEquals( ""chat"", n.getLiteralLexicalForm() );
		 assertLangString(n);
		 assertEquals( ""en-UK"", n.getLiteralLanguage() );
	 }
	 public void testCreateLanguagedLiteralEN2() {
		 Node n1 = NodeCreateUtils.create( ""'chat'en-UK"" );
		 Node n2 = NodeCreateUtils.create( ""'chat'EN-UK"" );
		 assertTrue( n1.sameValueAs(n2) ) ;
		 assertFalse( n1.equals(n2) ) ;
	 }
	 public void testCreateLanguagedLiteralXY() {
		 Node n = NodeCreateUtils.create( ""\""chat\""xy-AB"" );
		 assertEquals( ""chat"", n.getLiteralLexicalForm() );
		 assertEquals( ""xy-AB"", n.getLiteralLanguage() );
		 assertLangString(n) ;
	 }
	 public void testCreateTypedLiteralInteger() {
		 Node n = NodeCreateUtils.create( ""'42'xsd:integer"" );
		 assertEquals( ""42"", n.getLiteralLexicalForm() );
		 assertEquals( """", n.getLiteralLanguage() );
		 assertEquals( expand( ""xsd:integer"" ), n.getLiteralDatatypeURI() );
	 }
	 public void testCreateTypedLiteralBoolean() {
		 Node n = NodeCreateUtils.create( ""\""true\""xsd:boolean"" );
		 assertEquals( ""true"", n.getLiteralLexicalForm() );
		 assertEquals( """", n.getLiteralLanguage() );
		 assertEquals( expand( ""xsd:boolean"" ), n.getLiteralDatatypeURI() );
	 }
	 public void testGetPlainLiteralLexicalForm() {
		 Node n = NodeCreateUtils.create( ""'stuff'"" );
		 assertEquals( ""stuff"", n.getLiteralLexicalForm() );
	 }
	 public void testGetNumericLiteralLexicalForm() {
		 Node n = NodeCreateUtils.create( ""17"" );
		 assertEquals( ""17"", n.getLiteralLexicalForm() );
	 }
	 public void testTypesExpandPrefix() {
		 testTypeExpandsPrefix( ""rdf:spoo"" );
		 testTypeExpandsPrefix( ""rdfs:bar"" );
		 testTypeExpandsPrefix( ""owl:henry"" );
		 testTypeExpandsPrefix( ""xsd:bool"" );
		 testTypeExpandsPrefix( ""unknown:spoo"" );
	 }
	 private void testTypeExpandsPrefix( String type ) {
		 Node n = NodeCreateUtils.create( ""'stuff'"" + type );
		 String wanted = PrefixMapping.Extended.expandPrefix( type );
		 assertEquals( wanted, n.getLiteralDatatypeURI() );
	 }
	 public void testCreateURI() {
		 String uri = ""http: testCreateURI( uri );
		 testCreateURI( ""rdf:trinket"", ""http: testCreateURI( ""rdfs:device"", ""http: testCreateURI( ""dc:creator"", DC.getURI() + ""creator"" );
		 testCreateURI( ""rss:something"", RSS.getURI() + ""something"" );
		 testCreateURI( ""vcard:TITLE"", VCARD.getURI() + ""TITLE"" );
		 testCreateURI( ""owl:wol"", OWL.NAMESPACE + ""wol"" );
	 }
	 public void testCreateURIOtherMap() {
		 String myNS = ""eh:foo/bar#"", suffix = ""something"";
		 PrefixMapping mine = PrefixMapping.Factory.create().setNsPrefix( ""mine"", myNS );
		 Node n = NodeCreateUtils.create( mine, ""mine:"" + suffix );
		 assertEquals( myNS + suffix, n.getURI() );
	 }
	 private void testCreateURI( String inOut ) {
		 testCreateURI( inOut, inOut );
	 }
	 private void testCreateURI( String in, String wanted ) {
		 String got = NodeCreateUtils.create( in ).getURI();
		 if (!wanted.equals( got )) {
			 if (in.equals( wanted )) fail( ""should preserve "" + in );
			 else fail( ""should translate "" + in + "" to "" + wanted + "" not "" + got );
		 }
	 }
	 public void testCreatePrefixed() {
		 PrefixMapping pm = PrefixMapping.Factory.create();
		 NodeCreateUtils.create( pm, ""xyz"" );
	 }
	 public void testToStringWithPrefixMapping() {
		 PrefixMapping pm = PrefixMapping.Factory.create();
		 String prefix = ""spoo"", ns = ""abc:def/ghi#"";
		 pm.setNsPrefix( prefix, ns );
		 String suffix = ""bamboozle"";
		 assertEquals( prefix + "":"" + suffix, NodeCreateUtils.create( ns + suffix ).toString( pm ) );
	 }
	 public void testNodeHelp() {
		 assertTrue( ""node() making URIs"", node( ""hello"" ).isURI() );
		 assertTrue( ""node() making literals"", node( ""123"" ).isLiteral() );
		 assertTrue( ""node() making literals"", node( ""'hello'"" ).isLiteral() );
		 assertTrue( ""node() making hyphens"", node( ""_x"" ).isBlank() );
		 assertTrue( ""node() making variables"", node( ""?x"" ).isVariable() );
	 }
	 public void testVisitorPatternNode() {
		 NodeVisitor returnNode = new NodeVisitor() {
			 public Object visitAny( Node_ANY it ) {
				 return it;
			 }
			 public Object visitBlank( Node_Blank it, BlankNodeId id ) {
				 return it;
			 }
			 public Object visitLiteral( Node_Literal it, LiteralLabel lit ) {
				 return it;
			 }
			 public Object visitURI( Node_URI it, String uri ) {
				 return it;
			 }
			 public Object visitVariable( Node_Variable it, String name ) {
				 return it;
			 }
			 public Object visitTriple(Node_Triple it, Triple triple) {
				 return it;
			 }
			 public Object visitGraph(Node_Graph it, Graph graph) {
				 return it;
			 }
		 }
		;
		 testVisitorPatternNode( ""sortOfURI"", returnNode );
		 testVisitorPatternNode( ""?variable"", returnNode );
		 testVisitorPatternNode( ""_anon"", returnNode );
		 testVisitorPatternNode( ""11"", returnNode );
		 testVisitorPatternNode( ""??"", returnNode );
	 }
	 private void testVisitorPatternNode( String ns, NodeVisitor v ) {
		 Node n = node( ns );
		 assertEquals( n, n.visitWith( v ) );
	 }
	 private void visitExamples( NodeVisitor nv ) {
		 node( ""sortOfURI"" ).visitWith( nv );
		 node( ""?variableI"" ).visitWith( nv );
		 node( ""_anon"" ).visitWith( nv );
		 node( ""11"" ).visitWith( nv );
		 node( ""??"" ).visitWith( nv );
		 Node s = node( ""uri1"" );
		 Node p = node( ""uri2"" );
		 Node o = node( ""uri1"" );
		 Node_Triple nt = new Node_Triple(s, p, o);
		 nt.visitWith(nv);
		 Graph g = GraphMemFactory.empty();
		 Node_Graph ng = new Node_Graph(g);
		 ng.visitWith(nv);
	 }
	 public void testVisitorPatternValue() {
		 NodeVisitor checkValue = new NodeVisitor() {
			 public Object visitAny( Node_ANY it ) {
				 return null;
			 }
			 public Object visitBlank( Node_Blank it, BlankNodeId id ) {
				 assertTrue( it.getBlankNodeId() == id );
				 return null;
			 }
			 public Object visitLiteral( Node_Literal it, LiteralLabel lit ) {
				 assertTrue( it.getLiteral() == lit );
				 return null;
			 }
			 public Object visitURI( Node_URI it, String uri ) {
				 assertTrue( it.getURI() == uri );
				 return null;
			 }
			 public Object visitVariable( Node_Variable it, String name ) {
				 assertEquals( it.getName(), name );
				 return null;
			 }
			 public Object visitTriple(Node_Triple it, Triple triple) {
				 assertEquals( it.getTriple(), triple );
				 return null;
			 }
			 public Object visitGraph(Node_Graph it, Graph graph) {
				 assertEquals( it.getGraph(), graph );
				 return null;
			 }
		 }
		;
		 visitExamples( checkValue );
	 }
	 public void testVisitorPatternCalled() {
		 final String [] strings = new String [] {
		 """" }
		;
		 NodeVisitor checkCalled = new NodeVisitor() {
			 public Object visitAny( Node_ANY it ) {
				 strings[0] += "" any"";
				 return null;
			 }
			 public Object visitBlank( Node_Blank it, BlankNodeId id ) {
				 strings[0] += "" blank"";
				 return null;
			 }
			 public Object visitLiteral( Node_Literal it, LiteralLabel lit ) {
				 strings[0] += "" literal"";
				 return null;
			 }
			 public Object visitURI( Node_URI it, String uri ) {
				 strings[0] += "" uri"";
				 return null;
			 }
			 public Object visitVariable( Node_Variable it, String name ) {
				 strings[0] += "" variable"";
				 return null;
			 }
			 public Object visitTriple(Node_Triple it, Triple triple) {
				 strings[0] += "" termTriple"";
				 return null;
			 }
			 public Object visitGraph(Node_Graph it, Graph graph) {
				 strings[0] += "" termGraph"";
				 return null;
			 }
		 }
		;
		 String desired = "" uri variable blank literal any termTriple termGraph"";
		 visitExamples( checkCalled );
		 assertEquals( ""all visits must have been made"", desired, strings[0] );
	 }
	 public void testSimpleMatches() {
		 assertTrue( NodeCreateUtils.create( ""S"").matches( NodeCreateUtils.create( ""S"" ) ) );
		 assertFalse( """", NodeCreateUtils.create( ""S"").matches( NodeCreateUtils.create( ""T"" ) ) );
		 assertFalse( """", NodeCreateUtils.create( ""S"" ).matches( null ) );
		 assertTrue( NodeCreateUtils.create( ""_X"").matches( NodeCreateUtils.create( ""_X"" ) ) );
		 assertFalse( """", NodeCreateUtils.create( ""_X"").matches( NodeCreateUtils.create( ""_Y"" ) ) );
		 assertFalse( """", NodeCreateUtils.create( ""_X"").matches( null ) );
		 assertTrue( NodeCreateUtils.create( ""10"" ).matches( NodeCreateUtils.create( ""10"" ) ) );
		 assertFalse( """", NodeCreateUtils.create( ""10"" ).matches( NodeCreateUtils.create( ""11"" ) ) );
		 assertFalse( """", NodeCreateUtils.create( ""10"" ).matches( null ) );
		 assertTrue( Node.ANY.matches( NodeCreateUtils.create( ""S"" ) ) );
		 assertTrue( Node.ANY.matches( NodeCreateUtils.create( ""_X"" ) ) );
		 assertTrue( Node.ANY.matches( NodeCreateUtils.create( ""10"" ) ) );
		 assertFalse( """", Node.ANY.matches( null ) );
	 }
	 public void testDataMatches() {
		 TypeMapper tm = TypeMapper.getInstance();
		 RDFDatatype dt1 = tm.getTypeByValue( Integer.valueOf( 10 ) );
		 RDFDatatype dt2 = tm.getTypeByValue( Short.valueOf( (short) 10 ) );
		 Node a = NodeFactory.createLiteral( ""10"", dt1 );
		 Node b = NodeFactory.createLiteral( ""10"", dt2 );
		 assertDiffer( ""types must make a difference"", a, b );
		 assertTrue( ""A and B must express the same value"", a.sameValueAs( b ) );
		 assertTrue( ""matching literals must respect sameValueAs"", a.matches( b ) );
	 }
	 public void testLiteralToString() {
		 TypeMapper tm = TypeMapper.getInstance();
		 RDFDatatype dtInt = tm.getTypeByValue( Integer.valueOf( 10 ) );
		 Node plain = NodeFactory.createLiteral( ""rhubarb"", """");
		 Node english = NodeFactory.createLiteral( ""eccentric"", ""en_UK"");
		 Node typed = NodeFactory.createLiteral( ""10"", dtInt );
		 assertEquals( ""\""rhubarb\"""", plain.toString() );
		 assertEquals( ""rhubarb"", plain.toString( false ) );
		 assertEquals( ""\""eccentric\"""", english.toString() );
	 assertEquals( ""10^^http: }
	 public void testGetIndexingValueURI() {
		 Node u = NodeCreateUtils.create( ""eh:/telephone"" );
		 assertSame( u, u.getIndexingValue() );
	 }
	 public void testGetIndexingValueBlank() {
		 Node b = NodeCreateUtils.create( ""_television"" );
		 assertSame( b, b.getIndexingValue() );
	 }
	 public void testGetIndexingValuePlainString() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""'literally'"" ) );
	 }
	 public void testGetIndexingValueLanguagedString() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""'chat'fr"" ) );
	 }
	 public void testGetIndexingValueXSDString() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""'string'xsd:string"" ) );
	 }
	 public void testGetIndexingValueHexBinary1() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""''xsd:hexBinary"" ) );
	 }
	 public void testGetIndexingValueHexBinary2() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""'ABCD'xsd:hexBinary"" ) );
	 }
	 public void testGetIndexingValueBase64Binary1() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""''xsd:base64Binary"" ) );
	 }
	 public void testGetIndexingValueBase64Binary2() {
		 testIndexingValueLiteral( ()->NodeCreateUtils.create( ""'c3VyZS4='xsd:base64Binary"" ) );
	 }
	 private void testIndexingValueLiteral( Creator<Node> creator) {
		 Node n1 = creator.create();
		 Node n2 = creator.create();
		 testIndexingValueLiteral(n1,n2);
	 }
	 private void testIndexingValueLiteral(Node n1, Node n2) {
		 assertNotSame(n1, n2);
		 assertEquals(n1.getLiteral().getIndexingValue(), n2.getIndexingValue());
		 assertEquals(n1.getLiteral().getIndexingValue().hashCode(), n2.getIndexingValue().hashCode());
	 }
	 public void testGetLiteralValuePlainString() {
		 Node s = NodeCreateUtils.create( ""'aString'"" );
		 assertSame( s.getLiteral().getValue(), s.getLiteralValue() );
	 }
	 public void testGetLiteralDatatypePlainString() {
		 assertString(NodeCreateUtils.create( ""'plain'"" )) ;
	 }
	 public void testLiteralIsXML() {
		 assertFalse( NodeCreateUtils.create( ""'notXML'"" ).getLiteralIsXML() );
		 assertFalse( NodeCreateUtils.create( ""17"" ).getLiteralIsXML() );
		 assertFalse( NodeCreateUtils.create( ""'joke'xsd:Joke"" ).getLiteralIsXML() );
		 assertTrue( NodeFactory.createLiteral( ""lit"", ""lang"", true ).getLiteralIsXML() );
		 assertFalse( NodeFactory.createLiteral( ""lit"", ""lang"", false ).getLiteralIsXML() );
	 }
	 public void testConcrete() {
		 assertTrue( NodeCreateUtils.create( ""S"" ).isConcrete() );
		 assertTrue( NodeCreateUtils.create( ""_P"" ).isConcrete() );
		 assertTrue( NodeCreateUtils.create( ""11"" ).isConcrete() );
		 assertTrue( NodeCreateUtils.create( ""'hello'"" ).isConcrete() );
		 assertFalse( NodeCreateUtils.create( ""??"" ).isConcrete() );
		 assertFalse( NodeCreateUtils.create( ""?x"" ).isConcrete() );
	 }
	 static String [] someURIs = new String [] {
	 ""http: ""http: ""ftp: ""potatoe:rhubarb"" }
	;
	 public void testNamespace() {
		 for ( String uri : someURIs ) {
			 int split = Util.splitNamespaceXML( uri );
			 Node n = NodeCreateUtils.create( uri );
			 assertEquals( ""check namespace"", uri.substring( 0, split ), n.getNameSpace() );
			 assertEquals( ""check localname"", uri.substring( split ), n.getLocalName() );
		 }
	 }
	 protected static String [] someNodes = {
	 ""42"", ""'hello'"", ""_anon"", ""'robotic'tick"", ""'teriffic'abc:def"" }
	;
	 public void testHasURI() {
		 for ( String someURI : someURIs ) {
			 testHasURI( someURI );
		 }
		 for ( String someNode : someNodes ) {
			 testHasURI( someNode );
		 }
	 }
	 protected void testHasURI( String uri ) {
		 Node n = NodeCreateUtils.create( uri );
		 assertTrue( uri, !n.isURI() || n.hasURI( uri ) );
		 assertFalse( uri, n.hasURI( uri + ""x"" ) );
	 }
	 private static void assertString(Node n) {
		 RDFDatatype dt = n.getLiteralDatatype() ;
		 assertEquals("""", n.getLiteralLanguage() ) ;
		 if ( JenaRuntime.isRDF11 ) assertEquals(XSDDatatype.XSDstring, dt) ;
		 else assertEquals(null, dt) ;
	 }
	 private static void assertLangString(Node n) {
		 RDFDatatype dt = n.getLiteralDatatype() ;
		 assertDiffer("""", n.getLiteralLanguage() ) ;
		 if ( JenaRuntime.isRDF11 ) assertEquals(RDF.dtLangString, dt) ;
		 else assertEquals(null, dt) ;
	 }
	 private String expand( String s ) {
		 return PrefixMapping.Extended.expandPrefix( s );
	 }
}",1,0,0,0
"private static ColumnIdentifier getValueId(CFMetaData cfm) {
	 return cfm.getValueAlias() == null ? new ColumnIdentifier(DEFAULT_VALUE_ALIAS, false) : new ColumnIdentifier(cfm.getValueAlias());
 }",0,0,0,0
"final class MonoWhen extends Mono<Void> implements SourceProducer<Void> {
	final boolean delayError;
	final Publisher<?>[] sources;
	final Iterable<? extends Publisher<?>> sourcesIterable;
	MonoWhen(boolean delayError, Publisher<?>... sources) {
		this.delayError = delayError;
		this.sources = Objects.requireNonNull(sources, ""sources"");
		this.sourcesIterable = null;
	}
	MonoWhen(boolean delayError, Iterable<? extends Publisher<?>> sourcesIterable) {
		this.delayError = delayError;
		this.sources = null;
		this.sourcesIterable = Objects.requireNonNull(sourcesIterable, ""sourcesIterable"");
	}
	Mono<Void> whenAdditionalSource(Publisher<?> source) {
		Publisher[] oldSources = sources;
		if (oldSources != null) {
			int oldLen = oldSources.length;
			Publisher<?>[] newSources = new Publisher[oldLen + 1];
			System.arraycopy(oldSources, 0, newSources, 0, oldLen);
			newSources[oldLen] = source;
			return new MonoWhen(delayError, newSources);
		}
		return null;
	}
	public void subscribe(CoreSubscriber<? super Void> actual) {
		Publisher<?>[] a;
		int n = 0;
		if (sources != null) {
			a = sources;
			n = a.length;
		}
		else {
			a = new Publisher[8];
			for (Publisher<?> m : sourcesIterable) {
				if (n == a.length) {
					Publisher<?>[] b = new Publisher[n + (n >> 2)];
					System.arraycopy(a, 0, b, 0, n);
					a = b;
				}
				a[n++] = m;
			}
		}
		if (n == 0) {
			Operators.complete(actual);
			return;
		}
		WhenCoordinator parent = new WhenCoordinator(actual, n, delayError);
		actual.onSubscribe(parent);
		parent.subscribe(a);
	}
	public Object scanUnsafe(Attr key) {
		if (key == Attr.DELAY_ERROR) return delayError;
		return null;
	}
	static final class WhenCoordinator extends Operators.MonoSubscriber<Object, Void> {
		final WhenInner[] subscribers;
		final boolean delayError;
		volatile int done;
		static final AtomicIntegerFieldUpdater<WhenCoordinator> DONE =AtomicIntegerFieldUpdater.newUpdater(WhenCoordinator.class, ""done"");
		WhenCoordinator(CoreSubscriber<? super Void> subscriber,int n,boolean delayError) {
			super(subscriber);
			this.delayError = delayError;
			subscribers = new WhenInner[n];
			for (int i = 0;
			 i < n;
			 i++) {
				subscribers[i] = new WhenInner(this);
			}
		}
		public Object scanUnsafe(Attr key) {
			if (key == Attr.TERMINATED) {
				return done == subscribers.length;
			}
			if (key == Attr.BUFFERED) {
				return subscribers.length;
			}
			if (key == Attr.DELAY_ERROR) {
				return delayError;
			}
			return super.scanUnsafe(key);
		}
		public Stream<? extends Scannable> inners() {
			return Stream.of(subscribers);
		}
		void subscribe(Publisher<?>[] sources) {
			WhenInner[] a = subscribers;
			for (int i = 0;
			 i < a.length;
			 i++) {
				sources[i].subscribe(a[i]);
			}
		}
		void signalError(Throwable t) {
			if (delayError) {
				signal();
			}
			else {
				int n = subscribers.length;
				if (DONE.getAndSet(this, n) != n) {
					cancel();
					actual.onError(t);
				}
			}
		}
		void signal() {
			WhenInner[] a = subscribers;
			int n = a.length;
			if (DONE.incrementAndGet(this) != n) {
				return;
			}
			Throwable error = null;
			Throwable compositeError = null;
			for (int i = 0;
			 i < a.length;
			 i++) {
				WhenInner m = a[i];
				Throwable e = m.error;
				if (e != null) {
					if (compositeError != null) {
						compositeError.addSuppressed(e);
					}
					else if (error != null) {
						compositeError = Exceptions.multiple(error, e);
					}
					else {
						error = e;
					}
				}
			}
			if (compositeError != null) {
				actual.onError(compositeError);
			}
			else if (error != null) {
				actual.onError(error);
			}
			else {
				actual.onComplete();
			}
		}
		public void cancel() {
			if (!isCancelled()) {
				super.cancel();
				for (WhenInner ms : subscribers) {
					ms.cancel();
				}
			}
		}
	}
	static final class WhenInner implements InnerConsumer<Object> {
		final WhenCoordinator parent;
		volatile Subscription s;
		static final AtomicReferenceFieldUpdater<WhenInner, Subscription> S =AtomicReferenceFieldUpdater.newUpdater(WhenInner.class,Subscription.class,""s"");
		Throwable error;
		WhenInner(WhenCoordinator parent) {
			this.parent = parent;
		}
		public Object scanUnsafe(Attr key) {
			if (key == Attr.CANCELLED) {
				return s == Operators.cancelledSubscription();
			}
			if (key == Attr.PARENT) {
				return s;
			}
			if (key == Attr.ACTUAL) {
				return parent;
			}
			if (key == Attr.ERROR) {
				return error;
			}
			return null;
		}
		public Context currentContext() {
			return parent.currentContext();
		}
		public void onSubscribe(Subscription s) {
			if (Operators.setOnce(S, this, s)) {
				s.request(Long.MAX_VALUE);
			}
			else {
				s.cancel();
			}
		}
		public void onNext(Object t) {
		}
		public void onError(Throwable t) {
			error = t;
			parent.signalError(t);
		}
		public void onComplete() {
			parent.signal();
		}
		void cancel() {
			Operators.terminate(S, this);
		}
	}
}",1,0,0,0
"public abstract class ArchiveResource extends Resource {
	 private static final int NULL_ARCHIVE = Resource.getMagicNumber(""null archive"".getBytes());
	 private Resource archive;
	 private boolean haveEntry = false;
	 private boolean modeSet = false;
	 private int mode = 0;
	 public ArchiveResource() {
	 }
	 public ArchiveResource(File a) {
		 this(a, false);
	 }
	 public ArchiveResource(File a, boolean withEntry) {
		 setArchive(a);
		 haveEntry = withEntry;
	 }
	 public ArchiveResource(Resource a, boolean withEntry) {
		 addConfigured(a);
		 haveEntry = withEntry;
	 }
	 public void setArchive(File a) {
		 checkAttributesAllowed();
		 archive = new FileResource(a);
	 }
	 public void setMode(int mode) {
		 checkAttributesAllowed();
		 this.mode = mode;
		 modeSet = true;
	 }
	 public void addConfigured(ResourceCollection a) {
		 checkChildrenAllowed();
		 if (archive != null) {
			 throw new BuildException(""you must not specify more than one"" + "" archive"");
		 }
		 if (a.size() != 1) {
			 throw new BuildException(""only single argument resource collections"" + "" are supported as archives"");
		 }
		 archive = (Resource) a.iterator().next();
	 }
	 public Resource getArchive() {
		 return isReference() ? ((ArchiveResource) getCheckedRef()).getArchive() : archive;
	 }
	 public long getLastModified() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getLastModified();
		 }
		 checkEntry();
		 return super.getLastModified();
	 }
	 public long getSize() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getSize();
		 }
		 checkEntry();
		 return super.getSize();
	 }
	 public boolean isDirectory() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).isDirectory();
		 }
		 checkEntry();
		 return super.isDirectory();
	 }
	 public boolean isExists() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).isExists();
		 }
		 checkEntry();
		 return super.isExists();
	 }
	 public int getMode() {
		 if (isReference()) {
			 return ((ArchiveResource) getCheckedRef()).getMode();
		 }
		 checkEntry();
		 return mode;
	 }
	 public void setRefid(Reference r) {
		 if (archive != null || modeSet) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 public int compareTo(Object another) {
		 return this.equals(another) ? 0 : super.compareTo(another);
	 }
	 public boolean equals(Object another) {
		 if (this == another) {
			 return true;
		 }
		 if (isReference()) {
			 return getCheckedRef().equals(another);
		 }
		 if (!(another.getClass().equals(getClass()))) {
			 return false;
		 }
		 ArchiveResource r = (ArchiveResource) another;
		 return getArchive().equals(r.getArchive()) && getName().equals(r.getName());
	 }
	 public int hashCode() {
	 return super.hashCode() }
	 public String toString() {
		 return isReference() ? getCheckedRef().toString() : getArchive().toString() + ':' + getName();
	 }
	 private synchronized void checkEntry() throws BuildException {
		 if (haveEntry) {
			 return;
		 }
		 String name = getName();
		 if (name == null) {
			 throw new BuildException(""entry name not set"");
		 }
		 Resource r = getArchive();
		 if (r == null) {
			 throw new BuildException(""archive attribute not set"");
		 }
		 if (!r.isExists()) {
			 throw new BuildException(r.toString() + "" does not exist."");
		 }
		 if (r.isDirectory()) {
			 throw new BuildException(r + "" denotes a directory."");
		 }
		 fetchEntry();
		 haveEntry = true;
	 }
	 protected abstract void fetchEntry();
}",0,0,0,0
"private void setupRandPartC() throws IOException {
	 if (this.su_j2 < this.su_z) {
		 this.currentChar = this.su_ch2;
		 this.crc.updateCRC(this.su_ch2);
		 this.su_j2++;
	 }
	 else {
		 this.currentState = RAND_PART_A_STATE;
		 this.su_i2++;
		 this.su_count = 0;
		 setupRandPartA();
	 }
 }",0,0,0,0
"private static class Frame {
	private final BufferedImage image;
	private final int delayTime;
	Frame(BufferedImage image, int delayTime) {
		this.image = image;
		this.delayTime = delayTime;
	}
	public BufferedImage getImage() {
		return this.image;
	}
	public int getDelayTime() {
		return this.delayTime;
	}
}",0,0,0,0
"static class Cause {
	 final Tuple<Node> tuple ;
	 final Mapping mapping ;
	 public Cause(Tuple<Node> tuple, Mapping mapping) {
		 super() ;
		 this.tuple = tuple ;
		 this.mapping = mapping ;
	 }
 }",0,1,0,0
"public class ObjectStringMessageConverter extends StringMessageConverter {
	protected Object convertFromInternal(Message<?> message, Class<?> targetClass, Object conversionHint) {
		Object payload = message.getPayload();
		if (payload instanceof String || payload instanceof byte[]) {
			return super.convertFromInternal(message, targetClass, conversionHint);
		}
		else {
			return payload.toString();
		}
	}
}",0,0,0,0
"public String getServerName() {
	 return serverInfo.getServerName();
 }",0,0,0,0
"public class ColumnIndexer{
	 public static void serialize(IIterableColumns columns, DataOutput dos) {
		 try {
			 writeIndex(serialize(columns), dos);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public static void serialize(RowHeader indexInfo, DataOutput dos) {
		 try {
			 writeIndex(indexInfo, dos);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public static RowHeader serialize(IIterableColumns columns) {
		 int columnCount = columns.getEstimatedColumnCount();
		 BloomFilter bf = BloomFilter.getFilter(columnCount, 4);
		 if (columnCount == 0) return new RowHeader(bf, Collections.<IndexHelper.IndexInfo>emptyList());
		 List<IndexHelper.IndexInfo> indexList = new ArrayList<IndexHelper.IndexInfo>();
		 long endPosition = 0, startPosition = -1;
		 IColumn lastColumn = null, firstColumn = null;
		 for (IColumn column : columns) {
			 bf.add(column.name());
			 if (firstColumn == null) {
				 firstColumn = column;
				 startPosition = endPosition;
			 }
			 endPosition += column.serializedSize();
			 if (endPosition - startPosition >= DatabaseDescriptor.getColumnIndexSize()) {
				 IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), startPosition, endPosition - startPosition);
				 indexList.add(cIndexInfo);
				 firstColumn = null;
			 }
			 lastColumn = column;
		 }
		 if (lastColumn == null) return new RowHeader(bf, Collections.<IndexHelper.IndexInfo>emptyList());
		 if (indexList.isEmpty() || columns.getComparator().compare(indexList.get(indexList.size() - 1).lastName, lastColumn.name()) != 0) {
			 IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), startPosition, endPosition - startPosition);
			 indexList.add(cIndexInfo);
		 }
		 assert indexList.size() > 0;
		 return new RowHeader(bf, indexList);
	 }
	 private static void writeIndex(RowHeader indexInfo, DataOutput dos) throws IOException {
		 assert indexInfo != null;
		 writeBloomFilter(dos, indexInfo.bloomFilter);
		 dos.writeInt(indexInfo.entriesSize);
		 if (indexInfo.indexEntries.size() > 1) {
			 for (IndexHelper.IndexInfo cIndexInfo : indexInfo.indexEntries) cIndexInfo.serialize(dos);
		 }
	 }
	 private static void writeBloomFilter(DataOutput dos, BloomFilter bf) throws IOException {
		 DataOutputBuffer bufOut = new DataOutputBuffer();
		 BloomFilter.serializer().serialize(bf, bufOut);
		 dos.writeInt(bufOut.getLength());
		 dos.write(bufOut.getData(), 0, bufOut.getLength());
		 bufOut.flush();
	 }
	 public static class RowHeader {
		 public final BloomFilter bloomFilter;
		 public final List<IndexHelper.IndexInfo> indexEntries;
		 public final int entriesSize;
		 public RowHeader(BloomFilter bf, List<IndexHelper.IndexInfo> indexes) {
			 assert bf != null;
			 assert indexes != null;
			 bloomFilter = bf;
			 indexEntries = indexes;
			 int entriesSize = 0;
			 if (indexEntries.size() > 1) {
				 for (IndexHelper.IndexInfo info : indexEntries) entriesSize += info.serializedSize();
			 }
			 this.entriesSize = entriesSize;
		 }
		 public long serializedSize() {
			 return DBConstants.intSize + bloomFilter.serializedSize() + DBConstants.intSize + entriesSize;
		 }
	 }
}",0,0,0,0
"public class RestConfiguration {
	 public static final String CORS_ACCESS_CONTROL_ALLOW_ORIGIN = ""*"";
	 public static final String CORS_ACCESS_CONTROL_ALLOW_METHODS = ""GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH"";
	 public static final String CORS_ACCESS_CONTROL_MAX_AGE = ""3600"";
	 public static final String CORS_ACCESS_CONTROL_ALLOW_HEADERS = ""Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers"";
	 public enum RestBindingMode {
	 auto, off, json, xml, json_xml }
	 public enum RestHostNameResolver {
	 allLocalIp, localIp, localHostName }
	 private String component;
	 private String apiComponent;
	 private String producerComponent;
	 private String producerApiDoc;
	 private String scheme;
	 private String host;
	 private boolean useXForwardHeaders = true;
	 private String apiHost;
	 private int port;
	 private String contextPath;
	 private String apiContextPath;
	 private String apiContextRouteId;
	 private String apiContextIdPattern;
	 private boolean apiContextListing;
	 private boolean apiVendorExtension;
	 private RestHostNameResolver hostNameResolver = RestHostNameResolver.allLocalIp;
	 private RestBindingMode bindingMode = RestBindingMode.off;
	 private boolean skipBindingOnErrorCode = true;
	 private boolean clientRequestValidation;
	 private boolean enableCORS;
	 private String jsonDataFormat;
	 private String xmlDataFormat;
	 private Map<String, Object> componentProperties;
	 private Map<String, Object> endpointProperties;
	 private Map<String, Object> consumerProperties;
	 private Map<String, Object> dataFormatProperties;
	 private Map<String, Object> apiProperties;
	 private Map<String, String> corsHeaders;
	 public String getComponent() {
		 return component;
	 }
	 public void setComponent(String componentName) {
		 this.component = componentName;
	 }
	 public String getApiComponent() {
		 return apiComponent;
	 }
	 public void setApiComponent(String apiComponent) {
		 this.apiComponent = apiComponent;
	 }
	 public String getProducerComponent() {
		 return producerComponent;
	 }
	 public void setProducerComponent(String componentName) {
		 this.producerComponent = componentName;
	 }
	 public String getProducerApiDoc() {
		 return producerApiDoc;
	 }
	 public void setProducerApiDoc(String producerApiDoc) {
		 this.producerApiDoc = producerApiDoc;
	 }
	 public String getHost() {
		 return host;
	 }
	 public void setHost(String host) {
		 this.host = host;
	 }
	 public boolean isUseXForwardHeaders() {
		 return useXForwardHeaders;
	 }
	 public void setUseXForwardHeaders(boolean useXForwardHeaders) {
		 this.useXForwardHeaders = useXForwardHeaders;
	 }
	 public String getApiHost() {
		 return apiHost;
	 }
	 public void setApiHost(String apiHost) {
		 this.apiHost = apiHost;
	 }
	 public String getScheme() {
		 return scheme;
	 }
	 public void setScheme(String scheme) {
		 this.scheme = scheme;
	 }
	 public int getPort() {
		 return port;
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public String getContextPath() {
		 return contextPath;
	 }
	 public void setContextPath(String contextPath) {
		 this.contextPath = contextPath;
	 }
	 public String getApiContextPath() {
		 return apiContextPath;
	 }
	 public void setApiContextPath(String contextPath) {
		 this.apiContextPath = contextPath;
	 }
	 public String getApiContextRouteId() {
		 return apiContextRouteId;
	 }
	 public void setApiContextRouteId(String apiContextRouteId) {
		 this.apiContextRouteId = apiContextRouteId;
	 }
	 public String getApiContextIdPattern() {
		 return apiContextIdPattern;
	 }
	 public void setApiContextIdPattern(String apiContextIdPattern) {
		 this.apiContextIdPattern = apiContextIdPattern;
	 }
	 public boolean isApiContextListing() {
		 return apiContextListing;
	 }
	 public void setApiContextListing(boolean apiContextListing) {
		 this.apiContextListing = apiContextListing;
	 }
	 public boolean isApiVendorExtension() {
		 return apiVendorExtension;
	 }
	 public void setApiVendorExtension(boolean apiVendorExtension) {
		 this.apiVendorExtension = apiVendorExtension;
	 }
	 public RestHostNameResolver getHostNameResolver() {
		 return hostNameResolver;
	 }
	 public void setHostNameResolver(RestHostNameResolver hostNameResolver) {
		 this.hostNameResolver = hostNameResolver;
	 }
	 public void setHostNameResolver(String hostNameResolver) {
		 this.hostNameResolver = RestHostNameResolver.valueOf(hostNameResolver);
	 }
	 public RestBindingMode getBindingMode() {
		 return bindingMode;
	 }
	 public void setBindingMode(RestBindingMode bindingMode) {
		 this.bindingMode = bindingMode;
	 }
	 public void setBindingMode(String bindingMode) {
		 this.bindingMode = RestBindingMode.valueOf(bindingMode);
	 }
	 public boolean isSkipBindingOnErrorCode() {
		 return skipBindingOnErrorCode;
	 }
	 public void setSkipBindingOnErrorCode(boolean skipBindingOnErrorCode) {
		 this.skipBindingOnErrorCode = skipBindingOnErrorCode;
	 }
	 public boolean isClientRequestValidation() {
		 return clientRequestValidation;
	 }
	 public void setClientRequestValidation(boolean clientRequestValidation) {
		 this.clientRequestValidation = clientRequestValidation;
	 }
	 public boolean isEnableCORS() {
		 return enableCORS;
	 }
	 public void setEnableCORS(boolean enableCORS) {
		 this.enableCORS = enableCORS;
	 }
	 public String getJsonDataFormat() {
		 return jsonDataFormat;
	 }
	 public void setJsonDataFormat(String name) {
		 this.jsonDataFormat = name;
	 }
	 public String getXmlDataFormat() {
		 return xmlDataFormat;
	 }
	 public void setXmlDataFormat(String name) {
		 this.xmlDataFormat = name;
	 }
	 public Map<String, Object> getComponentProperties() {
		 return componentProperties;
	 }
	 public void setComponentProperties(Map<String, Object> componentProperties) {
		 this.componentProperties = componentProperties;
	 }
	 public Map<String, Object> getEndpointProperties() {
		 return endpointProperties;
	 }
	 public void setEndpointProperties(Map<String, Object> endpointProperties) {
		 this.endpointProperties = endpointProperties;
	 }
	 public Map<String, Object> getConsumerProperties() {
		 return consumerProperties;
	 }
	 public void setConsumerProperties(Map<String, Object> consumerProperties) {
		 this.consumerProperties = consumerProperties;
	 }
	 public Map<String, Object> getDataFormatProperties() {
		 return dataFormatProperties;
	 }
	 public void setDataFormatProperties(Map<String, Object> dataFormatProperties) {
		 this.dataFormatProperties = dataFormatProperties;
	 }
	 public Map<String, Object> getApiProperties() {
		 return apiProperties;
	 }
	 public void setApiProperties(Map<String, Object> apiProperties) {
		 this.apiProperties = apiProperties;
	 }
	 public Map<String, String> getCorsHeaders() {
		 return corsHeaders;
	 }
	 public void setCorsHeaders(Map<String, String> corsHeaders) {
		 this.corsHeaders = corsHeaders;
	 }
}",1,1,0,0
"public class ParserTokenManager implements ParserConstants{
	 public java.io.PrintStream debugStream = System.out;
	 public void setDebugStream(java.io.PrintStream ds) {
		 debugStream = ds;
	 }
	private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2){
		 switch (pos) {
			 case 0: if ((active1 & 0x200020000000000L) != 0L) return 56;
			 if ((active0 & 0x3eL) != 0L) return 0;
			 if ((active1 & 0x10000L) != 0L) return 11;
			 if ((active0 & 0xffffffffffffc00L) != 0L) {
				 jjmatchedKind = 69;
				 return 35;
			 }
			 return -1;
			 case 1: if ((active0 & 0x100600000L) != 0L) return 35;
			 if ((active0 & 0xffffffeff9ffc00L) != 0L) {
				 if (jjmatchedPos != 1) {
					 jjmatchedKind = 69;
					 jjmatchedPos = 1;
				 }
				 return 35;
			 }
			 return -1;
			 case 2: if ((active0 & 0xefffecebfdffc00L) != 0L) {
				 if (jjmatchedPos != 2) {
					 jjmatchedKind = 69;
					 jjmatchedPos = 2;
				 }
				 return 35;
			 }
			 if ((active0 & 0x100013040000000L) != 0L) return 35;
			 return -1;
			 case 3: if ((active0 & 0xc7ffcae3e5d3c00L) != 0L) {
				 if (jjmatchedPos != 3) {
					 jjmatchedKind = 69;
					 jjmatchedPos = 3;
				 }
				 return 35;
			 }
			 if ((active0 & 0x28002408182c000L) != 0L) return 35;
			 return -1;
			 case 4: if ((active0 & 0x86080003c053000L) != 0L) return 35;
			 if ((active0 & 0x41f7cae02580c00L) != 0L) {
				 if (jjmatchedPos != 4) {
					 jjmatchedKind = 69;
					 jjmatchedPos = 4;
				 }
				 return 35;
			 }
			 return -1;
			 case 5: if ((active0 & 0x41a1c2a12180c00L) != 0L) {
				 jjmatchedKind = 69;
				 jjmatchedPos = 5;
				 return 35;
			 }
			 if ((active0 & 0x45608400400000L) != 0L) return 35;
			 return -1;
			 case 6: if ((active0 & 0x41a102a00080400L) != 0L) {
				 jjmatchedKind = 69;
				 jjmatchedPos = 6;
				 return 35;
			 }
			 if ((active0 & 0xc0012100800L) != 0L) return 35;
			 return -1;
			 case 7: if ((active0 & 0x402000000080400L) != 0L) return 35;
			 if ((active0 & 0x18102a00000000L) != 0L) {
				 jjmatchedKind = 69;
				 jjmatchedPos = 7;
				 return 35;
			 }
			 return -1;
			 case 8: if ((active0 & 0x8000a00000000L) != 0L) {
				 jjmatchedKind = 69;
				 jjmatchedPos = 8;
				 return 35;
			 }
			 if ((active0 & 0x10102000000000L) != 0L) return 35;
			 return -1;
			 case 9: if ((active0 & 0x8000000000000L) != 0L) {
				 jjmatchedKind = 69;
				 jjmatchedPos = 9;
				 return 35;
			 }
			 if ((active0 & 0xa00000000L) != 0L) return 35;
			 return -1;
			 case 10: if ((active0 & 0x8000000000000L) != 0L) {
				 if (jjmatchedPos != 10) {
					 jjmatchedKind = 69;
					 jjmatchedPos = 10;
				 }
				 return 35;
			 }
			 return -1;
			 case 11: if ((active0 & 0x8000000000000L) != 0L) return 35;
			 return -1;
			 default : return -1;
		 }
	}
	private final int jjStartNfa_0(int pos, long active0, long active1, long active2){
		 return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
	}
	private final int jjStopAtPos(int pos, int kind){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 return pos + 1;
	}
	private final int jjStartNfaWithStates_0(int pos, int kind, int state){
		 jjmatchedKind = kind;
		 jjmatchedPos = pos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return pos + 1;
		 }
		 return jjMoveNfa_0(state, pos + 1);
	}
	private final int jjMoveStringLiteralDfa0_0(){
		 switch(curChar) {
			 case 9: return jjStartNfaWithStates_0(0, 2, 0);
			 case 10: return jjStartNfaWithStates_0(0, 5, 0);
			 case 12: return jjStartNfaWithStates_0(0, 4, 0);
			 case 13: return jjStartNfaWithStates_0(0, 3, 0);
			 case 32: return jjStartNfaWithStates_0(0, 1, 0);
			 case 33: jjmatchedKind = 86;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x80000000L, 0x0L);
			 case 37: jjmatchedKind = 111;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000000L, 0x0L);
			 case 38: jjmatchedKind = 106;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x400000400000000L, 0x0L);
			 case 40: return jjStopAtPos(0, 72);
			 case 41: return jjStopAtPos(0, 73);
			 case 42: jjmatchedKind = 104;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L, 0x0L);
			 case 43: jjmatchedKind = 102;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x40001000000000L, 0x0L);
			 case 44: return jjStopAtPos(0, 79);
			 case 45: jjmatchedKind = 103;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x80002000000000L, 0x0L);
			 case 46: return jjStartNfaWithStates_0(0, 80, 11);
			 case 47: jjmatchedKind = 105;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000000L, 0x0L);
			 case 58: return jjStopAtPos(0, 89);
			 case 59: return jjStopAtPos(0, 78);
			 case 60: jjmatchedKind = 84;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x1000008000000L, 0x1L);
			 case 61: jjmatchedKind = 81;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000L, 0x0L);
			 case 62: jjmatchedKind = 82;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x14000020000000L, 0x14L);
			 case 63: return jjStopAtPos(0, 88);
			 case 64: return jjMoveStringLiteralDfa1_0(0x0L, 0x282a280a50280000L, 0x2aL);
			 case 91: return jjStopAtPos(0, 76);
			 case 93: return jjStopAtPos(0, 77);
			 case 94: jjmatchedKind = 110;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000000000L, 0x0L);
			 case 97: return jjMoveStringLiteralDfa1_0(0x400L, 0x0L, 0x0L);
			 case 98: return jjMoveStringLiteralDfa1_0(0x5800L, 0x0L, 0x0L);
			 case 99: return jjMoveStringLiteralDfa1_0(0xfa000L, 0x0L, 0x0L);
			 case 100: return jjMoveStringLiteralDfa1_0(0x700000L, 0x0L, 0x0L);
			 case 101: return jjMoveStringLiteralDfa1_0(0x3800000L, 0x0L, 0x0L);
			 case 102: return jjMoveStringLiteralDfa1_0(0x7c000000L, 0x0L, 0x0L);
			 case 103: return jjMoveStringLiteralDfa1_0(0x80000000L, 0x0L, 0x0L);
			 case 105: return jjMoveStringLiteralDfa1_0(0x3f00000000L, 0x0L, 0x0L);
			 case 108: return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
			 case 110: return jjMoveStringLiteralDfa1_0(0x38000000000L, 0x0L, 0x0L);
			 case 112: return jjMoveStringLiteralDfa1_0(0x3c0000000000L, 0x0L, 0x0L);
			 case 114: return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L, 0x0L);
			 case 115: return jjMoveStringLiteralDfa1_0(0xf800000000000L, 0x0L, 0x0L);
			 case 116: return jjMoveStringLiteralDfa1_0(0x1f0000000000000L, 0x0L, 0x0L);
			 case 118: return jjMoveStringLiteralDfa1_0(0x600000000000000L, 0x0L, 0x0L);
			 case 119: return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L, 0x0L);
			 case 123: return jjStopAtPos(0, 74);
			 case 124: jjmatchedKind = 108;
			 return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000100000000L, 0x0L);
			 case 125: return jjStopAtPos(0, 75);
			 case 126: return jjStopAtPos(0, 87);
			 default : return jjMoveNfa_0(6, 0);
		 }
	}
	private final int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2){
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(0, active0, active1, active2);
			 return 1;
		 }
		 switch(curChar) {
			 case 38: if ((active1 & 0x400000000L) != 0L) return jjStopAtPos(1, 98);
			 break;
			 case 43: if ((active1 & 0x1000000000L) != 0L) return jjStopAtPos(1, 100);
			 break;
			 case 45: if ((active1 & 0x2000000000L) != 0L) return jjStopAtPos(1, 101);
			 break;
			 case 60: if ((active1 & 0x1000000000000L) != 0L) {
				 jjmatchedKind = 112;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x1L);
			 case 61: if ((active1 & 0x4000000L) != 0L) return jjStopAtPos(1, 90);
			 else if ((active1 & 0x8000000L) != 0L) return jjStopAtPos(1, 91);
			 else if ((active1 & 0x20000000L) != 0L) return jjStopAtPos(1, 93);
			 else if ((active1 & 0x80000000L) != 0L) return jjStopAtPos(1, 95);
			 else if ((active1 & 0x40000000000000L) != 0L) return jjStopAtPos(1, 118);
			 else if ((active1 & 0x80000000000000L) != 0L) return jjStopAtPos(1, 119);
			 else if ((active1 & 0x100000000000000L) != 0L) return jjStopAtPos(1, 120);
			 else if ((active1 & 0x200000000000000L) != 0L) return jjStopAtPos(1, 121);
			 else if ((active1 & 0x400000000000000L) != 0L) return jjStopAtPos(1, 122);
			 else if ((active1 & 0x1000000000000000L) != 0L) return jjStopAtPos(1, 124);
			 else if ((active1 & 0x4000000000000000L) != 0L) return jjStopAtPos(1, 126);
			 else if ((active1 & 0x8000000000000000L) != 0L) return jjStopAtPos(1, 127);
			 break;
			 case 62: if ((active1 & 0x4000000000000L) != 0L) {
				 jjmatchedKind = 114;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000000000000L, active2, 0x14L);
			 case 97: return jjMoveStringLiteralDfa2_0(active0, 0x48004018000L, active1, 0x800000800000000L, active2, 0L);
			 case 98: return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0x280000000000L, active2, 0L);
			 case 101: return jjMoveStringLiteralDfa2_0(active0, 0x410000100000L, active1, 0L, active2, 0L);
			 case 102: if ((active0 & 0x100000000L) != 0L) return jjStartNfaWithStates_0(1, 32, 35);
			 break;
			 case 103: return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x40080000L, active2, 0L);
			 case 104: return jjMoveStringLiteralDfa2_0(active0, 0x860800000020000L, active1, 0L, active2, 0L);
			 case 105: return jjMoveStringLiteralDfa2_0(active0, 0x18000000L, active1, 0L, active2, 0L);
			 case 108: return jjMoveStringLiteralDfa2_0(active0, 0x20802000L, active1, 0x2000010200000L, active2, 0x2L);
			 case 109: return jjMoveStringLiteralDfa2_0(active0, 0x600000000L, active1, 0L, active2, 0L);
			 case 110: return jjMoveStringLiteralDfa2_0(active0, 0x3801000000L, active1, 0L, active2, 0L);
			 case 111: if ((active0 & 0x200000L) != 0L) {
				 jjmatchedKind = 21;
				 jjmatchedPos = 1;
			 }
			 return jjMoveStringLiteralDfa2_0(active0, 0x6000040c04c0800L, active1, 0x2000000200000000L, active2, 0L);
			 case 114: return jjMoveStringLiteralDfa2_0(active0, 0x190180000001000L, active1, 0x28000000000000L, active2, 0x28L);
			 case 116: return jjMoveStringLiteralDfa2_0(active0, 0x3000000000000L, active1, 0L, active2, 0L);
			 case 117: return jjMoveStringLiteralDfa2_0(active0, 0x220000000000L, active1, 0L, active2, 0L);
			 case 119: return jjMoveStringLiteralDfa2_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
			 case 120: return jjMoveStringLiteralDfa2_0(active0, 0x2000000L, active1, 0L, active2, 0L);
			 case 121: return jjMoveStringLiteralDfa2_0(active0, 0x8000000004000L, active1, 0L, active2, 0L);
			 case 124: if ((active1 & 0x100000000L) != 0L) return jjStopAtPos(1, 96);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(0, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(0, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(1, active0, active1, active2);
			 return 2;
		 }
		 switch(curChar) {
			 case 61: if ((active2 & 0x1L) != 0L) return jjStopAtPos(2, 128);
			 else if ((active2 & 0x4L) != 0L) return jjStopAtPos(2, 130);
			 break;
			 case 62: if ((active1 & 0x10000000000000L) != 0L) {
				 jjmatchedKind = 116;
				 jjmatchedPos = 2;
			 }
			 return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x10L);
			 case 97: return jjMoveStringLiteralDfa3_0(active0, 0x11000000022000L, active1, 0L, active2, 0L);
			 case 98: return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L, active2, 0L);
			 case 99: return jjMoveStringLiteralDfa3_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
			 case 101: return jjMoveStringLiteralDfa3_0(active0, 0x1000L, active1, 0x2000000000000L, active2, 0x2L);
			 case 102: return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L, active2, 0L);
			 case 105: return jjMoveStringLiteralDfa3_0(active0, 0xa04080000000000L, active1, 0x28280000000000L, active2, 0x28L);
			 case 108: return jjMoveStringLiteralDfa3_0(active0, 0x400020004000000L, active1, 0L, active2, 0L);
			 case 110: return jjMoveStringLiteralDfa3_0(active0, 0x80040180c0000L, active1, 0x800000800000000L, active2, 0L);
			 case 111: return jjMoveStringLiteralDfa3_0(active0, 0x900020000800L, active1, 0L, active2, 0L);
			 case 112: return jjMoveStringLiteralDfa3_0(active0, 0x600000000L, active1, 0L, active2, 0L);
			 case 114: if ((active0 & 0x40000000L) != 0L) return jjStartNfaWithStates_0(2, 30, 35);
			 else if ((active1 & 0x200000000L) != 0L) {
				 jjmatchedKind = 97;
				 jjmatchedPos = 2;
			 }
			 return jjMoveStringLiteralDfa3_0(active0, 0x62000000000000L, active1, 0x2000000000000000L, active2, 0L);
			 case 115: return jjMoveStringLiteralDfa3_0(active0, 0x800808400L, active1, 0L, active2, 0L);
			 case 116: if ((active0 & 0x1000000000L) != 0L) {
				 jjmatchedKind = 36;
				 jjmatchedPos = 2;
			 }
			 else if ((active1 & 0x80000L) != 0L) {
				 jjmatchedKind = 83;
				 jjmatchedPos = 2;
			 }
			 else if ((active1 & 0x200000L) != 0L) {
				 jjmatchedKind = 85;
				 jjmatchedPos = 2;
			 }
			 return jjMoveStringLiteralDfa3_0(active0, 0x40a082014000L, active1, 0x50000000L, active2, 0L);
			 case 117: return jjMoveStringLiteralDfa3_0(active0, 0x80000001400000L, active1, 0L, active2, 0L);
			 case 119: if ((active0 & 0x10000000000L) != 0L) return jjStartNfaWithStates_0(2, 40, 35);
			 break;
			 case 121: if ((active0 & 0x100000000000000L) != 0L) return jjStartNfaWithStates_0(2, 56, 35);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(1, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(1, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(2, active0, active1, active2);
			 return 3;
		 }
		 switch(curChar) {
			 case 61: if ((active2 & 0x10L) != 0L) return jjStopAtPos(3, 132);
			 break;
			 case 95: return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
			 case 97: return jjMoveStringLiteralDfa4_0(active0, 0x400000038101000L, active1, 0L, active2, 0L);
			 case 98: return jjMoveStringLiteralDfa4_0(active0, 0x400000L, active1, 0L, active2, 0L);
			 case 99: return jjMoveStringLiteralDfa4_0(active0, 0x8000000010000L, active1, 0L, active2, 0L);
			 case 100: if ((active0 & 0x200000000000000L) != 0L) return jjStartNfaWithStates_0(3, 57, 35);
			 else if ((active1 & 0x800000000L) != 0L) {
				 jjmatchedKind = 99;
				 jjmatchedPos = 3;
			 }
			 return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
			 case 101: if ((active0 & 0x4000L) != 0L) return jjStartNfaWithStates_0(3, 14, 35);
			 else if ((active0 & 0x8000L) != 0L) return jjStartNfaWithStates_0(3, 15, 35);
			 else if ((active0 & 0x800000L) != 0L) return jjStartNfaWithStates_0(3, 23, 35);
			 else if ((active0 & 0x80000000000000L) != 0L) return jjStartNfaWithStates_0(3, 55, 35);
			 return jjMoveStringLiteralDfa4_0(active0, 0x2002000000L, active1, 0x50000000L, active2, 0L);
			 case 102: return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
			 case 103: if ((active0 & 0x4000000000L) != 0L) return jjStartNfaWithStates_0(3, 38, 35);
			 return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);
			 case 105: return jjMoveStringLiteralDfa4_0(active0, 0x2008000000000L, active1, 0L, active2, 0L);
			 case 107: return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
			 case 108: if ((active0 & 0x20000000000L) != 0L) return jjStartNfaWithStates_0(3, 41, 35);
			 return jjMoveStringLiteralDfa4_0(active0, 0x800200200000800L, active1, 0L, active2, 0L);
			 case 109: if ((active0 & 0x1000000L) != 0L) return jjStartNfaWithStates_0(3, 24, 35);
			 break;
			 case 110: return jjMoveStringLiteralDfa4_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
			 case 111: if ((active0 & 0x80000000L) != 0L) return jjStartNfaWithStates_0(3, 31, 35);
			 return jjMoveStringLiteralDfa4_0(active0, 0x60000400000000L, active1, 0L, active2, 0L);
			 case 114: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(3, 17, 35);
			 return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L, active1, 0L, active2, 0L);
			 case 115: return jjMoveStringLiteralDfa4_0(active0, 0x4042000L, active1, 0L, active2, 0L);
			 case 116: return jjMoveStringLiteralDfa4_0(active0, 0x5100800080400L, active1, 0x280000000000L, active2, 0L);
			 case 117: return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L, active1, 0L, active2, 0L);
			 case 118: return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_0(2, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(2, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(3, active0, active1, active2);
			 return 4;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
			 case 97: return jjMoveStringLiteralDfa5_0(active0, 0xc0800000000L, active1, 0x2000000000000000L, active2, 0L);
			 case 99: return jjMoveStringLiteralDfa5_0(active0, 0x6000000000000L, active1, 0L, active2, 0L);
			 case 101: if ((active0 & 0x4000000L) != 0L) return jjStartNfaWithStates_0(4, 26, 35);
			 else if ((active0 & 0x800000000000000L) != 0L) return jjStartNfaWithStates_0(4, 59, 35);
			 return jjMoveStringLiteralDfa5_0(active0, 0x100200000800L, active1, 0L, active2, 0L);
			 case 104: if ((active0 & 0x10000L) != 0L) return jjStartNfaWithStates_0(4, 16, 35);
			 return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000L, active1, 0x28000000000000L, active2, 0x28L);
			 case 105: return jjMoveStringLiteralDfa5_0(active0, 0x1200000080000L, active1, 0L, active2, 0L);
			 case 107: if ((active0 & 0x1000L) != 0L) return jjStartNfaWithStates_0(4, 12, 35);
			 break;
			 case 108: if ((active0 & 0x8000000L) != 0L) {
				 jjmatchedKind = 27;
				 jjmatchedPos = 4;
			 }
			 return jjMoveStringLiteralDfa5_0(active0, 0x10400000L, active1, 0L, active2, 0L);
			 case 110: return jjMoveStringLiteralDfa5_0(active0, 0x2000000L, active1, 0L, active2, 0L);
			 case 113: if ((active1 & 0x10000000L) != 0L) return jjStopAtPos(4, 92);
			 else if ((active1 & 0x40000000L) != 0L) return jjStopAtPos(4, 94);
			 break;
			 case 114: return jjMoveStringLiteralDfa5_0(active0, 0x402400000400L, active1, 0L, active2, 0L);
			 case 115: if ((active0 & 0x2000L) != 0L) return jjStartNfaWithStates_0(4, 13, 35);
			 return jjMoveStringLiteralDfa5_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
			 case 116: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 35);
			 else if ((active0 & 0x20000000L) != 0L) return jjStartNfaWithStates_0(4, 29, 35);
			 else if ((active0 & 0x800000000000L) != 0L) return jjStartNfaWithStates_0(4, 47, 35);
			 return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0x2000000000000L, active2, 0x2L);
			 case 117: return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0L, active2, 0L);
			 case 118: return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0L, active2, 0L);
			 case 119: if ((active0 & 0x20000000000000L) != 0L) {
				 jjmatchedKind = 53;
				 jjmatchedPos = 4;
			 }
			 return jjMoveStringLiteralDfa5_0(active0, 0x40000000000000L, active1, 0x280000000000L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_0(3, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(3, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(4, active0, active1, active2);
			 return 5;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
			 case 97: return jjMoveStringLiteralDfa6_0(active0, 0xc00L, active1, 0x800000000000000L, active2, 0L);
			 case 99: if ((active0 & 0x200000000000L) != 0L) return jjStartNfaWithStates_0(5, 45, 35);
			 else if ((active0 & 0x1000000000000L) != 0L) return jjStartNfaWithStates_0(5, 48, 35);
			 return jjMoveStringLiteralDfa6_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
			 case 100: return jjMoveStringLiteralDfa6_0(active0, 0x2000000L, active1, 0L, active2, 0L);
			 case 101: if ((active0 & 0x400000L) != 0L) return jjStartNfaWithStates_0(5, 22, 35);
			 else if ((active0 & 0x8000000000L) != 0L) return jjStartNfaWithStates_0(5, 39, 35);
			 break;
			 case 102: return jjMoveStringLiteralDfa6_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
			 case 103: return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
			 case 104: if ((active0 & 0x4000000000000L) != 0L) return jjStartNfaWithStates_0(5, 50, 35);
			 break;
			 case 105: return jjMoveStringLiteralDfa6_0(active0, 0x410000000000000L, active1, 0x280000000000L, active2, 0L);
			 case 108: return jjMoveStringLiteralDfa6_0(active0, 0x10100000L, active1, 0L, active2, 0L);
			 case 109: return jjMoveStringLiteralDfa6_0(active0, 0x200000000L, active1, 0L, active2, 0L);
			 case 110: if ((active0 & 0x400000000000L) != 0L) return jjStartNfaWithStates_0(5, 46, 35);
			 return jjMoveStringLiteralDfa6_0(active0, 0x800080000L, active1, 0L, active2, 0L);
			 case 114: return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
			 case 115: if ((active0 & 0x40000000000000L) != 0L) return jjStartNfaWithStates_0(5, 54, 35);
			 return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
			 case 116: if ((active0 & 0x400000000L) != 0L) return jjStartNfaWithStates_0(5, 34, 35);
			 return jjMoveStringLiteralDfa6_0(active0, 0x2080000000000L, active1, 0x28000000000000L, active2, 0x28L);
			 default : break;
		 }
		 return jjStartNfa_0(4, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(4, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(5, active0, active1, active2);
			 return 6;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);
			 case 97: return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
			 case 99: return jjMoveStringLiteralDfa7_0(active0, 0x800000400L, active1, 0L, active2, 0L);
			 case 101: if ((active0 & 0x40000000000L) != 0L) return jjStartNfaWithStates_0(6, 42, 35);
			 else if ((active0 & 0x80000000000L) != 0L) return jjStartNfaWithStates_0(6, 43, 35);
			 return jjMoveStringLiteralDfa7_0(active0, 0x10000200000000L, active1, 0L, active2, 0L);
			 case 102: return jjMoveStringLiteralDfa7_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
			 case 108: return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L, active2, 0L);
			 case 110: if ((active0 & 0x800L) != 0L) return jjStartNfaWithStates_0(6, 11, 35);
			 break;
			 case 111: return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
			 case 115: if ((active0 & 0x2000000L) != 0L) return jjStartNfaWithStates_0(6, 25, 35);
			 return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x2802280000000000L, active2, 0x2L);
			 case 116: if ((active0 & 0x100000L) != 0L) return jjStartNfaWithStates_0(6, 20, 35);
			 return jjMoveStringLiteralDfa7_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
			 case 117: return jjMoveStringLiteralDfa7_0(active0, 0x80000L, active1, 0L, active2, 0L);
			 case 121: if ((active0 & 0x10000000L) != 0L) return jjStartNfaWithStates_0(6, 28, 35);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(5, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(5, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(6, active0, active1, active2);
			 return 7;
		 }
		 switch(curChar) {
			 case 99: return jjMoveStringLiteralDfa8_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
			 case 101: if ((active0 & 0x80000L) != 0L) return jjStartNfaWithStates_0(7, 19, 35);
			 else if ((active0 & 0x400000000000000L) != 0L) return jjStartNfaWithStates_0(7, 58, 35);
			 return jjMoveStringLiteralDfa8_0(active0, 0x100800000000L, active1, 0x280000000000L, active2, 0L);
			 case 104: return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
			 case 105: return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
			 case 110: return jjMoveStringLiteralDfa8_0(active0, 0x18000200000000L, active1, 0L, active2, 0L);
			 case 112: if ((active0 & 0x2000000000000L) != 0L) return jjStartNfaWithStates_0(7, 49, 35);
			 break;
			 case 115: return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x808000000000000L, active2, 0x8L);
			 case 116: if ((active0 & 0x400L) != 0L) return jjStartNfaWithStates_0(7, 10, 35);
			 break;
			 case 117: return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(6, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(6, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(7, active0, active1, active2);
			 return 8;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x280000000000L, active2, 0L);
			 case 100: if ((active0 & 0x100000000000L) != 0L) return jjStartNfaWithStates_0(8, 44, 35);
			 break;
			 case 101: if ((active0 & 0x2000000000L) != 0L) return jjStartNfaWithStates_0(8, 37, 35);
			 break;
			 case 103: return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
			 case 104: return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
			 case 105: return jjMoveStringLiteralDfa9_0(active0, 0x8000000000000L, active1, 0x802000000000000L, active2, 0x2L);
			 case 110: return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
			 case 111: return jjMoveStringLiteralDfa9_0(active0, 0x800000000L, active1, 0L, active2, 0L);
			 case 116: if ((active0 & 0x10000000000000L) != 0L) return jjStartNfaWithStates_0(8, 52, 35);
			 return jjMoveStringLiteralDfa9_0(active0, 0x200000000L, active1, 0L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_0(7, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(7, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(8, active0, active1, active2);
			 return 9;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x80000000000L, active2, 0L);
			 case 102: if ((active0 & 0x800000000L) != 0L) return jjStartNfaWithStates_0(9, 35, 35);
			 return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
			 case 103: return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
			 case 105: return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
			 case 110: if ((active1 & 0x2000000000000000L) != 0L) return jjStopAtPos(9, 125);
			 break;
			 case 111: return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x200000000000L, active2, 0L);
			 case 115: if ((active0 & 0x200000000L) != 0L) return jjStartNfaWithStates_0(9, 33, 35);
			 return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
			 case 122: return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
			 default : break;
		 }
		 return jjStartNfa_0(8, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(8, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(9, active0, active1, active2);
			 return 10;
		 }
		 switch(curChar) {
			 case 101: return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
			 case 102: return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
			 case 105: return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
			 case 110: if ((active1 & 0x800000000000000L) != 0L) return jjStopAtPos(10, 123);
			 return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x80000000000L, active2, 0L);
			 case 114: if ((active1 & 0x200000000000L) != 0L) return jjStopAtPos(10, 109);
			 break;
			 case 116: if ((active1 & 0x2000000000000L) != 0L) {
				 jjmatchedKind = 113;
				 jjmatchedPos = 10;
			 }
			 return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0L, active2, 0x2L);
			 default : break;
		 }
		 return jjStartNfa_0(9, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(9, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(10, active0, active1, active2);
			 return 11;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x2L);
			 case 100: if ((active0 & 0x8000000000000L) != 0L) return jjStartNfaWithStates_0(11, 51, 35);
			 else if ((active1 & 0x80000000000L) != 0L) return jjStopAtPos(11, 107);
			 break;
			 case 103: return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
			 case 116: if ((active1 & 0x8000000000000L) != 0L) {
				 jjmatchedKind = 115;
				 jjmatchedPos = 11;
			 }
			 return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x8L);
			 default : break;
		 }
		 return jjStartNfa_0(10, active0, active1, active2);
	}
	private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1, long old2, long active2){
		 if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(10, old0, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(11, 0L, active1, active2);
			 return 12;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x8L);
			 case 97: return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x2L);
			 case 110: return jjMoveStringLiteralDfa13_0(active1, 0x20000000000000L, active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(11, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa13_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(11, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(12, 0L, active1, active2);
			 return 13;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x8L);
			 case 101: return jjMoveStringLiteralDfa14_0(active1, 0x20000000000000L, active2, 0x20L);
			 case 115: return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x2L);
			 default : break;
		 }
		 return jjStartNfa_0(12, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa14_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(12, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(13, 0L, active1, active2);
			 return 14;
		 }
		 switch(curChar) {
			 case 100: return jjMoveStringLiteralDfa15_0(active1, 0x20000000000000L, active2, 0x20L);
			 case 115: return jjMoveStringLiteralDfa15_0(active1, 0L, active2, 0xaL);
			 default : break;
		 }
		 return jjStartNfa_0(13, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa15_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(13, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(14, 0L, active1, active2);
			 return 15;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa16_0(active1, 0x20000000000000L, active2, 0x20L);
			 case 105: return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x2L);
			 case 115: return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x8L);
			 default : break;
		 }
		 return jjStartNfa_0(14, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa16_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(14, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(15, 0L, active1, active2);
			 return 16;
		 }
		 switch(curChar) {
			 case 103: return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x2L);
			 case 105: return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x8L);
			 case 115: return jjMoveStringLiteralDfa17_0(active1, 0x20000000000000L, active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(15, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa17_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(15, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(16, 0L, active1, active2);
			 return 17;
		 }
		 switch(curChar) {
			 case 103: return jjMoveStringLiteralDfa18_0(active1, 0L, active2, 0x8L);
			 case 104: return jjMoveStringLiteralDfa18_0(active1, 0x20000000000000L, active2, 0x20L);
			 case 110: if ((active2 & 0x2L) != 0L) return jjStopAtPos(17, 129);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(16, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa18_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(16, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(17, 0L, active1, active2);
			 return 18;
		 }
		 switch(curChar) {
			 case 105: return jjMoveStringLiteralDfa19_0(active1, 0x20000000000000L, active2, 0x20L);
			 case 110: if ((active2 & 0x8L) != 0L) return jjStopAtPos(18, 131);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(17, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa19_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(17, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(18, 0L, active1, active2);
			 return 19;
		 }
		 switch(curChar) {
			 case 102: return jjMoveStringLiteralDfa20_0(active1, 0x20000000000000L, active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(18, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa20_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(18, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(19, 0L, active1, active2);
			 return 20;
		 }
		 switch(curChar) {
			 case 116: if ((active1 & 0x20000000000000L) != 0L) {
				 jjmatchedKind = 117;
				 jjmatchedPos = 20;
			 }
			 return jjMoveStringLiteralDfa21_0(active1, 0L, active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(19, 0L, active1, active2);
	}
	private final int jjMoveStringLiteralDfa21_0(long old1, long active1, long old2, long active2){
		 if (((active1 &= old1) | (active2 &= old2)) == 0L) return jjStartNfa_0(19, 0L, old1, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(20, 0L, 0L, active2);
			 return 21;
		 }
		 switch(curChar) {
			 case 95: return jjMoveStringLiteralDfa22_0(active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(20, 0L, 0L, active2);
	}
	private final int jjMoveStringLiteralDfa22_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(20, 0L, 0L, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(21, 0L, 0L, active2);
			 return 22;
		 }
		 switch(curChar) {
			 case 97: return jjMoveStringLiteralDfa23_0(active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(21, 0L, 0L, active2);
	}
	private final int jjMoveStringLiteralDfa23_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(21, 0L, 0L, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(22, 0L, 0L, active2);
			 return 23;
		 }
		 switch(curChar) {
			 case 115: return jjMoveStringLiteralDfa24_0(active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(22, 0L, 0L, active2);
	}
	private final int jjMoveStringLiteralDfa24_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(22, 0L, 0L, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(23, 0L, 0L, active2);
			 return 24;
		 }
		 switch(curChar) {
			 case 115: return jjMoveStringLiteralDfa25_0(active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(23, 0L, 0L, active2);
	}
	private final int jjMoveStringLiteralDfa25_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(23, 0L, 0L, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(24, 0L, 0L, active2);
			 return 25;
		 }
		 switch(curChar) {
			 case 105: return jjMoveStringLiteralDfa26_0(active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(24, 0L, 0L, active2);
	}
	private final int jjMoveStringLiteralDfa26_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(24, 0L, 0L, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(25, 0L, 0L, active2);
			 return 26;
		 }
		 switch(curChar) {
			 case 103: return jjMoveStringLiteralDfa27_0(active2, 0x20L);
			 default : break;
		 }
		 return jjStartNfa_0(25, 0L, 0L, active2);
	}
	private final int jjMoveStringLiteralDfa27_0(long old2, long active2){
		 if (((active2 &= old2)) == 0L) return jjStartNfa_0(25, 0L, 0L, old2);
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 jjStopStringLiteralDfa_0(26, 0L, 0L, active2);
			 return 27;
		 }
		 switch(curChar) {
			 case 110: if ((active2 & 0x20L) != 0L) return jjStopAtPos(27, 133);
			 break;
			 default : break;
		 }
		 return jjStartNfa_0(26, 0L, 0L, active2);
	}
	private final void jjCheckNAdd(int state){
		 if (jjrounds[state] != jjround) {
			 jjstateSet[jjnewStateCnt++] = state;
			 jjrounds[state] = jjround;
		 }
	}
	private final void jjAddStates(int start, int end){
		 do {
			 jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		 }
		 while (start++ != end);
	}
	private final void jjCheckNAddTwoStates(int state1, int state2){
		 jjCheckNAdd(state1);
		 jjCheckNAdd(state2);
	}
	private final void jjCheckNAddStates(int start, int end){
		 do {
			 jjCheckNAdd(jjnextStates[start]);
		 }
		 while (start++ != end);
	}
	private final void jjCheckNAddStates(int start){
		 jjCheckNAdd(jjnextStates[start]);
		 jjCheckNAdd(jjnextStates[start + 1]);
	}
	static final long[] jjbitVec0 = {
	 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL}
	;
	static final long[] jjbitVec1 = {
	 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL}
	;
	static final long[] jjbitVec3 = {
	 0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L}
	;
	static final long[] jjbitVec4 = {
	 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL}
	;
	static final long[] jjbitVec5 = {
	 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL}
	;
	static final long[] jjbitVec6 = {
	 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L}
	;
	static final long[] jjbitVec7 = {
	 0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L}
	;
	static final long[] jjbitVec8 = {
	 0x3fffffffffffL, 0x0L, 0x0L, 0x0L}
	;
	private final int jjMoveNfa_0(int startState, int curPos){
		 int[] nextStates;
		 int startsAt = 0;
		 jjnewStateCnt = 74;
		 int i = 1;
		 jjstateSet[0] = startState;
		 int j, kind = 0x7fffffff;
		 for (;
		;
		) {
			 if (++jjround == 0x7fffffff) ReInitRounds();
			 if (curChar < 64) {
				 long l = 1L << curChar;
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 6: if ((0x1ffffffffL & l) != 0L) {
							 if (kind > 6) kind = 6;
							 jjCheckNAdd(0);
						 }
						 else if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(0, 6);
						 else if (curChar == 47) jjAddStates(7, 9);
						 else if (curChar == 36) {
							 if (kind > 69) kind = 69;
							 jjCheckNAdd(35);
						 }
						 else if (curChar == 34) jjCheckNAddStates(10, 12);
						 else if (curChar == 39) jjAddStates(13, 14);
						 else if (curChar == 46) jjCheckNAdd(11);
						 else if (curChar == 35) jjstateSet[jjnewStateCnt++] = 1;
						 if ((0x3fe000000000000L & l) != 0L) {
							 if (kind > 60) kind = 60;
							 jjCheckNAddTwoStates(8, 9);
						 }
						 else if (curChar == 48) {
							 if (kind > 60) kind = 60;
							 jjCheckNAddStates(15, 17);
						 }
						 break;
						 case 56: if (curChar == 42) jjstateSet[jjnewStateCnt++] = 67;
						 else if (curChar == 47) {
							 if (kind > 7) kind = 7;
							 jjCheckNAddStates(18, 20);
						 }
						 if (curChar == 42) jjCheckNAdd(62);
						 break;
						 case 0: if ((0x1ffffffffL & l) == 0L) break;
						 if (kind > 6) kind = 6;
						 jjCheckNAdd(0);
						 break;
						 case 1: if (curChar == 33) jjCheckNAddStates(21, 23);
						 break;
						 case 2: if ((0xffffffffffffdbffL & l) != 0L) jjCheckNAddStates(21, 23);
						 break;
						 case 3: if ((0x2400L & l) != 0L && kind > 8) kind = 8;
						 break;
						 case 4: if (curChar == 10 && kind > 8) kind = 8;
						 break;
						 case 5: if (curChar == 13) jjstateSet[jjnewStateCnt++] = 4;
						 break;
						 case 7: if ((0x3fe000000000000L & l) == 0L) break;
						 if (kind > 60) kind = 60;
						 jjCheckNAddTwoStates(8, 9);
						 break;
						 case 8: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 60) kind = 60;
						 jjCheckNAddTwoStates(8, 9);
						 break;
						 case 10: if (curChar == 46) jjCheckNAdd(11);
						 break;
						 case 11: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 64) kind = 64;
						 jjCheckNAddStates(24, 26);
						 break;
						 case 13: if ((0x280000000000L & l) != 0L) jjCheckNAdd(14);
						 break;
						 case 14: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 64) kind = 64;
						 jjCheckNAddTwoStates(14, 15);
						 break;
						 case 16: if (curChar == 39) jjAddStates(13, 14);
						 break;
						 case 17: if ((0xffffff7fffffdbffL & l) != 0L) jjCheckNAdd(18);
						 break;
						 case 18: if (curChar == 39 && kind > 66) kind = 66;
						 break;
						 case 20: if ((0x8400000000L & l) != 0L) jjCheckNAdd(18);
						 break;
						 case 21: if ((0xff000000000000L & l) != 0L) jjCheckNAddTwoStates(22, 18);
						 break;
						 case 22: if ((0xff000000000000L & l) != 0L) jjCheckNAdd(18);
						 break;
						 case 23: if ((0xf000000000000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 24;
						 break;
						 case 24: if ((0xff000000000000L & l) != 0L) jjCheckNAdd(22);
						 break;
						 case 25: if (curChar == 34) jjCheckNAddStates(10, 12);
						 break;
						 case 26: if ((0xfffffffbffffdbffL & l) != 0L) jjCheckNAddStates(10, 12);
						 break;
						 case 28: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(10, 12);
						 break;
						 case 29: if (curChar == 34 && kind > 67) kind = 67;
						 break;
						 case 30: if ((0xff000000000000L & l) != 0L) jjCheckNAddStates(27, 30);
						 break;
						 case 31: if ((0xff000000000000L & l) != 0L) jjCheckNAddStates(10, 12);
						 break;
						 case 32: if ((0xf000000000000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 33;
						 break;
						 case 33: if ((0xff000000000000L & l) != 0L) jjCheckNAdd(31);
						 break;
						 case 34: if (curChar != 36) break;
						 if (kind > 69) kind = 69;
						 jjCheckNAdd(35);
						 break;
						 case 35: if ((0x3ff001000000000L & l) == 0L) break;
						 if (kind > 69) kind = 69;
						 jjCheckNAdd(35);
						 break;
						 case 36: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(0, 6);
						 break;
						 case 37: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(37, 38);
						 break;
						 case 38: if (curChar != 46) break;
						 if (kind > 64) kind = 64;
						 jjCheckNAddStates(31, 33);
						 break;
						 case 39: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 64) kind = 64;
						 jjCheckNAddStates(31, 33);
						 break;
						 case 41: if ((0x280000000000L & l) != 0L) jjCheckNAdd(42);
						 break;
						 case 42: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 64) kind = 64;
						 jjCheckNAddTwoStates(42, 15);
						 break;
						 case 43: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(43, 44);
						 break;
						 case 45: if ((0x280000000000L & l) != 0L) jjCheckNAdd(46);
						 break;
						 case 46: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 64) kind = 64;
						 jjCheckNAddTwoStates(46, 15);
						 break;
						 case 47: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddStates(34, 36);
						 break;
						 case 49: if ((0x280000000000L & l) != 0L) jjCheckNAdd(50);
						 break;
						 case 50: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(50, 15);
						 break;
						 case 51: if (curChar != 48) break;
						 if (kind > 60) kind = 60;
						 jjCheckNAddStates(15, 17);
						 break;
						 case 53: if ((0x3ff000000000000L & l) == 0L) break;
						 if (kind > 60) kind = 60;
						 jjCheckNAddTwoStates(53, 9);
						 break;
						 case 54: if ((0xff000000000000L & l) == 0L) break;
						 if (kind > 60) kind = 60;
						 jjCheckNAddTwoStates(54, 9);
						 break;
						 case 55: if (curChar == 47) jjAddStates(7, 9);
						 break;
						 case 57: if ((0xffffffffffffdbffL & l) == 0L) break;
						 if (kind > 7) kind = 7;
						 jjCheckNAddStates(18, 20);
						 break;
						 case 58: if ((0x2400L & l) != 0L && kind > 7) kind = 7;
						 break;
						 case 59: if (curChar == 10 && kind > 7) kind = 7;
						 break;
						 case 60: if (curChar == 13) jjstateSet[jjnewStateCnt++] = 59;
						 break;
						 case 61: if (curChar == 42) jjCheckNAdd(62);
						 break;
						 case 62: if ((0xfffffbffffffffffL & l) != 0L) jjCheckNAddTwoStates(62, 63);
						 break;
						 case 63: if (curChar == 42) jjCheckNAddStates(37, 39);
						 break;
						 case 64: if ((0xffff7bffffffffffL & l) != 0L) jjCheckNAddTwoStates(65, 63);
						 break;
						 case 65: if ((0xfffffbffffffffffL & l) != 0L) jjCheckNAddTwoStates(65, 63);
						 break;
						 case 66: if (curChar == 47 && kind > 9) kind = 9;
						 break;
						 case 67: if (curChar == 42) jjCheckNAddTwoStates(68, 69);
						 break;
						 case 68: if ((0xfffffbffffffffffL & l) != 0L) jjCheckNAddTwoStates(68, 69);
						 break;
						 case 69: if (curChar == 42) jjCheckNAddStates(40, 42);
						 break;
						 case 70: if ((0xffff7bffffffffffL & l) != 0L) jjCheckNAddTwoStates(71, 69);
						 break;
						 case 71: if ((0xfffffbffffffffffL & l) != 0L) jjCheckNAddTwoStates(71, 69);
						 break;
						 case 72: if (curChar == 47 && kind > 68) kind = 68;
						 break;
						 case 73: if (curChar == 42) jjstateSet[jjnewStateCnt++] = 67;
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else if (curChar < 128) {
				 long l = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 6: case 35: if ((0x7fffffe87fffffeL & l) == 0L) break;
						 if (kind > 69) kind = 69;
						 jjCheckNAdd(35);
						 break;
						 case 2: jjAddStates(21, 23);
						 break;
						 case 9: if ((0x100000001000L & l) != 0L && kind > 60) kind = 60;
						 break;
						 case 12: if ((0x2000000020L & l) != 0L) jjAddStates(43, 44);
						 break;
						 case 15: if ((0x5000000050L & l) != 0L && kind > 64) kind = 64;
						 break;
						 case 17: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAdd(18);
						 break;
						 case 19: if (curChar == 92) jjAddStates(45, 47);
						 break;
						 case 20: if ((0x14404410000000L & l) != 0L) jjCheckNAdd(18);
						 break;
						 case 26: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(10, 12);
						 break;
						 case 27: if (curChar == 92) jjAddStates(48, 50);
						 break;
						 case 28: if ((0x14404410000000L & l) != 0L) jjCheckNAddStates(10, 12);
						 break;
						 case 40: if ((0x2000000020L & l) != 0L) jjAddStates(51, 52);
						 break;
						 case 44: if ((0x2000000020L & l) != 0L) jjAddStates(53, 54);
						 break;
						 case 48: if ((0x2000000020L & l) != 0L) jjAddStates(55, 56);
						 break;
						 case 52: if ((0x100000001000000L & l) != 0L) jjCheckNAdd(53);
						 break;
						 case 53: if ((0x7e0000007eL & l) == 0L) break;
						 if (kind > 60) kind = 60;
						 jjCheckNAddTwoStates(53, 9);
						 break;
						 case 57: if (kind > 7) kind = 7;
						 jjAddStates(18, 20);
						 break;
						 case 62: jjCheckNAddTwoStates(62, 63);
						 break;
						 case 64: case 65: jjCheckNAddTwoStates(65, 63);
						 break;
						 case 68: jjCheckNAddTwoStates(68, 69);
						 break;
						 case 70: case 71: jjCheckNAddTwoStates(71, 69);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 else {
				 int hiByte = (int)(curChar >> 8);
				 int i1 = hiByte >> 6;
				 long l1 = 1L << (hiByte & 077);
				 int i2 = (curChar & 0xff) >> 6;
				 long l2 = 1L << (curChar & 077);
				 MatchLoop: do {
					 switch(jjstateSet[--i]) {
						 case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
							 if (kind > 6) kind = 6;
							 jjCheckNAdd(0);
						 }
						 if (jjCanMove_2(hiByte, i1, i2, l1, l2)) {
							 if (kind > 69) kind = 69;
							 jjCheckNAdd(35);
						 }
						 break;
						 case 0: if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 6) kind = 6;
						 jjCheckNAdd(0);
						 break;
						 case 2: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjAddStates(21, 23);
						 break;
						 case 17: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjstateSet[jjnewStateCnt++] = 18;
						 break;
						 case 26: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjAddStates(10, 12);
						 break;
						 case 34: case 35: if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 69) kind = 69;
						 jjCheckNAdd(35);
						 break;
						 case 57: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break;
						 if (kind > 7) kind = 7;
						 jjAddStates(18, 20);
						 break;
						 case 62: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(62, 63);
						 break;
						 case 64: case 65: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(65, 63);
						 break;
						 case 68: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(68, 69);
						 break;
						 case 70: case 71: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(71, 69);
						 break;
						 default : break;
					 }
				 }
				 while(i != startsAt);
			 }
			 if (kind != 0x7fffffff) {
				 jjmatchedKind = kind;
				 jjmatchedPos = curPos;
				 kind = 0x7fffffff;
			 }
			 ++curPos;
			 if ((i = jjnewStateCnt) == (startsAt = 74 - (jjnewStateCnt = startsAt))) return curPos;
			 try {
				 curChar = input_stream.readChar();
			 }
			 catch(java.io.IOException e) {
				 return curPos;
			 }
		 }
	}
	static final int[] jjnextStates = {
	 37, 38, 43, 44, 47, 48, 15, 56, 61, 73, 26, 27, 29, 17, 19, 52, 54, 9, 57, 58, 60, 2, 3, 5, 11, 12, 15, 26, 27, 31, 29, 39, 40, 15, 47, 48, 15, 63, 64, 66, 69, 70, 72, 13, 14, 20, 21, 23, 28, 30, 32, 41, 42, 45, 46, 49, 50, }
	;
	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec0[i2] & l2) != 0L);
			 default : return false;
		 }
	}
	private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec0[i2] & l2) != 0L);
			 default : if ((jjbitVec1[i1] & l1) != 0L) return true;
			 return false;
		 }
	}
	private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2){
		 switch(hiByte) {
			 case 0: return ((jjbitVec4[i2] & l2) != 0L);
			 case 48: return ((jjbitVec5[i2] & l2) != 0L);
			 case 49: return ((jjbitVec6[i2] & l2) != 0L);
			 case 51: return ((jjbitVec7[i2] & l2) != 0L);
			 case 61: return ((jjbitVec8[i2] & l2) != 0L);
			 default : if ((jjbitVec3[i1] & l1) != 0L) return true;
			 return false;
		 }
	}
	public static final String[] jjstrLiteralImages = {
	"""", null, null, null, null, null, null, null, null, null, ""\141\142\163\164\162\141\143\164"", ""\142\157\157\154\145\141\156"", ""\142\162\145\141\153"", ""\143\154\141\163\163"", ""\142\171\164\145"", ""\143\141\163\145"", ""\143\141\164\143\150"", ""\143\150\141\162"", ""\143\157\156\163\164"", ""\143\157\156\164\151\156\165\145"", ""\144\145\146\141\165\154\164"", ""\144\157"", ""\144\157\165\142\154\145"", ""\145\154\163\145"", ""\145\156\165\155"", ""\145\170\164\145\156\144\163"", ""\146\141\154\163\145"", ""\146\151\156\141\154"", ""\146\151\156\141\154\154\171"", ""\146\154\157\141\164"", ""\146\157\162"", ""\147\157\164\157"", ""\151\146"", ""\151\155\160\154\145\155\145\156\164\163"", ""\151\155\160\157\162\164"", ""\151\156\163\164\141\156\143\145\157\146"", ""\151\156\164"", ""\151\156\164\145\162\146\141\143\145"", ""\154\157\156\147"", ""\156\141\164\151\166\145"", ""\156\145\167"", ""\156\165\154\154"", ""\160\141\143\153\141\147\145"", ""\160\162\151\166\141\164\145"", ""\160\162\157\164\145\143\164\145\144"", ""\160\165\142\154\151\143"", ""\162\145\164\165\162\156"", ""\163\150\157\162\164"", ""\163\164\141\164\151\143"", ""\163\164\162\151\143\164\146\160"", ""\163\167\151\164\143\150"", ""\163\171\156\143\150\162\157\156\151\172\145\144"", ""\164\162\141\156\163\151\145\156\164"", ""\164\150\162\157\167"", ""\164\150\162\157\167\163"", ""\164\162\165\145"", ""\164\162\171"", ""\166\157\151\144"", ""\166\157\154\141\164\151\154\145"", ""\167\150\151\154\145"", null, null, null, null, null, null, null, null, null, null, null, null, ""\50"", ""\51"", ""\173"", ""\175"", ""\133"", ""\135"", ""\73"", ""\54"", ""\56"", ""\75"", ""\76"", ""\100\147\164"", ""\74"", ""\100\154\164"", ""\41"", ""\176"", ""\77"", ""\72"", ""\75\75"", ""\74\75"", ""\100\154\164\145\161"", ""\76\75"", ""\100\147\164\145\161"", ""\41\75"", ""\174\174"", ""\100\157\162"", ""\46\46"", ""\100\141\156\144"", ""\53\53"", ""\55\55"", ""\53"", ""\55"", ""\52"", ""\57"", ""\46"", ""\100\142\151\164\167\151\163\145\137\141\156\144"", ""\174"", ""\100\142\151\164\167\151\163\145\137\157\162"", ""\136"", ""\45"", ""\74\74"", ""\100\154\145\146\164\137\163\150\151\146\164"", ""\76\76"", ""\100\162\151\147\150\164\137\163\150\151\146\164"", ""\76\76\76"", ""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164"", ""\53\75"", ""\55\75"", ""\52\75"", ""\57\75"", ""\46\75"", ""\100\141\156\144\137\141\163\163\151\147\156"", ""\174\75"", ""\100\157\162\137\141\163\163\151\147\156"", ""\136\75"", ""\45\75"", ""\74\74\75"", ""\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", ""\76\76\75"", ""\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", ""\76\76\76\75"", ""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156"", }
	;
	public static final String[] lexStateNames = {
	 ""DEFAULT"", }
	;
	static final long[] jjtoToken = {
	 0x1ffffffffffffc01L, 0xffffffffffffff3dL, 0x3fL, }
	;
	static final long[] jjtoSkip = {
	 0x3feL, 0x0L, 0x0L, }
	;
	static final long[] jjtoSpecial = {
	 0x380L, 0x0L, 0x0L, }
	;
	protected JavaCharStream input_stream;
	private final int[] jjrounds = new int[74];
	private final int[] jjstateSet = new int[148];
	protected char curChar;
	public ParserTokenManager(JavaCharStream stream){
		 if (JavaCharStream.staticFlag) throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
		 input_stream = stream;
	}
	public ParserTokenManager(JavaCharStream stream, int lexState){
		 this(stream);
		 SwitchTo(lexState);
	}
	public void ReInit(JavaCharStream stream){
		 jjmatchedPos = jjnewStateCnt = 0;
		 curLexState = defaultLexState;
		 input_stream = stream;
		 ReInitRounds();
	}
	private final void ReInitRounds(){
		 int i;
		 jjround = 0x80000001;
		 for (i = 74;
		 i-- > 0;
		) jjrounds[i] = 0x80000000;
	}
	public void ReInit(JavaCharStream stream, int lexState){
		 ReInit(stream);
		 SwitchTo(lexState);
	}
	public void SwitchTo(int lexState){
		 if (lexState >= 1 || lexState < 0) throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
		 else curLexState = lexState;
	}
	protected Token jjFillToken(){
		 Token t = Token.newToken(jjmatchedKind);
		 t.kind = jjmatchedKind;
		 String im = jjstrLiteralImages[jjmatchedKind];
		 t.image = (im == null) ? input_stream.GetImage() : im;
		 t.beginLine = input_stream.getBeginLine();
		 t.beginColumn = input_stream.getBeginColumn();
		 t.endLine = input_stream.getEndLine();
		 t.endColumn = input_stream.getEndColumn();
		 return t;
	}
	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;
	public Token getNextToken() {
		 int kind;
		 Token specialToken = null;
		 Token matchedToken;
		 int curPos = 0;
		 EOFLoop : for (;
		;
		) {
			 try {
				 curChar = input_stream.BeginToken();
			 }
			 catch(java.io.IOException e) {
				 jjmatchedKind = 0;
				 matchedToken = jjFillToken();
				 matchedToken.specialToken = specialToken;
				 return matchedToken;
			 }
			 jjmatchedKind = 0x7fffffff;
			 jjmatchedPos = 0;
			 curPos = jjMoveStringLiteralDfa0_0();
			 if (jjmatchedKind != 0x7fffffff) {
				 if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
				 if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
					 matchedToken = jjFillToken();
					 matchedToken.specialToken = specialToken;
					 return matchedToken;
				 }
				 else {
					 if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						 matchedToken = jjFillToken();
						 if (specialToken == null) specialToken = matchedToken;
						 else {
							 matchedToken.specialToken = specialToken;
							 specialToken = (specialToken.next = matchedToken);
						 }
					 }
					 continue EOFLoop;
				 }
			 }
			 int error_line = input_stream.getEndLine();
			 int error_column = input_stream.getEndColumn();
			 String error_after = null;
			 boolean EOFSeen = false;
			 try {
				 input_stream.readChar();
				 input_stream.backup(1);
			 }
			 catch (java.io.IOException e1) {
				 EOFSeen = true;
				 error_after = curPos <= 1 ? """" : input_stream.GetImage();
				 if (curChar == '\n' || curChar == '\r') {
					 error_line++;
					 error_column = 0;
				 }
				 else error_column++;
			 }
			 if (!EOFSeen) {
				 input_stream.backup(1);
				 error_after = curPos <= 1 ? """" : input_stream.GetImage();
			 }
			 throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
		 }
	}
}",1,0,0,0
"public List<Row> scan(IndexClause clause, AbstractBounds range, IFilter dataFilter) {
	 IndexExpression primary = highestSelectivityPredicate(clause);
	 ColumnFamilyStore indexCFS = getIndexedColumnFamilyStore(primary.column_name);
	 if (logger.isDebugEnabled()) logger.debug(""Primary scan clause is "" + getComparator().getString(primary.column_name));
	 assert indexCFS != null;
	 DecoratedKey indexKey = indexCFS.partitioner.decorateKey(primary.value);
	 IFilter firstFilter = dataFilter;
	 NamesQueryFilter extraFilter = null;
	 if (clause.expressions.size() > 1) {
		 if (dataFilter instanceof SliceQueryFilter) {
			 if (getMaxRowSize() < DatabaseDescriptor.getColumnIndexSize()) {
				 logger.debug(""Expanding slice filter to entire row to cover additional expressions"");
				 firstFilter = new SliceQueryFilter(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, ((SliceQueryFilter) dataFilter).reversed, Integer.MAX_VALUE);
			 }
			 else {
				 logger.debug(""adding extraFilter to cover additional expressions"");
				 SortedSet<ByteBuffer> columns = new TreeSet<ByteBuffer>(getComparator());
				 for (IndexExpression expr : clause.expressions) {
					 if (expr == primary) continue;
					 columns.add(expr.column_name);
				 }
				 extraFilter = new NamesQueryFilter(columns);
			 }
		 }
		 else {
			 logger.debug(""adding columns to firstFilter to cover additional expressions"");
			 assert dataFilter instanceof NamesQueryFilter;
			 SortedSet<ByteBuffer> columns = new TreeSet<ByteBuffer>(getComparator());
			 for (IndexExpression expr : clause.expressions) {
				 if (expr == primary || ((NamesQueryFilter) dataFilter).columns.contains(expr.column_name)) continue;
				 columns.add(expr.column_name);
			 }
			 if (columns.size() > 0) {
				 columns.addAll(((NamesQueryFilter) dataFilter).columns);
				 firstFilter = new NamesQueryFilter(columns);
			 }
		 }
	 }
	 List<Row> rows = new ArrayList<Row>();
	 ByteBuffer startKey = clause.start_key;
	 QueryPath path = new QueryPath(columnFamily);
	 outer: while (true) {
		 if (logger.isDebugEnabled()) logger.debug(String.format(""Scanning index row %s:%s starting with %s"", indexCFS.columnFamily, indexKey, indexCFS.getComparator().getString(startKey)));
		 QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey, new QueryPath(indexCFS.getColumnFamilyName()), startKey, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, clause.count);
		 ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
		 logger.debug(""fetched {
		}
		"", indexRow);
		 if (indexRow == null) break;
		 ByteBuffer dataKey = null;
		 int n = 0;
		 for (IColumn column : indexRow.getSortedColumns()) {
			 if (column.isMarkedForDelete()) continue;
			 dataKey = column.name();
			 n++;
			 DecoratedKey dk = partitioner.decorateKey(dataKey);
			 if (!range.right.equals(partitioner.getMinimumToken()) && range.right.compareTo(dk.token) < 0) break outer;
			 if (!range.contains(dk.token)) continue;
			 ColumnFamily data = getColumnFamily(new QueryFilter(dk, path, firstFilter));
			 logger.debug(""fetched data row {
			}
			"", data);
			 if (extraFilter != null) {
				 for (IndexExpression expr : clause.expressions) {
					 if (expr != primary && data.getColumn(expr.column_name) == null) {
						 data.addAll(getColumnFamily(new QueryFilter(dk, path, extraFilter)));
						 break;
					 }
				 }
			 }
			 if (satisfies(data, clause, primary)) {
				 logger.debug(""row {
				}
				 satisfies all clauses"", data);
				 if (firstFilter != dataFilter) {
					 ColumnFamily expandedData = data;
					 data = expandedData.cloneMeShallow();
					 IColumnIterator iter = dataFilter.getMemtableColumnIterator(expandedData, dk, getComparator());
					 new QueryFilter(dk, path, dataFilter).collectCollatedColumns(data, iter, gcBefore());
				 }
				 rows.add(new Row(dk, data));
			 }
			 if (rows.size() == clause.count) break outer;
		 }
		 if (n < clause.count || startKey.equals(dataKey)) break;
		 startKey = dataKey;
	 }
	 return rows;
 }",0,0,1,0
"public class UICommunityPortalForm extends UISimpleForm {
	 static public List PRIORITIES ;
	 static {
		 PRIORITIES = new ArrayList() ;
		 for(int i = 1;
		 i <= 10;
		 i++) {
			 String num = Integer.toString(i) ;
			 PRIORITIES.add(new SelectItem(num, num)) ;
		 }
	 }
	 private UISelectBox membershipInput_ ;
	 private UIStringInput portalInput_ ;
	 private UISelectBox priorityInput_ ;
	 private UITextArea descriptionInput_ ;
	 private CommunityConfigService service_ ;
	 private CommunityPortal communityPortal_ ;
	 public UICommunityPortalForm(CommunityConfigService service, OrganizationService orgService) throws Exception {
		 super(""communityPortalForm"", ""post"", null) ;
		 service_ = service ;
		 Collection memberships = orgService.findMembershipTypes() ;
		 Iterator i = memberships.iterator() ;
		 List mtypes = new ArrayList(10) ;
		 while(i.hasNext()) {
			 MembershipType mt = (MembershipType) i.next();
			 String name = mt.getName() ;
			 mtypes.add(new SelectItem(name, name)) ;
		 }
		 membershipInput_ = new UISelectBox(""membership"", """", mtypes) ;
		 portalInput_ = new UIStringInput(""portal"", """"). addValidator(ValidUserValidator.class) ;
		 priorityInput_ = new UISelectBox(""priority"", ""1"", PRIORITIES) ;
		 descriptionInput_ = new UITextArea(""description"", """") ;
		 add(new HeaderRow(). add(new Cell(""#{
		UICommunityPortalForm.header.community-portal}
		""). addColspan(""2"")));
		 add(new Row(). add(new LabelCell(""#{
		UICommunityPortalForm.label.membership}
		"")). add(new ComponentCell(this, membershipInput_)));
		 add(new Row(). add(new LabelCell(""#{
		UICommunityPortalForm.label.portal}
		"")). add(new ComponentCell(this, portalInput_)));
		 add(new Row(). add(new LabelCell(""#{
		UICommunityPortalForm.label.priority}
		"")). add(new ComponentCell(this, priorityInput_)));
		 add(new Row(). add(new LabelCell(""#{
		UICommunityPortalForm.label.description}
		"")). add(new ComponentCell(this, descriptionInput_)));
		 add(new Row(). add(new ListComponentCell(). add(new FormButton(""#{
		UICommunityPortalForm.button.save}
		"", SAVE_ACTION)). add(new FormButton(""#{
		UICommunityPortalForm.button.cancel}
		"", CANCEL_ACTION)). addColspan(""2"").addAlign(""center""))) ;
		 addActionListener(SaveUpdateListener.class, SAVE_ACTION) ;
		 addActionListener(CancelActionListener.class, CANCEL_ACTION) ;
	 }
	 public void setCommunityPortal(CommunityPortal cp) {
		 communityPortal_ = cp;
		 if(cp == null) {
			 membershipInput_.setValue("""") ;
			 portalInput_.setValue("""") ;
			 priorityInput_.setValue(""5"") ;
			 descriptionInput_.setValue("""") ;
		 }
		 else {
			 membershipInput_.setValue(cp.getMembership()) ;
			 portalInput_.setValue(cp.getPortal()) ;
			 priorityInput_.setValue(Integer.toString(cp.getPriority())) ;
			 descriptionInput_.setValue(cp.getDescription()) ;
		 }
	 }
	 static public class SaveUpdateListener extends ExoActionListener {
		 public void execute(ExoActionEvent event) throws Exception {
			 UICommunityPortalForm uiForm = (UICommunityPortalForm) event.getComponent() ;
			 CommunityPortal cp = uiForm.communityPortal_ ;
			 if(cp == null) {
				 UIGroupExplorer uiExplorer = (UIGroupExplorer) uiForm.getAncestorOfType(UIGroupExplorer.class) ;
				 Group currentGroup = uiExplorer.getCurrentGroup() ;
				 if(currentGroup == null) {
					 InformationProvider iprovider = findInformationProvider(uiForm);
					 iprovider.addMessage(new ExoFacesMessage(""#{
					UICommunityPortalForm.msg.no-group}
					"")) ;
					 uiForm.setRenderedSibling(UIGroupCommunityInfo.class) ;
					 return ;
				 }
				 cp = new CommunityPortal() ;
				 cp.setGroupId(currentGroup.getId()) ;
			 }
			 cp.setMembership(uiForm.membershipInput_.getValue()) ;
			 cp.setPortal(uiForm.portalInput_.getValue()) ;
			 cp.setPriority(Integer.parseInt(uiForm.priorityInput_.getValue())) ;
			 cp.setDescription(uiForm.descriptionInput_.getValue()) ;
			 uiForm.service_.addCommunityPortal(cp) ;
			 UIGroupCommunityInfo uiInfo = (UIGroupCommunityInfo) uiForm.getSibling(UIGroupCommunityInfo.class);
			 uiInfo.setCommunityPortal(cp) ;
			 uiForm.setRenderedSibling(UIGroupCommunityInfo.class) ;
		 }
	 }
	 static public class CancelActionListener extends ExoActionListener {
		 public void execute(ExoActionEvent event) throws Exception {
			 UICommunityPortalForm uiForm = (UICommunityPortalForm) event.getComponent() ;
			 uiForm.setRenderedSibling(UIGroupCommunityInfo.class) ;
		 }
	 }
}",0,1,0,0
"void turnOn(Integer cfId, Integer position) {
	 cfLastWrite.put(cfId, position);
 }",0,0,0,0
"public class Min<V extends Number> extends BaseNumberValueOperator<V> implements Unifier<V>{
	 protected V low;
	 protected boolean flag = false;
	 public final transient DefaultInputPort<V> data = new DefaultInputPort<V>() {
		 public void process(V tuple) {
			 Min.this.process(tuple);
		 }
	 }
	;
	 public void process(V tuple) {
		 if (!flag) {
			 low = tuple;
			 flag = true;
		 }
		 else if (low.doubleValue() > tuple.doubleValue()) {
			 low = tuple;
		 }
	 }
	 public final transient DefaultOutputPort<V> min = new DefaultOutputPort<V>() {
		 public Unifier<V> getUnifier() {
			 return Min.this;
		 }
	 }
	;
	 public void endWindow() {
		 if (flag) {
			 min.emit(low);
		 }
		 flag = false;
		 low = null;
	 }
}",0,0,0,0
"public class BrocadeVcsApi {
	 private static final Logger s_logger = Logger.getLogger(BrocadeVcsApi.class);
	 private final String _host;
	 private final String _adminuser;
	 private final String _adminpass;
	 protected DefaultHttpClient _client;
	 protected HttpRequestBase createMethod(String type, String uri) throws BrocadeVcsApiException {
		 String url;
		 try {
			 url = new URL(Constants.PROTOCOL, _host, Constants.PORT, uri).toString();
		 }
		 catch (final MalformedURLException e) {
			 s_logger.error(""Unable to build Brocade Switch API URL"", e);
			 throw new BrocadeVcsApiException(""Unable to build Brocade Switch API URL"", e);
		 }
		 if (""post"".equalsIgnoreCase(type)) {
			 return new HttpPost(url);
		 }
		 else if (""get"".equalsIgnoreCase(type)) {
			 return new HttpGet(url);
		 }
		 else if (""delete"".equalsIgnoreCase(type)) {
			 return new HttpDelete(url);
		 }
		 else if (""patch"".equalsIgnoreCase(type)) {
			 return new HttpPatch(url);
		 }
		 else {
			 throw new BrocadeVcsApiException(""Requesting unknown method type"");
		 }
	 }
	 public BrocadeVcsApi(String address, String username, String password) {
		 _host = address;
		 _adminuser = username;
		 _adminpass = password;
		 _client = new DefaultHttpClient();
		 _client.getCredentialsProvider().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(_adminuser, _adminpass));
	 }
	 public Output getSwitchStatus() throws BrocadeVcsApiException {
		 return executeRetreiveStatus(Constants.STATUS_URI);
	 }
	 public boolean createNetwork(int vlanId, long networkId) throws BrocadeVcsApiException {
		 if (createInterfaceVlan(vlanId)) {
			 final PortProfile portProfile = createPortProfile(vlanId, networkId);
			 if (portProfile != null) {
				 return activatePortProfile(portProfile);
			 }
		 }
		 return false;
	 }
	 private boolean activatePortProfile(PortProfile portProfile) throws BrocadeVcsApiException {
		 final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
		 portProfile.setVlanProfile(null);
		 final Activate activate = new Activate();
		 portProfile.setActivate(activate);
		 portProfileGlobal.setPortProfile(portProfile);
		 return executeUpdateObject(portProfileGlobal, Constants.URI);
	 }
	 private PortProfile createPortProfile(int vlanId, long networkId) throws BrocadeVcsApiException {
		 final PortProfile portProfile = new PortProfile();
		 portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
		 if (executeCreateObject(portProfile, Constants.URI)) {
			 if (createVlanSubProfile(vlanId, portProfile)) {
				 return portProfile;
			 }
		 }
		 return null;
	 }
	 private boolean createVlanSubProfile(int vlanId, PortProfile portProfile) throws BrocadeVcsApiException {
		 final VlanProfile vlanProfile = new VlanProfile();
		 portProfile.setVlanProfile(vlanProfile);
		 if (executeUpdateObject(portProfile, Constants.URI)) {
			 return configureVlanSubProfile(vlanId, portProfile);
		 }
		 return false;
	 }
	 private boolean configureVlanSubProfile(int vlanId, PortProfile portProfile) throws BrocadeVcsApiException {
		 final SwitchportBasic switchPortBasic = new SwitchportBasic();
		 final Basic basic = new Basic();
		 switchPortBasic.setBasic(basic);
		 portProfile.getVlanProfile().setSwitchportBasic(switchPortBasic);
		 if (executeUpdateObject(portProfile, Constants.URI)) {
			 VlanProfile vlanProfile = new VlanProfile();
			 Switchport switchPort = new Switchport();
			 final Mode mode = new Mode();
			 mode.setVlanMode(""trunk"");
			 switchPort.setMode(mode);
			 vlanProfile.setSwitchport(switchPort);
			 portProfile.setVlanProfile(vlanProfile);
			 if (executeUpdateObject(portProfile, Constants.URI)) {
				 vlanProfile = new VlanProfile();
				 switchPort = new Switchport();
				 final Trunk trunk = new Trunk();
				 final Allowed allowed = new Allowed();
				 final Allowed.Vlan allowedVlan = new Allowed.Vlan();
				 allowedVlan.setAdd(vlanId);
				 allowed.setVlan(allowedVlan);
				 trunk.setAllowed(allowed);
				 switchPort.setTrunk(trunk);
				 vlanProfile.setSwitchport(switchPort);
				 portProfile.setVlanProfile(vlanProfile);
				 return executeUpdateObject(portProfile, Constants.URI);
			 }
		 }
		 return false;
	 }
	 private boolean createInterfaceVlan(int vlanId) throws BrocadeVcsApiException {
		 final InterfaceVlan interfaceVlan = new InterfaceVlan();
		 final Interface interfaceObj = new Interface();
		 final Vlan vlan = new Vlan();
		 vlan.setName(vlanId);
		 interfaceObj.setVlan(vlan);
		 interfaceVlan.setInterface(interfaceObj);
		 return executeUpdateObject(interfaceVlan, Constants.URI);
	 }
	 public boolean associateMacToNetwork(long networkId, String macAddress) throws BrocadeVcsApiException {
		 final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
		 final PortProfile portProfile = new PortProfile();
		 portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
		 final Static staticObj = new Static();
		 staticObj.setMacAddress(macAddress);
		 portProfile.setStatic(staticObj);
		 portProfileGlobal.setPortProfile(portProfile);
		 return executeUpdateObject(portProfileGlobal, Constants.URI);
	 }
	 public boolean disassociateMacFromNetwork(long networkId, String macAddress) throws BrocadeVcsApiException {
		 final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
		 final PortProfile portProfile = new PortProfile();
		 portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
		 final Static staticObj = new Static();
		 staticObj.setOperation(""delete"");
		 staticObj.setMacAddress(macAddress);
		 portProfile.setStatic(staticObj);
		 portProfileGlobal.setPortProfile(portProfile);
		 return executeUpdateObject(portProfileGlobal, Constants.URI);
	 }
	 public boolean deleteNetwork(int vlanId, long networkId) throws BrocadeVcsApiException {
		 if (deactivatePortProfile(networkId)) {
			 if (deletePortProfile(networkId)) {
				 return deleteInterfaceVlan(vlanId);
			 }
		 }
		 return false;
	 }
	 private boolean deleteInterfaceVlan(int vlanId) throws BrocadeVcsApiException {
		 final InterfaceVlan interfaceVlan = new InterfaceVlan();
		 final Interface interfaceObj = new Interface();
		 final Vlan vlan = new Vlan();
		 vlan.setOperation(""delete"");
		 vlan.setName(vlanId);
		 interfaceObj.setVlan(vlan);
		 interfaceVlan.setInterface(interfaceObj);
		 return executeUpdateObject(interfaceVlan, Constants.URI);
	 }
	 private boolean deactivatePortProfile(long networkId) throws BrocadeVcsApiException {
		 final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
		 final PortProfile portProfile = new PortProfile();
		 portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
		 final Activate activate = new Activate();
		 activate.setOperation(""delete"");
		 portProfile.setActivate(activate);
		 portProfileGlobal.setPortProfile(portProfile);
		 return executeUpdateObject(portProfileGlobal, Constants.URI);
	 }
	 private boolean deletePortProfile(long networkId) throws BrocadeVcsApiException {
		 final PortProfile portProfile = new PortProfile();
		 portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
		 portProfile.setOperation(""delete"");
		 return executeUpdateObject(portProfile, Constants.URI);
	 }
	 protected <T> boolean executeUpdateObject(T newObject, String uri) throws BrocadeVcsApiException {
		 final boolean result = true;
		 if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
			 throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
		 }
		 final HttpPatch pm = (HttpPatch)createMethod(""patch"", uri);
		 pm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");
		 pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));
		 final HttpResponse response = executeMethod(pm);
		 if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {
			 String errorMessage;
			 try {
				 errorMessage = responseToErrorMessage(response);
			 }
			 catch (final IOException e) {
				 s_logger.error(""Failed to update object : "" + e.getMessage());
				 throw new BrocadeVcsApiException(""Failed to update object : "" + e.getMessage());
			 }
			 pm.releaseConnection();
			 s_logger.error(""Failed to update object : "" + errorMessage);
			 throw new BrocadeVcsApiException(""Failed to update object : "" + errorMessage);
		 }
		 pm.releaseConnection();
		 return result;
	 }
	 protected <T> String convertToString(T object) throws BrocadeVcsApiException {
		 final StringWriter stringWriter = new StringWriter();
		 try {
			 final JAXBContext context = JAXBContext.newInstance(object.getClass());
			 final Marshaller marshaller = context.createMarshaller();
			 marshaller.marshal(object, stringWriter);
		 }
		 catch (final JAXBException e) {
			 s_logger.error(""Failed to convert object to string : "" + e.getMessage());
			 throw new BrocadeVcsApiException(""Failed to convert object to string : "" + e.getMessage());
		 }
		 final String str = stringWriter.toString();
		 s_logger.info(str);
		 return str;
	 }
	 protected Output convertToXML(String object) throws BrocadeVcsApiException {
		 Output output = null;
		 try {
			 final JAXBContext context = JAXBContext.newInstance(Output.class);
			 final StringReader reader = new StringReader(object);
			 final Unmarshaller unmarshaller = context.createUnmarshaller();
			 final Object result = unmarshaller.unmarshal(reader);
			 if (result instanceof Output) {
				 output = (Output)result;
				 s_logger.info(output);
			 }
		 }
		 catch (final JAXBException e) {
			 s_logger.error(""Failed to convert string to object : "" + e.getMessage());
			 throw new BrocadeVcsApiException(""Failed to convert string to object : "" + e.getMessage());
		 }
		 return output;
	 }
	 protected <T> boolean executeCreateObject(T newObject, String uri) throws BrocadeVcsApiException {
		 if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
			 throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
		 }
		 final boolean result = true;
		 final HttpPost pm = (HttpPost)createMethod(""post"", uri);
		 pm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");
		 pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));
		 final HttpResponse response = executeMethod(pm);
		 if (response.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {
			 String errorMessage;
			 try {
				 errorMessage = responseToErrorMessage(response);
			 }
			 catch (final IOException e) {
				 s_logger.error(""Failed to create object : "" + e.getMessage());
				 throw new BrocadeVcsApiException(""Failed to create object : "" + e.getMessage());
			 }
			 pm.releaseConnection();
			 s_logger.error(""Failed to create object : "" + errorMessage);
			 throw new BrocadeVcsApiException(""Failed to create object : "" + errorMessage);
		 }
		 pm.releaseConnection();
		 return result;
	 }
	 protected Output executeRetreiveStatus(String uri) throws BrocadeVcsApiException {
		 if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
			 throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
		 }
		 String readLine = null;
		 StringBuffer sb = null;
		 final HttpPost pm = (HttpPost)createMethod(""post"", uri);
		 pm.setHeader(""Accept"", ""application/vnd.operational-state.resource+xml"");
		 pm.setEntity(new StringEntity(""<show-vcs></show-vcs>"", ContentType.APPLICATION_XML));
		 final HttpResponse response = executeMethod(pm);
		 if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
			 String errorMessage;
			 try {
				 errorMessage = responseToErrorMessage(response);
			 }
			 catch (final IOException e) {
				 s_logger.error(""Failed to retreive status : "" + e.getMessage());
				 throw new BrocadeVcsApiException(""Failed to retreive status : "" + e.getMessage());
			 }
			 pm.releaseConnection();
			 s_logger.error(""Failed to retreive status : "" + errorMessage);
			 throw new BrocadeVcsApiException(""Failed to retreive status : "" + errorMessage);
		 }
		 try (BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName(""UTF-8"")))) {
			 sb = new StringBuffer();
			 while ((readLine = br.readLine()) != null) {
				 s_logger.debug(readLine);
				 sb.append(readLine);
			 }
		 }
		 catch (final Exception e) {
			 s_logger.error(""Failed to retreive status : "" + e.getMessage());
			 throw new BrocadeVcsApiException(""Failed to retreive status : "" + e.getMessage());
		 }
		 pm.releaseConnection();
		 return convertToXML(sb.toString());
	 }
	 protected void executeDeleteObject(String uri) throws BrocadeVcsApiException {
		 if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
			 throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
		 }
		 final HttpDelete dm = (HttpDelete)createMethod(""delete"", uri);
		 dm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");
		 final HttpResponse response = executeMethod(dm);
		 if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {
			 String errorMessage;
			 try {
				 errorMessage = responseToErrorMessage(response);
			 }
			 catch (final IOException e) {
				 s_logger.error(""Failed to delete object : "" + e.getMessage());
				 throw new BrocadeVcsApiException(""Failed to delete object : "" + e.getMessage());
			 }
			 dm.releaseConnection();
			 s_logger.error(""Failed to delete object : "" + errorMessage);
			 throw new BrocadeVcsApiException(""Failed to delete object : "" + errorMessage);
		 }
		 dm.releaseConnection();
	 }
	 protected HttpResponse executeMethod(HttpRequestBase method) throws BrocadeVcsApiException {
		 HttpResponse response = null;
		 try {
			 response = _client.execute(method);
			 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
				 method.releaseConnection();
				 response = _client.execute(method);
			 }
		 }
		 catch (final IOException e) {
			 s_logger.error(""IOException caught while trying to connect to the Brocade Switch"", e);
			 method.releaseConnection();
			 throw new BrocadeVcsApiException(""API call to Brocade Switch Failed"", e);
		 }
		 return response;
	 }
	 private String responseToErrorMessage(HttpResponse response) throws IOException {
		 if (""text/html"".equals(response.getEntity().getContentType().getValue())) {
			 try (BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName(""UTF-8"")))) {
				 final StringBuffer result = new StringBuffer();
				 String line = """";
				 while ((line = rd.readLine()) != null) {
					 result.append(line);
				 }
				 return result.toString();
			 }
		 }
		 return null;
	 }
}",1,0,0,0
"public class OsgiRequirementAdapter implements Requirement {
	private static final Logger logger = LoggerFactory.getLogger(OsgiRequirementAdapter.class);
	private final org.osgi.resource.Requirement requirement;
	public OsgiRequirementAdapter(org.osgi.resource.Requirement requirement) {
		if (requirement == null)throw new NullPointerException(""Missing required parameter: requirement"");
		this.requirement = requirement;
	}
	public String getComment() {
		return null;
	}
	public String getFilter() {
		return requirement.getDirectives().get(Constants.FILTER_DIRECTIVE);
	}
	public String getName() {
		return NamespaceTranslator.translate(requirement.getNamespace());
	}
	public boolean isExtend() {
		return false;
	}
	public boolean isMultiple() {
		String multiple = requirement.getDirectives().get(Namespace.REQUIREMENT_CARDINALITY_DIRECTIVE);
		return Namespace.CARDINALITY_MULTIPLE.equals(multiple);
	}
	public boolean isOptional() {
		String resolution = requirement.getDirectives().get(Constants.RESOLUTION_DIRECTIVE);
		return Constants.RESOLUTION_OPTIONAL.equals(resolution);
	}
	public boolean isSatisfied(Capability capability) {
		logger.debug(LOG_ENTRY, ""isSatisfied"", capability);
		boolean result = ResourceHelper.matches(requirement, new FelixCapabilityAdapter(capability, null));
		logger.debug(LOG_EXIT, ""isSatisfied"", result);
		return result;
	}
}",0,1,0,0
"public abstract class PersistentReplicatedTestBase extends JUnit4CacheTestCase {
	 protected static final int MAX_WAIT = 60 * 1000;
	 protected static String REGION_NAME = ""region"";
	 protected File diskDir;
	 protected static String SAVED_ACK_WAIT_THRESHOLD;
	 public final void postSetUp() throws Exception {
		 Invoke.invokeInEveryVM(PersistentReplicatedTestBase.class, ""setRegionName"", new Object[] {
		getUniqueName()}
		);
		 setRegionName(getUniqueName());
		 diskDir = new File(""diskDir-"" + getName()).getAbsoluteFile();
		 FileUtils.deleteDirectory(diskDir);
		 diskDir.mkdir();
		 diskDir.deleteOnExit();
	 }
	 public static void setRegionName(String testName) {
		 REGION_NAME = testName + ""Region"";
	 }
	 public final void postTearDownCacheTestCase() throws Exception {
		 FileUtils.deleteDirectory(diskDir);
		 postTearDownPersistentReplicatedTestBase();
	 }
	 protected void postTearDownPersistentReplicatedTestBase() throws Exception {
	}
	 protected void waitForBlockedInitialization(VM vm) {
		 vm.invoke(new SerializableRunnable() {
			 public void run() {
				 GeodeAwaitility.await().untilAsserted(new WaitCriterion() {
					 public String description() {
						 return ""Waiting for another persistent member to come online"";
					 }
					 public boolean done() {
						 GemFireCacheImpl cache = (GemFireCacheImpl) getCache();
						 PersistentMemberManager mm = cache.getPersistentMemberManager();
						 Map<String, Set<PersistentMemberID>> regions = mm.getWaitingRegions();
						 boolean done = !regions.isEmpty();
						 return done;
					 }
				 }
				);
			 }
		 }
		);
	 }
	 protected SerializableRunnable createPersistentRegionWithoutCompaction(final VM vm0) {
		 SerializableRunnable createRegion = new SerializableRunnable(""Create persistent region"") {
			 public void run() {
				 Cache cache = getCache();
				 DiskStoreFactory dsf = cache.createDiskStoreFactory();
				 File dir = getDiskDirForVM(vm0);
				 dir.mkdirs();
				 dsf.setDiskDirs(new File[] {
				dir}
				);
				 dsf.setMaxOplogSize(1);
				 dsf.setAutoCompact(false);
				 dsf.setAllowForceCompaction(true);
				 dsf.setCompactionThreshold(20);
				 DiskStore ds = dsf.create(REGION_NAME);
				 RegionFactory rf = new RegionFactory();
				 rf.setDiskStoreName(ds.getName());
				 rf.setDiskSynchronous(true);
				 rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
				 rf.setScope(Scope.DISTRIBUTED_ACK);
				 rf.create(REGION_NAME);
			 }
		 }
		;
		 vm0.invoke(createRegion);
		 return createRegion;
	 }
	 protected void closeRegion(final VM vm) {
		 SerializableRunnable closeRegion = new SerializableRunnable(""Close persistent region"") {
			 public void run() {
				 Cache cache = getCache();
				 Region region = cache.getRegion(REGION_NAME);
				 region.close();
			 }
		 }
		;
		 vm.invoke(closeRegion);
	 }
	 protected void closeCache(final VM vm) {
		 SerializableRunnable closeCache = new SerializableRunnable(""close cache"") {
			 public void run() {
				 Cache cache = getCache();
				 cache.close();
			 }
		 }
		;
		 vm.invoke(closeCache);
	 }
	 protected AsyncInvocation closeCacheAsync(VM vm0) {
		 SerializableRunnable close = new SerializableRunnable() {
			 public void run() {
				 Cache cache = getCache();
				 cache.close();
			 }
		 }
		;
		 return vm0.invokeAsync(close);
	 }
	 protected void createNonPersistentRegion(VM vm) throws Exception {
		 SerializableRunnable createRegion = new SerializableRunnable(""Create non persistent region"") {
			 public void run() {
				 Cache cache = getCache();
				 RegionFactory rf = new RegionFactory();
				 rf.setDataPolicy(DataPolicy.REPLICATE);
				 rf.setScope(Scope.DISTRIBUTED_ACK);
				 rf.create(REGION_NAME);
			 }
		 }
		;
		 vm.invoke(createRegion);
	 }
	 protected AsyncInvocation createPersistentRegionWithWait(VM vm) throws Exception {
		 return _createPersistentRegion(vm, true);
	 }
	 protected void createPersistentRegion(VM vm) throws Exception {
		 _createPersistentRegion(vm, false);
	 }
	 private AsyncInvocation _createPersistentRegion(VM vm, boolean wait) throws Exception {
		 AsyncInvocation future = createPersistentRegionAsync(vm);
		 long waitTime = wait ? 500 : MAX_WAIT;
		 future.join(waitTime);
		 if (future.isAlive() && !wait) {
			 fail(""Region not created within"" + MAX_WAIT);
		 }
		 if (!future.isAlive() && wait) {
			 fail(""Did not expect region creation to complete"");
		 }
		 if (!wait && future.exceptionOccurred()) {
			 throw new RuntimeException(future.getException());
		 }
		 return future;
	 }
	 protected AsyncInvocation createPersistentRegionAsync(final VM vm) {
		 SerializableRunnable createRegion = new SerializableRunnable(""Create persistent region"") {
			 public void run() {
				 Cache cache = getCache();
				 DiskStoreFactory dsf = cache.createDiskStoreFactory();
				 File dir = getDiskDirForVM(vm);
				 dir.mkdirs();
				 dsf.setDiskDirs(new File[] {
				dir}
				);
				 dsf.setMaxOplogSize(1);
				 DiskStore ds = dsf.create(REGION_NAME);
				 RegionFactory rf = new RegionFactory();
				 rf.setDiskStoreName(ds.getName());
				 rf.setDiskSynchronous(true);
				 rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
				 rf.setScope(Scope.DISTRIBUTED_ACK);
				 rf.create(REGION_NAME);
			 }
		 }
		;
		 return vm.invokeAsync(createRegion);
	 }
	 protected File getDiskDirForVM(final VM vm) {
		 File dir = new File(diskDir, String.valueOf(vm.getId()));
		 return dir;
	 }
	 protected void backupDir(VM vm) throws IOException {
		 File dirForVM = getDiskDirForVM(vm);
		 File backFile = new File(dirForVM.getParent(), dirForVM.getName() + "".bk"");
		 FileUtils.copyDirectory(dirForVM, backFile);
	 }
	 protected void restoreBackup(VM vm) throws IOException {
		 File dirForVM = getDiskDirForVM(vm);
		 File backFile = new File(dirForVM.getParent(), dirForVM.getName() + "".bk"");
		 if (!backFile.renameTo(dirForVM)) {
			 FileUtils.deleteDirectory(dirForVM);
			 FileUtils.copyDirectory(backFile, dirForVM);
			 FileUtils.deleteDirectory(backFile);
		 }
	 }
}",1,0,0,0
"private static class GrailsContentProposal implements IContentProposal, Comparable<GrailsContentProposal> {
	private String fLabel;
	private String fContent;
	private String fDescription;
	private Image fImage;
	public GrailsContentProposal(String label, String content, String description, Image image) {
		fLabel = label;
		fContent = content;
		fDescription = description;
		fImage = image;
	}
	public String getContent() {
		return fContent;
	}
	public int getCursorPosition() {
		if (fContent != null) {
			return fContent.length();
		}
		return 0;
	}
	public String getDescription() {
		return fDescription;
	}
	public String getLabel() {
		return fLabel;
	}
	public Image getImage() {
		return fImage;
	}
	public String toString() {
		return fLabel;
	}
	public int compareTo(GrailsContentProposal o) {
		return this.fContent.compareTo(o.fContent);
	}
}",0,1,0,0
"public class ChangeRequest {
	public static final int REGISTER = 1;
	public static final int CHANGEOPS = 2;
	public static final int CLOSE = 3;
	public SocketChannel socket;
	public int type;
	public int ops;
	public ChangeRequest(SocketChannel socket, int type, int ops) {
		this.socket = socket;
		this.type = type;
		this.ops = ops;
	}
}",0,0,0,0
"public class Token {
	 public int kind;
	 public int beginLine, beginColumn, endLine, endColumn;
	 public String image;
	 public Token next;
	 public Token specialToken;
	 public String toString() {
		 return image;
	 }
	 public static final Token newToken(int ofKind) {
		 switch(ofKind) {
			 default : return new Token();
		 }
	 }
}",0,0,0,0
"public interface AdminUserCredentials extends PrincipalCredentials {
}",0,0,0,0
"public abstract class AbstractCommutativeType extends AbstractType<Long>{
	 public boolean isCommutative() {
		 return true;
	 }
	 public Long compose(ByteBuffer bytes) {
		 return CounterContext.instance().total(bytes);
	 }
	 public ByteBuffer decompose(Long value) {
		 return ByteBufferUtil.bytes(value);
	 }
	 public abstract Column createColumn(ByteBuffer name, ByteBuffer value, long timestamp);
	 public Class<Long> getType() {
		 return Long.class;
	 }
	 public boolean isSigned() {
		 return true;
	 }
	 public boolean isCaseSensitive() {
		 return false;
	 }
	 public boolean isCurrency() {
		 return false;
	 }
	 public int getPrecision(Long obj) {
		 return obj.toString().length();
	 }
	 public int getScale(Long obj) {
		 return 0;
	 }
	 public int getJdbcType() {
		 return Types.INTEGER;
	 }
	 public boolean needsQuotes() {
		 return false;
	 }
}",0,0,0,0
"public String toString() {
	 StringBuilder sb = new StringBuilder();
	 sb.append(Constants.INDENT);
	 sb.append(""kdf: 0x"");
	 sb.append(Functions.toFullHexString(kdf));
	 sb.append(Constants.NEWLINE);
	 sb.append(Constants.INDENT);
	 sb.append(""pSharedDataLen: "");
	 sb.append(pSharedData.length);
	 sb.append(Constants.NEWLINE);
	 sb.append(Constants.INDENT);
	 sb.append(""pSharedData: "");
	 sb.append(Functions.toHexString(pSharedData));
	 sb.append(Constants.NEWLINE);
	 sb.append(Constants.INDENT);
	 sb.append(""pPublicDataLen: "");
	 sb.append(pPublicData.length);
	 sb.append(Constants.NEWLINE);
	 sb.append(Constants.INDENT);
	 sb.append(""pPublicData: "");
	 sb.append(Functions.toHexString(pPublicData));
	 return sb.toString();
 }",0,0,1,0
"public void visit(DirectedGraph dg) {
	CompoundDirectedGraph graph = (CompoundDirectedGraph) dg;
	NodeList roots = new NodeList();
	for (int i = 0;
	 i < graph.nodes.size();
	 i++) {
		Object node = graph.nodes.get(i);
		if (node instanceof Subgraph) {
			Subgraph s = (Subgraph) node;
			Insets padding = dg.getPadding(s);
			s.head = new SubgraphBoundary(s, padding, 0);
			s.tail = new SubgraphBoundary(s, padding, 2);
			Edge headToTail = new Edge(s.head, s.tail);
			headToTail.weight = 10;
			graph.edges.add(headToTail);
			graph.containment.add(headToTail);
			graph.subgraphs.add(s);
			if (s.getParent() == null)roots.add(s);
			if (s.members.size() == 2) graph.edges.add(new Edge(s.head, s.tail));
		}
	}
	buildNestingTreeIndices(roots, 0);
	convertSubgraphEndpoints(graph);
	addContainmentEdges(graph);
	replaceSubgraphsWithBoundaries(graph);
}",0,0,1,0
"public void appendFolderOrItem(CaldavResponse response, CaldavRequest request, ExchangeSession.Folder folder, String subFolder) throws IOException {
	 response.startResponse(encodePath(request, request.getPath(subFolder)));
	 response.startPropstat();
	 if (request.hasProperty(""resourcetype"")) {
		 if (folder.isContact()) {
			 response.appendProperty(""D:resourcetype"", ""<D:collection/>"" + ""<E:addressbook/>"");
		 }
		 else if (folder.isCalendar() || folder.isTask()) {
			 response.appendProperty(""D:resourcetype"", ""<D:collection/>"" + ""<C:calendar/>"");
		 }
		 else {
			 response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
		 }
	 }
	 if (request.hasProperty(""owner"")) {
		 if (""users"".equals(request.getPathElement(1))) {
			 response.appendHrefProperty(""D:owner"", ""/principals/users/"" + request.getPathElement(2));
		 }
		 else {
			 response.appendHrefProperty(""D:owner"", ""/principals"" + request.getPath());
		 }
	 }
	 if (request.hasProperty(""getcontenttype"")) {
		 if (folder.isContact()) {
			 response.appendProperty(""D:getcontenttype"", ""text/x-vcard"");
		 }
		 else if (folder.isCalendar()) {
			 response.appendProperty(""D:getcontenttype"", ""text/calendar;
			 component=vevent"");
		 }
		 else if (folder.isTask()) {
			 response.appendProperty(""D:getcontenttype"", ""text/calendar;
			 component=vtodo"");
		 }
	 }
	 if (request.hasProperty(""getetag"")) {
		 response.appendProperty(""D:getetag"", folder.etag);
	 }
	 if (request.hasProperty(""getctag"")) {
		 response.appendProperty(""CS:getctag"", ""CS=\""http: IOUtil.encodeBase64AsString(folder.ctag));
	 }
	 if (request.hasProperty(""displayname"")) {
		 if (subFolder == null || subFolder.length() == 0) {
			 String displayname = request.getLastPath();
			 if (""calendar"".equals(displayname)) {
				 displayname = folder.displayName;
			 }
			 response.appendProperty(""D:displayname"", displayname);
		 }
		 else {
			 response.appendProperty(""D:displayname"", subFolder);
		 }
	 }
	 if (request.hasProperty(""calendar-description"")) {
		 response.appendProperty(""C:calendar-description"", """");
	 }
	 if (request.hasProperty(""supported-calendar-component-set"")) {
		 if (folder.isCalendar()) {
			 response.appendProperty(""C:supported-calendar-component-set"", ""<C:comp name=\""VEVENT\""/><C:comp name=\""VTODO\""/>"");
		 }
		 else if (folder.isTask()) {
			 response.appendProperty(""C:supported-calendar-component-set"", ""<C:comp name=\""VTODO\""/>"");
		 }
	 }
	 if (request.hasProperty(""current-user-privilege-set"")) {
		 response.appendProperty(""D:current-user-privilege-set"", ""<D:privilege><D:read/><D:write/></D:privilege>"");
	 }
	 response.endPropStatOK();
	 response.endResponse();
 }",0,0,1,0
"private static class add_schema_version_resultStandardScheme extends StandardScheme<add_schema_version_result> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, add_schema_version_result struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.o1 = new AlreadyExistsException();
					 struct.o1.read(iprot);
					 struct.setO1IsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.o2 = new NoSuchObjectException();
					 struct.o2.read(iprot);
					 struct.setO2IsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.o3 = new MetaException();
					 struct.o3.read(iprot);
					 struct.setO3IsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, add_schema_version_result struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.o1 != null) {
			 oprot.writeFieldBegin(O1_FIELD_DESC);
			 struct.o1.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.o2 != null) {
			 oprot.writeFieldBegin(O2_FIELD_DESC);
			 struct.o2.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.o3 != null) {
			 oprot.writeFieldBegin(O3_FIELD_DESC);
			 struct.o3.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
"private static void vswap(int[] fmap, int p1, int p2, int n) {
	 n += p1;
	 while (p1 < n) {
		 int t = fmap[p1];
		 fmap[p1++] = fmap[p2];
		 fmap[p2++] = t;
	 }
 }",0,0,0,0
"public static Message makeWriteResponseMessage(Message original, WriteResponse respose) throws IOException {
	 byte[] bytes = FBUtilities.serialize(respose, WriteResponse.serializer(), original.getVersion());
	 return original.getReply(FBUtilities.getBroadcastAddress(), bytes, original.getVersion());
 }",0,0,0,0
"public CMap parse( InputStream input ) throws IOException {
	 PushbackInputStream cmapStream = new PushbackInputStream( input );
	 CMap result = new CMap();
	 Object previousToken = null;
	 Object token = null;
	 while( (token = parseNextToken( cmapStream )) != null ) {
		 if( token instanceof Operator ) {
			 Operator op = (Operator)token;
			 if( op.op.equals( BEGIN_CODESPACE_RANGE ) ) {
				 Number cosCount = (Number)previousToken;
				 for( int j=0;
				 j<cosCount.intValue();
				 j++ ) {
					 byte[] startRange = (byte[])parseNextToken( cmapStream );
					 byte[] endRange = (byte[])parseNextToken( cmapStream );
					 CodespaceRange range = new CodespaceRange();
					 range.setStart( startRange );
					 range.setEnd( endRange );
					 result.addCodespaceRange( range );
				 }
			 }
			 else if( op.op.equals( BEGIN_BASE_FONT_CHAR ) ) {
				 Number cosCount = (Number)previousToken;
				 for( int j=0;
				 j<cosCount.intValue();
				 j++ ) {
					 byte[] inputCode = (byte[])parseNextToken( cmapStream );
					 Object nextToken = parseNextToken( cmapStream );
					 if( nextToken instanceof byte[] ) {
						 byte[] bytes = (byte[])nextToken;
						 String value = createStringFromBytes( bytes );
						 result.addMapping( inputCode, value );
					 }
					 else if( nextToken instanceof LiteralName ) {
						 result.addMapping( inputCode, ((LiteralName)nextToken).name );
					 }
					 else {
						 throw new IOException(MessageLocalization.getComposedMessage(""error.parsing.cmap.beginbfchar.expected.cosstring.or.cosname.and.not.1"", nextToken));
					 }
				 }
			 }
			 else if( op.op.equals( BEGIN_BASE_FONT_RANGE ) ) {
				 Number cosCount = (Number)previousToken;
				 for( int j=0;
				 j<cosCount.intValue();
				 j++ ) {
					 byte[] startCode = (byte[])parseNextToken( cmapStream );
					 byte[] endCode = (byte[])parseNextToken( cmapStream );
					 Object nextToken = parseNextToken( cmapStream );
					 List<byte[]> array = null;
					 byte[] tokenBytes = null;
					 if( nextToken instanceof List ) {
						 array = (List<byte[]>)nextToken;
						 tokenBytes = array.get( 0 );
					 }
					 else {
						 tokenBytes = (byte[])nextToken;
					 }
					 String value = null;
					 int arrayIndex = 0;
					 boolean done = false;
					 while( !done ) {
						 if( compare( startCode, endCode ) >= 0 ) {
							 done = true;
						 }
						 value = createStringFromBytes( tokenBytes );
						 result.addMapping( startCode, value );
						 increment( startCode );
						 if( array == null ) {
							 increment( tokenBytes );
						 }
						 else {
							 arrayIndex++;
							 if( arrayIndex < array.size() ) {
								 tokenBytes = array.get( arrayIndex );
							 }
						 }
					 }
				 }
			 }
		 }
		 previousToken = token;
	 }
	 return result;
 }",0,0,1,0
"public final void mRULE_ML_COMMENT() throws RecognitionException {
	 try {
		 int _type = RULE_ML_COMMENT;
		 int _channel = DEFAULT_TOKEN_CHANNEL;
		 {
			 match("""");
		 }
		 state.type = _type;
		 state.channel = _channel;
	 }
	 finally {
	 }
 }",0,0,1,0
"private void validate() throws BuildException {
	 if (null == inputDir) {
		 inputDir = getProject().getBaseDir();
	 }
	 if (null == destFile) {
		 final String message = ""Destfile must be set."";
		 throw new BuildException(message);
	 }
	 if (!inputDir.exists()) {
		 final String message = ""Cannot find base dir "" + inputDir.getAbsolutePath();
		 throw new BuildException(message);
	 }
	 if (null != usersFile && !usersFile.exists()) {
		 final String message = ""Cannot find user lookup list "" + usersFile.getAbsolutePath();
		 throw new BuildException(message);
	 }
	 if ((null != startTag || null != endTag) && (null != startDate || null != endDate)) {
		 final String message = ""Specify either a tag or date range,"" + "" not both"";
		 throw new BuildException(message);
	 }
 }",0,0,0,0
"public void unsetDb_name() {
	 this.db_name = null;
 }",0,0,0,0
"public class DFSShell extends ToolBase {
	 FileSystem fs;
	 public DFSShell() {
	 }
	 public void init() throws IOException {
		 conf.setQuietMode(true);
		 this.fs = FileSystem.get(conf);
	 }
	 void copyFromLocal(Path src, String dstf) throws IOException {
		 fs.copyFromLocalFile(src, new Path(dstf));
	 }
	 void moveFromLocal(Path src, String dstf) throws IOException {
		 fs.moveFromLocalFile(src, new Path(dstf));
	 }
	 void copyToLocal(String srcf, String dstf) throws IOException {
		 Path [] srcs = fs.globPaths( new Path(srcf) );
		 if( srcs.length > 1 && !new File( dstf ).isDirectory()) {
			 throw new IOException( ""When copy multiple files, "" + ""destination should be a directory."" );
		 }
		 Path dst = new Path( dstf );
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 fs.copyToLocalFile( srcs[i], dst );
		 }
	 }
	 void copyMergeToLocal(String srcf, Path dst) throws IOException {
		 copyMergeToLocal(srcf, dst, false);
	 }
	 void copyMergeToLocal(String srcf, Path dst, boolean endline) throws IOException {
		 Path [] srcs = fs.globPaths( new Path( srcf ) );
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 if(endline) {
				 FileUtil.copyMerge(fs, srcs[i], FileSystem.getNamed(""local"", conf), dst, false, conf, ""\n"");
			 }
			 else {
				 FileUtil.copyMerge(fs, srcs[i], FileSystem.getNamed(""local"", conf), dst, false, conf, null);
			 }
		 }
	 }
	 void moveToLocal(String srcf, Path dst) throws IOException {
		 System.err.println(""Option '-moveToLocal' is not implemented yet."");
	 }
	 void cat(String srcf) throws IOException {
		 Path [] srcs = fs.globPaths( new Path( srcf ) );
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 cat(srcs[i]);
		 }
	 }
	 private void cat(Path src) throws IOException {
		 FSDataInputStream in = fs.open(src);
		 try {
			 BufferedReader din = new BufferedReader(new InputStreamReader(in));
			 String line;
			 while((line = din.readLine()) != null) {
				 System.out.println(line);
			 }
		 }
		 finally {
			 in.close();
		 }
	 }
	 private void setReplication(String[] cmd, int pos) throws IOException {
		 if(cmd.length-pos<2 || (cmd.length-pos==2 && cmd[pos].equalsIgnoreCase(""-R""))) {
			 System.err.println(""Usage: [-R] <repvalue> <path>"");
			 System.exit(-1);
		 }
		 boolean recursive = false;
		 short rep = 3;
		 if(""-R"".equalsIgnoreCase(cmd[pos])) {
			 recursive=true;
			 pos++;
		 }
		 try {
			 rep = Short.parseShort(cmd[pos]);
			 pos++;
		 }
		 catch (NumberFormatException e) {
			 System.err.println(""Cannot set replication to: "" + cmd[pos]);
			 System.exit(-1);
		 }
		 setReplication(rep, cmd[pos], recursive);
	 }
	 public void setReplication(short newRep, String srcf, boolean recursive) throws IOException {
		 Path[] srcs = fs.globPaths( new Path(srcf) );
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 setReplication( newRep, srcs[i], recursive );
		 }
	 }
	 private void setReplication(short newRep, Path src, boolean recursive) throws IOException {
		 if(!fs.isDirectory(src)) {
			 setFileReplication(src, newRep);
			 return;
		 }
		 Path items[] = fs.listPaths(src);
		 if (items == null) {
			 throw new IOException(""Could not get listing for "" + src);
		 }
		 else {
			 for (int i = 0;
			 i < items.length;
			 i++) {
				 Path cur = items[i];
				 if(!fs.isDirectory(cur)) {
					 setFileReplication(cur, newRep);
				 }
				 else if(recursive) {
					 setReplication(newRep, cur, recursive);
				 }
			 }
		 }
	 }
	 private void setFileReplication(Path file, short newRep) throws IOException {
		 if(fs.setReplication(file, newRep)) {
			 System.out.println(""Replication "" + newRep + "" set: "" + file);
		 }
		 else {
			 System.err.println(""Could not set replication for: "" + file);
		 }
	 }
	 public void ls(String srcf, boolean recursive) throws IOException {
		 Path[] srcs = fs.globPaths( new Path(srcf) );
		 boolean printHeader = (srcs.length == 1) ? true: false;
		 for(int i=0;
		 i<srcs.length;
		 i++) {
			 ls(srcs[i], recursive, printHeader);
		 }
	 }
	 private void ls(Path src, boolean recursive, boolean printHeader ) throws IOException {
		 Path items[] = fs.listPaths(src);
		 if (items == null) {
			 throw new IOException(""Could not get listing for "" + src);
		 }
		 else {
			 if(!recursive && printHeader ) {
				 System.out.println(""Found "" + items.length + "" items"");
			 }
			 for (int i = 0;
			 i < items.length;
			 i++) {
				 Path cur = items[i];
				 System.out.println(cur + ""\t"" + (fs.isDirectory(cur) ? ""<dir>"" : (""<r "" + fs.getReplication(cur) + "">\t"" + fs.getLength(cur))));
				 if(recursive && fs.isDirectory(cur)) {
					 ls(cur, recursive, printHeader);
				 }
			 }
		 }
	 }
	 public void du(String src) throws IOException {
		 Path items[] = fs.listPaths( fs.globPaths( new Path(src) ) );
		 if (items == null) {
			 throw new IOException(""Could not get listing for "" + src);
		 }
		 else {
			 System.out.println(""Found "" + items.length + "" items"");
			 for (int i = 0;
			 i < items.length;
			 i++) {
				 DfsPath cur = (DfsPath) items[i];
				 System.out.println(cur + ""\t"" + cur.getContentsLength());
			 }
		 }
	 }
	 public void mkdir(String src) throws IOException {
		 Path f = new Path(src);
		 if (!fs.mkdirs(f)) {
			 throw new IOException(""Mkdirs failed to create "" + src);
		 }
	 }
	 public void rename(String srcf, String dstf) throws IOException {
		 Path [] srcs = fs.globPaths( new Path(srcf) );
		 Path dst = new Path(dstf);
		 if( srcs.length > 1 && !fs.isDirectory(dst)) {
			 throw new IOException( ""When moving multiple files, "" + ""destination should be a directory."" );
		 }
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 if (fs.rename(srcs[i], dst)) {
				 System.out.println(""Renamed "" + srcs[i] + "" to "" + dstf);
			 }
			 else {
				 System.out.println(""Rename failed "" + srcs[i]);
			 }
		 }
	 }
	 private int rename(String argv[], Configuration conf) throws IOException {
		 int i = 0;
		 int exitCode = 0;
		 String cmd = argv[i++];
		 String dest = argv[argv.length-1];
		 if (argv.length > 3) {
			 Path dst = new Path(dest);
			 if (!fs.isDirectory(dst)) {
				 throw new IOException( ""When moving multiple files, "" + ""destination "" + dest + "" should be a directory."" );
			 }
		 }
		 for (;
		 i < argv.length - 1;
		 i++) {
			 try {
				 rename(argv[i], dest);
			 }
			 catch (RemoteException e) {
				 exitCode = -1;
				 try {
					 String[] content;
					 content = e.getLocalizedMessage().split(""\n"");
					 System.err.println(cmd.substring(1) + "": "" + content[0]);
				 }
				 catch (Exception ex) {
					 System.err.println(cmd.substring(1) + "": "" + ex.getLocalizedMessage());
				 }
			 }
			 catch (IOException e) {
				 exitCode = -1;
				 System.err.println(cmd.substring(1) + "": "" + e.getLocalizedMessage());
			 }
		 }
		 return exitCode;
	 }
	 public void copy(String srcf, String dstf, Configuration conf) throws IOException {
		 Path [] srcs = fs.globPaths( new Path(srcf) );
		 Path dst = new Path(dstf);
		 if( srcs.length > 1 && !fs.isDirectory(dst)) {
			 throw new IOException( ""When copying multiple files, "" + ""destination should be a directory."" );
		 }
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 FileUtil.copy(fs, srcs[i], fs, dst, false, conf);
		 }
	 }
	 private int copy(String argv[], Configuration conf) throws IOException {
		 int i = 0;
		 int exitCode = 0;
		 String cmd = argv[i++];
		 String dest = argv[argv.length-1];
		 if (argv.length > 3) {
			 Path dst = new Path(dest);
			 if (!fs.isDirectory(dst)) {
				 throw new IOException( ""When copying multiple files, "" + ""destination "" + dest + "" should be a directory."" );
			 }
		 }
		 for (;
		 i < argv.length - 1;
		 i++) {
			 try {
				 copy(argv[i], dest, conf);
			 }
			 catch (RemoteException e) {
				 exitCode = -1;
				 try {
					 String[] content;
					 content = e.getLocalizedMessage().split(""\n"");
					 System.err.println(cmd.substring(1) + "": "" + content[0]);
				 }
				 catch (Exception ex) {
					 System.err.println(cmd.substring(1) + "": "" + ex.getLocalizedMessage());
				 }
			 }
			 catch (IOException e) {
				 exitCode = -1;
				 System.err.println(cmd.substring(1) + "": "" + e.getLocalizedMessage());
			 }
		 }
		 return exitCode;
	 }
	 public void delete(String srcf, boolean recursive) throws IOException {
		 Path [] srcs = fs.globPaths( new Path(srcf) );
		 for( int i=0;
		 i<srcs.length;
		 i++ ) {
			 delete(srcs[i], recursive);
		 }
	 }
	 private void delete(Path src, boolean recursive ) throws IOException {
		 if (fs.isDirectory(src) && !recursive) {
			 throw new IOException(""Cannot remove directory \"""" + src + ""\"", use -rmr instead"");
		 }
		 if (fs.delete(src)) {
			 System.out.println(""Deleted "" + src);
		 }
		 else {
			 throw new IOException(""Delete failed "" + src);
		 }
	 }
	 static String byteDesc(long len) {
		 double val = 0.0;
		 String ending = """";
		 if (len < 1024 * 1024) {
			 val = (1.0 * len) / 1024;
			 ending = "" k"";
		 }
		 else if (len < 1024 * 1024 * 1024) {
			 val = (1.0 * len) / (1024 * 1024);
			 ending = "" MB"";
		 }
		 else if (len < 128L * 1024 * 1024 * 1024 ) {
			 val = (1.0 * len) / (1024 * 1024 * 1024);
			 ending = "" GB"";
		 }
		 else if (len < 1024L * 1024 * 1024 * 1024 * 1024) {
			 val = (1.0 * len) / (1024L * 1024 * 1024 * 1024);
			 ending = "" TB"";
		 }
		 else {
			 val = (1.0 * len) / (1024L * 1024 * 1024 * 1024 * 1024);
			 ending = "" PB"";
		 }
		 return limitDecimal(val, 2) + ending;
	 }
	 static String limitDecimal(double d, int placesAfterDecimal) {
		 String strVal = Double.toString(d);
		 int decpt = strVal.indexOf(""."");
		 if (decpt >= 0) {
			 strVal = strVal.substring(0, Math.min(strVal.length(), decpt + 1 + placesAfterDecimal));
		 }
		 return strVal;
	 }
	 private int doall(String cmd, String argv[], Configuration conf, int startindex) {
		 int exitCode = 0;
		 int i = startindex;
		 for (;
		 i < argv.length;
		 i++) {
			 try {
				 if (""-cat"".equals(cmd)) {
					 cat(argv[i]);
				 }
				 else if (""-mkdir"".equals(cmd)) {
					 mkdir(argv[i]);
				 }
				 else if (""-rm"".equals(cmd)) {
					 delete(argv[i], false);
				 }
				 else if (""-rmr"".equals(cmd)) {
					 delete(argv[i], true);
				 }
				 else if (""-du"".equals(cmd)) {
					 du(argv[i]);
				 }
				 else if (""-ls"".equals(cmd)) {
					 ls(argv[i], false);
				 }
				 else if (""-lsr"".equals(cmd)) {
					 ls(argv[i], true);
				 }
			 }
			 catch (RemoteException e) {
				 exitCode = -1;
				 try {
					 String[] content;
					 content = e.getLocalizedMessage().split(""\n"");
					 System.err.println(cmd.substring(1) + "": "" + content[0]);
				 }
				 catch (Exception ex) {
					 System.err.println(cmd.substring(1) + "": "" + ex.getLocalizedMessage());
				 }
			 }
			 catch (IOException e) {
				 exitCode = -1;
				 System.err.println(cmd.substring(1) + "": "" + e.getLocalizedMessage());
			 }
		 }
		 return exitCode;
	 }
	 public void printUsage(String cmd) {
		 if (""-fs"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" [-fs <local | namenode:port>]"");
		 }
		 else if (""-conf"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" [-conf <configuration file>]"");
		 }
		 else if (""-D"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" [-D <[property=value>]"");
		 }
		 else if (""-ls"".equals(cmd) || ""-lsr"".equals(cmd) || ""-du"".equals(cmd) || ""-rm"".equals(cmd) || ""-rmr"".equals(cmd) || ""-mkdir"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" ["" + cmd + "" <path>]"");
		 }
		 else if (""-mv"".equals(cmd) || ""-cp"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" ["" + cmd + "" <src> <dst>]"");
		 }
		 else if (""-put"".equals(cmd) || ""-copyFromLocal"".equals(cmd) || ""-moveFromLocal"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" ["" + cmd + "" <localsrc> <dst>]"");
		 }
		 else if (""-get"".equals(cmd) || ""-copyToLocal"".equals(cmd) || ""-moveToLocal"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" ["" + cmd + "" <src> <localdst>]"");
		 }
		 else if (""-cat"".equals(cmd)) {
			 System.out.println(""Usage: java DFSShell"" + "" ["" + cmd + "" <src>]"");
		 }
		 else if (""-get"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" ["" + cmd + "" <src> <localdst> [addnl]]"");
		 }
		 else if (""-setrep"".equals(cmd)) {
			 System.err.println(""Usage: java DFSShell"" + "" [-setrep [-R] <rep> <path/file>]"");
		 }
		 else {
			 System.err.println(""Usage: java DFSShell"");
			 System.err.println("" [-fs <local | namenode:port>]"");
			 System.err.println("" [-conf <configuration file>]"");
			 System.err.println("" [-D <[property=value>]"");
			 System.err.println("" [-ls <path>]"" );
			 System.err.println("" [-lsr <path>]"");
			 System.err.println("" [-du <path>]"");
			 System.err.println("" [-mv <src> <dst>]"");
			 System.err.println("" [-cp <src> <dst>]"");
			 System.err.println("" [-rm <path>]"");
			 System.err.println("" [-rmr <path>]"");
			 System.err.println("" [-put <localsrc> <dst>]"");
			 System.err.println("" [-copyFromLocal <localsrc> <dst>]"");
			 System.err.println("" [-moveFromLocal <localsrc> <dst>]"");
			 System.err.println("" [-get <src> <localdst>]"");
			 System.err.println("" [-getmerge <src> <localdst> [addnl]]"");
			 System.err.println("" [-cat <src>]"");
			 System.err.println("" [-copyToLocal <src> <localdst>]"");
			 System.err.println("" [-moveToLocal <src> <localdst>]"");
			 System.err.println("" [-mkdir <path>]"");
			 System.err.println("" [-setrep [-R] <rep> <path/file>]"");
		 }
	 }
	 public int run( String argv[] ) throws Exception {
		 if (argv.length < 1) {
			 printUsage("""");
			 return -1;
		 }
		 int exitCode = -1;
		 int i = 0;
		 String cmd = argv[i++];
		 if (""-put"".equals(cmd) || ""-get"".equals(cmd) || ""-copyFromLocal"".equals(cmd) || ""-moveFromLocal"".equals(cmd) || ""-copyToLocal"".equals(cmd) || ""-moveToLocal"".equals(cmd)) {
			 if (argv.length != 3) {
				 printUsage(cmd);
				 return exitCode;
			 }
		 }
		 else if (""-mv"".equals(cmd) || ""-cp"".equals(cmd)) {
			 if (argv.length < 3) {
				 printUsage(cmd);
				 return exitCode;
			 }
		 }
		 else if (""-rm"".equals(cmd) || ""-rmr"".equals(cmd) || ""-cat"".equals(cmd) || ""-mkdir"".equals(cmd)) {
			 if (argv.length < 2) {
				 printUsage(cmd);
				 return exitCode;
			 }
		 }
		 try {
			 init();
		 }
		 catch (RPC.VersionMismatch v) {
			 System.err.println(""Version Mismatch between client and server"" + ""... command aborted."");
			 return exitCode;
		 }
		 catch (IOException e) {
			 System.err.println(""Bad connection to DFS... command aborted."");
			 return exitCode;
		 }
		 exitCode = 0;
		 try {
			 if (""-put"".equals(cmd) || ""-copyFromLocal"".equals(cmd)) {
				 copyFromLocal(new Path(argv[i++]), argv[i++]);
			 }
			 else if (""-moveFromLocal"".equals(cmd)) {
				 moveFromLocal(new Path(argv[i++]), argv[i++]);
			 }
			 else if (""-get"".equals(cmd) || ""-copyToLocal"".equals(cmd)) {
				 copyToLocal(argv[i++], argv[i++]);
			 }
			 else if (""-getmerge"".equals(cmd)) {
				 if(argv.length>i+2) copyMergeToLocal(argv[i++], new Path(argv[i++]), Boolean.parseBoolean(argv[i++]));
				 else copyMergeToLocal(argv[i++], new Path(argv[i++]));
			 }
			 else if (""-cat"".equals(cmd)) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else if (""-moveToLocal"".equals(cmd)) {
				 moveToLocal(argv[i++], new Path(argv[i++]));
			 }
			 else if (""-setrep"".equals(cmd)) {
				 setReplication(argv, i);
			 }
			 else if (""-ls"".equals(cmd)) {
				 if (i < argv.length) {
					 exitCode = doall(cmd, argv, conf, i);
				 }
				 else {
					 ls("""", false);
				 }
			 }
			 else if (""-lsr"".equals(cmd)) {
				 if (i < argv.length) {
					 exitCode = doall(cmd, argv, conf, i);
				 }
				 else {
					 ls("""", true);
				 }
			 }
			 else if (""-mv"".equals(cmd)) {
				 exitCode = rename(argv, conf);
			 }
			 else if (""-cp"".equals(cmd)) {
				 exitCode = copy(argv, conf);
			 }
			 else if (""-rm"".equals(cmd)) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else if (""-rmr"".equals(cmd)) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else if (""-du"".equals(cmd)) {
				 if (i < argv.length) {
					 exitCode = doall(cmd, argv, conf, i);
				 }
				 else {
					 du("""");
				 }
			 }
			 else if (""-mkdir"".equals(cmd)) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else {
				 exitCode = -1;
				 System.err.println(cmd.substring(1) + "": Unknown command"");
				 printUsage("""");
			 }
		 }
		 catch (RemoteException e) {
			 exitCode = -1;
			 try {
				 String[] content;
				 content = e.getLocalizedMessage().split(""\n"");
				 System.err.println(cmd.substring(1) + "": "" + content[0]);
			 }
			 catch (Exception ex) {
				 System.err.println(cmd.substring(1) + "": "" + ex.getLocalizedMessage());
			 }
		 }
		 catch (IOException e ) {
			 exitCode = -1;
			 System.err.println(cmd.substring(1) + "": "" + e.getLocalizedMessage());
		 }
		 finally {
			 fs.close();
		 }
		 return exitCode;
	 }
	 public static void main(String argv[]) throws Exception {
		 int res = new DFSShell().doMain(new Configuration(), argv);
		 System.exit(res);
	 }
}",0,0,0,0
"public class WeightedRunningAverage implements RunningAverage, Serializable {
	 private double totalWeight;
	 private double average;
	 public WeightedRunningAverage() {
		 totalWeight = 0.0;
		 average = Double.NaN;
	 }
	 public synchronized void addDatum(double datum) {
		 addDatum(datum, 1.0);
	 }
	 public synchronized void addDatum(double datum, double weight) {
		 double oldTotalWeight = totalWeight;
		 totalWeight += weight;
		 if (oldTotalWeight <= 0.0) {
			 average = datum;
		 }
		 else {
			 average = average * oldTotalWeight / totalWeight + datum * weight / totalWeight;
		 }
	 }
	 public synchronized void removeDatum(double datum) {
		 removeDatum(datum, 1.0);
	 }
	 public synchronized void removeDatum(double datum, double weight) {
		 double oldTotalWeight = totalWeight;
		 totalWeight -= weight;
		 if (totalWeight <= 0.0) {
			 average = Double.NaN;
			 totalWeight = 0.0;
		 }
		 else {
			 average = average * oldTotalWeight / totalWeight - datum * weight / totalWeight;
		 }
	 }
	 public synchronized void changeDatum(double delta) {
		 changeDatum(delta, 1.0);
	 }
	 public synchronized void changeDatum(double delta, double weight) {
		 Preconditions.checkArgument(weight <= totalWeight, ""weight must be <= totalWeight"");
		 average += delta * weight / totalWeight;
	 }
	 public synchronized double getTotalWeight() {
		 return totalWeight;
	 }
	 public synchronized int getCount() {
		 return (int) totalWeight;
	 }
	 public synchronized double getAverage() {
		 return average;
	 }
	 public RunningAverage inverse() {
		 return new InvertedRunningAverage(this);
	 }
	 public synchronized String toString() {
		 return String.valueOf(average);
	 }
}",0,0,0,0
"protected void handleErrorFlush(String output) {
	 if (realThing instanceof Task) {
		 ((Task) realThing).handleErrorOutput(output);
	 }
	 else {
		 super.handleErrorOutput(output);
	 }
 }",0,0,0,0
"public java.util.concurrent.Future<UpdateStackResponse> updateStack( final UpdateStackRequest request, final com.oracle.bmc.responses.AsyncHandler<UpdateStackRequest, UpdateStackResponse> handler) {
	 LOG.trace(""Called async updateStack"");
	 final UpdateStackRequest interceptedRequest = UpdateStackConverter.interceptRequest(request);
	 final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib = UpdateStackConverter.fromRequest(client, interceptedRequest);
	 final com.google.common.base.Function<javax.ws.rs.core.Response, UpdateStackResponse> transformer = UpdateStackConverter.fromResponse();
	 com.oracle.bmc.responses.AsyncHandler<UpdateStackRequest, UpdateStackResponse> handlerToUse = handler;
	 if (handler != null && this.authenticationDetailsProvider instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
		 handlerToUse = new com.oracle.bmc.util.internal.RefreshAuthTokenWrappingAsyncHandler< UpdateStackRequest, UpdateStackResponse>( (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) this.authenticationDetailsProvider, handler) {
			 public void retryCall() {
				 final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess = new com.oracle.bmc.http.internal.SuccessConsumer<>( this, transformer, interceptedRequest);
				 final com.oracle.bmc.util.internal.Consumer<Throwable> onError = new com.oracle.bmc.http.internal.ErrorConsumer<>( this, interceptedRequest);
				 client.put( ib, interceptedRequest.getUpdateStackDetails(), interceptedRequest, onSuccess, onError);
			 }
		 }
		;
	 }
	 final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess = (handler == null) ? null : new com.oracle.bmc.http.internal.SuccessConsumer<>( handlerToUse, transformer, interceptedRequest);
	 final com.oracle.bmc.util.internal.Consumer<Throwable> onError = (handler == null) ? null : new com.oracle.bmc.http.internal.ErrorConsumer<>( handlerToUse, interceptedRequest);
	 java.util.concurrent.Future<javax.ws.rs.core.Response> responseFuture = client.put( ib, interceptedRequest.getUpdateStackDetails(), interceptedRequest, onSuccess, onError);
	 if (this.authenticationDetailsProvider instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
		 return new com.oracle.bmc.util.internal.RefreshAuthTokenTransformingFuture< javax.ws.rs.core.Response, UpdateStackResponse>( responseFuture, transformer, (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) this.authenticationDetailsProvider, new com.google.common.base.Supplier< java.util.concurrent.Future<javax.ws.rs.core.Response>>() {
			 public java.util.concurrent.Future<javax.ws.rs.core.Response> get() {
				 return client.put( ib, interceptedRequest.getUpdateStackDetails(), interceptedRequest, onSuccess, onError);
			 }
		 }
		);
	 }
	 else {
		 return new com.oracle.bmc.util.internal.TransformingFuture<>( responseFuture, transformer);
	 }
 }",0,0,1,0
"public SiteEntity create(SiteEntity entity) {
	 Preconditions.checkNotNull(entity.getSiteId(), ""SiteId is null: "" + entity.getSiteId());
	 if (siteId2EntityMap.containsKey(entity.getSiteId())) {
		 throw new IllegalArgumentException(""Duplicated siteId: "" + entity.getSiteId());
	 }
	 entity.ensureDefault();
	 siteId2EntityMap.put(entity.getSiteId(), entity);
	 return entity;
 }",0,0,0,0
"private JPanel createSchedulerPanel() {
	JPanel p = new JPanel();
	p.setLayout(null);
	p.setOpaque(false);
	int y = 5;
	h = 30;
	JLabel lbl67 = new JLabel(StringResource.get(""Q_LIST_DESC""));
	lbl67.setForeground(Color.WHITE);
	lbl67.setFont(FontResource.getNormalFont());
	lbl67.setBounds(15, y, 350 - 30, h);
	p.add(lbl67);
	y += h;
	int h = 100;
	queueModel = new DefaultListModel<DownloadQueue>();
	qList = new JList<DownloadQueue>(queueModel);
	qList.setCellRenderer(new QueueListRenderer());
	qList.setBorder(null);
	qList.setOpaque(false);
	qList.setSelectedIndex(0);
	qList.addListSelectionListener(this);
	JScrollPane jsp2 = new JScrollPane();
	jsp2.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
	jsp2.getViewport().setOpaque(false);
	jsp2.setViewportView(qList);
	jsp2.setBounds(15, y, 350 - 40, h);
	jsp2.setOpaque(false);
	DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
	jsp2.setVerticalScrollBar(scrollBar);
	jsp2.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
	p.add(jsp2);
	y += h;
	y += 10;
	h = 25;
	JButton btnSave = createButton2(""DESC_PASS_NEW"");
	btnSave.setName(""BTN_Q_NEW"");
	btnSave.setBounds(15, y, 80, h);
	p.add(btnSave);
	JButton btnDel = createButton2(""DESC_PASS_DEL"");
	btnDel.setName(""BTN_Q_DEL"");
	btnDel.setBounds(15 + 80 + 10, y, 80, h);
	p.add(btnDel);
	JButton btnNew = createButton2(""DESC_SAVE_Q"");
	btnNew.setName(""BTN_Q_SAVE"");
	btnNew.setBounds(350 - 25 - 80, y, 80, h);
	p.add(btnNew);
	y += h;
	y += 20;
	h = 30;
	JLabel lbl6 = new JLabel(StringResource.get(""MSG_QNAME""));
	lbl6.setForeground(Color.WHITE);
	lbl6.setFont(FontResource.getNormalFont());
	lbl6.setBounds(15, y, 350 - 30, h);
	p.add(lbl6);
	y += h;
	h = 25;
	txtQueueName = new JTextField();
	txtQueueName.setCaretColor(Color.WHITE);
	txtQueueName.setBounds(15, y, 350 - 30 - 10, h);
	txtQueueName.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtQueueName.setEditable(true);
	txtQueueName.setForeground(Color.WHITE);
	txtQueueName.setOpaque(false);
	p.add(txtQueueName);
	y += h;
	y += 20;
	h = 30;
	JLabel lbl69 = new JLabel(StringResource.get(""Q_LIST_FILES""));
	lbl69.setForeground(Color.WHITE);
	lbl69.setFont(FontResource.getNormalFont());
	lbl69.setBounds(15, y, 350 - 30, h);
	p.add(lbl69);
	y += h;
	h = 100;
	queuedItemsModel = new DefaultListModel<String>();
	qItemsList = new JList<String>(queuedItemsModel);
	qItemsList.setCellRenderer(new QueuedItemsRenderer());
	qItemsList.setBorder(null);
	qItemsList.setOpaque(false);
	qItemsList.addListSelectionListener(this);
	JScrollPane jsp3 = new JScrollPane();
	jsp3.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
	jsp3.getViewport().setOpaque(false);
	jsp3.setViewportView(qItemsList);
	jsp3.setBounds(15, y, 350 - 40, h);
	jsp3.setOpaque(false);
	DarkScrollBar scrollBar2 = new DarkScrollBar(JScrollBar.VERTICAL);
	jsp3.setVerticalScrollBar(scrollBar2);
	jsp3.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
	jsp3.setAutoscrolls(true);
	p.add(jsp3);
	y += h;
	y += 10;
	h = 25;
	JButton btnQMoveUp = createButton2(""Q_MOVE_UP"");
	btnQMoveUp.setName(""Q_MOVE_UP"");
	btnQMoveUp.setBounds(15, y, 100, h);
	p.add(btnQMoveUp);
	JButton btnQMoveDown = createButton2(""Q_MOVE_DN"");
	btnQMoveDown.setName(""Q_MOVE_DN"");
	btnQMoveDown.setBounds(15 + 100 + 5, y, 100, h);
	p.add(btnQMoveDown);
	btnQMoveTo = createButton2(""Q_MOVE_TO"");
	btnQMoveTo.setName(""Q_MOVE_TO"");
	btnQMoveTo.setBounds(350 - 25 - 100, y, 100, h);
	p.add(btnQMoveTo);
	y += h;
	y += 20;
	h = 30;
	JLabel lbl68 = new JLabel(StringResource.get(""Q_SCHEDULE_TXT""));
	lbl68.setForeground(Color.WHITE);
	lbl68.setFont(FontResource.getNormalFont());
	lbl68.setBounds(15, y, 350 - 30, h);
	p.add(lbl68);
	y += h;
	y += 10;
	h = 20;
	chkQStart = createCheckBox(""MSG_Q_START"");
	chkQStart.setBounds(15, y, 150, h);
	chkQStart.addActionListener(this);
	p.add(chkQStart);
	spinnerDateModel1 = new SpinnerDateModel(new Date(), null, null, Calendar.HOUR_OF_DAY);
	spStartTime = new JSpinner(spinnerDateModel1);
	spStartTime.setForeground(Color.WHITE);
	spStartTime.setBackground(ColorResource.getDarkBgColor());
	spStartTime.setBorder(null);
	JSpinner.DateEditor ed1 = new JSpinner.DateEditor(spStartTime, ""hh:mm a"");
	int n = ed1.getComponentCount();
	for (int i = 0;
	 i < n;
	 i++) {
		Component c = ed1.getComponent(i);
		if (c instanceof JTextField) {
			c.setForeground(Color.WHITE);
			c.setBackground(ColorResource.getDarkBtnColor());
		}
	}
	spStartTime.setEditor(ed1);
	spStartTime.setBounds(210, y, 115, h);
	p.add(spStartTime);
	y += h;
	y += 5;
	h = 20;
	chkQStop = createCheckBox(""MSG_Q_STOP"");
	chkQStop.setBounds(15, y, 150, h);
	p.add(chkQStop);
	spinnerDateModel2 = new SpinnerDateModel(new Date(), null, null, Calendar.HOUR_OF_DAY);
	spEndTime = new JSpinner(spinnerDateModel2);
	spEndTime.setBorder(null);
	JSpinner.DateEditor ed2 = new JSpinner.DateEditor(spEndTime, ""hh:mm a"");
	n = ed2.getComponentCount();
	for (int i = 0;
	 i < n;
	 i++) {
		Component c = ed2.getComponent(i);
		if (c instanceof JTextField) {
			c.setForeground(Color.WHITE);
			c.setBackground(ColorResource.getDarkBtnColor());
		}
	}
	spEndTime.setEditor(ed2);
	spEndTime.setBounds(210, y, 115, h);
	p.add(spEndTime);
	y += h;
	y += 20;
	ButtonGroup radioGroup = new ButtonGroup();
	h = 30;
	radOnetime = createRadioButton(""MSQ_Q_ONETIME"", FontResource.getNormalFont());
	radOnetime.setName(""Q_ONCE"");
	radOnetime.addActionListener(this);
	radOnetime.setBounds(15, y, 120, h);
	p.add(radOnetime);
	radOnetime.setEnabled(false);
	radioGroup.add(radOnetime);
	y += 5;
	h = 20;
	spinnerDateModel3 = new SpinnerDateModel(new Date(), DateTimeUtils.getBeginDate(), DateTimeUtils.getEndDate(),Calendar.DAY_OF_MONTH);
	spExecDate = new JSpinner(spinnerDateModel3);
	spExecDate.setBorder(null);
	JSpinner.DateEditor ed3 = new JSpinner.DateEditor(spExecDate, ""dd-MMM-yy"");
	n = ed3.getComponentCount();
	for (int i = 0;
	 i < n;
	 i++) {
		Component c = ed3.getComponent(i);
		if (c instanceof JTextField) {
			c.setForeground(Color.WHITE);
			c.setBackground(ColorResource.getDarkBtnColor());
		}
	}
	spExecDate.setEditor(ed3);
	spExecDate.setBounds(120, y, 205, h);
	p.add(spExecDate);
	y += h;
	y += 15;
	radPeriodic = createRadioButton(""MSG_Q_DAILY"", FontResource.getNormalFont());
	radPeriodic.setName(""Q_DAILY"");
	radPeriodic.addActionListener(this);
	radPeriodic.setBounds(15, y, 100, h);
	p.add(radPeriodic);
	radioGroup.add(radPeriodic);
	h = 20;
	int x = 120;
	chkDays = new JCheckBox[7];
	for (int i = 1;
	 i < 8;
	 i++) {
		JCheckBox chkDay = createCheckBox(""MSG_Q_D"" + i, FontResource.getNormalFont());
		chkDay.setBounds(x, y, 100, h);
		p.add(chkDay);
		chkDays[i - 1] = chkDay;
		x += 100;
		if (i % 2 == 0) {
			x = 120;
			y += h;
		}
	}
	y += h;
	y += 20;
	y += 50;
	p.setPreferredSize(new Dimension(350, y));
	return p;
}",0,0,1,0
"class CollectionJson<T> {
	private String version;
	private String href;
	private Links links;
	private List<CollectionJsonItem<T>> items;
	private List<CollectionJsonQuery> queries;
	private CollectionJsonTemplate template;
	private CollectionJsonError error;
	CollectionJson( String version, String href, Links links, List<CollectionJsonItem<T>> items, List<CollectionJsonQuery> queries, CollectionJsonTemplate template, CollectionJsonError error) {
		this.version = version;
		this.href = href;
		this.links = links == null ? Links.NONE : links;
		this.items = items == null ? Collections.emptyList() : items;
		this.queries = queries == null ? Collections.emptyList() : queries;
		this.template = template;
		this.error = error;
	}
	CollectionJson() {
		this(""1.0"", null, Links.NONE, Collections.emptyList(), null, null, null);
	}
	final CollectionJson<T> withItems(CollectionJsonItem<T>... items) {
		return withItems(Arrays.asList(items));
	}
	CollectionJson<T> withItems(List<CollectionJsonItem<T>> items) {
		return new CollectionJson<>(version, href, links, items, queries, template, error);
	}
	CollectionJson<T> withLinks(Link... links) {
		return withLinks(Links.of(links));
	}
	CollectionJson<T> withLinks(Links links) {
		return new CollectionJson<>(version, href, links, items, queries, template, error);
	}
	CollectionJson<T> withOwnSelfLink() {
		String href = this.href;
		if (href == null) {
			return this;
		}
		return withLinks(Links.of(new Link(href)).merge(MergeMode.SKIP_BY_REL, links));
	}
	boolean hasItems() {
		return !items.isEmpty();
	}
}",0,1,0,0
"public class StdSchedulerFactory implements SchedulerFactory {
	 public static final String PROPERTIES_FILE = ""org.quartz.properties"";
	 public static final String PROP_SCHED_INSTANCE_NAME = ""org.quartz.scheduler.instanceName"";
	 public static final String PROP_SCHED_INSTANCE_ID = ""org.quartz.scheduler.instanceId"";
	 public static final String PROP_SCHED_INSTANCE_ID_GENERATOR_PREFIX = ""org.quartz.scheduler.instanceIdGenerator"";
	 public static final String PROP_SCHED_INSTANCE_ID_GENERATOR_CLASS = PROP_SCHED_INSTANCE_ID_GENERATOR_PREFIX + "".class"";
	 public static final String PROP_SCHED_THREAD_NAME = ""org.quartz.scheduler.threadName"";
	 public static final String PROP_SCHED_SKIP_UPDATE_CHECK = ""org.quartz.scheduler.skipUpdateCheck"";
	 public static final String PROP_SCHED_JMX_EXPORT = ""org.quartz.scheduler.jmx.export"";
	 public static final String PROP_SCHED_JMX_OBJECT_NAME = ""org.quartz.scheduler.jmx.objectName"";
	 public static final String PROP_SCHED_JMX_PROXY = ""org.quartz.scheduler.jmx.proxy"";
	 public static final String PROP_SCHED_JMX_PROXY_CLASS = ""org.quartz.scheduler.jmx.proxy.class"";
	 public static final String PROP_SCHED_RMI_EXPORT = ""org.quartz.scheduler.rmi.export"";
	 public static final String PROP_SCHED_RMI_PROXY = ""org.quartz.scheduler.rmi.proxy"";
	 public static final String PROP_SCHED_RMI_HOST = ""org.quartz.scheduler.rmi.registryHost"";
	 public static final String PROP_SCHED_RMI_PORT = ""org.quartz.scheduler.rmi.registryPort"";
	 public static final String PROP_SCHED_RMI_SERVER_PORT = ""org.quartz.scheduler.rmi.serverPort"";
	 public static final String PROP_SCHED_RMI_CREATE_REGISTRY = ""org.quartz.scheduler.rmi.createRegistry"";
	 public static final String PROP_SCHED_RMI_BIND_NAME = ""org.quartz.scheduler.rmi.bindName"";
	 public static final String PROP_SCHED_WRAP_JOB_IN_USER_TX = ""org.quartz.scheduler.wrapJobExecutionInUserTransaction"";
	 public static final String PROP_SCHED_USER_TX_URL = ""org.quartz.scheduler.userTransactionURL"";
	 public static final String PROP_SCHED_IDLE_WAIT_TIME = ""org.quartz.scheduler.idleWaitTime"";
	 public static final String PROP_SCHED_DB_FAILURE_RETRY_INTERVAL = ""org.quartz.scheduler.dbFailureRetryInterval"";
	 public static final String PROP_SCHED_MAKE_SCHEDULER_THREAD_DAEMON = ""org.quartz.scheduler.makeSchedulerThreadDaemon"";
	 public static final String PROP_SCHED_SCHEDULER_THREADS_INHERIT_CONTEXT_CLASS_LOADER_OF_INITIALIZING_THREAD = ""org.quartz.scheduler.threadsInheritContextClassLoaderOfInitializer"";
	 public static final String PROP_SCHED_CLASS_LOAD_HELPER_CLASS = ""org.quartz.scheduler.classLoadHelper.class"";
	 public static final String PROP_SCHED_JOB_FACTORY_CLASS = ""org.quartz.scheduler.jobFactory.class"";
	 public static final String PROP_SCHED_JOB_FACTORY_PREFIX = ""org.quartz.scheduler.jobFactory"";
	 public static final String PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN = ""org.quartz.scheduler.interruptJobsOnShutdown"";
	 public static final String PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN_WITH_WAIT = ""org.quartz.scheduler.interruptJobsOnShutdownWithWait"";
	 public static final String PROP_SCHED_CONTEXT_PREFIX = ""org.quartz.context.key"";
	 public static final String PROP_THREAD_POOL_PREFIX = ""org.quartz.threadPool"";
	 public static final String PROP_THREAD_POOL_CLASS = ""org.quartz.threadPool.class"";
	 public static final String PROP_JOB_STORE_PREFIX = ""org.quartz.jobStore"";
	 public static final String PROP_JOB_STORE_LOCK_HANDLER_PREFIX = PROP_JOB_STORE_PREFIX + "".lockHandler"";
	 public static final String PROP_JOB_STORE_LOCK_HANDLER_CLASS = PROP_JOB_STORE_LOCK_HANDLER_PREFIX + "".class"";
	 public static final String PROP_TABLE_PREFIX = ""tablePrefix"";
	 public static final String PROP_JOB_STORE_CLASS = ""org.quartz.jobStore.class"";
	 public static final String PROP_JOB_STORE_USE_PROP = ""org.quartz.jobStore.useProperties"";
	 public static final String PROP_DATASOURCE_PREFIX = ""org.quartz.dataSource"";
	 public static final String PROP_CONNECTION_PROVIDER_CLASS = ""connectionProvider.class"";
	 public static final String PROP_DATASOURCE_DRIVER = ""driver"";
	 public static final String PROP_DATASOURCE_URL = ""URL"";
	 public static final String PROP_DATASOURCE_USER = ""user"";
	 public static final String PROP_DATASOURCE_PASSWORD = ""password"";
	 public static final String PROP_DATASOURCE_MAX_CONNECTIONS = ""maxConnections"";
	 public static final String PROP_DATASOURCE_VALIDATION_QUERY = ""validationQuery"";
	 public static final String PROP_DATASOURCE_JNDI_URL = ""jndiURL"";
	 public static final String PROP_DATASOURCE_JNDI_ALWAYS_LOOKUP = ""jndiAlwaysLookup"";
	 public static final String PROP_DATASOURCE_JNDI_INITIAL = ""java.naming.factory.initial"";
	 public static final String PROP_DATASOURCE_JNDI_PROVDER = ""java.naming.provider.url"";
	 public static final String PROP_DATASOURCE_JNDI_PRINCIPAL = ""java.naming.security.principal"";
	 public static final String PROP_DATASOURCE_JNDI_CREDENTIALS = ""java.naming.security.credentials"";
	 public static final String PROP_PLUGIN_PREFIX = ""org.quartz.plugin"";
	 public static final String PROP_PLUGIN_CLASS = ""class"";
	 public static final String PROP_JOB_LISTENER_PREFIX = ""org.quartz.jobListener"";
	 public static final String PROP_TRIGGER_LISTENER_PREFIX = ""org.quartz.triggerListener"";
	 public static final String PROP_LISTENER_CLASS = ""class"";
	 public static final String DEFAULT_INSTANCE_ID = ""NON_CLUSTERED"";
	 public static final String AUTO_GENERATE_INSTANCE_ID = ""AUTO"";
	 private SchedulerException initException = null;
	 private String propSrc = null;
	 private PropertiesParser cfg;
	 private final Logger log = LoggerFactory.getLogger(getClass());
	 public StdSchedulerFactory() {
	 }
	 public StdSchedulerFactory(Properties props) throws SchedulerException {
		 initialize(props);
	 }
	 public StdSchedulerFactory(String fileName) throws SchedulerException {
		 initialize(fileName);
	 }
	 public Logger getLog() {
		 return log;
	 }
	 public void initialize() throws SchedulerException {
		 if (cfg != null) {
			 return;
		 }
		 if (initException != null) {
			 throw initException;
		 }
		 String requestedFile = System.getProperty(PROPERTIES_FILE);
		 String propFileName = requestedFile != null ? requestedFile : ""quartz.properties"";
		 File propFile = new File(propFileName);
		 Properties props = new Properties();
		 InputStream in = null;
		 try {
			 if (propFile.exists()) {
				 try {
					 if (requestedFile != null) {
						 propSrc = ""specified file: '"" + requestedFile + ""'"";
					 }
					 else {
						 propSrc = ""default file in current working dir: 'quartz.properties'"";
					 }
					 in = new BufferedInputStream(new FileInputStream(propFileName));
					 props.load(in);
				 }
				 catch (IOException ioe) {
					 initException = new SchedulerException(""Properties file: '"" + propFileName + ""' could not be read."", ioe);
					 throw initException;
				 }
			 }
			 else if (requestedFile != null) {
				 in = Thread.currentThread().getContextClassLoader().getResourceAsStream(requestedFile);
				 if(in == null) {
					 initException = new SchedulerException(""Properties file: '"" + requestedFile + ""' could not be found."");
					 throw initException;
				 }
				 propSrc = ""specified file: '"" + requestedFile + ""' in the class resource path."";
				 in = new BufferedInputStream(in);
				 try {
					 props.load(in);
				 }
				 catch (IOException ioe) {
					 initException = new SchedulerException(""Properties file: '"" + requestedFile + ""' could not be read."", ioe);
					 throw initException;
				 }
			 }
			 else {
				 propSrc = ""default resource file in Quartz package: 'quartz.properties'"";
				 ClassLoader cl = getClass().getClassLoader();
				 if(cl == null) cl = findClassloader();
				 if(cl == null) throw new SchedulerConfigException(""Unable to find a class loader on the current thread or class."");
				 in = cl.getResourceAsStream( ""quartz.properties"");
				 if (in == null) {
					 in = cl.getResourceAsStream( ""/quartz.properties"");
				 }
				 if (in == null) {
					 in = cl.getResourceAsStream( ""org/quartz/quartz.properties"");
				 }
				 if (in == null) {
					 initException = new SchedulerException( ""Default quartz.properties not found in class path"");
					 throw initException;
				 }
				 try {
					 props.load(in);
				 }
				 catch (IOException ioe) {
					 initException = new SchedulerException( ""Resource properties file: 'org/quartz/quartz.properties' "" + ""could not be read from the classpath."", ioe);
					 throw initException;
				 }
			 }
		 }
		 finally {
			 if(in != null) {
				 try {
					 in.close();
				 }
				 catch(IOException ignore) {
				 }
			 }
		 }
		 initialize(overrideWithSysProps(props));
	 }
	 private Properties overrideWithSysProps(Properties props) {
		 Properties sysProps = null;
		 try {
			 sysProps = System.getProperties();
		 }
		 catch (AccessControlException e) {
			 getLog().warn( ""Skipping overriding quartz properties with System properties "" + ""during initialization because of an AccessControlException. "" + ""This is likely due to not having read/write access for "" + ""java.util.PropertyPermission as required by java.lang.System.getProperties(). "" + ""To resolve this warning, either add this permission to your policy file or "" + ""use a non-default version of initialize()."", e);
		 }
		 if (sysProps != null) {
			 props.putAll(sysProps);
		 }
		 return props;
	 }
	 public void initialize(String filename) throws SchedulerException {
		 if (cfg != null) {
			 return;
		 }
		 if (initException != null) {
			 throw initException;
		 }
		 InputStream is = null;
		 Properties props = new Properties();
		 is = Thread.currentThread().getContextClassLoader().getResourceAsStream(filename);
		 try {
			 if(is != null) {
				 is = new BufferedInputStream(is);
				 propSrc = ""the specified file : '"" + filename + ""' from the class resource path."";
			 }
			 else {
				 is = new BufferedInputStream(new FileInputStream(filename));
				 propSrc = ""the specified file : '"" + filename + ""'"";
			 }
			 props.load(is);
		 }
		 catch (IOException ioe) {
			 initException = new SchedulerException(""Properties file: '"" + filename + ""' could not be read."", ioe);
			 throw initException;
		 }
		 finally {
			 if(is != null) try {
				 is.close();
			 }
			 catch(IOException ignore) {
			}
		 }
		 initialize(props);
	 }
	 public void initialize(InputStream propertiesStream) throws SchedulerException {
		 if (cfg != null) {
			 return;
		 }
		 if (initException != null) {
			 throw initException;
		 }
		 Properties props = new Properties();
		 if (propertiesStream != null) {
			 try {
				 props.load(propertiesStream);
				 propSrc = ""an externally opened InputStream."";
			 }
			 catch (IOException e) {
				 initException = new SchedulerException( ""Error loading property data from InputStream"", e);
				 throw initException;
			 }
		 }
		 else {
			 initException = new SchedulerException( ""Error loading property data from InputStream - InputStream is null."");
			 throw initException;
		 }
		 initialize(props);
	 }
	 public void initialize(Properties props) throws SchedulerException {
		 if (propSrc == null) {
			 propSrc = ""an externally provided properties instance."";
		 }
		 this.cfg = new PropertiesParser(props);
	 }
	 private Scheduler instantiate() throws SchedulerException {
		 if (cfg == null) {
			 initialize();
		 }
		 if (initException != null) {
			 throw initException;
		 }
		 JobStore js = null;
		 ThreadPool tp = null;
		 QuartzScheduler qs = null;
		 SchedulingContext schedCtxt = null;
		 DBConnectionManager dbMgr = null;
		 String instanceIdGeneratorClass = null;
		 Properties tProps = null;
		 String userTXLocation = null;
		 boolean wrapJobInTx = false;
		 boolean autoId = false;
		 long idleWaitTime = -1;
		 long dbFailureRetry = -1;
		 String classLoadHelperClass;
		 String jobFactoryClass;
		 SchedulerRepository schedRep = SchedulerRepository.getInstance();
		 String schedName = cfg.getStringProperty(PROP_SCHED_INSTANCE_NAME, ""QuartzScheduler"");
		 String threadName = cfg.getStringProperty(PROP_SCHED_THREAD_NAME, schedName + ""_QuartzSchedulerThread"");
		 String schedInstId = cfg.getStringProperty(PROP_SCHED_INSTANCE_ID, DEFAULT_INSTANCE_ID);
		 if (schedInstId.equals(AUTO_GENERATE_INSTANCE_ID)) {
			 autoId = true;
			 instanceIdGeneratorClass = cfg.getStringProperty( PROP_SCHED_INSTANCE_ID_GENERATOR_CLASS, ""org.quartz.simpl.SimpleInstanceIdGenerator"");
		 }
		 userTXLocation = cfg.getStringProperty(PROP_SCHED_USER_TX_URL, userTXLocation);
		 if (userTXLocation != null && userTXLocation.trim().length() == 0) {
			 userTXLocation = null;
		 }
		 classLoadHelperClass = cfg.getStringProperty( PROP_SCHED_CLASS_LOAD_HELPER_CLASS, ""org.quartz.simpl.CascadingClassLoadHelper"");
		 wrapJobInTx = cfg.getBooleanProperty(PROP_SCHED_WRAP_JOB_IN_USER_TX, wrapJobInTx);
		 jobFactoryClass = cfg.getStringProperty( PROP_SCHED_JOB_FACTORY_CLASS, null);
		 idleWaitTime = cfg.getLongProperty(PROP_SCHED_IDLE_WAIT_TIME, idleWaitTime);
		 dbFailureRetry = cfg.getLongProperty( PROP_SCHED_DB_FAILURE_RETRY_INTERVAL, dbFailureRetry);
		 boolean makeSchedulerThreadDaemon = cfg.getBooleanProperty(PROP_SCHED_MAKE_SCHEDULER_THREAD_DAEMON);
		 boolean threadsInheritInitalizersClassLoader = cfg.getBooleanProperty(PROP_SCHED_SCHEDULER_THREADS_INHERIT_CONTEXT_CLASS_LOADER_OF_INITIALIZING_THREAD);
		 boolean skipUpdateCheck = cfg.getBooleanProperty(PROP_SCHED_SKIP_UPDATE_CHECK, false);
		 boolean interruptJobsOnShutdown = cfg.getBooleanProperty(PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, false);
		 boolean interruptJobsOnShutdownWithWait = cfg.getBooleanProperty(PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN_WITH_WAIT, false);
		 boolean jmxExport = cfg.getBooleanProperty(PROP_SCHED_JMX_EXPORT);
		 String jmxObjectName = cfg.getStringProperty(PROP_SCHED_JMX_OBJECT_NAME);
		 boolean jmxProxy = cfg.getBooleanProperty(PROP_SCHED_JMX_PROXY);
		 String jmxProxyClass = cfg.getStringProperty(PROP_SCHED_JMX_PROXY_CLASS);
		 boolean rmiExport = cfg.getBooleanProperty(PROP_SCHED_RMI_EXPORT, false);
		 boolean rmiProxy = cfg.getBooleanProperty(PROP_SCHED_RMI_PROXY, false);
		 String rmiHost = cfg.getStringProperty(PROP_SCHED_RMI_HOST, ""localhost"");
		 int rmiPort = cfg.getIntProperty(PROP_SCHED_RMI_PORT, 1099);
		 int rmiServerPort = cfg.getIntProperty(PROP_SCHED_RMI_SERVER_PORT, -1);
		 String rmiCreateRegistry = cfg.getStringProperty( PROP_SCHED_RMI_CREATE_REGISTRY, QuartzSchedulerResources.CREATE_REGISTRY_NEVER);
		 String rmiBindName = cfg.getStringProperty(PROP_SCHED_RMI_BIND_NAME);
		 if (jmxProxy && rmiProxy) {
			 throw new SchedulerConfigException(""Cannot proxy both RMI and JMX."");
		 }
		 Properties schedCtxtProps = cfg.getPropertyGroup(PROP_SCHED_CONTEXT_PREFIX, true);
		 if (rmiProxy) {
			 if (autoId) {
				 schedInstId = DEFAULT_INSTANCE_ID;
			 }
			 schedCtxt = new SchedulingContext();
			 schedCtxt.setInstanceId(schedInstId);
			 String uid = (rmiBindName == null) ? QuartzSchedulerResources.getUniqueIdentifier( schedName, schedInstId) : rmiBindName;
			 RemoteScheduler remoteScheduler = new RemoteScheduler(schedCtxt, uid, rmiHost, rmiPort);
			 schedRep.bind(remoteScheduler);
			 return remoteScheduler;
		 }
		 ClassLoadHelper loadHelper = null;
		 try {
			 loadHelper = (ClassLoadHelper) loadClass(classLoadHelperClass) .newInstance();
		 }
		 catch (Exception e) {
			 throw new SchedulerConfigException( ""Unable to instantiate class load helper class: "" + e.getMessage(), e);
		 }
		 loadHelper.initialize();
		 if (jmxProxy) {
			 if (autoId) {
				 schedInstId = DEFAULT_INSTANCE_ID;
			 }
			 if (jmxProxyClass == null) {
				 throw new SchedulerConfigException(""No JMX Proxy Scheduler class provided"");
			 }
			 RemoteMBeanScheduler jmxScheduler = null;
			 try {
				 jmxScheduler = (RemoteMBeanScheduler)loadHelper.loadClass(jmxProxyClass) .newInstance();
			 }
			 catch (Exception e) {
				 throw new SchedulerConfigException( ""Unable to instantiate RemoteMBeanScheduler class."", e);
			 }
			 schedCtxt = new SchedulingContext();
			 schedCtxt.setInstanceId(schedInstId);
			 if (jmxObjectName == null) {
				 jmxObjectName = QuartzSchedulerResources.generateJMXObjectName(schedName, schedInstId);
			 }
			 jmxScheduler.setSchedulingContext(schedCtxt);
			 jmxScheduler.setSchedulerObjectName(jmxObjectName);
			 tProps = cfg.getPropertyGroup(PROP_SCHED_JMX_PROXY, true);
			 try {
				 setBeanProps(jmxScheduler, tProps);
			 }
			 catch (Exception e) {
				 initException = new SchedulerException(""RemoteMBeanScheduler class '"" + jmxProxyClass + ""' props could not be configured."", e);
				 initException.setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 jmxScheduler.initialize();
			 schedRep.bind(jmxScheduler);
			 return jmxScheduler;
		 }
		 JobFactory jobFactory = null;
		 if(jobFactoryClass != null) {
			 try {
				 jobFactory = (JobFactory) loadHelper.loadClass(jobFactoryClass) .newInstance();
			 }
			 catch (Exception e) {
				 throw new SchedulerConfigException( ""Unable to instantiate JobFactory class: "" + e.getMessage(), e);
			 }
			 tProps = cfg.getPropertyGroup(PROP_SCHED_JOB_FACTORY_PREFIX, true);
			 try {
				 setBeanProps(jobFactory, tProps);
			 }
			 catch (Exception e) {
				 initException = new SchedulerException(""JobFactory class '"" + jobFactoryClass + ""' props could not be configured."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
		 }
		 InstanceIdGenerator instanceIdGenerator = null;
		 if(instanceIdGeneratorClass != null) {
			 try {
				 instanceIdGenerator = (InstanceIdGenerator) loadHelper.loadClass(instanceIdGeneratorClass) .newInstance();
			 }
			 catch (Exception e) {
				 throw new SchedulerConfigException( ""Unable to instantiate InstanceIdGenerator class: "" + e.getMessage(), e);
			 }
			 tProps = cfg.getPropertyGroup(PROP_SCHED_INSTANCE_ID_GENERATOR_PREFIX, true);
			 try {
				 setBeanProps(instanceIdGenerator, tProps);
			 }
			 catch (Exception e) {
				 initException = new SchedulerException(""InstanceIdGenerator class '"" + instanceIdGeneratorClass + ""' props could not be configured."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
		 }
		 String tpClass = cfg.getStringProperty(PROP_THREAD_POOL_CLASS, null);
		 if (tpClass == null) {
			 initException = new SchedulerException( ""ThreadPool class not specified. "", SchedulerException.ERR_BAD_CONFIGURATION);
			 throw initException;
		 }
		 try {
			 tp = (ThreadPool) loadHelper.loadClass(tpClass).newInstance();
		 }
		 catch (Exception e) {
			 initException = new SchedulerException(""ThreadPool class '"" + tpClass + ""' could not be instantiated."", e);
			 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
			 throw initException;
		 }
		 tProps = cfg.getPropertyGroup(PROP_THREAD_POOL_PREFIX, true);
		 try {
			 setBeanProps(tp, tProps);
		 }
		 catch (Exception e) {
			 initException = new SchedulerException(""ThreadPool class '"" + tpClass + ""' props could not be configured."", e);
			 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
			 throw initException;
		 }
		 String jsClass = cfg.getStringProperty(PROP_JOB_STORE_CLASS, RAMJobStore.class.getName());
		 if (jsClass == null) {
			 initException = new SchedulerException( ""JobStore class not specified. "", SchedulerException.ERR_BAD_CONFIGURATION);
			 throw initException;
		 }
		 try {
			 js = (JobStore) loadHelper.loadClass(jsClass).newInstance();
		 }
		 catch (Exception e) {
			 initException = new SchedulerException(""JobStore class '"" + jsClass + ""' could not be instantiated."", e);
			 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
			 throw initException;
		 }
		 SchedulerDetailsSetter.setDetails(js, schedName, schedInstId);
		 tProps = cfg.getPropertyGroup(PROP_JOB_STORE_PREFIX, true, new String[] {
		PROP_JOB_STORE_LOCK_HANDLER_PREFIX}
		);
		 try {
			 setBeanProps(js, tProps);
		 }
		 catch (Exception e) {
			 initException = new SchedulerException(""JobStore class '"" + jsClass + ""' props could not be configured."", e);
			 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
			 throw initException;
		 }
		 if (js instanceof JobStoreSupport) {
			 String lockHandlerClass = cfg.getStringProperty(PROP_JOB_STORE_LOCK_HANDLER_CLASS);
			 if (lockHandlerClass != null) {
				 try {
					 Semaphore lockHandler = (Semaphore)loadHelper.loadClass(lockHandlerClass).newInstance();
					 tProps = cfg.getPropertyGroup(PROP_JOB_STORE_LOCK_HANDLER_PREFIX, true);
					 if (lockHandler instanceof TablePrefixAware) {
						 tProps.setProperty( PROP_TABLE_PREFIX, ((JobStoreSupport)js).getTablePrefix());
					 }
					 try {
						 setBeanProps(lockHandler, tProps);
					 }
					 catch (Exception e) {
						 initException = new SchedulerException(""JobStore LockHandler class '"" + lockHandlerClass + ""' props could not be configured."", e);
						 initException.setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
						 throw initException;
					 }
					 ((JobStoreSupport)js).setLockHandler(lockHandler);
					 getLog().info(""Using custom data access locking (synchronization): "" + lockHandlerClass);
				 }
				 catch (Exception e) {
					 initException = new SchedulerException(""JobStore LockHandler class '"" + lockHandlerClass + ""' could not be instantiated."", e);
					 initException.setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
					 throw initException;
				 }
			 }
		 }
		 String[] dsNames = cfg.getPropertyGroups(PROP_DATASOURCE_PREFIX);
		 for (int i = 0;
		 i < dsNames.length;
		 i++) {
			 PropertiesParser pp = new PropertiesParser(cfg.getPropertyGroup( PROP_DATASOURCE_PREFIX + ""."" + dsNames[i], true));
			 String cpClass = pp.getStringProperty(PROP_CONNECTION_PROVIDER_CLASS, null);
			 if(cpClass != null) {
				 ConnectionProvider cp = null;
				 try {
					 cp = (ConnectionProvider) loadHelper.loadClass(cpClass).newInstance();
				 }
				 catch (Exception e) {
					 initException = new SchedulerException(""ConnectionProvider class '"" + cpClass + ""' could not be instantiated."", e);
					 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
					 throw initException;
				 }
				 try {
					 pp.getUnderlyingProperties().remove( PROP_CONNECTION_PROVIDER_CLASS);
					 setBeanProps(cp, pp.getUnderlyingProperties());
				 }
				 catch (Exception e) {
					 initException = new SchedulerException(""ConnectionProvider class '"" + cpClass + ""' props could not be configured."", e);
					 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
					 throw initException;
				 }
				 dbMgr = DBConnectionManager.getInstance();
				 dbMgr.addConnectionProvider(dsNames[i], cp);
			 }
			 else {
				 String dsJndi = pp.getStringProperty(PROP_DATASOURCE_JNDI_URL, null);
				 if (dsJndi != null) {
					 boolean dsAlwaysLookup = pp.getBooleanProperty( PROP_DATASOURCE_JNDI_ALWAYS_LOOKUP);
					 String dsJndiInitial = pp.getStringProperty( PROP_DATASOURCE_JNDI_INITIAL);
					 String dsJndiProvider = pp.getStringProperty( PROP_DATASOURCE_JNDI_PROVDER);
					 String dsJndiPrincipal = pp.getStringProperty( PROP_DATASOURCE_JNDI_PRINCIPAL);
					 String dsJndiCredentials = pp.getStringProperty( PROP_DATASOURCE_JNDI_CREDENTIALS);
					 Properties props = null;
					 if (null != dsJndiInitial || null != dsJndiProvider || null != dsJndiPrincipal || null != dsJndiCredentials) {
						 props = new Properties();
						 if (dsJndiInitial != null) {
							 props.put(PROP_DATASOURCE_JNDI_INITIAL, dsJndiInitial);
						 }
						 if (dsJndiProvider != null) {
							 props.put(PROP_DATASOURCE_JNDI_PROVDER, dsJndiProvider);
						 }
						 if (dsJndiPrincipal != null) {
							 props.put(PROP_DATASOURCE_JNDI_PRINCIPAL, dsJndiPrincipal);
						 }
						 if (dsJndiCredentials != null) {
							 props.put(PROP_DATASOURCE_JNDI_CREDENTIALS, dsJndiCredentials);
						 }
					 }
					 JNDIConnectionProvider cp = new JNDIConnectionProvider(dsJndi, props, dsAlwaysLookup);
					 dbMgr = DBConnectionManager.getInstance();
					 dbMgr.addConnectionProvider(dsNames[i], cp);
				 }
				 else {
					 String dsDriver = pp.getStringProperty(PROP_DATASOURCE_DRIVER);
					 String dsURL = pp.getStringProperty(PROP_DATASOURCE_URL);
					 String dsUser = pp.getStringProperty(PROP_DATASOURCE_USER, """");
					 String dsPass = pp.getStringProperty(PROP_DATASOURCE_PASSWORD, """");
					 int dsCnt = pp.getIntProperty(PROP_DATASOURCE_MAX_CONNECTIONS, 10);
					 String dsValidation = pp.getStringProperty(PROP_DATASOURCE_VALIDATION_QUERY);
					 if (dsDriver == null) {
						 initException = new SchedulerException( ""Driver not specified for DataSource: "" + dsNames[i]);
						 throw initException;
					 }
					 if (dsURL == null) {
						 initException = new SchedulerException( ""DB URL not specified for DataSource: "" + dsNames[i]);
						 throw initException;
					 }
					 try {
						 PoolingConnectionProvider cp = new PoolingConnectionProvider( dsDriver, dsURL, dsUser, dsPass, dsCnt, dsValidation);
						 dbMgr = DBConnectionManager.getInstance();
						 dbMgr.addConnectionProvider(dsNames[i], cp);
					 }
					 catch (SQLException sqle) {
						 initException = new SchedulerException( ""Could not initialize DataSource: "" + dsNames[i], sqle);
						 throw initException;
					 }
				 }
			 }
		 }
		 String[] pluginNames = cfg.getPropertyGroups(PROP_PLUGIN_PREFIX);
		 SchedulerPlugin[] plugins = new SchedulerPlugin[pluginNames.length];
		 for (int i = 0;
		 i < pluginNames.length;
		 i++) {
			 Properties pp = cfg.getPropertyGroup(PROP_PLUGIN_PREFIX + ""."" + pluginNames[i], true);
			 String plugInClass = pp.getProperty(PROP_PLUGIN_CLASS, null);
			 if (plugInClass == null) {
				 initException = new SchedulerException( ""SchedulerPlugin class not specified for plugin '"" + pluginNames[i] + ""'"", SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 SchedulerPlugin plugin = null;
			 try {
				 plugin = (SchedulerPlugin) loadHelper.loadClass(plugInClass).newInstance();
			 }
			 catch (Exception e) {
				 initException = new SchedulerException( ""SchedulerPlugin class '"" + plugInClass + ""' could not be instantiated."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 try {
				 setBeanProps(plugin, pp);
			 }
			 catch (Exception e) {
				 initException = new SchedulerException( ""JobStore SchedulerPlugin '"" + plugInClass + ""' props could not be configured."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 plugins[i] = plugin;
		 }
		 Class[] strArg = new Class[] {
		 String.class }
		;
		 String[] jobListenerNames = cfg.getPropertyGroups(PROP_JOB_LISTENER_PREFIX);
		 JobListener[] jobListeners = new JobListener[jobListenerNames.length];
		 for (int i = 0;
		 i < jobListenerNames.length;
		 i++) {
			 Properties lp = cfg.getPropertyGroup(PROP_JOB_LISTENER_PREFIX + ""."" + jobListenerNames[i], true);
			 String listenerClass = lp.getProperty(PROP_LISTENER_CLASS, null);
			 if (listenerClass == null) {
				 initException = new SchedulerException( ""JobListener class not specified for listener '"" + jobListenerNames[i] + ""'"", SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 JobListener listener = null;
			 try {
				 listener = (JobListener) loadHelper.loadClass(listenerClass).newInstance();
			 }
			 catch (Exception e) {
				 initException = new SchedulerException( ""JobListener class '"" + listenerClass + ""' could not be instantiated."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 try {
				 Method nameSetter = listener.getClass().getMethod(""setName"", strArg);
				 if(nameSetter != null) {
					 nameSetter.invoke(listener, new Object[] {
					jobListenerNames[i] }
					 );
				 }
				 setBeanProps(listener, lp);
			 }
			 catch (Exception e) {
				 initException = new SchedulerException( ""JobListener '"" + listenerClass + ""' props could not be configured."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 jobListeners[i] = listener;
		 }
		 String[] triggerListenerNames = cfg.getPropertyGroups(PROP_TRIGGER_LISTENER_PREFIX);
		 TriggerListener[] triggerListeners = new TriggerListener[triggerListenerNames.length];
		 for (int i = 0;
		 i < triggerListenerNames.length;
		 i++) {
			 Properties lp = cfg.getPropertyGroup(PROP_TRIGGER_LISTENER_PREFIX + ""."" + triggerListenerNames[i], true);
			 String listenerClass = lp.getProperty(PROP_LISTENER_CLASS, null);
			 if (listenerClass == null) {
				 initException = new SchedulerException( ""TriggerListener class not specified for listener '"" + triggerListenerNames[i] + ""'"", SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 TriggerListener listener = null;
			 try {
				 listener = (TriggerListener) loadHelper.loadClass(listenerClass).newInstance();
			 }
			 catch (Exception e) {
				 initException = new SchedulerException( ""TriggerListener class '"" + listenerClass + ""' could not be instantiated."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 try {
				 Method nameSetter = listener.getClass().getMethod(""setName"", strArg);
				 if(nameSetter != null) {
					 nameSetter.invoke(listener, new Object[] {
					triggerListenerNames[i] }
					 );
				 }
				 setBeanProps(listener, lp);
			 }
			 catch (Exception e) {
				 initException = new SchedulerException( ""TriggerListener '"" + listenerClass + ""' props could not be configured."", e);
				 initException .setErrorCode(SchedulerException.ERR_BAD_CONFIGURATION);
				 throw initException;
			 }
			 triggerListeners[i] = listener;
		 }
		 boolean tpInited = false;
		 boolean qsInited = false;
		 try {
			 JobRunShellFactory jrsf = null;
			 if (userTXLocation != null) {
				 UserTransactionHelper.setUserTxLocation(userTXLocation);
			 }
			 if (wrapJobInTx) {
				 jrsf = new JTAJobRunShellFactory();
			 }
			 else {
				 jrsf = new StdJobRunShellFactory();
			 }
			 if (autoId) {
				 try {
					 schedInstId = DEFAULT_INSTANCE_ID;
					 if (js.isClustered()) {
						 if (js.getClass().getName().equals(""org.terracotta.quartz.TerracottaJobStore"")) {
							 Class c = js.getClass();
							 Method m = c.getMethod(""getUUID"");
							 if (m == null) {
								 throw new RuntimeException(""TerracottaJobStore does not have expected UUID property."");
							 }
							 String uuid = (String) m.invoke(js);
							 schedInstId = ""TERRACOTTA_CLUSTERED_SCHEDULER,node="" + uuid;
						 }
						 else {
							 schedInstId = instanceIdGenerator.generateInstanceId();
						 }
					 }
				 }
				 catch (Exception e) {
					 getLog().error(""Couldn't generate instance Id!"", e);
					 throw new IllegalStateException(""Cannot run without an instance id."");
				 }
			 }
			 if (js instanceof JobStoreSupport) {
				 JobStoreSupport jjs = (JobStoreSupport)js;
				 jjs.setDbRetryInterval(dbFailureRetry);
				 if(threadsInheritInitalizersClassLoader) jjs.setThreadsInheritInitializersClassLoadContext(threadsInheritInitalizersClassLoader);
			 }
			 QuartzSchedulerResources rsrcs = new QuartzSchedulerResources();
			 rsrcs.setName(schedName);
			 rsrcs.setThreadName(threadName);
			 rsrcs.setInstanceId(schedInstId);
			 rsrcs.setJobRunShellFactory(jrsf);
			 rsrcs.setMakeSchedulerThreadDaemon(makeSchedulerThreadDaemon);
			 rsrcs.setThreadsInheritInitializersClassLoadContext(threadsInheritInitalizersClassLoader);
			 rsrcs.setRunUpdateCheck(!skipUpdateCheck);
			 rsrcs.setInterruptJobsOnShutdown(interruptJobsOnShutdownWithWait);
			 rsrcs.setInterruptJobsOnShutdownWithWait(interruptJobsOnShutdownWithWait);
			 rsrcs.setJMXExport(jmxExport);
			 rsrcs.setJMXObjectName(jmxObjectName);
			 if (rmiExport) {
				 rsrcs.setRMIRegistryHost(rmiHost);
				 rsrcs.setRMIRegistryPort(rmiPort);
				 rsrcs.setRMIServerPort(rmiServerPort);
				 rsrcs.setRMICreateRegistryStrategy(rmiCreateRegistry);
				 rsrcs.setRMIBindName(rmiBindName);
			 }
			 SchedulerDetailsSetter.setDetails(tp, schedName, schedInstId);
			 rsrcs.setThreadPool(tp);
			 if(tp instanceof SimpleThreadPool) {
				 ((SimpleThreadPool)tp).setThreadNamePrefix(schedName + ""_Worker"");
				 if(threadsInheritInitalizersClassLoader) ((SimpleThreadPool)tp).setThreadsInheritContextClassLoaderOfInitializingThread(threadsInheritInitalizersClassLoader);
			 }
			 tp.initialize();
			 tpInited = true;
			 rsrcs.setJobStore(js);
			 for (int i = 0;
			 i < plugins.length;
			 i++) {
				 rsrcs.addSchedulerPlugin(plugins[i]);
			 }
			 schedCtxt = new SchedulingContext();
			 schedCtxt.setInstanceId(rsrcs.getInstanceId());
			 qs = new QuartzScheduler(rsrcs, schedCtxt, idleWaitTime, dbFailureRetry);
			 qsInited = true;
			 Scheduler scheduler = instantiate(rsrcs, qs);
			 if(jobFactory != null) {
				 qs.setJobFactory(jobFactory);
			 }
			 for (int i = 0;
			 i < plugins.length;
			 i++) {
				 plugins[i].initialize(pluginNames[i], scheduler);
			 }
			 for (int i = 0;
			 i < jobListeners.length;
			 i++) {
				 qs.addGlobalJobListener(jobListeners[i]);
			 }
			 for (int i = 0;
			 i < triggerListeners.length;
			 i++) {
				 qs.addGlobalTriggerListener(triggerListeners[i]);
			 }
			 Iterator itr = schedCtxtProps.keySet().iterator();
			 while(itr.hasNext()) {
				 String key = (String) itr.next();
				 String val = schedCtxtProps.getProperty(key);
				 scheduler.getContext().put(key, val);
			 }
			 js.setInstanceId(schedInstId);
			 js.setInstanceName(schedName);
			 js.initialize(loadHelper, qs.getSchedulerSignaler());
			 jrsf.initialize(scheduler, schedCtxt);
			 qs.initialize();
			 getLog().info( ""Quartz scheduler '"" + scheduler.getSchedulerName() + ""' initialized from "" + propSrc);
			 getLog().info(""Quartz scheduler version: "" + qs.getVersion());
			 qs.addNoGCObject(schedRep);
			 if (dbMgr != null) {
				 qs.addNoGCObject(dbMgr);
			 }
			 schedRep.bind(scheduler);
			 return scheduler;
		 }
		 catch(SchedulerException e) {
			 if(qsInited) qs.shutdown(false);
			 else if(tpInited) tp.shutdown(false);
			 throw e;
		 }
		 catch(RuntimeException re) {
			 if(qsInited) qs.shutdown(false);
			 else if(tpInited) tp.shutdown(false);
			 throw re;
		 }
		 catch(Error re) {
			 if(qsInited) qs.shutdown(false);
			 else if(tpInited) tp.shutdown(false);
			 throw re;
		 }
	 }
	 protected Scheduler instantiate(QuartzSchedulerResources rsrcs, QuartzScheduler qs) {
		 SchedulingContext schedCtxt = new SchedulingContext();
		 schedCtxt.setInstanceId(rsrcs.getInstanceId());
		 Scheduler scheduler = new StdScheduler(qs, schedCtxt);
		 return scheduler;
	 }
	 private void setBeanProps(Object obj, Properties props) throws NoSuchMethodException, IllegalAccessException, java.lang.reflect.InvocationTargetException, IntrospectionException, SchedulerConfigException {
		 props.remove(""class"");
		 BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
		 PropertyDescriptor[] propDescs = bi.getPropertyDescriptors();
		 PropertiesParser pp = new PropertiesParser(props);
		 java.util.Enumeration keys = props.keys();
		 while (keys.hasMoreElements()) {
			 String name = (String) keys.nextElement();
			 String c = name.substring(0, 1).toUpperCase(Locale.US);
			 String methName = ""set"" + c + name.substring(1);
			 java.lang.reflect.Method setMeth = getSetMethod(methName, propDescs);
			 try {
				 if (setMeth == null) {
					 throw new NoSuchMethodException( ""No setter for property '"" + name + ""'"");
				 }
				 Class[] params = setMeth.getParameterTypes();
				 if (params.length != 1) {
					 throw new NoSuchMethodException( ""No 1-argument setter for property '"" + name + ""'"");
				 }
				 PropertiesParser refProps = pp;
				 String refName = pp.getStringProperty(name);
				 if(refName != null && refName.startsWith(""$@"")) {
					 refName = refName.substring(2);
					 refProps = cfg;
				 }
				 else refName = name;
				 if (params[0].equals(int.class)) {
					 setMeth.invoke(obj, new Object[]{
					new Integer(refProps.getIntProperty(refName))}
					);
				 }
				 else if (params[0].equals(long.class)) {
					 setMeth.invoke(obj, new Object[]{
					new Long(refProps.getLongProperty(refName))}
					);
				 }
				 else if (params[0].equals(float.class)) {
					 setMeth.invoke(obj, new Object[]{
					new Float(refProps.getFloatProperty(refName))}
					);
				 }
				 else if (params[0].equals(double.class)) {
					 setMeth.invoke(obj, new Object[]{
					new Double(refProps.getDoubleProperty(refName))}
					);
				 }
				 else if (params[0].equals(boolean.class)) {
					 setMeth.invoke(obj, new Object[]{
					new Boolean(refProps.getBooleanProperty(refName))}
					);
				 }
				 else if (params[0].equals(String.class)) {
					 setMeth.invoke(obj, new Object[]{
					refProps.getStringProperty(refName)}
					);
				 }
				 else {
					 throw new NoSuchMethodException( ""No primitive-type setter for property '"" + name + ""'"");
				 }
			 }
			 catch (NumberFormatException nfe) {
				 throw new SchedulerConfigException(""Could not parse property '"" + name + ""' into correct data type: "" + nfe.toString());
			 }
		 }
	 }
	 private java.lang.reflect.Method getSetMethod(String name, PropertyDescriptor[] props) {
		 for (int i = 0;
		 i < props.length;
		 i++) {
			 java.lang.reflect.Method wMeth = props[i].getWriteMethod();
			 if (wMeth != null && wMeth.getName().equals(name)) {
				 return wMeth;
			 }
		 }
		 return null;
	 }
	 private Class loadClass(String className) throws ClassNotFoundException, SchedulerConfigException {
		 try {
			 ClassLoader cl = findClassloader();
			 if(cl != null) return cl.loadClass(className);
			 throw new SchedulerConfigException(""Unable to find a class loader on the current thread or class."");
		 }
		 catch (ClassNotFoundException e) {
			 if(getClass().getClassLoader() != null) return getClass().getClassLoader().loadClass(className);
			 throw e;
		 }
	 }
	 private ClassLoader findClassloader() {
		 if(Thread.currentThread().getContextClassLoader() == null && getClass().getClassLoader() != null) {
			 Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
		 }
		 return Thread.currentThread().getContextClassLoader();
	 }
	 private String getSchedulerName() {
		 return cfg.getStringProperty(PROP_SCHED_INSTANCE_NAME, ""QuartzScheduler"");
	 }
	 private String getSchedulerInstId() {
		 return cfg.getStringProperty(PROP_SCHED_INSTANCE_ID, DEFAULT_INSTANCE_ID);
	 }
	 public Scheduler getScheduler() throws SchedulerException {
		 if (cfg == null) {
			 initialize();
		 }
		 SchedulerRepository schedRep = SchedulerRepository.getInstance();
		 Scheduler sched = schedRep.lookup(getSchedulerName());
		 if (sched != null) {
			 if (sched.isShutdown()) {
				 schedRep.remove(getSchedulerName());
			 }
			 else {
				 return sched;
			 }
		 }
		 sched = instantiate();
		 return sched;
	 }
	 public static Scheduler getDefaultScheduler() throws SchedulerException {
		 StdSchedulerFactory fact = new StdSchedulerFactory();
		 return fact.getScheduler();
	 }
	 public Scheduler getScheduler(String schedName) throws SchedulerException {
		 return SchedulerRepository.getInstance().lookup(schedName);
	 }
	 public Collection getAllSchedulers() throws SchedulerException {
		 return SchedulerRepository.getInstance().lookupAll();
	 }
}",1,0,0,0
"protected XMLReader createDefaultReader() {
	 SAXParserFactory factory = SAXParserFactory.newInstance();
	 factory.setValidating(true);
	 factory.setNamespaceAware(true);
	 XMLReader reader = null;
	 try {
		 SAXParser saxParser = factory.newSAXParser();
		 reader = saxParser.getXMLReader();
	 }
	 catch (ParserConfigurationException e) {
		 throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
	 }
	 catch (SAXException e) {
		 throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
	 }
	 return reader;
 }",0,0,0,0
"public abstract class AbstractLs implements Command {
	 private static ResourceBundle bundle = CommandHelper.getBundle();
	 protected int longWidth = 9;
	 private int defaultMaxItems = 100;
	 private String maxItemsKey = ""maxItems"";
	 private boolean path;
	 protected void printFooter(Context ctx, Iterator iter) {
		 CommandHelper.getOutput(ctx).println();
		 CommandHelper.getOutput(ctx).println(bundle.getString(""word.total""));
		 if (iter instanceof NodeIterator) {
			 printFooter(ctx, (NodeIterator) iter);
		 }
		 else if (iter instanceof PropertyIterator) {
			 printFooter(ctx, (PropertyIterator) iter);
		 }
	 }
	 private void printFooter(Context ctx, NodeIterator iter) {
		 CommandHelper.getOutput(ctx).println( iter.getSize() + "" "" + bundle.getString(""word.nodes""));
	 }
	 private void printFooter(Context ctx, PropertyIterator iter) {
		 CommandHelper.getOutput(ctx).println( iter.getSize() + "" "" + bundle.getString(""word.properties""));
	 }
	 public int getDefaultMaxItems() {
		 return defaultMaxItems;
	 }
	 public void setDefaultMaxItems(int maxItems) {
		 this.defaultMaxItems = maxItems;
	 }
	 public boolean isPath() {
		 return path;
	 }
	 public void setPath(boolean path) {
		 this.path = path;
	 }
	 public String getMaxItemsKey() {
		 return maxItemsKey;
	 }
	 public void setMaxItemsKey(String maxItemsKey) {
		 this.maxItemsKey = maxItemsKey;
	 }
	 protected int getMaxItems(Context ctx) {
		 String maxItems = (String) ctx.get(this.maxItemsKey);
		 if (maxItems == null) {
			 maxItems = new Integer(this.defaultMaxItems).toString();
		 }
		 return Integer.valueOf(maxItems).intValue();
	 }
}",0,0,0,0
"int offerService() throws Exception {
	 long lastHeartbeat = 0;
	 this.fs = FileSystem.getNamed(jobClient.getFilesystemName(), this.fConf);
	 while (running) {
		 long now = System.currentTimeMillis();
		 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
		 if (waitTime > 0) {
			 try {
				 Thread.sleep(waitTime);
			 }
			 catch (InterruptedException ie) {
			 }
			 continue;
		 }
		 lastHeartbeat = now;
		 Vector taskReports = new Vector();
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 TaskStatus status = tip.createStatus();
				 taskReports.add(status);
				 if (status.getRunState() != TaskStatus.RUNNING) {
					 if (tip.getTask().isMapTask()) {
						 mapTotal--;
					 }
					 else {
						 reduceTotal--;
					 }
					 it.remove();
				 }
			 }
		 }
		 TaskTrackerStatus status = new TaskTrackerStatus(taskTrackerName, localHostname, mapOutputPort, taskReports, failures);
		 int resultCode = jobClient.emitHeartbeat(status, justStarted);
		 justStarted = false;
		 if (resultCode == InterTrackerProtocol.UNKNOWN_TASKTRACKER) {
			 return STALE_STATE;
		 }
		 try {
			 if (mapTotal < maxCurrentTasks || reduceTotal < maxCurrentTasks) {
				 Task t = jobClient.pollForNewTask(taskTrackerName);
				 if (t != null) {
					 startNewTask(t);
				 }
			 }
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem launching task: "" + StringUtils.stringifyException(ie));
		 }
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 long timeSinceLastReport = System.currentTimeMillis() - tip.getLastProgressReport();
				 if ((tip.getRunState() == TaskStatus.RUNNING) && (timeSinceLastReport > this.taskTimeout) && !tip.wasKilled) {
					 String msg = ""Task failed to report status for "" + (timeSinceLastReport / 1000) + "" seconds. Killing."";
					 LOG.info(tip.getTask().getTaskId() + "": "" + msg);
					 tip.reportDiagnosticInfo(msg);
					 try {
						 tip.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 try {
			 String[] toCloseIds = jobClient.pollForTaskWithClosedJob(taskTrackerName);
			 if (toCloseIds != null) {
				 synchronized (this) {
					 for (int i = 0;
					 i < toCloseIds.length;
					 i++) {
						 TaskInProgress tip = (TaskInProgress) tasks.get(toCloseIds[i]);
						 try {
							 tip.jobHasFinished();
						 }
						 catch (IOException ie) {
							 LOG.info(""problem finishing task: "" + StringUtils.stringifyException(ie));
						 }
					 }
				 }
			 }
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem getting closed tasks: "" + StringUtils.stringifyException(ie));
		 }
	 }
	 return 0;
 }",0,0,1,0
"class MapOutputLocation implements Writable {
	 static {
		 WritableFactories.setFactory (MapOutputLocation.class, new WritableFactory() {
			 public Writable newInstance() {
				 return new MapOutputLocation();
			 }
		 }
		);
	 }
	 private String mapTaskId;
	 private int mapId;
	 private String host;
	 private int port;
	 public MapOutputLocation() {
	 }
	 public MapOutputLocation(String mapTaskId, int mapId, String host, int port) {
		 this.mapTaskId = mapTaskId;
		 this.mapId = mapId;
		 this.host = host;
		 this.port = port;
	 }
	 public String getMapTaskId() {
		 return mapTaskId;
	 }
	 public int getMapId() {
		 return mapId;
	 }
	 public String getHost() {
		 return host;
	 }
	 public int getPort() {
		 return port;
	 }
	 public void write(DataOutput out) throws IOException {
		 UTF8.writeString(out, mapTaskId);
		 out.writeInt(mapId);
		 UTF8.writeString(out, host);
		 out.writeInt(port);
	 }
	 public void readFields(DataInput in) throws IOException {
		 this.mapTaskId = UTF8.readString(in);
		 this.mapId = in.readInt();
		 this.host = UTF8.readString(in);
		 this.port = in.readInt();
	 }
	 public String toString() {
		 return ""http: mapTaskId;
	 }
	 public long getFile(FileSystem fileSys, Path localFilename, int reduce, Progressable pingee) throws IOException {
		 boolean good = false;
		 long totalBytes = 0;
		 URL path = new URL(toString() + ""&reduce="" + reduce);
		 try {
			 URLConnection connection = path.openConnection();
			 InputStream input = connection.getInputStream();
			 try {
				 OutputStream output = fileSys.create(localFilename);
				 try {
					 byte[] buffer = new byte[64 * 1024];
					 int len = input.read(buffer);
					 while (len > 0) {
						 totalBytes += len;
						 output.write(buffer, 0 ,len);
						 if (pingee != null) {
							 pingee.progress();
						 }
						 len = input.read(buffer);
					 }
				 }
				 finally {
					 output.close();
				 }
			 }
			 finally {
				 input.close();
			 }
			 good = ((int) totalBytes) == connection.getContentLength();
			 if (!good) {
				 throw new IOException(""Incomplete map output received for "" + path + "" ("" + totalBytes + "" instead of "" + connection.getContentLength() + "")"");
			 }
		 }
		 finally {
			 if (!good) {
				 try {
					 fileSys.delete(localFilename);
					 totalBytes = 0;
				 }
				 catch (Throwable th) {
				 }
			 }
		 }
		 return totalBytes;
	 }
}",0,0,0,0
"public interface DevicePackageDownloadOperation {
	 KapuaId getId();
	 void setId(KapuaId id);
	 Integer getSize();
	 void setSize(Integer downloadSize);
	 Integer getProgress();
	 void setProgress(Integer downloadProgress);
	 DevicePackageDownloadStatus getStatus();
	 void setStatus(DevicePackageDownloadStatus status);
}",0,0,0,0
private float getYAlignFactor(JRPrintImage printImage);,0,0,0,0
"public class BookmarkablePageRequestTarget implements IBookmarkablePageRequestTarget{
	private Page page;
	private final WeakReference<Class<? extends Page>> pageClassRef;
	private final String pageMapName;
	private final PageParameters pageParameters;
	public <C extends Page> BookmarkablePageRequestTarget(Class<C> pageClass){
		this(null, pageClass);
	}
	public <C extends Page> BookmarkablePageRequestTarget(Class<C> pageClass,PageParameters pageParameters){
		this(null, pageClass, pageParameters);
	}
	public <C extends Page> BookmarkablePageRequestTarget(String pageMapName, Class<C> pageClass){
		this(pageMapName, pageClass, null);
	}
	public <C extends Page> BookmarkablePageRequestTarget(String pageMapName, Class<C> pageClass,PageParameters pageParameters){
		if (pageClass == null){
			throw new IllegalArgumentException(""Argument pageClass must be not null"");
		}
		if (!Page.class.isAssignableFrom(pageClass)){
			throw new IllegalArgumentException(""Argument pageClass must be an instance of "" +Page.class.getName());
		}
		pageClassRef = new WeakReference<Class<? extends Page>>(pageClass);
		this.pageParameters = (pageParameters == null) ? new PageParameters() : pageParameters;
		this.pageMapName = pageMapName;
	}
	public void detach(RequestCycle requestCycle){
		if (page != null){
			page.detach();
		}
	}
	public boolean equals(Object obj){
		boolean equal = false;
		if (obj != null && (obj instanceof BookmarkablePageRequestTarget)){
			BookmarkablePageRequestTarget that = (BookmarkablePageRequestTarget)obj;
			if (getPageClass().equals(that.getPageClass())){
				boolean mapMatch = false;
				if (pageMapName != null){
					mapMatch = (that.pageMapName != null && pageMapName.equals(that.pageMapName));
				}
				else{
					mapMatch = (that.pageMapName == null);
				}
				equal = mapMatch;
			}
		}
		return equal;
	}
	public final Page getPage(){
		return page;
	}
	protected final void setPage(Page page){
		this.page = page;
	}
	public final Class<? extends Page> getPageClass(){
		return pageClassRef.get();
	}
	public final String getPageMapName(){
		return pageMapName;
	}
	public final PageParameters getPageParameters(){
		return pageParameters;
	}
	public int hashCode(){
		int result = ""BookmarkablePageRequestTarget"".hashCode();
		result += getPageClass().hashCode();
		result += pageMapName != null ? pageMapName.hashCode() : 0;
		return 17 * result;
	}
	public void processEvents(RequestCycle requestCycle){
		if (!requestCycle.isRedirect()){
			page = getPage(requestCycle);
		}
	}
	public void respond(RequestCycle requestCycle){
		if (pageClassRef != null && pageClassRef.get() != null){
			if (requestCycle.isRedirect()){
				IRequestCycleProcessor processor = requestCycle.getProcessor();
				String redirectUrl = processor.getRequestCodingStrategy().encode(requestCycle, this).toString();
				if (redirectUrl.startsWith(""./"")){
					redirectUrl = redirectUrl.length() == 2 ? ""."" : redirectUrl.substring(2);
				}
				requestCycle.getResponse().redirect(redirectUrl);
			}
			else{
				getPage(requestCycle).renderPage();
			}
		}
	}
	public String toString(){
		return ""[BookmarkablePageRequestTarget@"" + hashCode() + "" pageClass="" +getPageClass().getName() + ""]"";
	}
	protected <C extends Page> Page newPage(final Class<C> pageClass,final RequestCycle requestCycle){
		IPageFactory pageFactory = requestCycle.getApplication().getSessionSettings().getPageFactory();
		if (pageParameters == null || pageParameters.size() == 0){
			return pageFactory.newPage(pageClass);
		}
		else{
			final Map<String, String[]> requestMap = requestCycle.getRequest().getParameterMap();
			requestMap.putAll(pageParameters.toRequestParameters());
			return pageFactory.newPage(pageClass, pageParameters);
		}
	}
	protected final Page getPage(RequestCycle requestCycle){
		if (page == null && !requestCycle.isRedirect()){
			page = newPage(getPageClass(), requestCycle);
		}
		return page;
	}
}",0,0,0,0
"public interface JsonObjectMapper<N, P> {
	default String toJson(Object value) throws IOException {
		return null;
	}
	default void toJson(Object value, Writer writer) throws IOException {
	}
	default N toJsonNode(Object value) throws IOException {
		return null;
	}
	default <T> T fromJson(Object json, Class<T> valueType) throws IOException {
		return null;
	}
	default <T> T fromJson(Object json, ResolvableType valueType) throws IOException {
		return null;
	}
	default <T> T fromJson(Object json, Map<String, Object> javaTypes) throws IOException {
		return null;
	}
	default <T> T fromJson(P parser, Type valueType) throws IOException {
		return null;
	}
	default void populateJavaTypes(Map<String, Object> map, Object object) {
		Class<?> targetClass = object.getClass();
		Class<?> contentClass = null;
		Class<?> keyClass = null;
		map.put(JsonHeaders.TYPE_ID, targetClass);
		if (object instanceof Collection && !((Collection<?>) object).isEmpty()) {
			Object firstElement = ((Collection<?>) object).iterator().next();
			if (firstElement != null) {
				contentClass = firstElement.getClass();
				map.put(JsonHeaders.CONTENT_TYPE_ID, contentClass);
			}
		}
		if (object instanceof Map && !((Map<?, ?>) object).isEmpty()) {
			Object firstValue = ((Map<?, ?>) object).values().iterator().next();
			if (firstValue != null) {
				contentClass = firstValue.getClass();
				map.put(JsonHeaders.CONTENT_TYPE_ID, contentClass);
			}
			Object firstKey = ((Map<?, ?>) object).keySet().iterator().next();
			if (firstKey != null) {
				keyClass = firstKey.getClass();
				map.put(JsonHeaders.KEY_TYPE_ID, keyClass);
			}
		}
		map.put(JsonHeaders.RESOLVABLE_TYPE, buildResolvableType(targetClass, contentClass, keyClass));
	}
	static ResolvableType buildResolvableType(Class<?> targetClass, Class<?> contentClass, Class<?> keyClass) {
		if (keyClass != null) {
			return TypeDescriptor.map(targetClass,TypeDescriptor.valueOf(keyClass),TypeDescriptor.valueOf(contentClass)).getResolvableType();
		}
		else if (contentClass != null) {
			return TypeDescriptor.collection(targetClass,TypeDescriptor.valueOf(contentClass)).getResolvableType();
		}
		else {
			return ResolvableType.forClass(targetClass);
		}
	}
}",1,0,0,0
"public class DotGraphReader {
	 static public DotGraph load(String dotContent) {
		 ByteArrayInputStream stream = new ByteArrayInputStream(dotContent.getBytes());
		 DOTParser dotParser = new DOTParser(stream);
		 DotGraph graph = null;
		 try {
			 graph = dotParser.Parse();
		 }
		 catch (ParseException pe) {
			 System.out.println(pe.getMessage());
			 throw new RuntimeException(""Bad Dot file"");
		 }
		 return graph;
	 }
	 static public DotGraph loadFromFile(String file) {
		 StringBuilder sb = new StringBuilder();
		 BufferedReader br = null;
		 try {
			 br = new BufferedReader(new FileReader(file));
			 String str;
			 while ((str = br.readLine()) != null) {
				 sb.append(str);
				 sb.append(""\n"");
			 }
		 }
		 catch (FileNotFoundException fnfe) {
			 throw new RuntimeException(""file:"" + file + "" not found!"");
		 }
		 catch (IOException ioe) {
			 throw new RuntimeException(""Error while reading from:"" + file);
		 }
		 return load(sb.toString());
	 }
}",1,0,0,0
"public static class PackageMapDistributor extends AtlasVirtualFile.DistributorBase {
	 private final PackageDistribution packageDistribution;
	 private final ExecutorService executorService;
	 PackageMapDistributor(ApplicationWriter writer, PackageDistribution packageDistribution, ExecutorService executorService) {
		 super(writer);
		 this.packageDistribution = packageDistribution;
		 this.executorService = executorService;
	 }
	 public Map<Integer, AtlasVirtualFile> run() throws ExecutionException, IOException {
		 assert this.nameToFileMap.size() == 1;
		 assert this.nameToFileMap.containsKey(0);
		 int maxReferencedIndex = this.packageDistribution.maxReferencedIndex();
		 for(int index = 1;
		 index <= maxReferencedIndex;
		 ++index) {
			 AtlasVirtualFile file = new AtlasVirtualFile(index, this.writer.namingLens);
			 this.nameToFileMap.put(index, file);
		 }
		 this.fillForMainDexList(this.classes);
		 this.classes = this.sortClassesByPackage(this.classes, this.originalNames);
		 Set<String> usedPrefixes = this.fillForDistribution(this.classes, this.originalNames);
		 Map newAssignments;
		 if (this.classes.isEmpty()) {
			 newAssignments = Collections.emptyMap();
		 }
		 else {
			 newAssignments = (new AtlasVirtualFile.PackageSplitPopulator(this.nameToFileMap, this.classes, this.originalNames, usedPrefixes, this.application.dexItemFactory, AtlasVirtualFile.FillStrategy.LEAVE_SPACE_FOR_GROWTH, this.writer.namingLens)).call();
			 if (!newAssignments.isEmpty() && this.nameToFileMap.size() > 1) {
				 System.err.println("" * The used package map is missing entries. The following default mappings have been used:"");
				 this.writeAssignments(newAssignments, new OutputStreamWriter(System.err));
				 System.err.println("" * Consider updating the map."");
			 }
		 }
		 Path newPackageMap = Paths.get(""package.map"");
		 System.out.println("" - "" + newPackageMap.toString());
		 PackageDistribution.writePackageToFileMap(newPackageMap, newAssignments, this.packageDistribution);
		 return this.nameToFileMap;
	 }
	 private Set<String> fillForDistribution(Set<DexProgramClass> classes, Map<DexProgramClass, String> originalNames) throws ExecutionException {
		 Set<String> usedPrefixes = null;
		 if (this.packageDistribution != null) {
			 ArrayList<Future<List<DexProgramClass>>> futures = new ArrayList(this.nameToFileMap.size());
			 usedPrefixes = this.packageDistribution.getFiles();
			 Iterator var5 = this.nameToFileMap.values().iterator();
			 while(var5.hasNext()) {
				 AtlasVirtualFile file = (AtlasVirtualFile)var5.next();
				 AtlasVirtualFile.PackageMapPopulator populator = new AtlasVirtualFile.PackageMapPopulator(file, classes, this.packageDistribution, originalNames);
				 futures.add(this.executorService.submit(populator));
			 }
			 ThreadUtils.awaitFutures(futures).forEach(classes::removeAll);
		 }
		 return usedPrefixes;
	 }
	 private void writeAssignments(Map<String, Integer> assignments, Writer output) throws IOException {
		 Iterator var3 = assignments.entrySet().iterator();
		 while(var3.hasNext()) {
			 Map.Entry<String, Integer> entry = (Map.Entry)var3.next();
			 output.write("" "");
			 PackageDistribution.formatEntry(entry, output);
			 output.write(""\n"");
		 }
		 output.flush();
	 }
 }",0,0,0,0
"public class PigServer {
	 protected final Log log = LogFactory.getLog(getClass());
	 public static final String PRETTY_PRINT_SCHEMA_PROPERTY = ""pig.pretty.print.schema"";
	 private static final String PIG_LOCATION_CHECK_STRICT = ""pig.location.check.strict"";
	 protected final Deque<Graph> graphs = new LinkedList<Graph>();
	 private Graph currDAG;
	 protected final PigContext pigContext;
	 private String jobName;
	 private String jobPriority;
	 private final static AtomicInteger scopeCounter = new AtomicInteger(0);
	 protected final String scope = constructScope();
	 private boolean validateEachStatement = false;
	 private boolean skipParseInRegisterForBatch = false;
	 private final BlackAndWhitelistFilter filter;
	 private String constructScope() {
		 return """" + scopeCounter.incrementAndGet();
	 }
	 public static void resetScope() {
		 scopeCounter.set(0);
	 }
	 public PigServer(String execTypeString) throws ExecException, IOException {
		 this(addExecTypeProperty(PropertiesUtil.loadDefaultProperties(), execTypeString));
	 }
	 public PigServer(String execTypeString, Properties properties) throws ExecException, IOException {
		 this(addExecTypeProperty(properties, execTypeString));
	 }
	 public PigServer(Properties properties) throws ExecException, IOException {
		 this(new PigContext(properties));
	 }
	 private static Properties addExecTypeProperty(Properties properties, String execType) {
		 properties.setProperty(""exectype"", execType);
		 return properties;
	 }
	 public PigServer(ExecType execType) throws ExecException {
		 this(execType, PropertiesUtil.loadDefaultProperties());
	 }
	 public PigServer(ExecType execType, Properties properties) throws ExecException {
		 this(new PigContext(execType, properties));
	 }
	 public PigServer(ExecType execType, Configuration conf) throws ExecException {
		 this(new PigContext(execType, conf));
	 }
	 public PigServer(PigContext context) throws ExecException {
		 this(context, true);
	 }
	 public PigServer(PigContext context, boolean connect) throws ExecException {
		 this.pigContext = context;
		 currDAG = new Graph(false);
		 jobName = pigContext.getProperties().getProperty( PigContext.JOB_NAME, PigContext.JOB_NAME_PREFIX + "":DefaultJobName"");
		 if (connect) {
			 pigContext.connect();
		 }
		 this.filter = new BlackAndWhitelistFilter(this);
		 addHadoopProperties();
		 addJarsFromProperties();
		 markPredeployedJarsFromProperties();
		 if (ScriptState.get() == null) {
			 ScriptState.start(pigContext.getExecutionEngine().instantiateScriptState());
		 }
		 PigStats.start(pigContext.getExecutionEngine().instantiatePigStats());
		 String auditId = PigATSClient.getPigAuditId(pigContext);
		 String callerId = (String)pigContext.getProperties().get(PigConfiguration.PIG_LOG_TRACE_ID);
		 log.info(""Pig Script ID for the session: "" + auditId);
		 if (callerId != null) {
			 log.info(""Caller ID for session: "" + callerId);
		 }
		 if (Boolean.parseBoolean(pigContext.getProperties() .getProperty(PigConfiguration.PIG_ATS_ENABLED))) {
			 if (Boolean.parseBoolean(pigContext.getProperties() .getProperty(""yarn.timeline-service.enabled"", ""false""))) {
				 PigATSClient.ATSEvent event = new PigATSClient.ATSEvent(auditId, callerId);
				 try {
					 PigATSClient.getInstance().logEvent(event);
				 }
				 catch (Exception e) {
					 log.warn(""Error posting to ATS: "", e);
				 }
			 }
			 else {
				 log.warn(""ATS is disabled since"" + "" yarn.timeline-service.enabled set to false"");
			 }
		 }
		 Class callerContextClass = null;
		 try {
			 callerContextClass = Class.forName(""org.apache.hadoop.ipc.CallerContext"");
		 }
		 catch (ClassNotFoundException e) {
		 }
		 if (callerContextClass != null) {
			 try {
				 Class callerContextBuilderClass = Class.forName(""org.apache.hadoop.ipc.CallerContext$Builder"");
				 Constructor callerContextBuilderConstruct = callerContextBuilderClass.getConstructor(String.class);
				 Object builder = callerContextBuilderConstruct.newInstance(auditId);
				 Method builderBuildMethod = builder.getClass().getMethod(""build"");
				 Object hdfsContext = builderBuildMethod.invoke(builder);
				 Method callerContextSetCurrentMethod = callerContextClass.getMethod(""setCurrent"", hdfsContext.getClass());
				 callerContextSetCurrentMethod.invoke(callerContextClass, hdfsContext);
			 }
			 catch (Exception e) {
				 throw new ExecException(e);
			 }
		 }
	 }
	 private void addHadoopProperties() throws ExecException {
		 String codecs = pigContext.getProperties().getProperty(""io.compression.codecs"");
		 if( codecs != null && codecs.contains(BZip2Codec.class.getCanonicalName() ) ) {
			 pigContext.getProperties().setProperty(""io.compression.codecs"", codecs + "","" + BZip2CodecWithExtensionBZ.class.getCanonicalName() );
		 }
	 }
	 private void addJarsFromProperties() throws ExecException {
		 String jar_str = pigContext.getProperties().getProperty(""pig.additional.jars"");
		 if (jar_str==null) {
			 jar_str = """";
		 }
		 jar_str = jar_str.replaceAll(File.pathSeparator, "","");
		 if (!jar_str.isEmpty()) {
			 jar_str += "","";
		 }
		 String jar_str_comma = pigContext.getProperties().getProperty(""pig.additional.jars.uris"");
		 if (jar_str_comma!=null && !jar_str_comma.isEmpty()) {
			 jar_str = jar_str + jar_str_comma;
		 }
		 if(jar_str != null && !jar_str.isEmpty()){
			 for(String jar : jar_str.split("","")){
				 try {
					 registerJar(jar);
				 }
				 catch (IOException e) {
					 int errCode = 4010;
					 String msg = ""Failed to register jar :"" + jar + "". Caught exception."";
					 throw new ExecException( msg, errCode, PigException.USER_ENVIRONMENT, e );
				 }
			 }
		 }
	 }
	 private void markPredeployedJarsFromProperties() throws ExecException {
		 String jar_str = pigContext.getProperties().getProperty(""pig.predeployed.jars"");
		 if(jar_str != null){
			 for(String jar : jar_str.split(File.pathSeparator)){
				 if (jar.length() > 0) {
					 pigContext.markJarAsPredeployed(jar);
				 }
			 }
		 }
	 }
	 public PigContext getPigContext(){
		 return pigContext;
	 }
	 public Graph getCurrentDAG() {
		 return this.currDAG;
	 }
	 public void debugOn() {
		 Logger.getLogger(""org.apache.pig"").setLevel(Level.DEBUG);
		 pigContext.getLog4jProperties().setProperty(""log4j.logger.org.apache.pig"", Level.DEBUG.toString());
	 }
	 public void debugOff() {
		 Logger.getLogger(""org.apache.pig"").setLevel(pigContext.getDefaultLogLevel());
		 pigContext.getLog4jProperties().setProperty(""log4j.logger.org.apache.pig"", pigContext.getDefaultLogLevel().toString());
	 }
	 public void setDefaultParallel(int p) {
		 pigContext.defaultParallel = p;
	 }
	 public void setBatchOn() {
		 log.debug(""Create a new graph."");
		 if (currDAG != null) {
			 graphs.push(currDAG);
		 }
		 currDAG = new Graph(true);
	 }
	 public boolean isBatchOn() {
		 return graphs.size() > 0;
	 }
	 public boolean isBatchEmpty() throws FrontendException {
		 if (currDAG == null) {
			 int errCode = 1083;
			 String msg = ""setBatchOn() must be called first."";
			 throw new FrontendException(msg, errCode, PigException.INPUT);
		 }
		 return currDAG.isBatchEmpty();
	 }
	 public void parseAndBuild() throws IOException {
		 if (currDAG == null || !isBatchOn()) {
			 int errCode = 1083;
			 String msg = ""setBatchOn() must be called first."";
			 throw new FrontendException(msg, errCode, PigException.INPUT);
		 }
		 currDAG.parseQuery();
		 currDAG.buildPlan( null );
	 }
	 public List<ExecJob> executeBatch() throws IOException {
		 return executeBatch(true);
	 }
	 public List<ExecJob> executeBatch(boolean parseAndBuild) throws IOException {
		 if (parseAndBuild) {
			 parseAndBuild();
		 }
		 PigStats stats = execute();
		 return getJobs(stats);
	 }
	 protected List<ExecJob> getJobs(PigStats stats) {
		 LinkedList<ExecJob> jobs = new LinkedList<ExecJob>();
		 if (stats instanceof EmptyPigStats) {
			 HJob job = new HJob(HJob.JOB_STATUS.COMPLETED, pigContext, stats.result(null) .getPOStore(), null);
			 jobs.add(job);
			 return jobs;
		 }
		 JobGraph jGraph = stats.getJobGraph();
		 Iterator<JobStats> iter = jGraph.iterator();
		 while (iter.hasNext()) {
			 JobStats js = iter.next();
			 for (OutputStats output : js.getOutputs()) {
				 if (js.isSuccessful()) {
					 jobs.add(new HJob(HJob.JOB_STATUS.COMPLETED, pigContext, output .getPOStore(), output.getAlias(), stats));
				 }
				 else {
					 HJob hjob = new HJob(HJob.JOB_STATUS.FAILED, pigContext, output .getPOStore(), output.getAlias(), stats);
					 hjob.setException(js.getException());
					 jobs.add(hjob);
				 }
			 }
		 }
		 return jobs;
	 }
	 public void discardBatch() throws FrontendException {
		 if (currDAG == null || !isBatchOn()) {
			 int errCode = 1083;
			 String msg = ""setBatchOn() must be called first."";
			 throw new FrontendException(msg, errCode, PigException.INPUT);
		 }
		 currDAG = graphs.pop();
	 }
	 public void addPathToSkip(String path) {
		 pigContext.addPathToSkip(path);
	 }
	 public void registerFunction(String function, FuncSpec funcSpec) {
		 pigContext.registerFunction(function, funcSpec);
	 }
	 public void registerStreamingCommand(String commandAlias, StreamingCommand command) {
		 pigContext.registerStreamCmd(commandAlias, command);
	 }
	 private URL locateJarFromResources(String jarName) throws IOException {
		 Enumeration<URL> urls = ClassLoader.getSystemResources(jarName);
		 URL resourceLocation = null;
		 if (urls.hasMoreElements()) {
			 resourceLocation = urls.nextElement();
		 }
		 if (urls.hasMoreElements()) {
			 StringBuffer sb = new StringBuffer(""Found multiple resources that match "");
			 sb.append(jarName);
			 sb.append("": "");
			 sb.append(resourceLocation);
			 while (urls.hasMoreElements()) {
				 sb.append(urls.nextElement());
				 sb.append("";
				 "");
			 }
			 log.debug(sb.toString());
		 }
		 return resourceLocation;
	 }
	 public void registerJar(String name) throws IOException {
		 filter.validate(PigCommandFilter.Command.REGISTER);
		 if (pigContext.hasJar(name)) {
			 log.debug(""Ignoring duplicate registration for jar "" + name);
			 return;
		 }
		 if (name != null) {
			 if (name.isEmpty()) {
				 log.warn(""Empty string specified for jar path"");
				 return;
			 }
			 URL resource = locateJarFromResources(name);
			 if (resource == null) {
				 FetchFileRet[] files = FileLocalizer.fetchFiles(pigContext.getProperties(), name);
				 for (FetchFileRet file : files) {
					 File f = file.file;
					 if (!f.canRead()) {
						 int errCode = 4002;
						 String msg = ""Can't read jar file: "" + name;
						 throw new FrontendException(msg, errCode, PigException.USER_ENVIRONMENT);
					 }
					 pigContext.addJar(f.toURI().toURL(), name);
				 }
			 }
			 else {
				 pigContext.addJar(resource, name);
			 }
		 }
	 }
	 public void registerCode(String path, String scriptingLang, String namespace) throws IOException {
		 if (pigContext.scriptingUDFs.containsKey(path) && pigContext.scriptingUDFs.get(path).equals(namespace)) {
			 log.debug(""Ignoring duplicate registration for scripting udf file "" + path + "" in namespace "" + namespace);
			 return;
		 }
		 else {
			 pigContext.scriptingUDFs.put(path, namespace);
		 }
		 FetchFileRet ret = FileLocalizer.fetchFile(pigContext.getProperties(), path);
		 File f = ret.file;
		 if (!f.canRead()) {
			 int errCode = 4002;
			 String msg = ""Can't read file: "" + path;
			 throw new FrontendException(msg, errCode, PigException.USER_ENVIRONMENT);
		 }
		 String cwd = new File(""."").getCanonicalPath();
		 String filePath = f.getCanonicalPath();
		 String nameInJar = filePath;
		 if (!ret.didFetch) {
			 if (!new File(path).isAbsolute() && path.indexOf(""."" + File.separator) == -1) {
				 nameInJar = path;
			 }
			 else if (filePath.equals(cwd + File.separator + path)) {
				 nameInJar = filePath.substring(cwd.length() + 1);
			 }
		 }
		 pigContext.addScriptFile(nameInJar, filePath);
		 if(scriptingLang != null) {
			 ScriptEngine se = ScriptEngine.getInstance(scriptingLang);
			 se.registerFunctions(nameInJar, namespace, pigContext);
		 }
	 }
	 public void registerQuery(String query, int startLine) throws IOException {
		 currDAG.registerQuery(query, startLine, validateEachStatement, skipParseInRegisterForBatch);
	 }
	 public void registerQuery(String query) throws IOException {
		 registerQuery(query, 1);
	 }
	 public void registerScript(InputStream in) throws IOException{
		 registerScript(in, null, null);
	 }
	 public void registerScript(InputStream in, Map<String,String> params) throws IOException{
		 registerScript(in, params, null);
	 }
	 public void registerScript(InputStream in, List<String> paramsFiles) throws IOException {
		 registerScript(in, null, paramsFiles);
	 }
	 public void registerScript(InputStream in, Map<String,String> params,List<String> paramsFiles) throws IOException {
		 try {
			 String script = IOUtils.toString(in);
			 ScriptState.get().setScript(script);
			 String substituted = pigContext.doParamSubstitution(new BufferedReader(new StringReader(script)), paramMapToList(params), paramsFiles);
			 GruntParser grunt = new GruntParser(new StringReader(substituted), this);
			 grunt.setInteractive(false);
			 grunt.parseStopOnError(true);
		 }
		 catch (org.apache.pig.tools.pigscript.parser.ParseException e) {
			 log.error(e.getLocalizedMessage());
			 throw new IOException(e);
		 }
	 }
	 protected List<String> paramMapToList(Map<String, String> params) {
		 List<String> paramList = new ArrayList<String>();
		 if (params != null) {
			 for (Map.Entry<String, String> entry : params.entrySet()) {
				 paramList.add(entry.getKey() + ""="" + entry.getValue());
			 }
		 }
		 return paramList;
	 }
	 protected Graph getClonedGraph() throws IOException {
		 Graph graph = currDAG.duplicate();
		 if (graph == null) {
			 int errCode = 2127;
			 String msg = ""Cloning of plan failed."";
			 throw new FrontendException(msg, errCode, PigException.BUG);
		 }
		 return graph;
	 }
	 public void registerScript(String fileName) throws IOException {
		 registerScript(fileName, null, null);
	 }
	 public void registerScript(String fileName, Map<String,String> params) throws IOException {
		 registerScript(fileName, params, null);
	 }
	 public void registerScript(String fileName, List<String> paramsFiles) throws IOException {
		 registerScript(fileName, null, paramsFiles);
	 }
	 public void registerScript(String fileName, Map<String,String> params,List<String> paramsFiles) throws IOException {
		 FileInputStream fis = null;
		 try{
			 fis = new FileInputStream(fileName);
			 ScriptState.get().setFileName(fileName);
			 registerScript(fis, params, paramsFiles);
		 }
		catch (FileNotFoundException e){
			 log.error(e.getLocalizedMessage());
			 throw new IOException(e);
		 }
		 finally {
			 if (fis != null) {
				 fis.close();
			 }
		 }
	 }
	 public void printAliases () throws FrontendException {
		 System.out.println(""aliases: "" + currDAG.getAliasOp().keySet());
	 }
	 public Schema dumpSchema(String alias) throws IOException {
		 try {
			 pigContext.inDumpSchema = true;
			 if (""@"".equals(alias)) {
				 alias = getLastRel();
			 }
			 LogicalRelationalOperator op = getOperatorForAlias( alias );
			 LogicalSchema schema = op.getSchema();
			 boolean pretty = ""true"".equals(pigContext.getProperties() .getProperty(PRETTY_PRINT_SCHEMA_PROPERTY));
			 if (schema != null) {
				 Schema s = org.apache.pig.newplan.logical.Util.translateSchema(schema);
				 System.out.println(alias + "": "" + (pretty ? s.prettyPrint() : s.toString()));
				 return s;
			 }
			 else {
				 System.out.println(""Schema for "" + alias + "" unknown."");
				 return null;
			 }
		 }
		 catch (FrontendException fee) {
			 int errCode = 1001;
			 String msg = ""Unable to describe schema for alias "" + alias;
			 throw new FrontendException (msg, errCode, PigException.INPUT, false, null, fee);
		 }
		 finally {
			 pigContext.inDumpSchema = false;
		 }
	 }
	 public Schema dumpSchemaNested(String alias, String nestedAlias) throws IOException {
		 try {
			 pigContext.inDumpSchema = true;
			 if (""@"".equals(alias)) {
				 alias = getLastRel();
			 }
			 Operator op = getOperatorForAlias( alias );
			 if( op instanceof LOForEach ) {
				 LogicalSchema nestedSc = ((LOForEach)op).dumpNestedSchema(alias, nestedAlias);
				 if (nestedSc!=null) {
					 Schema s = org.apache.pig.newplan.logical.Util.translateSchema(nestedSc);
					 System.out.println(alias+ ""::"" + nestedAlias + "": "" + s.toString());
					 return s;
				 }
				 else {
					 System.out.println(""Schema for ""+ alias+ ""::"" + nestedAlias + "" unknown."");
					 return null;
				 }
			 }
			 else {
				 int errCode = 1001;
				 String msg = ""Unable to describe schema for "" + alias + ""::"" + nestedAlias;
				 throw new FrontendException (msg, errCode, PigException.INPUT, false, null);
			 }
		 }
		 finally {
			 pigContext.inDumpSchema = false;
		 }
	 }
	 public void setJobName(String name) {
		 jobName = PigContext.JOB_NAME_PREFIX + "":"" + name;
	 }
	 public void setJobPriority(String priority) {
		 jobPriority = priority;
	 }
	 public Iterator<Tuple> openIterator(String id) throws IOException {
		 try {
			 pigContext.getProperties().setProperty( PigContext.JOB_NAME, jobName );
			 if( jobPriority != null ) {
				 pigContext.getProperties().setProperty( PigContext.JOB_PRIORITY, jobPriority );
			 }
			 ExecJob job = store(id, FileLocalizer.getTemporaryPath(pigContext) .toString(), Utils.getTmpFileCompressorName(pigContext) + ""()"");
			 if (job.getStatus() == JOB_STATUS.COMPLETED) {
				 return job.getResults();
			 }
			 else if (job.getStatus() == JOB_STATUS.FAILED && job.getException() != null) {
				 Exception e = job.getException();
				 int errCode = 1066;
				 String msg = ""Unable to open iterator for alias "" + id + "". Backend error : "" + e.getMessage();
				 throw new FrontendException(msg, errCode, PigException.INPUT, e);
			 }
			 else {
				 throw new IOException(""Job terminated with anomalous status "" + job.getStatus().toString());
			 }
		 }
		 catch (FrontendException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 int errCode = 1066;
			 String msg = ""Unable to open iterator for alias "" + id;
			 throw new FrontendException(msg, errCode, PigException.INPUT, e);
		 }
	 }
	 public ExecJob store(String id, String filename) throws IOException {
		 return store(id, filename, PigStorage.class.getName() + ""()"");
	 }
	 public ExecJob store(String id, String filename, String func) throws IOException {
		 PigStats stats = storeEx(id, filename, func);
		 if (stats.getOutputStats().size() < 1) {
			 throw new IOException(""Couldn't retrieve job."");
		 }
		 OutputStats output = stats.getOutputStats().get(0);
		 if(stats.isSuccessful()){
			 return new HJob(JOB_STATUS.COMPLETED, pigContext, output .getPOStore(), output.getAlias(), stats);
		 }
		else{
			 HJob job = new HJob(JOB_STATUS.FAILED, pigContext, output.getPOStore(), output.getAlias(), stats);
			 Exception ex = null;
			 for(JobStats js : stats.getJobGraph()){
				 if(js.getException() != null) {
					 ex = js.getException();
				 }
			 }
			 job.setException(ex);
			 return job;
		 }
	 }
	 private PigStats storeEx(String alias, String filename, String func) throws IOException {
		 if (""@"".equals(alias)) {
			 alias = getLastRel();
		 }
		 currDAG.parseQuery();
		 currDAG.skipStores();
		 currDAG.buildPlan( alias );
		 try {
			 QueryParserUtils.attachStorePlan(scope, currDAG.lp, filename, func, currDAG.getOperator( alias ), alias, pigContext);
			 currDAG.compile();
			 return executeCompiledLogicalPlan();
		 }
		 catch (PigException e) {
			 int errCode = 1002;
			 String msg = ""Unable to store alias "" + alias;
			 throw new PigException(msg, errCode, PigException.INPUT, e);
		 }
	 }
	 public void explain(String alias, PrintStream stream) throws IOException {
		 explain(alias, ""text"", true, false, stream, stream, null, null);
	 }
	 public void explain(String alias, String format, boolean verbose, boolean markAsExecute, PrintStream lps, PrintStream eps, File dir, String suffix) throws IOException {
		 try {
			 pigContext.inExplain = true;
			 buildStorePlan( alias );
			 currDAG.lp.optimize(pigContext);
			 if (format == ""xml"" && lps == eps) {
				 lps.println(""<plan>"");
			 }
			 currDAG.lp.explain(lps, format, verbose);
			 if( currDAG.lp.size() == 0 ) {
				 if (format == ""xml"" && lps == eps) {
					 lps.println(""</plan>"");
				 }
				 return;
			 }
			 pigContext.getExecutionEngine().explain(currDAG.lp, pigContext, eps, format, verbose, dir, suffix );
			 if (format.equals(""xml"") && lps == eps) {
				 lps.println(""</plan>"");
			 }
			 if (markAsExecute) {
				 currDAG.markAsExecuted();
			 }
		 }
		 catch (Exception e) {
			 int errCode = 1067;
			 String msg = ""Unable to explain alias "" + alias;
			 throw new FrontendException(msg, errCode, PigException.INPUT, e);
		 }
		 finally {
			 pigContext.inExplain = false;
		 }
	 }
	 public long capacity() throws IOException {
		 if (pigContext.getExecType().isLocal()) {
			 throw new IOException(""capacity only supported for non-local execution"");
		 }
		 else {
			 DataStorage dds = pigContext.getDfs();
			 Map<String, Object> stats = dds.getStatistics();
			 String rawCapacityStr = (String) stats.get(DataStorage.RAW_CAPACITY_KEY);
			 String rawUsedStr = (String) stats.get(DataStorage.RAW_USED_KEY);
			 if ((rawCapacityStr == null) || (rawUsedStr == null)) {
				 throw new IOException(""Failed to retrieve capacity stats"");
			 }
			 long rawCapacityBytes = new Long(rawCapacityStr).longValue();
			 long rawUsedBytes = new Long(rawUsedStr).longValue();
			 return rawCapacityBytes - rawUsedBytes;
		 }
	 }
	 public long fileSize(String filename) throws IOException {
		 DataStorage dfs = pigContext.getDfs();
		 ElementDescriptor elem = dfs.asElement(filename);
		 Map<String, Object> stats = elem.getStatistics();
		 long length = (Long) stats.get(ElementDescriptor.LENGTH_KEY);
		 int replication = (Short) stats .get(ElementDescriptor.BLOCK_REPLICATION_KEY);
		 return length * replication;
	 }
	 public boolean existsFile(String filename) throws IOException {
		 ElementDescriptor elem = pigContext.getDfs().asElement(filename);
		 return elem.exists();
	 }
	 public boolean deleteFile(String filename) throws IOException {
		 filter.validate(PigCommandFilter.Command.RM);
		 filter.validate(PigCommandFilter.Command.RMF);
		 ElementDescriptor elem = pigContext.getDfs().asElement(filename);
		 elem.delete();
		 return true;
	 }
	 public boolean renameFile(String source, String target) throws IOException {
		 filter.validate(PigCommandFilter.Command.MV);
		 pigContext.rename(source, target);
		 return true;
	 }
	 public boolean mkdirs(String dirs) throws IOException {
		 filter.validate(PigCommandFilter.Command.MKDIR);
		 ContainerDescriptor container = pigContext.getDfs().asContainer(dirs);
		 container.create();
		 return true;
	 }
	 public String[] listPaths(String dir) throws IOException {
		 filter.validate(PigCommandFilter.Command.LS);
		 Collection<String> allPaths = new ArrayList<String>();
		 ContainerDescriptor container = pigContext.getDfs().asContainer(dir);
		 Iterator<ElementDescriptor> iter = container.iterator();
		 while (iter.hasNext()) {
			 ElementDescriptor elem = iter.next();
			 allPaths.add(elem.toString());
		 }
		 String[] type = new String[1];
		 return allPaths.toArray(type);
	 }
	 public Map<String, LogicalPlan> getAliases() {
		 Map<String, LogicalPlan> aliasPlans = new HashMap<String, LogicalPlan>();
		 for (LogicalRelationalOperator op : currDAG.getAliases().keySet()) {
			 String alias = op.getAlias();
			 if(null != alias) {
				 aliasPlans.put(alias, currDAG.getAliases().get(op));
			 }
		 }
		 return aliasPlans;
	 }
	 public void shutdown() {
		 FileLocalizer.deleteTempFiles();
	 }
	 public Set<String> getAliasKeySet() {
		 return currDAG.getAliasOp().keySet();
	 }
	 public Map<Operator, DataBag> getExamples(String alias) throws IOException {
		 try {
			 if (currDAG.isBatchOn() && alias != null) {
				 currDAG.parseQuery();
				 currDAG.buildPlan( null );
				 execute();
			 }
			 currDAG.parseQuery();
			 currDAG.skipStores();
			 currDAG.buildPlan( alias );
			 currDAG.compile();
		 }
		 catch (IOException e) {
			 e.printStackTrace();
		 }
		 ExampleGenerator exgen = new ExampleGenerator( currDAG.lp, pigContext );
		 try {
			 return exgen.getExamples();
		 }
		 catch (ExecException e) {
			 e.printStackTrace(System.out);
			 throw new IOException(""ExecException"" , e);
		 }
		 catch (Exception e) {
			 e.printStackTrace(System.out);
			 throw new IOException(""Exception "", e);
		 }
	 }
	 public void printHistory(boolean withNumbers) {
		 List<String> sc = currDAG.getScriptCache();
		 if(!sc.isEmpty()) {
			 for(int i = 0 ;
			 i < sc.size();
			 i++) {
				 if(withNumbers) System.out.print((i+1)+"" "");
				 System.out.println(sc.get(i));
			 }
		 }
	 }
	 private void buildStorePlan(String alias) throws IOException {
		 currDAG.parseQuery();
		 currDAG.buildPlan( alias );
		 if( !isBatchOn() || alias != null ) {
			 QueryParserUtils.attachStorePlan(scope, currDAG.lp, ""fakefile"", null, currDAG.getOperator( alias ), ""fake"", pigContext );
		 }
		 currDAG.compile();
	 }
	 private PigStats execute() throws IOException {
		 pigContext.getProperties().setProperty( PigContext.JOB_NAME, jobName );
		 if( jobPriority != null ) {
			 pigContext.getProperties().setProperty( PigContext.JOB_PRIORITY, jobPriority );
		 }
		 currDAG.countExecutedStores();
		 currDAG.compile();
		 if( currDAG.lp.size() == 0 ) {
			 return PigStats.get();
		 }
		 pigContext.getProperties().setProperty(""pig.logical.plan.signature"", currDAG.lp.getSignature());
		 PigStats stats = executeCompiledLogicalPlan();
		 return stats;
	 }
	 private PigStats executeCompiledLogicalPlan() throws ExecException, FrontendException {
		 ScriptState.get().setScriptFeatures(currDAG.lp);
		 currDAG.lp.optimize(pigContext);
		 return launchPlan(currDAG.lp, ""job_pigexec_"");
	 }
	 protected PigStats launchPlan(LogicalPlan lp, String jobName) throws ExecException, FrontendException {
		 PigStats stats = null;
		 try {
			 stats = pigContext.getExecutionEngine().launchPig(lp, jobName, pigContext);
		 }
		 catch (ExecException e) {
			 throw e;
		 }
		 catch (FrontendException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 int errCode = 2043;
			 String msg = ""Unexpected error during execution."";
			 throw new ExecException(msg, errCode, PigException.BUG, e);
		 }
		 return stats;
	 }
	 private LogicalPlan buildLp() throws IOException {
		 currDAG.buildPlan( null);
		 currDAG.compile();
		 return currDAG.lp;
	 }
	 private LogicalRelationalOperator getOperatorForAlias(String alias) throws IOException {
		 buildStorePlan (alias);
		 LogicalRelationalOperator op = (LogicalRelationalOperator)currDAG.getOperator( alias );
		 if( op == null ) {
			 int errCode = 1005;
			 String msg = ""No plan for "" + alias + "" to describe"";
			 throw new FrontendException(msg, errCode, PigException.INPUT, false, null);
		 }
		 if( op instanceof LOForEach && ((LOForEach)op).getCasterForAsClause() != null) {
			 return ((LOForEach)op).getCasterForAsClause();
		 }
		 else {
			 return op;
		 }
	 }
	 public LogicalPlanData getLogicalPlanData() {
		 return new LogicalPlanData(currDAG.lp);
	 }
	 protected class Graph {
		 private final Map<LogicalRelationalOperator, LogicalPlan> aliases = new HashMap<LogicalRelationalOperator, LogicalPlan>();
		 private Map<String, Operator> operators = new HashMap<String, Operator>();
		 private String lastRel;
		 private final List<String> scriptCache = new ArrayList<String>();
		 private Map<String, String> fileNameMap = new HashMap<String, String>();
		 private final boolean batchMode;
		 private int processedStores = 0;
		 private LogicalPlan lp;
		 private int currentLineNum = 0;
		 public Graph(boolean batchMode) {
			 this.batchMode = batchMode;
			 this.lp = new LogicalPlan();
		 }
		;
		 private void countExecutedStores() throws FrontendException {
			 List<LOStore> sinks = Util.getLogicalRelationalOperators(lp, LOStore.class);
			 processedStores += sinks.size();
		 }
		 Map<LogicalRelationalOperator, LogicalPlan> getAliases() {
			 return aliases;
		 }
		 Map<String, Operator> getAliasOp() {
			 return operators;
		 }
		 boolean isBatchOn() {
			 return batchMode;
		 }
		;
		 boolean isBatchEmpty() {
			 for( Operator op : lp.getSinks() ) {
				 if( op instanceof LOStore ) return false;
			 }
			 return true;
		 }
		 void markAsExecuted() {
		 }
		 public LogicalPlan getLogicalPlan() {
			 return this.lp;
		 }
		 Operator getOperator(String alias) throws FrontendException {
			 return operators.get( alias );
		 }
		 public LogicalPlan getPlan(String alias) throws IOException {
			 LogicalPlan plan = lp;
			 if (alias != null) {
				 LogicalRelationalOperator op = (LogicalRelationalOperator) operators.get(alias);
				 if(op == null) {
					 int errCode = 1003;
					 String msg = ""Unable to find an operator for alias "" + alias;
					 throw new FrontendException(msg, errCode, PigException.INPUT);
				 }
				 plan = aliases.get(op);
			 }
			 return plan;
		 }
		 void buildPlan(String alias) throws IOException {
			 if( alias == null ) skipStores();
			 final Queue<Operator> queue = new LinkedList<Operator>();
			 if( alias != null ) {
				 Operator op = getOperator( alias );
				 if (op == null) {
					 String msg = ""Unable to find an operator for alias "" + alias;
					 throw new FrontendException( msg, 1003, PigException.INPUT );
				 }
				 queue.add( op );
			 }
			 else {
				 List<LOStore> stores = Util.getLogicalRelationalOperators(lp, LOStore.class);
				 for (LOStore op : stores) {
					 boolean addSink = true;
					 List<Operator> succs = lp.getSuccessors(op);
					 if (succs != null && succs.size() > 0) {
						 for (Operator succ : succs) {
							 if (!(succ instanceof LOLoad)) {
								 addSink = false;
								 break;
							 }
						 }
					 }
					 if (addSink) {
						 queue.add(op);
					 }
				 }
			 }
			 LogicalPlan plan = new LogicalPlan();
			 while( !queue.isEmpty() ) {
				 Operator currOp = queue.poll();
				 plan.add( currOp );
				 List<Operator> preds = lp.getPredecessors( currOp );
				 if( preds != null ) {
					 List<Operator> ops = new ArrayList<Operator>( preds );
					 for( Operator pred : ops ) {
						 if( !queue.contains( pred ) ) queue.add( pred );
						 plan.connect( pred, currOp );
					 }
				 }
				 currOp.accept( new AllExpressionVisitor( plan, new DependencyOrderWalker( plan ) ) {
					 protected LogicalExpressionVisitor getVisitor(LogicalExpressionPlan exprPlan) throws FrontendException {
						 return new LogicalExpressionVisitor( exprPlan, new DependencyOrderWalker( exprPlan ) ) {
							 public void visit(ScalarExpression expr) throws FrontendException {
								 Operator refOp = expr.getImplicitReferencedOperator();
								 if( !queue.contains( refOp ) ) queue.add( refOp );
							 }
						 }
						;
					 }
				 }
				 );
				 currOp.setPlan( plan );
			 }
			 lp = plan;
		 }
		 private void skipStores() throws IOException {
			 List<LOStore> sinks = Util.getLogicalRelationalOperators(lp, LOStore.class);
			 List<Operator> sinksToRemove = new ArrayList<Operator>();
			 int skipCount = processedStores;
			 if( skipCount > 0 ) {
				 for( LOStore sink : sinks ) {
					 sinksToRemove.add( sink );
					 skipCount--;
					 if( skipCount == 0 ) break;
				 }
			 }
			 for( Operator op : sinksToRemove ) {
				 removeToLoad(op);
				 Operator pred = lp.getPredecessors( op ).get(0);
				 lp.disconnect( pred, op );
				 lp.remove( op );
			 }
		 }
		 private void removeToLoad(Operator toRemove) throws IOException {
			 List<Operator> successors = lp.getSuccessors(toRemove);
			 List<Operator> succToRemove = new ArrayList<Operator>();
			 if (successors != null && successors.size() > 0) {
				 succToRemove.addAll(successors);
				 for (Operator succ : succToRemove) {
					 lp.disconnect( toRemove, succ );
					 if (!(succ instanceof LOLoad)) {
						 removeToLoad(succ);
						 lp.remove(succ);
					 }
				 }
			 }
		 }
		 void registerQuery(String query, int startLine, boolean validateEachStatement, boolean skipParseForBatch) throws IOException {
			 if( batchMode ) {
				 if( startLine == currentLineNum ) {
					 String line = scriptCache.remove( scriptCache.size() - 1 );
					 scriptCache.add( line + query );
				 }
				 else {
					 while( startLine > currentLineNum + 1 ) {
						 scriptCache.add( """" );
						 currentLineNum++;
					 }
					 BufferedReader br = new BufferedReader(new StringReader(query));
					 String line = br.readLine();
					 while (line != null) {
						 scriptCache.add(line);
						 currentLineNum++;
						 line = br.readLine();
					 }
				 }
				 if (skipParseForBatch) {
					 return;
				 }
			 }
			 else {
				 scriptCache.add( query );
			 }
			 if(validateEachStatement){
				 validateQuery();
			 }
			 parseQuery();
			 if( !batchMode ) {
				 buildPlan( null );
				 for( Operator sink : lp.getSinks() ) {
					 if( sink instanceof LOStore ) {
						 try {
							 execute();
						 }
						 catch (Exception e) {
							 int errCode = 1002;
							 String msg = ""Unable to store alias "" + ((LOStore) sink).getAlias();
							 throw new FrontendException(msg, errCode, PigException.INPUT, e);
						 }
						 break;
					 }
				 }
			 }
		 }
		 private void validateQuery() throws FrontendException {
			 String query = buildQuery();
			 QueryParserDriver parserDriver = new QueryParserDriver( pigContext, scope, fileNameMap );
			 try {
				 LogicalPlan plan = parserDriver.parse( query );
				 plan.validate(pigContext, scope, true);
			 }
			 catch(FrontendException ex) {
				 scriptCache.remove( scriptCache.size() -1 );
				 throw ex;
			 }
		 }
		 public List<String> getScriptCache() {
			 return scriptCache;
		 }
		 private void parseQuery() throws FrontendException {
			 UDFContext.getUDFContext().reset();
			 UDFContext.getUDFContext().setClientSystemProps(pigContext.getProperties());
			 String query = buildQuery();
			 if( query.isEmpty() ) {
				 lp = new LogicalPlan();
				 return;
			 }
			 try {
				 QueryParserDriver parserDriver = new QueryParserDriver( pigContext, scope, fileNameMap );
				 lp = parserDriver.parse( query );
				 operators = parserDriver.getOperators();
				 lastRel = parserDriver.getLastRel();
			 }
			 catch(Exception ex) {
				 scriptCache.remove( scriptCache.size() -1 );
				 PigException pe = LogUtils.getPigException(ex);
				 int errCode = 1000;
				 String msg = ""Error during parsing. "" + (pe == null ? ex.getMessage() : pe.getMessage());
				 log.error(""exception during parsing: "" + msg, ex);
				 if (null == pe) {
					 throw new FrontendException (msg, errCode, PigException.INPUT , ex);
				 }
				 else {
					 throw new FrontendException (msg, errCode, PigException.INPUT , ex, pe.getSourceLocation() );
				 }
			 }
		 }
		 public String getLastRel() {
			 return lastRel;
		 }
		 private String buildQuery() {
			 StringBuilder accuQuery = new StringBuilder();
			 for( String line : scriptCache ) {
				 accuQuery.append( line + ""\n"" );
			 }
			 return accuQuery.toString();
		 }
		 private void compile() throws IOException {
			 lp.validate(pigContext, scope, false);
			 currDAG.postProcess();
		 }
		 private void postProcess() throws IOException {
			 Set<LOLoad> loadOps = new HashSet<LOLoad>();
			 List<Operator> sources = lp.getSources();
			 for (Operator source : sources) {
				 if (source instanceof LOLoad) {
					 loadOps.add((LOLoad)source);
				 }
			 }
			 Set<LOStore> storeOps = new HashSet<LOStore>();
			 List<Operator> sinks = lp.getSinks();
			 for (Operator sink : sinks) {
				 if (sink instanceof LOStore) {
					 storeOps.add((LOStore)sink);
				 }
			 }
			 if (""true"".equals(pigContext.getProperties().getProperty(PIG_LOCATION_CHECK_STRICT))) {
				 log.info(""Output location strick check enabled"");
				 checkDuplicateStoreLoc(storeOps);
			 }
			 for (LOLoad load : loadOps) {
				 for (LOStore store : storeOps) {
					 String ifile = load.getFileSpec().getFileName();
					 String ofile = store.getFileSpec().getFileName();
					 if (ofile.equals(ifile)) {
						 if (!store.getPlan().pathExists(load, store)) {
							 store.getPlan().connect(store, load);
						 }
					 }
				 }
			 }
		 }
		 private void checkDuplicateStoreLoc(Set<LOStore> storeOps) {
			 Set<String> uniqueStoreLoc = new HashSet<String>();
			 for(LOStore store : storeOps) {
				 String fileName = store.getFileSpec().getFileName();
				 if(!uniqueStoreLoc.add(fileName) && UriUtil.isHDFSFileOrLocalOrS3N(fileName, new Configuration(true))) {
					 throw new RuntimeException(""Script contains 2 or more STORE statements writing to same location : ""+ fileName);
				 }
			 }
		 }
		 protected Graph duplicate() {
			 int lineNumber = 1;
			 Graph graph = new Graph(isBatchOn());
			 graph.processedStores = processedStores;
			 graph.fileNameMap = new HashMap<String, String>(fileNameMap);
			 try {
				 for (Iterator<String> it = scriptCache.iterator();
				 it.hasNext();
				 lineNumber++) {
					 graph.registerQuery(it.next(), lineNumber, false, false);
				 }
				 graph.postProcess();
			 }
			 catch (IOException ioe) {
				 ioe.printStackTrace();
				 graph = null;
			 }
			 return graph;
		 }
	 }
	 public void setValidateEachStatement(boolean validateEachStatement) {
		 this.validateEachStatement = validateEachStatement;
	 }
	 public void setSkipParseInRegisterForBatch(boolean skipParseInRegisterForBatch) {
		 this.skipParseInRegisterForBatch = skipParseInRegisterForBatch;
	 }
	 public String getLastRel() {
		 return currDAG.getLastRel();
	 }
	 public boolean isDebugOn() {
		 if (Logger.getLogger(""org.apache.pig"").getLevel() == Level.DEBUG) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public String getJobName() {
		 return jobName;
	 }
	 public String getJobPriority() {
		 return jobPriority;
	 }
}",1,0,0,0
"public class SimpleMessage implements Message {
	 private final MessageId messageId;
	 private final String subType;
	 private final String mediaType;
	 private final SharedInputStream content;
	 private final int bodyStartOctet;
	 private final Date internalDate;
	 private final long size;
	 private final Long textualLineCount;
	 private final List<Property> properties;
	 private final List<MessageAttachment> attachments;
	 public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List<Property> properties, List<MessageAttachment> attachments) {
		 this.messageId = messageId;
		 this.subType = subType;
		 this.mediaType = mediaType;
		 this.content = content;
		 this.bodyStartOctet = bodyStartOctet;
		 this.internalDate = internalDate;
		 this.size = size;
		 this.textualLineCount = textualLineCount;
		 this.properties = properties;
		 this.attachments = attachments;
	 }
	 public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List<Property> properties) {
		 this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.<MessageAttachment>of());
	 }
	 public MessageId getMessageId() {
		 return messageId;
	 }
	 public Date getInternalDate() {
		 return internalDate;
	 }
	 public InputStream getBodyContent() throws IOException {
		 return content.newStream(bodyStartOctet, -1);
	 }
	 public String getMediaType() {
		 return mediaType;
	 }
	 public String getSubType() {
		 return subType;
	 }
	 public long getBodyOctets() {
		 return getFullContentOctets() - bodyStartOctet;
	 }
	 public long getHeaderOctets() {
		 return bodyStartOctet;
	 }
	 public long getFullContentOctets() {
		 return size;
	 }
	 public Long getTextualLineCount() {
		 return textualLineCount;
	 }
	 public InputStream getHeaderContent() throws IOException {
		 long headerEnd = bodyStartOctet;
		 if (headerEnd < 0) {
			 headerEnd = 0;
		 }
		 return content.newStream(0, headerEnd);
	 }
	 public InputStream getFullContent() throws IOException {
		 return content.newStream(0, -1);
	 }
	 public List<Property> getProperties() {
		 return properties;
	 }
	 public List<MessageAttachment> getAttachments() {
		 return attachments;
	 }
}",1,1,0,0
"private static void header(PrintStream out, String section) {
	 out.println();
	 out.println(""-------------------------------------------"");
	 out.print("" "");
	 out.println(section);
	 out.println(""-------------------------------------------"");
 }",0,0,0,0
"private static class get_schema_with_environment_context_argsStandardScheme extends StandardScheme<get_schema_with_environment_context_args> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, get_schema_with_environment_context_args struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
					 struct.db_name = iprot.readString();
					 struct.setDb_nameIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
					 struct.table_name = iprot.readString();
					 struct.setTable_nameIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.environment_context = new EnvironmentContext();
					 struct.environment_context.read(iprot);
					 struct.setEnvironment_contextIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, get_schema_with_environment_context_args struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.db_name != null) {
			 oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
			 oprot.writeString(struct.db_name);
			 oprot.writeFieldEnd();
		 }
		 if (struct.table_name != null) {
			 oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
			 oprot.writeString(struct.table_name);
			 oprot.writeFieldEnd();
		 }
		 if (struct.environment_context != null) {
			 oprot.writeFieldBegin(ENVIRONMENT_CONTEXT_FIELD_DESC);
			 struct.environment_context.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
"public boolean setPropertyHook(String ns, String name, Object value, boolean inherited, boolean user, boolean isNew) {
	 if (getNext() != null) {
		 boolean subst = getNext().setPropertyHook(ns, name, value, inherited, user, isNew);
		 if (subst) {
			 return true;
		 }
	 }
	 return false;
 }",0,0,0,0
"private static final class NumberLiteralNode extends PrimitiveLiteralNode<Number> {
	 private static final long serialVersionUID = 1L;
	 private final Type type = numberGetType(value);
	 private NumberLiteralNode(final long token, final int finish, final Number value) {
		 super(Token.recast(token, TokenType.DECIMAL), finish, value);
	 }
	 private NumberLiteralNode(final NumberLiteralNode literalNode) {
		 super(literalNode);
	 }
	 private static Type numberGetType(final Number number) {
		 if (number instanceof Integer) {
			 return Type.INT;
		 }
		 else if (number instanceof Double) {
			 return Type.NUMBER;
		 }
		 else {
			 assert false;
		 }
		 return null;
	 }
	 public Type getType() {
		 return type;
	 }
	 public Type getWidestOperationType() {
		 return getType();
	 }
 }",0,1,0,0
"public void log(final int level, final Object obj1, final Object obj2, final Object obj3, final Object obj4, final Object obj5, final Object obj6, final Object obj7, final Object obj8);",0,0,0,1
"public class ColumnText {
	 public static final int AR_NOVOWEL = ArabicLigaturizer.ar_novowel;
	 public static final int AR_COMPOSEDTASHKEEL = ArabicLigaturizer.ar_composedtashkeel;
	 public static final int AR_LIG = ArabicLigaturizer.ar_lig;
	 public static final int DIGITS_EN2AN = ArabicLigaturizer.DIGITS_EN2AN;
	 public static final int DIGITS_AN2EN = ArabicLigaturizer.DIGITS_AN2EN;
	 public static final int DIGITS_EN2AN_INIT_LR = ArabicLigaturizer.DIGITS_EN2AN_INIT_LR;
	 public static final int DIGITS_EN2AN_INIT_AL = ArabicLigaturizer.DIGITS_EN2AN_INIT_AL;
	 public static final int DIGIT_TYPE_AN = ArabicLigaturizer.DIGIT_TYPE_AN;
	 public static final int DIGIT_TYPE_AN_EXTENDED = ArabicLigaturizer.DIGIT_TYPE_AN_EXTENDED;
	 protected int runDirection = PdfWriter.RUN_DIRECTION_DEFAULT;
	 public static final float GLOBAL_SPACE_CHAR_RATIO = 0;
	 public static final int START_COLUMN = 0;
	 public static final int NO_MORE_TEXT = 1;
	 public static final int NO_MORE_COLUMN = 2;
	 protected static final int LINE_STATUS_OK = 0;
	 protected static final int LINE_STATUS_OFFLIMITS = 1;
	 protected static final int LINE_STATUS_NOLINE = 2;
	 protected float maxY;
	 protected float minY;
	 protected float leftX;
	 protected float rightX;
	 protected int alignment = Element.ALIGN_LEFT;
	 protected ArrayList<float[]> leftWall;
	 protected ArrayList<float[]> rightWall;
	 protected BidiLine bidiLine;
	 protected float yLine;
	 protected float lastX;
	 protected float currentLeading = 16;
	 protected float fixedLeading = 16;
	 protected float multipliedLeading = 0;
	 protected PdfContentByte canvas;
	 protected PdfContentByte[] canvases;
	 protected int lineStatus;
	 protected float indent = 0;
	 protected float followingIndent = 0;
	 protected float rightIndent = 0;
	 protected float extraParagraphSpace = 0;
	 protected float rectangularWidth = -1;
	 protected boolean rectangularMode = false;
	 private float spaceCharRatio = GLOBAL_SPACE_CHAR_RATIO;
	 private boolean lastWasNewline = true;
	 private int linesWritten;
	 private float firstLineY;
	 private boolean firstLineYDone = false;
	 private int arabicOptions = 0;
	 protected float descender;
	 protected boolean composite = false;
	 protected ColumnText compositeColumn;
	 protected LinkedList<Element> compositeElements;
	 protected int listIdx = 0;
	 private boolean splittedRow;
	 protected Phrase waitPhrase;
	 private boolean useAscender = false;
	 private float filledWidth;
	 private boolean adjustFirstLine = true;
	 public ColumnText(PdfContentByte canvas) {
		 this.canvas = canvas;
	 }
	 public static ColumnText duplicate(ColumnText org) {
		 ColumnText ct = new ColumnText(null);
		 ct.setACopy(org);
		 return ct;
	 }
	 public ColumnText setACopy(ColumnText org) {
		 setSimpleVars(org);
		 if (org.bidiLine != null) bidiLine = new BidiLine(org.bidiLine);
		 return this;
	 }
	 protected void setSimpleVars(ColumnText org) {
		 maxY = org.maxY;
		 minY = org.minY;
		 alignment = org.alignment;
		 leftWall = null;
		 if (org.leftWall != null) leftWall = new ArrayList<float[]>(org.leftWall);
		 rightWall = null;
		 if (org.rightWall != null) rightWall = new ArrayList<float[]>(org.rightWall);
		 yLine = org.yLine;
		 currentLeading = org.currentLeading;
		 fixedLeading = org.fixedLeading;
		 multipliedLeading = org.multipliedLeading;
		 canvas = org.canvas;
		 canvases = org.canvases;
		 lineStatus = org.lineStatus;
		 indent = org.indent;
		 followingIndent = org.followingIndent;
		 rightIndent = org.rightIndent;
		 extraParagraphSpace = org.extraParagraphSpace;
		 rectangularWidth = org.rectangularWidth;
		 rectangularMode = org.rectangularMode;
		 spaceCharRatio = org.spaceCharRatio;
		 lastWasNewline = org.lastWasNewline;
		 linesWritten = org.linesWritten;
		 arabicOptions = org.arabicOptions;
		 runDirection = org.runDirection;
		 descender = org.descender;
		 composite = org.composite;
		 splittedRow = org.splittedRow;
		 if (org.composite) {
			 compositeElements = new LinkedList<Element>(org.compositeElements);
			 if (splittedRow) {
				 PdfPTable table = (PdfPTable)compositeElements.getFirst();
				 compositeElements.set(0, new PdfPTable(table));
			 }
			 if (org.compositeColumn != null) compositeColumn = duplicate(org.compositeColumn);
		 }
		 listIdx = org.listIdx;
		 firstLineY = org.firstLineY;
		 leftX = org.leftX;
		 rightX = org.rightX;
		 firstLineYDone = org.firstLineYDone;
		 waitPhrase = org.waitPhrase;
		 useAscender = org.useAscender;
		 filledWidth = org.filledWidth;
		 adjustFirstLine = org.adjustFirstLine;
	 }
	 private void addWaitingPhrase() {
		 if (bidiLine == null && waitPhrase != null) {
			 bidiLine = new BidiLine();
			 for (Chunk c: waitPhrase.getChunks()) {
				 bidiLine.addChunk(new PdfChunk(c, null));
			 }
			 waitPhrase = null;
		 }
	 }
	 public void addText(Phrase phrase) {
		 if (phrase == null || composite) return;
		 addWaitingPhrase();
		 if (bidiLine == null) {
			 waitPhrase = phrase;
			 return;
		 }
		 for (Object element : phrase.getChunks()) {
			 bidiLine.addChunk(new PdfChunk((Chunk)element, null));
		 }
	 }
	 public void setText(Phrase phrase) {
		 bidiLine = null;
		 composite = false;
		 compositeColumn = null;
		 compositeElements = null;
		 listIdx = 0;
		 splittedRow = false;
		 waitPhrase = phrase;
	 }
	 public void addText(Chunk chunk) {
		 if (chunk == null || composite) return;
		 addText(new Phrase(chunk));
	 }
	 public void addElement(Element element) {
		 if (element == null) return;
		 if (element instanceof Image) {
			 Image img = (Image)element;
			 PdfPTable t = new PdfPTable(1);
			 float w = img.getWidthPercentage();
			 if (w == 0) {
				 t.setTotalWidth(img.getScaledWidth());
				 t.setLockedWidth(true);
			 }
			 else t.setWidthPercentage(w);
			 t.setSpacingAfter(img.getSpacingAfter());
			 t.setSpacingBefore(img.getSpacingBefore());
			 switch (img.getAlignment()) {
				 case Image.LEFT: t.setHorizontalAlignment(Element.ALIGN_LEFT);
				 break;
				 case Image.RIGHT: t.setHorizontalAlignment(Element.ALIGN_RIGHT);
				 break;
				 default: t.setHorizontalAlignment(Element.ALIGN_CENTER);
				 break;
			 }
			 PdfPCell c = new PdfPCell(img, true);
			 c.setPadding(0);
			 c.setBorder(img.getBorder());
			 c.setBorderColor(img.getBorderColor());
			 c.setBorderWidth(img.getBorderWidth());
			 c.setBackgroundColor(img.getBackgroundColor());
			 t.addCell(c);
			 element = t;
		 }
		 if (element.type() == Element.CHUNK) {
			 element = new Paragraph((Chunk)element);
		 }
		 else if (element.type() == Element.PHRASE) {
			 element = new Paragraph((Phrase)element);
		 }
		 if (element.type() != Element.PARAGRAPH && element.type() != Element.LIST && element.type() != Element.PTABLE && element.type() != Element.YMARK) throw new IllegalArgumentException(MessageLocalization.getComposedMessage(""element.not.allowed""));
		 if (!composite) {
			 composite = true;
			 compositeElements = new LinkedList<Element>();
			 bidiLine = null;
			 waitPhrase = null;
		 }
		 compositeElements.add(element);
	 }
	 protected ArrayList<float []> convertColumn(float cLine[]) {
		 if (cLine.length < 4) throw new RuntimeException(MessageLocalization.getComposedMessage(""no.valid.column.line.found""));
		 ArrayList<float []> cc = new ArrayList<float []>();
		 for (int k = 0;
		 k < cLine.length - 2;
		 k += 2) {
			 float x1 = cLine[k];
			 float y1 = cLine[k + 1];
			 float x2 = cLine[k + 2];
			 float y2 = cLine[k + 3];
			 if (y1 == y2) continue;
			 float a = (x1 - x2) / (y1 - y2);
			 float b = x1 - a * y1;
			 float r[] = new float[4];
			 r[0] = Math.min(y1, y2);
			 r[1] = Math.max(y1, y2);
			 r[2] = a;
			 r[3] = b;
			 cc.add(r);
			 maxY = Math.max(maxY, r[1]);
			 minY = Math.min(minY, r[0]);
		 }
		 if (cc.isEmpty()) throw new RuntimeException(MessageLocalization.getComposedMessage(""no.valid.column.line.found""));
		 return cc;
	 }
	 protected float findLimitsPoint(ArrayList<float []> wall) {
		 lineStatus = LINE_STATUS_OK;
		 if (yLine < minY || yLine > maxY) {
			 lineStatus = LINE_STATUS_OFFLIMITS;
			 return 0;
		 }
		 for (int k = 0;
		 k < wall.size();
		 ++k) {
			 float r[] = wall.get(k);
			 if (yLine < r[0] || yLine > r[1]) continue;
			 return r[2] * yLine + r[3];
		 }
		 lineStatus = LINE_STATUS_NOLINE;
		 return 0;
	 }
	 protected float[] findLimitsOneLine() {
		 float x1 = findLimitsPoint(leftWall);
		 if (lineStatus == LINE_STATUS_OFFLIMITS || lineStatus == LINE_STATUS_NOLINE) return null;
		 float x2 = findLimitsPoint(rightWall);
		 if (lineStatus == LINE_STATUS_NOLINE) return null;
		 return new float[]{
		x1, x2}
		;
	 }
	 protected float[] findLimitsTwoLines() {
		 boolean repeat = false;
		 for (;
		;
		) {
			 if (repeat && currentLeading == 0) return null;
			 repeat = true;
			 float x1[] = findLimitsOneLine();
			 if (lineStatus == LINE_STATUS_OFFLIMITS) return null;
			 yLine -= currentLeading;
			 if (lineStatus == LINE_STATUS_NOLINE) {
				 continue;
			 }
			 float x2[] = findLimitsOneLine();
			 if (lineStatus == LINE_STATUS_OFFLIMITS) return null;
			 if (lineStatus == LINE_STATUS_NOLINE) {
				 yLine -= currentLeading;
				 continue;
			 }
			 if (x1[0] >= x2[1] || x2[0] >= x1[1]) continue;
			 return new float[]{
			x1[0], x1[1], x2[0], x2[1]}
			;
		 }
	 }
	 public void setColumns(float leftLine[], float rightLine[]) {
		 maxY = -10e20f;
		 minY = 10e20f;
		 setYLine(Math.max(leftLine[1], leftLine[leftLine.length - 1]));
		 rightWall = convertColumn(rightLine);
		 leftWall = convertColumn(leftLine);
		 rectangularWidth = -1;
		 rectangularMode = false;
	 }
	 public void setSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment) {
		 addText(phrase);
		 setSimpleColumn(llx, lly, urx, ury, leading, alignment);
	 }
	 public void setSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment) {
		 setLeading(leading);
		 this.alignment = alignment;
		 setSimpleColumn(llx, lly, urx, ury);
	 }
	 public void setSimpleColumn(float llx, float lly, float urx, float ury) {
		 leftX = Math.min(llx, urx);
		 maxY = Math.max(lly, ury);
		 minY = Math.min(lly, ury);
		 rightX = Math.max(llx, urx);
		 yLine = maxY;
		 rectangularWidth = rightX - leftX;
		 if (rectangularWidth < 0) rectangularWidth = 0;
		 rectangularMode = true;
	 }
	 public void setLeading(float leading) {
		 fixedLeading = leading;
		 multipliedLeading = 0;
	 }
	 public void setLeading(float fixedLeading, float multipliedLeading) {
		 this.fixedLeading = fixedLeading;
		 this.multipliedLeading = multipliedLeading;
	 }
	 public float getLeading() {
		 return fixedLeading;
	 }
	 public float getMultipliedLeading() {
		 return multipliedLeading;
	 }
	 public void setYLine(float yLine) {
		 this.yLine = yLine;
	 }
	 public float getYLine() {
		 return yLine;
	 }
	 public void setAlignment(int alignment) {
		 this.alignment = alignment;
	 }
	 public int getAlignment() {
		 return alignment;
	 }
	 public void setIndent(float indent) {
		 this.indent = indent;
		 lastWasNewline = true;
	 }
	 public float getIndent() {
		 return indent;
	 }
	 public void setFollowingIndent(float indent) {
		 this.followingIndent = indent;
		 lastWasNewline = true;
	 }
	 public float getFollowingIndent() {
		 return followingIndent;
	 }
	 public void setRightIndent(float indent) {
		 this.rightIndent = indent;
		 lastWasNewline = true;
	 }
	 public float getRightIndent() {
		 return rightIndent;
	 }
	 public int go() throws DocumentException {
		 return go(false);
	 }
	 public int go(boolean simulate) throws DocumentException {
		 if (composite) return goComposite(simulate);
		 addWaitingPhrase();
		 if (bidiLine == null) return NO_MORE_TEXT;
		 descender = 0;
		 linesWritten = 0;
		 lastX = 0;
		 boolean dirty = false;
		 float ratio = spaceCharRatio;
		 Object currentValues[] = new Object[2];
		 PdfFont currentFont = null;
		 Float lastBaseFactor = new Float(0);
		 currentValues[1] = lastBaseFactor;
		 PdfDocument pdf = null;
		 PdfContentByte graphics = null;
		 PdfContentByte text = null;
		 firstLineY = Float.NaN;
		 int localRunDirection = PdfWriter.RUN_DIRECTION_NO_BIDI;
		 if (runDirection != PdfWriter.RUN_DIRECTION_DEFAULT) localRunDirection = runDirection;
		 if (canvas != null) {
			 graphics = canvas;
			 pdf = canvas.getPdfDocument();
			 text = canvas.getDuplicate();
		 }
		 else if (!simulate) throw new NullPointerException(MessageLocalization.getComposedMessage(""columntext.go.with.simulate.eq.eq.false.and.text.eq.eq.null""));
		 if (!simulate) {
			 if (ratio == GLOBAL_SPACE_CHAR_RATIO) ratio = text.getPdfWriter().getSpaceCharRatio();
			 else if (ratio < 0.001f) ratio = 0.001f;
		 }
		 float firstIndent = 0;
		 PdfLine line;
		 float x1;
		 int status = 0;
		 while(true) {
			 firstIndent = lastWasNewline ? indent : followingIndent;
			 if (rectangularMode) {
				 if (rectangularWidth <= firstIndent + rightIndent) {
					 status = NO_MORE_COLUMN;
					 if (bidiLine.isEmpty()) status |= NO_MORE_TEXT;
					 break;
				 }
				 if (bidiLine.isEmpty()) {
					 status = NO_MORE_TEXT;
					 break;
				 }
				 line = bidiLine.processLine(leftX, rectangularWidth - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions);
				 if (line == null) {
					 status = NO_MORE_TEXT;
					 break;
				 }
				 float[] maxSize = line.getMaxSize();
				 if (isUseAscender() && Float.isNaN(firstLineY)) currentLeading = line.getAscender();
				 else currentLeading = Math.max(fixedLeading + maxSize[0] * multipliedLeading, maxSize[1]);
				 if (yLine > maxY || yLine - currentLeading < minY ) {
					 status = NO_MORE_COLUMN;
					 bidiLine.restore();
					 break;
				 }
				 yLine -= currentLeading;
				 if (!simulate && !dirty) {
					 text.beginText();
					 dirty = true;
				 }
				 if (Float.isNaN(firstLineY)) firstLineY = yLine;
				 updateFilledWidth(rectangularWidth - line.widthLeft());
				 x1 = leftX;
			 }
			 else {
				 float yTemp = yLine;
				 float xx[] = findLimitsTwoLines();
				 if (xx == null) {
					 status = NO_MORE_COLUMN;
					 if (bidiLine.isEmpty()) status |= NO_MORE_TEXT;
					 yLine = yTemp;
					 break;
				 }
				 if (bidiLine.isEmpty()) {
					 status = NO_MORE_TEXT;
					 yLine = yTemp;
					 break;
				 }
				 x1 = Math.max(xx[0], xx[2]);
				 float x2 = Math.min(xx[1], xx[3]);
				 if (x2 - x1 <= firstIndent + rightIndent) continue;
				 if (!simulate && !dirty) {
					 text.beginText();
					 dirty = true;
				 }
				 line = bidiLine.processLine(x1, x2 - x1 - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions);
				 if (line == null) {
					 status = NO_MORE_TEXT;
					 yLine = yTemp;
					 break;
				 }
			 }
			 if (!simulate) {
				 currentValues[0] = currentFont;
				 text.setTextMatrix(x1 + (line.isRTL() ? rightIndent : firstIndent) + line.indentLeft(), yLine);
				 lastX = pdf.writeLineToContent(line, text, graphics, currentValues, ratio);
				 currentFont = (PdfFont)currentValues[0];
			 }
			 lastWasNewline = line.isNewlineSplit();
			 yLine -= line.isNewlineSplit() ? extraParagraphSpace : 0;
			 ++linesWritten;
			 descender = line.getDescender();
		 }
		 if (dirty) {
			 text.endText();
			 canvas.add(text);
		 }
		 return status;
	 }
	 public float getExtraParagraphSpace() {
		 return extraParagraphSpace;
	 }
	 public void setExtraParagraphSpace(float extraParagraphSpace) {
		 this.extraParagraphSpace = extraParagraphSpace;
	 }
	 public void clearChunks() {
		 if (bidiLine != null) bidiLine.clearChunks();
	 }
	 public float getSpaceCharRatio() {
		 return spaceCharRatio;
	 }
	 public void setSpaceCharRatio(float spaceCharRatio) {
		 this.spaceCharRatio = spaceCharRatio;
	 }
	 public void setRunDirection(int runDirection) {
		 if (runDirection < PdfWriter.RUN_DIRECTION_DEFAULT || runDirection > PdfWriter.RUN_DIRECTION_RTL) throw new RuntimeException(MessageLocalization.getComposedMessage(""invalid.run.direction.1"", runDirection));
		 this.runDirection = runDirection;
	 }
	 public int getRunDirection() {
		 return runDirection;
	 }
	 public int getLinesWritten() {
		 return this.linesWritten;
	 }
	 public float getLastX() {
		 return lastX;
	 }
	 public int getArabicOptions() {
		 return this.arabicOptions;
	 }
	 public void setArabicOptions(int arabicOptions) {
		 this.arabicOptions = arabicOptions;
	 }
	 public float getDescender() {
		 return descender;
	 }
	 public static float getWidth(Phrase phrase, int runDirection, int arabicOptions) {
		 ColumnText ct = new ColumnText(null);
		 ct.addText(phrase);
		 ct.addWaitingPhrase();
		 PdfLine line = ct.bidiLine.processLine(0, 20000, Element.ALIGN_LEFT, runDirection, arabicOptions);
		 if (line == null) return 0;
		 else return 20000 - line.widthLeft();
	 }
	 public static float getWidth(Phrase phrase) {
		 return getWidth(phrase, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);
	 }
	 public static void showTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions) {
		 if (alignment != Element.ALIGN_LEFT && alignment != Element.ALIGN_CENTER && alignment != Element.ALIGN_RIGHT) alignment = Element.ALIGN_LEFT;
		 canvas.saveState();
		 ColumnText ct = new ColumnText(canvas);
		 float lly = -1;
		 float ury = 2;
		 float llx;
		 float urx;
		 switch (alignment) {
			 case Element.ALIGN_LEFT: llx = 0;
			 urx = 20000;
			 break;
			 case Element.ALIGN_RIGHT: llx = -20000;
			 urx = 0;
			 break;
			 default: llx = -20000;
			 urx = 20000;
			 break;
		 }
		 if (rotation == 0) {
			 llx += x;
			 lly += y;
			 urx += x;
			 ury += y;
		 }
		 else {
			 double alpha = rotation * Math.PI / 180.0;
			 float cos = (float)Math.cos(alpha);
			 float sin = (float)Math.sin(alpha);
			 canvas.concatCTM(cos, sin, -sin, cos, x, y);
		 }
		 ct.setSimpleColumn(phrase, llx, lly, urx, ury, 2, alignment);
		 if (runDirection == PdfWriter.RUN_DIRECTION_RTL) {
			 if (alignment == Element.ALIGN_LEFT) alignment = Element.ALIGN_RIGHT;
			 else if (alignment == Element.ALIGN_RIGHT) alignment = Element.ALIGN_LEFT;
		 }
		 ct.setAlignment(alignment);
		 ct.setArabicOptions(arabicOptions);
		 ct.setRunDirection(runDirection);
		 try {
			 ct.go();
		 }
		 catch (DocumentException e) {
			 throw new ExceptionConverter(e);
		 }
		 canvas.restoreState();
	 }
	 public static void showTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation) {
		 showTextAligned(canvas, alignment, phrase, x, y, rotation, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);
	 }
	 protected int goComposite(boolean simulate) throws DocumentException {
		 if (!rectangularMode) throw new DocumentException(MessageLocalization.getComposedMessage(""irregular.columns.are.not.supported.in.composite.mode""));
		 linesWritten = 0;
		 descender = 0;
		 boolean firstPass = adjustFirstLine;
		 main_loop: while (true) {
			 if (compositeElements.isEmpty()) return NO_MORE_TEXT;
			 Element element = compositeElements.getFirst();
			 if (element.type() == Element.PARAGRAPH) {
				 Paragraph para = (Paragraph)element;
				 int status = 0;
				 for (int keep = 0;
				 keep < 2;
				 ++keep) {
					 float lastY = yLine;
					 boolean createHere = false;
					 if (compositeColumn == null) {
						 compositeColumn = new ColumnText(canvas);
						 compositeColumn.setAlignment(para.getAlignment());
						 compositeColumn.setIndent(para.getIndentationLeft() + para.getFirstLineIndent());
						 compositeColumn.setExtraParagraphSpace(para.getExtraParagraphSpace());
						 compositeColumn.setFollowingIndent(para.getIndentationLeft());
						 compositeColumn.setRightIndent(para.getIndentationRight());
						 compositeColumn.setLeading(para.getLeading(), para.getMultipliedLeading());
						 compositeColumn.setRunDirection(runDirection);
						 compositeColumn.setArabicOptions(arabicOptions);
						 compositeColumn.setSpaceCharRatio(spaceCharRatio);
						 compositeColumn.addText(para);
						 if (!firstPass) {
							 yLine -= para.getSpacingBefore();
						 }
						 createHere = true;
					 }
					 compositeColumn.setUseAscender(firstPass ? useAscender : false);
					 compositeColumn.leftX = leftX;
					 compositeColumn.rightX = rightX;
					 compositeColumn.yLine = yLine;
					 compositeColumn.rectangularWidth = rectangularWidth;
					 compositeColumn.rectangularMode = rectangularMode;
					 compositeColumn.minY = minY;
					 compositeColumn.maxY = maxY;
					 boolean keepCandidate = para.getKeepTogether() && createHere && !firstPass;
					 status = compositeColumn.go(simulate || keepCandidate && keep == 0);
					 lastX = compositeColumn.getLastX();
					 updateFilledWidth(compositeColumn.filledWidth);
					 if ((status & NO_MORE_TEXT) == 0 && keepCandidate) {
						 compositeColumn = null;
						 yLine = lastY;
						 return NO_MORE_COLUMN;
					 }
					 if (simulate || !keepCandidate) break;
					 if (keep == 0) {
						 compositeColumn = null;
						 yLine = lastY;
					 }
				 }
				 firstPass = false;
				 yLine = compositeColumn.yLine;
				 linesWritten += compositeColumn.linesWritten;
				 descender = compositeColumn.descender;
				 if ((status & NO_MORE_TEXT) != 0) {
					 compositeColumn = null;
					 compositeElements.removeFirst();
					 yLine -= para.getSpacingAfter();
				 }
				 if ((status & NO_MORE_COLUMN) != 0) {
					 return NO_MORE_COLUMN;
				 }
			 }
			 else if (element.type() == Element.LIST) {
				 com.itextpdf.text.List list = (com.itextpdf.text.List)element;
				 ArrayList<Element> items = list.getItems();
				 ListItem item = null;
				 float listIndentation = list.getIndentationLeft();
				 int count = 0;
				 Stack<Object[]> stack = new Stack<Object[]>();
				 for (int k = 0;
				 k < items.size();
				 ++k) {
					 Object obj = items.get(k);
					 if (obj instanceof ListItem) {
						 if (count == listIdx) {
							 item = (ListItem)obj;
							 break;
						 }
						 else ++count;
					 }
					 else if (obj instanceof com.itextpdf.text.List) {
						 stack.push(new Object[]{
						list, new Integer(k), new Float(listIndentation)}
						);
						 list = (com.itextpdf.text.List)obj;
						 items = list.getItems();
						 listIndentation += list.getIndentationLeft();
						 k = -1;
						 continue;
					 }
					 if (k == items.size() - 1) {
						 if (!stack.isEmpty()) {
							 Object objs[] = stack.pop();
							 list = (com.itextpdf.text.List)objs[0];
							 items = list.getItems();
							 k = ((Integer)objs[1]).intValue();
							 listIndentation = ((Float)objs[2]).floatValue();
						 }
					 }
				 }
				 int status = 0;
				 for (int keep = 0;
				 keep < 2;
				 ++keep) {
					 float lastY = yLine;
					 boolean createHere = false;
					 if (compositeColumn == null) {
						 if (item == null) {
							 listIdx = 0;
							 compositeElements.removeFirst();
							 continue main_loop;
						 }
						 compositeColumn = new ColumnText(canvas);
						 compositeColumn.setUseAscender(firstPass ? useAscender : false);
						 compositeColumn.setAlignment(item.getAlignment());
						 compositeColumn.setIndent(item.getIndentationLeft() + listIndentation + item.getFirstLineIndent());
						 compositeColumn.setExtraParagraphSpace(item.getExtraParagraphSpace());
						 compositeColumn.setFollowingIndent(compositeColumn.getIndent());
						 compositeColumn.setRightIndent(item.getIndentationRight() + list.getIndentationRight());
						 compositeColumn.setLeading(item.getLeading(), item.getMultipliedLeading());
						 compositeColumn.setRunDirection(runDirection);
						 compositeColumn.setArabicOptions(arabicOptions);
						 compositeColumn.setSpaceCharRatio(spaceCharRatio);
						 compositeColumn.addText(item);
						 if (!firstPass) {
							 yLine -= item.getSpacingBefore();
						 }
						 createHere = true;
					 }
					 compositeColumn.leftX = leftX;
					 compositeColumn.rightX = rightX;
					 compositeColumn.yLine = yLine;
					 compositeColumn.rectangularWidth = rectangularWidth;
					 compositeColumn.rectangularMode = rectangularMode;
					 compositeColumn.minY = minY;
					 compositeColumn.maxY = maxY;
					 boolean keepCandidate = item.getKeepTogether() && createHere && !firstPass;
					 status = compositeColumn.go(simulate || keepCandidate && keep == 0);
					 lastX = compositeColumn.getLastX();
					 updateFilledWidth(compositeColumn.filledWidth);
					 if ((status & NO_MORE_TEXT) == 0 && keepCandidate) {
						 compositeColumn = null;
						 yLine = lastY;
						 return NO_MORE_COLUMN;
					 }
					 if (simulate || !keepCandidate) break;
					 if (keep == 0) {
						 compositeColumn = null;
						 yLine = lastY;
					 }
				 }
				 firstPass = false;
				 yLine = compositeColumn.yLine;
				 linesWritten += compositeColumn.linesWritten;
				 descender = compositeColumn.descender;
				 if (!Float.isNaN(compositeColumn.firstLineY) && !compositeColumn.firstLineYDone) {
					 if (!simulate) showTextAligned(canvas, Element.ALIGN_LEFT, new Phrase(item.getListSymbol()), compositeColumn.leftX + listIndentation, compositeColumn.firstLineY, 0);
					 compositeColumn.firstLineYDone = true;
				 }
				 if ((status & NO_MORE_TEXT) != 0) {
					 compositeColumn = null;
					 ++listIdx;
					 yLine -= item.getSpacingAfter();
				 }
				 if ((status & NO_MORE_COLUMN) != 0) return NO_MORE_COLUMN;
			 }
			 else if (element.type() == Element.PTABLE) {
				 if (yLine < minY || yLine > maxY) return NO_MORE_COLUMN;
				 PdfPTable table = (PdfPTable)element;
				 if (table.size() <= table.getHeaderRows()) {
					 compositeElements.removeFirst();
					 continue;
				 }
				 float yTemp = yLine;
				 if (!firstPass && listIdx == 0) yTemp -= table.spacingBefore();
				 float yLineWrite = yTemp;
				 if (yTemp < minY || yTemp > maxY) return NO_MORE_COLUMN;
				 currentLeading = 0;
				 float x1 = leftX;
				 float tableWidth;
				 if (table.isLockedWidth()) {
					 tableWidth = table.getTotalWidth();
					 updateFilledWidth(tableWidth);
				 }
				 else {
					 tableWidth = rectangularWidth * table.getWidthPercentage() / 100f;
					 table.setTotalWidth(tableWidth);
				 }
				 int headerRows = table.getHeaderRows();
				 int footerRows = table.getFooterRows();
				 if (footerRows > headerRows) footerRows = headerRows;
				 int realHeaderRows = headerRows - footerRows;
				 float headerHeight = table.getHeaderHeight();
				 float footerHeight = table.getFooterHeight();
				 boolean skipHeader = !firstPass && table.isSkipFirstHeader() && listIdx <= headerRows;
				 if (!skipHeader) {
					 yTemp -= headerHeight;
					 if (yTemp < minY || yTemp > maxY) {
						 if (firstPass) {
							 compositeElements.removeFirst();
							 continue;
						 }
						 return NO_MORE_COLUMN;
					 }
				 }
				 int k;
				 if (listIdx < headerRows) listIdx = headerRows;
				 if (!table.isComplete()) yTemp -= footerHeight;
				 for (k = listIdx;
				 k < table.size();
				 ++k) {
					 float rowHeight = table.getRowHeight(k);
					 if (yTemp - rowHeight < minY) break;
					 yTemp -= rowHeight;
				 }
				 if (!table.isComplete()) yTemp += footerHeight;
				 if (k < table.size()) {
					 if (table.isSplitRows() && (!table.isSplitLate() || k == listIdx && firstPass)) {
						 if (!splittedRow) {
							 splittedRow = true;
							 table = new PdfPTable(table);
							 compositeElements.set(0, table);
							 ArrayList<PdfPRow> rows = table.getRows();
							 for (int i = headerRows;
							 i < listIdx;
							 ++i) rows.set(i, null);
						 }
						 float h = yTemp - minY;
						 PdfPRow newRow = table.getRow(k).splitRow(table, k, h);
						 if (newRow == null) {
							 if (k == listIdx) return NO_MORE_COLUMN;
						 }
						 else {
							 yTemp = minY;
							 table.getRows().add(++k, newRow);
						 }
					 }
					 else if (!table.isSplitRows() && k == listIdx && firstPass) {
						 compositeElements.removeFirst();
						 splittedRow = false;
						 continue;
					 }
					 else if (k == listIdx && !firstPass && (!table.isSplitRows() || table.isSplitLate()) && (table.getFooterRows() == 0 || table.isComplete())) return NO_MORE_COLUMN;
				 }
				 firstPass = false;
				 if (!simulate) {
					 switch (table.getHorizontalAlignment()) {
						 case Element.ALIGN_LEFT: break;
						 case Element.ALIGN_RIGHT: x1 += rectangularWidth - tableWidth;
						 break;
						 default: x1 += (rectangularWidth - tableWidth) / 2f;
					 }
					 PdfPTable nt = PdfPTable.shallowCopy(table);
					 ArrayList<PdfPRow> sub = nt.getRows();
					 if (!skipHeader && realHeaderRows > 0) {
						 sub.addAll(table.getRows(0, realHeaderRows));
					 }
					 else nt.setHeaderRows(footerRows);
					 sub.addAll(table.getRows(listIdx, k));
					 boolean showFooter = !table.isSkipLastFooter();
					 boolean newPageFollows = false;
					 if (k < table.size()) {
						 nt.setComplete(true);
						 showFooter = true;
						 newPageFollows = true;
					 }
					 for (int j = 0;
					 j < footerRows && nt.isComplete() && showFooter;
					 ++j) sub.add(table.getRow(j + realHeaderRows));
					 float rowHeight = 0;
					 int index = sub.size() - 1;
					 if (showFooter) index -= footerRows;
					 PdfPRow last = sub.get(index);
					 if (table.isExtendLastRow(newPageFollows)) {
						 rowHeight = last.getMaxHeights();
						 last.setMaxHeights(yTemp - minY + rowHeight);
						 yTemp = minY;
					 }
					 if (canvases != null) nt.writeSelectedRows(0, -1, x1, yLineWrite, canvases);
					 else nt.writeSelectedRows(0, -1, x1, yLineWrite, canvas);
					 if (table.isExtendLastRow(newPageFollows)) {
						 last.setMaxHeights(rowHeight);
					 }
				 }
				 else if (table.isExtendLastRow() && minY > PdfPRow.BOTTOM_LIMIT) yTemp = minY;
				 yLine = yTemp;
				 if (!(skipHeader || table.isComplete())) yLine += footerHeight;
				 if (k >= table.size()) {
					 yLine -= table.spacingAfter();
					 compositeElements.removeFirst();
					 splittedRow = false;
					 listIdx = 0;
				 }
				 else {
					 if (splittedRow) {
						 ArrayList<PdfPRow> rows = table.getRows();
						 for (int i = listIdx;
						 i < k;
						 ++i) rows.set(i, null);
					 }
					 listIdx = k;
					 return NO_MORE_COLUMN;
				 }
			 }
			 else if (element.type() == Element.YMARK) {
				 if (!simulate) {
					 DrawInterface zh = (DrawInterface)element;
					 zh.draw(canvas, leftX, minY, rightX, maxY, yLine);
				 }
				 compositeElements.removeFirst();
			 }
			 else compositeElements.removeFirst();
		 }
	 }
	 public PdfContentByte getCanvas() {
		 return canvas;
	 }
	 public void setCanvas(PdfContentByte canvas) {
		 this.canvas = canvas;
		 this.canvases = null;
		 if (compositeColumn != null) compositeColumn.setCanvas(canvas);
	 }
	 public void setCanvases(PdfContentByte[] canvases) {
		 this.canvases = canvases;
		 this.canvas = canvases[PdfPTable.TEXTCANVAS];
		 if (compositeColumn != null) compositeColumn.setCanvases(canvases);
	 }
	 public PdfContentByte[] getCanvases() {
		 return canvases;
	 }
	 public boolean zeroHeightElement() {
		 return composite && !compositeElements.isEmpty() && compositeElements.getFirst().type() == Element.YMARK;
	 }
	 public boolean isUseAscender() {
		 return useAscender;
	 }
	 public void setUseAscender(boolean useAscender) {
		 this.useAscender = useAscender;
	 }
	 public static boolean hasMoreText(int status) {
		 return (status & ColumnText.NO_MORE_TEXT) == 0;
	 }
	 public float getFilledWidth() {
		 return filledWidth;
	 }
	 public void setFilledWidth(float filledWidth) {
		 this.filledWidth = filledWidth;
	 }
	 public void updateFilledWidth(float w) {
		 if (w > filledWidth) filledWidth = w;
	 }
	 public boolean isAdjustFirstLine() {
		 return adjustFirstLine;
	 }
	 public void setAdjustFirstLine(boolean adjustFirstLine) {
		 this.adjustFirstLine = adjustFirstLine;
	 }
}",1,0,0,0
"public boolean getDefaultFormProcessing(){
	return defaultFormProcessing;
}",0,0,0,0
"public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer);",0,0,0,1
"public interface ErrorReporter {
	 void warning(String message, String sourceName, int line, String lineSource, int lineOffset);
	 void error(String message, String sourceName, int line, String lineSource, int lineOffset);
	 EvaluatorException runtimeError(String message, String sourceName, int line, String lineSource, int lineOffset);
}",0,0,0,0
"public static class Builder {
	 public static AssumeRoleOptions externalId(String externalId) {
		 return new AssumeRoleOptions().externalId(externalId);
	 }
	 public static AssumeRoleOptions durationSeconds(long durationSeconds) {
		 return new AssumeRoleOptions().durationSeconds(durationSeconds);
	 }
	 public static AssumeRoleOptions policy(String policy) {
		 return new AssumeRoleOptions().policy(policy);
	 }
 }",0,0,0,0
"public ByteBuffer computeOldShardMerger(ByteBuffer context, List<NodeId.NodeIdRecord> oldIds, long mergeBefore) {
	 long now = System.currentTimeMillis();
	 int hlength = headerLength(context);
	 NodeId localId = NodeId.getLocalId();
	 Iterator<NodeId.NodeIdRecord> recordIterator = oldIds.iterator();
	 NodeId.NodeIdRecord currRecord = recordIterator.hasNext() ? recordIterator.next() : null;
	 ContextState state = new ContextState(context, hlength);
	 ContextState foundState = null;
	 List<NodeId> toMerge = new ArrayList<NodeId>();
	 long mergeTotal = 0;
	 while (state.hasRemaining() && currRecord != null) {
		 assert !currRecord.id.equals(localId);
		 NodeId nodeId = state.getNodeId();
		 int c = nodeId.compareTo(currRecord.id);
		 if (c > 0) {
			 currRecord = recordIterator.hasNext() ? recordIterator.next() : null;
			 continue;
		 }
		 if (state.isDelta()) {
			 if (state.getClock() < 0) {
				 if (nodeId.equals(localId)) throw new RuntimeException(""Current nodeId with a negative clock (likely due to #2968). You need to restart this node with -Dcassandra.renew_counter_id=true to fix."");
				 if (state.getCount() != 0) {
					 logger.error(String.format(""Invalid counter context (clock is %d and count is %d for NodeId %s), will fix"", state.getCount(), state.getCount(), nodeId.toString()));
					 toMerge.add(nodeId);
					 mergeTotal += state.getCount();
				 }
			 }
			 else if (c == 0) {
				 if (currRecord.timestamp < mergeBefore) {
					 toMerge.add(nodeId);
					 mergeTotal += state.getCount();
				 }
			 }
		 }
		 if (c == 0) currRecord = recordIterator.hasNext() ? recordIterator.next() : null;
		 state.moveToNext();
	 }
	 while (state.hasRemaining()) {
		 NodeId nodeId = state.getNodeId();
		 if (state.isDelta() && state.getClock() < 0) {
			 if (nodeId.equals(localId)) throw new RuntimeException(""Current nodeId with a negative clock (likely due to #2968). You need to restart this node with -Dcassandra.renew_counter_id=true to fix."");
			 if (state.getCount() != 0) {
				 logger.error(String.format(""Invalid counter context (clock is %d and count is %d for NodeId %s), will fix"", state.getClock(), state.getCount(), nodeId.toString()));
				 toMerge.add(nodeId);
				 mergeTotal += state.getCount();
			 }
		 }
		 state.moveToNext();
	 }
	 if (toMerge.isEmpty()) return null;
	 ContextState merger = ContextState.allocate(toMerge.size() + 1, toMerge.size() + 1);
	 state.reset();
	 int i = 0;
	 int removedTotal = 0;
	 boolean localWritten = false;
	 while (state.hasRemaining()) {
		 NodeId nodeId = state.getNodeId();
		 if (nodeId.compareTo(localId) > 0) {
			 merger.writeElement(localId, 1L, mergeTotal, true);
			 localWritten = true;
		 }
		 else if (i < toMerge.size() && nodeId.compareTo(toMerge.get(i)) == 0) {
			 long count = state.getCount();
			 removedTotal += count;
			 merger.writeElement(nodeId, -now - state.getClock(), -count, true);
			 ++i;
		 }
		 state.moveToNext();
	 }
	 if (!localWritten) merger.writeElement(localId, 1L, mergeTotal, true);
	 assert mergeTotal == removedTotal;
	 return merger.context;
 }",0,0,1,0
"public void setName(String name) throws BuildException {
	 throw new BuildException(""you can't change the name of a compressed"" + "" resource"");
 }",0,0,0,0
"public static class MissedUpdatesFinder extends MissedUpdatesFinderBase {
	 private long ourHighThreshold;
	 private long ourHighest;
	 private String logPrefix;
	 private long nUpdates;
	 MissedUpdatesFinder(List<Long> ourUpdates, String logPrefix, long nUpdates, long ourLowThreshold, long ourHighThreshold) {
		 super(ourUpdates, ourLowThreshold);
		 this.logPrefix = logPrefix;
		 this.ourHighThreshold = ourHighThreshold;
		 this.ourHighest = ourUpdates.get(0);
		 this.nUpdates = nUpdates;
	 }
	 public MissedUpdatesRequest find(List<Long> otherVersions, Object updateFrom, Supplier<Boolean> canHandleVersionRanges) {
		 otherVersions.sort(absComparator);
		 if (debug) {
			 log.debug(""{
			}
			 sorted versions from {
			}
			 = {
			}
			"", logPrefix, otherVersions, updateFrom);
		 }
		 long otherHigh = percentile(otherVersions, .2f);
		 long otherLow = percentile(otherVersions, .8f);
		 long otherHighest = otherVersions.get(0);
		 if (ourHighThreshold < otherLow) {
			 log.info(""{
			}
			 Our versions are too old. ourHighThreshold={
			}
			 otherLowThreshold={
			}
			 ourHighest={
			}
			 otherHighest={
			}
			"", logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);
			 return MissedUpdatesRequest.UNABLE_TO_SYNC;
		 }
		 if (ourLowThreshold > otherHigh && ourHighest >= otherHighest) {
			 log.info(""{
			}
			 Our versions are newer. ourHighThreshold={
			}
			 otherLowThreshold={
			}
			 ourHighest={
			}
			 otherHighest={
			}
			"", logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);
			 return MissedUpdatesRequest.ALREADY_IN_SYNC;
		 }
		 boolean completeList = otherVersions.size() < nUpdates;
		 MissedUpdatesRequest updatesRequest;
		 if (canHandleVersionRanges.get()) {
			 updatesRequest = handleVersionsWithRanges(otherVersions, completeList);
		 }
		 else {
			 updatesRequest = handleIndividualVersions(otherVersions, completeList);
		 }
		 if (updatesRequest.totalRequestedUpdates > nUpdates) {
			 log.info(""{
			}
			 PeerSync will fail because number of missed updates is more than:{
			}
			"", logPrefix, nUpdates);
			 return MissedUpdatesRequest.UNABLE_TO_SYNC;
		 }
		 if (updatesRequest == MissedUpdatesRequest.EMPTY) {
			 log.info(""{
			}
			 No additional versions requested. ourHighThreshold={
			}
			 otherLowThreshold={
			}
			 ourHighest={
			}
			 otherHighest={
			}
			"", logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);
		 }
		 return updatesRequest;
	 }
 }",1,0,0,0
"private static DimFilter negate(final DimFilter filter) {
	 if (Filtration.matchEverything().equals(filter)) {
		 return Filtration.matchNothing();
	 }
	 else if (Filtration.matchNothing().equals(filter)) {
		 return Filtration.matchEverything();
	 }
	 else if (filter instanceof NotDimFilter) {
		 return ((NotDimFilter) filter).getField();
	 }
	 else if (filter instanceof BoundDimFilter) {
		 final BoundDimFilter negated = Bounds.not((BoundDimFilter) filter);
		 return negated != null ? negated : new NotDimFilter(filter);
	 }
	 else {
		 return new NotDimFilter(filter);
	 }
 }",0,0,1,0
"public void stop() {
	 try {
		 outputThread.join();
	 }
	 catch (InterruptedException e) {
	 }
	 try {
		 errorThread.join();
	 }
	 catch (InterruptedException e) {
	 }
	 if (inputPump != null) {
		 inputPump.stop();
	 }
	 try {
		 err.flush();
	 }
	 catch (IOException e) {
	 }
	 try {
		 out.flush();
	 }
	 catch (IOException e) {
	 }
 }",0,0,0,0
"public class SeekableXZInputStream extends SeekableInputStream {
	 private final ArrayCache arrayCache;
	 private SeekableInputStream in;
	 private final int memoryLimit;
	 private int indexMemoryUsage = 0;
	 private final ArrayList<IndexDecoder> streams = new ArrayList<IndexDecoder>();
	 private int checkTypes = 0;
	 private long uncompressedSize = 0;
	 private long largestBlockSize = 0;
	 private int blockCount = 0;
	 private final BlockInfo curBlockInfo;
	 private final BlockInfo queriedBlockInfo;
	 private Check check;
	 private final boolean verifyCheck;
	 private BlockInputStream blockDecoder = null;
	 private long curPos = 0;
	 private long seekPos;
	 private boolean seekNeeded = false;
	 private boolean endReached = false;
	 private IOException exception = null;
	 private final byte[] tempBuf = new byte[1];
	 public SeekableXZInputStream(SeekableInputStream in) throws IOException {
		 this(in, -1);
	 }
	 public SeekableXZInputStream(SeekableInputStream in, ArrayCache arrayCache) throws IOException {
		 this(in, -1, arrayCache);
	 }
	 public SeekableXZInputStream(SeekableInputStream in, int memoryLimit) throws IOException {
		 this(in, memoryLimit, true);
	 }
	 public SeekableXZInputStream(SeekableInputStream in, int memoryLimit, ArrayCache arrayCache) throws IOException {
		 this(in, memoryLimit, true, arrayCache);
	 }
	 public SeekableXZInputStream(SeekableInputStream in, int memoryLimit, boolean verifyCheck) throws IOException {
		 this(in, memoryLimit, verifyCheck, ArrayCache.getDefaultCache());
	 }
	 public SeekableXZInputStream(SeekableInputStream in, int memoryLimit, boolean verifyCheck, ArrayCache arrayCache) throws IOException {
		 this.arrayCache = arrayCache;
		 this.verifyCheck = verifyCheck;
		 this.in = in;
		 DataInputStream inData = new DataInputStream(in);
		 {
			 in.seek(0);
			 byte[] buf = new byte[XZ.HEADER_MAGIC.length];
			 inData.readFully(buf);
			 if (!Arrays.equals(buf, XZ.HEADER_MAGIC)) throw new XZFormatException();
		 }
		 long pos = in.length();
		 if ((pos & 3) != 0) throw new CorruptedInputException( ""XZ file size is not a multiple of 4 bytes"");
		 byte[] buf = new byte[DecoderUtil.STREAM_HEADER_SIZE];
		 long streamPadding = 0;
		 while (pos > 0) {
			 if (pos < DecoderUtil.STREAM_HEADER_SIZE) throw new CorruptedInputException();
			 in.seek(pos - DecoderUtil.STREAM_HEADER_SIZE);
			 inData.readFully(buf);
			 if (buf[8] == 0x00 && buf[9] == 0x00 && buf[10] == 0x00 && buf[11] == 0x00) {
				 streamPadding += 4;
				 pos -= 4;
				 continue;
			 }
			 pos -= DecoderUtil.STREAM_HEADER_SIZE;
			 StreamFlags streamFooter = DecoderUtil.decodeStreamFooter(buf);
			 if (streamFooter.backwardSize >= pos) throw new CorruptedInputException( ""Backward Size in XZ Stream Footer is too big"");
			 check = Check.getInstance(streamFooter.checkType);
			 checkTypes |= 1 << streamFooter.checkType;
			 in.seek(pos - streamFooter.backwardSize);
			 IndexDecoder index;
			 try {
				 index = new IndexDecoder(in, streamFooter, streamPadding, memoryLimit);
			 }
			 catch (MemoryLimitException e) {
				 assert memoryLimit >= 0;
				 throw new MemoryLimitException( e.getMemoryNeeded() + indexMemoryUsage, memoryLimit + indexMemoryUsage);
			 }
			 indexMemoryUsage += index.getMemoryUsage();
			 if (memoryLimit >= 0) {
				 memoryLimit -= index.getMemoryUsage();
				 assert memoryLimit >= 0;
			 }
			 if (largestBlockSize < index.getLargestBlockSize()) largestBlockSize = index.getLargestBlockSize();
			 long off = index.getStreamSize() - DecoderUtil.STREAM_HEADER_SIZE;
			 if (pos < off) throw new CorruptedInputException(""XZ Index indicates "" + ""too big compressed size for the XZ Stream"");
			 pos -= off;
			 in.seek(pos);
			 inData.readFully(buf);
			 StreamFlags streamHeader = DecoderUtil.decodeStreamHeader(buf);
			 if (!DecoderUtil.areStreamFlagsEqual(streamHeader, streamFooter)) throw new CorruptedInputException( ""XZ Stream Footer does not match Stream Header"");
			 uncompressedSize += index.getUncompressedSize();
			 if (uncompressedSize < 0) throw new UnsupportedOptionsException(""XZ file is too big"");
			 blockCount += index.getRecordCount();
			 if (blockCount < 0) throw new UnsupportedOptionsException( ""XZ file has over "" + Integer.MAX_VALUE + "" Blocks"");
			 streams.add(index);
			 streamPadding = 0;
		 }
		 assert pos == 0;
		 this.memoryLimit = memoryLimit;
		 IndexDecoder prev = streams.get(streams.size() - 1);
		 for (int i = streams.size() - 2;
		 i >= 0;
		 --i) {
			 IndexDecoder cur = streams.get(i);
			 cur.setOffsets(prev);
			 prev = cur;
		 }
		 IndexDecoder first = streams.get(streams.size() - 1);
		 curBlockInfo = new BlockInfo(first);
		 queriedBlockInfo = new BlockInfo(first);
	 }
	 public int getCheckTypes() {
		 return checkTypes;
	 }
	 public int getIndexMemoryUsage() {
		 return indexMemoryUsage;
	 }
	 public long getLargestBlockSize() {
		 return largestBlockSize;
	 }
	 public int getStreamCount() {
		 return streams.size();
	 }
	 public int getBlockCount() {
		 return blockCount;
	 }
	 public long getBlockPos(int blockNumber) {
		 locateBlockByNumber(queriedBlockInfo, blockNumber);
		 return queriedBlockInfo.uncompressedOffset;
	 }
	 public long getBlockSize(int blockNumber) {
		 locateBlockByNumber(queriedBlockInfo, blockNumber);
		 return queriedBlockInfo.uncompressedSize;
	 }
	 public long getBlockCompPos(int blockNumber) {
		 locateBlockByNumber(queriedBlockInfo, blockNumber);
		 return queriedBlockInfo.compressedOffset;
	 }
	 public long getBlockCompSize(int blockNumber) {
		 locateBlockByNumber(queriedBlockInfo, blockNumber);
		 return (queriedBlockInfo.unpaddedSize + 3) & ~3;
	 }
	 public int getBlockCheckType(int blockNumber) {
		 locateBlockByNumber(queriedBlockInfo, blockNumber);
		 return queriedBlockInfo.getCheckType();
	 }
	 public int getBlockNumber(long pos) {
		 locateBlockByPos(queriedBlockInfo, pos);
		 return queriedBlockInfo.blockNumber;
	 }
	 public int read() throws IOException {
		 return read(tempBuf, 0, 1) == -1 ? -1 : (tempBuf[0] & 0xFF);
	 }
	 public int read(byte[] buf, int off, int len) throws IOException {
		 if (off < 0 || len < 0 || off + len < 0 || off + len > buf.length) throw new IndexOutOfBoundsException();
		 if (len == 0) return 0;
		 if (in == null) throw new XZIOException(""Stream closed"");
		 if (exception != null) throw exception;
		 int size = 0;
		 try {
			 if (seekNeeded) seek();
			 if (endReached) return -1;
			 while (len > 0) {
				 if (blockDecoder == null) {
					 seek();
					 if (endReached) break;
				 }
				 int ret = blockDecoder.read(buf, off, len);
				 if (ret > 0) {
					 curPos += ret;
					 size += ret;
					 off += ret;
					 len -= ret;
				 }
				 else if (ret == -1) {
					 blockDecoder = null;
				 }
			 }
		 }
		 catch (IOException e) {
			 if (e instanceof EOFException) e = new CorruptedInputException();
			 exception = e;
			 if (size == 0) throw e;
		 }
		 return size;
	 }
	 public int available() throws IOException {
		 if (in == null) throw new XZIOException(""Stream closed"");
		 if (exception != null) throw exception;
		 if (endReached || seekNeeded || blockDecoder == null) return 0;
		 return blockDecoder.available();
	 }
	 public void close() throws IOException {
		 close(true);
	 }
	 public void close(boolean closeInput) throws IOException {
		 if (in != null) {
			 if (blockDecoder != null) {
				 blockDecoder.close();
				 blockDecoder = null;
			 }
			 try {
				 if (closeInput) in.close();
			 }
			 finally {
				 in = null;
			 }
		 }
	 }
	 public long length() {
		 return uncompressedSize;
	 }
	 public long position() throws IOException {
		 if (in == null) throw new XZIOException(""Stream closed"");
		 return seekNeeded ? seekPos : curPos;
	 }
	 public void seek(long pos) throws IOException {
		 if (in == null) throw new XZIOException(""Stream closed"");
		 if (pos < 0) throw new XZIOException(""Negative seek position: "" + pos);
		 seekPos = pos;
		 seekNeeded = true;
	 }
	 public void seekToBlock(int blockNumber) throws IOException {
		 if (in == null) throw new XZIOException(""Stream closed"");
		 if (blockNumber < 0 || blockNumber >= blockCount) throw new XZIOException(""Invalid XZ Block number: "" + blockNumber);
		 seekPos = getBlockPos(blockNumber);
		 seekNeeded = true;
	 }
	 private void seek() throws IOException {
		 if (!seekNeeded) {
			 if (curBlockInfo.hasNext()) {
				 curBlockInfo.setNext();
				 initBlockDecoder();
				 return;
			 }
			 seekPos = curPos;
		 }
		 seekNeeded = false;
		 if (seekPos >= uncompressedSize) {
			 curPos = seekPos;
			 if (blockDecoder != null) {
				 blockDecoder.close();
				 blockDecoder = null;
			 }
			 endReached = true;
			 return;
		 }
		 endReached = false;
		 locateBlockByPos(curBlockInfo, seekPos);
		 if (!(curPos > curBlockInfo.uncompressedOffset && curPos <= seekPos)) {
			 in.seek(curBlockInfo.compressedOffset);
			 check = Check.getInstance(curBlockInfo.getCheckType());
			 initBlockDecoder();
			 curPos = curBlockInfo.uncompressedOffset;
		 }
		 if (seekPos > curPos) {
			 long skipAmount = seekPos - curPos;
			 if (blockDecoder.skip(skipAmount) != skipAmount) throw new CorruptedInputException();
			 curPos = seekPos;
		 }
	 }
	 private void locateBlockByPos(BlockInfo info, long pos) {
		 if (pos < 0 || pos >= uncompressedSize) throw new IndexOutOfBoundsException( ""Invalid uncompressed position: "" + pos);
		 IndexDecoder index;
		 for (int i = 0;
		 ;
		 ++i) {
			 index = streams.get(i);
			 if (index.hasUncompressedOffset(pos)) break;
		 }
		 index.locateBlock(info, pos);
		 assert (info.compressedOffset & 3) == 0;
		 assert info.uncompressedSize > 0;
		 assert pos >= info.uncompressedOffset;
		 assert pos < info.uncompressedOffset + info.uncompressedSize;
	 }
	 private void locateBlockByNumber(BlockInfo info, int blockNumber) {
		 if (blockNumber < 0 || blockNumber >= blockCount) throw new IndexOutOfBoundsException( ""Invalid XZ Block number: "" + blockNumber);
		 if (info.blockNumber == blockNumber) return;
		 for (int i = 0;
		 ;
		 ++i) {
			 IndexDecoder index = streams.get(i);
			 if (index.hasRecord(blockNumber)) {
				 index.setBlockInfo(info, blockNumber);
				 return;
			 }
		 }
	 }
	 private void initBlockDecoder() throws IOException {
		 try {
			 if (blockDecoder != null) {
				 blockDecoder.close();
				 blockDecoder = null;
			 }
			 blockDecoder = new BlockInputStream( in, check, verifyCheck, memoryLimit, curBlockInfo.unpaddedSize, curBlockInfo.uncompressedSize, arrayCache);
		 }
		 catch (MemoryLimitException e) {
			 assert memoryLimit >= 0;
			 throw new MemoryLimitException( e.getMemoryNeeded() + indexMemoryUsage, memoryLimit + indexMemoryUsage);
		 }
		 catch (IndexIndicatorException e) {
			 throw new CorruptedInputException();
		 }
	 }
}",1,1,0,0
"public interface OpenDefinitionsDocument extends DJDocument, Finalizable<DefinitionsDocument>, Comparable<OpenDefinitionsDocument>, INavigatorItem {
	 public int commentLines(int selStart, int selEnd);
	 public int uncommentLines(int selStart, int selEnd);
	 public DefinitionsDocument getDocument();
	 public boolean getClassFileInSync();
	 public void setClassFileInSync(boolean val);
	 public int getCurrentLine();
	 public int getCurrentCol();
	 public int _getOffset(int lineNum);
	 public String getQualifiedClassName() throws ClassNameNotFoundException;
	 public String getQualifiedClassName(int pos) throws ClassNameNotFoundException;
	 public String getLexiName();
	 public CompoundUndoManager getUndoManager();
	 public void resetUndoManager();
	 public File getCachedClassFile();
	 public void setCachedClassFile(File f);
	 public DocumentListener[] getDocumentListeners();
	 public UndoableEditListener[] getUndoableEditListeners();
	 public File getRawFile();
	 public File getFile() throws FileMovedException;
	 public void setFile(File file);
	 public String getFileName();
	 public String getCanonicalPath();
	 public String getCompletePath();
	 public File getParentDirectory();
	 public Pageable getPageable() throws IllegalStateException;
	 public boolean undoManagerCanUndo();
	 public boolean undoManagerCanRedo();
	 public boolean inProjectPath();
	 public boolean inNewProjectPath(File root);
	 public boolean isEmpty();
	 public boolean isAuxiliaryFile();
	 public boolean isSourceFile();
	 public boolean inProject();
	 public boolean isReady();
	 public boolean isUntitled();
	 public boolean fileExists();
	 public boolean modifiedOnDisk();
	 public void resetModification();
	 public long getTimestamp();
	 public void addBrowserRegion(BrowserDocumentRegion r);
	 public void removeBrowserRegion(BrowserDocumentRegion r);
	 public String getFirstTopLevelClassName() throws ClassNameNotFoundException;
	 public boolean verifyExists();
	 public boolean saveFile(FileSaveSelector com) throws IOException;
	 public void revertFile() throws IOException;
	 public boolean saveFileAs(FileSaveSelector com) throws IOException;
	 public void startCompile() throws IOException;
	 public void runMain(String qualifiedClassName) throws ClassNameNotFoundException, IOException;
	 public void runApplet(String qualifiedClassName) throws ClassNameNotFoundException, IOException;
	 public void runSmart(String qualifiedClassName) throws ClassNameNotFoundException, IOException;
	 public void startJUnit() throws ClassNotFoundException, IOException;
	 public void generateJavadoc(FileSaveSelector saver) throws IOException;
	 public boolean isModifiedSinceSave();
	 public boolean revertIfModifiedOnDisk() throws IOException;
	 public boolean canAbandonFile();
	 public boolean quitFile();
	 public int gotoLine(int line);
	 public File getSourceRoot() throws InvalidPackageException;
	 public String getPackageNameFromDocument();
	 public String getPackageName();
	 public void setPackage(String s);
	 public String getEnclosingClassName(int pos, boolean qual) throws BadLocationException, ClassNameNotFoundException;
	 public void preparePrintJob() throws BadLocationException, FileMovedException;
	 public void print() throws PrinterException, BadLocationException, FileMovedException;
	 public void cleanUpPrintJob();
	 public boolean checkIfClassFileInSync();
	 public void documentSaved();
	 public void documentModified();
	 public void documentReset();
	 public RegionManager<Breakpoint> getBreakpointManager();
	 public RegionManager<MovingDocumentRegion> getBookmarkManager();
	 public void clearBrowserRegions();
	 public void removeFromDebugger();
	 public void updateModifiedSinceSave();
	 public void close();
	 public int getInitialVerticalScroll();
	 public int getInitialHorizontalScroll();
	 public int getInitialSelectionStart();
	 public int getInitialSelectionEnd();
	 public int getNumberOfLines();
	 public int getLineOfOffset(int offset);
	 public int getOffsetOfLine(int line);
	 public int getCaretPosition();
	 public Position createUnwrappedPosition(int offs) throws BadLocationException;
	 public boolean isShadowed(int pos);
	 public boolean containsClassOrInterfaceOrEnum() throws BadLocationException;
}",1,0,0,0
"public void reportTaskTrackerError(String taskTracker, String errorClass, String errorMessage) throws IOException;
}",0,0,0,0
"protected void exportReportToStream(Writer writer) throws JRException, IOException{
	tempBodyWriter = new StringWriter();
	tempStyleWriter = new StringWriter();
	styleCache = new XmlssStyleCache(tempStyleWriter, fontMap);
	sheetNamesMap = new HashMap();
	sheetNamesMap.put(""Page"", Integer.valueOf(0));
	 for(reportIndex = 0;
	 reportIndex < jasperPrintList.size();
	 reportIndex++){
		setJasperPrint((JasperPrint)jasperPrintList.get(reportIndex));
		defaultFont = new JRBasePrintText(jasperPrint.getDefaultStyleProvider());
		List pages = jasperPrint.getPages();
		if (pages != null && pages.size() > 0){
			if (isModeBatch){
				startPageIndex = 0;
				endPageIndex = pages.size() - 1;
			}
			if (isOnePagePerSheet){
				for(int pageIndex = startPageIndex;
				 pageIndex <= endPageIndex;
				 pageIndex++){
					if (Thread.interrupted()){
						throw new JRException(""Current thread interrupted."");
					}
					JRPrintPage page = (JRPrintPage)pages.get(pageIndex);
					if (sheetNames != null && sheetIndex < sheetNames.length){
						tempBodyWriter.write(""<Worksheet ss:Name=\""""+getSheetName(sheetNames[sheetIndex])+""\"">\n"");
					}
					else{
						tempBodyWriter.write(""<Worksheet ss:Name=\""""+getSheetName(""Page"")+""\"">\n"");
					}
					sheetIndex++;
					tempBodyWriter.write(""<Table>\n"");
					exportPage(page, null, 0, null, true);
					tempBodyWriter.write(""</Table>\n"");
					closeWorksheet();
				}
			}
			else{
				if (sheetNames != null && sheetIndex < sheetNames.length){
					tempBodyWriter.write(""<Worksheet ss:Name=\""""+getSheetName(sheetNames[sheetIndex])+""\"">\n"");
				}
				else{
					tempBodyWriter.write(""<Worksheet ss:Name=\""""+getSheetName(jasperPrint.getName())+""\"">\n"");
				}
				tempBodyWriter.write(""<Table>\n"");
				sheetIndex++;
				CutsInfo xCuts =JRGridLayout.calculateXCuts(nature, pages, startPageIndex, endPageIndex,jasperPrint.getPageWidth(), globalOffsetX);
				if (filter instanceof ResetableExporterFilter){
					((ResetableExporterFilter)filter).reset();
				}
				int startRow = 0;
				for(int pageIndex = startPageIndex;
				 pageIndex <= endPageIndex;
				 pageIndex++){
					if (Thread.interrupted()){
						throw new JRException(""Current thread interrupted."");
					}
					JRPrintPage page = (JRPrintPage)pages.get(pageIndex);
					startRow = exportPage(page, xCuts, startRow, null, pageIndex == startPageIndex);
				}
				tempBodyWriter.write(""</Table>\n"");
				closeWorksheet();
			}
		}
	}
	tempBodyWriter.flush();
	tempStyleWriter.flush();
	tempBodyWriter.close();
	tempStyleWriter.close();
	XmlssContentBuilder xmlssContentBuilder =new XmlssContentBuilder(writer,tempStyleWriter,tempBodyWriter);
	xmlssContentBuilder.build();
}",0,0,1,0
"public class Device {
	private String id;
	private String deviceType;
	private String name;
	private Authentication authentication;
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getDeviceType() {
		return deviceType;
	}
	public void setDeviceType(String deviceType) {
		this.deviceType = deviceType;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Authentication getAuthentication() {
		return authentication;
	}
	public void setAuthentication(Authentication authentication) {
		this.authentication = authentication;
	}
}",0,1,0,0
"public boolean compile(File skelroot, SkeletonBean skel, File basedir ,JSmoothModelBean data, File out) throws Exception {
	try {
		 fireStepChange(0, ""Starting compilation"");
		 File pattern = new File(skelroot, skel.getExecutableName());
		 if (pattern.exists() == false){
			 m_errors.add(""Error: Can't find any skeleton at "" + skelroot);
			 fireFailedChange();
			 return false;
		}
		 fireStepChange(10, ""Scanning skeleton..."");
		 PEFile pe = new PEFile(pattern);
		 pe.open();
		 PEResourceDirectory resdir = pe.getResourceDirectory();
		 boolean resb = false;
		 if (data.getEmbeddedJar() == true){
			 if (data.getJarLocation() == null){
				 m_errors.add(""Error: Jar is not specified!"");
				 fireFailedChange();
				 return false;
			}
			 fireStepChange(40, ""Loading Jar..."");
			 File jarloc = concFile(basedir, new File(data.getJarLocation()));
			 if (jarloc.exists() == false){
				 m_errors.add(""Error: Can't find jar at "" + jarloc);
				 fireFailedChange();
				 return false;
			}
			 ByteBuffer jardata = load(jarloc);
			 fireStepChange(60, ""Adding Jar to Resources..."");
			 resb = resdir.replaceResource(skel.getResourceCategory(), skel.getResourceJarId(), 1033, jardata);
			 if (resb == false){
				 m_errors.add(""Error: Can't replace jar resource! It is probably missing from the skeleton."");
				 fireFailedChange();
				 return false;
			}
		}
		 fireStepChange(70, ""Adding Properties to Resources..."");
		 String props = PropertiesBuilder.makeProperties(basedir, data);
		 ByteBuffer propdata = convert(props);
		 resb = resdir.replaceResource(skel.getResourceCategory(), skel.getResourcePropsId(), 1033, propdata);
		 if (data.getIconLocation() != null){
			 fireStepChange(80, ""Loading icon..."");
			 String iconpath;
			 if (new java.io.File(data.getIconLocation()).isAbsolute())iconpath = data.getIconLocation();
			 elseiconpath = new java.io.File(basedir, data.getIconLocation()).getAbsolutePath();
			 Image img = getScaledImage(iconpath, 32, 32);
			 Hashtable set = calculateColorCount(img);
			 if (img != null){
				 net.charabia.jsmoothgen.pe.res.ResIcon resicon = new net.charabia.jsmoothgen.pe.res.ResIcon(img);
				 pe.replaceDefaultIcon(resicon);
			}
		}
		 fireStepChange(90, ""Saving exe..."");
		 pe.dumpTo(out);
		 fireCompleteChange();
		 return true;
	}
	 catch (Exception exc) {
		m_errors.add(""Error: "" + exc.getMessage());
		exc.printStackTrace();
		fireFailedChange();
		return false;
	 }
 }",0,0,1,0
"public class ImportImpl extends ElementImpl implements Import{
	 protected static final String IMPORTED_NAMESPACE_EDEFAULT = null;
	 protected String importedNamespace = IMPORTED_NAMESPACE_EDEFAULT;
	 protected ImportImpl() {
		 super();
	 }
	 protected EClass eStaticClass() {
		 return SDomainPackage.Literals.IMPORT;
	 }
	 public String getImportedNamespace() {
		 return importedNamespace;
	 }
	 public void setImportedNamespace(String newImportedNamespace) {
		 String oldImportedNamespace = importedNamespace;
		 importedNamespace = newImportedNamespace;
		 if (eNotificationRequired()) eNotify(new ENotificationImpl(this, Notification.SET, SDomainPackage.IMPORT__IMPORTED_NAMESPACE, oldImportedNamespace, importedNamespace));
	 }
	 public Object eGet(int featureID, boolean resolve, boolean coreType) {
		 switch (featureID) {
			 case SDomainPackage.IMPORT__IMPORTED_NAMESPACE: return getImportedNamespace();
		 }
		 return super.eGet(featureID, resolve, coreType);
	 }
	 public void eSet(int featureID, Object newValue) {
		 switch (featureID) {
			 case SDomainPackage.IMPORT__IMPORTED_NAMESPACE: setImportedNamespace((String)newValue);
			 return;
		 }
		 super.eSet(featureID, newValue);
	 }
	 public void eUnset(int featureID) {
		 switch (featureID) {
			 case SDomainPackage.IMPORT__IMPORTED_NAMESPACE: setImportedNamespace(IMPORTED_NAMESPACE_EDEFAULT);
			 return;
		 }
		 super.eUnset(featureID);
	 }
	 public boolean eIsSet(int featureID) {
		 switch (featureID) {
			 case SDomainPackage.IMPORT__IMPORTED_NAMESPACE: return IMPORTED_NAMESPACE_EDEFAULT == null ? importedNamespace != null : !IMPORTED_NAMESPACE_EDEFAULT.equals(importedNamespace);
		 }
		 return super.eIsSet(featureID);
	 }
	 public String toString() {
		 if (eIsProxy()) return super.toString();
		 StringBuffer result = new StringBuffer(super.toString());
		 result.append("" (importedNamespace: "");
		 result.append(importedNamespace);
		 result.append(')');
		 return result.toString();
	 }
}",0,1,0,0
"public short syncAll(short syncMode) {
	 short syncState = SYNC_STATE_IN_SYNC;
	 s_logger.debug(""syncing cloudstack db with vnc"");
	 try {
		 for (Class<T> cls : _vncClasses) {
			 _lockSyncMode.lock();
			 _rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;
			 _dbSync.setSyncMode(syncMode);
			 if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
				 s_logger.debug(""sync check start: "" + DBSyncGeneric.getClassName(cls));
			 }
			 else {
				 s_logger.debug(""sync start: "" + DBSyncGeneric.getClassName(cls));
			 }
			 if (_dbSync.sync(cls) == false) {
				 if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
					 s_logger.info(""out of sync detected: "" + DBSyncGeneric.getClassName(cls));
				 }
				 else {
					 s_logger.info(""out of sync detected and re-synced: "" + DBSyncGeneric.getClassName(cls));
				 }
				 syncState = SYNC_STATE_OUT_OF_SYNC;
			 }
			 if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
				 s_logger.debug(""sync check finish: "" + DBSyncGeneric.getClassName(cls));
			 }
			 else {
				 s_logger.debug(""sync finish: "" + DBSyncGeneric.getClassName(cls));
			 }
			 _lockSyncMode.unlock();
		 }
	 }
	 catch (Exception ex) {
		 s_logger.warn(""DB Synchronization"", ex);
		 syncState = SYNC_STATE_UNKNOWN;
		 if (_lockSyncMode.isLocked()) {
			 _lockSyncMode.unlock();
		 }
	 }
	 return syncState;
 }",0,0,1,0
"public class SingleSignOnMessage implements ClusterMessage, Serializable {
	 public static final int ADD_SESSION = 1;
	 public static final int DEREGISTER_SESSION = 2;
	 public static final int LOGOUT_SESSION = 3;
	 public static final int REGISTER_SESSION = 4;
	 public static final int UPDATE_SESSION = 5;
	 public static final int REMOVE_SESSION = 6;
	 private int action = -1;
	 private String ssoId = null;
	 private String ctxname = null;
	 private String sessionId = null;
	 private String authType = null;
	 private String password = null;
	 private String username = null;
	 private Member address = null;
	 private long timestamp = 0;
	 private String uniqueId = null;
	 public SingleSignOnMessage(Member source, String ssoId, String sessionId) {
		 this.address = source;
		 this.ssoId = ssoId;
		 this.sessionId = sessionId;
	 }
	 public Member getAddress() {
		 return address;
	 }
	 public void setAddress(Member member) {
		 this.address = member;
	 }
	 public long getTimestamp() {
		 return timestamp;
	 }
	 public void setTimestamp(long timestamp) {
		 this.timestamp = timestamp;
	 }
	 public String getUniqueId() {
		 if (this.uniqueId != null) return this.uniqueId;
		 StringBuilder result = new StringBuilder(getSsoId());
		 result.append(""#-#"");
		 result.append(System.currentTimeMillis());
		 return result.toString();
	 }
	 public void setUniqueId(String uniqueId) {
		 this.uniqueId = uniqueId;
	 }
	 public int getAction() {
		 return action;
	 }
	 public void setAction(int action) {
		 this.action = action;
	 }
	 public String getSsoId() {
		 return ssoId;
	 }
	 public void setSsoId(String ssoId) {
		 this.ssoId = ssoId;
	 }
	 public String getContextName() {
		 return ctxname;
	 }
	 public void setContextName(String ctxname) {
		 this.ctxname = ctxname;
	 }
	 public String getSessionId() {
		 return sessionId;
	 }
	 public void setSessionId(String sessionId) {
		 this.sessionId = sessionId;
	 }
	 public String getAuthType() {
		 return authType;
	 }
	 public void setAuthType(String authType) {
		 this.authType = authType;
	 }
	 public String getPassword() {
		 return password;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public String getUsername() {
		 return username;
	 }
	 public void setUsername(String username) {
		 this.username = username;
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder(""SingleSignOnMessage[action="");
		 sb.append(getAction()).append("", ssoId="").append(getSsoId());
		 sb.append("", sessionId="").append(getSessionId()).append("", username="");
		 sb.append(getUsername()).append(""]"");
		 return (sb.toString());
	 }
}",0,1,0,0
"public static class Builder {
	 public static AddDomainOptions primaryNameServer(String primaryNameServer) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().primaryNameServer(primaryNameServer));
	 }
	 public static AddDomainOptions responsiblePerson(String responsiblePerson) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().responsiblePerson(responsiblePerson));
	 }
	 public static AddDomainOptions ttl(int ttl) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().ttl(ttl));
	 }
	 public static AddDomainOptions refresh(int refresh) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().refresh(refresh));
	 }
	 public static AddDomainOptions retry(int retry) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().retry(retry));
	 }
	 public static AddDomainOptions expire(int expire) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().expire(expire));
	 }
	 public static AddDomainOptions minimum(int minimum) {
		 return AddDomainOptions.class.cast(new AddDomainOptions().minimum(minimum));
	 }
	 public static AddDomainOptions minimalRecords() {
		 return AddDomainOptions.class.cast(new AddDomainOptions().minimalRecords());
	 }
 }",1,0,0,0
"public byte getByte(long offset) {
	 checkPosition(offset);
	 return unsafe.getByte(peer + offset);
 }",0,0,0,0
"private static void applyMigrationOnStage(final Migration m) throws SchemaDisagreementException, InvalidRequestException {
	 Future<T> f = StageManager.getStage(Stage.MIGRATION).submit(new Callable<Object>() {
		 public Object call() throws Exception {
			 m.apply();
			 m.announce();
			 return null;
		 }
	 }
	);
	 try {
		 f.get();
	 }
	 catch (InterruptedException e) {
		 throw new RuntimeException(e);
	 }
	 catch (ExecutionException e) {
		 if (e.getCause() != null) {
			 InvalidRequestException ex = new InvalidRequestException(e.getCause().getMessage());
			 ex.initCause(e.getCause());
			 throw ex;
		 }
		 else {
			 InvalidRequestException ex = new InvalidRequestException(e.getMessage());
			 ex.initCause(e);
			 throw ex;
		 }
	 }
	 validateSchemaIsSettled();
 }",0,0,0,0
"public class TableFrameXmlBean{
	 private int x;
	 private int y;
	 private int widht;
	 private int height;
	 public int getX() {
		 return x;
	 }
	 public void setX(int x) {
		 this.x = x;
	 }
	 public int getY() {
		 return y;
	 }
	 public void setY(int y) {
		 this.y = y;
	 }
	 public int getWidht() {
		 return widht;
	 }
	 public void setWidht(int widht) {
		 this.widht = widht;
	 }
	 public int getHeight() {
		 return height;
	 }
	 public void setHeight(int height) {
		 this.height = height;
	 }
}",0,1,0,0
"public static boolean handle(File tempFile, ParsedHookData data) {
	try {
		StringBuffer buf = new StringBuffer();
		InputStream in = new FileInputStream(tempFile);
		BufferedReader r = new BufferedReader(new InputStreamReader(in));
		while (true) {
			String ln = r.readLine();
			if (ln == null) {
				break;
			}
			buf.append(ln + ""\n"");
		}
		in.close();
		String keyword = ""\""progressive\"""";
		int index = buf.indexOf(keyword);
		if (index < 0) {
			return false;
		}
		index += keyword.length();
		index = buf.indexOf("":"", index);
		if (index < 0) {
			return false;
		}
		index++;
		index = buf.indexOf(""["", index);
		if (index < 0) {
			return false;
		}
		index++;
		int start = index;
		index = buf.indexOf(""]"", index);
		if (index < 0) {
			return false;
		}
		String str = buf.substring(start, index);
		index = 0;
		while (index != -1) {
			index = str.indexOf(""{
				"", index);
				if (index > -1) {
					index++;
					start = index;
				index = str.indexOf(""}
				"", index);
				if (index > -1) {
					String s = str.substring(start, index);
					processString(s, data);
				}
			}
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	return false;
}",0,0,1,0
"public class ElsqlComponentAutoConfiguration {
	 private static final Logger LOGGER = LoggerFactory .getLogger(ElsqlComponentAutoConfiguration.class);
	 private ApplicationContext applicationContext;
	 private CamelContext camelContext;
	 private ElsqlComponentConfiguration configuration;
	 private List<ComponentCustomizer<ElsqlComponent>> customizers;
	 static class GroupConditions extends GroupCondition {
		 public GroupConditions() {
			 super(""camel.component"", ""camel.component.elsql"");
		 }
	 }
	 public ElsqlComponent configureElsqlComponent() throws Exception {
		 ElsqlComponent component = new ElsqlComponent();
		 component.setCamelContext(camelContext);
		 Map<String, Object> parameters = new HashMap<>();
		 IntrospectionSupport.getProperties(configuration, parameters, null, false);
		 for (Map.Entry<String, Object> entry : parameters.entrySet()) {
			 Object value = entry.getValue();
			 Class<?> paramClass = value.getClass();
			 if (paramClass.getName().endsWith(""NestedConfiguration"")) {
				 Class nestedClass = null;
				 try {
					 nestedClass = (Class) paramClass.getDeclaredField( ""CAMEL_NESTED_CLASS"").get(null);
					 HashMap<String, Object> nestedParameters = new HashMap<>();
					 IntrospectionSupport.getProperties(value, nestedParameters, null, false);
					 Object nestedProperty = nestedClass.newInstance();
					 CamelPropertiesHelper.setCamelProperties(camelContext, nestedProperty, nestedParameters, false);
					 entry.setValue(nestedProperty);
				 }
				 catch (NoSuchFieldException e) {
				 }
			 }
		 }
		 CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);
		 if (ObjectHelper.isNotEmpty(customizers)) {
			 for (ComponentCustomizer<ElsqlComponent> customizer : customizers) {
				 boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), ""camel.component.customizer"", ""camel.component.elsql.customizer"", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), ""camel.component.customizer"", ""camel.component.elsql.customizer"");
				 if (useCustomizer) {
					 LOGGER.debug(""Configure component {
					}
					, with customizer {
					}
					"", component, customizer);
					 customizer.customize(component);
				 }
			 }
		 }
		 return component;
	 }
}",0,0,0,0
"public class ParserDML extends ParserDQL {
	 ParserDML(Session session, Scanner t) {
		 super(session, t);
	 }
	 StatementDMQL compileInsertStatement(RangeVariable[] outerRanges) {
		 read();
		 readThis(Tokens.INTO);
		 boolean[] columnCheckList;
		 int[] columnMap;
		 int colCount;
		 Table table = readTableName();
		 boolean overridingUser = false;
		 boolean overridingSystem = false;
		 boolean assignsToIdentity = false;
		 columnCheckList = null;
		 columnMap = table.getColumnMap();
		 colCount = table.getColumnCount();
		 int position = getPosition();
		 if (!table.isInsertable() && !table.isTriggerInsertable() && !session.isProcessingScript) {
			 throw Error.error(ErrorCode.X_42545);
		 }
		 Table baseTable = table.isTriggerInsertable() ? table : table.getBaseTable();
		 switch (token.tokenType) {
			 case Tokens.DEFAULT : {
				 read();
				 readThis(Tokens.VALUES);
				 Expression insertExpression = new Expression(OpTypes.ROW, new Expression[]{
				}
				);
				 insertExpression = new Expression(OpTypes.TABLE, new Expression[]{
				 insertExpression }
				);
				 columnCheckList = table.getNewColumnCheckList();
				 for (int i = 0;
				 i < table.colDefaults.length;
				 i++) {
					 if (table.colDefaults[i] == null && table.identityColumn != i) {
						 if (!table.getColumn(i).isGenerated()) {
							 throw Error.error(ErrorCode.X_42544);
						 }
					 }
				 }
				 StatementDMQL cs = new StatementInsert(session, table, columnMap, insertExpression, columnCheckList, compileContext);
				 return cs;
			 }
			 case Tokens.OPENBRACKET : {
				 int brackets = readOpenBrackets();
				 if (brackets == 1) {
					 boolean isQuery = false;
					 switch (token.tokenType) {
						 case Tokens.WITH : case Tokens.SELECT : case Tokens.TABLE : {
							 rewind(position);
							 isQuery = true;
							 break;
						 }
					 default : }
					 if (isQuery) {
						 break;
					 }
					 OrderedHashSet columnNames = new OrderedHashSet();
					 readSimpleColumnNames(columnNames, table);
					 readThis(Tokens.CLOSEBRACKET);
					 colCount = columnNames.size();
					 columnMap = table.getColumnIndexes(columnNames);
					 if (token.tokenType != Tokens.VALUES && token.tokenType != Tokens.OVERRIDING) {
						 break;
					 }
				 }
				 else {
					 rewind(position);
					 break;
				 }
			 }
			 case Tokens.OVERRIDING : {
				 if (token.tokenType == Tokens.OVERRIDING) {
					 read();
					 if (token.tokenType == Tokens.USER) {
						 read();
						 overridingUser = true;
					 }
					 else if (token.tokenType == Tokens.SYSTEM) {
						 read();
						 overridingSystem = true;
					 }
					 else {
						 unexpectedToken();
					 }
					 readThis(Tokens.VALUE);
					 if (token.tokenType != Tokens.VALUES) {
						 break;
					 }
				 }
			 }
			 case Tokens.VALUES : {
				 read();
				 columnCheckList = table.getColumnCheckList(columnMap);
				 Expression insertExpressions = XreadContextuallyTypedTable(colCount);
				 HsqlList unresolved = insertExpressions.resolveColumnReferences(outerRanges, null);
				 ExpressionColumn.checkColumnsResolved(unresolved);
				 insertExpressions.resolveTypes(session, null);
				 setParameterTypes(insertExpressions, table, columnMap);
				 if (table != baseTable) {
					 int[] baseColumnMap = table.getBaseTableColumnMap();
					 int[] newColumnMap = new int[columnMap.length];
					 ArrayUtil.projectRow(baseColumnMap, columnMap, newColumnMap);
					 columnMap = newColumnMap;
				 }
				 Expression[] rowList = insertExpressions.nodes;
				 for (int j = 0;
				 j < rowList.length;
				 j++) {
					 Expression[] rowArgs = rowList[j].nodes;
					 for (int i = 0;
					 i < rowArgs.length;
					 i++) {
						 Expression e = rowArgs[i];
						 ColumnSchema column = baseTable.getColumn(columnMap[i]);
						 if (column.isIdentity()) {
							 assignsToIdentity = true;
							 if (e.getType() != OpTypes.DEFAULT) {
								 if (table.identitySequence.isAlways()) {
									 if (!overridingUser && !overridingSystem) {
										 throw Error.error(ErrorCode.X_42543);
									 }
								 }
								 if (overridingUser) {
									 rowArgs[i] = new ExpressionColumn(OpTypes.DEFAULT);
								 }
							 }
						 }
						 else if (column.hasDefault()) {
						}
						 else if (column.isGenerated()) {
							 if (e.getType() != OpTypes.DEFAULT) {
								 throw Error.error(ErrorCode.X_42541);
							 }
						 }
						 else {
							 if (e.getType() == OpTypes.DEFAULT) {
								 throw Error.error(ErrorCode.X_42544);
							 }
						 }
						 if (e.isUnresolvedParam()) {
							 e.setAttributesAsColumn(column, true);
						 }
					 }
				 }
				 if (!assignsToIdentity && (overridingUser || overridingSystem)) {
					 unexpectedTokenRequire(Tokens.T_OVERRIDING);
				 }
				 StatementDMQL cs = new StatementInsert(session, table, columnMap, insertExpressions, columnCheckList, compileContext);
				 return cs;
			 }
			 case Tokens.WITH : case Tokens.SELECT : case Tokens.TABLE : {
				 break;
			 }
			 default : {
				 throw unexpectedToken();
			 }
		 }
		 columnCheckList = table.getColumnCheckList(columnMap);
		 if (baseTable != null && table != baseTable) {
			 int[] baseColumnMap = table.getBaseTableColumnMap();
			 int[] newColumnMap = new int[columnMap.length];
			 ArrayUtil.projectRow(baseColumnMap, columnMap, newColumnMap);
			 columnMap = newColumnMap;
		 }
		 int enforcedDefaultIndex = table.getIdentityColumnIndex();
		 int overrideIndex = -1;
		 if (enforcedDefaultIndex != -1 && ArrayUtil.find(columnMap, enforcedDefaultIndex) > -1) {
			 if (table.identitySequence.isAlways()) {
				 if (!overridingUser && !overridingSystem) {
					 throw Error.error(ErrorCode.X_42543);
				 }
			 }
			 if (overridingUser) {
				 overrideIndex = enforcedDefaultIndex;
			 }
		 }
		 else if (overridingUser || overridingSystem) {
			 unexpectedTokenRequire(Tokens.T_OVERRIDING);
		 }
		 Type[] types = new Type[columnMap.length];
		 ArrayUtil.projectRow(baseTable.getColumnTypes(), columnMap, types);
		 QueryExpression queryExpression = XreadQueryExpression();
		 queryExpression.setReturningResult();
		 queryExpression.resolve(session, outerRanges, types);
		 if (colCount != queryExpression.getColumnCount()) {
			 throw Error.error(ErrorCode.X_42546);
		 }
		 StatementDMQL cs = new StatementInsert(session, table, columnMap, columnCheckList, queryExpression, compileContext, overrideIndex);
		 return cs;
	 }
	 private static void setParameterTypes(Expression tableExpression, Table table, int[] columnMap) {
		 for (int i = 0;
		 i < tableExpression.nodes.length;
		 i++) {
			 Expression[] list = tableExpression.nodes[i].nodes;
			 for (int j = 0;
			 j < list.length;
			 j++) {
				 if (list[j].isUnresolvedParam()) {
					 list[j].setAttributesAsColumn( table.getColumn(columnMap[j]), true);
				 }
			 }
		 }
	 }
	 StatementDMQL compileDeleteStatement(RangeVariable[] outerRanges) {
		 Expression condition = null;
		 boolean truncate = false;
		 boolean restartIdentity = false;
		 int statementType;
		 switch (token.tokenType) {
			 case Tokens.TRUNCATE : {
				 read();
				 readThis(Tokens.TABLE);
				 truncate = true;
				 statementType = StatementTypes.TRUNCATE;
				 break;
			 }
			 case Tokens.DELETE : {
				 read();
				 readThis(Tokens.FROM);
				 statementType = StatementTypes.DELETE_WHERE;
				 break;
			 }
			 default : throw unexpectedToken();
		 }
		 RangeVariable[] rangeVariables = {
		 readSimpleRangeVariable(statementType) }
		;
		 Table table = rangeVariables[0].getTable();
		 Table baseTable = table.getBaseTable();
		 if (truncate) {
			 if (table != baseTable) {
				 throw Error.error(ErrorCode.X_42545);
			 }
			 if (table.isTriggerDeletable()) {
				 throw Error.error(ErrorCode.X_42545);
			 }
			 switch (token.tokenType) {
				 case Tokens.CONTINUE : {
					 read();
					 readThis(Tokens.IDENTITY);
					 break;
				 }
				 case Tokens.RESTART : {
					 read();
					 readThis(Tokens.IDENTITY);
					 restartIdentity = true;
					 break;
				 }
			 }
			 if (table.fkMainConstraints.length > 0) {
				 throw Error.error(ErrorCode.X_23504);
			 }
		 }
		 if (!truncate && token.tokenType == Tokens.WHERE) {
			 read();
			 condition = XreadBooleanValueExpression();
			 HsqlList unresolved = condition.resolveColumnReferences(outerRanges, null);
			 unresolved = Expression.resolveColumnSet(rangeVariables, rangeVariables.length, unresolved, null);
			 ExpressionColumn.checkColumnsResolved(unresolved);
			 condition.resolveTypes(session, null);
			 if (condition.isUnresolvedParam()) {
				 condition.dataType = Type.SQL_BOOLEAN;
			 }
			 if (condition.getDataType() != Type.SQL_BOOLEAN) {
				 throw Error.error(ErrorCode.X_42568);
			 }
		 }
		 if (baseTable == null) {
		 }
		 else if (table != baseTable) {
			 QuerySpecification baseSelect = ((TableDerived) table).getQueryExpression().getMainSelect();
			 RangeVariable[] newRangeVariables = (RangeVariable[]) ArrayUtil.duplicateArray( baseSelect.rangeVariables);
			 newRangeVariables[0] = baseSelect.rangeVariables[0].duplicate();
			 Expression[] newBaseExprColumns = new Expression[baseSelect.indexLimitData];
			 for (int i = 0;
			 i < baseSelect.indexLimitData;
			 i++) {
				 Expression e = baseSelect.exprColumns[i].duplicate();
				 newBaseExprColumns[i] = e;
				 e.replaceRangeVariables(baseSelect.rangeVariables, newRangeVariables);
			 }
			 Expression baseQueryCondition = baseSelect.queryCondition;
			 if (baseQueryCondition != null) {
				 baseQueryCondition = baseQueryCondition.duplicate();
				 baseQueryCondition.replaceRangeVariables(rangeVariables, newRangeVariables);
			 }
			 if (condition != null) {
				 condition = condition.replaceColumnReferences(rangeVariables[0], newBaseExprColumns);
			 }
			 rangeVariables = newRangeVariables;
			 condition = ExpressionLogical.andExpressions(baseQueryCondition, condition);
		 }
		 if (condition != null) {
			 rangeVariables[0].addJoinCondition(condition);
			 RangeVariableResolver resolver = new RangeVariableResolver(rangeVariables, null, compileContext);
			 resolver.processConditions(session);
			 rangeVariables = resolver.rangeVariables;
		 }
		 StatementDMQL cs = new StatementDML(session, table, rangeVariables, compileContext, restartIdentity, statementType);
		 return cs;
	 }
	 StatementDMQL compileUpdateStatement(RangeVariable[] outerRanges) {
		 read();
		 Expression[] updateExpressions;
		 int[] columnMap;
		 boolean[] columnCheckList;
		 OrderedHashSet targetSet = new OrderedHashSet();
		 LongDeque colIndexList = new LongDeque();
		 HsqlArrayList exprList = new HsqlArrayList();
		 RangeVariable[] rangeVariables = {
		 readSimpleRangeVariable(StatementTypes.UPDATE_WHERE) }
		;
		 Table table = rangeVariables[0].rangeTable;
		 Table baseTable = table.getBaseTable();
		 readThis(Tokens.SET);
		 readSetClauseList(rangeVariables, targetSet, colIndexList, exprList);
		 columnMap = new int[colIndexList.size()];
		 colIndexList.toArray(columnMap);
		 Expression[] targets = new Expression[targetSet.size()];
		 targetSet.toArray(targets);
		 for (int i = 0;
		 i < targets.length;
		 i++) {
			 this.resolveOuterReferencesAndTypes(outerRanges, targets[i]);
		 }
		 columnCheckList = table.getColumnCheckList(columnMap);
		 updateExpressions = new Expression[exprList.size()];
		 exprList.toArray(updateExpressions);
		 Expression condition = null;
		 if (token.tokenType == Tokens.WHERE) {
			 read();
			 condition = XreadBooleanValueExpression();
			 HsqlList unresolved = condition.resolveColumnReferences(outerRanges, null);
			 unresolved = Expression.resolveColumnSet(rangeVariables, rangeVariables.length, unresolved, null);
			 ExpressionColumn.checkColumnsResolved(unresolved);
			 condition.resolveTypes(session, null);
			 if (condition.isUnresolvedParam()) {
				 condition.dataType = Type.SQL_BOOLEAN;
			 }
			 if (condition.getDataType() != Type.SQL_BOOLEAN) {
				 throw Error.error(ErrorCode.X_42568);
			 }
		 }
		 resolveUpdateExpressions(table, rangeVariables, columnMap, updateExpressions, outerRanges);
		 if (table != baseTable) {
			 QuerySpecification baseSelect = ((TableDerived) table).getQueryExpression().getMainSelect();
			 RangeVariable[] newRangeVariables = (RangeVariable[]) ArrayUtil.duplicateArray( baseSelect.rangeVariables);
			 newRangeVariables[0] = baseSelect.rangeVariables[0].duplicate();
			 Expression[] newBaseExprColumns = new Expression[baseSelect.indexLimitData];
			 for (int i = 0;
			 i < baseSelect.indexLimitData;
			 i++) {
				 Expression e = baseSelect.exprColumns[i].duplicate();
				 newBaseExprColumns[i] = e;
				 e.replaceRangeVariables(baseSelect.rangeVariables, newRangeVariables);
			 }
			 Expression baseQueryCondition = baseSelect.queryCondition;
			 if (baseQueryCondition != null) {
				 baseQueryCondition = baseQueryCondition.duplicate();
				 baseQueryCondition.replaceRangeVariables(rangeVariables, newRangeVariables);
			 }
			 if (condition != null) {
				 condition = condition.replaceColumnReferences(rangeVariables[0], newBaseExprColumns);
			 }
			 for (int i = 0;
			 i < updateExpressions.length;
			 i++) {
				 updateExpressions[i] = updateExpressions[i].replaceColumnReferences( rangeVariables[0], newBaseExprColumns);
			 }
			 rangeVariables = newRangeVariables;
			 condition = ExpressionLogical.andExpressions(baseQueryCondition, condition);
		 }
		 if (condition != null) {
			 rangeVariables[0].addJoinCondition(condition);
			 RangeVariableResolver resolver = new RangeVariableResolver(rangeVariables, null, compileContext);
			 resolver.processConditions(session);
			 rangeVariables = resolver.rangeVariables;
		 }
		 if (baseTable != null && table != baseTable) {
			 int[] baseColumnMap = table.getBaseTableColumnMap();
			 int[] newColumnMap = new int[columnMap.length];
			 ArrayUtil.projectRow(baseColumnMap, columnMap, newColumnMap);
			 columnMap = newColumnMap;
			 for (int i = 0;
			 i < columnMap.length;
			 i++) {
				 if (baseTable.colGenerated[columnMap[i]]) {
					 throw Error.error(ErrorCode.X_42513);
				 }
			 }
		 }
		 StatementDMQL cs = new StatementDML(session, targets, table, rangeVariables, columnMap, updateExpressions, columnCheckList, compileContext);
		 return cs;
	 }
	 void resolveUpdateExpressions(Table targetTable, RangeVariable[] rangeVariables, int[] columnMap, Expression[] colExpressions, RangeVariable[] outerRanges) {
		 HsqlList unresolved = null;
		 int enforcedDefaultIndex = -1;
		 if (targetTable.hasIdentityColumn() && targetTable.identitySequence.isAlways()) {
			 enforcedDefaultIndex = targetTable.getIdentityColumnIndex();
		 }
		 for (int i = 0, ix = 0;
		 i < columnMap.length;
		 ix++) {
			 Expression expr = colExpressions[ix];
			 Expression e;
			 if (targetTable.colGenerated[columnMap[i]]) {
				 throw Error.error(ErrorCode.X_42513);
			 }
			 if (expr.getType() == OpTypes.ROW) {
				 Expression[] elements = expr.nodes;
				 for (int j = 0;
				 j < elements.length;
				 j++, i++) {
					 e = elements[j];
					 if (enforcedDefaultIndex == columnMap[i]) {
						 if (e.getType() != OpTypes.DEFAULT) {
							 throw Error.error(ErrorCode.X_42541);
						 }
					 }
					 if (e.isUnresolvedParam()) {
						 e.setAttributesAsColumn( targetTable.getColumn(columnMap[i]), true);
					 }
					 else if (e.getType() == OpTypes.DEFAULT) {
						 if (targetTable.colDefaults[columnMap[i]] == null && targetTable.identityColumn != columnMap[i]) {
							 throw Error.error(ErrorCode.X_42544);
						 }
					 }
					 else {
						 unresolved = expr.resolveColumnReferences(outerRanges, null);
						 unresolved = Expression.resolveColumnSet(rangeVariables, rangeVariables.length, unresolved, null);
						 ExpressionColumn.checkColumnsResolved(unresolved);
						 unresolved = null;
						 e.resolveTypes(session, null);
					 }
				 }
			 }
			 else if (expr.getType() == OpTypes.ROW_SUBQUERY) {
				 unresolved = expr.resolveColumnReferences(outerRanges, null);
				 unresolved = Expression.resolveColumnSet(rangeVariables, rangeVariables.length, unresolved, null);
				 ExpressionColumn.checkColumnsResolved(unresolved);
				 expr.resolveTypes(session, null);
				 int count = expr.subQuery.queryExpression.getColumnCount();
				 for (int j = 0;
				 j < count;
				 j++, i++) {
					 if (enforcedDefaultIndex == columnMap[i]) {
						 throw Error.error(ErrorCode.X_42541);
					 }
				 }
			 }
			 else {
				 e = expr;
				 if (enforcedDefaultIndex == columnMap[i]) {
					 if (e.getType() != OpTypes.DEFAULT) {
						 throw Error.error(ErrorCode.X_42541);
					 }
				 }
				 if (e.isUnresolvedParam()) {
					 e.setAttributesAsColumn( targetTable.getColumn(columnMap[i]), true);
				 }
				 else if (e.getType() == OpTypes.DEFAULT) {
					 if (targetTable.colDefaults[columnMap[i]] == null && targetTable.identityColumn != columnMap[i]) {
						 throw Error.error(ErrorCode.X_42544);
					 }
				 }
				 else {
					 unresolved = expr.resolveColumnReferences(outerRanges, null);
					 unresolved = Expression.resolveColumnSet(rangeVariables, rangeVariables.length, unresolved, null);
					 ExpressionColumn.checkColumnsResolved(unresolved);
					 e.resolveTypes(session, null);
				 }
				 i++;
			 }
		 }
	 }
	 void readSetClauseList(RangeVariable[] rangeVars, OrderedHashSet targets, LongDeque colIndexList, HsqlArrayList expressions) {
		 while (true) {
			 int degree;
			 if (token.tokenType == Tokens.OPENBRACKET) {
				 read();
				 int oldCount = targets.size();
				 readTargetSpecificationList(targets, rangeVars, colIndexList);
				 degree = targets.size() - oldCount;
				 readThis(Tokens.CLOSEBRACKET);
			 }
			 else {
				 Expression target = XreadTargetSpecification(rangeVars, colIndexList);
				 if (!targets.add(target)) {
					 ColumnSchema col = target.getColumn();
					 throw Error.error(ErrorCode.X_42579, col.getName().name);
				 }
				 degree = 1;
			 }
			 readThis(Tokens.EQUALS);
			 int position = getPosition();
			 int brackets = readOpenBrackets();
			 if (token.tokenType == Tokens.SELECT) {
				 rewind(position);
				 SubQuery sq = XreadSubqueryBody(false, OpTypes.ROW_SUBQUERY);
				 if (degree != sq.queryExpression.getColumnCount()) {
					 throw Error.error(ErrorCode.X_42546);
				 }
				 Expression e = new Expression(OpTypes.ROW_SUBQUERY, sq);
				 expressions.add(e);
				 if (token.tokenType == Tokens.COMMA) {
					 read();
					 continue;
				 }
				 break;
			 }
			 if (brackets > 0) {
				 rewind(position);
			 }
			 if (degree > 1) {
				 readThis(Tokens.OPENBRACKET);
				 Expression e = readRow();
				 readThis(Tokens.CLOSEBRACKET);
				 int rowDegree = e.getType() == OpTypes.ROW ? e.nodes.length : 1;
				 if (degree != rowDegree) {
					 throw Error.error(ErrorCode.X_42546);
				 }
				 expressions.add(e);
			 }
			 else {
				 Expression e = XreadValueExpressionWithContext();
				 expressions.add(e);
			 }
			 if (token.tokenType == Tokens.COMMA) {
				 read();
				 continue;
			 }
			 break;
		 }
	 }
	 StatementDMQL compileMergeStatement(RangeVariable[] outerRanges) {
		 boolean[] insertColumnCheckList;
		 int[] insertColumnMap = null;
		 int[] updateColumnMap = null;
		 int[] baseUpdateColumnMap;
		 Table table;
		 RangeVariable targetRange;
		 RangeVariable sourceRange;
		 Expression mergeCondition;
		 Expression[] targets = null;
		 HsqlArrayList updateList = new HsqlArrayList();
		 Expression[] updateExpressions = Expression.emptyArray;
		 HsqlArrayList insertList = new HsqlArrayList();
		 Expression insertExpression = null;
		 read();
		 readThis(Tokens.INTO);
		 targetRange = readSimpleRangeVariable(StatementTypes.MERGE);
		 table = targetRange.rangeTable;
		 readThis(Tokens.USING);
		 sourceRange = readTableOrSubquery();
		 readThis(Tokens.ON);
		 mergeCondition = XreadBooleanValueExpression();
		 if (mergeCondition.getDataType() != Type.SQL_BOOLEAN) {
			 throw Error.error(ErrorCode.X_42568);
		 }
		 RangeVariable[] fullRangeVars = new RangeVariable[] {
		 sourceRange, targetRange }
		;
		 RangeVariable[] sourceRangeVars = new RangeVariable[]{
		 sourceRange }
		;
		 RangeVariable[] targetRangeVars = new RangeVariable[]{
		 targetRange }
		;
		 insertColumnMap = table.getColumnMap();
		 insertColumnCheckList = table.getNewColumnCheckList();
		 OrderedHashSet updateTargetSet = new OrderedHashSet();
		 OrderedHashSet insertColNames = new OrderedHashSet();
		 LongDeque updateColIndexList = new LongDeque();
		 readMergeWhen(updateColIndexList, insertColNames, updateTargetSet, insertList, updateList, targetRangeVars, sourceRange);
		 if (insertList.size() > 0) {
			 int colCount = insertColNames.size();
			 if (colCount != 0) {
				 insertColumnMap = table.getColumnIndexes(insertColNames);
				 insertColumnCheckList = table.getColumnCheckList(insertColumnMap);
			 }
			 insertExpression = (Expression) insertList.get(0);
			 setParameterTypes(insertExpression, table, insertColumnMap);
		 }
		 if (updateList.size() > 0) {
			 targets = new Expression[updateTargetSet.size()];
			 updateTargetSet.toArray(targets);
			 for (int i = 0;
			 i < targets.length;
			 i++) {
				 this.resolveOuterReferencesAndTypes(outerRanges, targets[i]);
			 }
			 updateExpressions = new Expression[updateList.size()];
			 updateList.toArray(updateExpressions);
			 updateColumnMap = new int[updateColIndexList.size()];
			 updateColIndexList.toArray(updateColumnMap);
		 }
		 if (updateExpressions.length != 0) {
			 Table baseTable = table.getBaseTable();
			 baseUpdateColumnMap = updateColumnMap;
			 if (table != baseTable) {
				 baseUpdateColumnMap = new int[updateColumnMap.length];
				 ArrayUtil.projectRow(table.getBaseTableColumnMap(), updateColumnMap, baseUpdateColumnMap);
			 }
			 resolveUpdateExpressions(table, sourceRangeVars, updateColumnMap, updateExpressions, outerRanges);
		 }
		 HsqlList unresolved = null;
		 unresolved = mergeCondition.resolveColumnReferences(fullRangeVars, null);
		 ExpressionColumn.checkColumnsResolved(unresolved);
		 mergeCondition.resolveTypes(session, null);
		 if (mergeCondition.isUnresolvedParam()) {
			 mergeCondition.dataType = Type.SQL_BOOLEAN;
		 }
		 if (mergeCondition.getDataType() != Type.SQL_BOOLEAN) {
			 throw Error.error(ErrorCode.X_42568);
		 }
		 RangeVariableResolver resolver = new RangeVariableResolver(fullRangeVars, mergeCondition, compileContext);
		 resolver.processConditions(session);
		 fullRangeVars = resolver.rangeVariables;
		 if (insertExpression != null) {
			 unresolved = insertExpression.resolveColumnReferences(sourceRangeVars, unresolved);
			 ExpressionColumn.checkColumnsResolved(unresolved);
			 insertExpression.resolveTypes(session, null);
		 }
		 StatementDMQL cs = new StatementDML(session, targets, fullRangeVars, insertColumnMap, updateColumnMap, insertColumnCheckList, mergeCondition, insertExpression, updateExpressions, compileContext);
		 return cs;
	 }
	 private void readMergeWhen(LongDeque updateColIndexList, OrderedHashSet insertColumnNames, OrderedHashSet updateTargetSet, HsqlArrayList insertExpressions, HsqlArrayList updateExpressions, RangeVariable[] targetRangeVars, RangeVariable sourceRangeVar) {
		 Table table = targetRangeVars[0].rangeTable;
		 int columnCount = table.getColumnCount();
		 readThis(Tokens.WHEN);
		 if (token.tokenType == Tokens.MATCHED) {
			 if (updateExpressions.size() != 0) {
				 throw Error.error(ErrorCode.X_42547);
			 }
			 read();
			 readThis(Tokens.THEN);
			 readThis(Tokens.UPDATE);
			 readThis(Tokens.SET);
			 readSetClauseList(targetRangeVars, updateTargetSet, updateColIndexList, updateExpressions);
		 }
		 else if (token.tokenType == Tokens.NOT) {
			 if (insertExpressions.size() != 0) {
				 throw Error.error(ErrorCode.X_42548);
			 }
			 read();
			 readThis(Tokens.MATCHED);
			 readThis(Tokens.THEN);
			 readThis(Tokens.INSERT);
			 int brackets = readOpenBrackets();
			 if (brackets == 1) {
				 readSimpleColumnNames(insertColumnNames, targetRangeVars[0]);
				 columnCount = insertColumnNames.size();
				 readThis(Tokens.CLOSEBRACKET);
				 brackets = 0;
			 }
			 readThis(Tokens.VALUES);
			 Expression e = XreadContextuallyTypedTable(columnCount);
			 if (e.nodes.length != 1) {
				 throw Error.error(ErrorCode.X_21000);
			 }
			 insertExpressions.add(e);
		 }
		 else {
			 throw unexpectedToken();
		 }
		 if (token.tokenType == Tokens.WHEN) {
			 readMergeWhen(updateColIndexList, insertColumnNames, updateTargetSet, insertExpressions, updateExpressions, targetRangeVars, sourceRangeVar);
		 }
	 }
	 StatementDMQL compileCallStatement(RangeVariable[] outerRanges, boolean isStrictlyProcedure) {
		 read();
		 if (isIdentifier()) {
			 checkValidCatalogName(token.namePrePrefix);
			 RoutineSchema routineSchema = (RoutineSchema) database.schemaManager.findSchemaObject( token.tokenString, session.getSchemaName(token.namePrefix), SchemaObject.PROCEDURE);
			 if (routineSchema != null) {
				 read();
				 HsqlArrayList list = new HsqlArrayList();
				 readThis(Tokens.OPENBRACKET);
				 if (token.tokenType == Tokens.CLOSEBRACKET) {
					 read();
				 }
				 else {
					 while (true) {
						 Expression e = XreadValueExpression();
						 list.add(e);
						 if (token.tokenType == Tokens.COMMA) {
							 read();
						 }
						 else {
							 readThis(Tokens.CLOSEBRACKET);
							 break;
						 }
					 }
				 }
				 Expression[] arguments = new Expression[list.size()];
				 list.toArray(arguments);
				 Routine routine = routineSchema.getSpecificRoutine(arguments.length);
				 compileContext.addProcedureCall(routine);
				 HsqlList unresolved = null;
				 for (int i = 0;
				 i < arguments.length;
				 i++) {
					 Expression e = arguments[i];
					 if (e.isUnresolvedParam()) {
						 e.setAttributesAsColumn( routine.getParameter(i), routine.getParameter(i).isWriteable());
					 }
					 else {
						 int paramMode = routine.getParameter(i).getParameterMode();
						 unresolved = arguments[i].resolveColumnReferences(outerRanges, unresolved);
						 if (paramMode != SchemaObject.ParameterModes.PARAM_IN) {
							 if (e.getType() != OpTypes.VARIABLE) {
								 throw Error.error(ErrorCode.X_42603);
							 }
						 }
					 }
				 }
				 ExpressionColumn.checkColumnsResolved(unresolved);
				 for (int i = 0;
				 i < arguments.length;
				 i++) {
					 arguments[i].resolveTypes(session, null);
					 if (!routine.getParameter( i).getDataType().canBeAssignedFrom( arguments[i].getDataType())) {
						 throw Error.error(ErrorCode.X_42561);
					 }
				 }
				 StatementDMQL cs = new StatementProcedure(session, routine, arguments, compileContext);
				 return cs;
			 }
		 }
		 if (isStrictlyProcedure) {
			 throw Error.error(ErrorCode.X_42501, token.tokenString);
		 }
		 Expression expression = this.XreadValueExpression();
		 HsqlList unresolved = expression.resolveColumnReferences(outerRanges, null);
		 ExpressionColumn.checkColumnsResolved(unresolved);
		 expression.resolveTypes(session, null);
		 StatementDMQL cs = new StatementProcedure(session, expression, compileContext);
		 return cs;
	 }
	 void resolveOuterReferencesAndTypes(RangeVariable[] rangeVars, Expression e) {
		 HsqlList unresolved = e.resolveColumnReferences(rangeVars, rangeVars.length, null, false);
		 unresolved = Expression.resolveColumnSet(rangeVars, rangeVars.length, unresolved, null);
		 ExpressionColumn.checkColumnsResolved(unresolved);
		 e.resolveTypes(session, null);
	 }
}",1,0,0,0
"public class WebRequestEncoder{
	boolean firstParameter = true;
	AppendingStringBuffer url;
	public WebRequestEncoder(AppendingStringBuffer url){
		if (url.indexOf(""?"") >= 0){
			firstParameter = false;
		}
		this.url = url;
	}
	public void addValue(String key, Object value){
		if (value instanceof String[]){
			String[] values = (String[])value;
			for (int i = 0;
			 i < values.length;
			 i++){
				addValue(key, values[i]);
			}
		}
		else if (value instanceof String){
			addValue(key, (String)value);
		}
		else{
			addValue(key, value.toString());
		}
	}
	public void addValue(String key, String value){
		if (!firstParameter){
			url.append('&');
		}
		else{
			firstParameter = false;
			url.append('?');
		}
		url.append(WicketURLEncoder.QUERY_INSTANCE.encode(key));
		url.append('=');
		url.append(WicketURLEncoder.QUERY_INSTANCE.encode(value));
	}
}",0,0,0,0
"private boolean processDashSegment(ParsedHookData data) {
	try {
		URL url = new URL(data.getUrl());
		String host = url.getHost();
		if (!(host.contains(""youtube.com"") || host.contains(""googlevideo.com""))) {
			Logger.log(""non yt host"");
			return false;
		}
		String type = data.getContentType();
		if (type == null) {
			type = """";
		}
		if (!(type.contains(""audio/"") || type.contains(""video/"") || type.contains(""application/octet""))) {
			Logger.log(""non yt type"");
			return false;
		}
		String low_path = data.getUrl().toLowerCase();
		if (low_path.indexOf(""videoplayback"") >= 0 && low_path.indexOf(""itag"") >= 0) {
			if (StringUtils.isNullOrEmptyOrBlank(url.getQuery())) {
				return false;
			}
			int index = data.getUrl().indexOf(""?"");
			String path = data.getUrl().substring(0, index);
			String query = data.getUrl().substring(index + 1);
			String arr[] = query.split(""&"");
			StringBuilder yt_url = new StringBuilder();
			yt_url.append(path + ""?"");
			int itag = 0;
			long clen = 0;
			String id = """";
			String mime = """";
			for (int i = 0;
			 i < arr.length;
			 i++) {
				String str = arr[i];
				index = str.indexOf(""="");
				if (index > 0) {
					String key = str.substring(0, index).trim();
					String val = str.substring(index + 1).trim();
					if (key.startsWith(""range"")) {
						continue;
					}
					if (key.equals(""itag"")) {
						itag = Integer.parseInt(val);
					}
					if (key.equals(""clen"")) {
						clen = Integer.parseInt(val);
					}
					if (key.startsWith(""mime"")) {
						mime = URLDecoder.decode(val, ""UTF-8"");
					}
					if (str.startsWith(""id"")) {
						id = val;
					}
				}
				yt_url.append(str);
				if (i < arr.length - 1) {
					yt_url.append(""&"");
				}
			}
			if (itag != 0) {
				if (YtUtil.isNormalVideo(itag)) {
					Logger.log(""Normal vid"");
					return false;
				}
			}
			DASH_INFO info = new DASH_INFO();
			info.url = yt_url.toString();
			info.clen = clen;
			info.video = mime.startsWith(""video"");
			info.itag = itag;
			info.id = id;
			info.mime = mime;
			info.headers = data.getRequestHeaders();
			Logger.log(""processing yt mime: "" + mime + "" id: "" + id + "" clen: "" + clen + "" itag: "" + itag);
			if (YtUtil.addToQueue(info)) {
				DASH_INFO di = YtUtil.getDASHPair(info);
				if (di != null) {
					DashMetadata dm = new DashMetadata();
					dm.setUrl(info.video ? info.url : di.url);
					dm.setUrl2(info.video ? di.url : info.url);
					dm.setLen1(info.video ? info.clen : di.clen);
					dm.setLen2(info.video ? di.clen : info.clen);
					dm.setHeaders(info.video ? info.headers : di.headers);
					dm.setHeaders2(info.video ? di.headers : info.headers);
					String file = data.getFile();
					if (StringUtils.isNullOrEmptyOrBlank(file)) {
						file = XDMUtils.getFileName(data.getUrl());
					}
					Logger.log(""file: "" + file + "" url1: "" + dm.getUrl() + "" url2: "" + dm.getUrl2() + "" len1: ""+ dm.getLen1() + "" len2: "" + dm.getLen2());
					String szStr = null;
					if (info.clen > 0 && di.clen > 0) {
						szStr = FormatUtilities.formatSize(info.clen + di.clen);
					}
					String videoContentType = info.video ? info.mime : di.mime;
					String audioContentType = di.video ? di.mime : info.mime;
					String ext = getYtDashFormat(videoContentType, audioContentType);
					file += ""."" + ext;
					if (info.video) {
					}
					XDMApp.getInstance().addMedia(dm, file, YtUtil.getInfoFromITAG(info.video ? info.itag : di.itag)+ (szStr == null ? """" : "" "" + szStr));
					return true;
				}
			}
			return true;
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	return false;
}",0,0,1,0
"public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
	 public JDBCAccessLogValve() {
		 super(false);
		 driverName = null;
		 connectionURL = null;
		 tableName = ""access"";
		 remoteHostField = ""remoteHost"";
		 userField = ""userName"";
		 timestampField = ""timestamp"";
		 virtualHostField = ""virtualHost"";
		 methodField = ""method"";
		 queryField = ""query"";
		 statusField = ""status"";
		 bytesField = ""bytes"";
		 refererField = ""referer"";
		 userAgentField = ""userAgent"";
		 pattern = ""common"";
		 resolveHosts = false;
		 conn = null;
		 ps = null;
		 currentTimeMillis = new java.util.Date().getTime();
	 }
	 protected boolean useLongContentLength = false ;
	 protected String connectionName = null;
	 protected String connectionPassword = null;
	 protected Driver driver = null;
	 private String driverName;
	 private String connectionURL;
	 private String tableName;
	 private String remoteHostField;
	 private String userField;
	 private String timestampField;
	 private String virtualHostField;
	 private String methodField;
	 private String queryField;
	 private String statusField;
	 private String bytesField;
	 private String refererField;
	 private String userAgentField;
	 private String pattern;
	 private boolean resolveHosts;
	 private Connection conn;
	 private PreparedStatement ps;
	 private long currentTimeMillis;
	 protected static final String info = ""org.apache.catalina.valves.JDBCAccessLogValve/1.1"";
	 private static final StringManager sm = StringManager.getManager(Constants.Package);
	 public String getConnectionName() {
		 return connectionName;
	 }
	 public void setConnectionName(String connectionName) {
		 this.connectionName = connectionName;
	 }
	 public void setDriverName(String driverName) {
		 this.driverName = driverName;
	 }
	 public String getConnectionPassword() {
		 return connectionPassword;
	 }
	 public void setConnectionPassword(String connectionPassword) {
		 this.connectionPassword = connectionPassword;
	 }
	 public void setConnectionURL(String connectionURL) {
		 this.connectionURL = connectionURL;
	 }
	 public void setTableName(String tableName) {
		 this.tableName = tableName;
	 }
	 public void setRemoteHostField(String remoteHostField) {
		 this.remoteHostField = remoteHostField;
	 }
	 public void setUserField(String userField) {
		 this.userField = userField;
	 }
	 public void setTimestampField(String timestampField) {
		 this.timestampField = timestampField;
	 }
	 public void setVirtualHostField(String virtualHostField) {
		 this.virtualHostField = virtualHostField;
	 }
	 public void setMethodField(String methodField) {
		 this.methodField = methodField;
	 }
	 public void setQueryField(String queryField) {
		 this.queryField = queryField;
	 }
	 public void setStatusField(String statusField) {
		 this.statusField = statusField;
	 }
	 public void setBytesField(String bytesField) {
		 this.bytesField = bytesField;
	 }
	 public void setRefererField(String refererField) {
		 this.refererField = refererField;
	 }
	 public void setUserAgentField(String userAgentField) {
		 this.userAgentField = userAgentField;
	 }
	 public void setPattern(String pattern) {
		 this.pattern = pattern;
	 }
	 public void setResolveHosts(String resolveHosts) {
		 this.resolveHosts = new Boolean(resolveHosts).booleanValue();
	 }
	 public boolean getUseLongContentLength() {
		 return this.useLongContentLength ;
	 }
	 public void setUseLongContentLength(boolean useLongContentLength) {
		 this.useLongContentLength = useLongContentLength;
	 }
	 public void invoke(Request request, Response response) throws IOException, ServletException {
		 getNext().invoke(request, response);
		 log (request, response, 0);
	 }
	 public void log(Request request, Response response, long time) {
		 final String EMPTY = """" ;
		 String remoteHost;
		 if(resolveHosts) remoteHost = request.getRemoteHost();
		 else remoteHost = request.getRemoteAddr();
		 String user = request.getRemoteUser();
		 String query=request.getRequestURI();
		 long bytes = response.getContentCountLong() ;
		 if(bytes < 0) bytes = 0;
		 int status = response.getStatus();
		 String virtualHost = EMPTY;
		 String method = EMPTY;
		 String referer = EMPTY;
		 String userAgent = EMPTY;
		 if (pattern.equals(""combined"")) {
			 virtualHost = request.getServerName();
			 method = request.getMethod();
			 referer = request.getHeader(""referer"");
			 userAgent = request.getHeader(""user-agent"");
		 }
		 synchronized (this) {
			 int numberOfTries = 2;
			 while (numberOfTries>0) {
				 try {
					 open();
					 ps.setString(1, remoteHost);
					 ps.setString(2, user);
					 ps.setTimestamp(3, new Timestamp(getCurrentTimeMillis()));
					 ps.setString(4, query);
					 ps.setInt(5, status);
					 if(useLongContentLength) {
						 ps.setLong(6, bytes);
					 }
					 else {
						 if (bytes > Integer.MAX_VALUE) bytes = -1 ;
						 ps.setInt(6, (int) bytes);
					 }
					 if (pattern.equals(""combined"")) {
						 ps.setString(7, virtualHost);
						 ps.setString(8, method);
						 ps.setString(9, referer);
						 ps.setString(10, userAgent);
					 }
					 ps.executeUpdate();
					 return;
				 }
				 catch (SQLException e) {
					 container.getLogger().error(sm.getString(""jdbcAccessLogValve.exception""), e);
					 if (conn != null) close();
				 }
				 numberOfTries--;
			 }
		 }
	 }
	 protected void open() throws SQLException {
		 if (conn != null) return ;
		 if (driver == null) {
			 try {
				 Class<?> clazz = Class.forName(driverName);
				 driver = (Driver) clazz.newInstance();
			 }
			 catch (Throwable e) {
				 throw new SQLException(e.getMessage());
			 }
		 }
		 Properties props = new Properties();
		 props.put(""autoReconnect"", ""true"");
		 if (connectionName != null) props.put(""user"", connectionName);
		 if (connectionPassword != null) props.put(""password"", connectionPassword);
		 conn = driver.connect(connectionURL, props);
		 conn.setAutoCommit(true);
		 if (pattern.equals(""common"")) {
			 ps = conn.prepareStatement (""INSERT INTO "" + tableName + "" ("" + remoteHostField + "", "" + userField + "", "" + timestampField +"", "" + queryField + "", "" + statusField + "", "" + bytesField + "") VALUES(?, ?, ?, ?, ?, ?)"");
		 }
		 else if (pattern.equals(""combined"")) {
			 ps = conn.prepareStatement (""INSERT INTO "" + tableName + "" ("" + remoteHostField + "", "" + userField + "", "" + timestampField + "", "" + queryField + "", "" + statusField + "", "" + bytesField + "", "" + virtualHostField + "", "" + methodField + "", "" + refererField + "", "" + userAgentField + "") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"");
		 }
	 }
	 protected void close() {
		 if (conn == null) return;
		 try {
			 ps.close();
		 }
		 catch (Throwable f) {
			 ExceptionUtils.handleThrowable(f);
		 }
		 this.ps = null;
		 try {
			 conn.close();
		 }
		 catch (SQLException e) {
			 container.getLogger().error(sm.getString(""jdbcAccessLogValeve.close""), e);
		 }
		 finally {
			 this.conn = null;
		 }
	 }
	 protected synchronized void startInternal() throws LifecycleException {
		 try {
			 open() ;
		 }
		 catch (SQLException e) {
			 throw new LifecycleException(e);
		 }
		 setState(LifecycleState.STARTING);
	 }
	 protected synchronized void stopInternal() throws LifecycleException {
		 setState(LifecycleState.STOPPING);
		 close() ;
	 }
	 public long getCurrentTimeMillis() {
		 long systime = System.currentTimeMillis();
		 if ((systime - currentTimeMillis) > 1000) {
			 currentTimeMillis = new java.util.Date(systime).getTime();
		 }
		 return currentTimeMillis;
	 }
}",0,0,0,0
"void cleanup() {
	for (final BundleWire requiredWire : requiredWires.getAllValues()) {
		final ConciergeBundleWiring bw = ((ConciergeBundleWire) requiredWire).providerWiring;
		if (bw != null) {
			bw.inUseSet.remove(revision);
		}
	}
	for (final BundleWire hostWire : providedWires.lookup(HostNamespace.HOST_NAMESPACE)) {
		final ConciergeBundleWiring bw = ((ConciergeBundleWire) hostWire).requirerWiring;
		if (bw != null) {
			bw.inUseSet.remove(revision);
		}
	}
}",0,0,1,0
"public class DynamicWebAppClusterImpl extends DynamicClusterImpl implements DynamicWebAppCluster {
	 private static final Logger log = LoggerFactory.getLogger(DynamicWebAppClusterImpl.class);
	 private static final FilenameToWebContextMapper FILENAME_TO_WEB_CONTEXT_MAPPER = new FilenameToWebContextMapper();
	 public DynamicWebAppClusterImpl() {
		 super();
	 }
	 public void init() {
		 super.init();
		 List<? extends List<? extends AttributeSensor<? extends Number>>> summingEnricherSetup = ImmutableList.of( ImmutableList.of(REQUEST_COUNT, REQUEST_COUNT), ImmutableList.of(ERROR_COUNT, ERROR_COUNT), ImmutableList.of(REQUESTS_PER_SECOND_LAST, REQUESTS_PER_SECOND_LAST), ImmutableList.of(REQUESTS_PER_SECOND_IN_WINDOW, REQUESTS_PER_SECOND_IN_WINDOW), ImmutableList.of(TOTAL_PROCESSING_TIME, TOTAL_PROCESSING_TIME), ImmutableList.of(PROCESSING_TIME_FRACTION_IN_WINDOW, PROCESSING_TIME_FRACTION_IN_WINDOW) );
		 List<? extends List<? extends AttributeSensor<? extends Number>>> averagingEnricherSetup = ImmutableList.of( ImmutableList.of(REQUEST_COUNT, REQUEST_COUNT_PER_NODE), ImmutableList.of(ERROR_COUNT, ERROR_COUNT_PER_NODE), ImmutableList.of(REQUESTS_PER_SECOND_LAST, REQUESTS_PER_SECOND_LAST_PER_NODE), ImmutableList.of(REQUESTS_PER_SECOND_IN_WINDOW, REQUESTS_PER_SECOND_IN_WINDOW_PER_NODE), ImmutableList.of(TOTAL_PROCESSING_TIME, TOTAL_PROCESSING_TIME_PER_NODE), ImmutableList.of(PROCESSING_TIME_FRACTION_IN_WINDOW, PROCESSING_TIME_FRACTION_IN_WINDOW_PER_NODE) );
		 for (List<? extends AttributeSensor<? extends Number>> es : summingEnricherSetup) {
			 AttributeSensor<? extends Number> t = es.get(0);
			 AttributeSensor<? extends Number> total = es.get(1);
			 enrichers().add(Enrichers.builder() .aggregating(t) .publishing(total) .fromMembers() .computingSum() .build());
		 }
		 for (List<? extends AttributeSensor<? extends Number>> es : averagingEnricherSetup) {
			 AttributeSensor<Number> t = (AttributeSensor<Number>) es.get(0);
			 AttributeSensor<Double> average = (AttributeSensor<Double>) es.get(1);
			 enrichers().add(Enrichers.builder() .aggregating(t) .publishing(average) .fromMembers() .computingAverage() .defaultValueForUnreportedSensors(0) .build());
		 }
	 }
	 static <T> Task<T> whenServiceUp(final Entity target, final TaskAdaptable<T> task, String name) {
		 return Tasks.<T>builder().displayName(name).dynamic(true).body(new Callable<T>() {
			 public T call() {
				 try {
					 while (true) {
						 if (!Entities.isManaged(target)) {
							 Tasks.markInessential();
							 throw new IllegalStateException(""Target ""+target+"" is no longer managed"");
						 }
						 if (Boolean.TRUE.equals(target.getAttribute(Attributes.SERVICE_UP))) {
							 Tasks.resetBlockingDetails();
							 TaskTags.markInessential(task);
							 DynamicTasks.queue(task);
							 try {
								 return task.asTask().getUnchecked();
							 }
							 catch (Exception e) {
								 if (Entities.isManaged(target)) {
									 throw Exceptions.propagate(e);
								 }
								 else {
									 Tasks.markInessential();
									 throw new IllegalStateException(""Target ""+target+"" is no longer managed"", e);
								 }
							 }
						 }
						 else {
							 Tasks.setBlockingDetails(""Waiting on ""+target+"" to be ready"");
						 }
						 Time.sleep(Duration.ONE_SECOND);
					 }
				 }
				 finally {
					 Tasks.resetBlockingDetails();
				 }
			 }
		 }
		).build();
	 }
	 public void deploy(String url, String targetName) {
		 checkNotNull(url, ""url"");
		 checkNotNull(targetName, ""targetName"");
		 targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
		 addToWarsByContext(this, url, targetName);
		 log.debug(""Deploying ""+targetName+""->""+url+"" across cluster ""+this+"";
		 WARs now ""+getConfig(WARS_BY_CONTEXT));
		 Iterable<CanDeployAndUndeploy> targets = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);
		 TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).displayName(""Deploy ""+targetName+"" to cluster (size ""+Iterables.size(targets)+"")"");
		 for (Entity target: targets) {
			 tb.add(whenServiceUp(target, Effectors.invocation(target, DEPLOY, MutableMap.of(""url"", url, ""targetName"", targetName)), ""Deploy ""+targetName+"" to ""+target+"" when ready""));
		 }
		 DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();
		 Set<String> deployedWars = MutableSet.copyOf(getAttribute(DEPLOYED_WARS));
		 deployedWars.add(targetName);
		 sensors().set(DEPLOYED_WARS, deployedWars);
	 }
	 public void undeploy(String targetName) {
		 checkNotNull(targetName, ""targetName"");
		 targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
		 if (!removeFromWarsByContext(this, targetName)) {
			 DynamicTasks.submit(Tasks.warning(""Context ""+targetName+"" not known at ""+this+"";
			 attempting to undeploy regardless"", null), this);
		 }
		 log.debug(""Undeploying ""+targetName+"" across cluster ""+this+"";
		 WARs now ""+getConfig(WARS_BY_CONTEXT));
		 Iterable<CanDeployAndUndeploy> targets = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);
		 TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).displayName(""Undeploy ""+targetName+"" across cluster (size ""+Iterables.size(targets)+"")"");
		 for (Entity target: targets) {
			 tb.add(whenServiceUp(target, Effectors.invocation(target, UNDEPLOY, MutableMap.of(""targetName"", targetName)), ""Undeploy ""+targetName+"" at ""+target+"" when ready""));
		 }
		 DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();
		 Set<String> deployedWars = MutableSet.copyOf(getAttribute(DEPLOYED_WARS));
		 deployedWars.remove( FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName) );
		 sensors().set(DEPLOYED_WARS, deployedWars);
	 }
	 static void addToWarsByContext(Entity entity, String url, String targetName) {
		 targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
		 synchronized (entity) {
			 Map<String,String> newWarsMap = MutableMap.copyOf(entity.getConfig(WARS_BY_CONTEXT));
			 newWarsMap.put(targetName, url);
			 entity.config().set(WARS_BY_CONTEXT, newWarsMap);
		 }
	 }
	 static boolean removeFromWarsByContext(Entity entity, String targetName) {
		 targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
		 synchronized (entity) {
			 Map<String,String> newWarsMap = MutableMap.copyOf(entity.getConfig(WARS_BY_CONTEXT));
			 String url = newWarsMap.remove(targetName);
			 if (url==null) {
				 return false;
			 }
			 entity.config().set(WARS_BY_CONTEXT, newWarsMap);
			 return true;
		 }
	 }
	 public void redeployAll() {
		 Map<String, String> wars = MutableMap.copyOf(getConfig(WARS_BY_CONTEXT));
		 String redeployPrefix = ""Redeploy all WARs (count ""+wars.size()+"")"";
		 log.debug(""Redeplying all WARs across cluster ""+this+"": ""+getConfig(WARS_BY_CONTEXT));
		 Iterable<CanDeployAndUndeploy> targetEntities = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);
		 TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).displayName(redeployPrefix+"" across cluster (size ""+Iterables.size(targetEntities)+"")"");
		 for (Entity targetEntity: targetEntities) {
			 TaskBuilder<Void> redeployAllToTarget = Tasks.<Void>builder().displayName(redeployPrefix+"" at ""+targetEntity+"" (after ready check)"");
			 for (String warContextPath: wars.keySet()) {
				 redeployAllToTarget.add(Effectors.invocation(targetEntity, DEPLOY, MutableMap.of(""url"", wars.get(warContextPath), ""targetName"", warContextPath)));
			 }
			 tb.add(whenServiceUp(targetEntity, redeployAllToTarget.build(), redeployPrefix+"" at ""+targetEntity+"" when ready""));
		 }
		 DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();
	 }
 }",1,0,0,0
"public final static class Bucket {
	 private long baseOffset;
	 private int itemAllocationSize, sizeIndex;
	 private int itemCount;
	 private int freeList[];
	 private int freeCount, usedCount;
	 public Bucket(long offset) {
		 baseOffset = offset;
		 sizeIndex = -1;
	 }
	 void reconfigure(int sizeIndex, int[] bucketSizes, long bucketCapacity) {
		 Preconditions.checkElementIndex(sizeIndex, bucketSizes.length);
		 this.sizeIndex = sizeIndex;
		 itemAllocationSize = bucketSizes[sizeIndex];
		 itemCount = (int) (bucketCapacity / (long) itemAllocationSize);
		 freeCount = itemCount;
		 usedCount = 0;
		 freeList = new int[itemCount];
		 for (int i = 0;
		 i < freeCount;
		 ++i) freeList[i] = i;
	 }
	 public boolean isUninstantiated() {
		 return sizeIndex == -1;
	 }
	 public int sizeIndex() {
		 return sizeIndex;
	 }
	 public int getItemAllocationSize() {
		 return itemAllocationSize;
	 }
	 public boolean hasFreeSpace() {
		 return freeCount > 0;
	 }
	 public boolean isCompletelyFree() {
		 return usedCount == 0;
	 }
	 public int freeCount() {
		 return freeCount;
	 }
	 public int usedCount() {
		 return usedCount;
	 }
	 public int getFreeBytes() {
		 return freeCount * itemAllocationSize;
	 }
	 public int getUsedBytes() {
		 return usedCount * itemAllocationSize;
	 }
	 public long getBaseOffset() {
		 return baseOffset;
	 }
	 public long allocate() {
		 assert freeCount > 0;
		 assert sizeIndex != -1;
		 ++usedCount;
		 long offset = baseOffset + (freeList[--freeCount] * itemAllocationSize);
		 assert offset >= 0;
		 return offset;
	 }
	 public void addAllocation(long offset) throws BucketAllocatorException {
		 offset -= baseOffset;
		 if (offset < 0 || offset % itemAllocationSize != 0) throw new BucketAllocatorException( ""Attempt to add allocation for bad offset: "" + offset + "" base="" + baseOffset + "", bucket size="" + itemAllocationSize);
		 int idx = (int) (offset / itemAllocationSize);
		 boolean matchFound = false;
		 for (int i = 0;
		 i < freeCount;
		 ++i) {
			 if (matchFound) freeList[i - 1] = freeList[i];
			 else if (freeList[i] == idx) matchFound = true;
		 }
		 if (!matchFound) throw new BucketAllocatorException(""Couldn't find match for index "" + idx + "" in free list"");
		 ++usedCount;
		 --freeCount;
	 }
	 private void free(long offset) {
		 offset -= baseOffset;
		 assert offset >= 0;
		 assert offset < itemCount * itemAllocationSize;
		 assert offset % itemAllocationSize == 0;
		 assert usedCount > 0;
		 assert freeCount < itemCount;
		 int item = (int) (offset / (long) itemAllocationSize);
		 assert !freeListContains(item);
		 --usedCount;
		 freeList[freeCount++] = item;
	 }
	 private boolean freeListContains(int blockNo) {
		 for (int i = 0;
		 i < freeCount;
		 ++i) {
			 if (freeList[i] == blockNo) return true;
		 }
		 return false;
	 }
 }",0,0,0,0
"public class FieldAttributeModel {
	 private final String typeName;
	 private boolean needInitialize;
	 private String fieldName;
	 private Type type;
	 private boolean isList;
	 private boolean isPrimitive;
	 private boolean isMap;
	 private boolean isListOfDto;
	 private boolean isMapOfDto;
	 private String dtoImpl;
	 private boolean isDto;
	 private boolean isEnum;
	 private String mapKeyType;
	 private String mapValueType;
	 private String dtsType;
	 private Class declarationClass;
	 public FieldAttributeModel(String fieldName, Type type, Class declarationClass) {
		 this.fieldName = fieldName;
		 this.type = type;
		 this.typeName = convertType(type);
		 this.dtsType = convertTypeForDTS(declarationClass, type);
		 this.declarationClass = declarationClass;
		 if (typeName.startsWith(""Array<"") || typeName.startsWith(""Map<"")) {
			 this.needInitialize = true;
		 }
		 if (this.type instanceof ParameterizedType) {
			 ParameterizedType parameterizedType = (ParameterizedType) this.type;
			 Type rawType = parameterizedType.getRawType();
			 analyzeParametrizedType(parameterizedType, rawType);
		 }
		 else if (Primitives.isPrimitive(this.type) || Primitives.isWrapperType(this.type) || String.class.equals(this.type)) {
			 this.isPrimitive = true;
		 }
		 else if (this.type instanceof Class && ((Class) this.type).isAnnotationPresent(DTO.class)) {
			 this.isDto = true;
			 dtoImpl = this.type.getTypeName() + ""Impl"";
		 }
		 else if (this.type instanceof Class && ((Class) this.type).isEnum()) {
			 this.isEnum = true;
		 }
	 }
	 protected void analyzeParametrizedType(ParameterizedType parameterizedType, Type rawType) {
		 if (List.class.equals(rawType)) {
			 this.isList = true;
			 if (parameterizedType.getActualTypeArguments()[0] instanceof Class && ((Class) parameterizedType.getActualTypeArguments()[0]) .isAnnotationPresent(DTO.class)) {
				 isListOfDto = true;
				 dtoImpl = convertType(parameterizedType.getActualTypeArguments()[0]) + ""Impl"";
			 }
		 }
		 else if (Map.class.equals(rawType)) {
			 isMap = true;
			 mapKeyType = convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[0]);
			 if (parameterizedType.getActualTypeArguments()[1] instanceof Class && ((Class) parameterizedType.getActualTypeArguments()[1]) .isAnnotationPresent(DTO.class)) {
				 isMapOfDto = true;
				 dtoImpl = convertType(parameterizedType.getActualTypeArguments()[1]) + ""Impl"";
			 }
			 mapValueType = convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[1]);
		 }
	 }
	 public String getTypeName() {
		 return typeName;
	 }
	 public String getFieldName() {
		 return fieldName;
	 }
	 public Type getType() {
		 return type;
	 }
	 public boolean isList() {
		 return isList;
	 }
	 public boolean isPrimitive() {
		 return isPrimitive;
	 }
	 public boolean isMap() {
		 return isMap;
	 }
	 public boolean isListOfDto() {
		 return isListOfDto;
	 }
	 public boolean isMapOfDto() {
		 return isMapOfDto;
	 }
	 public String getDtoImpl() {
		 return dtoImpl;
	 }
	 public boolean isDto() {
		 return isDto;
	 }
	 public boolean isNeedInitialize() {
		 return needInitialize;
	 }
	 public boolean isEnum() {
		 return isEnum;
	 }
	 public String getName() {
		 return this.fieldName;
	 }
	 public String getSimpleType() {
		 return this.typeName;
	 }
	 public String getMapKeyType() {
		 return mapKeyType;
	 }
	 public String getMapValueType() {
		 return mapValueType;
	 }
	 public String getDtsType() {
		 return dtsType;
	 }
}",1,1,0,0
"public ClientInfo getClientInfo(){
	if (clientInfo == null){
		clientInfo = RequestCycle.get().newClientInfo();
	}
	return clientInfo;
}",0,0,0,0
"public void applyAdd(int start, List<Object> target){
	Iterator<Object> i = chunk.iterator();
	while (i.hasNext()){
		target.add(start++, i.next());
	}
}",0,0,0,0
"public interface DebuggableObject {
	 public Object[] getAllIds();
}",0,0,0,0
"public class SparkCubingMerge extends AbstractApplication implements Serializable {
	 protected static final Logger logger = LoggerFactory.getLogger(SparkCubingMerge.class);
	 public static final Option OPTION_CUBE_NAME = OptionBuilder.withArgName(BatchConstants.ARG_CUBE_NAME).hasArg() .isRequired(true).withDescription(""Cube Name"").create(BatchConstants.ARG_CUBE_NAME);
	 public static final Option OPTION_SEGMENT_ID = OptionBuilder.withArgName(""segment"").hasArg().isRequired(true) .withDescription(""Cube Segment Id"").create(""segmentId"");
	 public static final Option OPTION_META_URL = OptionBuilder.withArgName(""metaUrl"").hasArg().isRequired(true) .withDescription(""HDFS metadata url"").create(""metaUrl"");
	 public static final Option OPTION_OUTPUT_PATH = OptionBuilder.withArgName(BatchConstants.ARG_OUTPUT).hasArg() .isRequired(true).withDescription(""HFile output path"").create(BatchConstants.ARG_OUTPUT);
	 public static final Option OPTION_INPUT_PATH = OptionBuilder.withArgName(BatchConstants.ARG_INPUT).hasArg() .isRequired(true).withDescription(""Cuboid files PATH"").create(BatchConstants.ARG_INPUT);
	 private Options options;
	 private String cubeName;
	 private String metaUrl;
	 public SparkCubingMerge() {
		 options = new Options();
		 options.addOption(OPTION_META_URL);
		 options.addOption(OPTION_CUBE_NAME);
		 options.addOption(OPTION_SEGMENT_ID);
		 options.addOption(OPTION_INPUT_PATH);
		 options.addOption(OPTION_OUTPUT_PATH);
	 }
	 protected Options getOptions() {
		 return options;
	 }
	 protected void execute(OptionsHelper optionsHelper) throws Exception {
		 this.metaUrl = optionsHelper.getOptionValue(OPTION_META_URL);
		 this.cubeName = optionsHelper.getOptionValue(OPTION_CUBE_NAME);
		 final String inputPath = optionsHelper.getOptionValue(OPTION_INPUT_PATH);
		 final String segmentId = optionsHelper.getOptionValue(OPTION_SEGMENT_ID);
		 final String outputPath = optionsHelper.getOptionValue(OPTION_OUTPUT_PATH);
		 Class[] kryoClassArray = new Class[] {
		 Class.forName(""scala.reflect.ClassTag$$anon$1"") }
		;
		 SparkConf conf = new SparkConf().setAppName(""Merge segments for cube:"" + cubeName + "", segment "" + segmentId);
		 conf.set(""spark.serializer"", ""org.apache.spark.serializer.KryoSerializer"");
		 conf.set(""spark.kryo.registrator"", ""org.apache.kylin.engine.spark.KylinKryoRegistrator"");
		 conf.set(""spark.kryo.registrationRequired"", ""true"").registerKryoClasses(kryoClassArray);
		 try (JavaSparkContext sc = new JavaSparkContext(conf)) {
			 SparkUtil.modifySparkHadoopConfiguration(sc.sc());
			 KylinSparkJobListener jobListener = new KylinSparkJobListener();
			 sc.sc().addSparkListener(jobListener);
			 HadoopUtil.deletePath(sc.hadoopConfiguration(), new Path(outputPath));
			 final SerializableConfiguration sConf = new SerializableConfiguration(sc.hadoopConfiguration());
			 final KylinConfig envConfig = AbstractHadoopJob.loadKylinConfigFromHdfs(sConf, metaUrl);
			 final CubeInstance cubeInstance = CubeManager.getInstance(envConfig).getCube(cubeName);
			 final CubeDesc cubeDesc = CubeDescManager.getInstance(envConfig).getCubeDesc(cubeInstance.getDescName());
			 final CubeSegment cubeSegment = cubeInstance.getSegmentById(segmentId);
			 final CubeStatsReader cubeStatsReader = new CubeStatsReader(cubeSegment, envConfig);
			 logger.info(""Input path: {
			}
			"", inputPath);
			 logger.info(""Output path: {
			}
			"", outputPath);
			 final Job job = Job.getInstance(sConf.get());
			 SparkUtil.setHadoopConfForCuboid(job, cubeSegment, metaUrl);
			 final MeasureAggregators aggregators = new MeasureAggregators(cubeDesc.getMeasures());
			 final Function2 reduceFunction = new Function2<Object[], Object[], Object[]>() {
				 public Object[] call(Object[] input1, Object[] input2) throws Exception {
					 Object[] measureObjs = new Object[input1.length];
					 aggregators.aggregate(input1, input2, measureObjs);
					 return measureObjs;
				 }
			 }
			;
			 final PairFunction convertTextFunction = new PairFunction<Tuple2<Text, Object[]>, org.apache.hadoop.io.Text, org.apache.hadoop.io.Text>() {
				 private transient volatile boolean initialized = false;
				 BufferedMeasureCodec codec;
				 public Tuple2<org.apache.hadoop.io.Text, org.apache.hadoop.io.Text> call(Tuple2<Text, Object[]> tuple2) throws Exception {
					 if (initialized == false) {
						 synchronized (SparkCubingMerge.class) {
							 if (initialized == false) {
								 synchronized (SparkCubingMerge.class) {
									 if (initialized == false) {
										 KylinConfig kylinConfig = AbstractHadoopJob.loadKylinConfigFromHdfs(sConf, metaUrl);
										 try (KylinConfig.SetAndUnsetThreadLocalConfig autoUnset = KylinConfig .setAndUnsetThreadLocalConfig(kylinConfig)) {
											 CubeDesc desc = CubeDescManager.getInstance(kylinConfig).getCubeDesc(cubeName);
											 codec = new BufferedMeasureCodec(desc.getMeasures());
											 initialized = true;
										 }
									 }
								 }
							 }
						 }
					 }
					 ByteBuffer valueBuf = codec.encode(tuple2._2());
					 byte[] encodedBytes = new byte[valueBuf.position()];
					 System.arraycopy(valueBuf.array(), 0, encodedBytes, 0, valueBuf.position());
					 return new Tuple2<>(tuple2._1(), new org.apache.hadoop.io.Text(encodedBytes));
				 }
			 }
			;
			 final int totalLevels = cubeSegment.getCuboidScheduler().getBuildLevel();
			 final String[] inputFolders = StringSplitter.split(inputPath, "","");
			 FileSystem fs = HadoopUtil.getWorkingFileSystem();
			 boolean isLegacyMode = false;
			 for (String inputFolder : inputFolders) {
				 Path baseCuboidPath = new Path(BatchCubingJobBuilder2.getCuboidOutputPathsByLevel(inputFolder, 0));
				 if (fs.exists(baseCuboidPath) == false) {
					 isLegacyMode = true;
					 break;
				 }
			 }
			 if (isLegacyMode == true) {
				 List<JavaPairRDD<Text, Object[]>> mergingSegs = Lists.newArrayListWithExpectedSize(inputFolders.length);
				 for (int i = 0;
				 i < inputFolders.length;
				 i++) {
					 String path = inputFolders[i];
					 JavaPairRDD segRdd = SparkUtil.parseInputPath(path, fs, sc, Text.class, Text.class);
					 CubeSegment sourceSegment = findSourceSegment(path, cubeInstance);
					 JavaPairRDD<Text, Object[]> newEcoddedRdd = segRdd.mapToPair(new ReEncodeCuboidFunction(cubeName, sourceSegment.getUuid(), cubeSegment.getUuid(), metaUrl, sConf));
					 mergingSegs.add(newEcoddedRdd);
				 }
				 FileOutputFormat.setOutputPath(job, new Path(outputPath));
				 sc.union(mergingSegs.toArray(new JavaPairRDD[mergingSegs.size()])) .reduceByKey(reduceFunction, SparkUtil.estimateTotalPartitionNum(cubeStatsReader, envConfig)) .mapToPair(convertTextFunction).saveAsNewAPIHadoopDataset(job.getConfiguration());
			 }
			 else {
				 for (int level = 0;
				 level <= totalLevels;
				 level++) {
					 List<JavaPairRDD<Text, Object[]>> mergingSegs = Lists.newArrayList();
					 for (int i = 0;
					 i < inputFolders.length;
					 i++) {
						 String path = inputFolders[i];
						 CubeSegment sourceSegment = findSourceSegment(path, cubeInstance);
						 final String cuboidInputPath = BatchCubingJobBuilder2.getCuboidOutputPathsByLevel(path, level);
						 JavaPairRDD<Text, Text> segRdd = sc.sequenceFile(cuboidInputPath, Text.class, Text.class);
						 JavaPairRDD<Text, Object[]> newEcoddedRdd = segRdd.mapToPair(new ReEncodeCuboidFunction(cubeName, sourceSegment.getUuid(), cubeSegment.getUuid(), metaUrl, sConf));
						 mergingSegs.add(newEcoddedRdd);
					 }
					 final String cuboidOutputPath = BatchCubingJobBuilder2.getCuboidOutputPathsByLevel(outputPath, level);
					 FileOutputFormat.setOutputPath(job, new Path(cuboidOutputPath));
					 sc.union(mergingSegs.toArray(new JavaPairRDD[mergingSegs.size()])) .reduceByKey(reduceFunction, SparkUtil.estimateLayerPartitionNum(level, cubeStatsReader, envConfig)) .mapToPair(convertTextFunction).saveAsNewAPIHadoopDataset(job.getConfiguration());
				 }
			 }
			 logger.info(""HDFS: Number of bytes written={
			}
			"", jobListener.metrics.getBytesWritten());
		 }
	 }
	 static class ReEncodeCuboidFunction implements PairFunction<Tuple2<Text, Text>, Text, Object[]> {
		 private transient volatile boolean initialized = false;
		 private String cubeName;
		 private String sourceSegmentId;
		 private String mergedSegmentId;
		 private String metaUrl;
		 private SerializableConfiguration conf;
		 private transient KylinConfig kylinConfig;
		 private transient SegmentReEncoder segmentReEncoder = null;
		 ReEncodeCuboidFunction(String cubeName, String sourceSegmentId, String mergedSegmentId, String metaUrl, SerializableConfiguration conf) {
			 this.cubeName = cubeName;
			 this.sourceSegmentId = sourceSegmentId;
			 this.mergedSegmentId = mergedSegmentId;
			 this.metaUrl = metaUrl;
			 this.conf = conf;
		 }
		 private void init() {
			 this.kylinConfig = AbstractHadoopJob.loadKylinConfigFromHdfs(conf, metaUrl);
			 final CubeInstance cube = CubeManager.getInstance(kylinConfig).getCube(cubeName);
			 final CubeDesc cubeDesc = CubeDescManager.getInstance(kylinConfig).getCubeDesc(cube.getDescName());
			 final CubeSegment sourceSeg = cube.getSegmentById(sourceSegmentId);
			 final CubeSegment mergedSeg = cube.getSegmentById(mergedSegmentId);
			 this.segmentReEncoder = new SegmentReEncoder(cubeDesc, sourceSeg, mergedSeg, kylinConfig);
		 }
		 public Tuple2<Text, Object[]> call(Tuple2<Text, Text> textTextTuple2) throws Exception {
			 if (initialized == false) {
				 synchronized (ReEncodeCuboidFunction.class) {
					 if (initialized == false) {
						 init();
						 initialized = true;
					 }
				 }
			 }
			 Pair<Text, Object[]> encodedPair = segmentReEncoder.reEncode2(textTextTuple2._1, textTextTuple2._2);
			 return new Tuple2(encodedPair.getFirst(), encodedPair.getSecond());
		 }
	 }
	 private CubeSegment findSourceSegment(String filePath, CubeInstance cube) {
		 String jobID = JobBuilderSupport.extractJobIDFromPath(filePath);
		 return CubeInstance.findSegmentWithJobId(jobID, cube);
	 }
}",1,0,0,0
"private void init(KeyBinding binding, Vector allBindings, Buffer debugBuffer);",0,0,0,0
"public void offerService() throws Exception {
	 long lastHeartbeat = 0, lastBlockReport = 0;
	 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
	 try {
		 while (shouldRun) {
			 long now = System.currentTimeMillis();
			 if (now - lastHeartbeat > HEARTBEAT_INTERVAL) {
				 BlockCommand cmd = namenode.sendHeartbeat(dnRegistration, data.getCapacity(), data.getRemaining(), xmitsInProgress, xceiverCount.getValue());
				 lastHeartbeat = now;
				 if( cmd != null ) {
					 data.checkDataDir();
					 if (cmd.transferBlocks()) {
						 Block blocks[] = cmd.getBlocks();
						 DatanodeInfo xferTargets[][] = cmd.getTargets();
						 for (int i = 0;
						 i < blocks.length;
						 i++) {
							 if (!data.isValidBlock(blocks[i])) {
								 String errStr = ""Can't send invalid block "" + blocks[i];
								 LOG.info(errStr);
								 namenode.errorReport( dnRegistration, DatanodeProtocol.INVALID_BLOCK, errStr);
								 break;
							 }
							 else {
								 if (xferTargets[i].length > 0) {
									 LOG.info(""Starting thread to transfer block "" + blocks[i] + "" to "" + xferTargets[i]);
									 new Daemon(new DataTransfer(xferTargets[i], blocks[i])).start();
								 }
							 }
						 }
					 }
					 else if (cmd.invalidateBlocks()) {
						 Block toDelete[] = cmd.getBlocks();
						 data.invalidate(toDelete);
						 myMetrics.removedBlocks(toDelete.length);
					 }
					 else if( cmd.shutdownNode()) {
						 this.shutdown();
						 continue;
					 }
				 }
			 }
			 if (now - lastBlockReport > blockReportInterval) {
				 data.checkDataDir();
				 Block toDelete[] = namenode.blockReport(dnRegistration, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			 }
			 Block [] blockArray=null;
			 synchronized( receivedBlockList ) {
				 if (receivedBlockList.size() > 0) {
					 blockArray = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
					 receivedBlockList.removeAllElements();
				 }
			 }
			 if( blockArray != null ) {
				 namenode.blockReceived( dnRegistration, blockArray );
			 }
			 long waitTime = HEARTBEAT_INTERVAL - (System.currentTimeMillis() - lastHeartbeat);
			 synchronized( receivedBlockList ) {
				 if (waitTime > 0 && receivedBlockList.size() == 0) {
					 try {
						 receivedBlockList.wait(waitTime);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
	 }
	 catch(DiskErrorException e) {
		 handleDiskError(e.getLocalizedMessage());
	 }
	 catch( RemoteException re ) {
		 String reClass = re.getClassName();
		 if( UnregisteredDatanodeException.class.getName().equals( reClass )) {
			 LOG.warn( ""DataNode is shutting down: "" + StringUtils.stringifyException(re));
			 shutdown();
			 return;
		 }
		 throw re;
	 }
 }",0,0,1,0
"private File getWorkDir(){
	return defaultWorkDir;
}",0,0,0,0
"public class GossipDigestAckVerbHandler implements IVerbHandler{
	 private static Logger logger_ = LoggerFactory.getLogger(GossipDigestAckVerbHandler.class);
	 public void doVerb(Message message, String id) {
		 InetAddress from = message.getFrom();
		 if (logger_.isTraceEnabled()) logger_.trace(""Received a GossipDigestAckMessage from {
		}
		"", from);
		 if (!Gossiper.instance.isEnabled()) {
			 if (logger_.isTraceEnabled()) logger_.trace(""Ignoring GossipDigestAckMessage because gossip is disabled"");
			 return;
		 }
		 byte[] bytes = message.getMessageBody();
		 DataInputStream dis = new DataInputStream( new ByteArrayInputStream(bytes) );
		 try {
			 GossipDigestAckMessage gDigestAckMessage = GossipDigestAckMessage.serializer().deserialize(dis, message.getVersion());
			 List<GossipDigest> gDigestList = gDigestAckMessage.getGossipDigestList();
			 Map<InetAddress, EndpointState> epStateMap = gDigestAckMessage.getEndpointStateMap();
			 if ( epStateMap.size() > 0 ) {
				 Gossiper.instance.notifyFailureDetector(epStateMap);
				 Gossiper.instance.applyStateLocally(epStateMap);
			 }
			 Map<InetAddress, EndpointState> deltaEpStateMap = new HashMap<InetAddress, EndpointState>();
			 for( GossipDigest gDigest : gDigestList ) {
				 InetAddress addr = gDigest.getEndpoint();
				 EndpointState localEpStatePtr = Gossiper.instance.getStateForVersionBiggerThan(addr, gDigest.getMaxVersion());
				 if ( localEpStatePtr != null ) deltaEpStateMap.put(addr, localEpStatePtr);
			 }
			 GossipDigestAck2Message gDigestAck2 = new GossipDigestAck2Message(deltaEpStateMap);
			 Message gDigestAck2Message = Gossiper.instance.makeGossipDigestAck2Message(gDigestAck2, message.getVersion());
			 if (logger_.isTraceEnabled()) logger_.trace(""Sending a GossipDigestAck2Message to {
			}
			"", from);
			 MessagingService.instance().sendOneWay(gDigestAck2Message, from);
		 }
		 catch ( IOException e ) {
			 throw new RuntimeException(e);
		 }
	 }
}",0,0,0,0
"static class Solaris extends OperatingSystem.Unix {
	 public String getFamilyName() {
		 return ""solaris"";
	 }
	 protected String getOsPrefix() {
		 return ""sunos"";
	 }
	 protected String getArch() {
		 String arch = System.getProperty(""os.arch"");
		 if (arch.equals(""i386"") || arch.equals(""x86"")) {
			 return ""x86"";
		 }
		 return super.getArch();
	 }
 }",0,1,0,0
"public final class BodyTagAttributeModifier extends AttributeModifier{
	private static final long serialVersionUID = 1L;
	private transient WeakReference<Component> componentReference;
	public BodyTagAttributeModifier(final String attribute, final boolean addAttributeIfNotPresent,final IModel<?> replaceModel, final Component behaviorOwner){
		super(attribute, addAttributeIfNotPresent, replaceModel);
		init(behaviorOwner);
	}
	public BodyTagAttributeModifier(final String attribute, final IModel<?> replaceModel,final Component behaviorOwner){
		super(attribute, replaceModel);
		init(behaviorOwner);
	}
	public BodyTagAttributeModifier(final String attribute, final String pattern,final boolean addAttributeIfNotPresent, final IModel<?> replaceModel,final Component behaviorOwner){
		super(attribute, pattern, addAttributeIfNotPresent, replaceModel);
		init(behaviorOwner);
	}
	public BodyTagAttributeModifier(final String attribute, final String pattern,final IModel<?> replaceModel, final Component behaviorOwner){
		super(attribute, pattern, replaceModel);
		init(behaviorOwner);
	}
	private void init(final Component behaviorOwner){
		if (behaviorOwner != null){
			componentReference = new WeakReference<Component>(behaviorOwner);
		}
	}
	protected String newValue(final String currentValue, final String replacementValue){
		if (componentReference != null){
			final Component behaviorOwner = componentReference.get();
			if (behaviorOwner == null){
				setEnabled(false);
				return currentValue;
			}
			if (!(behaviorOwner instanceof Page) && behaviorOwner.findParent(Page.class) == null){
				setEnabled(false);
				return currentValue;
			}
			if (behaviorOwner.isVisibleInHierarchy() == false){
				return currentValue;
			}
		}
		if (currentValue != null && !currentValue.trim().endsWith("";
		"")){
			return currentValue + "";
			"" + replacementValue;
		}
		return (currentValue == null ? replacementValue : currentValue + replacementValue);
	}
	private void readObject(final ObjectInputStream inputStream) throws IOException,ClassNotFoundException{
		inputStream.defaultReadObject();
		final Object object = inputStream.readObject();
		if (object != null){
			componentReference = new WeakReference<Component>((Component)object);
		}
	}
	private void writeObject(final ObjectOutputStream outputStream) throws IOException{
		outputStream.defaultWriteObject();
		if (componentReference != null){
			outputStream.writeObject(componentReference.get());
		}
		else{
			outputStream.writeObject(null);
		}
	}
}",0,0,0,0
"public class TraXLiaison implements XSLTLiaison3, ErrorListener, XSLTLoggerAware {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private Project project;
	 private String factoryName = null;
	 private TransformerFactory tfactory = null;
	 private Resource stylesheet;
	 private XSLTLogger logger;
	 private EntityResolver entityResolver;
	 private Transformer transformer;
	 private Templates templates;
	 private long templatesModTime;
	 private URIResolver uriResolver;
	 private Vector outputProperties = new Vector();
	 private Hashtable params = new Hashtable();
	 private Vector attributes = new Vector();
	 public TraXLiaison() throws Exception {
	 }
	 public void setStylesheet(File stylesheet) throws Exception {
		 FileResource fr = new FileResource();
		 fr.setProject(project);
		 fr.setFile(stylesheet);
		 setStylesheet(fr);
	 }
	 public void setStylesheet(Resource stylesheet) throws Exception {
		 if (this.stylesheet != null) {
			 transformer = null;
			 if (!this.stylesheet.equals(stylesheet) || (stylesheet.getLastModified() != templatesModTime)) {
				 templates = null;
			 }
		 }
		 this.stylesheet = stylesheet;
	 }
	 public void transform(File infile, File outfile) throws Exception {
		 if (transformer == null) {
			 createTransformer();
		 }
		 InputStream fis = null;
		 OutputStream fos = null;
		 try {
			 fis = new BufferedInputStream(new FileInputStream(infile));
			 fos = new BufferedOutputStream(new FileOutputStream(outfile));
			 StreamResult res = new StreamResult(fos);
			 res.setSystemId(JAXPUtils.getSystemId(outfile));
			 Source src = getSource(fis, infile);
			 setTransformationParameters();
			 transformer.transform(src, res);
		 }
		 finally {
			 try {
				 if (fis != null) {
					 fis.close();
				 }
			 }
			 catch (IOException ignored) {
			 }
			 try {
				 if (fos != null) {
					 fos.close();
				 }
			 }
			 catch (IOException ignored) {
			 }
		 }
	 }
	 private Source getSource(InputStream is, File infile) throws ParserConfigurationException, SAXException {
		 Source src = null;
		 if (entityResolver != null) {
			 if (getFactory().getFeature(SAXSource.FEATURE)) {
				 SAXParserFactory spFactory = SAXParserFactory.newInstance();
				 spFactory.setNamespaceAware(true);
				 XMLReader reader = spFactory.newSAXParser().getXMLReader();
				 reader.setEntityResolver(entityResolver);
				 src = new SAXSource(reader, new InputSource(is));
			 }
			 else {
				 throw new IllegalStateException(""xcatalog specified, but "" + ""parser doesn't support SAX"");
			 }
		 }
		 else {
			 src = new StreamSource(is);
		 }
		 src.setSystemId(JAXPUtils.getSystemId(infile));
		 return src;
	 }
	 private Source getSource(InputStream is, Resource resource) throws ParserConfigurationException, SAXException {
		 Source src = null;
		 if (entityResolver != null) {
			 if (getFactory().getFeature(SAXSource.FEATURE)) {
				 SAXParserFactory spFactory = SAXParserFactory.newInstance();
				 spFactory.setNamespaceAware(true);
				 XMLReader reader = spFactory.newSAXParser().getXMLReader();
				 reader.setEntityResolver(entityResolver);
				 src = new SAXSource(reader, new InputSource(is));
			 }
			 else {
				 throw new IllegalStateException(""xcatalog specified, but "" + ""parser doesn't support SAX"");
			 }
		 }
		 else {
			 src = new StreamSource(is);
		 }
		 src.setSystemId(resourceToURI(resource));
		 return src;
	 }
	 private String resourceToURI(Resource resource) {
		 if (resource instanceof FileResource) {
			 File f = ((FileResource) resource).getFile();
			 return FILE_UTILS.toURI(f.getAbsolutePath());
		 }
		 if (resource instanceof URLResource) {
			 URL u = ((URLResource) resource).getURL();
			 return String.valueOf(u);
		 }
		 else {
			 return resource.getName();
		 }
	 }
	 private void readTemplates() throws IOException, TransformerConfigurationException, ParserConfigurationException, SAXException {
		 InputStream xslStream = null;
		 try {
			 xslStream = new BufferedInputStream(stylesheet.getInputStream());
			 templatesModTime = stylesheet.getLastModified();
			 Source src = getSource(xslStream, stylesheet);
			 templates = getFactory().newTemplates(src);
		 }
		 finally {
			 if (xslStream != null) {
				 xslStream.close();
			 }
		 }
	 }
	 private void createTransformer() throws Exception {
		 if (templates == null) {
			 readTemplates();
		 }
		 transformer = templates.newTransformer();
		 transformer.setErrorListener(this);
		 if (uriResolver != null) {
			 transformer.setURIResolver(uriResolver);
		 }
		 for (int i = 0;
		 i < outputProperties.size();
		 i++) {
			 final String[] pair = (String[]) outputProperties.elementAt(i);
			 transformer.setOutputProperty(pair[0], pair[1]);
		 }
	 }
	 private void setTransformationParameters() {
		 for (final Enumeration enumeration = params.keys();
		 enumeration.hasMoreElements();
		) {
			 final String name = (String) enumeration.nextElement();
			 final String value = (String) params.get(name);
			 transformer.setParameter(name, value);
		 }
	 }
	 private TransformerFactory getFactory() throws BuildException {
		 if (tfactory != null) {
			 return tfactory;
		 }
		 if (factoryName == null) {
			 tfactory = TransformerFactory.newInstance();
		 }
		 else {
			 try {
				 Class clazz = Class.forName(factoryName);
				 tfactory = (TransformerFactory) clazz.newInstance();
			 }
			 catch (Exception e) {
				 throw new BuildException(e);
			 }
		 }
		 tfactory.setErrorListener(this);
		 for (int i = 0;
		 i < attributes.size();
		 i++) {
			 final Object[] pair = (Object[]) attributes.elementAt(i);
			 tfactory.setAttribute((String) pair[0], pair[1]);
		 }
		 if (uriResolver != null) {
			 tfactory.setURIResolver(uriResolver);
		 }
		 return tfactory;
	 }
	 public void setFactory(String name) {
		 factoryName = name;
	 }
	 public void setAttribute(String name, Object value) {
		 final Object[] pair = new Object[]{
		name, value}
		;
		 attributes.addElement(pair);
	 }
	 public void setOutputProperty(String name, String value) {
		 final String[] pair = new String[]{
		name, value}
		;
		 outputProperties.addElement(pair);
	 }
	 public void setEntityResolver(EntityResolver aResolver) {
		 entityResolver = aResolver;
	 }
	 public void setURIResolver(URIResolver aResolver) {
		 uriResolver = aResolver;
	 }
	 public void addParam(String name, String value) {
		 params.put(name, value);
	 }
	 public void setLogger(XSLTLogger l) {
		 logger = l;
	 }
	 public void error(TransformerException e) {
		 logError(e, ""Error"");
	 }
	 public void fatalError(TransformerException e) {
		 logError(e, ""Fatal Error"");
		 throw new BuildException(""Fatal error during transformation"", e);
	 }
	 public void warning(TransformerException e) {
		 logError(e, ""Warning"");
	 }
	 private void logError(TransformerException e, String type) {
		 if (logger == null) {
			 return;
		 }
		 StringBuffer msg = new StringBuffer();
		 SourceLocator locator = e.getLocator();
		 if (locator != null) {
			 String systemid = locator.getSystemId();
			 if (systemid != null) {
				 String url = systemid;
				 if (url.startsWith(""file:"")) {
					 url = FileUtils.getFileUtils().fromURI(url);
				 }
				 msg.append(url);
			 }
			 else {
				 msg.append(""Unknown file"");
			 }
			 int line = locator.getLineNumber();
			 if (line != -1) {
				 msg.append("":"");
				 msg.append(line);
				 int column = locator.getColumnNumber();
				 if (column != -1) {
					 msg.append("":"");
					 msg.append(column);
				 }
			 }
		 }
		 msg.append("": "");
		 msg.append(type);
		 msg.append(""! "");
		 msg.append(e.getMessage());
		 if (e.getCause() != null) {
			 msg.append("" Cause: "");
			 msg.append(e.getCause());
		 }
		 logger.log(msg.toString());
	 }
	 protected String getSystemId(File file) {
		 return JAXPUtils.getSystemId(file);
	 }
	 public void configure(XSLTProcess xsltTask) {
		 project = xsltTask.getProject();
		 XSLTProcess.Factory factory = xsltTask.getFactory();
		 if (factory != null) {
			 setFactory(factory.getName());
			 for (Enumeration attrs = factory.getAttributes();
			 attrs.hasMoreElements();
			) {
				 XSLTProcess.Factory.Attribute attr = (XSLTProcess.Factory.Attribute) attrs.nextElement();
				 setAttribute(attr.getName(), attr.getValue());
			 }
		 }
		 XMLCatalog xmlCatalog = xsltTask.getXMLCatalog();
		 if (xmlCatalog != null) {
			 setEntityResolver(xmlCatalog);
			 setURIResolver(xmlCatalog);
		 }
		 for (Enumeration props = xsltTask.getOutputProperties();
		 props.hasMoreElements();
		) {
			 XSLTProcess.OutputProperty prop = (XSLTProcess.OutputProperty) props.nextElement();
			 setOutputProperty(prop.getName(), prop.getValue());
		 }
	 }
}",0,0,0,0
"public class MemoryConsumptionTestClient{
	 private static final Logger LOGGER = LoggerFactory.getLogger(MemoryConsumptionTestClient.class);
	 private static final String RESULTS_FILE_ARG = ""resultsFile"";
	 private static final String JNDI_PROPERTIES_ARG = ""jndiProperties"";
	 private static final String JNDI_CONNECTION_FACTORY_ARG = ""jndiConnectionFactory"";
	 private static final String JNDI_DESTINATION_ARG = ""jndiDestination"";
	 private static final String CONNECTIONS_ARG = ""connections"";
	 private static final String SESSIONS_ARG = ""sessions"";
	 private static final String PRODUCERS_ARG = ""producers"";
	 private static final String MESSAGE_COUNT_ARG = ""messagecount"";
	 private static final String MESSAGE_SIZE_ARG = ""size"";
	 private static final String PERSISTENT_ARG = ""persistent"";
	 private static final String TIMEOUT_ARG = ""timeout"";
	 private static final String TRANSACTED_ARG = ""transacted"";
	 private static final String JMX_HOST_ARG = ""jmxhost"";
	 private static final String JMX_PORT_ARG = ""jmxport"";
	 private static final String JMX_USER_ARG = ""jmxuser"";
	 private static final String JMX_USER_PASSWORD_ARG = ""jmxpassword"";
	 private static final String RESULTS_FILE_DEFAULT = ""results.csv"";
	 private static final String JNDI_PROPERTIES_DEFAULT = ""stress-test-client-qpid-jms-client-0-x.properties"";
	 private static final String JNDI_CONNECTION_FACTORY_DEFAULT = ""qpidConnectionFactory"";
	 private static final String JNDI_DESTINATION_DEFAULT = ""stressTestQueue"";
	 private static final String CONNECTIONS_DEFAULT = ""1"";
	 private static final String SESSIONS_DEFAULT = ""1"";
	 private static final String PRODUCERS_DEFAULT = ""1"";
	 private static final String MESSAGE_COUNT_DEFAULT = ""1"";
	 private static final String MESSAGE_SIZE_DEFAULT = ""256"";
	 private static final String PERSISTENT_DEFAULT = ""false"";
	 private static final String TIMEOUT_DEFAULT = ""1000"";
	 private static final String TRANSACTED_DEFAULT = ""false"";
	 private static final String JMX_HOST_DEFAULT = ""localhost"";
	 private static final String JMX_PORT_DEFAULT = ""8999"";
	 private static final String JMX_GARBAGE_COLLECTOR_MBEAN = ""gc"";
	 public static void main(String[] args) throws Exception {
		 Map<String,String> options = new HashMap<>();
		 options.put(RESULTS_FILE_ARG, RESULTS_FILE_DEFAULT);
		 options.put(JNDI_PROPERTIES_ARG, JNDI_PROPERTIES_DEFAULT);
		 options.put(JNDI_CONNECTION_FACTORY_ARG, JNDI_CONNECTION_FACTORY_DEFAULT);
		 options.put(JNDI_DESTINATION_ARG, JNDI_DESTINATION_DEFAULT);
		 options.put(CONNECTIONS_ARG, CONNECTIONS_DEFAULT);
		 options.put(SESSIONS_ARG, SESSIONS_DEFAULT);
		 options.put(PRODUCERS_ARG, PRODUCERS_DEFAULT);
		 options.put(MESSAGE_COUNT_ARG, MESSAGE_COUNT_DEFAULT);
		 options.put(MESSAGE_SIZE_ARG, MESSAGE_SIZE_DEFAULT);
		 options.put(PERSISTENT_ARG, PERSISTENT_DEFAULT);
		 options.put(TIMEOUT_ARG, TIMEOUT_DEFAULT);
		 options.put(TRANSACTED_ARG, TRANSACTED_DEFAULT);
		 options.put(JMX_HOST_ARG, JMX_HOST_DEFAULT);
		 options.put(JMX_PORT_ARG, JMX_PORT_DEFAULT);
		 options.put(JMX_USER_ARG, """");
		 options.put(JMX_USER_PASSWORD_ARG, """");
		 options.put(JMX_GARBAGE_COLLECTOR_MBEAN, ""java.lang:type=GarbageCollector,name=ConcurrentMarkSweep"");
		 if(args.length == 1 && (args[0].equals(""-h"") || args[0].equals(""--help"") || args[0].equals(""help""))) {
			 System.out.println(""arg=value options: \n"" + options.keySet());
			 return;
		 }
		 parseArgumentsIntoConfig(options, args);
		 MemoryConsumptionTestClient testClient = new MemoryConsumptionTestClient();
		 testClient.runTest(options);
	 }
	 private static void parseArgumentsIntoConfig(Map<String, String> initialValues, String[] args) {
		 for(String arg: args) {
			 int equalPos = arg.indexOf('=');
			 if(equalPos == -1) {
				 throw new IllegalArgumentException(""arguments must have format <name>=<value>: "" + arg);
			 }
			 if(initialValues.put(arg.substring(0, equalPos), arg.substring(equalPos + 1)) == null) {
				 throw new IllegalArgumentException(""not a valid configuration property: "" + arg);
			 }
		 }
	 }
	 private void runTest(Map<String,String> options) throws Exception {
		 String resultsFile = options.get(RESULTS_FILE_ARG);
		 String jndiProperties = options.get(JNDI_PROPERTIES_ARG);
		 String connectionFactoryString = options.get(JNDI_CONNECTION_FACTORY_ARG);
		 int numConnections = Integer.parseInt(options.get(CONNECTIONS_ARG));
		 int numSessions = Integer.parseInt(options.get(SESSIONS_ARG));
		 int numProducers = Integer.parseInt(options.get(PRODUCERS_ARG));
		 int numMessage = Integer.parseInt(options.get(MESSAGE_COUNT_ARG));
		 int messageSize = Integer.parseInt(options.get(MESSAGE_SIZE_ARG));
		 String queueString = options.get(JNDI_DESTINATION_ARG);
		 int deliveryMode = Boolean.valueOf(options.get(PERSISTENT_ARG)) ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;
		 long receiveTimeout = Long.parseLong(options.get(TIMEOUT_ARG));
		 boolean transacted = Boolean.valueOf(options.get(TRANSACTED_ARG));
		 LOGGER.info(""Using options: "" + options);
		 Context ctx = getInitialContext(jndiProperties);
		 final ConnectionFactory conFac = (ConnectionFactory) ctx.lookup(connectionFactoryString);
		 Destination destination = ensureQueueCreated(queueString, conFac);
		 Map<Connection, List<Session>> connectionsAndSessions = openConnectionsAndSessions(numConnections, numSessions, transacted, conFac);
		 publish(numMessage, messageSize, numProducers, deliveryMode, destination, connectionsAndSessions);
		 MemoryStatistic memoryStatistics = collectMemoryStatistics(options);
		 generateCSV(memoryStatistics, numConnections, numSessions, transacted, numMessage, messageSize, numProducers, deliveryMode, resultsFile);
		 purgeQueue(conFac, queueString, receiveTimeout);
		 closeConnections(connectionsAndSessions.keySet());
		 System.exit(0);
	 }
	 private void generateCSV(MemoryStatistic memoryStatistics, int numConnections, int numSessions, boolean transacted, int numMessage, int messageSize, int numProducers, int deliveryMode, final String resultsFile) throws IOException {
		 try (FileWriter writer = new FileWriter(resultsFile)) {
			 writer.write(memoryStatistics.getHeapUsage() + "","" + memoryStatistics.getDirectMemoryUsage() + "","" + numConnections + "","" + numSessions + "","" + numProducers + "","" + transacted + "","" + numMessage + "","" + messageSize + "","" + deliveryMode + "","" + toUserFriendlyName(memoryStatistics.getHeapUsage()) + "","" + toUserFriendlyName(memoryStatistics.getDirectMemoryUsage()) + System.lineSeparator());
		 }
	 }
	 private void publish(int numberOfMessages, int messageSize, int numberOfProducers, int deliveryMode, Destination destination, Map<Connection, List<Session>> connectionsAndSessions) throws JMSException {
		 byte[] messageBytes = generateMessage(messageSize);
		 for (List<Session> sessions : connectionsAndSessions.values()) {
			 for (Session session: sessions) {
				 BytesMessage message = session.createBytesMessage();
				 if (messageSize > 0) {
					 message.writeBytes(messageBytes);
				 }
				 for(int i = 0;
				 i < numberOfProducers ;
				 i++) {
					 MessageProducer prod = session.createProducer(destination);
					 for(int j = 0;
					 j < numberOfMessages ;
					 j++) {
						 prod.send(message, deliveryMode, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
						 if(session.getTransacted()) {
							 session.commit();
						 }
					 }
				 }
			 }
		 }
	 }
	 private Map<Connection, List<Session>> openConnectionsAndSessions(int numConnections, int numSessions, boolean transacted, ConnectionFactory conFac) throws JMSException {
		 Map<Connection, List<Session>> connectionAndSessions = new HashMap<>();
		 for (int i= 0;
		 i < numConnections ;
		 i++) {
			 Connection connection = conFac.createConnection();
			 connection.setExceptionListener(jmse -> {
				 LOGGER.error(""The sample received an exception through the ExceptionListener"", jmse);
				 System.exit(1);
			 }
			);
			 List<Session> sessions = new ArrayList<>();
			 connectionAndSessions.put(connection, sessions);
			 connection.start();
			 for (int s= 0;
			 s < numSessions ;
			 s++) {
				 Session session = connection.createSession(transacted, transacted?Session.SESSION_TRANSACTED:Session.AUTO_ACKNOWLEDGE);
				 sessions.add(session);
			 }
		 }
		 return connectionAndSessions;
	 }
	 private Context getInitialContext(final String jndiProperties) throws IOException, NamingException {
		 Properties properties = new Properties();
		 try(InputStream is = this.getClass().getClassLoader().getResourceAsStream(jndiProperties)) {
			 if (is != null) {
				 properties.load(is);
				 return new InitialContext(properties);
			 }
		 }
		 System.out.printf(MemoryConsumptionTestClient.class.getSimpleName() + "": Failed to find '%s' on classpath, using fallback\n"", jndiProperties);
		 return new InitialContext();
	 }
	 private Destination ensureQueueCreated(String queueURL, ConnectionFactory connectionFactory) throws JMSException {
		 Connection connection = connectionFactory.createConnection();
		 Destination destination;
		 try {
			 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
			 destination = session.createQueue(queueURL);
			 MessageConsumer consumer = session.createConsumer(destination);
			 consumer.close();
			 session.close();
		 }
		 finally {
			 connection.close();
		 }
		 return destination;
	 }
	 private void closeConnections(Collection<Connection> connections) throws JMSException, NamingException {
		 for (Connection c: connections) {
			 c.close();
		 }
	 }
	 private void purgeQueue(ConnectionFactory connectionFactory, String queueString, long receiveTimeout) throws JMSException {
		 LOGGER.debug(""Consuming left over messages, using receive timeout:"" + receiveTimeout);
		 Connection connection = connectionFactory.createConnection();
		 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
		 Destination destination = session.createQueue(queueString);
		 MessageConsumer consumer = session.createConsumer(destination);
		 connection.start();
		 int count = 0;
		 while (true) {
			 BytesMessage msg = (BytesMessage) consumer.receive(receiveTimeout);
			 if(msg == null) {
				 LOGGER.debug(""Received {
				}
				 message(s)"", count);
				 break;
			 }
			 else {
				 count++;
			 }
		 }
		 consumer.close();
		 session.close();
		 connection.close();
	 }
	 private MemoryStatistic collectMemoryStatistics(Map<String, String> options) throws Exception {
		 String host = options.get(JMX_HOST_ARG);
		 String port = options.get(JMX_PORT_ARG);
		 String user = options.get(JMX_USER_ARG);
		 String password = options.get(JMX_USER_PASSWORD_ARG);
		 if (!"""".equals(host) && !"""".equals(port) && !"""".equals(user) && !"""".equals(password)) {
			 Map<String, Object> environment = Collections.<String, Object>singletonMap(JMXConnector.CREDENTIALS, new String[]{
			user, password}
			);
			 try(JMXConnector jmxConnector = JMXConnectorFactory.newJMXConnector(new JMXServiceURL(""rmi"", """", 0, ""/jndi/rmi: {
				 jmxConnector.connect();
				 final MBeanServerConnection mBeanServerConnection = jmxConnector.getMBeanServerConnection();
				 final ObjectName memoryMBean = new ObjectName(""java.lang:type=Memory"");
				 String gcCollectorMBeanName = options.get(JMX_GARBAGE_COLLECTOR_MBEAN);
				 if (gcCollectorMBeanName.equals("""")) {
					 mBeanServerConnection.invoke(memoryMBean, ""gc"", null, null);
					 MemoryStatistic memoryStatistics = new MemoryStatistic();
					 collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);
					 return memoryStatistics;
				 }
				 else {
					 ObjectName gcMBean = new ObjectName(gcCollectorMBeanName);
					 if (mBeanServerConnection.isRegistered(gcMBean)) {
						 return collectMemoryStatisticsAfterGCNotification(mBeanServerConnection, gcMBean);
					 }
					 else {
						 Set<ObjectName> existingGCs = mBeanServerConnection.queryNames(new ObjectName(""java.lang:type=GarbageCollector,name=*""), null);
						 throw new IllegalArgumentException(""MBean '"" +gcCollectorMBeanName + ""' does not exists! Registered GC MBeans :"" + existingGCs);
					 }
				 }
			 }
		 }
		 return null;
	 }
	 private MemoryStatistic collectMemoryStatisticsAfterGCNotification(final MBeanServerConnection mBeanServerConnection, ObjectName gcMBean) throws MalformedObjectNameException, IOException, InstanceNotFoundException, ReflectionException, MBeanException, InterruptedException {
		 final MemoryStatistic memoryStatistics = new MemoryStatistic();
		 final CountDownLatch notificationReceived = new CountDownLatch(1);
		 final ObjectName memoryMBean = new ObjectName(""java.lang:type=Memory"");
		 mBeanServerConnection.addNotificationListener(gcMBean, (notification, handback) -> {
			 if (notification.getType().equals(""com.sun.management.gc.notification"")) {
				 CompositeData userData = (CompositeData) notification.getUserData();
				 try {
					 Object gcAction = userData.get(""gcAction"");
					 Object gcCause = userData.get(""gcCause"");
					 if (""System.gc()"".equals(gcCause) && String.valueOf(gcAction).contains(""end of major GC"")) {
						 try {
							 collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);
						 }
						 finally {
							 notificationReceived.countDown();
						 }
					 }
				 }
				 catch (Exception e) {
					 e.printStackTrace();
					 notificationReceived.countDown();
				 }
			 }
		 }
		, null, null);
		 mBeanServerConnection.invoke(memoryMBean, ""gc"", null, null);
		 if (!notificationReceived.await(5, TimeUnit.SECONDS)) {
			 throw new RuntimeException(""GC notification was not sent in timely manner"");
		 }
		 return memoryStatistics;
	 }
	 private void collectMemoryStatistics(MemoryStatistic memoryStatistics, MBeanServerConnection mBeanServerConnection, ObjectName memoryMBean) throws MBeanException, AttributeNotFoundException, InstanceNotFoundException, ReflectionException, IOException, MalformedObjectNameException {
		 Object heapMemoryUsage = mBeanServerConnection.getAttribute(memoryMBean, ""HeapMemoryUsage"");
		 Object used = ((CompositeData) heapMemoryUsage).get(""used"");
		 Object directMemoryTotalCapacity = mBeanServerConnection.getAttribute(new ObjectName(""java.nio:type=BufferPool,name=direct""), ""TotalCapacity"");
		 memoryStatistics.setHeapUsage(Long.parseLong(String.valueOf(used)));
		 memoryStatistics.setDirectMemoryUsage(Long.parseLong(String.valueOf(directMemoryTotalCapacity)));
	 }
	 private String toUserFriendlyName(Object intValue) {
		 long value = Long.parseLong(String.valueOf(intValue));
		 if (value <= 1024) {
			 return String.valueOf(value) + ""B"";
		 }
		 else if (value <= 1024 * 1024) {
			 return String.valueOf(value/1024) + ""kB"";
		 }
		 else if (value <= 1024L * 1024L * 1024L) {
			 return String.valueOf(value/1024L/1024L) + ""MB"";
		 }
		 else {
			 return String.valueOf(value/1024L/1024L/1024L) + ""GB"";
		 }
	 }
	 private byte[] generateMessage(int messageSize) {
		 byte[] sentBytes = new byte[messageSize];
		 for(int r = 0 ;
		 r < messageSize ;
		 r++) {
			 sentBytes[r] = (byte) (48 + (r % 10));
		 }
		 return sentBytes;
	 }
	 private class MemoryStatistic {
		 private long heapUsage;
		 private long directMemoryUsage;
		 long getHeapUsage() {
			 return heapUsage;
		 }
		 void setHeapUsage(long heapUsage) {
			 this.heapUsage = heapUsage;
		 }
		 long getDirectMemoryUsage() {
			 return directMemoryUsage;
		 }
		 void setDirectMemoryUsage(long directMemoryUsage) {
			 this.directMemoryUsage = directMemoryUsage;
		 }
	 }
}",1,1,0,0
"public class DispatchUtils {
	 public static final void execute(Object task) throws BuildException {
		 String methodName = ""execute"";
		 Dispatchable dispatchable = null;
		 try {
			 if (task instanceof Dispatchable) {
				 dispatchable = (Dispatchable) task;
			 }
			 else if (task instanceof UnknownElement) {
				 UnknownElement ue = (UnknownElement) task;
				 Object realThing = ue.getRealThing();
				 if (realThing != null && realThing instanceof Dispatchable && realThing instanceof Task) {
					 dispatchable = (Dispatchable) realThing;
				 }
			 }
			 if (dispatchable != null) {
				 String mName = null;
				 try {
					 final String name = dispatchable.getActionParameterName();
					 if (name != null && name.trim().length() > 0) {
						 mName = ""get"" + name.trim().substring(0, 1).toUpperCase();
						 if (name.length() > 1) {
							 mName += name.substring(1);
						 }
						 final Class c = dispatchable.getClass();
						 final Method actionM = c.getMethod(mName, new Class[0]);
						 if (actionM != null) {
							 final Object o = actionM.invoke(dispatchable, (Object[]) null);
							 if (o != null) {
								 final String s = o.toString();
								 if (s != null && s.trim().length() > 0) {
									 methodName = s.trim();
									 Method executeM = null;
									 executeM = dispatchable.getClass().getMethod( methodName, new Class[0]);
									 if (executeM == null) {
										 throw new BuildException( ""No public "" + methodName + ""() in "" + dispatchable.getClass());
									 }
									 executeM.invoke(dispatchable, (Object[]) null);
									 if (task instanceof UnknownElement) {
										 ((UnknownElement) task).setRealThing(null);
									 }
								 }
								 else {
									 throw new BuildException( ""Dispatchable Task attribute '"" + name.trim() + ""' not set or value is empty."");
								 }
							 }
							 else {
								 throw new BuildException( ""Dispatchable Task attribute '"" + name.trim() + ""' not set or value is empty."");
							 }
						 }
					 }
					 else {
						 throw new BuildException( ""Action Parameter Name must not be empty for Dispatchable Task."");
					 }
				 }
				 catch (NoSuchMethodException nsme) {
					 throw new BuildException(""No public "" + mName + ""() in "" + task.getClass());
				 }
			 }
			 else {
				 Method executeM = null;
				 executeM = task.getClass().getMethod(methodName, new Class[0]);
				 if (executeM == null) {
					 throw new BuildException(""No public "" + methodName + ""() in "" + task.getClass());
				 }
				 executeM.invoke(task, (Object[]) null);
				 if (task instanceof UnknownElement) {
					 ((UnknownElement) task).setRealThing(null);
				 }
			 }
		 }
		 catch (InvocationTargetException ie) {
			 Throwable t = ie.getTargetException();
			 if (t instanceof BuildException) {
				 throw ((BuildException) t);
			 }
			 else {
				 throw new BuildException(t);
			 }
		 }
		 catch (NoSuchMethodException e) {
			 throw new BuildException(e);
		 }
		 catch (IllegalAccessException e) {
			 throw new BuildException(e);
		 }
	 }
}",0,0,0,0
"public final void renderHead(final IHeaderResponse response){
	IHeaderContributor[] contributors = getHeaderContributors();
	if (contributors == null){
		return;
	}
	for (int i = 0;
	 i < contributors.length;
	 i++){
		if (response.wasRendered(contributors[i]) == false){
			contributors[i].renderHead(response);
			response.markRendered(contributors[i]);
		}
	}
}",0,0,0,0
"public class ConstantPartitioner implements DocumentPartitioner {
	 private final List<String> legalContentTypes;
	 private final String contentType;
	 private int documentLength = 0;
	 private DocumentHandle documentHandle;
	 public ConstantPartitioner(final String contentType) {
		 this.contentType = contentType;
		 this.legalContentTypes = Collections.singletonList(this.contentType);
	 }
	 public ConstantPartitioner() {
		 this(DEFAULT_CONTENT_TYPE);
	 }
	 public void onDocumentChanged(final DocumentChangedEvent event) {
		 final int removed = event.getLength();
		 int added = 0;
		 if (event.getText() != null) {
			 added = event.getText().length();
		 }
		 final int sizeDelta = added - removed;
		 this.documentLength += sizeDelta;
	 }
	 public void initialize() {
		 this.documentLength = getDocumentHandle().getDocument().getContentsCharCount();
	 }
	 public List<String> getLegalContentTypes() {
		 return legalContentTypes;
	 }
	 public String getContentType(final int offset) {
		 return this.contentType;
	 }
	 public List<TypedRegion> computePartitioning(final int offset, final int length) {
		 final TypedRegion region = getPartition(offset);
		 return Collections.singletonList(region);
	 }
	 public TypedRegion getPartition(final int offset) {
		 return new TypedRegionImpl(offset, this.documentLength, this.contentType);
	 }
	 public DocumentHandle getDocumentHandle() {
		 return documentHandle;
	 }
	 public void setDocumentHandle(DocumentHandle handle) {
		 this.documentHandle = handle;
	 }
	 public void release() {
	}
}",0,1,0,0
"int offerService() throws Exception {
	 long lastHeartbeat = 0;
	 this.fs = FileSystem.getNamed(jobClient.getFilesystemName(), this.fConf);
	 while (running) {
		 long now = System.currentTimeMillis();
		 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
		 if (waitTime > 0) {
			 try {
				 Thread.sleep(waitTime);
			 }
			 catch (InterruptedException ie) {
			 }
			 continue;
		 }
		 lastHeartbeat = now;
		 Vector taskReports = new Vector();
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 TaskStatus status = tip.createStatus();
				 taskReports.add(status);
				 if (status.getRunState() != TaskStatus.RUNNING) {
					 if (tip.getTask().isMapTask()) {
						 mapTotal--;
					 }
					 else {
						 reduceTotal--;
					 }
					 it.remove();
				 }
			 }
		 }
		 TaskTrackerStatus status = new TaskTrackerStatus(taskTrackerName, localHostname, mapOutputPort, httpPort, taskReports, failures);
		 int resultCode = jobClient.emitHeartbeat(status, justStarted);
		 justStarted = false;
		 if (resultCode == InterTrackerProtocol.UNKNOWN_TASKTRACKER) {
			 return STALE_STATE;
		 }
		 try {
			 if (mapTotal < maxCurrentTasks || reduceTotal < maxCurrentTasks) {
				 checkLocalDirs(fConf.getLocalDirs());
				 Task t = jobClient.pollForNewTask(taskTrackerName);
				 if (t != null) {
					 startNewTask(t);
				 }
			 }
		 }
		 catch (DiskErrorException de ) {
			 LOG.warn(""Exiting task tracker because ""+de.getMessage());
			 jobClient.reportTaskTrackerError(taskTrackerName, ""DiskErrorException"", de.getMessage());
			 return STALE_STATE;
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem launching task: "" + StringUtils.stringifyException(ie));
		 }
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 long timeSinceLastReport = System.currentTimeMillis() - tip.getLastProgressReport();
				 if ((tip.getRunState() == TaskStatus.RUNNING) && (timeSinceLastReport > this.taskTimeout) && !tip.wasKilled) {
					 String msg = ""Task failed to report status for "" + (timeSinceLastReport / 1000) + "" seconds. Killing."";
					 LOG.info(tip.getTask().getTaskId() + "": "" + msg);
					 tip.reportDiagnosticInfo(msg);
					 try {
						 tip.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 try {
			 String[] toCloseIds = jobClient.pollForTaskWithClosedJob(taskTrackerName);
			 if (toCloseIds != null) {
				 synchronized (this) {
					 for (int i = 0;
					 i < toCloseIds.length;
					 i++) {
						 Object tip = tasks.get(toCloseIds[i]);
						 if (tip != null) {
							 tasksToCleanup.put(tip);
						 }
						 else {
							 LOG.info(""Attempt to cleanup unknown tip "" + toCloseIds[i]);
						 }
					 }
				 }
			 }
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem getting closed tasks: "" + StringUtils.stringifyException(ie));
		 }
	 }
	 return 0;
 }",0,0,1,0
"public static class FilterRecordWriter<K,V> implements RecordWriter<K,V> {
	 protected RecordWriter<K,V> rawWriter = null;
	 public FilterRecordWriter() throws IOException {
		 rawWriter = null;
	 }
	 public FilterRecordWriter(RecordWriter<K,V> rawWriter) throws IOException {
		 this.rawWriter = rawWriter;
	 }
	 public void close(Reporter reporter) throws IOException {
		 getRawWriter().close(reporter);
	 }
	 public void write(K key, V value) throws IOException {
		 getRawWriter().write(key, value);
	 }
	 private RecordWriter<K,V> getRawWriter() throws IOException {
		 if (rawWriter == null) {
			 throw new IOException (""Record Writer not set for FilterRecordWriter"");
		 }
		 return rawWriter;
	 }
 }",0,0,0,0
"public abstract class AbstractReplicationStrategy{
	 private static final Logger logger = LoggerFactory.getLogger(AbstractReplicationStrategy.class);
	 public final String table;
	 public final Map<String, String> configOptions;
	 private final TokenMetadata tokenMetadata;
	 public IEndpointSnitch snitch;
	 AbstractReplicationStrategy(String table, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> configOptions) {
		 assert table != null;
		 assert snitch != null;
		 assert tokenMetadata != null;
		 this.tokenMetadata = tokenMetadata;
		 this.snitch = snitch;
		 this.tokenMetadata.register(this);
		 this.configOptions = configOptions;
		 this.table = table;
	 }
	 private final Map<Token, ArrayList<InetAddress>> cachedEndpoints = new NonBlockingHashMap<Token, ArrayList<InetAddress>>();
	 public ArrayList<InetAddress> getCachedEndpoints(Token t) {
		 return cachedEndpoints.get(t);
	 }
	 public void cacheEndpoint(Token t, ArrayList<InetAddress> addr) {
		 cachedEndpoints.put(t, addr);
	 }
	 public void clearEndpointCache() {
		 logger.debug(""clearing cached endpoints"");
		 cachedEndpoints.clear();
	 }
	 public ArrayList<InetAddress> getNaturalEndpoints(Token searchToken) {
		 Token keyToken = TokenMetadata.firstToken(tokenMetadata.sortedTokens(), searchToken);
		 ArrayList<InetAddress> endpoints = getCachedEndpoints(keyToken);
		 if (endpoints == null) {
			 TokenMetadata tokenMetadataClone = tokenMetadata.cloneOnlyTokenMap();
			 keyToken = TokenMetadata.firstToken(tokenMetadataClone.sortedTokens(), searchToken);
			 endpoints = new ArrayList<InetAddress>(calculateNaturalEndpoints(searchToken, tokenMetadataClone));
			 cacheEndpoint(keyToken, endpoints);
		 }
		 return new ArrayList<InetAddress>(endpoints);
	 }
	 public abstract List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetadata tokenMetadata);
	 public IWriteResponseHandler getWriteResponseHandler(Collection<InetAddress> writeEndpoints, Multimap<InetAddress, InetAddress> hintedEndpoints, ConsistencyLevel consistency_level) {
		 if (consistency_level == ConsistencyLevel.LOCAL_QUORUM) {
			 return DatacenterWriteResponseHandler.create(writeEndpoints, hintedEndpoints, consistency_level, table);
		 }
		 else if (consistency_level == ConsistencyLevel.EACH_QUORUM) {
			 return DatacenterSyncWriteResponseHandler.create(writeEndpoints, hintedEndpoints, consistency_level, table);
		 }
		 return WriteResponseHandler.create(writeEndpoints, hintedEndpoints, consistency_level, table);
	 }
	 public abstract int getReplicationFactor();
	 public Multimap<InetAddress, InetAddress> getHintedEndpoints(Collection<InetAddress> targets) {
		 Multimap<InetAddress, InetAddress> map = HashMultimap.create(targets.size(), 1);
		 for (InetAddress ep : targets) {
			 if (FailureDetector.instance.isAlive(ep)) map.put(ep, ep);
		 }
		 if (map.size() == targets.size() || !StorageProxy.isHintedHandoffEnabled()) return map;
		 InetAddress localAddress = FBUtilities.getLocalAddress();
		 for (InetAddress ep : targets) {
			 if (map.containsKey(ep)) continue;
			 if (!StorageProxy.shouldHint(ep)) {
				 if (logger.isDebugEnabled()) logger.debug(""not hinting "" + ep + "" which has been down "" + Gossiper.instance.getEndpointDowntime(ep) + ""ms"");
				 continue;
			 }
			 InetAddress destination = map.isEmpty() ? localAddress : snitch.getSortedListByProximity(localAddress, map.keySet()).get(0);
			 map.put(destination, ep);
		 }
		 return map;
	 }
	 public Multimap<InetAddress, Range> getAddressRanges(TokenMetadata metadata) {
		 Multimap<InetAddress, Range> map = HashMultimap.create();
		 for (Token token : metadata.sortedTokens()) {
			 Range range = metadata.getPrimaryRangeFor(token);
			 for (InetAddress ep : calculateNaturalEndpoints(token, metadata)) {
				 map.put(ep, range);
			 }
		 }
		 return map;
	 }
	 public Multimap<Range, InetAddress> getRangeAddresses(TokenMetadata metadata) {
		 Multimap<Range, InetAddress> map = HashMultimap.create();
		 for (Token token : metadata.sortedTokens()) {
			 Range range = metadata.getPrimaryRangeFor(token);
			 for (InetAddress ep : calculateNaturalEndpoints(token, metadata)) {
				 map.put(range, ep);
			 }
		 }
		 return map;
	 }
	 public Multimap<InetAddress, Range> getAddressRanges() {
		 return getAddressRanges(tokenMetadata);
	 }
	 public Collection<Range> getPendingAddressRanges(TokenMetadata metadata, Token pendingToken, InetAddress pendingAddress) {
		 TokenMetadata temp = metadata.cloneOnlyTokenMap();
		 temp.updateNormalToken(pendingToken, pendingAddress);
		 return getAddressRanges(temp).get(pendingAddress);
	 }
	 public void invalidateCachedTokenEndpointValues() {
		 clearEndpointCache();
	 }
	 public abstract void validateOptions() throws ConfigurationException;
	 public static AbstractReplicationStrategy createReplicationStrategy(String table, Class<? extends AbstractReplicationStrategy> strategyClass, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> strategyOptions) throws ConfigurationException {
		 AbstractReplicationStrategy strategy;
		 Class [] parameterTypes = new Class[] {
		String.class, TokenMetadata.class, IEndpointSnitch.class, Map.class}
		;
		 try {
			 Constructor<? extends AbstractReplicationStrategy> constructor = strategyClass.getConstructor(parameterTypes);
			 strategy = constructor.newInstance(table, tokenMetadata, snitch, strategyOptions);
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
		 strategy.validateOptions();
		 return strategy;
	 }
	 public static AbstractReplicationStrategy createReplicationStrategy(String table, String strategyClassName, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> strategyOptions) throws ConfigurationException {
		 Class<AbstractReplicationStrategy> c = getClass(strategyClassName);
		 return createReplicationStrategy(table, c, tokenMetadata, snitch, strategyOptions);
	 }
	 public static Class<AbstractReplicationStrategy> getClass(String cls) throws ConfigurationException {
		 String className = cls.contains(""."") ? cls : ""org.apache.cassandra.locator."" + cls;
		 return FBUtilities.classForName(className, ""replication strategy"");
	 }
	 protected void validateReplicationFactor(String rf) throws ConfigurationException {
		 try {
			 if (Integer.parseInt(rf) < 0) {
				 throw new ConfigurationException(""Replication factor must be non-negative;
				 found "" + rf);
			 }
		 }
		 catch (NumberFormatException e2) {
			 throw new ConfigurationException(""Replication factor must be numeric;
			 found "" + rf);
		 }
	 }
}",0,0,0,0
"public class HTMLScanner implements XMLDocumentScanner, XMLLocator, HTMLComponent {
	 public static final String HTML_4_01_STRICT_PUBID = ""- public static final String HTML_4_01_STRICT_SYSID = ""http: public static final String HTML_4_01_TRANSITIONAL_PUBID = ""- public static final String HTML_4_01_TRANSITIONAL_SYSID = ""http: public static final String HTML_4_01_FRAMESET_PUBID = ""- public static final String HTML_4_01_FRAMESET_SYSID = ""http: protected static final String AUGMENTATIONS = ""http: protected static final String REPORT_ERRORS = ""http: public static final String NOTIFY_CHAR_REFS = ""http: public static final String NOTIFY_XML_BUILTIN_REFS = ""http: public static final String NOTIFY_HTML_BUILTIN_REFS = ""http: public static final String FIX_MSWINDOWS_REFS = ""http: public static final String SCRIPT_STRIP_COMMENT_DELIMS = ""http: public static final String SCRIPT_STRIP_CDATA_DELIMS = ""http: public static final String STYLE_STRIP_COMMENT_DELIMS = ""http: public static final String STYLE_STRIP_CDATA_DELIMS = ""http: public static final String IGNORE_SPECIFIED_CHARSET = ""http: public static final String CDATA_SECTIONS = ""http: public static final String OVERRIDE_DOCTYPE = ""http: public static final String INSERT_DOCTYPE = ""http: public static final String PARSE_NOSCRIPT_CONTENT = ""http: protected static final String NORMALIZE_ATTRIBUTES = ""http: private static final String[] RECOGNIZED_FEATURES = {
	 AUGMENTATIONS, REPORT_ERRORS, NOTIFY_CHAR_REFS, NOTIFY_XML_BUILTIN_REFS, NOTIFY_HTML_BUILTIN_REFS, FIX_MSWINDOWS_REFS, SCRIPT_STRIP_CDATA_DELIMS, SCRIPT_STRIP_COMMENT_DELIMS, STYLE_STRIP_CDATA_DELIMS, STYLE_STRIP_COMMENT_DELIMS, IGNORE_SPECIFIED_CHARSET, CDATA_SECTIONS, OVERRIDE_DOCTYPE, INSERT_DOCTYPE, NORMALIZE_ATTRIBUTES, PARSE_NOSCRIPT_CONTENT, }
	;
	 private static final Boolean[] RECOGNIZED_FEATURES_DEFAULTS = {
	 null, null, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.TRUE, }
	;
	 protected static final String NAMES_ELEMS = ""http: protected static final String NAMES_ATTRS = ""http: protected static final String DEFAULT_ENCODING = ""http: protected static final String ERROR_REPORTER = ""http: protected static final String DOCTYPE_PUBID = ""http: protected static final String DOCTYPE_SYSID = ""http: private static final String[] RECOGNIZED_PROPERTIES = {
	 NAMES_ELEMS, NAMES_ATTRS, DEFAULT_ENCODING, ERROR_REPORTER, DOCTYPE_PUBID, DOCTYPE_SYSID, }
	;
	 private static final Object[] RECOGNIZED_PROPERTIES_DEFAULTS = {
	 null, null, ""Windows-1252"", null, HTML_4_01_TRANSITIONAL_PUBID, HTML_4_01_TRANSITIONAL_SYSID, }
	;
	 protected static final short STATE_CONTENT = 0;
	 protected static final short STATE_MARKUP_BRACKET = 1;
	 protected static final short STATE_START_DOCUMENT = 10;
	 protected static final short STATE_END_DOCUMENT = 11;
	 protected static final short NAMES_NO_CHANGE = 0;
	 protected static final short NAMES_UPPERCASE = 1;
	 protected static final short NAMES_LOWERCASE = 2;
	 protected static final int DEFAULT_BUFFER_SIZE = 2048;
	 private static final boolean DEBUG_SCANNER = false;
	 private static final boolean DEBUG_SCANNER_STATE = false;
	 private static final boolean DEBUG_BUFFER = false;
	 private static final boolean DEBUG_CHARSET = false;
	 protected static final boolean DEBUG_CALLBACKS = false;
	 protected static final HTMLEventInfo SYNTHESIZED_ITEM = new HTMLEventInfo.SynthesizedItem();
	 private final static BitSet ENTITY_CHARS = new BitSet();
	 static {
		 final String str = ""-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"";
		 for (int i = 0;
		 i < str.length();
		 ++i) {
			 char c = str.charAt(i);
			 ENTITY_CHARS.set(c);
		 }
	 }
	 protected boolean fAugmentations;
	 protected boolean fReportErrors;
	 protected boolean fNotifyCharRefs;
	 protected boolean fNotifyXmlBuiltinRefs;
	 protected boolean fNotifyHtmlBuiltinRefs;
	 protected boolean fFixWindowsCharRefs;
	 protected boolean fScriptStripCDATADelims;
	 protected boolean fScriptStripCommentDelims;
	 protected boolean fStyleStripCDATADelims;
	 protected boolean fStyleStripCommentDelims;
	 protected boolean fIgnoreSpecifiedCharset;
	 protected boolean fCDATASections;
	 protected boolean fOverrideDoctype;
	 protected boolean fInsertDoctype;
	 protected boolean fNormalizeAttributes;
	 protected boolean fParseNoScriptContent;
	 protected boolean fParseNoFramesContent;
	 protected short fNamesElems;
	 protected short fNamesAttrs;
	 protected String fDefaultIANAEncoding;
	 protected HTMLErrorReporter fErrorReporter;
	 protected String fDoctypePubid;
	 protected String fDoctypeSysid;
	 protected int fBeginLineNumber;
	 protected int fBeginColumnNumber;
	 protected int fBeginCharacterOffset;
	 protected int fEndLineNumber;
	 protected int fEndColumnNumber;
	 protected int fEndCharacterOffset;
	 protected PlaybackInputStream fByteStream;
	 protected CurrentEntity fCurrentEntity;
	 protected final Stack fCurrentEntityStack = new Stack();
	 protected Scanner fScanner;
	 protected short fScannerState;
	 protected XMLDocumentHandler fDocumentHandler;
	 protected String fIANAEncoding;
	 protected String fJavaEncoding;
	 protected boolean fIso8859Encoding;
	 protected int fElementCount;
	 protected int fElementDepth;
	 protected Scanner fContentScanner = new ContentScanner();
	 protected SpecialScanner fSpecialScanner = new SpecialScanner();
	 protected final XMLStringBuffer fStringBuffer = new XMLStringBuffer(1024);
	 private final XMLStringBuffer fStringBuffer2 = new XMLStringBuffer(1024);
	 private final XMLStringBuffer fNonNormAttr = new XMLStringBuffer(128);
	 private final HTMLAugmentations fInfosetAugs = new HTMLAugmentations();
	 private final LocationItem fLocationItem = new LocationItem();
	 private final boolean[] fSingleBoolean = {
	 false }
	;
	 private final XMLResourceIdentifierImpl fResourceId = new XMLResourceIdentifierImpl();
	 public void pushInputSource(XMLInputSource inputSource) {
		 final Reader reader = getReader(inputSource);
		 fCurrentEntityStack.push(fCurrentEntity);
		 String encoding = inputSource.getEncoding();
		 String publicId = inputSource.getPublicId();
		 String baseSystemId = inputSource.getBaseSystemId();
		 String literalSystemId = inputSource.getSystemId();
		 String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);
		 fCurrentEntity = new CurrentEntity(reader, encoding, publicId, baseSystemId, literalSystemId, expandedSystemId);
	 }
	 private Reader getReader(final XMLInputSource inputSource) {
		 Reader reader = inputSource.getCharacterStream();
		 if (reader == null) {
			 try {
				return new InputStreamReader(inputSource.getByteStream(), fJavaEncoding);
			}
			 catch (final UnsupportedEncodingException e) {
			}
		 }
		 return reader;
	}
	 public void evaluateInputSource(XMLInputSource inputSource) {
		 final Scanner previousScanner = fScanner;
		 final short previousScannerState = fScannerState;
		 final CurrentEntity previousEntity = fCurrentEntity;
		 final Reader reader = getReader(inputSource);
		 String encoding = inputSource.getEncoding();
		 String publicId = inputSource.getPublicId();
		 String baseSystemId = inputSource.getBaseSystemId();
		 String literalSystemId = inputSource.getSystemId();
		 String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);
		 fCurrentEntity = new CurrentEntity(reader, encoding, publicId, baseSystemId, literalSystemId, expandedSystemId);
		 setScanner(fContentScanner);
		 setScannerState(STATE_CONTENT);
		 try {
			 do {
				 fScanner.scan(false);
			 }
			 while (fScannerState != STATE_END_DOCUMENT);
		 }
		 catch (final IOException e) {
		 }
		 setScanner(previousScanner);
		 setScannerState(previousScannerState);
		 fCurrentEntity = previousEntity;
	 }
	 public void cleanup(boolean closeall) {
		 int size = fCurrentEntityStack.size();
		 if (size > 0) {
			 if (fCurrentEntity != null) {
				 fCurrentEntity.closeQuietly();
			 }
			 for (int i = closeall ? 0 : 1;
			 i < size;
			 i++) {
				 fCurrentEntity = (CurrentEntity) fCurrentEntityStack.pop();
				 fCurrentEntity.closeQuietly();
			 }
		 }
		 else if (closeall && fCurrentEntity != null) {
			 fCurrentEntity.closeQuietly();
		 }
	 }
	 public String getEncoding() {
		 return fCurrentEntity != null ? fCurrentEntity.encoding : null;
	 }
	 public String getPublicId() {
		 return fCurrentEntity != null ? fCurrentEntity.publicId : null;
	 }
	 public String getBaseSystemId() {
		 return fCurrentEntity != null ? fCurrentEntity.baseSystemId : null;
	 }
	 public String getLiteralSystemId() {
		 return fCurrentEntity != null ? fCurrentEntity.literalSystemId : null;
	 }
	 public String getExpandedSystemId() {
		 return fCurrentEntity != null ? fCurrentEntity.expandedSystemId : null;
	 }
	 public int getLineNumber() {
		 return fCurrentEntity != null ? fCurrentEntity.getLineNumber() : -1;
	 }
	 public int getColumnNumber() {
		 return fCurrentEntity != null ? fCurrentEntity.getColumnNumber() : -1;
	 }
	 public String getXMLVersion() {
		return fCurrentEntity != null ? fCurrentEntity.version : null;
	 }
	 public int getCharacterOffset() {
		return fCurrentEntity != null ? fCurrentEntity.getCharacterOffset() : -1;
	 }
	 public Boolean getFeatureDefault(String featureId) {
		 int length = RECOGNIZED_FEATURES != null ? RECOGNIZED_FEATURES.length : 0;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return RECOGNIZED_FEATURES_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 int length = RECOGNIZED_PROPERTIES != null ? RECOGNIZED_PROPERTIES.length : 0;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return RECOGNIZED_PROPERTIES_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public String[] getRecognizedFeatures() {
		 return RECOGNIZED_FEATURES;
	 }
	 public String[] getRecognizedProperties() {
		 return RECOGNIZED_PROPERTIES;
	 }
	 public void reset(XMLComponentManager manager) throws XMLConfigurationException {
		 fAugmentations = manager.getFeature(AUGMENTATIONS);
		 fReportErrors = manager.getFeature(REPORT_ERRORS);
		 fNotifyCharRefs = manager.getFeature(NOTIFY_CHAR_REFS);
		 fNotifyXmlBuiltinRefs = manager.getFeature(NOTIFY_XML_BUILTIN_REFS);
		 fNotifyHtmlBuiltinRefs = manager.getFeature(NOTIFY_HTML_BUILTIN_REFS);
		 fFixWindowsCharRefs = manager.getFeature(FIX_MSWINDOWS_REFS);
		 fScriptStripCDATADelims = manager.getFeature(SCRIPT_STRIP_CDATA_DELIMS);
		 fScriptStripCommentDelims = manager.getFeature(SCRIPT_STRIP_COMMENT_DELIMS);
		 fStyleStripCDATADelims = manager.getFeature(STYLE_STRIP_CDATA_DELIMS);
		 fStyleStripCommentDelims = manager.getFeature(STYLE_STRIP_COMMENT_DELIMS);
		 fIgnoreSpecifiedCharset = manager.getFeature(IGNORE_SPECIFIED_CHARSET);
		 fCDATASections = manager.getFeature(CDATA_SECTIONS);
		 fOverrideDoctype = manager.getFeature(OVERRIDE_DOCTYPE);
		 fInsertDoctype = manager.getFeature(INSERT_DOCTYPE);
		 fNormalizeAttributes = manager.getFeature(NORMALIZE_ATTRIBUTES);
		 fParseNoScriptContent = manager.getFeature(PARSE_NOSCRIPT_CONTENT);
		 fNamesElems = getNamesValue(String.valueOf(manager.getProperty(NAMES_ELEMS)));
		 fNamesAttrs = getNamesValue(String.valueOf(manager.getProperty(NAMES_ATTRS)));
		 fDefaultIANAEncoding = String.valueOf(manager.getProperty(DEFAULT_ENCODING));
		 fErrorReporter = (HTMLErrorReporter)manager.getProperty(ERROR_REPORTER);
		 fDoctypePubid = String.valueOf(manager.getProperty(DOCTYPE_PUBID));
		 fDoctypeSysid = String.valueOf(manager.getProperty(DOCTYPE_SYSID));
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
		 if (featureId.equals(AUGMENTATIONS)) {
			 fAugmentations = state;
		 }
		 else if (featureId.equals(IGNORE_SPECIFIED_CHARSET)) {
			 fIgnoreSpecifiedCharset = state;
		 }
		 else if (featureId.equals(NOTIFY_CHAR_REFS)) {
			 fNotifyCharRefs = state;
		 }
		 else if (featureId.equals(NOTIFY_XML_BUILTIN_REFS)) {
			 fNotifyXmlBuiltinRefs = state;
		 }
		 else if (featureId.equals(NOTIFY_HTML_BUILTIN_REFS)) {
			 fNotifyHtmlBuiltinRefs = state;
		 }
		 else if (featureId.equals(FIX_MSWINDOWS_REFS)) {
			 fFixWindowsCharRefs = state;
		 }
		 else if (featureId.equals(SCRIPT_STRIP_CDATA_DELIMS)) {
			 fScriptStripCDATADelims = state;
		 }
		 else if (featureId.equals(SCRIPT_STRIP_COMMENT_DELIMS)) {
			 fScriptStripCommentDelims = state;
		 }
		 else if (featureId.equals(STYLE_STRIP_CDATA_DELIMS)) {
			 fStyleStripCDATADelims = state;
		 }
		 else if (featureId.equals(STYLE_STRIP_COMMENT_DELIMS)) {
			 fStyleStripCommentDelims = state;
		 }
		 else if (featureId.equals(IGNORE_SPECIFIED_CHARSET)) {
			 fIgnoreSpecifiedCharset = state;
		 }
		 else if (featureId.equals(PARSE_NOSCRIPT_CONTENT)) {
			 fParseNoScriptContent = state;
		 }
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
		 if (propertyId.equals(NAMES_ELEMS)) {
			 fNamesElems = getNamesValue(String.valueOf(value));
			 return;
		 }
		 if (propertyId.equals(NAMES_ATTRS)) {
			 fNamesAttrs = getNamesValue(String.valueOf(value));
			 return;
		 }
		 if (propertyId.equals(DEFAULT_ENCODING)) {
			 fDefaultIANAEncoding = String.valueOf(value);
			 return;
		 }
	 }
	 public void setInputSource(XMLInputSource source) throws IOException {
		 fElementCount = 0;
		 fElementDepth = -1;
		 fByteStream = null;
		 fCurrentEntityStack.removeAllElements();
		 fBeginLineNumber = 1;
		 fBeginColumnNumber = 1;
		 fBeginCharacterOffset = 0;
		 fEndLineNumber = fBeginLineNumber;
		 fEndColumnNumber = fBeginColumnNumber;
		 fEndCharacterOffset = fBeginCharacterOffset;
		 fIANAEncoding = fDefaultIANAEncoding;
		 fJavaEncoding = fIANAEncoding;
		 String encoding = source.getEncoding();
		 String publicId = source.getPublicId();
		 String baseSystemId = source.getBaseSystemId();
		 String literalSystemId = source.getSystemId();
		 String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);
		 Reader reader = source.getCharacterStream();
		 if (reader == null) {
			 InputStream inputStream = source.getByteStream();
			 if (inputStream == null) {
				 URL url = new URL(expandedSystemId);
				 inputStream = url.openStream();
			 }
			 fByteStream = new PlaybackInputStream(inputStream);
			 String[] encodings = new String[2];
			 if (encoding == null) {
				 fByteStream.detectEncoding(encodings);
			 }
			 else {
				 encodings[0] = encoding;
			 }
			 if (encodings[0] == null) {
				 encodings[0] = fDefaultIANAEncoding;
				 if (fReportErrors) {
					 fErrorReporter.reportWarning(""HTML1000"", null);
				 }
			 }
			 if (encodings[1] == null) {
				 encodings[1] = EncodingMap.getIANA2JavaMapping(encodings[0].toUpperCase());
				 if (encodings[1] == null) {
					 encodings[1] = encodings[0];
					 if (fReportErrors) {
						 fErrorReporter.reportWarning(""HTML1001"", new Object[]{
						encodings[0]}
						);
					 }
				 }
			 }
			 fIANAEncoding = encodings[0];
			 fJavaEncoding = encodings[1];
			 fIso8859Encoding = fIANAEncoding == null || fIANAEncoding.toUpperCase().startsWith(""ISO-8859"") || fIANAEncoding.equalsIgnoreCase(fDefaultIANAEncoding);
			 encoding = fIANAEncoding;
			 reader = new InputStreamReader(fByteStream, fJavaEncoding);
		 }
		 fCurrentEntity = new CurrentEntity(reader, encoding, publicId, baseSystemId, literalSystemId, expandedSystemId);
		 setScanner(fContentScanner);
		 setScannerState(STATE_START_DOCUMENT);
	 }
	 public boolean scanDocument(boolean complete) throws XNIException, IOException {
		 do {
			 if (!fScanner.scan(complete)) {
				 return false;
			 }
		 }
		 while (complete);
		 return true;
	 }
	 public void setDocumentHandler(XMLDocumentHandler handler) {
		 fDocumentHandler = handler;
	 }
	 public XMLDocumentHandler getDocumentHandler() {
		 return fDocumentHandler;
	 }
	 protected static String getValue(XMLAttributes attrs, String aname) {
		 int length = attrs != null ? attrs.getLength() : 0;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (attrs.getQName(i).equalsIgnoreCase(aname)) {
				 return attrs.getValue(i);
			 }
		 }
		 return null;
	 }
	 public static String expandSystemId(String systemId, String baseSystemId) {
		 if (systemId == null || systemId.length() == 0) {
			 return systemId;
		 }
		 try {
			 URI uri = new URI(systemId);
			 if (uri != null) {
				 return systemId;
			 }
		 }
		 catch (URI.MalformedURIException e) {
		 }
		 String id = fixURI(systemId);
		 URI base = null;
		 URI uri = null;
		 try {
			 if (baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)) {
				 String dir;
				 try {
					 dir = fixURI(System.getProperty(""user.dir""));
				 }
				 catch (SecurityException se) {
					 dir = """";
				 }
				 if (!dir.endsWith(""/"")) {
					 dir = dir + ""/"";
				 }
				 base = new URI(""file"", """", dir, null, null);
			 }
			 else {
				 try {
					 base = new URI(fixURI(baseSystemId));
				 }
				 catch (URI.MalformedURIException e) {
					 String dir;
					 try {
						 dir = fixURI(System.getProperty(""user.dir""));
					 }
					 catch (SecurityException se) {
						 dir = """";
					 }
					 if (baseSystemId.indexOf(':') != -1) {
						 base = new URI(""file"", """", fixURI(baseSystemId), null, null);
					 }
					 else {
						 if (!dir.endsWith(""/"")) {
							 dir = dir + ""/"";
						 }
						 dir = dir + fixURI(baseSystemId);
						 base = new URI(""file"", """", dir, null, null);
					 }
				 }
			 }
			 uri = new URI(base, id);
		 }
		 catch (URI.MalformedURIException e) {
		 }
		 if (uri == null) {
			 return systemId;
		 }
		 return uri.toString();
	 }
	 protected static String fixURI(String str) {
		 str = str.replace(java.io.File.separatorChar, '/');
		 if (str.length() >= 2) {
			 char ch1 = str.charAt(1);
			 if (ch1 == ':') {
				 char ch0 = Character.toUpperCase(str.charAt(0));
				 if (ch0 >= 'A' && ch0 <= 'Z') {
					 str = ""/"" + str;
				 }
			 }
			 else if (ch1 == '/' && str.charAt(0) == '/') {
				 str = ""file:"" + str;
			 }
		 }
		 return str;
	 }
	 protected static final String modifyName(String name, short mode) {
		 switch (mode) {
			 case NAMES_UPPERCASE: return name.toUpperCase();
			 case NAMES_LOWERCASE: return name.toLowerCase();
		 }
		 return name;
	 }
	 protected static final short getNamesValue(String value) {
		 if (value.equals(""lower"")) {
			 return NAMES_LOWERCASE;
		 }
		 if (value.equals(""upper"")) {
			 return NAMES_UPPERCASE;
		 }
		 return NAMES_NO_CHANGE;
	 }
	 protected int fixWindowsCharacter(int origChar) {
		 switch(origChar) {
			 case 130: return 8218;
			 case 131: return 402;
			 case 132: return 8222;
			 case 133: return 8230;
			 case 134: return 8224;
			 case 135: return 8225;
			 case 136: return 710;
			 case 137: return 8240;
			 case 138: return 352;
			 case 139: return 8249;
			 case 140: return 338;
			 case 145: return 8216;
			 case 146: return 8217;
			 case 147: return 8220;
			 case 148: return 8221;
			 case 149: return 8226;
			 case 150: return 8211;
			 case 151: return 8212;
			 case 152: return 732;
			 case 153: return 8482;
			 case 154: return 353;
			 case 155: return 8250;
			 case 156: return 339;
			 case 159: return 376;
		 }
		 return origChar;
	 }
	 protected int read() throws IOException {
		 return fCurrentEntity.read();
	 }
	 protected void setScanner(Scanner scanner) {
		 fScanner = scanner;
		 if (DEBUG_SCANNER) {
			 System.out.print(""$$$ setScanner("");
			 System.out.print(scanner!=null?scanner.getClass().getName():""null"");
			 System.out.println("");
			"");
		 }
	 }
	 protected void setScannerState(short state) {
		 fScannerState = state;
		 if (DEBUG_SCANNER_STATE) {
			 System.out.print(""$$$ setScannerState("");
			 switch (fScannerState) {
				 case STATE_CONTENT: {
					 System.out.print(""STATE_CONTENT"");
					 break;
				 }
				 case STATE_MARKUP_BRACKET: {
					 System.out.print(""STATE_MARKUP_BRACKET"");
					 break;
				 }
				 case STATE_START_DOCUMENT: {
					 System.out.print(""STATE_START_DOCUMENT"");
					 break;
				 }
				 case STATE_END_DOCUMENT: {
					 System.out.print(""STATE_END_DOCUMENT"");
					 break;
				 }
			 }
			 System.out.println("");
			"");
		 }
	 }
	 protected void scanDoctype() throws IOException {
		 String root = null;
		 String pubid = null;
		 String sysid = null;
		 if (skipSpaces()) {
			 root = scanName();
			 if (root == null) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1014"", null);
				 }
			 }
			 else {
				 root = modifyName(root, fNamesElems);
			 }
			 if (skipSpaces()) {
				 if (skip(""PUBLIC"", false)) {
					 skipSpaces();
					 pubid = scanLiteral();
					 if (skipSpaces()) {
						 sysid = scanLiteral();
					 }
				 }
				 else if (skip(""SYSTEM"", false)) {
					 skipSpaces();
					 sysid = scanLiteral();
				 }
			 }
		 }
		 int c;
		 while ((c = fCurrentEntity.read()) != -1) {
			 if (c == '<') {
				 fCurrentEntity.rewind();
				 break;
			 }
			 if (c == '>') {
				 break;
			 }
			 if (c == '[') {
				 skipMarkup(true);
				 break;
			 }
		 }
		 if (fDocumentHandler != null) {
			 if (fOverrideDoctype) {
				 pubid = fDoctypePubid;
				 sysid = fDoctypeSysid;
			 }
			 fEndLineNumber = fCurrentEntity.getLineNumber();
			 fEndColumnNumber = fCurrentEntity.getColumnNumber();
			 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
			 fDocumentHandler.doctypeDecl(root, pubid, sysid, locationAugs());
		 }
	 }
	 protected String scanLiteral() throws IOException {
		 int quote = fCurrentEntity.read();
		 if (quote == '\'' || quote == '""') {
			 StringBuffer str = new StringBuffer();
			 int c;
			 while ((c = fCurrentEntity.read()) != -1) {
				 if (c == quote) {
					 break;
				 }
				 if (c == '\r' || c == '\n') {
					 fCurrentEntity.rewind();
					 skipNewlines();
					 str.append(' ');
				 }
				 else if (c == '<') {
					 fCurrentEntity.rewind();
					 break;
				 }
				 else {
					 str.append((char)c);
				 }
			 }
			 if (c == -1) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1007"", null);
				 }
				 throw new EOFException();
			 }
			 return str.toString();
		 }
		 else {
			 fCurrentEntity.rewind();
		 }
		 return null;
	 }
	 protected String scanName() throws IOException {
		 fCurrentEntity.debugBufferIfNeeded(""(scanName: "");
		 if (fCurrentEntity.offset == fCurrentEntity.length) {
			 if (fCurrentEntity.load(0) == -1) {
				 fCurrentEntity.debugBufferIfNeeded("")scanName: "");
				 return null;
			 }
		 }
		 int offset = fCurrentEntity.offset;
		 while (true) {
			 while (fCurrentEntity.hasNext()) {
				 char c = fCurrentEntity.getNextChar();
				 if (!Character.isLetterOrDigit(c) && !(c == '-' || c == '.' || c == ':' || c == '_')) {
					 fCurrentEntity.rewind();
					 break;
				 }
			 }
			 if (fCurrentEntity.offset == fCurrentEntity.length) {
				 int length = fCurrentEntity.length - offset;
				 System.arraycopy(fCurrentEntity.buffer, offset, fCurrentEntity.buffer, 0, length);
				 int count = fCurrentEntity.load(length);
				 offset = 0;
				 if (count == -1) {
					 break;
				 }
			 }
			 else {
				 break;
			 }
		 }
		 int length = fCurrentEntity.offset - offset;
		 String name = length > 0 ? new String(fCurrentEntity.buffer, offset, length) : null;
		 fCurrentEntity.debugBufferIfNeeded("")scanName: "", "" -> \"""" + name + '""');
		 return name;
	 }
	 protected int scanEntityRef(final XMLStringBuffer str, final boolean content) throws IOException {
		 str.clear();
		 str.append('&');
		 boolean endsWithSemicolon = false;
		 while (true) {
			 int c = fCurrentEntity.read();
			 if (c == ';
			') {
				 str.append(';
				');
				 endsWithSemicolon = true;
				 break;
			 }
			 else if (c == -1) {
				 break;
			 }
			 else if (!ENTITY_CHARS.get(c) && c != '#') {
				 fCurrentEntity.rewind();
				 break;
			 }
			 str.append((char)c);
		 }
		 if (!endsWithSemicolon) {
			 if (fReportErrors) {
				 fErrorReporter.reportWarning(""HTML1004"", null);
			 }
		 }
		 if (str.length == 1) {
			 if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 fDocumentHandler.characters(str, locationAugs());
			 }
			 return -1;
		 }
		 final String name;
		 if (endsWithSemicolon) name = str.toString().substring(1, str.length -1);
		 else name = str.toString().substring(1);
		 if (name.startsWith(""#"")) {
			 int value = -1;
			 try {
				 if (name.startsWith(""#x"") || name.startsWith(""#X"")) {
					 value = Integer.parseInt(name.substring(2), 16);
				 }
				 else {
					 value = Integer.parseInt(name.substring(1));
				 }
				 if (fFixWindowsCharRefs && fIso8859Encoding) {
					 value = fixWindowsCharacter(value);
				 }
				 if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {
					 fEndLineNumber = fCurrentEntity.getLineNumber();
					 fEndColumnNumber = fCurrentEntity.getColumnNumber();
					 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
					 if (fNotifyCharRefs) {
						 XMLResourceIdentifier id = resourceId();
						 String encoding = null;
						 fDocumentHandler.startGeneralEntity(name, id, encoding, locationAugs());
					 }
					 str.clear();
					 str.append((char)value);
					 fDocumentHandler.characters(str, locationAugs());
					 if (fNotifyCharRefs) {
						 fDocumentHandler.endGeneralEntity(name, locationAugs());
					 }
				 }
			 }
			 catch (NumberFormatException e) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1005"", new Object[]{
					name}
					);
				 }
				 if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {
					 fEndLineNumber = fCurrentEntity.getLineNumber();
					 fEndColumnNumber = fCurrentEntity.getColumnNumber();
					 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
					 fDocumentHandler.characters(str, locationAugs());
				 }
			 }
			 return value;
		 }
		 int c = HTMLEntities.get(name);
		 final boolean invalidEntityInAttribute = !content && !endsWithSemicolon && c > 256;
		 if (c == -1 || invalidEntityInAttribute) {
			 if (fReportErrors) {
				 fErrorReporter.reportWarning(""HTML1006"", new Object[]{
				name}
				);
			 }
			 if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 fDocumentHandler.characters(str, locationAugs());
			 }
			 return -1;
		 }
		 if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {
			 fEndLineNumber = fCurrentEntity.getLineNumber();
			 fEndColumnNumber = fCurrentEntity.getColumnNumber();
			 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
			 boolean notify = fNotifyHtmlBuiltinRefs || (fNotifyXmlBuiltinRefs && builtinXmlRef(name));
			 if (notify) {
				 XMLResourceIdentifier id = resourceId();
				 String encoding = null;
				 fDocumentHandler.startGeneralEntity(name, id, encoding, locationAugs());
			 }
			 str.clear();
			 str.append((char)c);
			 fDocumentHandler.characters(str, locationAugs());
			 if (notify) {
				 fDocumentHandler.endGeneralEntity(name, locationAugs());
			 }
		 }
		 return c;
	 }
	 protected boolean skip(String s, boolean caseSensitive) throws IOException {
		 int length = s != null ? s.length() : 0;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (fCurrentEntity.offset == fCurrentEntity.length) {
				 System.arraycopy(fCurrentEntity.buffer, fCurrentEntity.offset - i, fCurrentEntity.buffer, 0, i);
				 if (fCurrentEntity.load(i) == -1) {
					 fCurrentEntity.offset = 0;
					 return false;
				 }
			 }
			 char c0 = s.charAt(i);
			 char c1 = fCurrentEntity.getNextChar();
			 if (!caseSensitive) {
				 c0 = Character.toUpperCase(c0);
				 c1 = Character.toUpperCase(c1);
			 }
			 if (c0 != c1) {
				 fCurrentEntity.rewind(i + 1);
				 return false;
			 }
		 }
		 return true;
	 }
	 protected boolean skipMarkup(boolean balance) throws IOException {
		 fCurrentEntity.debugBufferIfNeeded(""(skipMarkup: "");
		 int depth = 1;
		 boolean slashgt = false;
		 OUTER: while (true) {
			 if (fCurrentEntity.offset == fCurrentEntity.length) {
				 if (fCurrentEntity.load(0) == -1) {
					 break OUTER;
				 }
			 }
			 while (fCurrentEntity.hasNext()) {
				 char c = fCurrentEntity.getNextChar();
				 if (balance && c == '<') {
					 depth++;
				 }
				 else if (c == '>') {
					 depth--;
					 if (depth == 0) {
						 break OUTER;
					 }
				 }
				 else if (c == '/') {
					 if (fCurrentEntity.offset == fCurrentEntity.length) {
						 if (fCurrentEntity.load(0) == -1) {
							 break OUTER;
						 }
					 }
					 c = fCurrentEntity.getNextChar();
					 if (c == '>') {
						 slashgt = true;
						 depth--;
						 if (depth == 0) {
							 break OUTER;
						 }
					 }
					 else {
						 fCurrentEntity.rewind();
					 }
				 }
				 else if (c == '\r' || c == '\n') {
					 fCurrentEntity.rewind();
					 skipNewlines();
				 }
			 }
		 }
		 fCurrentEntity.debugBufferIfNeeded("")skipMarkup: "", "" -> ""+slashgt);
		 return slashgt;
	 }
	 protected boolean skipSpaces() throws IOException {
		 fCurrentEntity.debugBufferIfNeeded(""(skipSpaces: "");
		 boolean spaces = false;
		 while (true) {
			 if (fCurrentEntity.offset == fCurrentEntity.length) {
				 if (fCurrentEntity.load(0) == -1) {
					 break;
				 }
			 }
			 char c = fCurrentEntity.getNextChar();
			 if (!Character.isWhitespace(c)) {
				 fCurrentEntity.rewind();
				 break;
			 }
			 spaces = true;
			 if (c == '\r' || c == '\n') {
				 fCurrentEntity.rewind();
				 skipNewlines();
				 continue;
			 }
		 }
		 fCurrentEntity.debugBufferIfNeeded("")skipSpaces: "", "" -> "" + spaces);
		 return spaces;
	 }
	 protected int skipNewlines() throws IOException {
		 fCurrentEntity.debugBufferIfNeeded(""(skipNewlines: "");
		 if (!fCurrentEntity.hasNext()) {
			 if (fCurrentEntity.load(0) == -1) {
				 fCurrentEntity.debugBufferIfNeeded("")skipNewlines: "");
				 return 0;
			 }
		 }
		 char c = fCurrentEntity.getCurrentChar();
		 int newlines = 0;
		 int offset = fCurrentEntity.offset;
		 if (c == '\n' || c == '\r') {
			 do {
				 c = fCurrentEntity.getNextChar();
				 if (c == '\r') {
					 newlines++;
					 if (fCurrentEntity.offset == fCurrentEntity.length) {
						 offset = 0;
						 fCurrentEntity.offset = newlines;
						 if (fCurrentEntity.load(newlines) == -1) {
							 break;
						 }
					 }
					 if (fCurrentEntity.getCurrentChar() == '\n') {
						 fCurrentEntity.offset++;
						 fCurrentEntity.characterOffset_++;
						 offset++;
					 }
				 }
				 else if (c == '\n') {
					 newlines++;
					 if (fCurrentEntity.offset == fCurrentEntity.length) {
						 offset = 0;
						 fCurrentEntity.offset = newlines;
						 if (fCurrentEntity.load(newlines) == -1) {
							 break;
						 }
					 }
				 }
				 else {
					 fCurrentEntity.rewind();
					 break;
				 }
			 }
			 while (fCurrentEntity.offset < fCurrentEntity.length - 1);
			 fCurrentEntity.incLine(newlines);
		 }
		 fCurrentEntity.debugBufferIfNeeded("")skipNewlines: "", "" -> "" + newlines);
		 return newlines;
	 }
	 protected final Augmentations locationAugs() {
		 HTMLAugmentations augs = null;
		 if (fAugmentations) {
			 fLocationItem.setValues(fBeginLineNumber, fBeginColumnNumber, fBeginCharacterOffset, fEndLineNumber, fEndColumnNumber, fEndCharacterOffset);
			 augs = fInfosetAugs;
			 augs.removeAllItems();
			 augs.putItem(AUGMENTATIONS, fLocationItem);
		 }
		 return augs;
	 }
	 protected final Augmentations synthesizedAugs() {
		 HTMLAugmentations augs = null;
		 if (fAugmentations) {
			 augs = fInfosetAugs;
			 augs.removeAllItems();
			 augs.putItem(AUGMENTATIONS, SYNTHESIZED_ITEM);
		 }
		 return augs;
	 }
	 protected final XMLResourceIdentifier resourceId() {
		 fResourceId.clear();
		 return fResourceId;
	 }
	 protected static boolean builtinXmlRef(String name) {
		 return name.equals(""amp"") || name.equals(""lt"") || name.equals(""gt"") || name.equals(""quot"") || name.equals(""apos"");
	 }
	 public interface Scanner {
		 public boolean scan(boolean complete) throws IOException;
	 }
	 public static class CurrentEntity {
		 private Reader stream_;
		 public final String encoding;
		 public final String publicId;
		 public final String baseSystemId;
		 public final String literalSystemId;
		 public final String expandedSystemId;
		public final String version = ""1.0"";
		 private int lineNumber_ = 1;
		 private int columnNumber_ = 1;
		 public int characterOffset_ = 0;
		 public char[] buffer = new char[DEFAULT_BUFFER_SIZE];
		 public int offset = 0;
		 public int length = 0;
		 private boolean endReached_ = false;
		 public CurrentEntity(Reader stream, String encoding, String publicId, String baseSystemId, String literalSystemId, String expandedSystemId) {
			 stream_ = stream;
			 this.encoding = encoding;
			 this.publicId = publicId;
			 this.baseSystemId = baseSystemId;
			 this.literalSystemId = literalSystemId;
			 this.expandedSystemId = expandedSystemId;
		 }
		 private char getCurrentChar() {
			 return buffer[offset];
		 }
		 private char getNextChar() {
			 characterOffset_++;
			 columnNumber_++;
			 return buffer[offset++];
		 }
		 private void closeQuietly() {
			 try {
				 stream_.close();
			 }
			 catch (IOException e) {
			 }
		}
		 boolean hasNext() {
			 return offset < length;
		 }
		 protected int load(int offset) throws IOException {
			 debugBufferIfNeeded(""(load: "");
			 if (offset == buffer.length) {
				 int adjust = buffer.length / 4;
				 char[] array = new char[buffer.length + adjust];
				 System.arraycopy(buffer, 0, array, 0, length);
				 buffer = array;
			 }
			 int count = stream_.read(buffer, offset, buffer.length - offset);
			 if (count == -1) {
				 endReached_ = true;
			 }
			 length = count != -1 ? count + offset : offset;
			 this.offset = offset;
			 debugBufferIfNeeded("")load: "", "" -> "" + count);
			 return count;
		 }
		 protected int read() throws IOException {
			 debugBufferIfNeeded(""(read: "");
			 if (offset == length) {
				 if (endReached_) {
					 return -1;
				 }
				 if (load(0) == -1) {
					 if (DEBUG_BUFFER) {
						 System.out.println("")read: -> -1"");
					 }
					 return -1;
				 }
			 }
			 final char c = buffer[offset++];
			 characterOffset_++;
			 columnNumber_++;
			 debugBufferIfNeeded("")read: "", "" -> "" + c);
			 return c;
		 }
		 private void debugBufferIfNeeded(final String prefix) {
			 debugBufferIfNeeded(prefix, """");
		 }
		 private void debugBufferIfNeeded(final String prefix, final String suffix) {
			 if (DEBUG_BUFFER) {
				 System.out.print(prefix);
				 System.out.print('[');
				 System.out.print(length);
				 System.out.print(' ');
				 System.out.print(offset);
				 if (length > 0) {
					 System.out.print("" \"""");
					 for (int i = 0;
					 i < length;
					 i++) {
						 if (i == offset) {
							 System.out.print('^');
						 }
						 char c = buffer[i];
						 switch (c) {
							 case '\r': {
								 System.out.print(""\\r"");
								 break;
							 }
							 case '\n': {
								 System.out.print(""\\n"");
								 break;
							 }
							 case '\t': {
								 System.out.print(""\\t"");
								 break;
							 }
							 case '""': {
								 System.out.print(""\\\"""");
								 break;
							 }
							 default: {
								 System.out.print(c);
							 }
						 }
					 }
					 if (offset == length) {
						 System.out.print('^');
					 }
					 System.out.print('""');
				 }
				 System.out.print(']');
				 System.out.print(suffix);
				 System.out.println();
			 }
		 }
		 private void setStream(final InputStreamReader inputStreamReader) {
			 stream_ = inputStreamReader;
			 offset = length = characterOffset_ = 0;
			 lineNumber_ = columnNumber_ = 1;
		}
		private void rewind() {
			 offset--;
			 characterOffset_--;
			 columnNumber_--;
		}
		 private void rewind(int i) {
			 offset -= i;
			 characterOffset_ -= i;
			 columnNumber_ -= i;
		}
		private void incLine() {
			 lineNumber_++;
			 columnNumber_ = 1;
		}
		private void incLine(int nbLines) {
			 lineNumber_ += nbLines;
			 columnNumber_ = 1;
		}
		public int getLineNumber() {
			return lineNumber_;
		}
		private void resetBuffer(final XMLStringBuffer buffer, final int lineNumber,final int columnNumber, final int characterOffset) {
			 lineNumber_ = lineNumber;
			 columnNumber_ = columnNumber;
			 this.characterOffset_ = characterOffset;
			 this.buffer = buffer.ch;
			 this.offset = buffer.offset;
			 this.length = buffer.length;
		}
		private int getColumnNumber() {
			return columnNumber_;
		}
		private void restorePosition(int originalOffset,int originalColumnNumber, int originalCharacterOffset) {
			 this.offset = originalOffset;
			 this.columnNumber_ = originalColumnNumber;
			 this.characterOffset_ = originalCharacterOffset;
		}
		private int getCharacterOffset() {
			return characterOffset_;
		}
	 }
	 public class ContentScanner implements Scanner {
		 private final QName fQName = new QName();
		 private final XMLAttributesImpl fAttributes = new XMLAttributesImpl();
		 public boolean scan(boolean complete) throws IOException {
			 boolean next;
			 do {
				 try {
					 next = false;
					 switch (fScannerState) {
						 case STATE_CONTENT: {
							 fBeginLineNumber = fCurrentEntity.getLineNumber();
							 fBeginColumnNumber = fCurrentEntity.getColumnNumber();
							 fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();
							 int c = fCurrentEntity.read();
							 if (c == '<') {
								 setScannerState(STATE_MARKUP_BRACKET);
								 next = true;
							 }
							 else if (c == '&') {
								 scanEntityRef(fStringBuffer, true);
							 }
							 else if (c == -1) {
								 throw new EOFException();
							 }
							 else {
								 fCurrentEntity.rewind();
								 scanCharacters();
							 }
							 break;
						 }
						 case STATE_MARKUP_BRACKET: {
							 int c = fCurrentEntity.read();
							 if (c == '!') {
								 if (skip(""--"", false)) {
									 scanComment();
								 }
								 else if (skip(""[CDATA["", false)) {
									 scanCDATA();
								 }
								 else if (skip(""DOCTYPE"", false)) {
									 scanDoctype();
								 }
								 else {
									 if (fReportErrors) {
										 fErrorReporter.reportError(""HTML1002"", null);
									 }
									 skipMarkup(true);
								 }
							 }
							 else if (c == '?') {
								 scanPI();
							 }
							 else if (c == '/') {
								 scanEndElement();
							 }
							 else if (c == -1) {
								 if (fReportErrors) {
									 fErrorReporter.reportError(""HTML1003"", null);
								 }
								 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
									 fStringBuffer.clear();
									 fStringBuffer.append('<');
									 fDocumentHandler.characters(fStringBuffer, null);
								 }
								 throw new EOFException();
							 }
							 else {
								 fCurrentEntity.rewind();
								 fElementCount++;
								 fSingleBoolean[0] = false;
								 final String ename = scanStartElement(fSingleBoolean);
								 fBeginLineNumber = fCurrentEntity.getLineNumber();
								 fBeginColumnNumber = fCurrentEntity.getColumnNumber();
								 fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();
								 if (""script"".equalsIgnoreCase(ename)) {
									 scanScriptContent();
								 }
								 else if (!fParseNoScriptContent && ""noscript"".equalsIgnoreCase(ename)) {
									 scanNoXxxContent(""noscript"");
								 }
								 else if (!fParseNoFramesContent && ""noframes"".equalsIgnoreCase(ename)) {
									 scanNoXxxContent(""noframes"");
								 }
								 else if (ename != null && !fSingleBoolean[0] && HTMLElements.getElement(ename).isSpecial() && (!ename.equalsIgnoreCase(""TITLE"") || isEnded(ename))) {
									 setScanner(fSpecialScanner.setElementName(ename));
									 setScannerState(STATE_CONTENT);
									 return true;
								 }
							 }
							 setScannerState(STATE_CONTENT);
							 break;
						 }
						 case STATE_START_DOCUMENT: {
							 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
								 if (DEBUG_CALLBACKS) {
									 System.out.println(""startDocument()"");
								 }
								 XMLLocator locator = HTMLScanner.this;
								 String encoding = fIANAEncoding;
								 Augmentations augs = locationAugs();
								 NamespaceContext nscontext = new NamespaceSupport();
								 XercesBridge.getInstance().XMLDocumentHandler_startDocument(fDocumentHandler, locator, encoding, nscontext, augs);
							 }
							 if (fInsertDoctype && fDocumentHandler != null) {
								 String root = HTMLElements.getElement(HTMLElements.HTML).name;
								 root = modifyName(root, fNamesElems);
								 String pubid = fDoctypePubid;
								 String sysid = fDoctypeSysid;
								 fDocumentHandler.doctypeDecl(root, pubid, sysid, synthesizedAugs());
							 }
							 setScannerState(STATE_CONTENT);
							 break;
						 }
						 case STATE_END_DOCUMENT: {
							 if (fDocumentHandler != null && fElementCount >= fElementDepth && complete) {
								 if (DEBUG_CALLBACKS) {
									 System.out.println(""endDocument()"");
								 }
								 fEndLineNumber = fCurrentEntity.getLineNumber();
								 fEndColumnNumber = fCurrentEntity.getColumnNumber();
								 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
								 fDocumentHandler.endDocument(locationAugs());
							 }
							 return false;
						 }
						 default: {
							 throw new RuntimeException(""unknown scanner state: ""+fScannerState);
						 }
					 }
				 }
				 catch (EOFException e) {
					 if (fCurrentEntityStack.empty()) {
						 setScannerState(STATE_END_DOCUMENT);
					 }
					 else {
						 fCurrentEntity = (CurrentEntity)fCurrentEntityStack.pop();
					 }
					 next = true;
				 }
			 }
			 while (next || complete);
			 return true;
		 }
		 private void scanNoXxxContent(final String tagName) throws IOException {
			 final XMLStringBuffer buffer = new XMLStringBuffer();
			 final String end = ""/"" + tagName;
			 while (true) {
				 int c = fCurrentEntity.read();
				 if (c == -1) {
					 break;
				 }
				 if (c == '<') {
					 final String next = nextContent(10) + "" "";
					 if (next.length() >= 10 && end.equalsIgnoreCase(next.substring(0, end.length())) && ('>' == next.charAt(9) || Character.isWhitespace(next.charAt(9)))) {
						 fCurrentEntity.rewind();
						 break;
					 }
				 }
				 if (c == '\r' || c == '\n') {
					 fCurrentEntity.rewind();
					 int newlines = skipNewlines();
					 for (int i = 0;
					 i < newlines;
					 i++) {
						 buffer.append('\n');
					 }
				 }
				 else {
					 buffer.append((char)c);
				 }
			 }
			 if (buffer.length > 0 && fDocumentHandler != null) {
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 fDocumentHandler.characters(buffer, locationAugs());
			 }
		 }
		 private void scanScriptContent() throws IOException {
			 final XMLStringBuffer buffer = new XMLStringBuffer();
			 boolean waitForEndComment = false;
			 while (true) {
				 int c = fCurrentEntity.read();
				 if (c == -1) {
					 break;
				 }
				 else if (c == '-' && endsWith(buffer, ""<!-"")) {
					 waitForEndComment = endCommentAvailable();
				 }
				 else if (!waitForEndComment && c == '<') {
					 final String next = nextContent(8) + "" "";
					 if (next.length() >= 8 && ""/script"".equalsIgnoreCase(next.substring(0, 7)) && ('>' == next.charAt(7) || Character.isWhitespace(next.charAt(7)))) {
						 fCurrentEntity.rewind();
						 break;
					 }
				 }
				 else if (c == '>' && endsWith(buffer, ""--"")) {
					 waitForEndComment = false;
				 }
				 if (c == '\r' || c == '\n') {
					 fCurrentEntity.rewind();
					 int newlines = skipNewlines();
					 for (int i = 0;
					 i < newlines;
					 i++) {
						 buffer.append('\n');
					 }
				 }
				 else {
					 buffer.append((char)c);
				 }
			 }
			 if (fScriptStripCommentDelims) {
				 reduceToContent(buffer, ""<!--"", ""-->"");
			 }
			 if (fScriptStripCDATADelims) {
				 reduceToContent(buffer, ""<![CDATA["", ""]]>"");
			 }
			 if (buffer.length > 0 && fDocumentHandler != null && fElementCount >= fElementDepth) {
				 if (DEBUG_CALLBACKS) {
					 System.out.println(""characters(""+buffer+"")"");
				 }
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 fDocumentHandler.characters(buffer, locationAugs());
			 }
		 }
		 protected String nextContent(int len) throws IOException {
			 final int originalOffset = fCurrentEntity.offset;
			 final int originalColumnNumber = fCurrentEntity.getColumnNumber();
			 final int originalCharacterOffset = fCurrentEntity.getCharacterOffset();
			 char[] buff = new char[len];
			 int nbRead = 0;
			 for (nbRead=0;
			 nbRead<len;
			 ++nbRead) {
				 if (fCurrentEntity.offset == fCurrentEntity.length) {
					 if (fCurrentEntity.length == fCurrentEntity.buffer.length) {
						 fCurrentEntity.load(fCurrentEntity.buffer.length);
					 }
					 else {
						 break;
					 }
				 }
				 int c = fCurrentEntity.read();
				 if (c == -1) {
					 break;
				 }
				 else {
					 buff[nbRead] = (char) c;
				 }
			 }
			 fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);
			 return new String(buff, 0, nbRead);
		 }
		 protected void scanCharacters() throws IOException {
			 fCurrentEntity.debugBufferIfNeeded(""(scanCharacters: "");
			 fStringBuffer.clear();
			 while(true) {
				 int newlines = skipNewlines();
				 if (newlines == 0 && fCurrentEntity.offset == fCurrentEntity.length) {
					 fCurrentEntity.debugBufferIfNeeded("")scanCharacters: "");
					 break;
				 }
				 char c;
				 int offset = fCurrentEntity.offset - newlines;
				 for (int i = offset;
				 i < fCurrentEntity.offset;
				 i++) {
					 fCurrentEntity.buffer[i] = '\n';
				 }
				 while (fCurrentEntity.hasNext()) {
					 c = fCurrentEntity.getNextChar();
					 if (c == '<' || c == '&' || c == '\n' || c == '\r') {
						 fCurrentEntity.rewind();
						 break;
					 }
				 }
				 if (fCurrentEntity.offset > offset && fDocumentHandler != null && fElementCount >= fElementDepth) {
					 if (DEBUG_CALLBACKS) {
						 final XMLString xmlString = new XMLString(fCurrentEntity.buffer, offset, fCurrentEntity.offset - offset);
						 System.out.println(""characters("" + xmlString + "")"");
					 }
					 fEndLineNumber = fCurrentEntity.getLineNumber();
					 fEndColumnNumber = fCurrentEntity.getColumnNumber();
					 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
					 fStringBuffer.append(fCurrentEntity.buffer, offset, fCurrentEntity.offset - offset);
				 }
				 fCurrentEntity.debugBufferIfNeeded("")scanCharacters: "");
				 boolean hasNext = fCurrentEntity.offset < fCurrentEntity.buffer.length;
				 int next = hasNext ? fCurrentEntity.getCurrentChar() : -1;
				 if(next == '&' || next == '<' || next == -1) {
					 break;
				 }
			 }
			 if(fStringBuffer.length != 0) {
				 fDocumentHandler.characters(fStringBuffer, locationAugs());
			 }
		 }
		 protected void scanCDATA() throws IOException {
			 fCurrentEntity.debugBufferIfNeeded(""(scanCDATA: "");
			 fStringBuffer.clear();
			 if (fCDATASections) {
				 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
					 fEndLineNumber = fCurrentEntity.getLineNumber();
					 fEndColumnNumber = fCurrentEntity.getColumnNumber();
					 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
					 if (DEBUG_CALLBACKS) {
						 System.out.println(""startCDATA()"");
					 }
					 fDocumentHandler.startCDATA(locationAugs());
				 }
			 }
			 else {
				 fStringBuffer.append(""[CDATA["");
			 }
			 boolean eof = scanMarkupContent(fStringBuffer, ']');
			 if (!fCDATASections) {
				 fStringBuffer.append(""]]"");
			 }
			 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 if (fCDATASections) {
					 if (DEBUG_CALLBACKS) {
						 System.out.println(""characters(""+fStringBuffer+"")"");
					 }
					 fDocumentHandler.characters(fStringBuffer, locationAugs());
					 if (DEBUG_CALLBACKS) {
						 System.out.println(""endCDATA()"");
					 }
					 fDocumentHandler.endCDATA(locationAugs());
				 }
				 else {
					 if (DEBUG_CALLBACKS) {
						 System.out.println(""comment(""+fStringBuffer+"")"");
					 }
					 fDocumentHandler.comment(fStringBuffer, locationAugs());
				 }
			 }
			 fCurrentEntity.debugBufferIfNeeded("")scanCDATA: "");
			 if (eof) {
				 throw new EOFException();
			 }
		 }
		 protected void scanComment() throws IOException {
			 fCurrentEntity.debugBufferIfNeeded(""(scanComment: "");
			 fEndLineNumber = fCurrentEntity.getLineNumber();
			 fEndColumnNumber = fCurrentEntity.getColumnNumber();
			 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
			 XMLStringBuffer buffer = new XMLStringBuffer();
			 boolean eof = scanMarkupContent(buffer, '-');
			 if (eof) {
				 fCurrentEntity.resetBuffer(buffer, fEndLineNumber, fEndColumnNumber, fEndCharacterOffset);
				 buffer = new XMLStringBuffer();
				 while (true) {
					 int c = fCurrentEntity.read();
					 if (c == -1) {
						 if (fReportErrors) {
							 fErrorReporter.reportError(""HTML1007"", null);
						 }
						 eof = true;
						 break;
					 }
					 else if (c != '>') {
						 buffer.append((char)c);
						 continue;
					 }
					 else if (c == '\n' || c == '\r') {
						 fCurrentEntity.rewind();
						 int newlines = skipNewlines();
						 for (int i = 0;
						 i < newlines;
						 i++) {
							 buffer.append('\n');
						 }
						 continue;
					 }
					 eof = false;
					 break;
				 }
			 }
			 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
				 if (DEBUG_CALLBACKS) {
					 System.out.println(""comment("" + buffer + "")"");
				 }
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 fDocumentHandler.comment(buffer, locationAugs());
			 }
			 fCurrentEntity.debugBufferIfNeeded("")scanComment: "");
			 if (eof) {
				 throw new EOFException();
			 }
		 }
		 protected boolean scanMarkupContent(XMLStringBuffer buffer, char cend) throws IOException {
			 int c = -1;
			 OUTER: while (true) {
				 c = fCurrentEntity.read();
				 if (c == cend) {
					 int count = 1;
					 while (true) {
						 c = fCurrentEntity.read();
						 if (c == cend) {
							 count++;
							 continue;
						 }
						 break;
					 }
					 if (c == -1) {
						 if (fReportErrors) {
							 fErrorReporter.reportError(""HTML1007"", null);
						 }
						 break OUTER;
					 }
					 if (count < 2) {
						 buffer.append(cend);
						 fCurrentEntity.rewind();
						 continue;
					 }
					 if (c != '>') {
						 for (int i = 0;
						 i < count;
						 i++) {
							 buffer.append(cend);
						 }
						 fCurrentEntity.rewind();
						 continue;
					 }
					 for (int i = 0;
					 i < count - 2;
					 i++) {
						 buffer.append(cend);
					 }
					 break;
				 }
				 else if (c == '\n' || c == '\r') {
					 fCurrentEntity.rewind();
					 int newlines = skipNewlines();
					 for (int i = 0;
					 i < newlines;
					 i++) {
						 buffer.append('\n');
					 }
					 continue;
				 }
				 else if (c == -1) {
					 if (fReportErrors) {
						 fErrorReporter.reportError(""HTML1007"", null);
					 }
					 break;
				 }
				 buffer.append((char)c);
			 }
			 return c == -1;
		 }
		 protected void scanPI() throws IOException {
			 fCurrentEntity.debugBufferIfNeeded(""(scanPI: "");
			 if (fReportErrors) {
				 fErrorReporter.reportWarning(""HTML1008"", null);
			 }
			 String target = scanName();
			 if (target != null && !target.equalsIgnoreCase(""xml"")) {
				 while (true) {
					 int c = fCurrentEntity.read();
					 if (c == '\r' || c == '\n') {
						 if (c == '\r') {
							 c = fCurrentEntity.read();
							 if (c != '\n') {
								 fCurrentEntity.offset--;
								 fCurrentEntity.characterOffset_--;
							 }
						 }
						 fCurrentEntity.incLine();
						 continue;
					 }
					 if (c == -1) {
						 break;
					 }
					 if (c != ' ' && c != '\t') {
						 fCurrentEntity.rewind();
						 break;
					 }
				 }
				 fStringBuffer.clear();
				 while (true) {
					 int c = fCurrentEntity.read();
					 if (c == '?' || c == '/') {
						 char c0 = (char)c;
						 c = fCurrentEntity.read();
						 if (c == '>') {
							 break;
						 }
						 else {
							 fStringBuffer.append(c0);
							 fCurrentEntity.rewind();
							 continue;
						 }
					 }
					 else if (c == '\r' || c == '\n') {
						 fStringBuffer.append('\n');
						 if (c == '\r') {
							 c = fCurrentEntity.read();
							 if (c != '\n') {
								 fCurrentEntity.offset--;
								 fCurrentEntity.characterOffset_--;
							 }
						 }
						 fCurrentEntity.incLine();
						 continue;
					 }
					 else if (c == -1) {
						 break;
					 }
					 else {
						 fStringBuffer.append((char)c);
					 }
				 }
				 XMLString data = fStringBuffer;
				 if (fDocumentHandler != null) {
					 fEndLineNumber = fCurrentEntity.getLineNumber();
					 fEndColumnNumber = fCurrentEntity.getColumnNumber();
					 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
					 fDocumentHandler.processingInstruction(target, data, locationAugs());
				 }
			 }
			 else {
				 int beginLineNumber = fBeginLineNumber;
				 int beginColumnNumber = fBeginColumnNumber;
				 int beginCharacterOffset = fBeginCharacterOffset;
				 fAttributes.removeAllAttributes();
				 int aindex = 0;
				 while (scanPseudoAttribute(fAttributes)) {
					 if (fAttributes.getValue(aindex).length() == 0) {
						 fAttributes.removeAttributeAt(aindex);
					 }
					 else {
						 fAttributes.getName(aindex,fQName);
						 fQName.rawname = fQName.rawname.toLowerCase();
						 fAttributes.setName(aindex,fQName);
						 aindex++;
					 }
				 }
				 if (fDocumentHandler != null) {
					 String version = fAttributes.getValue(""version"");
					 String encoding = fAttributes.getValue(""encoding"");
					 String standalone = fAttributes.getValue(""standalone"");
					 final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);
					 if (xmlDeclNow) {
						 fBeginLineNumber = beginLineNumber;
						 fBeginColumnNumber = beginColumnNumber;
						 fBeginCharacterOffset = beginCharacterOffset;
						 fEndLineNumber = fCurrentEntity.getLineNumber();
						 fEndColumnNumber = fCurrentEntity.getColumnNumber();
						 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
						 fDocumentHandler.xmlDecl(version, encoding, standalone, locationAugs());
					 }
				 }
			 }
			 fCurrentEntity.debugBufferIfNeeded("")scanPI: "");
		 }
		 protected String scanStartElement(boolean[] empty) throws IOException {
			 String ename = scanName();
			 int length = ename != null ? ename.length() : 0;
			 int c = length > 0 ? ename.charAt(0) : -1;
			 if (length == 0 || !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1009"", null);
				 }
				 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
					 fStringBuffer.clear();
					 fStringBuffer.append('<');
					 if (length > 0) {
						 fStringBuffer.append(ename);
					 }
					 fDocumentHandler.characters(fStringBuffer, null);
				 }
				 return null;
			 }
			 ename = modifyName(ename, fNamesElems);
			 fAttributes.removeAllAttributes();
			 int beginLineNumber = fBeginLineNumber;
			 int beginColumnNumber = fBeginColumnNumber;
			 int beginCharacterOffset = fBeginCharacterOffset;
			 while (scanAttribute(fAttributes, empty)) {
			 }
			 fBeginLineNumber = beginLineNumber;
			 fBeginColumnNumber = beginColumnNumber;
			 fBeginCharacterOffset = beginCharacterOffset;
			 if (fByteStream != null && fElementDepth == -1) {
				 if (ename.equalsIgnoreCase(""META"")) {
					 if (DEBUG_CHARSET) {
						 System.out.println(""+++ <META>"");
					 }
					 String httpEquiv = getValue(fAttributes, ""http-equiv"");
					 if (httpEquiv != null && httpEquiv.equalsIgnoreCase(""content-type"")) {
						 if (DEBUG_CHARSET) {
							 System.out.println(""+++ -type: \""""+httpEquiv+'""');
						 }
						 String content = getValue(fAttributes, ""content"");
						 if (content != null) {
							 content = removeSpaces(content);
							 int index1 = content.toLowerCase().indexOf(""charset="");
							 if (index1 != -1 && !fIgnoreSpecifiedCharset) {
								 final int index2 = content.indexOf(';
								', index1);
								 final String charset = index2 != -1 ? content.substring(index1+8, index2) : content.substring(index1+8);
								 changeEncoding(charset);
							 }
						 }
					 }
				 }
				 else if (ename.equalsIgnoreCase(""BODY"")) {
					 fByteStream.clear();
					 fByteStream = null;
				 }
				 else {
					 HTMLElements.Element element = HTMLElements.getElement(ename);
					 if (element.parent != null && element.parent.length > 0) {
						 if (element.parent[0].code == HTMLElements.BODY) {
							 fByteStream.clear();
							 fByteStream = null;
						 }
					 }
				 }
			 }
			 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
				 fQName.setValues(null, ename, ename, null);
				 if (DEBUG_CALLBACKS) {
					 System.out.println(""startElement(""+fQName+','+fAttributes+"")"");
				 }
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 if (empty[0]) {
					 fDocumentHandler.emptyElement(fQName, fAttributes, locationAugs());
				 }
				 else {
					 fDocumentHandler.startElement(fQName, fAttributes, locationAugs());
				 }
			 }
			 return ename;
		 }
		 private String removeSpaces(final String content) {
			 StringBuffer sb = null;
			 for (int i=content.length()-1;
			 i>=0;
			 --i) {
				 if (Character.isWhitespace(content.charAt(i))) {
					 if (sb == null) {
						 sb = new StringBuffer(content);
					 }
					 sb.deleteCharAt(i);
				 }
			 }
			return (sb == null) ? content : sb.toString();
		}
		private boolean changeEncoding(String charset) {
			if (charset == null || fByteStream == null) {
				return false;
			}
			charset = charset.trim();
			boolean encodingChanged = false;
			try {
				 String ianaEncoding = charset;
				 String javaEncoding = EncodingMap.getIANA2JavaMapping(ianaEncoding.toUpperCase());
				 if (DEBUG_CHARSET) {
					 System.out.println(""+++ ianaEncoding: ""+ianaEncoding);
					 System.out.println(""+++ javaEncoding: ""+javaEncoding);
				 }
				 if (javaEncoding == null) {
					 javaEncoding = ianaEncoding;
					 if (fReportErrors) {
						 fErrorReporter.reportError(""HTML1001"", new Object[]{
						ianaEncoding}
						);
					 }
				 }
				 if (!javaEncoding.equals(fJavaEncoding)) {
					 if (!isEncodingCompatible(javaEncoding, fJavaEncoding)) {
						 if (fReportErrors) {
							 fErrorReporter.reportError(""HTML1015"", new Object[]{
							javaEncoding,fJavaEncoding}
							);
						 }
					 }
					 else {
						 fIso8859Encoding = ianaEncoding == null || ianaEncoding.toUpperCase().startsWith(""ISO-8859"") || ianaEncoding.equalsIgnoreCase(fDefaultIANAEncoding);
						 fJavaEncoding = javaEncoding;
						 fCurrentEntity.setStream(new InputStreamReader(fByteStream, javaEncoding));
						 fByteStream.playback();
						 fElementDepth = fElementCount;
						 fElementCount = 0;
						 encodingChanged = true;
					 }
				 }
			}
			catch (UnsupportedEncodingException e) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1010"", new Object[]{
					charset}
					);
				 }
				 fByteStream.clear();
				 fByteStream = null;
			}
			return encodingChanged;
		}
		 protected boolean scanAttribute(XMLAttributesImpl attributes, boolean[] empty) throws IOException {
			 return scanAttribute(attributes,empty,'/');
		 }
		 protected boolean scanPseudoAttribute(XMLAttributesImpl attributes) throws IOException {
			 return scanAttribute(attributes,fSingleBoolean,'?');
		 }
		 protected boolean scanAttribute(XMLAttributesImpl attributes, boolean[] empty, char endc) throws IOException {
			 boolean skippedSpaces = skipSpaces();
			 fBeginLineNumber = fCurrentEntity.getLineNumber();
			 fBeginColumnNumber = fCurrentEntity.getColumnNumber();
			 fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();
			 int c = fCurrentEntity.read();
			 if (c == -1) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1007"", null);
				 }
				 return false;
			 }
			 else if (c == '>') {
				 return false;
			 }
			 else if (c == '<') {
				 fCurrentEntity.rewind();
				 return false;
			 }
			 fCurrentEntity.rewind();
			 String aname = scanName();
			 if (aname == null) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1011"", null);
				 }
				 empty[0] = skipMarkup(false);
				 return false;
			 }
			 if (!skippedSpaces && fReportErrors) {
				 fErrorReporter.reportError(""HTML1013"", new Object[] {
				 aname }
				);
			 }
			 aname = modifyName(aname, fNamesAttrs);
			 skipSpaces();
			 c = fCurrentEntity.read();
			 if (c == -1) {
				 if (fReportErrors) {
					 fErrorReporter.reportError(""HTML1007"", null);
				 }
				 throw new EOFException();
			 }
			 if (c == '/' || c == '>') {
				 fQName.setValues(null, aname, aname, null);
				 attributes.addAttribute(fQName, ""CDATA"", """");
				 attributes.setSpecified(attributes.getLength()-1, true);
				 if (fAugmentations) {
					 addLocationItem(attributes, attributes.getLength() - 1);
				 }
				 if (c == '/') {
					 fCurrentEntity.rewind();
					 empty[0] = skipMarkup(false);
				 }
				 return false;
			 }
			 if (c == '=') {
				 skipSpaces();
				 c = fCurrentEntity.read();
				 if (c == -1) {
					 if (fReportErrors) {
						 fErrorReporter.reportError(""HTML1007"", null);
					 }
					 throw new EOFException();
				 }
				 if (c == '>') {
					 fQName.setValues(null, aname, aname, null);
					 attributes.addAttribute(fQName, ""CDATA"", """");
					 attributes.setSpecified(attributes.getLength()-1, true);
					 if (fAugmentations) {
						 addLocationItem(attributes, attributes.getLength() - 1);
					 }
					 return false;
				 }
				 fStringBuffer.clear();
				 fNonNormAttr.clear();
				 if (c != '\'' && c != '""') {
					 fCurrentEntity.rewind();
					 while (true) {
						 c = fCurrentEntity.read();
						 if (Character.isWhitespace((char)c) || c == '>') {
							 fCurrentEntity.rewind();
							 break;
						 }
						 if (c == -1) {
							 if (fReportErrors) {
								 fErrorReporter.reportError(""HTML1007"", null);
							 }
							 throw new EOFException();
						 }
						 if (c == '&') {
							 int ce = scanEntityRef(fStringBuffer2, false);
							 if (ce != -1) {
								 fStringBuffer.append((char)ce);
							 }
							 else {
								 fStringBuffer.append(fStringBuffer2);
							 }
							 fNonNormAttr.append(fStringBuffer2);
						 }
						 else {
							 fStringBuffer.append((char)c);
							 fNonNormAttr.append((char)c);
						 }
					 }
					 fQName.setValues(null, aname, aname, null);
					 String avalue = fStringBuffer.toString();
					 attributes.addAttribute(fQName, ""CDATA"", avalue);
					 int lastattr = attributes.getLength()-1;
					 attributes.setSpecified(lastattr, true);
					 attributes.setNonNormalizedValue(lastattr, fNonNormAttr.toString());
					 if (fAugmentations) {
						 addLocationItem(attributes, attributes.getLength() - 1);
					 }
					 return true;
				 }
				 char quote = (char)c;
				 boolean isStart = true;
				 boolean prevSpace = false;
				 do {
					 boolean acceptSpace = !fNormalizeAttributes || (!isStart && !prevSpace);
					 c = fCurrentEntity.read();
					 if (c == -1) {
						 if (fReportErrors) {
							 fErrorReporter.reportError(""HTML1007"", null);
						 }
						 break;
					 }
					 if (c == '&') {
						 isStart = false;
						 int ce = scanEntityRef(fStringBuffer2, false);
						 if (ce != -1) {
							 fStringBuffer.append((char)ce);
						 }
						 else {
							 fStringBuffer.append(fStringBuffer2);
						 }
						 fNonNormAttr.append(fStringBuffer2);
					 }
					 else if (c == ' ' || c == '\t') {
						 if (acceptSpace) {
							 fStringBuffer.append(fNormalizeAttributes ? ' ' : (char)c);
						 }
						 fNonNormAttr.append((char)c);
					 }
					 else if (c == '\r' || c == '\n') {
						 if (c == '\r') {
							 int c2 = fCurrentEntity.read();
							 if (c2 != '\n') {
								 fCurrentEntity.rewind();
							 }
							 else {
								 fNonNormAttr.append('\r');
								 c = c2;
							 }
						 }
						 if (acceptSpace) {
							 fStringBuffer.append(fNormalizeAttributes ? ' ' : '\n');
						 }
						 fCurrentEntity.incLine();
						 fNonNormAttr.append((char)c);
					 }
					 else if (c != quote) {
						 isStart = false;
						 fStringBuffer.append((char)c);
						 fNonNormAttr.append((char)c);
					 }
					 prevSpace = c == ' ' || c == '\t' || c == '\r' || c == '\n';
					 isStart = isStart && prevSpace;
				 }
				 while (c != quote);
				 if (fNormalizeAttributes && fStringBuffer.length > 0) {
					 if (fStringBuffer.ch[fStringBuffer.length - 1] == ' ') {
						 fStringBuffer.length--;
					 }
				 }
				 fQName.setValues(null, aname, aname, null);
				 String avalue = fStringBuffer.toString();
				 attributes.addAttribute(fQName, ""CDATA"", avalue);
				 int lastattr = attributes.getLength()-1;
				 attributes.setSpecified(lastattr, true);
				 attributes.setNonNormalizedValue(lastattr, fNonNormAttr.toString());
				 if (fAugmentations) {
					 addLocationItem(attributes, attributes.getLength() - 1);
				 }
			 }
			 else {
				 fQName.setValues(null, aname, aname, null);
				 attributes.addAttribute(fQName, ""CDATA"", """");
				 attributes.setSpecified(attributes.getLength()-1, true);
				 fCurrentEntity.rewind();
				 if (fAugmentations) {
					 addLocationItem(attributes, attributes.getLength() - 1);
				 }
			 }
			 return true;
		 }
		 protected void addLocationItem(XMLAttributes attributes, int index) {
			 fEndLineNumber = fCurrentEntity.getLineNumber();
			 fEndColumnNumber = fCurrentEntity.getColumnNumber();
			 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
			 LocationItem locationItem = new LocationItem();
			 locationItem.setValues(fBeginLineNumber, fBeginColumnNumber, fBeginCharacterOffset, fEndLineNumber, fEndColumnNumber, fEndCharacterOffset);
			 Augmentations augs = attributes.getAugmentations(index);
			 augs.putItem(AUGMENTATIONS, locationItem);
		 }
		 protected void scanEndElement() throws IOException {
			 String ename = scanName();
			 if (fReportErrors && ename == null) {
				 fErrorReporter.reportError(""HTML1012"", null);
			 }
			 skipMarkup(false);
			 if (ename != null) {
				 ename = modifyName(ename, fNamesElems);
				 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
					 fQName.setValues(null, ename, ename, null);
					 if (DEBUG_CALLBACKS) {
						 System.out.println(""endElement(""+fQName+"")"");
					 }
					 fEndLineNumber = fCurrentEntity.getLineNumber();
					 fEndColumnNumber = fCurrentEntity.getColumnNumber();
					 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
					 fDocumentHandler.endElement(fQName, locationAugs());
				 }
			 }
		 }
		 private boolean isEnded(String ename) {
			 String content = new String(fCurrentEntity.buffer, fCurrentEntity.offset, fCurrentEntity.length - fCurrentEntity.offset);
			 return content.toLowerCase().indexOf(""</"" + ename.toLowerCase() + "">"") != -1;
		 }
	 }
	 public class SpecialScanner implements Scanner {
		 protected String fElementName;
		 protected boolean fStyle;
		 protected boolean fTextarea;
		 protected boolean fTitle;
		 private final QName fQName = new QName();
		 private final XMLStringBuffer fStringBuffer = new XMLStringBuffer();
		 public Scanner setElementName(String ename) {
			 fElementName = ename;
			 fStyle = fElementName.equalsIgnoreCase(""STYLE"");
			 fTextarea = fElementName.equalsIgnoreCase(""TEXTAREA"");
			 fTitle = fElementName.equalsIgnoreCase(""TITLE"");
			 return this;
		 }
		 public boolean scan(boolean complete) throws IOException {
			 boolean next;
			 do {
				 try {
					 next = false;
					 switch (fScannerState) {
						 case STATE_CONTENT: {
							 fBeginLineNumber = fCurrentEntity.getLineNumber();
							 fBeginColumnNumber = fCurrentEntity.getColumnNumber();
							 fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();
							 int c = fCurrentEntity.read();
							 if (c == '<') {
								 setScannerState(STATE_MARKUP_BRACKET);
								 continue;
							 }
							 if (c == '&') {
								 if (fTextarea || fTitle) {
									 scanEntityRef(fStringBuffer, true);
									 continue;
								 }
								 fStringBuffer.clear();
								 fStringBuffer.append('&');
							 }
							 else if (c == -1) {
								 if (fReportErrors) {
									 fErrorReporter.reportError(""HTML1007"", null);
								 }
								 throw new EOFException();
							 }
							 else {
								 fCurrentEntity.rewind();
								 fStringBuffer.clear();
							 }
							 scanCharacters(fStringBuffer, -1);
							 break;
						 }
						 case STATE_MARKUP_BRACKET: {
							 int delimiter = -1;
							 int c = fCurrentEntity.read();
							 if (c == '/') {
								 String ename = scanName();
								 if (ename != null) {
									 if (ename.equalsIgnoreCase(fElementName)) {
										 if (fCurrentEntity.read() == '>') {
											 ename = modifyName(ename, fNamesElems);
											 if (fDocumentHandler != null && fElementCount >= fElementDepth) {
												 fQName.setValues(null, ename, ename, null);
												 if (DEBUG_CALLBACKS) {
													 System.out.println(""endElement(""+fQName+"")"");
												 }
												 fEndLineNumber = fCurrentEntity.getLineNumber();
												 fEndColumnNumber = fCurrentEntity.getColumnNumber();
												 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
												 fDocumentHandler.endElement(fQName, locationAugs());
											 }
											 setScanner(fContentScanner);
											 setScannerState(STATE_CONTENT);
											 return true;
										 }
										 else {
											 fCurrentEntity.rewind();
										 }
									 }
									 fStringBuffer.clear();
									 fStringBuffer.append(""</"");
									 fStringBuffer.append(ename);
								 }
								 else {
									 fStringBuffer.clear();
									 fStringBuffer.append(""</"");
								 }
							 }
							 else {
								 fStringBuffer.clear();
								 fStringBuffer.append('<');
								 fStringBuffer.append((char)c);
							 }
							 scanCharacters(fStringBuffer, delimiter);
							 setScannerState(STATE_CONTENT);
							 break;
						 }
					 }
				 }
				 catch (EOFException e) {
					 setScanner(fContentScanner);
					 if (fCurrentEntityStack.empty()) {
						 setScannerState(STATE_END_DOCUMENT);
					 }
					 else {
						 fCurrentEntity = (CurrentEntity)fCurrentEntityStack.pop();
						 setScannerState(STATE_CONTENT);
					 }
					 return true;
				 }
			 }
			 while (next || complete);
			 return true;
		 }
		 protected void scanCharacters(XMLStringBuffer buffer, int delimiter) throws IOException {
			 fCurrentEntity.debugBufferIfNeeded(""(scanCharacters, delimiter=""+delimiter+"": "");
			 while (true) {
				 int c = fCurrentEntity.read();
				 if (c == -1 || (c == '<' || c == '&')) {
					 if (c != -1) {
						 fCurrentEntity.rewind();
					 }
					 break;
				 }
				 else if (c == '\r' || c == '\n') {
					 fCurrentEntity.rewind();
					 int newlines = skipNewlines();
					 for (int i = 0;
					 i < newlines;
					 i++) {
						 buffer.append('\n');
					 }
				 }
				 else {
					 buffer.append((char)c);
					 if (c == '\n') {
						 fCurrentEntity.incLine();
					 }
				 }
			 }
			 if (fStyle) {
				 if (fStyleStripCommentDelims) {
					 reduceToContent(buffer, ""<!--"", ""-->"");
				 }
				 if (fStyleStripCDATADelims) {
					 reduceToContent(buffer, ""<![CDATA["", ""]]>"");
				 }
			 }
			 if (buffer.length > 0 && fDocumentHandler != null && fElementCount >= fElementDepth) {
				 if (DEBUG_CALLBACKS) {
					 System.out.println(""characters(""+buffer+"")"");
				 }
				 fEndLineNumber = fCurrentEntity.getLineNumber();
				 fEndColumnNumber = fCurrentEntity.getColumnNumber();
				 fEndCharacterOffset = fCurrentEntity.getCharacterOffset();
				 fDocumentHandler.characters(buffer, locationAugs());
			 }
			 fCurrentEntity.debugBufferIfNeeded("")scanCharacters: "");
		 }
	 }
	 public static class PlaybackInputStream extends FilterInputStream {
		 private static final boolean DEBUG_PLAYBACK = false;
		 protected boolean fPlayback = false;
		 protected boolean fCleared = false;
		 protected boolean fDetected = false;
		 protected byte[] fByteBuffer = new byte[1024];
		 protected int fByteOffset = 0;
		 protected int fByteLength = 0;
		 public int fPushbackOffset = 0;
		 public int fPushbackLength = 0;
		 public PlaybackInputStream(InputStream in) {
			 super(in);
		 }
		 public void detectEncoding(String[] encodings) throws IOException {
			 if (fDetected) {
				 throw new IOException(""Should not detect encoding twice."");
			 }
			 fDetected = true;
			 int b1 = read();
			 if (b1 == -1) {
				 return;
			 }
			 int b2 = read();
			 if (b2 == -1) {
				 fPushbackLength = 1;
				 return;
			 }
			 if (b1 == 0xEF && b2 == 0xBB) {
				 int b3 = read();
				 if (b3 == 0xBF) {
					 fPushbackOffset = 3;
					 encodings[0] = ""UTF-8"";
					 encodings[1] = ""UTF8"";
					 return;
				 }
				 fPushbackLength = 3;
			 }
			 if (b1 == 0xFF && b2 == 0xFE) {
				 encodings[0] = ""UTF-16"";
				 encodings[1] = ""UnicodeLittleUnmarked"";
				 return;
			 }
			 else if (b1 == 0xFE && b2 == 0xFF) {
				 encodings[0] = ""UTF-16"";
				 encodings[1] = ""UnicodeBigUnmarked"";
				 return;
			 }
			 fPushbackLength = 2;
		 }
		 public void playback() {
			 fPlayback = true;
		 }
		 public void clear() {
			 if (!fPlayback) {
				 fCleared = true;
				 fByteBuffer = null;
			 }
		 }
		 public int read() throws IOException {
			 if (DEBUG_PLAYBACK) {
				 System.out.println(""(read"");
			 }
			 if (fPushbackOffset < fPushbackLength) {
				 return fByteBuffer[fPushbackOffset++];
			 }
			 if (fCleared) {
				 return in.read();
			 }
			 if (fPlayback) {
				 int c = fByteBuffer[fByteOffset++];
				 if (fByteOffset == fByteLength) {
					 fCleared = true;
					 fByteBuffer = null;
				 }
				 if (DEBUG_PLAYBACK) {
					 System.out.println("")read -> ""+(char)c);
				 }
				 return c;
			 }
			 int c = in.read();
			 if (c != -1) {
				 if (fByteLength == fByteBuffer.length) {
					 byte[] newarray = new byte[fByteLength + 1024];
					 System.arraycopy(fByteBuffer, 0, newarray, 0, fByteLength);
					 fByteBuffer = newarray;
				 }
				 fByteBuffer[fByteLength++] = (byte)c;
			 }
			 if (DEBUG_PLAYBACK) {
				 System.out.println("")read -> ""+(char)c);
			 }
			 return c;
		 }
		 public int read(byte[] array) throws IOException {
			 return read(array, 0, array.length);
		 }
		 public int read(byte[] array, int offset, int length) throws IOException {
			 if (DEBUG_PLAYBACK) {
				 System.out.println("")read(""+offset+','+length+')');
			 }
			 if (fPushbackOffset < fPushbackLength) {
				 int count = fPushbackLength - fPushbackOffset;
				 if (count > length) {
					 count = length;
				 }
				 System.arraycopy(fByteBuffer, fPushbackOffset, array, offset, count);
				 fPushbackOffset += count;
				 return count;
			 }
			 if (fCleared) {
				 return in.read(array, offset, length);
			 }
			 if (fPlayback) {
				 if (fByteOffset + length > fByteLength) {
					 length = fByteLength - fByteOffset;
				 }
				 System.arraycopy(fByteBuffer, fByteOffset, array, offset, length);
				 fByteOffset += length;
				 if (fByteOffset == fByteLength) {
					 fCleared = true;
					 fByteBuffer = null;
				 }
				 return length;
			 }
			 int count = in.read(array, offset, length);
			 if (count != -1) {
				 if (fByteLength + count > fByteBuffer.length) {
					 byte[] newarray = new byte[fByteLength + count + 512];
					 System.arraycopy(fByteBuffer, 0, newarray, 0, fByteLength);
					 fByteBuffer = newarray;
				 }
				 System.arraycopy(array, offset, fByteBuffer, fByteLength, count);
				 fByteLength += count;
			 }
			 if (DEBUG_PLAYBACK) {
				 System.out.println("")read(""+offset+','+length+"") -> ""+count);
			 }
			 return count;
		 }
	 }
	 protected static class LocationItem implements HTMLEventInfo, Cloneable {
		 protected int fBeginLineNumber;
		 protected int fBeginColumnNumber;
		 protected int fBeginCharacterOffset;
		 protected int fEndLineNumber;
		 protected int fEndColumnNumber;
		 protected int fEndCharacterOffset;
		 public LocationItem() {
		 }
		 LocationItem(final LocationItem other) {
			setValues(other.fBeginLineNumber, other.fBeginColumnNumber, other.fBeginCharacterOffset,other.fEndLineNumber, other.fEndColumnNumber, other.fEndCharacterOffset);
		}
		 public void setValues(int beginLine, int beginColumn, int beginOffset, int endLine, int endColumn, int endOffset) {
			 fBeginLineNumber = beginLine;
			 fBeginColumnNumber = beginColumn;
			 fBeginCharacterOffset = beginOffset;
			 fEndLineNumber = endLine;
			 fEndColumnNumber = endColumn;
			 fEndCharacterOffset = endOffset;
		 }
		 public int getBeginLineNumber() {
			 return fBeginLineNumber;
		 }
		 public int getBeginColumnNumber() {
			 return fBeginColumnNumber;
		 }
		 public int getBeginCharacterOffset() {
			 return fBeginCharacterOffset;
		 }
		 public int getEndLineNumber() {
			 return fEndLineNumber;
		 }
		 public int getEndColumnNumber() {
			 return fEndColumnNumber;
		 }
		 public int getEndCharacterOffset() {
			 return fEndCharacterOffset;
		 }
		 public boolean isSynthesized() {
			 return false;
		 }
		 public String toString() {
			 StringBuffer str = new StringBuffer();
			 str.append(fBeginLineNumber);
			 str.append(':');
			 str.append(fBeginColumnNumber);
			 str.append(':');
			 str.append(fBeginCharacterOffset);
			 str.append(':');
			 str.append(fEndLineNumber);
			 str.append(':');
			 str.append(fEndColumnNumber);
			 str.append(':');
			 str.append(fEndCharacterOffset);
			 return str.toString();
		 }
	 }
	 boolean isEncodingCompatible(final String encoding1, final String encoding2) {
		final String reference = ""<html><head><meta http-equiv=\""Content-Type\"" content=\""text/html;
		charset="";
		try {
			final byte[] bytesEncoding1 = reference.getBytes(encoding1);
			final String referenceWithEncoding2 = new String(bytesEncoding1, encoding2);
			return reference.equals(referenceWithEncoding2);
		}
		catch (final UnsupportedEncodingException e) {
			return false;
		}
	 }
	 private boolean endsWith(final XMLStringBuffer buffer, final String string) {
		final int l = string.length();
		if (buffer.length < l) {
			return false;
		}
		else {
			final String s = new String(buffer.ch, buffer.length-l, l);
			return string.equals(s);
		}
	}
	 protected int readPreservingBufferContent() throws IOException {
		 fCurrentEntity.debugBufferIfNeeded(""(read: "");
		 if (fCurrentEntity.offset == fCurrentEntity.length) {
			 if (fCurrentEntity.load(fCurrentEntity.length) < 1) {
				 if (DEBUG_BUFFER) {
					 System.out.println("")read: -> -1"");
				 }
				 return -1;
			 }
		 }
		 final char c = fCurrentEntity.getNextChar();
		 fCurrentEntity.debugBufferIfNeeded("")read: "", "" -> "" + c);
		 return c;
	 }
	 private boolean endCommentAvailable() throws IOException {
		int nbCaret = 0;
		 final int originalOffset = fCurrentEntity.offset;
		 final int originalColumnNumber = fCurrentEntity.getColumnNumber();
		 final int originalCharacterOffset = fCurrentEntity.getCharacterOffset();
		while (true) {
			 int c = readPreservingBufferContent();
			 if (c == -1) {
				 fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);
				 return false;
			 }
			 else if (c == '>' && nbCaret >= 2) {
				 fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);
				 return true;
			 }
			 else if (c == '-') {
				 nbCaret++;
			 }
			 else {
				 nbCaret = 0;
			 }
		}
	}
	static void reduceToContent(final XMLStringBuffer buffer, final String startMarker, final String endMarker) {
		int i = 0;
		int startContent = -1;
		final int l1 = startMarker.length();
		final int l2 = endMarker.length();
		while (i < buffer.length - l1 - l2) {
			final char c = buffer.ch[buffer.offset+i];
			if (Character.isWhitespace(c)) {
				++i;
			}
			else if (c == startMarker.charAt(0)&& startMarker.equals(new String(buffer.ch, buffer.offset+i, l1))) {
				startContent = buffer.offset + i + l1;
				break;
			}
			else {
				return;
			 }
		}
		if (startContent == -1) {
			 return;
		}
		i = buffer.length - 1;
		while (i > startContent + l2) {
			final char c = buffer.ch[buffer.offset+i];
			if (Character.isWhitespace(c)) {
				--i;
			}
			else if (c == endMarker.charAt(l2-1)&& endMarker.equals(new String(buffer.ch, buffer.offset+i-l2+1, l2))) {
				buffer.length = buffer.offset + i - startContent - 2;
				buffer.offset = startContent;
				return;
			}
			else {
				return;
			 }
		}
	}
}",1,0,0,0
"public boolean supportsParameter(MethodParameter parameter) {
	if (!super.supportsParameter(parameter)) {
		return false;
	}
	Class<T> type = parameter.getParameterType();
	if (!type.isInterface()) {
		return false;
	}
	if (parameter.getParameterAnnotation(ProjectedPayload.class) != null) {
		return true;
	}
	if (AnnotatedElementUtils.findMergedAnnotation(type, ProjectedPayload.class) != null) {
		return true;
	}
	String packageName = ClassUtils.getPackageName(type);
	return !IGNORED_PACKAGES.stream().anyMatch(it -> packageName.startsWith(it));
}",0,0,1,0
"private class MouseObservationEvent extends ObservationEvent {
	 private int deltaX;
	 private int deltaY;
	 private int deltaZ;
	 public MouseObservationEvent(int deltaX, int deltaY, int deltaZ) {
		 super();
		 this.deltaX = deltaX;
		 this.deltaY = deltaY;
		 this.deltaZ = deltaZ;
	 }
	 public JsonObject getJSON() {
		 JsonObject jsonEvent = new JsonObject();
		 jsonEvent.addProperty(""time"", this.timestamp);
		 jsonEvent.addProperty(""type"", ""mouse"");
		 jsonEvent.addProperty(""deltaX"", this.deltaX);
		 jsonEvent.addProperty(""deltaY"", this.deltaY);
		 jsonEvent.addProperty(""deltaZ"", this.deltaZ);
		 return jsonEvent;
	 }
 }",0,1,0,0
"public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
	com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(this.getUnknownFields());
	while (true) {
		int tag = 0;
		try {
			tag = input.readTag();
		}
		 catch (Exception e) {
		}
		switch (tag) {
			case 0 :this.setUnknownFields(unknownFields.build());
			onChanged();
			return this;
			default : {
				if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
					this.setUnknownFields(unknownFields.build());
					onChanged();
					return this;
				}
				break;
			}
			case 10 : {
				bitField0_ |= 0x00000001;
				message_ = input.readBytes();
				break;
			}
			case 16 : {
				int rawValue = input.readEnum();
				org.eclipse.orion.server.cf.loggregator.LoggregatorMessage.Message.MessageType value = org.eclipse.orion.server.cf.loggregator.LoggregatorMessage.Message.MessageType.valueOf(rawValue);
				if (value == null) {
					unknownFields.mergeVarintField(2, rawValue);
				}
				 else {
					bitField0_ |= 0x00000002;
					messageType_ = value;
				}
				break;
			}
			case 24 : {
				bitField0_ |= 0x00000004;
				timestamp_ = input.readSInt64();
				break;
			}
			case 34 : {
				bitField0_ |= 0x00000008;
				appId_ = input.readBytes();
				break;
			}
			case 50 : {
				bitField0_ |= 0x00000010;
				sourceId_ = input.readBytes();
				break;
			}
			case 58 : {
				ensureDrainUrlsIsMutable();
				drainUrls_.add(input.readBytes());
				break;
			}
			case 66 : {
				bitField0_ |= 0x00000040;
				sourceName_ = input.readBytes();
				break;
			}
		}
	}
}",0,0,1,0
"public class SetMonitorServiceConfigItem extends AbstractConfigItemFacade {
	 public List<ConfigItem> generateConfig(final NetworkElementCommand cmd) {
		 final SetMonitorServiceCommand command = (SetMonitorServiceCommand) cmd;
		 final MonitorService monitorService = new MonitorService(command.getConfiguration(), cmd.getAccessDetail(NetworkElementCommand.ROUTER_MONITORING_ENABLE));
		 return generateConfigItems(monitorService);
	 }
	 protected List<ConfigItem> generateConfigItems(final ConfigBase configuration) {
		 destinationFile = VRScripts.MONITOR_SERVICE_CONFIG;
		 return super.generateConfigItems(configuration);
	 }
}",0,0,0,0
"public class DbSyncModule implements Module {
	 public static final String MERGER_FACTORIES_MAP = ""cayenne.dbsync.mergerfactories"";
	 public static MapBuilder<MergerTokenFactory> contributeMergerTokenFactories(Binder binder) {
		 return binder.bindMap(MergerTokenFactory.class, MERGER_FACTORIES_MAP);
	 }
	 public void configure(Binder binder) {
		 binder.bind(MergerTokenFactory.class).to(DefaultMergerTokenFactory.class);
		 contributeMergerTokenFactories(binder) .put(DB2Adapter.class.getName(), DB2MergerTokenFactory.class) .put(DerbyAdapter.class.getName(), DerbyMergerTokenFactory.class) .put(FirebirdAdapter.class.getName(), FirebirdMergerTokenFactory.class) .put(H2Adapter.class.getName(), H2MergerTokenFactory.class) .put(HSQLDBAdapter.class.getName(), HSQLMergerTokenFactory.class) .put(IngresAdapter.class.getName(), IngresMergerTokenFactory.class) .put(MySQLAdapter.class.getName(), MySQLMergerTokenFactory.class) .put(OpenBaseAdapter.class.getName(), OpenBaseMergerTokenFactory.class) .put(OracleAdapter.class.getName(), OracleMergerTokenFactory.class) .put(Oracle8Adapter.class.getName(), OracleMergerTokenFactory.class) .put(PostgresAdapter.class.getName(), PostgresMergerTokenFactory.class) .put(SQLServerAdapter.class.getName(), SQLServerMergerTokenFactory.class) .put(SybaseAdapter.class.getName(), SybaseMergerTokenFactory.class);
		 binder.bind(MergerTokenFactoryProvider.class).to(MergerTokenFactoryProvider.class);
	 }
}",0,0,0,0
"public final Object to(final Class<T> type) throws StringValueConversionException{
	if (type == String.class){
		return toString();
	}
	if (type == Integer.TYPE || type == Integer.class){
		return toInteger();
	}
	if (type == Long.TYPE || type == Long.class){
		return toLongObject();
	}
	if (type == Boolean.TYPE || type == Boolean.class){
		return toBooleanObject();
	}
	if (type == Double.TYPE || type == Double.class){
		return toDoubleObject();
	}
	if (type == Character.TYPE || type == Character.class){
		return toCharacter();
	}
	if (type == Time.class){
		return toTime();
	}
	if (type == Duration.class){
		return toDuration();
	}
	throw new StringValueConversionException(""Cannot convert '"" + toString() + ""'to type "" +type);
}",0,0,0,0
"public class TCPSocketChannel{
	 private AsynchronousSocketChannel channel;
	 private String address;
	 private int port;
	 private String logname;
	 public TCPSocketChannel(String address, int port, String logname) {
		 this.address = address;
		 this.port = port;
		 this.logname = logname;
		 try {
			 connectWithTimeout();
		 }
		 catch (IOException e) {
			 Log(Level.SEVERE, ""Failed to connectWithTimeout AsynchronousSocketChannel: "" + e);
		 }
		 catch (ExecutionException e) {
			 Log(Level.SEVERE, ""Failed to connectWithTimeout AsynchronousSocketChannel: "" + e);
		 }
		 catch (InterruptedException e) {
			 Log(Level.SEVERE, ""Failed to connectWithTimeout AsynchronousSocketChannel: "" + e);
		 }
		 catch (TimeoutException e) {
			 Log(Level.SEVERE, ""AsynchronousSocketChannel connectWithTimeout timed out: "" + e);
		 }
	 }
	 public int getPort() {
		 return port;
	 }
	 public String getAddress() {
		 return address;
	 }
	 public boolean isValid() {
		 return channel != null;
	 }
	 public boolean isOpen() {
		 return channel.isOpen();
	 }
	 private void Log(Level level, String message) {
		 TCPUtils.Log(level, ""<-"" + this.logname + ""("" + this.address + "":"" + this.port + "") "" + message);
	 }
	 private void SysLog(Level level, String message) {
		 TCPUtils.SysLog(level, ""<-"" + this.logname + ""("" + this.address + "":"" + this.port + "") "" + message);
	 }
	 private void connectWithTimeout() throws IOException, ExecutionException, InterruptedException, TimeoutException {
		 if (port == 0) return;
		 InetSocketAddress inetSocketAddress = new InetSocketAddress(address, port);
		 Log(Level.INFO, ""Attempting to open SocketChannel with InetSocketAddress: "" + inetSocketAddress);
		 this.channel = AsynchronousSocketChannel.open();
		 Future<Void> connected = this.channel.connect(inetSocketAddress);
		 connected.get(TCPUtils.DEFAULT_SOCKET_TIMEOUT_MS, TimeUnit.MILLISECONDS);
	 }
	 public void close() {
		 Log(Level.INFO, ""Attempting to close channel."");
		 if (this.channel != null) {
			 try {
				 this.channel.close();
			 }
			 catch (IOException e) {
				 SysLog(Level.SEVERE, ""Failed to close channel: "" + e);
			 }
		 }
	 }
	 public boolean sendTCPString(String message) {
		 return sendTCPString(message, 0);
	 }
	 public boolean sendTCPString(String message, int retries) {
		 Log(Level.FINE, ""About to send: "" + message);
		 byte[] bytes = message.getBytes();
		 return sendTCPBytes(bytes, retries);
	 }
	 public boolean sendTCPBytes(byte[] buffer) {
		 return sendTCPBytes(buffer, 0);
	 }
	 public boolean sendTCPBytes(byte[] bytes, int retries) {
		 try {
			 ByteBuffer header = createHeader(bytes.length);
			 safeWrite(header);
			 ByteBuffer buffer = ByteBuffer.wrap(bytes);
			 safeWrite(buffer);
		 }
		 catch (Exception e) {
			 SysLog(Level.SEVERE, ""Failed to send TCP bytes"" + (retries > 0 ? "" -- retrying "" : """") + "": "" + e);
			 try {
				 channel.close();
			 }
			 catch (IOException ioe) {
			 }
			 if (retries > 0) {
				 try {
					 connectWithTimeout();
				 }
				 catch (Exception connectException) {
					 SysLog(Level.SEVERE, ""Failed to reconnect: "" + connectException);
					 return false;
				 }
				 return sendTCPBytes(bytes, retries - 1);
			 }
			 return false;
		 }
		 return true;
	 }
	 public boolean sendTCPBytes(ByteBuffer[] srcbuffers, int length) {
		 boolean success = false;
		 try {
			 ByteBuffer header = createHeader(length);
			 ByteBuffer[] buffers = new ByteBuffer[1 + srcbuffers.length];
			 buffers[0] = header;
			 for (int i = 0;
			 i < srcbuffers.length;
			 i++) buffers[i + 1] = srcbuffers[i];
			 if (TCPUtils.isLogging()) {
				 long t1 = System.nanoTime();
				 long bytesWritten = write(buffers);
				 long t2 = System.nanoTime();
				 double rate = 1000.0 * 1000.0 * 1000.0 * (double) (bytesWritten) / (1024.0 * (double) (t2 - t1));
				 Log(Level.INFO, ""Sent "" + bytesWritten + "" bytes at "" + rate + "" Kb/s"");
			 }
			 else {
				 write(buffers);
			 }
			 success = true;
		 }
		 catch (Exception e) {
			 SysLog(Level.SEVERE, ""Failed to send TCP bytes: "" + e);
			 try {
				 channel.close();
			 }
			 catch (IOException ioe) {
			}
		 }
		 return success;
	 }
	 private ByteBuffer createHeader(int length) {
		 ByteBuffer header = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(length);
		 header.flip();
		 return header;
	 }
	 private void safeWrite(ByteBuffer buffer) throws InterruptedException, TimeoutException, ExecutionException, IOException {
		 while (buffer.remaining() > 0) {
			 Future<Integer> future = this.channel.write(buffer);
			 int bytesWritten = future.get(TCPUtils.DEFAULT_SOCKET_TIMEOUT_MS, TimeUnit.MILLISECONDS);
			 if (bytesWritten == 0) {
				 throw new IOException(""async write failed to send any bytes."");
			 }
		 }
	 }
	 private long write(ByteBuffer[] buffers) throws InterruptedException, TimeoutException, ExecutionException, IOException {
		 long bytesWritten = 0;
		 for (ByteBuffer b : buffers) {
			 bytesWritten += b.remaining();
			 safeWrite(b);
		 }
		 return bytesWritten;
	 }
}",1,1,0,0
"private void initUI(String file, String folder) {
	setUndecorated(true);
	try {
		if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			setOpacity(0.85f);
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	setIconImage(ImageResource.get(""icon.png"").getImage());
	setSize(350, 210);
	setLocationRelativeTo(null);
	setAlwaysOnTop(true);
	getContentPane().setLayout(null);
	getContentPane().setBackground(ColorResource.getDarkestBgColor());
	JPanel titlePanel = new TitlePanel(null, this);
	titlePanel.setOpaque(false);
	titlePanel.setBounds(0, 0, 350, 50);
	add(titlePanel);
	JButton closeBtn = new CustomButton();
	closeBtn.setBounds(310, 5, 30, 30);
	closeBtn.setBackground(ColorResource.getDarkestBgColor());
	closeBtn.setBorderPainted(false);
	closeBtn.setFocusPainted(false);
	closeBtn.setName(""CLOSE"");
	closeBtn.setIcon(ImageResource.get(""close_btn.png""));
	closeBtn.addActionListener(this);
	titlePanel.add(closeBtn);
	JLabel titleLbl = new JLabel(StringResource.get(""CD_TITLE""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(25, 15, 200, 30);
	titlePanel.add(titleLbl);
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, 55, 350, 1);
	lineLbl.setOpaque(true);
	add(lineLbl);
	JLabel lblFile = new JLabel(StringResource.get(""ND_FILE""), JLabel.RIGHT);
	lblFile.setBounds(0, 75, 70, 20);
	lblFile.setForeground(Color.WHITE);
	add(lblFile);
	JLabel lblSave = new JLabel(StringResource.get(""CD_LOC""), JLabel.RIGHT);
	lblSave.setBounds(0, 100, 70, 20);
	lblSave.setForeground(Color.WHITE);
	add(lblSave);
	txtFile = new JTextField();
	txtFile.setText(file);
	txtFile.setEditable(false);
	txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	txtFile.setBackground(ColorResource.getDarkestBgColor());
	txtFile.setForeground(Color.WHITE);
	txtFile.setBounds(80, 75, 220, 20);
	txtFile.setCaretColor(ColorResource.getSelectionColor());
	add(txtFile);
	txtFolder = new JTextField();
	txtFolder.setText(folder);
	txtFolder.setEditable(false);
	txtFolder.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	txtFolder.setBackground(ColorResource.getDarkestBgColor());
	txtFolder.setForeground(Color.WHITE);
	txtFolder.setBounds(80, 100, 220, 20);
	txtFolder.setCaretColor(ColorResource.getSelectionColor());
	add(txtFolder);
	chkDontShow = new JCheckBox(StringResource.get(""MSG_DONT_SHOW_AGAIN""));
	chkDontShow.setBackground(ColorResource.getDarkestBgColor());
	chkDontShow.setName(""MSG_DONT_SHOW_AGAIN"");
	chkDontShow.setForeground(Color.WHITE);
	chkDontShow.setFocusPainted(false);
	chkDontShow.setBounds(75, 125, 200, 20);
	chkDontShow.setIcon(ImageResource.get(""unchecked.png""));
	chkDontShow.setSelectedIcon(ImageResource.get(""checked.png""));
	chkDontShow.addActionListener(this);
	add(chkDontShow);
	JPanel panel = new JPanel(null);
	panel.setBounds(0, 155, 400, 55);
	panel.setBackground(Color.DARK_GRAY);
	add(panel);
	CustomButton btnMore = new CustomButton(StringResource.get(""CD_OPEN_FILE"")),btnDN = new CustomButton(StringResource.get(""CD_OPEN_FOLDER"")),btnCN = new CustomButton(StringResource.get(""ND_CANCEL""));
	btnMore.setBounds(0, 1, 100, 55);
	btnMore.setName(""CTX_OPEN_FILE"");
	styleButton(btnMore);
	panel.add(btnMore);
	btnDN.setBounds(101, 1, 148, 55);
	btnDN.setName(""CTX_OPEN_FOLDER"");
	styleButton(btnDN);
	panel.add(btnDN);
	btnCN.setBounds(250, 1, 100, 55);
	btnCN.setName(""CLOSE"");
	styleButton(btnCN);
	panel.add(btnCN);
}",0,0,1,0
"public class TezClientUtils {
	 private static Log LOG = LogFactory.getLog(TezClientUtils.class);
	 private static final int UTF8_CHUNK_SIZE = 16 * 1024;
	 static Map<String, LocalResource> setupTezJarsLocalResources( TezConfiguration conf, Credentials credentials) throws IOException {
		 Preconditions.checkNotNull(credentials, ""A non-null credentials object should be specified"");
		 Map<String, LocalResource> tezJarResources = new HashMap<String, LocalResource>();
		 if (conf.getBoolean(TezConfiguration.TEZ_IGNORE_LIB_URIS, false)){
			 LOG.info(""Ignoring '"" + TezConfiguration.TEZ_LIB_URIS + ""' since '"" + TezConfiguration.TEZ_IGNORE_LIB_URIS + ""' is set to true"");
		 }
		 else {
			 String[] tezJarUris = conf.getStrings(TezConfiguration.TEZ_LIB_URIS);
			 if (tezJarUris == null || tezJarUris.length == 0) {
				 throw new TezUncheckedException(""Invalid configuration of tez jars"" + "", "" + TezConfiguration.TEZ_LIB_URIS + "" is not defined in the configurartion"");
			 }
			 List<Path> tezJarPaths = Lists.newArrayListWithCapacity(tezJarUris.length);
			 for (String tezJarUri : tezJarUris) {
				 URI uri;
				 try {
					 uri = new URI(tezJarUri.trim());
				 }
				 catch (URISyntaxException e) {
					 String message = ""Invalid URI defined in configuration for"" + "" location of TEZ jars. providedURI="" + tezJarUri;
					 LOG.error(message);
					 throw new TezUncheckedException(message, e);
				 }
				 if (!uri.isAbsolute()) {
					 String message = ""Non-absolute URI defined in configuration for"" + "" location of TEZ jars. providedURI="" + tezJarUri;
					 LOG.error(message);
					 throw new TezUncheckedException(message);
				 }
				 Path p = new Path(uri);
				 FileSystem pathfs = p.getFileSystem(conf);
				 p = pathfs.makeQualified(p);
				 tezJarPaths.add(p);
				 RemoteIterator<LocatedFileStatus> iter = pathfs.listFiles(p, false);
				 while (iter.hasNext()) {
					 LocatedFileStatus fStatus = iter.next();
					 String rsrcName = fStatus.getPath().getName();
					 if (tezJarResources.containsKey(rsrcName)) {
						 String message = ""Duplicate resource found"" + "", resourceName="" + rsrcName + "", existingPath="" + tezJarResources.get(rsrcName).getResource().toString() + "", newPath="" + fStatus.getPath();
						 LOG.warn(message);
					 }
					 tezJarResources.put(rsrcName, LocalResource.newInstance( ConverterUtils.getYarnUrlFromPath(fStatus.getPath()), LocalResourceType.FILE, LocalResourceVisibility.PUBLIC, fStatus.getLen(), fStatus.getModificationTime()));
				 }
			 }
			 if (tezJarResources.isEmpty()) {
				 throw new TezUncheckedException( ""No files found in locations specified in "" + TezConfiguration.TEZ_LIB_URIS + "" . Locations: "" + StringUtils.join(tezJarUris, ','));
			 }
			 else {
				 TokenCache.obtainTokensForFileSystems(credentials, tezJarPaths.toArray(new Path[tezJarPaths.size()]), conf);
			 }
		 }
		 return tezJarResources;
	 }
	 static void processTezLocalCredentialsFile(Credentials credentials, Configuration conf) throws IOException {
		 String path = conf.get(TezJobConfig.TEZ_CREDENTIALS_PATH);
		 if (path == null) {
			 return;
		 }
		 else {
			 TokenCache.mergeBinaryTokens(credentials, conf, path);
		 }
	 }
	 public static FileSystem ensureStagingDirExists(Configuration conf, Path stagingArea) throws IOException {
		 FileSystem fs = stagingArea.getFileSystem(conf);
		 String realUser;
		 String currentUser;
		 UserGroupInformation ugi = UserGroupInformation.getLoginUser();
		 realUser = ugi.getShortUserName();
		 currentUser = UserGroupInformation.getCurrentUser().getShortUserName();
		 if (fs.exists(stagingArea)) {
			 FileStatus fsStatus = fs.getFileStatus(stagingArea);
			 String owner = fsStatus.getOwner();
			 if (!(owner.equals(currentUser) || owner.equals(realUser))) {
				 throw new IOException(""The ownership on the staging directory "" + stagingArea + "" is not as expected. "" + ""It is owned by "" + owner + "". The directory must "" + ""be owned by the submitter "" + currentUser + "" or "" + ""by "" + realUser);
			 }
			 if (!fsStatus.getPermission().equals(TezCommonUtils.TEZ_AM_DIR_PERMISSION)) {
				 LOG.info(""Permissions on staging directory "" + stagingArea + "" are "" + ""incorrect: "" + fsStatus.getPermission() + "". Fixing permissions "" + ""to correct value "" + TezCommonUtils.TEZ_AM_DIR_PERMISSION);
				 fs.setPermission(stagingArea, TezCommonUtils.TEZ_AM_DIR_PERMISSION);
			 }
		 }
		 else {
			 TezCommonUtils.mkDirForAM(fs, stagingArea);
		 }
		 return fs;
	 }
	 static void setupDAGCredentials(DAG dag, Credentials sessionCredentials, Configuration conf) throws IOException {
		 Preconditions.checkNotNull(sessionCredentials);
		 LogUtils.logCredentials(LOG, sessionCredentials, ""session"");
		 Credentials dagCredentials = dag.getCredentials();
		 if (dagCredentials == null) {
			 dagCredentials = new Credentials();
			 dag.setCredentials(dagCredentials);
		 }
		 dagCredentials.mergeAll(sessionCredentials);
		 Collection<URI> uris = dag.getURIsForCredentials();
		 if (uris != null && !uris.isEmpty()) {
			 Iterator<Path> pathIter = Iterators.transform(uris.iterator(), new Function<URI, Path>() {
				 public Path apply(URI input) {
					 return new Path(input);
				 }
			 }
			);
			 Path[] paths = Iterators.toArray(pathIter, Path.class);
			 TokenCache.obtainTokensForFileSystems(dagCredentials, paths, conf);
		 }
		 try {
			 Set<Path> lrPaths = new HashSet<Path>();
			 for (Vertex v: dag.getVertices()) {
				 for (LocalResource lr: v.getTaskLocalFiles().values()) {
					 lrPaths.add(ConverterUtils.getPathFromYarnURL(lr.getResource()));
				 }
			 }
			 Path[] paths = lrPaths.toArray(new Path[lrPaths.size()]);
			 TokenCache.obtainTokensForFileSystems(dagCredentials, paths, conf);
		 }
		 catch (URISyntaxException e) {
			 throw new IOException(e);
		 }
	 }
	 static ApplicationSubmissionContext createApplicationSubmissionContext( TezConfiguration conf, ApplicationId appId, DAG dag, String amName, AMConfiguration amConfig, Map<String, LocalResource> tezJarResources, Credentials sessionCreds) throws IOException, YarnException{
		 Preconditions.checkNotNull(sessionCreds);
		 FileSystem fs = TezClientUtils.ensureStagingDirExists(conf, TezCommonUtils.getTezBaseStagingPath(conf));
		 String strAppId = appId.toString();
		 Path tezSysStagingPath = TezCommonUtils.createTezSystemStagingPath(conf, strAppId);
		 Path binaryConfPath = TezCommonUtils.getTezConfStagingPath(tezSysStagingPath);
		 binaryConfPath = fs.makeQualified(binaryConfPath);
		 Resource capability = Records.newRecord(Resource.class);
		 capability.setMemory( amConfig.getTezConfiguration().getInt(TezConfiguration.TEZ_AM_RESOURCE_MEMORY_MB, TezConfiguration.TEZ_AM_RESOURCE_MEMORY_MB_DEFAULT));
		 capability.setVirtualCores( amConfig.getTezConfiguration().getInt(TezConfiguration.TEZ_AM_RESOURCE_CPU_VCORES, TezConfiguration.TEZ_AM_RESOURCE_CPU_VCORES_DEFAULT));
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""AppMaster capability = "" + capability);
		 }
		 ByteBuffer securityTokens = null;
		 Credentials amLaunchCredentials = new Credentials();
		 if (amConfig.getCredentials() != null) {
			 amLaunchCredentials.addAll(amConfig.getCredentials());
		 }
		 TokenCache.obtainTokensForFileSystems(sessionCreds, new Path[] {
		binaryConfPath}
		, conf);
		 amLaunchCredentials.mergeAll(sessionCreds);
		 DataOutputBuffer dob = new DataOutputBuffer();
		 amLaunchCredentials.writeTokenStorageToStream(dob);
		 securityTokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength());
		 if (dag != null) {
			 setupDAGCredentials(dag, sessionCreds, conf);
		 }
		 List<String> vargs = new ArrayList<String>(8);
		 vargs.add(Environment.JAVA_HOME.$() + ""/bin/java"");
		 String amOpts = amConfig.getTezConfiguration().get( TezConfiguration.TEZ_AM_LAUNCH_CMD_OPTS, TezConfiguration.TEZ_AM_LAUNCH_CMD_OPTS_DEFAULT);
		 amOpts = maybeAddDefaultMemoryJavaOpts(amOpts, capability, amConfig.getTezConfiguration().getDouble(TezConfiguration.TEZ_CONTAINER_MAX_JAVA_HEAP_FRACTION, TezConfiguration.TEZ_CONTAINER_MAX_JAVA_HEAP_FRACTION_DEFAULT));
		 vargs.add(amOpts);
		 String amLogLevel = amConfig.getTezConfiguration().get( TezConfiguration.TEZ_AM_LOG_LEVEL, TezConfiguration.TEZ_AM_LOG_LEVEL_DEFAULT);
		 maybeAddDefaultLoggingJavaOpts(amLogLevel, vargs);
		 vargs.add(""-Dsun.nio.ch.bugLevel=''"");
		 vargs.add(TezConfiguration.TEZ_APPLICATION_MASTER_CLASS);
		 if (dag == null) {
			 vargs.add(""--"" + TezConstants.TEZ_SESSION_MODE_CLI_OPTION);
		 }
		 vargs.add(""1>"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + File.separator + ApplicationConstants.STDOUT);
		 vargs.add(""2>"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + File.separator + ApplicationConstants.STDERR);
		 Vector<String> vargsFinal = new Vector<String>(8);
		 StringBuilder mergedCommand = new StringBuilder();
		 for (CharSequence str : vargs) {
			 mergedCommand.append(str).append("" "");
		 }
		 vargsFinal.add(mergedCommand.toString());
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Command to launch container for ApplicationMaster is : "" + mergedCommand);
		 }
		 Map<String, String> environment = new TreeMap<String, String>();
		 TezYARNUtils.setupDefaultEnv(environment, conf, TezConfiguration.TEZ_AM_LAUNCH_ENV, TezConfiguration.TEZ_AM_LAUNCH_ENV_DEFAULT);
		 if (amConfig.getEnv() != null) {
			 for (Map.Entry<String, String> entry : amConfig.getEnv().entrySet()) {
				 TezYARNUtils.addToEnvironment(environment, entry.getKey(), entry.getValue(), File.pathSeparator);
			 }
		 }
		 Map<String, LocalResource> localResources = new TreeMap<String, LocalResource>();
		 if (amConfig.getLocalResources() != null) {
			 localResources.putAll(amConfig.getLocalResources());
		 }
		 localResources.putAll(tezJarResources);
		 Configuration finalTezConf = createFinalTezConfForApp(conf, amConfig.getTezConfiguration());
		 FSDataOutputStream amConfPBOutBinaryStream = null;
		 try {
			 ConfigurationProto.Builder confProtoBuilder = ConfigurationProto.newBuilder();
			 Iterator<Entry<String, String>> iter = finalTezConf.iterator();
			 while (iter.hasNext()) {
				 Entry<String, String> entry = iter.next();
				 PlanKeyValuePair.Builder kvp = PlanKeyValuePair.newBuilder();
				 kvp.setKey(entry.getKey());
				 kvp.setValue(entry.getValue());
				 confProtoBuilder.addConfKeyValues(kvp);
			 }
			 amConfPBOutBinaryStream = TezCommonUtils.createFileForAM(fs, binaryConfPath);
			 confProtoBuilder.build().writeTo(amConfPBOutBinaryStream);
		 }
		 finally {
			 if(amConfPBOutBinaryStream != null){
				 amConfPBOutBinaryStream.close();
			 }
		 }
		 LocalResource binaryConfLRsrc = TezClientUtils.createLocalResource(fs, binaryConfPath, LocalResourceType.FILE, LocalResourceVisibility.APPLICATION);
		 localResources.put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME, binaryConfLRsrc);
		 Path sessionJarsPath = TezCommonUtils.getTezSessionJarStagingPath(tezSysStagingPath);
		 FSDataOutputStream sessionJarsPBOutStream = null;
		 try {
			 Map<String, LocalResource> sessionJars = new HashMap<String, LocalResource>(tezJarResources.size() + 1);
			 sessionJars.putAll(tezJarResources);
			 sessionJars.put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME, binaryConfLRsrc);
			 DAGProtos.PlanLocalResourcesProto proto = DagTypeConverters.convertFromLocalResources(sessionJars);
			 sessionJarsPBOutStream = TezCommonUtils.createFileForAM(fs, sessionJarsPath);
			 proto.writeDelimitedTo(sessionJarsPBOutStream);
			 DAGProtos.PlanLocalResourcesProto amResourceProto;
			 if (amConfig.getLocalResources() != null && !amConfig.getLocalResources().isEmpty()) {
				 amResourceProto = DagTypeConverters.convertFromLocalResources(localResources);
			 }
			 else {
				 amResourceProto = DAGProtos.PlanLocalResourcesProto.getDefaultInstance();
			 }
			 amResourceProto.writeDelimitedTo(sessionJarsPBOutStream);
		 }
		 finally {
			 if (sessionJarsPBOutStream != null) {
				 sessionJarsPBOutStream.close();
			 }
		 }
		 LocalResource sessionJarsPBLRsrc = TezClientUtils.createLocalResource(fs, sessionJarsPath, LocalResourceType.FILE, LocalResourceVisibility.APPLICATION);
		 localResources.put( TezConfiguration.TEZ_SESSION_LOCAL_RESOURCES_PB_FILE_NAME, sessionJarsPBLRsrc);
		 if(dag != null) {
			 for (Vertex v : dag.getVertices()) {
				 if (tezJarResources != null) {
					 v.getTaskLocalFiles().putAll(tezJarResources);
				 }
				 v.getTaskLocalFiles().put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME, binaryConfLRsrc);
				 Map<String, String> taskEnv = v.getTaskEnvironment();
				 TezYARNUtils.setupDefaultEnv(taskEnv, conf, TezConfiguration.TEZ_TASK_LAUNCH_ENV, TezConfiguration.TEZ_TASK_LAUNCH_ENV_DEFAULT);
				 TezClientUtils.setDefaultLaunchCmdOpts(v, amConfig.getTezConfiguration());
			 }
			 Path binaryPath = TezCommonUtils.getTezBinPlanStagingPath(tezSysStagingPath);
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(""Stage directory information for AppId :"" + appId + "" tezSysStagingPath :"" + tezSysStagingPath + "" binaryConfPath :"" + binaryConfPath + "" sessionJarsPath :"" + sessionJarsPath + "" binaryPlanPath :"" + binaryPath);
			 }
			 amConfig.getTezConfiguration().set(TezConfiguration.TEZ_AM_PLAN_REMOTE_PATH, binaryPath.toUri().toString());
			 DAGPlan dagPB = dag.createDag(null);
			 FSDataOutputStream dagPBOutBinaryStream = null;
			 try {
				 dagPBOutBinaryStream = TezCommonUtils.createFileForAM(fs, binaryPath);
				 dagPB.writeTo(dagPBOutBinaryStream);
			 }
			 finally {
				 if(dagPBOutBinaryStream != null){
					 dagPBOutBinaryStream.close();
				 }
			 }
			 localResources.put(TezConfiguration.TEZ_PB_PLAN_BINARY_NAME, TezClientUtils.createLocalResource(fs, binaryPath, LocalResourceType.FILE, LocalResourceVisibility.APPLICATION));
			 if (Level.DEBUG.isGreaterOrEqual(Level.toLevel(amLogLevel))) {
				 Path textPath = localizeDagPlanAsText(dagPB, fs, amConfig, strAppId, tezSysStagingPath);
				 localResources.put(TezConfiguration.TEZ_PB_PLAN_TEXT_NAME, TezClientUtils.createLocalResource(fs, textPath, LocalResourceType.FILE, LocalResourceVisibility.APPLICATION));
			 }
		 }
		 Map<ApplicationAccessType, String> acls = new HashMap<ApplicationAccessType, String>();
		 ContainerLaunchContext amContainer = ContainerLaunchContext.newInstance(localResources, environment, vargsFinal, null, securityTokens, acls);
		 ApplicationSubmissionContext appContext = Records .newRecord(ApplicationSubmissionContext.class);
		 appContext.setApplicationType(TezConfiguration.TEZ_APPLICATION_TYPE);
		 appContext.setApplicationId(appId);
		 appContext.setResource(capability);
		 if (amConfig.getQueueName() != null) {
			 appContext.setQueue(amConfig.getQueueName());
		 }
		 appContext.setApplicationName(amName);
		 appContext.setCancelTokensWhenComplete(amConfig.getTezConfiguration().getBoolean( TezConfiguration.TEZ_AM_CANCEL_DELEGATION_TOKEN, TezConfiguration.TEZ_AM_CANCEL_DELEGATION_TOKEN_DEFAULT));
		 appContext.setAMContainerSpec(amContainer);
		 appContext.setMaxAppAttempts( finalTezConf.getInt(TezConfiguration.TEZ_AM_MAX_APP_ATTEMPTS, TezConfiguration.TEZ_AM_MAX_APP_ATTEMPTS_DEFAULT));
		 return appContext;
	 }
	 static void maybeAddDefaultLoggingJavaOpts(String logLevel, List<String> vargs) {
		 if (vargs != null && !vargs.isEmpty()) {
			 for (String arg : vargs) {
				 if (arg.contains(TezConfiguration.TEZ_ROOT_LOGGER_NAME)) {
					 return ;
				 }
			 }
		 }
		 TezClientUtils.addLog4jSystemProperties(logLevel, vargs);
	 }
	 static String maybeAddDefaultLoggingJavaOpts(String logLevel, String javaOpts) {
		 List<String> vargs = new ArrayList<String>(5);
		 if (javaOpts != null) {
			 vargs.add(javaOpts);
		 }
		 else {
			 vargs.add("""");
		 }
		 maybeAddDefaultLoggingJavaOpts(logLevel, vargs);
		 if (vargs.size() == 1) {
			 return vargs.get(0);
		 }
		 return StringUtils.join(vargs, "" "").trim();
	 }
	 static void setDefaultLaunchCmdOpts(Vertex v, TezConfiguration conf) {
		 String vOpts = v.getTaskLaunchCmdOpts();
		 String vConfigOpts = conf.get(TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS, TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS_DEFAULT);
		 if (vConfigOpts != null && vConfigOpts.length() > 0) {
			 vOpts += ("" "" + vConfigOpts);
		 }
		 vOpts = maybeAddDefaultLoggingJavaOpts(conf.get( TezConfiguration.TEZ_TASK_LOG_LEVEL, TezConfiguration.TEZ_TASK_LOG_LEVEL_DEFAULT), vOpts);
		 v.setTaskLaunchCmdOpts(vOpts);
	 }
	 public static void addLog4jSystemProperties(String logLevel, List<String> vargs) {
		 vargs.add(""-Dlog4j.configuration="" + TezConfiguration.TEZ_CONTAINER_LOG4J_PROPERTIES_FILE);
		 vargs.add(""-D"" + YarnConfiguration.YARN_APP_CONTAINER_LOG_DIR + ""="" + ApplicationConstants.LOG_DIR_EXPANSION_VAR);
		 vargs.add(""-D"" + TezConfiguration.TEZ_ROOT_LOGGER_NAME + ""="" + logLevel + "","" + TezConfiguration.TEZ_CONTAINER_LOGGER_NAME);
	 }
	 static Configuration createFinalTezConfForApp(TezConfiguration tezConf, TezConfiguration amConf) {
		 Configuration conf = new Configuration(false);
		 conf.setQuietMode(true);
		 assert tezConf != null;
		 assert amConf != null;
		 Entry<String, String> entry;
		 Iterator<Entry<String, String>> iter = tezConf.iterator();
		 while (iter.hasNext()) {
			 entry = iter.next();
			 if (entry.getKey().startsWith(TezConfiguration.TEZ_PREFIX)) {
				 conf.set(entry.getKey(), entry.getValue());
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Adding tez dag am parameter from conf: "" + entry.getKey() + "", with value: "" + entry.getValue());
				 }
			 }
		 }
		 iter = amConf.iterator();
		 while (iter.hasNext()) {
			 entry = iter.next();
			 if (entry.getKey().startsWith(TezConfiguration.TEZ_PREFIX)) {
				 conf.set(entry.getKey(), entry.getValue());
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Adding tez dag am parameter from amConf: "" + entry.getKey() + "", with value: "" + entry.getValue());
				 }
			 }
		 }
		 return conf;
	 }
	 static LocalResource createLocalResource(FileSystem fs, Path p, LocalResourceType type, LocalResourceVisibility visibility) throws IOException {
		 LocalResource rsrc = Records.newRecord(LocalResource.class);
		 FileStatus rsrcStat = fs.getFileStatus(p);
		 rsrc.setResource(ConverterUtils.getYarnUrlFromPath(fs.resolvePath(rsrcStat .getPath())));
		 rsrc.setSize(rsrcStat.getLen());
		 rsrc.setTimestamp(rsrcStat.getModificationTime());
		 rsrc.setType(type);
		 rsrc.setVisibility(visibility);
		 return rsrc;
	 }
	 private static Path localizeDagPlanAsText(DAGPlan dagPB, FileSystem fs, AMConfiguration amConfig, String strAppId, Path tezSysStagingPath) throws IOException {
		 Path textPath = TezCommonUtils.getTezTextPlanStagingPath(tezSysStagingPath);
		 FSDataOutputStream dagPBOutTextStream = null;
		 try {
			 dagPBOutTextStream = TezCommonUtils.createFileForAM(fs, textPath);
			 String dagPBStr = dagPB.toString();
			 int dagPBStrLen = dagPBStr.length();
			 if (dagPBStrLen <= UTF8_CHUNK_SIZE) {
				 dagPBOutTextStream.writeUTF(dagPBStr);
			 }
			 else {
				 int startIndex = 0;
				 while (startIndex < dagPBStrLen) {
					 int endIndex = startIndex + UTF8_CHUNK_SIZE;
					 if (endIndex > dagPBStrLen) {
						 endIndex = dagPBStrLen;
					 }
					 dagPBOutTextStream.writeUTF(dagPBStr.substring(startIndex, endIndex));
					 startIndex += UTF8_CHUNK_SIZE;
				 }
			 }
		 }
		 finally {
			 if (dagPBOutTextStream != null) {
				 dagPBOutTextStream.close();
			 }
		 }
		 return textPath;
	 }
	 static DAGClientAMProtocolBlockingPB getSessionAMProxy(YarnClient yarnClient, Configuration conf, ApplicationId applicationId) throws TezException, IOException {
		 ApplicationReport appReport;
		 try {
			 appReport = yarnClient.getApplicationReport( applicationId);
			 if(appReport == null) {
				 throw new TezUncheckedException(""Could not retrieve application report"" + "" from YARN, applicationId="" + applicationId);
			 }
			 YarnApplicationState appState = appReport.getYarnApplicationState();
			 if(appState != YarnApplicationState.RUNNING) {
				 if (appState == YarnApplicationState.FINISHED || appState == YarnApplicationState.KILLED || appState == YarnApplicationState.FAILED) {
					 throw new SessionNotRunning(""Application not running"" + "", applicationId="" + applicationId + "", yarnApplicationState="" + appReport.getYarnApplicationState() + "", finalApplicationStatus="" + appReport.getFinalApplicationStatus() + "", trackingUrl="" + appReport.getTrackingUrl());
				 }
				 return null;
			 }
		 }
		 catch (YarnException e) {
			 throw new TezException(e);
		 }
		 return getAMProxy(conf, appReport.getHost(), appReport.getRpcPort(), appReport.getClientToAMToken());
	 }
	 public static DAGClientAMProtocolBlockingPB getAMProxy(final Configuration conf, String amHost, int amRpcPort, org.apache.hadoop.yarn.api.records.Token clientToAMToken) throws IOException {
		 final InetSocketAddress serviceAddr = new InetSocketAddress(amHost, amRpcPort);
		 UserGroupInformation userUgi = UserGroupInformation.createRemoteUser(UserGroupInformation .getCurrentUser().getUserName());
		 if (clientToAMToken != null) {
			 Token<ClientToAMTokenIdentifier> token = ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);
			 userUgi.addToken(token);
		 }
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Connecting to Tez AM at "" + serviceAddr);
		 }
		 DAGClientAMProtocolBlockingPB proxy = null;
		 try {
			 proxy = userUgi.doAs(new PrivilegedExceptionAction<DAGClientAMProtocolBlockingPB>() {
				 public DAGClientAMProtocolBlockingPB run() throws IOException {
					 RPC.setProtocolEngine(conf, DAGClientAMProtocolBlockingPB.class, ProtobufRpcEngine.class);
					 return (DAGClientAMProtocolBlockingPB) RPC.getProxy(DAGClientAMProtocolBlockingPB.class, 0, serviceAddr, conf);
				 }
			 }
			);
		 }
		 catch (InterruptedException e) {
			 throw new IOException(""Failed to connect to AM"", e);
		 }
		 return proxy;
	 }
	 public static void createSessionToken(String tokenIdentifier, JobTokenSecretManager jobTokenSecretManager, Credentials credentials) {
		 JobTokenIdentifier identifier = new JobTokenIdentifier(new Text( tokenIdentifier));
		 Token<JobTokenIdentifier> sessionToken = new Token<JobTokenIdentifier>(identifier, jobTokenSecretManager);
		 sessionToken.setService(identifier.getJobId());
		 TokenCache.setSessionToken(sessionToken, credentials);
	 }
	 public static String maybeAddDefaultMemoryJavaOpts(String javaOpts, Resource resource, double maxHeapFactor) {
		 if ((javaOpts != null && !javaOpts.isEmpty() && (javaOpts.contains(""-Xmx"") || javaOpts.contains(""-Xms""))) || (resource.getMemory() <= 0)) {
			 return javaOpts;
		 }
		 if (maxHeapFactor <= 0 || maxHeapFactor >= 1) {
			 return javaOpts;
		 }
		 int maxMemory = (int)(resource.getMemory() * maxHeapFactor);
		 maxMemory = maxMemory <= 0 ? 1 : maxMemory;
		 return "" -Xmx"" + maxMemory + ""m "" + ( javaOpts != null ? javaOpts : """");
	 }
}",1,0,0,0
"public class FunctionTagsTable extends Composite {
	 private final FunctionEditorInput functionEditorInput;
	 private final KeyValueSetEditingComposite tagsEditingComposite;
	 private final KeyValueSetDataModel tagsDataModel;
	 public FunctionTagsTable(Composite parent, FormToolkit toolkit, FunctionEditorInput functionEditorInput) {
		 super(parent, SWT.NONE);
		 this.functionEditorInput = functionEditorInput;
		 this.setLayout(new GridLayout());
		 this.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
		 tagsDataModel = new KeyValueSetDataModel(MAX_LAMBDA_TAGS, new ArrayList<Pair>());
		 tagsEditingComposite = new KeyValueSetEditingCompositeBuilder() .addKeyValidator(new StringLengthValidator(1, MAX_LAMBDA_TAG_KEY_LENGTH, String.format(""This field is too long. Maximum length is %d characters."", MAX_LAMBDA_TAG_KEY_LENGTH))) .addValueValidator(new StringLengthValidator(0, MAX_LAMBDA_TAG_VALUE_LENGTH, String.format(""This field is too long. Maximum length is %d characters."", MAX_LAMBDA_TAG_VALUE_LENGTH))) .addKeyValidator(new LambdaTagNameValidator()) .saveListener(new SelectionAdapter() {
			 public void widgetSelected(SelectionEvent e) {
				 onSaveTags();
			 }
		 }
		) .build(this, tagsDataModel);
		 Composite buttonComposite = new Composite(this, SWT.NONE);
		 buttonComposite.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false));
		 buttonComposite.setLayout(new GridLayout(1, false));
		 refresh();
	 }
	 public void refresh() {
		 Map<String, String> tagMap = functionEditorInput.getLambdaClient() .listTags(new ListTagsRequest() .withResource(functionEditorInput.getFunctionArn())) .getTags();
		 tagsDataModel.getPairSet().clear();
		 for (Entry<String, String> entry : tagMap.entrySet()) {
			 tagsDataModel.getPairSet().add(new Pair(entry.getKey(), entry.getValue()));
		 }
		 tagsEditingComposite.refresh();
	 }
	 private void onSaveTags() {
		 try {
			 AWSLambda lambda = functionEditorInput.getLambdaClient();
			 Map<String, String> oldTagMap = lambda .listTags(new ListTagsRequest() .withResource(functionEditorInput.getFunctionArn())) .getTags();
			 List<String> tagKeysToBeRemoved = new ArrayList<>();
			 for (String key : oldTagMap.keySet()) {
				 if (!tagsDataModel.getPairSet().contains(key)) {
					 tagKeysToBeRemoved.add(key);
				 }
			 }
			 Map<String, String> tagMap = new HashMap<>();
			 for (Pair pair : tagsDataModel.getPairSet()) {
				 tagMap.put(pair.getKey(), pair.getValue());
			 }
			 if (!tagKeysToBeRemoved.isEmpty()) {
				 lambda.untagResource(new UntagResourceRequest() .withResource(functionEditorInput.getFunctionArn()) .withTagKeys(tagKeysToBeRemoved));
			 }
			 lambda.tagResource(new TagResourceRequest() .withResource(functionEditorInput.getFunctionArn()) .withTags(tagMap));
		 }
		 catch (AWSLambdaException e) {
			 LambdaPlugin.getDefault().reportException(e.getMessage(), e);
		 }
	 }
}",1,0,0,0
"public class MimeMailer extends Mailer {
	 private static final String SSL_FACTORY = ""javax.net.ssl.SSLSocketFactory"";
	 private static final String GENERIC_ERROR = ""Problem while sending mime mail:"";
	 private static final String DEFAULT_CHARSET = System.getProperty(""file.encoding"");
	 class StringDataSource implements javax.activation.DataSource {
		 private String data = null;
		 private String type = null;
		 private String charset = null;
		 private ByteArrayOutputStream out;
		 public InputStream getInputStream() throws IOException {
			 if (data == null && out == null) {
				 throw new IOException(""No data"");
			 }
			 if (out != null) {
				 String encodedOut = out.toString(charset);
				 data = (data != null) ? data.concat(encodedOut) : encodedOut;
				 out = null;
			 }
			 return new ByteArrayInputStream(data.getBytes(charset));
		 }
		 public OutputStream getOutputStream() throws IOException {
			 out = (out == null) ? new ByteArrayOutputStream() : out;
			 return out;
		 }
		 public void setContentType(String type) {
			 this.type = type.toLowerCase(Locale.ENGLISH);
		 }
		 public String getContentType() {
			 if (type != null && type.indexOf(""charset"") > 0 && type.startsWith(""text/"")) {
				 return type;
			 }
			 return new StringBuffer(type != null ? type : ""text/plain"").append( "";
			 charset="").append(charset).toString();
		 }
		 public String getName() {
			 return ""StringDataSource"";
		 }
		 public void setCharset(String charset) {
			 this.charset = charset;
		 }
		 public String getCharset() {
			 return charset;
		 }
	 }
	 public void send() {
		 try {
			 Properties props = new Properties();
			 props.put(""mail.smtp.host"", host);
			 props.put(""mail.smtp.port"", String.valueOf(port));
			 Session sesh;
			 Authenticator auth = null;
			 if (SSL) {
				 try {
					 Provider p = (Provider) Class.forName( ""com.sun.net.ssl.internal.ssl.Provider"").newInstance();
					 Security.addProvider(p);
				 }
				 catch (Exception e) {
					 throw new BuildException(""could not instantiate ssl "" + ""security provider, check that you have JSSE in "" + ""your classpath"");
				 }
				 props.put(""mail.smtp.socketFactory.class"", SSL_FACTORY);
				 props.put(""mail.smtp.socketFactory.fallback"", ""false"");
				 if (isPortExplicitlySpecified()) {
					 props.put(""mail.smtp.socketFactory.port"", String.valueOf(port));
				 }
			 }
			 if (user != null || password != null) {
				 props.put(""mail.smtp.auth"", ""true"");
				 auth = new SimpleAuthenticator(user, password);
			 }
			 if (isStartTLSEnabled()) {
				 props.put(""mail.smtp.starttls.enable"", ""true"");
			 }
			 sesh = Session.getInstance(props, auth);
			 MimeMessage msg = new MimeMessage(sesh);
			 MimeMultipart attachments = new MimeMultipart();
			 if (from.getName() == null) {
				 msg.setFrom(new InternetAddress(from.getAddress()));
			 }
			 else {
				 msg.setFrom(new InternetAddress(from.getAddress(), from.getName()));
			 }
			 msg.setReplyTo(internetAddresses(replyToList));
			 msg.setRecipients(Message.RecipientType.TO, internetAddresses(toList));
			 msg.setRecipients(Message.RecipientType.CC, internetAddresses(ccList));
			 msg.setRecipients(Message.RecipientType.BCC, internetAddresses(bccList));
			 String charset = parseCharSetFromMimeType(message.getMimeType());
			 if (charset != null) {
				 message.setCharset(charset);
			 }
			 else {
				 charset = message.getCharset();
				 if (charset == null) {
					 charset = DEFAULT_CHARSET;
					 message.setCharset(charset);
				 }
			 }
			 StringDataSource sds = new StringDataSource();
			 sds.setContentType(message.getMimeType());
			 sds.setCharset(charset);
			 if (subject != null) {
				 msg.setSubject(subject, charset);
			 }
			 msg.addHeader(""Date"", getDate());
			 if (headers != null) {
				 for (Iterator iter = headers.iterator();
				 iter.hasNext();
				) {
					 Header h = (Header) iter.next();
					 msg.addHeader(h.getName(), h.getValue());
				 }
			 }
			 PrintStream out = new PrintStream(sds.getOutputStream());
			 message.print(out);
			 out.close();
			 MimeBodyPart textbody = new MimeBodyPart();
			 textbody.setDataHandler(new DataHandler(sds));
			 attachments.addBodyPart(textbody);
			 Enumeration e = files.elements();
			 while (e.hasMoreElements()) {
				 File file = (File) e.nextElement();
				 MimeBodyPart body;
				 body = new MimeBodyPart();
				 if (!file.exists() || !file.canRead()) {
					 throw new BuildException(""File \"""" + file.getAbsolutePath() + ""\"" does not exist or is not "" + ""readable."");
				 }
				 FileDataSource fileData = new FileDataSource(file);
				 DataHandler fileDataHandler = new DataHandler(fileData);
				 body.setDataHandler(fileDataHandler);
				 body.setFileName(file.getName());
				 attachments.addBodyPart(body);
			 }
			 msg.setContent(attachments);
			 try {
				 Transport transport = sesh.getTransport(SSL ? ""smtps"" : ""smtp"");
				 transport.connect(host, user, password);
				 transport.sendMessage(msg, msg.getAllRecipients());
			 }
			 catch (SendFailedException sfe) {
				 if (!shouldIgnoreInvalidRecipients()) {
					 throw new BuildException(GENERIC_ERROR, sfe);
				 }
				 else if (sfe.getValidSentAddresses() == null || sfe.getValidSentAddresses().length == 0) {
					 throw new BuildException(""Couldn't reach any recipient"", sfe);
				 }
				 else {
					 Address[] invalid = sfe.getInvalidAddresses();
					 if (invalid == null) {
						 invalid = new Address[0];
					 }
					 for (int i = 0;
					 i < invalid.length;
					 i++) {
						 didntReach(invalid[i], ""invalid"", sfe);
					 }
					 Address[] validUnsent = sfe.getValidUnsentAddresses();
					 if (validUnsent == null) {
						 validUnsent = new Address[0];
					 }
					 for (int i = 0;
					 i < validUnsent.length;
					 i++) {
						 didntReach(validUnsent[i], ""valid"", sfe);
					 }
				 }
			 }
		 }
		 catch (MessagingException e) {
			 throw new BuildException(GENERIC_ERROR, e);
		 }
		 catch (IOException e) {
			 throw new BuildException(GENERIC_ERROR, e);
		 }
	 }
	 private static InternetAddress[] internetAddresses(Vector list) throws AddressException, UnsupportedEncodingException {
		 final int size = list.size();
		 InternetAddress[] addrs = new InternetAddress[size];
		 for (int i = 0;
		 i < size;
		 ++i) {
			 EmailAddress addr = (EmailAddress) list.elementAt(i);
			 String name = addr.getName();
			 addrs[i] = (name == null) ? new InternetAddress(addr.getAddress()) : new InternetAddress(addr.getAddress(), name);
		 }
		 return addrs;
	 }
	 private String parseCharSetFromMimeType(String type) {
		 if (type == null) {
			 return null;
		 }
		 int pos = type.indexOf(""charset"");
		 if (pos < 0) {
			 return null;
		 }
		 StringTokenizer token = new StringTokenizer(type.substring(pos), ""=;
		 "");
		 token.nextToken();
		 return token.nextToken();
	 }
	 private void didntReach(Address addr, String category, MessagingException ex) {
		 String msg = ""Failed to send mail to "" + category + "" address "" + addr + "" because of "" + ex.getMessage();
		 if (task != null) {
			 task.log(msg, Project.MSG_WARN);
		 }
		 else {
			 System.err.println(msg);
		 }
	 }
	 static class SimpleAuthenticator extends Authenticator {
		 private String user = null;
		 private String password = null;
		 public SimpleAuthenticator(String user, String password) {
			 this.user = user;
			 this.password = password;
		 }
		 public PasswordAuthentication getPasswordAuthentication() {
			 return new PasswordAuthentication(user, password);
		 }
	 }
}",0,0,0,0
"TreeNodeChildren(final TreeNode parent, final Object metadata, final PropertyAccessor accessor) {
	 this.parent = parent;
	 this.metadata = metadata;
	 this.accessor = accessor;
	 this.children = new TreeNode[accessor.count()];
	 if (parent.table.valuePolicy == ValueExistencePolicy.COMPACT) {
		 TitleProperty an = accessor.implementation.getAnnotation(TitleProperty.class);
		 if (an == null) {
			 Class<T> implementation = parent.table.standard.getImplementation(accessor.type);
			 if (implementation != null) {
				 an = implementation.getAnnotation(TitleProperty.class);
			 }
		 }
		 if (an != null) {
			 final int index = accessor.indexOf(an.name(), false);
			 final Class<T> type = accessor.type(index, TypeValuePolicy.ELEMENT_TYPE);
			 if (type != null && !parent.isMetadata(type) && type == accessor.type(index, TypeValuePolicy.PROPERTY_TYPE)) {
				 titleProperty = index;
				 return;
			 }
		 }
	 }
	 titleProperty = -1;
 }",0,0,1,0
"public synchronized StringBuffer getText() {
	 return (characters == null) ? new StringBuffer(0) : characters;
 }",0,0,0,0
"public interface ClusterServiceArtifactResponse {
	 ClusterServiceArtifactResponseInfo getClusterServiceArtifactResponseInfo();
	 Map<String, Object> getArtifactData();
	 interface ClusterServiceArtifactResponseInfo {
		 String getArtifactName();
		 String getClusterName();
		 String getServiceName();
	 }
}",0,1,0,0
"private void runBuild(ClassLoader coreLoader) throws BuildException {
	 if (!readyToRun) {
		 return;
	 }
	 final Project project = new Project();
	 project.setCoreLoader(coreLoader);
	 Throwable error = null;
	 try {
		 addBuildListeners(project);
		 addInputHandler(project);
		 PrintStream savedErr = System.err;
		 PrintStream savedOut = System.out;
		 InputStream savedIn = System.in;
		 SecurityManager oldsm = null;
		 oldsm = System.getSecurityManager();
		 try {
			 if (allowInput) {
				 project.setDefaultInputStream(System.in);
			 }
			 System.setIn(new DemuxInputStream(project));
			 System.setOut(new PrintStream(new DemuxOutputStream(project, false)));
			 System.setErr(new PrintStream(new DemuxOutputStream(project, true)));
			 if (!projectHelp) {
				 project.fireBuildStarted();
			 }
			 if (threadPriority != null) {
				 try {
					 project.log(""Setting Ant's thread priority to "" + threadPriority, Project.MSG_VERBOSE);
					 Thread.currentThread().setPriority(threadPriority.intValue());
				 }
				 catch (SecurityException swallowed) {
					 project.log(""A security manager refused to set the -nice value"");
				 }
			 }
			 project.init();
			 PropertyHelper propertyHelper = (PropertyHelper) PropertyHelper.getPropertyHelper(project);
			 HashMap props = new HashMap(definedProps);
			 new ResolvePropertyMap(project, propertyHelper, propertyHelper.getExpanders()) .resolveAllProperties(props, null, false);
			 for (Iterator e = props.entrySet().iterator();
			 e.hasNext();
			 ) {
				 Map.Entry ent = (Map.Entry) e.next();
				 String arg = (String) ent.getKey();
				 Object value = ent.getValue();
				 project.setUserProperty(arg, String.valueOf(value));
			 }
			 project.setUserProperty(MagicNames.ANT_FILE, buildFile.getAbsolutePath());
			 project.setUserProperty(MagicNames.ANT_FILE_TYPE, MagicNames.ANT_FILE_TYPE_FILE);
			 project.setKeepGoingMode(keepGoingMode);
			 if (proxy) {
				 ProxySetup proxySetup = new ProxySetup(project);
				 proxySetup.enableProxies();
			 }
			 ProjectHelper.configureProject(project, buildFile);
			 if (projectHelp) {
				 printDescription(project);
				 printTargets(project, msgOutputLevel > Project.MSG_INFO, msgOutputLevel > Project.MSG_VERBOSE);
				 return;
			 }
			 if (targets.size() == 0) {
				 if (project.getDefaultTarget() != null) {
					 targets.addElement(project.getDefaultTarget());
				 }
			 }
			 project.executeTargets(targets);
		 }
		 finally {
			 if (oldsm != null) {
				 System.setSecurityManager(oldsm);
			 }
			 System.setOut(savedOut);
			 System.setErr(savedErr);
			 System.setIn(savedIn);
		 }
	 }
	 catch (RuntimeException exc) {
		 error = exc;
		 throw exc;
	 }
	 catch (Error e) {
		 error = e;
		 throw e;
	 }
	 finally {
		 if (!projectHelp) {
			 try {
				 project.fireBuildFinished(error);
			 }
			 catch (Throwable t) {
				 System.err.println(""Caught an exception while logging the"" + "" end of the build. Exception was:"");
				 t.printStackTrace();
				 if (error != null) {
					 System.err.println(""There has been an error prior to"" + "" that:"");
					 error.printStackTrace();
				 }
				 throw new BuildException(t);
			 }
		 }
		 else if (error != null) {
			 project.log(error.toString(), Project.MSG_ERR);
		 }
	 }
 }",0,0,1,0
"private void doCleanupCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, NodeId.OneShotRenewer renewer) throws IOException {
	 assert !cfs.isIndex();
	 Table table = cfs.table;
	 Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(table.name);
	 boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();
	 if (ranges.isEmpty()) {
		 logger.info(""Cleanup cannot run before a node has joined the ring"");
		 return;
	 }
	 for (SSTableReader sstable : sstables) {
		 CompactionController controller = new CompactionController(cfs, Collections.singletonList(sstable), getDefaultGcBefore(cfs), false);
		 long startTime = System.currentTimeMillis();
		 long totalkeysWritten = 0;
		 int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(), (int)(SSTableReader.getApproximateKeyCount(Arrays.asList(sstable))));
		 if (logger.isDebugEnabled()) logger.debug(""Expected bloom filter size : "" + expectedBloomFilterSize);
		 SSTableWriter writer = null;
		 SSTableReader newSstable = null;
		 logger.info(""Cleaning up "" + sstable);
		 long expectedRangeFileSize = cfs.getExpectedCompactedFileSize(Arrays.asList(sstable)) / 2;
		 File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(expectedRangeFileSize);
		 if (compactionFileLocation == null) throw new IOException(""disk full"");
		 SSTableScanner scanner = sstable.getDirectScanner();
		 Collection<ByteBuffer> indexedColumns = cfs.indexManager.getIndexedColumns();
		 List<IColumn> indexedColumnsInRow = null;
		 CleanupInfo ci = new CleanupInfo(sstable, scanner);
		 executor.beginCompaction(ci);
		 try {
			 while (scanner.hasNext()) {
				 if (ci.isStopped()) throw new CompactionInterruptedException(ci.getCompactionInfo());
				 SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();
				 if (Range.isInRanges(row.getKey().token, ranges)) {
					 AbstractCompactedRow compactedRow = controller.getCompactedRow(row);
					 if (compactedRow.isEmpty()) continue;
					 writer = maybeCreateWriter(cfs, compactionFileLocation, expectedBloomFilterSize, writer, Collections.singletonList(sstable));
					 writer.append(compactedRow);
					 totalkeysWritten++;
				 }
				 else {
					 cfs.invalidateCachedRow(row.getKey());
					 if (!indexedColumns.isEmpty() || isCommutative) {
						 if (indexedColumnsInRow != null) indexedColumnsInRow.clear();
						 while (row.hasNext()) {
							 IColumn column = row.next();
							 if (column instanceof CounterColumn) renewer.maybeRenew((CounterColumn) column);
							 if (indexedColumns.contains(column.name())) {
								 if (indexedColumnsInRow == null) indexedColumnsInRow = new ArrayList<IColumn>();
								 indexedColumnsInRow.add(column);
							 }
						 }
						 if (indexedColumnsInRow != null && !indexedColumnsInRow.isEmpty()) {
							 Table.switchLock.readLock().lock();
							 try {
								 cfs.indexManager.deleteFromIndexes(row.getKey(), indexedColumnsInRow);
							 }
							 finally {
								 Table.switchLock.readLock().unlock();
							 }
						 }
					 }
				 }
			 }
			 if (writer != null) newSstable = writer.closeAndOpenReader(sstable.maxDataAge);
		 }
		 catch (Exception e) {
			 if (writer != null) writer.abort();
			 throw FBUtilities.unchecked(e);
		 }
		 finally {
			 scanner.close();
			 executor.finishCompaction(ci);
		 }
		 List<SSTableReader> results = new ArrayList<SSTableReader>();
		 if (newSstable != null) {
			 results.add(newSstable);
			 String format = ""Cleaned up to %s. %,d to %,d (~%d%% of original) bytes for %,d keys. Time: %,dms."";
			 long dTime = System.currentTimeMillis() - startTime;
			 long startsize = sstable.onDiskLength();
			 long endsize = newSstable.onDiskLength();
			 double ratio = (double)endsize / (double)startsize;
			 logger.info(String.format(format, writer.getFilename(), startsize, endsize, (int)(ratio*100), totalkeysWritten, dTime));
		 }
		 cfs.indexManager.flushIndexesBlocking();
		 cfs.replaceCompactedSSTables(Arrays.asList(sstable), results, OperationType.CLEANUP);
	 }
 }",0,0,1,0
"private void installExtensions(List<PluginDescriptor> pRegisteredPlugins) throws PluginRuntimeException {
	 for (PluginDescriptor descriptor : pRegisteredPlugins) {
		 for(Extension extension:descriptor.getExtensions()) {
			 String xpId = extension.getTargetPoint();
			 ExtensionPoint point = getExtensionPoint(xpId);
			 if (point == null) {
				 throw new PluginRuntimeException(""Plugin ("" + descriptor.getPluginId() + ""), "" + ""extension point: "" + xpId + "" does not exist."");
			 }
			 point.addExtension(extension);
		 }
	 }
 }",0,0,0,0
"public ListenableFuture<Void> recover(QueueManagingVirtualHost<T> virtualHost) {
	 EventLogger eventLogger = virtualHost.getEventLogger();
	 MessageStore store = virtualHost.getMessageStore();
	 MessageStore.MessageStoreReader storeReader = store.newMessageStoreReader();
	 MessageStoreLogSubject logSubject = new MessageStoreLogSubject(virtualHost.getName(), store.getClass().getSimpleName());
	 Map<Queue<T>, Integer> queueRecoveries = new TreeMap<>();
	 Map<Long, ServerMessage<T>> recoveredMessages = new HashMap<>();
	 Map<Long, StoredMessage<T>> unusedMessages = new TreeMap<>();
	 Map<UUID, Integer> unknownQueuesWithMessages = new HashMap<>();
	 Map<Queue<T>, Integer> queuesWithUnknownMessages = new HashMap<>();
	 eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_START());
	 storeReader.visitMessages(new MessageVisitor(recoveredMessages, unusedMessages));
	 eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_START(null, false));
	 try {
		 storeReader.visitMessageInstances(new MessageInstanceVisitor(virtualHost, store, queueRecoveries, recoveredMessages, unusedMessages, unknownQueuesWithMessages, queuesWithUnknownMessages));
	 }
	 finally {
		 if (!unknownQueuesWithMessages.isEmpty()) {
			 unknownQueuesWithMessages.forEach((queueId, count) -> {
				 LOGGER.info(""Discarded {
				}
				 entry(s) associated with queue id '{
				}
				' as a queue with this "" + ""id does not appear in the configuration."", count, queueId);
			 }
			);
		 }
		 if (!queuesWithUnknownMessages.isEmpty()) {
			 queuesWithUnknownMessages.forEach((queue, count) -> {
				 LOGGER.info(""Discarded {
				}
				 entry(s) associated with queue '{
				}
				' as the referenced message "" + ""does not exist."", count, queue.getName());
			 }
			);
		 }
	 }
	 for(Map.Entry<Queue<T>, Integer> entry : queueRecoveries.entrySet()) {
		 Queue<T> queue = entry.getKey();
		 Integer deliveredCount = entry.getValue();
		 eventLogger.message(logSubject, TransactionLogMessages.RECOVERED(deliveredCount, queue.getName()));
		 eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(queue.getName(), true));
		 queue.completeRecovery();
	 }
	 for (Queue<T> q : virtualHost.getChildren(Queue.class)) {
		 if (!queueRecoveries.containsKey(q)) {
			 q.completeRecovery();
		 }
	 }
	 storeReader.visitDistributedTransactions(new DistributedTransactionVisitor(virtualHost, eventLogger, logSubject, recoveredMessages, unusedMessages));
	 for(StoredMessage<T> m : unusedMessages.values()) {
		 LOGGER.debug(""Message id '{
		}
		' is orphaned, removing"", m.getMessageNumber());
		 m.remove();
	 }
	 if (unusedMessages.size() > 0) {
		 LOGGER.info(""Discarded {
		}
		 orphaned message(s)."", unusedMessages.size());
	 }
	 eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(null, false));
	 eventLogger.message(logSubject, MessageStoreMessages.RECOVERED(recoveredMessages.size() - unusedMessages.size()));
	 eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_COMPLETE());
	 return Futures.immediateFuture(null);
 }",0,0,1,0
"public static class FieldSchemaWrapper {
	 private FieldSchema fieldSchema;
	 public String name;
	 public String type;
	 public String comment;
	 public FieldSchemaWrapper( String name, String type, String comment) {
		 this.name = name;
		 this.type = type;
		 this.comment = comment;
		 this.fieldSchema = new FieldSchema(name, type, comment);
	 }
	 public FieldSchemaWrapper(FieldSchema fieldSchema) {
		 this.fieldSchema = fieldSchema;
		 this.name = fieldSchema.getName();
		 this.type = fieldSchema.getType();
		 this.comment = fieldSchema.getComment();
	 }
	 public FieldSchema getFieldSchema() {
		 return fieldSchema;
	 }
 }",0,1,0,0
"public class TypeCheckingTestUtil {
	 public static org.apache.pig.newplan.logical.relational.LOLoad genDummyLOLoadNewLP( org.apache.pig.newplan.logical.relational.LogicalPlan plan) throws ExecException {
		 String pigStorage = PigStorage.class.getName() ;
		 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
		 pc.connect();
		 org.apache.pig.newplan.logical.relational.LOLoad load = newLOLoad( new FileSpec(""pi"", new FuncSpec(pigStorage)), null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration())) );
		 return load ;
	 }
	 public static Schema genFlatSchema(String[] aliases, byte[] types) {
		 if (aliases.length != types.length) {
			 throw new AssertionError("" aliase number and type number don't match"") ;
		 }
		 List<Schema.FieldSchema> fsList = new ArrayList<Schema.FieldSchema>() ;
		 for(int i=0;
		 i<aliases.length ;
		i++) {
			 fsList.add(new Schema.FieldSchema(aliases[i], types[i])) ;
		 }
		 return new Schema(fsList) ;
	 }
	 public static Schema genFlatSchemaInTuple(String[] aliases, byte[] types) {
		 Schema flatSchema = genFlatSchema(aliases, types);
		 return new Schema(new Schema.FieldSchema(""t"", flatSchema));
	 }
	 public static OperatorKey genNewOperatorKey() {
		 long newId = NodeIdGenerator.getGenerator().getNextNodeId(""scope"") ;
		 return new OperatorKey(""scope"", newId) ;
	 }
	 public static void printTypeGraph(LogicalPlan plan) {
		 System.out.println(""*****Type Graph*******"") ;
		 String rep = plan.toString() ;
		 System.out.println(rep) ;
	 }
	 public static void printMessageCollector(CompilationMessageCollector collector) {
		 if (collector.hasMessage()) {
			 System.out.println(""*****MessageCollector dump*******"") ;
			 Iterator<CompilationMessageCollector.Message> it1 = collector.iterator() ;
			 while (it1.hasNext()) {
				 CompilationMessageCollector.Message msg = it1.next() ;
				 System.out.println(msg.getMessageType() + "":"" + msg.getMessage());
			 }
		 }
	 }
	 public static void printCurrentMethodName() {
		 StackTraceElement e[] = Thread.currentThread().getStackTrace() ;
		 boolean doNext = false;
		 for (StackTraceElement s : e) {
			 if (doNext) {
				 System.out.println(s.getMethodName());
				 return;
			 }
			 doNext = s.getMethodName().equals(""printCurrentMethodName"");
		 }
	 }
	 public static String getCurrentMethodName() {
		 StackTraceElement e[] = Thread.currentThread().getStackTrace() ;
		 boolean doNext = false;
		 for (StackTraceElement s : e) {
			 if (doNext) {
				 return s.getMethodName();
			 }
			 doNext = s.getMethodName().equals(""getCurrentMethodName"");
		 }
		 return null;
	 }
}",1,0,0,0
"public class TezCompiler extends PhyPlanVisitor {
	 private static final Log LOG = LogFactory.getLog(TezCompiler.class);
	 private PigContext pigContext;
	 private Properties pigProperties;
	 private PhysicalPlan plan;
	 private TezOperPlan tezPlan;
	 private TezOperator curTezOp;
	 private TezOperator[] compiledInputs = null;
	 private Map<OperatorKey, TezOperator> splitsSeen;
	 private NodeIdGenerator nig;
	 private String scope;
	 private UDFFinder udfFinder;
	 private Map<PhysicalOperator, TezOperator> phyToTezOpMap;
	 private Map<TezOperator, List<TezOperator>> inputsMap;
	 public static final String USER_COMPARATOR_MARKER = ""user.comparator.func:"";
	 public static final String FILE_CONCATENATION_THRESHOLD = ""pig.files.concatenation.threshold"";
	 public static final String OPTIMISTIC_FILE_CONCATENATION = ""pig.optimistic.files.concatenation"";
	 private int fileConcatenationThreshold = 100;
	 private boolean optimisticFileConcatenation = false;
	 private List<String> readOnceLoadFuncs = null;
	 private Configuration conf;
	 private POLocalRearrangeTezFactory localRearrangeFactory;
	 public TezCompiler(PhysicalPlan plan, PigContext pigContext) throws TezCompilerException {
		 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
		 this.plan = plan;
		 this.pigContext = pigContext;
		 pigProperties = pigContext.getProperties();
		 conf = ConfigurationUtil.toConfiguration(pigProperties, false);
		 splitsSeen = Maps.newHashMap();
		 tezPlan = new TezOperPlan();
		 nig = NodeIdGenerator.getGenerator();
		 udfFinder = new UDFFinder();
		 List<PhysicalOperator> roots = plan.getRoots();
		 if((roots == null) || (roots.size() <= 0)) {
			 int errCode = 2053;
			 String msg = ""Internal error. Did not find roots in the physical plan."";
			 throw new TezCompilerException(msg, errCode, PigException.BUG);
		 }
		 scope = roots.get(0).getOperatorKey().getScope();
		 localRearrangeFactory = new POLocalRearrangeTezFactory(scope, nig);
		 phyToTezOpMap = Maps.newHashMap();
		 inputsMap = Maps.newHashMap();
		 fileConcatenationThreshold = Integer.parseInt(pigProperties .getProperty(FILE_CONCATENATION_THRESHOLD, ""100""));
		 optimisticFileConcatenation = pigProperties.getProperty( OPTIMISTIC_FILE_CONCATENATION, ""false"").equals(""true"");
		 LOG.info(""File concatenation threshold: "" + fileConcatenationThreshold + "" optimistic? "" + optimisticFileConcatenation);
		 String loadFuncs = pigContext.getProperties().getProperty( PigConfiguration.PIG_SORT_READONCE_LOADFUNCS);
		 if (loadFuncs != null && loadFuncs.trim().length() > 0) {
			 readOnceLoadFuncs = Arrays.asList(StringUtils.split(loadFuncs.trim()));
		 }
	 }
	 public TezOperPlan getTezPlan() {
		 return tezPlan;
	 }
	 public TezPlanContainer getPlanContainer() throws PlanException {
		 TezPlanContainer tezPlanContainer = new TezPlanContainer(pigContext);
		 tezPlanContainer.addPlan(tezPlan);
		 return tezPlanContainer;
	 }
	 public TezOperPlan compile() throws IOException, PlanException, VisitorException {
		 List<PhysicalOperator> leaves = plan.getLeaves();
		 if (!pigContext.inIllustrator) {
			 for (PhysicalOperator op : leaves) {
				 if (!(op instanceof POStore)) {
					 int errCode = 2025;
					 String msg = ""Expected leaf of reduce plan to "" + ""always be POStore. Found "" + op.getClass().getSimpleName();
					 throw new TezCompilerException(msg, errCode, PigException.BUG);
				 }
			 }
		 }
		 List<POStore> stores = PlanHelper.getPhysicalOperators(plan, POStore.class);
		 List<PONative> nativeTezs= PlanHelper.getPhysicalOperators(plan, PONative.class);
		 List<PhysicalOperator> ops;
		 if (!pigContext.inIllustrator) {
			 ops = new ArrayList<PhysicalOperator>(stores.size() + nativeTezs.size());
			 ops.addAll(stores);
		 }
		 else {
			 ops = new ArrayList<PhysicalOperator>(leaves.size() + nativeTezs.size());
			 ops.addAll(leaves);
		 }
		 ops.addAll(nativeTezs);
		 Collections.sort(ops);
		 for (PhysicalOperator op : ops) {
			 compile(op);
		 }
		 for (TezOperator tezOper : splitsSeen.values()) {
			 int idx = 0;
			 List<POStore> strs = PlanHelper.getPhysicalOperators(tezOper.plan, POStore.class);
			 for (POStore op : strs) {
				 op.setIndex(idx++);
			 }
			 tezOper.setClosed(true);
		 }
		 fixScalar();
		 return tezPlan;
	 }
	 private void fixScalar() throws VisitorException, PlanException {
		 Map<POStore, POValueOutputTez> storeSeen = new HashMap<POStore, POValueOutputTez>();
		 for (TezOperator tezOp : tezPlan) {
			 List<POUserFunc> userFuncs = PlanHelper.getPhysicalOperators(tezOp.plan, POUserFunc.class);
			 for (POUserFunc userFunc : userFuncs) {
				 if (userFunc.getReferencedOperator()!=null) {
					 POStore store = (POStore)userFunc.getReferencedOperator();
					 TezOperator from = phyToTezOpMap.get(store);
					 FuncSpec newSpec = new FuncSpec(ReadScalarsTez.class.getName(), from.getOperatorKey().toString());
					 userFunc.setFuncSpec(newSpec);
					 if (userFunc.getInputs().size() == 2) {
						 userFunc.getInputs().remove(1);
					 }
					 if (storeSeen.containsKey(store)) {
						 storeSeen.get(store).addOutputKey(tezOp.getOperatorKey().toString());
					 }
					 else {
						 POValueOutputTez output = new POValueOutputTez(OperatorKey.genOpKey(scope));
						 output.setScalarOutput(true);
						 output.addOutputKey(tezOp.getOperatorKey().toString());
						 from.plan.remove(from.plan.getOperator(store.getOperatorKey()));
						 from.plan.addAsLeaf(output);
						 storeSeen.put(store, output);
					 }
					 if (tezPlan.getPredecessors(tezOp)==null || !tezPlan.getPredecessors(tezOp).contains(from)) {
						 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, from, tezOp);
						 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
					 }
				 }
			 }
		 }
	 }
	 private void compile(PhysicalOperator op) throws IOException, PlanException, VisitorException {
		 TezOperator[] prevCompInp = compiledInputs;
		 List<PhysicalOperator> predecessors = plan.getPredecessors(op);
		 if(op instanceof PONative){
		 }
		 else if (predecessors != null && predecessors.size() > 0) {
			 if (op instanceof POLoad) {
				 if (predecessors.size() != 1) {
					 int errCode = 2125;
					 String msg = ""Expected at most one predecessor of load. Got ""+predecessors.size();
					 throw new PlanException(msg, errCode, PigException.BUG);
				 }
				 PhysicalOperator p = predecessors.get(0);
				 TezOperator oper = null;
				 if (p instanceof POStore || p instanceof PONative) {
					 oper = phyToTezOpMap.get(p);
				 }
				 else {
					 int errCode = 2126;
					 String msg = ""Predecessor of load should be a store or native oper. Got "" + p.getClass();
					 throw new PlanException(msg, errCode, PigException.BUG);
				 }
				 curTezOp = getTezOp();
				 curTezOp.plan.add(op);
				 curTezOp.setUseMRMapSettings(true);
				 if (((POLoad) op).getLFile() != null && ((POLoad) op).getLFile().getFuncSpec() != null) {
					 curTezOp.UDFs.add(((POLoad)op).getLFile().getFuncSpec().toString());
				 }
				 tezPlan.add(curTezOp);
				 phyToTezOpMap.put(op, curTezOp);
				 plan.disconnect(op, p);
				 TezCompilerUtil.connect(tezPlan, oper, curTezOp);
				 oper.segmentBelow = true;
				 return;
			 }
			 Collections.sort(predecessors);
			 if(op instanceof POSplit && splitsSeen.containsKey(op.getOperatorKey())){
			 }
			 else {
				 compiledInputs = new TezOperator[predecessors.size()];
				 int i = -1;
				 for (PhysicalOperator pred : predecessors) {
					 compile(pred);
					 compiledInputs[++i] = curTezOp;
				 }
			 }
		 }
		 else {
			 curTezOp = getTezOp();
			 curTezOp.plan.add(op);
			 curTezOp.setUseMRMapSettings(true);
			 if (op !=null && op instanceof POLoad) {
				 if (((POLoad)op).getLFile()!=null && ((POLoad)op).getLFile().getFuncSpec()!=null) curTezOp.UDFs.add(((POLoad)op).getLFile().getFuncSpec().toString());
			 }
			 tezPlan.add(curTezOp);
			 phyToTezOpMap.put(op, curTezOp);
			 return;
		 }
		 op.visit(this);
		 compiledInputs = prevCompInp;
	 }
	 private void nonBlocking(PhysicalOperator op) throws PlanException, IOException {
		 TezOperator tezOp;
		 if (compiledInputs.length == 1) {
			 tezOp = compiledInputs[0];
			 if (tezOp.isClosed()) {
				 int errCode = 2027;
				 String msg = ""Tez operator has been closed. This is unexpected for a merge."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
		 }
		 else {
			 tezOp = merge(compiledInputs);
		 }
		 tezOp.plan.addAsLeaf(op);
		 curTezOp = tezOp;
	 }
	 private void blocking() throws IOException, PlanException {
		 TezOperator newTezOp = getTezOp();
		 tezPlan.add(newTezOp);
		 for (TezOperator tezOp : compiledInputs) {
			 tezOp.setClosed(true);
			 TezCompilerUtil.connect(tezPlan, tezOp, newTezOp);
		 }
		 curTezOp = newTezOp;
	 }
	 private POSplit findPOSplit(TezOperator tezOp, OperatorKey splitKey) throws PlanException {
		 POSplit split = (POSplit) tezOp.plan.getOperator(splitKey);
		 if (split != null) {
			 return split;
		 }
		 else {
			 Stack<POSplit> stack = new Stack<POSplit>();
			 split = (POSplit) tezOp.plan.getLeaves().get(0);
			 stack.push(split);
			 while (!stack.isEmpty()) {
				 split = stack.pop();
				 for (PhysicalPlan plan : split.getPlans()) {
					 PhysicalOperator op = plan.getLeaves().get(0);
					 if (op instanceof POSplit) {
						 split = (POSplit) op;
						 if (split.getOperatorKey().equals(splitKey)) {
							 return split;
						 }
						 else {
							 stack.push(split);
						 }
					 }
				 }
			 }
		 }
		 throw new PlanException( ""Could not find the split operator "" + splitKey, 2059, PigException.BUG);
	 }
	 private TezOperator merge(TezOperator[] compiledInputs) throws PlanException {
		 TezOperator ret = getTezOp();
		 tezPlan.add(ret);
		 Set<TezOperator> toBeConnected = Sets.newHashSet();
		 List<TezOperator> toBeRemoved = Lists.newArrayList();
		 List<PhysicalPlan> toBeMerged = Lists.newArrayList();
		 for (TezOperator tezOp : compiledInputs) {
			 if (!tezOp.isClosed()) {
				 toBeRemoved.add(tezOp);
				 toBeMerged.add(tezOp.plan);
				 List<TezOperator> predecessors = tezPlan.getPredecessors(tezOp);
				 if (predecessors != null) {
					 for (TezOperator predecessorTezOp : predecessors) {
						 toBeConnected.add(predecessorTezOp);
					 }
				 }
			 }
			 else {
				 int errCode = 2027;
				 String msg = ""Tez operator has been closed. This is unexpected for a merge."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
		 }
		 merge(ret.plan, toBeMerged);
		 Iterator<TezOperator> it = toBeConnected.iterator();
		 while (it.hasNext()) {
			 tezPlan.connect(it.next(), ret);
		 }
		 for (TezOperator tezOp : toBeRemoved) {
			 if (tezOp.getRequestedParallelism() > ret.getRequestedParallelism()) {
				 ret.setRequestedParallelism(tezOp.getRequestedParallelism());
			 }
			 for (String udf : tezOp.UDFs) {
				 if (!ret.UDFs.contains(udf)) {
					 ret.UDFs.add(udf);
				 }
			 }
			 for (PhysicalOperator physOp : tezOp.scalars) {
				 if (!ret.scalars.contains(physOp)) {
					 ret.scalars.add(physOp);
				 }
			 }
			 Set<PhysicalOperator> opsToChange = Sets.newHashSet();
			 for (Map.Entry<PhysicalOperator, TezOperator> entry : phyToTezOpMap.entrySet()) {
				 if (entry.getValue()==tezOp) {
					 opsToChange.add(entry.getKey());
				 }
			 }
			 for (PhysicalOperator op : opsToChange) {
				 phyToTezOpMap.put(op, ret);
			 }
			 tezPlan.remove(tezOp);
		 }
		 return ret;
	 }
	 private <O extends Operator<?>, E extends OperatorPlan<O>> void merge( E finPlan, List<E> plans) throws PlanException {
		 for (E e : plans) {
			 finPlan.merge(e);
		 }
	 }
	 private void processUDFs(PhysicalPlan plan) throws VisitorException {
		 if (plan != null) {
			 ScalarPhyFinder scalarPhyFinder = new ScalarPhyFinder(plan);
			 scalarPhyFinder.visit();
			 curTezOp.scalars.addAll(scalarPhyFinder.getScalars());
			 udfFinder.setPlan(plan);
			 udfFinder.visit();
			 curTezOp.UDFs.addAll(udfFinder.getUDFs());
		 }
	 }
	 public void visitCollectedGroup(POCollectedGroup op) throws VisitorException {
		 List<PhysicalOperator> roots = curTezOp.plan.getRoots();
		 if(roots.size() != 1){
			 int errCode = 2171;
			 String errMsg = ""Expected one but found more then one root physical operator in physical plan."";
			 throw new TezCompilerException(errMsg,errCode,PigException.BUG);
		 }
		 PhysicalOperator phyOp = roots.get(0);
		 if(! (phyOp instanceof POLoad)){
			 int errCode = 2172;
			 String errMsg = ""Expected physical operator at root to be POLoad. Found : ""+phyOp.getClass().getCanonicalName();
			 throw new TezCompilerException(errMsg,errCode,PigException.BUG);
		 }
		 LoadFunc loadFunc = ((POLoad)phyOp).getLoadFunc();
		 try {
			 if(!(CollectableLoadFunc.class.isAssignableFrom(loadFunc.getClass()))){
				 int errCode = 2249;
				 throw new TezCompilerException(""While using 'collected' on group;
				 data must be loaded via loader implementing CollectableLoadFunc."", errCode);
			 }
			 ((CollectableLoadFunc)loadFunc).ensureAllKeyInstancesInSameSplit();
		 }
		 catch (TezCompilerException e){
			 throw (e);
		 }
		 catch (IOException e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
		 try{
			 nonBlocking(op);
			 phyToTezOpMap.put(op, curTezOp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitCounter(POCounter op) throws VisitorException {
		 try{
			 curTezOp.markRankCounter();
			 POCounterTez counterTez = new POCounterTez(op);
			 nonBlocking(counterTez);
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitCross(POCross op) throws VisitorException {
		 try{
			 nonBlocking(op);
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitDistinct(PODistinct op) throws VisitorException {
		 try {
			 POLocalRearrangeTez lr = localRearrangeFactory.create();
			 lr.setDistinct(true);
			 lr.copyAliasFrom(op);
			 curTezOp.plan.addAsLeaf(lr);
			 TezOperator lastOp = curTezOp;
			 blocking();
			 TezCompilerUtil.setCustomPartitioner(op.getCustomPartitioner(), curTezOp);
			 TezEdgeDescriptor edge = curTezOp.inEdges.get(lastOp.getOperatorKey());
			 edge.setNeedsDistinctCombiner(true);
			 curTezOp.markDistinct();
			 addDistinctPlan(curTezOp.plan, op.getRequestedParallelism());
			 curTezOp.setRequestedParallelism(op.getRequestedParallelism());
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Cannot compile "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG);
		 }
	 }
	 private void addDistinctPlan(PhysicalPlan plan, int rp) throws PlanException {
		 POPackage pkg = getPackage(1, DataType.TUPLE);
		 pkg.getPkgr().setDistinct(true);
		 plan.addAsLeaf(pkg);
		 POProject project = new POProject(OperatorKey.genOpKey(scope));
		 project.setResultType(DataType.TUPLE);
		 project.setStar(false);
		 project.setColumn(0);
		 project.setOverloaded(false);
		 POForEach forEach = TezCompilerUtil.getForEach(project, rp, scope, nig);
		 plan.addAsLeaf(forEach);
	 }
	 public void visitFilter(POFilter op) throws VisitorException {
		 try {
			 nonBlocking(op);
			 processUDFs(op.getPlan());
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitFRJoin(POFRJoin op) throws VisitorException {
		 try {
			 List<String> inputKeys = Lists.newArrayList();
			 curTezOp = phyToTezOpMap.get(op.getInputs().get(op.getFragment()));
			 for (int i = 0;
			 i < compiledInputs.length;
			 i++) {
				 TezOperator tezOp = compiledInputs[i];
				 if (curTezOp.equals(tezOp)) {
					 continue;
				 }
				 if (!tezOp.isClosed()) {
					 POLocalRearrangeTez lr = new POLocalRearrangeTez(op.getLRs()[i]);
					 lr.setOutputKey(curTezOp.getOperatorKey().toString());
					 lr.setConnectedToPackage(false);
					 tezOp.plan.addAsLeaf(lr);
					 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, tezOp, curTezOp);
					 inputKeys.add(tezOp.getOperatorKey().toString());
					 edge.dataMovementType = DataMovementType.BROADCAST;
					 edge.outputClassName = UnorderedKVOutput.class.getName();
					 edge.inputClassName = UnorderedKVInput.class.getName();
				 }
				 else {
					 int errCode = 2022;
					 String msg = ""The current operator is closed. This is unexpected while compiling."";
					 throw new TezCompilerException(msg, errCode, PigException.BUG);
				 }
			 }
			 if (!curTezOp.isClosed()) {
				 curTezOp.plan.addAsLeaf(new POFRJoinTez(op, inputKeys));
			 }
			 else {
				 int errCode = 2022;
				 String msg = ""The current operator is closed. This is unexpected while compiling."";
				 throw new TezCompilerException(msg, errCode, PigException.BUG);
			 }
			 List<List<PhysicalPlan>> joinPlans = op.getJoinPlans();
			 if (joinPlans != null) {
				 for (List<PhysicalPlan> joinPlan : joinPlans) {
					 if (joinPlan != null) {
						 for (PhysicalPlan plan : joinPlan) {
							 processUDFs(plan);
						 }
					 }
				 }
			 }
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitLimit(POLimit op) throws VisitorException {
		 try {
			 if (op.getLimitPlan() != null) {
				 processUDFs(op.getLimitPlan());
			 }
			 if (!pigContext.inIllustrator) {
				 nonBlocking(op);
				 phyToTezOpMap.put(op, curTezOp);
			 }
			 boolean limitAfterSort = curTezOp.isGlobalSort();
			 if (curTezOp.getRequestedParallelism() == 1 || curTezOp.isUnion()) {
				 boolean canStop = true;
				 for (PhysicalOperator planOp : curTezOp.plan.getRoots()) {
					 if (planOp instanceof POLoad) {
						 canStop = false;
						 break;
					 }
				 }
				 if (canStop) {
					 if (curTezOp.isUnion()) {
						 curTezOp.setRequestedParallelism(1);
					 }
					 curTezOp.setDontEstimateParallelism(true);
					 if (limitAfterSort) {
						 curTezOp.markLimitAfterSort();
					 }
					 else {
						 curTezOp.markLimit();
					 }
					 return;
				 }
			 }
			 POValueOutputTez output = new POValueOutputTez(OperatorKey.genOpKey(scope));
			 output.copyAliasFrom(op);
			 curTezOp.plan.addAsLeaf(output);
			 TezOperator prevOp = curTezOp;
			 blocking();
			 curTezOp.setRequestedParallelism(1);
			 curTezOp.setDontEstimateParallelism(true);
			 output.addOutputKey(curTezOp.getOperatorKey().toString());
			 TezEdgeDescriptor edge = curTezOp.inEdges.get(prevOp.getOperatorKey());
			 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.SCATTER_GATHER);
			 if (limitAfterSort) {
				 curTezOp.markLimitAfterSort();
				 output.setTaskIndexWithRecordIndexAsKey(true);
				 edge.outputClassName = UnorderedKVOutput.class.getName();
				 edge.inputClassName = OrderedGroupedKVInput.class.getName();
				 edge.setIntermediateOutputKeyClass(TezCompilerUtil.TUPLE_CLASS);
				 edge.setIntermediateOutputKeyComparatorClass(PigTupleWritableComparator.class.getName());
			 }
			 else {
				 curTezOp.markLimit();
			 }
			 POValueInputTez input = new POValueInputTez(OperatorKey.genOpKey(scope));
			 input.copyAliasFrom(op);
			 input.setInputKey(prevOp.getOperatorKey().toString());
			 curTezOp.plan.addAsLeaf(input);
			 if (!pigContext.inIllustrator) {
				 POLimit limitCopy = new POLimit(OperatorKey.genOpKey(scope));
				 limitCopy.copyAliasFrom(op);
				 limitCopy.setLimit(op.getLimit());
				 limitCopy.setLimitPlan(op.getLimitPlan());
				 curTezOp.plan.addAsLeaf(limitCopy);
			 }
			 else {
				 curTezOp.plan.addAsLeaf(op);
			 }
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitLoad(POLoad op) throws VisitorException {
		 try {
			 nonBlocking(op);
			 curTezOp.setUseMRMapSettings(true);
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitLocalRearrange(POLocalRearrange op) throws VisitorException {
		 try{
			 POLocalRearrange opTez = new POLocalRearrangeTez(op);
			 nonBlocking(opTez);
			 List<PhysicalPlan> plans = opTez.getPlans();
			 if (plans != null) {
				 for (PhysicalPlan ep : plans) {
					 processUDFs(ep);
				 }
			 }
			 phyToTezOpMap.put(opTez, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitGlobalRearrange(POGlobalRearrange op) throws VisitorException {
		 try {
			 blocking();
			 inputsMap.put(curTezOp, new ArrayList<>(Arrays.asList(compiledInputs)));
			 TezCompilerUtil.setCustomPartitioner(op.getCustomPartitioner(), curTezOp);
			 curTezOp.setRequestedParallelism(op.getRequestedParallelism());
			 if (op.isCross()) {
				 curTezOp.addCrossKey(op.getOperatorKey().toString());
			 }
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitMergeCoGroup(POMergeCogroup poCoGroup) throws VisitorException {
		 POMergeCogroupTez poCoGrp = new POMergeCogroupTez(poCoGroup);
		 if(compiledInputs.length < 2){
			 int errCode=2251;
			 String errMsg = ""Merge Cogroup work on two or more relations."" + ""To use map-side group-by on single relation, use 'collected' qualifier."";
			 throw new TezCompilerException(errMsg, errCode);
		 }
		 List<FuncSpec> funcSpecs = new ArrayList<FuncSpec>(compiledInputs.length-1);
		 List<String> fileSpecs = new ArrayList<String>(compiledInputs.length-1);
		 List<String> loaderSigns = new ArrayList<String>(compiledInputs.length-1);
		 try{
			 poCoGrp.setEndOfRecordMark(POStatus.STATUS_NULL);
			 for(int i=0 ;
			 i < compiledInputs.length;
			 i++){
				 TezOperator tezOper = compiledInputs[i];
				 PhysicalPlan plan = tezOper.plan;
				 if(plan.getRoots().size() != 1){
					 int errCode = 2171;
					 String errMsg = ""Expected one but found more then one root physical operator in physical plan."";
					 throw new TezCompilerException(errMsg,errCode,PigException.BUG);
				 }
				 PhysicalOperator rootPOOp = plan.getRoots().get(0);
				 if(! (rootPOOp instanceof POLoad)){
					 int errCode = 2172;
					 String errMsg = ""Expected physical operator at root to be POLoad. Found : ""+rootPOOp.getClass().getCanonicalName();
					 throw new TezCompilerException(errMsg,errCode);
				 }
				 POLoad sideLoader = (POLoad)rootPOOp;
				 FileSpec loadFileSpec = sideLoader.getLFile();
				 FuncSpec funcSpec = loadFileSpec.getFuncSpec();
				 LoadFunc loadfunc = sideLoader.getLoadFunc();
				 if(i == 0){
					 if(!(CollectableLoadFunc.class.isAssignableFrom(loadfunc.getClass()))){
						 int errCode = 2252;
						 throw new TezCompilerException(""Base loader in Cogroup must implement CollectableLoadFunc."", errCode);
					 }
					 ((CollectableLoadFunc)loadfunc).ensureAllKeyInstancesInSameSplit();
					 continue;
				 }
				 if(!(IndexableLoadFunc.class.isAssignableFrom(loadfunc.getClass()))){
					 int errCode = 2253;
					 throw new TezCompilerException(""Side loaders in cogroup must implement IndexableLoadFunc."", errCode);
				 }
				 funcSpecs.add(funcSpec);
				 fileSpecs.add(loadFileSpec.getFileName());
				 loaderSigns.add(sideLoader.getSignature());
				 tezPlan.remove(tezOper);
			 }
			 poCoGrp.setSideLoadFuncs(funcSpecs);
			 poCoGrp.setSideFileSpecs(fileSpecs);
			 poCoGrp.setLoaderSignatures(loaderSigns);
			 TezOperator baseMROp = phyToTezOpMap.get(poCoGrp.getInputs().get(0));
			 if(baseMROp.isClosed()){
				 int errCode = 2254;
				 throw new TezCompilerException(""Currently merged cogroup is not supported after blocking operators."", errCode);
			 }
			 TezOperator indexerTezOp = getTezOp();
			 configureIndexerOp(indexerTezOp, baseMROp, poCoGrp);
			 baseMROp.plan.addAsLeaf(poCoGrp);
			 baseMROp.markMergeCogroup();
			 for (FuncSpec funcSpec : funcSpecs) baseMROp.UDFs.add(funcSpec.toString());
			 phyToTezOpMap.put(poCoGrp, baseMROp);
			 curTezOp = baseMROp;
		 }
		 catch (ExecException e) {
			 throw new TezCompilerException(e.getDetailedMessage(), e.getErrorCode(), e.getErrorSource(), e);
		 }
		 catch (TezCompilerException mrce) {
			 throw (mrce);
		 }
		 catch (CloneNotSupportedException e) {
			 throw new TezCompilerException(e);
		 }
		 catch (PlanException e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + poCoGrp.getClass().getCanonicalName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
		 catch (IOException e) {
			 int errCode = 3000;
			 String errMsg = ""IOException caught while compiling POMergeCoGroup"";
			 throw new TezCompilerException(errMsg, errCode, e);
		 }
	 }
	 private void configureIndexerOp(TezOperator indexerTezOp, final TezOperator baseTezOp, final POMergeCogroupTez poCoGrp) throws TezCompilerException, PlanException, ExecException, IOException, CloneNotSupportedException {
		 PhysicalPlan basePlan = baseTezOp.plan;
		 POLoad baseLoader = (POLoad)basePlan.getRoots().get(0);
		 FileSpec origLoaderFileSpec = baseLoader.getLFile();
		 FuncSpec funcSpec = origLoaderFileSpec.getFuncSpec();
		 LoadFunc loadFunc = baseLoader.getLoadFunc();
		 if (! (OrderedLoadFunc.class.isAssignableFrom(loadFunc.getClass()))){
			 int errCode = 1104;
			 String errMsg = ""Base relation of merge-coGroup must implement "" + ""OrderedLoadFunc interface. The specified loader "" + funcSpec + "" doesn't implement it"";
			 throw new TezCompilerException(errMsg,errCode);
		 }
		 String[] indexerArgs = new String[6];
		 indexerArgs[0] = funcSpec.toString();
		 indexerArgs[1] = ObjectSerializer.serialize((Serializable) poCoGrp.getLRInnerPlansOf(0));
		 indexerArgs[3] = baseLoader.getSignature();
		 indexerArgs[4] = baseLoader.getOperatorKey().scope;
		 indexerArgs[5] = Boolean.toString(false);
		 PhysicalPlan phyPlan;
		 if (basePlan.getSuccessors(baseLoader) == null || basePlan.getSuccessors(baseLoader).isEmpty()){
			 phyPlan = null;
		 }
		 else{
			 phyPlan = basePlan.clone();
			 PhysicalOperator root = phyPlan.getRoots().get(0);
			 phyPlan.disconnect(root, phyPlan.getSuccessors(root).get(0));
			 phyPlan.remove(root);
		 }
		 indexerArgs[2] = ObjectSerializer.serialize(phyPlan);
		 POLoad idxJobLoader = new POLoad(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 idxJobLoader.copyAliasFrom(baseLoader);
		 idxJobLoader.setPc(pigContext);
		 idxJobLoader.setIsTmpLoad(true);
		 idxJobLoader.setLFile(new FileSpec(origLoaderFileSpec.getFileName(), new FuncSpec(MergeJoinIndexer.class.getName(), indexerArgs)));
		 indexerTezOp.plan.add(idxJobLoader);
		 indexerTezOp.UDFs.add(baseLoader.getLFile().getFuncSpec().toString());
		 TezOperator indexAggrOper = getTezOp();
		 tezPlan.add(indexAggrOper);
		 tezPlan.add(indexerTezOp);
		 TezCompilerUtil.simpleConnectTwoVertex(tezPlan, indexerTezOp, indexAggrOper, scope, nig);
		 indexerTezOp.setRequestedParallelism(1);
		 indexerTezOp.setDontEstimateParallelism(true);
		 POValueOutputTez indexAggrOperOutput = new POValueOutputTez(OperatorKey.genOpKey(scope));
		 indexAggrOper.plan.addAsLeaf(indexAggrOperOutput);
		 indexAggrOperOutput.addOutputKey(baseTezOp.getOperatorKey().toString());
		 indexAggrOper.markIndexer();
		 indexAggrOper.setClosed(true);
		 TezEdgeDescriptor edge = new TezEdgeDescriptor();
		 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
		 TezCompilerUtil.connect(tezPlan, indexAggrOper, baseTezOp, edge);
		 poCoGrp.setInputKey(indexAggrOper.getOperatorKey().toString());
	 }
	 public void visitMergeJoin(POMergeJoin joinOp) throws VisitorException {
		 try{
			 if (compiledInputs.length != 2 || joinOp.getInputs().size() != 2) {
				 int errCode=1101;
				 throw new TezCompilerException(""Merge Join must have exactly two inputs. Found : ""+compiledInputs.length, errCode);
			 }
			 curTezOp = phyToTezOpMap.get(joinOp.getInputs().get(0));
			 TezOperator rightTezOpr = null;
			 TezOperator rightTezOprAggr = null;
			 if (curTezOp.equals(compiledInputs[0])) {
				 rightTezOpr = compiledInputs[1];
			 }
			 else {
				 rightTezOpr = compiledInputs[0];
			 }
			 PhysicalPlan rightPipelinePlan;
			 if(!rightTezOpr.closed){
				 PhysicalPlan rightPlan = rightTezOpr.plan;
				 if(rightPlan.getRoots().size() != 1){
					 int errCode = 2171;
					 String errMsg = ""Expected one but found more then one root physical operator in physical plan."";
					 throw new TezCompilerException(errMsg,errCode,PigException.BUG);
				 }
				 PhysicalOperator rightLoader = rightPlan.getRoots().get(0);
				 if(! (rightLoader instanceof POLoad)){
					 int errCode = 2172;
					 String errMsg = ""Expected physical operator at root to be POLoad. Found : ""+rightLoader.getClass().getCanonicalName();
					 throw new TezCompilerException(errMsg,errCode);
				 }
				 if (rightPlan.getSuccessors(rightLoader) == null || rightPlan.getSuccessors(rightLoader).isEmpty()) rightPipelinePlan = null;
				 else{
					 rightPipelinePlan = rightPlan.clone();
					 PhysicalOperator root = rightPipelinePlan.getRoots().get(0);
					 rightPipelinePlan.disconnect(root, rightPipelinePlan.getSuccessors(root).get(0));
					 rightPipelinePlan.remove(root);
					 rightPlan.trimBelow(rightLoader);
				 }
			 }
			 else{
				 int errCode = 2022;
				 String msg = ""Right input plan have been closed. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 joinOp.setupRightPipeline(rightPipelinePlan);
			 POLoad rightLoader = (POLoad)rightTezOpr.plan.getRoots().get(0);
			 joinOp.setSignature(rightLoader.getSignature());
			 LoadFunc rightLoadFunc = rightLoader.getLoadFunc();
			 List<String> udfs = new ArrayList<String>();
			 if(IndexableLoadFunc.class.isAssignableFrom(rightLoadFunc.getClass())) {
				 joinOp.setRightLoaderFuncSpec(rightLoader.getLFile().getFuncSpec());
				 joinOp.setRightInputFileName(rightLoader.getLFile().getFileName());
				 udfs.add(rightLoader.getLFile().getFuncSpec().toString());
				 tezPlan.remove(rightTezOpr);
				 if(rightTezOpr == compiledInputs[0]) {
					 compiledInputs[0] = null;
				 }
				 else if(rightTezOpr == compiledInputs[1]) {
					 compiledInputs[1] = null;
				 }
				 rightTezOpr = null;
				 int numInputs = mPlan.getPredecessors(joinOp).size();
				 for(int i = 0;
				 i < numInputs;
				 i++) {
					 List<PhysicalPlan> keyPlans = joinOp.getInnerPlansOf(i);
					 for (PhysicalPlan keyPlan : keyPlans) {
						 for(PhysicalOperator op : keyPlan) {
							 if(!(op instanceof POProject)) {
								 int errCode = 1106;
								 String errMsg = ""Merge join is possible only for simple column or '*' join keys when using "" + rightLoader.getLFile().getFuncSpec() + "" as the loader"";
								 throw new TezCompilerException(errMsg, errCode, PigException.INPUT);
							 }
						 }
					 }
				 }
			 }
			 else {
				 joinOp = new POMergeJoinTez(joinOp);
				 LoadFunc loadFunc = rightLoader.getLoadFunc();
				 if (joinOp.getJoinType() == LOJoin.JOINTYPE.MERGESPARSE) {
					 int errCode = 1104;
					 String errMsg = ""Right input of merge-join must implement IndexableLoadFunc. "" + ""The specified loader "" + loadFunc + "" doesn't implement it"";
					 throw new TezCompilerException(errMsg,errCode);
				 }
				 if (! (OrderedLoadFunc.class.isAssignableFrom(loadFunc.getClass()))){
					 int errCode = 1104;
					 String errMsg = ""Right input of merge-join must implement "" + ""OrderedLoadFunc interface. The specified loader "" + loadFunc + "" doesn't implement it"";
					 throw new TezCompilerException(errMsg,errCode);
				 }
				 String[] indexerArgs = new String[6];
				 List<PhysicalPlan> rightInpPlans = joinOp.getInnerPlansOf(1);
				 FileSpec origRightLoaderFileSpec = rightLoader.getLFile();
				 indexerArgs[0] = origRightLoaderFileSpec.getFuncSpec().toString();
				 indexerArgs[1] = ObjectSerializer.serialize((Serializable)rightInpPlans);
				 indexerArgs[2] = ObjectSerializer.serialize(rightPipelinePlan);
				 indexerArgs[3] = rightLoader.getSignature();
				 indexerArgs[4] = rightLoader.getOperatorKey().scope;
				 indexerArgs[5] = Boolean.toString(true);
				 FileSpec lFile = new FileSpec(rightLoader.getLFile().getFileName(),new FuncSpec(MergeJoinIndexer.class.getName(), indexerArgs));
				 rightLoader.setLFile(lFile);
				 rightTezOprAggr = getTezOp();
				 tezPlan.add(rightTezOprAggr);
				 TezCompilerUtil.simpleConnectTwoVertex(tezPlan, rightTezOpr, rightTezOprAggr, scope, nig);
				 rightTezOprAggr.setRequestedParallelism(1);
				 rightTezOprAggr.setDontEstimateParallelism(true);
				 POValueOutputTez rightTezOprAggrOutput = new POValueOutputTez(OperatorKey.genOpKey(scope));
				 rightTezOprAggr.plan.addAsLeaf(rightTezOprAggrOutput);
				 rightTezOprAggrOutput.addOutputKey(curTezOp.getOperatorKey().toString());
				 TezEdgeDescriptor edge = new TezEdgeDescriptor();
				 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
				 TezCompilerUtil.connect(tezPlan, rightTezOprAggr, curTezOp, edge);
				 ((POMergeJoinTez) joinOp).setInputKey(rightTezOprAggr.getOperatorKey().toString());
				 String[] tezIndexableLoaderArgs = new String[3];
				 tezIndexableLoaderArgs[0] = origRightLoaderFileSpec.getFuncSpec().toString();
				 tezIndexableLoaderArgs[1] = joinOp.getOperatorKey().scope;
				 tezIndexableLoaderArgs[2] = origRightLoaderFileSpec.getFileName();
				 joinOp.setRightLoaderFuncSpec( (new FuncSpec(TezIndexableLoader.class.getName(), tezIndexableLoaderArgs)));
				 joinOp.setRightInputFileName(origRightLoaderFileSpec.getFileName());
				 udfs.add(origRightLoaderFileSpec.getFuncSpec().toString());
			 }
			 if(joinOp.getJoinType() == LOJoin.JOINTYPE.MERGESPARSE) {
				 curTezOp.markMergeSparseJoin();
			 }
			 else {
				 curTezOp.markMergeJoin();
			 }
			 if (!curTezOp.isClosed()) {
				 curTezOp.plan.addAsLeaf(joinOp);
			 }
			 else{
				 int errCode = 2022;
				 String msg = ""Input plan has been closed. This is unexpected while compiling."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 if(rightTezOprAggr != null) {
				 rightTezOprAggr.markIndexer();
			 }
			 phyToTezOpMap.put(joinOp, curTezOp);
			 curTezOp.noCombineSmallSplits();
			 curTezOp.UDFs.addAll(udfs);
		 }
		 catch(PlanException e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + joinOp.getClass().getCanonicalName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
		 catch (IOException e){
			 int errCode = 3000;
			 String errMsg = ""IOException caught while compiling POMergeJoin"";
			 throw new TezCompilerException(errMsg, errCode,e);
		 }
		 catch(CloneNotSupportedException e){
			 int errCode = 2127;
			 String errMsg = ""Cloning exception caught while compiling POMergeJoin"";
			 throw new TezCompilerException(errMsg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitNative(PONative op) throws VisitorException {
		 try{
			 curTezOp.segmentBelow = true;
			 TezOperator nativeTezOper = new NativeTezOper(new OperatorKey(scope,nig.getNextNodeId(scope)), op.getNativeMRjar(), op.getParams());
			 tezPlan.add(nativeTezOper);
			 curTezOp.setClosed(true);
			 tezPlan.connect(curTezOp, nativeTezOper);
			 phyToTezOpMap.put(op, nativeTezOper);
			 nativeTezOper.setClosed(true);
			 nativeTezOper.segmentBelow = true;
			 nativeTezOper.markNative();
			 curTezOp = nativeTezOper;
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitPackage(POPackage op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 phyToTezOpMap.put(op, curTezOp);
			 if (op.getPkgr().getPackageType() == PackageType.JOIN) {
				 curTezOp.markRegularJoin();
			 }
			 else if (op.getPkgr().getPackageType() == PackageType.GROUP) {
				 if (op.getNumInps() == 1) {
					 curTezOp.markGroupBy();
				 }
				 else if (op.getNumInps() > 1) {
					 curTezOp.markCogroup();
				 }
			 }
			 else if (op.getPkgr().getPackageType() == PackageType.BLOOMJOIN) {
				 curTezOp.markRegularJoin();
				 addBloomToJoin(op, curTezOp);
			 }
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 private void addBloomToJoin(POPackage op, TezOperator curTezOp) throws PlanException {
		 List<TezOperator> inputs = inputsMap.get(curTezOp);
		 TezOperator buildBloomOp;
		 List<TezOperator> applyBloomOps = new ArrayList<>();
		 String strategy = conf.get(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, POBuildBloomRearrangeTez.DEFAULT_BLOOM_STRATEGY);
		 boolean createBloomInMap = ""map"".equals(strategy);
		 if (!createBloomInMap && !strategy.equals(""reduce"")) {
			 throw new PlanException(new IllegalArgumentException( ""Invalid value for "" + PigConfiguration.PIG_BLOOMJOIN_STRATEGY + "" - "" + strategy + "". Valid values are map and reduce""));
		 }
		 int numHash = conf.getInt(PigConfiguration.PIG_BLOOMJOIN_HASH_FUNCTIONS, POBuildBloomRearrangeTez.DEFAULT_NUM_BLOOM_HASH_FUNCTIONS);
		 int vectorSizeBytes = conf.getInt(PigConfiguration.PIG_BLOOMJOIN_VECTORSIZE_BYTES, POBuildBloomRearrangeTez.DEFAULT_BLOOM_VECTOR_SIZE_BYTES);
		 int numBloomFilters = POBuildBloomRearrangeTez.getNumBloomFilters(conf);
		 int hashType = Hash.parseHashType(conf.get(PigConfiguration.PIG_BLOOMJOIN_HASH_TYPE, POBuildBloomRearrangeTez.DEFAULT_BLOOM_HASH_TYPE));
		 boolean[] inner = op.getPkgr().getInner();
		 boolean skipNullKeys = true;
		 if (inner[inner.length - 1]) {
			 buildBloomOp = inputs.get(inputs.size() - 1);
			 for (int i = 0;
			 i < (inner.length - 1);
			 i++) {
				 applyBloomOps.add(inputs.get(i));
			 }
			 skipNullKeys = inner[0];
		 }
		 else {
			 skipNullKeys = false;
			 buildBloomOp = inputs.get(0);
			 for (int i = 1;
			 i < inner.length;
			 i++) {
				 applyBloomOps.add(inputs.get(i));
			 }
		 }
		 POLocalRearrangeTez lr = (POLocalRearrangeTez) buildBloomOp.plan.getLeaves().get(0);
		 POBuildBloomRearrangeTez bbr = new POBuildBloomRearrangeTez(lr, createBloomInMap, numBloomFilters, vectorSizeBytes, numHash, hashType);
		 bbr.setSkipNullKeys(skipNullKeys);
		 buildBloomOp.plan.remove(lr);
		 buildBloomOp.plan.addAsLeaf(bbr);
		 TezOperator combineBloomOp = getTezOp();
		 tezPlan.add(combineBloomOp);
		 combineBloomOp.markBuildBloom();
		 combineBloomOp.setEstimatedParallelism(numBloomFilters);
		 combineBloomOp.setDontEstimateParallelism(true);
		 String combineBloomOpKey = combineBloomOp.getOperatorKey().toString();
		 TezEdgeDescriptor edge = new TezEdgeDescriptor();
		 TezCompilerUtil.connect(tezPlan, buildBloomOp, combineBloomOp, edge);
		 bbr.setBloomOutputKey(combineBloomOpKey);
		 POPackage pkg = new POPackage(OperatorKey.genOpKey(scope));
		 pkg.setNumInps(1);
		 BloomPackager pkgr = new BloomPackager(createBloomInMap, numBloomFilters, vectorSizeBytes, numHash, hashType);
		 pkg.setPkgr(pkgr);
		 POValueOutputTez combineBloomOutput = new POValueOutputTez(OperatorKey.genOpKey(scope));
		 combineBloomOp.plan.addAsLeaf(pkg);
		 combineBloomOp.plan.addAsLeaf(combineBloomOutput);
		 if (createBloomInMap) {
			 pkgr.setKeyType(DataType.INTEGER);
			 edge.setIntermediateOutputKeyClass(NullableIntWritable.class.getName());
			 edge.setIntermediateOutputKeyComparatorClass( PigWritableComparators.PigIntRawBytesComparator.class.getName());
			 POPackage pkg_c = new POPackage(OperatorKey.genOpKey(scope));
			 pkg_c.setPkgr(new BloomPackager(createBloomInMap, numBloomFilters, vectorSizeBytes, numHash, hashType));
			 pkg_c.getPkgr().setKeyType(DataType.INTEGER);
			 pkg_c.setNumInps(1);
			 edge.combinePlan.addAsLeaf(pkg_c);
			 POProject prjKey = new POProject(OperatorKey.genOpKey(scope));
			 prjKey.setResultType(DataType.INTEGER);
			 List<PhysicalPlan> clrInps = new ArrayList<PhysicalPlan>();
			 PhysicalPlan pp = new PhysicalPlan();
			 pp.add(prjKey);
			 clrInps.add(pp);
			 POLocalRearrangeTez clr = localRearrangeFactory.create(0, LocalRearrangeType.WITHPLAN, clrInps, DataType.INTEGER);
			 clr.setOutputKey(combineBloomOpKey);
			 edge.combinePlan.addAsLeaf(clr);
			 edge.setCombinerInMap(false);
			 edge.setCombinerInReducer(true);
		 }
		 else {
			 pkgr.setKeyType(DataType.BYTEARRAY);
			 edge.setIntermediateOutputKeyClass(NullableBytesWritable.class.getName());
			 edge.setIntermediateOutputKeyComparatorClass(PigWritableComparators.PigBytesRawBytesComparator.class.getName());
			 edge.partitionerClass = BloomFilterPartitioner.class;
			 edge.setNeedsDistinctCombiner(!conf.getBoolean(PigConfiguration.PIG_BLOOMJOIN_NOCOMBINER, false));
		 }
		 for (TezOperator applyBloomOp : applyBloomOps) {
			 applyBloomOp.markFilterBloom();
			 lr = (POLocalRearrangeTez) applyBloomOp.plan.getLeaves().get(0);
			 POBloomFilterRearrangeTez bfr = new POBloomFilterRearrangeTez(lr, numBloomFilters);
			 applyBloomOp.plan.remove(lr);
			 applyBloomOp.plan.addAsLeaf(bfr);
			 bfr.setInputKey(combineBloomOpKey);
			 edge = new TezEdgeDescriptor();
			 edge.setIntermediateOutputKeyClass(NullableIntWritable.class.getName());
			 edge.setIntermediateOutputKeyComparatorClass(PigWritableComparators.PigIntRawBytesComparator.class.getName());
			 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
			 TezCompilerUtil.connect(tezPlan, combineBloomOp, applyBloomOp, edge);
			 combineBloomOutput.addOutputKey(applyBloomOp.getOperatorKey().toString());
		 }
	 }
	 public void visitPOForEach(POForEach op) throws VisitorException{
		 try{
			 nonBlocking(op);
			 List<PhysicalPlan> plans = op.getInputPlans();
			 if (plans != null) {
				 for (PhysicalPlan ep : plans) {
					 processUDFs(ep);
				 }
			 }
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitRank(PORank op) throws VisitorException {
		 try{
			 TezOperator counterOper = curTezOp;
			 POCounterTez counterTez = (POCounterTez) counterOper.plan.getLeaves().get(0);
			 TezOperator statsOper = getTezOp();
			 tezPlan.add(statsOper);
			 POCounterStatsTez counterStatsTez = new POCounterStatsTez(OperatorKey.genOpKey(scope));
			 statsOper.plan.addAsLeaf(counterStatsTez);
			 statsOper.setRequestedParallelism(1);
			 statsOper.setDontEstimateParallelism(true);
			 TezOperator rankOper = getTezOp();
			 tezPlan.add(rankOper);
			 PORankTez rankTez = new PORankTez(op);
			 rankOper.plan.addAsLeaf(rankTez);
			 curTezOp = rankOper;
			 rankOper.setRequestedParallelismByReference(counterOper);
			 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, counterOper, rankOper);
			 rankOper.setUseMRMapSettings(counterOper.isUseMRMapSettings());
			 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.ONE_TO_ONE);
			 counterTez.setTuplesOutputKey(rankOper.getOperatorKey().toString());
			 rankTez.setTuplesInputKey(counterOper.getOperatorKey().toString());
			 edge = TezCompilerUtil.connect(tezPlan, counterOper, statsOper);
			 edge.setIntermediateOutputKeyClass(IntWritable.class.getName());
			 edge.partitionerClass = HashPartitioner.class;
			 edge.setIntermediateOutputValueClass(LongWritable.class.getName());
			 counterTez.setStatsOutputKey(statsOper.getOperatorKey().toString());
			 counterStatsTez.setInputKey(counterOper.getOperatorKey().toString());
			 edge = TezCompilerUtil.connect(tezPlan, statsOper, rankOper);
			 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
			 counterStatsTez.setOutputKey(rankOper.getOperatorKey().toString());
			 rankTez.setStatsInputKey(statsOper.getOperatorKey().toString());
			 phyToTezOpMap.put(op, rankOper);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitSkewedJoin(POSkewedJoin op) throws VisitorException {
		 try {
			 POLocalRearrangeTez lrTez = new POLocalRearrangeTez(OperatorKey.genOpKey(scope));
			 POLocalRearrangeTez lrTezSample = localRearrangeFactory.create(LocalRearrangeType.NULL);
			 int sampleRate = POPoissonSample.DEFAULT_SAMPLE_RATE;
			 if (pigProperties.containsKey(PigConfiguration.PIG_POISSON_SAMPLER_SAMPLE_RATE)) {
				 sampleRate = Integer.valueOf(pigProperties.getProperty(PigConfiguration.PIG_POISSON_SAMPLER_SAMPLE_RATE));
			 }
			 float heapPerc = PartitionSkewedKeys.DEFAULT_PERCENT_MEMUSAGE;
			 if (pigProperties.containsKey(PigConfiguration.PIG_SKEWEDJOIN_REDUCE_MEMUSAGE)) {
				 heapPerc = Float.valueOf(pigProperties.getProperty(PigConfiguration.PIG_SKEWEDJOIN_REDUCE_MEMUSAGE));
			 }
			 long totalMemory = -1;
			 if (pigProperties.containsKey(PigConfiguration.PIG_SKEWEDJOIN_REDUCE_MEM)) {
				 totalMemory = Long.valueOf(pigProperties.getProperty(PigConfiguration.PIG_SKEWEDJOIN_REDUCE_MEM));
			 }
			 POPoissonSample poSample = new POPoissonSample(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, sampleRate, heapPerc, totalMemory);
			 TezOperator samplerOper = compiledInputs[0];
			 boolean writeDataForPartitioner = shouldWriteDataForPartitioner(samplerOper);
			 PhysicalPlan partitionerPlan = null;
			 if (writeDataForPartitioner) {
				 samplerOper.plan.addAsLeaf(lrTez);
			 }
			 else {
				 partitionerPlan = samplerOper.plan.clone();
				 partitionerPlan.addAsLeaf(lrTez);
			 }
			 samplerOper.plan.addAsLeaf(poSample);
			 samplerOper.markSampler();
			 MultiMap<PhysicalOperator, PhysicalPlan> joinPlans = op.getJoinPlans();
			 List<PhysicalOperator> l = plan.getPredecessors(op);
			 List<PhysicalPlan> groups = joinPlans.get(l.get(0));
			 List<Boolean> ascCol = new ArrayList<Boolean>();
			 for (int i=0;
			 i< groups.size();
			 i++) {
				 ascCol.add(false);
			 }
			 List<PhysicalPlan> transformPlans = new ArrayList<PhysicalPlan>();
			 transformPlans.addAll(groups);
			 POProject prjStar = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prjStar.setResultType(DataType.TUPLE);
			 prjStar.setStar(true);
			 List<PhysicalOperator> ufInps = new ArrayList<PhysicalOperator>();
			 ufInps.add(prjStar);
			 PhysicalPlan ep = new PhysicalPlan();
			 POUserFunc uf = new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ufInps, new FuncSpec(GetMemNumRows.class.getName(), (String[])null));
			 uf.setResultType(DataType.TUPLE);
			 ep.add(uf);
			 ep.add(prjStar);
			 ep.connect(prjStar, uf);
			 transformPlans.add(ep);
			 List<Boolean> flat1 = new ArrayList<Boolean>();
			 List<PhysicalPlan> eps1 = new ArrayList<PhysicalPlan>();
			 for (int i=0;
			 i<transformPlans.size();
			 i++) {
				 eps1.add(transformPlans.get(i));
				 flat1.add(i == transformPlans.size() - 1 ? true : false);
			 }
			 POForEach nfe1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, eps1, flat1);
			 samplerOper.plan.addAsLeaf(nfe1);
			 samplerOper.plan.addAsLeaf(lrTezSample);
			 samplerOper.setClosed(true);
			 int rp = op.getRequestedParallelism();
			 if (rp == -1) {
				 rp = pigContext.defaultParallel;
			 }
			 POSort sort = new POSort(op.getOperatorKey(), rp, null, groups, ascCol, null);
			 String per = pigProperties.getProperty(""pig.skewedjoin.reduce.memusage"", String.valueOf(PartitionSkewedKeys.DEFAULT_PERCENT_MEMUSAGE));
			 String mc = pigProperties.getProperty(""pig.skewedjoin.reduce.maxtuple"", ""0"");
			 Pair<TezOperator, Integer> sampleJobPair = getSamplingAggregationJob(sort, rp, null, PartitionSkewedKeysTez.class.getName(), new String[]{
			per, mc}
			);
			 rp = sampleJobPair.second;
			 TezOperator[] joinJobs = new TezOperator[] {
			null, compiledInputs[1], null}
			;
			 TezOperator[] joinInputs = new TezOperator[] {
			compiledInputs[0], compiledInputs[1]}
			;
			 TezOperator[] rearrangeOutputs = new TezOperator[2];
			 compiledInputs = new TezOperator[] {
			joinInputs[0]}
			;
			 curTezOp = getTezOp();
			 tezPlan.add(curTezOp);
			 joinJobs[0] = curTezOp;
			 try {
				 lrTez.setIndex(0);
			 }
			 catch (ExecException e) {
				 int errCode = 2058;
				 String msg = ""Unable to set index on newly created POLocalRearrange."";
				 throw new PlanException(msg, errCode, PigException.BUG, e);
			 }
			 byte type = DataType.TUPLE;
			 if (groups.size() == 1) {
				 type = groups.get(0).getLeaves().get(0).getResultType();
			 }
			 lrTez.setKeyType(type);
			 lrTez.setPlans(groups);
			 lrTez.setResultType(DataType.TUPLE);
			 POLocalRearrangeTez partitionerLR = null;
			 if (!writeDataForPartitioner) {
				 joinJobs[0].plan = partitionerPlan;
				 partitionerLR = lrTez;
				 lrTez.setSkewedJoin(true);
			 }
			 else {
				 partitionerLR = new POIdentityInOutTez( OperatorKey.genOpKey(scope), lrTez, samplerOper.getOperatorKey().toString());
				 partitionerLR.setSkewedJoin(true);
				 joinJobs[0].plan.addAsLeaf(partitionerLR);
				 lrTez.setOutputKey(joinJobs[0].getOperatorKey().toString());
				 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, samplerOper, joinJobs[0]);
				 edge.dataMovementType = DataMovementType.ONE_TO_ONE;
				 edge.outputClassName = UnorderedKVOutput.class.getName();
				 edge.inputClassName = UnorderedKVInput.class.getName();
				 joinJobs[0].setRequestedParallelismByReference(samplerOper);
			 }
			 joinJobs[0].setClosed(true);
			 joinJobs[0].markSampleBasedPartitioner();
			 joinJobs[0].setUseMRMapSettings(samplerOper.isUseMRMapSettings());
			 rearrangeOutputs[0] = joinJobs[0];
			 compiledInputs = new TezOperator[] {
			joinInputs[1]}
			;
			 POPartitionRearrangeTez pr = new POPartitionRearrangeTez(OperatorKey.genOpKey(scope));
			 try {
				 pr.setIndex(1);
			 }
			 catch (ExecException e) {
				 int errCode = 2058;
				 String msg = ""Unable to set index on newly created POPartitionRearrange."";
				 throw new PlanException(msg, errCode, PigException.BUG, e);
			 }
			 groups = joinPlans.get(l.get(1));
			 pr.setPlans(groups);
			 pr.setKeyType(type);
			 pr.setSkewedJoin(true);
			 pr.setResultType(DataType.TUPLE);
			 joinJobs[1].plan.addAsLeaf(pr);
			 joinJobs[1].setClosed(true);
			 rearrangeOutputs[1] = joinJobs[1];
			 compiledInputs = rearrangeOutputs;
			 POGlobalRearrange gr = new POGlobalRearrange(OperatorKey.genOpKey(scope), rp);
			 gr.setResultType(DataType.TUPLE);
			 gr.visit(this);
			 joinJobs[2] = curTezOp;
			 joinJobs[2].setRequestedParallelism(rp);
			 compiledInputs = new TezOperator[] {
			joinJobs[2]}
			;
			 POPackage pkg = getPackage(2, type);
			 pkg.setResultType(DataType.TUPLE);
			 boolean [] inner = op.getInnerFlags();
			 pkg.getPkgr().setInner(inner);
			 pkg.visit(this);
			 compiledInputs = new TezOperator[] {
			curTezOp}
			;
			 List<PhysicalPlan> eps = new ArrayList<PhysicalPlan>();
			 List<Boolean> flat = new ArrayList<Boolean>();
			 boolean containsRightOuter = false;
			 for (int i=0;
			 i < 2;
			 i++) {
				 ep = new PhysicalPlan();
				 POProject prj = new POProject(OperatorKey.genOpKey(scope));
				 prj.setColumn(i+1);
				 prj.setOverloaded(false);
				 prj.setResultType(DataType.BAG);
				 ep.add(prj);
				 eps.add(ep);
				 if (!inner[i]) {
					 if (i == 0) {
						 containsRightOuter = true;
						 CompilerUtils.addEmptyBagOuterJoin(ep, op.getSchema(i), true, IsFirstReduceOfKeyTez.class.getName());
					 }
					 else {
						 CompilerUtils.addEmptyBagOuterJoin(ep, op.getSchema(i), false, IsFirstReduceOfKeyTez.class.getName());
					 }
				 }
				 flat.add(true);
			 }
			 POForEach fe = new POForEach(OperatorKey.genOpKey(scope), -1, eps, flat);
			 fe.setResultType(DataType.TUPLE);
			 fe.visit(this);
			 lrTezSample.setOutputKey(sampleJobPair.first.getOperatorKey().toString());
			 partitionerLR.setOutputKey(joinJobs[2].getOperatorKey().toString());
			 pr.setOutputKey(joinJobs[2].getOperatorKey().toString());
			 TezCompilerUtil.connect(tezPlan, samplerOper, sampleJobPair.first);
			 POValueOutputTez sampleOut = (POValueOutputTez) sampleJobPair.first.plan.getLeaves().get(0);
			 for (int i = 0;
			 i <= 2;
			 i++) {
				 if (i != 2 || containsRightOuter) {
					 joinJobs[i].setSampleOperator(sampleJobPair.first);
					 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, sampleJobPair.first, joinJobs[i]);
					 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
					 sampleOut.addOutputKey(joinJobs[i].getOperatorKey().toString());
				 }
				 if (i != 2) {
					 TezEdgeDescriptor edge = joinJobs[2].inEdges.get(joinJobs[i].getOperatorKey());
					 edge.partitionerClass = SkewedPartitionerTez.class;
				 }
			 }
			 joinJobs[2].markSkewedJoin();
			 sampleJobPair.first.setSortOperator(joinJobs[2]);
			 if (rp == -1) {
				 sampleJobPair.first.setNeedEstimatedQuantile(true);
			 }
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public static FileSpec getTempFileSpec(PigContext pigContext) throws IOException {
		 return new FileSpec(FileLocalizer.getTemporaryPath(pigContext).toString(), new FuncSpec(Utils.getTmpFileCompressorName(pigContext)));
	 }
	 private boolean shouldWriteDataForPartitioner(TezOperator samplerOper) {
		 boolean writeDataForPartitioner = false;
		 if (samplerOper.plan.getRoots().get(0) instanceof POLoad) {
			 for (PhysicalOperator oper : samplerOper.plan) {
				 if (oper instanceof POForEach) {
					 continue;
				 }
				 else if (oper instanceof POLoad && oper.getInputs() == null) {
					 String loadFunc = ((POLoad) oper).getLoadFunc().getClass().getName();
					 if (readOnceLoadFuncs == null || !readOnceLoadFuncs.contains(loadFunc)) {
						 continue;
					 }
				 }
				 writeDataForPartitioner = true;
				 break;
			 }
		 }
		 else {
			 writeDataForPartitioner = true;
		 }
		 return writeDataForPartitioner;
	 }
	 private POLocalRearrangeTez getLocalRearrangeForSortInput(POSort sort, byte keyType, Pair<POProject, Byte>[] fields) throws PlanException {
		 POLocalRearrangeTez lr = new POLocalRearrangeTez(OperatorKey.genOpKey(scope));
		 List<PhysicalPlan> eps = new ArrayList<PhysicalPlan>();
		 if (fields == null) {
			 PhysicalPlan ep = new PhysicalPlan();
			 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prj.setStar(true);
			 prj.setOverloaded(false);
			 prj.setResultType(DataType.TUPLE);
			 ep.add(prj);
			 eps.add(ep);
		 }
		 else {
			 eps.addAll(sort.getSortPlans());
		 }
		 try {
			 lr.setIndex(0);
		 }
		 catch (ExecException e) {
			 int errCode = 2058;
			 String msg = ""Unable to set index on newly created POLocalRearrange."";
			 throw new PlanException(msg, errCode, PigException.BUG, e);
		 }
		 lr.setKeyType((fields == null || fields.length>1) ? DataType.TUPLE : keyType);
		 lr.setPlans(eps);
		 lr.setResultType(DataType.TUPLE);
		 lr.addOriginalLocation(sort.getAlias(), sort.getOriginalLocations());
		 return lr;
	 }
	 private POLocalRearrangeTez addSamplingToSortInput(POSort sort, TezOperator oper, byte keyType, Pair<POProject, Byte>[] fields) throws PlanException {
		 POLocalRearrangeTez lrSample = localRearrangeFactory.create(LocalRearrangeType.NULL);
		 if (!oper.isClosed()) {
			 List<Boolean> flat1 = new ArrayList<Boolean>();
			 List<PhysicalPlan> eps1 = new ArrayList<PhysicalPlan>();
			 Pair<POProject, Byte>[] sortProjs = null;
			 try{
				 sortProjs = getSortCols(sort.getSortPlans());
			 }
			catch(Exception e) {
				 throw new RuntimeException(e);
			 }
			 if (sortProjs == null) {
				 PhysicalPlan ep = new PhysicalPlan();
				 POProject prj = new POProject(new OperatorKey(scope, nig.getNextNodeId(scope)));
				 prj.setStar(true);
				 prj.setOverloaded(false);
				 prj.setResultType(DataType.TUPLE);
				 ep.add(prj);
				 eps1.add(ep);
				 flat1.add(false);
			 }
			 else {
				 for (Pair<POProject, Byte> sortProj : sortProjs) {
					 if(sortProj == null){
						 int errCode = 2174;
						 String msg = ""Internal exception. Could not create a sampler job"";
						 throw new PlanException(msg, errCode, PigException.BUG);
					 }
					 PhysicalPlan ep = new PhysicalPlan();
					 POProject prj;
					 try {
						 prj = sortProj.first.clone();
					 }
					 catch (CloneNotSupportedException e) {
						 throw new AssertionError( ""Error cloning project caught exception"" + e );
					 }
					 ep.add(prj);
					 eps1.add(ep);
					 flat1.add(false);
				 }
			 }
			 String numSamples = pigContext.getProperties().getProperty(PigConfiguration.PIG_RANDOM_SAMPLER_SAMPLE_SIZE, ""100"");
			 POReservoirSample poSample = new POReservoirSample(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, null, Integer.parseInt(numSamples));
			 oper.plan.addAsLeaf(poSample);
			 List<PhysicalPlan> sortPlans = sort.getSortPlans();
			 List<PhysicalPlan> transformPlans = new ArrayList<PhysicalPlan>();
			 transformPlans.addAll(sortPlans);
			 POProject prjStar = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prjStar.setResultType(DataType.TUPLE);
			 prjStar.setStar(true);
			 List<PhysicalOperator> ufInps = new ArrayList<PhysicalOperator>();
			 ufInps.add(prjStar);
			 PhysicalPlan ep = new PhysicalPlan();
			 POUserFunc uf = new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ufInps, new FuncSpec(GetMemNumRows.class.getName(), (String[])null));
			 uf.setResultType(DataType.TUPLE);
			 ep.add(uf);
			 ep.add(prjStar);
			 ep.connect(prjStar, uf);
			 transformPlans.add(ep);
			 flat1 = new ArrayList<Boolean>();
			 eps1 = new ArrayList<PhysicalPlan>();
			 for (int i=0;
			 i<transformPlans.size();
			 i++) {
				 eps1.add(transformPlans.get(i));
				 if (i<sortPlans.size()) {
					 flat1.add(false);
				 }
				 else {
					 flat1.add(true);
				 }
			 }
			 POForEach nfe1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, eps1, flat1);
			 oper.plan.addAsLeaf(nfe1);
			 lrSample.setOutputKey(curTezOp.getOperatorKey().toString());
			 oper.plan.addAsLeaf(lrSample);
		 }
		 else {
			 int errCode = 2022;
			 String msg = ""The current operator is closed. This is unexpected while compiling."";
			 throw new PlanException(msg, errCode, PigException.BUG);
		 }
		 oper.markSampler();
		 return lrSample;
	 }
	 private Pair<TezOperator,Integer> getOrderbySamplingAggregationJob( POSort inpSort, int rp) throws PlanException, VisitorException, ExecException {
		 POSort sort = new POSort(inpSort.getOperatorKey(), inpSort .getRequestedParallelism(), null, inpSort.getSortPlans(), inpSort.getMAscCols(), inpSort.getMSortFunc());
		 sort.addOriginalLocation(inpSort.getAlias(), inpSort.getOriginalLocations());
		 List<Boolean> ascCols = inpSort.getMAscCols();
		 String[] ascs = new String[ascCols.size()];
		 for (int i = 0;
		 i < ascCols.size();
		 i++) ascs[i] = ascCols.get(i).toString();
		 String[] ctorArgs = ascs;
		 if(sort.isUDFComparatorUsed) {
			 String userComparatorFuncSpec = sort.getMSortFunc().getFuncSpec().toString();
			 ctorArgs = new String[ascs.length + 1];
			 ctorArgs[0] = USER_COMPARATOR_MARKER + userComparatorFuncSpec;
			 for(int j = 0;
			 j < ascs.length;
			 j++) {
				 ctorArgs[j+1] = ascs[j];
			 }
		 }
		 return getSamplingAggregationJob(sort, rp, null, FindQuantilesTez.class.getName(), ctorArgs);
	 }
	 private Pair<TezOperator,Integer> getSamplingAggregationJob(POSort sort, int rp, List<PhysicalPlan> sortKeyPlans, String udfClassName, String[] udfArgs) throws PlanException, VisitorException, ExecException {
		 TezOperator oper = getTezOp();
		 tezPlan.add(oper);
		 POPackage pkg = getPackage(1, DataType.BYTEARRAY);
		 oper.plan.add(pkg);
		 PhysicalPlan fe2Plan = new PhysicalPlan();
		 POProject topPrj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 topPrj.setColumn(1);
		 topPrj.setResultType(DataType.BAG);
		 topPrj.setOverloaded(true);
		 fe2Plan.add(topPrj);
		 List<PhysicalPlan> nesSortPlanLst = new ArrayList<PhysicalPlan>();
		 if (sortKeyPlans != null) {
			 for(int i=0;
			 i<sortKeyPlans.size();
			 i++) {
				 nesSortPlanLst.add(sortKeyPlans.get(i));
			 }
		 }
		else{
			 Pair<POProject, Byte>[] sortProjs = null;
			 try{
				 sortProjs = getSortCols(sort.getSortPlans());
			 }
			catch(Exception e) {
				 throw new RuntimeException(e);
			 }
			 if (sortProjs == null) {
				 PhysicalPlan ep = new PhysicalPlan();
				 POProject prj = new POProject(new OperatorKey(scope, nig.getNextNodeId(scope)));
				 prj.setStar(true);
				 prj.setOverloaded(false);
				 prj.setResultType(DataType.TUPLE);
				 ep.add(prj);
				 nesSortPlanLst.add(ep);
			 }
			 else {
				 for (int i=0;
				 i<sortProjs.length;
				 i++) {
					 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
					 prj.setResultType(sortProjs[i].second);
					 if(sortProjs[i].first != null && sortProjs[i].first.isProjectToEnd()){
						 if(i != sortProjs.length -1){
							 throw new AssertionError(""Project-range to end (x..)"" + "" is supported in order-by only as last sort column"");
						 }
						 prj.setProjectToEnd(i);
						 break;
					 }
					 else{
						 prj.setColumn(i);
					 }
					 prj.setOverloaded(false);
					 PhysicalPlan ep = new PhysicalPlan();
					 ep.add(prj);
					 nesSortPlanLst.add(ep);
				 }
			 }
		 }
		 sort.setSortPlans(nesSortPlanLst);
		 sort.setResultType(DataType.BAG);
		 fe2Plan.add(sort);
		 fe2Plan.connect(topPrj, sort);
		 PhysicalPlan rpep = new PhysicalPlan();
		 ConstantExpression rpce = new ConstantExpression(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 rpce.setRequestedParallelism(rp);
		 rpce.setValue(rp);
		 rpce.setResultType(DataType.INTEGER);
		 rpep.add(rpce);
		 List<PhysicalPlan> genEps = new ArrayList<PhysicalPlan>();
		 genEps.add(rpep);
		 genEps.add(fe2Plan);
		 List<Boolean> flattened2 = new ArrayList<Boolean>();
		 flattened2.add(false);
		 flattened2.add(false);
		 POForEach nfe2 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1, genEps, flattened2);
		 oper.plan.add(nfe2);
		 oper.plan.connect(pkg, nfe2);
		 PhysicalPlan ep4 = new PhysicalPlan();
		 POProject prjStar4 = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 prjStar4.setResultType(DataType.TUPLE);
		 prjStar4.setStar(true);
		 ep4.add(prjStar4);
		 List<PhysicalOperator> ufInps = new ArrayList<PhysicalOperator>();
		 ufInps.add(prjStar4);
		 POUserFunc uf = new POUserFunc(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ufInps, new FuncSpec(udfClassName, udfArgs));
		 ep4.add(uf);
		 ep4.connect(prjStar4, uf);
		 List<PhysicalPlan> ep4s = new ArrayList<PhysicalPlan>();
		 ep4s.add(ep4);
		 List<Boolean> flattened3 = new ArrayList<Boolean>();
		 flattened3.add(false);
		 POForEach nfe3 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, ep4s, flattened3);
		 oper.plan.add(nfe3);
		 oper.plan.connect(nfe2, nfe3);
		 POValueOutputTez sampleOut = new POValueOutputTez(OperatorKey.genOpKey(scope));
		 oper.plan.add(sampleOut);
		 oper.plan.connect(nfe3, sampleOut);
		 oper.setClosed(true);
		 oper.setRequestedParallelism(1);
		 oper.setDontEstimateParallelism(true);
		 oper.markSampleAggregation();
		 return new Pair<TezOperator, Integer>(oper, rp);
	 }
	 private static class FindKeyTypeVisitor extends PhyPlanVisitor {
		 byte keyType = DataType.UNKNOWN;
		 FindKeyTypeVisitor(PhysicalPlan plan) {
			 super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
		 }
		 public void visitProject(POProject p) throws VisitorException {
			 keyType = p.getResultType();
		 }
	 }
	 public static Pair<POProject,Byte> [] getSortCols(List<PhysicalPlan> plans) throws PlanException {
		 if(plans!=null){
			 Pair<POProject,Byte>[] ret = new Pair[plans.size()];
			 int i=-1;
			 for (PhysicalPlan plan : plans) {
				 PhysicalOperator op = plan.getLeaves().get(0);
				 POProject proj;
				 if (op instanceof POProject) {
					 if (((POProject)op).isStar()) return null;
					 proj = (POProject)op;
				 }
				 else {
					 proj = null;
				 }
				 byte type = op.getResultType();
				 ret[++i] = new Pair<POProject, Byte>(proj, type);
			 }
			 return ret;
		 }
		 int errCode = 2026;
		 String msg = ""No expression plan found in POSort."";
		 throw new PlanException(msg, errCode, PigException.BUG);
	 }
	 private TezOperator[] getSortJobs( TezOperator inputOper, PhysicalPlan partitionerPlan, POLocalRearrangeTez inputOperRearrange, POSort sort, byte keyType, Pair<POProject, Byte>[] fields) throws PlanException{
		 TezOperator[] opers = new TezOperator[2];
		 TezOperator oper1 = getTezOp();
		 tezPlan.add(oper1);
		 opers[0] = oper1;
		 POLocalRearrangeTez partitionerLR = null;
		 if (partitionerPlan != null) {
			 oper1.plan = partitionerPlan;
			 partitionerLR = inputOperRearrange;
		 }
		 else {
			 partitionerLR = new POIdentityInOutTez( OperatorKey.genOpKey(scope), inputOperRearrange, inputOper.getOperatorKey().toString());
			 oper1.plan.addAsLeaf(partitionerLR);
		 }
		 oper1.setClosed(true);
		 oper1.markSampleBasedPartitioner();
		 TezOperator oper2 = getTezOp();
		 partitionerLR.setOutputKey(oper2.getOperatorKey().toString());
		 oper2.markGlobalSort();
		 opers[1] = oper2;
		 tezPlan.add(oper2);
		 long limit = sort.getLimit();
		 boolean[] sortOrder;
		 List<Boolean> sortOrderList = sort.getMAscCols();
		 if(sortOrderList != null) {
			 sortOrder = new boolean[sortOrderList.size()];
			 for(int i = 0;
			 i < sortOrderList.size();
			 ++i) {
				 sortOrder[i] = sortOrderList.get(i);
			 }
			 oper2.setSortOrder(sortOrder);
		 }
		 if (limit!=-1) {
			 POPackage pkg_c = new POPackage(OperatorKey.genOpKey(scope));
			 pkg_c.setPkgr(new LitePackager());
			 pkg_c.getPkgr().setKeyType((fields == null || fields.length > 1) ? DataType.TUPLE : keyType);
			 pkg_c.setNumInps(1);
			 oper2.inEdges.put(oper1.getOperatorKey(), new TezEdgeDescriptor());
			 PhysicalPlan combinePlan = oper2.inEdges.get(oper1.getOperatorKey()).combinePlan;
			 combinePlan.add(pkg_c);
			 List<PhysicalPlan> eps_c1 = new ArrayList<PhysicalPlan>();
			 List<Boolean> flat_c1 = new ArrayList<Boolean>();
			 PhysicalPlan ep_c1 = new PhysicalPlan();
			 POProject prj_c1 = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 prj_c1.setColumn(1);
			 prj_c1.setOverloaded(false);
			 prj_c1.setResultType(DataType.BAG);
			 ep_c1.add(prj_c1);
			 eps_c1.add(ep_c1);
			 flat_c1.add(true);
			 POForEach fe_c1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)), -1, eps_c1, flat_c1);
			 fe_c1.setResultType(DataType.TUPLE);
			 combinePlan.addAsLeaf(fe_c1);
			 POLimit pLimit = new POLimit(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 pLimit.setLimit(limit);
			 combinePlan.addAsLeaf(pLimit);
			 List<PhysicalPlan> eps_c2 = new ArrayList<PhysicalPlan>();
			 eps_c2.addAll(sort.getSortPlans());
			 POLocalRearrangeTez lr_c2 = new POLocalRearrangeTez(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 lr_c2.setOutputKey(oper2.getOperatorKey().toString());
			 try {
				 lr_c2.setIndex(0);
			 }
			 catch (ExecException e) {
				 int errCode = 2058;
				 String msg = ""Unable to set index on newly created POLocalRearrange."";
				 throw new PlanException(msg, errCode, PigException.BUG, e);
			 }
			 lr_c2.setKeyType((fields.length>1) ? DataType.TUPLE : keyType);
			 lr_c2.setPlans(eps_c2);
			 lr_c2.setResultType(DataType.TUPLE);
			 combinePlan.addAsLeaf(lr_c2);
		 }
		 POPackage pkg = new POPackage(OperatorKey.genOpKey(scope));
		 pkg.setPkgr(new LitePackager());
		 pkg.getPkgr().setKeyType((fields == null || fields.length > 1) ? DataType.TUPLE : keyType);
		 pkg.setNumInps(1);
		 oper2.plan.add(pkg);
		 PhysicalPlan ep = new PhysicalPlan();
		 POProject prj = new POProject(new OperatorKey(scope,nig.getNextNodeId(scope)));
		 prj.setColumn(1);
		 prj.setOverloaded(false);
		 prj.setResultType(DataType.BAG);
		 ep.add(prj);
		 List<PhysicalPlan> eps2 = new ArrayList<PhysicalPlan>();
		 eps2.add(ep);
		 List<Boolean> flattened = new ArrayList<Boolean>();
		 flattened.add(true);
		 POForEach nfe1 = new POForEach(new OperatorKey(scope,nig.getNextNodeId(scope)),-1,eps2,flattened);
		 oper2.plan.add(nfe1);
		 oper2.plan.connect(pkg, nfe1);
		 if (limit!=-1) {
			 POLimit pLimit2 = new POLimit(new OperatorKey(scope,nig.getNextNodeId(scope)));
			 pLimit2.setLimit(limit);
			 oper2.plan.addAsLeaf(pLimit2);
		 }
		 return opers;
	 }
	 public void visitSort(POSort op) throws VisitorException {
		 try{
			 if (compiledInputs.length > 1) {
				 int errCode = 2023;
				 String msg = ""Received a multi input plan when expecting only a single input one."";
				 throw new PlanException(msg, errCode, PigException.BUG);
			 }
			 Pair<POProject, Byte>[] fields = getSortCols(op.getSortPlans());
			 byte keyType = DataType.UNKNOWN;
			 try {
				 FindKeyTypeVisitor fktv = new FindKeyTypeVisitor(op.getSortPlans().get(0));
				 fktv.visit();
				 keyType = fktv.keyType;
			 }
			 catch (VisitorException ve) {
				 int errCode = 2035;
				 String msg = ""Internal error. Could not compute key type of sort operator."";
				 throw new PlanException(msg, errCode, PigException.BUG, ve);
			 }
			 TezOperator samplerOper = compiledInputs[0];
			 boolean writeDataForPartitioner = shouldWriteDataForPartitioner(samplerOper);
			 POLocalRearrangeTez lr = getLocalRearrangeForSortInput(op, keyType, fields);
			 PhysicalPlan partitionerPlan = null;
			 if (writeDataForPartitioner) {
				 samplerOper.plan.addAsLeaf(lr);
			 }
			 else {
				 partitionerPlan = samplerOper.plan.clone();
				 partitionerPlan.addAsLeaf(lr);
			 }
			 int rp = op.getRequestedParallelism();
			 if (rp == -1) {
				 rp = pigContext.defaultParallel;
			 }
			 POLocalRearrangeTez lrSample = addSamplingToSortInput(op, samplerOper, keyType, fields);
			 Pair<TezOperator, Integer> quantJobParallelismPair = getOrderbySamplingAggregationJob(op, rp);
			 TezCompilerUtil.connect(tezPlan, samplerOper, quantJobParallelismPair.first);
			 TezOperator[] sortOpers = getSortJobs(samplerOper, partitionerPlan, lr, op, keyType, fields);
			 sortOpers[0].setUseMRMapSettings(samplerOper.isUseMRMapSettings());
			 if (writeDataForPartitioner) {
				 lr.setOutputKey(sortOpers[0].getOperatorKey().toString());
				 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, samplerOper, sortOpers[0]);
				 edge.dataMovementType = DataMovementType.ONE_TO_ONE;
				 edge.outputClassName = UnorderedKVOutput.class.getName();
				 edge.inputClassName = UnorderedKVInput.class.getName();
				 sortOpers[0].setRequestedParallelismByReference(samplerOper);
			 }
			 if (rp == -1) {
				 quantJobParallelismPair.first.setNeedEstimatedQuantile(true);
			 }
			 quantJobParallelismPair.first.setSortOperator(sortOpers[1]);
			 sortOpers[1].setRequestedParallelism(quantJobParallelismPair.second);
			 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, quantJobParallelismPair.first, sortOpers[0]);
			 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.BROADCAST);
			 POValueOutputTez sampleOut = (POValueOutputTez)quantJobParallelismPair.first.plan.getLeaves().get(0);
			 sampleOut.addOutputKey(sortOpers[0].getOperatorKey().toString());
			 sortOpers[0].setSampleOperator(quantJobParallelismPair.first);
			 lrSample.setOutputKey(quantJobParallelismPair.first.getOperatorKey().toString());
			 edge = TezCompilerUtil.connect(tezPlan, sortOpers[0], sortOpers[1]);
			 edge.partitionerClass = WeightedRangePartitionerTez.class;
			 curTezOp = sortOpers[1];
			 if (op.isLimited() && rp != 1) {
				 POValueOutputTez output = new POValueOutputTez(OperatorKey.genOpKey(scope));
				 output.copyAliasFrom(op);
				 sortOpers[1].plan.addAsLeaf(output);
				 TezOperator limitOper = getTezOp();
				 tezPlan.add(limitOper);
				 curTezOp = limitOper;
				 limitOper.setRequestedParallelism(1);
				 limitOper.setDontEstimateParallelism(true);
				 limitOper.markLimitAfterSort();
				 edge = TezCompilerUtil.connect(tezPlan, sortOpers[1], limitOper);
				 output.addOutputKey(limitOper.getOperatorKey().toString());
				 output.setTaskIndexWithRecordIndexAsKey(true);
				 edge = curTezOp.inEdges.get(sortOpers[1].getOperatorKey());
				 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.SCATTER_GATHER);
				 edge.outputClassName = UnorderedKVOutput.class.getName();
				 edge.inputClassName = OrderedGroupedKVInput.class.getName();
				 edge.setIntermediateOutputKeyClass(TezCompilerUtil.TUPLE_CLASS);
				 edge.setIntermediateOutputKeyComparatorClass(PigTupleWritableComparator.class.getName());
				 POValueInputTez input = new POValueInputTez(OperatorKey.genOpKey(scope));
				 input.copyAliasFrom(op);
				 input.setInputKey(sortOpers[1].getOperatorKey().toString());
				 curTezOp.plan.addAsLeaf(input);
				 POLimit limit = new POLimit(OperatorKey.genOpKey(scope));
				 limit.setLimit(op.getLimit());
				 curTezOp.plan.addAsLeaf(limit);
			 }
			 phyToTezOpMap.put(op, curTezOp);
		 }
		catch(Exception e){
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitSplit(POSplit op) throws VisitorException {
		 try {
			 TezOperator splitOp = curTezOp;
			 POValueOutputTez output = null;
			 if (splitsSeen.containsKey(op.getOperatorKey())) {
				 splitOp = splitsSeen.get(op.getOperatorKey());
				 output = (POValueOutputTez)splitOp.plan.getLeaves().get(0);
			 }
			 else {
				 splitsSeen.put(op.getOperatorKey(), splitOp);
				 splitOp.setSplitter(true);
				 phyToTezOpMap.put(op, splitOp);
				 output = new POValueOutputTez(OperatorKey.genOpKey(scope));
				 output.copyAliasFrom(op);
				 splitOp.plan.addAsLeaf(output);
			 }
			 curTezOp = getTezOp();
			 curTezOp.setSplitParent(splitOp.getOperatorKey());
			 tezPlan.add(curTezOp);
			 output.addOutputKey(curTezOp.getOperatorKey().toString());
			 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, splitOp, curTezOp);
			 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.ONE_TO_ONE);
			 curTezOp.setRequestedParallelismByReference(splitOp);
			 POValueInputTez input = new POValueInputTez(OperatorKey.genOpKey(scope));
			 input.copyAliasFrom(op);
			 input.setInputKey(splitOp.getOperatorKey().toString());
			 curTezOp.plan.addAsLeaf(input);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitStore(POStore op) throws VisitorException {
		 try {
			 POStoreTez store = new POStoreTez(op);
			 nonBlocking(store);
			 phyToTezOpMap.put(op, curTezOp);
			 if (store.getSFile()!=null && store.getSFile().getFuncSpec()!=null) curTezOp.UDFs.add(store.getSFile().getFuncSpec().toString());
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitStream(POStream op) throws VisitorException {
		 try {
			 nonBlocking(op);
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch(Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 public void visitUnion(POUnion op) throws VisitorException {
		 try {
			 TezOperator unionTezOp = getTezOp();
			 tezPlan.add(unionTezOp);
			 unionTezOp.markUnion();
			 unionTezOp.setRequestedParallelism(op.getRequestedParallelism());
			 POShuffledValueInputTez unionInput = new POShuffledValueInputTez(OperatorKey.genOpKey(scope));
			 unionTezOp.plan.addAsLeaf(unionInput);
			 POValueOutputTez[] outputs = new POValueOutputTez[compiledInputs.length];
			 for (int i = 0;
			 i < compiledInputs.length;
			 i++) {
				 TezOperator prevTezOp = compiledInputs[i];
				 unionTezOp.addUnionPredecessor(prevTezOp.getOperatorKey());
				 TezEdgeDescriptor edge = TezCompilerUtil.connect(tezPlan, prevTezOp, unionTezOp);
				 TezCompilerUtil.configureValueOnlyTupleOutput(edge, DataMovementType.SCATTER_GATHER);
				 outputs[i] = new POValueOutputTez(OperatorKey.genOpKey(scope));
				 outputs[i].addOutputKey(unionTezOp.getOperatorKey().toString());
				 unionInput.addInputKey(prevTezOp.getOperatorKey().toString());
				 prevTezOp.plan.addAsLeaf(outputs[i]);
				 prevTezOp.setClosed(true);
				 if (prevTezOp.isUseMRMapSettings()) {
					 unionTezOp.setUseMRMapSettings(true);
				 }
			 }
			 curTezOp = unionTezOp;
			 phyToTezOpMap.put(op, curTezOp);
		 }
		 catch (Exception e) {
			 int errCode = 2034;
			 String msg = ""Error compiling operator "" + op.getClass().getSimpleName();
			 throw new TezCompilerException(msg, errCode, PigException.BUG, e);
		 }
	 }
	 private POPackage getPackage(int numOfInputs, byte keyType) {
		 boolean[] inner = new boolean[numOfInputs];
		 POPackage pkg = new POPackage(OperatorKey.genOpKey(scope));
		 pkg.getPkgr().setInner(inner);
		 pkg.getPkgr().setKeyType(keyType);
		 pkg.setNumInps(numOfInputs);
		 return pkg;
	 }
	 private TezOperator getTezOp() {
		 return new TezOperator(OperatorKey.genOpKey(scope));
	 }
}",1,0,0,0
"public Z getMinimum(){
	return minimum;
}",0,0,0,0
"public class Configuration {
	 private static final Log LOG = LogFactory.getLog(""org.apache.hadoop.conf.Configuration"");
	 private boolean quietmode = false;
	 private ArrayList defaultResources = new ArrayList();
	 private ArrayList finalResources = new ArrayList();
	 private Properties properties;
	 private Properties overlay;
	 private ClassLoader classLoader;
	 {
		 classLoader = Thread.currentThread().getContextClassLoader();
		 if (classLoader == null) {
			 classLoader = Configuration.class.getClassLoader();
		 }
	 }
	 public Configuration() {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(StringUtils.stringifyException(new IOException(""config()"")));
		 }
		 defaultResources.add(""hadoop-default.xml"");
		 finalResources.add(""hadoop-site.xml"");
	 }
	 public Configuration(Configuration other) {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(StringUtils.stringifyException (new IOException(""config(config)"")));
		 }
		 this.defaultResources = (ArrayList)other.defaultResources.clone();
		 this.finalResources = (ArrayList)other.finalResources.clone();
		 if (other.properties != null) this.properties = (Properties)other.properties.clone();
		 if(other.overlay!=null) this.overlay = (Properties)other.overlay.clone();
	 }
	 public void addDefaultResource(String name) {
		 addResource(defaultResources, name);
	 }
	 public void addDefaultResource(URL url) {
		 addResource(defaultResources, url);
	 }
	 public void addDefaultResource(Path file) {
		 addResource(defaultResources, file);
	 }
	 public void addFinalResource(String name) {
		 addResource(finalResources, name);
	 }
	 public void addFinalResource(URL url) {
		 addResource(finalResources, url);
	 }
	 public void addFinalResource(Path file) {
		 addResource(finalResources, file);
	 }
	 private synchronized void addResource(ArrayList resources, Object resource) {
		 resources.add(resource);
		 properties = null;
	 }
	 public Object getObject(String name) {
		 return getProps().get(name);
	}
	 public void setObject(String name, Object value) {
		 getProps().put(name, value);
	 }
	 public Object get(String name, Object defaultValue) {
		 Object res = getObject(name);
		 if (res != null) return res;
		 else return defaultValue;
	 }
	 private static Pattern varPat = Pattern.compile(""\\$\\{
	[^\\}
\\$\u0020]+\\}
"");
 private static int MAX_SUBST = 20;
 private String substituteVars(String expr) {
	 if(expr == null) {
		 return null;
	 }
	 Matcher match = varPat.matcher("""");
	 String eval = expr;
	 for(int s=0;
	 s<MAX_SUBST;
	 s++) {
		 match.reset(eval);
		 if(! match.find()) {
			 return eval;
		 }
		 String var = match.group();
		 var = var.substring(2, var.length()-1);
		 String val = System.getProperty(var);
		 if(val == null) {
			 val = (String)this.getObject(var);
		 }
		 if(val == null) {
			 return eval;
		 }
		 eval = eval.substring(0, match.start())+val+eval.substring(match.end());
	 }
	 throw new IllegalStateException(""Variable substitution depth too large: "" + MAX_SUBST + "" "" + expr);
 }
 public String get(String name) {
	 return substituteVars(getProps().getProperty(name));
 }
 public void set(String name, Object value) {
	 getOverlay().setProperty(name, value.toString());
	 getProps().setProperty(name, value.toString());
 }
 private synchronized Properties getOverlay() {
	 if(overlay==null){
		 overlay=new Properties();
	 }
	 return overlay;
 }
 public String get(String name, String defaultValue) {
	 return substituteVars(getProps().getProperty(name, defaultValue));
 }
 public int getInt(String name, int defaultValue) {
	 String valueString = get(name);
	 if (valueString == null) return defaultValue;
	 try {
		 return Integer.parseInt(valueString);
	 }
	 catch (NumberFormatException e) {
		 return defaultValue;
	 }
 }
 public void setInt(String name, int value) {
	 set(name, Integer.toString(value));
 }
 public long getLong(String name, long defaultValue) {
	 String valueString = get(name);
	 if (valueString == null) return defaultValue;
	 try {
		 return Long.parseLong(valueString);
	 }
	 catch (NumberFormatException e) {
		 return defaultValue;
	 }
 }
 public void setLong(String name, long value) {
	 set(name, Long.toString(value));
 }
 public float getFloat(String name, float defaultValue) {
	 String valueString = get(name);
	 if (valueString == null) return defaultValue;
	 try {
		 return Float.parseFloat(valueString);
	 }
	 catch (NumberFormatException e) {
		 return defaultValue;
	 }
 }
 public boolean getBoolean(String name, boolean defaultValue) {
	 String valueString = get(name);
	 if (""true"".equals(valueString)) return true;
	 else if (""false"".equals(valueString)) return false;
	 else return defaultValue;
 }
 public void setBoolean(String name, boolean value) {
	 set(name, Boolean.toString(value));
 }
 public String[] getStrings(String name) {
	 String valueString = get(name);
	 return StringUtils.getStrings(valueString);
 }
 public Class getClassByName(String name) throws ClassNotFoundException {
	 return Class.forName(name, true, classLoader);
 }
 public Class getClass(String name, Class defaultValue) {
	 String valueString = get(name);
	 if (valueString == null) return defaultValue;
	 try {
		 return getClassByName(valueString);
	 }
	 catch (ClassNotFoundException e) {
		 throw new RuntimeException(e);
	 }
 }
 public Class getClass(String propertyName, Class defaultValue,Class xface) {
	 try {
		 Class theClass = getClass(propertyName, defaultValue);
		 if (theClass != null && !xface.isAssignableFrom(theClass)) throw new RuntimeException(theClass+"" not ""+xface.getName());
		 return theClass;
	 }
	 catch (Exception e) {
		 throw new RuntimeException(e);
	 }
 }
 public void setClass(String propertyName, Class theClass, Class xface) {
	 if (!xface.isAssignableFrom(theClass)) throw new RuntimeException(theClass+"" not ""+xface.getName());
	 set(propertyName, theClass.getName());
 }
 public Path getLocalPath(String dirsProp, String path) throws IOException {
	 String[] dirs = getStrings(dirsProp);
	 int hashCode = path.hashCode();
	 FileSystem fs = FileSystem.getNamed(""local"", this);
	 for (int i = 0;
	 i < dirs.length;
	 i++) {
		 int index = (hashCode+i & Integer.MAX_VALUE) % dirs.length;
		 Path file = new Path(dirs[index], path);
		 Path dir = file.getParent();
		 if (fs.mkdirs(dir) || fs.exists(dir)) {
			 return file;
		 }
	 }
	 LOG.warn(""Could not make "" + path + "" in local directories from "" + dirsProp);
	 for(int i=0;
	 i < dirs.length;
	 i++) {
		 int index = (hashCode+i & Integer.MAX_VALUE) % dirs.length;
		 LOG.warn(dirsProp + ""["" + index + ""]="" + dirs[index]);
	 }
	 throw new IOException(""No valid local directories in property: ""+dirsProp);
 }
 public File getFile(String dirsProp, String path) throws IOException {
	 String[] dirs = getStrings(dirsProp);
	 int hashCode = path.hashCode();
	 for (int i = 0;
	 i < dirs.length;
	 i++) {
		 int index = (hashCode+i & Integer.MAX_VALUE) % dirs.length;
		 File file = new File(dirs[index], path);
		 File dir = file.getParentFile();
		 if (dir.exists() || dir.mkdirs()) {
			 return file;
		 }
	 }
	 throw new IOException(""No valid local directories in property: ""+dirsProp);
 }
 public URL getResource(String name) {
	 return classLoader.getResource(name);
 }
 public InputStream getConfResourceAsInputStream(String name) {
	 try {
		 URL url= getResource(name);
		 if (url == null) {
			 LOG.info(name + "" not found"");
			 return null;
		 }
		 else {
			 LOG.info(""found resource "" + name + "" at "" + url);
		 }
		 return url.openStream();
	 }
	 catch (Exception e) {
		 return null;
	 }
 }
 public Reader getConfResourceAsReader(String name) {
	 try {
		 URL url= getResource(name);
		 if (url == null) {
			 LOG.info(name + "" not found"");
			 return null;
		 }
		 else {
			 LOG.info(""found resource "" + name + "" at "" + url);
		 }
		 return new InputStreamReader(url.openStream());
	 }
	 catch (Exception e) {
		 return null;
	 }
 }
 private synchronized Properties getProps() {
	 if (properties == null) {
		 Properties newProps = new Properties();
		 loadResources(newProps, defaultResources, false, quietmode);
		 loadResources(newProps, finalResources, true, true);
		 properties = newProps;
		 if(overlay!=null) properties.putAll(overlay);
	 }
	 return properties;
 }
 public Iterator entries() {
	 return getProps().entrySet().iterator();
 }
 private void loadResources(Properties props, ArrayList resources, boolean reverse, boolean quiet) {
	 ListIterator i = resources.listIterator(reverse ? resources.size() : 0);
	 while (reverse ? i.hasPrevious() : i.hasNext()) {
		 loadResource(props, reverse ? i.previous() : i.next(), quiet);
	 }
 }
 private void loadResource(Properties properties, Object name, boolean quiet) {
	 try {
		 DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
		 Document doc = null;
		 if (name instanceof URL) {
			 URL url = (URL)name;
			 if (url != null) {
				 if (!quiet) {
					 LOG.info(""parsing "" + url);
				 }
				 doc = builder.parse(url.toString());
			 }
		 }
		 else if (name instanceof String) {
			 URL url = getResource((String)name);
			 if (url != null) {
				 if (!quiet) {
					 LOG.info(""parsing "" + url);
				 }
				 doc = builder.parse(url.toString());
			 }
		 }
		 else if (name instanceof Path) {
			 Path file = (Path)name;
			 FileSystem fs = FileSystem.getNamed(""local"", this);
			 if (fs.exists(file)) {
				 if (!quiet) {
					 LOG.info(""parsing "" + file);
				 }
				 InputStream in = new BufferedInputStream(fs.openRaw(file));
				 try {
					 doc = builder.parse(in);
				 }
				 finally {
					 in.close();
				 }
			 }
		 }
		 if (doc == null) {
			 if (quiet) return;
			 throw new RuntimeException(name + "" not found"");
		 }
		 Element root = doc.getDocumentElement();
		 if (!""configuration"".equals(root.getTagName())) LOG.fatal(""bad conf file: top-level element not <configuration>"");
		 NodeList props = root.getChildNodes();
		 for (int i = 0;
		 i < props.getLength();
		 i++) {
			 Node propNode = props.item(i);
			 if (!(propNode instanceof Element)) continue;
			 Element prop = (Element)propNode;
			 if (!""property"".equals(prop.getTagName())) LOG.warn(""bad conf file: element not <property>"");
			 NodeList fields = prop.getChildNodes();
			 String attr = null;
			 String value = null;
			 for (int j = 0;
			 j < fields.getLength();
			 j++) {
				 Node fieldNode = fields.item(j);
				 if (!(fieldNode instanceof Element)) continue;
				 Element field = (Element)fieldNode;
				 if (""name"".equals(field.getTagName())) attr = ((Text)field.getFirstChild()).getData();
				 if (""value"".equals(field.getTagName()) && field.hasChildNodes()) value = ((Text)field.getFirstChild()).getData();
			 }
			 if (attr != null && value != null) properties.setProperty(attr, value);
		 }
	 }
	 catch (Exception e) {
		 LOG.fatal(""error parsing conf file: "" + e);
		 throw new RuntimeException(e);
	 }
 }
 public void write(OutputStream out) throws IOException {
	 Properties properties = getProps();
	 try {
		 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
		 Element conf = doc.createElement(""configuration"");
		 doc.appendChild(conf);
		 conf.appendChild(doc.createTextNode(""\n""));
		 for (Enumeration e = properties.keys();
		 e.hasMoreElements();
		) {
			 String name = (String)e.nextElement();
			 Object object = properties.get(name);
			 String value = null;
			 if(object instanceof String) {
				 value = (String) object;
			 }
			else {
				 continue;
			 }
			 Element propNode = doc.createElement(""property"");
			 conf.appendChild(propNode);
			 Element nameNode = doc.createElement(""name"");
			 nameNode.appendChild(doc.createTextNode(name));
			 propNode.appendChild(nameNode);
			 Element valueNode = doc.createElement(""value"");
			 valueNode.appendChild(doc.createTextNode(value));
			 propNode.appendChild(valueNode);
			 conf.appendChild(doc.createTextNode(""\n""));
		 }
		 DOMSource source = new DOMSource(doc);
		 StreamResult result = new StreamResult(out);
		 TransformerFactory transFactory = TransformerFactory.newInstance();
		 Transformer transformer = transFactory.newTransformer();
		 transformer.transform(source, result);
	 }
	 catch (Exception e) {
		 throw new RuntimeException(e);
	 }
 }
 public ClassLoader getClassLoader() {
	 return classLoader;
 }
 public void setClassLoader(ClassLoader classLoader) {
	 this.classLoader = classLoader;
 }
 public String toString() {
	 StringBuffer sb = new StringBuffer();
	 sb.append(""Configuration: "");
	 sb.append(""defaults: "");
	 toString(defaultResources, sb);
	 sb.append(""final: "");
	 toString(finalResources, sb);
	 return sb.toString();
 }
 private void toString(ArrayList resources, StringBuffer sb) {
	 ListIterator i = resources.listIterator();
	 while (i.hasNext()) {
		 if (i.nextIndex() != 0) {
			 sb.append("" , "");
		 }
		 sb.append(i.next());
	 }
 }
 public void setQuietMode(boolean value) {
	 quietmode = value;
 }
 public static void main(String[] args) throws Exception {
	 new Configuration().write(System.out);
 }
}",0,0,0,0
"protected static class CreateFileThread extends Thread {
	 protected final HDFSSession session;
	 protected final Path path;
	 protected final InputStream input;
	 protected Throwable exception = null;
	 public CreateFileThread(HDFSSession session, Path path, InputStream input) {
		 super();
		 this.session = session;
		 this.path = path;
		 this.input = input;
		 setDaemon(true);
	 }
	 public void run() {
		 try {
			 session.createFile(path,input);
		 }
		 catch (Throwable e) {
			 this.exception = e;
		 }
	 }
	 public void finishUp() throws InterruptedException, IOException {
		 join();
		 Throwable thr = exception;
		 if (thr != null) {
			 if (thr instanceof IOException) {
				 throw (IOException) thr;
			 }
			 else if (thr instanceof RuntimeException) {
				 throw (RuntimeException) thr;
			 }
			 else {
				 throw (Error) thr;
			 }
		 }
	 }
 }",1,0,0,0
"public class StarTeamLabel extends StarTeamTask {
	 private String labelName;
	 private String description;
	 private boolean buildlabel = false;
	 private boolean revisionlabel = false;
	 private OLEDate lastBuild = null;
	 private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(""yyyyMMddHHmmss"");
	 public void setLabel(String label) {
		 this.labelName = label;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public void setBuildLabel(boolean buildlabel) {
		 this.buildlabel = buildlabel;
	 }
	 public void setRevisionLabel(boolean revisionlabel) {
		 this.revisionlabel = revisionlabel;
	 }
	 public void setLastBuild(String lastbuild) throws BuildException {
		 try {
			 Date lastBuildTime = DATE_FORMAT.parse(lastbuild);
			 this.lastBuild = new OLEDate(lastBuildTime);
		 }
		 catch (ParseException e) {
			 throw new BuildException(""Unable to parse the date '"" + lastbuild + ""'"", e);
		 }
	 }
	 public void execute() throws BuildException {
		 if (this.revisionlabel && this.buildlabel) {
			 throw new BuildException(""'revisionlabel' and 'buildlabel' "" + ""both specified. A revision label cannot be a build label."");
		 }
		 try {
			 View snapshot = openView();
			 if (this.revisionlabel) {
				 new Label(snapshot, this.labelName, this.description).update();
				 log(""Created Revision Label "" + this.labelName);
			 }
			 else if (null != lastBuild) {
				 new Label(snapshot, this.labelName, this.description, this.lastBuild, this.buildlabel).update();
				 log(""Created View Label ("" + (this.buildlabel ? """" : ""non-"") + ""build) "" + this.labelName + "" as of "" + this.lastBuild.toString());
			 }
			 else {
				 new Label(snapshot, this.labelName, this.description, this.buildlabel).update();
				 log(""Created View Label ("" + (this.buildlabel ? """" : ""non-"") + ""build) "" + this.labelName);
			 }
		 }
		 catch (Exception e) {
			 throw new BuildException(e);
		 }
		 finally {
			 disconnectFromServer();
		 }
	 }
	 protected View createSnapshotView(View raw) {
		 return raw;
	 }
}",0,0,0,0
"public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 CrawlDatum highest = null;
	 CrawlDatum old = null;
	 byte[] signature = null;
	 linked.clear();
	 while (values.hasNext()) {
		 CrawlDatum datum = (CrawlDatum)values.next();
		 if (highest == null || datum.getStatus() > highest.getStatus()) {
			 highest = datum;
		 }
		 switch (datum.getStatus()) {
			 case CrawlDatum.STATUS_DB_UNFETCHED: case CrawlDatum.STATUS_DB_FETCHED: case CrawlDatum.STATUS_DB_GONE: old = datum;
			 break;
			 case CrawlDatum.STATUS_LINKED: linked.add(datum);
			 break;
			 case CrawlDatum.STATUS_SIGNATURE: signature = datum.getSignature();
		 }
	 }
	 result.set(highest);
	 if (old != null) {
		 if (old.getMetaData().size() > 0) {
			 result.getMetaData().putAll(old.getMetaData());
			 if (highest.getMetaData().size() > 0) result.getMetaData().putAll(highest.getMetaData());
		 }
		 if (old.getModifiedTime() > 0 && highest.getModifiedTime() == 0) {
			 result.setModifiedTime(old.getModifiedTime());
		 }
	 }
	 switch (highest.getStatus()) {
		 case CrawlDatum.STATUS_DB_UNFETCHED: case CrawlDatum.STATUS_DB_FETCHED: case CrawlDatum.STATUS_DB_GONE: result.set(old);
		 break;
		 case CrawlDatum.STATUS_LINKED: if (old != null) {
			 result.set(old);
		 }
		 else {
			 result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);
			 try {
				 scfilters.initialScore((UTF8)key, result);
			 }
			 catch (ScoringFilterException e) {
				 if (LOG.isWarnEnabled()) {
					 LOG.warn(""Cannot filter init score for url "" + key + "", using default: "" + e.getMessage());
				 }
				 result.setScore(scoreInjected);
			 }
		 }
		 break;
		 case CrawlDatum.STATUS_FETCH_SUCCESS: if (highest.getSignature() == null) result.setSignature(signature);
		 result.setStatus(CrawlDatum.STATUS_DB_FETCHED);
		 result.setNextFetchTime();
		 break;
		 case CrawlDatum.STATUS_SIGNATURE: if (LOG.isWarnEnabled()) {
			 LOG.warn(""Lone CrawlDatum.STATUS_SIGNATURE: "" + key);
		 }
		 return;
		 case CrawlDatum.STATUS_FETCH_RETRY: if (old != null) result.setSignature(old.getSignature());
		 if (highest.getRetriesSinceFetch() < retryMax) {
			 result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);
		 }
		 else {
			 result.setStatus(CrawlDatum.STATUS_DB_GONE);
		 }
		 break;
		 case CrawlDatum.STATUS_FETCH_GONE: if (old != null) result.setSignature(old.getSignature());
		 result.setStatus(CrawlDatum.STATUS_DB_GONE);
		 break;
		 default: throw new RuntimeException(""Unknown status: "" + highest.getStatus() + "" "" + key);
	 }
	 try {
		 scfilters.updateDbScore((UTF8)key, old, result, linked);
	 }
	 catch (Exception e) {
		 if (LOG.isWarnEnabled()) {
			 LOG.warn(""Couldn't update score, key="" + key + "": "" + e);
		 }
	 }
	 output.collect(key, result);
 }",0,0,1,0
"final class Target_jline_TerminalFactory {
	 public static Terminal create(String ttyDevice) {
		 Terminal t;
		 try {
			 t = new UnixTerminal();
			 t.init();
		 }
		 catch (Exception e) {
			 Log.error(""Failed to construct terminal;
			 falling back to UnsupportedTerminal"", e);
			 t = new UnsupportedTerminal();
		 }
		 Log.debug(""Created Terminal: "", t);
		 return t;
	 }
}",0,0,0,0
"public void execute() throws org.apache.tools.ant.BuildException {
	 int result = 0;
	 if (repository == null || repository.trim().equals("""")) {
		 throw new BuildException(""Required argument repository not specified"");
	 }
	 Commandline commandLine = new Commandline();
	 commandLine.setExecutable(getExecutable(PCLI_EXE));
	 commandLine.createArgument().setValue(""lvf"");
	 commandLine.createArgument().setValue(""-z"");
	 commandLine.createArgument().setValue(""-aw"");
	 if (getWorkspace() != null) {
		 commandLine.createArgument().setValue(""-sp"" + getWorkspace());
	 }
	 commandLine.createArgument().setValue(""-pr"" + getRepository());
	 String uid = getUserId();
	 if (uid != null) {
		 commandLine.createArgument().setValue(""-id"" + uid);
	 }
	 if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
		 pvcsProject = ""/"";
	 }
	 if (getPvcsproject() != null) {
		 commandLine.createArgument().setValue(getPvcsproject());
	 }
	 if (!getPvcsprojects().isEmpty()) {
		 Enumeration e = getPvcsprojects().elements();
		 while (e.hasMoreElements()) {
			 String projectName = ((PvcsProject) e.nextElement()).getName();
			 if (projectName == null || (projectName.trim()).equals("""")) {
				 throw new BuildException(""name is a required attribute "" + ""of pvcsproject"");
			 }
			 commandLine.createArgument().setValue(projectName);
		 }
	 }
	 File tmp = null;
	 File tmp2 = null;
	 try {
		 Random rand = new Random(System.currentTimeMillis());
		 tmp = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
		 FileOutputStream fos = new FileOutputStream(tmp);
		 tmp2 = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
		 log(commandLine.describeCommand(), Project.MSG_VERBOSE);
		 try {
			 result = runCmd(commandLine, new PumpStreamHandler(fos, new LogOutputStream(this, Project.MSG_WARN)));
		 }
		 finally {
			 fos.close();
		 }
		 if (Execute.isFailure(result) && !ignorerc) {
			 String msg = ""Failed executing: "" + commandLine.toString();
			 throw new BuildException(msg, getLocation());
		 }
		 if (!tmp.exists()) {
			 throw new BuildException(""Communication between ant and pvcs "" + ""failed. No output generated from executing PVCS "" + ""commandline interface \""pcli\"" and \""get\"""");
		 }
		 log(""Creating folders"", Project.MSG_INFO);
		 createFolders(tmp);
		 massagePCLI(tmp, tmp2);
		 commandLine.clearArgs();
		 commandLine.setExecutable(getExecutable(GET_EXE));
		 if (getConfig() != null && getConfig().length() > 0) {
			 commandLine.createArgument().setValue(""-c"" + getConfig());
		 }
		 if (getForce() != null && getForce().equals(""yes"")) {
			 commandLine.createArgument().setValue(""-Y"");
		 }
		 else {
			 commandLine.createArgument().setValue(""-N"");
		 }
		 if (getPromotiongroup() != null) {
			 commandLine.createArgument().setValue(""-G"" + getPromotiongroup());
		 }
		 else {
			 if (getLabel() != null) {
				 commandLine.createArgument().setValue(""-v"" + getLabel());
			 }
			 else {
				 if (getRevision() != null) {
					 commandLine.createArgument().setValue(""-r"" + getRevision());
				 }
			 }
		 }
		 if (updateOnly) {
			 commandLine.createArgument().setValue(""-U"");
		 }
		 commandLine.createArgument().setValue(""@"" + tmp2.getAbsolutePath());
		 log(""Getting files"", Project.MSG_INFO);
		 log(""Executing "" + commandLine.toString(), Project.MSG_VERBOSE);
		 result = runCmd(commandLine, new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
		 if (result != 0 && !ignorerc) {
			 String msg = ""Failed executing: "" + commandLine.toString() + "". Return code was "" + result;
			 throw new BuildException(msg, getLocation());
		 }
	 }
	 catch (FileNotFoundException e) {
		 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
		 throw new BuildException(msg, getLocation());
	 }
	 catch (IOException e) {
		 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
		 throw new BuildException(msg, getLocation());
	 }
	 catch (ParseException e) {
		 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
		 throw new BuildException(msg, getLocation());
	 }
	 finally {
		 if (tmp != null) {
			 tmp.delete();
		 }
		 if (tmp2 != null) {
			 tmp2.delete();
		 }
	 }
 }",0,0,1,0
"public void configure() {
	 if (isConfigured) {
		 return;
	 }
	 isConfigured = true;
	 Project p = getProject();
	 String filename = ""cache.properties"";
	 File cachefile = null;
	 if (p != null) {
		 cachefile = new File(p.getBaseDir(), filename);
		 getProject().addBuildListener(this);
	 }
	 else {
		 cachefile = new File(filename);
		 setDelayUpdate(false);
	 }
	 Cache defaultCache = new PropertiesfileCache(cachefile);
	 Algorithm defaultAlgorithm = new DigestAlgorithm();
	 Comparator defaultComparator = new EqualComparator();
	 update = true;
	 selectDirectories = true;
	 for (Iterator itConfig = configParameter.iterator();
	 itConfig.hasNext();
	) {
		 Parameter par = (Parameter) itConfig.next();
		 if (par.getName().indexOf(""."") > 0) {
			 specialParameter.add(par);
		 }
		 else {
			 useParameter(par);
		 }
	 }
	 configParameter = new Vector();
	 if (algoName != null) {
		 if (""hashvalue"".equals(algoName.getValue())) {
			 algorithm = new HashvalueAlgorithm();
		 }
		 else if (""digest"".equals(algoName.getValue())) {
			 algorithm = new DigestAlgorithm();
		 }
		 else if (""checksum"".equals(algoName.getValue())) {
			 algorithm = new ChecksumAlgorithm();
		 }
	 }
	 else {
		 if (algorithmClass != null) {
			 algorithm = (Algorithm) loadClass( algorithmClass, ""is not an Algorithm."", Algorithm.class);
		 }
		 else {
			 algorithm = defaultAlgorithm;
		 }
	 }
	 if (cacheName != null) {
		 if (""propertyfile"".equals(cacheName.getValue())) {
			 cache = new PropertiesfileCache();
		 }
	 }
	 else {
		 if (cacheClass != null) {
			 cache = (Cache) loadClass(cacheClass, ""is not a Cache."", Cache.class);
		 }
		 else {
			 cache = defaultCache;
		 }
	 }
	 if (compName != null) {
		 if (""equal"".equals(compName.getValue())) {
			 comparator = new EqualComparator();
		 }
		 else if (""rule"".equals(compName.getValue())) {
			 throw new BuildException(""RuleBasedCollator not yet supported."");
		 }
	 }
	 else {
		 if (comparatorClass != null) {
			 comparator = (Comparator) loadClass( comparatorClass, ""is not a Comparator."", Comparator.class);
		 }
		 else {
			 comparator = defaultComparator;
		 }
	 }
	 for (Iterator itSpecial = specialParameter.iterator();
	 itSpecial.hasNext();
	) {
		 Parameter par = (Parameter) itSpecial.next();
		 useParameter(par);
	 }
	 specialParameter = new Vector();
 }",0,0,1,0
"public boolean incrementToken() throws IOException {
	 for(;
	;
	) {
		 if (!remainingTokens.isEmpty()) {
			 restoreState(remainingTokens.removeFirst());
			 return true;
		 }
		 if (!input.incrementToken()) return false;
		 int len = termAtt.length();
		 if (len==0) return true;
		 int firstAlternativeIncrement = inject ? 0 : posAtt.getPositionIncrement();
		 String v = termAtt.toString();
		 String primaryPhoneticValue = encoder.doubleMetaphone(v);
		 String alternatePhoneticValue = encoder.doubleMetaphone(v, true);
		 boolean saveState=inject;
		 if (primaryPhoneticValue!=null && primaryPhoneticValue.length() > 0 && !primaryPhoneticValue.equals(v)) {
			 if (saveState) {
				 remainingTokens.addLast(captureState());
			 }
			 posAtt.setPositionIncrement( firstAlternativeIncrement );
			 firstAlternativeIncrement = 0;
			 termAtt.setEmpty().append(primaryPhoneticValue);
			 saveState = true;
		 }
		 if (alternatePhoneticValue!=null && alternatePhoneticValue.length() > 0 && !alternatePhoneticValue.equals(primaryPhoneticValue) && !primaryPhoneticValue.equals(v)) {
			 if (saveState) {
				 remainingTokens.addLast(captureState());
				 saveState = false;
			 }
			 posAtt.setPositionIncrement( firstAlternativeIncrement );
			 termAtt.setEmpty().append(alternatePhoneticValue);
			 saveState = true;
		 }
		 if (remainingTokens.isEmpty()) {
			 return true;
		 }
		 if (saveState) {
			 remainingTokens.addLast(captureState());
		 }
	 }
 }",0,0,1,0
"public class NfaState{
	 public static boolean unicodeWarningGiven = false;
	 public static int generatedStates = 0;
	 private static int idCnt = 0;
	 private static int lohiByteCnt;
	 private static int dummyStateIndex = -1;
	 private static boolean done;
	 private static boolean mark[];
	 private static boolean stateDone[];
	 private static List allStates = new ArrayList();
	 private static List indexedAllStates = new ArrayList();
	 private static List nonAsciiTableForMethod = new ArrayList();
	 private static Hashtable equivStatesTable = new Hashtable();
	 private static Hashtable allNextStates = new Hashtable();
	 private static Hashtable lohiByteTab = new Hashtable();
	 private static Hashtable stateNameForComposite = new Hashtable();
	 private static Hashtable compositeStateTable = new Hashtable();
	 private static Hashtable stateBlockTable = new Hashtable();
	 private static Hashtable stateSetsToFix = new Hashtable();
	 private static boolean jjCheckNAddStatesUnaryNeeded = false;
	 private static boolean jjCheckNAddStatesDualNeeded = false;
	 public static void ReInit() {
		 generatedStates = 0;
		 idCnt = 0;
		 dummyStateIndex = -1;
		 done = false;
		 mark = null;
		 stateDone = null;
		 allStates.clear();
		 indexedAllStates.clear();
		 equivStatesTable.clear();
		 allNextStates.clear();
		 compositeStateTable.clear();
		 stateBlockTable.clear();
		 stateNameForComposite.clear();
		 stateSetsToFix.clear();
	 }
	 long[] asciiMoves = new long[2];
	 char[] charMoves = null;
	 private char[] rangeMoves = null;
	 NfaState next = null;
	 private NfaState stateForCase;
	 Vector epsilonMoves = new Vector();
	 private String epsilonMovesString;
	 private NfaState[] epsilonMoveArray;
	 private int id;
	 int stateName = -1;
	 int kind = Integer.MAX_VALUE;
	 private int lookingFor;
	 private int usefulEpsilonMoves = 0;
	 int inNextOf;
	 private int lexState;
	 private int nonAsciiMethod = -1;
	 private int kindToPrint = Integer.MAX_VALUE;
	 boolean dummy = false;
	 private boolean isComposite = false;
	 private int[] compositeStates = null;
	 boolean isFinal = false;
	 private Vector loByteVec;
	 private int[] nonAsciiMoveIndices;
	 private int round = 0;
	 private int onlyChar = 0;
	 private char matchSingleChar;
	 NfaState() {
		 id = idCnt++;
		 allStates.add(this);
		 lexState = LexGen.lexStateIndex;
		 lookingFor = LexGen.curKind;
	 }
	 NfaState CreateClone() {
		 NfaState retVal = new NfaState();
		 retVal.isFinal = isFinal;
		 retVal.kind = kind;
		 retVal.lookingFor = lookingFor;
		 retVal.lexState = lexState;
		 retVal.inNextOf = inNextOf;
		 retVal.MergeMoves(this);
		 return retVal;
	 }
	 static void InsertInOrder(List v, NfaState s) {
		 int j;
		 for (j = 0;
		 j < v.size();
		 j++) if (((NfaState)v.get(j)).id > s.id) break;
		 else if (((NfaState)v.get(j)).id == s.id) return;
		 v.add(j, s);
	 }
	 private static char[] ExpandCharArr(char[] oldArr, int incr) {
		 char[] ret = new char[oldArr.length + incr];
		 System.arraycopy(oldArr, 0, ret, 0, oldArr.length);
		 return ret;
	 }
	 void AddMove(NfaState newState) {
		 if (!epsilonMoves.contains(newState)) InsertInOrder(epsilonMoves, newState);
	 }
	 private final void AddASCIIMove(char c) {
		 asciiMoves[c / 64] |= (1L << (c % 64));
	 }
	 void AddChar(char c) {
		 onlyChar++;
		 matchSingleChar = c;
		 int i;
		 char temp;
		 char temp1;
		 if ((int)c < 128) {
			 AddASCIIMove(c);
			 return;
		 }
		 if (charMoves == null) charMoves = new char[10];
		 int len = charMoves.length;
		 if (charMoves[len - 1] != 0) {
			 charMoves = ExpandCharArr(charMoves, 10);
			 len += 10;
		 }
		 for (i = 0;
		 i < len;
		 i++) if (charMoves[i] == 0 || charMoves[i] > c) break;
		 if (!unicodeWarningGiven && c > 0xff && !Options.getJavaUnicodeEscape() && !Options.getUserCharStream()) {
			 unicodeWarningGiven = true;
			 JavaCCErrors.warning(LexGen.curRE, ""Non-ASCII characters used in regular expression.\n"" + ""Please make sure you use the correct Reader when you create the parser, "" + ""one that can handle your character set."");
		 }
		 temp = charMoves[i];
		 charMoves[i] = c;
		 for (i++;
		 i < len;
		 i++) {
			 if (temp == 0) break;
			 temp1 = charMoves[i];
			 charMoves[i] = temp;
			 temp = temp1;
		 }
	 }
	 void AddRange(char left, char right) {
		 onlyChar = 2;
		 int i;
		 char tempLeft1, tempLeft2, tempRight1, tempRight2;
		 if (left < 128) {
			 if (right < 128) {
				 for (;
				 left <= right;
				 left++) AddASCIIMove(left);
				 return;
			 }
			 for (;
			 left < 128;
			 left++) AddASCIIMove(left);
		 }
		 if (!unicodeWarningGiven && (left > 0xff || right > 0xff) && !Options.getJavaUnicodeEscape() && !Options.getUserCharStream()) {
			 unicodeWarningGiven = true;
			 JavaCCErrors.warning(LexGen.curRE, ""Non-ASCII characters used in regular expression.\n"" + ""Please make sure you use the correct Reader when you create the parser, "" + ""one that can handle your character set."");
		 }
		 if (rangeMoves == null) rangeMoves = new char[20];
		 int len = rangeMoves.length;
		 if (rangeMoves[len - 1] != 0) {
			 rangeMoves = ExpandCharArr(rangeMoves, 20);
			 len += 20;
		 }
		 for (i = 0;
		 i < len;
		 i += 2) if (rangeMoves[i] == 0 || (rangeMoves[i] > left) || ((rangeMoves[i] == left) && (rangeMoves[i + 1] > right))) break;
		 tempLeft1 = rangeMoves[i];
		 tempRight1 = rangeMoves[i + 1];
		 rangeMoves[i] = left;
		 rangeMoves[i + 1] = right;
		 for (i += 2;
		 i < len;
		 i += 2) {
			 if (tempLeft1 == 0) break;
			 tempLeft2 = rangeMoves[i];
			 tempRight2 = rangeMoves[i + 1];
			 rangeMoves[i] = tempLeft1;
			 rangeMoves[i + 1] = tempRight1;
			 tempLeft1 = tempLeft2;
			 tempRight1 = tempRight2;
		 }
	 }
	 private static boolean EqualCharArr(char[] arr1, char[] arr2) {
		 if (arr1 == arr2) return true;
		 if (arr1 != null && arr2 != null && arr1.length == arr2.length) {
			 for (int i = arr1.length;
			 i-- > 0;
			) if (arr1[i] != arr2[i]) return false;
			 return true;
		 }
		 return false;
	 }
	 private boolean closureDone = false;
	 private void EpsilonClosure() {
		 int i = 0;
		 if (closureDone || mark[id]) return;
		 mark[id] = true;
		 for (i = 0;
		 i < epsilonMoves.size();
		 i++) ((NfaState)epsilonMoves.get(i)).EpsilonClosure();
		 Enumeration e = epsilonMoves.elements();
		 while (e.hasMoreElements()) {
			 NfaState tmp = (NfaState)e.nextElement();
			 for (i = 0;
			 i < tmp.epsilonMoves.size();
			 i++) {
				 NfaState tmp1 = (NfaState)tmp.epsilonMoves.get(i);
				 if (tmp1.UsefulState() && !epsilonMoves.contains(tmp1)) {
					 InsertInOrder(epsilonMoves, tmp1);
					 done = false;
				 }
			 }
			 if (kind > tmp.kind) kind = tmp.kind;
		 }
		 if (HasTransitions() && !epsilonMoves.contains(this)) InsertInOrder(epsilonMoves, this);
	 }
	 private boolean UsefulState() {
		 return isFinal || HasTransitions();
	 }
	 public boolean HasTransitions() {
		 return (asciiMoves[0] != 0L || asciiMoves[1] != 0L || (charMoves != null && charMoves[0] != 0) || (rangeMoves != null && rangeMoves[0] != 0));
	 }
	 void MergeMoves(NfaState other) {
		 if (asciiMoves == other.asciiMoves) {
			 JavaCCErrors.semantic_error(""Bug in JavaCC : Please send "" + ""a report along with the input that caused this. Thank you."");
			 throw new Error();
		 }
		 asciiMoves[0] = asciiMoves[0] | other.asciiMoves[0];
		 asciiMoves[1] = asciiMoves[1] | other.asciiMoves[1];
		 if (other.charMoves != null) {
			 if (charMoves == null) charMoves = other.charMoves;
			 else {
				 char[] tmpCharMoves = new char[charMoves.length + other.charMoves.length];
				 System.arraycopy(charMoves, 0, tmpCharMoves, 0, charMoves.length);
				 charMoves = tmpCharMoves;
				 for (int i = 0;
				 i < other.charMoves.length;
				 i++) AddChar(other.charMoves[i]);
			 }
		 }
		 if (other.rangeMoves != null) {
			 if (rangeMoves == null) rangeMoves = other.rangeMoves;
			 else {
				 char[] tmpRangeMoves = new char[rangeMoves.length + other.rangeMoves.length];
				 System.arraycopy(rangeMoves, 0, tmpRangeMoves, 0, rangeMoves.length);
				 rangeMoves = tmpRangeMoves;
				 for (int i = 0;
				 i < other.rangeMoves.length;
				 i += 2) AddRange(other.rangeMoves[i], other.rangeMoves[i + 1]);
			 }
		 }
		 if (other.kind < kind) kind = other.kind;
		 if (other.kindToPrint < kindToPrint) kindToPrint = other.kindToPrint;
		 isFinal |= other.isFinal;
	 }
	 NfaState CreateEquivState(List states) {
		 NfaState newState = ((NfaState)states.get(0)).CreateClone();
		 newState.next = new NfaState();
		 InsertInOrder(newState.next.epsilonMoves, ((NfaState)states.get(0)).next);
		 for (int i = 1;
		 i < states.size();
		 i++) {
			 NfaState tmp2 = ((NfaState)states.get(i));
			 if (tmp2.kind < newState.kind) newState.kind = tmp2.kind;
			 newState.isFinal |= tmp2.isFinal;
			 InsertInOrder(newState.next.epsilonMoves, tmp2.next);
		 }
		 return newState;
	 }
	 private NfaState GetEquivalentRunTimeState() {
		 Outer : for (int i = allStates.size();
		 i-- > 0;
		) {
			 NfaState other = (NfaState)allStates.get(i);
			 if (this != other && other.stateName != -1 && kindToPrint == other.kindToPrint && asciiMoves[0] == other.asciiMoves[0] && asciiMoves[1] == other.asciiMoves[1] && EqualCharArr(charMoves, other.charMoves) && EqualCharArr(rangeMoves, other.rangeMoves)) {
				 if (next == other.next) return other;
				 else if (next != null && other.next != null) {
					 if (next.epsilonMoves.size() == other.next.epsilonMoves.size()) {
						 for (int j = 0;
						 j < next.epsilonMoves.size();
						 j++) if (next.epsilonMoves.get(j) != other.next.epsilonMoves.get(j)) continue Outer;
						 return other;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 void GenerateCode() {
		 if (stateName != -1) return;
		 if (next != null) {
			 next.GenerateCode();
			 if (next.kind != Integer.MAX_VALUE) kindToPrint = next.kind;
		 }
		 if (stateName == -1 && HasTransitions()) {
			 NfaState tmp = GetEquivalentRunTimeState();
			 if (tmp != null) {
				 stateName = tmp.stateName;
				 dummy = true;
				 return;
			 }
			 stateName = generatedStates++;
			 indexedAllStates.add(this);
			 GenerateNextStatesCode();
		 }
	 }
	 public static void ComputeClosures() {
		 for (int i = allStates.size();
		 i-- > 0;
		 ) {
			 NfaState tmp = (NfaState)allStates.get(i);
			 if (!tmp.closureDone) tmp.OptimizeEpsilonMoves(true);
		 }
		 for (int i = 0;
		 i < allStates.size();
		 i++) {
			 NfaState tmp = (NfaState)allStates.get(i);
			 if (!tmp.closureDone) tmp.OptimizeEpsilonMoves(false);
		 }
		 for (int i = 0;
		 i < allStates.size();
		 i++) {
			 NfaState tmp = (NfaState)allStates.get(i);
			 tmp.epsilonMoveArray = new NfaState[tmp.epsilonMoves.size()];
			 tmp.epsilonMoves.copyInto(tmp.epsilonMoveArray);
		 }
	 }
	 void OptimizeEpsilonMoves(boolean optReqd) {
		 int i;
		 done = false;
		 while (!done) {
			 if (mark == null || mark.length < allStates.size()) mark = new boolean[allStates.size()];
			 for (i = allStates.size();
			 i-- > 0;
			) mark[i] = false;
			 done = true;
			 EpsilonClosure();
		 }
		 for (i = allStates.size();
		 i-- > 0;
		) ((NfaState)allStates.get(i)).closureDone = mark[((NfaState)allStates.get(i)).id];
		 boolean sometingOptimized = true;
		 NfaState newState = null;
		 NfaState tmp1, tmp2;
		 int j;
		 List equivStates = null;
		 while (sometingOptimized) {
			 sometingOptimized = false;
			 for (i = 0;
			 optReqd && i < epsilonMoves.size();
			 i++) {
				 if ((tmp1 = (NfaState)epsilonMoves.get(i)).HasTransitions()) {
					 for (j = i + 1;
					 j < epsilonMoves.size();
					 j++) {
						 if ((tmp2 = (NfaState)epsilonMoves.get(j)). HasTransitions() && (tmp1.asciiMoves[0] == tmp2.asciiMoves[0] && tmp1.asciiMoves[1] == tmp2.asciiMoves[1] && EqualCharArr(tmp1.charMoves, tmp2.charMoves) && EqualCharArr(tmp1.rangeMoves, tmp2.rangeMoves))) {
							 if (equivStates == null) {
								 equivStates = new ArrayList();
								 equivStates.add(tmp1);
							 }
							 InsertInOrder(equivStates, tmp2);
							 epsilonMoves.removeElementAt(j--);
						 }
					 }
				 }
				 if (equivStates != null) {
					 sometingOptimized = true;
					 String tmp = """";
					 for (int l = 0;
					 l < equivStates.size();
					 l++) tmp += String.valueOf( ((NfaState)equivStates.get(l)).id) + "", "";
					 if ((newState = (NfaState)equivStatesTable.get(tmp)) == null) {
						 newState = CreateEquivState(equivStates);
						 equivStatesTable.put(tmp, newState);
					 }
					 epsilonMoves.removeElementAt(i--);
					 epsilonMoves.add(newState);
					 equivStates = null;
					 newState = null;
				 }
			 }
			 for (i = 0;
			 i < epsilonMoves.size();
			 i++) {
				 tmp1 = (NfaState)epsilonMoves.get(i);
				 for (j = i + 1;
				 j < epsilonMoves.size();
				 j++) {
					 tmp2 = (NfaState)epsilonMoves.get(j);
					 if (tmp1.next == tmp2.next) {
						 if (newState == null) {
							 newState = tmp1.CreateClone();
							 newState.next = tmp1.next;
							 sometingOptimized = true;
						 }
						 newState.MergeMoves(tmp2);
						 epsilonMoves.removeElementAt(j--);
					 }
				 }
				 if (newState != null) {
					 epsilonMoves.removeElementAt(i--);
					 epsilonMoves.add(newState);
					 newState = null;
				 }
			 }
		 }
		 if (epsilonMoves.size() > 0) {
			 for (i = 0;
			 i < epsilonMoves.size();
			 i++) if (((NfaState)epsilonMoves.get(i)).HasTransitions()) usefulEpsilonMoves++;
			 else epsilonMoves.removeElementAt(i--);
		 }
	 }
	 void GenerateNextStatesCode() {
		 if (next.usefulEpsilonMoves > 0) next.GetEpsilonMovesString();
	 }
	 String GetEpsilonMovesString() {
		 int[] stateNames = new int[usefulEpsilonMoves];
		 int cnt = 0;
		 if (epsilonMovesString != null) return epsilonMovesString;
		 if (usefulEpsilonMoves > 0) {
			 NfaState tempState;
			 epsilonMovesString = ""{
				 "";
				 for (int i = 0;
				 i < epsilonMoves.size();
				 i++) {
					 if ((tempState = (NfaState)epsilonMoves.get(i)). HasTransitions()) {
						 if (tempState.stateName == -1) tempState.GenerateCode();
						 ((NfaState)indexedAllStates.get(tempState.stateName)).inNextOf++;
						 stateNames[cnt] = tempState.stateName;
						 epsilonMovesString += tempState.stateName + "", "";
						 if (cnt++ > 0 && cnt % 16 == 0) epsilonMovesString += ""\n"";
					 }
				 }
			 epsilonMovesString += ""}
			;
			"";
		 }
		 usefulEpsilonMoves = cnt;
		 if (epsilonMovesString != null && allNextStates.get(epsilonMovesString) == null) {
			 int[] statesToPut = new int[usefulEpsilonMoves];
			 System.arraycopy(stateNames, 0, statesToPut, 0, cnt);
			 allNextStates.put(epsilonMovesString, statesToPut);
		 }
		 return epsilonMovesString;
	 }
	 public static boolean CanStartNfaUsingAscii(char c) {
		 if (c >= 128) throw new Error(""JavaCC Bug: Please send mail to sankar"");
		 String s = LexGen.initialState.GetEpsilonMovesString();
		 if (s == null || s.equals(""null;
		"")) return false;
		 int[] states = (int[])allNextStates.get(s);
		 for (int i = 0;
		 i < states.length;
		 i++) {
			 NfaState tmp = (NfaState)indexedAllStates.get(states[i]);
			 if ((tmp.asciiMoves[c / 64 ] & (1L << c % 64)) != 0L) return true;
		 }
		 return false;
	 }
	 final boolean CanMoveUsingChar(char c) {
		 int i;
		 if (onlyChar == 1) return c == matchSingleChar;
		 if (c < 128) return ((asciiMoves[c / 64 ] & (1L << c % 64)) != 0L);
		 if (charMoves != null && charMoves[0] != 0) {
			 for (i = 0;
			 i < charMoves.length;
			 i++) {
				 if (c == charMoves[i]) return true;
				 else if (c < charMoves[i] || charMoves[i] == 0) break;
			 }
		 }
		 if (rangeMoves != null && rangeMoves[0] != 0) for (i = 0;
		 i < rangeMoves.length;
		 i += 2) if (c >= rangeMoves[i] && c <= rangeMoves[i + 1]) return true;
		 else if (c < rangeMoves[i] || rangeMoves[i] == 0) break;
		 return false;
	 }
	 public int getFirstValidPos(String s, int i, int len) {
		 if (onlyChar == 1) {
			 char c = matchSingleChar;
			 while (c != s.charAt(i) && ++i < len);
			 return i;
		 }
		 do {
			 if (CanMoveUsingChar(s.charAt(i))) return i;
		 }
		 while (++i < len);
		 return i;
	 }
	 public int MoveFrom(char c, List newStates) {
		 if (CanMoveUsingChar(c)) {
			 for (int i = next.epsilonMoves.size();
			 i-- > 0;
			) InsertInOrder(newStates, (NfaState)next.epsilonMoves.get(i));
			 return kindToPrint;
		 }
		 return Integer.MAX_VALUE;
	 }
	 public static int MoveFromSet(char c, List states, List newStates) {
		 int tmp;
		 int retVal = Integer.MAX_VALUE;
		 for (int i = states.size();
		 i-- > 0;
		) if (retVal > (tmp = ((NfaState)states.get(i)).MoveFrom(c, newStates))) retVal = tmp;
		 return retVal;
	 }
	 public static int moveFromSetForRegEx(char c, NfaState[] states, NfaState[] newStates, int round) {
		 int start = 0;
		 int sz = states.length;
		 for (int i = 0;
		 i < sz;
		 i++) {
			 NfaState tmp1, tmp2;
			 if ((tmp1 = states[i]) == null) break;
			 if (tmp1.CanMoveUsingChar(c)) {
				 if (tmp1.kindToPrint != Integer.MAX_VALUE) {
					 newStates[start] = null;
					 return 1;
				 }
				 NfaState[] v = tmp1.next.epsilonMoveArray;
				 for (int j = v.length;
				 j-- > 0;
				) {
					 if ((tmp2 = v[j]).round != round) {
						 tmp2.round = round;
						 newStates[start++] = tmp2;
					 }
				 }
			 }
		 }
		 newStates[start] = null;
		 return Integer.MAX_VALUE;
	 }
	 static List allBitVectors = new ArrayList();
	 static int[] tmpIndices = new int[512];
	 void GenerateNonAsciiMoves(java.io.PrintWriter ostr) {
		 int i = 0, j = 0;
		 char hiByte;
		 int cnt = 0;
		 long[][] loBytes = new long[256][4];
		 if ((charMoves == null || charMoves[0] == 0) && (rangeMoves == null || rangeMoves[0] == 0)) return;
		 if (charMoves != null) {
			 for (i = 0;
			 i < charMoves.length;
			 i++) {
				 if (charMoves[i] == 0) break;
				 hiByte = (char)(charMoves[i] >> 8);
				 loBytes[hiByte][(charMoves[i] & 0xff) / 64] |= (1L << ((charMoves[i] & 0xff) % 64));
			 }
		 }
		 if (rangeMoves != null) {
			 for (i = 0;
			 i < rangeMoves.length;
			 i += 2) {
				 if (rangeMoves[i] == 0) break;
				 char c, r;
				 r = (char)(rangeMoves[i + 1] & 0xff);
				 hiByte = (char)(rangeMoves[i] >> 8);
				 if (hiByte == (char)(rangeMoves[i + 1] >> 8)) {
					 for (c = (char)(rangeMoves[i] & 0xff);
					 c <= r;
					 c++) loBytes[hiByte][c / 64] |= (1L << (c % 64));
					 continue;
				 }
				 for (c = (char)(rangeMoves[i] & 0xff);
				 c <= 0xff;
				 c++) loBytes[hiByte][c / 64] |= (1L << (c % 64));
				 while (++hiByte < (char)(rangeMoves[i + 1] >> 8)) {
					 loBytes[hiByte][0] |= 0xffffffffffffffffL;
					 loBytes[hiByte][1] |= 0xffffffffffffffffL;
					 loBytes[hiByte][2] |= 0xffffffffffffffffL;
					 loBytes[hiByte][3] |= 0xffffffffffffffffL;
				 }
				 for (c = 0;
				 c <= r;
				 c++) loBytes[hiByte][c / 64] |= (1L << (c % 64));
			 }
		 }
		 long[] common = null;
		 boolean[] done = new boolean[256];
		 for (i = 0;
		 i <= 255;
		 i++) {
			 if (done[i] || (done[i] = loBytes[i][0] == 0 && loBytes[i][1] == 0 && loBytes[i][2] == 0 && loBytes[i][3] == 0)) continue;
			 for (j = i + 1;
			 j < 256;
			 j++) {
				 if (done[j]) continue;
				 if (loBytes[i][0] == loBytes[j][0] && loBytes[i][1] == loBytes[j][1] && loBytes[i][2] == loBytes[j][2] && loBytes[i][3] == loBytes[j][3]) {
					 done[j] = true;
					 if (common == null) {
						 done[i] = true;
						 common = new long[4];
						 common[i / 64] |= (1L << (i % 64));
					 }
					 common[j / 64] |= (1L << (j % 64));
				 }
			 }
			 if (common != null) {
				 Integer ind;
				 String tmp;
				 tmp = ""{
				\n 0x"" + Long.toHexString(common[0]) + ""L, "" + ""0x"" + Long.toHexString(common[1]) + ""L, "" + ""0x"" + Long.toHexString(common[2]) + ""L, "" + ""0x"" + Long.toHexString(common[3]) + ""L\n}
				;
				"";
				 if ((ind = (Integer)lohiByteTab.get(tmp)) == null) {
					 allBitVectors.add(tmp);
					 if (!AllBitsSet(tmp)) ostr.println(""static final long[] jjbitVec"" + lohiByteCnt + "" = "" + tmp);
					 lohiByteTab.put(tmp, ind = new Integer(lohiByteCnt++));
				 }
				 tmpIndices[cnt++] = ind.intValue();
				 tmp = ""{
				\n 0x"" + Long.toHexString(loBytes[i][0]) + ""L, "" + ""0x"" + Long.toHexString(loBytes[i][1]) + ""L, "" + ""0x"" + Long.toHexString(loBytes[i][2]) + ""L, "" + ""0x"" + Long.toHexString(loBytes[i][3]) + ""L\n}
				;
				"";
				 if ((ind = (Integer)lohiByteTab.get(tmp)) == null) {
					 allBitVectors.add(tmp);
					 if (!AllBitsSet(tmp)) ostr.println(""static final long[] jjbitVec"" + lohiByteCnt + "" = "" + tmp);
					 lohiByteTab.put(tmp, ind = new Integer(lohiByteCnt++));
				 }
				 tmpIndices[cnt++] = ind.intValue();
				 common = null;
			 }
		 }
		 nonAsciiMoveIndices = new int[cnt];
		 System.arraycopy(tmpIndices, 0, nonAsciiMoveIndices, 0, cnt);
		 for (i = 0;
		 i < 256;
		 i++) {
			 if (done[i]) loBytes[i] = null;
			 else {
				 String tmp;
				 Integer ind;
				 tmp = ""{
				\n 0x"" + Long.toHexString(loBytes[i][0]) + ""L, "" + ""0x"" + Long.toHexString(loBytes[i][1]) + ""L, "" + ""0x"" + Long.toHexString(loBytes[i][2]) + ""L, "" + ""0x"" + Long.toHexString(loBytes[i][3]) + ""L\n}
				;
				"";
				 if ((ind = (Integer)lohiByteTab.get(tmp)) == null) {
					 allBitVectors.add(tmp);
					 if (!AllBitsSet(tmp)) ostr.println(""static final long[] jjbitVec"" + lohiByteCnt + "" = "" + tmp);
					 lohiByteTab.put(tmp, ind = new Integer(lohiByteCnt++));
				 }
				 if (loByteVec == null) loByteVec = new Vector();
				 loByteVec.add(new Integer(i));
				 loByteVec.add(ind);
			 }
		 }
		 UpdateDuplicateNonAsciiMoves();
	 }
	 private void UpdateDuplicateNonAsciiMoves() {
		 for (int i = 0;
		 i < nonAsciiTableForMethod.size();
		 i++) {
			 NfaState tmp = (NfaState)nonAsciiTableForMethod.get(i);
			 if (EqualLoByteVectors(loByteVec, tmp.loByteVec) && EqualNonAsciiMoveIndices(nonAsciiMoveIndices, tmp.nonAsciiMoveIndices)) {
				 nonAsciiMethod = i;
				 return;
			 }
		 }
		 nonAsciiMethod = nonAsciiTableForMethod.size();
		 nonAsciiTableForMethod.add(this);
	 }
	 private static boolean EqualLoByteVectors(List vec1, List vec2) {
		 if (vec1 == null || vec2 == null) return false;
		 if (vec1 == vec2) return true;
		 if (vec1.size() != vec2.size()) return false;
		 for (int i = 0;
		 i < vec1.size();
		 i++) {
			 if (((Integer)vec1.get(i)).intValue() != ((Integer)vec2.get(i)).intValue()) return false;
		 }
		 return true;
	 }
	 private static boolean EqualNonAsciiMoveIndices(int[] moves1, int[] moves2) {
		 if (moves1 == moves2) return true;
		 if (moves1 == null || moves2 == null) return false;
		 if (moves1.length != moves2.length) return false;
		 for (int i = 0;
		 i < moves1.length;
		 i++) {
			 if (moves1[i] != moves2[i]) return false;
		 }
		 return true;
	 }
	 static String allBits = ""{
	\n 0xffffffffffffffffL, "" + ""0xffffffffffffffffL, "" + ""0xffffffffffffffffL, "" + ""0xffffffffffffffffL\n}
	;
	"";
	 static boolean AllBitsSet(String bitVec) {
		 return bitVec.equals(allBits);
	 }
	 static int AddStartStateSet(String stateSetString) {
		 return AddCompositeStateSet(stateSetString, true);
	 }
	 private static int AddCompositeStateSet(String stateSetString, boolean starts) {
		 Integer stateNameToReturn;
		 if ((stateNameToReturn = (Integer)stateNameForComposite.get(stateSetString)) != null) return stateNameToReturn.intValue();
		 int toRet = 0;
		 int[] nameSet = (int[])allNextStates.get(stateSetString);
		 if (!starts) stateBlockTable.put(stateSetString, stateSetString);
		 if (nameSet == null) throw new Error(""JavaCC Bug: Please send mail to sankar;
		 nameSet null for : "" + stateSetString);
		 if (nameSet.length == 1) {
			 stateNameToReturn = new Integer(nameSet[0]);
			 stateNameForComposite.put(stateSetString, stateNameToReturn);
			 return nameSet[0];
		 }
		 for (int i = 0;
		 i < nameSet.length;
		 i++) {
			 if (nameSet[i] == -1) continue;
			 NfaState st = (NfaState)indexedAllStates.get(nameSet[i]);
			 st.isComposite = true;
			 st.compositeStates = nameSet;
		 }
		 while (toRet < nameSet.length && (starts && ((NfaState)indexedAllStates.get(nameSet[toRet])).inNextOf > 1)) toRet++;
		 Enumeration e = compositeStateTable.keys();
		 String s;
		 while (e.hasMoreElements()) {
			 s = (String)e.nextElement();
			 if (!s.equals(stateSetString) && Intersect(stateSetString, s)) {
				 int[] other = (int[])compositeStateTable.get(s);
				 while (toRet < nameSet.length && ((starts && ((NfaState)indexedAllStates.get(nameSet[toRet])).inNextOf > 1) || ElemOccurs(nameSet[toRet], other) >= 0)) toRet++;
			 }
		 }
		 int tmp;
		 if (toRet >= nameSet.length) {
			 if (dummyStateIndex == -1) tmp = dummyStateIndex = generatedStates;
			 else tmp = ++dummyStateIndex;
		 }
		 else tmp = nameSet[toRet];
		 stateNameToReturn = new Integer(tmp);
		 stateNameForComposite.put(stateSetString, stateNameToReturn);
		 compositeStateTable.put(stateSetString, nameSet);
		 return tmp;
	 }
	 private static int StateNameForComposite(String stateSetString) {
		 return ((Integer)stateNameForComposite.get(stateSetString)).intValue();
	 }
	 static int InitStateName() {
		 String s = LexGen.initialState.GetEpsilonMovesString();
		 if (LexGen.initialState.usefulEpsilonMoves != 0) return StateNameForComposite(s);
		 return -1;
	 }
	 public void GenerateInitMoves(java.io.PrintWriter ostr) {
		 GetEpsilonMovesString();
		 if (epsilonMovesString == null) epsilonMovesString = ""null;
		"";
		 AddStartStateSet(epsilonMovesString);
	 }
	 static Hashtable tableToDump = new Hashtable();
	 static List orderedStateSet = new ArrayList();
	 static int lastIndex = 0;
	 private static int[] GetStateSetIndicesForUse(String arrayString) {
		 int[] ret;
		 int[] set = (int[])allNextStates.get(arrayString);
		 if ((ret = (int[])tableToDump.get(arrayString)) == null) {
			 ret = new int[2];
			 ret[0] = lastIndex;
			 ret[1] = lastIndex + set.length - 1;
			 lastIndex += set.length;
			 tableToDump.put(arrayString, ret);
			 orderedStateSet.add(set);
		 }
		 return ret;
	 }
	 public static void DumpStateSets(java.io.PrintWriter ostr) {
		 int cnt = 0;
		 ostr.print(""static final int[] jjnextStates = {
			"");
			 for (int i = 0;
			 i < orderedStateSet.size();
			 i++) {
				 int[] set = (int[])orderedStateSet.get(i);
				 for (int j = 0;
				 j < set.length;
				 j++) {
					 if (cnt++ % 16 == 0) ostr.print(""\n "");
					 ostr.print(set[j] + "", "");
				 }
			 }
		 ostr.println(""\n}
		;
		"");
	 }
	 static String GetStateSetString(int[] states) {
		 String retVal = ""{
			 "";
			 for (int i = 0;
			 i < states.length;
			 ) {
				 retVal += states[i] + "", "";
				 if (i++ > 0 && i % 16 == 0) retVal += ""\n"";
			 }
		 retVal += ""}
		;
		"";
		 allNextStates.put(retVal, states);
		 return retVal;
	 }
	 static String GetStateSetString(List states) {
		 if (states == null || states.size() == 0) return ""null;
		"";
		 int[] set = new int[states.size()];
		 String retVal = ""{
			 "";
			 for (int i = 0;
			 i < states.size();
			 ) {
				 int k;
				 retVal += (k = ((NfaState)states.get(i)).stateName) + "", "";
				 set[i] = k;
				 if (i++ > 0 && i % 16 == 0) retVal += ""\n"";
			 }
		 retVal += ""}
		;
		"";
		 allNextStates.put(retVal, set);
		 return retVal;
	 }
	 static int NumberOfBitsSet(long l) {
		 int ret = 0;
		 for (int i = 0;
		 i < 63;
		 i++) if (((l >> i) & 1L) != 0L) ret++;
		 return ret;
	 }
	 static int OnlyOneBitSet(long l) {
		 int oneSeen = -1;
		 for (int i = 0;
		 i < 64;
		 i++) if (((l >> i) & 1L) != 0L) {
			 if (oneSeen >= 0) return -1;
			 oneSeen = i;
		 }
		 return oneSeen;
	 }
	 private static int ElemOccurs(int elem, int[] arr) {
		 for (int i = arr.length;
		 i-- > 0;
		) if (arr[i] == elem) return i;
		 return -1;
	 }
	 private boolean FindCommonBlocks() {
		 if (next == null || next.usefulEpsilonMoves <= 1) return false;
		 if (stateDone == null) stateDone = new boolean[generatedStates];
		 String set = next.epsilonMovesString;
		 int[] nameSet = (int[])allNextStates.get(set);
		 if (nameSet.length <= 2 || compositeStateTable.get(set) != null) return false;
		 int i;
		 int freq[] = new int[nameSet.length];
		 boolean live[] = new boolean[nameSet.length];
		 int[] count = new int[allNextStates.size()];
		 for (i = 0;
		 i < nameSet.length;
		 i++) {
			 if (nameSet[i] != -1) {
				 if (live[i] = !stateDone[nameSet[i]]) count[0]++;
			 }
		 }
		 int j, blockLen = 0, commonFreq = 0;
		 Enumeration e = allNextStates.keys();
		 boolean needUpdate;
		 while (e.hasMoreElements()) {
			 int[] tmpSet = (int[])allNextStates.get(e.nextElement());
			 if (tmpSet == nameSet) continue;
			 needUpdate = false;
			 for (j = 0;
			 j < nameSet.length;
			 j++) {
				 if (nameSet[j] == -1) continue;
				 if (live[j] && ElemOccurs(nameSet[j], tmpSet) >= 0) {
					 if (!needUpdate) {
						 needUpdate = true;
						 commonFreq++;
					 }
					 count[freq[j]]--;
					 count[commonFreq]++;
					 freq[j] = commonFreq;
				 }
			 }
			 if (needUpdate) {
				 int foundFreq = -1;
				 blockLen = 0;
				 for (j = 0;
				 j <= commonFreq;
				 j++) if (count[j] > blockLen) {
					 foundFreq = j;
					 blockLen = count[j];
				 }
				 if (blockLen <= 1) return false;
				 for (j = 0;
				 j < nameSet.length;
				 j++) if (nameSet[j] != -1 && freq[j] != foundFreq) {
					 live[j] = false;
					 count[freq[j]]--;
				 }
			 }
		 }
		 if (blockLen <= 1) return false;
		 int[] commonBlock = new int[blockLen];
		 int cnt = 0;
		 for (i = 0;
		 i < nameSet.length;
		 i++) {
			 if (live[i]) {
				 if (((NfaState)indexedAllStates.get(nameSet[i])).isComposite) return false;
				 stateDone[nameSet[i]] = true;
				 commonBlock[cnt++] = nameSet[i];
			 }
		 }
		 String s = GetStateSetString(commonBlock);
		 e = allNextStates.keys();
		 Outer : while (e.hasMoreElements()) {
			 int at;
			 boolean firstOne = true;
			 String stringToFix;
			 int[] setToFix = (int[])allNextStates.get(stringToFix = (String)e.nextElement());
			 if (setToFix == commonBlock) continue;
			 for (int k = 0;
			 k < cnt;
			 k++) {
				 if ((at = ElemOccurs(commonBlock[k], setToFix)) >= 0) {
					 if (!firstOne) setToFix[at] = -1;
					 firstOne = false;
				 }
				 else continue Outer;
			 }
			 if (stateSetsToFix.get(stringToFix) == null) stateSetsToFix.put(stringToFix, setToFix);
		 }
		 next.usefulEpsilonMoves -= blockLen - 1;
		 AddCompositeStateSet(s, false);
		 return true;
	 }
	 private boolean CheckNextOccursTogether() {
		 if (next == null || next.usefulEpsilonMoves <= 1) return true;
		 String set = next.epsilonMovesString;
		 int[] nameSet = (int[])allNextStates.get(set);
		 if (nameSet.length == 1 || compositeStateTable.get(set) != null || stateSetsToFix.get(set) != null) return false;
		 int i;
		 Hashtable occursIn = new Hashtable();
		 NfaState tmp = (NfaState)allStates.get(nameSet[0]);
		 for (i = 1;
		 i < nameSet.length;
		 i++) {
			 NfaState tmp1 = (NfaState)allStates.get(nameSet[i]);
			 if (tmp.inNextOf != tmp1.inNextOf) return false;
		 }
		 int isPresent, j;
		 Enumeration e = allNextStates.keys();
		 while (e.hasMoreElements()) {
			 String s;
			 int[] tmpSet = (int[])allNextStates.get(s = (String)e.nextElement());
			 if (tmpSet == nameSet) continue;
			 isPresent = 0;
			 for (j = 0;
			 j < nameSet.length;
			 j++) {
				 if (ElemOccurs(nameSet[j], tmpSet) >= 0) isPresent++;
				 else if (isPresent > 0) return false;
			 }
			 if (isPresent == j) {
				 if (tmpSet.length > nameSet.length) occursIn.put(s, tmpSet);
				 if (compositeStateTable.get(s) != null || stateSetsToFix.get(s) != null) return false;
			 }
			 else if (isPresent != 0) return false;
		 }
		 e = occursIn.keys();
		 while (e.hasMoreElements()) {
			 String s;
			 int[] setToFix = (int[])occursIn.get(s = (String)e.nextElement());
			 if (stateSetsToFix.get(s) == null) stateSetsToFix.put(s, setToFix);
			 for (int k = 0;
			 k < setToFix.length;
			 k++) if (ElemOccurs(setToFix[k], nameSet) > 0) setToFix[k] = -1;
		 }
		 next.usefulEpsilonMoves = 1;
		 AddCompositeStateSet(next.epsilonMovesString, false);
		 return true;
	 }
	 private static void FixStateSets() {
		 Hashtable fixedSets = new Hashtable();
		 Enumeration e = stateSetsToFix.keys();
		 int[] tmp = new int[generatedStates];
		 int i;
		 while (e.hasMoreElements()) {
			 String s;
			 int[] toFix = (int[])stateSetsToFix.get(s = (String)e.nextElement());
			 int cnt = 0;
			 for (i = 0;
			 i < toFix.length;
			 i++) {
				 if (toFix[i] != -1) tmp[cnt++] = toFix[i];
			 }
			 int[] fixed = new int[cnt];
			 System.arraycopy(tmp, 0, fixed, 0, cnt);
			 fixedSets.put(s, fixed);
			 allNextStates.put(s, fixed);
		 }
		 for (i = 0;
		 i < allStates.size();
		 i++) {
			 NfaState tmpState = (NfaState)allStates.get(i);
			 int[] newSet;
			 if (tmpState.next == null || tmpState.next.usefulEpsilonMoves == 0) continue;
			 if ((newSet = (int[])fixedSets.get(tmpState.next.epsilonMovesString)) != null) tmpState.FixNextStates(newSet);
		 }
	 }
	 private final void FixNextStates(int[] newSet) {
		 next.usefulEpsilonMoves = newSet.length;
	 }
	 private static boolean Intersect(String set1, String set2) {
		 if (set1 == null || set2 == null) return false;
		 int[] nameSet1 = (int[])allNextStates.get(set1);
		 int[] nameSet2 = (int[])allNextStates.get(set2);
		 if (nameSet1 == null || nameSet2 == null) return false;
		 if (nameSet1 == nameSet2) return true;
		 for (int i = nameSet1.length;
		 i-- > 0;
		 ) for (int j = nameSet2.length;
		 j-- > 0;
		 ) if (nameSet1[i] == nameSet2[j]) return true;
		 return false;
	 }
	 private static void DumpHeadForCase(java.io.PrintWriter ostr, int byteNum) {
		 if (byteNum == 0) ostr.println("" long l = 1L << curChar;
		"");
		 else if (byteNum == 1) ostr.println("" long l = 1L << (curChar & 077);
		"");
		 else {
			 if (Options.getJavaUnicodeEscape() || unicodeWarningGiven) {
				 ostr.println("" int hiByte = (int)(curChar >> 8);
				"");
				 ostr.println("" int i1 = hiByte >> 6;
				"");
				 ostr.println("" long l1 = 1L << (hiByte & 077);
				"");
			 }
			 ostr.println("" int i2 = (curChar & 0xff) >> 6;
			"");
			 ostr.println("" long l2 = 1L << (curChar & 077);
			"");
		 }
		 ostr.println("" do"");
		 ostr.println("" {
			"");
			 ostr.println("" switch(jjstateSet[--i])"");
			 ostr.println("" {
				"");
			 }
			 private static Vector PartitionStatesSetForAscii(int[] states, int byteNum) {
				 int[] cardinalities = new int[states.length];
				 Vector original = new Vector();
				 Vector partition = new Vector();
				 NfaState tmp;
				 original.setSize(states.length);
				 int cnt = 0;
				 for (int i = 0;
				 i < states.length;
				 i++) {
					 tmp = (NfaState)allStates.get(states[i]);
					 if (tmp.asciiMoves[byteNum] != 0L) {
						 int j;
						 int p = NumberOfBitsSet(tmp.asciiMoves[byteNum]);
						 for (j = 0;
						 j < i;
						 j++) if (cardinalities[j] <= p) break;
						 for (int k = i;
						 k > j;
						 k--) cardinalities[k] = cardinalities[k - 1];
						 cardinalities[j] = p;
						 original.insertElementAt(tmp, j);
						 cnt++;
					 }
				 }
				 original.setSize(cnt);
				 while (original.size() > 0) {
					 tmp = (NfaState)original.get(0);
					 original.removeElement(tmp);
					 long bitVec = tmp.asciiMoves[byteNum];
					 List subSet = new ArrayList();
					 subSet.add(tmp);
					 for (int j = 0;
					 j < original.size();
					 j++) {
						 NfaState tmp1 = (NfaState)original.get(j);
						 if ((tmp1.asciiMoves[byteNum] & bitVec) == 0L) {
							 bitVec |= tmp1.asciiMoves[byteNum];
							 subSet.add(tmp1);
							 original.removeElementAt(j--);
						 }
					 }
					 partition.add(subSet);
				 }
				 return partition;
			 }
			 private String PrintNoBreak(java.io.PrintWriter ostr, int byteNum, boolean[] dumped) {
				 if (inNextOf != 1) throw new Error(""JavaCC Bug: Please send mail to sankar"");
				 dumped[stateName] = true;
				 if (byteNum >= 0) {
					 if (asciiMoves[byteNum] != 0L) {
						 ostr.println("" case "" + stateName + "":"");
						 DumpAsciiMoveForCompositeState(ostr, byteNum, false);
						 return """";
					 }
				 }
				 else if (nonAsciiMethod != -1) {
					 ostr.println("" case "" + stateName + "":"");
					 DumpNonAsciiMoveForCompositeState(ostr);
					 return """";
				 }
				 return ("" case "" + stateName + "":\n"");
			 }
			 private static void DumpCompositeStatesAsciiMoves(java.io.PrintWriter ostr, String key, int byteNum, boolean[] dumped) {
				 int i;
				 int[] nameSet = (int[])allNextStates.get(key);
				 if (nameSet.length == 1 || dumped[StateNameForComposite(key)]) return;
				 NfaState toBePrinted = null;
				 int neededStates = 0;
				 NfaState tmp;
				 NfaState stateForCase = null;
				 String toPrint = """";
				 boolean stateBlock = (stateBlockTable.get(key) != null);
				 for (i = 0;
				 i < nameSet.length;
				 i++) {
					 tmp = (NfaState)allStates.get(nameSet[i]);
					 if (tmp.asciiMoves[byteNum] != 0L) {
						 if (neededStates++ == 1) break;
						 else toBePrinted = tmp;
					 }
					 else dumped[tmp.stateName] = true;
					 if (tmp.stateForCase != null) {
						 if (stateForCase != null) throw new Error(""JavaCC Bug: Please send mail to sankar : "");
						 stateForCase = tmp.stateForCase;
					 }
				 }
				 if (stateForCase != null) toPrint = stateForCase.PrintNoBreak(ostr, byteNum, dumped);
				 if (neededStates == 0) {
					 if (stateForCase != null && toPrint.equals("""")) ostr.println("" break;
					"");
					 return;
				 }
				 if (neededStates == 1) {
					 if (!toPrint.equals("""")) ostr.print(toPrint);
					 ostr.println("" case "" + StateNameForComposite(key) + "":"");
					 if (!dumped[toBePrinted.stateName] && !stateBlock && toBePrinted.inNextOf > 1) ostr.println("" case "" + toBePrinted.stateName + "":"");
					 dumped[toBePrinted.stateName] = true;
					 toBePrinted.DumpAsciiMove(ostr, byteNum, dumped);
					 return;
				 }
				 List partition = PartitionStatesSetForAscii(nameSet, byteNum);
				 if (!toPrint.equals("""")) ostr.print(toPrint);
				 int keyState = StateNameForComposite(key);
				 ostr.println("" case "" + keyState + "":"");
				 if (keyState < generatedStates) dumped[keyState] = true;
				 for (i = 0;
				 i < partition.size();
				 i++) {
					 List subSet = (List)partition.get(i);
					 for (int j = 0;
					 j < subSet.size();
					 j++) {
						 tmp = (NfaState)subSet.get(j);
						 if (stateBlock) dumped[tmp.stateName] = true;
						 tmp.DumpAsciiMoveForCompositeState(ostr, byteNum, j != 0);
					 }
				 }
				 if (stateBlock) ostr.println("" break;
				"");
				 else ostr.println("" break;
				"");
			 }
			 private boolean selfLoop() {
				 if (next == null || next.epsilonMovesString == null) return false;
				 int[] set = (int[])allNextStates.get(next.epsilonMovesString);
				 return ElemOccurs(stateName, set) >= 0;
			 }
			 private void DumpAsciiMoveForCompositeState(java.io.PrintWriter ostr, int byteNum, boolean elseNeeded) {
				 boolean nextIntersects = selfLoop();
				 for (int j = 0;
				 j < allStates.size();
				 j++) {
					 NfaState temp1 = (NfaState)allStates.get(j);
					 if (this == temp1 || temp1.stateName == -1 || temp1.dummy || stateName == temp1.stateName || temp1.asciiMoves[byteNum] == 0L) continue;
					 if (!nextIntersects && Intersect(temp1.next.epsilonMovesString, next.epsilonMovesString)) {
						 nextIntersects = true;
						 break;
					 }
				 }
				 String prefix = """";
				 if (asciiMoves[byteNum] != 0xffffffffffffffffL) {
					 int oneBit = OnlyOneBitSet(asciiMoves[byteNum]);
					 if (oneBit != -1) ostr.println("" "" + (elseNeeded ? ""else "" : """") + ""if (curChar == "" + (64 * byteNum + oneBit) + "")"");
					 else ostr.println("" "" + (elseNeeded ? ""else "" : """") + ""if ((0x"" + Long.toHexString(asciiMoves[byteNum]) + ""L & l) != 0L)"");
					 prefix = "" "";
				 }
				 if (kindToPrint != Integer.MAX_VALUE) {
					 if (asciiMoves[byteNum] != 0xffffffffffffffffL) {
						 ostr.println("" {
							"");
						 }
						 ostr.println(prefix + "" if (kind > "" + kindToPrint + "")"");
						 ostr.println(prefix + "" kind = "" + kindToPrint + "";
						"");
					 }
					 if (next != null && next.usefulEpsilonMoves > 0) {
						 int[] stateNames = (int[])allNextStates.get( next.epsilonMovesString);
						 if (next.usefulEpsilonMoves == 1) {
							 int name = stateNames[0];
							 if (nextIntersects) ostr.println(prefix + "" jjCheckNAdd("" + name + "");
							"");
							 else ostr.println(prefix + "" jjstateSet[jjnewStateCnt++] = "" + name + "";
							"");
						 }
						 else if (next.usefulEpsilonMoves == 2 && nextIntersects) {
							 ostr.println(prefix + "" jjCheckNAddTwoStates("" + stateNames[0] + "", "" + stateNames[1] + "");
							"");
						 }
						 else {
							 int[] indices = GetStateSetIndicesForUse(next.epsilonMovesString);
							 boolean notTwo = (indices[0] + 1 != indices[1]);
							 if (nextIntersects) {
								 ostr.print(prefix + "" jjCheckNAddStates("" + indices[0]);
								 if (notTwo) {
									 jjCheckNAddStatesDualNeeded = true;
									 ostr.print("", "" + indices[1]);
								 }
								 else {
									 jjCheckNAddStatesUnaryNeeded = true;
								 }
								 ostr.println("");
								"");
							 }
							 else ostr.println(prefix + "" jjAddStates("" + indices[0] + "", "" + indices[1] + "");
							"");
						 }
					 }
				 if (asciiMoves[byteNum] != 0xffffffffffffffffL && kindToPrint != Integer.MAX_VALUE) ostr.println("" }
				"");
			 }
			 private void DumpAsciiMove(java.io.PrintWriter ostr, int byteNum, boolean dumped[]) {
				 boolean nextIntersects = selfLoop() && isComposite;
				 boolean onlyState = true;
				 for (int j = 0;
				 j < allStates.size();
				 j++) {
					 NfaState temp1 = (NfaState)allStates.get(j);
					 if (this == temp1 || temp1.stateName == -1 || temp1.dummy || stateName == temp1.stateName || temp1.asciiMoves[byteNum] == 0L) continue;
					 if (onlyState && (asciiMoves[byteNum] & temp1.asciiMoves[byteNum]) != 0L) onlyState = false;
					 if (!nextIntersects && Intersect(temp1.next.epsilonMovesString, next.epsilonMovesString)) nextIntersects = true;
					 if (!dumped[temp1.stateName] && !temp1.isComposite && asciiMoves[byteNum] == temp1.asciiMoves[byteNum] && kindToPrint == temp1.kindToPrint && (next.epsilonMovesString == temp1.next.epsilonMovesString || (next.epsilonMovesString != null && temp1.next.epsilonMovesString != null && next.epsilonMovesString.equals( temp1.next.epsilonMovesString)))) {
						 dumped[temp1.stateName] = true;
						 ostr.println("" case "" + temp1.stateName + "":"");
					 }
				 }
				 int oneBit = OnlyOneBitSet(asciiMoves[byteNum]);
				 if (asciiMoves[byteNum] != 0xffffffffffffffffL) {
					 if ((next == null || next.usefulEpsilonMoves == 0) && kindToPrint != Integer.MAX_VALUE) {
						 String kindCheck = """";
						 if (!onlyState) kindCheck = "" && kind > "" + kindToPrint;
						 if (oneBit != -1) ostr.println("" if (curChar == "" + (64 * byteNum + oneBit) + kindCheck + "")"");
						 else ostr.println("" if ((0x"" + Long.toHexString(asciiMoves[byteNum]) + ""L & l) != 0L"" + kindCheck + "")"");
						 ostr.println("" kind = "" + kindToPrint + "";
						"");
						 if (onlyState) ostr.println("" break;
						"");
						 else ostr.println("" break;
						"");
						 return;
					 }
				 }
				 String prefix = """";
				 if (kindToPrint != Integer.MAX_VALUE) {
					 if (oneBit != -1) {
						 ostr.println("" if (curChar != "" + (64 * byteNum + oneBit) + "")"");
						 ostr.println("" break;
						"");
					 }
					 else if (asciiMoves[byteNum] != 0xffffffffffffffffL) {
						 ostr.println("" if ((0x"" + Long.toHexString(asciiMoves[byteNum]) + ""L & l) == 0L)"");
						 ostr.println("" break;
						"");
					 }
					 if (onlyState) {
						 ostr.println("" kind = "" + kindToPrint + "";
						"");
					 }
					 else {
						 ostr.println("" if (kind > "" + kindToPrint + "")"");
						 ostr.println("" kind = "" + kindToPrint + "";
						"");
					 }
				 }
				 else {
					 if (oneBit != -1) {
						 ostr.println("" if (curChar == "" + (64 * byteNum + oneBit) + "")"");
						 prefix = "" "";
					 }
					 else if (asciiMoves[byteNum] != 0xffffffffffffffffL) {
						 ostr.println("" if ((0x"" + Long.toHexString(asciiMoves[byteNum]) + ""L & l) != 0L)"");
						 prefix = "" "";
					 }
				 }
				 if (next != null && next.usefulEpsilonMoves > 0) {
					 int[] stateNames = (int[])allNextStates.get( next.epsilonMovesString);
					 if (next.usefulEpsilonMoves == 1) {
						 int name = stateNames[0];
						 if (nextIntersects) ostr.println(prefix + "" jjCheckNAdd("" + name + "");
						"");
						 else ostr.println(prefix + "" jjstateSet[jjnewStateCnt++] = "" + name + "";
						"");
					 }
					 else if (next.usefulEpsilonMoves == 2 && nextIntersects) {
						 ostr.println(prefix + "" jjCheckNAddTwoStates("" + stateNames[0] + "", "" + stateNames[1] + "");
						"");
					 }
					 else {
						 int[] indices = GetStateSetIndicesForUse(next.epsilonMovesString);
						 boolean notTwo = (indices[0] + 1 != indices[1]);
						 if (nextIntersects) {
							 ostr.print(prefix + "" jjCheckNAddStates("" + indices[0]);
							 if (notTwo) {
								 jjCheckNAddStatesDualNeeded = true;
								 ostr.print("", "" + indices[1]);
							 }
							 else {
								 jjCheckNAddStatesUnaryNeeded = true;
							 }
							 ostr.println("");
							"");
						 }
						 else ostr.println(prefix + "" jjAddStates("" + indices[0] + "", "" + indices[1] + "");
						"");
					 }
				 }
				 if (onlyState) ostr.println("" break;
				"");
				 else ostr.println("" break;
				"");
			 }
			 private static void DumpAsciiMoves(java.io.PrintWriter ostr, int byteNum) {
				 boolean[] dumped = new boolean[Math.max(generatedStates, dummyStateIndex + 1)];
				 Enumeration e = compositeStateTable.keys();
				 DumpHeadForCase(ostr, byteNum);
				 while (e.hasMoreElements()) DumpCompositeStatesAsciiMoves(ostr, (String)e.nextElement(), byteNum, dumped);
				 for (int i = 0;
				 i < allStates.size();
				 i++) {
					 NfaState temp = (NfaState)allStates.get(i);
					 if (dumped[temp.stateName] || temp.lexState != LexGen.lexStateIndex || !temp.HasTransitions() || temp.dummy || temp.stateName == -1) continue;
					 String toPrint = """";
					 if (temp.stateForCase != null) {
						 if (temp.inNextOf == 1) continue;
						 if (dumped[temp.stateForCase.stateName]) continue;
						 toPrint = (temp.stateForCase.PrintNoBreak(ostr, byteNum, dumped));
						 if (temp.asciiMoves[byteNum] == 0L) {
							 if (toPrint.equals("""")) ostr.println("" break;
							"");
							 continue;
						 }
					 }
					 if (temp.asciiMoves[byteNum] == 0L) continue;
					 if (!toPrint.equals("""")) ostr.print(toPrint);
					 dumped[temp.stateName] = true;
					 ostr.println("" case "" + temp.stateName + "":"");
					 temp.DumpAsciiMove(ostr, byteNum, dumped);
				 }
				 ostr.println("" default : break;
				"");
			 ostr.println("" }
			"");
		 ostr.println("" }
		 while(i != startsAt);
		"");
	 }
	 private static void DumpCompositeStatesNonAsciiMoves(java.io.PrintWriter ostr, String key, boolean[] dumped) {
		 int i;
		 int[] nameSet = (int[])allNextStates.get(key);
		 if (nameSet.length == 1 || dumped[StateNameForComposite(key)]) return;
		 NfaState toBePrinted = null;
		 int neededStates = 0;
		 NfaState tmp;
		 NfaState stateForCase = null;
		 String toPrint = """";
		 boolean stateBlock = (stateBlockTable.get(key) != null);
		 for (i = 0;
		 i < nameSet.length;
		 i++) {
			 tmp = (NfaState)allStates.get(nameSet[i]);
			 if (tmp.nonAsciiMethod != -1) {
				 if (neededStates++ == 1) break;
				 else toBePrinted = tmp;
			 }
			 else dumped[tmp.stateName] = true;
			 if (tmp.stateForCase != null) {
				 if (stateForCase != null) throw new Error(""JavaCC Bug: Please send mail to sankar : "");
				 stateForCase = tmp.stateForCase;
			 }
		 }
		 if (stateForCase != null) toPrint = stateForCase.PrintNoBreak(ostr, -1, dumped);
		 if (neededStates == 0) {
			 if (stateForCase != null && toPrint.equals("""")) ostr.println("" break;
			"");
			 return;
		 }
		 if (neededStates == 1) {
			 if (!toPrint.equals("""")) ostr.print(toPrint);
			 ostr.println("" case "" + StateNameForComposite(key) + "":"");
			 if (!dumped[toBePrinted.stateName] && !stateBlock && toBePrinted.inNextOf > 1) ostr.println("" case "" + toBePrinted.stateName + "":"");
			 dumped[toBePrinted.stateName] = true;
			 toBePrinted.DumpNonAsciiMove(ostr, dumped);
			 return;
		 }
		 if (!toPrint.equals("""")) ostr.print(toPrint);
		 int keyState = StateNameForComposite(key);
		 ostr.println("" case "" + keyState + "":"");
		 if (keyState < generatedStates) dumped[keyState] = true;
		 for (i = 0;
		 i < nameSet.length;
		 i++) {
			 tmp = (NfaState)allStates.get(nameSet[i]);
			 if (tmp.nonAsciiMethod != -1) {
				 if (stateBlock) dumped[tmp.stateName] = true;
				 tmp.DumpNonAsciiMoveForCompositeState(ostr);
			 }
		 }
		 if (stateBlock) ostr.println("" break;
		"");
		 else ostr.println("" break;
		"");
	 }
	 private final void DumpNonAsciiMoveForCompositeState(java.io.PrintWriter ostr) {
		 boolean nextIntersects = selfLoop();
		 for (int j = 0;
		 j < allStates.size();
		 j++) {
			 NfaState temp1 = (NfaState)allStates.get(j);
			 if (this == temp1 || temp1.stateName == -1 || temp1.dummy || stateName == temp1.stateName || (temp1.nonAsciiMethod == -1)) continue;
			 if (!nextIntersects && Intersect(temp1.next.epsilonMovesString, next.epsilonMovesString)) {
				 nextIntersects = true;
				 break;
			 }
		 }
		 if (!Options.getJavaUnicodeEscape() && !unicodeWarningGiven) {
			 if (loByteVec != null && loByteVec.size() > 1) ostr.println("" if ((jjbitVec"" + ((Integer)loByteVec.get(1)).intValue() + ""[i2"" + ""] & l2) != 0L)"");
		 }
		 else {
			 ostr.println("" if (jjCanMove_"" + nonAsciiMethod + ""(hiByte, i1, i2, l1, l2))"");
		 }
		 if (kindToPrint != Integer.MAX_VALUE) {
			 ostr.println("" {
				"");
				 ostr.println("" if (kind > "" + kindToPrint + "")"");
				 ostr.println("" kind = "" + kindToPrint + "";
				"");
			 }
			 if (next != null && next.usefulEpsilonMoves > 0) {
				 int[] stateNames = (int[])allNextStates.get( next.epsilonMovesString);
				 if (next.usefulEpsilonMoves == 1) {
					 int name = stateNames[0];
					 if (nextIntersects) ostr.println("" jjCheckNAdd("" + name + "");
					"");
					 else ostr.println("" jjstateSet[jjnewStateCnt++] = "" + name + "";
					"");
				 }
				 else if (next.usefulEpsilonMoves == 2 && nextIntersects) {
					 ostr.println("" jjCheckNAddTwoStates("" + stateNames[0] + "", "" + stateNames[1] + "");
					"");
				 }
				 else {
					 int[] indices = GetStateSetIndicesForUse(next.epsilonMovesString);
					 boolean notTwo = (indices[0] + 1 != indices[1]);
					 if (nextIntersects) {
						 ostr.print("" jjCheckNAddStates("" + indices[0]);
						 if (notTwo) {
							 jjCheckNAddStatesDualNeeded = true;
							 ostr.print("", "" + indices[1]);
						 }
						 else {
							 jjCheckNAddStatesUnaryNeeded = true;
						 }
						 ostr.println("");
						"");
					 }
					 else ostr.println("" jjAddStates("" + indices[0] + "", "" + indices[1] + "");
					"");
				 }
			 }
		 if (kindToPrint != Integer.MAX_VALUE) ostr.println("" }
		"");
	 }
	 private final void DumpNonAsciiMove(java.io.PrintWriter ostr, boolean dumped[]) {
		 boolean nextIntersects = selfLoop() && isComposite;
		 for (int j = 0;
		 j < allStates.size();
		 j++) {
			 NfaState temp1 = (NfaState)allStates.get(j);
			 if (this == temp1 || temp1.stateName == -1 || temp1.dummy || stateName == temp1.stateName || (temp1.nonAsciiMethod == -1)) continue;
			 if (!nextIntersects && Intersect(temp1.next.epsilonMovesString, next.epsilonMovesString)) nextIntersects = true;
			 if (!dumped[temp1.stateName] && !temp1.isComposite && nonAsciiMethod == temp1.nonAsciiMethod && kindToPrint == temp1.kindToPrint && (next.epsilonMovesString == temp1.next.epsilonMovesString || (next.epsilonMovesString != null && temp1.next.epsilonMovesString != null && next.epsilonMovesString.equals(temp1.next.epsilonMovesString)))) {
				 dumped[temp1.stateName] = true;
				 ostr.println("" case "" + temp1.stateName + "":"");
			 }
		 }
		 if (next == null || next.usefulEpsilonMoves <= 0) {
			 String kindCheck = "" && kind > "" + kindToPrint;
			 if (!Options.getJavaUnicodeEscape() && !unicodeWarningGiven) {
				 if (loByteVec != null && loByteVec.size() > 1) ostr.println("" if ((jjbitVec"" + ((Integer)loByteVec.get(1)).intValue() + ""[i2"" + ""] & l2) != 0L"" + kindCheck + "")"");
			 }
			 else {
				 ostr.println("" if (jjCanMove_"" + nonAsciiMethod + ""(hiByte, i1, i2, l1, l2)"" + kindCheck + "")"");
			 }
			 ostr.println("" kind = "" + kindToPrint + "";
			"");
			 ostr.println("" break;
			"");
			 return;
		 }
		 String prefix = "" "";
		 if (kindToPrint != Integer.MAX_VALUE) {
			 if (!Options.getJavaUnicodeEscape() && !unicodeWarningGiven) {
				 if (loByteVec != null && loByteVec.size() > 1) {
					 ostr.println("" if ((jjbitVec"" + ((Integer)loByteVec.get(1)).intValue() + ""[i2"" + ""] & l2) == 0L)"");
					 ostr.println("" break;
					"");
				 }
			 }
			 else {
				 ostr.println("" if (!jjCanMove_"" + nonAsciiMethod + ""(hiByte, i1, i2, l1, l2))"");
				 ostr.println("" break;
				"");
			 }
			 ostr.println("" if (kind > "" + kindToPrint + "")"");
			 ostr.println("" kind = "" + kindToPrint + "";
			"");
			 prefix = """";
		 }
		 else if (!Options.getJavaUnicodeEscape() && !unicodeWarningGiven) {
			 if (loByteVec != null && loByteVec.size() > 1) ostr.println("" if ((jjbitVec"" + ((Integer)loByteVec.get(1)).intValue() + ""[i2"" + ""] & l2) != 0L)"");
		 }
		 else {
			 ostr.println("" if (jjCanMove_"" + nonAsciiMethod + ""(hiByte, i1, i2, l1, l2))"");
		 }
		 if (next != null && next.usefulEpsilonMoves > 0) {
			 int[] stateNames = (int[])allNextStates.get( next.epsilonMovesString);
			 if (next.usefulEpsilonMoves == 1) {
				 int name = stateNames[0];
				 if (nextIntersects) ostr.println(prefix + "" jjCheckNAdd("" + name + "");
				"");
				 else ostr.println(prefix + "" jjstateSet[jjnewStateCnt++] = "" + name + "";
				"");
			 }
			 else if (next.usefulEpsilonMoves == 2 && nextIntersects) {
				 ostr.println(prefix + "" jjCheckNAddTwoStates("" + stateNames[0] + "", "" + stateNames[1] + "");
				"");
			 }
			 else {
				 int[] indices = GetStateSetIndicesForUse(next.epsilonMovesString);
				 boolean notTwo = (indices[0] + 1 != indices[1]);
				 if (nextIntersects) {
					 ostr.print(prefix + "" jjCheckNAddStates("" + indices[0]);
					 if (notTwo) {
						 jjCheckNAddStatesDualNeeded = true;
						 ostr.print("", "" + indices[1]);
					 }
					 else {
						 jjCheckNAddStatesUnaryNeeded = true;
					 }
					 ostr.println("");
					"");
				 }
				 else ostr.println(prefix + "" jjAddStates("" + indices[0] + "", "" + indices[1] + "");
				"");
			 }
		 }
		 ostr.println("" break;
		"");
	 }
	 public static void DumpCharAndRangeMoves(java.io.PrintWriter ostr) {
		 boolean[] dumped = new boolean[Math.max(generatedStates, dummyStateIndex + 1)];
		 Enumeration e = compositeStateTable.keys();
		 int i;
		 DumpHeadForCase(ostr, -1);
		 while (e.hasMoreElements()) DumpCompositeStatesNonAsciiMoves(ostr, (String)e.nextElement(), dumped);
		 for (i = 0;
		 i < allStates.size();
		 i++) {
			 NfaState temp = (NfaState)allStates.get(i);
			 if (temp.stateName == -1 || dumped[temp.stateName] || temp.lexState != LexGen.lexStateIndex || !temp.HasTransitions() || temp.dummy ) continue;
			 String toPrint = """";
			 if (temp.stateForCase != null) {
				 if (temp.inNextOf == 1) continue;
				 if (dumped[temp.stateForCase.stateName]) continue;
				 toPrint = (temp.stateForCase.PrintNoBreak(ostr, -1, dumped));
				 if (temp.nonAsciiMethod == -1) {
					 if (toPrint.equals("""")) ostr.println("" break;
					"");
					 continue;
				 }
			 }
			 if (temp.nonAsciiMethod == -1) continue;
			 if (!toPrint.equals("""")) ostr.print(toPrint);
			 dumped[temp.stateName] = true;
			 ostr.println("" case "" + temp.stateName + "":"");
			 temp.DumpNonAsciiMove(ostr, dumped);
		 }
		 ostr.println("" default : break;
		"");
	 ostr.println("" }
	"");
 ostr.println("" }
 while(i != startsAt);
"");
 }
 public static void DumpNonAsciiMoveMethods(java.io.PrintWriter ostr) {
 if (!Options.getJavaUnicodeEscape() && !unicodeWarningGiven) return;
 if (nonAsciiTableForMethod.size() <= 0) return;
 for (int i = 0;
 i < nonAsciiTableForMethod.size();
 i++) {
	 NfaState tmp = (NfaState)nonAsciiTableForMethod.get(i);
	 tmp.DumpNonAsciiMoveMethod(ostr);
 }
 }
 void DumpNonAsciiMoveMethod(java.io.PrintWriter ostr) {
 int j;
 ostr.println(""private static final boolean jjCanMove_"" + nonAsciiMethod + ""(int hiByte, int i1, int i2, long l1, long l2)"");
 ostr.println(""{
	"");
	 ostr.println("" switch(hiByte)"");
	 ostr.println("" {
		"");
		 if (loByteVec != null && loByteVec.size() > 0) {
			 for (j = 0;
			 j < loByteVec.size();
			 j += 2) {
				 ostr.println("" case "" + ((Integer)loByteVec.get(j)).intValue() + "":"");
				 if (!AllBitsSet((String)allBitVectors.get( ((Integer)loByteVec.get(j + 1)).intValue()))) {
					 ostr.println("" return ((jjbitVec"" + ((Integer)loByteVec.get(j + 1)).intValue() + ""[i2"" + ""] & l2) != 0L);
					"");
				 }
				 else ostr.println("" return true;
				"");
			 }
		 }
		 ostr.println("" default :"");
		 if (nonAsciiMoveIndices != null && (j = nonAsciiMoveIndices.length) > 0) {
			 do {
				 if (!AllBitsSet((String)allBitVectors.get( nonAsciiMoveIndices[j - 2]))) ostr.println("" if ((jjbitVec"" + nonAsciiMoveIndices[j - 2] + ""[i1] & l1) != 0L)"");
				 if (!AllBitsSet((String)allBitVectors.get( nonAsciiMoveIndices[j - 1]))) {
					 ostr.println("" if ((jjbitVec"" + nonAsciiMoveIndices[j - 1] + ""[i2] & l2) == 0L)"");
					 ostr.println("" return false;
					"");
					 ostr.println("" else"");
				 }
				 ostr.println("" return true;
				"");
			 }
			 while ((j -= 2) > 0);
		 }
		 ostr.println("" return false;
		"");
	 ostr.println("" }
	"");
 ostr.println(""}
"");
 }
 private static void ReArrange() {
 List v = allStates;
 allStates = new ArrayList(Collections.nCopies(generatedStates, null));
 if (allStates.size() != generatedStates) throw new Error(""What??"");
 for (int j = 0;
 j < v.size();
 j++) {
	 NfaState tmp = (NfaState)v.get(j);
	 if (tmp.stateName != -1 && !tmp.dummy) allStates.set(tmp.stateName, tmp);
 }
 }
 static void PrintBoilerPlate(java.io.PrintWriter ostr) {
 ostr.println((Options.getStatic() ? ""static "" : """") + ""private void "" + ""jjCheckNAdd(int state)"");
 ostr.println(""{
	"");
	 ostr.println("" if (jjrounds[state] != jjround)"");
	 ostr.println("" {
		"");
		 ostr.println("" jjstateSet[jjnewStateCnt++] = state;
		"");
		 ostr.println("" jjrounds[state] = jjround;
		"");
	 ostr.println("" }
	"");
 ostr.println(""}
"");
 ostr.println((Options.getStatic() ? ""static "" : """") + ""private void "" + ""jjAddStates(int start, int end)"");
 ostr.println(""{
	"");
	 ostr.println("" do {
		"");
		 ostr.println("" jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		"");
	 ostr.println("" }
	 while (start++ != end);
	"");
 ostr.println(""}
"");
 ostr.println((Options.getStatic() ? ""static "" : """") + ""private void "" + ""jjCheckNAddTwoStates(int state1, int state2)"");
 ostr.println(""{
	"");
	 ostr.println("" jjCheckNAdd(state1);
	"");
	 ostr.println("" jjCheckNAdd(state2);
	"");
 ostr.println(""}
"");
 ostr.println("""");
 if(jjCheckNAddStatesDualNeeded) {
	 ostr.println((Options.getStatic() ? ""static "" : """") + ""private void "" + ""jjCheckNAddStates(int start, int end)"");
	 ostr.println(""{
		"");
		 ostr.println("" do {
			"");
			 ostr.println("" jjCheckNAdd(jjnextStates[start]);
			"");
		 ostr.println("" }
		 while (start++ != end);
		"");
	 ostr.println(""}
	"");
	 ostr.println("""");
 }
 if(jjCheckNAddStatesUnaryNeeded) {
	 ostr.println((Options.getStatic() ? ""static "" : """") + ""private void "" + ""jjCheckNAddStates(int start)"");
	 ostr.println(""{
		"");
		 ostr.println("" jjCheckNAdd(jjnextStates[start]);
		"");
		 ostr.println("" jjCheckNAdd(jjnextStates[start + 1]);
		"");
	 ostr.println(""}
	"");
	 ostr.println("""");
 }
 }
 private static void FindStatesWithNoBreak() {
 Hashtable printed = new Hashtable();
 boolean[] put = new boolean[generatedStates];
 int cnt = 0;
 int i, j, foundAt = 0;
 Outer : for (j = 0;
 j < allStates.size();
 j++) {
	 NfaState stateForCase = null;
	 NfaState tmpState = (NfaState)allStates.get(j);
	 if (tmpState.stateName == -1 || tmpState.dummy || !tmpState.UsefulState() || tmpState.next == null || tmpState.next.usefulEpsilonMoves < 1) continue;
	 String s = tmpState.next.epsilonMovesString;
	 if (compositeStateTable.get(s) != null || printed.get(s) != null) continue;
	 printed.put(s, s);
	 int[] nexts = (int[])allNextStates.get(s);
	 if (nexts.length == 1) continue;
	 int state = cnt;
	 for (i = 0;
	 i < nexts.length;
	 i++) {
		 if ((state = nexts[i]) == -1) continue;
		 NfaState tmp = (NfaState)allStates.get(state);
		 if (!tmp.isComposite && tmp.inNextOf == 1) {
			 if (put[state]) throw new Error(""JavaCC Bug: Please send mail to sankar"");
			 foundAt = i;
			 cnt++;
			 stateForCase = tmp;
			 put[state] = true;
			 break;
		 }
	 }
	 if (stateForCase == null) continue;
	 for (i = 0;
	 i < nexts.length;
	 i++) {
		 if ((state = nexts[i]) == -1) continue;
		 NfaState tmp = (NfaState)allStates.get(state);
		 if (!put[state] && tmp.inNextOf > 1 && !tmp.isComposite && tmp.stateForCase == null) {
			 cnt++;
			 nexts[i] = -1;
			 put[state] = true;
			 int toSwap = nexts[0];
			 nexts[0] = nexts[foundAt];
			 nexts[foundAt] = toSwap;
			 tmp.stateForCase = stateForCase;
			 stateForCase.stateForCase = tmp;
			 stateSetsToFix.put(s, nexts);
			 continue Outer;
		 }
	 }
	 for (i = 0;
	 i < nexts.length;
	 i++) {
		 if ((state = nexts[i]) == -1) continue;
		 NfaState tmp = (NfaState)allStates.get(state);
		 if (tmp.inNextOf <= 1) put[state] = false;
	 }
 }
 }
 static int[][] kinds;
 static int[][][] statesForState;
 public static void DumpMoveNfa(java.io.PrintWriter ostr) {
 int i;
 int[] kindsForStates = null;
 if (kinds == null) {
	 kinds = new int[LexGen.maxLexStates][];
	 statesForState = new int[LexGen.maxLexStates][][];
 }
 ReArrange();
 for (i = 0;
 i < allStates.size();
 i++) {
	 NfaState temp = (NfaState)allStates.get(i);
	 if (temp.lexState != LexGen.lexStateIndex || !temp.HasTransitions() || temp.dummy || temp.stateName == -1) continue;
	 if (kindsForStates == null) {
		 kindsForStates = new int[generatedStates];
		 statesForState[LexGen.lexStateIndex] = new int[Math.max(generatedStates, dummyStateIndex + 1)][];
	 }
	 kindsForStates[temp.stateName] = temp.lookingFor;
	 statesForState[LexGen.lexStateIndex][temp.stateName] = temp.compositeStates;
	 temp.GenerateNonAsciiMoves(ostr);
 }
 Enumeration e = stateNameForComposite.keys();
 while (e.hasMoreElements()) {
	 String s = (String)e.nextElement();
	 int state = ((Integer)stateNameForComposite.get(s)).intValue();
	 if (state >= generatedStates) statesForState[LexGen.lexStateIndex][state] = (int[])allNextStates.get(s);
 }
 if (stateSetsToFix.size() != 0) FixStateSets();
 kinds[LexGen.lexStateIndex] = kindsForStates;
 ostr.println((Options.getStatic() ? ""static "" : """") + ""private int "" + ""jjMoveNfa"" + LexGen.lexStateSuffix + ""(int startState, int curPos)"");
 ostr.println(""{
	"");
	 if (generatedStates == 0) {
		 ostr.println("" return curPos;
		"");
	 ostr.println(""}
	"");
	 return;
 }
 if (LexGen.mixed[LexGen.lexStateIndex]) {
	 ostr.println("" int strKind = jjmatchedKind;
	"");
	 ostr.println("" int strPos = jjmatchedPos;
	"");
	 ostr.println("" int seenUpto;
	"");
	 ostr.println("" input_stream.backup(seenUpto = curPos + 1);
	"");
	 ostr.println("" try {
		 curChar = input_stream.readChar();
	 }
	"");
	 ostr.println("" catch(java.io.IOException e) {
		 throw new Error(\""Internal Error\"");
	 }
	"");
	 ostr.println("" curPos = 0;
	"");
 }
 ostr.println("" int startsAt = 0;
"");
 ostr.println("" jjnewStateCnt = "" + generatedStates + "";
"");
 ostr.println("" int i = 1;
"");
 ostr.println("" jjstateSet[0] = startState;
"");
 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println(\"" Starting NFA to match one of : \"" + "" + ""jjKindsForStateVector(curLexState, jjstateSet, 0, 1));
"");
 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println("" + (LexGen.maxLexStates > 1 ? ""\""<\"" + lexStateNames[curLexState] + \"">\"" + "" : """") + ""\""Current character : \"" + "" + ""TokenMgrError.addEscapes(String.valueOf(curChar)) + \"" (\"" + (int)curChar + \"") "" + ""at line \"" + input_stream.getEndLine() + \"" column \"" + input_stream.getEndColumn());
"");
 ostr.println("" int kind = 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "";
"");
 ostr.println("" for (;
;
)"");
 ostr.println("" {
	"");
	 ostr.println("" if (++jjround == 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "")"");
	 ostr.println("" ReInitRounds();
	"");
	 ostr.println("" if (curChar < 64)"");
	 ostr.println("" {
		"");
		 DumpAsciiMoves(ostr, 0);
	 ostr.println("" }
	"");
	 ostr.println("" else if (curChar < 128)"");
	 ostr.println("" {
		"");
		 DumpAsciiMoves(ostr, 1);
	 ostr.println("" }
	"");
	 ostr.println("" else"");
	 ostr.println("" {
		"");
		 DumpCharAndRangeMoves(ostr);
	 ostr.println("" }
	"");
	 ostr.println("" if (kind != 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "")"");
	 ostr.println("" {
		"");
		 ostr.println("" jjmatchedKind = kind;
		"");
		 ostr.println("" jjmatchedPos = curPos;
		"");
		 ostr.println("" kind = 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "";
		"");
	 ostr.println("" }
	"");
	 ostr.println("" ++curPos;
	"");
	 if (Options.getDebugTokenManager()) {
		 ostr.println("" if (jjmatchedKind != 0 && jjmatchedKind != 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "")"");
		 ostr.println("" debugStream.println("" + ""\"" Currently matched the first \"" + (jjmatchedPos + 1) + \"" characters as"" + "" a \"" + tokenImage[jjmatchedKind] + \"" token.\"");
		"");
	 }
	 ostr.println("" if ((i = jjnewStateCnt) == (startsAt = "" + generatedStates + "" - (jjnewStateCnt = startsAt)))"");
	 if (LexGen.mixed[LexGen.lexStateIndex]) ostr.println("" break;
	"");
	 else ostr.println("" return curPos;
	"");
	 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println(\"" Possible kinds of longer matches : \"" + "" + ""jjKindsForStateVector(curLexState, jjstateSet, startsAt, i));
	"");
	 ostr.println("" try {
		 curChar = input_stream.readChar();
	 }
	"");
	 if (LexGen.mixed[LexGen.lexStateIndex]) ostr.println("" catch(java.io.IOException e) {
		 break;
	 }
	"");
	 else ostr.println("" catch(java.io.IOException e) {
		 return curPos;
	 }
	"");
	 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println("" + (LexGen.maxLexStates > 1 ? ""\""<\"" + lexStateNames[curLexState] + \"">\"" + "" : """") + ""\""Current character : \"" + "" + ""TokenMgrError.addEscapes(String.valueOf(curChar)) + \"" (\"" + (int)curChar + \"") "" + ""at line \"" + input_stream.getEndLine() + \"" column \"" + input_stream.getEndColumn());
	"");
 ostr.println("" }
"");
 if (LexGen.mixed[LexGen.lexStateIndex]) {
	 ostr.println("" if (jjmatchedPos > strPos)"");
	 ostr.println("" return curPos;
	"");
	 ostr.println("""");
	 ostr.println("" int toRet = Math.max(curPos, seenUpto);
	"");
	 ostr.println("""");
	 ostr.println("" if (curPos < toRet)"");
	 ostr.println("" for (i = toRet - Math.min(curPos, seenUpto);
	 i-- > 0;
	 )"");
	 ostr.println("" try {
		 curChar = input_stream.readChar();
	 }
	"");
	 ostr.println("" catch(java.io.IOException e) {
		 "" + ""throw new Error(\""Internal Error : Please send a bug report.\"");
	 }
	"");
	 ostr.println("""");
	 ostr.println("" if (jjmatchedPos < strPos)"");
	 ostr.println("" {
		"");
		 ostr.println("" jjmatchedKind = strKind;
		"");
		 ostr.println("" jjmatchedPos = strPos;
		"");
	 ostr.println("" }
	"");
	 ostr.println("" else if (jjmatchedPos == strPos && jjmatchedKind > strKind)"");
	 ostr.println("" jjmatchedKind = strKind;
	"");
	 ostr.println("""");
	 ostr.println("" return toRet;
	"");
 }
 ostr.println(""}
"");
 allStates.clear();
 }
 public static void DumpStatesForState(java.io.PrintWriter ostr) {
 ostr.print(""protected static final int[][][] statesForState = "");
 if (statesForState == null) {
 ostr.println(""null;
"");
 return;
 }
 else ostr.println(""{
"");
 for (int i = 0;
 i < statesForState.length;
 i++) {
	 if (statesForState[i] == null) {
		 ostr.println("" null,"");
		 continue;
	 }
	 ostr.println("" {
		"");
		 for (int j = 0;
		 j < statesForState[i].length;
		 j++) {
			 int[] stateSet = statesForState[i][j];
			 if (stateSet == null) {
				 ostr.println("" {
				 "" + j + "" }
				,"");
				 continue;
			 }
			 ostr.print("" {
				 "");
				 for (int k = 0;
				 k < stateSet.length;
				 k++) ostr.print(stateSet[k] + "", "");
			 ostr.println(""}
			,"");
		 }
	 ostr.println("" }
	,"");
 }
 ostr.println(""\n}
;
"");
 }
 public static void DumpStatesForKind(java.io.PrintWriter ostr) {
 DumpStatesForState(ostr);
 boolean moreThanOne = false;
 int cnt = 0;
 ostr.print(""protected static final int[][] kindForState = "");
 if (kinds == null) {
 ostr.println(""null;
"");
 return;
 }
 else ostr.println(""{
"");
 for (int i = 0;
 i < kinds.length;
 i++) {
	 if (moreThanOne) ostr.println("","");
	 moreThanOne = true;
	 if (kinds[i] == null) ostr.println(""null"");
	 else {
		 cnt = 0;
		 ostr.print(""{
			 "");
			 for (int j = 0;
			 j < kinds[i].length;
			 j++) {
				 if (cnt++ > 0) ostr.print("","");
				 if (cnt % 15 == 0) ostr.print(""\n "");
				 else if (cnt > 1) ostr.print("" "");
				 ostr.print(kinds[i][j]);
			 }
		 ostr.print(""}
		"");
	 }
 }
 ostr.println(""\n}
;
"");
 }
 public static void reInit() {
 unicodeWarningGiven = false;
 generatedStates = 0;
 idCnt = 0;
 lohiByteCnt = 0;
 dummyStateIndex = -1;
 done = false;
 mark = null;
 stateDone = null;
 allStates = new ArrayList();
 indexedAllStates = new ArrayList();
 nonAsciiTableForMethod = new ArrayList();
 equivStatesTable = new Hashtable();
 allNextStates = new Hashtable();
 lohiByteTab = new Hashtable();
 stateNameForComposite = new Hashtable();
 compositeStateTable = new Hashtable();
 stateBlockTable = new Hashtable();
 stateSetsToFix = new Hashtable();
 allBitVectors = new ArrayList();
 tmpIndices = new int[512];
 allBits = ""{
\n 0xffffffffffffffffL, "" + ""0xffffffffffffffffL, "" + ""0xffffffffffffffffL, "" + ""0xffffffffffffffffL\n}
;
"";
 tableToDump = new Hashtable();
 orderedStateSet = new ArrayList();
 lastIndex = 0;
 jjCheckNAddStatesUnaryNeeded = false;
 jjCheckNAddStatesDualNeeded = false;
 kinds = null;
 statesForState = null;
 }
}",1,0,0,0
"private class ContentVisitor implements IContentVisitor{
	public Object visit( IContent content, Object value ){
		return visitContent( content, value );
	}
	public Object visitContent( IContent content, Object value ){
		boolean isInline = PropertyUtil.isInlineElement( content );
		if ( isInline ){
			return new InlineBlockLayout( context, parent, content );
		}
		else{
			return new BlockStackingLayout( context, parent, content);
		}
	}
	public Object visitPage( IPageContent page, Object value ){
		return new PageLayout(executor, context, parent, page);
	}
	public Object visitContainer( IContainerContent container, Object value ){
		boolean isInline = PropertyUtil.isInlineElement( container );
		if ( isInline ){
			return new InlineContainerLayout( context, parent, container);
		}
		else{
			return new BlockStackingLayout( context, parent, container);
		}
	}
	public Object visitTable( ITableContent table, Object value ){
		return new TableLayout( context, parent, table );
	}
	public Object visitTableBand( ITableBandContent tableBand, Object value ){
		return new TableBandLayout( context, parent, tableBand);
	}
	public Object visitRow( IRowContent row, Object value ){
		return new RowLayout( context, parent, row );
	}
	public Object visitCell( ICellContent cell, Object value ){
		return new CellLayout( context, parent, cell );
	}
	public Object visitText( ITextContent text, Object value ){
		return handleText( text );
	}
	public Object visitLabel( ILabelContent label, Object value ){
		return handleText( label );
	}
	public Object visitData( IDataContent data, Object value ){
		return handleText( data );
	}
	public Object visitImage( IImageContent image, Object value ){
		return new ImageLayout( context, parent, image );
	}
	public Object visitForeign( IForeignContent foreign, Object value ){
		boolean isInline = PropertyUtil.isInlineElement( foreign );
		if ( isInline ){
			return new InlineContainerLayout( context, parent, foreign);
		}
		else{
			return new BlockStackingLayout( context, parent, foreign);
		}
	}
	public Object visitAutoText( IAutoTextContent autoText, Object value ){
		int type = autoText.getType( );
		if ( type == IAutoTextContent.TOTAL_PAGE|| type == IAutoTextContent.UNFILTERED_TOTAL_PAGE ){
			context.addUnresolvedContent( autoText );
			return new TemplateLayout( context, parent, autoText );
		}
		return handleText( autoText );
	}
	private Object handleText( ITextContent content ){
		boolean isInline = parent instanceof IInlineStackingLayout;
		if ( isInline ){
			return new InlineTextLayout( context, parent, content );
		}
		else{
			String text = content.getText( );
			if ( text == null || """".equals( text ) ) {
				content.setText( "" "" );
			 }
			return new BlockTextLayout( context, parent, content);
		}
	}
	public Object visitList( IListContent list, Object value ){
		return new ListLayout( context, parent, list );
	}
	public Object visitListBand( IListBandContent listBand, Object value ){
		assert ( false );
		return null;
	}
	public Object visitListGroup( IListGroupContent group, Object value ){
		return new ListGroupLayout( context, parent, group );
	}
	public Object visitTableGroup( ITableGroupContent group, Object value ){
		return new TableGroupLayout( context, parent, group );
	}
	public Object visitGroup( IGroupContent group, Object value ){
		return new BlockStackingLayout( context, parent, group );
	}
}",1,0,0,0
"public class Application {
	 private String name;
	 private Map<String, String> inputs;
	 public Application() {
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public Map<String, String> getInputs() {
		 return inputs;
	 }
	 public void setInputs(Map<String, String> inputs) {
		 this.inputs = inputs;
	 }
 }",0,1,0,0
"public class ConfigFrame extends SwingFrame {
	 private static final int FRAME_WIDTH = 850;
	 private static final int FRAME_HEIGHT = 550;
	 private final MainFrame _mainFrame;
	 private final JTree _tree;
	 private final DefaultTreeModel _treeModel;
	 private final PanelTreeNode _rootNode;
	 private final JButton _okButton;
	 private final JButton _applyButton;
	 private final JButton _cancelButton;
	 private final JPanel _mainPanel;
	 private final JFileChooser _fileOptionChooser;
	 private final JFileChooser _browserChooser;
	 private final JFileChooser _jarChooser;
	 private final DirectoryChooser _dirChooser;
	 private final ConfigOptionListeners.RequiresInteractionsRestartListener<Boolean> _junitLocationEnabledListener;
	 private final ConfigOptionListeners.RequiresInteractionsRestartListener<File> _junitLocationListener;
	 private final ConfigOptionListeners.RequiresInteractionsRestartListener<String> _concJUnitChecksEnabledListener;
	 private final ConfigOptionListeners.RequiresInteractionsRestartListener<File> _rtConcJUnitLocationListener;
	 private StringOptionComponent javadocCustomParams;
	 protected final String SEPS = "" \t\n-,;
	.("";
	 private OptionComponent.ChangeListener _changeListener = new OptionComponent.ChangeListener() {
		 public Object value(Object oc) {
			 _applyButton.setEnabled(true);
			 return null;
		 }
	 }
	;
	 public ConfigFrame(MainFrame frame) {
		 super(""Preferences"");
		 _mainFrame = frame;
		 _junitLocationEnabledListener = new ConfigOptionListeners. RequiresInteractionsRestartListener<Boolean>(this, ""Use External JUnit"");
		 _junitLocationListener = new ConfigOptionListeners. RequiresInteractionsRestartListener<File>(this, ""JUnit Location"");
		 _concJUnitChecksEnabledListener = new ConfigOptionListeners. RequiresInteractionsRestartListener<String>(this, ""Enabled ConcJUnit Checks"");
		 _rtConcJUnitLocationListener = new ConfigOptionListeners. RequiresInteractionsRestartListener<File>(this, ""ConcJUnit Runtime Location"");
		 Action applyAction = new AbstractAction(""Apply"") {
			 public void actionPerformed(ActionEvent e) {
				 try {
					 saveSettings();
					 _applyButton.setEnabled(false);
				 }
				 catch (IOException ioe) {
				 }
			 }
		 }
		;
		 _applyButton = new JButton(applyAction);
		 _applyButton.setEnabled(false);
		 Action okAction = new AbstractAction(""OK"") {
			 public void actionPerformed(ActionEvent e) {
				 boolean successful = true;
				 try {
					 successful = saveSettings();
				 }
				 catch (IOException ioe) {
				 }
				 if (successful) _applyButton.setEnabled(false);
				 ConfigFrame.this.setVisible(false);
			 }
		 }
		;
		 _okButton = new JButton(okAction);
		 Action cancelAction = new AbstractAction(""Cancel"") {
			 public void actionPerformed(ActionEvent e) {
				 cancel();
			 }
		 }
		;
		 _cancelButton = new JButton(cancelAction);
		 File workDir = _getWorkDir();
		 if (workDir == null || workDir == FileOps.NULL_FILE) workDir = new File(System.getProperty(""user.dir""));
		 _fileOptionChooser = new JFileChooser(workDir);
		 _jarChooser = new JFileChooser(workDir);
		 _browserChooser = new JFileChooser(workDir);
		 _dirChooser = new DirectoryChooser(this);
		 _rootNode = new PanelTreeNode(""Preferences"");
		 _treeModel = new DefaultTreeModel(_rootNode);
		 _tree = new JTree(_treeModel);
		 _initTree();
		 _createPanels();
		 _mainPanel= new JPanel();
		 _mainPanel.setLayout(new BorderLayout());
		 _tree.addTreeSelectionListener(new PanelTreeSelectionListener());
		 Container cp = getContentPane();
		 cp.setLayout(new BorderLayout());
		 if (_rootNode.getChildCount() != 0) {
			 PanelTreeNode firstChild = (PanelTreeNode)_rootNode.getChildAt(0);
			 TreeNode[] firstChildPath = firstChild.getPath();
			 TreePath path = new TreePath(firstChildPath);
			 _tree.expandPath(path);
			 _tree.setSelectionPath(path);
		 }
		 JScrollPane treeScroll = new JScrollPane(_tree);
		 JPanel treePanel = new JPanel();
		 treePanel.setLayout(new BorderLayout());
		 treeScroll.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), ""Categories""));
		 treePanel.add(treeScroll, BorderLayout.CENTER);
		 cp.add(treePanel, BorderLayout.WEST);
		 cp.add(_mainPanel, BorderLayout.CENTER);
		 JPanel bottom = new JPanel();
		 bottom.setBorder(new EmptyBorder(5,5,5,5));
		 bottom.setLayout(new BoxLayout(bottom, BoxLayout.X_AXIS));
		 bottom.add(Box.createHorizontalGlue());
		 bottom.add(_applyButton);
		 bottom.add(_okButton);
		 bottom.add(_cancelButton);
		 bottom.add(Box.createHorizontalGlue());
		 cp.add(bottom, BorderLayout.SOUTH);
		 Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		 if (dim.width>FRAME_WIDTH) {
			 dim.width = FRAME_WIDTH;
		 }
		 else {
			 dim.width -= 80;
		 }
		 if (dim.height>FRAME_HEIGHT) {
			 dim.height = FRAME_HEIGHT;
		 }
		 else {
			 dim.height -= 80;
		 }
		 setSize(dim);
		 _mainFrame.setPopupLoc(this);
		 int row = 0;
		 while(row<_tree.getRowCount()) {
			 _tree.expandRow(row);
			 ++row;
		 }
		 initDone();
	 }
	 public void setUp() {
		 assert EventQueue.isDispatchThread();
		 _fileOptionChooser.setDialogTitle(""Select"");
		 _fileOptionChooser.setApproveButtonText(""Select"");
		 _fileOptionChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
		 _fileOptionChooser.setFileFilter(ClassPathFilter.ONLY);
		 _jarChooser.setDialogTitle(""Select"");
		 _jarChooser.setApproveButtonText(""Select"");
		 _jarChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		 _jarChooser.setFileFilter(ClassPathFilter.ONLY);
		 _browserChooser.setDialogTitle(""Select Web Browser"");
		 _browserChooser.setApproveButtonText(""Select"");
		 _browserChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		 _dirChooser.setSelectedFile(_getWorkDir());
		 _dirChooser.setDialogTitle(""Select"");
		 _dirChooser.setApproveButtonText(""Select"");
		 _dirChooser.setMultiSelectionEnabled(false);
	 }
	 private void enableChangeListeners() {
		 DrJava.getConfig().addOptionListener(OptionConstants.JUNIT_LOCATION_ENABLED, _junitLocationEnabledListener);
		 DrJava.getConfig().addOptionListener(OptionConstants.JUNIT_LOCATION, _junitLocationListener);
		 DrJava.getConfig().addOptionListener(OptionConstants.CONCJUNIT_CHECKS_ENABLED, _concJUnitChecksEnabledListener);
		 DrJava.getConfig().addOptionListener(OptionConstants.RT_CONCJUNIT_LOCATION, _rtConcJUnitLocationListener);
	 }
	 private void disableChangeListeners() {
		 DrJava.getConfig().removeOptionListener(OptionConstants.JUNIT_LOCATION_ENABLED, _junitLocationEnabledListener);
		 DrJava.getConfig().removeOptionListener(OptionConstants.JUNIT_LOCATION, _junitLocationListener);
		 DrJava.getConfig().removeOptionListener(OptionConstants.CONCJUNIT_CHECKS_ENABLED, _concJUnitChecksEnabledListener);
		 DrJava.getConfig().removeOptionListener(OptionConstants.RT_CONCJUNIT_LOCATION, _rtConcJUnitLocationListener);
	 }
	 private File _getWorkDir() {
		 File workDir = _mainFrame.getModel().getMasterWorkingDirectory();
		 assert workDir != null;
		 if (workDir.isDirectory()) return workDir;
		 if (workDir.getParent() != null) workDir = workDir.getParentFile();
		 return workDir;
	 }
	 public boolean apply() {
		 return _rootNode.update();
	 }
	 public void resetToCurrent() {
		 _rootNode.resetToCurrent();
		 VectorKeyStrokeOptionComponent.resetCurrentKeyStrokeMap();
	 }
	 public void cancel() {
		 resetToCurrent();
		 _applyButton.setEnabled(false);
		 ConfigFrame.this.setVisible(false);
	 }
	 protected final Runnable1<WindowEvent> CANCEL = new Runnable1<WindowEvent>() {
		 public void run(WindowEvent e) {
			 cancel();
		 }
	 }
	;
	 public void setVisible(boolean vis) {
		 assert EventQueue.isDispatchThread();
		 validate();
		 if (vis) {
			 enableChangeListeners();
			 toFront();
		 }
		 else {
			 disableChangeListeners();
			 _mainFrame.toFront();
		 }
		 super.setVisible(vis);
	 }
	 public boolean saveSettings() throws IOException {
		 boolean successful = apply();
		 if (successful) {
			 try {
				 DrJava.getConfig().saveConfiguration();
			 }
			 catch (IOException ioe) {
				 JOptionPane.showMessageDialog(this, ""Could not save changes to your \"".drjava\"" file in your home directory. \n\n"" + ioe, ""Could Not Save Changes"", JOptionPane.ERROR_MESSAGE);
				 throw ioe;
			 }
		 }
		 return successful;
	 }
	 private void _displayPanel(ConfigPanel cf) {
		 _mainPanel.removeAll();
		 _mainPanel.add(cf, BorderLayout.CENTER);
		 _mainPanel.revalidate();
		 _mainPanel.repaint();
	 }
	 private void _initTree() {
		 _tree.setEditable(false);
		 _tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		 _tree.setShowsRootHandles(true);
		 _tree.setRootVisible(false);
		 DefaultTreeCellRenderer dtcr = new DefaultTreeCellRenderer();
		 dtcr.setLeafIcon(null);
		 dtcr.setOpenIcon(null);
		 dtcr.setClosedIcon(null);
		 _tree.setCellRenderer(dtcr);
	 }
	 private PanelTreeNode _createPanel(String t, PanelTreeNode parent) {
		 PanelTreeNode ptNode = new PanelTreeNode(t);
		 _treeModel.insertNodeInto(ptNode, parent, parent.getChildCount());
		 TreeNode[] pathArray = ptNode.getPath();
		 TreePath path = new TreePath(pathArray);
		 _tree.expandPath(path);
		 return ptNode;
	 }
	 private PanelTreeNode _createPanel(String t) {
		 return _createPanel(t, _rootNode);
	 }
	 private void _createPanels() {
		 PanelTreeNode resourceLocNode = _createPanel(""Resource Locations"");
		 _setupResourceLocPanel(resourceLocNode.getPanel());
		 PanelTreeNode displayNode = _createPanel(""Display Options"");
		 _setupDisplayPanel(displayNode.getPanel());
		 PanelTreeNode fontNode = _createPanel(""Fonts"", displayNode);
		 _setupFontPanel(fontNode.getPanel());
		 PanelTreeNode colorNode = _createPanel(""Colors"", displayNode);
		 _setupColorPanel(colorNode.getPanel());
		 PanelTreeNode positionsNode = _createPanel(""Window Positions"", displayNode);
		 _setupPositionsPanel(positionsNode.getPanel());
		 PanelTreeNode keystrokesNode = _createPanel(""Key Bindings"");
		 _setupKeyBindingsPanel(keystrokesNode.getPanel());
		 PanelTreeNode compilerOptionsNode = _createPanel(""Compiler Options"");
		 _setupCompilerPanel(compilerOptionsNode.getPanel());
		 PanelTreeNode interactionsNode = _createPanel(""Interactions Pane"");
		 _setupInteractionsPanel(interactionsNode.getPanel());
		 PanelTreeNode debugNode = _createPanel(""Debugger"");
		 _setupDebugPanel(debugNode.getPanel());
		 PanelTreeNode junitNode = _createPanel(""JUnit"");
		 _setupJUnitPanel(junitNode.getPanel());
		 PanelTreeNode javadocNode = _createPanel(""Javadoc"");
		 _setupJavadocPanel(javadocNode.getPanel());
		 PanelTreeNode notificationsNode = _createPanel(""Notifications"");
		 _setupNotificationsPanel(notificationsNode.getPanel());
		 PanelTreeNode miscNode = _createPanel(""Miscellaneous"");
		 _setupMiscPanel(miscNode.getPanel());
		 PanelTreeNode fileTypesNode = _createPanel(""File Types"", miscNode);
		 _setupFileTypesPanel(fileTypesNode.getPanel());
		 PanelTreeNode jvmsNode = _createPanel(""JVMs"", miscNode);
		 _setupJVMsPanel(jvmsNode.getPanel());
	 }
	 public <X,C extends JComponent> void addOptionComponent(ConfigPanel panel, OptionComponent<X,C> oc) {
		 panel.addComponent(oc);
		 oc.addChangeListener(_changeListener);
	 }
	 private void _setupResourceLocPanel(ConfigPanel panel) {
		 FileOptionComponent browserLoc = new FileOptionComponent(OptionConstants.BROWSER_FILE, ""Web Browser"", this, ""<html>Location of a web browser to use for Javadoc and Help links.<br>"" + ""If left blank, only the Web Browser Command will be used.<br>"" + ""This is not necessary if a default browser is available on your system."", _browserChooser);
		 addOptionComponent(panel, browserLoc);
		 StringOptionComponent browserCommand = new StringOptionComponent(OptionConstants.BROWSER_STRING, ""Web Browser Command"", this, ""<html>Command to send to the web browser to view a web location.<br>"" + ""The string <code>&lt;
		URL&gt;
		</code> will be replaced with the URL address.<br>"" + ""This is not necessary if a default browser is available on your system."");
		 addOptionComponent(panel, browserCommand);
		 FileOptionComponent javacLoc = new FileOptionComponent(OptionConstants.JAVAC_LOCATION, ""Tools.jar Location"", this, ""Optional location of the JDK's tools.jar, which contains the compiler and debugger."", _fileOptionChooser);
		 javacLoc.setFileFilter(ClassPathFilter.ONLY);
		 addOptionComponent(panel, javacLoc);
		 BooleanOptionComponent displayAllCompilerVersions = new BooleanOptionComponent(OptionConstants.DISPLAY_ALL_COMPILER_VERSIONS, ""Display All Compiler Versions"", this, ""Display all compiler versions, even if they have the same major version."");
		 addOptionComponent(panel, displayAllCompilerVersions );
		 addOptionComponent(panel, new VectorFileOptionComponent(OptionConstants.EXTRA_CLASSPATH, ""Extra Classpath"", this, ""<html>Any directories or jar files to add to the classpath<br>""+ ""of the Compiler and Interactions Pane.</html>"", true));
		 panel.displayComponents();
	 }
	 private void _setupDisplayPanel(ConfigPanel panel) {
		 final ForcedChoiceOptionComponent lookAndFeelComponent = new ForcedChoiceOptionComponent(OptionConstants.LOOK_AND_FEEL, ""Look and Feel"", this, ""Changes the general appearance of DrJava."");
		 addOptionComponent(panel, lookAndFeelComponent);
		 final ForcedChoiceOptionComponent plasticComponent = new ForcedChoiceOptionComponent(OptionConstants.PLASTIC_THEMES, ""Plastic Theme"", this, ""Pick the theme to be used by the Plastic family of Look and Feels"");
		 lookAndFeelComponent.addChangeListener(new OptionComponent.ChangeListener() {
			 public Object value(Object oc) {
				 plasticComponent.getComponent().setEnabled(lookAndFeelComponent.getCurrentComboBoxValue().startsWith(""com.jgoodies.looks.plastic.""));
				 return null;
			 }
		 }
		);
		 plasticComponent.getComponent().setEnabled(lookAndFeelComponent.getCurrentComboBoxValue().startsWith(""com.jgoodies.looks.plastic.""));
		 addOptionComponent(panel, plasticComponent);
		 addOptionComponent(panel, new ToolbarOptionComponent(""Toolbar Buttons"", this, ""How to display the toolbar buttons.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.LINEENUM_ENABLED, ""Show All Line Numbers"", this, ""Whether to show line numbers on the left side of the Definitions Pane.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_SOURCE_WHEN_SWITCHING, ""Show sample of source code when fast switching"", this, ""Whether to show a sample of the source code under the document's filename when fast switching documents.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_CODE_PREVIEW_POPUPS, ""Show Code Preview Popups"", this, ""<html>Whether to show a popup window with a code preview when the mouse is hovering<br>""+ ""over an item in the Breakpoints, Bookmarks and Find All panes.</html>""));
		 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.CLIPBOARD_HISTORY_SIZE, ""Size of Clipboard History"", this, ""Determines how many entries are kept in the clipboard history.""));
		 BooleanOptionComponent checkbox = new BooleanOptionComponent(OptionConstants.DIALOG_GOTOFILE_FULLY_QUALIFIED, ""<html><p align=\""right\"">"" + StringOps. splitStringAtWordBoundaries(""Display Fully-Qualified Class Names in \""Go to File\"" Dialog"", 40, ""<br>"", SEPS)+""</p></html>"", this, ""<html>Whether to also display fully-qualified class names in the \""Go to File\"" dialog.<br>""+ ""Enabling this option on network drives might cause the dialog to display after a slight delay.</html>"");
		 addOptionComponent(panel, checkbox);
		 checkbox = new BooleanOptionComponent(OptionConstants.DIALOG_COMPLETE_SCAN_CLASS_FILES, ""<html><p align=\""right\"">"" + StringOps. splitStringAtWordBoundaries(""Scan Class Files After Each Compile for Auto-Completion and Auto-Import"", 40, ""<br>"", SEPS)+""</p></html>"", this, ""<html>Whether to scan the class files after a compile to generate class names<br>""+ ""used for auto-completion and auto-import.<br>""+ ""Enabling this option will slow compiles down.</html>"");
		 addOptionComponent(panel, checkbox);
		 checkbox = new BooleanOptionComponent(OptionConstants.DIALOG_COMPLETE_JAVAAPI, ""<html><p align=\""right\"">"" + StringOps. splitStringAtWordBoundaries(""Consider Java API Classes for Auto-Completion"", 40, ""<br>"", SEPS)+""</p></html>"", this, ""Whether to use the names of the Java API classes for auto-completion as well."");
		 addOptionComponent(panel, checkbox);
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 final BooleanOptionComponent drmComponent = new BooleanOptionComponent(OptionConstants.DISPLAY_RIGHT_MARGIN, ""Display right margin"", this, ""Whether to display a line at the right margin."");
		 addOptionComponent(panel, drmComponent);
		 final IntegerOptionComponent rmcComponent = new IntegerOptionComponent(OptionConstants.RIGHT_MARGIN_COLUMNS, ""Right Margin Position"", this, ""The number of columns after which the right margin is displayed."");
		 addOptionComponent(panel, rmcComponent);
		 OptionComponent.ChangeListener drmListener = new OptionComponent.ChangeListener() {
			 public Object value(Object oc) {
				 rmcComponent.getComponent().setEnabled(drmComponent.getComponent().isSelected());
				 return null;
			 }
		 }
		;
		 drmComponent.addChangeListener(drmListener);
		 drmListener.value(drmComponent);
		 panel.displayComponents();
	 }
	 private void _setupFontPanel(ConfigPanel panel) {
		 addOptionComponent(panel, new FontOptionComponent(OptionConstants.FONT_MAIN, ""Main Font"", this, ""The font used for most text in DrJava.""));
		 addOptionComponent(panel, new FontOptionComponent(OptionConstants.FONT_LINE_NUMBERS, ""Line Numbers Font"", this, ""<html>The font for displaying line numbers on the left side of<br>"" + ""the Definitions Pane if Show All Line Numbers is enabled.<br>"" + ""Cannot be displayed larger than the Main Font.</html>""));
		 addOptionComponent(panel, new FontOptionComponent(OptionConstants.FONT_DOCLIST, ""Document List Font"", this, ""The font used in the list of open documents.""));
		 addOptionComponent(panel, new FontOptionComponent(OptionConstants.FONT_TOOLBAR, ""Toolbar Font"", this, ""The font used in the toolbar buttons.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.TEXT_ANTIALIAS, ""Use anti-aliased text"", this, ""Whether to graphically smooth the text.""));
		 panel.displayComponents();
	 }
	 private void _setupColorPanel(ConfigPanel panel) {
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_NORMAL_COLOR, ""Normal Color"", this, ""The default color for text in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_KEYWORD_COLOR, ""Keyword Color"", this, ""The color for Java keywords in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_TYPE_COLOR, ""Type Color"", this, ""The color for classes and types in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_COMMENT_COLOR, ""Comment Color"", this, ""The color for comments in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_DOUBLE_QUOTED_COLOR, ""Double-quoted Color"", this, ""The color for quoted strings (eg. \""...\"") in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_SINGLE_QUOTED_COLOR, ""Single-quoted Color"", this, ""The color for quoted characters (eg. 'a') in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_NUMBER_COLOR, ""Number Color"", this, ""The color for numbers in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_BACKGROUND_COLOR, ""Background Color"", this, ""The background color of the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_LINE_NUMBER_COLOR, ""Line Number Color"", this, ""The color for line numbers in the Definitions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_LINE_NUMBER_BACKGROUND_COLOR, ""Line Number Background Color"", this, ""The background color for line numbers in the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_MATCH_COLOR, ""Brace-matching Color"", this, ""The color for matching brace highlights in the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.COMPILER_ERROR_COLOR, ""Compiler Error Color"", this, ""The color for compiler error highlights in the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.BOOKMARK_COLOR, ""Bookmark Color"", this, ""The color for bookmarks in the Definitions Pane."", true));
		 for (int i = 0;
		 i < OptionConstants.FIND_RESULTS_COLORS.length;
		 ++i) {
			 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.FIND_RESULTS_COLORS[i], ""Find Results Color ""+(i+1), this, ""A color for highlighting find results in the Definitions Pane."", true));
		 }
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEBUG_BREAKPOINT_COLOR, ""Debugger Breakpoint Color"", this, ""The color for breakpoints in the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEBUG_BREAKPOINT_DISABLED_COLOR, ""Disabled Debugger Breakpoint Color"", this, ""The color for disabled breakpoints in the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEBUG_THREAD_COLOR, ""Debugger Location Color"", this, ""The color for the location of the current suspended thread in the Definitions Pane."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.SYSTEM_OUT_COLOR, ""System.out Color"", this, ""The color for System.out in the Interactions and Console Panes.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.SYSTEM_ERR_COLOR, ""System.err Color"", this, ""The color for System.err in the Interactions and Console Panes.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.SYSTEM_IN_COLOR, ""System.in Color"", this, ""The color for System.in in the Interactions Pane.""));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.INTERACTIONS_ERROR_COLOR, ""Interactions Error Color"", this, ""The color for interactions errors in the Interactions Pane."", false, true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEBUG_MESSAGE_COLOR, ""Debug Message Color"", this, ""The color for debugger messages in the Interactions Pane."", false, true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DRJAVA_ERRORS_BUTTON_COLOR, ""DrJava Errors Button Background Color"", this, ""The background color of the \""Errors\"" button used to show internal DrJava errors."", true));
		 addOptionComponent(panel, new ColorOptionComponent(OptionConstants.RIGHT_MARGIN_COLOR, ""Right Margin Color"", this, ""The color of the right margin line, if displayed."", true));
		 panel.displayComponents();
	 }
	 private void _setupPositionsPanel(ConfigPanel panel) {
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WINDOW_STORE_POSITION, ""Save Main Window Position"", this, ""Whether to save and restore the size and position of the main window."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_CLIPBOARD_HISTORY_STORE_POSITION, ""Save \""Clipboard History\"" Dialog Position"", this, ""Whether to save and restore the size and position of the \""Clipboard History\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetClipboardHistoryDialogPosition();
			 }
		 }
		, ""Reset \""Clipboard History\"" Dialog Position and Size"", this, ""This resets the dialog position and size to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_GOTOFILE_STORE_POSITION, ""Save \""Go to File\"" Dialog Position"", this, ""Whether to save and restore the size and position of the \""Go to File\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetGotoFileDialogPosition();
			 }
		 }
		, ""Reset \""Go to File\"" Dialog Position and Size"", this, ""This resets the dialog position and size to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_COMPLETE_WORD_STORE_POSITION, ""Save \""Auto-Complete Word\"" Dialog Position"", this, ""Whether to save and restore the size and position of the \""Auto-Complete Word\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetCompleteWordDialogPosition();
			 }
		 }
		, ""Reset \""Auto-Complete Word\"" Dialog Position and Size"", this, ""This resets the dialog position and size to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_JAROPTIONS_STORE_POSITION, ""Save \""Create Jar File from Project\"" Dialog Position"", this, ""Whether to save and restore the position of the \""Create Jar File from Project\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetJarOptionsDialogPosition();
			 }
		 }
		, ""Reset \""Create Jar File from Project\"" Dialog Position"", this, ""This resets the dialog position to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_OPENJAVADOC_STORE_POSITION, ""Save \""Open Javadoc\"" Dialog Position"", this, ""Whether to save and restore the size and position of the \""Open Javadoc\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetOpenJavadocDialogPosition();
			 }
		 }
		, ""Reset \""Open Javadoc\"" Dialog Position and Size"", this, ""This resets the dialog position and size to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_AUTOIMPORT_STORE_POSITION, ""Save \""Auto Import\"" Dialog Position"", this, ""Whether to save and restore the size and position of the \""Auto Import\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetAutoImportDialogPosition();
			 }
		 }
		, ""Reset \""Auto Import\"" Dialog Position and Size"", this, ""This resets the dialog position and size to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_EXTERNALPROCESS_STORE_POSITION, ""Save \""Execute External Process\"" Dialog Position"", this, ""Whether to save and restore the position of the \""Execute External Process\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetExecuteExternalProcessPosition();
			 }
		 }
		, ""Reset \""Execute External Process\"" Dialog Position"", this, ""This resets the dialog position to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_EDITEXTERNALPROCESS_STORE_POSITION, ""Save \""Edit External Process\"" Dialog Position"", this, ""Whether to save and restore the position of the \""Edit External Process\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetEditExternalProcessPosition();
			 }
		 }
		, ""Reset \""Execute External Process\"" Dialog Position"", this, ""This resets the dialog position to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_OPENJAVADOC_STORE_POSITION, ""Save \""Open Javadoc\"" Dialog Position"", this, ""Whether to save and restore the position of the \""Open Javadoc\"" dialog."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetOpenJavadocDialogPosition();
			 }
		 }
		, ""Reset \""Open Javadoc\"" Dialog Position"", this, ""This resets the dialog position to its default values.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_TABBEDPANES_STORE_POSITION, ""Save \""Tabbed Panes\"" Window Position"", this, ""Whether to save and restore the position of the \""Tabbed Panes\"" window."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetTabbedPanesFrame();
			 }
		 }
		, ""Reset \""Tabbed Panes\"" Window Position"", this, ""This resets the window position to its default values.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DETACH_TABBEDPANES, ""Detach Tabbed Panes"", this, ""Whether to detach the tabbed panes and display them in a separate window."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_DEBUGFRAME_STORE_POSITION, ""Save \""Debugger\"" Window Position"", this, ""Whether to save and restore the position of the \""Debugger\"" window."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new ButtonComponent(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _mainFrame.resetDebugFrame();
			 }
		 }
		, ""Reset \""Debugger\"" Window Position"", this, ""This resets the window position to its default values.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DETACH_DEBUGGER, ""Detach Debugger"", this, ""Whether to detach the debugger and display it in a separate window."", false) .setEntireColumn(true));
		 panel.displayComponents();
	 }
	 private void _setupKeyBindingsPanel(ConfigPanel panel) {
		 TreeMap<String,VectorKeyStrokeOptionComponent> _comps = new TreeMap<String,VectorKeyStrokeOptionComponent>();
		 VectorKeyStrokeOptionComponent vksoc;
		 for (KeyStrokeData ksd: KeyBindingManager.ONLY.getKeyStrokeData()) {
			 if (ksd.getOption() != null) {
				 Action a = ksd.getAction();
				 String name = (String) a.getValue(Action.SHORT_DESCRIPTION);
				 if (name == null || name.trim().equals("""")) name = ksd.getName();
				 String desc = (String) a.getValue(Action.LONG_DESCRIPTION);
				 if (desc == null || desc.trim().equals("""")) desc = name;
				 if (_comps.containsKey(name)) {
					 name = desc;
					 if (_comps.containsKey(name)) {
						 name = ksd.getOption().getName();
					 }
				 }
				 vksoc = new VectorKeyStrokeOptionComponent(ksd.getOption(), name, this, desc);
				 if (vksoc != null) _comps.put(name, vksoc);
			 }
		 }
		 Iterator<VectorKeyStrokeOptionComponent> iter = _comps.values().iterator();
		 while (iter.hasNext()) {
			 VectorKeyStrokeOptionComponent x = iter.next();
			 addOptionComponent(panel, x);
		 }
		 panel.displayComponents();
	 }
	 private void _setupDebugPanel(ConfigPanel panel) {
		 if (!_mainFrame.getModel().getDebugger().isAvailable()) {
			 String howto = ""\nThe debugger is not currently available. To use the debugger,\n"" + ""you can enter the location of the tools.jar file in the\n"" + ""\""Resource Locations\"" pane, in case DrJava does not automatically find it.\n"" + ""See the user documentation for more details.\n"";
			 LabelComponent label = new LabelComponent(howto, this);
			 label.setEntireColumn(true);
			 addOptionComponent(panel, label);
		 }
		 VectorFileOptionComponent sourcePath = new VectorFileOptionComponent(OptionConstants.DEBUG_SOURCEPATH, ""Sourcepath"", this, ""<html>Any directories in which to search for source<br>"" + ""files when stepping in the Debugger.</html>"", true);
		 sourcePath.getFileChooser().setFileFilter(new DirectoryFilter(""Source Directories""));
		 addOptionComponent(panel, sourcePath);
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DEBUG_STEP_JAVA, ""Step Into Java Classes"", this, ""<html>Whether the Debugger should step into Java library classes,<br>"" + ""including java.*, javax.*, sun.*, com.sun.*, com.apple.eawt.*, and com.apple.eio.*</html>""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DEBUG_STEP_INTERPRETER, ""Step Into Interpreter Classes"", this, ""<html>Whether the Debugger should step into the classes<br>"" + ""used by the Interactions Pane (DynamicJava).</html>""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DEBUG_STEP_DRJAVA, ""Step Into DrJava Classes"", this, ""Whether the Debugger should step into DrJava's own class files.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		"" + ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		"" + ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new VectorStringOptionComponent(OptionConstants.DEBUG_STEP_EXCLUDE, ""Classes/Packages To Exclude"", this, ""<html>Any classes that the debuggger should not step into.<br>"" + ""Should be a list of fully-qualified class names.<br>"" + ""To exclude a package, add <code>packagename.*</code> to the list.</html>""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DEBUG_AUTO_IMPORT, ""Auto-Import after Breakpoint/Step"", this, ""<html>Whether the Debugger should automatically import packages<br>""+ ""and classes again after a breakpoint or step.</html>""));
		 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.AUTO_STEP_RATE, ""Auto-Step Rate in ms"", this, ""<html>A defined rate in ms at which the debugger automatically steps into/over each line of code.<br>"" + ""Value entered must be an integer value. </html>""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DEBUG_EXPRESSIONS_AND_METHODS_IN_WATCHES, ""Allow Expressions and Method Calls in Watches"", this, ""<html>Whether the Debugger should allow expressions and method<br>""+ ""calls in watches. These may have side effects and can cause<br>""+ ""delays during the debug process.</html>""));
		 panel.displayComponents();
	 }
	 private void _setupJavadocPanel(ConfigPanel panel) {
		 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.JAVADOC_API_REF_VERSION, ""Java Version for \""Open Java API Javadoc\"""", this, ""Version of the Java API documentation to be used.""));
		 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.JAVADOC_ACCESS_LEVEL, ""Access Level"", this, ""<html>Fields and methods with access modifiers at this level<br>"" + ""or higher will be included in the generated Javadoc.</html>""));
		 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.JAVADOC_LINK_VERSION, ""Java Version for Javadoc Links"", this, ""Version of Java for generating links to online Javadoc documentation.""));
		 addOptionComponent(panel, new StringOptionComponent(OptionConstants.JAVADOC_1_5_LINK, ""Javadoc 1.5 URL"", this, ""URL for the Java 1.5 API, for generating links to library classes.""));
		 addOptionComponent(panel, new StringOptionComponent(OptionConstants.JAVADOC_1_6_LINK, ""Javadoc 1.6 URL"", this, ""URL for the Java 1.6 API, for generating links to library classes.""));
		 addOptionComponent(panel, new StringOptionComponent(OptionConstants.JUNIT_LINK, ""JUnit URL"", this, ""URL for the JUnit API, for \""Open Java API Javadoc\"".""));
		 VectorStringOptionComponent additionalJavadoc = new VectorStringOptionComponent(OptionConstants.JAVADOC_ADDITIONAL_LINKS, ""Additional Javadoc URLs"", this, ""<html>Additional URLs with Javadoc, for \""Open Java API Javadoc\""<br>"" + ""and auto-completion.</html>"") {
			 protected boolean verify(String s) {
				 boolean result = true;
				 try {
					 java.net.URL url = new java.net.URL(s+""/allclasses-frame.html"");
					 java.io.InputStream urls = url.openStream();
					 java.io.InputStreamReader is = null;
					 java.io.BufferedReader br = null;
					 try {
						 is = new java.io.InputStreamReader(urls);
						 br = new java.io.BufferedReader(is);
						 String line = br.readLine();
						 if (line == null) {
							 result = false;
						 }
					 }
					 finally {
						 if (br != null) {
							 br.close();
						 }
						 if (is != null) {
							 is.close();
						 }
						 if (urls != null) {
							 urls.close();
						 }
					 }
				 }
				 catch(java.io.IOException ioe) {
					 result = false;
				 }
				 if (!result) {
					 JOptionPane.showMessageDialog(ConfigFrame.this, ""Could not find the Javadoc at the URL\n""+ s, ""Error Adding Javadoc"", JOptionPane.ERROR_MESSAGE);
				 }
				 return result;
			 }
		 }
		;
		 addOptionComponent(panel, additionalJavadoc);
		 addOptionComponent(panel, new DirectoryOptionComponent(OptionConstants.JAVADOC_DESTINATION, ""Default Destination Directory"", this, ""Optional default directory for saving Javadoc documentation."", _dirChooser));
		 addOptionComponent(panel, javadocCustomParams = new StringOptionComponent(OptionConstants.JAVADOC_CUSTOM_PARAMS, ""Custom Javadoc Parameters"", this, ""Any extra flags or parameters to pass to Javadoc.""));
		 panel.displayComponents();
	 }
	 private void _setupNotificationsPanel(ConfigPanel panel) {
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.QUIT_PROMPT, ""Prompt Before Quit"", this, ""Whether DrJava should prompt the user before quitting."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.INTERACTIONS_RESET_PROMPT, ""Prompt Before Resetting Interactions Pane"", this, ""<html>Whether DrJava should prompt the user before<br>"" + ""manually resetting the interactions pane.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.INTERACTIONS_EXIT_PROMPT, ""Prompt if Interactions Pane Exits Unexpectedly"", this, ""<html>Whether DrJava should show a dialog box if a program<br>"" + ""in the Interactions Pane exits without the user clicking Reset.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.JAVADOC_PROMPT_FOR_DESTINATION, ""Prompt for Javadoc Destination"", this, ""<html>Whether Javadoc should always prompt the user<br>"" + ""to select a destination directory.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.PROMPT_BEFORE_CLEAN, ""Prompt before Cleaning Build Directory"", this, ""<html>Whether DrJava should prompt before cleaning the<br>"" + ""build directory of a project</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.PROMPT_RENAME_LL_FILES, ""Prompt to Rename Old Language Level Files When Saving"", this, ""<html>Whether DrJava should prompt the user to rename old language level files.<br>""+ ""DrJava suggests to rename .dj0 and .dj1 files to .dj, and .dj2 files to .java.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_SAVE_BEFORE_COMPILE, ""Automatically Save Before Compiling"", this, ""<html>Whether DrJava should automatically save before<br>"" + ""recompiling or ask the user each time.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_COMPILE_BEFORE_JUNIT, ""Automatically Compile Before Testing"", this, ""<html>Whether DrJava should automatically compile before<br>"" + ""testing with JUnit or ask the user each time.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_SAVE_BEFORE_JAVADOC, ""Automatically Save Before Generating Javadoc"", this, ""<html>Whether DrJava should automatically save before<br>"" + ""generating Javadoc or ask the user each time.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_COMPILE_BEFORE_JAVADOC, ""Automatically Compile Before Generating Javadoc"", this, ""<html>Whether DrJava should automatically compile before<br>"" + ""generating Javadoc or ask the user each time.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_BREAKPOINT_OUT_OF_SYNC, ""Warn on Breakpoint if Out of Sync"", this, ""<html>Whether DrJava should warn the user if the class file<br>"" + ""is out of sync before setting a breakpoint in that file.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_DEBUG_MODIFIED_FILE, ""Warn if Debugging Modified File"", this, ""<html>Whether DrJava should warn the user if the file being<br>"" + ""debugged has been modified since its last save.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_CHANGE_LAF, ""Warn to Restart to Change Look and Feel"", this, ""<html>Whether DrJava should warn the user that look and feel<br>"" + ""changes will not be applied until DrJava is restarted.</html>."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_CHANGE_THEME, ""Warn to Restart to Change Theme"", this, ""<html>Whether DrJava should warn the user that theme<br>"" + ""changes will not be applied until DrJava is restarted.</html>."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_CHANGE_DCP, ""Warn to Restart to Change Default Compiler Preference"", this, ""<html>Whether DrJava should warn the user that default compiler preference<br>"" + ""changes will not be applied until DrJava is restarted.</html>."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_CHANGE_MISC, ""Warn to Restart to Change Preferences (other)"", this, ""<html>Whether DrJava should warn the user that preference<br>"" + ""changes will not be applied until DrJava is restarted.</html>."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_CHANGE_INTERACTIONS, ""Warn to Reset to Change Interactions"", this, ""<html>Whether DrJava should warn the user that preference<br>"" + ""changes will not be applied until the Interactions Pane<br>"" + ""is reset.</html>."", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_PATH_CONTAINS_POUND, ""Warn if File's Path Contains a '#' Symbol"", this, ""<html>Whether DrJava should warn the user if the file being<br>"" + ""saved has a path that contains a '#' symbol.<br>"" + ""Users cannot use such files in the Interactions Pane<br>"" + ""because of a bug in Java.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_DRJAVA_ERROR_POPUP_ENABLED, ""Show a notification window when the first DrJava error occurs"", this, ""<html>Whether to show a notification window when the first DrJava error occurs.<br>"" + ""If this is disabled, only the \""DrJava Error\"" button will appear.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.WARN_IF_COMPIZ, ""Warn If Compiz Detected"", this, ""<html>Whether DrJava should warn the user if Compiz is running.<br>""+ ""Compiz and Java Swing are incompatible and can lead to crashes.</html>"", false) .setEntireColumn(true));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		"" + ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		"" + ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.DELETE_LL_CLASS_FILES, ""Delete language level class files?"", this, ""Whether DrJava should delete class files in directories with language level files.""));
		 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		"" + ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		"" + ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		</html>"", this, true));
		 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.NEW_VERSION_NOTIFICATION, ""Check for new versions?"", this, ""Whether DrJava should check for new versions on drjava.org.""));
		 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.NEW_VERSION_NOTIFICATION_DAYS, ""Days between new version check"", this, ""The number of days between automatic new version checks.""));
		 panel.displayComponents();
	 }
	 private void _setupMiscPanel(ConfigPanel panel) {
		 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.INDENT_LEVEL, ""Indent Level"", this, ""The number of spaces to use for each level of indentation.""));
		 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.RECENT_FILES_MAX_SIZE, ""Recent Files List Size"", this, ""<html>The number of files to remember in<br>"" + ""the recently used files list in the File menu.</html>""));
		 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.BROWSER_HISTORY_MAX_SIZE, ""Maximum Size of Browser History"", this, ""Determines how many entries are kept in the browser history.""));
		 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.AUTO_CLOSE_COMMENTS, ""Automatically Close Block Comments"", this, ""<html>Whether to automatically insert a closing comment tag (\""*/\"")<br>"" + ""when the enter key is pressed after typing a new block comment<br>"" + ""tag (\"" private void _setupJVMsPanel(ConfigPanel panel) {
			 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.MASTER_JVM_XMX, ""Maximum Heap Size for Main JVM in MB"", this, ""The maximum heap the Main JVM can use. Select blank for default.""));
			 addOptionComponent(panel, new StringOptionComponent(OptionConstants.MASTER_JVM_ARGS, ""JVM Args for Main JVM"", this, ""The command-line arguments to pass to the Main JVM.""));
			 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.SLAVE_JVM_XMX, ""Maximum Heap Size for Interactions JVM in MB"", this, ""The maximum heap the Interactions JVM can use. Select blank for default""));
			 addOptionComponent(panel, new StringOptionComponent(OptionConstants.SLAVE_JVM_ARGS, ""JVM Args for Interactions JVM"", this, ""The command-line arguments to pass to the Interactions JVM.""));
			 panel.displayComponents();
		 }
		 private void _setupFileTypesPanel(ConfigPanel panel) {
			 if (PlatformFactory.ONLY.canRegisterFileExtensions()) {
				 addOptionComponent(panel, new LabelComponent(""<html>Assign DrJava project files and DrJava extensions<br>""+ ""(with the extensions .drjava and .djapp) to DrJava.<br>""+ ""When double-clicking on a .drjava file, DrJava will open it.</html>"", this, true));
				 panel.addComponent(new ButtonComponent(new ActionListener() {
					 public void actionPerformed(ActionEvent e) {
						 if (PlatformFactory.ONLY.registerDrJavaFileExtensions()) {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Successfully set .drjava and .djapp file associations."", ""Success"", JOptionPane.INFORMATION_MESSAGE);
						 }
						 else {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Could not set .drjava and .djapp file associations."", ""File Types Error"", JOptionPane.ERROR_MESSAGE);
						 }
					 }
				 }
				, ""Associate .drjava and .djapp Files with DrJava"", this, ""This associates .drjava and .djapp files with DrJava.""));
				 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
				</html>"", this, true));
				 panel.addComponent(new ButtonComponent(new ActionListener() {
					 public void actionPerformed(ActionEvent e) {
						 if (PlatformFactory.ONLY.unregisterDrJavaFileExtensions()) {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Successfully removed .drjava and .djapp file associations."", ""Success"", JOptionPane.INFORMATION_MESSAGE);
						 }
						 else {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Could not remove .drjava and .djapp file associations."", ""File Types Error"", JOptionPane.ERROR_MESSAGE);
						 }
					 }
				 }
				, ""Remove .drjava and .djapp File Associations"", this, ""This removes the association of .drjava and .djapp files with DrJava.""));
				 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
				</html>"", this, true));
				 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
				</html>"", this, true));
				 addOptionComponent(panel, new LabelComponent(""<html>Assign Java source files with the<br>""+ ""extension .java to DrJava. When double-clicking<br>""+ ""on a .java file, DrJava will open it.</html>"", this, true));
				 panel.addComponent(new ButtonComponent(new ActionListener() {
					 public void actionPerformed(ActionEvent e) {
						 if (PlatformFactory.ONLY.registerJavaFileExtension()) {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Successfully set .java file association."", ""Success"", JOptionPane.INFORMATION_MESSAGE);
						 }
						 else {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Could not set .java file association."", ""File Types Error"", JOptionPane.ERROR_MESSAGE);
						 }
					 }
				 }
				, ""Associate .java Files with DrJava"", this, ""This associates .java source files with DrJava.""));
				 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
				</html>"", this, true));
				 panel.addComponent(new ButtonComponent(new ActionListener() {
					 public void actionPerformed(ActionEvent e) {
						 if (PlatformFactory.ONLY.unregisterJavaFileExtension()) {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Successfully removed .java file association."", ""Success"", JOptionPane.INFORMATION_MESSAGE);
						 }
						 else {
							 JOptionPane.showMessageDialog(ConfigFrame.this, ""Could not remove .java file association."", ""File Types Error"", JOptionPane.ERROR_MESSAGE);
						 }
					 }
				 }
				, ""Remove .java File Association"", this, ""This removes the association of .java project files with DrJava.""));
				 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
				</html>"", this, true));
				 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
				</html>"", this, true));
				 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.FILE_EXT_REGISTRATION, ""<html>Automatically assign .java, .drjava and .djapp Files to DrJava</html>"", this, ""<html>Assign files with the extensions .java, .drjava and .djapp to DrJava.<br>""+ ""When double-clicking those files, they will be opened in DrJava.<br><br>""+ ""Selecting 'always' will re-establish this association every time DrJava<br>""+ ""started, without asking. Selecting 'ask me' will ask the user at start up<br>""+ ""if the association has been changed. Selecting 'never' will not assign<br>""+ "".java, .drjava and .djapp files to DrJava.""));
			 }
			 else {
				 addOptionComponent(panel, new LabelComponent(""<html><br><br>""+ (PlatformFactory.ONLY.isMacPlatform()? ""File associations are managed automatically by Mac OS."": (PlatformFactory.ONLY.isWindowsPlatform()? ""To set file associations, please use the .exe file version of DrJava.<br>""+ ""Configuring file associations is not supported for the .jar file version."": ""Managing file associations is not supported yet on this operating system.""))+ ""</html>"", this, true));
			 }
			 panel.displayComponents();
		 }
		 private void _setupCompilerPanel(ConfigPanel panel) {
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_UNCHECKED_WARNINGS, ""Show Unchecked Warnings"", this, ""<html>Warn about unchecked conversions involving parameterized types.</html>"", false) .setEntireColumn(true));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_DEPRECATION_WARNINGS, ""Show Deprecation Warnings"", this, ""<html>Warn about each use or override of a deprecated method, field, or class.</html>"", false) .setEntireColumn(true));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_PATH_WARNINGS, ""Show Path Warnings"", this, ""<html>Warn about nonexistent members of the classpath and sourcepath.</html>"", false) .setEntireColumn(true));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_SERIAL_WARNINGS, ""Show Serial Warnings"", this, ""<html>Warn about missing <code>serialVersionUID</code> definitions on serializable classes.</html>"", false) .setEntireColumn(true));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_FINALLY_WARNINGS, ""Show Finally Warnings"", this, ""<html>Warn about <code>finally</code> clauses that cannot complete normally.</html>"", false) .setEntireColumn(true));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.SHOW_FALLTHROUGH_WARNINGS, ""Show Fall-Through Warnings"", this, ""<html>Warn about <code>switch</code> block cases that fall through to the next case.</html>"", false) .setEntireColumn(true));
			 final ForcedChoiceOptionComponent CPC = new ForcedChoiceOptionComponent(OptionConstants.COMPILER_PREFERENCE_CONTROL.evaluate(), ""Compiler Preference"", this, ""Which compiler is prefered?"");
			 ActionListener CPCActionListener = new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 if(!edu.rice.cs.drjava.DrJava.getConfig().getSetting(OptionConstants.DEFAULT_COMPILER_PREFERENCE).equals(CPC.getCurrentComboBoxValue())){
						 edu.rice.cs.drjava.DrJava.getConfig().setSetting(OptionConstants.DEFAULT_COMPILER_PREFERENCE,CPC.getCurrentComboBoxValue());
					 }
				 }
			 }
			;
			 _applyButton.addActionListener(CPCActionListener);
			 _okButton.addActionListener(CPCActionListener);
			 addOptionComponent(panel, CPC.setEntireColumn(false) );
			 addOptionComponent(panel, new LabelComponent(""<html><br><br>Note: Compiler warnings not shown if compiling any Java language level files.</html>"", this, true));
			 panel.displayComponents();
		 }
		 private void _setupInteractionsPanel(ConfigPanel panel) {
			 final DirectoryOptionComponent wdComponent = new DirectoryOptionComponent(OptionConstants.FIXED_INTERACTIONS_DIRECTORY, ""Interactions Working Directory"", this, ""<html>Working directory for the Interactions Pane (unless<br>""+ ""a project working directory has been set).</html>"", _dirChooser);
			 addOptionComponent(panel, wdComponent);
			 final BooleanOptionComponent stickyComponent = new BooleanOptionComponent(OptionConstants.STICKY_INTERACTIONS_DIRECTORY, ""<html><p align=\""right\"">"" + StringOps. splitStringAtWordBoundaries(""Restore last working directory of the Interactions pane on start up"", 33, ""<br>"", SEPS), this, ""<html>Whether to restore the last working directory of the Interaction pane on start up,<br>"" + ""or to always use the value of the \""user.home\"" Java property<br>""+ ""(currently ""+System.getProperty(""user.home"")+"")."");
			 addOptionComponent(panel, stickyComponent);
			 OptionComponent.ChangeListener wdListener = new OptionComponent.ChangeListener() {
				 public Object value(Object oc) {
					 File f = wdComponent.getComponent().getFileFromField();
					 boolean enabled = (f == null) || (f.equals(FileOps.NULL_FILE));
					 stickyComponent.getComponent().setEnabled(enabled);
					 return null;
				 }
			 }
			;
			 wdComponent.addChangeListener(wdListener);
			 wdListener.value(wdComponent);
			 addOptionComponent(panel, new BooleanOptionComponent (OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS, ""Smart Run Command"", this, ""<html>Whether the Run button and meni item should automatically detect<br>""+ ""applets and ACM Java Task Force programs (subclasses of acm.program.Program).</html>""));
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.HISTORY_MAX_SIZE, ""Size of Interactions History"", this, ""The number of interactions to remember in the history.""));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DIALOG_AUTOIMPORT_ENABLED, ""Enable the \""Auto Import\"" Dialog"", this, ""<html>Whether DrJava should open the \""Auto Import\"" dialog when<br>""+ ""an undefined class is encountered in the Interactions Pane.</html>""));
			 VectorStringOptionComponent autoImportClasses = new VectorStringOptionComponent(OptionConstants.INTERACTIONS_AUTO_IMPORT_CLASSES, ""Classes to Auto-Import"", this, ""<html>List of classes to auto-import every time the<br>""+ ""Interaction Pane is reset or started. Examples:<br><br>""+ ""java.io.File<br>""+ ""java.util.*</html>"") {
				 protected boolean verify(String s) {
					 boolean result = true;
					 for(int i = 0;
					 i < s.length();
					 ++i) {
						 char ch = s.charAt(i);
						 if ((ch!='.') && (ch!='*') && (!Character.isJavaIdentifierPart(ch))) {
							 result = false;
							 break;
						 }
					 }
					 if (!result) {
						 JOptionPane.showMessageDialog(ConfigFrame.this, ""This is not a valid class name:\n""+ s, ""Error Adding Class Name"", JOptionPane.ERROR_MESSAGE);
					 }
					 return result;
				 }
			 }
			;
			 addOptionComponent(panel, autoImportClasses);
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 addOptionComponent(panel, new ForcedChoiceOptionComponent(OptionConstants.DYNAMICJAVA_ACCESS_CONTROL, ""Enforce access control"", this, ""What kind of access control should DrJava enforce in the Interactions Pane?""));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DYNAMICJAVA_REQUIRE_SEMICOLON, ""Require Semicolon"", this, ""<html>Whether DrJava should require a semicolon at the<br>""+ ""end of a statement in the Interactions Pane.</html>""));
			 addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.DYNAMICJAVA_REQUIRE_VARIABLE_TYPE, ""Require Variable Type"", this, ""<html>Whether DrJava should require a variable type for<br>""+ ""variable declarations in the Interactions Pane.</html>""));
			 panel.displayComponents();
		 }
		 private void _setupJUnitPanel(ConfigPanel panel) {
			 final BooleanOptionComponent junitLocEnabled = new BooleanOptionComponent(OptionConstants.JUNIT_LOCATION_ENABLED, ""Use external JUnit"", this, ""<html>If this is enabled, DrJava will use the JUnit configured<br>""+ ""below under 'JUnit/ConcJUnit Location'. If it is disabled,<br>""+ ""DrJava will use the JUnit that is built-in.</html>"", false) .setEntireColumn(true);
			 addOptionComponent(panel, junitLocEnabled);
			 final FileOptionComponent junitLoc = new FileOptionComponent(OptionConstants.JUNIT_LOCATION, ""JUnit/ConcJUnit Location"", this, ""<html>Optional location of the JUnit or ConcJUnit jar file.<br>""+ ""(Changes will not be applied until the Interactions Pane<br>""+ ""is reset.)</html>"", new FileSelectorComponent(this, _jarChooser, 30, 10f) {
				 public void setFileField(File file) {
					 if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidJUnitFile(file) || edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(file)) {
						 super.setFileField(file);
					 }
					 else if (file.exists()) {
						 new edu.rice.cs.drjava.ui.DrJavaScrollableDialog(_parent, ""Invalid JUnit/ConcJUnit File"", ""Stack trace:"", edu.rice.cs.util.StringOps.getStackTrace(), 600, 400, false).show();
						 JOptionPane.showMessageDialog(_parent, ""The file '""+ file.getName() + ""'\nis not a valid JUnit/ConcJUnit file."", ""Invalid JUnit/ConcJUnit File"", JOptionPane.ERROR_MESSAGE);
						 resetFileField();
					 }
				 }
				 public boolean validateTextField() {
					 String newValue = _fileField.getText().trim();
					 File newFile = FileOps.NULL_FILE;
					 if (!newValue.equals("""")) newFile = new File(newValue);
					 if (newFile != FileOps.NULL_FILE && !newFile.exists()) {
						 JOptionPane.showMessageDialog(_parent, ""The file '""+ newFile.getName() + ""'\nis invalid because it does not exist."", ""Invalid File Name"", JOptionPane.ERROR_MESSAGE);
						 if (_file != null && ! _file.exists()) _file = FileOps.NULL_FILE;
						 resetFileField();
						 return false;
					 }
					 else {
						 if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidJUnitFile(newFile) || edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(newFile) || FileOps.NULL_FILE.equals(newFile)) {
							 setFileField(newFile);
							 return true;
						 }
						 else {
							 new edu.rice.cs.drjava.ui.DrJavaScrollableDialog(_parent, ""Invalid JUnit/ConcJUnit File"", ""newFile is NULL_FILE? ""+(FileOps.NULL_FILE.equals(newFile)), edu.rice.cs.util.StringOps.getStackTrace(), 600, 400, false).show();
							 JOptionPane.showMessageDialog(_parent, ""The file '""+ newFile.getName() + ""'\nis not a valid JUnit/ConcJUnit file."", ""Invalid JUnit/ConcJUnit File"", JOptionPane.ERROR_MESSAGE);
							 resetFileField();
							 return false;
						 }
					 }
				 }
			 }
			);
			 junitLoc.setFileFilter(ClassPathFilter.ONLY);
			 addOptionComponent(panel, junitLoc);
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 final ForcedChoiceOptionComponent concJUnitChecksEnabledComponent = new ForcedChoiceOptionComponent(OptionConstants.CONCJUNIT_CHECKS_ENABLED, ""Enabled ConcJUnit Checks"", this, ""<html>The concurrent unit testing checks that should be performed.<br>""+ ""'none' uses plain JUnit. ConcJUnit can also detect failures in<br>""+ ""all threads ('all-threads'), detect threads that did not end in<br>""+ ""time ('all-threads, join'), and threads that ended in time only<br>""+ ""because they were lucky ('all-threads, nojoin, lucky).<br>""+ ""The last setting requires a 'ConcJUnit Runtime Location' to be set.</html>"");
			 addOptionComponent(panel, concJUnitChecksEnabledComponent);
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 final FileOptionComponent rtConcJUnitLoc = new FileOptionComponent(OptionConstants.RT_CONCJUNIT_LOCATION, ""ConcJUnit Runtime Location"", this, ""<html>Optional location of the Java Runtime Library processed<br>""+ ""to generate &quot;
			lucky&quot;
			 warnings. If left blank, &quot;
			lucky&quot;
			 warnings<br>""+ ""will not be generated. This setting is deactivated if the path to<br>""+ ""ConcJUnit has not been specified above.<br>"" + ""(Changes will not be applied until the Interactions Pane is reset.)</html>"", new FileSelectorComponent(this, _jarChooser, 30, 10f) {
				 public void setFileField(File file) {
					 if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(file)) {
						 super.setFileField(file);
					 }
					 else if (file.exists()) {
						 JOptionPane.showMessageDialog(_parent, ""The file '""+ file.getName() + ""'\nis not a valid ConcJUnit Runtime file."", ""Invalid ConcJUnit Runtime File"", JOptionPane.ERROR_MESSAGE);
						 resetFileField();
					 }
				 }
				 public boolean validateTextField() {
					 String newValue = _fileField.getText().trim();
					 File newFile = FileOps.NULL_FILE;
					 if (!newValue.equals("""")) newFile = new File(newValue);
					 if (newFile != FileOps.NULL_FILE && !newFile.exists()) {
						 JOptionPane.showMessageDialog(_parent, ""The file '""+ newFile.getName() + ""'\nis invalid because it does not exist."", ""Invalid File Name"", JOptionPane.ERROR_MESSAGE);
						 if (_file != null && ! _file.exists()) _file = FileOps.NULL_FILE;
						 resetFileField();
						 return false;
					 }
					 else {
						 if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(newFile) || FileOps.NULL_FILE.equals(newFile)) {
							 setFileField(newFile);
							 return true;
						 }
						 else {
							 JOptionPane.showMessageDialog(_parent, ""The file '""+ newFile.getName() + ""'\nis not a valid ConcJUnit Runtime file."", ""Invalid ConcJUnit Runtime File"", JOptionPane.ERROR_MESSAGE);
							 resetFileField();
							 return false;
						 }
					 }
				 }
			 }
			);
			 rtConcJUnitLoc.setFileFilter(ClassPathFilter.ONLY);
			 ActionListener processRTListener = new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 File concJUnitJarFile = FileOps.getDrJavaFile();
					 if (junitLocEnabled.getComponent().isSelected()) {
						 concJUnitJarFile = junitLoc.getComponent().getFileFromField();
					 }
					 File rtFile = rtConcJUnitLoc.getComponent().getFileFromField();
					 edu.rice.cs.drjava.model.junit.ConcJUnitUtils. showGenerateRTConcJUnitJarFileDialog(ConfigFrame.this, rtFile, concJUnitJarFile, new Runnable1<File>() {
						 public void run(File targetFile) {
							 rtConcJUnitLoc.getComponent().setFileField(targetFile);
						 }
					 }
					, new Runnable() {
						 public void run() {
						 }
					 }
					);
				 }
			 }
			;
			 final ButtonComponent processRT = new ButtonComponent(processRTListener, ""Generate ConcJUnit Runtime File"", this, ""<html>Generate the ConcJUnit Runtime file specified above.<br>""+ ""This setting is deactivated if the path to ConcJUnit has not been specified above.</html>"");
			 OptionComponent.ChangeListener rtConcJUnitListener = new OptionComponent.ChangeListener() {
				 public Object value(Object oc) {
					 File f = junitLoc.getComponent().getFileFromField();
					 boolean enabled = (!junitLocEnabled.getComponent().isSelected()) || edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(f);
					 rtConcJUnitLoc.getComponent().setEnabled(enabled);
					 processRT.getComponent().setEnabled(enabled);
					 concJUnitChecksEnabledComponent.getComponent().setEnabled(enabled);
					 return null;
				 }
			 }
			;
			 OptionComponent.ChangeListener junitLocListener = new OptionComponent.ChangeListener() {
				 public Object value(Object oc) {
					 boolean enabled = junitLocEnabled.getComponent().isSelected();
					 junitLoc.getComponent().setEnabled(enabled);
					 return null;
				 }
			 }
			;
			 junitLocEnabled.addChangeListener(junitLocListener);
			 junitLocEnabled.addChangeListener(rtConcJUnitListener);
			 junitLoc.addChangeListener(rtConcJUnitListener);
			 addOptionComponent(panel, rtConcJUnitLoc);
			 addOptionComponent(panel, processRT);
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 final LabelComponent internalExternalStatus = new LabelComponent(""<html>&nbsp;
			</html>"", this, true);
			 final LabelComponent threadsStatus = new LabelComponent(""<html>&nbsp;
			</html>"", this, true);
			 final LabelComponent joinStatus = new LabelComponent(""<html>&nbsp;
			</html>"", this, true);
			 final LabelComponent luckyStatus = new LabelComponent(""<html>&nbsp;
			</html>"", this, true);
			 OptionComponent.ChangeListener junitStatusChangeListener = new OptionComponent.ChangeListener() {
				 public Object value(Object oc) {
					 File f = junitLoc.getComponent().getFileFromField();
					 String[] s = new String[] {
					 "" "", "" "", "" "", "" "" }
					;
					 boolean isConcJUnit = true;
					 if ((!junitLocEnabled.getComponent().isSelected()) || (f==null) || FileOps.NULL_FILE.equals(f) || !f.exists()) {
						 s[0] = ""DrJava uses the built-in ConcJUnit framework."";
					 }
					 else {
						 String type = ""ConcJUnit"";
						 if (!edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(f)) {
							 type = ""JUnit"";
							 isConcJUnit = false;
						 }
						 s[0] = ""DrJava uses an external ""+type+"" framework."";
					 }
					 if (!isConcJUnit) {
						 s[1] = ""JUnit does not support all-thread, no-join"";
						 s[2] = ""or lucky checks. They are all disabled."";
					 }
					 else {
						 s[1] = ""All-thread checks are disabled."";
						 s[2] = ""No-join checks are disabled."";
						 s[3] = ""Lucky checks are disabled."";
						 if (!concJUnitChecksEnabledComponent.getCurrentComboBoxValue(). equals(OptionConstants.ConcJUnitCheckChoices.NONE)) {
							 s[1] = ""All-thread checks are enabled."";
							 if (concJUnitChecksEnabledComponent.getCurrentComboBoxValue(). equals(OptionConstants.ConcJUnitCheckChoices.ALL) || concJUnitChecksEnabledComponent.getCurrentComboBoxValue(). equals(OptionConstants.ConcJUnitCheckChoices.NO_LUCKY)) {
								 s[2] = ""No-join checks are enabled."";
								 if (concJUnitChecksEnabledComponent.getCurrentComboBoxValue(). equals(OptionConstants.ConcJUnitCheckChoices.ALL)) {
									 File rtf = rtConcJUnitLoc.getComponent().getFileFromField();
									 if ((rtf!=null) && !FileOps.NULL_FILE.equals(rtf) && rtf.exists() && edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(rtf)) {
										 s[3] = ""Lucky checks are enabled."";
									 }
								 }
							 }
						 }
					 }
					 internalExternalStatus.getComponent().setText(s[0]);
					 threadsStatus.getComponent().setText(s[1]);
					 joinStatus.getComponent().setText(s[2]);
					 luckyStatus.getComponent().setText(s[3]);
					 return null;
				 }
			 }
			;
			 concJUnitChecksEnabledComponent.addChangeListener(junitStatusChangeListener);
			 junitLocEnabled.addChangeListener(junitStatusChangeListener);
			 junitLoc.addChangeListener(junitStatusChangeListener);
			 rtConcJUnitLoc.addChangeListener(junitStatusChangeListener);
			 addOptionComponent(panel, internalExternalStatus);
			 addOptionComponent(panel, threadsStatus);
			 addOptionComponent(panel, joinStatus);
			 addOptionComponent(panel, luckyStatus);
			 junitLocListener.value(null);
			 rtConcJUnitListener.value(null);
			 junitStatusChangeListener.value(null);
			 addOptionComponent(panel, new LabelComponent(""<html>&nbsp;
			</html>"", this, true));
			 final BooleanOptionComponent forceTestSuffix = new BooleanOptionComponent(OptionConstants.FORCE_TEST_SUFFIX, ""Require test classes in projects to end in \""Test\"""", this, ""Whether to force test classes in projects to end in \""Test\""."", false) .setEntireColumn(true);
			 addOptionComponent(panel, forceTestSuffix);
			 panel.displayComponents();
		 }
		 private class PanelTreeNode extends DefaultMutableTreeNode {
			 private final ConfigPanel _panel;
			 public PanelTreeNode(String t) {
				 super(t);
				 _panel = new ConfigPanel(t);
			 }
			 public PanelTreeNode(ConfigPanel c) {
				 super(c.getTitle());
				 _panel = c;
			 }
			 private ConfigPanel getPanel() {
				 return _panel;
			 }
			 private boolean update() {
				 boolean isValidUpdate = _panel.update();
				 if (!isValidUpdate) {
					 TreeNode[] nodes = getPath();
					 TreePath path = new TreePath(nodes);
					 _tree.expandPath(path);
					 _tree.setSelectionPath(path);
					 return false;
				 }
				 Enumeration<?> childNodes = children();
				 while (childNodes.hasMoreElements()) {
					 boolean isValidUpdateChildren = ((PanelTreeNode)childNodes.nextElement()).update();
					 if (!isValidUpdateChildren) {
						 return false;
					 }
				 }
				 return true;
			 }
			 public void resetToCurrent() {
				 _panel.resetToCurrent();
				 Enumeration<?> childNodes = children();
				 while (childNodes.hasMoreElements()) {
					 ((PanelTreeNode)childNodes.nextElement()).resetToCurrent();
				 }
			 }
		 }
		 private class PanelTreeSelectionListener implements TreeSelectionListener {
			 public void valueChanged(TreeSelectionEvent e) {
				 Object o = _tree.getLastSelectedPathComponent();
				 if (o instanceof PanelTreeNode) {
					 PanelTreeNode child = (PanelTreeNode) _tree.getLastSelectedPathComponent();
					 _displayPanel(child.getPanel());
				 }
			 }
		 }
	}",1,0,0,0
"public class DdbStreamComponent extends DefaultComponent {
	 private String accessKey;
	 private String secretKey;
	 private String region;
	 private DdbStreamConfiguration configuration;
	 public DdbStreamComponent() {
		 this(null);
	 }
	 public DdbStreamComponent(CamelContext context) {
		 super(context);
		 this.configuration = new DdbStreamConfiguration();
		 registerExtension(new DdbStreamComponentVerifierExtension());
	 }
	 protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
		 DdbStreamConfiguration configuration = this.configuration.copy();
		 configuration.setTableName(remaining);
		 setProperties(configuration, parameters);
		 if (remaining == null || remaining.trim().length() == 0) {
			 throw new IllegalArgumentException(""Table name must be specified."");
		 }
		 configuration.setTableName(remaining);
		 if (ObjectHelper.isEmpty(configuration.getAccessKey())) {
			 setAccessKey(accessKey);
		 }
		 if (ObjectHelper.isEmpty(configuration.getSecretKey())) {
			 setSecretKey(secretKey);
		 }
		 if (ObjectHelper.isEmpty(configuration.getRegion())) {
			 setRegion(region);
		 }
		 if (configuration.getAmazonDynamoDbStreamsClient() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {
			 throw new IllegalArgumentException(""amazonDDBStreamsClient or accessKey and secretKey must be specified"");
		 }
		 DdbStreamEndpoint endpoint = new DdbStreamEndpoint(uri, configuration, this);
		 setProperties(endpoint, parameters);
		 return endpoint;
	 }
	 public DdbStreamConfiguration getConfiguration() {
		 return configuration;
	 }
	 public void setConfiguration(DdbStreamConfiguration configuration) {
		 this.configuration = configuration;
	 }
	 public String getAccessKey() {
		 return configuration.getAccessKey();
	 }
	 public void setAccessKey(String accessKey) {
		 configuration.setAccessKey(accessKey);
	 }
	 public String getSecretKey() {
		 return configuration.getSecretKey();
	 }
	 public void setSecretKey(String secretKey) {
		 configuration.setSecretKey(secretKey);
	 }
	 public String getRegion() {
		 return configuration.getRegion();
	 }
	 public void setRegion(String region) {
		 configuration.setRegion(region);
	 }
}",1,0,0,0
"public class ScriptRuntime {
	 protected ScriptRuntime() {
	 }
	 private static class NoSuchMethodShim implements Callable {
		 String methodName;
		 Callable noSuchMethodMethod;
		 NoSuchMethodShim(Callable noSuchMethodMethod, String methodName) {
			 this.noSuchMethodMethod = noSuchMethodMethod;
			 this.methodName = methodName;
		 }
		 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
			 Object[] nestedArgs = new Object[2];
			 nestedArgs[0] = methodName;
			 nestedArgs[1] = newArrayLiteral(args, null, cx, scope);
			 return noSuchMethodMethod.call(cx, scope, thisObj, nestedArgs);
		 }
	 }
	 public final static Class BooleanClass = Kit.classOrNull(""java.lang.Boolean""), ByteClass = Kit.classOrNull(""java.lang.Byte""), CharacterClass = Kit.classOrNull(""java.lang.Character""), ClassClass = Kit.classOrNull(""java.lang.Class""), DoubleClass = Kit.classOrNull(""java.lang.Double""), FloatClass = Kit.classOrNull(""java.lang.Float""), IntegerClass = Kit.classOrNull(""java.lang.Integer""), LongClass = Kit.classOrNull(""java.lang.Long""), NumberClass = Kit.classOrNull(""java.lang.Number""), ObjectClass = Kit.classOrNull(""java.lang.Object""), ShortClass = Kit.classOrNull(""java.lang.Short""), StringClass = Kit.classOrNull(""java.lang.String""), DateClass = Kit.classOrNull(""java.util.Date"");
	 public final static Class ContextClass = Kit.classOrNull(""org.mozilla.javascript.Context""), ContextFactoryClass = Kit.classOrNull(""org.mozilla.javascript.ContextFactory""), FunctionClass = Kit.classOrNull(""org.mozilla.javascript.Function""), ScriptableClass = Kit.classOrNull(""org.mozilla.javascript.Scriptable""), ScriptableObjectClass = Kit.classOrNull(""org.mozilla.javascript.ScriptableObject"");
	 private static final String[] lazilyNames = {
	 ""RegExp"", ""org.mozilla.javascript.regexp.NativeRegExp"", ""Packages"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""java"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""getClass"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""JavaAdapter"", ""org.mozilla.javascript.JavaAdapter"", ""JavaImporter"", ""org.mozilla.javascript.ImporterTopLevel"", ""XML"", ""(xml)"", ""XMLList"", ""(xml)"", ""Namespace"", ""(xml)"", ""QName"", ""(xml)"", }
	;
	 private static final Object LIBRARY_SCOPE_KEY = new Object();
	 public static boolean isRhinoRuntimeType(Class cl) {
		 if (cl.isPrimitive()) {
			 return (cl != Character.TYPE);
		 }
		 else {
			 return (cl == StringClass || cl == BooleanClass || NumberClass.isAssignableFrom(cl) || ScriptableClass.isAssignableFrom(cl));
		 }
	 }
	 public static ScriptableObject initStandardObjects(Context cx, ScriptableObject scope, boolean sealed) {
		 if (scope == null) {
			 scope = new NativeObject();
		 }
		 scope.associateValue(LIBRARY_SCOPE_KEY, scope);
		 (new ClassCache()).associate(scope);
		 BaseFunction.init(scope, sealed);
		 NativeObject.init(scope, sealed);
		 Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
		 Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);
		 functionProto.setPrototype(objectProto);
		 if (scope.getPrototype() == null) scope.setPrototype(objectProto);
		 NativeError.init(scope, sealed);
		 NativeGlobal.init(cx, scope, sealed);
		 NativeArray.init(scope, sealed);
		 NativeString.init(scope, sealed);
		 NativeBoolean.init(scope, sealed);
		 NativeNumber.init(scope, sealed);
		 NativeDate.init(scope, sealed);
		 NativeMath.init(scope, sealed);
		 NativeWith.init(scope, sealed);
		 NativeCall.init(scope, sealed);
		 NativeScript.init(scope, sealed);
		 boolean withXml = cx.hasFeature(Context.FEATURE_E4X) && cx.getE4xImplementationFactory() != null;
		 for (int i = 0;
		 i != lazilyNames.length;
		 i += 2) {
			 String topProperty = lazilyNames[i];
			 String className = lazilyNames[i + 1];
			 if (!withXml && className.equals(""(xml)"")) {
				 continue;
			 }
			 else if (withXml && className.equals(""(xml)"")) {
				className = cx.getE4xImplementationFactory().getImplementationClassName();
			}
			 new LazilyLoadedCtor(scope, topProperty, className, sealed);
		 }
		 Continuation.init(scope, sealed);
		 return scope;
	 }
	 public static ScriptableObject getLibraryScopeOrNull(Scriptable scope) {
		 ScriptableObject libScope;
		 libScope = (ScriptableObject)ScriptableObject. getTopScopeValue(scope, LIBRARY_SCOPE_KEY);
		 return libScope;
	 }
	 public static boolean isJSLineTerminator(int c) {
		 if ((c & 0xDFD0) != 0) {
			 return false;
		 }
		 return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
	 }
	 public static Boolean wrapBoolean(boolean b) {
		 return b ? Boolean.TRUE : Boolean.FALSE;
	 }
	 public static Integer wrapInt(int i) {
		 return new Integer(i);
	 }
	 public static Number wrapNumber(double x) {
		 if (x != x) {
			 return ScriptRuntime.NaNobj;
		 }
		 return new Double(x);
	 }
	 public static boolean toBoolean(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue();
			 if (val == null || val == Undefined.instance) return false;
			 if (val instanceof String) return ((String) val).length() != 0;
			 if (val instanceof Number) {
				 double d = ((Number) val).doubleValue();
				 return (d == d && d != 0.0);
			 }
			 if (val instanceof Scriptable) {
				 if (Context.getContext().isVersionECMA1()) {
					 return true;
				 }
				 val = ((Scriptable) val).getDefaultValue(BooleanClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return true;
		 }
	 }
	 public static boolean toBoolean(Object[] args, int index) {
		 return (index < args.length) ? toBoolean(args[index]) : false;
	 }
	 public static double toNumber(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Number) return ((Number) val).doubleValue();
			 if (val == null) return +0.0;
			 if (val == Undefined.instance) return NaN;
			 if (val instanceof String) return toNumber((String) val);
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue() ? 1 : +0.0;
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(NumberClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return NaN;
		 }
	 }
	 public static double toNumber(Object[] args, int index) {
		 return (index < args.length) ? toNumber(args[index]) : NaN;
	 }
	 public static final double NaN = Double.longBitsToDouble(0x7ff8000000000000L);
	 public static final double negativeZero = Double.longBitsToDouble(0x8000000000000000L);
	 public static final Double NaNobj = new Double(NaN);
	 static double stringToNumber(String s, int start, int radix) {
		 char digitMax = '9';
		 char lowerCaseBound = 'a';
		 char upperCaseBound = 'A';
		 int len = s.length();
		 if (radix < 10) {
			 digitMax = (char) ('0' + radix - 1);
		 }
		 if (radix > 10) {
			 lowerCaseBound = (char) ('a' + radix - 10);
			 upperCaseBound = (char) ('A' + radix - 10);
		 }
		 int end;
		 double sum = 0.0;
		 for (end=start;
		 end < len;
		 end++) {
			 char c = s.charAt(end);
			 int newDigit;
			 if ('0' <= c && c <= digitMax) newDigit = c - '0';
			 else if ('a' <= c && c < lowerCaseBound) newDigit = c - 'a' + 10;
			 else if ('A' <= c && c < upperCaseBound) newDigit = c - 'A' + 10;
			 else break;
			 sum = sum*radix + newDigit;
		 }
		 if (start == end) {
			 return NaN;
		 }
		 if (sum >= 9007199254740992.0) {
			 if (radix == 10) {
				 try {
					 return Double.valueOf(s.substring(start, end)).doubleValue();
				 }
				 catch (NumberFormatException nfe) {
					 return NaN;
				 }
			 }
			 else if (radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32) {
				 int bitShiftInChar = 1;
				 int digit = 0;
				 final int SKIP_LEADING_ZEROS = 0;
				 final int FIRST_EXACT_53_BITS = 1;
				 final int AFTER_BIT_53 = 2;
				 final int ZEROS_AFTER_54 = 3;
				 final int MIXED_AFTER_54 = 4;
				 int state = SKIP_LEADING_ZEROS;
				 int exactBitsLimit = 53;
				 double factor = 0.0;
				 boolean bit53 = false;
				 boolean bit54 = false;
				 for (;
				;
				) {
					 if (bitShiftInChar == 1) {
						 if (start == end) break;
						 digit = s.charAt(start++);
						 if ('0' <= digit && digit <= '9') digit -= '0';
						 else if ('a' <= digit && digit <= 'z') digit -= 'a' - 10;
						 else digit -= 'A' - 10;
						 bitShiftInChar = radix;
					 }
					 bitShiftInChar >>= 1;
					 boolean bit = (digit & bitShiftInChar) != 0;
					 switch (state) {
						 case SKIP_LEADING_ZEROS: if (bit) {
							 --exactBitsLimit;
							 sum = 1.0;
							 state = FIRST_EXACT_53_BITS;
						 }
						 break;
						 case FIRST_EXACT_53_BITS: sum *= 2.0;
						 if (bit) sum += 1.0;
						 --exactBitsLimit;
						 if (exactBitsLimit == 0) {
							 bit53 = bit;
							 state = AFTER_BIT_53;
						 }
						 break;
						 case AFTER_BIT_53: bit54 = bit;
						 factor = 2.0;
						 state = ZEROS_AFTER_54;
						 break;
						 case ZEROS_AFTER_54: if (bit) {
							 state = MIXED_AFTER_54;
						 }
						 case MIXED_AFTER_54: factor *= 2;
						 break;
					 }
				 }
				 switch (state) {
					 case SKIP_LEADING_ZEROS: sum = 0.0;
					 break;
					 case FIRST_EXACT_53_BITS: case AFTER_BIT_53: break;
					 case ZEROS_AFTER_54: if (bit54 & bit53) sum += 1.0;
					 sum *= factor;
					 break;
					 case MIXED_AFTER_54: if (bit54) sum += 1.0;
					 sum *= factor;
					 break;
				 }
			 }
		 }
		 return sum;
	 }
	 public static double toNumber(String s) {
		 int len = s.length();
		 int start = 0;
		 char startChar;
		 for (;
		;
		) {
			 if (start == len) {
				 return +0.0;
			 }
			 startChar = s.charAt(start);
			 if (!Character.isWhitespace(startChar)) break;
			 start++;
		 }
		 if (startChar == '0') {
			 if (start + 2 < len) {
				 int c1 = s.charAt(start + 1);
				 if (c1 == 'x' || c1 == 'X') {
					 return stringToNumber(s, start + 2, 16);
				 }
			 }
		 }
		 else if (startChar == '+' || startChar == '-') {
			 if (start + 3 < len && s.charAt(start + 1) == '0') {
				 int c2 = s.charAt(start + 2);
				 if (c2 == 'x' || c2 == 'X') {
					 double val = stringToNumber(s, start + 3, 16);
					 return startChar == '-' ? -val : val;
				 }
			 }
		 }
		 int end = len - 1;
		 char endChar;
		 while (Character.isWhitespace(endChar = s.charAt(end))) end--;
		 if (endChar == 'y') {
			 if (startChar == '+' || startChar == '-') start++;
			 if (start + 7 == end && s.regionMatches(start, ""Infinity"", 0, 8)) return startChar == '-' ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
			 return NaN;
		 }
		 String sub = s.substring(start, end+1);
		 if (MSJVM_BUG_WORKAROUNDS) {
			 for (int i=sub.length()-1;
			 i >= 0;
			 i--) {
				 char c = sub.charAt(i);
				 if (('0' <= c && c <= '9') || c == '.' || c == 'e' || c == 'E' || c == '+' || c == '-') continue;
				 return NaN;
			 }
		 }
		 try {
			 return Double.valueOf(sub).doubleValue();
		 }
		 catch (NumberFormatException ex) {
			 return NaN;
		 }
	 }
	 public static Object[] padArguments(Object[] args, int count) {
		 if (count < args.length) return args;
		 int i;
		 Object[] result = new Object[count];
		 for (i = 0;
		 i < args.length;
		 i++) {
			 result[i] = args[i];
		 }
		 for (;
		 i < count;
		 i++) {
			 result[i] = Undefined.instance;
		 }
		 return result;
	 }
	 private final static boolean MSJVM_BUG_WORKAROUNDS = true;
	 public static String escapeString(String s) {
		 return escapeString(s, '""');
	 }
	 public static String escapeString(String s, char escapeQuote) {
		 if (!(escapeQuote == '""' || escapeQuote == '\'')) Kit.codeBug();
		 StringBuffer sb = null;
		 for(int i = 0, L = s.length();
		 i != L;
		 ++i) {
			 int c = s.charAt(i);
			 if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\') {
				 if (sb != null) {
					 sb.append((char)c);
				 }
				 continue;
			 }
			 if (sb == null) {
				 sb = new StringBuffer(L + 3);
				 sb.append(s);
				 sb.setLength(i);
			 }
			 int escape = -1;
			 switch (c) {
				 case '\b': escape = 'b';
				 break;
				 case '\f': escape = 'f';
				 break;
				 case '\n': escape = 'n';
				 break;
				 case '\r': escape = 'r';
				 break;
				 case '\t': escape = 't';
				 break;
				 case 0xb: escape = 'v';
				 break;
				 case ' ': escape = ' ';
				 break;
				 case '\\': escape = '\\';
				 break;
			 }
			 if (escape >= 0) {
				 sb.append('\\');
				 sb.append((char)escape);
			 }
			 else if (c == escapeQuote) {
				 sb.append('\\');
				 sb.append(escapeQuote);
			 }
			 else {
				 int hexSize;
				 if (c < 256) {
					 sb.append(""\\x"");
					 hexSize = 2;
				 }
				 else {
					 sb.append(""\\u"");
					 hexSize = 4;
				 }
				 for (int shift = (hexSize - 1) * 4;
				 shift >= 0;
				 shift -= 4) {
					 int digit = 0xf & (c >> shift);
					 int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
					 sb.append((char)hc);
				 }
			 }
		 }
		 return (sb == null) ? s : sb.toString();
	 }
	 static boolean isValidIdentifierName(String s) {
		 int L = s.length();
		 if (L == 0) return false;
		 if (!Character.isJavaIdentifierStart(s.charAt(0))) return false;
		 for (int i = 1;
		 i != L;
		 ++i) {
			 if (!Character.isJavaIdentifierPart(s.charAt(i))) return false;
		 }
		 return !TokenStream.isKeyword(s);
	 }
	 public static String toString(Object val) {
		 for (;
		;
		) {
			 if (val == null) {
				 return ""null"";
			 }
			 if (val == Undefined.instance) {
				 return ""undefined"";
			 }
			 if (val instanceof String) {
				 return (String)val;
			 }
			 if (val instanceof Number) {
				 return numberToString(((Number)val).doubleValue(), 10);
			 }
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(StringClass);
				 if (val instanceof Scriptable) {
					 throw errorWithClassName(""msg.primitive.expected"", val);
				 }
				 continue;
			 }
			 return val.toString();
		 }
	 }
	 static String defaultObjectToString(Scriptable obj) {
		 return ""[object "" + obj.getClassName() + ']';
	 }
	 public static String toString(Object[] args, int index) {
		 return (index < args.length) ? toString(args[index]) : ""undefined"";
	 }
	 public static String toString(double val) {
		 return numberToString(val, 10);
	 }
	 public static String numberToString(double d, int base) {
		 if (d != d) return ""NaN"";
		 if (d == Double.POSITIVE_INFINITY) return ""Infinity"";
		 if (d == Double.NEGATIVE_INFINITY) return ""-Infinity"";
		 if (d == 0.0) return ""0"";
		 if ((base < 2) || (base > 36)) {
			 throw Context.reportRuntimeError1( ""msg.bad.radix"", Integer.toString(base));
		 }
		 if (base != 10) {
			 return DToA.JS_dtobasestr(base, d);
		 }
		 else {
			 StringBuffer result = new StringBuffer();
			 DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);
			 return result.toString();
		 }
	 }
	 static String uneval(Context cx, Scriptable scope, Object value) {
		 if (value == null) {
			 return ""null"";
		 }
		 if (value == Undefined.instance) {
			 return ""undefined"";
		 }
		 if (value instanceof String) {
			 String escaped = escapeString((String)value);
			 StringBuffer sb = new StringBuffer(escaped.length() + 2);
			 sb.append('\""');
			 sb.append(escaped);
			 sb.append('\""');
			 return sb.toString();
		 }
		 if (value instanceof Number) {
			 double d = ((Number)value).doubleValue();
			 if (d == 0 && 1 / d < 0) {
				 return ""-0"";
			 }
			 return toString(d);
		 }
		 if (value instanceof Boolean) {
			 return toString(value);
		 }
		 if (value instanceof Scriptable) {
			 Scriptable obj = (Scriptable)value;
			 Object v = ScriptableObject.getProperty(obj, ""toSource"");
			 if (v instanceof Function) {
				 Function f = (Function)v;
				 return toString(f.call(cx, scope, obj, emptyArgs));
			 }
			 return toString(value);
		 }
		 warnAboutNonJSObject(value);
		 return value.toString();
	 }
	 static String defaultObjectToSource(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 StringBuffer result = new StringBuffer(128);
		 if (toplevel) {
			 result.append(""("");
		 }
		 result.append('{
			');
			 try {
				 if (!iterating) {
					 cx.iterating.intern(thisObj);
					 Object[] ids = thisObj.getIds();
					 for (int i=0;
					 i < ids.length;
					 i++) {
						 Object id = ids[i];
						 Object value;
						 if (id instanceof Integer) {
							 int intId = ((Integer)id).intValue();
							 value = thisObj.get(intId, thisObj);
							 if (value == Scriptable.NOT_FOUND) continue;
							 if (i > 0) result.append("", "");
							 result.append(intId);
						 }
						 else {
							 String strId = (String)id;
							 value = thisObj.get(strId, thisObj);
							 if (value == Scriptable.NOT_FOUND) continue;
							 if (i > 0) result.append("", "");
							 if (ScriptRuntime.isValidIdentifierName(strId)) {
								 result.append(strId);
							 }
							 else {
								 result.append('\'');
								 result.append( ScriptRuntime.escapeString(strId, '\''));
								 result.append('\'');
							 }
						 }
						 result.append(':');
						 result.append(ScriptRuntime.uneval(cx, scope, value));
					 }
				 }
			 }
			 finally {
				 if (toplevel) {
					 cx.iterating = null;
				 }
			 }
		 result.append('}
		');
		 if (toplevel) {
			 result.append(')');
		 }
		 return result.toString();
	 }
	 public static Scriptable toObject(Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObjectOrNull(Context cx, Object obj) {
		 if (obj instanceof Scriptable) {
			 return (Scriptable)obj;
		 }
		 else if (obj != null && obj != Undefined.instance) {
			 return toObject(cx, getTopCallScope(cx), obj);
		 }
		 return null;
	 }
	 public static Scriptable toObject(Scriptable scope, Object val, Class staticClass) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable) val;
		 }
		 if (val == null) {
			 throw typeError0(""msg.null.to.object"");
		 }
		 if (val == Undefined.instance) {
			 throw typeError0(""msg.undef.to.object"");
		 }
		 String className = val instanceof String ? ""String"" : val instanceof Number ? ""Number"" : val instanceof Boolean ? ""Boolean"" : null;
		 if (className != null) {
			 Object[] args = {
			 val }
			;
			 scope = ScriptableObject.getTopLevelScope(scope);
			 return newObject(cx, scope, className, args);
		 }
		 Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);
		 if (wrapped instanceof Scriptable) return (Scriptable) wrapped;
		 throw errorWithClassName(""msg.invalid.type"", val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val, Class staticClass) {
		 return toObject(cx, scope, val);
	 }
	 public static Object call(Context cx, Object fun, Object thisArg, Object[] args, Scriptable scope) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(toString(fun));
		 }
		 Function function = (Function)fun;
		 Scriptable thisObj = toObjectOrNull(cx, thisArg);
		 if (thisObj == null) {
			 throw undefCallError(thisObj, ""function"");
		 }
		 return function.call(cx, scope, thisObj, args);
	 }
	 public static Scriptable newObject(Context cx, Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = getExistingCtor(cx, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(cx, scope, args);
	 }
	 public static double toInteger(Object val) {
		 return toInteger(toNumber(val));
	 }
	 public static double toInteger(double d) {
		 if (d != d) return +0.0;
		 if (d == 0.0 || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) return d;
		 if (d > 0.0) return Math.floor(d);
		 else return Math.ceil(d);
	 }
	 public static double toInteger(Object[] args, int index) {
		 return (index < args.length) ? toInteger(args[index]) : +0.0;
	 }
	 public static int toInt32(Object val) {
		 if (val instanceof Integer) return ((Integer)val).intValue();
		 return toInt32(toNumber(val));
	 }
	 public static int toInt32(Object[] args, int index) {
		 return (index < args.length) ? toInt32(args[index]) : 0;
	 }
	 public static int toInt32(double d) {
		 int id = (int)d;
		 if (id == d) {
			 return id;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 d = Math.IEEEremainder(d, two32);
		 long l = (long)d;
		 return (int)l;
	 }
	 public static long toUint32(double d) {
		 long l = (long)d;
		 if (l == d) {
			 return l & 0xffffffffL;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 l = (long)Math.IEEEremainder(d, two32);
		 return l & 0xffffffffL;
	 }
	 public static long toUint32(Object val) {
		 return toUint32(toNumber(val));
	 }
	 public static char toUint16(Object val) {
		 double d = toNumber(val);
		 int i = (int)d;
		 if (i == d) {
			 return (char)i;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 int int16 = 0x10000;
		 i = (int)Math.IEEEremainder(d, int16);
		 return (char)i;
	 }
	 private static final String DEFAULT_NS_TAG = ""__default_namespace__"";
	 public static Object setDefaultNamespace(Object namespace, Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 XMLLib xmlLib = currentXMLLib(cx);
		 Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);
		 if (!scope.has(DEFAULT_NS_TAG, scope)) {
			 ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns, ScriptableObject.PERMANENT | ScriptableObject.DONTENUM);
		 }
		 else {
			 scope.put(DEFAULT_NS_TAG, scope, ns);
		 }
		 return Undefined.instance;
	 }
	 public static Object searchDefaultNamespace(Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 Object nsObject;
		 for (;
		;
		) {
			 Scriptable parent = scope.getParentScope();
			 if (parent == null) {
				 nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);
				 if (nsObject == Scriptable.NOT_FOUND) {
					 return null;
				 }
				 break;
			 }
			 nsObject = scope.get(DEFAULT_NS_TAG, scope);
			 if (nsObject != Scriptable.NOT_FOUND) {
				 break;
			 }
			 scope = parent;
		 }
		 return nsObject;
	 }
	 public static Object getTopLevelProp(Scriptable scope, String id) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 return ScriptableObject.getProperty(scope, id);
	 }
	 static Function getExistingCtor(Context cx, Scriptable scope, String constructorName) {
		 Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
		 if (ctorVal instanceof Function) {
			 return (Function)ctorVal;
		 }
		 if (ctorVal == Scriptable.NOT_FOUND) {
			 throw Context.reportRuntimeError1( ""msg.ctor.not.found"", constructorName);
		 }
		 else {
			 throw Context.reportRuntimeError1( ""msg.not.ctor"", constructorName);
		 }
	 }
	 private static long indexFromString(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (len > 0) {
			 int i = 0;
			 boolean negate = false;
			 int c = str.charAt(0);
			 if (c == '-') {
				 if (len > 1) {
					 c = str.charAt(1);
					 i = 1;
					 negate = true;
				 }
			 }
			 c -= '0';
			 if (0 <= c && c <= 9 && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH)) {
				 int index = -c;
				 int oldIndex = 0;
				 i++;
				 if (index != 0) {
					 while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9) {
						 oldIndex = index;
						 index = 10 * index - c;
						 i++;
					 }
				 }
				 if (i == len && (oldIndex > (Integer.MIN_VALUE / 10) || (oldIndex == (Integer.MIN_VALUE / 10) && c <= (negate ? -(Integer.MIN_VALUE % 10) : (Integer.MAX_VALUE % 10))))) {
					 return 0xFFFFFFFFL & (negate ? index : -index);
				 }
			 }
		 }
		 return -1L;
	 }
	 public static long testUint32String(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (1 <= len && len <= MAX_VALUE_LENGTH) {
			 int c = str.charAt(0);
			 c -= '0';
			 if (c == 0) {
				 return (len == 1) ? 0L : -1L;
			 }
			 if (1 <= c && c <= 9) {
				 long v = c;
				 for (int i = 1;
				 i != len;
				 ++i) {
					 c = str.charAt(i) - '0';
					 if (!(0 <= c && c <= 9)) {
						 return -1;
					 }
					 v = 10 * v + c;
				 }
				 if ((v >>> 32) == 0) {
					 return v;
				 }
			 }
		 }
		 return -1;
	 }
	 static Object getIndexObject(String s) {
		 long indexTest = indexFromString(s);
		 if (indexTest >= 0) {
			 return new Integer((int)indexTest);
		 }
		 return s;
	 }
	 static Object getIndexObject(double d) {
		 int i = (int)d;
		 if (i == d) {
			 return new Integer(i);
		 }
		 return toString(d);
	 }
	 static String toStringIdOrIndex(Context cx, Object id) {
		 if (id instanceof Number) {
			 double d = ((Number)id).doubleValue();
			 int index = (int)d;
			 if (index == d) {
				 storeIndexResult(cx, index);
				 return null;
			 }
			 return toString(id);
		 }
		 else {
			 String s;
			 if (id instanceof String) {
				 s = (String)id;
			 }
			 else {
				 s = toString(id);
			 }
			 long indexTest = indexFromString(s);
			 if (indexTest >= 0) {
				 storeIndexResult(cx, (int)indexTest);
				 return null;
			 }
			 return s;
		 }
	 }
	 public static Object getObjectElem(Object obj, Object elem, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, elem);
		 }
		 return getObjectElem(sobj, elem, cx);
	 }
	 public static Object getObjectElem(Scriptable obj, Object elem, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, elem);
		 }
		 Object result;
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = ScriptableObject.getProperty(obj, index);
		 }
		 else {
			 result = ScriptableObject.getProperty(obj, s);
		 }
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectProp(Object obj, String property, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, property);
		 }
		 return getObjectProp(sobj, property, cx);
	 }
	 public static Object getObjectProp(Scriptable obj, String property, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, property);
		 }
		 Object result = ScriptableObject.getProperty(obj, property);
		 if (result == Scriptable.NOT_FOUND) {
			 if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {
				 Context.reportWarning(ScriptRuntime.getMessage1( ""msg.ref.undefined.prop"", property));
			 }
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectIndex(Object obj, double dblIndex, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, toString(dblIndex));
		 }
		 int index = (int)dblIndex;
		 if (index == dblIndex) {
			 return getObjectIndex(sobj, index, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return getObjectProp(sobj, s, cx);
		 }
	 }
	 public static Object getObjectIndex(Scriptable obj, int index, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, new Integer(index));
		 }
		 Object result = ScriptableObject.getProperty(obj, index);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object setObjectElem(Object obj, Object elem, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, elem, value);
		 }
		 return setObjectElem(sobj, elem, value, cx);
	 }
	 public static Object setObjectElem(Scriptable obj, Object elem, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, elem, value);
			 return value;
		 }
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, s, value);
		 }
		 return value;
	 }
	 public static Object setObjectProp(Object obj, String property, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, property, value);
		 }
		 return setObjectProp(sobj, property, value, cx);
	 }
	 public static Object setObjectProp(Scriptable obj, String property, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, property, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, property, value);
		 }
		 return value;
	 }
	 public static Object setObjectIndex(Object obj, double dblIndex, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, String.valueOf(dblIndex), value);
		 }
		 int index = (int)dblIndex;
		 if (index == dblIndex) {
			 return setObjectIndex(sobj, index, value, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return setObjectProp(sobj, s, value, cx);
		 }
	 }
	 public static Object setObjectIndex(Scriptable obj, int index, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, new Integer(index), value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 return value;
	 }
	 public static boolean deleteObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaDelete(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.deleteProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.deleteProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static boolean hasObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaHas(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.hasProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.hasProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static Object refGet(Ref ref, Context cx) {
		 return ref.get(cx);
	 }
	 public static Object refSet(Ref ref, Object value, Context cx) {
		 return ref.set(cx, value);
	 }
	 public static Object refDel(Ref ref, Context cx) {
		 return wrapBoolean(ref.delete(cx));
	 }
	 static boolean isSpecialProperty(String s) {
		 return s.equals(""__proto__"") || s.equals(""__parent__"");
	 }
	 public static Ref specialRef(Object obj, String specialProperty, Context cx) {
		 return SpecialRef.createSpecial(cx, obj, specialProperty);
	 }
	 public static Object delete(Object obj, Object id, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 String idStr = (id == null) ? ""null"" : id.toString();
			 throw typeError2(""msg.undef.prop.delete"", toString(obj), idStr);
		 }
		 boolean result = deleteObjectElem(sobj, id, cx);
		 return wrapBoolean(result);
	 }
	 public static Object name(Context cx, Scriptable scope, String name) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (result == Scriptable.NOT_FOUND) {
				 throw notFoundError(scope, name);
			 }
			 return result;
		 }
		 return nameOrFunction(cx, scope, parent, name, false);
	 }
	 private static Object nameOrFunction(Context cx, Scriptable scope, Scriptable parentScope, String name, boolean asFunctionCall) {
		 Object result;
		 Scriptable thisObj = scope;
		 XMLObject firstXMLObject = null;
		 for (;
		;
		) {
			 if (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObj = (XMLObject)withObj;
					 if (xmlObj.ecmaHas(cx, name)) {
						 thisObj = xmlObj;
						 result = xmlObj.ecmaGet(cx, name);
						 break;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObj;
					 }
				 }
				 else {
					 result = ScriptableObject.getProperty(withObj, name);
					 if (result != Scriptable.NOT_FOUND) {
						 thisObj = withObj;
						 break;
					 }
				 }
			 }
			 else if (scope instanceof NativeCall) {
				 result = scope.get(name, scope);
				 if (result != Scriptable.NOT_FOUND) {
					 if (asFunctionCall) {
						 thisObj = ScriptableObject. getTopLevelScope(parentScope);
					 }
					 break;
				 }
			 }
			 else {
				 result = ScriptableObject.getProperty(scope, name);
				 if (result != Scriptable.NOT_FOUND) {
					 thisObj = scope;
					 break;
				 }
			 }
			 scope = parentScope;
			 parentScope = parentScope.getParentScope();
			 if (parentScope == null) {
				 result = topScopeName(cx, scope, name);
				 if (result == Scriptable.NOT_FOUND) {
					 if (firstXMLObject == null || asFunctionCall) {
						 throw notFoundError(scope, name);
					 }
					 result = firstXMLObject.ecmaGet(cx, name);
				 }
				 thisObj = scope;
				 break;
			 }
		 }
		 if (asFunctionCall) {
			 if (!(result instanceof Callable)) {
				 throw notFunctionError(result, name);
			 }
			 storeScriptable(cx, thisObj);
		 }
		 return result;
	 }
	 private static Object topScopeName(Context cx, Scriptable scope, String name) {
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 return ScriptableObject.getProperty(scope, name);
	 }
	 public static Scriptable bind(Context cx, Scriptable scope, String id) {
		 Scriptable firstXMLObject = null;
		 Scriptable parent = scope.getParentScope();
		 childScopesChecks: if (parent != null) {
			 while (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObject = (XMLObject)withObj;
					 if (xmlObject.ecmaHas(cx, id)) {
						 return xmlObject;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObject;
					 }
				 }
				 else {
					 if (ScriptableObject.hasProperty(withObj, id)) {
						 return withObj;
					 }
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
			 for (;
			;
			) {
				 if (ScriptableObject.hasProperty(scope, id)) {
					 return scope;
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
		 }
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 if (ScriptableObject.hasProperty(scope, id)) {
			 return scope;
		 }
		 return firstXMLObject;
	 }
	 public static Object setName(Scriptable bound, Object value, Context cx, Scriptable scope, String id) {
		 if (bound != null) {
			 if (bound instanceof XMLObject) {
				 XMLObject xmlObject = (XMLObject)bound;
				 xmlObject.ecmaPut(cx, id, value);
			 }
			 else {
				 ScriptableObject.putProperty(bound, id, value);
			 }
		 }
		 else {
			 if (cx.hasFeature(Context.FEATURE_STRICT_MODE) || cx.hasFeature(Context.FEATURE_STRICT_VARS)) {
				 Context.reportWarning( ScriptRuntime.getMessage1(""msg.assn.create.strict"", id));
			 }
			 bound = ScriptableObject.getTopLevelScope(scope);
			 if (cx.useDynamicScope) {
				 bound = checkDynamicScope(cx.topCallScope, bound);
			 }
			 bound.put(id, bound, value);
		 }
		 return value;
	 }
	 public static Object setConst(Scriptable bound, Object value, Context cx, String id) {
		 if (bound instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)bound;
			 xmlObject.ecmaPut(cx, id, value);
		 }
		 else {
			 ScriptableObject.putConstProperty(bound, id, value);
		 }
		 return value;
	 }
	 private static class IdEnumeration {
		 Scriptable obj;
		 Object[] ids;
		 int index;
		 ObjToIntMap used;
		 String currentId;
		 boolean enumValues;
	 }
	 public static Object enumInit(Object value, Context cx, boolean enumValues) {
		 IdEnumeration x = new IdEnumeration();
		 x.obj = toObjectOrNull(cx, value);
		 if (x.obj != null) {
			 x.enumValues = enumValues;
			 enumChangeObject(x);
		 }
		 return x;
	 }
	 public static Boolean enumNext(Object enumObj) {
		 boolean result;
		 IdEnumeration x = (IdEnumeration)enumObj;
		 for (;
		;
		) {
			 if (x.obj == null) {
				 result = false;
				 break;
			 }
			 if (x.index == x.ids.length) {
				 x.obj = x.obj.getPrototype();
				 enumChangeObject(x);
				 continue;
			 }
			 Object id = x.ids[x.index++];
			 if (x.used != null && x.used.has(id)) {
				 continue;
			 }
			 if (id instanceof String) {
				 String strId = (String)id;
				 if (!x.obj.has(strId, x.obj)) continue;
				 x.currentId = strId;
			 }
			 else {
				 int intId = ((Number)id).intValue();
				 if (!x.obj.has(intId, x.obj)) continue;
				 x.currentId = String.valueOf(intId);
			 }
			 result = true;
			 break;
		 }
		 return wrapBoolean(result);
	 }
	 public static Object enumId(Object enumObj, Context cx) {
		 IdEnumeration x = (IdEnumeration)enumObj;
		 if (!x.enumValues) return x.currentId;
		 Object result;
		 String s = toStringIdOrIndex(cx, x.currentId);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = x.obj.get(index, x.obj);
		 }
		 else {
			 result = x.obj.get(s, x.obj);
		 }
		 return result;
	 }
	 private static void enumChangeObject(IdEnumeration x) {
		 Object[] ids = null;
		 while (x.obj != null) {
			 ids = x.obj.getIds();
			 if (ids.length != 0) {
				 break;
			 }
			 x.obj = x.obj.getPrototype();
		 }
		 if (x.obj != null && x.ids != null) {
			 Object[] previous = x.ids;
			 int L = previous.length;
			 if (x.used == null) {
				 x.used = new ObjToIntMap(L);
			 }
			 for (int i = 0;
			 i != L;
			 ++i) {
				 x.used.intern(previous[i]);
			 }
		 }
		 x.ids = ids;
		 x.index = 0;
	 }
	 public static Callable getNameFunctionAndThis(String name, Context cx, Scriptable scope) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (!(result instanceof Callable)) {
				 if (result == Scriptable.NOT_FOUND) {
					 throw notFoundError(scope, name);
				 }
				 else {
					 throw notFunctionError(result, name);
				 }
			 }
			 Scriptable thisObj = scope;
			 storeScriptable(cx, thisObj);
			 return (Callable)result;
		 }
		 return (Callable)nameOrFunction(cx, scope, parent, name, true);
	 }
	 public static Callable getElemFunctionAndThis(Object obj, Object elem, Context cx) {
		 String s = toStringIdOrIndex(cx, elem);
		 if (s != null) {
			 return getPropFunctionAndThis(obj, s, cx);
		 }
		 int index = lastIndexResult(cx);
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, String.valueOf(index));
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, index);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, elem);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getPropFunctionAndThis(Object obj, String property, Context cx) {
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, property);
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, property);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 Object noSuchMethod = ScriptableObject.getProperty(thisObj, ""__noSuchMethod__"");
			 if (noSuchMethod instanceof Callable) value = new NoSuchMethodShim((Callable)noSuchMethod, property);
			 else throw notFunctionError(value, property);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getValueFunctionAndThis(Object value, Context cx) {
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value);
		 }
		 Callable f = (Callable)value;
		 Scriptable thisObj = null;
		 if (f instanceof Scriptable) {
			 thisObj = ((Scriptable)f).getParentScope();
		 }
		 if (thisObj == null) {
			 if (cx.topCallScope == null) throw new IllegalStateException();
			 thisObj = cx.topCallScope;
		 }
		 if (thisObj.getParentScope() != null) {
			 if (thisObj instanceof NativeWith) {
			 }
			 else if (thisObj instanceof NativeCall) {
				 thisObj = ScriptableObject.getTopLevelScope(thisObj);
			 }
		 }
		 storeScriptable(cx, thisObj);
		 return f;
	 }
	 public static Ref callRef(Callable function, Scriptable thisObj, Object[] args, Context cx) {
		 if (function instanceof RefCallable) {
			 RefCallable rfunction = (RefCallable)function;
			 Ref ref = rfunction.refCall(cx, thisObj, args);
			 if (ref == null) {
				 throw new IllegalStateException(rfunction.getClass().getName()+"".refCall() returned null"");
			 }
			 return ref;
		 }
		 String msg = getMessage1(""msg.no.ref.from.function"", toString(function));
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static Scriptable newObject(Object fun, Context cx, Scriptable scope, Object[] args) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(fun);
		 }
		 Function function = (Function)fun;
		 return function.construct(cx, scope, args);
	 }
	 public static Object callSpecial(Context cx, Callable fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String filename, int lineNumber) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 return evalSpecial(cx, scope, callerThis, args, filename, lineNumber);
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 throw Context.reportRuntimeError1(""msg.only.from.new"", ""With"");
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return fun.call(cx, scope, thisObj, args);
	 }
	 public static Object newSpecial(Context cx, Object fun, Object[] args, Scriptable scope, int callType) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 throw typeError1(""msg.not.ctor"", ""eval"");
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 return NativeWith.newWithSpecial(cx, scope, args);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return newObject(fun, cx, scope, args);
	 }
	 public static Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 int L = args.length;
		 Callable function;
		 if (thisObj instanceof Callable) {
			 function = (Callable)thisObj;
		 }
		 else {
			 Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);
			 if (!(value instanceof Callable)) {
				 throw ScriptRuntime.notFunctionError(value, thisObj);
			 }
			 function = (Callable)value;
		 }
		 Scriptable callThis = null;
		 if (L != 0) {
			 callThis = toObjectOrNull(cx, args[0]);
		 }
		 if (callThis == null) {
			 callThis = getTopCallScope(cx);
		 }
		 Object[] callArgs;
		 if (isApply) {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 Object arg1 = args[1];
				 if (arg1 == null || arg1 == Undefined.instance) {
					 callArgs = ScriptRuntime.emptyArgs;
				 }
				 else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {
					 callArgs = cx.getElements((Scriptable) arg1);
				 }
				 else {
					 throw ScriptRuntime.typeError0(""msg.arg.isnt.array"");
				 }
			 }
		 }
		 else {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 callArgs = new Object[L - 1];
				 System.arraycopy(args, 1, callArgs, 0, L - 1);
			 }
		 }
		 return function.call(cx, scope, callThis, callArgs);
	 }
	 public static Object evalSpecial(Context cx, Scriptable scope, Object thisArg, Object[] args, String filename, int lineNumber) {
		 if (args.length < 1) return Undefined.instance;
		 Object x = args[0];
		 if (!(x instanceof String)) {
			 if (cx.hasFeature(Context.FEATURE_STRICT_MODE) || cx.hasFeature(Context.FEATURE_STRICT_EVAL)) {
				 throw Context.reportRuntimeError0(""msg.eval.nonstring.strict"");
			 }
			 String message = ScriptRuntime.getMessage0(""msg.eval.nonstring"");
			 Context.reportWarning(message);
			 return x;
		 }
		 if (filename == null) {
			 int[] linep = new int[1];
			 filename = Context.getSourcePositionFromStack(linep);
			 if (filename != null) {
				 lineNumber = linep[0];
			 }
			 else {
				 filename = """";
			 }
		 }
		 String sourceName = ScriptRuntime. makeUrlForGeneratedScript(true, filename, lineNumber);
		 ErrorReporter reporter;
		 reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());
		 Script script = cx.compileString((String)x, new Interpreter(), reporter, sourceName, 1, null);
		 ((InterpretedFunction)script).idata.evalScriptFlag = true;
		 Callable c = (Callable)script;
		 return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);
	 }
	 public static String typeof(Object value) {
		 if (value == null) return ""object"";
		 if (value == Undefined.instance) return ""undefined"";
		 if (value instanceof Scriptable) {
			 if (value instanceof XMLObject) return ""xml"";
			 return (value instanceof Callable) ? ""function"" : ""object"";
		 }
		 if (value instanceof String) return ""string"";
		 if (value instanceof Number) return ""number"";
		 if (value instanceof Boolean) return ""boolean"";
		 throw errorWithClassName(""msg.invalid.type"", value);
	 }
	 public static String typeofName(Scriptable scope, String id) {
		 Context cx = Context.getContext();
		 Scriptable val = bind(cx, scope, id);
		 if (val == null) return ""undefined"";
		 return typeof(getObjectProp(val, id, cx));
	 }
	 public static Object add(Object val1, Object val2, Context cx) {
		 if(val1 instanceof Number && val2 instanceof Number) {
			 return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 }
		 if (val1 instanceof XMLObject) {
			 Object test = ((XMLObject)val1).addValues(cx, true, val2);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val2 instanceof XMLObject) {
			 Object test = ((XMLObject)val2).addValues(cx, false, val1);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(null);
		 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(null);
		 if (!(val1 instanceof String) && !(val2 instanceof String)) if ((val1 instanceof Number) && (val2 instanceof Number)) return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 else return wrapNumber(toNumber(val1) + toNumber(val2));
		 return toString(val1).concat(toString(val2));
	 }
	 public static Object nameIncrDecr(Scriptable scopeChain, String id, int incrDecrMask) {
		 return nameIncrDecr(scopeChain, id, Context.getContext(), incrDecrMask);
	 }
	 public static Object nameIncrDecr(Scriptable scopeChain, String id, Context cx, int incrDecrMask) {
		 Scriptable target;
		 Object value;
		 search: {
			 do {
				 if (cx.useDynamicScope && scopeChain.getParentScope() == null) {
					 scopeChain = checkDynamicScope(cx.topCallScope, scopeChain);
				 }
				 target = scopeChain;
				 do {
					 value = target.get(id, scopeChain);
					 if (value != Scriptable.NOT_FOUND) {
						 break search;
					 }
					 target = target.getPrototype();
				 }
				 while (target != null);
				 scopeChain = scopeChain.getParentScope();
			 }
			 while (scopeChain != null);
			 throw notFoundError(scopeChain, id);
		 }
		 return doScriptableIncrDecr(target, id, scopeChain, value, incrDecrMask);
	 }
	 public static Object propIncrDecr(Object obj, String id, Context cx, int incrDecrMask) {
		 Scriptable start = toObjectOrNull(cx, obj);
		 if (start == null) {
			 throw undefReadError(obj, id);
		 }
		 Scriptable target = start;
		 Object value;
		 search: {
			 do {
				 value = target.get(id, start);
				 if (value != Scriptable.NOT_FOUND) {
					 break search;
				 }
				 target = target.getPrototype();
			 }
			 while (target != null);
			 start.put(id, start, NaNobj);
			 return NaNobj;
		 }
		 return doScriptableIncrDecr(target, id, start, value, incrDecrMask);
	 }
	 private static Object doScriptableIncrDecr(Scriptable target, String id, Scriptable protoChainStart, Object value, int incrDecrMask) {
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 target.put(id, protoChainStart, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object elemIncrDecr(Object obj, Object index, Context cx, int incrDecrMask) {
		 Object value = getObjectElem(obj, index, cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 setObjectElem(obj, index, result, cx);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask) {
		 Object value = ref.get(cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 ref.set(cx, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 private static Object toPrimitive(Object val) {
		 if (!(val instanceof Scriptable)) {
			 return val;
		 }
		 Scriptable s = (Scriptable)val;
		 Object result = s.getDefaultValue(null);
		 if (result instanceof Scriptable) throw typeError0(""msg.bad.default.value"");
		 return result;
	 }
	 public static boolean eq(Object x, Object y) {
		 if (x == null || x == Undefined.instance) {
			 if (y == null || y == Undefined.instance) {
				 return true;
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return false;
		 }
		 else if (x instanceof Number) {
			 return eqNumber(((Number)x).doubleValue(), y);
		 }
		 else if (x instanceof String) {
			 return eqString((String)x, y);
		 }
		 else if (x instanceof Boolean) {
			 boolean b = ((Boolean)x).booleanValue();
			 if (y instanceof Boolean) {
				 return b == ((Boolean)y).booleanValue();
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return eqNumber(b ? 1.0 : 0.0, y);
		 }
		 else if (x instanceof Scriptable) {
			 if (y instanceof Scriptable) {
				 if (x == y) {
					 return true;
				 }
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (x instanceof Wrapper && y instanceof Wrapper) {
					 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
				 }
				 return false;
			 }
			 else if (y instanceof Boolean) {
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;
				 return eqNumber(d, x);
			 }
			 else if (y instanceof Number) {
				 return eqNumber(((Number)y).doubleValue(), x);
			 }
			 else if (y instanceof String) {
				 return eqString((String)y, x);
			 }
			 return false;
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
	 }
	 static boolean eqNumber(double x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof Number) {
				 return x == ((Number)y).doubleValue();
			 }
			 else if (y instanceof String) {
				 return x == toNumber(y);
			 }
			 else if (y instanceof Boolean) {
				 return x == (((Boolean)y).booleanValue() ? 1.0 : +0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object xval = wrapNumber(x);
					 Object test = ((ScriptableObject)y).equivalentValues(xval);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 private static boolean eqString(String x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof String) {
				 return x.equals(y);
			 }
			 else if (y instanceof Number) {
				 return toNumber(x) == ((Number)y).doubleValue();
			 }
			 else if (y instanceof Boolean) {
				 return toNumber(x) == (((Boolean)y).booleanValue() ? 1.0 : 0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
				 continue;
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 public static boolean shallowEq(Object x, Object y) {
		 if (x == y) {
			 if (!(x instanceof Number)) {
				 return true;
			 }
			 double d = ((Number)x).doubleValue();
			 return d == d;
		 }
		 if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 if (y instanceof Number) {
				 return ((Number)x).doubleValue() == ((Number)y).doubleValue();
			 }
		 }
		 else if (x instanceof String) {
			 if (y instanceof String) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Boolean) {
			 if (y instanceof Boolean) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Scriptable) {
			 if (x instanceof Wrapper && y instanceof Wrapper) {
				 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
			 }
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
		 return false;
	 }
	 public static boolean instanceOf(Object a, Object b, Context cx) {
		 if (! (b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 if (! (a instanceof Scriptable)) return false;
		 return ((Scriptable)b).hasInstance((Scriptable)a);
	 }
	 public static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
		 Scriptable proto = lhs.getPrototype();
		 while (proto != null) {
			 if (proto.equals(rhs)) return true;
			 proto = proto.getPrototype();
		 }
		 return false;
	 }
	 public static boolean in(Object a, Object b, Context cx) {
		 if (!(b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 return hasObjectElem((Scriptable)b, a, cx);
	 }
	 public static boolean cmp_LT(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) < 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 < d2;
	 }
	 public static boolean cmp_LE(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) <= 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 <= d2;
	 }
	 public static ScriptableObject getGlobal(Context cx) {
		 final String GLOBAL_CLASS = ""org.mozilla.javascript.tools.shell.Global"";
		 Class globalClass = Kit.classOrNull(GLOBAL_CLASS);
		 if (globalClass != null) {
			 try {
				 Class[] parm = {
				 ScriptRuntime.ContextClass }
				;
				 Constructor globalClassCtor = globalClass.getConstructor(parm);
				 Object[] arg = {
				 cx }
				;
				 return (ScriptableObject) globalClassCtor.newInstance(arg);
			 }
			 catch (Exception e) {
			 }
		 }
		 return new ImporterTopLevel(cx);
	 }
	 public static boolean hasTopCall(Context cx) {
		 return (cx.topCallScope != null);
	 }
	 public static Scriptable getTopCallScope(Context cx) {
		 Scriptable scope = cx.topCallScope;
		 if (scope == null) {
			 throw new IllegalStateException();
		 }
		 return scope;
	 }
	 public static Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (scope == null) throw new IllegalArgumentException();
		 if (cx.topCallScope != null) throw new IllegalStateException();
		 Object result;
		 cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
		 cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
		 ContextFactory f = cx.getFactory();
		 try {
			 result = f.doTopCall(callable, cx, scope, thisObj, args);
		 }
		 finally {
			 cx.topCallScope = null;
			 cx.cachedXMLLib = null;
			 if (cx.currentActivationCall != null) {
				 throw new IllegalStateException();
			 }
		 }
		 return result;
	 }
	 static Scriptable checkDynamicScope(Scriptable possibleDynamicScope, Scriptable staticTopScope) {
		 if (possibleDynamicScope == staticTopScope) {
			 return possibleDynamicScope;
		 }
		 Scriptable proto = possibleDynamicScope;
		 for (;
		;
		) {
			 proto = proto.getPrototype();
			 if (proto == staticTopScope) {
				 return possibleDynamicScope;
			 }
			 if (proto == null) {
				 return staticTopScope;
			 }
		 }
	 }
	 public static void initScript(NativeFunction funObj, Scriptable thisObj, Context cx, Scriptable scope, boolean evalScript) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 int varCount = funObj.getParamAndVarCount();
		 if (varCount != 0) {
			 Scriptable varScope = scope;
			 while (varScope instanceof NativeWith) {
				 varScope = varScope.getParentScope();
			 }
			 for (int i = varCount;
			 i-- != 0;
			) {
				 String name = funObj.getParamOrVarName(i);
				 boolean isConst = funObj.getParamOrVarConst(i);
				 if (!ScriptableObject.hasProperty(scope, name)) {
					 if (!evalScript) {
						 if (isConst) ScriptableObject.defineConstProperty(varScope, name);
						 else ScriptableObject.defineProperty( varScope, name, Undefined.instance, ScriptableObject.PERMANENT);
					 }
					 else {
						 varScope.put(name, varScope, Undefined.instance);
					 }
				 }
				 else {
					 ScriptableObject.redefineProperty(scope, name, isConst);
				 }
			 }
		 }
	 }
	 public static Scriptable createFunctionActivation(NativeFunction funObj, Scriptable scope, Object[] args) {
		 return new NativeCall(funObj, scope, args);
	 }
	 public static void enterActivationFunction(Context cx, Scriptable scope) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 NativeCall call = (NativeCall)scope;
		 call.parentActivationCall = cx.currentActivationCall;
		 cx.currentActivationCall = call;
	 }
	 public static void exitActivationFunction(Context cx) {
		 NativeCall call = cx.currentActivationCall;
		 cx.currentActivationCall = call.parentActivationCall;
		 call.parentActivationCall = null;
	 }
	 static NativeCall findFunctionActivation(Context cx, Function f) {
		 NativeCall call = cx.currentActivationCall;
		 while (call != null) {
			 if (call.function == f) return call;
			 call = call.parentActivationCall;
		 }
		 return null;
	 }
	 public static Scriptable newCatchScope(Throwable t, Scriptable lastCatchScope, String exceptionName, Context cx, Scriptable scope) {
		 Object obj;
		 boolean cacheObj;
		 getObj: if (t instanceof JavaScriptException) {
			 cacheObj = false;
			 obj = ((JavaScriptException)t).getValue();
		 }
		 else {
			 cacheObj = true;
			 if (lastCatchScope != null) {
				 NativeObject last = (NativeObject)lastCatchScope;
				 obj = last.getAssociatedValue(t);
				 if (obj == null) Kit.codeBug();
				 break getObj;
			 }
			 RhinoException re;
			 String errorName;
			 String errorMsg;
			 Throwable javaException = null;
			 if (t instanceof EcmaError) {
				 EcmaError ee = (EcmaError)t;
				 re = ee;
				 errorName = ee.getName();
				 errorMsg = ee.getErrorMessage();
			 }
			 else if (t instanceof WrappedException) {
				 WrappedException we = (WrappedException)t;
				 re = we;
				 javaException = we.getWrappedException();
				 errorName = ""JavaException"";
				 errorMsg = javaException.getClass().getName() +"": ""+javaException.getMessage();
			 }
			 else if (t instanceof EvaluatorException) {
				 EvaluatorException ee = (EvaluatorException)t;
				 re = ee;
				 errorName = ""InternalError"";
				 errorMsg = ee.getMessage();
			 }
			 else {
				 throw Kit.codeBug();
			 }
			 String sourceUri = re.sourceName();
			 if (sourceUri == null) {
				 sourceUri = """";
			 }
			 int line = re.lineNumber();
			 Object args[];
			 if (line > 0) {
				 args = new Object[] {
				 errorMsg, sourceUri, new Integer(line) }
				;
			 }
			 else {
				 args = new Object[] {
				 errorMsg, sourceUri }
				;
			 }
			 Scriptable errorObject = cx.newObject(scope, errorName, args);
			 ScriptableObject.putProperty(errorObject, ""name"", errorName);
			 if (javaException != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException, null);
				 ScriptableObject.defineProperty( errorObject, ""javaException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);
			 ScriptableObject.defineProperty( errorObject, ""rhinoException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 obj = errorObject;
		 }
		 NativeObject catchScopeObject = new NativeObject();
		 catchScopeObject.defineProperty( exceptionName, obj, ScriptableObject.PERMANENT);
		 catchScopeObject.defineProperty( ""__exception__"", Context.javaToJS(t, catchScopeObject), ScriptableObject.PERMANENT|ScriptableObject.DONTENUM);
		 if (cacheObj) {
			 catchScopeObject.associateValue(t, obj);
		 }
		 return catchScopeObject;
	 }
	 public static Scriptable enterWith(Object obj, Context cx, Scriptable scope) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw typeError1(""msg.undef.with"", toString(obj));
		 }
		 if (sobj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)sobj;
			 return xmlObject.enterWith(scope);
		 }
		 return new NativeWith(scope, sobj);
	 }
	 public static Scriptable leaveWith(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static Scriptable enterDotQuery(Object value, Scriptable scope) {
		 if (!(value instanceof XMLObject)) {
			 throw notXmlError(value);
		 }
		 XMLObject object = (XMLObject)value;
		 return object.enterDotQuery(scope);
	 }
	 public static Object updateDotQuery(boolean value, Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.updateDotQuery(value);
	 }
	 public static Scriptable leaveDotQuery(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static void setFunctionProtoAndParent(BaseFunction fn, Scriptable scope) {
		 fn.setParentScope(scope);
		 fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
	 }
	 public static void setObjectProtoAndParent(ScriptableObject object, Scriptable scope) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 object.setParentScope(scope);
		 Scriptable proto = ScriptableObject.getClassPrototype(scope, object.getClassName());
		 object.setPrototype(proto);
	 }
	 public static void initFunction(Context cx, Scriptable scope, NativeFunction function, int type, boolean fromEvalCode) {
		 if (type == FunctionNode.FUNCTION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 if (!fromEvalCode) {
					 ScriptableObject.defineProperty (scope, name, function, ScriptableObject.PERMANENT);
				 }
				 else {
					 scope.put(name, scope, function);
				 }
			 }
		 }
		 else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 while (scope instanceof NativeWith) {
					 scope = scope.getParentScope();
				 }
				 scope.put(name, scope, function);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
	 }
	 public static Scriptable newArrayLiteral(Object[] objects, int[] skipIndexces, Context cx, Scriptable scope) {
		 int count = objects.length;
		 int skipCount = 0;
		 if (skipIndexces != null) {
			 skipCount = skipIndexces.length;
		 }
		 int length = count + skipCount;
		 Integer lengthObj = new Integer(length);
		 Scriptable arrayObj;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 arrayObj = cx.newObject(scope, ""Array"", ScriptRuntime.emptyArgs);
			 ScriptableObject.putProperty(arrayObj, ""length"", lengthObj);
		 }
		 else {
			 arrayObj = cx.newObject(scope, ""Array"", new Object[] {
			 lengthObj }
			);
		 }
		 int skip = 0;
		 for (int i = 0, j = 0;
		 i != length;
		 ++i) {
			 if (skip != skipCount && skipIndexces[skip] == i) {
				 ++skip;
				 continue;
			 }
			 ScriptableObject.putProperty(arrayObj, i, objects[j]);
			 ++j;
		 }
		 return arrayObj;
	 }
	 public static Scriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, Context cx, Scriptable scope) {
		 int [] getterSetters = new int[propertyIds.length];
		 return newObjectLiteral(propertyIds, propertyValues, getterSetters, cx, scope);
	 }
	 public static Scriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, int [] getterSetters, Context cx, Scriptable scope) {
		 Scriptable object = cx.newObject(scope);
		 for (int i = 0, end = propertyIds.length;
		 i != end;
		 ++i) {
			 Object id = propertyIds[i];
			 int getterSetter = getterSetters[i];
			 Object value = propertyValues[i];
			 if (id instanceof String) {
				 if (getterSetter == 0) ScriptableObject.putProperty(object, (String)id, value);
				 else {
					 Callable fun;
					 String definer;
					 if (getterSetter < 0) definer = ""__defineGetter__"";
					 else definer = ""__defineSetter__"";
					 fun = getPropFunctionAndThis(object, definer, cx);
					 lastStoredScriptable(cx);
					 Object[] outArgs = new Object[2];
					 outArgs[0] = id;
					 outArgs[1] = value;
					 fun.call(cx, scope, object, outArgs);
				 }
			 }
			 else {
				 int index = ((Integer)id).intValue();
				 ScriptableObject.putProperty(object, index, value);
			 }
		 }
		 return object;
	 }
	 public static boolean isArrayObject(Object obj) {
		 return obj instanceof NativeArray || obj instanceof Arguments;
	 }
	 public static Object[] getArrayElements(Scriptable object) {
		 Context cx = Context.getContext();
		 long longLen = NativeArray.getLengthProperty(cx, object);
		 if (longLen > Integer.MAX_VALUE) {
			 throw new IllegalArgumentException();
		 }
		 int len = (int) longLen;
		 if (len == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 else {
			 Object[] result = new Object[len];
			 for (int i=0;
			 i < len;
			 i++) {
				 Object elem = ScriptableObject.getProperty(object, i);
				 result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance : elem;
			 }
			 return result;
		 }
	 }
	 static void checkDeprecated(Context cx, String name) {
		 int version = cx.getLanguageVersion();
		 if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
			 String msg = getMessage1(""msg.deprec.ctor"", name);
			 if (version == Context.VERSION_DEFAULT) Context.reportWarning(msg);
			 else throw Context.reportRuntimeError(msg);
		 }
	 }
	 public static String getMessage0(String messageId) {
		 return getMessage(messageId, null);
	 }
	 public static String getMessage1(String messageId, Object arg1) {
		 Object[] arguments = {
		arg1}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage2( String messageId, Object arg1, Object arg2) {
		 Object[] arguments = {
		arg1, arg2}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage3( String messageId, Object arg1, Object arg2, Object arg3) {
		 Object[] arguments = {
		arg1, arg2, arg3}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage4( String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 Object[] arguments = {
		arg1, arg2, arg3, arg4}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage(String messageId, Object[] arguments) {
		 final String defaultResource = ""org.mozilla.javascript.resources.Messages"";
		 Context cx = Context.getCurrentContext();
		 Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();
		 ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);
		 String formatString;
		 try {
			 formatString = rb.getString(messageId);
		 }
		 catch (java.util.MissingResourceException mre) {
			 throw new RuntimeException (""no message resource found for message property ""+ messageId);
		 }
		 MessageFormat formatter = new MessageFormat(formatString);
		 return formatter.format(arguments);
	 }
	 public static EcmaError constructError(String error, String message) {
		 int[] linep = new int[1];
		 String filename = Context.getSourcePositionFromStack(linep);
		 return constructError(error, message, filename, linep[0], null, 0);
	 }
	 public static EcmaError constructError(String error, String message, String sourceName, int lineNumber, String lineSource, int columnNumber) {
		 return new EcmaError(error, message, sourceName, lineNumber, lineSource, columnNumber);
	 }
	 public static EcmaError typeError(String message) {
		 return constructError(""TypeError"", message);
	 }
	 public static EcmaError typeError0(String messageId) {
		 String msg = getMessage0(messageId);
		 return typeError(msg);
	 }
	 public static EcmaError typeError1(String messageId, String arg1) {
		 String msg = getMessage1(messageId, arg1);
		 return typeError(msg);
	 }
	 public static EcmaError typeError2(String messageId, String arg1, String arg2) {
		 String msg = getMessage2(messageId, arg1, arg2);
		 return typeError(msg);
	 }
	 public static EcmaError typeError3(String messageId, String arg1, String arg2, String arg3) {
		 String msg = getMessage3(messageId, arg1, arg2, arg3);
		 return typeError(msg);
	 }
	 public static RuntimeException undefReadError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.prop.read"", toString(object), idStr);
	 }
	 public static RuntimeException undefCallError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.method.call"", toString(object), idStr);
	 }
	 public static RuntimeException undefWriteError(Object object, Object id, Object value) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 String valueStr = (value instanceof Scriptable) ? value.toString() : toString(value);
		 return typeError3(""msg.undef.prop.write"", toString(object), idStr, valueStr);
	 }
	 public static RuntimeException notFoundError(Scriptable object, String property) {
		 String msg = getMessage1(""msg.is.not.defined"", property);
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static RuntimeException notFunctionError(Object value) {
		 return notFunctionError(value, value);
	 }
	 public static RuntimeException notFunctionError(Object value, Object messageHelper) {
		 String msg = (messageHelper == null) ? ""null"" : messageHelper.toString();
		 if (value == Scriptable.NOT_FOUND) {
			 return typeError1(""msg.function.not.found"", msg);
		 }
		 return typeError2(""msg.isnt.function"", msg, value == null ? ""null"" : value.getClass().getName());
	 }
	 private static RuntimeException notXmlError(Object value) {
		 throw typeError1(""msg.isnt.xml.object"", ScriptRuntime.toString(value));
	 }
	 private static void warnAboutNonJSObject(Object nonJSObject) {
		 String message =""RHINO USAGE WARNING: Missed Context.javaToJS() conversion:\n""+""Rhino runtime detected object ""+nonJSObject+"" of class ""+nonJSObject.getClass().getName()+"" where it expected String, Number, Boolean or Scriptable instance. Please check your code for missing Context.javaToJS() call."";
		 Context.reportWarning(message);
		 System.err.println(message);
	 }
	 public static RegExpProxy getRegExpProxy(Context cx) {
		 return cx.getRegExpProxy();
	 }
	 public static void setRegExpProxy(Context cx, RegExpProxy proxy) {
		 if (proxy == null) throw new IllegalArgumentException();
		 cx.regExpProxy = proxy;
	 }
	 public static RegExpProxy checkRegExpProxy(Context cx) {
		 RegExpProxy result = getRegExpProxy(cx);
		 if (result == null) {
			 throw Context.reportRuntimeError0(""msg.no.regexp"");
		 }
		 return result;
	 }
	 private static XMLLib currentXMLLib(Context cx) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 XMLLib xmlLib = cx.cachedXMLLib;
		 if (xmlLib == null) {
			 xmlLib = XMLLib.extractFromScope(cx.topCallScope);
			 if (xmlLib == null) throw new IllegalStateException();
			 cx.cachedXMLLib = xmlLib;
		 }
		 return xmlLib;
	 }
	 public static String escapeAttributeValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeAttributeValue(value);
	 }
	 public static String escapeTextValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeTextValue(value);
	 }
	 public static Ref memberRef(Object obj, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, elem, memberTypeFlags);
	 }
	 public static Ref memberRef(Object obj, Object namespace, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);
	 }
	 public static Ref nameRef(Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, name, scope, memberTypeFlags);
	 }
	 public static Ref nameRef(Object namespace, Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);
	 }
	 private static void storeIndexResult(Context cx, int index) {
		 cx.scratchIndex = index;
	 }
	 static int lastIndexResult(Context cx) {
		 return cx.scratchIndex;
	 }
	 public static void storeUint32Result(Context cx, long value) {
		 if ((value >>> 32) != 0) throw new IllegalArgumentException();
		 cx.scratchUint32 = value;
	 }
	 public static long lastUint32Result(Context cx) {
		 long value = cx.scratchUint32;
		 if ((value >>> 32) != 0) throw new IllegalStateException();
		 return value;
	 }
	 private static void storeScriptable(Context cx, Scriptable value) {
		 if (cx.scratchScriptable != null) throw new IllegalStateException();
		 cx.scratchScriptable = value;
	 }
	 public static Scriptable lastStoredScriptable(Context cx) {
		 Scriptable result = cx.scratchScriptable;
		 cx.scratchScriptable = null;
		 return result;
	 }
	 static String makeUrlForGeneratedScript (boolean isEval, String masterScriptUrl, int masterScriptLine) {
		 if (isEval) {
			 return masterScriptUrl+'#'+masterScriptLine+""(eval)"";
		 }
		 else {
			 return masterScriptUrl+'#'+masterScriptLine+""(Function)"";
		 }
	 }
	 static boolean isGeneratedScript(String sourceUrl) {
		 return sourceUrl.indexOf(""(eval)"") >= 0 || sourceUrl.indexOf(""(Function)"") >= 0;
	 }
	 private static RuntimeException errorWithClassName(String msg, Object val) {
		 return Context.reportRuntimeError1(msg, val.getClass().getName());
	 }
	 public static final Object[] emptyArgs = new Object[0];
	 public static final String[] emptyStrings = new String[0];
}",1,0,0,0
"public Summary getSummary(String text, Query query) throws IOException {
	 Token[] tokens = getTokens(text);
	 if (tokens.length == 0) return new Summary();
	 String[] terms = query.getTerms();
	 HashSet highlight = new HashSet();
	 for (int i = 0;
	 i < terms.length;
	 i++) highlight.add(terms[i]);
	 SortedSet excerptSet = new TreeSet(new Comparator() {
		 public int compare(Object o1, Object o2) {
			 Excerpt excerpt1 = (Excerpt) o1;
			 Excerpt excerpt2 = (Excerpt) o2;
			 if (excerpt1 == null && excerpt2 != null) {
				 return -1;
			 }
			 else if (excerpt1 != null && excerpt2 == null) {
				 return 1;
			 }
			 else if (excerpt1 == null && excerpt2 == null) {
				 return 0;
			 }
			 int numToks1 = excerpt1.numUniqueTokens();
			 int numToks2 = excerpt2.numUniqueTokens();
			 if (numToks1 < numToks2) {
				 return -1;
			 }
			 else if (numToks1 == numToks2) {
				 return excerpt1.numFragments() - excerpt2.numFragments();
			 }
			 else {
				 return 1;
			 }
		 }
	 }
	 );
	 int lastExcerptPos = 0;
	 for (int i = 0;
	 i < tokens.length;
	 i++) {
		 if (highlight.contains(tokens[i].termText())) {
			 int startToken = (i > SUM_CONTEXT) ? i-SUM_CONTEXT : 0;
			 int endToken = Math.min(i+SUM_CONTEXT, tokens.length);
			 int offset = tokens[startToken].startOffset();
			 int j = startToken;
			 Excerpt excerpt = new Excerpt();
			 if (i != 0) {
				 excerpt.add(new Summary.Ellipsis());
			 }
			 while ((j < endToken) && (j - startToken < SUM_LENGTH)) {
				 Token t = tokens[j];
				 if (highlight.contains(t.termText())) {
					 excerpt.addToken(t.termText());
					 excerpt.add(new Fragment(text.substring(offset, t.startOffset())));
					 excerpt.add(new Highlight(text.substring(t.startOffset(),t.endOffset())));
					 offset = t.endOffset();
					 endToken = Math.min(j+SUM_CONTEXT, tokens.length);
				 }
				 j++;
			 }
			 lastExcerptPos = endToken;
			 if (j < tokens.length) {
				 excerpt.add(new Fragment(text.substring(offset,tokens[j].endOffset())));
			 }
			 excerpt.setNumTerms(j - startToken);
			 excerptSet.add(excerpt);
			 i = j+SUM_CONTEXT;
		 }
	 }
	 if (excerptSet.size() == 0) {
		 Excerpt excerpt = new Excerpt();
		 int excerptLen = Math.min(SUM_LENGTH, tokens.length);
		 lastExcerptPos = excerptLen;
		 excerpt.add(new Fragment(text.substring(tokens[0].startOffset(), tokens[excerptLen-1].startOffset())));
		 excerpt.setNumTerms(excerptLen);
		 excerptSet.add(excerpt);
	 }
	 double tokenCount = 0;
	 Summary s = new Summary();
	 while (tokenCount <= SUM_LENGTH && excerptSet.size() > 0) {
		 Excerpt excerpt = (Excerpt) excerptSet.last();
		 excerptSet.remove(excerpt);
		 double tokenFraction = (1.0 * excerpt.getNumTerms()) / excerpt.numFragments();
		 for (Enumeration e = excerpt.elements();
		 e.hasMoreElements();
		 ) {
			 Fragment f = (Fragment) e.nextElement();
			 if (tokenCount + tokenFraction <= SUM_LENGTH) {
				 s.add(f);
			 }
			 tokenCount += tokenFraction;
		 }
	 }
	 if (tokenCount > 0 && lastExcerptPos < tokens.length) s.add(new Ellipsis());
	 return s;
 }",0,0,1,0
"public interface ReplicatedLevelDBStoreViewMBean {
	 String getZkAddress();
	 String getZkPath();
	 String getZkSessionTimeout();
	 String getBind();
	 int getReplicas();
	 String getNodeRole();
	 String getStatus();
	 CompositeData[] getSlaves();
	 Long getPosition();
	 Long getPositionDate();
	 String getDirectory();
	 String getSync();
	 String getNodeId();
}",0,1,0,0
"public static AbstractJdbcType<T> getTypeForComparator(String comparator) {
	 if ((comparator != null) && (!comparator.contains("".""))) return map.get(""org.apache.cassandra.db.marshal."" + comparator);
	 return map.get(comparator);
 }",0,0,0,0
"public class WantPropertyElement extends Frame implements WantsObjectFrameI, HasSubjectFrameI {
	 int liCounter = 1;
	 ANode predicate;
	 ANode object;
	 ANode reify;
	 boolean objectIsBlank = false;
	 public WantPropertyElement(HasSubjectFrameI s, AbsXMLContext x) {
		 super(s, x);
	 }
	 static final private int TYPEDLITERAL = 1;
	 static final private int EMPTYWITHOBJ = 2;
	 static final private int PARSETYPE = 4;
	 public FrameI startElement(String uri, String localName, String rawName, Attributes atts) throws SAXParseException {
		 clearObject();
		 if (nonWhiteMsgGiven) taint.isTainted();
		 nonWhiteMsgGiven = false;
		 if (uri==null || uri.equals("""")) {
			 warning(WARN_UNQUALIFIED_ELEMENT,""Unqualified property elements are not allowed. Treated as a relative URI."");
		 }
		 ElementLexer el = new ElementLexer(taint, this, uri, localName, rawName, E_LI, CoreAndOldTerms | E_DESCRIPTION, false);
		 predicate = el.goodMatch ? (AResourceInternal) rdf_n(liCounter++) : URIReference.fromQName(this, uri, localName);
		 if (taint.isTainted()) predicate.taint();
		 taint = new TaintImpl();
		 AttributeLexer ap = new AttributeLexer(this, A_XMLLANG | A_XMLBASE | A_XML_OTHER | A_DATATYPE | A_ID | A_NODEID | A_PARSETYPE | A_RESOURCE | A_TYPE, A_BADATTRS);
		 int cnt = ap.processSpecials(taint, atts);
		 final int nextStateCode = (ap.datatype == null ? 0 : TYPEDLITERAL) | (ap.parseType == null ? 0 : PARSETYPE) | (mustBeEmpty(ap, atts, cnt) ? EMPTYWITHOBJ : 0);
		 if (this.badStateCode(nextStateCode)) {
			 warning(errorNumber(nextStateCode), descriptionOfCases(ap, nextStateCode, propertyAttributeDescription(atts, ap, cnt)));
		 }
		 AbsXMLContext x = ap.xml(xml);
		 reify = ap.id == null ? null : URIReference.fromID(this, x, ap.id);
		 if (taint.isTainted()) predicate.taint();
		 if (mustBeEmpty(ap, atts, cnt)) {
			 if (ap.nodeID != null) {
				 object = new ARPResource(arp, ap.nodeID);
				 checkNodeID_XMLName(object, ap.nodeID);
				 objectIsBlank = true;
			 }
			 if (ap.resource != null) {
				 if (object != null) {
					 if (!badStateCode(nextStateCode)) warning(ERR_SYNTAX_ERROR, ""On a property element, only one of the attributes rdf:nodeID or rdf:resource is permitted."");
				 }
				 else object = URIReference.resolve(this, x, ap.resource);
			 }
			 if (object == null) {
				 object = new ARPResource(arp);
				 objectIsBlank = true;
			 }
			 if (taint.isTainted()) object.taint();
			 processPropertyAttributes(ap, atts, x);
		 }
		 FrameI nextFrame = nextFrame(atts, ap, cnt, nextStateCode, x);
		 if (object != null) {
			 if (taint.isTainted()) object.taint();
			 theObject(object);
		 }
		 if (taint.isTainted()) predicate.taint();
		 return nextFrame;
	 }
	 private boolean mustBeEmpty(AttributeLexer ap, Attributes atts, int cnt) {
		 return cnt < atts.getLength() || ap.type != null || ap.nodeID != null || ap.resource != null;
	 }
	 private FrameI nextFrame(Attributes atts, AttributeLexer ap, int cnt, int nextStateCode, AbsXMLContext x) throws SAXParseException {
		 switch (nextStateCode) {
			 case 0: return new WantLiteralValueOrDescription(this, x);
			 case PARSETYPE | TYPEDLITERAL: case PARSETYPE | TYPEDLITERAL | EMPTYWITHOBJ: case PARSETYPE | EMPTYWITHOBJ: case PARSETYPE: return withParsetype(ap.parseType, x);
			 case TYPEDLITERAL | EMPTYWITHOBJ: case TYPEDLITERAL: return new WantTypedLiteral(this, ap.datatype, x);
			 case EMPTYWITHOBJ: return new WantEmpty(this, x);
		 }
		 throw new IllegalStateException(""impossible"");
	 }
	 private FrameI withParsetype(String pt, AbsXMLContext x) throws SAXParseException {
		 if (pt.equals(""Collection"")) {
			 return new RDFCollection(this, x);
		 }
		 if (pt.equals(""Resource"")) {
			 if (object == null) {
				 object = new ARPResource(arp);
				 objectIsBlank = true;
			 }
			 return new WantPropertyElement(this, x);
		 }
		 if (!pt.equals(""Literal"")) {
			 warning(WARN_UNKNOWN_PARSETYPE, ""Unknown rdf:parseType: '"" + pt + ""' (treated as 'Literal'."");
		 }
		 return new OuterXMLLiteral(this, x, pt);
	 }
	 String suggestParsetypeLiteral() {
		 return (getParent() instanceof WantTopLevelDescription) ? """" : super .suggestParsetypeLiteral();
	 }
	 public void aPredAndObj(ANode p, ANode o) {
		 triple(object, p, o);
	 }
	 public void makeSubjectReificationWith(ANode r) {
		 triple(r, RDF_SUBJECT, object);
	 }
	 public void theObject(ANode o) {
		 HasSubjectFrameI p = (HasSubjectFrameI) getParent();
		 p.aPredAndObj(predicate, o);
		 if (reify != null) {
			 triple(reify, RDF_TYPE, RDF_STATEMENT);
			 triple(reify, RDF_OBJECT, o);
			 triple(reify, RDF_PREDICATE, predicate);
			 p.makeSubjectReificationWith(reify);
		 }
	 }
	 public void endElement() {
		 clearObject();
	 }
	 public void abort() {
		 clearObject();
	 }
	 private void clearObject() {
		 if (objectIsBlank) arp.endLocalScope(object);
		 objectIsBlank = false;
		 object = null;
	 }
	 static private URIReference _rdf_n[] = new URIReference[0];
	 static private URIReference rdf_n(int i) {
		 if (i >= _rdf_n.length) {
			 int newLength = (i + 10) * 3 / 2;
			 URIReference new_rdf_n[] = new URIReference[newLength];
			 System.arraycopy(_rdf_n, 0, new_rdf_n, 0, _rdf_n.length);
			 for (int j = _rdf_n.length;
			 j < newLength;
			 j++) {
				 new_rdf_n[j] = URIReference.createNoChecks(rdfns + ""_"" + j);
			 }
			 _rdf_n = new_rdf_n;
		 }
		 return _rdf_n[i];
	 }
	 private boolean badStateCode(int nextStateCode) {
		 switch (nextStateCode) {
			 case PARSETYPE | TYPEDLITERAL: case PARSETYPE | TYPEDLITERAL | EMPTYWITHOBJ: case PARSETYPE | EMPTYWITHOBJ: case TYPEDLITERAL | EMPTYWITHOBJ: return true;
			 case 0: case PARSETYPE: case TYPEDLITERAL: case EMPTYWITHOBJ: return false;
		 }
		 throw new IllegalStateException(""impossible"");
	 }
	 private int errorNumber(int nextStateCode) {
		 return ERR_SYNTAX_ERROR;
	 }
	 private String descriptionOfCases(AttributeLexer ap, int nextStateCode, String propAttrs) {
		 return ((propAttrs == null && ap.type == null) || (ap.nodeID == null && ap.resource == null && ap.type == null) || (ap.nodeID == null && ap.resource == null && propAttrs == null)) ? pairwiseIncompatibleErrorMessage( nextStateCode, ap, propAttrs) : complicatedErrorMessage(nextStateCode, ap, propAttrs);
	 }
	 private String pairwiseIncompatibleErrorMessage(int nextStateCode, AttributeLexer ap, String propAttrs) {
		 ArrayList<String> cases = new ArrayList<>();
		 if ((nextStateCode & PARSETYPE) != 0) cases.add(""rdf:parseType"");
		 if ((nextStateCode & TYPEDLITERAL) != 0) cases.add(""rdf:datatype"");
		 if (ap.nodeID != null) cases.add(""rdf:nodeID"");
		 if (ap.resource != null) cases.add(""rdf:resource"");
		 if (ap.type != null) cases.add(""rdf:type"");
		 if (cases.size() == 1) {
			 if (propAttrs == null) throw new IllegalStateException(""Shouldn't happen."");
			 return ""The attribute "" + cases.get(0) + "" is not permitted with "" + propAttrs + "" on a property element."";
		 }
		 String rslt = ""On a property element, only one of the "";
		 if (propAttrs == null) rslt += ""attributes "";
		 for (int i = 0;
		 i < cases.size();
		 i++) {
			 rslt += cases.get(i);
			 switch (cases.size() - i) {
				 case 1: break;
				 case 2: rslt += "" or "";
				 break;
				 default: rslt += "", "";
				 break;
			 }
		 }
		 if (propAttrs != null) {
			 rslt += "" attributes or "" + propAttrs;
		 }
		 rslt += "" is permitted."";
		 return rslt;
	 }
	 private String complicatedErrorMessage(int nextStateCode, AttributeLexer ap, String propAttrs) {
		 String subjectIs;
		 if (ap.nodeID == null && ap.resource == null && (ap.type == null || propAttrs == null)) throw new IllegalStateException(""precondition failed."");
		 switch (nextStateCode & (TYPEDLITERAL | PARSETYPE)) {
			 case TYPEDLITERAL | PARSETYPE: subjectIs = ""the mutually incompatible attributes rdf:datatype and rdf:parseType are"";
			 break;
			 case TYPEDLITERAL: subjectIs = ""the attribute rdf:datatype is"";
			 break;
			 case PARSETYPE: subjectIs = ""the attribute rdf:parseType is"";
			 break;
			 default: throw new IllegalStateException(""precondition failed"");
		 }
		 String nodeIDResource = null;
		 if (ap.nodeID != null && ap.resource != null) {
			 nodeIDResource = ""the mutually incompatible attributes rdf:nodeID and rdf:resource"";
		 }
		 else if (ap.nodeID != null) {
			 nodeIDResource = ""the attribute rdf:nodeID"";
		 }
		 else if (ap.resource != null) {
			 nodeIDResource = ""the attribute rdf:resource"";
		 }
		 int otherAttCount = nodeIDResource == null ? 0 : 1;
		 String otherAtts;
		 if (ap.type != null) otherAttCount++;
		 if (propAttrs != null) otherAttCount++;
		 if (otherAttCount < 2) throw new IllegalStateException(""logic error"");
		 otherAtts = otherAttCount == 2 ? ""both "" : ""each of "";
		 if (ap.type != null && propAttrs != null) {
			 if (nodeIDResource == null) otherAtts += ""the attribute rdf:type and the "" + propAttrs;
			 else otherAtts += ""the attribute rdf:type, the "" + propAttrs;
		 }
		 else if (ap.type != null) {
			 otherAtts += ""the attribute rdf:type"";
		 }
		 else {
			 otherAtts = ""the "" + propAttrs;
		 }
		 if (nodeIDResource != null) otherAtts += "" and ""+nodeIDResource;
		 return ""On a property element, "" + subjectIs + "" incompatible with "" + otherAtts +""."";
	 }
	 private String propertyAttributeDescription(Attributes atts, AttributeLexer ap, int cnt) {
		 String propAttrs = """";
		 int propAttrCount = atts.getLength() - cnt;
		 int found = 0;
		 if (propAttrCount == 0) return null;
		 switch (propAttrCount) {
			 case 0: break;
			 case 1: case 2: case 3: for (int i = 0;
			 i < atts.getLength();
			 i++) if (!ap.done(i)) {
				 propAttrs += atts.getQName(i);
				 found++;
				 switch (propAttrCount - found) {
					 case 0: break;
					 case 1: propAttrs += "" and "";
					 break;
					 default: propAttrs += "", "";
				 }
			 }
			 break;
			 default: if (propAttrCount < 0) throw new IllegalStateException(""Shouldn't happen."");
			 for (int i = 0;
			 i < atts.getLength();
			 i++) if (!ap.done(i)) {
				 found++;
				 switch (found) {
					 case 1: propAttrs += atts.getQName(i) + "", "";
					 break;
					 case 2: propAttrs += atts.getQName(i) + "", ..."";
					 break;
				 default: }
			 }
		 }
		 return ""property attributes ("" + propAttrs + "")"";
	 }
}",1,0,0,0
"private boolean fetchNext() throws IgniteCheckedException {
	 if (data == null) return false;
	 try {
		 if (!data.next()) {
			 close();
			 return false;
		 }
		 if (res != null) {
			 Value[] values = res.currentRow();
			 for (int c = 0;
			 c < row.length;
			 c++) {
				 Value val = values[c];
				 if (val instanceof GridH2ValueCacheObject) {
					 GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];
					 row[c] = valCacheObj.getObject(true);
				 }
				 else row[c] = val.getObject();
			 }
		 }
		 else {
			 for (int c = 0;
			 c < row.length;
			 c++) row[c] = data.getObject(c + 1);
		 }
		 return true;
	 }
	 catch (SQLException e) {
		 throw new IgniteSQLException(e);
	 }
 }",0,0,1,0
"public void writeCells(int colStart, int colEnd, float xPos, float yPos, PdfContentByte[] canvases) {
	if (!calculated)calculateHeights();
	if (colEnd < 0)colEnd = cells.length;
	elsecolEnd = Math.min(colEnd, cells.length);
	if (colStart < 0)colStart = 0;
	if (colStart >= colEnd)return;
	int newStart;
	for (newStart = colStart;
	 newStart >= 0;
	 --newStart) {
		if (cells[newStart] != null)break;
		if (newStart > 0)xPos -= widths[newStart - 1];
	}
	if (newStart < 0)newStart = 0;
	if (cells[newStart] != null)xPos -= cells[newStart].getLeft();
	for (int k = newStart;
	 k < colEnd;
	 ++k) {
		PdfPCell cell = cells[k];
		if (cell == null)continue;
		float currentMaxHeight = maxHeight + extraHeights[k];
		writeBorderAndBackground(xPos, yPos, currentMaxHeight, cell, canvases);
		Image img = cell.getImage();
		float tly = cell.getTop() + yPos - cell.getEffectivePaddingTop();
		if (cell.getHeight() <= currentMaxHeight) {
			switch (cell.getVerticalAlignment()) {
				case Element.ALIGN_BOTTOM:tly = cell.getTop() + yPos - currentMaxHeight + cell.getHeight()- cell.getEffectivePaddingTop();
				break;
				case Element.ALIGN_MIDDLE:tly = cell.getTop() + yPos + (cell.getHeight() - currentMaxHeight) / 2- cell.getEffectivePaddingTop();
				break;
				default:break;
			}
		}
		if (img != null) {
			 if (cell.getRotation() != 0) {
				 img = Image.getInstance(img);
				 img.setRotation(img.getImageRotation() + (float)(cell.getRotation() * Math.PI / 180.0));
			 }
			boolean vf = false;
			if (cell.getHeight() > currentMaxHeight) {
				img.scalePercent(100);
				float scale = (currentMaxHeight - cell.getEffectivePaddingTop() - cell.getEffectivePaddingBottom())/ img.getScaledHeight();
				img.scalePercent(scale * 100);
				vf = true;
			}
			float left = cell.getLeft() + xPos+ cell.getEffectivePaddingLeft();
			if (vf) {
				switch (cell.getHorizontalAlignment()) {
					case Element.ALIGN_CENTER:left = xPos+ (cell.getLeft() + cell.getEffectivePaddingLeft()+ cell.getRight()- cell.getEffectivePaddingRight() - img.getScaledWidth()) / 2;
					break;
					case Element.ALIGN_RIGHT:left = xPos + cell.getRight()- cell.getEffectivePaddingRight()- img.getScaledWidth();
					break;
					default:break;
				}
				tly = cell.getTop() + yPos - cell.getEffectivePaddingTop();
			}
			img.setAbsolutePosition(left, tly - img.getScaledHeight());
			try {
				canvases[PdfPTable.TEXTCANVAS].addImage(img);
			}
			 catch (DocumentException e) {
				throw new ExceptionConverter(e);
			}
		}
		 else {
			 if (cell.getRotation() == 90 || cell.getRotation() == 270) {
				 float netWidth = currentMaxHeight - cell.getEffectivePaddingTop() - cell.getEffectivePaddingBottom();
				 float netHeight = cell.getWidth() - cell.getEffectivePaddingLeft() - cell.getEffectivePaddingRight();
				 ColumnText ct = ColumnText.duplicate(cell.getColumn());
				 ct.setCanvases(canvases);
				 ct.setSimpleColumn(0, 0, netWidth + 0.001f, -netHeight);
				 try {
					 ct.go(true);
				 }
				 catch (DocumentException e) {
					 throw new ExceptionConverter(e);
				 }
				 float calcHeight = -ct.getYLine();
				 if (netWidth <= 0 || netHeight <= 0) calcHeight = 0;
				 if (calcHeight > 0) {
					 if (cell.isUseDescender()) calcHeight -= ct.getDescender();
					 ct = ColumnText.duplicate(cell.getColumn());
					 ct.setCanvases(canvases);
					 ct.setSimpleColumn(-0.003f, -0.001f, netWidth + 0.003f, calcHeight);
					 float pivotX;
					 float pivotY;
					 if (cell.getRotation() == 90) {
						 pivotY = cell.getTop() + yPos - currentMaxHeight + cell.getEffectivePaddingBottom();
						 switch (cell.getVerticalAlignment()) {
							 case Element.ALIGN_BOTTOM: pivotX = cell.getLeft() + xPos + cell.getWidth() - cell.getEffectivePaddingRight();
							 break;
							 case Element.ALIGN_MIDDLE: pivotX = cell.getLeft() + xPos + (cell.getWidth() + cell.getEffectivePaddingLeft() - cell.getEffectivePaddingRight() + calcHeight) / 2;
							 break;
							 default: pivotX = cell.getLeft() + xPos + cell.getEffectivePaddingLeft() + calcHeight;
							 break;
						 }
						 saveAndRotateCanvases(canvases, 0,1,-1,0,pivotX,pivotY);
					 }
					 else {
						 pivotY = cell.getTop() + yPos - cell.getEffectivePaddingTop();
						 switch (cell.getVerticalAlignment()) {
							 case Element.ALIGN_BOTTOM: pivotX = cell.getLeft() + xPos + cell.getEffectivePaddingLeft();
							 break;
							 case Element.ALIGN_MIDDLE: pivotX = cell.getLeft() + xPos + (cell.getWidth() + cell.getEffectivePaddingLeft() - cell.getEffectivePaddingRight() - calcHeight) / 2;
							 break;
							 default: pivotX = cell.getLeft() + xPos + cell.getWidth() - cell.getEffectivePaddingRight() - calcHeight;
							 break;
						 }
						 saveAndRotateCanvases(canvases, 0,-1,1,0,pivotX,pivotY);
					 }
					 try {
						 ct.go();
					 }
					 catch (DocumentException e) {
						 throw new ExceptionConverter(e);
					 }
					 finally {
						 restoreCanvases(canvases);
					 }
				 }
			 }
			 else {
				 float fixedHeight = cell.getFixedHeight();
				 float rightLimit = cell.getRight() + xPos - cell.getEffectivePaddingRight();
				 float leftLimit = cell.getLeft() + xPos + cell.getEffectivePaddingLeft();
				 if (cell.isNoWrap()) {
					 switch (cell.getHorizontalAlignment()) {
						 case Element.ALIGN_CENTER: rightLimit += 10000;
						 leftLimit -= 10000;
						 break;
						 case Element.ALIGN_RIGHT: if (cell.getRotation() == 180) {
							 rightLimit += RIGHT_LIMIT;
						 }
						 else {
							 leftLimit -= RIGHT_LIMIT;
						 }
						 break;
						 default: if (cell.getRotation() == 180) {
							 leftLimit -= RIGHT_LIMIT;
						 }
						 else {
							 rightLimit += RIGHT_LIMIT;
						 }
						 break;
					 }
				 }
				 ColumnText ct = ColumnText.duplicate(cell.getColumn());
				 ct.setCanvases(canvases);
				 float bry = tly - (currentMaxHeight - cell.getEffectivePaddingTop() - cell.getEffectivePaddingBottom());
				 if (fixedHeight > 0) {
					 if (cell.getHeight() > currentMaxHeight) {
						 tly = cell.getTop() + yPos - cell.getEffectivePaddingTop();
						 bry = cell.getTop() + yPos - currentMaxHeight + cell.getEffectivePaddingBottom();
					 }
				 }
				 if ((tly > bry || ct.zeroHeightElement()) && leftLimit < rightLimit) {
					 ct.setSimpleColumn(leftLimit, bry - 0.001f,rightLimit, tly);
					 if (cell.getRotation() == 180) {
						 float shx = leftLimit + rightLimit;
						 float shy = yPos + yPos - currentMaxHeight + cell.getEffectivePaddingBottom() - cell.getEffectivePaddingTop();
						 saveAndRotateCanvases(canvases, -1,0,0,-1,shx,shy);
					 }
					 try {
						 ct.go();
					 }
					 catch (DocumentException e) {
						 throw new ExceptionConverter(e);
					 }
					 finally {
						 if (cell.getRotation() == 180) {
							 restoreCanvases(canvases);
						 }
					 }
				 }
			 }
		 }
		PdfPCellEvent evt = cell.getCellEvent();
		if (evt != null) {
			Rectangle rect = new Rectangle(cell.getLeft() + xPos, cell.getTop()+ yPos - currentMaxHeight, cell.getRight() + xPos, cell.getTop()+ yPos);
			evt.cellLayout(cell, rect, canvases);
		}
	}
}",0,0,1,0
"class FindReplacePanel extends TabbedPanel implements ClipboardOwner {
	 public static final char LEFT = '\u25FE';
	 public static final char RIGHT = '\u25FE';
	 private JButton _findNextButton;
	 private JButton _findPreviousButton;
	 private JButton _findAllButton;
	 private JButton _replaceButton;
	 private JButton _replaceFindNextButton;
	 private JButton _replaceFindPreviousButton;
	 private JButton _replaceAllButton;
	 private JTextPane _findField;
	 private JTextPane _replaceField;
	 private JLabel _findLabelBot;
	 private JCheckBox _ignoreCommentsAndStrings;
	 private JCheckBox _matchCase;
	 private JCheckBox _searchAllDocuments;
	 private JCheckBox _matchWholeWord;
	 private JCheckBox _ignoreTestCases;
	 private JCheckBox _searchSelectionOnly;
	 private FindReplaceMachine _machine;
	 private SingleDisplayModel _model;
	 private DefinitionsPane _defPane = null;
	 private boolean _caretChanged;
	 private boolean _isFindReplaceActive = false;
	 public boolean isFindReplaceActive() {
		return _isFindReplaceActive;
	}
	 private CaretListener _caretListener = new CaretListener() {
		 public void caretUpdate(CaretEvent e) {
			 assert EventQueue.isDispatchThread();
			 _replaceAction.setEnabled(false);
			 _replaceFindNextAction.setEnabled(false);
			 _replaceFindPreviousAction.setEnabled(false);
			 _machine.positionChanged();
			 _caretChanged = true;
		 }
	 }
	;
	 Action _findNextAction = new AbstractAction(""Find Next"") {
		 public void actionPerformed(ActionEvent e) {
			 findNext();
		 }
	 }
	;
	 Action _findPreviousAction = new AbstractAction(""Find Previous"") {
		 public void actionPerformed(ActionEvent e) {
			 findPrevious();
		 }
	 }
	;
	 private Action _findAllAction = new AbstractAction(""Find All"") {
		 public void actionPerformed(final ActionEvent e) {
			 _isFindReplaceActive = true;
			 _findAll();
			 _isFindReplaceActive = false;
		}
	 }
	;
	 private Action _doFindAction = new AbstractAction(""Do Find"") {
		 public void actionPerformed(ActionEvent e) {
			 _doFind();
		 }
	 }
	;
	 Action _replaceAction = new AbstractAction(""Replace"") {
		 public void actionPerformed(ActionEvent e) {
			 _replace();
		 }
	 }
	;
	 Action _replaceFindNextAction = new AbstractAction(""Replace/Find Next"") {
		 public void actionPerformed(ActionEvent e) {
			 _replaceFindNext();
		 }
	 }
	;
	 Action _replaceFindPreviousAction = new AbstractAction(""Replace/Find Previous"") {
		 public void actionPerformed(ActionEvent e) {
			 _replaceFindPrevious();
		 }
		;
	 }
	;
	 private Action _replaceAllAction = new AbstractAction(""Replace All"") {
		 public void actionPerformed(ActionEvent e) {
			 _replaceAll();
		 }
	 }
	;
	 Action _standardNewlineAction = new TextAction(""Newline Action"") {
		 public void actionPerformed(ActionEvent e) {
			 JTextComponent c = getTextComponent(e);
			 String text = c.getText();
			 int caretPos = c.getCaretPosition();
			 String textBeforeCaret = text.substring(0, caretPos);
			 String textAfterCaret = text.substring(caretPos);
			 c.setText(textBeforeCaret.concat(""\n"").concat(textAfterCaret));
			 c.setCaretPosition(caretPos+1);
		 }
	 }
	;
	 public FindReplacePanel(MainFrame frame, SingleDisplayModel model) {
		 super(frame, ""Find/Replace"");
		 _model = model;
		 _machine = new FindReplaceMachine(_model, _model.getDocumentIterator(), frame);
		 _findNextButton = new JButton(_findNextAction);
		 _findPreviousButton = new JButton(_findPreviousAction);
		 _findAllButton = new JButton(_findAllAction);
		 _replaceButton = new JButton(_replaceAction);
		 _replaceFindNextButton = new JButton(_replaceFindNextAction);
		 _replaceFindPreviousButton = new JButton(_replaceFindPreviousAction);
		 _replaceAllButton = new JButton(_replaceAllAction);
		 _replaceAction.setEnabled(false);
		 _replaceFindNextAction.setEnabled(false);
		 _replaceFindPreviousAction.setEnabled(false);
		 _findField = new JTextPane(new DefaultStyledDocument());
		 _replaceField = new JTextPane(new SwingDocument());
		 AbstractDJPane.disableAltCntlMetaChars(_findField);
		 AbstractDJPane.disableAltCntlMetaChars(_replaceField);
		 _findField.addKeyListener(frame._historyListener);
		 _findField.addFocusListener(frame._focusListenerForRecentDocs);
		 _replaceField.addKeyListener(frame._historyListener);
		 _findField.addFocusListener(frame._focusListenerForRecentDocs);
		 int tabForward = KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS;
		 int tabBackward = KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS;
		 _findField.setFocusTraversalKeys(tabForward, null);
		 _replaceField.setFocusTraversalKeys(tabForward, null);
		 _findField.setFocusTraversalKeys(tabBackward, null);
		 _replaceField.setFocusTraversalKeys(tabBackward, null);
		 KeyStroke enter = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0);
		 KeyStroke ctrlEnter = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, Event.CTRL_MASK);
		 KeyStroke ctrlTab = KeyStroke.getKeyStroke(KeyEvent.VK_TAB, Event.CTRL_MASK);
		 InputMap findIM = _findField.getInputMap();
		 InputMap replaceIM = _replaceField.getInputMap();
		 findIM.put(enter, ""Do Find"");
		 findIM.put(ctrlEnter, ""Insert Newline"");
		 findIM.put(ctrlTab, ""Insert Tab"");
		 for(KeyStroke k: DrJava.getConfig().getSetting(OptionConstants.KEY_CUT)) findIM.put(k, ""Cut"");
		 for(KeyStroke k: DrJava.getConfig().getSetting(OptionConstants.KEY_COPY)) findIM.put(k, ""Copy"");
		 replaceIM.put(enter, ""Insert Newline"");
		 replaceIM.put(ctrlEnter, ""Insert Newline"");
		 replaceIM.put(ctrlTab, ""Insert Tab"");
		 for(KeyStroke k: DrJava.getConfig().getSetting(OptionConstants.KEY_CUT)) replaceIM.put(k, ""Cut"");
		 for(KeyStroke k: DrJava.getConfig().getSetting(OptionConstants.KEY_COPY)) replaceIM.put(k, ""Copy"");
		 Action insertTabAction = new DefaultEditorKit.InsertTabAction();
		 ActionMap findAM = _findField.getActionMap();
		 ActionMap replaceAM = _replaceField.getActionMap();
		 findAM.put(""Do Find"", _doFindAction);
		 findAM.put(""Insert Newline"", _standardNewlineAction);
		 findAM.put(""Insert Tab"", insertTabAction);
		 findAM.put(""Cut"", cutAction);
		 findAM.put(""Copy"", copyAction);
		 replaceAM.put(""Insert Newline"", _standardNewlineAction);
		 replaceAM.put(""Insert Tab"", insertTabAction);
		 replaceAM.put(""Cut"", cutAction);
		 replaceAM.put(""Copy"", copyAction);
		 new ForegroundColorListener(_findField);
		 new BackgroundColorListener(_findField);
		 new ForegroundColorListener(_replaceField);
		 new BackgroundColorListener(_replaceField);
		 Font font = DrJava.getConfig().getSetting(OptionConstants.FONT_MAIN);
		 setFieldFont(font);
		 JLabel _replaceLabelTop = new JLabel(""Replace"", SwingConstants.RIGHT);
		 JLabel _replaceLabelBot = new JLabel(""With"", SwingConstants.RIGHT);
		 JPanel replaceLabelPanelTop = new JPanel(new BorderLayout(5,5));
		 JPanel replaceLabelPanelBot = new JPanel(new BorderLayout(5,5));
		 JPanel replaceLabelPanel = new JPanel(new GridLayout(2,1));
		 replaceLabelPanelTop.add(_replaceLabelTop, BorderLayout.SOUTH);
		 replaceLabelPanelBot.add(_replaceLabelBot, BorderLayout.NORTH);
		 replaceLabelPanel.add(replaceLabelPanelTop);
		 replaceLabelPanel.add(replaceLabelPanelBot);
		 JLabel _findLabelTop = new JLabel(""Find"", SwingConstants.RIGHT);
		 _findLabelBot = new JLabel(""Next"", SwingConstants.RIGHT);
		 JPanel findLabelPanelTop = new JPanel(new BorderLayout(5,5));
		 JPanel findLabelPanelBot = new JPanel(new BorderLayout(5,5));
		 JPanel findLabelPanel = new JPanel(new GridLayout(2,1));
		 findLabelPanelTop.add(_findLabelTop, BorderLayout.SOUTH);
		 findLabelPanelBot.add(_findLabelBot, BorderLayout.NORTH);
		 findLabelPanel.add(findLabelPanelTop);
		 findLabelPanel.add(findLabelPanelBot);
		 JPanel buttons = new JPanel();
		 buttons.setLayout(new GridLayout(1,0,5,0));
		 buttons.add(_findNextButton);
		 buttons.add(_findPreviousButton);
		 buttons.add(_findAllButton);
		 buttons.add(_replaceFindNextButton);
		 buttons.add(_replaceFindPreviousButton);
		 buttons.add(_replaceButton);
		 buttons.add(_replaceAllButton);
		 boolean matchCaseSelected = DrJava.getConfig().getSetting(OptionConstants.FIND_MATCH_CASE);
		 _matchCase = new JCheckBox(""Match Case"", matchCaseSelected);
		 _machine.setMatchCase(matchCaseSelected);
		 _matchCase.addItemListener(new ItemListener() {
			 public void itemStateChanged(ItemEvent e) {
				 boolean isSelected = (e.getStateChange() == ItemEvent.SELECTED);
				 _machine.setMatchCase(isSelected);
				 DrJava.getConfig().setSetting(OptionConstants.FIND_MATCH_CASE, isSelected);
				 _findField.requestFocusInWindow();
			 }
		 }
		);
		 boolean searchAllSelected = DrJava.getConfig().getSetting(OptionConstants.FIND_ALL_DOCUMENTS);
		 _searchAllDocuments = new JCheckBox(""Search All Documents"", searchAllSelected);
		 _machine.setSearchAllDocuments(searchAllSelected);
		 _searchAllDocuments.addItemListener(new ItemListener() {
			 public void itemStateChanged(ItemEvent e) {
				 boolean isSelected = (e.getStateChange() == ItemEvent.SELECTED);
				 if(isSelected) _searchSelectionOnly.setSelected(false);
				 _machine.setSearchAllDocuments(isSelected);
				 DrJava.getConfig().setSetting(OptionConstants.FIND_ALL_DOCUMENTS, isSelected);
				 _findField.requestFocusInWindow();
			 }
		 }
		);
		 boolean searchSelection = DrJava.getConfig().getSetting(OptionConstants.FIND_ONLY_SELECTION);
		 _searchSelectionOnly = new JCheckBox(""Search Selection Only"", searchSelection);
		 _machine.setSearchSelectionOnly(searchSelection);
		 _searchSelectionOnly.addItemListener(new ItemListener() {
			 public void itemStateChanged(ItemEvent e) {
				 boolean isSelected = (e.getStateChange() == ItemEvent.SELECTED);
				 _machine.setSearchSelectionOnly(isSelected);
				 if(isSelected) {
					 _ignoreTestCases.setSelected(false);
					 _searchAllDocuments.setSelected(false);
					 _findNextAction.setEnabled(false);
					 _findPreviousAction.setEnabled(false);
					 _replaceFindNextAction.setEnabled(false);
					 _replaceAction.setEnabled(false);
					 _replaceFindPreviousAction.setEnabled(false);
				 }
				 else {
					 _findNextAction.setEnabled(true);
					 _findPreviousAction.setEnabled(true);
					 _replaceFindNextAction.setEnabled(true);
					 _replaceAction.setEnabled(true);
					 _replaceFindPreviousAction.setEnabled(true);
				 }
				 DrJava.getConfig().setSetting(OptionConstants.FIND_ONLY_SELECTION, isSelected);
				 _findField.requestFocusInWindow();
			 }
		 }
		);
		 boolean matchWordSelected = DrJava.getConfig().getSetting(OptionConstants.FIND_WHOLE_WORD);
		 _matchWholeWord = new JCheckBox(""Whole Word"", matchWordSelected);
		 if (matchWordSelected) {
			 _machine.setMatchWholeWord();
		 }
		 else {
			 _machine.setFindAnyOccurrence();
		 }
		 _matchWholeWord.addItemListener(new ItemListener() {
			 public void itemStateChanged(ItemEvent e) {
				 boolean isSelected = (e.getStateChange() == ItemEvent.SELECTED);
				 if (isSelected) {
					 _machine.setMatchWholeWord();
				 }
				 else {
					 _machine.setFindAnyOccurrence();
				 }
				 DrJava.getConfig().setSetting(OptionConstants.FIND_WHOLE_WORD, isSelected);
				 _findField.requestFocusInWindow();
			 }
		 }
		);
		 boolean ignoreCommentsSelected = DrJava.getConfig().getSetting(OptionConstants.FIND_NO_COMMENTS_STRINGS);
		 _ignoreCommentsAndStrings = new JCheckBox(""No Comments/Strings"", ignoreCommentsSelected);
		 _machine.setIgnoreCommentsAndStrings(ignoreCommentsSelected);
		 _ignoreCommentsAndStrings.addItemListener(new ItemListener() {
			 public void itemStateChanged(ItemEvent e) {
				 boolean isSelected = (e.getStateChange() == ItemEvent.SELECTED);
				 _machine.setIgnoreCommentsAndStrings(isSelected);
				 DrJava.getConfig().setSetting(OptionConstants.FIND_NO_COMMENTS_STRINGS, isSelected);
				 _findField.requestFocusInWindow();
			 }
		 }
		);
		 boolean ignoreTestCasesSelected = DrJava.getConfig().getSetting(OptionConstants.FIND_NO_TEST_CASES);
		 _ignoreTestCases = new JCheckBox(""No Test Cases"", ignoreTestCasesSelected);
		 _machine.setIgnoreTestCases(ignoreTestCasesSelected);
		 _ignoreTestCases.addItemListener(new ItemListener() {
			 public void itemStateChanged(ItemEvent e) {
				 boolean isSelected = (e.getStateChange() == ItemEvent.SELECTED);
				 if(isSelected) _searchSelectionOnly.setSelected(false);
				 _machine.setIgnoreTestCases(isSelected);
				 DrJava.getConfig().setSetting(OptionConstants.FIND_NO_TEST_CASES, isSelected);
				 _findField.requestFocusInWindow();
			 }
		 }
		);
		 this.removeAll();
		 _closePanel = new JPanel(new BorderLayout());
		 _closePanel.add(_closeButton, BorderLayout.NORTH);
		 JPanel _lowerCheckPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		 _lowerCheckPanel.add(_matchWholeWord);
		 _lowerCheckPanel.add(_ignoreCommentsAndStrings);
		 _lowerCheckPanel.setMaximumSize(new Dimension(200, 40));
		 JPanel _matchCaseAndAllDocsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		 _matchCase.setPreferredSize(_matchWholeWord.getPreferredSize());
		 _matchCaseAndAllDocsPanel.add(_matchCase);
		 _matchCaseAndAllDocsPanel.add(_searchAllDocuments);
		 _matchCaseAndAllDocsPanel.setMaximumSize(new Dimension(200, 40));
		 JPanel _ignoreTestCasesPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		 _ignoreTestCasesPanel.add(_ignoreTestCases);
		 _ignoreTestCasesPanel.add(_searchSelectionOnly);
		 _ignoreTestCasesPanel.setMaximumSize(new Dimension(200, 40));
		 BorderlessScrollPane _findPane = new BorderlessScrollPane(_findField);
		 BorderlessScrollPane _replacePane = new BorderlessScrollPane(_replaceField);
		 _findPane.setHorizontalScrollBarPolicy(BorderlessScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		 _replacePane.setHorizontalScrollBarPolicy(BorderlessScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		 JPanel findPanel = new JPanel(new BorderLayout(5,5));
		 findPanel.add(findLabelPanel, BorderLayout.WEST);
		 findPanel.add(_findPane, BorderLayout.CENTER);
		 JPanel replacePanel = new JPanel(new BorderLayout(5,5));
		 replacePanel.add(replaceLabelPanel, BorderLayout.WEST);
		 replacePanel.add(_replacePane, BorderLayout.CENTER);
		 JPanel leftPanel = new JPanel(new GridLayout(1,2,5,5));
		 leftPanel.add(findPanel);
		 leftPanel.add(replacePanel);
		 GridBagLayout gbLayout = new GridBagLayout();
		 GridBagConstraints c = new GridBagConstraints();
		 JPanel emptyPanel = new JPanel();
		 JPanel optionsPanel = new JPanel(gbLayout);
		 optionsPanel.setLayout(gbLayout);
		 optionsPanel.add(_matchCaseAndAllDocsPanel);
		 optionsPanel.add(_lowerCheckPanel);
		 optionsPanel.add(_ignoreTestCasesPanel);
		 optionsPanel.add(emptyPanel);
		 c.fill = GridBagConstraints.HORIZONTAL;
		 c.anchor = GridBagConstraints.NORTH;
		 c.gridwidth = GridBagConstraints.REMAINDER;
		 c.weightx = 1.0;
		 gbLayout.setConstraints(_matchCaseAndAllDocsPanel, c);
		 gbLayout.setConstraints(_lowerCheckPanel, c);
		 gbLayout.setConstraints(_ignoreTestCasesPanel, c);
		 c.fill = GridBagConstraints.BOTH;
		 c.anchor = GridBagConstraints.SOUTH;
		 c.gridheight = GridBagConstraints.REMAINDER;
		 c.weighty = 1.0;
		 gbLayout.setConstraints(emptyPanel, c);
		 JPanel midPanel = new JPanel(new BorderLayout(5,5));
		 midPanel.add(leftPanel, BorderLayout.CENTER);
		 midPanel.add(optionsPanel, BorderLayout.EAST);
		 JPanel _rightPanel = new JPanel(new BorderLayout(5, 5));
		 _rightPanel.add(midPanel, BorderLayout.CENTER);
		 _rightPanel.add(_closePanel, BorderLayout.EAST);
		 JPanel newPanel = new JPanel();
		 newPanel.setLayout(new BoxLayout(newPanel, BoxLayout.Y_AXIS));
		 newPanel.add(_rightPanel);
		 newPanel.add(Box.createVerticalStrut(5));
		 newPanel.add(buttons);
		 newPanel.add(Box.createVerticalStrut(5));
		 this.add(newPanel);
		 _findField.getDocument().addDocumentListener(new DocumentListener() {
			 public void changedUpdate(DocumentEvent e) {
				 _updateHelper();
			 }
			 public void insertUpdate(DocumentEvent e) {
				 _updateHelper();
			 }
			 public void removeUpdate(DocumentEvent e) {
				 _updateHelper();
			 }
			 private void _updateHelper() {
				 assert EventQueue.isDispatchThread();
				 updateFirstDocInSearch();
				 _replaceAction.setEnabled(false);
				 _replaceFindNextAction.setEnabled(false);
				 _replaceFindPreviousAction.setEnabled(false);
				 _machine.positionChanged();
				 if (_findField.getText().equals("""")) _replaceAllAction.setEnabled(false);
				 else _replaceAllAction.setEnabled(true);
				 updateUI();
			 }
		 }
		);
	 }
	 public boolean requestFocusInWindow() {
		 super.requestFocusInWindow();
		 _findField.selectAll();
		 return _findField.requestFocusInWindow();
	 }
	 JTextPane getFindField() {
		 return _findField;
	 }
	 private void _findAll() {
		 _findLabelBot.setText(""Next"");
		 String searchStr = _findField.getText();
		 String title = searchStr;
		 OpenDefinitionsDocument startDoc = _defPane.getOpenDefDocument();
		 boolean searchAll = _machine.getSearchAllDocuments();
		 boolean searchSelectionOnly = _machine.getSearchSelectionOnly();
		 String tabLabel = (title.length() <= 20) ? title : title.substring(0,20);
		 RegionManager<MovingDocumentRegion> rm = _model.createFindResultsManager();
		 MovingDocumentRegion region = new MovingDocumentRegion(startDoc, _defPane.getSelectionStart(), _defPane.getSelectionEnd(), startDoc._getLineStartPos(_defPane.getSelectionStart()), startDoc._getLineEndPos(_defPane.getSelectionEnd()));
		 final FindResultsPanel panel = _frame.createFindResultsPanel(rm, region, tabLabel, searchStr, searchAll, searchSelectionOnly, _machine.getMatchCase(), _machine.getMatchWholeWord(), _machine.getIgnoreCommentsAndStrings(), _ignoreTestCases.isSelected(), new WeakReference<OpenDefinitionsDocument>(startDoc), this);
		 findAll(searchStr, searchAll, searchSelectionOnly, _machine.getMatchCase(), _machine.getMatchWholeWord(), _machine.getIgnoreCommentsAndStrings(), _ignoreTestCases.isSelected(), startDoc, rm, region, panel);
		 panel.requestFocusInWindow();
		 EventQueue.invokeLater(new Runnable() {
			 public void run() {
				 panel._regTree.scrollRowToVisible(0);
			 }
		 }
		);
	 }
	 public void findAll(String searchStr, final boolean searchAll, final boolean searchSelectionOnly, final boolean matchCase, final boolean wholeWord, final boolean noComments, final boolean noTestCases, final OpenDefinitionsDocument startDoc, final RegionManager<MovingDocumentRegion> rm, final MovingDocumentRegion region, final FindResultsPanel panel) {
		 _machine.setSearchBackwards(false);
		 int searchLen = searchStr.length();
		 if (searchLen == 0) return;
		 _frame.updateStatusField(""Finding All"");
		 OpenDefinitionsDocument oldDoc = _machine.getDocument();
		 OpenDefinitionsDocument oldFirstDoc = _machine.getFirstDoc();
		 String oldFindWord = _machine.getFindWord();
		 boolean oldSearchAll = _machine.getSearchAllDocuments();
		 boolean oldSearchSelectionOnly = _machine.getSearchSelectionOnly();
		 boolean oldMatchCase = _machine.getMatchCase();
		 boolean oldWholeWord = _machine.getMatchWholeWord();
		 boolean oldNoComments = _machine.getIgnoreCommentsAndStrings();
		 boolean oldNoTestCases = _machine.getIgnoreTestCases();
		 int oldPosition = _machine.getCurrentOffset();
		 _machine.setDocument(startDoc);
		 if (_machine.getFirstDoc() == null) _machine.setFirstDoc(startDoc);
		 _machine.setSearchAllDocuments(searchAll);
		 _machine.setSearchSelectionOnly(searchSelectionOnly);
		 _machine.setMatchCase(matchCase);
		 if (wholeWord) {
			 _machine.setMatchWholeWord();
		 }
		 else {
			 _machine.setFindAnyOccurrence();
		 }
		 _machine.setIgnoreCommentsAndStrings(noComments);
		 _machine.setPosition(startDoc.getCurrentLocation());
		 _machine.setIgnoreTestCases(noTestCases);
		 _machine.setFindWord(searchStr);
		 String replaceStr = _replaceField.getText();
		 _machine.setReplaceWord(replaceStr);
		 _frame.clearStatusMessage();
		 final List<FindResult> results = new ArrayList<FindResult>();
		 _frame.hourglassOn();
		 try {
			 final int count = _machine.processAll(new Runnable1<FindResult>() {
				 public void run(FindResult fr) {
					 results.add(fr);
				 }
			 }
			, region);
			 _machine.setDocument(oldDoc);
			 _machine.setFirstDoc(oldFirstDoc);
			 _machine.setFindWord(oldFindWord);
			 _machine.setSearchAllDocuments(oldSearchAll);
			 _machine.setSearchSelectionOnly(oldSearchSelectionOnly);
			 _machine.setMatchCase(oldMatchCase);
			 if (oldWholeWord) {
				 _machine.setMatchWholeWord();
			 }
			 else {
				 _machine.setFindAnyOccurrence();
			 }
			 _machine.setIgnoreCommentsAndStrings(oldNoComments);
			 _machine.setIgnoreTestCases(oldNoTestCases);
			 _machine.setPosition(oldPosition);
			 for (FindResult fr: results) {
				 final OpenDefinitionsDocument doc = fr.getDocument();
				 if (_model.getActiveDocument() != doc) _model.setActiveDocument(doc);
				 else _model.refreshActiveDocument();
				 int end = fr.getFoundOffset();
				 int start = end - searchLen;
				 int lineStart = doc._getLineStartPos(start);
				 int lineEnd = doc._getLineEndPos(end);
				 rm.addRegion(new MovingDocumentRegion(doc, start, end, lineStart, lineEnd));
			 }
			 if (count > 0) _frame.showFindResultsPanel(panel);
			 else {
				 Toolkit.getDefaultToolkit().beep();
				 panel.freeResources();
			 }
			 _frame.setStatusMessage(""Found "" + count + "" occurrence"" + ((count == 1) ? """" : ""s"") + ""."");
			 if (searchSelectionOnly) {
				 EventQueue.invokeLater(new Runnable() {
					 public void run() {
						 if (_defPane != null) {
							 _defPane.requestFocusInWindow();
							 _defPane.setSelectionStart(region.getStartOffset());
							 _defPane.setSelectionEnd(region.getEndOffset());
						 }
					 }
				 }
				);
			 }
		 }
		 finally {
			 _frame.hourglassOff();
			 _model.setActiveDocument(startDoc);
		 }
	 }
	 private void _replaceAll() {
		 _frame.updateStatusField(""Replacing All"");
		 _machine.setFindWord(_findField.getText());
		 _machine.setReplaceWord(_replaceField.getText());
		 _machine.setSearchBackwards(false);
		 OpenDefinitionsDocument startDoc = _defPane.getOpenDefDocument();
		 MovingDocumentRegion region = new MovingDocumentRegion(startDoc, _defPane.getSelectionStart(), _defPane.getSelectionEnd(), startDoc._getLineStartPos(_defPane.getSelectionStart()), startDoc._getLineEndPos(_defPane.getSelectionEnd()));
		 _machine.setSelection(region);
		 _frame.clearStatusMessage();
		 int count = _machine.replaceAll();
		 Toolkit.getDefaultToolkit().beep();
		 _frame.setStatusMessage(""Replaced "" + count + "" occurrence"" + ((count == 1) ? """" : ""s"") + ""."");
		 _replaceAction.setEnabled(false);
		 _replaceFindNextAction.setEnabled(false);
		 _replaceFindPreviousAction.setEnabled(false);
		 _model.refreshActiveDocument();
	 }
	 private void _replaceFindNext() {
		 _frame.updateStatusField(""Replacing and Finding Next"");
		 if (isSearchBackwards() == true) {
			 _machine.positionChanged();
			 findNext();
		 }
		 _updateMachine();
		 _machine.setFindWord(_findField.getText());
		 final String replaceWord = _replaceField.getText();
		 _machine.setReplaceWord(replaceWord);
		 _frame.clearStatusMessage();
		 boolean replaced = _machine.replaceCurrent();
		 if (replaced) {
			 _selectFoundOrReplacedItem(replaceWord.length());
			 findNext();
			 _replaceFindNextButton.requestFocusInWindow();
		 }
		 else {
			 _replaceAction.setEnabled(false);
			 _replaceFindNextAction.setEnabled(false);
			 _replaceFindPreviousAction.setEnabled(false);
			 Toolkit.getDefaultToolkit().beep();
			 _frame.setStatusMessage(""Replace failed."");
		 }
	 }
	 private void _replaceFindPrevious() {
		 _frame.updateStatusField(""Replacing and Finding Previous"");
		 if (isSearchBackwards() == false) {
			 _machine.positionChanged();
			 findPrevious();
		 }
		 _updateMachine();
		 _machine.setFindWord(_findField.getText());
		 final String replaceWord = _replaceField.getText();
		 _machine.setReplaceWord(replaceWord);
		 _frame.clearStatusMessage();
		 boolean replaced = _machine.replaceCurrent();
		 if (replaced) {
			 _selectFoundOrReplacedItem(replaceWord.length());
			 findPrevious();
			 _replaceFindPreviousButton.requestFocusInWindow();
		 }
		 else {
			 _replaceAction.setEnabled(false);
			 _replaceFindNextAction.setEnabled(false);
			 _replaceFindPreviousAction.setEnabled(false);
			 Toolkit.getDefaultToolkit().beep();
			 _frame.setStatusMessage(""Replace failed."");
		 }
	 }
	 void findNext() {
		 _frame.updateStatusField(""Finding Next"");
		 _machine.setSearchBackwards(false);
		 _findLabelBot.setText(""Next"");
		 _doFind();
		 if (DrJava.getConfig().getSetting(OptionConstants.FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {
			 _defPane.requestFocusInWindow();
		 }
	 }
	 void findPrevious() {
		 _frame.updateStatusField(""Finding Previous"");
		 _machine.setSearchBackwards(true);
		 _findLabelBot.setText(""Prev"");
		 _doFind();
		 if (DrJava.getConfig().getSetting(OptionConstants.FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {
			 _defPane.requestFocusInWindow();
		 }
	 }
	 private void _replace() {
		 _frame.updateStatusField(""Replacing"");
		 _machine.setFindWord(_findField.getText());
		 final String replaceWord = _replaceField.getText();
		 _machine.setReplaceWord(replaceWord);
		 _frame.clearStatusMessage();
		 boolean replaced = _machine.replaceCurrent();
		 if (replaced) _selectFoundOrReplacedItem(replaceWord.length());
		 _replaceAction.setEnabled(false);
		 _replaceFindNextAction.setEnabled(false);
		 _replaceFindPreviousAction.setEnabled(false);
		 _replaceButton.requestFocusInWindow();
	 }
	 void beginListeningTo(DefinitionsPane defPane) {
		 if (_defPane == null) {
			 _displayed = true;
			 _defPane = defPane;
			 _defPane.addCaretListener(_caretListener);
			 _caretChanged = true;
			 _updateMachine();
			 _machine.setFindWord(_findField.getText());
			 _machine.setReplaceWord(_replaceField.getText());
			 _frame.clearStatusMessage();
			 if (! _machine.onMatch() || _findField.getText().equals("""")) {
				 _replaceAction.setEnabled(false);
				 _replaceFindNextAction.setEnabled(false);
				 _replaceFindPreviousAction.setEnabled(false);
			 }
			 else {
				 _replaceAction.setEnabled(true);
				 _replaceFindNextAction.setEnabled(true);
				 _replaceFindPreviousAction.setEnabled(true);
				 _machine.setLastFindWord();
			 }
			 if (_findField.getText().equals("""")) _replaceAllAction.setEnabled(false);
			 else _replaceAllAction.setEnabled(true);
			 _frame.clearStatusMessage();
		 }
		 else throw new UnexpectedException(new RuntimeException(""FindReplacePanel should not be listening to anything""));
	 }
	 public void stopListening() {
		 if (_defPane != null) {
			 _defPane.removeCaretListener(_caretListener);
			 _defPane = null;
			 _displayed = false;
			 _frame.clearStatusMessage();
		 }
	 }
	 private void _doFind() {
		 if (_findField.getText().length() > 0) {
			 _updateMachine();
			 final String findWord = _findField.getText();
			 _machine.setFindWord(findWord);
			 _machine.setReplaceWord(_replaceField.getText());
			 _frame.clearStatusMessage();
			 final boolean searchAll = _machine.getSearchAllDocuments();
			 _frame.hourglassOn();
			 try {
				 FindResult fr = _machine.findNext();
				 OpenDefinitionsDocument matchDoc = fr.getDocument();
				 OpenDefinitionsDocument openDoc = _defPane.getOpenDefDocument();
				 final boolean docChanged = matchDoc != openDoc;
				 final int pos = fr.getFoundOffset();
				 if (pos >= 0) _model.addToBrowserHistory();
				 if (searchAll) {
					 if (docChanged) _model.setActiveDocument(matchDoc);
					 else _model.refreshActiveDocument();
				 }
				 if (fr.getWrapped() && ! searchAll) {
					 Toolkit.getDefaultToolkit().beep();
					 if (! _machine.isSearchBackwards()) _frame.setStatusMessage(""Search wrapped to beginning."");
					 else _frame.setStatusMessage(""Search wrapped to end."");
				 }
				 if (fr.getAllWrapped() && searchAll) {
					 Toolkit.getDefaultToolkit().beep();
					 _frame.setStatusMessage(""Search wrapped around all documents."");
				 }
				 if (pos >= 0) {
					 _defPane.setCaretPosition(pos);
					 _caretChanged = true;
					 _updateMachine();
					 final Runnable command = new Runnable() {
						 public void run() {
							 _selectFoundOrReplacedItem(findWord.length());
							 _replaceAction.setEnabled(true);
							 _replaceFindNextAction.setEnabled(true);
							 _replaceFindPreviousAction.setEnabled(true);
							 _machine.setLastFindWord();
							 _model.addToBrowserHistory();
							 if (DrJava.getConfig().getSetting(OptionConstants.FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {
								 _frame.toFront();
								 EventQueue.invokeLater(new Runnable() {
									 public void run() {
										 if (_defPane != null) {
											 _defPane.requestFocusInWindow();
										 }
									 }
								 }
								);
							 }
						 }
					 }
					;
					 if (docChanged) EventQueue.invokeLater(command);
					 else command.run();
				 }
				 else {
					 Toolkit.getDefaultToolkit().beep();
					 final StringBuilder statusMessage = new StringBuilder(""Search text \"""");
					 if (findWord.length() <= 50) statusMessage.append(findWord);
					 else statusMessage.append(findWord.substring(0, 49) + ""..."");
					 statusMessage.append(""\"" not found."");
					 _frame.setStatusMessage(statusMessage.toString());
				 }
			 }
			 finally {
				 _frame.hourglassOff();
			 }
		 }
		 if (! DrJava.getConfig().getSetting(OptionConstants.FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {
			 _findField.requestFocusInWindow();
		 }
	 }
	 protected void _close() {
		 _defPane.requestFocusInWindow();
		 if (_displayed) stopListening();
		 super._close();
	 }
	 public void setSearchBackwards(boolean b) {
		 _machine.setSearchBackwards(b);
	 }
	 public boolean isSearchBackwards() {
		 return _machine.isSearchBackwards();
	 }
	 public void setFieldFont(Font f) {
		 _findField.setFont(f);
		 _replaceField.setFont(f);
	 }
	 public void updateFirstDocInSearch() {
		 _machine.setFirstDoc(_model.getActiveDocument());
	 }
	 private void _updateMachine() {
		 if (_caretChanged) {
			 OpenDefinitionsDocument doc = _model.getActiveDocument();
			 _machine.setDocument(doc);
			 if (_machine.getFirstDoc() == null) _machine.setFirstDoc(doc);
			 _machine.setPosition(_defPane.getCaretPosition());
			 _caretChanged = false;
		 }
	 }
	 private void _selectFoundOrReplacedItem(int length) {
		 int offset = _machine.getCurrentOffset();
		 int from, to;
		 if (_machine.isSearchBackwards()) {
			 from = offset + length;
			 to = offset;
		 }
		 else {
			 from = offset - length;
			 to = offset;
		 }
		 _selectFoundOrReplacedItem(from, to);
	 }
	 private void _selectFoundOrReplacedItem(int from, int to) {
		 _defPane.centerViewOnOffset(from);
		 _defPane.select(from, to);
		 EventQueue.invokeLater(new Runnable() {
			 public void run() {
				 _defPane.getCaret().setSelectionVisible(true);
			 }
		 }
		);
	 }
	 public void lostOwnership(Clipboard clipboard, Transferable contents) {
	 }
	 Action cutAction = new DefaultEditorKit.CutAction() {
		 public void actionPerformed(ActionEvent e) {
			 if (e.getSource() instanceof JTextComponent) {
				 JTextComponent tc = (JTextComponent)e.getSource();
				 if (tc.getSelectedText() != null) {
					 super.actionPerformed(e);
					 String s = edu.rice.cs.util.swing.Utilities.getClipboardSelection(FindReplacePanel.this);
					 if (s != null && s.length() != 0){
						 ClipboardHistoryModel.singleton().put(s);
					 }
				 }
			 }
		 }
	 }
	;
	 Action copyAction = new DefaultEditorKit.CopyAction() {
		 public void actionPerformed(ActionEvent e) {
			 if (e.getSource() instanceof JTextComponent) {
				 JTextComponent tc = (JTextComponent)e.getSource();
				 if (tc.getSelectedText() != null) {
					 super.actionPerformed(e);
					 String s = edu.rice.cs.util.swing.Utilities.getClipboardSelection(FindReplacePanel.this);
					 if (s != null && s.length() != 0) {
						 ClipboardHistoryModel.singleton().put(s);
					 }
				 }
			 }
		 }
	 }
	;
	 public DefinitionsPane getDefPane() {
		 return _defPane;
	 }
	 public JButton getFindNextButton() {
		return _findNextButton;
	 }
}",1,0,0,0
"public Explanation explain(LeafReaderContext context, int doc) throws IOException {
	 Scorer scorer = scorer(context);
	 if (scorer != null) {
		 int newDoc = scorer.iterator().advance(doc);
		 if (newDoc == doc) {
			 final float freq;
			 if (scorer instanceof BM25FScorer) {
				 freq = ((BM25FScorer) scorer).freq();
			 }
			 else {
				 assert scorer instanceof TermScorer;
				 freq = ((TermScorer) scorer).freq();
			 }
			 final MultiNormsLeafSimScorer docScorer = new MultiNormsLeafSimScorer(simWeight, context.reader(), fieldAndWeights.values(), true);
			 Explanation freqExplanation = Explanation.match(freq, ""termFreq="" + freq);
			 Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);
			 return Explanation.match( scoreExplanation.getValue(), ""weight("" + getQuery() + "" in "" + doc + "") ["" + similarity.getClass().getSimpleName() + ""], result of:"", scoreExplanation);
		 }
	 }
	 return Explanation.noMatch(""no matching term"");
 }",0,0,1,0
"protected int exportPage(JRPrintPage page, CutsInfo xCuts, int startRow, JRPrintElementIndex frameIndex, boolean isNewSheet) throws JRException{
	try{
		JRGridLayout layout =new JRGridLayout(nature,page.getElements(),jasperPrint.getPageWidth(),jasperPrint.getPageHeight(),globalOffsetX,globalOffsetY,xCuts);
		JRExporterGridCell grid[][] = layout.getGrid();
		boolean createXCuts = (xCuts == null);
		if (createXCuts){
			xCuts = layout.getXCuts();
		}
		CutsInfo yCuts = layout.getYCuts();
		int skippedRows = 0;
		int rowIndex = startRow;
		XmlssTableBuilder tableBuilder = frameIndex == null? new XmlssTableBuilder(reportIndex, pageIndex, tempBodyWriter, tempStyleWriter): new XmlssTableBuilder(frameIndex.toString(), tempBodyWriter, tempStyleWriter);
		if(isNewSheet){
			buildColumns(xCuts, tableBuilder);
		}
		for(int y = 0;
		 y < grid.length;
		 y++){
			rowIndex = y - skippedRows + startRow;
			if(maxRowsPerSheet > 0 && rowIndex >= maxRowsPerSheet){
				tableBuilder.buildTableFooter();
				closeWorksheet();
				tempBodyWriter.write(""<Worksheet ss:Name=\""""+getSheetName(currentSheetName)+""\"">\n"");
				tableBuilder.buildTableHeader();
				buildColumns(xCuts, tableBuilder);
				startRow = 0;
				rowIndex = 0;
				skippedRows = y;
			}
			if (yCuts.isCutNotEmpty(y)|| ((!isRemoveEmptySpaceBetweenRows || yCuts.isCutSpanned(y))&& !isCollapseRowSpan)){
				JRExporterGridCell[] gridRow = grid[y];
				int emptyCellColSpan = 0;
				int emptyCellRowSpan = 0;
				int emptyCellWidth = 0;
				int rowHeight = isCollapseRowSpan ? JRGridLayout.getMaxRowHeight(gridRow) : JRGridLayout.getRowHeight(gridRow);
				tableBuilder.buildRowHeader(rowIndex, rowHeight);
				int emptyCols = 0;
				for(int colIndex = 0;
				 colIndex < gridRow.length;
				 colIndex++){
					emptyCols += (isRemoveEmptySpaceBetweenColumns && (!(xCuts.isCutNotEmpty(colIndex) || xCuts.isCutSpanned(colIndex))) ? 1 : 0);
					JRExporterGridCell gridCell = gridRow[colIndex];
					if(gridCell.getWrapper() != null){
						if (emptyCellColSpan > 0){
							tableBuilder.buildEmptyCell(emptyCellColSpan, emptyCellRowSpan);
							emptyCellColSpan = 0;
							emptyCellWidth = 0;
						}
						JRPrintElement element = gridCell.getWrapper().getElement();
						if (element instanceof JRPrintText){
							exportText(tableBuilder, (JRPrintText)element, gridCell);
						}
						colIndex += gridCell.getColSpan() - 1;
					}
					else{
						emptyCellColSpan++;
						emptyCellWidth += gridCell.getWidth();
					}
				}
				if (emptyCellColSpan > 0){
					tableBuilder.buildEmptyCell(emptyCellColSpan, emptyCellRowSpan);
					emptyCellColSpan = 0;
					emptyCellWidth = 0;
				}
				tableBuilder.buildRowFooter();
				++rowIndex;
			}
			else{
				skippedRows++;
			}
		}
		if (progressMonitor != null){
			progressMonitor.afterPageExport();
		}
		return rowIndex;
	}
	catch (IOException e){
		throw new JRException(e);
	}
}",0,0,1,0
"public class WeblogTrackbackRequest extends WeblogRequest {
	 private static Log log = LogFactory.getLog(WeblogTrackbackRequest.class);
	 private static final String TRACKBACK_SERVLET = ""/roller-ui/rendering/trackback"";
	 private String blogName = null;
	 private String url = null;
	 private String excerpt = null;
	 private String title = null;
	 private String weblogAnchor = null;
	 private WeblogEntry weblogEntry = null;
	 public WeblogTrackbackRequest() {
	}
	 public WeblogTrackbackRequest(HttpServletRequest request) throws InvalidRequestException {
		 super(request);
		 String servlet = request.getServletPath();
		 String pathInfo = this.getPathInfo();
		 if(servlet == null || !TRACKBACK_SERVLET.equals(servlet)) {
			 throw new InvalidRequestException(""not a weblog trackback request, ""+ request.getRequestURL());
		 }
		 if(pathInfo != null && pathInfo.trim().length() > 0) {
			 String[] pathElements = pathInfo.split(""/"");
			 if(pathElements.length == 2) {
				 String context = pathElements[0];
				 if(""entry"".equals(context)) {
					 try {
						 this.weblogAnchor = URLDecoder.decode(pathElements[1], ""UTF-8"");
					 }
					 catch (UnsupportedEncodingException ex) {
						 log.error(ex);
					 }
				 }
				 else {
					 throw new InvalidRequestException(""bad path info, ""+ request.getRequestURL());
				 }
			 }
			 else {
				 throw new InvalidRequestException(""bad path info, ""+ request.getRequestURL());
			 }
		 }
		 else {
			 throw new InvalidRequestException(""bad path info, ""+ request.getRequestURL());
		 }
		 if(request.getParameter(""blog_name"") != null) {
			 this.blogName = request.getParameter(""blog_name"");
		 }
		 if(request.getParameter(""url"") != null) {
			 this.url = request.getParameter(""url"");
		 }
		 if(request.getParameter(""excerpt"") != null) {
			 this.excerpt = request.getParameter(""excerpt"");
		 }
		 if(request.getParameter(""title"") != null) {
			 this.title = request.getParameter(""title"");
		 }
		 if(this.blogName == null || this.url == null || this.excerpt == null || this.title == null) {
			 throw new InvalidRequestException(""bad request data. did not ""+ ""receive values for all trackback params (blog_name, url, excerpt, title)"");
		 }
		 if(log.isDebugEnabled()) {
			 log.debug(""name = ""+this.blogName);
			 log.debug(""url = ""+this.url);
			 log.debug(""excerpt = ""+this.excerpt);
			 log.debug(""title = ""+this.title);
			 log.debug(""weblogAnchor = ""+this.weblogAnchor);
		 }
	 }
	 public String getBlogName() {
		 return blogName;
	 }
	 public void setBlogName(String blogName) {
		 this.blogName = blogName;
	 }
	 public String getUrl() {
		 return url;
	 }
	 public void setUrl(String url) {
		 this.url = url;
	 }
	 public String getExcerpt() {
		 return excerpt;
	 }
	 public void setExcerpt(String excerpt) {
		 this.excerpt = excerpt;
	 }
	 public String getTitle() {
		 return title;
	 }
	 public void setTitle(String title) {
		 this.title = title;
	 }
	 public String getWeblogAnchor() {
		 return weblogAnchor;
	 }
	 public void setWeblogAnchor(String weblogAnchor) {
		 this.weblogAnchor = weblogAnchor;
	 }
	 public WeblogEntry getWeblogEntry() {
		 if(weblogEntry == null && weblogAnchor != null) {
			 try {
				 WeblogManager wmgr = WebloggerFactory.getWeblogger().getWeblogManager();
				 weblogEntry = wmgr.getWeblogEntryByAnchor(getWeblog(), weblogAnchor);
			 }
			 catch (WebloggerException ex) {
				 log.error(""Error getting weblog entry ""+weblogAnchor, ex);
			 }
		 }
		 return weblogEntry;
	 }
	 public void setWeblogEntry(WeblogEntry weblogEntry) {
		 this.weblogEntry = weblogEntry;
	 }
}",0,1,0,0
"public class MetadataProvider {
	 private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MetadataProvider.class);
	 private static final String IN_FUNCTION = ""in"";
	 private static final String LIKE_FUNCTION = ""like"";
	 private static final String AND_FUNCTION = ""booleanand"";
	 private static final String OR_FUNCTION = ""booleanor"";
	 public static Runnable catalogs(final UserSession session, final DrillbitContext dContext, final GetCatalogsReq req, final ResponseSender responseSender) {
		 return new CatalogsProvider(session, dContext, req, responseSender);
	 }
	 public static Runnable schemas(final UserSession session, final DrillbitContext dContext, final GetSchemasReq req, final ResponseSender responseSender) {
		 return new SchemasProvider(session, dContext, req, responseSender);
	 }
	 public static Runnable tables(final UserSession session, final DrillbitContext dContext, final GetTablesReq req, final ResponseSender responseSender) {
		 return new TablesProvider(session, dContext, req, responseSender);
	 }
	 public static Runnable columns(final UserSession session, final DrillbitContext dContext, final GetColumnsReq req, final ResponseSender responseSender) {
		 return new ColumnsProvider(session, dContext, req, responseSender);
	 }
	 private abstract static class MetadataRunnable implements Runnable {
		 protected final UserSession session;
		 private final ResponseSender responseSender;
		 private final DrillbitContext dContext;
		 private MetadataRunnable(final UserSession session, final DrillbitContext dContext, final ResponseSender responseSender) {
			 this.session = Preconditions.checkNotNull(session);
			 this.dContext = Preconditions.checkNotNull(dContext);
			 this.responseSender = Preconditions.checkNotNull(responseSender);
		 }
		 public void run() {
			 try(SchemaTreeProvider schemaTreeProvider = new SchemaTreeProvider(dContext)) {
				 responseSender.send(runInternal(session, schemaTreeProvider));
			 }
			 catch (final Throwable error) {
				 logger.error(""Unhandled metadata provider error"", error);
			 }
		 }
		 protected abstract Response runInternal(UserSession session, SchemaTreeProvider schemaProvider);
		 public DrillConfig getConfig() {
			 return dContext.getConfig();
		 }
	 }
	 private static class CatalogsProvider extends MetadataRunnable {
		 private static final Ordering<CatalogMetadata> CATALOGS_ORDERING = new Ordering<CatalogMetadata>() {
			 public int compare(CatalogMetadata left, CatalogMetadata right) {
				 return Ordering.natural().compare(left.getCatalogName(), right.getCatalogName());
			 }
		 }
		;
		 private final GetCatalogsReq req;
		 public CatalogsProvider(final UserSession session, final DrillbitContext dContext, final GetCatalogsReq req, final ResponseSender responseSender) {
			 super(session, dContext, responseSender);
			 this.req = Preconditions.checkNotNull(req);
		 }
		 protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {
			 final GetCatalogsResp.Builder respBuilder = GetCatalogsResp.newBuilder();
			 final InfoSchemaFilter filter = createInfoSchemaFilter( req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null, null, null, null, null);
			 try {
				 final PojoRecordReader<Catalog> records = getPojoRecordReader(CATALOGS, filter, getConfig(), schemaProvider, session);
				 List<CatalogMetadata> metadata = new ArrayList<>();
				 for(Catalog c : records) {
					 final CatalogMetadata.Builder catBuilder = CatalogMetadata.newBuilder();
					 catBuilder.setCatalogName(c.CATALOG_NAME);
					 catBuilder.setDescription(c.CATALOG_DESCRIPTION);
					 catBuilder.setConnect(c.CATALOG_CONNECT);
					 metadata.add(catBuilder.build());
				 }
				 Collections.sort(metadata, CATALOGS_ORDERING);
				 respBuilder.addAllCatalogs(metadata);
				 respBuilder.setStatus(RequestStatus.OK);
			 }
			 catch (Throwable e) {
				 respBuilder.setStatus(RequestStatus.FAILED);
				 respBuilder.setError(createPBError(""get catalogs"", e));
			 }
			 finally {
				 return new Response(RpcType.CATALOGS, respBuilder.build());
			 }
		 }
	 }
	 private static class SchemasProvider extends MetadataRunnable {
		 private static final Ordering<SchemaMetadata> SCHEMAS_ORDERING = new Ordering<SchemaMetadata>() {
			 public int compare(SchemaMetadata left, SchemaMetadata right) {
				 return ComparisonChain.start() .compare(left.getCatalogName(), right.getCatalogName()) .compare(left.getSchemaName(), right.getSchemaName()) .result();
			 }
			;
		 }
		;
		 private final GetSchemasReq req;
		 private SchemasProvider(final UserSession session, final DrillbitContext dContext, final GetSchemasReq req, final ResponseSender responseSender) {
			 super(session, dContext, responseSender);
			 this.req = Preconditions.checkNotNull(req);
		 }
		 protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {
			 final GetSchemasResp.Builder respBuilder = GetSchemasResp.newBuilder();
			 final InfoSchemaFilter filter = createInfoSchemaFilter( req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null, req.hasSchemaNameFilter() ? req.getSchemaNameFilter() : null, null, null, null);
			 try {
				 final PojoRecordReader<Schema> records = getPojoRecordReader(SCHEMATA, filter, getConfig(), schemaProvider, session);
				 List<SchemaMetadata> metadata = new ArrayList<>();
				 for(Schema s : records) {
					 final SchemaMetadata.Builder schemaBuilder = SchemaMetadata.newBuilder();
					 schemaBuilder.setCatalogName(s.CATALOG_NAME);
					 schemaBuilder.setSchemaName(s.SCHEMA_NAME);
					 schemaBuilder.setOwner(s.SCHEMA_OWNER);
					 schemaBuilder.setType(s.TYPE);
					 schemaBuilder.setMutable(s.IS_MUTABLE);
					 metadata.add(schemaBuilder.build());
				 }
				 Collections.sort(metadata, SCHEMAS_ORDERING);
				 respBuilder.addAllSchemas(metadata);
				 respBuilder.setStatus(RequestStatus.OK);
			 }
			 catch (Throwable e) {
				 respBuilder.setStatus(RequestStatus.FAILED);
				 respBuilder.setError(createPBError(""get schemas"", e));
			 }
			 finally {
				 return new Response(RpcType.SCHEMAS, respBuilder.build());
			 }
		 }
	 }
	 private static class TablesProvider extends MetadataRunnable {
		 private static final Ordering<TableMetadata> TABLES_ORDERING = new Ordering<TableMetadata>() {
			 public int compare(TableMetadata left, TableMetadata right) {
				 return ComparisonChain.start() .compare(left.getType(), right.getType()) .compare(left.getCatalogName(), right.getCatalogName()) .compare(left.getSchemaName(), right.getSchemaName()) .compare(left.getTableName(), right.getTableName()) .result();
			 }
		 }
		;
		 private final GetTablesReq req;
		 private TablesProvider(final UserSession session, final DrillbitContext dContext, final GetTablesReq req, final ResponseSender responseSender) {
			 super(session, dContext, responseSender);
			 this.req = Preconditions.checkNotNull(req);
		 }
		 protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {
			 final GetTablesResp.Builder respBuilder = GetTablesResp.newBuilder();
			 final InfoSchemaFilter filter = createInfoSchemaFilter( req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null, req.hasSchemaNameFilter() ? req.getSchemaNameFilter() : null, req.hasTableNameFilter() ? req.getTableNameFilter() : null, req.getTableTypeFilterCount() != 0 ? req.getTableTypeFilterList() : null, null);
			 try {
				 final PojoRecordReader<Table> records = getPojoRecordReader(TABLES, filter, getConfig(), schemaProvider, session);
				 List<TableMetadata> metadata = new ArrayList<>();
				 for(Table t : records) {
					 final TableMetadata.Builder tableBuilder = TableMetadata.newBuilder();
					 tableBuilder.setCatalogName(t.TABLE_CATALOG);
					 tableBuilder.setSchemaName(t.TABLE_SCHEMA);
					 tableBuilder.setTableName(t.TABLE_NAME);
					 tableBuilder.setType(t.TABLE_TYPE);
					 metadata.add(tableBuilder.build());
				 }
				 Collections.sort(metadata, TABLES_ORDERING);
				 respBuilder.addAllTables(metadata);
				 respBuilder.setStatus(RequestStatus.OK);
			 }
			 catch (Throwable e) {
				 respBuilder.setStatus(RequestStatus.FAILED);
				 respBuilder.setError(createPBError(""get tables"", e));
			 }
			 finally {
				 return new Response(RpcType.TABLES, respBuilder.build());
			 }
		 }
	 }
	 private static class ColumnsProvider extends MetadataRunnable {
		 private static final Ordering<ColumnMetadata> COLUMNS_ORDERING = new Ordering<ColumnMetadata>() {
			 public int compare(ColumnMetadata left, ColumnMetadata right) {
				 return ComparisonChain.start() .compare(left.getCatalogName(), right.getCatalogName()) .compare(left.getSchemaName(), right.getSchemaName()) .compare(left.getTableName(), right.getTableName()) .compare(left.getOrdinalPosition(), right.getOrdinalPosition()) .result();
			 }
		 }
		;
		 private final GetColumnsReq req;
		 private ColumnsProvider(final UserSession session, final DrillbitContext dContext, final GetColumnsReq req, final ResponseSender responseSender) {
			 super(session, dContext, responseSender);
			 this.req = Preconditions.checkNotNull(req);
		 }
		 protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {
			 final GetColumnsResp.Builder respBuilder = GetColumnsResp.newBuilder();
			 final InfoSchemaFilter filter = createInfoSchemaFilter( req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null, req.hasSchemaNameFilter() ? req.getSchemaNameFilter() : null, req.hasTableNameFilter() ? req.getTableNameFilter() : null, null, req.hasColumnNameFilter() ? req.getColumnNameFilter() : null );
			 try {
				 final PojoRecordReader<Column> records = getPojoRecordReader(COLUMNS, filter, getConfig(), schemaProvider, session);
				 List<ColumnMetadata> metadata = new ArrayList<>();
				 for(Column c : records) {
					 final ColumnMetadata.Builder columnBuilder = ColumnMetadata.newBuilder();
					 columnBuilder.setCatalogName(c.TABLE_CATALOG);
					 columnBuilder.setSchemaName(c.TABLE_SCHEMA);
					 columnBuilder.setTableName(c.TABLE_NAME);
					 columnBuilder.setColumnName(c.COLUMN_NAME);
					 columnBuilder.setOrdinalPosition(c.ORDINAL_POSITION);
					 if (c.COLUMN_DEFAULT != null) {
						 columnBuilder.setDefaultValue(c.COLUMN_DEFAULT);
					 }
					 if (""YES"".equalsIgnoreCase(c.IS_NULLABLE)) {
						 columnBuilder.setIsNullable(true);
					 }
					 else {
						 columnBuilder.setIsNullable(false);
					 }
					 columnBuilder.setDataType(c.DATA_TYPE);
					 if (c.CHARACTER_MAXIMUM_LENGTH != null) {
						 columnBuilder.setCharMaxLength(c.CHARACTER_MAXIMUM_LENGTH);
					 }
					 if (c.CHARACTER_OCTET_LENGTH != null) {
						 columnBuilder.setCharOctetLength(c.CHARACTER_OCTET_LENGTH);
					 }
					 if (c.NUMERIC_SCALE != null) {
						 columnBuilder.setNumericScale(c.NUMERIC_SCALE);
					 }
					 if (c.NUMERIC_PRECISION != null) {
						 columnBuilder.setNumericPrecision(c.NUMERIC_PRECISION);
					 }
					 if (c.NUMERIC_PRECISION_RADIX != null) {
						 columnBuilder.setNumericPrecisionRadix(c.NUMERIC_PRECISION_RADIX);
					 }
					 if (c.DATETIME_PRECISION != null) {
						 columnBuilder.setDateTimePrecision(c.DATETIME_PRECISION);
					 }
					 if (c.INTERVAL_TYPE != null) {
						 columnBuilder.setIntervalType(c.INTERVAL_TYPE);
					 }
					 if (c.INTERVAL_PRECISION != null) {
						 columnBuilder.setIntervalPrecision(c.INTERVAL_PRECISION);
					 }
					 if (c.COLUMN_SIZE != null) {
						 columnBuilder.setColumnSize(c.COLUMN_SIZE);
					 }
					 metadata.add(columnBuilder.build());
				 }
				 Collections.sort(metadata, COLUMNS_ORDERING);
				 respBuilder.addAllColumns(metadata);
				 respBuilder.setStatus(RequestStatus.OK);
			 }
			 catch (Throwable e) {
				 respBuilder.setStatus(RequestStatus.FAILED);
				 respBuilder.setError(createPBError(""get columns"", e));
			 }
			 finally {
				 return new Response(RpcType.COLUMNS, respBuilder.build());
			 }
		 }
	 }
	 private static InfoSchemaFilter createInfoSchemaFilter(LikeFilter catalogNameFilter, LikeFilter schemaNameFilter, LikeFilter tableNameFilter, List<String> tableTypeFilter, LikeFilter columnNameFilter) {
		 FunctionExprNode exprNode = createLikeFunctionExprNode(CATS_COL_CATALOG_NAME, catalogNameFilter);
		 if (schemaNameFilter != null) {
			 LikeFilter.Builder builder = LikeFilter.newBuilder();
			 if (schemaNameFilter.hasPattern()) {
				 builder.setPattern(schemaNameFilter.getPattern().toLowerCase());
			 }
			 if (schemaNameFilter.hasEscape()) {
				 builder.setEscape(schemaNameFilter.getEscape().toLowerCase());
			 }
			 schemaNameFilter = builder.build();
		 }
		 exprNode = combineFunctions(AND_FUNCTION, exprNode, combineFunctions(OR_FUNCTION, createLikeFunctionExprNode(SHRD_COL_TABLE_SCHEMA, schemaNameFilter), createLikeFunctionExprNode(SCHS_COL_SCHEMA_NAME, schemaNameFilter) ) );
		 exprNode = combineFunctions(AND_FUNCTION, exprNode, createLikeFunctionExprNode(SHRD_COL_TABLE_NAME, tableNameFilter) );
		 exprNode = combineFunctions(AND_FUNCTION, exprNode, createInFunctionExprNode(TBLS_COL_TABLE_TYPE, tableTypeFilter) );
		 exprNode = combineFunctions(AND_FUNCTION, exprNode, createLikeFunctionExprNode(COLS_COL_COLUMN_NAME, columnNameFilter) );
		 return exprNode != null ? new InfoSchemaFilter(exprNode) : null;
	 }
	 private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) {
		 if (likeFilter == null) {
			 return null;
		 }
		 return new FunctionExprNode(LIKE_FUNCTION, likeFilter.hasEscape() ? ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern()), new ConstantExprNode(likeFilter.getEscape())) : ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern())) );
	 }
	 private static FunctionExprNode createInFunctionExprNode(String fieldName, List<String> valuesFilter) {
		 if (valuesFilter == null) {
			 return null;
		 }
		 ImmutableList.Builder<ExprNode> nodes = ImmutableList.builder();
		 nodes.add(new FieldExprNode(fieldName));
		 for(String type: valuesFilter) {
			 nodes.add(new ConstantExprNode(type));
		 }
		 return new FunctionExprNode(IN_FUNCTION, nodes.build());
	 }
	 private static FunctionExprNode combineFunctions(final String functionName, final FunctionExprNode func1, final FunctionExprNode func2) {
		 if (func1 == null) {
			 return func2;
		 }
		 if (func2 == null) {
			 return func1;
		 }
		 return new FunctionExprNode(functionName, ImmutableList.<ExprNode>of(func1, func2));
	 }
	 private static <S> PojoRecordReader<S> getPojoRecordReader(final InfoSchemaTableType tableType, final InfoSchemaFilter filter, final DrillConfig config, final SchemaTreeProvider provider, final UserSession userSession) {
		 final SchemaPlus rootSchema = provider.createFullRootSchema(userSession.getCredentials().getUserName(), newSchemaConfigInfoProvider(config, userSession, provider));
		 return tableType.getRecordReader(rootSchema, filter, userSession.getOptions());
	 }
	 private static SchemaConfigInfoProvider newSchemaConfigInfoProvider(final DrillConfig config, final UserSession session, final SchemaTreeProvider schemaTreeProvider) {
		 return new SchemaConfigInfoProvider() {
			 private final ViewExpansionContext viewExpansionContext = new ViewExpansionContext(config, this);
			 public ViewExpansionContext getViewExpansionContext() {
				 return viewExpansionContext;
			 }
			 public SchemaPlus getRootSchema(String userName) {
				 return schemaTreeProvider.createRootSchema(userName, this);
			 }
			 public OptionValue getOption(String optionKey) {
				 return session.getOptions().getOption(optionKey);
			 }
			 public String getQueryUserName() {
				 return session.getCredentials().getUserName();
			 }
		 }
		;
	 }
	 static DrillPBError createPBError(final String failedFunction, final Throwable ex) {
		 final String errorId = UUID.randomUUID().toString();
		 logger.error(""Failed to {
		}
		. ErrorId: {
		}
		"", failedFunction, errorId, ex);
		 final DrillPBError.Builder builder = DrillPBError.newBuilder();
		 builder.setErrorType(ErrorType.SYSTEM);
		 builder.setErrorId(errorId);
		 if (ex.getMessage() != null) {
			 builder.setMessage(ex.getMessage());
		 }
		 builder.setException(ErrorHelper.getWrapper(ex));
		 return builder.build();
	 }
}",1,0,0,0
"public class SecuredModelTest {
	 protected final MockSecurityEvaluator securityEvaluator;
	 protected SecuredModel securedModel;
	 protected Model baseModel;
	 protected Resource s;
	 protected Resource s2;
	 protected Property p;
	 protected Property p2;
	 protected Resource o;
	 protected Resource o2;
	 public SecuredModelTest(final MockSecurityEvaluator securityEvaluator) {
		 this.securityEvaluator = securityEvaluator;
	 }
	 protected Model createModel() {
		 return ModelFactory.createDefaultModel();
	 }
	 protected Model createSecondModel() {
		 Model secondModel = ModelFactory.createDefaultModel();
		 secondModel.add(s2, p2, o2);
		 return secondModel;
	 }
	 private boolean shouldRead() {
		 return !securityEvaluator.isHardReadError() || securityEvaluator.evaluate(Action.Read);
	 }
	 public void setup() {
		 baseModel = createModel();
		 baseModel.removeAll();
		 baseModel.setNsPrefix(""foo"", ""http: securedModel = Factory.getInstance(securityEvaluator, ""http: s = ResourceFactory.createResource(""http: p = ResourceFactory.createProperty(""http: o = ResourceFactory.createResource(""http: baseModel.add(s, p, o);
		 p2 = ResourceFactory.createProperty(""http: baseModel.add(s, p2, ""yeehaw"");
		 baseModel.add(s, p2, ""yeehaw yall"", ""us"");
		 baseModel.add(s, p2, ""whohoo"", ""uk"");
	 s2 = ResourceFactory.createResource(""http: o2 = ResourceFactory.createResource(""http: }
	 private void __testAdd(Supplier<Model> addFunc) {
		 final Set<Action> createAndUpdate = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Update, Action.Create }
		);
		 try {
			 assertNotNull(addFunc.get());
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testAdd() throws Exception {
		 final List<Statement> stmt = baseModel.listStatements().toList();
		 __testAdd(() -> securedModel.add(stmt));
		 __testAdd(() -> securedModel.add(baseModel));
		 __testAdd(() -> securedModel.add(stmt.get(0)));
		 __testAdd(() -> securedModel.add(stmt.toArray(new Statement[stmt.size()])));
		 __testAdd(() -> securedModel.add(baseModel.listStatements()));
		 __testAdd(() -> securedModel.add(baseModel));
		 __testAdd(() -> securedModel.add(s, p, o));
		 __testAdd(() -> securedModel.add(s, p, ""foo""));
		 __testAdd(() -> securedModel.add(s, p, ""foo"", false));
		 __testAdd(() -> securedModel.add(s, p, ""foo"", XSDDatatype.XSDstring));
		 __testAdd(() -> securedModel.add(s, p, ""foo"", ""en""));
	 }
	 public void testAddLiteral() throws Exception {
		 __testAdd(() -> securedModel.addLiteral(s, p, true));
		 __testAdd(() -> securedModel.addLiteral(s, p, 'c'));
		 __testAdd(() -> securedModel.addLiteral(s, p, 2.0d));
		 __testAdd(() -> securedModel.addLiteral(s, p, 2.0f));
		 __testAdd(() -> securedModel.addLiteral(s, p, 5));
		 __testAdd(() -> securedModel.addLiteral(s, p, 5L));
		 __testAdd(() -> securedModel.addLiteral(s, p, new ArrayList<String>()));
		 __testAdd(() -> securedModel.addLiteral(s, p, baseModel.createLiteral(""Literal"")));
	 }
	 public void testAnonymousInModel() {
		 final RDFNode rdfNode = ResourceFactory.createResource();
		 final RDFNode rdfNode2 = rdfNode.inModel(securedModel);
		 Assert.assertEquals(""Should have placed RDFNode in secured securedModel"", securedModel, rdfNode2.getModel());
	 }
	 public void testAsRDFNode() {
		 RDFNode node = securedModel.asRDFNode(NodeFactory.createURI(""http: assertTrue(node.isResource());
		 assertEquals(securedModel, node.getModel());
		 if (securedModel.canRead()) {
		 assertEquals(""http: }
	 }
	 public void testAsStatement_Exists() {
		 Triple t = Triple.create(s.asNode(), p.asNode(), o.asNode());
		 try {
			 Statement stmt = securedModel.asStatement(t);
			 assertEquals(securedModel, stmt.getModel());
			 if (securedModel.canRead(t)) {
				 assertEquals(s, stmt.getSubject());
				 assertEquals(p, stmt.getPredicate());
				 assertEquals(o, stmt.getObject());
			 }
			 if (!securityEvaluator.evaluate(Action.Read) && !securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Read) && securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testAsStatement_NotExists() {
		 Triple t = Triple.create(s.asNode(), p2.asNode(), o.asNode());
		 try {
			 Statement stmt = securedModel.asStatement(t);
			 assertEquals(securedModel, stmt.getModel());
			 if (securedModel.canRead(t)) {
				 assertEquals(s, stmt.getSubject());
				 assertEquals(p2, stmt.getPredicate());
				 assertEquals(o, stmt.getObject());
			 }
			 if (!securityEvaluator.evaluate(Action.Read) && !securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 private void __testContains_true(Supplier<Boolean> supplier) {
		 try {
			 boolean result = supplier.get();
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertTrue(result);
			 }
			 else {
				 Assert.assertFalse(result);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 private void __testContains_false(Supplier<Boolean> supplier) {
		 try {
			 boolean result = supplier.get();
			 Assert.assertFalse(result);
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testContains() throws Exception {
		 final Statement stmt = baseModel.listStatements().next();
		 __testContains_true(() -> securedModel.contains(stmt));
		 __testContains_true(() -> securedModel.contains(s, p));
		 __testContains_true(() -> securedModel.contains(s, p, o));
		 __testContains_true(() -> securedModel.contains(s, p2, ""yeehaw""));
		 __testContains_true(() -> securedModel.contains(s, p2, ""whohoo"", ""uk""));
		 final Statement stmt2 = createSecondModel().listStatements().next();
		 __testContains_false(() -> securedModel.contains(stmt2));
		 __testContains_false(() -> securedModel.contains(s2, p));
		 __testContains_false(() -> securedModel.contains(s, p, o2));
		 __testContains_false(() -> securedModel.contains(s, p2, ""foo""));
		 __testContains_false(() -> securedModel.contains(s, p, ""whohoo"", ""fr""));
	 }
	 public void testContainsAll_Model() throws Exception {
		 try {
			 boolean result = securedModel.containsAll(baseModel);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertTrue(result);
			 }
			 else {
				 Assert.assertFalse(result);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 Model secondModel = createSecondModel();
			 secondModel.add(s, p, o);
			 boolean result = securedModel.containsAll(secondModel);
			 Assert.assertFalse(result);
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testContainsAll_Statements() throws Exception {
		 try {
			 boolean result = securedModel.containsAll(baseModel.listStatements());
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertTrue(result);
			 }
			 else {
				 Assert.assertFalse(result);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 Model secondModel = createSecondModel();
			 secondModel.add(s, p2, o);
			 boolean result = securedModel.containsAll(secondModel.listStatements());
			 Assert.assertFalse(result);
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateAlt() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createAlt();
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.createAlt(""foo"");
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateBag() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createBag();
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.createBag(""foo"");
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateList() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Update, Action.Create }
		);
		 final List<RDFNode> nodeList = new ArrayList<>();
		 try {
			 securedModel.createList();
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown UpdateDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown UpdateDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 baseModel.removeAll();
		 try {
			 securedModel.createList(nodeList.iterator());
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 baseModel.removeAll();
		 try {
			 final RDFNode[] list = new RDFNode[] {
			 ResourceFactory.createResource(), ResourceFactory.createResource(), ResourceFactory.createResource(), ResourceFactory.createResource(), }
			;
			 securedModel.createList(list);
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 baseModel.removeAll();
	 }
	 public void testCreateLiteral() throws Exception {
		 securedModel.createLiteral(""foo"");
		 securedModel.createLiteral(""foo"", false);
	 }
	 public void testCreateLiteralBoolean() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, true);
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateLiteralChar() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, 'a');
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateLiteralDouble() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, 1.0d);
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateLiteralFloat() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, 1.0f);
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateLiteralInt() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, 1);
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateLiteralLong() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, 1L);
			 if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testCreateLiteralObject() throws Exception {
		 final Set<Action> CU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Create, Action.Update }
		);
		 try {
			 securedModel.createLiteralStatement(s, p, new URL(""http: if (!securityEvaluator.evaluate(CU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(CU)) {
				 e.printStackTrace();
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testDifference() throws Exception {
		 try {
			 Model m = securedModel.difference(baseModel);
			 assertTrue(m.isEmpty());
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 Model secondModel = createSecondModel();
		 try {
			 Model m = securedModel.difference(secondModel);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertEquals(4, m.size());
				 assertTrue(m.contains(s, p, o));
				 assertEquals(""yeehaw"", m.getProperty(s, p2, """").getString());
				 assertEquals(""yeehaw yall"", m.getProperty(s, p2, ""us"").getString());
				 assertEquals(""whohoo"", m.getProperty(s, p2, ""uk"").getString());
			 }
			 else {
				 assertTrue(m.isEmpty());
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testEquals() throws Exception {
		 securedModel.equals(baseModel);
		 baseModel.equals(securedModel);
	 }
	 public void testGetAlt_Existing() throws Exception {
		 Resource r = baseModel.createAlt(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Bag.asNode());
		 try {
			 Alt alt = securedModel.getAlt(r);
			 assertEquals(securedModel, alt.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
		 try {
			 Alt alt = securedModel.getAlt(""http: assertEquals(securedModel, alt.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetAlt_ResourceNotExisting() throws Exception {
		 Resource r = ResourceFactory.createResource(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Alt.asNode());
		 try {
			 Alt alt = securedModel.getAlt(r);
			 assertEquals(securedModel, alt.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetAlt_StringNotExisting() throws Exception {
		 Resource r = ResourceFactory.createResource(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Alt.asNode());
		 try {
			 Alt alt = securedModel.getAlt(""http: assertEquals(securedModel, alt.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetAnyReifiedStmt_none() {
		 try {
			 Resource r = securedModel.getAnyReifiedStatement(baseModel.listStatements().next());
			 Assert.assertNotNull(r);
			 if (!securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(""Should have thrown UpdateDeniedException Exception"");
			 }
			 if (!securityEvaluator.evaluate(Action.Create)) {
				 Assert.fail(""Should have thrown AddDeniedException Exception"");
			 }
		 }
		 catch (final UpdateDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(String.format(""Should not have thrown UpdateDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 catch (final AddDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Create)) {
				 Assert.fail(String.format(""Should not have thrown AddDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testGetAnyReifiedStmt_one() {
		 final Statement st = baseModel.listStatements().next();
		 ReifiedStatement s = baseModel.createReifiedStatement(st);
		 try {
			 Resource r = securedModel.getAnyReifiedStatement(st);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertEquals(s.getURI(), r.getURI());
			 }
			 if (!securityEvaluator.evaluate(Action.Update) && !securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(""Should have thrown UpdateDeniedException Exception"");
			 }
			 if (!securityEvaluator.evaluate(Action.Create) && !securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(""Should have thrown AddDeniedException Exception"");
			 }
		 }
		 catch (final UpdateDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(String.format(""Should not have thrown UpdateDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 catch (final AddDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Create)) {
				 Assert.fail(String.format(""Should not have thrown AddDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testGetBag_Existing() {
		 final Resource r = baseModel.createBag(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Bag.asNode());
		 try {
			 Bag bag = securedModel.getBag(r);
			 assertEquals(securedModel, bag.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
		 try {
			 Bag bag = securedModel.getBag(""http: assertEquals(securedModel, bag.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetBag_ResourceNotExisting() throws Exception {
		 Resource r = ResourceFactory.createResource(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Bag.asNode());
		 try {
			 Bag bag = securedModel.getBag(r);
			 assertEquals(securedModel, bag.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetBag_StringNotExisting() throws Exception {
		 Resource r = ResourceFactory.createResource(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Bag.asNode());
		 try {
			 Bag bag = securedModel.getBag(""http: assertEquals(securedModel, bag.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetGraph() throws Exception {
		 final Graph g = securedModel.getGraph();
		 Assert.assertTrue(g instanceof SecuredGraph);
		 EqualityTester.testInequality(""getGraph test"", g, baseModel.getGraph());
	 }
	 public void testGetLock() {
		 securedModel.getLock();
	 }
	 private void __testGetProperty_exists(Supplier<Property> supplier) {
		 try {
			 Property prop = supplier.get();
			 assertEquals(p.getURI(), prop.getURI());
			 if (!securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 private void __testGetProperty_notExists(Supplier<Property> supplier) {
		 try {
			 Property actual = supplier.get();
			 Assert.assertEquals(""http: if (!securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testGetProperty_String() {
	 __testGetProperty_exists(() -> securedModel.getProperty(""http: }
	 public void testGetProperty_String_String() {
	 __testGetProperty_exists(() -> securedModel.getProperty(""http: }
	 public void testGetProperty_String_notExist() {
	 __testGetProperty_notExists(() -> securedModel.getProperty(""http: }
	 public void testGetProperty_String_String_notExist() {
	 __testGetProperty_notExists(() -> securedModel.getProperty(""http: }
	 public void testGetProperty_SP_exists() {
		 Statement expected = baseModel.getProperty(s, p);
		 try {
			 Statement actual = securedModel.getProperty(s, p);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertEquals(expected, actual);
			 }
			 else {
				 Assert.assertNull(actual);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testGetProperty_SP_notExists() {
		 try {
			 Statement actual = securedModel.getProperty(s2, p);
			 Assert.assertNull(actual);
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 private void __testGetProperty_lang(Supplier<Statement> supplier, String expected) {
		 try {
			 Statement stmt = supplier.get();
			 if (securityEvaluator.evaluate(Action.Read) && expected != null) {
				 assertNotNull(stmt);
				 assertEquals(expected, stmt.getObject().asLiteral().getString());
			 }
			 else {
				 assertNull(stmt);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testGetPropertyWithLang() {
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p2, """"), ""yeehaw"");
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p2, ""us""), ""yeehaw yall"");
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p2, ""uk""), ""whohoo"");
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p2, ""fr""), null);
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p, """"), null);
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p, ""us""), null);
		 __testGetProperty_lang(() -> securedModel.getProperty(s, p, ""uk""), null);
	 }
	 public void testGetPrefixMapping() throws Exception {
		 SecuredPrefixMappingTest.runTests(securityEvaluator, new Supplier<PrefixMapping>() {
			 public PrefixMapping get() {
				 setup();
				 return securedModel;
			 }
		 }
		, baseModel.getNsPrefixMap());
	 }
	 public void testGetRDFNode() {
		 RDFNode node = securedModel.getRDFNode(NodeFactory.createURI(""http: assertTrue(node.isResource());
		 assertEquals(securedModel, node.getModel());
		 if (securedModel.canRead()) {
		 assertEquals(""http: }
	 }
	 public void testGetReader() {
		 securedModel.getReader();
		 securedModel.getReader(""TURTLE"");
	 }
	 public void testGetResource() {
		 securedModel.getResource(""foo"");
	 }
	 public void testGetSeq_Existing() {
		 final Resource r = baseModel.createSeq(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Bag.asNode());
		 try {
			 Seq seq = securedModel.getSeq(r);
			 assertEquals(securedModel, seq.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
		 try {
			 Seq seq = securedModel.getSeq(""http: assertEquals(securedModel, seq.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetSeq_ResourceNotExisting() throws Exception {
		 Resource r = ResourceFactory.createResource(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Seq.asNode());
		 try {
			 Seq seq = securedModel.getSeq(r);
			 assertEquals(securedModel, seq.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetSeq_StringNotExisting() throws Exception {
		 Resource r = ResourceFactory.createResource(""http: Triple t = Triple.create(r.asNode(), RDF.type.asNode(), RDF.Seq.asNode());
		 try {
			 Seq seq = securedModel.getSeq(""http: assertEquals(securedModel, seq.getModel());
			 if (securedModel.canRead()) {
			 assertEquals(""http: }
			 else if (!securedModel.canUpdate() || !securedModel.canCreate(t)) {
				 fail(""Should have thrown AddDeniedException "");
			 }
		 }
		 catch (AddDeniedException e) {
			 if (securedModel.canUpdate() && securedModel.canCreate(t)) {
				 fail(String.format(""Should not have thrown AddDeniedException "", e));
			 }
		 }
	 }
	 public void testGetWriter() {
		 securedModel.getWriter();
		 securedModel.getWriter(""TURTLE"");
	 }
	 public void testIndependent() throws Exception {
		 Assert.assertFalse(securedModel.independent());
	 }
	 public void testIntersection() throws Exception {
		 try {
			 Model m = securedModel.intersection(baseModel);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertTrue(m.isIsomorphicWith(baseModel));
			 }
			 else {
				 assertTrue(m.isEmpty());
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 Model secondModel = createSecondModel();
		 try {
			 Model m = securedModel.intersection(secondModel);
			 assertTrue(m.isEmpty());
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 secondModel.add(s, p, o);
		 try {
			 Model m = securedModel.intersection(secondModel);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertTrue(m.contains(s, p, o));
				 assertEquals(1, m.size());
			 }
			 else {
				 assertTrue(m.isEmpty());
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testIsClosed() throws Exception {
		 securedModel.isClosed();
	 }
	 public void testIsEmpty() throws Exception {
		 try {
			 boolean actual = securedModel.isEmpty();
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertFalse(actual);
			 }
			 else {
				 Assert.assertTrue(actual);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 baseModel.removeAll();
		 try {
			 boolean actual = securedModel.isEmpty();
			 Assert.assertTrue(actual);
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testIsIsomorphicWith() {
		 try {
			 boolean result = securedModel.isIsomorphicWith(baseModel);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertTrue(result);
			 }
			 else {
				 Assert.assertFalse(result);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 boolean result = baseModel.isIsomorphicWith(securedModel);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertTrue(result);
			 }
			 else {
				 Assert.assertFalse(result);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testIsReified() {
		 Statement stmt = baseModel.listStatements().next();
		 try {
			 boolean actual = securedModel.isReified(stmt);
			 assertFalse(actual);
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 baseModel.createReifiedStatement(stmt);
		 try {
			 boolean actual = securedModel.isReified(stmt);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertTrue(actual);
			 }
			 else {
				 assertFalse(actual);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 private void __testListLiteralStatements(Supplier<StmtIterator> supplier) {
		 try {
			 StmtIterator iter = supplier.get();
			 assertNotNull(iter);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertTrue(iter.hasNext());
			 }
			 else {
				 assertFalse(iter.hasNext());
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testListLiteralStatements() throws Exception {
		 baseModel.addLiteral(s, p, true);
		 baseModel.addLiteral(s, p, '0');
		 baseModel.addLiteral(s, p, 2d);
		 baseModel.addLiteral(s, p, 2f);
		 baseModel.addLiteral(s, p, 1);
		 __testListLiteralStatements(() -> securedModel.listLiteralStatements(s, p, true));
		 __testListLiteralStatements(() -> securedModel.listLiteralStatements(s, p, '0'));
		 __testListLiteralStatements(() -> securedModel.listLiteralStatements(s, p, 2.0d));
		 __testListLiteralStatements(() -> securedModel.listLiteralStatements(s, p, 2.0f));
		 __testListLiteralStatements(() -> securedModel.listLiteralStatements(s, p, 1));
	 }
	 public void testLock() throws Exception {
		 try {
			 securedModel.lock();
			 if (!securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(""Should have thrown UpdateDeniedException Exception"");
			 }
		 }
		 catch (final UpdateDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Update)) {
				 Assert.fail(String.format(""Should not have thrown UpdateDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testPrefixMapping() throws Exception {
		 SecuredPrefixMappingTest.runTests(securityEvaluator, new Supplier<PrefixMapping>() {
			 public PrefixMapping get() {
				 setup();
				 return securedModel;
			 }
		 }
		, baseModel.getNsPrefixMap());
	 }
	 public void testQuery() throws Exception {
		 final Selector s = new SimpleSelector();
		 try {
			 Model model = securedModel.query(s);
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertTrue(model.isIsomorphicWith(baseModel));
			 }
			 else {
				 Assert.assertTrue(model.isEmpty());
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testRDFNodeInModel() {
		 final RDFNode rdfNode = ResourceFactory.createResource(""http: final RDFNode rdfNode2 = rdfNode.inModel(securedModel);
		 Assert.assertEquals(""Should have placed RDFNode in secured securedModel"", securedModel, rdfNode2.getModel());
	 }
	 public void testReadEmpty() throws Exception {
		 final Set<Action> createAndUpdate = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Update, Action.Create }
		);
		 final String XML_INPUT = ""<rdf:RDF"" + "" xmlns:rdf='http: + "" xmlns:rt='http: + "" <rdf:Description rdf:about='http: + "" <rdf:type rdf:resource='http: + ""</rdf:RDF>"";
		 final String TTL_INPUT = "" rt: <http: final String base = ""http: final String lang = ""TURTLE"";
		 try {
			 final URL url = SecuredModelTest.class.getResource(""./test.xml"");
			 securedModel.read(url.toString());
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
		 try {
			 final InputStream in = new ByteArrayInputStream(XML_INPUT.getBytes());
			 securedModel.read(in, base);
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
		 try {
			 final Reader reader = new StringReader(XML_INPUT);
			 securedModel.read(reader, base);
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
		 try {
			 final URL url = SecuredModelTest.class.getResource(""./test.ttl"");
			 securedModel.read(url.toString(), lang);
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
		 try {
			 final InputStream in = new ByteArrayInputStream(TTL_INPUT.getBytes());
			 securedModel.read(in, base, lang);
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
		 try {
			 final Reader reader = new StringReader(TTL_INPUT);
			 securedModel.read(reader, base, lang);
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
		 try {
			 final URL url = SecuredModelTest.class.getResource(""./test.ttl"");
			 securedModel.read(url.toString(), base, lang);
			 if (!securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(createAndUpdate)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 finally {
			 baseModel.removeAll();
		 }
	 }
	 public void testRemove() throws Exception {
		 final Set<Action> DU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Delete, Action.Update }
		);
		 final List<Statement> stmt = baseModel.listStatements().toList();
		 try {
			 securedModel.remove(baseModel.listStatements().toList());
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.remove(baseModel);
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.remove(stmt.get(0));
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.remove(stmt.toArray(new Statement[stmt.size()]));
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.remove(baseModel.listStatements());
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.remove(baseModel);
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 try {
			 securedModel.remove(s, p, o);
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testRemoveAll() throws Exception {
		 final Set<Action> DU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Delete, Action.Update }
		);
		 try {
			 securedModel.removeAll();
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 baseModel.add(s, p, o);
		 try {
			 securedModel.removeAll(s, p, o);
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testRemoveAllReifications() {
		 final Set<Action> DU = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Delete, Action.Update }
		);
		 final List<Statement> stmt = baseModel.listStatements().toList();
		 baseModel.createReifiedStatement(stmt.get(0));
		 try {
			 securedModel.removeAllReifications(stmt.get(0));
			 if (!securityEvaluator.evaluate(DU)) {
				 Assert.fail(""Should have thrown AccessDeniedException Exception"");
			 }
		 }
		 catch (final AccessDeniedException e) {
			 if (securityEvaluator.evaluate(DU)) {
				 Assert.fail(String.format(""Should not have thrown AccessDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testGetRequiredProperty() {
		 try {
			 securedModel.getRequiredProperty(s, p);
			 if (!securityEvaluator.evaluate(Action.Read)) {
				 if (securityEvaluator.isHardReadError()) {
					 fail(""Should have thrown ReadDeniedException Exception"");
				 }
				 fail(""Should have thrown PropertyNotFoundException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 catch (PropertyNotFoundException e) {
			 if (securityEvaluator.isHardReadError() || securedModel.canRead()) {
				 fail(""Should not have thrown PropertyNotFoundException"");
			 }
		 }
	 }
	 private void _testRequiredPropertyWithLang(Supplier<Statement> supplier, String expected) {
		 try {
			 Statement stmt = supplier.get();
			 assertNotNull(stmt);
			 if (securedModel.canRead()) {
				 assertEquals(expected, stmt.getObject().asLiteral().getString());
			 }
			 else {
				 if (securityEvaluator.isHardReadError()) {
					 fail(""Should have thrown ReadDeniedException Exception"");
				 }
				 fail(""Should have thrown PropertyNotFoundException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
		 catch (PropertyNotFoundException e) {
			 if (securityEvaluator.isHardReadError() || securedModel.canRead()) {
				 fail(""Should not have thrown PropertyNotFoundException"");
			 }
		 }
	 }
	 public void testGetRequiredPropertyWithLang() {
		 _testRequiredPropertyWithLang(() -> securedModel.getRequiredProperty(s, p2, """"), ""yeehaw"");
		 _testRequiredPropertyWithLang(() -> securedModel.getRequiredProperty(s, p2, ""us""), ""yeehaw yall"");
		 _testRequiredPropertyWithLang(() -> securedModel.getRequiredProperty(s, p2, ""uk""), ""whohoo"");
	 }
	 public void testSize() throws Exception {
		 try {
			 long size = securedModel.size();
			 if (securityEvaluator.evaluate(Action.Read)) {
				 Assert.assertEquals(4, size);
			 }
			 else {
				 Assert.assertEquals(0, size);
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testUnion_onLeft() throws Exception {
		 Model secondModel = createSecondModel();
		 try {
			 Model uModel = securedModel.union(secondModel);
			 assertTrue(uModel.contains(s2, p2, o2));
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertTrue(uModel.contains(s, p, o));
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testUnion_onRight() throws Exception {
		 Model secondModel = createSecondModel();
		 try {
			 Model uModel = secondModel.union(securedModel);
			 assertTrue(uModel.contains(s2, p2, o2));
			 if (securityEvaluator.evaluate(Action.Read)) {
				 assertTrue(uModel.contains(s, p, o));
			 }
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testVariableInModel() {
		 final RDFNode rdfNode = ResourceFactory.createTypedLiteral(""yeehaw2"");
		 final RDFNode rdfNode2 = rdfNode.inModel(securedModel);
		 Assert.assertEquals(""Should have placed RDFNode in secured securedModel"", securedModel, rdfNode2.getModel());
	 }
	 public void testWrapAsResource() throws Exception {
	 securedModel.wrapAsResource(NodeFactory.createURI(""http: }
	 private void __testWrite(Supplier<Model> supplier) {
		 try {
			 supplier.get();
			 if (!shouldRead()) {
				 Assert.fail(""Should have thrown ReadDeniedException Exception"");
			 }
		 }
		 catch (final ReadDeniedException e) {
			 if (shouldRead()) {
				 Assert.fail(String.format(""Should not have thrown ReadDeniedException Exception: %s - %s"", e, e.getTriple()));
			 }
		 }
	 }
	 public void testWrite_stream() throws Exception {
		 __testWrite(() -> securedModel.write(new ByteArrayOutputStream()));
	 }
	 public void testWrite_stream_lang() throws Exception {
		 __testWrite(() -> securedModel.write(new ByteArrayOutputStream(), ""TURTLE""));
	 }
	 public void testWrite_stream_lang_base() throws Exception {
	 __testWrite(() -> securedModel.write(new ByteArrayOutputStream(), ""TURTLE"", ""http: }
	 public void testWrite_writer() throws Exception {
		 __testWrite(() -> securedModel.write(new CharArrayWriter()));
	 }
	 public void testWrite_writer_lang() throws Exception {
		 __testWrite(() -> securedModel.write(new CharArrayWriter(), ""TURTLE""));
	 }
	 public void testWrite_writer_lang_base() throws Exception {
	 __testWrite(() -> securedModel.write(new CharArrayWriter(), ""TURTLE"", ""http: }
}",1,0,0,0
"protected void initializeOp(Configuration hconf) throws HiveException {
	 initDone = true;
	 super.initializeOp(hconf);
	 closeCalled = false;
	 this.firstFetchHappened = false;
	 this.inputFileChanged = false;
	 int maxAlias = 0;
	 for (byte pos = 0;
	 pos < order.length;
	 pos++) {
		 if (pos > maxAlias) {
			 maxAlias = pos;
		 }
	 }
	 maxAlias += 1;
	 nextGroupStorage = new RowContainer[maxAlias];
	 candidateStorage = new RowContainer[maxAlias];
	 keyWritables = new ArrayList[maxAlias];
	 nextKeyWritables = new ArrayList[maxAlias];
	 fetchDone = new boolean[maxAlias];
	 foundNextKeyGroup = new boolean[maxAlias];
	 int bucketSize;
	 int oldVar = HiveConf.getIntVar(hconf, HiveConf.ConfVars.HIVEMAPJOINBUCKETCACHESIZE);
	 if (oldVar != 100) {
		 bucketSize = oldVar;
	 }
	 else {
		 bucketSize = HiveConf.getIntVar(hconf, HiveConf.ConfVars.HIVESMBJOINCACHEROWS);
	 }
	 for (byte pos = 0;
	 pos < order.length;
	 pos++) {
		 RowContainer<List<Object>> rc = JoinUtil.getRowContainer(hconf, rowContainerStandardObjectInspectors[pos], pos, bucketSize,spillTableDesc, conf, !hasFilter(pos), reporter);
		 nextGroupStorage[pos] = rc;
		 RowContainer<List<Object>> candidateRC = JoinUtil.getRowContainer(hconf, rowContainerStandardObjectInspectors[pos], pos, bucketSize,spillTableDesc, conf, !hasFilter(pos), reporter);
		 candidateStorage[pos] = candidateRC;
	 }
	 tagToAlias = conf.convertToArray(conf.getTagToAlias(), String.class);
	 for (byte pos = 0;
	 pos < order.length;
	 pos++) {
		 if (pos != posBigTable) {
			 fetchDone[pos] = false;
		 }
		 foundNextKeyGroup[pos] = false;
	 }
 }",0,0,1,0
"public void initClassDefaults(UIDefaults table) {
	super.initClassDefaults(table);
	table.putDefaults(new Object[] {
	 ""ButtonUI"", XDMButtonUI.class.getName(), ""ScrollBarUI"",XDMScrollBarUI.class.getName(), ""MenuItemUI"", XDMMenuItemUI.class.getName(), ""MenuUI"",XDMMenuUI.class.getName(), ""CheckBoxMenuItemUI"", XDMMenuItemUI.class.getName(), ""TreeUI"",XDMTreeUI.class.getName(), ""SpinnerUI"", XDMSpinnerUI.class.getName(), ""ProgressBarUI"",XDMProgressBarUI.class.getName(), ""ComboBoxUI"", XDMComboBoxUI.class.getName() }
	);
	System.setProperty(""xdm.defaulttheme"", ""true"");
	UIManager.put(""Table.focusCellHighlightBorder"", new EmptyBorder(1, 1, 1, 1));
	UIManager.put(""ComboBox.rendererUseListColors"", Boolean.TRUE);
}",0,0,1,0
"int loadFSEdits( Configuration conf ) throws IOException {
	 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
	 FSDirectory fsDir = fsNamesys.dir;
	 int numEdits = 0;
	 int logVersion = 0;
	 Vector<File> files = new Vector<File>();
	 for (int idx = 0;
	 idx < editFiles.length;
	 idx++) {
		 if (editFiles[idx].exists()) {
			 files.add(editFiles[idx]);
		 }
	 }
	 long maxLength = Long.MIN_VALUE;
	 File edits = null;
	 for (Iterator<File> it = files.iterator();
	 it.hasNext();
	) {
		 File f = it.next();
		 long length = f.length();
		 if (length > maxLength) {
			 maxLength = length;
			 edits = f;
		 }
	 }
	 if (edits != null) {
		 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(edits)));
		 in.mark( 4 );
		 boolean available = true;
		 try {
			 logVersion = in.readByte();
		 }
		 catch (EOFException e) {
			 available = false;
		 }
		 if (available) {
			 in.reset();
			 if( logVersion >= 0 ) logVersion = 0;
			 else logVersion = in.readInt();
			 if( logVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IOException( ""Unexpected version of the file system log file: "" + logVersion + "". Current version = "" + FSConstants.DFS_CURRENT_VERSION + ""."" );
		 }
		 short replication = (short)conf.getInt(""dfs.replication"", 3);
		 try {
			 while (true) {
				 byte opcode = -1;
				 try {
					 opcode = in.readByte();
				 }
				 catch (EOFException e) {
					 break;
				 }
				 numEdits++;
				 switch (opcode) {
					 case OP_ADD: {
						 UTF8 name = new UTF8();
						 ArrayWritable aw = null;
						 Writable writables[];
						 if( logVersion >= 0 ) name.readFields(in);
						 else {
							 aw = new ArrayWritable(UTF8.class);
							 aw.readFields(in);
							 writables = aw.get();
							 if( writables.length != 2 ) throw new IOException(""Incorrect data fortmat. "" + ""Name & replication pair expected"");
							 name = (UTF8) writables[0];
							 replication = Short.parseShort( ((UTF8)writables[1]).toString());
							 replication = adjustReplication( replication, conf );
						 }
						 aw = new ArrayWritable(Block.class);
						 aw.readFields(in);
						 writables = aw.get();
						 Block blocks[] = new Block[writables.length];
						 System.arraycopy(writables, 0, blocks, 0, blocks.length);
						 fsDir.unprotectedAddFile(name, blocks, replication );
						 break;
					 }
					 case OP_SET_REPLICATION: {
						 UTF8 src = new UTF8();
						 UTF8 repl = new UTF8();
						 src.readFields(in);
						 repl.readFields(in);
						 replication = adjustReplication( fromLogReplication(repl), conf);
						 fsDir.unprotectedSetReplication(src.toString(), replication, null);
						 break;
					 }
					 case OP_RENAME: {
						 UTF8 src = new UTF8();
						 UTF8 dst = new UTF8();
						 src.readFields(in);
						 dst.readFields(in);
						 fsDir.unprotectedRenameTo(src, dst);
						 break;
					 }
					 case OP_DELETE: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedDelete(src);
						 break;
					 }
					 case OP_MKDIR: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedMkdir(src.toString());
						 break;
					 }
					 case OP_DATANODE_ADD: {
						 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
						 DatanodeDescriptor node = new DatanodeDescriptor();
						 node.readFields(in);
						 fsNamesys.unprotectedAddDatanode( node );
						 break;
					 }
					 case OP_DATANODE_REMOVE: {
						 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
						 DatanodeID nodeID = new DatanodeID();
						 nodeID.readFields(in);
						 DatanodeDescriptor node = fsNamesys.getDatanode( nodeID );
						 if( node != null ) {
							 fsNamesys.unprotectedRemoveDatanode( node );
							 fsNamesys.wipeDatanode( nodeID );
						 }
						 break;
					 }
					 default: {
						 throw new IOException(""Never seen opcode "" + opcode);
					 }
				 }
			 }
		 }
		 finally {
			 in.close();
		 }
	 }
	 if( logVersion != FSConstants.DFS_CURRENT_VERSION ) numEdits++;
	 return numEdits;
 }",0,0,1,0
"public static class PartnerLinkRef extends OBase implements RValue, LValue, Serializable {
	 public static final long serialVersionUID = -1L;
	 private static final String PARTNERLINK = ""partnerLink"";
	 private static final String ISMYENDPOINTREFERENCE = ""isMyEndpointReference"";
	 public PartnerLinkRef() {
		 setIsMyEndpointReference(false);
	 }
	 public PartnerLinkRef(OProcess owner) {
		 super(owner);
		 setIsMyEndpointReference(false);
	 }
	 public boolean isIsMyEndpointReference() {
		 Object o = fieldContainer.get(ISMYENDPOINTREFERENCE);
		 return o == null ? false : (Boolean) o;
	 }
	 public OPartnerLink getPartnerLink() {
		 Object o = fieldContainer.get(PARTNERLINK);
		 return o == null ? null : (OPartnerLink) o;
	 }
	 public Variable getVariable() {
		 return null;
	 }
	 public void setIsMyEndpointReference(boolean isMyEndpointReference) {
		 fieldContainer.put(ISMYENDPOINTREFERENCE, isMyEndpointReference);
	 }
	 public void setPartnerLink(OPartnerLink partnerLink) {
		 fieldContainer.put(PARTNERLINK, partnerLink);
	 }
	 public String toString() {
		 return ""{
		PLinkRef "" + getPartnerLink() + ""!"" + isIsMyEndpointReference() + ""}
		"";
	 }
 }",1,1,0,0
"public ParsingException(int line, int column, String msg);",0,0,0,0
"public static class DeleteTasksBenchmark {
	 private StateManager manager;
	 private Storage storage;
	 private Set<String> taskIds;
	 private int numTasksToDelete;
	 public void setUpStorage() {
		 Injector injector = getInjector();
		 manager = injector.getInstance(StateManager.class);
		 storage = injector.getInstance(Storage.class);
		 storage.prepare();
	 }
	 public void setUp() {
		 storage.write(new Storage.MutateWork.NoResult.Quiet() {
			 public void execute(Storage.MutableStoreProvider storeProvider) throws RuntimeException {
				 taskIds = bulkInsertTasks(numTasksToDelete, storeProvider.getUnsafeTaskStore());
			 }
		 }
		);
	 }
	 public Set<String> run() {
		 return storage.write((Storage.MutateWork.Quiet<Set<String>>) storeProvider -> {
			 manager.deleteTasks(storeProvider, taskIds);
			 return taskIds;
		 }
		);
	 }
 }",1,0,0,0
"public final class MoreStrings {
	 private MoreStrings() {
	}
	 public static String linesToText(String... lines) {
		 return String.join(System.lineSeparator(), lines);
	 }
	 public static boolean isEmpty(CharSequence sequence) {
		 return sequence.length() == 0;
	 }
	 public static String withoutSuffix(String str, String suffix) {
		 Preconditions.checkArgument(str.endsWith(suffix), ""%s must end with %s"", str, suffix);
		 return str.substring(0, str.length() - suffix.length());
	 }
	 public static String capitalize(String str) {
		 if (!str.isEmpty()) {
			 return str.substring(0, 1).toUpperCase() + str.substring(1);
		 }
		 else {
			 return """";
		 }
	 }
	 public static int getLevenshteinDistance(String str1, String str2) {
		 if (str1.length() < str2.length()) {
			 return getLevenshteinDistance(str2, str1);
		 }
		 int previous = 0;
		 int[][] levenshteinDist = new int[2][str2.length() + 1];
		 for (int j = 0;
		 j <= str2.length();
		 j++) {
			 levenshteinDist[previous][j] = j;
		 }
		 for (int i = 1;
		 i <= str1.length();
		 i++, previous = 1 - previous) {
			 int current = 1 - previous;
			 levenshteinDist[current][0] = i;
			 for (int j = 1;
			 j <= str2.length();
			 j++) {
				 if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
					 levenshteinDist[current][j] = levenshteinDist[previous][j - 1];
				 }
				 else {
					 levenshteinDist[current][j] = Math.min( levenshteinDist[previous][j], Math.min(levenshteinDist[current][j - 1], levenshteinDist[previous][j - 1])) + 1;
				 }
			 }
		 }
		 return levenshteinDist[previous][str2.length()];
	 }
	 public static String regexPatternForAny(String... values) {
		 return regexPatternForAny(Arrays.asList(values));
	 }
	 public static String regexPatternForAny(Iterable<String> values) {
		 return ""((?:"" + Joiner.on("")|(?:"").join(values) + ""))"";
	 }
	 public static boolean endsWithIgnoreCase(String str, String suffix) {
		 if (str.length() < suffix.length()) {
			 return false;
		 }
		 return str.substring(str.length() - suffix.length()).equalsIgnoreCase(suffix);
	 }
	 public static Optional<String> stripPrefix(String s, String prefix) {
		 return s.startsWith(prefix) ? Optional.of(s.substring(prefix.length())) : Optional.empty();
	 }
	 public static Optional<String> stripSuffix(String s, String suffix) {
		 return s.endsWith(suffix) ? Optional.of(s.substring(0, s.length() - suffix.length())) : Optional.empty();
	 }
	 public static String truncatePretty(String data) {
		 int keepFirstChars = 10000;
		 int keepLastChars = 10000;
		 String truncateMessage = ""...\n<truncated>\n..."";
		 return truncateMiddle(data, keepFirstChars, keepLastChars, truncateMessage);
	 }
	 public static String truncateMiddle( String data, int keepFirstChars, int keepLastChars, String truncateMessage) {
		 if (data.length() <= keepFirstChars + keepLastChars + truncateMessage.length()) {
			 return data;
		 }
		 return data.substring(0, keepFirstChars) + truncateMessage + data.substring(data.length() - keepLastChars);
	 }
	 public static ImmutableList<String> lines(String data) throws IOException {
		 return CharSource.wrap(data).readLines();
	 }
	 public static int compareStrings(String a, String b) {
		 if (a == b) {
			 return 0;
		 }
		 return a.compareTo(b);
	 }
	 public static List<String> getSpellingSuggestions( String input, Collection<String> options, int maxDistance) {
		 return options .stream() .map(option -> new Pair<>(option, MoreStrings.getLevenshteinDistance(input, option))) .filter(pair -> pair.getSecond() <= maxDistance) .sorted(Comparator.comparing(Pair::getSecond)) .map(Pair::getFirst) .collect(ImmutableList.toImmutableList());
	 }
	 public static String replaceCR(String text) {
		 return text.replace(""\r\n"", ""\n"").replace('\r', '\n');
	 }
}",0,0,0,0
"class Unparser {
	 static private Property LI = new PropertyImpl(RDF.getURI(), ""li"");
	 static private Property DESCRIPTION = new PropertyImpl(RDF.getURI(), ""Description"");
	 static protected Logger logger = LoggerFactory.getLogger(Unparser.class);
	 Unparser(RDFXML_Abbrev parent, String outputName, Model m, PrintWriter w) {
		 setOutputName(outputName);
		 prettyWriter = parent;
		 out = w;
		 model = m;
		 addTypeNameSpaces();
		 objectTable = new HashMap<>();
		 StmtIterator ss = m.listStatements();
		 try {
			 while (ss.hasNext()) {
				 Statement s = ss.nextStatement();
				 RDFNode rn = s.getObject();
				 if (rn instanceof Resource) {
					 increaseObjectCount((Resource) rn);
				 }
			 }
		 }
		 finally {
			 ss.close();
		 }
		 try {
			 res2statement = new HashMap<>();
			 statement2res = new HashMap<>();
			 ClosableIterator<Resource> reified = new MapFilterIterator<>(new MapFilter<Resource, Resource>() {
				 public Resource accept(Resource o) {
					 Resource r = o;
					 return (r.hasProperty(RDF.subject) && r.hasProperty(RDF.object) && r .hasProperty(RDF.predicate)) ? r : null;
				 }
			 }
			, model.listResourcesWithProperty(RDF.type, RDF.Statement));
			 while (reified.hasNext()) {
				 Resource r = reified.next();
				 try {
					 Statement subj = r.getRequiredProperty(RDF.subject);
					 Statement pred = r.getRequiredProperty(RDF.predicate);
					 Statement obj = r.getRequiredProperty(RDF.object);
					 RDFNode nobj = obj.getObject();
					 Resource rsubj = (Resource) subj.getObject();
					 Resource rpred = (Resource) pred.getObject();
					 Property ppred = model.createProperty(rpred.getURI());
					 Statement statement = model.createStatement(rsubj, ppred, nobj);
					 res2statement.put(r, statement);
					 statement2res.put(statement, r);
				 }
				 catch (Exception ignored) {
				 }
			 }
		 }
		 finally {
			 ss.close();
		 }
	 }
	 private void setOutputName(String uri) {
		 if (uri == null || uri.equals("""")) {
			 outputName = """";
			 return;
		 }
		 IRIx u = IRIx.create(uri);
		 u = u.resolve("""");
		 outputName = u.str();
	 }
	 void write() {
		 prettyWriter.workOutNamespaces();
		 wRDF();
	 }
	 void setTopLevelTypes(Resource types[]) {
		 pleasingTypes = types;
		 pleasingTypeSet = new HashSet<>(Arrays.asList(types));
	 }
	 private String xmlBase;
	 void setXMLBase(String b) {
		 xmlBase = b;
	 }
	 final private static String rdfns = RDF.type.getNameSpace();
	 final private static Integer one = 1;
	 private String outputName;
	 private Map<Resource, Integer> objectTable;
	 private Model model;
	 private PrintWriter out;
	 private Set<Resource> doing = new HashSet<>();
	 private Set<Statement> doneSet = new HashSet<>();
	 private Set<Resource> haveReified = new HashSet<>();
	 private Resource pleasingTypes[] = null;
	 private Set<Resource> pleasingTypeSet = new HashSet<>();
	 final private RDFXML_Abbrev prettyWriter;
	 private boolean avoidExplicitReification = true;
	 Map<Resource, Statement> res2statement;
	 Map<Statement, Resource> statement2res;
	 private void wRDF() {
		 tab();
		 print(""<"");
		 print(prettyWriter.rdfEl(""RDF""));
		 indentPlus();
		 printNameSpaceDefn();
		 if (xmlBase != null) {
			 setOutputName(xmlBase);
			 tab();
			 print(""xml:base="" + quote(xmlBase));
		 }
		 print("">"");
		 wObjStar();
		 indentMinus();
		 tab();
		 print(""</"");
		 print(prettyWriter.rdfEl(""RDF""));
		 print("">"");
		 tab();
	 }
	 private void wObjStar() {
		 Iterator<Resource> rs = listSubjects();
		 while (rs.hasNext()) {
			 Resource r = rs.next();
			 increaseObjectCount(r);
			 wObj(r, true);
		 }
		 closeAllResIterators();
	 }
	 private boolean wPropertyElt(WType wt, Property prop, Statement s, RDFNode val) {
		 return wPropertyEltCompact(wt, prop, s, val) || wPropertyEltCollection(wt, prop, s, val) || wPropertyEltLiteral(wt, prop, s, val) || wPropertyEltResource(wt, prop, s, val) || wPropertyEltDatatype(wt, prop, s, val) || wPropertyEltValue(wt, prop, s, val);
	 }
	 private boolean wPropertyEltCompact(WType wt, Property prop, Statement s, RDFNode val) {
		 if (!(val instanceof Resource)) return false;
		 Resource r = (Resource) val;
		 if (!(allPropsAreAttr(r) || doing.contains(r))) return false;
		 if ((!hasProperties(r)) && isGenuineAnon(r)) return false;
		 done(s);
		 tab();
		 print(""<"");
		 wt.wTypeStart(prop);
		 indentPlus();
		 wIdRefAttrOpt(s, r);
		 if (!doing.contains(r)) {
			 wPropAttrAll(r);
		 }
		 else if (isGenuineAnon(r)) {
			 error(""Genuine anon resource in cycle?"");
		 }
		 indentMinus();
		 print(""/>"");
		 return true;
	 }
	 private boolean wPropertyEltLiteral(WType wt, Property prop, Statement s, RDFNode r) {
		 if (prettyWriter.sParseTypeLiteralPropertyElt) return false;
		 if (!((r instanceof Literal) && ((Literal) r).isWellFormedXML())) {
			 return false;
		 }
		 done(s);
		 tab();
		 print(""<"");
		 wt.wTypeStart(prop);
		 wIdAttrReified(s);
		 maybeNewline();
		 wParseLiteral();
		 maybeNewline();
		 print("">"");
		 print(((Literal) r).getLexicalForm());
		 print(""</"");
		 wt.wTypeEnd(prop);
		 print("">"");
		 return true;
	 }
	 private boolean wPropertyEltDatatype(WType wt, Property prop, Statement s, RDFNode r) {
		 if (! (r instanceof Literal) ) return false ;
		 Literal lit = ((Literal) r) ;
		 if ( Util.isSimpleString(lit) ) return false;
		 if ( Util.isLangString(lit) ) return false;
		 done(s);
		 tab();
		 print(""<"");
		 wt.wTypeStart(prop);
		 wIdAttrReified(s);
		 maybeNewline();
		 wDatatype(((Literal) r).getDatatypeURI());
		 maybeNewline();
		 print("">"");
		 print(Util.substituteEntitiesInElementContent(((Literal) r) .getLexicalForm()));
		 print(""</"");
		 wt.wTypeEnd(prop);
		 print("">"");
		 return true;
	 }
	 private boolean wPropertyEltResource(WType wt, Property prop, Statement s, RDFNode r) {
		 if (prettyWriter.sParseTypeResourcePropertyElt) return false;
		 if (r instanceof Literal) return false;
		 Resource res = (Resource) r;
		 if (!isGenuineAnon(res)) return false;
		 if (getType(res) != null) return false;
		 done(s);
		 tab();
		 print(""<"");
		 wt.wTypeStart(prop);
		 indentPlus();
		 wIdAttrReified(s);
		 wParseResource();
		 print("">"");
		 wPropertyEltStar(res);
		 indentMinus();
		 tab();
		 print(""</"");
		 wt.wTypeEnd(prop);
		 print("">"");
		 return true;
	 }
	 private boolean wPropertyEltValue(WType wt, Property prop, Statement s, RDFNode r) {
		 return wPropertyEltValueString(wt, prop, s, r) || wPropertyEltValueObj(wt, prop, s, r);
	 }
	 private boolean wPropertyEltValueString(WType wt, Property prop, Statement s, RDFNode r) {
		 if (r instanceof Literal) {
			 done(s);
			 Literal lt = (Literal) r;
			 String lang = lt.getLanguage();
			 tab();
			 print(""<"");
			 wt.wTypeStart(prop);
			 wIdAttrReified(s);
			 maybeNewline();
			 if (lang != null && lang.length() > 0) print("" xml:lang="" + q(lang));
			 maybeNewline();
			 print("">"");
			 wValueString(lt);
			 print(""</"");
			 wt.wTypeEnd(prop);
			 print("">"");
			 return true;
		 }
		 return false;
	 }
	 private void wValueString(Literal lt) {
		 String val = lt.getString();
		 print(Util.substituteEntitiesInElementContent(val));
	 }
	 private boolean wPropertyEltValueObj(WType wt, Property prop, Statement s, RDFNode r) {
		 if (r instanceof Resource && !prettyWriter.sResourcePropertyElt) {
			 Resource res = (Resource) r;
			 done(s);
			 tab();
			 print(""<"");
			 wt.wTypeStart(prop);
			 wIdAttrReified(s);
			 print("">"");
			 tab();
			 indentPlus();
			 wObj(res, false);
			 indentMinus();
			 tab();
			 print(""</"");
			 wt.wTypeEnd(prop);
			 print("">"");
			 return true;
		 }
		 return false;
	 }
	 private boolean wPropertyEltCollection(WType wt, Property prop, Statement s, RDFNode r) {
		 Statement list[][] = getRDFList(r);
		 if (list == null) return false;
		 done(s);
		 for ( Statement[] aList1 : list ) {
			 done( aList1[0] );
			 done( aList1[1] );
		 }
		 tab();
		 print(""<"");
		 wt.wTypeStart(prop);
		 indentPlus();
		 wIdAttrReified(s);
		 wParseCollection();
		 print("">"");
		 for ( Statement[] aList : list ) {
			 wObj( (Resource) aList[0].getObject(), false );
		 }
		 indentMinus();
		 tab();
		 print(""</"");
		 wt.wTypeEnd(prop);
		 print("">"");
		 return true;
	 }
	 private void wPropAttrAll(Resource r) {
		 wPropAttrSome(r);
		 if (hasProperties(r)) error(""Bad call to wPropAttrAll"");
	 }
	 private void wPropAttrSome(Resource r) {
		 ClosableIterator<Statement> ss = listProperties(r);
		 try {
			 Set<Property> seen = new HashSet<>();
			 while (ss.hasNext()) {
				 Statement s = ss.next();
				 if (canBeAttribute(s, seen)) {
					 done(s);
					 wPropAttr(s.getPredicate(), s.getObject());
				 }
			 }
		 }
		 finally {
			 ss.close();
		 }
	 }
	 private boolean wObj(Resource r, boolean topLevel) {
		 try {
			 doing.add(r);
			 Statement typeStatement = getType(r);
			 if (typeStatement != null) {
				 Resource t = typeStatement.getResource();
				 if (!topLevel) {
					 if (pleasingTypeSet.contains(t) && (!isGenuineAnon(r))) {
						 return wTypedNodeNoProperties(r);
					 }
				 }
				 return wTypedNode(r) || wDescription(r);
			 }
			 return wDescription(r);
		 }
		 finally {
			 doing.remove(r);
		 }
	 }
	 abstract private class WType {
		 abstract void wTypeStart(Resource uri);
		 abstract void wTypeEnd(Resource uri);
	 }
	 static private int RDF_HASH = RDF.getURI().length();
	 private WType wdesc = new WType() {
		 void wTypeStart(Resource u) {
			 print(prettyWriter.rdfEl(u.getURI().substring(RDF_HASH)));
		 }
		 void wTypeEnd(Resource u) {
			 print(prettyWriter.rdfEl(u.getURI().substring(RDF_HASH)));
		 }
	 }
	;
	 private WType wtype = new WType() {
		 void wTypeStart(Resource u) {
			 print(prettyWriter.startElementTag(u.getURI()));
		 }
		 void wTypeEnd(Resource u) {
			 print(prettyWriter.endElementTag(u.getURI()));
		 }
	 }
	;
	 private boolean wDescription(Resource r) {
		 return wTypedNodeOrDescription(wdesc, DESCRIPTION, r);
	 }
	 private boolean wTypedNode(Resource r) {
		 Statement st = getType(r);
		 if (st == null) return false;
		 Resource type = st.getResource();
		 done(st);
		 return wTypedNodeOrDescription(wtype, type, r);
	 }
	 private boolean wTypedNodeOrDescription(WType wt, Resource ty, Resource r) {
		 Vector<Statement> found = new Vector<>();
		 ClosableIterator<Statement> ss = listProperties(r);
		 try {
			 int greatest = 0;
			 if (!prettyWriter.sListExpand) while (ss.hasNext()) {
				 Statement s = ss.next();
				 int ix = s.getPredicate().getOrdinal();
				 if (ix != 0) {
					 if (ix > greatest) {
						 found.setSize(ix);
						 greatest = ix;
					 }
					 found.set(ix - 1, s);
				 }
			 }
		 }
		 finally {
			 ss.close();
		 }
		 int last = found.indexOf(null);
		 List<Statement> li = last == -1 ? found : found.subList(0, last);
		 return wTypedNodeOrDescriptionCompact(wt, ty, r, li) || wTypedNodeOrDescriptionLong(wt, ty, r, li);
	 }
	 private boolean wTypedNodeOrDescriptionCompact(WType wt, Resource ty, Resource r, List<Statement> li) {
		 if ((!li.isEmpty()) || !allPropsAreAttr(r)) return false;
		 tab();
		 print(""<"");
		 wt.wTypeStart(ty);
		 indentPlus();
		 wIdAboutAttrOpt(r);
		 wPropAttrAll(r);
		 print(""/>"");
		 indentMinus();
		 return true;
	 }
	 private boolean wTypedNodeNoProperties(Resource r) {
		 if (isGenuineAnon(r)) return false;
		 Statement st = getType(r);
		 if (st == null) return false;
		 Resource type = st.getResource();
		 done(st);
		 tab();
		 print(""<"");
		 wtype.wTypeStart(type);
		 indentPlus();
		 wIdAboutAttrOpt(r);
		 print(""/>"");
		 indentMinus();
		 return true;
	 }
	 private boolean wTypedNodeOrDescriptionLong(WType wt, Resource ty, Resource r, List<Statement> li) {
		 Iterator<Statement> it = li.iterator();
		 while (it.hasNext()) {
			 done(it.next());
		 }
		 tab();
		 print(""<"");
		 wt.wTypeStart(ty);
		 indentPlus();
		 wIdAboutAttrOpt(r);
		 wPropAttrSome(r);
		 print("">"");
		 wLiEltStar(li.iterator());
		 wPropertyEltStar(r);
		 indentMinus();
		 tab();
		 print(""</"");
		 wt.wTypeEnd(ty);
		 print("">"");
		 return true;
	 }
	 private void wPropertyEltStar(Resource r) {
		 ClosableIterator<Statement> ss = this.listProperties(r);
		 try {
			 while (ss.hasNext()) {
				 Statement s = ss.next();
				 wPropertyElt(wtype, s.getPredicate(), s, s.getObject());
			 }
		 }
		 finally {
			 ss.close();
		 }
	 }
	 private void wLiEltStar(Iterator<Statement> ss) {
		 while (ss.hasNext()) {
			 Statement s = ss.next();
			 wPropertyElt(wdesc, LI, s, s.getObject());
		 }
	 }
	 private Set<Resource> idDone = new HashSet<>();
	 private boolean wIdAboutAttrOpt(Resource r) {
		 return wIdAttrOpt(r) || wNodeIDAttr(r) || wAboutAttr(r);
	 }
	 private boolean wIdAttrOpt(Resource r) {
		 if (isGenuineAnon(r)) return true;
		 if (prettyWriter.sIdAttr) return false;
		 if (r.isAnon()) return false;
		 if (isLocalReference(r)) {
			 if (wantReification(r)) return false;
			 if (idDone.contains(r)) {
				 return false;
			 }
			 idDone.add(r);
			 print("" "");
			 printRdfAt(""ID"");
			 print(""="");
			 print(quote(getXMLLocalName(r)));
			 return true;
		 }
		 return false;
	 }
	 private boolean wAboutAttr(Resource r) {
		 print("" "");
		 printRdfAt(""about"");
		 print(""="");
		 wURIreference(r);
		 return true;
	 }
	 private void wURIreference(String s) {
		 print(quote(prettyWriter.relativize(s)));
	 }
	 private void wURIreference(Resource r) {
		 wURIreference(r.getURI());
	 }
	 private void wIdRefAttrOpt(Statement s, Resource r) {
		 wIdAttrReified(s);
		 if (!isGenuineAnon(r)) {
			 wResourceNodeIDAttr(r);
		 }
	 }
	 private void wIdAttrReified(Statement s) {
		 if (wantReification(s)) {
			 Statement reify[] = reification(s);
			 Resource res = statement2res.get(s);
			 idDone.add(res);
			 int i;
			 for (i = 0;
			 i < reify.length;
			 i++) done(reify[i]);
			 print("" "");
			 printRdfAt(""ID"");
			 print(""="");
			 print(quote(getXMLLocalName(res)));
			 haveReified.add(res);
		 }
	 }
	 private boolean wResourceNodeIDAttr(Resource r) {
		 return wNodeIDAttr(r) || wResourceAttr(r);
	 }
	 private boolean wNodeIDAttr(Resource r) {
		 if (!r.isAnon()) return false;
		 print("" "");
		 printRdfAt(""nodeID"");
		 print(""="");
		 print(q(prettyWriter.anonId(r)));
		 return true;
	 }
	 private boolean wResourceAttr(Resource r) {
		 if (r.isAnon()) return false;
		 print("" "");
		 printRdfAt(""resource"");
		 print(""="");
		 wURIreference(r);
		 return true;
	 }
	 int codeCoverage[] = new int[8];
	 private void wQNameAttr(Property p) {
		 print(prettyWriter.attributeTag(p.getURI()));
	 }
	 private void printRdfAt(String s) {
		 print(prettyWriter.rdfAt(s));
	 }
	 private void wPropAttr(Property p, RDFNode n) {
		 tab();
		 if (p.equals(RDF.type)) wTypeAttr((Resource) n);
		 else wPropAttrString(p, (Literal) n);
	 }
	 private void wTypeAttr(Resource r) {
		 print("" "");
		 printRdfAt(""type"");
		 print(""="");
		 wURIreference(r);
	 }
	 private void wPropAttrString(Property p, Literal l) {
		 print("" "");
		 wQNameAttr(p);
		 print(""="" + quote(l.getLexicalForm())) ;
	 }
	 private void wParseCollection() {
		 print("" "");
		 printRdfAt(""parseType"");
		 print(""="" + q(""Collection""));
	 }
	 private void wParseLiteral() {
		 print("" "");
		 printRdfAt(""parseType"");
		 print(""="" + q(""Literal""));
	 }
	 private void wDatatype(String dtURI) {
		 print("" "");
		 printRdfAt(""datatype"");
		 print(""="");
		 maybeNewline();
		 wURIreference(dtURI);
	 }
	 private void wParseResource() {
		 print("" "");
		 printRdfAt(""parseType"");
		 print(""="" + q(""Resource""));
	 }
	 private void printNameSpaceDefn() {
		 print(prettyWriter.xmlnsDecl());
	 }
	 private int indentLevel = 0;
	 private int currentColumn = 0;
	 static private String filler(int lgth) {
		 char rslt[] = new char[lgth];
		 Arrays.fill(rslt, ' ');
		 return new String(rslt);
	 }
	 private void tab() {
		 int desiredColumn = prettyWriter.tabSize * indentLevel;
		 if (desiredColumn > prettyWriter.width) {
			 desiredColumn = 4 + (desiredColumn - 4) % prettyWriter.width;
		 }
		 if ((desiredColumn == 0 && currentColumn == 0) || desiredColumn > currentColumn) {
			 String spaces = filler(desiredColumn - currentColumn);
			 out.print(spaces);
		 }
		 else {
			 out.println();
			 out.print(filler(desiredColumn));
		 }
		 currentColumn = desiredColumn;
	 }
	 private void maybeNewline() {
		 if (currentColumn > prettyWriter.width) {
			 tab();
		 }
	 }
	 private String quote( String str ) {
		 return prettyWriter.substitutedAttribute(str);
	 }
	 private String q(String str) {
		 return prettyWriter.attributeQuoted(str);
	 }
	 private void print(String s) {
		 out.print(s);
		 int ix = s.lastIndexOf('\n');
		 if (ix == -1) currentColumn += s.length();
		 else currentColumn = s.length() - ix - 1;
	 }
	 private void indentPlus() {
		 indentLevel++;
	 }
	 private void indentMinus() {
		 indentLevel--;
	 }
	 private void error(String msg) {
		 JenaException e = new BrokenException(""Internal error in Unparser: "" + msg);
		 this.prettyWriter.fatalError(e);
		 throw e;
	 }
	 private void addTypeNameSpaces() {
		 NodeIterator nn = model.listObjectsOfProperty(RDF.type);
		 try {
			 while (nn.hasNext()) {
				 RDFNode obj = nn.nextNode();
				 int split = isOKType(obj);
				 if (split != -1) prettyWriter.addNameSpace(((Resource) obj).getURI() .substring(0, split));
			 }
		 }
		 finally {
			 nn.close();
		 }
	 }
	 private String getXMLNameSpace(Resource r) {
		 if (r.isAnon()) {
			 logger.error(""Internal error - Unparser.getNameSpace;
			 giving up"");
			 throw new BrokenException(""Internal error: getNameSpace(bNode)"");
		 }
		 String uri = r.getURI();
		 int split = Util.splitNamespaceXML(uri);
		 return uri.substring(0, split);
	 }
	 private boolean isGenuineAnon(Resource r) {
		 if (!r.isAnon()) return false;
		 Integer v = objectTable.get(r);
		 return v == null || ((!prettyWriter.sResourcePropertyElt) && v.intValue() <= 1 && (!haveReified .contains(r)));
	 }
	 private boolean isLocalReference(Resource r) {
		 return (!r.isAnon()) && getXMLNameSpace(r).equals(outputName + ""#"") && XMLChar.isValidNCName(getXMLLocalName(r));
	 }
	 private String getXMLLocalName(Resource r) {
		 if (r.isAnon()) {
			 logger.error(""Internal error - giving up - Unparser.getLocalName"");
			 throw new BrokenException(""Internal error: getLocalName(bNode)"");
		 }
		 String uri = r.getURI();
		 int split = Util.splitNamespaceXML(uri);
		 return uri.substring(split);
	 }
	 private void increaseObjectCount(Resource r) {
		 Integer cnt = objectTable.get(r);
		 if (cnt == null) {
			 cnt = one;
		 }
		 else {
			 cnt = Integer.valueOf(cnt.intValue() + 1);
		 }
		 objectTable.put(r, cnt);
	 }
	 private boolean wantReification(Statement s) {
		 return wantReification(s, statement2res.get(s));
	 }
	 private boolean wantReification(Resource res) {
		 return wantReification(res2statement.get(res), res);
	 }
	 private boolean wantReification(Statement s, Resource ref) {
		 if (s == null || ref == null || ref.isAnon() || prettyWriter.sReification) return false;
		 if (!(isLocalReference(ref))) return false;
		 Statement reify[] = reification(s);
		 int i;
		 for (i = 0;
		 i < reify.length;
		 i++) if (doneSet.contains(reify[i]) || (!model.contains(reify[i]))) return false;
		 return true;
	 }
	 private Statement[] reification(Statement s) {
		 Model m = s.getModel();
		 Resource r = statement2res.get(s);
		 return new Statement[] {
		 m.createStatement(r, RDF.type, RDF.Statement), m.createStatement(r, RDF.subject, s.getSubject()), m.createStatement(r, RDF.predicate, s.getPredicate()), m.createStatement(r, RDF.object, s.getObject()) }
		;
	 }
	 private boolean hasProperties(Resource r) {
		 ExtendedIterator<Statement> ss = listProperties(r);
		 if (avoidExplicitReification && (!r.isAnon()) && isLocalReference(r) && res2statement.containsKey(r)) {
			 ss = new MapFilterIterator<>(new MapFilter<Statement, Statement>() {
				 public Statement accept(Statement o) {
					 Statement s = o;
					 Property p = s.getPredicate();
					 return ((!p.getNameSpace().equals(rdfns)) || !((RDF.type .equals(p) && s.getObject().equals(RDF.Statement)) || RDF.object.equals(p) || RDF.predicate.equals(p) || RDF.subject .equals(p))) ? o : null;
				 }
			 }
			, ss);
		 }
		 try {
			 return ss.hasNext();
		 }
		 finally {
			 ss.close();
		 }
	 }
	 private ExtendedIterator<Statement> listProperties(Resource r) {
		 return new MapFilterIterator<>(new MapFilter<Statement, Statement>() {
			 public Statement accept( Statement o ) {
				 return doneSet.contains(o) ? null : o;
			 }
		 }
		, r.listProperties());
	 }
	 private boolean canBeAttribute(Statement s, Set<Property> seen) {
		 Property p = s.getPredicate();
		 if (prettyWriter.sPropertyAttr || seen.contains(p)) return false;
		 seen.add(p);
		 if (p.equals(RDF.type)) {
			 RDFNode n = s.getObject();
			 return n.isURIResource();
		 }
		 if (s.getObject() instanceof Literal) {
			 Literal l = s.getLiteral();
			 if ( ! Util.isSimpleString(l) ) if (l.getDatatypeURI() != null) return false;
			 if (l.getLanguage().equals("""")) {
				 if (prettyWriter.isDefaultNamespace(getXMLNameSpace(p))) return false;
				 String str = l.getString();
				 if (str.length() < 40) {
					 char buf[] = str.toCharArray();
					 for ( char aBuf : buf ) {
						 if ( aBuf <= ' ' || aBuf == 0xFFFF || aBuf == 0xFFFE ) {
							 return false;
						 }
					 }
					 return !wantReification(s);
				 }
			 }
		 }
		 return false;
	 }
	 private boolean allPropsAreAttr(Resource r) {
		 ClosableIterator<Statement> ss = listProperties(r);
		 Set<Property> seen = new HashSet<>();
		 try {
			 while (ss.hasNext()) {
				 Statement s = ss.next();
				 if (!canBeAttribute(s, seen)) return false;
			 }
		 }
		 finally {
			 ss.close();
		 }
		 return true;
	 }
	 private void done(Statement s) {
		 doneSet.add(s);
	 }
	 private Statement[][] getRDFList(RDFNode r) {
		 return prettyWriter.sParseTypeCollectionPropertyElt ? null : getList(r, null, RDF.first, RDF.rest, RDF.nil);
	 }
	 private Statement[][] getList(RDFNode r, Resource list, Property first, Property rest, Resource nil) {
		 Vector<Statement[]> rslt = new Vector<>();
		 Set<RDFNode> seen = new HashSet<>();
		 RDFNode next = r;
		 try {
			 while (!next.equals(nil)) {
				 Statement elt[] = new Statement[list == null ? 2 : 3];
				 if (next instanceof Literal) return null;
				 Resource res = (Resource) next;
				 if (!isGenuineAnon(res)) return null;
				 if (seen.contains(next)) return null;
				 seen.add(next);
				 StmtIterator ss = res.listProperties();
				 try {
					 while (ss.hasNext()) {
						 Statement s = ss.nextStatement();
						 Property p = s.getPredicate();
						 int ix;
						 RDFNode obj = s.getObject();
						 if (doneSet.contains(s)) return null;
						 if (!(obj instanceof Resource)) {
							 return null;
						 }
						 if (p.equals(RDF.type)) {
							 ix = 2;
							 if (!obj.equals(list)) return null;
						 }
						 else if (p.equals(first)) {
							 ix = 0;
						 }
						 else if (p.equals(rest)) {
							 ix = 1;
							 next = obj;
						 }
						 else {
							 return null;
						 }
						 if (elt[ix] != null) return null;
						 elt[ix] = s;
					 }
				 }
				 finally {
					 ss.close();
				 }
				 for ( Statement anElt : elt ) {
					 if ( anElt == null ) {
						 return null;
					 }
				 }
				 rslt.add(elt);
			 }
			 if (rslt.size() == 0) return null;
		 }
		 finally {
		 }
		 Statement array[][] = new Statement[rslt.size()][];
		 rslt.copyInto(array);
		 return array;
	 }
	 private Statement getType(Resource r) {
		 Statement rslt;
		 try {
			 if (r instanceof Statement) {
				 rslt = ((Statement) r).getStatementProperty(RDF.type);
				 if (rslt == null || (!rslt.getObject().equals(RDF.Statement))) error(""Statement type problem"");
			 }
			 else {
				 rslt = r.getRequiredProperty(RDF.type);
			 }
		 }
		 catch (PropertyNotFoundException rdfe) {
			 if (r instanceof Statement) error(""Statement type problem"");
			 rslt = null;
		 }
		 if (rslt == null || isOKType(rslt.getObject()) == -1) return null;
		 return rslt;
	 }
	 private int isOKType(RDFNode n) {
		 if (!(n instanceof Resource)) return -1;
		 if (((Resource) n).isAnon()) return -1;
		 String uri = ((Resource) n).getURI();
		 int split = Util.splitNamespaceXML(uri);
		 if (split == 0 || split == uri.length()) return -1;
		 return split;
	 }
	 private Set<Resource> infinite;
	 private void findInfiniteCycles() {
		 StmtIterator ss = model.listStatements();
		 Relation<Resource> relation = new Relation<>();
		 try {
			 while (ss.hasNext()) {
				 Statement s = ss.nextStatement();
				 if (!doneSet.contains(s)) {
					 RDFNode rn = s.getObject();
					 if (rn instanceof Resource) {
						 relation.set(s.getSubject(), (Resource)rn);
					 }
				 }
			 }
		 }
		 finally {
			 ss.close();
		 }
		 relation.transitiveClosure();
		 infinite = relation.getDiagonal();
	 }
	 private ExtendedIterator<Resource> allInfiniteLeft() {
		 return new LazyIterator<Resource>() {
			 public ExtendedIterator<Resource> create() {
				 return WrappedIterator.create(infinite.iterator());
			 }
		 }
		;
	 }
	 private Iterator<Resource> pleasingTypeIterator() {
		 if (pleasingTypes == null) return NullIterator.instance();
		 Map<Resource, Set<Resource>> buckets = new HashMap<>();
		 Set<Resource> bucketArray[] = new Set[pleasingTypes.length] ;
		 for (int i = 0;
		 i < pleasingTypes.length;
		 i++) {
			 bucketArray[i] = new HashSet<>();
			 buckets.put(pleasingTypes[i], bucketArray[i]);
		 }
		 ResIterator rs = model.listSubjects();
		 try {
			 while (rs.hasNext()) {
				 Resource r = rs.nextResource();
				 Statement s = getType(r);
				 if (s != null) {
					 Set<Resource> bucket = buckets.get(s.getObject());
					 if (bucket != null) {
						 if (isGenuineAnon(r)) {
							 Integer v = objectTable.get(r);
							 if (v != null && v.intValue() == 1) continue;
						 }
						 bucket.add(r);
					 }
				 }
			 }
		 }
		 finally {
			 rs.close();
		 }
		 return WrappedIterator.createIteratorIterator( new Map1Iterator<>(bkt -> bkt.iterator(), Arrays.asList(bucketArray).iterator()));
	 }
	 private Iterator<Resource> listSubjects() {
		 Iterator<Resource> currentFile = new SingletonIterator<>( model.createResource( this.outputName ) );
		 Iterator<Resource> pleasing = pleasingTypeIterator();
		 Iterator<Resource> fakeStopPleasing = new NullIterator<Resource>() {
			 public boolean hasNext() {
				 pleasingTypeSet = new HashSet<>();
				 return false;
			 }
		 }
		;
		Iterator<Resource> nonObjects = modelListSubjects().filterKeep( o -> !objectTable.containsKey(o) && !wantReification(o));
		 Iterator<Resource> fakeLazyEvaluator = new NullIterator<Resource>() {
			 public boolean hasNext() {
				 findInfiniteCycles();
				 return false;
			 }
		 }
		;
		Iterator<Resource> firstChoiceCyclic = allInfiniteLeft().filterKeep(r -> {
			codeCoverage[4]++;
			if (r.isAnon())return false;
			Integer cnt = objectTable.get(r);
			if (cnt == null || cnt.intValue() <= 1)return false;
			return true;
		}
		);
		Iterator<Resource> nonAnonInfinite = allInfiniteLeft().filterKeep(r -> {
			codeCoverage[5]++;
			return !isGenuineAnon(r);
		}
		);
		 Iterator<Resource> inf = allInfiniteLeft();
		 Iterator<Resource> anotherFake = new NullIterator<Resource>() {
			 public boolean hasNext() {
				 avoidExplicitReification = false;
				 return false;
			 }
		 }
		;
		Iterator<Resource> reifications = allInfiniteLeft().filterKeep(r -> {
			codeCoverage[6]++;
			return res2statement.containsKey(r);
		}
		);
		 Iterator<Resource> backStop = modelListSubjects();
		 Iterator<Resource> all[] = new Iterator[] {
			 currentFile, pleasing, fakeStopPleasing, nonObjects, fakeLazyEvaluator, firstChoiceCyclic, nonAnonInfinite, inf, anotherFake, reifications, new NullIterator<Resource>() {
				 public boolean hasNext() {
					 if (modelListSubjects().hasNext()) codeCoverage[7]++;
					 return false;
				 }
			 }
		, backStop }
		;
		 ExtendedIterator<Resource> allAsOne = WrappedIterator.createIteratorIterator( Arrays.asList(all).iterator() );
		 return allAsOne.filterKeep(this::hasProperties);
	 }
	 private Set<ResIterator> openResIterators = new HashSet<>();
	 private synchronized void closeAllResIterators() {
		 Iterator<ResIterator> members = openResIterators.iterator();
		 while (members.hasNext()) {
			 members.next().close();
		 }
		 openResIterators = new HashSet<>();
	 }
	 private ResIterator modelListSubjects() {
		 ResIterator resIt = model.listSubjects();
		 openResIterators.add(resIt);
		 return resIt;
	 }
}",1,0,0,0
"public static void main(String[] args) throws Exception {
	 if (args.length == 0) {
		 usage();
		 if (LOG.isFatalEnabled()) {
			 LOG.fatal(""Missing arguments"");
		 }
		 return;
	 }
	 File idx = new File(args[0]);
	 if (!idx.isDirectory()) {
		 usage();
		 if (LOG.isFatalEnabled()) {
			 LOG.fatal(""Not a directory: "" + idx);
		 }
		 return;
	 }
	 Vector paths = new Vector();
	 if (IndexReader.indexExists(idx)) {
		 paths.add(idx);
	 }
	 else {
		 File[] dirs = idx.listFiles(new FileFilter() {
			 public boolean accept(File f) {
				 return f.isDirectory();
			 }
		 }
		);
		 if (dirs == null || dirs.length == 0) {
			 usage();
			 if (LOG.isFatalEnabled()) {
				 LOG.fatal(""No indexes in "" + idx);
			 }
			 return;
		 }
		 for (int i = 0;
		 i < dirs.length;
		 i++) {
			 File sidx = new File(dirs[i], ""index"");
			 if (sidx.exists() && sidx.isDirectory() && IndexReader.indexExists(sidx)) {
				 paths.add(sidx);
			 }
		 }
		 if (paths.size() == 0) {
			 usage();
			 if (LOG.isFatalEnabled()) {
				 LOG.fatal(""No indexes in "" + idx + "" or its subdirs."");
			 }
			 return;
		 }
	 }
	 File[] indexes = (File[])paths.toArray(new File[0]);
	 boolean force = false;
	 boolean dryrun = false;
	 String qPath = null;
	 String outPath = null;
	 String fList = null;
	 for (int i = 1;
	 i < args.length;
	 i++) {
		 if (args[i].equals(""-force"")) {
			 force = true;
		 }
		 else if (args[i].equals(""-queries"")) {
			 qPath = args[++i];
		 }
		 else if (args[i].equals(""-output"")) {
			 outPath = args[++i];
		 }
		 else if (args[i].equals(""-showfields"")) {
			 fList = args[++i];
		 }
		 else if (args[i].equals(""-dryrun"")) {
			 dryrun = true;
		 }
		 else {
			 usage();
			 if (LOG.isFatalEnabled()) {
				 LOG.fatal(""Unrecognized option: "" + args[i]);
			 }
			 return;
		 }
	 }
	 Vector cv = new Vector();
	 if (fList != null) {
		 StringTokenizer st = new StringTokenizer(fList, "","");
		 Vector tokens = new Vector();
		 while (st.hasMoreTokens()) tokens.add(st.nextToken());
		 String[] fields = (String[])tokens.toArray(new String[0]);
		 PruneChecker pc = new PrintFieldsChecker(System.out, fields);
		 cv.add(pc);
	 }
	 if (outPath != null) {
		 StoreUrlsChecker luc = new StoreUrlsChecker(new File(outPath), false);
		 cv.add(luc);
	 }
	 PruneChecker[] checkers = null;
	 if (cv.size() > 0) {
		 checkers = (PruneChecker[])cv.toArray(new PruneChecker[0]);
	 }
	 Query[] queries = null;
	 InputStream is = null;
	 if (qPath != null) {
		 is = new FileInputStream(qPath);
	 }
	 else {
		 Configuration conf = NutchConfiguration.create();
		 qPath = conf.get(""prune.index.tool.queries"");
		 is = conf.getConfResourceAsInputStream(qPath);
	 }
	 if (is == null) {
		 if (LOG.isFatalEnabled()) {
			 LOG.fatal(""Can't load queries from "" + qPath);
		 }
		 return;
	 }
	 try {
		 queries = parseQueries(is);
	 }
	 catch (Exception e) {
		 if (LOG.isFatalEnabled()) {
			 LOG.fatal(""Error parsing queries: "" + e.getMessage());
		 }
		 return;
	 }
	 try {
		 PruneIndexTool pit = new PruneIndexTool(indexes, queries, checkers, force, dryrun);
		 pit.run();
	 }
	 catch (Exception e) {
		 if (LOG.isFatalEnabled()) {
			 LOG.fatal(""Error running PruneIndexTool: "" + e.getMessage());
		 }
		 return;
	 }
 }",0,0,1,0
"public void run( IAction action ){
	if ( !preGenerate( ) ){
		return;
	}
	IFile file = getSelectedFile( );
	if ( file != null ){
		String url = file.getLocation( ).toOSString( );
		Map options = new HashMap( );
		options.put( WebViewer.RESOURCE_FOLDER_KEY,ReportPlugin.getDefault( ).getResourceFolder( file.getProject( ) ) );
		options.put( WebViewer.SERVLET_NAME_KEY, WebViewer.VIEWER_DOCUMENT );
		Object adapter = ElementAdapterManager.getAdapter( action,IPreviewAction.class );
		if ( adapter instanceof IPreviewAction ){
			IPreviewAction delegate = (IPreviewAction) adapter;
			delegate.setProperty( IPreviewConstants.REPORT_PREVIEW_OPTIONS,options );
			delegate.setProperty( IPreviewConstants.REPORT_FILE_PATH, url );
			delegate.run( );
			return;
		}
		try{
			WebViewer.display( url, options );
		}
		catch ( Exception e ){
			ExceptionUtil.handle( e );
			return;
		}
	}
	else{
		action.setEnabled( false );
	}
}",0,0,1,0
"public class PickableVertexPaintTransformer<V> implements Transformer<V,Paint> {
	 protected Paint fill_paint;
	 protected Paint picked_paint;
	 protected PickedInfo<V> pi;
	 public PickableVertexPaintTransformer(PickedInfo<V> pi, Paint fill_paint, Paint picked_paint) {
		 if (pi == null) throw new IllegalArgumentException(""PickedInfo instance must be non-null"");
		 this.pi = pi;
		 this.fill_paint = fill_paint;
		 this.picked_paint = picked_paint;
	 }
	 public Paint transform(V v) {
		 if (pi.isPicked(v)) return picked_paint;
		 else return fill_paint;
	 }
}",0,0,0,0
"public class MyUDFReturnMap extends EvalFunc<Map<Object,Object>> {
	public static Map<Object,Object> map=new HashMap<Object, Object>();
	static{
		map.put(""anykey"", ""anyvalue"");
	}
	public Map<Object, Object> exec(Tuple input) throws IOException {
		return map;
	}
}",1,0,0,0
"public class RecordColumnarIndexer implements IExternalIndexer {
	 private static final long serialVersionUID = 1L;
	 public static final int NUM_OF_FIELDS = 3;
	 protected final AMutableInt32 fileNumber = new AMutableInt32(0);
	 protected final AMutableInt64 offset = new AMutableInt64(0);
	 protected long nextOffset;
	 protected final AMutableInt32 rowNumber = new AMutableInt32(0);
	 protected RecordReader<?, Writable> recordReader;
	 private ISerializerDeserializer<IAObject> intSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT32);
	 private ISerializerDeserializer<IAObject> longSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT64);
	 public void reset(IIndexingDatasource reader) throws HyracksDataException {
		 try {
			 HDFSRecordReader<?, Writable> hdfsReader = (HDFSRecordReader<?, Writable>) reader;
			 fileNumber.setValue(hdfsReader.getSnapshot().get(hdfsReader.getCurrentSplitIndex()).getFileNumber());
			 recordReader = hdfsReader.getReader();
			 offset.setValue(recordReader.getPos());
			 nextOffset = offset.getLongValue();
			 rowNumber.setValue(0);
		 }
		 catch (IOException e) {
			 throw HyracksDataException.create(e);
		 }
	 }
	 public void index(ArrayTupleBuilder tb) throws HyracksDataException {
		 try {
			 if (recordReader.getPos() != nextOffset) {
				 offset.setValue(nextOffset);
				 nextOffset = recordReader.getPos();
				 rowNumber.setValue(0);
			 }
			 tb.addField(intSerde, fileNumber);
			 tb.addField(longSerde, offset);
			 tb.addField(intSerde, rowNumber);
			 rowNumber.setValue(rowNumber.getIntegerValue() + 1);
		 }
		 catch (IOException e) {
			 throw HyracksDataException.create(e);
		 }
	 }
	 public int getNumberOfFields() {
		 return NUM_OF_FIELDS;
	 }
}",0,0,0,0
"static class Packed64SingleBlock6 extends Packed64SingleBlock {
	 Packed64SingleBlock6(int valueCount) {
		 super(valueCount, 6);
	 }
	 public long get(int index) {
		 final int o = index / 10;
		 final int b = index % 10;
		 final int shift = b * 6;
		 return (blocks[o] >>> shift) & 63L;
	 }
	 public void set(int index, long value) {
		 final int o = index / 10;
		 final int b = index % 10;
		 final int shift = b * 6;
		 blocks[o] = (blocks[o] & ~(63L << shift)) | (value << shift);
	 }
 }",0,0,0,0
"public void execute() throws org.apache.tools.ant.BuildException {
	 int result = 0;
	 if (repository == null || repository.trim().equals("""")) {
		 throw new BuildException(""Required argument repository not specified"");
	 }
	 Commandline commandLine = new Commandline();
	 commandLine.setExecutable(getExecutable(PCLI_EXE));
	 commandLine.createArgument().setValue(""lvf"");
	 commandLine.createArgument().setValue(""-z"");
	 commandLine.createArgument().setValue(""-aw"");
	 if (getWorkspace() != null) {
		 commandLine.createArgument().setValue(""-sp"" + getWorkspace());
	 }
	 commandLine.createArgument().setValue(""-pr"" + getRepository());
	 String uid = getUserId();
	 if (uid != null) {
		 commandLine.createArgument().setValue(""-id"" + uid);
	 }
	 if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
		 pvcsProject = ""/"";
	 }
	 if (getPvcsproject() != null) {
		 commandLine.createArgument().setValue(getPvcsproject());
	 }
	 if (!getPvcsprojects().isEmpty()) {
		 Enumeration e = getPvcsprojects().elements();
		 while (e.hasMoreElements()) {
			 String projectName = ((PvcsProject) e.nextElement()).getName();
			 if (projectName == null || (projectName.trim()).equals("""")) {
				 throw new BuildException(""name is a required attribute "" + ""of pvcsproject"");
			 }
			 commandLine.createArgument().setValue(projectName);
		 }
	 }
	 File tmp = null;
	 File tmp2 = null;
	 try {
		 Random rand = new Random(System.currentTimeMillis());
		 tmp = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
		 FileOutputStream fos = new FileOutputStream(tmp);
		 tmp2 = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
		 log(commandLine.describeCommand(), Project.MSG_VERBOSE);
		 try {
			 result = runCmd(commandLine, new PumpStreamHandler(fos, new LogOutputStream(this, Project.MSG_WARN)));
		 }
		 finally {
			 FileUtils.close(fos);
		 }
		 if (Execute.isFailure(result) && !ignorerc) {
			 String msg = ""Failed executing: "" + commandLine.toString();
			 throw new BuildException(msg, getLocation());
		 }
		 if (!tmp.exists()) {
			 throw new BuildException(""Communication between ant and pvcs "" + ""failed. No output generated from executing PVCS "" + ""commandline interface \""pcli\"" and \""get\"""");
		 }
		 log(""Creating folders"", Project.MSG_INFO);
		 createFolders(tmp);
		 massagePCLI(tmp, tmp2);
		 commandLine.clearArgs();
		 commandLine.setExecutable(getExecutable(GET_EXE));
		 if (getConfig() != null && getConfig().length() > 0) {
			 commandLine.createArgument().setValue(""-c"" + getConfig());
		 }
		 if (getForce() != null && getForce().equals(""yes"")) {
			 commandLine.createArgument().setValue(""-Y"");
		 }
		 else {
			 commandLine.createArgument().setValue(""-N"");
		 }
		 if (getPromotiongroup() != null) {
			 commandLine.createArgument().setValue(""-G"" + getPromotiongroup());
		 }
		 else {
			 if (getLabel() != null) {
				 commandLine.createArgument().setValue(""-v"" + getLabel());
			 }
			 else {
				 if (getRevision() != null) {
					 commandLine.createArgument().setValue(""-r"" + getRevision());
				 }
			 }
		 }
		 if (updateOnly) {
			 commandLine.createArgument().setValue(""-U"");
		 }
		 commandLine.createArgument().setValue(""@"" + tmp2.getAbsolutePath());
		 log(""Getting files"", Project.MSG_INFO);
		 log(""Executing "" + commandLine.toString(), Project.MSG_VERBOSE);
		 result = runCmd(commandLine, new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
		 if (result != 0 && !ignorerc) {
			 String msg = ""Failed executing: "" + commandLine.toString() + "". Return code was "" + result;
			 throw new BuildException(msg, getLocation());
		 }
	 }
	 catch (FileNotFoundException e) {
		 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
		 throw new BuildException(msg, getLocation());
	 }
	 catch (IOException e) {
		 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
		 throw new BuildException(msg, getLocation());
	 }
	 catch (ParseException e) {
		 String msg = ""Failed executing: "" + commandLine.toString() + "". Exception: "" + e.getMessage();
		 throw new BuildException(msg, getLocation());
	 }
	 finally {
		 if (tmp != null) {
			 tmp.delete();
		 }
		 if (tmp2 != null) {
			 tmp2.delete();
		 }
	 }
 }",0,0,1,0
"public boolean isAlive() {
	 return isAlive;
 }",0,0,0,0
"public class XtextResourceFactory {
	 private IResourceSetProvider resourceSetProvider;
	 private IProjects projects;
	 public XtextResource createResource(String uri, String contents) throws IOException {
		 return createResource(createURI(uri), contents);
	 }
	 public XtextResource createResource(URI uri, String contents) throws IOException {
		 ResourceSet resourceSet = resourceSetProvider.get(projects.activeProject());
		 XtextResource resource = (XtextResource) resourceSet.createResource(uri, UNSPECIFIED_CONTENT_TYPE);
		 resource.load(new StringInputStream(contents), singletonMap(OPTION_ENCODING, UTF_8));
		 resolveLazyCrossReferences(resource, NullImpl);
		 return resource;
	 }
}",0,0,0,0
"public class WatchWebHandler {
	 public WatchWebHandler() {
	 }
	 public void processDelete_forMember(GenericRequest request) throws BadInputException, DatabaseException {
		 SecurityUtil.checkHttpReferer(request);
		 int memberID = GenericParamUtil.getParameterInt(request, ""memberid"");
		 DAOFactory.getWatchDAO().delete_inMember(memberID);
	 }
}",1,0,0,0
"protected void configure(final RequestCycle requestCycle, final Response response,final IResourceStream resourceStream){
	String responseType = resourceStream.getContentType();
	if (responseType != null){
		if (responseType.toLowerCase().indexOf(""text"") != -1){
			response.setContentType(responseType + "";
			 charset="" +response.getCharacterEncoding());
		}
		else{
			response.setContentType(responseType);
		}
	}
	else{
		if (getFileName() != null){
			response.detectContentType(requestCycle, getFileName());
		}
		else{
			String path = requestCycle.getRequest().getURL();
			final int qs = path.indexOf('?');
			if (qs >= 0){
				path = path.substring(0, qs);
			}
			response.detectContentType(requestCycle, path);
		}
	}
	long len = resourceStream.length();
	if (len >= 0){
		response.setContentLength(len);
	}
	String file = getFileName();
	if (file != null && (response instanceof WebResponse)){
		((WebResponse)response).setAttachmentHeader(file);
	}
}",0,0,0,0
"public class Header {
	 public String key;
	 public String val;
	 public Header(String key, String val) {
		 this.key = key;
		 this.val = val;
	 }
	 public String getEncodedKey() {
		 return encode(key);
	 }
	 public String getEncodedValue() {
		 return encode(val);
	 }
 }",0,1,0,0
"public class FolderInfo implements MessageCountListener, ValueChangeListener, UserProfileContainer, MessageChangedListener, ConnectionListener {
	 Logger mLogger = null;
	 public static int CONNECTED = 0;
	 public static int LOST_CONNECTION = 5;
	 public static int PASSIVE = 10;
	 public static int DISCONNECTED = 15;
	 public static int CACHE_ONLY = 18;
	 public static int CLOSED = 20;
	 public static int NOT_LOADED = 25;
	 public static int INVALID = 30;
	 protected int status = NOT_LOADED;
	 protected int type = 0;
	 protected int preferredStatus = CONNECTED;
	 protected static String disconnectedMessage = ""error.Folder.disconnected"";
	 private Folder folder;
	 private String folderID;
	 private String mFolderName;
	 private EventListenerList eventListeners = new EventListenerList();
	 protected FolderNode folderNode;
	 protected Vector children;
	 protected FolderTableModel folderTableModel;
	 protected HashMap<Message, MessageInfo> messageToInfoTable = new HashMap<Message, MessageInfo>();
	 private List columnValues;
	 private List<String> columnNames;
	 private List<String> columnSizes;
	 private List<String> columnIds;
	 private FolderDisplayUI folderDisplayUI;
	 private Action[] defaultActions;
	 protected BackendMessageFilter[] backendFilters = null;
	 protected MessageFilter[] displayFilters = null;
	 protected MessageLoader mMessageLoader = null;
	 private FolderTracker folderTracker = null;
	 protected boolean loading = false;
	 protected int unreadCount = 0;
	 protected int messageCount = 0;
	 private boolean newMessages = false;
	 private FolderInfo parentFolder = null;
	 private StoreInfo parentStore = null;
	 private UserProfile defaultProfile = null;
	 private boolean sentFolder = false;
	 private boolean trashFolder = false;
	 private boolean notifyNewMessagesMain = true;
	 private boolean notifyNewMessagesNode = true;
	 private boolean tracksUnreadMessages = true;
	 protected FetchProfile fetchProfile = null;
	 protected OutgoingMailServer mailServer = null;
	 protected boolean mNamespace = false;
	 protected FolderInfo() {
	 }
	 public FolderInfo(FolderInfo parent, String fname) {
		 parentFolder = parent;
		 setFolderID(parent.getFolderID() + ""."" + fname);
		 mFolderName = fname;
		 try {
			 if (parent.isLoaded()) loadFolder();
		 }
		 catch (OperationCancelledException oce) {
		 }
		 catch (MessagingException me) {
			 if (getLogger().isLoggable(Level.FINE)) {
				 folderLog(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception from parentStore getting folder: "" + me);
				 me.printStackTrace();
			 }
		 }
		 updateChildren();
		 createFilters();
		 resetDefaultActions();
		 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesMain"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesMain(true);
		 else setNotifyNewMessagesMain(false);
		 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesNode"", """").equalsIgnoreCase(""false"")) {
			 setNotifyNewMessagesNode(true);
		 }
		 else {
			 setNotifyNewMessagesNode(false);
		 }
	 }
	 public FolderInfo(StoreInfo parent, String fname) {
		 parentStore = parent;
		 setFolderID(parent.getStoreID() + ""."" + fname);
		 mFolderName = fname;
		 mNamespace = Pooka.getProperty(getFolderID() + ""._namespace"", ""false"").equalsIgnoreCase(""true"");
		 try {
			 if (parent.isConnected()) loadFolder();
		 }
		 catch (OperationCancelledException oce) {
		 }
		 catch (MessagingException me) {
			 if (getLogger().isLoggable(Level.FINE)) {
				 folderLog(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception from parentStore getting folder: "" + me);
				 me.printStackTrace();
			 }
		 }
		 updateChildren();
		 createFilters();
		 resetDefaultActions();
		 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesMain"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesMain(true);
		 else setNotifyNewMessagesMain(false);
		 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesNode"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesNode(true);
		 else setNotifyNewMessagesNode(false);
	 }
	 public void loadFolder() throws MessagingException, OperationCancelledException {
		 loadFolder(true);
	 }
	 public void loadFolder(boolean pConnectStore) throws MessagingException, OperationCancelledException {
		 boolean parentIsConnected = false;
		 if (isLoaded() || (loading && children == null)) return;
		 Folder[] tmpFolder = null;
		 Folder tmpParentFolder;
		 try {
			 loading = true;
			 if (parentStore != null) {
				 folderLog(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": checking parent store connection."");
				 if (! parentStore.isAvailable()) throw new MessagingException();
				 if (!parentStore.isConnected()) {
					 if (pConnectStore) {
						 parentStore.connectStore();
					 }
					 else {
						 return;
					 }
				 }
				 Store store = parentStore.getStore();
				 try {
					 folderLog(Level.FINE, ""checking to see if "" + getFolderID() + "" is a shared folder."");
					 Folder[] sharedFolders = store.getSharedNamespaces();
					 if (sharedFolders != null && sharedFolders.length > 0) {
						 for (int i = 0;
						 ( tmpFolder == null || tmpFolder.length == 0 ) && i < sharedFolders.length;
						 i++) {
							 if (sharedFolders[i].getName().equalsIgnoreCase(mFolderName)) {
								 if (!mNamespace) {
									 Pooka.setProperty(getFolderID() + ""._namespace"", ""true"");
									 mNamespace = true;
								 }
								 tmpFolder = new Folder[1];
								 tmpFolder[0] = sharedFolders[i] ;
							 }
						 }
					 }
				 }
				 catch (Exception e) {
				 }
				 if (tmpFolder == null || tmpFolder.length == 0) {
					 tmpParentFolder = store.getDefaultFolder();
					 folderLog(Level.FINE, ""got "" + tmpParentFolder + "" as Default Folder for store."");
					 folderLog(Level.FINE, ""doing a list on default folder "" + tmpParentFolder + "" for folder "" + mFolderName);
					 tmpFolder = tmpParentFolder.list(mFolderName);
				 }
				 folderLog(Level.FINE, ""got "" + tmpFolder + "" as Folder for folder "" + getFolderID() + ""."");
			 }
			 else {
				 if (!parentFolder.isLoaded()) parentFolder.loadFolder();
				 if (!parentFolder.isLoaded()) {
					 tmpFolder = null;
				 }
				 else {
					 tmpParentFolder = parentFolder.getFolder();
					 if (tmpParentFolder != null) {
						 parentIsConnected = true;
						 folderLog(Level.FINE, ""running list ("" + mFolderName + "") on parent folder "" + tmpParentFolder);
						 tmpFolder = tmpParentFolder.list(mFolderName);
					 }
					 else {
						 tmpFolder = null;
					 }
				 }
			 }
			 if (tmpFolder != null && tmpFolder.length > 0) {
				 setFolder(tmpFolder[0]);
				 if (! getFolder().isSubscribed()) getFolder().setSubscribed(true);
				 type = getFolder().getType();
				 setStatus(CLOSED);
			 }
			 else {
				 folderLog(Level.FINE, ""folder "" + mFolderName + "" does not exist;
				 setting as INVALID."");
				 if (parentIsConnected) setStatus(INVALID);
				 setFolder(null);
			 }
		 }
		 finally {
			 loading = false;
		 }
		 initializeFolderInfo();
	 }
	 protected void addFolderListeners() {
		 if (folder != null) {
			 folder.addMessageChangedListener(this);
			 folder.addMessageCountListener(this);
			 folder.addConnectionListener(this);
		 }
	 }
	 protected void removeFolderListeners() {
		 if (folder != null) {
			 folder.removeMessageChangedListener(this);
			 folder.removeMessageCountListener(this);
			 folder.removeConnectionListener(this);
		 }
	 }
	 protected void initializeFolderInfo() {
		 addFolderListeners();
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty());
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".folderList"");
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".defaultProfile"");
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".displayFilters"");
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".backendFilters"");
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".notifyNewMessagesMain"");
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".notifyNewMessagesNode"");
		 Pooka.getLogManager().addLogger(getFolderProperty());
		 String defProfile = Pooka.getProperty(getFolderProperty() + "".defaultProfile"", """");
		 if ((!defProfile.equals("""")) && (!defProfile.equals(UserProfile.S_DEFAULT_PROFILE_KEY))) defaultProfile = Pooka.getPookaManager().getUserProfileManager().getProfile(defProfile);
		 if (getFolderTracker() == null) {
			 FolderTracker tracker = Pooka.getFolderTracker();
			 if (tracker != null) {
				 tracker.addFolder(this);
				 this.setFolderTracker(tracker);
			 }
			 else {
				 if (Pooka.sStartupManager.isShuttingDown()) {
					 getLogger().fine(""No FolderTracker available."");
				 }
				 else {
					 getLogger().warning(""Error: No FolderTracker available for folder "" + getFolderID());
				 }
			 }
		 }
	 }
	 public void closed(ConnectionEvent e) {
		 synchronized(this) {
			 folderLog(Level.FINE, ""Folder "" + getFolderID() + "" closed: "" + e);
			 if (getStatus() != CLOSED && getStatus() != DISCONNECTED) {
				 getFolderThread().addToQueue(new javax.swing.AbstractAction() {
					 public void actionPerformed(java.awt.event.ActionEvent e) {
						 StoreInfo parentStoreInfo = getParentStore();
						 if (parentStoreInfo != null) {
							 if (parentStoreInfo.isConnected()) parentStoreInfo.checkConnection();
						 }
					 }
				 }
				, new java.awt.event.ActionEvent(this, 0, ""folder-closed""), ActionThread.PRIORITY_HIGH);
				 if (getFolderDisplayUI() != null) {
					 getFolderDisplayUI().showStatusMessage(Pooka.getProperty(disconnectedMessage, ""Lost connection to folder...""));
				 }
				 if (status == CONNECTED) {
					 setStatus(LOST_CONNECTION);
				 }
			 }
		 }
		 fireConnectionEvent(e);
	 }
	 public void disconnected(ConnectionEvent e) {
		 synchronized(this) {
			 if (getLogger().isLoggable(Level.FINE)) {
				 folderLog(Level.FINE, ""Folder "" + getFolderID() + "" disconnected."");
				 Thread.dumpStack();
			 }
			 if (getStatus() != CLOSED) {
				 getFolderThread().addToQueue(new javax.swing.AbstractAction() {
					 public void actionPerformed(java.awt.event.ActionEvent e) {
						 StoreInfo parentStoreInfo = getParentStore();
						 if (parentStoreInfo != null && parentStoreInfo.isConnected()) {
							 parentStoreInfo.checkConnection();
						 }
					 }
				 }
				, new java.awt.event.ActionEvent(this, 0, ""folder-closed""), ActionThread.PRIORITY_HIGH);
				 if (getFolderDisplayUI() != null) {
					 getFolderDisplayUI().showStatusMessage(Pooka.getProperty(""error.UIDFolder.disconnected"", ""Lost connection to folder...""));
				 }
				 if (status == CONNECTED) {
					 setStatus(LOST_CONNECTION);
				 }
			 }
		 }
		 fireConnectionEvent(e);
	 }
	 public void opened (ConnectionEvent e) {
		 fireConnectionEvent(e);
	 }
	 public void connected (ConnectionEvent e) {
		 fireConnectionEvent(e);
	 }
	 public void openFolder(int mode) throws MessagingException, OperationCancelledException {
		 openFolder(mode, true);
	 }
	 public void openFolder(int mode, boolean pConnectStore) throws MessagingException, OperationCancelledException {
		 folderLog(Level.FINE, this + "": checking parent store."");
		 if (!getParentStore().isConnected() && pConnectStore) {
			 folderLog(Level.FINE, this + "": parent store isn't connected. trying connection."");
			 getParentStore().connectStore();
		 }
		 folderLog(Level.FINE, this + "": loading folder."");
		 if (! isLoaded() && status != CACHE_ONLY) loadFolder(pConnectStore);
		 folderLog(Level.FINE, this + "": folder loaded. status is "" + status);
		 folderLog(Level.FINE, this + "": checked on parent store. trying isLoaded() and isAvailable()."");
		 if (status == CLOSED || status == LOST_CONNECTION || status == DISCONNECTED) {
			 folderLog(Level.FINE, this + "": isLoaded() and isAvailable()."");
			 if (folder.isOpen()) {
				 if (folder.getMode() == mode) return;
				 else {
					 folder.close(false);
					 openFolder(mode);
					 updateFolderOpenStatus(true);
					 resetMessageCounts();
				 }
			 }
			 else {
				 folder.open(mode);
				 updateFolderOpenStatus(true);
				 resetMessageCounts();
			 }
		 }
		 else if (status == INVALID) {
			 throw new MessagingException(Pooka.getProperty(""error.folderInvalid"", ""Error: folder is invalid. "") + getFolderID());
		 }
	 }
	 protected void updateFolderOpenStatus(boolean isNowOpen) {
		 if (isNowOpen) {
			 setStatus(CONNECTED);
		 }
		 else {
			 setStatus(CLOSED);
		 }
	 }
	 public void openAllFolders(int mode) {
		 try {
			 openFolder(mode, false);
		 }
		 catch (MessagingException me) {
		 }
		 catch (OperationCancelledException oce) {
		 }
		 if (children != null) {
			 for (int i = 0;
			 i < children.size();
			 i++) {
				 doOpenFolders((FolderInfo) children.elementAt(i), mode);
			 }
		 }
	 }
	 private void doOpenFolders(FolderInfo fi, int mode) {
		 if (Pooka.getProperty(""Pooka.openFoldersInBackground"", ""false"").equalsIgnoreCase(""true"")) {
			 final FolderInfo current = fi;
			 final int finalMode = mode;
			 javax.swing.AbstractAction openFoldersAction =new javax.swing.AbstractAction() {
				 public void actionPerformed(java.awt.event.ActionEvent e) {
					 current.openAllFolders(finalMode);
				 }
			 }
			;
			 openFoldersAction.putValue(javax.swing.Action.NAME, ""file-open"");
			 openFoldersAction.putValue(javax.swing.Action.SHORT_DESCRIPTION, ""file-open on folder "" + fi.getFolderID());
			 getFolderThread().addToQueue(openFoldersAction, new java.awt.event.ActionEvent(this, 0, ""open-all""), ActionThread.PRIORITY_LOW);
		 }
		 else {
			 fi.openAllFolders(mode);
		 }
	 }
	 public void closeFolder(boolean expunge, boolean closeDisplay) throws MessagingException {
		 if (closeDisplay) {
			 unloadAllMessages();
			 if (getFolderDisplayUI() != null) getFolderDisplayUI().closeFolderDisplay();
			 setFolderDisplayUI(null);
		 }
		 if (getFolderTracker() != null) {
			 getFolderTracker().removeFolder(this);
			 setFolderTracker(null);
		 }
		 if (isLoaded() && isValid()) {
			 setStatus(CLOSED);
			 try {
				 folder.close(expunge);
			 }
			 catch (java.lang.IllegalStateException ise) {
				 throw new MessagingException(ise.getMessage(), ise);
			 }
		 }
	 }
	 public void closeFolder(boolean expunge) throws MessagingException {
		 closeFolder(expunge, true);
	 }
	 public void closeAllFolders(boolean expunge, boolean shuttingDown) throws MessagingException {
		 if (shuttingDown && mMessageLoader != null) {
			 mMessageLoader.stopLoading();
		 }
		 synchronized(getFolderThread().getRunLock()) {
			 MessagingException otherException = null;
			 Vector folders = getChildren();
			 if (folders != null) {
				 for (int i = 0;
				 i < folders.size();
				 i++) {
					 try {
						 ((FolderInfo) folders.elementAt(i)).closeAllFolders(expunge, shuttingDown);
					 }
					 catch (MessagingException me) {
						 if (otherException == null) otherException = me;
					 }
					 catch (Exception e) {
						 MessagingException newMe = new MessagingException (e.getMessage(), e);
						 if (otherException == null) otherException = newMe;
					 }
				 }
			 }
			 closeFolder(expunge, false);
			 if (otherException != null) throw otherException;
		 }
	 }
	 public Vector getAllFolders() {
		 Vector returnValue = new Vector();
		 if (children != null) {
			 for (int i = 0 ;
			 i < children.size();
			 i++) returnValue.addAll(((FolderInfo) children.elementAt(i)).getAllFolders());
		 }
		 if (isSortaOpen() && (getType() & Folder.HOLDS_MESSAGES) != 0) returnValue.add(this);
		 return returnValue;
	 }
	 public void synchSubscribed() throws MessagingException, OperationCancelledException {
		 if (mNamespace) return;
		 if (! isLoaded()) loadFolder();
		 if (status < NOT_LOADED) {
			 Folder[] subscribedFolders = folder.list();
			 List<String> subscribedNames = new ArrayList<String>();
			 for (int i = 0;
			 subscribedFolders != null && i < subscribedFolders.length;
			 i++) {
				 if (subscribedFolders[i].isSubscribed() || subscribedFolders[i].getName().equalsIgnoreCase(""INBOX"")) {
					 String folderName = subscribedFolders[i].getName();
					 subscribedNames.add(folderName);
				 }
			 }
			 Collections.sort(subscribedNames);
			 List<String> currentSubscribed = Pooka.getResources().getPropertyAsList(getFolderProperty() + "".folderList"", """");
			 Iterator<String> currentIter = currentSubscribed.iterator();
			 while(currentIter.hasNext()) {
				 String folder = currentIter.next();
				 if (! subscribedNames.contains(folder)) {
					 currentSubscribed.remove(folder);
				 }
				 else {
					 subscribedNames.remove(folder);
				 }
			 }
			 currentSubscribed.addAll(subscribedNames);
			 Pooka.setProperty(getFolderProperty() + "".folderList"", VariableBundle.convertToString(currentSubscribed));
			 for (int i = 0;
			 children != null && i < children.size();
			 i++) {
				 FolderInfo fi = (FolderInfo) children.elementAt(i);
				 fi.synchSubscribed();
			 }
		 }
	 }
	 protected FetchProfile createColumnInformation() {
		 String tableType;
		 if (isSentFolder()) tableType=""SentFolderTable"";
		 else if (isOutboxFolder()) tableType=""SentFolderTable"";
		 else tableType=""FolderTable"";
		 FetchProfile fp = new FetchProfile();
		 fp.add(FetchProfile.Item.FLAGS);
		 if (columnValues == null) {
			 List<String> colIds = Pooka.getResources().getPropertyAsList(tableType, """");
			 Vector colvals = new Vector();
			 Vector<String> colnames = new Vector<String>();
			 Vector<String> colsizes = new Vector<String>();
			 for (String tmp: colIds) {
				 String type = Pooka.getProperty(tableType + ""."" + tmp + "".type"", """");
				 if (type.equalsIgnoreCase(""Multi"")) {
					 SearchTermIconManager stm = new SearchTermIconManager(tableType + ""."" + tmp);
					 colvals.addElement(stm);
					 Vector toFetch = Pooka.getResources().getPropertyAsVector(tableType + ""."" + tmp + "".profileItems"", """");
					 if (toFetch != null) {
						 for (int z = 0;
						 z < toFetch.size();
						 z++) {
							 String profileDef = (String) toFetch.elementAt(z);
							 if (profileDef.equalsIgnoreCase(""Flags"")) {
								 folderLog(Level.FINE, ""adding FLAGS to FetchProfile."");
								 fp.add(FetchProfile.Item.FLAGS);
							 }
							 else if (profileDef.equalsIgnoreCase(""Envelope"")) {
								 folderLog(Level.FINE, ""adding ENVELOPE to FetchProfile."");
								 fp.add(FetchProfile.Item.ENVELOPE);
							 }
							 else if (profileDef.equalsIgnoreCase(""Content_Info"")) {
								 folderLog(Level.FINE, ""adding CONTENT_INFO to FetchProfile."");
								 fp.add(FetchProfile.Item.CONTENT_INFO);
							 }
							 else {
								 folderLog(Level.FINE, ""adding "" + profileDef + "" to FetchProfile."");
								 fp.add(profileDef);
							 }
						 }
					 }
				 }
				 else if (type.equalsIgnoreCase(""RowCounter"")) {
					 colvals.addElement(RowCounter.getInstance());
				 }
				 else {
					 String value = Pooka.getProperty(tableType + ""."" + tmp + "".value"", tmp);
					 colvals.addElement(value);
					 String fpValue = Pooka.getProperty(tableType + ""."" + tmp + "".profileItems"", value);
					 fp.add(fpValue);
				 }
				 colnames.addElement(Pooka.getProperty(tableType + ""."" + tmp + "".label"", tmp));
				 String value = Pooka.getProperty(getFolderProperty() + "".columnsize."" + tmp + "".value"", Pooka.getProperty(tableType + ""."" + tmp + "".value"", tmp));
				 colsizes.addElement(Pooka.getProperty(getFolderProperty() + "".columnsize."" + tmp + "".value"", Pooka.getProperty(tableType + ""."" + tmp + "".size"", tmp)));
			 }
			 setColumnNames(colnames);
			 setColumnValues(colvals);
			 setColumnSizes(colsizes);
			 setColumnIds(colIds);
		 }
		 if (filterHeaders != null) {
			 for (int i = 0;
			 i < filterHeaders.size();
			 i++) {
				 fp.add((String) filterHeaders.get(i));
			 }
		 }
		 if (getLogger().isLoggable(Level.FINE)) {
			 folderLog(Level.FINE, ""created fetch profile."");
			 String[] headers = fp.getHeaderNames();
			 if (headers != null) {
				 for (int i = 0;
				 i < headers.length;
				 i++) {
					 folderLog(Level.FINE, ""headers[""+i+""]="" + headers[i]);
				 }
			 }
			 folderLog(Level.FINE, ""headers done."");
		 }
		 return fp;
	 }
	 protected void updateDisplay(boolean start) {
		 if (getFolderDisplayUI() != null) {
			 if (start) {
				 getFolderDisplayUI().setBusy(true);
				 getFolderDisplayUI().showStatusMessage(Pooka.getProperty(""messages.Folder.loading.starting"", ""Loading messages.""));
			 }
			 else {
				 getFolderDisplayUI().setBusy(false);
				 getFolderDisplayUI().showStatusMessage(Pooka.getProperty(""messages.Folder.loading.finished"", ""Done loading messages.""));
			 }
		 }
	 }
	 protected void updateFolderStatusForLoading() throws MessagingException, OperationCancelledException {
		 if (! isConnected() ) {
			 openFolder(Folder.READ_WRITE);
		 }
	 }
	 protected void updateNode() {
		 if (getFolderNode() != null) getFolderNode().updateNode();
	 }
	 protected List createInfosAndProxies() throws MessagingException {
		 int fetchBatchSize = 50;
		 try {
			 fetchBatchSize = Integer.parseInt(Pooka.getProperty(""Pooka.fetchBatchSize"", ""50""));
		 }
		 catch (NumberFormatException nfe) {
		 }
		 Vector messageProxies = new Vector();
		 Message[] msgs = folder.getMessages();
		 Message[] toFetch = msgs;
		 if (msgs.length > fetchBatchSize) {
			 toFetch = new Message[fetchBatchSize];
			 System.arraycopy(msgs, msgs.length - fetchBatchSize, toFetch, 0, fetchBatchSize);
		 }
		 folder.fetch(toFetch, fetchProfile);
		 int firstFetched = Math.max(msgs.length - fetchBatchSize, 0);
		 MessageInfo mi;
		 for (int i = 0;
		 i < msgs.length;
		 i++) {
			 mi = new MessageInfo(msgs[i], this);
			 if ( i >= firstFetched) mi.setFetched(true);
			 messageProxies.add(new MessageProxy(getColumnValues() , mi));
			 messageToInfoTable.put(msgs[i], mi);
		 }
		 return messageProxies;
	 }
	 public void runFilters(List proxies) throws MessagingException {
		 if (isConnected()) {
			 Folder current = getFolder();
			 if (current != null && current.isOpen()) {
				 int newCount = current.getNewMessageCount();
				 if (newCount > 0) {
					 int numProxies = proxies.size();
					 List newProxies = new ArrayList();
					 for (int i = 0;
					 i < newCount;
					 i++) {
						 newProxies.add(proxies.get((numProxies - newCount) + i));
					 }
					 proxies.removeAll(applyFilters(newProxies));
				 }
			 }
		 }
	 }
	 protected void updateCache() throws MessagingException {
	 }
	 public synchronized void loadAllMessages() throws MessagingException, OperationCancelledException {
		 if (folderTableModel == null) {
			 updateDisplay(true);
			 if (! isLoaded()) loadFolder();
			 fetchProfile = createColumnInformation();
			 if (mMessageLoader == null) mMessageLoader = createMessageLoader();
			 try {
				 updateFolderStatusForLoading();
				 List messageProxies = createInfosAndProxies();
				 runFilters(messageProxies);
				 FolderTableModel ftm = new FolderTableModel(messageProxies, getColumnNames(), getColumnSizes(), getColumnValues(), getColumnIds());
				 setFolderTableModel(ftm);
				 updateCache();
				 Vector loadImmediately = null;
				 int loadBatchSize = 25;
				 if (messageProxies.size() > loadBatchSize) {
					 int firstUnread = messageProxies.size();
					 if (Pooka.getProperty(""Pooka.autoSelectFirstUnread"", ""true"").equalsIgnoreCase(""true"")) {
						 firstUnread = getFirstUnreadMessage();
					 }
					 int lastLoaded = messageProxies.size() - 1;
					 int firstLoaded = messageProxies.size() - loadBatchSize - 1;
					 if (firstUnread > -1) {
						 if (firstUnread < firstLoaded) {
							 firstLoaded = Math.max(0, firstUnread - 5);
							 lastLoaded = firstLoaded + loadBatchSize;
						 }
					 }
					 loadImmediately = new Vector();
					 for (int i = lastLoaded;
					 i >= firstLoaded;
					 i--) {
						 loadImmediately.add(messageProxies.get(i));
					 }
				 }
				 else {
					 loadImmediately = new Vector(messageProxies);
				 }
				 loadMessageTableInfos(loadImmediately);
				 mMessageLoader.loadMessages(messageProxies);
			 }
			 finally {
				 updateDisplay(false);
			 }
		 }
	 }
	 public void loadMessageTableInfos(Vector messages) {
		 int numMessages = messages.size();
		 MessageProxy mp;
		 int updateCounter = 0;
		 if (numMessages > 0) {
			 int fetchBatchSize = 25;
			 int loadBatchSize = 25;
			 try {
				 fetchBatchSize = Integer.parseInt(Pooka.getProperty(""Pooka.fetchBatchSize"", ""50""));
			 }
			 catch (NumberFormatException nfe) {
			 }
			 FetchProfile fetchProfile = getFetchProfile();
			 int i = numMessages - 1;
			 while ( i >= 0 ) {
				 for (int batchCount = 0;
				 i >=0 && batchCount < loadBatchSize;
				 batchCount++) {
					 mp=(MessageProxy)messages.elementAt(i);
					 if (! mp.getMessageInfo().hasBeenFetched()) {
						 try {
							 int fetchCount = 0;
							 Vector fetchVector = new Vector();
							 for (int j = i;
							 fetchCount < fetchBatchSize && j >= 0;
							 j--) {
								 MessageInfo fetchInfo = ((MessageProxy) messages.elementAt(j)).getMessageInfo();
								 if (! fetchInfo.hasBeenFetched()) {
									 fetchVector.add(fetchInfo);
									 fetchInfo.setFetched(true);
								 }
							 }
							 MessageInfo[] toFetch = new MessageInfo[fetchVector.size()];
							 toFetch = (MessageInfo[]) fetchVector.toArray(toFetch);
							 this.fetch(toFetch, fetchProfile);
						 }
						 catch(MessagingException me) {
							 folderLog(Level.FINE, ""caught error while fetching for folder "" + getFolderID() + "": "" + me);
							 me.printStackTrace();
						 }
					 }
					 try {
						 if (! mp.isLoaded()) mp.loadTableInfo();
						 if (mp.needsRefresh()) mp.refreshMessage();
						 else if (! mp.matchedFilters()) {
							 mp.matchFilters();
						 }
					 }
					 catch (Exception e) {
						 e.printStackTrace();
					 }
					 i--;
				 }
			 }
		 }
	 }
	 public void fetch(MessageInfo[] messages, FetchProfile profile) throws MessagingException {
		 Message[] realMsgs = new Message[messages.length];
		 for (int i = 0;
		 i < realMsgs.length;
		 i++) {
			 realMsgs[i] = messages[i].getMessage();
		 }
		 getFolder().fetch(realMsgs, profile);
		 for (int i = 0 ;
		 i < messages.length;
		 i++) {
			 messages[i].setFetched(true);
		 }
	 }
	 public void unloadAllMessages() {
		 folderTableModel = null;
	 }
	 public void unloadTableInfos() {
		 if (folderTableModel != null) {
			 List allProxies = folderTableModel.getAllProxies();
			 for (int i = 0;
			 i < allProxies.size();
			 i++) {
				 MessageProxy mp = (MessageProxy) allProxies.get(i);
				 mp.unloadTableInfo();
			 }
			 if (mMessageLoader != null) mMessageLoader.loadMessages(allProxies);
		 }
	 }
	 public void unloadMatchingFilters() {
		 if (folderTableModel != null) {
			 List allProxies = folderTableModel.getAllProxies();
			 for (int i = 0;
			 i < allProxies.size();
			 i++) {
				 MessageProxy mp = (MessageProxy) allProxies.get(i);
				 mp.clearMatchedFilters();
			 }
			 if (mMessageLoader != null) mMessageLoader.loadMessages(allProxies);
		 }
	 }
	 public void refreshHeaders(MessageInfo mi) throws MessagingException {
	 }
	 public void refreshFlags(MessageInfo mi) throws MessagingException {
	 }
	 public void checkFolder() throws javax.mail.MessagingException, OperationCancelledException {
		 folderLog(Level.FINE, ""checking folder "" + getFolderID());
		 if (isConnected()) {
			 Folder current = getFolder();
			 if (current != null && current.isOpen()) {
				 current.getNewMessageCount();
				 current.getUnreadMessageCount();
			 }
			 resetMessageCounts();
		 }
	 }
	 public int getFirstUnreadMessage() {
		 folderLog(Level.FINE, ""getting first unread message"");
		 if (! tracksUnreadMessages()) return -1;
		 if (getFolderTableModel() == null) return -1;
		 try {
			 int countUnread = 0;
			 int i;
			 if (unreadCount > 0) {
				 Message[] messages = getFolder().getMessages();
				 int lastUnreadFound = -1;
				 for (i = messages.length - 1;
				 ( i >= 0 && countUnread < unreadCount) ;
				 i--) {
					 if (!(messages[i].isSet(Flags.Flag.SEEN))) {
						 lastUnreadFound = i;
						 countUnread++;
					 }
				 }
				 if (lastUnreadFound != -1) {
					 folderLog(Level.FINE, ""Returning "" + (lastUnreadFound + 1));
					 return lastUnreadFound;
				 }
				 else {
					 folderLog(Level.FINE, ""unreads detected, but none found."");
					 return -1;
				 }
			 }
			 else {
				 folderLog(Level.FINE, ""Returning -1"");
				 return -1;
			 }
		 }
		 catch (MessagingException me) {
			 folderLog(Level.FINE, ""Messaging Exception. Returning -1"");
			 return -1;
		 }
	 }
	 public void updateChildren() {
		 Vector<FolderInfo> newChildren = new Vector();
		 List<String> newChildNames = Pooka.getResources().getPropertyAsList(getFolderProperty() + "".folderList"", """");
		 for (String newFolderName: newChildNames) {
			 FolderInfo childFolder = getChild(newFolderName);
			 if (childFolder == null) {
				 childFolder = createChildFolder(newFolderName);
			 }
			 newChildren.add(0, childFolder);
			 children = newChildren;
		 }
		 if (folderNode != null) folderNode.loadChildren();
	 }
	 protected FolderInfo createChildFolder(String newFolderName) {
		 return new FolderInfo(this, newFolderName);
	 }
	 public FolderInfo getChild(String childName) {
		 folderLog(Level.FINE, ""folder "" + getFolderID() + "" getting child "" + childName);
		 FolderInfo childFolder = null;
		 String folderName = null, subFolderName = null;
		 if (children != null) {
			 int divider = childName.indexOf('/');
			 if (divider > 0) {
				 folderName = childName.substring(0, divider);
				 if (divider < childName.length() - 1) subFolderName = childName.substring(divider + 1);
			 }
			 else folderName = childName;
			 folderLog(Level.FINE, ""getting direct child "" + folderName);
			 for (int i = 0;
			 i < children.size();
			 i++) if (((FolderInfo)children.elementAt(i)).getFolderName().equals(folderName)) childFolder = (FolderInfo)children.elementAt(i);
		 }
		 else {
			 folderLog(Level.FINE, ""children of "" + getFolderID() + "" is null."");
		 }
		 if (childFolder != null && subFolderName != null) return childFolder.getChild(subFolderName);
		 else return childFolder;
	 }
	 public FolderInfo getFolderById(String folderID) {
		 FolderInfo childFolder = null;
		 if (getFolderID().equals(folderID)) return this;
		 if (children != null) {
			 for (int i = 0;
			 i < children.size();
			 i++) {
				 FolderInfo possibleMatch = ((FolderInfo)children.elementAt(i)).getFolderById(folderID);
				 if (possibleMatch != null) {
					 return possibleMatch;
				 }
			 }
		 }
		 return null;
	 }
	 public LoadMessageThread createLoaderThread() {
		 LoadMessageThread lmt = new LoadMessageThread(this);
		 return lmt;
	 }
	 public MessageLoader createMessageLoader() {
		 MessageLoader ml = new MessageLoader(this);
		 return ml;
	 }
	 public MessageLoader getMessageLoader() {
		 return mMessageLoader;
	 }
	 public Message getRealMessage(MessageInfo mi) throws MessagingException {
		 return mi.getMessage();
	 }
	 public void setFlags(MessageInfo[] msgs, Flags flag, boolean value) throws MessagingException {
		 Message[] m = new Message[msgs.length];
		 for (int i = 0;
		 i < msgs.length;
		 i++) {
			 m[i] = msgs[i].getRealMessage();
		 }
		 getFolder().setFlags(m, flag, value);
	 }
	 public void copyMessages(MessageInfo[] msgs, FolderInfo targetFolder) throws MessagingException, OperationCancelledException {
		 if (targetFolder == null) {
			 throw new MessagingException(Pooka.getProperty(""error.null"", ""Error: null folder""));
		 }
		 else if (targetFolder.getStatus() == INVALID) {
			 throw new MessagingException(Pooka.getProperty(""error.folderInvalid"", ""Error: folder is invalid. "") + targetFolder.getFolderID());
		 }
		 if (! targetFolder.isAvailable()) targetFolder.loadFolder();
		 synchronized(targetFolder.getFolderThread().getRunLock()) {
			 Folder target = targetFolder.getFolder();
			 if (target != null) {
				 Message[] m = new Message[msgs.length];
				 for (int i = 0;
				 i < msgs.length;
				 i++) {
					 m[i] = msgs[i].getRealMessage();
				 }
				 getFolder().copyMessages(m, target);
				 targetFolder.checkFolder();
			 }
			 else {
				 targetFolder.appendMessages(msgs);
			 }
		 }
	 }
	 public void appendMessages(MessageInfo[] msgs) throws MessagingException, OperationCancelledException {
		 if (! isSortaOpen()) openFolder(Folder.READ_WRITE);
		 Message[] m = new Message[msgs.length];
		 for (int i = 0;
		 i < msgs.length;
		 i++) {
			 m[i] = msgs[i].getRealMessage();
		 }
		 getFolder().appendMessages(m);
	 }
	 public void expunge() throws MessagingException, OperationCancelledException {
		 getFolder().expunge();
	 }
	 public void fireMessageChangedEvent(MessageChangedEvent mce) {
		 Object[] listeners = eventListeners.getListenerList();
		 for (int i = listeners.length-2;
		 i>=0;
		 i-=2) {
			 if (listeners[i]==MessageChangedListener.class) {
				 ((MessageChangedListener)listeners[i+1]).messageChanged(mce);
			 }
		 }
	 }
	 public void addConnectionListener(ConnectionListener newListener) {
		 eventListeners.add(ConnectionListener.class, newListener);
	 }
	 public void removeConnectionListener(ConnectionListener oldListener) {
		 eventListeners.remove(ConnectionListener.class, oldListener);
	 }
	 public void fireConnectionEvent(ConnectionEvent e) {
		 Object[] listeners = eventListeners.getListenerList();
		 for (int i = listeners.length-2;
		 i>=0;
		 i-=2) {
			 if (listeners[i]==ConnectionListener.class) {
				 ConnectionListener listener = (ConnectionListener) listeners[i+1];
				 if (e.getType() == ConnectionEvent.CLOSED) listener.closed(e);
				 else if (e.getType() == ConnectionEvent.DISCONNECTED) listener.disconnected(e);
				 else if (e.getType() == ConnectionEvent.OPENED) listener.opened(e);
			 }
		 }
	 }
	 public void valueChanged(String changedValue) {
		 if (changedValue.equals(getFolderProperty() + "".folderList"")) {
			 final Runnable runMe = new Runnable() {
				 public void run() {
					 ((javax.swing.tree.DefaultTreeModel)(((FolderPanel)folderNode.getParentContainer()).getFolderTree().getModel())).nodeStructureChanged(folderNode);
				 }
			 }
			;
			 if (Thread.currentThread() != getFolderThread()) {
				 getFolderThread().addToQueue(new javax.swing.AbstractAction() {
					 public void actionPerformed(java.awt.event.ActionEvent e) {
						 updateChildren();
						 if (folderNode != null) {
							 javax.swing.SwingUtilities.invokeLater(runMe);
						 }
					 }
				 }
				 , new java.awt.event.ActionEvent(this, 0, ""open-all""));
			 }
			 else {
				 updateChildren();
				 if (folderNode != null) {
					 javax.swing.SwingUtilities.invokeLater(runMe);
				 }
			 }
		 }
		 else if (changedValue.equals(getFolderProperty() + "".defaultProfile"")) {
			 String newProfileValue = Pooka.getProperty(changedValue, """");
			 if (newProfileValue.length() < 1 || newProfileValue.equals(UserProfile.S_DEFAULT_PROFILE_KEY)) defaultProfile = null;
			 else defaultProfile = Pooka.getPookaManager().getUserProfileManager().getProfile(newProfileValue);
		 }
		 else if (changedValue.equals(getFolderProperty() + "".backendFilters"")) {
			 createFilters();
		 }
		 else if (changedValue.equals(getFolderProperty() + "".displayFilters"")) {
			 createFilters();
			 unloadMatchingFilters();
		 }
		 else if (changedValue.equals(getFolderProperty() + "".notifyNewMessagesMain"") || changedValue.equals(getFolderProperty() + "".notifyNewMessagesNode"")) {
			 setNotifyNewMessagesMain(!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesMain"", """").equalsIgnoreCase(""false""));
			 setNotifyNewMessagesNode(!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesNode"", """").equalsIgnoreCase(""false""));
		 }
	 }
	 public void createSubFolder(String subFolderName, int type) throws MessagingException, OperationCancelledException {
		 if ( ! isLoaded()) {
			 loadFolder();
		 }
		 if (folder != null) {
			 Folder subFolder = folder.getFolder(subFolderName);
			 if (subFolder == null) {
				 throw new MessagingException(""Store returned null for subfolder "" + subFolderName + "" of folder "" + getFolderName());
			 }
			 if (! subFolder.exists()) subFolder.create(type);
			 subscribeFolder(subFolderName);
		 }
		 else {
			 throw new MessagingException(""Failed to open folder "" + getFolderName() + "" to create subfolder "" + subFolderName);
		 }
	 }
	 public void subscribeFolder(String folderName) {
		 folderLog(Level.FINE, ""Folder "" + getFolderID() + "" subscribing subfolder "" + folderName);
		 String subFolderName = null;
		 String childFolderName = null;
		 int firstSlash = folderName.indexOf('/');
		 while (firstSlash == 0) {
			 folderName = folderName.substring(1);
			 firstSlash = folderName.indexOf('/');
		 }
		 if (firstSlash > 0) {
			 childFolderName = folderName.substring(0, firstSlash);
			 if (firstSlash < folderName.length() -1) subFolderName = folderName.substring(firstSlash +1);
		 }
		 else childFolderName = folderName;
		 folderLog(Level.FINE, ""Folder "" + getFolderID() + "" subscribing folder "" + childFolderName + "", plus subfolder "" + subFolderName);
		 this.addToFolderList(childFolderName);
		 FolderInfo childFolder = getChild(childFolderName);
		 folderLog(Level.FINE, ""got child folder "" + childFolder + "" from childFolderName "" + childFolderName);
		 if (childFolder != null && subFolderName != null) {
			 childFolder.subscribeFolder(subFolderName);
		 }
		 try {
			 if (childFolder != null && childFolder.isLoaded() == false) childFolder.loadFolder();
		 }
		 catch (MessagingException me) {
			 folderLog(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception from parentStore getting folder: "" + me);
			 if (getLogger().isLoggable(Level.FINE)) me.printStackTrace();
		 }
		 catch (OperationCancelledException me) {
		 }
		 updateChildren();
	 }
	 void addToFolderList(String addFolderName) {
		 Vector folderNames = Pooka.getResources().getPropertyAsVector(getFolderProperty() + "".folderList"", """");
		 boolean found = false;
		 for (int i = 0;
		 i < folderNames.size();
		 i++) {
			 String folderName = (String) folderNames.elementAt(i);
			 if (folderName.equals(addFolderName)) {
				 found=true;
			 }
		 }
		 if (!found) {
			 String currentValue = Pooka.getProperty(getFolderProperty() + "".folderList"", """");
			 if (currentValue.equals("""")) Pooka.setProperty(getFolderProperty() + "".folderList"", addFolderName);
			 else Pooka.setProperty(getFolderProperty() + "".folderList"", currentValue + "":"" + addFolderName);
		 }
	 }
	 void removeFromFolderList(String removeFolderName) {
		 Vector folderNames = Pooka.getResources().getPropertyAsVector(getFolderProperty() + "".folderList"", """");
		 boolean first = true;
		 StringBuffer newValue = new StringBuffer();
		 String folderName;
		 for (int i = 0;
		 i < folderNames.size();
		 i++) {
			 folderName = (String) folderNames.elementAt(i);
			 if (! folderName.equals(removeFolderName)) {
				 if (!first) newValue.append("":"");
				 newValue.append(folderName);
				 first = false;
			 }
		 }
		 Pooka.setProperty(getFolderProperty() + "".folderList"", newValue.toString());
	 }
	 public void unsubscribe() {
		 cleanup();
		 if (parentFolder != null) parentFolder.removeFromFolderList(getFolderName());
		 else if (parentStore != null) parentStore.removeFromFolderList(getFolderName());
		 try {
			 if (folder != null) folder.setSubscribed(false);
		 }
		 catch (MessagingException me) {
			 Pooka.getUIFactory().showError(Pooka.getProperty(""error.folder.unsubscribe"", ""Error unsubscribing on server from folder "") + getFolderID(), me);
		 }
	 }
	 public void delete() throws MessagingException, OperationCancelledException {
		 if (! isLoaded()) loadFolder();
		 Folder f = getFolder();
		 if (f == null) throw new MessagingException(""No folder."");
		 unsubscribe();
		 if (f.isOpen()) f.close(true);
		 f.delete(true);
	 }
	 protected void cleanup() {
		 Pooka.getResources().removeValueChangeListener(this);
		 Folder f = getFolder();
		 if (f != null) {
			 removeFolderListeners();
		 }
		 if (children != null && children.size() > 0) {
			 for (int i = 0;
			 i < children.size();
			 i++) ((FolderInfo)children.elementAt(i)).cleanup();
		 }
		 Pooka.getLogManager().removeLogger(getFolderProperty());
		 if (getFolderDisplayUI() != null) getFolderDisplayUI().closeFolderDisplay();
	 }
	 public boolean useTrashFolder() {
		 if (isTrashFolder()) return false;
		 String prop = Pooka.getProperty(getFolderProperty() + "".useTrashFolder"", """");
		 if (!prop.equals("""")) return (! prop.equalsIgnoreCase(""false""));
		 if (getParentFolder() != null) return getParentFolder().useTrashFolder();
		 else if (getParentStore() != null) return getParentStore().useTrashFolder();
		 else return (! Pooka.getProperty(""Pooka.useTrashFolder"", ""true"").equalsIgnoreCase(""true""));
	 }
	 public void emptyTrash() {
		 if (isTrashFolder()) {
			 try {
				 Message[] allMessages = getFolder().getMessages();
				 getFolder().setFlags(allMessages, new Flags(Flags.Flag.DELETED), true);
				 getFolder().expunge();
			 }
			 catch (MessagingException me) {
				 String m = Pooka.getProperty(""error.trashFolder.EmptyTrashError"", ""Error emptying Trash:"") +""\n"" + me.getMessage();
				 if (getFolderDisplayUI() != null) getFolderDisplayUI().showError(m);
				 else folderLog(Level.FINE, m);
			 }
		 }
	 }
	 public void resetDefaultActions() {
		 if (isTrashFolder()) {
			 defaultActions = new Action[] {
			 new net.suberic.util.thread.ActionWrapper(new UpdateCountAction(), getFolderThread()), new net.suberic.util.thread.ActionWrapper(new EmptyTrashAction(), getFolderThread()), new EditPropertiesAction() }
			;
		 }
		 else if (isOutboxFolder()) {
			 defaultActions = new Action[] {
			 new net.suberic.util.thread.ActionWrapper(new UpdateCountAction(), getFolderThread()), new net.suberic.util.thread.ActionWrapper(new SendAllAction(), getFolderThread()), new EditPropertiesAction() }
			;
		 }
		 else {
			 defaultActions = new Action[] {
			 new net.suberic.util.thread.ActionWrapper(new UpdateCountAction(), getFolderThread()), new EditPropertiesAction() }
			;
		 }
	 }
	 public MessageProxy getMessageProxy(int rowNumber) {
		 return getFolderTableModel().getMessageProxy(rowNumber);
	 }
	 public MessageInfo getMessageInfo(Message m) {
		 return (MessageInfo)messageToInfoTable.get(m);
	 }
	 public void addMessageCountListener(MessageCountListener newListener) {
		 eventListeners.add(MessageCountListener.class, newListener);
	 }
	 public void removeMessageCountListener(MessageCountListener oldListener) {
		 eventListeners.remove(MessageCountListener.class, oldListener);
	 }
	 public void fireMessageCountEvent(MessageCountEvent mce) {
		 Object[] listeners = eventListeners.getListenerList();
		 if (mce.getType() == MessageCountEvent.ADDED) {
			 for (int i = listeners.length-2;
			 i>=0;
			 i-=2) {
				 if (listeners[i]==MessageCountListener.class) {
					 ((MessageCountListener)listeners[i+1]).messagesAdded(mce);
				 }
			 }
		 }
		 else if (mce.getType() == MessageCountEvent.REMOVED) {
			 for (int i = listeners.length-2;
			 i>=0;
			 i-=2) {
				 if (listeners[i]==MessageCountListener.class) {
					 ((MessageCountListener)listeners[i+1]).messagesRemoved(mce);
				 }
			 }
		 }
	 }
	 public void addMessageChangedListener(MessageChangedListener newListener) {
		 eventListeners.add(MessageChangedListener.class, newListener);
	 }
	 public void removeMessageChangedListener(MessageChangedListener oldListener) {
		 eventListeners.remove(MessageChangedListener.class, oldListener);
	 }
	 public void messagesAdded(MessageCountEvent e) {
		 folderLog(Level.FINE, ""Messages added."");
		 if (Thread.currentThread() == getFolderThread() ) runMessagesAdded(e);
		 else getFolderThread().addToQueue(new net.suberic.util.thread.ActionWrapper(new javax.swing.AbstractAction() {
			 public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
				 runMessagesAdded((MessageCountEvent)actionEvent.getSource());
			 }
		 }
		, getFolderThread()), new java.awt.event.ActionEvent(e, 1, ""message-count-changed""));
	 }
	 protected void runMessagesAdded(MessageCountEvent mce) {
		 folderLog(Level.FINE, ""running messagesAdded on FolderInfo."");
		 if (folderTableModel != null) {
			 Message[] addedMessages = mce.getMessages();
			 MessageInfo mp;
			 Vector addedProxies = new Vector();
			 folderLog(Level.FINE, ""running messagesAdded: creating "" + addedMessages.length + "" proxies/MessageInfos."");
			 for (int i = 0;
			 i < addedMessages.length;
			 i++) {
				 mp = new MessageInfo(addedMessages[i], FolderInfo.this);
				 addedProxies.add(new MessageProxy(getColumnValues(), mp));
				 messageToInfoTable.put(addedMessages[i], mp);
			 }
			 folderLog(Level.FINE, ""filtering proxies."");
			 addedProxies.removeAll(applyFilters(addedProxies));
			 if (addedProxies.size() > 0) {
				 folderLog(Level.FINE, ""filters run;
				 adding "" + addedProxies.size() + "" messages."");
				 getFolderTableModel().addRows(addedProxies);
				 setNewMessages(true);
				 resetMessageCounts();
				 MessageProxy[] addedArray = (MessageProxy[]) addedProxies.toArray(new MessageProxy[0]);
				 mMessageLoader.loadMessages(addedArray, MessageLoader.HIGH);
				 fireMessageCountEvent(mce);
			 }
		 }
	 }
	 public void messagesRemoved(MessageCountEvent e) {
		 folderLog(Level.FINE, ""Messages Removed."");
		 if (Thread.currentThread() == getFolderThread() ) {
			 runMessagesRemoved(e);
		 }
		 else {
			 getFolderThread().addToQueue(new net.suberic.util.thread.ActionWrapper(new javax.swing.AbstractAction() {
				 public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
					 runMessagesRemoved((MessageCountEvent)actionEvent.getSource());
				 }
			 }
			, getFolderThread()), new java.awt.event.ActionEvent(e, 1, ""messages-removed""));
		 }
	 }
	 protected void runMessagesRemoved(MessageCountEvent mce) {
		 folderLog(Level.FINE, ""running MessagesRemoved on "" + getFolderID());
		 if (folderTableModel != null) {
			 Message[] removedMessages = mce.getMessages();
			 folderLog(Level.FINE, ""removedMessages was of size "" + removedMessages.length);
			 MessageInfo mi;
			 Vector removedProxies=new Vector();
			 if (getLogger().isLoggable(Level.FINE)) {
				 folderLog(Level.FINE, ""message in info table:"");
				 Iterator<Message> keyIter = messageToInfoTable.keySet().iterator();
				 while (keyIter.hasNext()) {
					 folderLog(Level.FINE, keyIter.next().toString());
				 }
			 }
			 for (int i = 0;
			 i < removedMessages.length;
			 i++) {
				 folderLog(Level.FINE, ""checking for existence of message "" + removedMessages[i]);
				 mi = getMessageInfo(removedMessages[i]);
				 if (mi != null) {
					 if (mi.getMessageProxy() != null) mi.getMessageProxy().close();
					 folderLog(Level.FINE, ""message exists--removing"");
					 removedProxies.add(mi.getMessageProxy());
					 messageToInfoTable.remove(removedMessages[i]);
				 }
			 }
			 if (getFolderDisplayUI() != null) {
				 if (removedProxies.size() > 0) getFolderDisplayUI().removeRows(removedProxies);
				 resetMessageCounts();
				 fireMessageCountEvent(mce);
			 }
			 else {
				 resetMessageCounts();
				 fireMessageCountEvent(mce);
				 if (removedProxies.size() > 0) getFolderTableModel().removeRows(removedProxies);
			 }
		 }
		 else {
			 resetMessageCounts();
			 fireMessageCountEvent(mce);
		 }
	 }
	 public void messageChanged(MessageChangedEvent e) {
		 if (Thread.currentThread() == getFolderThread() ) runMessageChanged(e);
		 else getFolderThread().addToQueue(new net.suberic.util.thread.ActionWrapper(new javax.swing.AbstractAction() {
			 public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
				 runMessageChanged((MessageChangedEvent)actionEvent.getSource());
			 }
		 }
		, getFolderThread()), new java.awt.event.ActionEvent(e, 1, ""message-changed""));
	 }
	 protected void runMessageChanged(MessageChangedEvent mce) {
		 boolean updateInfo = false;
		 try {
			 updateInfo = (!mce.getMessage().isSet(Flags.Flag.DELETED) || ! Pooka.getProperty(""Pooka.autoExpunge"", ""true"").equalsIgnoreCase(""true""));
		 }
		 catch (MessagingException me) {
		 }
		 if (updateInfo) {
			 try {
				 MessageInfo mi = getMessageInfo(mce.getMessage());
				 MessageProxy mp = mi.getMessageProxy();
				 if (mp != null) {
					 mp.unloadTableInfo();
					 mp.loadTableInfo();
					 if (mce.getMessageChangeType() == MessageChangedEvent.FLAGS_CHANGED) mi.refreshFlags();
					 else if (mce.getMessageChangeType() == MessageChangedEvent.ENVELOPE_CHANGED) mi.refreshHeaders();
				 }
			 }
			 catch (MessagingException me) {
			 }
			 if (! (mce instanceof net.suberic.pooka.event.MessageTableInfoChangedEvent)) {
				 resetMessageCounts();
			 }
		 }
		 fireMessageChangedEvent(mce);
	 }
	 public void showSearchFolder() {
		 Pooka.getUIFactory().showSearchForm(new FolderInfo[] {
		 this }
		);
	 }
	 public static void searchFolders(Vector folderList, javax.mail.search.SearchTerm term) {
		 final javax.mail.search.SearchTerm searchTerm = term;
		 final Vector selectedFolders = folderList;
		 Pooka.getSearchThread().addToQueue(new net.suberic.util.thread.ActionWrapper(new javax.swing.AbstractAction() {
			 public void actionPerformed(ActionEvent e) {
				 Vector matchingValues = new Vector();
				 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""init: matchingValues.size() = "" + matchingValues.size());
				 net.suberic.util.swing.ProgressDialog dialog = Pooka.getUIFactory().createProgressDialog(0,100,0,""Search"",""Searching"");
				 dialog.show();
				 boolean cancelled = dialog.isCancelled();
				 for (int i = 0;
				 ! cancelled && i < selectedFolders.size();
				 i++) {
					 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""trying selected folder number "" + i);
					 try {
						 net.suberic.pooka.MessageInfo[] matches = ((FolderInfo) selectedFolders.elementAt(i)).search(searchTerm);
						 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""matches.length = "" + matches.length);
						 for (int j = 0;
						 j < matches.length;
						 j++) {
							 matchingValues.add(matches[j]);
							 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""adding "" + matches[j] + "" to matchingValues."");
						 }
					 }
					 catch (MessagingException me) {
						 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""caught exception "" + me);
					 }
					 catch (OperationCancelledException oce) {
					 }
					 cancelled = dialog.isCancelled();
				 }
				 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""got "" + matchingValues.size() + "" matches."");
				 if (! cancelled) {
					 FolderInfo[] parentFolders = new FolderInfo[selectedFolders.size()];
					 for (int i = 0;
					 i < selectedFolders.size();
					 i++) {
						 parentFolders[i] = (FolderInfo) selectedFolders.elementAt(i);
					 }
					 MessageInfo[] matchingMessages = new MessageInfo[matchingValues.size()];
					 for (int i = 0;
					 i < matchingValues.size();
					 i++) {
						 Logger.getLogger(""Pooka.debug"").log(Level.FINE, ""matchingValues.elementAt("" + i + "") = "" + matchingValues.elementAt(i));
						 matchingMessages[i] = (MessageInfo) matchingValues.elementAt(i);
					 }
					 final VirtualFolderInfo sfi = new VirtualFolderInfo(matchingMessages, parentFolders);
					 Runnable runMe = new Runnable() {
						 public void run() {
							 FolderDisplayUI fdui = Pooka.getUIFactory().createFolderDisplayUI(sfi);
							 fdui.openFolderDisplay();
						 }
					 }
					;
					 javax.swing.SwingUtilities.invokeLater(runMe);
				 }
				 dialog.dispose();
			 }
		 }
		, Pooka.getSearchThread()), new java.awt.event.ActionEvent(FolderInfo.class, 1, ""search""));
	 }
	 public MessageInfo[] search(javax.mail.search.SearchTerm term) throws MessagingException, OperationCancelledException {
		 if (folderTableModel == null) loadAllMessages();
		 Message[] matchingMessages = folder.search(term);
		 MessageInfo returnValue[] = new MessageInfo[matchingMessages.length];
		 for (int i = 0;
		 i < matchingMessages.length;
		 i++) {
			 folderLog(Level.FINE, ""match "" + i + "" = "" + matchingMessages[i]);
			 MessageInfo info = getMessageInfo(matchingMessages[i]);
			 folderLog(Level.FINE, ""messageInfo "" + i + "" = "" + info);
			 returnValue[i] = info;
		 }
		 folderLog(Level.FINE, ""got "" + returnValue.length + "" results."");
		 return returnValue;
	 }
	 protected String getDefaultDisplayFiltersResource() {
		 if (isSentFolder()) return ""FolderInfo.sentFolderDefaultDisplayFilters"";
		 else return ""FolderInfo.defaultDisplayFilters"";
	 }
	 List filterHeaders = null;
	 public void createFilters() {
		 BackendMessageFilter[] tmpBackendFilters = null;
		 MessageFilter[] tmpDisplayFilters = null;
		 Vector backendFilterNames=Pooka.getResources().getPropertyAsVector(getFolderProperty() + "".backendFilters"", """");
		 if (backendFilterNames != null && backendFilterNames.size() > 0) {
			 tmpBackendFilters = new BackendMessageFilter[backendFilterNames.size()];
			 for (int i = 0;
			 i < backendFilterNames.size();
			 i++) {
				 tmpBackendFilters[i] = new BackendMessageFilter(getFolderProperty() + "".backendFilters."" + (String) backendFilterNames.elementAt(i));
			 }
			 backendFilters = tmpBackendFilters;
		 }
		 Vector foundFilters = new Vector();
		 Vector defaultFilterNames = Pooka.getResources().getPropertyAsVector(getDefaultDisplayFiltersResource(), """");
		 for (int i = 0;
		 i < defaultFilterNames.size();
		 i++) {
			 foundFilters.add(new MessageFilter(""FolderInfo.defaultDisplayFilters."" + (String) defaultFilterNames.elementAt(i)));
		 }
		 Vector displayFilterNames=Pooka.getResources().getPropertyAsVector(getFolderProperty() + "".displayFilters"", """");
		 for (int i = 0;
		 i < displayFilterNames.size();
		 i++) {
			 foundFilters.add(new MessageFilter(getFolderProperty() + "".displayFilters."" + (String) displayFilterNames.elementAt(i)));
		 }
		 tmpDisplayFilters = new MessageFilter[foundFilters.size()];
		 for (int i = 0;
		 i < foundFilters.size();
		 i++) tmpDisplayFilters[i] = (MessageFilter) foundFilters.elementAt(i);
		 displayFilters = tmpDisplayFilters;
		 filterHeaders = new LinkedList();
		 for (int i = 0;
		 i < tmpDisplayFilters.length;
		 i++) {
			 javax.mail.search.SearchTerm filterTerm = tmpDisplayFilters[i].getSearchTerm();
			 if (filterTerm != null) {
				 List headers = getHeaders(filterTerm);
				 filterHeaders.addAll(headers);
			 }
		 }
		 if (fetchProfile != null) {
			 for (int i = 0;
			 i < filterHeaders.size();
			 i++) {
				 fetchProfile.add((String) filterHeaders.get(i));
			 }
		 }
	 }
	 private List getHeaders(SearchTerm term) {
		 List returnValue = new LinkedList();
		 if (term instanceof HeaderTerm) {
			 String headerName = ((HeaderTerm) term).getHeaderName();
			 returnValue.add(headerName);
		 }
		 else if (term instanceof AndTerm) {
			 SearchTerm[] terms = ((AndTerm)term).getTerms();
			 for (int i = 0;
			 i < terms.length;
			 i++) {
				 returnValue.addAll(getHeaders(terms[i]));
			 }
		 }
		 else if (term instanceof OrTerm) {
			 SearchTerm[] terms = ((OrTerm)term).getTerms();
			 for (int i = 0;
			 i < terms.length;
			 i++) {
				 returnValue.addAll(getHeaders(terms[i]));
			 }
		 }
		 else if (term instanceof NotTerm) {
			 SearchTerm otherTerm = ((NotTerm)term).getTerm();
			 returnValue.addAll(getHeaders(otherTerm));
		 }
		 else if (term instanceof FromTerm || term instanceof FromStringTerm) {
			 returnValue.add(""From"");
		 }
		 else if (term instanceof RecipientTerm || term instanceof RecipientStringTerm) {
			 Message.RecipientType type;
			 if (term instanceof RecipientTerm) type = ((RecipientTerm) term).getRecipientType();
			 else type = ((RecipientStringTerm) term).getRecipientType();
			 if (type == Message.RecipientType.TO) returnValue.add(""To"");
			 else if (type == Message.RecipientType.CC) returnValue.add(""Cc"");
			 else if (type == Message.RecipientType.BCC) returnValue.add(""Bcc"");
		 }
		 return returnValue;
	 }
	 public Vector applyFilters(List messages) {
		 return applyFilters(messages, null);
	 }
	 public Vector applyFilters(List messages, net.suberic.util.swing.ProgressDialog pd) {
		 Vector notRemovedYet = new Vector(messages);
		 Vector removed = new Vector();
		 if (backendFilters != null) for (int i = 0;
		 i < backendFilters.length;
		 i++) {
			 if (backendFilters[i] != null) {
				 List justRemoved = backendFilters[i].filterMessages(notRemovedYet, pd);
				 removed.addAll(justRemoved);
				 notRemovedYet.removeAll(justRemoved);
			 }
		 }
		 if (removed.size() > 0) {
			 try {
				 expunge();
			 }
			 catch (OperationCancelledException oce) {
			 }
			 catch (MessagingException me) {
				 me.printStackTrace();
			 }
		 }
		 return removed;
	 }
	 public BackendMessageFilter[] getBackendFilters() {
		 return backendFilters;
	 }
	 public Action[] getActions() {
		 return defaultActions;
	 }
	 public Folder getFolder() {
		 return folder;
	 }
	 protected void setFolder(Folder newValue) {
		 folder=newValue;
	 }
	 public String getFolderID() {
		 return folderID;
	 }
	 private void setFolderID(String newValue) {
		 folderID=newValue;
	 }
	 public String getFolderName() {
		 return mFolderName;
	 }
	 public String getFolderDisplayName() {
		 return mFolderName + "" - "" + getParentStore().getStoreID();
	 }
	 public String getFolderProperty() {
		 return ""Store."" + getFolderID();
	 }
	 public Vector getChildren() {
		 return children;
	 }
	 public FolderNode getFolderNode() {
		 return folderNode;
	 }
	 public void setFolderNode(FolderNode newValue) {
		 folderNode = newValue;
	 }
	 public FolderTableModel getFolderTableModel() {
		 return folderTableModel;
	 }
	 public void setFolderTableModel(FolderTableModel newValue) {
		 folderTableModel = newValue;
	 }
	 public List getColumnValues() {
		 return columnValues;
	 }
	 public void setColumnValues(List newValue) {
		 columnValues = newValue;
	 }
	 public List<String> getColumnIds() {
		 return columnIds;
	 }
	 public void setColumnIds(List<String> newColumnIds) {
		 columnIds = newColumnIds;
	 }
	 public List<String> getColumnNames() {
		 return columnNames;
	 }
	 public void setColumnNames(List<String> newValue) {
		 columnNames = newValue;
	 }
	 public List<String> getColumnSizes() {
		 return columnSizes;
	 }
	 public void setColumnSizes(List<String> newValue) {
		 columnSizes = newValue;
	 }
	 public FolderDisplayUI getFolderDisplayUI() {
		 return folderDisplayUI;
	 }
	 protected void removeFromListeners(FolderDisplayUI display) {
		 if (display != null) {
			 removeMessageChangedListener(display);
			 removeMessageCountListener(display);
		 }
	 }
	 protected void addToListeners(FolderDisplayUI display) {
		 if (display != null) {
			 addMessageChangedListener(display);
			 addMessageCountListener(display);
		 }
	 }
	 public void setFolderDisplayUI(FolderDisplayUI newValue) {
		 removeFromListeners(folderDisplayUI);
		 folderDisplayUI = newValue;
		 addToListeners(folderDisplayUI);
	 }
	 public int getType() {
		 return type;
	 }
	 public boolean isConnected() {
		 return (status == CONNECTED);
	 }
	 public boolean shouldBeConnected() {
		 return (status < PASSIVE);
	 }
	 public boolean isSortaOpen() {
		 return (status < CLOSED);
	 }
	 public boolean isAvailable() {
		 return (status < NOT_LOADED);
	 }
	 public boolean isLoaded() {
		 return (folder != null);
	 }
	 public boolean isValid() {
		 return (status != INVALID);
	 }
	 public boolean hasUnread() {
		 return (tracksUnreadMessages() && unreadCount > 0);
	 }
	 public int getUnreadCount() {
		 if (!tracksUnreadMessages()) return 0;
		 else return unreadCount;
	 }
	 public int getMessageCount() {
		 return messageCount;
	 }
	 public boolean hasNewMessages() {
		 return newMessages;
	 }
	 public void setNewMessages(boolean newValue) {
		 newMessages = newValue;
	 }
	 public FolderTracker getFolderTracker() {
		 return folderTracker;
	 }
	 public void setFolderTracker(FolderTracker newTracker) {
		 folderTracker = newTracker;
	 }
	 public boolean isTrashFolder() {
		 return trashFolder;
	 }
	 public void setTrashFolder(boolean newValue) {
		 trashFolder = newValue;
		 if (newValue) {
			 setNotifyNewMessagesMain(false);
			 setNotifyNewMessagesNode(false);
		 }
		 else {
			 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesMain"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesMain(true);
			 else setNotifyNewMessagesMain(false);
			 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesNode"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesNode(true);
			 else setNotifyNewMessagesNode(false);
		 }
		 resetDefaultActions();
		 if (getFolderNode() != null) getFolderNode().popupMenu = null;
	 }
	 public boolean isSentFolder() {
		 return sentFolder;
	 }
	 public void setSentFolder(boolean newValue) {
		 sentFolder = newValue;
		 if (newValue) {
			 setNotifyNewMessagesMain(false);
			 setNotifyNewMessagesNode(false);
		 }
		 else {
			 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesMain"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesMain(true);
			 else setNotifyNewMessagesMain(false);
			 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesNode"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesNode(true);
			 else setNotifyNewMessagesNode(false);
		 }
		 setTracksUnreadMessages (! newValue);
		 createFilters();
	 }
	 public boolean isOutboxFolder() {
		 return (mailServer != null);
	 }
	 public void setOutboxFolder(OutgoingMailServer newServer) {
		 mailServer = newServer;
		 if (newServer != null) {
			 setNotifyNewMessagesMain(false);
			 setNotifyNewMessagesNode(false);
		 }
		 else {
			 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesMain"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesMain(true);
			 else setNotifyNewMessagesMain(false);
			 if (!Pooka.getProperty(getFolderProperty() + "".notifyNewMessagesNode"", """").equalsIgnoreCase(""false"")) setNotifyNewMessagesNode(true);
			 else setNotifyNewMessagesNode(false);
		 }
		 resetDefaultActions();
	 }
	 public boolean notifyNewMessagesMain() {
		 return notifyNewMessagesMain;
	 }
	 public void setNotifyNewMessagesMain(boolean newValue) {
		 notifyNewMessagesMain = newValue;
	 }
	 public boolean notifyNewMessagesNode() {
		 return notifyNewMessagesNode;
	 }
	 public void setNotifyNewMessagesNode(boolean newValue) {
		 notifyNewMessagesNode = newValue;
	 }
	 public void setTracksUnreadMessages(boolean newValue) {
		 tracksUnreadMessages = newValue;
	 }
	 public boolean tracksUnreadMessages() {
		 return tracksUnreadMessages;
	 }
	 public MessageFilter[] getDisplayFilters() {
		 return displayFilters;
	 }
	 public void resetMessageCounts() {
		 try {
			 if (getFolder() != null) folderLog(Level.FINE, ""running resetMessageCounts. unread message count is "" + getFolder().getUnreadMessageCount());
			 else folderLog(Level.FINE, ""running resetMessageCounts. getFolder() is null."");
			 if (tracksUnreadMessages()) {
				 unreadCount = getFolder().getUnreadMessageCount();
			 }
			 messageCount = getFolder().getMessageCount();
		 }
		 catch (MessagingException me) {
			 unreadCount = 0;
		 }
		 updateNode();
	 }
	 public FolderInfo getParentFolder() {
		 return parentFolder;
	 }
	 public StoreInfo getParentStore() {
		 if (parentStore == null) return parentFolder.getParentStore();
		 else return parentStore;
	 }
	 public UserProfile getDefaultProfile() {
		 if (defaultProfile != null) {
			 return defaultProfile;
		 }
		 else if (parentFolder != null) {
			 return parentFolder.getDefaultProfile();
		 }
		 else if (parentStore != null) {
			 return parentStore.getDefaultProfile();
		 }
		 else {
			 return null;
		 }
	 }
	 public void setStatus(int newStatus) {
		 synchronized(this) {
			 status = newStatus;
		 }
	 }
	 public int getStatus() {
		 return status;
	 }
	 public ActionThread getFolderThread() {
		 return getParentStore().getStoreThread();
	 }
	 public FolderInfo getTrashFolder() {
		 return getParentStore().getTrashFolder();
	 }
	 public FetchProfile getFetchProfile() {
		 return fetchProfile;
	 }
	 public boolean isNamespace() {
		 return mNamespace;
	 }
	 public void showStatusMessage(net.suberic.pooka.gui.FolderDisplayUI pUI, String message) {
		 if (pUI != null) pUI.showStatusMessage(message);
		 else Pooka.getUIFactory().showStatusMessage(message);
	 }
	 public void clearStatusMessage(net.suberic.pooka.gui.FolderDisplayUI pUI) {
		 if (pUI != null) pUI.clearStatusMessage();
		 else Pooka.getUIFactory().clearStatus();
	 }
	 public Logger getLogger() {
		 if (mLogger == null) {
			 mLogger = Logger.getLogger(getFolderProperty());
		 }
		 return mLogger;
	 }
	 public void folderLog(Level l, String message) {
		 getLogger().log(l, getFolderID() + "": "" + message);
	 }
	 class EditPropertiesAction extends AbstractAction {
		 EditPropertiesAction() {
			 super(""file-edit"");
		 }
		 public void actionPerformed(ActionEvent e) {
			 Pooka.getUIFactory().showEditorWindow(getFolderProperty(), getFolderProperty(), ""Folder.editor"");
		 }
	 }
	 class UpdateCountAction extends AbstractAction {
		 UpdateCountAction() {
			 super(""folder-update"");
		 }
		 public void actionPerformed(ActionEvent e) {
			 try {
				 checkFolder();
			 }
			 catch (OperationCancelledException oce) {
			 }
			 catch (MessagingException me) {
				 final MessagingException me2 = me;
				 javax.swing.SwingUtilities.invokeLater(new Runnable() {
					 public void run() {
						 if (getFolderDisplayUI() != null) getFolderDisplayUI().showError(Pooka.getProperty(""error.updatingFolder"", ""Error updating Folder "") + getFolderID(), me2);
						 else Pooka.getUIFactory().showError(Pooka.getProperty(""error.updatingFolder"", ""Error updating Folder "") + getFolderID(), me2);
					 }
				 }
				);
			 }
		 }
	 }
	 class EmptyTrashAction extends AbstractAction {
		 EmptyTrashAction() {
			 super(""folder-empty"");
		 }
		 public void actionPerformed(ActionEvent e) {
			 emptyTrash();
		 }
	 }
	 class SendAllAction extends AbstractAction {
		 SendAllAction() {
			 super(""folder-send"");
		 }
		 public void actionPerformed(ActionEvent e) {
			 if (isOutboxFolder()) mailServer.sendAll();
		 }
	 }
}",1,0,0,0
"public class JavaxScriptRunner extends ScriptRunnerBase {
	 private ReflectWrapper engine;
	 public String getManagerName() {
		 return ""javax"";
	 }
	 public boolean supportsLanguage() {
		 if (engine != null) {
			 return true;
		 }
		 checkLanguage();
		 ClassLoader origLoader = replaceContextLoader();
		 try {
			 return createEngine() != null;
		 }
		 catch (Exception ex) {
			 return false;
		 }
		 finally {
			 restoreContextLoader(origLoader);
		 }
	 }
	 public void executeScript(String execName) throws BuildException {
		 evaluateScript(execName);
	 }
	 public Object evaluateScript(String execName) throws BuildException {
		 checkLanguage();
		 ClassLoader origLoader = replaceContextLoader();
		 try {
			 ReflectWrapper engine = createEngine();
			 if (engine == null) {
				 throw new BuildException( ""Unable to create javax script engine for "" + getLanguage());
			 }
			 for (Iterator i = getBeans().keySet().iterator();
			 i.hasNext();
			) {
				 String key = (String) i.next();
				 Object value = getBeans().get(key);
				 if (""FX"".equalsIgnoreCase(getLanguage())) {
					 engine.invoke( ""put"", String.class, key + "":"" + value.getClass().getName(), Object.class, value);
				 }
				 else {
					 engine.invoke( ""put"", String.class, key, Object.class, value);
				 }
			 }
			 return engine.invoke(""eval"", String.class, getScript());
		 }
		 catch (BuildException be) {
			 throw unwrap(be);
		 }
		 catch (Exception be) {
			 Throwable t = be;
			 Throwable te = be.getCause();
			 if (te != null) {
				 if (te instanceof BuildException) {
					 throw (BuildException) te;
				 }
				 else {
					 t = te;
				 }
			 }
			 throw new BuildException(t);
		 }
		 finally {
			 restoreContextLoader(origLoader);
		 }
	 }
	 private ReflectWrapper createEngine() throws Exception {
		 if (engine != null) {
			 return engine;
		 }
		 ReflectWrapper manager = new ReflectWrapper( getClass().getClassLoader(), ""javax.script.ScriptEngineManager"");
		 Object e = manager.invoke( ""getEngineByName"", String.class, getLanguage());
		 if (e == null) {
			 return null;
		 }
		 ReflectWrapper ret = new ReflectWrapper(e);
		 if (getKeepEngine()) {
			 this.engine = ret;
		 }
		 return ret;
	 }
	 private static BuildException unwrap(Throwable t) {
		 BuildException deepest = t instanceof BuildException ? (BuildException) t : null;
		 Throwable current = t;
		 while (current.getCause() != null) {
			 current = current.getCause();
			 if (current instanceof BuildException) {
				 deepest = (BuildException) current;
			 }
		 }
		 return deepest;
	 }
}",0,0,0,0
"public void stop() {
	 LOG.info(""Stopping client"");
	 running = false;
 }",0,0,0,0
"public class DimsDataList implements Serializable {
	private static final long serialVersionUID = -5902704017223885965L;
	private List<DimsData> dimsData;
	private boolean expression;
	public DimsDataList() {
	}
	public DimsDataList(List<DimsData> chunk) {
		dimsData = chunk;
	}
	public DimsDataList(int[] dataShape) throws Exception {
		try {
			int xaxis=-1,yaxis=-1;
			for (int i = 0;
			 i<dataShape.length;
			 ++i) {
				add(new DimsData(i));
			}
			for (int i = dataShape.length-1;
			 i>=0;
			 i--) {
				if (dataShape[i]>1) {
					if (yaxis<0) {
						getDimsData(i).setPlotAxis(AxisType.Y);
						yaxis = i;
						continue;
					}
					 else if (xaxis<0) {
						getDimsData(i).setPlotAxis(AxisType.X);
						xaxis = i;
						continue;
					}
				}
			}
			if (yaxis>-1 && xaxis<0) {
				getDimsData(yaxis).setPlotAxis(AxisType.X);
			}
		}
		 finally {
		}
	}
	public Iterable<DimsData> iterable() {
		return dimsData;
	}
	public void add(DimsData dimension) {
		if (dimsData==null) dimsData = new ArrayList<DimsData>(3);
		if (dimsData.size()>dimension.getDimension() && dimension.getDimension()>-1) {
			dimsData.set(dimension.getDimension(), dimension);
		}
		 else {
			dimsData.add(dimension);
		}
	}
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((dimsData == null) ? 0 : dimsData.hashCode());
		return result;
	}
	public boolean equals(Object obj) {
		if (this == obj)return true;
		if (obj == null)return false;
		if (getClass() != obj.getClass())return false;
		DimsDataList other = (DimsDataList) obj;
		if (dimsData == null) {
			if (other.dimsData != null)return false;
		}
		 else if (!dimsData.equals(other.dimsData))return false;
		return true;
	}
	public static Object[] getDefault() {
		return new DimsData[]{
		new DimsData(0)}
		;
	}
	public Object[] getElements() {
		if (dimsData==null) return null;
		return dimsData.toArray(new DimsData[dimsData.size()]);
	}
	public int size() {
		if (dimsData==null) return 0;
		return dimsData.size();
	}
	public DimsData getDimsData(int i) {
		if (dimsData==null) return null;
		return dimsData.get(i);
	}
	public Iterator<DimsData> iterator() {
		if (dimsData==null) return null;
		return dimsData.iterator();
	}
	public void clear() {
		if (dimsData!=null) dimsData.clear();
	}
	public String toString() {
		return toString(null);
	}
	public String toString(int[] shape) {
		final StringBuilder buf = new StringBuilder();
		buf.append(""[ "");
		int index = 0;
		for (DimsData d : dimsData) {
			final int upper = shape!=null ? shape[index] : -1;
			buf.append(d.getUserString(upper));
			if (d!=dimsData.get(dimsData.size()-1)) buf.append("", "");
			++index;
		}
		buf.append("" ]"");
		return buf.toString();
	}
	public boolean isRangeDefined() {
		for (DimsData data : iterable()) {
			if (data.getSliceRange()!=null) return true;
		}
		return false;
	}
	public int getAxisCount() {
		if (dimsData==null) return -1;
		int count = 0;
		for (DimsData dd : dimsData) {
			if (!dd.getPlotAxis().hasValue()) count++;
		}
		return count;
	}
	public int getRangeCount() {
		int count = 0;
		for (DimsData dd : dimsData) {
			if (dd.getPlotAxis()==AxisType.RANGE) count++;
		}
		return count;
	}
	public boolean is2D() {
		return getAxisCount()==2;
	}
	public DimsDataList clone() {
		final DimsDataList clone = new DimsDataList();
		for (DimsData dd : iterable()) {
			DimsData dnew = dd.clone();
			clone.add(dnew);
		}
		clone.expression = expression;
		return clone;
	}
	public void normalise(AxisType axis) {
		for (DimsData dd : iterable()) {
			if (!dd.getPlotAxis().hasValue()) dd.setPlotAxis(axis);
		}
	}
	public void setSingleAxisOnly(AxisType iaxisToFind, AxisType iaxisValue) {
		DimsData found = null;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==iaxisToFind) {
				dd.setPlotAxis(iaxisValue);
				found=dd;
			}
		}
		if (found!=null) {
			for (DimsData dd : iterable()) {
				if (dd==found) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		}
		 else {
			 for (DimsData dd : iterable()) {
				if (!dd.getPlotAxis().hasValue()) {
					 dd.setPlotAxis(iaxisValue);
					 found=dd;
				}
			}
			for (DimsData dd : iterable()) {
				if (dd==found) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
		}
	}
	public void setTwoAxesOnly(AxisType firstAxis, AxisType secondAxis) {
		boolean foundFirst = false, foundSecond = false;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==firstAxis) foundFirst = true;
			if (dd.getPlotAxis()==secondAxis) foundSecond = true;
		}
		if (foundFirst&&foundSecond) {
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis) continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		}
		 else {
			 if (!foundFirst) foundFirst = processAxis(firstAxis, secondAxis);
			if (!foundSecond) foundSecond = processAxis(secondAxis, firstAxis);
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis) continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		}
	}
	public void setThreeAxesOnly(AxisType firstAxis, AxisType secondAxis, AxisType thirdAxis) {
		boolean foundFirst = false, foundSecond = false, foundThird = false;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==firstAxis) foundFirst = true;
			if (dd.getPlotAxis()==secondAxis) foundSecond = true;
			if (dd.getPlotAxis()==thirdAxis) foundThird = true;
		}
		if (foundFirst&&foundSecond&&foundThird) {
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis) continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==thirdAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		}
		 else {
			 if (!foundFirst) foundFirst = processAxis(firstAxis, secondAxis, thirdAxis);
			if (!foundSecond) foundSecond = processAxis(secondAxis, firstAxis, thirdAxis);
			if (!foundThird) foundThird = processAxis(thirdAxis, firstAxis, secondAxis);
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis) continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==thirdAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		}
	}
	private final boolean processAxis(AxisType axis, AxisType... ignoredAxes) {
		final List<Object> ignored = asList(ignoredAxes);
		for (DimsData dd : iterable()) {
			if (!dd.getPlotAxis().hasValue() && !ignored.contains(dd.getPlotAxis())) {
				 dd.setPlotAxis(axis);
				 return true;
			}
		}
		for (DimsData dd : iterable()) {
			if (!ignored.contains(dd.getPlotAxis())) {
				dd.setPlotAxis(axis);
				return true;
			}
		}
		return false;
	}
	 private static final <T> List<T> asList(final Object array) {
		 if (!array.getClass().isArray()) throw new IllegalArgumentException(""Not an array"");
		 return new AbstractList<T>() {
			 public T get(int index) {
				 return (T) Array.get(array, index);
			 }
			 public int size() {
				 return Array.getLength(array);
			 }
		 }
		;
	 }
	public boolean isXFirst() {
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis().hasValue()) continue;
			return dd.getPlotAxis()==AxisType.X;
		}
		return false;
	}
	public void reverseImage() {
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==AxisType.X) {
				dd.setPlotAxis(AxisType.Y);
				continue;
			}
			if (dd.getPlotAxis()==AxisType.Y) {
				dd.setPlotAxis(AxisType.X);
				continue;
			}
		}
	}
	public boolean isExpression() {
		return expression;
	}
	public void setExpression(boolean expression) {
		this.expression = expression;
	}
	public boolean isEmpty() {
		return dimsData==null || dimsData.isEmpty();
	}
	public boolean isAdvanced() {
		for (DimsData dd : iterable()) {
			 if (dd.getPlotAxis().isAdvanced()) return true;
		}
		return false;
	}
	public List<DimsData> getDimsData() {
		return dimsData;
	}
	public void setDimsData(List<DimsData> dimsData) {
		this.dimsData = dimsData;
	}
	public void removeLargeStacks(ISliceSystem slicingSystem, int maxStack) {
		for (DimsData dd : getDimsData()) {
			if (dd.getPlotAxis().isStack(slicingSystem)) {
				if (dd.getSliceRange(true)==null || """".equals(dd.getSliceRange(true)) || ""all"".equals(dd.getSliceRange(true))) {
					final ILazyDataset lz = slicingSystem.getData().getLazySet();
					if (lz!=null) {
						final int size = lz.getShape()[dd.getDimension()];
						if (size>=maxStack) {
							 dd.setSliceRange(""0:25"");
						}
					}
				}
			}
		}
	}
	public Slice[] toSliceArray(int[] dataShape) {
		final Slice[] ret = new Slice[size()];
		for (int i = 0;
		 i < size();
		 i++) {
			DimsData dd = getDimsData(i);
			if (dd.isSlice()) {
				ret[i] = new Slice(dd.getSlice(), dd.getSlice()+1);
			}
			 else {
				ret[i] = new Slice(dataShape[dd.getDimension()]);
			}
		}
		return ret;
	}
	public Map<Integer, String> toMap() {
		final Map<Integer, String> ret = new HashMap<Integer, String>(size());
		for (DimsData dd : iterable()) {
			if (dd.isSlice()) {
				ret.put(dd.getDimension(), String.valueOf(dd.getSlice()));
			}
			 else if (dd.isTextRange()) {
				ret.put(dd.getDimension(), dd.getSliceRange()!=null ? dd.getSliceRange() : ""all"");
			}
			 else if ( dd.getPlotAxis()!=null){
				ret.put(dd.getDimension(), dd.getPlotAxis().getName());
			}
		}
		 return ret;
	}
	public void fromMap(Map<Integer, String> map, int[] shape) {
		clear();
		for (int i = 0;
		 i < shape.length;
		 i++) {
			add(new DimsData(i));
		}
		if (map.isEmpty()) {
			 getDimsData(0).setSliceRange(""all"");
			if (size()==2) {
				getDimsData(1).setPlotAxis(AxisType.X);
			}
			 else if (size()>2) {
				getDimsData(1).setPlotAxis(AxisType.Y);
				getDimsData(2).setPlotAxis(AxisType.X);
				for (int i = 3;
				 i < size();
				 i++) {
					getDimsData(i).setSlice(0);
				}
			}
		}
		 else {
			 int dim = 0;
			for (DimsData dd : iterable()) {
				String value = map.get(dd.getDimension());
				if (value==null) value = map.get(String.valueOf(dd.getDimension()));
				if (value!=null) {
					if (""all"".equals(value)) {
						dd.setPlotAxis(AxisType.RANGE);
						continue;
					}
					AxisType at = AxisType.forLabel(value);
					if (at!=null) {
						dd.setPlotAxis(at);
						continue;
					}
					try {
						dd.setSlice(Integer.parseInt(value));
					}
					 catch (Exception ne) {
						dd.setSliceRange(value);
					}
				}
				 else {
					AxisType type = AxisType.forAxis(dim);
					dd.setPlotAxis(type);
					++dim;
				}
			}
		}
	}
}",1,0,0,0
"protected void splitUserName() {
	 String[] tokens = null;
	 if (userName.indexOf('/') >= 0) {
		 tokens = userName.split(""/"");
	 }
	 else if (userName.indexOf('\\') >= 0) {
		 tokens = userName.split(""\\\\"");
	 }
	 if (tokens != null && tokens.length == 3) {
		 userName = tokens[0] + '\\' + tokens[1];
		 baseMailboxPath = ""/users/"" + tokens[2] + '/';
	 }
 }",0,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 width = originalImage.getWidth();
	 height = originalImage.getHeight();
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 imageM = new int[width][height];
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int col = new Color(originalImage.getRGB(i, j)).getRed();
			 if (blackLetters) {
				 imageM[i][j] = 1 - (col / 255);
			 }
			 else {
				 imageM[i][j] = col / 255;
			 }
		 }
	 }
	 while (true) {
		 int[][] start = new int[width][height];
		 for (int i = 0;
		 i < width;
		 i++) {
			 for (int j = 0;
			 j < height;
			 j++) {
				 start[i][j] = imageM[i][j];
			 }
		 }
		 thiningGuoHallIteration(0);
		 thiningGuoHallIteration(1);
		 boolean same = true;
		 MainforLoop: for (int i = 0;
		 i < width;
		 i++) {
			 for (int j = 0;
			 j < height;
			 j++) {
				 if (start[i][j] != imageM[i][j]) {
					 same = false;
					 break MainforLoop;
				 }
			 }
		 }
		 if (same) {
			 break;
		 }
	 }
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 int col;
			 if (blackLetters) {
				 col = 255 - imageM[i][j] * 255;
			 }
			 else {
				 col = imageM[i][j] * 255;
			 }
			 int rgb = ImageUtilities.colorToRGB(alpha, col, col, col);
			 filteredImage.setRGB(i, j, rgb);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"private void extractDataAndSave(IBatchDAO batchDAO) {
	 if (logger.isDebugEnabled()) {
		 logger.debug(""Extract data and save"");
	 }
	 long startTime = System.currentTimeMillis();
	 try {
		 HistogramMetric.Timer timer = prepareLatency.createTimer();
		 List batchAllCollection = new LinkedList();
		 try {
			 List<PersistenceWorker> persistenceWorkers = new ArrayList<>();
			 persistenceWorkers.addAll(IndicatorProcess.INSTANCE.getPersistentWorkers());
			 persistenceWorkers.addAll(RecordProcess.INSTANCE.getPersistentWorkers());
			 persistenceWorkers.addAll(TopNProcess.INSTANCE.getPersistentWorkers());
			 persistenceWorkers.forEach(worker -> {
				 if (logger.isDebugEnabled()) {
					 logger.debug(""extract {
					}
					 worker data and save"", worker.getClass().getName());
				 }
				 if (worker.flushAndSwitch()) {
					 List<T> batchCollection = worker.buildBatchCollection();
					 if (logger.isDebugEnabled()) {
						 logger.debug(""extract {
						}
						 worker data size: {
						}
						"", worker.getClass().getName(), batchCollection.size());
					 }
					 batchAllCollection.addAll(batchCollection);
				 }
			 }
			);
			 if (debug) {
				 logger.info(""build batch persistence duration: {
				}
				 ms"", System.currentTimeMillis() - startTime);
			 }
		 }
		 finally {
			 timer.finish();
		 }
		 HistogramMetric.Timer executeLatencyTimer = executeLatency.createTimer();
		 try {
			 batchDAO.batchPersistence(batchAllCollection);
		 }
		 finally {
			 executeLatencyTimer.finish();
		 }
	 }
	 catch (Throwable e) {
		 errorCounter.inc();
		 logger.error(e.getMessage(), e);
	 }
	 finally {
		 if (logger.isDebugEnabled()) {
			 logger.debug(""persistence data save finish"");
		 }
	 }
	 if (debug) {
		 logger.info(""batch persistence duration: {
		}
		 ms"", System.currentTimeMillis() - startTime);
	 }
 }",0,0,1,0
"public void configure(JobConf job) {
	 seed = job.getInt(""partition.url.seed"", 0);
	 mode = job.get(PARTITION_MODE_KEY, PARTITION_MODE_HOST);
	 if (!mode.equals(PARTITION_MODE_IP) && !mode.equals(PARTITION_MODE_DOMAIN) && !mode.equals(PARTITION_MODE_HOST)) {
		 LOG.error(""Unknown partition mode : "" + mode + "" - forcing to byHost"");
		 mode = PARTITION_MODE_HOST;
	 }
	 normalizers = new URLNormalizers(job, URLNormalizers.SCOPE_PARTITION);
 }",0,0,0,0
"class IndexedSliceReader extends AbstractIterator<IColumn> implements IColumnIterator{
	 private final ColumnFamily emptyColumnFamily;
	 private final List<IndexHelper.IndexInfo> indexes;
	 private final FileDataInput file;
	 private final ByteBuffer startColumn;
	 private final ByteBuffer finishColumn;
	 private final boolean reversed;
	 private BlockFetcher fetcher;
	 private Deque<IColumn> blockColumns = new ArrayDeque<IColumn>();
	 private AbstractType<?> comparator;
	 public IndexedSliceReader(SSTableReader sstable, FileDataInput input, ByteBuffer startColumn, ByteBuffer finishColumn, boolean reversed) {
		 this.file = input;
		 this.startColumn = startColumn;
		 this.finishColumn = finishColumn;
		 this.reversed = reversed;
		 comparator = sstable.metadata.comparator;
		 try {
			 IndexHelper.skipBloomFilter(file);
			 indexes = IndexHelper.deserializeIndex(file);
			 emptyColumnFamily = ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(sstable.metadata), file);
			 fetcher = indexes == null ? new SimpleBlockFetcher() : new IndexedBlockFetcher();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public ColumnFamily getColumnFamily() {
		 return emptyColumnFamily;
	 }
	 public DecoratedKey getKey() {
		 throw new UnsupportedOperationException();
	 }
	 private boolean isColumnNeeded(IColumn column) {
		 if (startColumn.remaining() == 0 && finishColumn.remaining() == 0) return true;
		 else if (startColumn.remaining() == 0 && !reversed) return comparator.compare(column.name(), finishColumn) <= 0;
		 else if (startColumn.remaining() == 0 && reversed) return comparator.compare(column.name(), finishColumn) >= 0;
		 else if (finishColumn.remaining() == 0 && !reversed) return comparator.compare(column.name(), startColumn) >= 0;
		 else if (finishColumn.remaining() == 0 && reversed) return comparator.compare(column.name(), startColumn) <= 0;
		 else if (!reversed) return comparator.compare(column.name(), startColumn) >= 0 && comparator.compare(column.name(), finishColumn) <= 0;
		 else return comparator.compare(column.name(), startColumn) <= 0 && comparator.compare(column.name(), finishColumn) >= 0;
	 }
	 protected IColumn computeNext() {
		 while (true) {
			 IColumn column = blockColumns.poll();
			 if (column != null && isColumnNeeded(column)) return column;
			 try {
				 if (column == null && !fetcher.getNextBlock()) return endOfData();
			 }
			 catch (IOException e) {
				 throw new RuntimeException(e);
			 }
		 }
	 }
	 public void close() {
	 }
	 interface BlockFetcher {
		 public boolean getNextBlock() throws IOException;
	 }
	 private class IndexedBlockFetcher implements BlockFetcher {
		 private final FileMark mark;
		 private int curRangeIndex;
		 IndexedBlockFetcher() throws IOException {
			 file.readInt();
			 this.mark = file.mark();
			 curRangeIndex = IndexHelper.indexFor(startColumn, indexes, comparator, reversed);
		 }
		 public boolean getNextBlock() throws IOException {
			 if (curRangeIndex < 0 || curRangeIndex >= indexes.size()) return false;
			 IndexHelper.IndexInfo curColPosition = indexes.get(curRangeIndex);
			 if (reversed) {
				 if ((finishColumn.remaining() > 0 && comparator.compare(finishColumn, curColPosition.lastName) > 0) || (startColumn.remaining() > 0 && comparator.compare(startColumn, curColPosition.firstName) < 0)) return false;
			 }
			 else {
				 if ((startColumn.remaining() > 0 && comparator.compare(startColumn, curColPosition.lastName) > 0) || (finishColumn.remaining() > 0 && comparator.compare(finishColumn, curColPosition.firstName) < 0)) return false;
			 }
			 boolean outOfBounds = false;
			 file.reset(mark);
			 FileUtils.skipBytesFully(file, curColPosition.offset);
			 while (file.bytesPastMark(mark) < curColPosition.offset + curColPosition.width && !outOfBounds) {
				 IColumn column = emptyColumnFamily.getColumnSerializer().deserialize(file);
				 if (reversed) blockColumns.addFirst(column);
				 else blockColumns.addLast(column);
				 if (!reversed && finishColumn.remaining() > 0) outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;
				 else if (reversed && startColumn.remaining() > 0) outOfBounds = comparator.compare(column.name(), startColumn) >= 0;
			 }
			 if (reversed) curRangeIndex--;
			 else curRangeIndex++;
			 return true;
		 }
	 }
	 private class SimpleBlockFetcher implements BlockFetcher {
		 private SimpleBlockFetcher() throws IOException {
			 int columns = file.readInt();
			 for (int i = 0;
			 i < columns;
			 i++) {
				 IColumn column = emptyColumnFamily.getColumnSerializer().deserialize(file);
				 if (reversed) blockColumns.addFirst(column);
				 else blockColumns.addLast(column);
				 boolean outOfBounds = false;
				 if (!reversed && finishColumn.remaining() > 0) outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;
				 else if (reversed && startColumn.remaining() > 0) outOfBounds = comparator.compare(column.name(), startColumn) >= 0;
				 if (outOfBounds) break;
			 }
		 }
		 public boolean getNextBlock() throws IOException {
			 return false;
		 }
	 }
}",0,0,0,0
"public interface VMInstanceDao extends GenericDao<VMInstanceVO, Long>, StateDao<State, VirtualMachine.Event, VirtualMachine> {
	 List<VMInstanceVO> listByHostId(long hostId);
	 List<VMInstanceVO> listByZoneId(long zoneId);
	 List<VMInstanceVO> listByPodId(long podId);
	 public List<VMInstanceVO> listNonExpungedByTemplate(long templateId);
	 public List<VMInstanceVO> listNonExpungedByZoneAndTemplate(long zoneId, long templateId);
	 List<VMInstanceVO> findVMInstancesLike(String name);
	 List<VMInstanceVO> findVMInTransition(Date time, State... states);
	 List<VMInstanceVO> listByHostAndState(long hostId, State... states);
	 List<VMInstanceVO> listByTypes(VirtualMachine.Type... types);
	 VMInstanceVO findByIdTypes(long id, VirtualMachine.Type... types);
	 VMInstanceVO findVMByInstanceName(String name);
	 VMInstanceVO findVMByHostName(String hostName);
	 void updateProxyId(long id, Long proxyId, Date time);
	 List<VMInstanceVO> listByHostIdTypes(long hostid, VirtualMachine.Type... types);
	 List<VMInstanceVO> listUpByHostIdTypes(long hostid, VirtualMachine.Type... types);
	 List<VMInstanceVO> listByZoneIdAndType(long zoneId, VirtualMachine.Type type);
	 List<VMInstanceVO> listUpByHostId(Long hostId);
	 List<VMInstanceVO> listByLastHostId(Long hostId);
	 List<VMInstanceVO> listByTypeAndState(VirtualMachine.Type type, State state);
	 List<VMInstanceVO> listByAccountId(long accountId);
	 public List<Long> findIdsOfAllocatedVirtualRoutersForAccount(long accountId);
	 List<VMInstanceVO> listByClusterId(long clusterId);
	 List<VMInstanceVO> listLHByClusterId(long clusterId);
	 List<VMInstanceVO> listVmsMigratingFromHost(Long hostId);
	 public Long countActiveByHostId(long hostId);
	 Pair<List<Long>, Map<Long, Double>> listClusterIdsInZoneByVmCount(long zoneId, long accountId);
	 Pair<List<Long>, Map<Long, Double>> listClusterIdsInPodByVmCount(long podId, long accountId);
	 Pair<List<Long>, Map<Long, Double>> listPodIdsInZoneByVmCount(long dataCenterId, long accountId);
	 List<Long> listHostIdsByVmCount(long dcId, Long podId, Long clusterId, long accountId);
	 Long countRunningByAccount(long accountId);
	 Long countByZoneAndState(long zoneId, State state);
	 List<VMInstanceVO> listNonRemovedVmsByTypeAndNetwork(long networkId, VirtualMachine.Type... types);
	 List<String> listDistinctHostNames(long networkId, VirtualMachine.Type... types);
	 List<VMInstanceVO> findByHostInStates(Long hostId, State... states);
	 List<VMInstanceVO> listStartingWithNoHostId();
	 boolean updatePowerState(long instanceId, long powerHostId, VirtualMachine.PowerState powerState);
	 void resetVmPowerStateTracking(long instanceId);
	 void resetHostPowerStateTracking(long hostId);
	 HashMap<String, Long> countVgpuVMs(Long dcId, Long podId, Long clusterId);
	 VMInstanceVO findVMByHostNameInZone(String hostName, long zoneId);
	 boolean isPowerStateUpToDate(long instanceId);
	 List<VMInstanceVO> listNonMigratingVmsByHostEqualsLastHost(long hostId);
}",1,0,0,0
"abstract static class Builder {
	 abstract Builder setConfigProperties(Map<String, String> configProperties);
	 abstract Builder setDatabase(String database);
	 abstract Builder setTable(String table);
	 abstract Builder setFilter(String filter);
	 abstract Builder setSplitId(Integer splitId);
	 abstract Builder setContext(ReaderContext context);
	 abstract Read build();
 }",0,0,0,0
"public class GridClientJdkMarshaller implements GridClientMarshaller {
	 public static final byte ID = 2;
	 private final IgnitePredicate<String> clsFilter;
	 public GridClientJdkMarshaller() {
		 this(null);
	 }
	 public GridClientJdkMarshaller(IgnitePredicate<String> clsFilter) {
		 this.clsFilter = clsFilter;
	 }
	 public ByteBuffer marshal(Object obj, int off) throws IOException {
		 GridByteArrayOutputStream bOut = new GridByteArrayOutputStream();
		 ObjectOutput out = new ObjectOutputStream(bOut);
		 out.writeObject(obj);
		 out.flush();
		 ByteBuffer buf = ByteBuffer.allocate(off + bOut.size());
		 buf.position(off);
		 buf.put(bOut.internalArray(), 0, bOut.size());
		 buf.flip();
		 return buf;
	 }
	 public <T> T unmarshal(byte[] bytes) throws IOException {
		 ByteArrayInputStream tmp = new ByteArrayInputStream(bytes);
		 ObjectInput in = new ClientJdkInputStream(tmp, clsFilter);
		 try {
			 return (T)in.readObject();
		 }
		 catch (ClassNotFoundException e) {
			 throw new IOException(""Failed to unmarshal target object: "" + e.getMessage(), e);
		 }
	 }
	 private static class ClientJdkInputStream extends ObjectInputStream {
		 private final IgnitePredicate<String> clsFilter;
		 public ClientJdkInputStream(InputStream in, IgnitePredicate<String> clsFilter) throws IOException {
			 super(in);
			 this.clsFilter = clsFilter;
		 }
		 protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
			 String clsName = desc.getName();
			 if (clsFilter != null && !clsFilter.apply(clsName)) throw new RuntimeException(""Deserialization of class "" + clsName + "" is disallowed."");
			 return super.resolveClass(desc);
		 }
	 }
}",0,0,0,0
"public class GlobalOptionsDialog extends OptionsDialog {
	 private DocumentBuffer m_buffer;
	 private OptionGroup m_defaultGroup;
	 public GlobalOptionsDialog(TabbedView view) {
		 super(view, ""global"", Messages.getMessage(""Global.Options.Dialog.Title""), jsXe.getProperty(""global.last""));
	 }
	 protected OptionTreeModel createOptionTreeModel() {
		 m_defaultGroup = new OptionGroup(""jsxe"", ""jsXe"");
		 OptionTreeModel paneTreeModel = new OptionTreeModel();
		 OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();
		 TabbedView view = (TabbedView)getOwner();
		 DocumentBuffer buffer = view.getDocumentView().getDocumentBuffer();
		 OptionPane pane = jsXe.getOptionsPanel();
		 if (pane != null) {
			 addOptionPane(pane);
		 }
		 Iterator pluginItr = jsXe.getPluginLoader().getAllPlugins().iterator();
		 while (pluginItr.hasNext()) {
			 ActionPlugin plugin = (ActionPlugin)pluginItr.next();
			 pane = plugin.getOptionsPanel(buffer);
			 if (pane != null) {
				 addOptionPane(pane);
			 }
		 }
		 pane = buffer.getOptionsPanel();
		 if (pane != null) {
			 addOptionPane(pane);
		 }
		 addOptionGroup(m_defaultGroup, rootGroup);
		 return paneTreeModel;
	 }
	protected OptionGroup getDefaultGroup() {
		 return m_defaultGroup;
	 }
}",1,0,0,0
"void registerTitlePanel(JPanel panel) {
	vBox = Box.createVerticalBox();
	vBox.setOpaque(true);
	vBox.setBackground(ColorResource.getTitleColor());
	Box hBox = Box.createHorizontalBox();
	hBox.setBackground(ColorResource.getTitleColor());
	if (minimizeBox) {
		JButton btn = createTransparentButton(ImageResource.get(""min_btn.png""), new Dimension(30, 30), actMin);
		hBox.add(btn);
	}
	if (maximizeBox) {
		JButton btn = createTransparentButton(ImageResource.get(""max_btn.png""), new Dimension(30, 30), actMax);
		hBox.add(btn);
	}
	JButton btn = createTransparentButton(ImageResource.get(""close_btn.png""), new Dimension(30, 30), actClose);
	hBox.add(btn);
	vBox.add(hBox);
	vBox.add(Box.createVerticalGlue());
	panel.add(vBox, BorderLayout.EAST);
}",0,0,1,0
"public void setSrc(File s) {
	 this.source = s;
 }",0,0,0,0
"public interface XSLTLoggerAware {
	 void setLogger(XSLTLogger l);
}",0,0,0,0
"public class ConfigurationException extends Exception{
	 public ConfigurationException(String message) {
		 super(message);
	 }
	 public ConfigurationException(String message, Exception e) {
		 super(message, e);
	 }
}",0,0,0,0
"public void createMessage(String folderPath, String messageName, HashMap<String, String> properties, MimeMessage mimeMessage) throws IOException {
	 String messageUrl = URIUtil.encodePathQuery(getFolderPath(folderPath) + '/' + messageName);
	 PropPatchMethod patchMethod;
	 List<PropEntry> davProperties = buildProperties(properties);
	 if (properties != null && properties.containsKey(""draft"")) {
		 davProperties.add(Field.createDavProperty(""messageFlags"", properties.get(""draft"")));
	 }
	 if (properties != null && properties.containsKey(""mailOverrideFormat"")) {
		 davProperties.add(Field.createDavProperty(""mailOverrideFormat"", properties.get(""mailOverrideFormat"")));
	 }
	 if (properties != null && properties.containsKey(""messageFormat"")) {
		 davProperties.add(Field.createDavProperty(""messageFormat"", properties.get(""messageFormat"")));
	 }
	 if (!davProperties.isEmpty()) {
		 patchMethod = new PropPatchMethod(messageUrl, davProperties);
		 try {
			 int statusCode = httpClient.executeMethod(patchMethod);
			 if (statusCode != HttpStatus.SC_MULTI_STATUS) {
				 throw new DavMailException(""EXCEPTION_UNABLE_TO_CREATE_MESSAGE"", messageUrl, statusCode, ' ', patchMethod.getStatusLine());
			 }
		 }
		 finally {
			 patchMethod.releaseConnection();
		 }
	 }
	 PutMethod putmethod = new PutMethod(messageUrl);
	 putmethod.setRequestHeader(""Translate"", ""f"");
	 putmethod.setRequestHeader(""Content-Type"", ""message/rfc822"");
	 try {
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 mimeMessage.writeTo(baos);
		 baos.close();
		 putmethod.setRequestEntity(new ByteArrayRequestEntity(baos.toByteArray()));
		 int code = httpClient.executeMethod(putmethod);
		 if (code == HttpStatus.SC_NOT_ACCEPTABLE) {
			 LOGGER.warn(""Draft message creation failed, failover to property update. Note: attachments are lost"");
			 ArrayList<PropEntry> propertyList = new ArrayList<PropEntry>();
			 propertyList.add(Field.createDavProperty(""to"", mimeMessage.getHeader(""to"", "","")));
			 propertyList.add(Field.createDavProperty(""cc"", mimeMessage.getHeader(""cc"", "","")));
			 propertyList.add(Field.createDavProperty(""message-id"", mimeMessage.getHeader(""message-id"", "","")));
			 MimePart mimePart = mimeMessage;
			 if (mimeMessage.getContent() instanceof MimeMultipart) {
				 MimeMultipart multiPart = (MimeMultipart) mimeMessage.getContent();
				 for (int i = 0;
				 i < multiPart.getCount();
				 i++) {
					 String contentType = multiPart.getBodyPart(i).getContentType();
					 if (contentType.startsWith(""text/"")) {
						 mimePart = (MimePart) multiPart.getBodyPart(i);
						 break;
					 }
				 }
			 }
			 String contentType = mimePart.getContentType();
			 if (contentType.startsWith(""text/plain"")) {
				 propertyList.add(Field.createDavProperty(""description"", (String) mimePart.getContent()));
			 }
			 else if (contentType.startsWith(""text/html"")) {
				 propertyList.add(Field.createDavProperty(""htmldescription"", (String) mimePart.getContent()));
			 }
			 else {
				 LOGGER.warn(""Unsupported content type: "" + contentType + "" message body will be empty"");
			 }
			 propertyList.add(Field.createDavProperty(""subject"", mimeMessage.getHeader(""subject"", "","")));
			 PropPatchMethod propPatchMethod = new PropPatchMethod(messageUrl, propertyList);
			 try {
				 int patchStatus = DavGatewayHttpClientFacade.executeHttpMethod(httpClient, propPatchMethod);
				 if (patchStatus == HttpStatus.SC_MULTI_STATUS) {
					 code = HttpStatus.SC_OK;
				 }
			 }
			 finally {
				 propPatchMethod.releaseConnection();
			 }
		 }
		 if (code != HttpStatus.SC_OK && code != HttpStatus.SC_CREATED) {
			 if (!davProperties.isEmpty()) {
				 try {
					 DavGatewayHttpClientFacade.executeDeleteMethod(httpClient, messageUrl);
				 }
				 catch (IOException e) {
					 LOGGER.warn(""Unable to delete draft message"");
				 }
			 }
			 if (code == HttpStatus.SC_INSUFFICIENT_STORAGE) {
				 throw new InsufficientStorageException(putmethod.getStatusText());
			 }
			 else {
				 throw new DavMailException(""EXCEPTION_UNABLE_TO_CREATE_MESSAGE"", messageUrl, code, ' ', putmethod.getStatusLine());
			 }
		 }
	 }
	 catch (MessagingException e) {
		 throw new IOException(e.getMessage());
	 }
	 finally {
		 putmethod.releaseConnection();
	 }
	 try {
		 if (mimeMessage.getHeader(""Bcc"") != null) {
			 davProperties = new ArrayList<PropEntry>();
			 davProperties.add(Field.createDavProperty(""bcc"", mimeMessage.getHeader(""Bcc"", "","")));
			 patchMethod = new PropPatchMethod(messageUrl, davProperties);
			 try {
				 int statusCode = httpClient.executeMethod(patchMethod);
				 if (statusCode != HttpStatus.SC_MULTI_STATUS) {
					 throw new DavMailException(""EXCEPTION_UNABLE_TO_CREATE_MESSAGE"", messageUrl, statusCode, ' ', patchMethod.getStatusLine());
				 }
			 }
			 finally {
				 patchMethod.releaseConnection();
			 }
		 }
	 }
	 catch (MessagingException e) {
		 throw new IOException(e.getMessage());
	 }
 }",0,0,1,0
"public void setJavac(Javac attributes) {
	 this.attributes = attributes;
	 src = attributes.getSrcdir();
	 destDir = attributes.getDestdir();
	 encoding = attributes.getEncoding();
	 debug = attributes.getDebug();
	 optimize = attributes.getOptimize();
	 deprecation = attributes.getDeprecation();
	 depend = attributes.getDepend();
	 verbose = attributes.getVerbose();
	 target = attributes.getTarget();
	 bootclasspath = attributes.getBootclasspath();
	 extdirs = attributes.getExtdirs();
	 compileList = attributes.getFileList();
	 compileClasspath = attributes.getClasspath();
	 compileSourcepath = attributes.getSourcepath();
	 project = attributes.getProject();
	 location = attributes.getLocation();
	 includeAntRuntime = attributes.getIncludeantruntime();
	 includeJavaRuntime = attributes.getIncludejavaruntime();
	 memoryInitialSize = attributes.getMemoryInitialSize();
	 memoryMaximumSize = attributes.getMemoryMaximumSize();
 }",0,0,0,0
"public String getFailureProperty() {
	 return failureProperty;
 }",0,0,0,0
"public class Context{
	 public static final int VERSION_UNKNOWN = -1;
	 public static final int VERSION_DEFAULT = 0;
	 public static final int VERSION_1_0 = 100;
	 public static final int VERSION_1_1 = 110;
	 public static final int VERSION_1_2 = 120;
	 public static final int VERSION_1_3 = 130;
	 public static final int VERSION_1_4 = 140;
	 public static final int VERSION_1_5 = 150;
	 public static final int VERSION_1_6 = 160;
	 public static final int FEATURE_NON_ECMA_GET_YEAR = 1;
	 public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;
	 public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;
	 public static final int FEATURE_TO_STRING_AS_SOURCE = 4;
	 public static final int FEATURE_PARENT_PROTO_PROPRTIES = 5;
	 public static final int FEATURE_E4X = 6;
	 public static final int FEATURE_DYNAMIC_SCOPE = 7;
	 public static final int FEATURE_STRICT_VARS = 8;
	 public static final int FEATURE_STRICT_EVAL = 9;
	 public static final String languageVersionProperty = ""language version"";
	 public static final String errorReporterProperty = ""error reporter"";
	 public static final Object[] emptyArgs = ScriptRuntime.emptyArgs;
	 public Context() {
		 setLanguageVersion(VERSION_DEFAULT);
		 optimizationLevel = codegenClass != null ? 0 : -1;
		 maximumInterpreterStackDepth = Integer.MAX_VALUE;
	 }
	 public static Context getCurrentContext() {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 return VMBridge.instance.getContext(helper);
	 }
	 public static Context enter() {
		 return enter(null);
	 }
	 public static Context enter(Context cx) {
		 return enter(cx, ContextFactory.getGlobal());
	 }
	 static final Context enter(Context cx, ContextFactory factory) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context old = VMBridge.instance.getContext(helper);
		 if (old != null) {
			 if (cx != null && cx != old && cx.enterCount != 0) {
				 throw new IllegalArgumentException( ""Cannot enter Context active on another thread"");
			 }
			 if (old.factory != null) {
				 return old;
			 }
			 if (old.sealed) onSealedMutation();
			 cx = old;
		 }
		 else {
			 if (cx == null) {
				 cx = factory.makeContext();
			 }
			 else {
				 if (cx.sealed) onSealedMutation();
			 }
			 if (cx.enterCount != 0 || cx.factory != null) {
				 throw new IllegalStateException();
			 }
			 if (!cx.creationEventWasSent) {
				 cx.creationEventWasSent = true;
				 factory.onContextCreated(cx);
			 }
		 }
		 if (old == null) {
			 VMBridge.instance.setContext(helper, cx);
		 }
		 ++cx.enterCount;
		 return cx;
	 }
	 public static void exit() {
		 exit(ContextFactory.getGlobal());
	 }
	 static void exit(ContextFactory factory) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx == null) {
			 throw new IllegalStateException( ""Calling Context.exit without previous Context.enter"");
		 }
		 if (cx.factory != null) {
			 return;
		 }
		 if (cx.enterCount < 1) Kit.codeBug();
		 if (cx.sealed) onSealedMutation();
		 --cx.enterCount;
		 if (cx.enterCount == 0) {
			 VMBridge.instance.setContext(helper, null);
			 factory.onContextReleased(cx);
		 }
	 }
	 public static Object call(ContextAction action) {
		 return call(ContextFactory.getGlobal(), action);
	 }
	 public static Object call(ContextFactory factory, Callable callable, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (factory == null) {
			 factory = ContextFactory.getGlobal();
		 }
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx != null) {
			 Object result;
			 if (cx.factory != null) {
				 result = callable.call(cx, scope, thisObj, args);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 result = callable.call(cx, scope, thisObj, args);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
			 return result;
		 }
		 cx = prepareNewContext(factory, helper);
		 try {
			 return callable.call(cx, scope, thisObj, args);
		 }
		 finally {
			 releaseContext(helper, cx);
		 }
	 }
	 static Object call(ContextFactory factory, ContextAction action) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx != null) {
			 if (cx.factory != null) {
				 return action.run(cx);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 return action.run(cx);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
		 }
		 cx = prepareNewContext(factory, helper);
		 try {
			 return action.run(cx);
		 }
		 finally {
			 releaseContext(helper, cx);
		 }
	 }
	 private static Context prepareNewContext(ContextFactory factory, Object contextHelper) {
		 Context cx = factory.makeContext();
		 if (cx.factory != null || cx.enterCount != 0) {
			 throw new IllegalStateException(""factory.makeContext() returned Context instance already associated with some thread"");
		 }
		 cx.factory = factory;
		 factory.onContextCreated(cx);
		 if (factory.isSealed() && !cx.isSealed()) {
			 cx.seal(null);
		 }
		 VMBridge.instance.setContext(contextHelper, cx);
		 return cx;
	 }
	 private static void releaseContext(Object contextHelper, Context cx) {
		 VMBridge.instance.setContext(contextHelper, null);
		 try {
			 cx.factory.onContextReleased(cx);
		 }
		 finally {
			 cx.factory = null;
		 }
	 }
	 public static void addContextListener(ContextListener listener) {
		 String DBG = ""org.mozilla.javascript.tools.debugger.Main"";
		 if (DBG.equals(listener.getClass().getName())) {
			 Class cl = listener.getClass();
			 Class factoryClass = Kit.classOrNull( ""org.mozilla.javascript.ContextFactory"");
			 Class[] sig = {
			 factoryClass }
			;
			 Object[] args = {
			 ContextFactory.getGlobal() }
			;
			 try {
				 Method m = cl.getMethod(""attachTo"", sig);
				 m.invoke(listener, args);
			 }
			 catch (Exception ex) {
				 RuntimeException rex = new RuntimeException();
				 Kit.initCause(rex, ex);
				 throw rex;
			 }
			 return;
		 }
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public static void removeContextListener(ContextListener listener) {
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public final ContextFactory getFactory() {
		 ContextFactory result = factory;
		 if (result == null) {
			 result = ContextFactory.getGlobal();
		 }
		 return result;
	 }
	 public final boolean isSealed() {
		 return sealed;
	 }
	 public final void seal(Object sealKey) {
		 if (sealed) onSealedMutation();
		 sealed = true;
		 this.sealKey = sealKey;
	 }
	 public final void unseal(Object sealKey) {
		 if (sealKey == null) throw new IllegalArgumentException();
		 if (this.sealKey != sealKey) throw new IllegalArgumentException();
		 if (!sealed) throw new IllegalStateException();
		 sealed = false;
		 this.sealKey = null;
	 }
	 static void onSealedMutation() {
		 throw new IllegalStateException();
	 }
	 public final int getLanguageVersion() {
		 return version;
	 }
	 public void setLanguageVersion(int version) {
		 if (sealed) onSealedMutation();
		 checkLanguageVersion(version);
		 Object listeners = propertyListeners;
		 if (listeners != null && version != this.version) {
			 firePropertyChangeImpl(listeners, languageVersionProperty, new Integer(this.version), new Integer(version));
		 }
		 this.version = version;
	 }
	 public static boolean isValidLanguageVersion(int version) {
		 switch (version) {
			 case VERSION_DEFAULT: case VERSION_1_0: case VERSION_1_1: case VERSION_1_2: case VERSION_1_3: case VERSION_1_4: case VERSION_1_5: case VERSION_1_6: return true;
		 }
		 return false;
	 }
	 public static void checkLanguageVersion(int version) {
		 if (isValidLanguageVersion(version)) {
			 return;
		 }
		 throw new IllegalArgumentException(""Bad language version: ""+version);
	 }
	 public final String getImplementationVersion() {
		 if (implementationVersion == null) {
			 implementationVersion = ScriptRuntime.getMessage0(""implementation.version"");
		 }
		 return implementationVersion;
	 }
	 public final ErrorReporter getErrorReporter() {
		 if (errorReporter == null) {
			 return DefaultErrorReporter.instance;
		 }
		 return errorReporter;
	 }
	 public final ErrorReporter setErrorReporter(ErrorReporter reporter) {
		 if (sealed) onSealedMutation();
		 if (reporter == null) throw new IllegalArgumentException();
		 ErrorReporter old = getErrorReporter();
		 if (reporter == old) {
			 return old;
		 }
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, errorReporterProperty, old, reporter);
		 }
		 this.errorReporter = reporter;
		 return old;
	 }
	 public final Locale getLocale() {
		 if (locale == null) locale = Locale.getDefault();
		 return locale;
	 }
	 public final Locale setLocale(Locale loc) {
		 if (sealed) onSealedMutation();
		 Locale result = locale;
		 locale = loc;
		 return result;
	 }
	 public final void addPropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.addListener(propertyListeners, l);
	 }
	 public final void removePropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.removeListener(propertyListeners, l);
	 }
	 final void firePropertyChange(String property, Object oldValue, Object newValue) {
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, property, oldValue, newValue);
		 }
	 }
	 private void firePropertyChangeImpl(Object listeners, String property, Object oldValue, Object newValue) {
		 for (int i = 0;
		 ;
		 ++i) {
			 Object l = Kit.getListener(listeners, i);
			 if (l == null) break;
			 if (l instanceof PropertyChangeListener) {
				 PropertyChangeListener pcl = (PropertyChangeListener)l;
				 pcl.propertyChange(new PropertyChangeEvent( this, property, oldValue, newValue));
			 }
		 }
	 }
	 public static void reportWarning(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = Context.getContext();
		 cx.getErrorReporter().warning(message, sourceName, lineno, lineSource, lineOffset);
	 }
	 public static void reportWarning(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportWarning(message, filename, linep[0], null, 0);
	 }
	 public static void reportError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 cx.getErrorReporter().error(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 public static void reportError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportError(message, filename, linep[0], null, 0);
	 }
	 public static EvaluatorException reportRuntimeError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 return cx.getErrorReporter(). runtimeError(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 static EvaluatorException reportRuntimeError0(String messageId) {
		 String msg = ScriptRuntime.getMessage0(messageId);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError1(String messageId, Object arg1) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg1);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError2(String messageId, Object arg1, Object arg2) {
		 String msg = ScriptRuntime.getMessage2(messageId, arg1, arg2);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError3(String messageId, Object arg1, Object arg2, Object arg3) {
		 String msg = ScriptRuntime.getMessage3(messageId, arg1, arg2, arg3);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError4(String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 String msg = ScriptRuntime.getMessage4(messageId, arg1, arg2, arg3, arg4);
		 return reportRuntimeError(msg);
	 }
	 public static EvaluatorException reportRuntimeError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 return Context.reportRuntimeError(message, filename, linep[0], null, 0);
	 }
	 public final ScriptableObject initStandardObjects() {
		 return initStandardObjects(null, false);
	 }
	 public final Scriptable initStandardObjects(ScriptableObject scope) {
		 return initStandardObjects(scope, false);
	 }
	 public ScriptableObject initStandardObjects(ScriptableObject scope, boolean sealed) {
		 return ScriptRuntime.initStandardObjects(this, scope, sealed);
	 }
	 public static Object getUndefinedValue() {
		 return Undefined.instance;
	 }
	 public final Object evaluateString(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 Script script = compileString(source, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final Object evaluateReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 Script script = compileReader(scope, in, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final boolean stringIsCompilableUnit(String source) {
		 boolean errorseen = false;
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 compilerEnv.setGeneratingSource(false);
		 Parser p = new Parser(compilerEnv, DefaultErrorReporter.instance);
		 try {
			 p.parse(source, null, 1);
		 }
		 catch (EvaluatorException ee) {
			 errorseen = true;
		 }
		 if (errorseen && p.eof()) return false;
		 else return true;
	 }
	 public final Script compileReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 return compileReader(in, sourceName, lineno, securityDomain);
	 }
	 public final Script compileReader(Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return (Script) compileImpl(null, in, null, sourceName, lineno, securityDomain, false, null, null);
	 }
	 public final Script compileString(String source, String sourceName, int lineno, Object securityDomain) {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return compileString(source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Script compileString(String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Script) compileImpl(null, null, source, sourceName, lineno, securityDomain, false, compiler, compilationErrorReporter);
		 }
		 catch (IOException ex) {
			 throw new RuntimeException();
		 }
	 }
	 public final Function compileFunction(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 return compileFunction(scope, source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Function compileFunction(Scriptable scope, String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Function) compileImpl(scope, null, source, sourceName, lineno, securityDomain, true, compiler, compilationErrorReporter);
		 }
		 catch (IOException ioe) {
			 throw new RuntimeException();
		 }
	 }
	 public final String decompileScript(Script script, int indent) {
		 NativeFunction scriptImpl = (NativeFunction) script;
		 return scriptImpl.decompile(indent, 0);
	 }
	 public final String decompileFunction(Function fun, int indent) {
		 if (fun instanceof BaseFunction) return ((BaseFunction)fun).decompile(indent, 0);
		 else return ""function "" + fun.getClassName() + ""() {
		\n\t[native code]\n}
		\n"";
	 }
	 public final String decompileFunctionBody(Function fun, int indent) {
		 if (fun instanceof BaseFunction) {
			 BaseFunction bf = (BaseFunction)fun;
			 return bf.decompile(indent, Decompiler.ONLY_BODY_FLAG);
		 }
		 return ""[native code]\n"";
	 }
	 public final Scriptable newObject(Scriptable scope) {
		 return newObject(scope, ""Object"", ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName) {
		 return newObject(scope, constructorName, ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(this, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(this, scope, args);
	 }
	 public final Scriptable newArray(Scriptable scope, int length) {
		 NativeArray result = new NativeArray(length);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Scriptable newArray(Scriptable scope, Object[] elements) {
		 if (elements.getClass().getComponentType() != ScriptRuntime.ObjectClass) throw new IllegalArgumentException();
		 NativeArray result = new NativeArray(elements);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Object[] getElements(Scriptable object) {
		 return ScriptRuntime.getArrayElements(object);
	 }
	 public static boolean toBoolean(Object value) {
		 return ScriptRuntime.toBoolean(value);
	 }
	 public static double toNumber(Object value) {
		 return ScriptRuntime.toNumber(value);
	 }
	 public static String toString(Object value) {
		 return ScriptRuntime.toString(value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope, Class staticType) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Object javaToJS(Object value, Scriptable scope) {
		 if (value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Scriptable) {
			 return value;
		 }
		 else if (value instanceof Character) {
			 return String.valueOf(((Character)value).charValue());
		 }
		 else {
			 Context cx = Context.getContext();
			 return cx.getWrapFactory().wrap(cx, scope, value, null);
		 }
	 }
	 public static Object jsToJava(Object value, Class desiredType) throws EvaluatorException {
		 return NativeJavaObject.coerceTypeImpl(desiredType, value);
	 }
	 public static Object toType(Object value, Class desiredType) throws IllegalArgumentException {
		 try {
			 return jsToJava(value, desiredType);
		 }
		 catch (EvaluatorException ex) {
			 IllegalArgumentException ex2 = new IllegalArgumentException(ex.getMessage());
			 Kit.initCause(ex2, ex);
			 throw ex2;
		 }
	 }
	 public static RuntimeException throwAsScriptRuntimeEx(Throwable e) {
		 while ((e instanceof InvocationTargetException)) {
			 e = ((InvocationTargetException) e).getTargetException();
		 }
		 if (e instanceof Error) {
			 throw (Error)e;
		 }
		 if (e instanceof RhinoException) {
			 throw (RhinoException)e;
		 }
		 throw new WrappedException(e);
	 }
	 public final boolean isGeneratingDebug() {
		 return generatingDebug;
	 }
	 public final void setGeneratingDebug(boolean generatingDebug) {
		 if (sealed) onSealedMutation();
		 generatingDebugChanged = true;
		 if (generatingDebug && getOptimizationLevel() > 0) setOptimizationLevel(0);
		 this.generatingDebug = generatingDebug;
	 }
	 public final boolean isGeneratingSource() {
		 return generatingSource;
	 }
	 public final void setGeneratingSource(boolean generatingSource) {
		 if (sealed) onSealedMutation();
		 this.generatingSource = generatingSource;
	 }
	 public final int getOptimizationLevel() {
		 return optimizationLevel;
	 }
	 public final void setOptimizationLevel(int optimizationLevel) {
		 if (sealed) onSealedMutation();
		 if (optimizationLevel == -2) {
			 optimizationLevel = -1;
		 }
		 checkOptimizationLevel(optimizationLevel);
		 if (codegenClass == null) optimizationLevel = -1;
		 this.optimizationLevel = optimizationLevel;
	 }
	 public static boolean isValidOptimizationLevel(int optimizationLevel) {
		 return -1 <= optimizationLevel && optimizationLevel <= 9;
	 }
	 public static void checkOptimizationLevel(int optimizationLevel) {
		 if (isValidOptimizationLevel(optimizationLevel)) {
			 return;
		 }
		 throw new IllegalArgumentException( ""Optimization level outside [-1..9]: ""+optimizationLevel);
	 }
	 public final int getMaximumInterpreterStackDepth() {
		 return maximumInterpreterStackDepth;
	 }
	 public final void setMaximumInterpreterStackDepth(int max) {
		 if(sealed) onSealedMutation();
		 if(optimizationLevel != -1) {
			 throw new IllegalStateException(""Cannot set maximumInterpreterStackDepth when optimizationLevel != -1"");
		 }
		 if(max < 1) {
			 throw new IllegalArgumentException(""Cannot set maximumInterpreterStackDepth to less than 1"");
		 }
		 maximumInterpreterStackDepth = max;
	 }
	 public final void setSecurityController(SecurityController controller) {
		 if (sealed) onSealedMutation();
		 if (controller == null) throw new IllegalArgumentException();
		 if (securityController != null) {
			 throw new SecurityException(""Can not overwrite existing SecurityController object"");
		 }
		 if (SecurityController.hasGlobal()) {
			 throw new SecurityException(""Can not overwrite existing global SecurityController object"");
		 }
		 securityController = controller;
	 }
	 public final void setClassShutter(ClassShutter shutter) {
		 if (sealed) onSealedMutation();
		 if (shutter == null) throw new IllegalArgumentException();
		 if (classShutter != null) {
			 throw new SecurityException(""Cannot overwrite existing "" + ""ClassShutter object"");
		 }
		 classShutter = shutter;
	 }
	 final ClassShutter getClassShutter() {
		 return classShutter;
	 }
	 public final Object getThreadLocal(Object key) {
		 if (hashtable == null) return null;
		 return hashtable.get(key);
	 }
	 public final void putThreadLocal(Object key, Object value) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) hashtable = new Hashtable();
		 hashtable.put(key, value);
	 }
	 public final void removeThreadLocal(Object key) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) return;
		 hashtable.remove(key);
	 }
	 public final boolean hasCompileFunctionsWithDynamicScope() {
		 return compileFunctionsWithDynamicScopeFlag;
	 }
	 public final void setCompileFunctionsWithDynamicScope(boolean flag) {
		 if (sealed) onSealedMutation();
		 compileFunctionsWithDynamicScopeFlag = flag;
	 }
	 public static void setCachingEnabled(boolean cachingEnabled) {
	 }
	 public final void setWrapFactory(WrapFactory wrapFactory) {
		 if (sealed) onSealedMutation();
		 if (wrapFactory == null) throw new IllegalArgumentException();
		 this.wrapFactory = wrapFactory;
	 }
	 public final WrapFactory getWrapFactory() {
		 if (wrapFactory == null) {
			 wrapFactory = new WrapFactory();
		 }
		 return wrapFactory;
	 }
	 public final Debugger getDebugger() {
		 return debugger;
	 }
	 public final Object getDebuggerContextData() {
		 return debuggerData;
	 }
	 public final void setDebugger(Debugger debugger, Object contextData) {
		 if (sealed) onSealedMutation();
		 this.debugger = debugger;
		 debuggerData = contextData;
	 }
	 public static DebuggableScript getDebuggableView(Script script) {
		 if (script instanceof NativeFunction) {
			 return ((NativeFunction)script).getDebuggableView();
		 }
		 return null;
	 }
	 public boolean hasFeature(int featureIndex) {
		 ContextFactory f = getFactory();
		 return f.hasFeature(this, featureIndex);
	 }
	 public final int getInstructionObserverThreshold() {
		 return instructionThreshold;
	 }
	 public final void setInstructionObserverThreshold(int threshold) {
		 if (sealed) onSealedMutation();
		 if (threshold < 0) throw new IllegalArgumentException();
		 instructionThreshold = threshold;
	 }
	 protected void observeInstructionCount(int instructionCount) {
		 ContextFactory f = getFactory();
		 f.observeInstructionCount(this, instructionCount);
	 }
	 public GeneratedClassLoader createClassLoader(ClassLoader parent) {
		 ContextFactory f = getFactory();
		 return f.createClassLoader(parent);
	 }
	 public final ClassLoader getApplicationClassLoader() {
		 if (applicationClassLoader == null) {
			 ContextFactory f = getFactory();
			 ClassLoader loader = f.getApplicationClassLoader();
			 if (loader == null) {
				 ClassLoader threadLoader = VMBridge.instance.getCurrentThreadClassLoader();
				 if (threadLoader != null && Kit.testIfCanLoadRhinoClasses(threadLoader)) {
					 return threadLoader;
				 }
				 Class fClass = f.getClass();
				 if (fClass != ScriptRuntime.ContextFactoryClass) {
					 loader = fClass.getClassLoader();
				 }
				 else {
					 loader = getClass().getClassLoader();
				 }
			 }
			 applicationClassLoader = loader;
		 }
		 return applicationClassLoader;
	 }
	 public final void setApplicationClassLoader(ClassLoader loader) {
		 if (sealed) onSealedMutation();
		 if (loader == null) {
			 applicationClassLoader = null;
			 return;
		 }
		 if (!Kit.testIfCanLoadRhinoClasses(loader)) {
			 throw new IllegalArgumentException( ""Loader can not resolve Rhino classes"");
		 }
		 applicationClassLoader = loader;
	 }
	 static Context getContext() {
		 Context cx = getCurrentContext();
		 if (cx == null) {
			 throw new RuntimeException( ""No Context associated with current Thread"");
		 }
		 return cx;
	 }
	 private Object compileImpl(Scriptable scope, Reader sourceReader, String sourceString, String sourceName, int lineno, Object securityDomain, boolean returnFunction, Interpreter compiler, ErrorReporter compilationErrorReporter) throws IOException {
		 if (securityDomain != null && securityController == null) {
			 throw new IllegalArgumentException( ""securityDomain should be null if setSecurityController() was never called"");
		 }
		 if (!(sourceReader == null ^ sourceString == null)) Kit.codeBug();
		 if (!(scope == null ^ returnFunction)) Kit.codeBug();
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 if (compilationErrorReporter == null) {
			 compilationErrorReporter = compilerEnv.getErrorReporter();
		 }
		 if (debugger != null) {
			 if (sourceReader != null) {
				 sourceString = Kit.readReader(sourceReader);
				 sourceReader = null;
			 }
		 }
		 Parser p = new Parser(compilerEnv, compilationErrorReporter);
		 if (returnFunction) {
			 p.calledByCompileFunction = true;
		 }
		 ScriptOrFnNode tree;
		 if (sourceString != null) {
			 tree = p.parse(sourceString, sourceName, lineno);
		 }
		 else {
			 tree = p.parse(sourceReader, sourceName, lineno);
		 }
		 if (returnFunction) {
			 if (!(tree.getFunctionCount() == 1 && tree.getFirstChild() != null && tree.getFirstChild().getType() == Token.FUNCTION)) {
				 throw new IllegalArgumentException( ""compileFunction only accepts source with single JS function: ""+sourceString);
			 }
		 }
		 if (compiler == null) {
			 compiler = createCompiler();
		 }
		 String encodedSource = p.getEncodedSource();
		 Object bytecode = compiler.compile(compilerEnv, tree, encodedSource, returnFunction);
		 if (debugger != null) {
			 if (sourceString == null) Kit.codeBug();
			 if (bytecode instanceof DebuggableScript) {
				 DebuggableScript dscript = (DebuggableScript)bytecode;
				 notifyDebugger_r(this, dscript, sourceString);
			 }
			 else {
				 throw new RuntimeException(""NOT SUPPORTED"");
			 }
		 }
		 Object result;
		 if (returnFunction) {
			 result = compiler.createFunctionObject(this, scope, bytecode, securityDomain);
		 }
		 else {
			 result = compiler.createScriptObject(bytecode, securityDomain);
		 }
		 return result;
	 }
	 private static void notifyDebugger_r(Context cx, DebuggableScript dscript, String debugSource) {
		 cx.debugger.handleCompilationDone(cx, dscript, debugSource);
		 for (int i = 0;
		 i != dscript.getFunctionCount();
		 ++i) {
			 notifyDebugger_r(cx, dscript.getFunction(i), debugSource);
		 }
	 }
	 private static Class codegenClass = Kit.classOrNull( ""org.mozilla.javascript.optimizer.Codegen"");
	 private Interpreter createCompiler() {
		 Interpreter result = null;
		 if (optimizationLevel >= 0 && codegenClass != null) {
			 result = (Interpreter)Kit.newInstanceOrNull(codegenClass);
		 }
		 if (result == null) {
			 result = new Interpreter();
		 }
		 return result;
	 }
	 static String getSourcePositionFromStack(int[] linep) {
		 Context cx = getCurrentContext();
		 if (cx == null) return null;
		 if (cx.lastInterpreterFrame != null) {
			 return Interpreter.getSourcePositionFromStack(cx, linep);
		 }
		 CharArrayWriter writer = new CharArrayWriter();
		 RuntimeException re = new RuntimeException();
		 re.printStackTrace(new PrintWriter(writer));
		 String s = writer.toString();
		 int open = -1;
		 int close = -1;
		 int colon = -1;
		 for (int i=0;
		 i < s.length();
		 i++) {
			 char c = s.charAt(i);
			 if (c == ':') colon = i;
			 else if (c == '(') open = i;
			 else if (c == ')') close = i;
			 else if (c == '\n' && open != -1 && close != -1 && colon != -1 && open < colon && colon < close) {
				 String fileStr = s.substring(open + 1, colon);
				 if (!fileStr.endsWith("".java"")) {
					 String lineStr = s.substring(colon + 1, close);
					 try {
						 linep[0] = Integer.parseInt(lineStr);
						 if (linep[0] < 0) {
							 linep[0] = 0;
						 }
						 return fileStr;
					 }
					 catch (NumberFormatException e) {
					 }
				 }
				 open = close = colon = -1;
			 }
		 }
		 return null;
	 }
	 RegExpProxy getRegExpProxy() {
		 if (regExpProxy == null) {
			 Class cl = Kit.classOrNull( ""org.mozilla.javascript.regexp.RegExpImpl"");
			 if (cl != null) {
				 regExpProxy = (RegExpProxy)Kit.newInstanceOrNull(cl);
			 }
		 }
		 return regExpProxy;
	 }
	 final boolean isVersionECMA1() {
		 return version == VERSION_DEFAULT || version >= VERSION_1_3;
	 }
	 SecurityController getSecurityController() {
		 SecurityController global = SecurityController.global();
		 if (global != null) {
			 return global;
		 }
		 return securityController;
	 }
	 public final boolean isGeneratingDebugChanged() {
		 return generatingDebugChanged;
	 }
	 public void addActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames == null) activationNames = new Hashtable(5);
		 activationNames.put(name, name);
	 }
	 public final boolean isActivationNeeded(String name) {
		 return activationNames != null && activationNames.containsKey(name);
	 }
	 public void removeActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames != null) activationNames.remove(name);
	 }
	 private static String implementationVersion;
	 private ContextFactory factory;
	 private boolean sealed;
	 private Object sealKey;
	 Scriptable topCallScope;
	 NativeCall currentActivationCall;
	 XMLLib cachedXMLLib;
	 ObjToIntMap iterating;
	 Object interpreterSecurityDomain;
	 int version;
	 private SecurityController securityController;
	 private ClassShutter classShutter;
	 private ErrorReporter errorReporter;
	 RegExpProxy regExpProxy;
	 private Locale locale;
	 private boolean generatingDebug;
	 private boolean generatingDebugChanged;
	 private boolean generatingSource=true;
	 boolean compileFunctionsWithDynamicScopeFlag;
	 boolean useDynamicScope;
	 private int optimizationLevel;
	 private int maximumInterpreterStackDepth;
	 private WrapFactory wrapFactory;
	 Debugger debugger;
	 private Object debuggerData;
	 private int enterCount;
	 private Object propertyListeners;
	 private Hashtable hashtable;
	 private ClassLoader applicationClassLoader;
	 private boolean creationEventWasSent;
	 Hashtable activationNames;
	 Object lastInterpreterFrame;
	 ObjArray previousInterpreterInvocations;
	 int instructionCount;
	 int instructionThreshold;
	 int scratchIndex;
	 long scratchUint32;
	 Scriptable scratchScriptable;
}",1,0,0,0
"public abstract class AbstractAnalyzer implements DependencyAnalyzer {
	 public static final int MAX_LOOPS = 1000;
	 private Path sourcePath = new Path(null);
	 private Path classPath = new Path(null);
	 private Vector rootClasses = new Vector();
	 private boolean determined = false;
	 private Vector fileDependencies;
	 private Vector classDependencies;
	 private boolean closure = true;
	 protected AbstractAnalyzer() {
		 reset();
	 }
	 public void setClosure(boolean closure) {
		 this.closure = closure;
	 }
	 public Enumeration getFileDependencies() {
		 if (!supportsFileDependencies()) {
			 throw new RuntimeException(""File dependencies are not supported "" + ""by this analyzer"");
		 }
		 if (!determined) {
			 determineDependencies(fileDependencies, classDependencies);
		 }
		 return fileDependencies.elements();
	 }
	 public Enumeration getClassDependencies() {
		 if (!determined) {
			 determineDependencies(fileDependencies, classDependencies);
		 }
		 return classDependencies.elements();
	 }
	 public File getClassContainer(String classname) throws IOException {
		 String classLocation = classname.replace('.', '/') + "".class"";
		 return getResourceContainer(classLocation, classPath.list());
	 }
	 public File getSourceContainer(String classname) throws IOException {
		 String sourceLocation = classname.replace('.', '/') + "".java"";
		 return getResourceContainer(sourceLocation, sourcePath.list());
	 }
	 public void addSourcePath(Path sourcePath) {
		 if (sourcePath == null) {
			 return;
		 }
		 this.sourcePath.append(sourcePath);
		 this.sourcePath.setProject(sourcePath.getProject());
	 }
	 public void addClassPath(Path classPath) {
		 if (classPath == null) {
			 return;
		 }
		 this.classPath.append(classPath);
		 this.classPath.setProject(classPath.getProject());
	 }
	 public void addRootClass(String className) {
		 if (className == null) {
			 return;
		 }
		 if (!rootClasses.contains(className)) {
			 rootClasses.addElement(className);
		 }
	 }
	 public void config(String name, Object info) {
	 }
	 public void reset() {
		 rootClasses.removeAllElements();
		 determined = false;
		 fileDependencies = new Vector();
		 classDependencies = new Vector();
	 }
	 protected Enumeration getRootClasses() {
		 return rootClasses.elements();
	 }
	 protected boolean isClosureRequired() {
		 return closure;
	 }
	 protected abstract void determineDependencies(Vector files, Vector classes);
	 protected abstract boolean supportsFileDependencies();
	 private File getResourceContainer(String resourceLocation, String[] paths) throws IOException {
		 for (int i = 0;
		 i < paths.length;
		 ++i) {
			 File element = new File(paths[i]);
			 if (!element.exists()) {
				 continue;
			 }
			 if (element.isDirectory()) {
				 File resource = new File(element, resourceLocation);
				 if (resource.exists()) {
					 return resource;
				 }
			 }
			 else {
				 ZipFile zipFile = null;
				 try {
					 zipFile = new ZipFile(element);
					 if (zipFile.getEntry(resourceLocation) != null) {
						 return element;
					 }
				 }
				 finally {
					 if (zipFile != null) {
						 zipFile.close();
					 }
				 }
			 }
		 }
		 return null;
	 }
}",0,0,0,0
"public class ConstantPool extends HashMap<Constant, Constant> {
	 private final Constant key1 = new Constant();
	 private final Constant key2 = new Constant();
	 private final Constant key3 = new Constant();
	 private final Constant key4 = new Constant();
	 private final Constant key5 = new Constant();
	 public Constant newInteger(final int value) {
		 key1.set(value);
		 Constant result = get(key1);
		 if (result == null) {
			 result = new Constant(key1);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newFloat(final float value) {
		 key1.set(value);
		 Constant result = get(key1);
		 if (result == null) {
			 result = new Constant(key1);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newLong(final long value) {
		 key1.set(value);
		 Constant result = get(key1);
		 if (result == null) {
			 result = new Constant(key1);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newDouble(final double value) {
		 key1.set(value);
		 Constant result = get(key1);
		 if (result == null) {
			 result = new Constant(key1);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newUTF8(final String value) {
		 key1.set('s', value, null, null);
		 Constant result = get(key1);
		 if (result == null) {
			 result = new Constant(key1);
			 put(result);
		 }
		 return result;
	 }
	 private Constant newString(final String value) {
		 key2.set('S', value, null, null);
		 Constant result = get(key2);
		 if (result == null) {
			 newUTF8(value);
			 result = new Constant(key2);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newClass(final String value) {
		 key2.set('C', value, null, null);
		 Constant result = get(key2);
		 if (result == null) {
			 newUTF8(value);
			 result = new Constant(key2);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newMethodType(final String methodDescriptor) {
		 key2.set('t', methodDescriptor, null, null);
		 Constant result = get(key2);
		 if (result == null) {
			 newUTF8(methodDescriptor);
			 result = new Constant(key2);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newHandle(final int tag, final String owner, final String name, final String desc) {
		 key4.set((char) ('h' - 1 + tag), owner, name, desc);
		 Constant result = get(key4);
		 if (result == null) {
			 if (tag <= Opcodes.H_PUTSTATIC) {
				 newField(owner, name, desc);
			 }
			 else {
				 newMethod(owner, name, desc, tag == Opcodes.H_INVOKEINTERFACE);
			 }
			 result = new Constant(key4);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newConst(final Object cst) {
		 if (cst instanceof Integer) {
			 int val = ((Integer) cst).intValue();
			 return newInteger(val);
		 }
		 else if (cst instanceof Float) {
			 float val = ((Float) cst).floatValue();
			 return newFloat(val);
		 }
		 else if (cst instanceof Long) {
			 long val = ((Long) cst).longValue();
			 return newLong(val);
		 }
		 else if (cst instanceof Double) {
			 double val = ((Double) cst).doubleValue();
			 return newDouble(val);
		 }
		 else if (cst instanceof String) {
			 return newString((String) cst);
		 }
		 else if (cst instanceof Type) {
			 Type t = (Type) cst;
			 int s = t.getSort();
			 if (s == Type.OBJECT) {
				 return newClass(t.getInternalName());
			 }
			 else if (s == Type.METHOD) {
				 return newMethodType(t.getDescriptor());
			 }
			 else {
				 return newClass(t.getDescriptor());
			 }
		 }
		 else if (cst instanceof Handle) {
			 Handle h = (Handle) cst;
			 return newHandle(h.getTag(), h.getOwner(), h.getName(), h.getDesc());
		 }
		 else {
			 throw new IllegalArgumentException(""value "" + cst);
		 }
	 }
	 public Constant newField(final String owner, final String name, final String desc) {
		 key3.set('G', owner, name, desc);
		 Constant result = get(key3);
		 if (result == null) {
			 newClass(owner);
			 newNameType(name, desc);
			 result = new Constant(key3);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newMethod(final String owner, final String name, final String desc, final boolean itf) {
		 key3.set(itf ? 'N' : 'M', owner, name, desc);
		 Constant result = get(key3);
		 if (result == null) {
			 newClass(owner);
			 newNameType(name, desc);
			 result = new Constant(key3);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newInvokeDynamic(String name, String desc, Handle bsm, Object... bsmArgs) {
		 key5.set(name, desc, bsm, bsmArgs);
		 Constant result = get(key5);
		 if (result == null) {
			 newNameType(name, desc);
			 newHandle(bsm.getTag(), bsm.getOwner(), bsm.getName(), bsm.getDesc());
			 for (Object bsmArg : bsmArgs) {
				 newConst(bsmArg);
			 }
			 result = new Constant(key5);
			 put(result);
		 }
		 return result;
	 }
	 public Constant newNameType(final String name, final String desc) {
		 key2.set('T', name, desc, null);
		 Constant result = get(key2);
		 if (result == null) {
			 newUTF8(name);
			 newUTF8(desc);
			 result = new Constant(key2);
			 put(result);
		 }
		 return result;
	 }
	 private Constant get(final Constant key) {
		 return get((Object) key);
	 }
	 private void put(final Constant cst) {
		 put(cst, cst);
	 }
}",0,0,0,0
"public class XSLFSlideShow extends POIXMLDocument {
	public static final String MAIN_CONTENT_TYPE = ""application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"";
	public static final String NOTES_CONTENT_TYPE = ""application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml"";
	public static final String SLIDE_CONTENT_TYPE = ""application/vnd.openxmlformats-officedocument.presentationml.slide+xml"";
	public static final String SLIDE_LAYOUT_RELATION_TYPE = ""http:public static final String NOTES_RELATION_TYPE = ""http:public static final String COMMENT_RELATION_TYPE = ""http:private PresentationDocument presentationDoc;
	 private List<PackagePart> embedds;
	public XSLFSlideShow(OPCPackage container) throws OpenXML4JException, IOException, XmlException {
		super(container);
		presentationDoc =PresentationDocument.Factory.parse(getCorePart().getInputStream());
		 embedds = new LinkedList<PackagePart>();
		for (CTSlideIdListEntry ctSlide : getSlideReferences().getSldIdArray()) {
			 PackagePart slidePart = getTargetPart(getCorePart().getRelationship(ctSlide.getId2()));
			 for(PackageRelationship rel : slidePart.getRelationshipsByType(OLE_OBJECT_REL_TYPE)) embedds.add(getTargetPart(rel));
			 for(PackageRelationship rel : slidePart.getRelationshipsByType(PACK_OBJECT_REL_TYPE)) embedds.add(getTargetPart(rel));
		}
	}
	public XSLFSlideShow(String file) throws OpenXML4JException, IOException, XmlException {
		this(openPackage(file));
	}
	public CTPresentation getPresentation() {
		return presentationDoc.getPresentation();
	}
	public CTSlideIdList getSlideReferences() {
		return getPresentation().getSldIdLst();
	}
	public CTSlideMasterIdList getSlideMasterReferences() {
		return getPresentation().getSldMasterIdLst();
	}
	public PackagePart getSlideMasterPart(CTSlideMasterIdListEntry master) throws IOException, XmlException {
		try {
			return getTargetPart(getCorePart().getRelationship(master.getId2()));
		}
		 catch(InvalidFormatException e) {
			throw new XmlException(e);
		}
	}
	public CTSlideMaster getSlideMaster(CTSlideMasterIdListEntry master) throws IOException, XmlException {
		PackagePart masterPart = getSlideMasterPart(master);
		SldMasterDocument masterDoc =SldMasterDocument.Factory.parse(masterPart.getInputStream());
		return masterDoc.getSldMaster();
	}
	public PackagePart getSlidePart(CTSlideIdListEntry slide) throws IOException, XmlException {
		try {
			return getTargetPart(getCorePart().getRelationship(slide.getId2()));
		}
		 catch(InvalidFormatException e) {
			throw new XmlException(e);
		}
	}
	public CTSlide getSlide(CTSlideIdListEntry slide) throws IOException, XmlException {
		PackagePart slidePart = getSlidePart(slide);
		SldDocument slideDoc =SldDocument.Factory.parse(slidePart.getInputStream());
		return slideDoc.getSld();
	}
	public PackagePart getNodesPart(CTSlideIdListEntry parentSlide) throws IOException, XmlException {
		PackageRelationshipCollection notes;
		PackagePart slidePart = getSlidePart(parentSlide);
		try {
			notes = slidePart.getRelationshipsByType(NOTES_RELATION_TYPE);
		}
		 catch(InvalidFormatException e) {
			throw new IllegalStateException(e);
		}
		if(notes.size() == 0) {
			return null;
		}
		if(notes.size() > 1) {
			throw new IllegalStateException(""Expecting 0 or 1 notes for a slide, but found "" + notes.size());
		}
		try {
			return getTargetPart(notes.getRelationship(0));
		}
		 catch(InvalidFormatException e) {
			throw new IllegalStateException(e);
		}
	}
	public CTNotesSlide getNotes(CTSlideIdListEntry slide) throws IOException, XmlException {
		PackagePart notesPart = getNodesPart(slide);
		if(notesPart == null)return null;
		NotesDocument notesDoc =NotesDocument.Factory.parse(notesPart.getInputStream());
		return notesDoc.getNotes();
	}
	public CTCommentList getSlideComments(CTSlideIdListEntry slide) throws IOException, XmlException {
		PackageRelationshipCollection commentRels;
		PackagePart slidePart = getSlidePart(slide);
		try {
			commentRels = slidePart.getRelationshipsByType(COMMENT_RELATION_TYPE);
		}
		 catch(InvalidFormatException e) {
			throw new IllegalStateException(e);
		}
		if(commentRels.size() == 0) {
			return null;
		}
		if(commentRels.size() > 1) {
			throw new IllegalStateException(""Expecting 0 or 1 comments for a slide, but found "" + commentRels.size());
		}
		try {
			PackagePart cPart = getTargetPart(commentRels.getRelationship(0));
			CmLstDocument commDoc = CmLstDocument.Factory.parse(cPart.getInputStream());
			return commDoc.getCmLst();
		}
		 catch(InvalidFormatException e) {
			throw new IllegalStateException(e);
		}
	}
	 public List<PackagePart> getAllEmbedds() throws OpenXML4JException {
		 return embedds;
	 }
}",1,0,0,0
"public class GenerationHelperContentHandler extends DelegatingContentHandler {
	 private static final Attributes EMPTY_ATTS = new AttributesImpl();
	 private String mainNamespace;
	 private Object contentHandlerContext;
	 public GenerationHelperContentHandler(ContentHandler handler, String mainNamespace, Object contentHandlerContext) {
		 super(handler);
		 this.mainNamespace = mainNamespace;
		 this.contentHandlerContext = contentHandlerContext;
	 }
	 public String getMainNamespace() {
		 return this.mainNamespace;
	 }
	 public void setMainNamespace(String namespaceURI) {
		 this.mainNamespace = namespaceURI;
	 }
	 public Object getContentHandlerContext() {
		 return this.contentHandlerContext;
	 }
	 public void startElement(String localName, Attributes atts) throws SAXException {
		 getDelegateContentHandler().startElement(getMainNamespace(), localName, localName, atts);
	 }
	 public void startElement(String localName) throws SAXException {
		 startElement(localName, EMPTY_ATTS);
	 }
	 public void startElement(QName qName, Attributes atts) throws SAXException {
		 getDelegateContentHandler().startElement(qName.getNamespaceURI(), qName.getLocalName(), qName.getQName(), atts);
	 }
	 public void startElement(QName qName) throws SAXException {
		 startElement(qName, EMPTY_ATTS);
	 }
	 public void endElement(String localName) throws SAXException {
		 getDelegateContentHandler().endElement(getMainNamespace(), localName, localName);
	 }
	 public void endElement(QName qName) throws SAXException {
		 getDelegateContentHandler().endElement(qName.getNamespaceURI(), qName.getLocalName(), qName.getQName());
	 }
	 public void element(String localName, Attributes atts) throws SAXException {
		 getDelegateContentHandler().startElement(getMainNamespace(), localName, localName, atts);
		 getDelegateContentHandler().endElement(getMainNamespace(), localName, localName);
	 }
	 public void element(QName qName, Attributes atts) throws SAXException {
		 getDelegateContentHandler().startElement(qName.getNamespaceURI(), qName.getLocalName(), qName.getQName(), atts);
		 getDelegateContentHandler().endElement(qName.getNamespaceURI(), qName.getLocalName(), qName.getQName());
	 }
}",0,0,0,0
"public class DrillFilterItemStarReWriterRule {
	 public static final ProjectOnScan PROJECT_ON_SCAN = new ProjectOnScan( RelOptHelper.some(DrillProjectRel.class, RelOptHelper.any(DrillScanRel.class)), ""DrillFilterItemStarReWriterRule.ProjectOnScan"");
	 public static final FilterOnScan FILTER_ON_SCAN = new FilterOnScan( RelOptHelper.some(DrillFilterRel.class, RelOptHelper.any(DrillScanRel.class)), ""DrillFilterItemStarReWriterRule.FilterOnScan"");
	 public static final FilterProjectScan FILTER_PROJECT_SCAN = new FilterProjectScan( RelOptHelper.some(DrillFilterRel.class, RelOptHelper.some(DrillProjectRel.class, RelOptHelper.any(DrillScanRel.class))), ""DrillFilterItemStarReWriterRule.FilterProjectScan"");
	 private static class ProjectOnScan extends RelOptRule {
		 ProjectOnScan(RelOptRuleOperand operand, String id) {
			 super(operand, id);
		 }
		 public boolean matches(RelOptRuleCall call) {
			 DrillScanRel scan = call.rel(1);
			 return scan.getGroupScan() instanceof AbstractParquetGroupScan && super.matches(call);
		 }
		 public void onMatch(RelOptRuleCall call) {
			 DrillProjectRel projectRel = call.rel(0);
			 DrillScanRel scanRel = call.rel(1);
			 ItemStarFieldsVisitor itemStarFieldsVisitor = new ItemStarFieldsVisitor(scanRel.getRowType().getFieldNames());
			 List<RexNode> projects = projectRel.getProjects();
			 for (RexNode project : projects) {
				 project.accept(itemStarFieldsVisitor);
			 }
			 if (itemStarFieldsVisitor.hasNoItemStarFields()) {
				 return;
			 }
			 Map<String, DesiredField> itemStarFields = itemStarFieldsVisitor.getItemStarFields();
			 DrillScanRel newScan = createNewScan(scanRel, itemStarFields);
			 Map<RexNode, Integer> fieldMapper = createFieldMapper(itemStarFields.values(), scanRel.getRowType().getFieldCount());
			 FieldsReWriter fieldsReWriter = new FieldsReWriter(fieldMapper);
			 List<RexNode> newProjects = new ArrayList<>();
			 for (RexNode node : projectRel.getChildExps()) {
				 newProjects.add(node.accept(fieldsReWriter));
			 }
			 DrillProjectRel newProject = new DrillProjectRel( projectRel.getCluster(), projectRel.getTraitSet(), newScan, newProjects, projectRel.getRowType());
			 if (ProjectRemoveRule.isTrivial(newProject)) {
				 call.transformTo(newScan);
			 }
			 else {
				 call.transformTo(newProject);
			 }
		 }
	 }
	 private static class FilterOnScan extends RelOptRule {
		 FilterOnScan(RelOptRuleOperand operand, String id) {
			 super(operand, id);
		 }
		 public boolean matches(RelOptRuleCall call) {
			 DrillScanRel scan = call.rel(1);
			 return scan.getGroupScan() instanceof AbstractParquetGroupScan && super.matches(call);
		 }
		 public void onMatch(RelOptRuleCall call) {
			 DrillFilterRel filterRel = call.rel(0);
			 DrillScanRel scanRel = call.rel(1);
			 transformFilterCall(filterRel, null, scanRel, call);
		 }
	 }
	 private static class FilterProjectScan extends RelOptRule {
		 FilterProjectScan(RelOptRuleOperand operand, String id) {
			 super(operand, id);
		 }
		 public boolean matches(RelOptRuleCall call) {
			 DrillScanRel scan = call.rel(2);
			 return scan.getGroupScan() instanceof AbstractParquetGroupScan && super.matches(call);
		 }
		 public void onMatch(RelOptRuleCall call) {
			 DrillFilterRel filterRel = call.rel(0);
			 DrillProjectRel projectRel = call.rel(1);
			 DrillScanRel scanRel = call.rel(2);
			 transformFilterCall(filterRel, projectRel, scanRel, call);
		 }
	 }
	 private static void transformFilterCall(DrillFilterRel filterRel, DrillProjectRel projectRel, DrillScanRel scanRel, RelOptRuleCall call) {
		 List<String> fieldNames = projectRel == null ? scanRel.getRowType().getFieldNames() : projectRel.getRowType().getFieldNames();
		 ItemStarFieldsVisitor itemStarFieldsVisitor = new ItemStarFieldsVisitor(fieldNames);
		 filterRel.getCondition().accept(itemStarFieldsVisitor);
		 if (itemStarFieldsVisitor.hasNoItemStarFields()) {
			 return;
		 }
		 Map<String, DesiredField> itemStarFields = itemStarFieldsVisitor.getItemStarFields();
		 DrillScanRel newScan = createNewScan(scanRel, itemStarFields);
		 DrillProjectRel newProject = null;
		 if (projectRel != null) {
			 int projectIndex = scanRel.getRowType().getFieldCount();
			 List<RexNode> newProjects = new ArrayList<>(projectRel.getProjects());
			 for (DesiredField desiredField : itemStarFields.values()) {
				 newProjects.add(new RexInputRef(projectIndex, desiredField.getType()));
				 projectIndex++;
			 }
			 RelDataType newProjectRowType = createNewRowType( projectRel.getCluster().getTypeFactory(), projectRel.getRowType().getFieldList(), itemStarFields.keySet());
			 newProject = new DrillProjectRel( projectRel.getCluster(), projectRel.getTraitSet(), newScan, newProjects, newProjectRowType);
		 }
		 Map<RexNode, Integer> fieldMapper = createFieldMapper(itemStarFields.values(), scanRel.getRowType().getFieldCount());
		 FieldsReWriter fieldsReWriter = new FieldsReWriter(fieldMapper);
		 RexNode newCondition = filterRel.getCondition().accept(fieldsReWriter);
		 DrillFilterRel newFilter = DrillFilterRel.create(newProject != null ? newProject : newScan, newCondition);
		 List<RexNode> newProjects = new ArrayList<>();
		 RelDataType rowType = filterRel.getRowType();
		 List<RelDataTypeField> fieldList = rowType.getFieldList();
		 for (RelDataTypeField field : fieldList) {
			 RexInputRef inputRef = new RexInputRef(field.getIndex(), field.getType());
			 newProjects.add(inputRef);
		 }
		 DrillProjectRel wrapper = new DrillProjectRel(filterRel.getCluster(), filterRel.getTraitSet(), newFilter, newProjects, filterRel.getRowType());
		 call.transformTo(wrapper);
	 }
	 private static RelDataType createNewRowType(RelDataTypeFactory typeFactory, List<RelDataTypeField> originalFields, Collection<String> newFields) {
		 RelDataTypeHolder relDataTypeHolder = new RelDataTypeHolder();
		 for (RelDataTypeField field : originalFields) {
			 relDataTypeHolder.getField(typeFactory, field.getName());
		 }
		 for (String fieldName : newFields) {
			 relDataTypeHolder.getField(typeFactory, fieldName);
		 }
		 return new RelDataTypeDrillImpl(relDataTypeHolder, typeFactory);
	 }
	 private static DrillScanRel createNewScan(DrillScanRel scanRel, Map<String, DesiredField> itemStarFields) {
		 RelDataType newScanRowType = createNewRowType( scanRel.getCluster().getTypeFactory(), scanRel.getRowType().getFieldList(), itemStarFields.keySet());
		 List<SchemaPath> columns = new ArrayList<>(scanRel.getColumns());
		 for (DesiredField desiredField : itemStarFields.values()) {
			 String name = desiredField.getName();
			 PathSegment.NameSegment nameSegment = new PathSegment.NameSegment(name);
			 columns.add(new SchemaPath(nameSegment));
		 }
		 return new DrillScanRel( scanRel.getCluster(), scanRel.getTraitSet().plus(DrillRel.DRILL_LOGICAL), scanRel.getTable(), newScanRowType, columns);
	 }
	 private static Map<RexNode, Integer> createFieldMapper(Collection<DesiredField> desiredFields, int startingIndex) {
		 Map<RexNode, Integer> fieldMapper = new HashMap<>();
		 int index = startingIndex;
		 for (DesiredField desiredField : desiredFields) {
			 for (RexNode node : desiredField.getNodes()) {
				 fieldMapper.put(node, index);
			 }
			 index++;
		 }
		 return fieldMapper;
	 }
	 private static class ItemStarFieldsVisitor extends RexVisitorImpl<RexNode> {
		 private final Map<String, DesiredField> itemStarFields = new HashMap<>();
		 private final List<String> fieldNames;
		 ItemStarFieldsVisitor(List<String> fieldNames) {
			 super(true);
			 this.fieldNames = fieldNames;
		 }
		 boolean hasNoItemStarFields() {
			 return itemStarFields.isEmpty();
		 }
		 Map<String, DesiredField> getItemStarFields() {
			 return itemStarFields;
		 }
		 public RexNode visitCall(RexCall call) {
			 String fieldName = FieldsReWriterUtil.getFieldNameFromItemStarField(call, fieldNames);
			 if (fieldName != null) {
				 DesiredField desiredField = itemStarFields.get(fieldName);
				 if (desiredField == null) {
					 itemStarFields.put(fieldName, new DesiredField(fieldName, call.getType(), call));
				 }
				 else {
					 desiredField.addNode(call);
				 }
			 }
			 return super.visitCall(call);
		 }
	 }
}",1,0,0,0
"public class B002 extends A {
	public String pubEarly() {
		return ""B002.pubEarly()"";
	}
	private String privEarly() {
		return ""B002.privEarly()"";
	}
	static String staticEarly() {
		return ""B002.staticEarly()"";
	}
	public String pubLate() {
		return ""B002.pubLate()"";
	}
	private String privLate() {
		return ""B002.privLate()"";
	}
	static String staticLate() {
		return ""B002.staticLate()"";
	}
}",0,1,0,0
"public void defaultWriteObject() throws IOException{
	if (!defaultWrite.contains(curObject)){
		defaultWrite.add(curObject);
		classHandlerStack.peek().writeFields(this, curObject);
	}
}",0,0,0,0
"public class JakartaOroRegexp extends JakartaOroMatcher implements Regexp {
	 private static final int DECIMAL = 10;
	 public JakartaOroRegexp() {
		 super();
	 }
	 public String substitute(String input, String argument, int options) throws BuildException {
		 StringBuffer subst = new StringBuffer();
		 for (int i = 0;
		 i < argument.length();
		 i++) {
			 char c = argument.charAt(i);
			 if (c == '$') {
				 subst.append('\\');
				 subst.append('$');
			 }
			 else if (c == '\\') {
				 if (++i < argument.length()) {
					 c = argument.charAt(i);
					 int value = Character.digit(c, DECIMAL);
					 if (value > -1) {
						 subst.append(""$"").append(value);
					 }
					 else {
						 subst.append(c);
					 }
				 }
				 else {
					 subst.append('\\');
				 }
			 }
			 else {
				 subst.append(c);
			 }
		 }
		 Substitution s = new Perl5Substitution(subst.toString(), Perl5Substitution.INTERPOLATE_ALL);
		 return Util.substitute(matcher, getCompiledPattern(options), s, input, getSubsOptions(options));
	 }
	 protected int getSubsOptions(int options) {
		 boolean replaceAll = RegexpUtil.hasFlag(options, REPLACE_ALL);
		 int subsOptions = 1;
		 if (replaceAll) {
			 subsOptions = Util.SUBSTITUTE_ALL;
		 }
		 return subsOptions;
	 }
}",0,0,0,0
"public final class SequenceType implements Serializable {
	 private static final long serialVersionUID = 1L;
	 public static final Map<ItemType, SequenceType[]> BUILTIN_SEQ_TYPES;
	 private ItemType itemType;
	 private Quantifier quantifier;
	 static {
		 Map<ItemType, SequenceType[]> types = new LinkedHashMap<>();
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_ANY_ATOMIC);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_STRING);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NORMALIZED_STRING);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_TOKEN);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_LANGUAGE);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NMTOKEN);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NAME);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NCNAME);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_ID);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_IDREF);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_ENTITY);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_UNTYPED_ATOMIC);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_DATETIME);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_DATE);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_TIME);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_DURATION);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_YEAR_MONTH_DURATION);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_DAY_TIME_DURATION);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XSEXT_NUMERIC);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_FLOAT);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_DOUBLE);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_DECIMAL);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_INTEGER);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NON_POSITIVE_INTEGER);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NEGATIVE_INTEGER);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_LONG);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_LONG);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_INT);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_SHORT);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_BYTE);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NON_NEGATIVE_INTEGER);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_UNSIGNED_LONG);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_UNSIGNED_INT);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_UNSIGNED_SHORT);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_UNSIGNED_BYTE);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_POSITIVE_INTEGER);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_G_YEAR_MONTH);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_G_YEAR);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_G_MONTH_DAY);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_G_DAY);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_G_MONTH);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_BOOLEAN);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_BASE64_BINARY);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_HEX_BINARY);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_ANY_URI);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_QNAME);
		 createBuiltinEntry(types, BuiltinTypeRegistry.XS_NOTATION);
		 createBuiltinEntry(types, BuiltinTypeRegistry.JS_NULL);
		 createBuiltinEntry(types, AnyItemType.INSTANCE);
		 createBuiltinEntry(types, AnyNodeType.INSTANCE);
		 createBuiltinEntry(types, DocumentType.ANYDOCUMENT);
		 createBuiltinEntry(types, ElementType.ANYELEMENT);
		 createBuiltinEntry(types, AttributeType.ANYATTRIBUTE);
		 createBuiltinEntry(types, CommentType.INSTANCE);
		 createBuiltinEntry(types, ProcessingInstructionType.ANYPI);
		 createBuiltinEntry(types, ArrayType.INSTANCE);
		 createBuiltinEntry(types, ObjectType.INSTANCE);
		 BUILTIN_SEQ_TYPES = Collections.unmodifiableMap(types);
	 }
	 private SequenceType(ItemType itemType, Quantifier quantifier) {
		 this.itemType = itemType;
		 this.quantifier = quantifier;
	 }
	 private static void createBuiltinEntry(Map<ItemType, SequenceType[]> types, ItemType itemType) {
		 types.put(itemType, new SequenceType[] {
		 new SequenceType(itemType, Quantifier.QUANT_ZERO), new SequenceType(itemType, Quantifier.QUANT_ONE), new SequenceType(itemType, Quantifier.QUANT_QUESTION), new SequenceType(itemType, Quantifier.QUANT_STAR), new SequenceType(itemType, Quantifier.QUANT_PLUS), }
		);
	 }
	 public static SequenceType create(ItemType itemType, Quantifier quantifier) {
		 SequenceType[] types = BUILTIN_SEQ_TYPES.get(itemType);
		 if (types == null) {
			 return new SequenceType(itemType, quantifier);
		 }
		 return types[quantifier.ordinal()];
	 }
	 public ItemType getItemType() {
		 return itemType;
	 }
	 public Quantifier getQuantifier() {
		 return quantifier;
	 }
	 public int hashCode() {
		 final int prime = 31;
		 int result = 1;
		 result = prime * result + ((itemType == null) ? 0 : itemType.hashCode());
		 result = prime * result + ((quantifier == null) ? 0 : quantifier.hashCode());
		 return result;
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (obj == null) return false;
		 if (getClass() != obj.getClass()) return false;
		 SequenceType other = (SequenceType) obj;
		 if (itemType == null) {
			 if (other.itemType != null) return false;
		 }
		 else if (!itemType.equals(other.itemType)) return false;
		 if (quantifier != other.quantifier) return false;
		 return true;
	 }
	 public String toString() {
		 return String.valueOf(itemType) + Quantifier.toString(quantifier);
	 }
}",0,0,0,0
"public class IsSigned extends DataType implements Condition {
	 private static final String SIG_START = ""META-INF/"";
	 private static final String SIG_END = "".SF"";
	 private static final int SHORT_SIG_LIMIT = 8;
	 private String name;
	 private File file;
	 public void setFile(File file) {
		 this.file = file;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public static boolean isSigned(File zipFile, String name) throws IOException {
		 ZipFile jarFile = null;
		 try {
			 jarFile = new ZipFile(zipFile);
			 if (null == name) {
				 Enumeration entries = jarFile.getEntries();
				 while (entries.hasMoreElements()) {
					 String eName = ((ZipEntry) entries.nextElement()).getName();
					 if (eName.startsWith(SIG_START) && eName.endsWith(SIG_END)) {
						 return true;
					 }
				 }
				 return false;
			 }
			 name = replaceInvalidChars(name);
			 boolean shortSig = jarFile.getEntry(SIG_START + name.toUpperCase() + SIG_END) != null;
			 boolean longSig = false;
			 if (name.length() > SHORT_SIG_LIMIT) {
				 longSig = jarFile.getEntry( SIG_START + name.substring(0, SHORT_SIG_LIMIT).toUpperCase() + SIG_END) != null;
			 }
			 return shortSig || longSig;
		 }
		 finally {
			 ZipFile.closeQuietly(jarFile);
		 }
	 }
	 public boolean eval() {
		 if (file == null) {
			 throw new BuildException(""The file attribute must be set."");
		 }
		 if (!file.exists()) {
			 log(""The file \"""" + file.getAbsolutePath() + ""\"" does not exist."", Project.MSG_VERBOSE);
			 return false;
		 }
		 boolean r = false;
		 try {
			 r = isSigned(file, name);
		 }
		 catch (IOException e) {
			 log(""Got IOException reading file \"""" + file.getAbsolutePath() + ""\"""" + e, Project.MSG_WARN);
		 }
		 if (r) {
			 log(""File \"""" + file.getAbsolutePath() + ""\"" is signed."", Project.MSG_VERBOSE);
		 }
		 return r;
	 }
	 private static String replaceInvalidChars(final String name) {
		 StringBuffer sb = new StringBuffer();
		 final int len = name.length();
		 boolean changes = false;
		 for (int i = 0;
		 i < len;
		 i++) {
			 final char ch = name.charAt(i);
			 if (ManifestTask.VALID_ATTRIBUTE_CHARS.indexOf(ch) < 0) {
				 sb.append(""_"");
				 changes = true;
			 }
			 else {
				 sb.append(ch);
			 }
		 }
		 return changes ? sb.toString() : name;
	 }
}",0,0,0,0
"public interface ExtendFileSelector extends FileSelector, Parameterizable {
}",0,0,0,0
"public CellRangeAddress(int firstRow, int lastRow, int firstCol, int lastCol);",0,0,0,1
"public class PhTypeUtil {
	 public static byte[] toBytes(Object v, PhType phType) {
		 if (v == null) return null;
		 byte[] b = null;
		 if (phType == PhType.DEFAULT) {
			 PhType phType1 = PhType.getType(v.getClass());
			 if (phType1 != null && phType1 != PhType.DEFAULT) {
				 toBytes(v, phType1);
			 }
		 }
		 else if (phType == PhType.INTEGER) {
			 b = new byte[Bytes.SIZEOF_INT];
			 encodeInt(((Number) v).intValue(), b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_INT) {
			 b = new byte[Bytes.SIZEOF_INT];
			 encodeUnsignedInt(((Number) v).intValue(), b, 0);
		 }
		 else if (phType == PhType.BIGINT) {
			 b = new byte[Bytes.SIZEOF_LONG];
			 encodeLong(((Number) v).longValue(), b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_LONG) {
			 b = new byte[Bytes.SIZEOF_LONG];
			 encodeUnsignedLong(((Number) v).longValue(), b, 0);
		 }
		 else if (phType == PhType.SMALLINT) {
			 b = new byte[Bytes.SIZEOF_SHORT];
			 encodeShort(((Number) v).shortValue(), b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_SMALLINT) {
			 b = new byte[Bytes.SIZEOF_SHORT];
			 encodeUnsignedShort(((Number) v).shortValue(), b, 0);
		 }
		 else if (phType == PhType.TINYINT) {
			 b = new byte[Bytes.SIZEOF_BYTE];
			 encodeByte(((Number) v).byteValue(), b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_TINYINT) {
			 b = new byte[Bytes.SIZEOF_BYTE];
			 encodeUnsignedByte(((Number) v).byteValue(), b, 0);
		 }
		 else if (phType == PhType.FLOAT) {
			 b = new byte[Bytes.SIZEOF_FLOAT];
			 encodeFloat(((Number) v).floatValue(), b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_FLOAT) {
			 b = new byte[Bytes.SIZEOF_FLOAT];
			 encodeUnsignedFloat(((Number) v).floatValue(), b, 0);
		 }
		 else if (phType == PhType.DOUBLE) {
			 b = new byte[Bytes.SIZEOF_DOUBLE];
			 encodeDouble(((Number) v).doubleValue(), b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_DOUBLE) {
			 b = new byte[Bytes.SIZEOF_DOUBLE];
			 encodeUnsignedDouble(((Number) v).doubleValue(), b, 0);
		 }
		 else if (phType == PhType.BOOLEAN) {
			 if ((Boolean) v) {
				 b = new byte[] {
				 1 }
				;
			 }
			 else {
				 b = new byte[] {
				 0 }
				;
			 }
		 }
		 else if (phType == PhType.TIME || phType == PhType.DATE) {
			 b = new byte[Bytes.SIZEOF_LONG];
			 encodeDate(v, b, 0);
		 }
		 else if (phType == PhType.TIMESTAMP) {
			 b = new byte[Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT];
			 encodeTimestamp(v, b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_TIME || phType == PhType.UNSIGNED_DATE) {
			 b = new byte[Bytes.SIZEOF_LONG];
			 encodeUnsignedDate(v, b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_TIMESTAMP) {
			 b = new byte[Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT];
			 encodeUnsignedTimestamp(v, b, 0);
		 }
		 else if (phType == PhType.VARBINARY) {
			 b = (byte[]) v;
		 }
		 else if (phType == PhType.VARCHAR) {
			 b = Bytes.toBytes(v.toString());
		 }
		 else if (phType == PhType.DECIMAL) {
			 if (v instanceof BigDecimal) {
				 b = encodeDecimal(v);
			 }
			 else if (v instanceof Number) {
				 b = encodeDecimal(new BigDecimal(v.toString()));
			 }
		 }
		 return b;
	 }
	 public static Object toObject(byte[] b, PhType phType) {
		 if (b == null) return null;
		 Object v = null;
		 if (phType == PhType.INTEGER) {
			 v = decodeInt(b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_INT) {
			 v = decodeUnsignedInt(b, 0);
		 }
		 else if (phType == PhType.BIGINT) {
			 v = decodeLong(b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_LONG) {
			 v = decodeUnsignedLong(b, 0);
		 }
		 else if (phType == PhType.SMALLINT) {
			 v = decodeShort(b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_SMALLINT) {
			 v = decodeUnsignedShort(b, 0);
		 }
		 else if (phType == PhType.TINYINT) {
			 v = decodeByte(b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_TINYINT) {
			 v = decodeUnsignedByte(b, 0);
		 }
		 else if (phType == PhType.FLOAT) {
			 v = decodeFloat(b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_FLOAT) {
			 v = decodeUnsignedFloat(b, 0);
		 }
		 else if (phType == PhType.DOUBLE) {
			 v = decodeDouble(b, 0);
		 }
		 else if (phType == PhType.UNSIGNED_DOUBLE) {
			 v = decodeUnsignedDouble(b, 0);
		 }
		 else if (phType == PhType.BOOLEAN) {
			 checkForSufficientLength(b, 0, Bytes.SIZEOF_BOOLEAN);
			 if (b[0] == 1) {
				 v = true;
			 }
			 else if (b[0] == 0) {
				 v = false;
			 }
		 }
		 else if (phType == PhType.DATE) {
			 v = new java.sql.Date(decodeLong(b, 0));
		 }
		 else if (phType == PhType.TIME) {
			 v = new java.sql.Time(decodeLong(b, 0));
		 }
		 else if (phType == PhType.TIMESTAMP) {
			 long millisDeserialized = decodeLong(b, 0);
			 Timestamp ts = new Timestamp(millisDeserialized);
			 int nanosDeserialized = decodeUnsignedInt(b, Bytes.SIZEOF_LONG);
			 ts.setNanos(nanosDeserialized < 1000000 ? ts.getNanos() + nanosDeserialized : nanosDeserialized);
			 v = ts;
		 }
		 else if (phType == PhType.UNSIGNED_TIME || phType == PhType.UNSIGNED_DATE) {
			 v = new Date(decodeUnsignedLong(b, 0));
		 }
		 else if (phType == PhType.UNSIGNED_TIMESTAMP) {
			 long millisDeserialized = decodeUnsignedLong(b, 0);
			 Timestamp ts = new Timestamp(millisDeserialized);
			 int nanosDeserialized = decodeUnsignedInt(b, Bytes.SIZEOF_LONG);
			 ts.setNanos(nanosDeserialized < 1000000 ? ts.getNanos() + nanosDeserialized : nanosDeserialized);
			 v = ts;
		 }
		 else if (phType == PhType.VARBINARY) {
			 v = b;
		 }
		 else if (phType == PhType.VARCHAR || phType == PhType.DEFAULT) {
			 v = Bytes.toString(b);
		 }
		 else if (phType == PhType.DECIMAL) {
			 v = decodeDecimal(b, 0, b.length);
		 }
		 return v;
	 }
	 private static int decodeInt(byte[] bytes, int o) {
		 checkForSufficientLength(bytes, o, Bytes.SIZEOF_INT);
		 int v;
		 v = bytes[o] ^ 0x80;
		 for (int i = 1;
		 i < Bytes.SIZEOF_INT;
		 i++) {
			 v = (v << 8) + (bytes[o + i] & 0xff);
		 }
		 return v;
	 }
	 private static int encodeInt(int v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_INT);
		 b[o + 0] = (byte) ((v >> 24) ^ 0x80);
		 b[o + 1] = (byte) (v >> 16);
		 b[o + 2] = (byte) (v >> 8);
		 b[o + 3] = (byte) v;
		 return Bytes.SIZEOF_INT;
	 }
	 private static int decodeUnsignedInt(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_INT);
		 int v = Bytes.toInt(b, o);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 return v;
	 }
	 private static int encodeUnsignedInt(int v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_INT);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 Bytes.putInt(b, o, v);
		 return Bytes.SIZEOF_INT;
	 }
	 private static long decodeLong(byte[] bytes, int o) {
		 checkForSufficientLength(bytes, o, Bytes.SIZEOF_LONG);
		 long v;
		 byte b = bytes[o];
		 v = b ^ 0x80;
		 for (int i = 1;
		 i < Bytes.SIZEOF_LONG;
		 i++) {
			 b = bytes[o + i];
			 v = (v << 8) + (b & 0xff);
		 }
		 return v;
	 }
	 private static int encodeLong(long v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_LONG);
		 b[o + 0] = (byte) ((v >> 56) ^ 0x80);
		 b[o + 1] = (byte) (v >> 48);
		 b[o + 2] = (byte) (v >> 40);
		 b[o + 3] = (byte) (v >> 32);
		 b[o + 4] = (byte) (v >> 24);
		 b[o + 5] = (byte) (v >> 16);
		 b[o + 6] = (byte) (v >> 8);
		 b[o + 7] = (byte) v;
		 return Bytes.SIZEOF_LONG;
	 }
	 private static long decodeUnsignedLong(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_LONG);
		 long v = 0;
		 for (int i = o;
		 i < o + Bytes.SIZEOF_LONG;
		 i++) {
			 v <<= 8;
			 v ^= b[i] & 0xFF;
		 }
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 return v;
	 }
	 private static int encodeUnsignedLong(long v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_LONG);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 Bytes.putLong(b, o, v);
		 return Bytes.SIZEOF_LONG;
	 }
	 private static short decodeShort(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_SHORT);
		 int v;
		 v = b[o] ^ 0x80;
		 for (int i = 1;
		 i < Bytes.SIZEOF_SHORT;
		 i++) {
			 v = (v << 8) + (b[o + i] & 0xff);
		 }
		 return (short) v;
	 }
	 private static int encodeShort(short v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_SHORT);
		 b[o + 0] = (byte) ((v >> 8) ^ 0x80);
		 b[o + 1] = (byte) v;
		 return Bytes.SIZEOF_SHORT;
	 }
	 private static short decodeUnsignedShort(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_SHORT);
		 short v = Bytes.toShort(b, o);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 return v;
	 }
	 private static int encodeUnsignedShort(short v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_SHORT);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 Bytes.putShort(b, o, v);
		 return Bytes.SIZEOF_SHORT;
	 }
	 private static byte decodeByte(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_BYTE);
		 int v;
		 v = b[o] ^ 0x80;
		 return (byte) v;
	 }
	 private static int encodeByte(byte v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_BYTE);
		 b[o] = (byte) (v ^ 0x80);
		 return Bytes.SIZEOF_BYTE;
	 }
	 private static byte decodeUnsignedByte(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_BYTE);
		 byte v = b[o];
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 return v;
	 }
	 private static int encodeUnsignedByte(byte v, byte[] b, int o) {
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 Bytes.putByte(b, o, v);
		 return Bytes.SIZEOF_BYTE;
	 }
	 private static float decodeFloat(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_INT);
		 int value;
		 value = Bytes.toInt(b, o);
		 value--;
		 value ^= (~value >> Integer.SIZE - 1) | Integer.MIN_VALUE;
		 return Float.intBitsToFloat(value);
	 }
	 private static int encodeFloat(float v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_FLOAT);
		 int i = Float.floatToIntBits(v);
		 i = (i ^ ((i >> Integer.SIZE - 1) | Integer.MIN_VALUE)) + 1;
		 Bytes.putInt(b, o, i);
		 return Bytes.SIZEOF_FLOAT;
	 }
	 private static float decodeUnsignedFloat(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_FLOAT);
		 float v = Bytes.toFloat(b, o);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 return v;
	 }
	 private static int encodeUnsignedFloat(float v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_FLOAT);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 Bytes.putFloat(b, o, v);
		 return Bytes.SIZEOF_FLOAT;
	 }
	 private static double decodeDouble(byte[] bytes, int o) {
		 checkForSufficientLength(bytes, o, Bytes.SIZEOF_LONG);
		 long l;
		 l = Bytes.toLong(bytes, o);
		 l--;
		 l ^= (~l >> Long.SIZE - 1) | Long.MIN_VALUE;
		 return Double.longBitsToDouble(l);
	 }
	 private static int encodeDouble(double v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_LONG);
		 long l = Double.doubleToLongBits(v);
		 l = (l ^ ((l >> Long.SIZE - 1) | Long.MIN_VALUE)) + 1;
		 Bytes.putLong(b, o, l);
		 return Bytes.SIZEOF_LONG;
	 }
	 private static double decodeUnsignedDouble(byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_DOUBLE);
		 double v = Bytes.toDouble(b, o);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 return v;
	 }
	 private static int encodeUnsignedDouble(double v, byte[] b, int o) {
		 checkForSufficientLength(b, o, Bytes.SIZEOF_DOUBLE);
		 if (v < 0) {
			 throw new RuntimeException();
		 }
		 Bytes.putDouble(b, o, v);
		 return Bytes.SIZEOF_DOUBLE;
	 }
	 private static int encodeDate(Object v, byte[] b, int o) {
		 if (v instanceof Date) {
			 encodeLong(((Date) v).getTime(), b, 0);
		 }
		 else if (v instanceof String) {
			 String dateStr = (String) v;
			 Date date;
			 try {
				 date = Util.parseDate(dateStr);
				 if (date != null) {
					 encodeLong(date.getTime(), b, 0);
				 }
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
		 }
		 return Bytes.SIZEOF_LONG;
	 }
	 private static int encodeTimestamp(Object v, byte[] b, int o) {
		 if (v instanceof Timestamp) {
			 Timestamp ts = (Timestamp) v;
			 encodeLong(ts.getTime(), b, o);
			 Bytes.putInt(b, Bytes.SIZEOF_LONG, ts.getNanos() % 1000000);
		 }
		 else {
			 encodeDate(v, b, o);
		 }
		 return Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT;
	 }
	 private static int encodeUnsignedDate(Object v, byte[] b, int o) {
		 if (v instanceof Date) {
			 encodeUnsignedLong(((Date) v).getTime(), b, 0);
		 }
		 else if (v instanceof String) {
			 String dateStr = (String) v;
			 Date date;
			 try {
				 date = Util.parseDate(dateStr);
				 if (date != null) {
					 encodeUnsignedLong(date.getTime(), b, 0);
				 }
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
		 }
		 return Bytes.SIZEOF_LONG;
	 }
	 private static int encodeUnsignedTimestamp(Object v, byte[] b, int o) {
		 if (v instanceof Timestamp) {
			 Timestamp ts = (Timestamp) v;
			 encodeUnsignedLong(ts.getTime(), b, o);
			 Bytes.putInt(b, Bytes.SIZEOF_LONG, ts.getNanos() % 1000000);
		 }
		 else {
			 encodeUnsignedDate(v, b, o);
		 }
		 return Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT;
	 }
	 private static byte[] encodeDecimal(Object object) {
		 if (object == null) {
			 return new byte[0];
		 }
		 BigDecimal v = (BigDecimal) object;
		 v = v.round(DEFAULT_MATH_CONTEXT).stripTrailingZeros();
		 int len = getLength(v);
		 byte[] result = new byte[Math.min(len, 21)];
		 decimalToBytes(v, result, 0, len);
		 return result;
	 }
	 private static BigDecimal decodeDecimal(byte[] bytes, int offset, int length) {
		 if (length == 1 && bytes[offset] == ZERO_BYTE) {
			 return BigDecimal.ZERO;
		 }
		 int signum = ((bytes[offset] & 0x80) == 0) ? -1 : 1;
		 int scale;
		 int index;
		 int digitOffset;
		 long multiplier = 100L;
		 int begIndex = offset + 1;
		 if (signum == 1) {
			 scale = (byte) (((bytes[offset] & 0x7F) - 65) * -2);
			 index = offset + length;
			 digitOffset = POS_DIGIT_OFFSET;
		 }
		 else {
			 scale = (byte) ((~bytes[offset] - 65 - 128) * -2);
			 index = offset + length - (bytes[offset + length - 1] == NEG_TERMINAL_BYTE ? 1 : 0);
			 digitOffset = -NEG_DIGIT_OFFSET;
		 }
		 length = index - offset;
		 long l = signum * bytes[--index] - digitOffset;
		 if (l % 10 == 0) {
			 scale--;
			 l /= 10;
			 multiplier = 10;
		 }
		 while (index > begIndex) {
			 if (l >= MAX_LONG_FOR_DESERIALIZE || multiplier >= Long.MAX_VALUE / 100) {
				 multiplier = LongMath.divide(multiplier, 100L, RoundingMode.UNNECESSARY);
				 break;
			 }
			 int digit100 = signum * bytes[--index] - digitOffset;
			 l += digit100 * multiplier;
			 multiplier = LongMath.checkedMultiply(multiplier, 100);
		 }
		 BigInteger bi;
		 if (index > begIndex) {
			 bi = BigInteger.valueOf(l);
			 BigInteger biMultiplier = BigInteger.valueOf(multiplier).multiply(ONE_HUNDRED);
			 do {
				 int digit100 = signum * bytes[--index] - digitOffset;
				 bi = bi.add(biMultiplier.multiply(BigInteger.valueOf(digit100)));
				 biMultiplier = biMultiplier.multiply(ONE_HUNDRED);
			 }
			 while (index > begIndex);
			 if (signum == -1) {
				 bi = bi.negate();
			 }
		 }
		 else {
			 bi = BigInteger.valueOf(l * signum);
		 }
		 scale += (length - 2) * 2;
		 BigDecimal v = new BigDecimal(bi, scale);
		 return v;
	 }
	 private static int getLength(BigDecimal v) {
		 int signum = v.signum();
		 if (signum == 0) {
			 return 1;
		 }
		 return (signum < 0 ? 2 : 1) + (v.precision() + 1 + (v.scale() % 2 == 0 ? 0 : 1)) / 2;
	 }
	 private static final int MAX_PRECISION = 38;
	 private static final MathContext DEFAULT_MATH_CONTEXT = new MathContext(MAX_PRECISION, RoundingMode.HALF_UP);
	 private static final Integer MAX_BIG_DECIMAL_BYTES = 21;
	 private static final byte ZERO_BYTE = (byte) 0x80;
	 private static final byte NEG_TERMINAL_BYTE = (byte) 102;
	 private static final int EXP_BYTE_OFFSET = 65;
	 private static final int POS_DIGIT_OFFSET = 1;
	 private static final int NEG_DIGIT_OFFSET = 101;
	 private static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
	 private static final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);
	 private static final BigInteger ONE_HUNDRED = BigInteger.valueOf(100);
	 private static final long MAX_LONG_FOR_DESERIALIZE = Long.MAX_VALUE / 1000;
	 private static int decimalToBytes(BigDecimal v, byte[] result, final int offset, int length) {
		 int signum = v.signum();
		 if (signum == 0) {
			 result[offset] = ZERO_BYTE;
			 return 1;
		 }
		 int index = offset + length;
		 int scale = v.scale();
		 int expOffset = scale % 2 * (scale < 0 ? -1 : 1);
		 int multiplyBy;
		 BigInteger divideBy;
		 if (expOffset == 0) {
			 multiplyBy = 1;
			 divideBy = ONE_HUNDRED;
		 }
		 else {
			 multiplyBy = 10;
			 divideBy = BigInteger.TEN;
		 }
		 int digitOffset;
		 BigInteger compareAgainst;
		 if (signum == 1) {
			 digitOffset = POS_DIGIT_OFFSET;
			 compareAgainst = MAX_LONG;
			 scale -= (length - 2) * 2;
			 result[offset] = (byte) ((-(scale + expOffset) / 2 + EXP_BYTE_OFFSET) | 0x80);
		 }
		 else {
			 digitOffset = NEG_DIGIT_OFFSET;
			 compareAgainst = MIN_LONG;
			 scale -= (length - 2 - 1) * 2;
			 result[offset] = (byte) (~(-(scale + expOffset) / 2 + EXP_BYTE_OFFSET + 128) & 0x7F);
			 if (length <= MAX_BIG_DECIMAL_BYTES) {
				 result[--index] = NEG_TERMINAL_BYTE;
			 }
			 else {
				 length = MAX_BIG_DECIMAL_BYTES;
				 index = offset + length;
			 }
		 }
		 BigInteger bi = v.unscaledValue();
		 while (bi.compareTo(compareAgainst) * signum > 0) {
			 BigInteger[] dandr = bi.divideAndRemainder(divideBy);
			 bi = dandr[0];
			 int digit = dandr[1].intValue();
			 result[--index] = (byte) (digit * multiplyBy + digitOffset);
			 multiplyBy = 1;
			 divideBy = ONE_HUNDRED;
		 }
		 long l = bi.longValue();
		 do {
			 long divBy = 100 / multiplyBy;
			 long digit = l % divBy;
			 l /= divBy;
			 result[--index] = (byte) (digit * multiplyBy + digitOffset);
			 multiplyBy = 1;
		 }
		 while (l != 0);
		 return length;
	 }
	 private static void checkForSufficientLength(byte[] b, int offset, int requiredLength) {
		 if (b.length < offset + requiredLength) {
			 throw new RuntimeException( ""Expected length of at least "" + requiredLength + "" bytes, but had "" + (b.length - offset));
		 }
	 }
}",1,0,0,0
"public class Difference extends BaseResourceCollectionContainer {
	 protected Collection getCollection() {
		 List rc = getResourceCollections();
		 int size = rc.size();
		 if (size < 2) {
			 throw new BuildException(""The difference of "" + size + "" resource collection"" + ((size == 1) ? """" : ""s"") + "" is undefined."");
		 }
		 HashSet hs = new HashSet();
		 ArrayList al = new ArrayList();
		 for (Iterator rcIter = rc.iterator();
		 rcIter.hasNext();
		) {
			 for (Iterator r = nextRC(rcIter).iterator();
			 r.hasNext();
			) {
				 Object next = r.next();
				 if (hs.add(next)) {
					 al.add(next);
				 }
				 else {
					 al.remove(next);
				 }
			 }
		 }
		 return al;
	 }
	 private static ResourceCollection nextRC(Iterator i) {
		 return (ResourceCollection) i.next();
	 }
}",0,0,0,0
"public class Config {
	 public String mysqlAddr;
	 public Integer mysqlPort;
	 public String mysqlUsername;
	 public String mysqlPassword;
	 public String mqNamesrvAddr;
	 public String mqTopic;
	 public String startType = ""DEFAULT"";
	 public String binlogFilename;
	 public Long nextPosition;
	 public Integer maxTransactionRows = 100;
	 public void load() throws IOException {
		 InputStream in = Config.class.getClassLoader().getResourceAsStream(""rocketmq_mysql.conf"");
		 Properties properties = new Properties();
		 properties.load(in);
		 properties2Object(properties, this);
	 }
	 private void properties2Object(final Properties p, final Object object) {
		 Method[] methods = object.getClass().getMethods();
		 for (Method method : methods) {
			 String mn = method.getName();
			 if (mn.startsWith(""set"")) {
				 try {
					 String tmp = mn.substring(4);
					 String first = mn.substring(3, 4);
					 String key = first.toLowerCase() + tmp;
					 String property = p.getProperty(key);
					 if (property != null) {
						 Class<?>[] pt = method.getParameterTypes();
						 if (pt != null && pt.length > 0) {
							 String cn = pt[0].getSimpleName();
							 Object arg;
							 if (cn.equals(""int"") || cn.equals(""Integer"")) {
								 arg = Integer.parseInt(property);
							 }
							 else if (cn.equals(""long"") || cn.equals(""Long"")) {
								 arg = Long.parseLong(property);
							 }
							 else if (cn.equals(""double"") || cn.equals(""Double"")) {
								 arg = Double.parseDouble(property);
							 }
							 else if (cn.equals(""boolean"") || cn.equals(""Boolean"")) {
								 arg = Boolean.parseBoolean(property);
							 }
							 else if (cn.equals(""float"") || cn.equals(""Float"")) {
								 arg = Float.parseFloat(property);
							 }
							 else if (cn.equals(""String"")) {
								 arg = property;
							 }
							 else {
								 continue;
							 }
							 method.invoke(object, arg);
						 }
					 }
				 }
				 catch (Throwable ignored) {
				 }
			 }
		 }
	 }
	 public void setMysqlAddr(String mysqlAddr) {
		 this.mysqlAddr = mysqlAddr;
	 }
	 public void setMysqlPort(Integer mysqlPort) {
		 this.mysqlPort = mysqlPort;
	 }
	 public void setMysqlUsername(String mysqlUsername) {
		 this.mysqlUsername = mysqlUsername;
	 }
	 public void setMysqlPassword(String mysqlPassword) {
		 this.mysqlPassword = mysqlPassword;
	 }
	 public void setBinlogFilename(String binlogFilename) {
		 this.binlogFilename = binlogFilename;
	 }
	 public void setNextPosition(Long nextPosition) {
		 this.nextPosition = nextPosition;
	 }
	 public void setMaxTransactionRows(Integer maxTransactionRows) {
		 this.maxTransactionRows = maxTransactionRows;
	 }
	 public void setMqNamesrvAddr(String mqNamesrvAddr) {
		 this.mqNamesrvAddr = mqNamesrvAddr;
	 }
	 public void setMqTopic(String mqTopic) {
		 this.mqTopic = mqTopic;
	 }
	 public void setStartType(String startType) {
		 this.startType = startType;
	 }
}",1,1,0,0
"public class SpatialDimFilter implements DimFilter{
	 private final String dimension;
	 private final Bound bound;
	 public SpatialDimFilter( String dimension, Bound bound ) {
		 Preconditions.checkArgument(dimension != null, ""dimension must not be null"");
		 Preconditions.checkArgument(bound != null, ""bound must not be null"");
		 this.dimension = dimension;
		 this.bound = bound;
	 }
	 public byte[] getCacheKey() {
		 byte[] dimBytes = StringUtils.toUtf8(dimension);
		 byte[] boundBytes = bound.getCacheKey();
		 return ByteBuffer.allocate(2 + dimBytes.length + boundBytes.length) .put(DimFilterUtils.SPATIAL_CACHE_ID) .put(dimBytes) .put(DimFilterUtils.STRING_SEPARATOR) .put(boundBytes) .array();
	 }
	 public DimFilter optimize() {
		 return this;
	 }
	 public String getDimension() {
		 return dimension;
	 }
	 public Bound getBound() {
		 return bound;
	 }
	 public Filter toFilter() {
		 return new SpatialFilter(dimension, bound);
	 }
	 public RangeSet<String> getDimensionRangeSet(String dimension) {
		 return null;
	 }
	 public HashSet<String> getRequiredColumns() {
		 return Sets.newHashSet(dimension);
	 }
	 public boolean equals(Object o) {
		 if (this == o) {
			 return true;
		 }
		 if (o == null || getClass() != o.getClass()) {
			 return false;
		 }
		 SpatialDimFilter that = (SpatialDimFilter) o;
		 if (bound != null ? !bound.equals(that.bound) : that.bound != null) {
			 return false;
		 }
		 if (dimension != null ? !dimension.equals(that.dimension) : that.dimension != null) {
			 return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 int result = dimension != null ? dimension.hashCode() : 0;
		 result = 31 * result + (bound != null ? bound.hashCode() : 0);
		 return result;
	 }
	 public String toString() {
		 return ""SpatialDimFilter{
		"" + ""dimension='"" + dimension + '\'' + "", bound="" + bound + '}
		';
	 }
}",0,0,0,0
"public interface AclRule extends ManagedAttributeValue{
	 String getIdentity();
	 ObjectType getObjectType();
	 LegacyOperation getOperation();
	 Map<ObjectProperties.Property,String> getAttributes();
	 RuleOutcome getOutcome();
}",0,1,0,0
"public GrammerException(String msg, Exception e);",0,0,0,0
"protected String getSosCommand() {
	 if (sosCmdDir == null) {
		 return COMMAND_SOS_EXE;
	 }
	 else {
		 return sosCmdDir + File.separator + COMMAND_SOS_EXE;
	 }
 }",0,0,0,0
"public class ForeachCommand extends Command {
	public static String[] foreachArgs = null;
	public ForeachCommand(){
		addCommand(""foreach"", """", ""build up a list of elements to operate on "");
		addCommand(""do"", ""<command>"", ""repeat a command for each element in the list"");
	}
	public void run(String command, final String[] args, final Context context, final PrintStream out) throws DDRInteractiveCommandException {
		if (command.equals(""!do"")) {
			boolean echo = false;
			boolean quiet = false;
			String token = null;
			int commandIndex = 0;
			while (commandIndex < args.length) {
				if (args[commandIndex].equals(""help"")) {
					out.println(""The !do command is used to repeat a command on the elements gathered by the !foreach command."");
					out.println(""Syntax:!do [echo] [quiet] [token=<token>] <cmd> [args]"");
					out.println();
					out.println(""\techo\t\tOutput each command before it is run."");
					out.println(""\tquiet\t\tSuppress delimiters between command outputs."");
					out.println(""\ttoken=<chars>\tSpecify a substitution token. Occurrencs of this string in the args will be replaced by the current element."");
					return;
				}
				 else if (args[commandIndex].equals(""echo"")) {
					echo = true;
					commandIndex += 1;
				}
				 else if (args[commandIndex].equals(""quiet"")) {
					quiet = true;
					commandIndex += 1;
				}
				 else if (args[commandIndex].startsWith(""token="")) {
					token = args[commandIndex].substring(""token="".length());
					commandIndex += 1;
				}
				 else {
					break;
				}
			}
			if (commandIndex >= args.length) {
				out.println(""The do command requires another command to repeat."");
				return;
			}
			if ((null == foreachArgs) || (0 == foreachArgs.length)) {
				out.println(""Element list is empty. Use the foreach command to populate it."");
				return;
			}
			for (int i = 0;
			 i < foreachArgs.length;
			 i++) {
				if (!quiet && (i > 0)) {
					out.println(""========================================"");
				}
				try {
					String[] newArgs;
					if (null == token) {
						newArgs = substituteArgs(args, commandIndex, i);
					}
					 else {
						newArgs = substituteArgs(args, commandIndex, i, token);
					}
					if (echo) {
						System.out.println(""> "" + args[commandIndex] + "" "" + Arrays.toString(newArgs));
					}
					CommandParser commandParser = new CommandParser(args[commandIndex], newArgs);
					context.execute(commandParser, out);
				}
				 catch (ParseException e) {
					e.printStackTrace(out);
				}
				 catch (Throwable th) {
					out.println(""Exception while executing "" + args[commandIndex] + "" "" + foreachArgs[i]);
					th.printStackTrace(out);
				}
			}
		}
		 else if(command.equals(""!foreach"")) {
			if (args.length > 0) {
				out.println(""The !foreach command takes no arguments, but will read lines from the console until it encounters a blank line."");
				out.println(""These lines can then be used as arguments to commands specified using !do."");
				return;
			}
			ArrayList<String> lines = new ArrayList<String>();
			BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
			while (true) {
				String line;
				try {
					line = reader.readLine();
				}
				 catch (IOException e) {
					break;
				}
				if (0 == line.length()) {
					break;
				}
				 else {
					lines.add(line);
				}
			}
			String[] newArgs = new String[lines.size()];
			lines.toArray(newArgs);
			foreachArgs = newArgs;
		}
	}
	private String[] substituteArgs(String[] args, int commandIndex, int foreachIndex) {
		String[] newArgs = new String[args.length - commandIndex];
		System.arraycopy(args, commandIndex + 1, newArgs, 0, args.length - commandIndex - 1);
		newArgs[newArgs.length - 1] = foreachArgs[foreachIndex];
		return newArgs;
	}
	private String[] substituteArgs(String[] args, int commandIndex, int foreachIndex, String token) {
		String[] newArgs = new String[args.length - commandIndex - 1];
		System.arraycopy(args, commandIndex + 1, newArgs, 0, args.length - commandIndex - 1);
		for (int i = 0;
		 i < newArgs.length;
		 i++) {
			newArgs[i] = newArgs[i].replace(token, foreachArgs[foreachIndex]);
		}
		return newArgs;
	}
}",1,0,0,0
"public class CliCompleter extends SimpleCompletor{
	 private static String[] commands = {
	 ""connect"", ""describe keyspace"", ""exit"", ""help"", ""quit"", ""show cluster name"", ""show keyspaces"", ""show api version"", ""create keyspace"", ""create column family"", ""drop keyspace"", ""drop column family"", ""rename keyspace"", ""rename column family"", ""consistencylevel"", ""help connect"", ""help describe keyspace"", ""help exit"", ""help help"", ""help quit"", ""help show cluster name"", ""help show keyspaces"", ""help show api version"", ""help create keyspace"", ""help create column family"", ""help drop keyspace"", ""help drop column family"", ""help rename keyspace"", ""help rename column family"", ""help get"", ""help set"", ""help del"", ""help count"", ""help list"", ""help truncate"", ""help consistencylevel"" }
	;
	 private static String[] keyspaceCommands = {
	 ""get"", ""set"", ""count"", ""del"", ""list"", ""truncate"", ""incr"", ""decr"" }
	;
	 public CliCompleter() {
		 super(commands);
	 }
	 String[] getKeyspaceCommands() {
		 return keyspaceCommands;
	 }
}",0,0,0,0
"public class CustomTHsHaServer extends TNonblockingServer{
	 private static final Logger LOGGER = LoggerFactory.getLogger(CustomTHsHaServer.class.getName());
	 private Set<SelectorThread> ioThreads = new HashSet<SelectorThread>();
	 private volatile boolean stopped_ = true;
	 private ExecutorService invoker;
	 public CustomTHsHaServer(Args args, ExecutorService invoker, int threadCount) {
		 super(args);
		 this.invoker = invoker;
		 for (int i = 0;
		 i < threadCount;
		 ++i) ioThreads.add(new SelectorThread(""Selector-Thread-"" + i));
	 }
	 public void serve() {
		 if (!startListening()) return;
		 if (!startThreads()) return;
		 setServing(true);
		 joinSelector();
		 invoker.shutdown();
		 setServing(false);
		 stopListening();
	 }
	 protected class Invocation implements Runnable {
		 private final FrameBuffer frameBuffer;
		 private SelectorThread thread;
		 public Invocation(final FrameBuffer frameBuffer, SelectorThread thread) {
			 this.frameBuffer = frameBuffer;
			 this.thread = thread;
		 }
		 public void run() {
			 TNonblockingSocket socket = (TNonblockingSocket) frameBuffer.trans_;
			 SocketSessionManagementService.remoteSocket.set(socket.getSocketChannel().socket().getRemoteSocketAddress());
			 frameBuffer.invoke();
			 thread.requestSelectInterestChange(frameBuffer);
		 }
	 }
	 protected boolean startThreads() {
		 stopped_ = false;
		 for (SelectorThread thread : ioThreads) thread.start();
		 return true;
	 }
	 protected void joinSelector() {
		 try {
			 for (SelectorThread thread : ioThreads) thread.join();
		 }
		 catch (InterruptedException e) {
			 LOGGER.error(""Interrupted while joining threads!"", e);
		 }
	 }
	 public void stop() {
		 stopListening();
		 stopped_ = true;
		 for (SelectorThread thread : ioThreads) thread.wakeupSelector();
		 joinSelector();
	 }
	 protected class SelectorThread extends Thread {
		 private final Selector selector;
		 private TNonblockingServerTransport serverTransport;
		 private Set<FrameBuffer> selectInterestChanges = new HashSet<FrameBuffer>();
		 public SelectorThread(String name) {
			 super(name);
			 try {
				 this.selector = SelectorProvider.provider().openSelector();
				 this.serverTransport = (TNonblockingServerTransport) serverTransport_;
				 this.serverTransport.registerSelector(selector);
			 }
			 catch (IOException ex) {
				 throw new RuntimeException(""Couldnt open the NIO selector"", ex);
			 }
		 }
		 public void run() {
			 try {
				 while (!stopped_) {
					 select();
				 }
			 }
			 catch (Throwable t) {
				 LOGGER.error(""Uncaught Exception: "", t);
			 }
		 }
		 private void select() throws InterruptedException, IOException {
			 selector.select();
			 Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
			 while (keyIterator.hasNext()) {
				 SelectionKey key = keyIterator.next();
				 keyIterator.remove();
				 if (!key.isValid()) {
					 cleanupSelectionkey(key);
					 continue;
				 }
				 if (key.isAcceptable()) handleAccept();
				 if (key.isReadable()) handleRead(key);
				 else if (key.isWritable()) handleWrite(key);
				 else LOGGER.debug(""Unexpected state "" + key.interestOps());
			 }
			 processInterestChanges();
		 }
		 private void handleAccept() {
			 SelectionKey clientKey = null;
			 TNonblockingTransport client = null;
			 try {
				 client = (TNonblockingTransport) serverTransport.accept();
				 clientKey = client.registerSelector(selector, SelectionKey.OP_READ);
				 FrameBuffer frameBuffer = new FrameBuffer(client, clientKey);
				 clientKey.attach(frameBuffer);
			 }
			 catch (TTransportException ex) {
				 return;
			 }
			 catch (IOException tte) {
				 LOGGER.warn(""Exception trying to accept!"", tte);
				 tte.printStackTrace();
				 if (clientKey != null) cleanupSelectionkey(clientKey);
				 if (client != null) client.close();
			 }
		 }
		 private void handleRead(SelectionKey key) {
			 FrameBuffer buffer = (FrameBuffer) key.attachment();
			 if (!buffer.read()) {
				 cleanupSelectionkey(key);
				 return;
			 }
			 if (buffer.isFrameFullyRead()) {
				 if (!requestInvoke(buffer, this)) cleanupSelectionkey(key);
			 }
		 }
		 private void handleWrite(SelectionKey key) {
			 FrameBuffer buffer = (FrameBuffer) key.attachment();
			 if (!buffer.write()) cleanupSelectionkey(key);
		 }
		 public void requestSelectInterestChange(FrameBuffer frameBuffer) {
			 synchronized (selectInterestChanges) {
				 selectInterestChanges.add(frameBuffer);
			 }
			 selector.wakeup();
		 }
		 private void processInterestChanges() {
			 synchronized (selectInterestChanges) {
				 for (FrameBuffer fb : selectInterestChanges) fb.changeSelectInterests();
				 selectInterestChanges.clear();
			 }
		 }
		 private void cleanupSelectionkey(SelectionKey key) {
			 FrameBuffer buffer = (FrameBuffer) key.attachment();
			 if (buffer != null) buffer.close();
			 key.cancel();
		 }
		 public void wakeupSelector() {
			 selector.wakeup();
		 }
	 }
	 protected boolean requestInvoke(FrameBuffer frameBuffer, SelectorThread thread) {
		 try {
			 Runnable invocation = new Invocation(frameBuffer, thread);
			 invoker.execute(invocation);
			 return true;
		 }
		 catch (RejectedExecutionException rx) {
			 LOGGER.warn(""ExecutorService rejected execution!"", rx);
			 return false;
		 }
	 }
	 protected void requestSelectInterestChange(FrameBuffer fb) {
	 }
}",0,0,0,0
"public static class GenericConnectionStatusHtmlCreator {
	public static String generateConnectionViewHtml(String providerDisplayName, String providerId, UserProfile profile) {
		String escProviderDisplayName = escape(providerDisplayName);
		StringBuilder builder = new StringBuilder();
		if (profile == null) {
			builder.append(""<h3>Connect to "" + escProviderDisplayName + ""</h3>"");
			builder.append(""<form action=\""/connect/"");
			try {
				String escProviderId = UriUtils.encodePath(providerId, ""UTF-8"");
				builder.append(escProviderId);
			}
			 catch (UnsupportedEncodingException e) {
			 }
			builder.append(""\"" method=\""POST\"">"");
			builder.append(""<div class=\""formInfo\"">"");
			builder.append(""<p>You aren't connected to "");
			builder.append(escProviderDisplayName);
			builder.append("" yet. Click the button to connect with your "");
			builder.append(escProviderDisplayName);
			builder.append("" account.</p>"");
			builder.append(""</div>"");
			builder.append(""<p><button type=\""submit\"">Connect to "");
			builder.append(escProviderDisplayName);
			builder.append(""</button></p>"");
			builder.append(""</form>"");
		}
		 else {
			String escProfileName = escape(profile.getName());
			builder.append(""<h3>Connected to "");
			builder.append(escProviderDisplayName);
			builder.append(""</h3>"");
			builder.append(""<p>Hello, "");
			builder.append(escProfileName);
			builder.append(""!</p><p>You are now connected to "");
			builder.append(escProviderDisplayName);
			String username = profile.getUsername();
			if (username !=null) {
				builder.append("" as "");
				builder.append(escape(username));
			}
			builder.append("".</p>"");
		}
		return builder.toString();
	}
	private static String escape(String in) {
		return htmlEscape(in).replaceAll(""\\{
			"", ""&#123;
		"").replaceAll(""\\}
		"", ""&#125;
		"");
	}
}",1,0,0,0
"private static class drop_wm_pool_resultStandardScheme extends StandardScheme<drop_wm_pool_result> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, drop_wm_pool_result struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 0: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.success = new WMDropPoolResponse();
					 struct.success.read(iprot);
					 struct.setSuccessIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.o1 = new NoSuchObjectException();
					 struct.o1.read(iprot);
					 struct.setO1IsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.o2 = new InvalidOperationException();
					 struct.o2.read(iprot);
					 struct.setO2IsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.o3 = new MetaException();
					 struct.o3.read(iprot);
					 struct.setO3IsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, drop_wm_pool_result struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.success != null) {
			 oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
			 struct.success.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.o1 != null) {
			 oprot.writeFieldBegin(O1_FIELD_DESC);
			 struct.o1.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.o2 != null) {
			 oprot.writeFieldBegin(O2_FIELD_DESC);
			 struct.o2.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.o3 != null) {
			 oprot.writeFieldBegin(O3_FIELD_DESC);
			 struct.o3.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
"public final boolean isError(){
	return isLevel(ERROR);
}",0,0,0,0
"List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner, long additionalFlags) {
	 long flags = FINAL | SYNTHETIC | additionalFlags;
	 List<JCVariableDecl> defs = List.nil();
	 Set<Name> proxyNames = new HashSet<>();
	 for (List<VarSymbol> l = freevars;
	 l.nonEmpty();
	 l = l.tail) {
		 VarSymbol v = l.head;
		 int index = 0;
		 Name proxyName;
		 do {
			 proxyName = proxyName(v.name, index++);
		 }
		 while (!proxyNames.add(proxyName));
		 VarSymbol proxy = new VarSymbol( flags, proxyName, v.erasure(types), owner);
		 proxies.put(v, proxy);
		 JCVariableDecl vd = make.at(pos).VarDef(proxy, null);
		 vd.vartype = access(vd.vartype);
		 defs = defs.prepend(vd);
	 }
	 return defs;
 }",0,0,1,0
"protected final void field() throws RecognitionException, TokenStreamException {
	returnAST = null;
	ASTPair currentAST = new ASTPair();
	JavaAST field_AST = null;
	JavaAST mods_AST = null;
	JavaAST cparams_AST = null;
	JavaAST cthrows_AST = null;
	JavaAST cbody_AST = null;
	JavaAST t_AST = null;
	Token name = null;
	jparse.expr.IdentifierAST name_AST = null;
	JavaAST mparams_AST = null;
	JavaAST d_AST = null;
	JavaAST mthrows_AST = null;
	JavaAST mbody_AST = null;
	JavaAST vars_AST = null;
	try {
		 switch ( LA(1)) {
			case LCURLY:{
				compoundStatement();
				astFactory.addASTChild(currentAST, returnAST);
				if ( inputState.guessing==0 ) {
					field_AST = (JavaAST)currentAST.root;
					field_AST = (JavaAST)astFactory.make( (new ASTArray(2)).add((JavaAST)astFactory.create(INSTANCE_INIT,""INSTANCE_INIT"")).add(field_AST));
					currentAST.root = field_AST;
					currentAST.child = field_AST!=null &&field_AST.getFirstChild()!=null ?field_AST.getFirstChild() : field_AST;
					currentAST.advanceChildToEnd();
				}
				field_AST = (JavaAST)currentAST.root;
				break;
			}
			case SEMI:{
				JavaAST tmp24_AST = null;
				tmp24_AST = (JavaAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp24_AST);
				match(SEMI);
				field_AST = (JavaAST)currentAST.root;
				break;
			}
			default:if ((_tokenSet_9.member(LA(1))) && (_tokenSet_14.member(LA(2)))) {
				modifiers();
				mods_AST = (JavaAST)returnAST;
				{
					switch ( LA(1)) {
						case LITERAL_class:{
							classDefinition((ModifierAST)mods_AST);
							astFactory.addASTChild(currentAST, returnAST);
							break;
						}
						case LITERAL_interface:{
							interfaceDefinition((ModifierAST)mods_AST);
							astFactory.addASTChild(currentAST, returnAST);
							break;
						}
						default:if ((LA(1)==IDENT) && (LA(2)==LPAREN)) {
							if ( inputState.guessing==0 ) {
								JavaAST.currSymTable = new SymbolTable();
							}
							jparse.expr.IdentifierAST tmp25_AST = null;
							tmp25_AST = (jparse.expr.IdentifierAST)astFactory.create(LT(1),""jparse.expr.IdentifierAST"");
							astFactory.addASTChild(currentAST, tmp25_AST);
							match(IDENT);
							JavaAST tmp26_AST = null;
							tmp26_AST = (JavaAST)astFactory.create(LT(1));
							astFactory.addASTChild(currentAST, tmp26_AST);
							match(LPAREN);
							parameterDeclarationList();
							cparams_AST = (JavaAST)returnAST;
							astFactory.addASTChild(currentAST, returnAST);
							JavaAST tmp27_AST = null;
							tmp27_AST = (JavaAST)astFactory.create(LT(1));
							astFactory.addASTChild(currentAST, tmp27_AST);
							match(RPAREN);
							{
								switch ( LA(1)) {
									case LITERAL_throws:{
										throwsClause();
										cthrows_AST = (JavaAST)returnAST;
										astFactory.addASTChild(currentAST, returnAST);
										break;
									}
									case LCURLY:{
										break;
									}
									default:{
										throw new NoViableAltException(LT(1), getFilename());
									}
								}
							}
							compoundStatement();
							cbody_AST = (JavaAST)returnAST;
							astFactory.addASTChild(currentAST, returnAST);
							if ( inputState.guessing==0 ) {
								field_AST = (JavaAST)currentAST.root;
								JavaAST.currSymTable = JavaAST.currSymTable.parent;
								final ConstrAST constr = new ConstrAST((ModifierAST)mods_AST, cparams_AST, cthrows_AST,(CompoundAST)cbody_AST);
								field_AST = (JavaAST)astFactory.make( (new ASTArray(3)).add(constr).add(mods_AST).add(field_AST));
								currentAST.root = field_AST;
								currentAST.child = field_AST!=null &&field_AST.getFirstChild()!=null ?field_AST.getFirstChild() : field_AST;
								currentAST.advanceChildToEnd();
							}
						}
						else if ((_tokenSet_15.member(LA(1))) && (_tokenSet_16.member(LA(2)))) {
							typeSpec();
							t_AST = (JavaAST)returnAST;
							astFactory.addASTChild(currentAST, returnAST);
							{
								if ((LA(1)==IDENT) && (LA(2)==LPAREN)) {
									name = LT(1);
									name_AST = (jparse.expr.IdentifierAST)astFactory.create(name,""jparse.expr.IdentifierAST"");
									astFactory.addASTChild(currentAST, name_AST);
									match(IDENT);
									if ( inputState.guessing==0 ) {
										JavaAST.currSymTable = new SymbolTable();
									}
									JavaAST tmp28_AST = null;
									tmp28_AST = (JavaAST)astFactory.create(LT(1));
									astFactory.addASTChild(currentAST, tmp28_AST);
									match(LPAREN);
									parameterDeclarationList();
									mparams_AST = (JavaAST)returnAST;
									astFactory.addASTChild(currentAST, returnAST);
									JavaAST tmp29_AST = null;
									tmp29_AST = (JavaAST)astFactory.create(LT(1));
									astFactory.addASTChild(currentAST, tmp29_AST);
									match(RPAREN);
									declaratorBrackets();
									d_AST = (JavaAST)returnAST;
									astFactory.addASTChild(currentAST, returnAST);
									{
										switch ( LA(1)) {
											case LITERAL_throws:{
												throwsClause();
												mthrows_AST = (JavaAST)returnAST;
												astFactory.addASTChild(currentAST, returnAST);
												break;
											}
											case SEMI:case LCURLY:{
												break;
											}
											default:{
												throw new NoViableAltException(LT(1), getFilename());
											}
										}
									}
									{
										switch ( LA(1)) {
											case LCURLY:{
												compoundStatement();
												mbody_AST = (JavaAST)returnAST;
												astFactory.addASTChild(currentAST, returnAST);
												break;
											}
											case SEMI:{
												JavaAST tmp30_AST = null;
												tmp30_AST = (JavaAST)astFactory.create(LT(1));
												astFactory.addASTChild(currentAST, tmp30_AST);
												match(SEMI);
												break;
											}
											default:{
												throw new NoViableAltException(LT(1), getFilename());
											}
										}
									}
									if ( inputState.guessing==0 ) {
										field_AST = (JavaAST)currentAST.root;
										JavaAST.currSymTable = JavaAST.currSymTable.parent;
										final ModifierAST mod = (ModifierAST)mods_AST;
										if (jparse.TypeAST.currType.modifiers.isInterface())mod.setInterfaceMethod();
										final MethAST meth =new MethAST(mod, (jparse.expr.TypeAST)t_AST, name_AST,mparams_AST, d_AST, mthrows_AST, (CompoundAST)mbody_AST);
										field_AST = (JavaAST)astFactory.make( (new ASTArray(3)).add(meth).add(mod).add(field_AST));
										currentAST.root = field_AST;
										currentAST.child = field_AST!=null &&field_AST.getFirstChild()!=null ?field_AST.getFirstChild() : field_AST;
										currentAST.advanceChildToEnd();
									}
								}
								else if ((LA(1)==IDENT) && (_tokenSet_17.member(LA(2)))) {
									variableDefinitions();
									vars_AST = (JavaAST)returnAST;
									astFactory.addASTChild(currentAST, returnAST);
									JavaAST tmp31_AST = null;
									tmp31_AST = (JavaAST)astFactory.create(LT(1));
									astFactory.addASTChild(currentAST, tmp31_AST);
									match(SEMI);
									if ( inputState.guessing==0 ) {
										field_AST = (JavaAST)currentAST.root;
										final DeclarationAST decl =new DeclarationAST((ModifierAST)mods_AST, (jparse.expr.TypeAST)t_AST, vars_AST);
										field_AST = (JavaAST)astFactory.make( (new ASTArray(3)).add(decl).add(mods_AST).add(field_AST));
										currentAST.root = field_AST;
										currentAST.child = field_AST!=null &&field_AST.getFirstChild()!=null ?field_AST.getFirstChild() : field_AST;
										currentAST.advanceChildToEnd();
									}
								}
								else {
									throw new NoViableAltException(LT(1), getFilename());
								}
							}
						}
						else {
							throw new NoViableAltException(LT(1), getFilename());
						}
					}
				}
				field_AST = (JavaAST)currentAST.root;
			}
			else if ((LA(1)==LITERAL_static) && (LA(2)==LCURLY)) {
				JavaAST tmp32_AST = null;
				tmp32_AST = (JavaAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp32_AST);
				match(LITERAL_static);
				compoundStatement();
				astFactory.addASTChild(currentAST, returnAST);
				field_AST = (JavaAST)currentAST.root;
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
		}
	}
	catch (RecognitionException ex) {
		if (inputState.guessing==0) {
			reportError(ex);
			consume();
			consumeUntil(_tokenSet_18);
		}
		 else {
			 throw ex;
		}
	}
	returnAST = field_AST;
}",0,0,1,0
"public class LibraryBreadcrumbNodeProvider extendsDesignerBreadcrumbNodeProvider{
	public boolean validate( Object element ){
		if ( getEditPart( element ) == null)return false;
		return true;
	}
	public EditPart getEditPart( Object element ){
		return super.getEditPart( element );
	}
	public Object[] getChildren( Object element ){
		if ( getRealModel( element ) instanceof LibraryHandle ){
			return ( (LibraryHandle) getRealModel( element ) ).getComponents( ).getContents( ).toArray( );
		}
		List children = new ArrayList( );
		children.addAll( Arrays.asList( super.getChildren( element ) ) );
		for ( int i = 0;
		 i < children.size( );
		 i++ ){
			if ( children.get( i ) instanceof EmptyEditPart ){
				children.remove( i );
				i--;
			}
		}
		return children.toArray( );
	}
	public String getText( Object element ){
		Object object = getRealModel( element );
		if ( getEditPart( object ) == null ){
			if ( object instanceof DesignElementHandle&& ( (DesignElementHandle) object ).getContainer( ) instanceof LibraryHandle ){
				INodeProvider provider = ProviderFactory.createProvider( object );
				if ( provider == null )return object.toString( );
				return provider.getNodeDisplayName( object );
			}
		}
		return super.getText( element );
	}
	public Image getImage( Object element ){
		Object object = getRealModel( element );
		if ( getEditPart( object ) == null ){
			if ( object instanceof DesignElementHandle&& ( (DesignElementHandle) object ).getContainer( ) instanceof LibraryHandle ){
				INodeProvider provider = ProviderFactory.createProvider( object );
				if ( provider == null )return null;
				return provider.getNodeIcon( object );
			}
		}
		return super.getImage( element );
	}
	public String getTooltipText( Object element ){
		Object object = getRealModel( element );
		if ( getEditPart( object ) == null ){
			if ( object instanceof DesignElementHandle&& ( (DesignElementHandle) object ).getContainer( ) instanceof LibraryHandle ){
				INodeProvider provider = ProviderFactory.createProvider( object );
				if ( provider == null )return object.toString( );
				return provider.getNodeTooltip( object );
			}
		}
		return super.getTooltipText( element );
	}
}",1,0,0,0
""")public class MultiGetBuildSlaveLogDirResponse implements org.apache.thrift.TBase<MultiGetBuildSlaveLogDirResponse, MultiGetBuildSlaveLogDirResponse._Fields>, java.io.Serializable, Cloneable, Comparable<MultiGetBuildSlaveLogDirResponse> {
	 private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(""MultiGetBuildSlaveLogDirResponse"");
	 private static final org.apache.thrift.protocol.TField LOG_DIRS_FIELD_DESC = new org.apache.thrift.protocol.TField(""logDirs"", org.apache.thrift.protocol.TType.LIST, (short)1);
	 private static final org.apache.thrift.scheme.SchemeFactory STANDARD_SCHEME_FACTORY = new MultiGetBuildSlaveLogDirResponseStandardSchemeFactory();
	 private static final org.apache.thrift.scheme.SchemeFactory TUPLE_SCHEME_FACTORY = new MultiGetBuildSlaveLogDirResponseTupleSchemeFactory();
	 public java.util.List<LogDir> logDirs;
	 public enum _Fields implements org.apache.thrift.TFieldIdEnum {
		 LOG_DIRS((short)1, ""logDirs"");
		 private static final java.util.Map<java.lang.String, _Fields> byName = new java.util.HashMap<java.lang.String, _Fields>();
		 static {
			 for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {
				 byName.put(field.getFieldName(), field);
			 }
		 }
		 public static _Fields findByThriftId(int fieldId) {
			 switch(fieldId) {
				 case 1: return LOG_DIRS;
				 default: return null;
			 }
		 }
		 public static _Fields findByThriftIdOrThrow(int fieldId) {
			 _Fields fields = findByThriftId(fieldId);
			 if (fields == null) throw new java.lang.IllegalArgumentException(""Field "" + fieldId + "" doesn't exist!"");
			 return fields;
		 }
		 public static _Fields findByName(java.lang.String name) {
			 return byName.get(name);
		 }
		 private final short _thriftId;
		 private final java.lang.String _fieldName;
		 _Fields(short thriftId, java.lang.String fieldName) {
			 _thriftId = thriftId;
			 _fieldName = fieldName;
		 }
		 public short getThriftFieldId() {
			 return _thriftId;
		 }
		 public java.lang.String getFieldName() {
			 return _fieldName;
		 }
	 }
	 private static final _Fields optionals[] = {
	_Fields.LOG_DIRS}
	;
	 public static final java.util.Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
	 static {
		 java.util.Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new java.util.EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
		 tmpMap.put(_Fields.LOG_DIRS, new org.apache.thrift.meta_data.FieldMetaData(""logDirs"", org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, LogDir.class))));
		 metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);
		 org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(MultiGetBuildSlaveLogDirResponse.class, metaDataMap);
	 }
	 public MultiGetBuildSlaveLogDirResponse() {
	 }
	 public MultiGetBuildSlaveLogDirResponse(MultiGetBuildSlaveLogDirResponse other) {
		 if (other.isSetLogDirs()) {
			 java.util.List<LogDir> __this__logDirs = new java.util.ArrayList<LogDir>(other.logDirs.size());
			 for (LogDir other_element : other.logDirs) {
				 __this__logDirs.add(new LogDir(other_element));
			 }
			 this.logDirs = __this__logDirs;
		 }
	 }
	 public MultiGetBuildSlaveLogDirResponse deepCopy() {
		 return new MultiGetBuildSlaveLogDirResponse(this);
	 }
	 public void clear() {
		 this.logDirs = null;
	 }
	 public int getLogDirsSize() {
		 return (this.logDirs == null) ? 0 : this.logDirs.size();
	 }
	 public java.util.Iterator<LogDir> getLogDirsIterator() {
		 return (this.logDirs == null) ? null : this.logDirs.iterator();
	 }
	 public void addToLogDirs(LogDir elem) {
		 if (this.logDirs == null) {
			 this.logDirs = new java.util.ArrayList<LogDir>();
		 }
		 this.logDirs.add(elem);
	 }
	 public java.util.List<LogDir> getLogDirs() {
		 return this.logDirs;
	 }
	 public MultiGetBuildSlaveLogDirResponse setLogDirs(java.util.List<LogDir> logDirs) {
		 this.logDirs = logDirs;
		 return this;
	 }
	 public void unsetLogDirs() {
		 this.logDirs = null;
	 }
	 public boolean isSetLogDirs() {
		 return this.logDirs != null;
	 }
	 public void setLogDirsIsSet(boolean value) {
		 if (!value) {
			 this.logDirs = null;
		 }
	 }
	 public void setFieldValue(_Fields field, java.lang.Object value) {
		 switch (field) {
			 case LOG_DIRS: if (value == null) {
				 unsetLogDirs();
			 }
			 else {
				 setLogDirs((java.util.List<LogDir>)value);
			 }
			 break;
		 }
	 }
	 public java.lang.Object getFieldValue(_Fields field) {
		 switch (field) {
			 case LOG_DIRS: return getLogDirs();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean isSet(_Fields field) {
		 if (field == null) {
			 throw new java.lang.IllegalArgumentException();
		 }
		 switch (field) {
			 case LOG_DIRS: return isSetLogDirs();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean equals(java.lang.Object that) {
		 if (that == null) return false;
		 if (that instanceof MultiGetBuildSlaveLogDirResponse) return this.equals((MultiGetBuildSlaveLogDirResponse)that);
		 return false;
	 }
	 public boolean equals(MultiGetBuildSlaveLogDirResponse that) {
		 if (that == null) return false;
		 if (this == that) return true;
		 boolean this_present_logDirs = true && this.isSetLogDirs();
		 boolean that_present_logDirs = true && that.isSetLogDirs();
		 if (this_present_logDirs || that_present_logDirs) {
			 if (!(this_present_logDirs && that_present_logDirs)) return false;
			 if (!this.logDirs.equals(that.logDirs)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 int hashCode = 1;
		 hashCode = hashCode * 8191 + ((isSetLogDirs()) ? 131071 : 524287);
		 if (isSetLogDirs()) hashCode = hashCode * 8191 + logDirs.hashCode();
		 return hashCode;
	 }
	 public int compareTo(MultiGetBuildSlaveLogDirResponse other) {
		 if (!getClass().equals(other.getClass())) {
			 return getClass().getName().compareTo(other.getClass().getName());
		 }
		 int lastComparison = 0;
		 lastComparison = java.lang.Boolean.valueOf(isSetLogDirs()).compareTo(other.isSetLogDirs());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetLogDirs()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.logDirs, other.logDirs);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 return 0;
	 }
	 public _Fields fieldForId(int fieldId) {
		 return _Fields.findByThriftId(fieldId);
	 }
	 public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
		 scheme(iprot).read(iprot, this);
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
		 scheme(oprot).write(oprot, this);
	 }
	 public java.lang.String toString() {
		 java.lang.StringBuilder sb = new java.lang.StringBuilder(""MultiGetBuildSlaveLogDirResponse("");
		 boolean first = true;
		 if (isSetLogDirs()) {
			 sb.append(""logDirs:"");
			 if (this.logDirs == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.logDirs);
			 }
			 first = false;
		 }
		 sb.append("")"");
		 return sb.toString();
	 }
	 public void validate() throws org.apache.thrift.TException {
	 }
	 private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		 try {
			 write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {
		 try {
			 read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private static class MultiGetBuildSlaveLogDirResponseStandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
		 public MultiGetBuildSlaveLogDirResponseStandardScheme getScheme() {
			 return new MultiGetBuildSlaveLogDirResponseStandardScheme();
		 }
	 }
	 private static class MultiGetBuildSlaveLogDirResponseStandardScheme extends org.apache.thrift.scheme.StandardScheme<MultiGetBuildSlaveLogDirResponse> {
		 public void read(org.apache.thrift.protocol.TProtocol iprot, MultiGetBuildSlaveLogDirResponse struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TField schemeField;
			 iprot.readStructBegin();
			 while (true) {
				 schemeField = iprot.readFieldBegin();
				 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
					 break;
				 }
				 switch (schemeField.id) {
					 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
						 {
							 org.apache.thrift.protocol.TList _list120 = iprot.readListBegin();
							 struct.logDirs = new java.util.ArrayList<LogDir>(_list120.size);
							 LogDir _elem121;
							 for (int _i122 = 0;
							 _i122 < _list120.size;
							 ++_i122) {
								 _elem121 = new LogDir();
								 _elem121.read(iprot);
								 struct.logDirs.add(_elem121);
							 }
							 iprot.readListEnd();
						 }
						 struct.setLogDirsIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 iprot.readFieldEnd();
			 }
			 iprot.readStructEnd();
			 struct.validate();
		 }
		 public void write(org.apache.thrift.protocol.TProtocol oprot, MultiGetBuildSlaveLogDirResponse struct) throws org.apache.thrift.TException {
			 struct.validate();
			 oprot.writeStructBegin(STRUCT_DESC);
			 if (struct.logDirs != null) {
				 if (struct.isSetLogDirs()) {
					 oprot.writeFieldBegin(LOG_DIRS_FIELD_DESC);
					 {
						 oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.logDirs.size()));
						 for (LogDir _iter123 : struct.logDirs) {
							 _iter123.write(oprot);
						 }
						 oprot.writeListEnd();
					 }
					 oprot.writeFieldEnd();
				 }
			 }
			 oprot.writeFieldStop();
			 oprot.writeStructEnd();
		 }
	 }
	 private static class MultiGetBuildSlaveLogDirResponseTupleSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
		 public MultiGetBuildSlaveLogDirResponseTupleScheme getScheme() {
			 return new MultiGetBuildSlaveLogDirResponseTupleScheme();
		 }
	 }
	 private static class MultiGetBuildSlaveLogDirResponseTupleScheme extends org.apache.thrift.scheme.TupleScheme<MultiGetBuildSlaveLogDirResponse> {
		 public void write(org.apache.thrift.protocol.TProtocol prot, MultiGetBuildSlaveLogDirResponse struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
			 java.util.BitSet optionals = new java.util.BitSet();
			 if (struct.isSetLogDirs()) {
				 optionals.set(0);
			 }
			 oprot.writeBitSet(optionals, 1);
			 if (struct.isSetLogDirs()) {
				 {
					 oprot.writeI32(struct.logDirs.size());
					 for (LogDir _iter124 : struct.logDirs) {
						 _iter124.write(oprot);
					 }
				 }
			 }
		 }
		 public void read(org.apache.thrift.protocol.TProtocol prot, MultiGetBuildSlaveLogDirResponse struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
			 java.util.BitSet incoming = iprot.readBitSet(1);
			 if (incoming.get(0)) {
				 {
					 org.apache.thrift.protocol.TList _list125 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
					 struct.logDirs = new java.util.ArrayList<LogDir>(_list125.size);
					 LogDir _elem126;
					 for (int _i127 = 0;
					 _i127 < _list125.size;
					 ++_i127) {
						 _elem126 = new LogDir();
						 _elem126.read(iprot);
						 struct.logDirs.add(_elem126);
					 }
				 }
				 struct.setLogDirsIsSet(true);
			 }
		 }
	 }
	 private static <S extends org.apache.thrift.scheme.IScheme> S scheme(org.apache.thrift.protocol.TProtocol proto) {
		 return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();
	 }
}",1,0,0,0
"public static class Builder {
	 private File path;
	 private String interval;
	 private boolean incremental;
	 private File out;
	 private String filter;
	 private boolean ignoreMissingSegments;
	 private Builder() {
	 }
	 public Builder withPath(File path) {
		 this.path = checkNotNull(path);
		 return this;
	 }
	 public Builder withInterval(String interval) {
		 this.interval = checkNotNull(interval);
		 return this;
	 }
	 public Builder withIncremental(boolean incremental) {
		 this.incremental = incremental;
		 return this;
	 }
	 public Builder withOutput(File file) {
		 this.out = checkNotNull(file);
		 return this;
	 }
	 public Builder withFilter(String filter) {
		 this.filter = checkNotNull(filter);
		 return this;
	 }
	 public Builder withIgnoreMissingSegments(boolean ignoreMissingSegments) {
		 this.ignoreMissingSegments = ignoreMissingSegments;
		 return this;
	 }
	 public Diff build() {
		 checkNotNull(path);
		 checkNotNull(interval);
		 checkNotNull(out);
		 checkNotNull(filter);
		 return new Diff(this);
	 }
 }",0,1,0,0
"final class CellRenderer extends DefaultTableCellRenderer {
	 public Component getTableCellRendererComponent( JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
		 super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
		 ObjAttributeTableModel model = (ObjAttributeTableModel) table.getModel();
		 column = table.getColumnModel().getColumn(column).getModelIndex();
		 ObjAttribute attribute = model.getAttribute(row).getValue();
		 if (!model.isCellEditable(row, column)) {
			 setForeground(isSelected ? new Color(0xEEEEEE) : Color.GRAY);
		 }
		 else {
			 setForeground(isSelected && !hasFocus ? table.getSelectionForeground() : table.getForeground());
		 }
		 setIcon(null);
		 if (attribute.isInherited()) {
			 Font font = getFont();
			 Font newFont = font.deriveFont(Font.ITALIC);
			 setFont(newFont);
			 if(column == ObjAttributeTableModel.OBJ_ATTRIBUTE) {
				 setIcon(INHERITANCE_ICON);
			 }
		 }
		 setFont(UIManager.getFont(""Label.font""));
		 setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
		 return this;
	 }
	 public void mouseClicked(MouseEvent event, int x) {
		 Point point = event.getPoint();
		 if(point.x - x <= INHERITANCE_ICON.getIconWidth()) {
			 ActionManager actionManager = Application.getInstance().getActionManager();
			 actionManager.getAction(ObjEntityToSuperEntityAction.class).performAction(null);
		 }
	 }
 }",0,0,0,0
"public class User{
}",0,0,0,0
"static List<Period> generateSchedule(Calendar startDate,Tenor maturity, Frequency frequency, StubType stubType, int maxPeriods);",0,0,0,1
"public Mesh transform(Mesh obj) {
	 if (previous != null) obj = previous.transform(obj);
	 Mesh newmesh = (Mesh) obj.duplicate();
	 MeshVertex[] vert = newmesh.getVertices();
	 Vec3 newvert[] = new Vec3 [vert.length];
	 Vec3 origin = new Vec3();
	 for (int i = 0;
	 i < newvert.length;
	 i++) {
		 newvert[i] = vert[i].r;
		 if (preTransform != null) preTransform.transform(newvert[i]);
	 }
	 if (preTransform != null) preTransform.transform(origin);
	 double min = Double.MAX_VALUE, max = Double.MIN_VALUE;
	 for (int i = 0;
	 i < newvert.length;
	 i++) {
		 double value;
		 if (axis == X_AXIS) value = newvert[i].x;
		 else if (axis == Y_AXIS) value = newvert[i].y;
		 else value = newvert[i].z;
		 if (value < min) min = value;
		 if (value > max) max = value;
	 }
	 if (min >= max) return obj;
	 if (!forward) {
		 double temp = min;
		 min = max;
		 max = temp;
	 }
	 double theta = angle*(Math.PI/180.0);
	 double scale = theta/(max-min);
	 double radius = (max-min)/theta;
	 Vec3 center;
	 if (axis == X_AXIS) {
		 if (direction == Y_AXIS) for (int i = 0;
		 i < newvert.length;
		 i++) {
			 double a = scale*(newvert[i].x-min);
			 double b = newvert[i].y-origin.y-radius;
			 newvert[i].set(min-Math.sin(a)*b, origin.y+radius+Math.cos(a)*b, newvert[i].z);
		 }
		 else for (int i = 0;
		 i < newvert.length;
		 i++) {
			 double a = scale*(newvert[i].x-min);
			 double b = newvert[i].z-origin.z-radius;
			 newvert[i].set(min-Math.sin(a)*b, newvert[i].y, origin.z+radius+Math.cos(a)*b);
		 }
	 }
	 else if (axis == Y_AXIS) {
		 if (direction == X_AXIS) for (int i = 0;
		 i < newvert.length;
		 i++) {
			 double a = scale*(newvert[i].y-min);
			 double b = newvert[i].x-origin.x-radius;
			 newvert[i].set(origin.x+radius+Math.cos(a)*b, min-Math.sin(a)*b, newvert[i].z);
		 }
		 else for (int i = 0;
		 i < newvert.length;
		 i++) {
			 double a = scale*(newvert[i].y-min);
			 double b = newvert[i].z-origin.z-radius;
			 newvert[i].set(newvert[i].x, min-Math.sin(a)*b, origin.z+radius+Math.cos(a)*b);
		 }
	 }
	 else {
		 if (direction == X_AXIS) for (int i = 0;
		 i < newvert.length;
		 i++) {
			 double a = scale*(newvert[i].z-min);
			 double b = newvert[i].x-origin.x-radius;
			 newvert[i].set(origin.x+radius+Math.cos(a)*b, newvert[i].y, min-Math.sin(a)*b);
		 }
		 else for (int i = 0;
		 i < newvert.length;
		 i++) {
			 double a = scale*(newvert[i].z-min);
			 double b = newvert[i].y-origin.y-radius;
			 newvert[i].set(newvert[i].x, origin.y+radius+Math.cos(a)*b, min-Math.sin(a)*b);
		 }
	 }
	 if (postTransform != null) for (int i = 0;
	 i < newvert.length;
	 i++) postTransform.transform(newvert[i]);
	 newmesh.setVertexPositions(newvert);
	 return newmesh;
 }",0,0,1,0
"private void start(String props, InetAddress bind_addr, int port, int min_threads, int max_threads, long rpc_timeout, long caching_time, boolean migrate_data, boolean use_l1_cache, int l1_max_entries, long l1_reaping_interval, int l2_max_entries, long l2_reaping_interval) throws Exception;",0,0,0,1
"private void spinThreads() throws BuildException {
	 final int numTasks = nestedTasks.size();
	 TaskRunnable[] runnables = new TaskRunnable[numTasks];
	 stillRunning = true;
	 timedOut = false;
	 int threadNumber = 0;
	 for (Enumeration e = nestedTasks.elements();
	 e.hasMoreElements();
	 threadNumber++) {
		 Task nestedTask = (Task) e.nextElement();
		 runnables[threadNumber] = new TaskRunnable(nestedTask);
	 }
	 final int maxRunning = numTasks < numThreads ? numTasks : numThreads;
	 TaskRunnable[] running = new TaskRunnable[maxRunning];
	 threadNumber = 0;
	 ThreadGroup group = new ThreadGroup(""parallel"");
	 TaskRunnable[] daemons = null;
	 if (daemonTasks != null && daemonTasks.tasks.size() != 0) {
		 daemons = new TaskRunnable[daemonTasks.tasks.size()];
	 }
	 synchronized (semaphore) {
	 }
	 synchronized (semaphore) {
		 if (daemons != null) {
			 for (int i = 0;
			 i < daemons.length;
			 ++i) {
				 daemons[i] = new TaskRunnable((Task) daemonTasks.tasks.get(i));
				 Thread daemonThread = new Thread(group, daemons[i]);
				 daemonThread.setDaemon(true);
				 daemonThread.start();
			 }
		 }
		 for (int i = 0;
		 i < maxRunning;
		 ++i) {
			 running[i] = runnables[threadNumber++];
			 Thread thread = new Thread(group, running[i]);
			 thread.start();
		 }
		 if (timeout != 0) {
			 Thread timeoutThread = new Thread() {
				 public synchronized void run() {
					 try {
						 wait(timeout);
						 synchronized (semaphore) {
							 stillRunning = false;
							 timedOut = true;
							 semaphore.notifyAll();
						 }
					 }
					 catch (InterruptedException e) {
					 }
				 }
			 }
			;
			 timeoutThread.start();
		 }
		 outer: while (threadNumber < numTasks && stillRunning) {
			 for (int i = 0;
			 i < maxRunning;
			 i++) {
				 if (running[i] == null || running[i].isFinished()) {
					 running[i] = runnables[threadNumber++];
					 Thread thread = new Thread(group, running[i]);
					 thread.start();
					 continue outer;
				 }
			 }
			 try {
				 semaphore.wait();
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 outer2: while (stillRunning) {
			 for (int i = 0;
			 i < maxRunning;
			 ++i) {
				 if (running[i] != null && !running[i].isFinished()) {
					 try {
						 semaphore.wait();
					 }
					 catch (InterruptedException ie) {
					 }
					 continue outer2;
				 }
			 }
			 stillRunning = false;
		 }
	 }
	 if (timedOut) {
		 throw new BuildException(""Parallel execution timed out"");
	 }
	 exceptionMessage = new StringBuffer();
	 numExceptions = 0;
	 firstException = null;
	 firstLocation = Location.UNKNOWN_LOCATION;
	 processExceptions(daemons);
	 processExceptions(runnables);
	 if (numExceptions == 1) {
		 if (firstException instanceof BuildException) {
			 throw (BuildException) firstException;
		 }
		 else {
			 throw new BuildException(firstException);
		 }
	 }
	 else if (numExceptions > 1) {
		 throw new BuildException(exceptionMessage.toString(), firstLocation);
	 }
 }",0,0,1,0
"public class GrpcXceiverService extends XceiverClientProtocolServiceGrpc.XceiverClientProtocolServiceImplBase {
	 public static final Logger LOG = LoggerFactory.getLogger(GrpcXceiverService.class);
	 private final ContainerDispatcher dispatcher;
	 private final boolean isGrpcTokenEnabled;
	 private final TokenVerifier tokenVerifier;
	 public GrpcXceiverService(ContainerDispatcher dispatcher) {
		 this(dispatcher, false, null);
	 }
	 public GrpcXceiverService(ContainerDispatcher dispatcher, boolean grpcTokenEnabled, TokenVerifier tokenVerifier) {
		 this.dispatcher = dispatcher;
		 this.isGrpcTokenEnabled = grpcTokenEnabled;
		 this.tokenVerifier = tokenVerifier;
	 }
	 public StreamObserver<ContainerCommandRequestProto> send( StreamObserver<ContainerCommandResponseProto> responseObserver) {
		 return new StreamObserver<ContainerCommandRequestProto>() {
			 private final AtomicBoolean isClosed = new AtomicBoolean(false);
			 public void onNext(ContainerCommandRequestProto request) {
				 try {
					 if(isGrpcTokenEnabled) {
						 tokenVerifier.verify(UserGroupInformation.getCurrentUser() .getShortUserName(), request.getEncodedToken());
					 }
					 ContainerCommandResponseProto resp = dispatcher.dispatch(request, null);
					 responseObserver.onNext(resp);
				 }
				 catch (Throwable e) {
					 LOG.error(""{
					}
					 got exception when processing"" + "" ContainerCommandRequestProto {
					}
					: {
					}
					"", request, e);
					 responseObserver.onError(e);
				 }
			 }
			 public void onError(Throwable t) {
				 LOG.error(""{
				}
				: ContainerCommand send on error. Exception: {
				}
				"", t);
			 }
			 public void onCompleted() {
				 if (isClosed.compareAndSet(false, true)) {
					 LOG.debug(""{
					}
					: ContainerCommand send completed"");
					 responseObserver.onCompleted();
				 }
			 }
		 }
		;
	 }
}",1,0,0,0
"public class LivePropertySource {
	private final List<LiveProperty> properties;
	private final String sourceName;
	public LivePropertySource(String sourceName, List<LiveProperty> properties) {
		this.sourceName = sourceName;
		this.properties = properties != null ? ImmutableList.copyOf(properties) : ImmutableList.of();
	}
	public String getSourceName() {
		return this.sourceName;
	}
	public LiveProperty getProperty(String propertyName) {
		for (LiveProperty liveProperty : properties) {
			if (liveProperty.getProperty().equals(propertyName)) {
				return liveProperty;
			}
		}
		return null;
	}
}",0,1,0,0
"public synchronized Task pollForNewTask(String taskTracker) {
	 int avgMaps = 0;
	 int avgReduces = 0;
	 int numTaskTrackers;
	 TaskTrackerStatus tts;
	 synchronized (taskTrackers) {
		 numTaskTrackers = taskTrackers.size();
		 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
	 }
	 if (numTaskTrackers > 0) {
		 avgMaps = totalMaps / numTaskTrackers;
		 avgReduces = totalReduces / numTaskTrackers;
	 }
	 int totalCapacity = numTaskTrackers * maxCurrentTasks;
	 if (tts == null) {
		 LOG.warning(""Unknown task tracker polling;
		 ignoring: "" + taskTracker);
		 return null;
	 }
	 int numMaps = tts.countMapTasks();
	 int numReduces = tts.countReduceTasks();
	 synchronized (jobsByArrival) {
		 if ((numMaps < maxCurrentTasks) && (numMaps <= (avgMaps + TASK_ALLOC_EPSILON))) {
			 int totalNeededMaps = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewMapTask(taskTracker, tts);
				 if (t != null) {
					 return t;
				 }
				 totalNeededMaps += job.desiredMaps();
				 double padding = 0;
				 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, totalNeededMaps * PAD_FRACTION);
				 }
				 if (totalNeededMaps + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
		 if ((numReduces < maxCurrentTasks) && (numReduces <= (avgReduces + TASK_ALLOC_EPSILON))) {
			 int totalNeededReduces = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewReduceTask(taskTracker, tts);
				 if (t != null) {
					 return t;
				 }
				 totalNeededReduces += job.desiredReduces();
				 double padding = 0;
				 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, totalNeededReduces * PAD_FRACTION);
				 }
				 if (totalNeededReduces + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public int run( String argv[] ) throws Exception {
	 if (argv.length < 1) {
		 printUsage("""");
		 return -1;
	 }
	 int exitCode = -1;
	 int i = 0;
	 String cmd = argv[i++];
	 if (""-put"".equals(cmd) || ""-get"".equals(cmd) || ""-copyFromLocal"".equals(cmd) || ""-moveFromLocal"".equals(cmd) || ""-copyToLocal"".equals(cmd) || ""-moveToLocal"".equals(cmd)) {
		 if (argv.length != 3) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 else if (""-safemode"".equals(cmd)) {
		 if (argv.length != 2) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 else if ( ""-report"".equals(cmd)) {
		 if (argv.length != 1) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 else if (""-mv"".equals(cmd) || ""-cp"".equals(cmd)) {
		 if (argv.length < 3) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 else if (""-rm"".equals(cmd) || ""-rmr"".equals(cmd) || ""-cat"".equals(cmd) || ""-mkdir"".equals(cmd)) {
		 if (argv.length < 2) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 try {
		 init();
	 }
	 catch (RPC.VersionMismatch v) {
		 System.err.println(""Version Mismatch between client and server"" + ""... command aborted."");
		 return exitCode;
	 }
	 catch (IOException e) {
		 System.err.println(""Bad connection to DFS... command aborted."");
		 return exitCode;
	 }
	 exitCode = 0;
	 try {
		 if (""-put"".equals(cmd) || ""-copyFromLocal"".equals(cmd)) {
			 copyFromLocal(new Path(argv[i++]), argv[i++]);
		 }
		 else if (""-moveFromLocal"".equals(cmd)) {
			 moveFromLocal(new Path(argv[i++]), argv[i++]);
		 }
		 else if (""-get"".equals(cmd) || ""-copyToLocal"".equals(cmd)) {
			 copyToLocal(argv[i++], argv[i++]);
		 }
		 else if (""-getmerge"".equals(cmd)) {
			 if(argv.length>i+2) copyMergeToLocal(argv[i++], new Path(argv[i++]), Boolean.parseBoolean(argv[i++]));
			 else copyMergeToLocal(argv[i++], new Path(argv[i++]));
		 }
		 else if (""-cat"".equals(cmd)) {
			 doall(cmd, argv, conf, i);
		 }
		 else if (""-moveToLocal"".equals(cmd)) {
			 moveToLocal(argv[i++], new Path(argv[i++]));
		 }
		 else if (""-setrep"".equals(cmd)) {
			 setReplication(argv, i);
		 }
		 else if (""-ls"".equals(cmd)) {
			 if (i < argv.length) {
				 doall(cmd, argv, conf, i);
			 }
			 else {
				 ls("""", false);
			 }
		 }
		 else if (""-lsr"".equals(cmd)) {
			 if (i < argv.length) {
				 doall(cmd, argv, conf, i);
			 }
			 else {
				 ls("""", true);
			 }
		 }
		 else if (""-mv"".equals(cmd)) {
			 exitCode = rename(argv, conf);
		 }
		 else if (""-cp"".equals(cmd)) {
			 exitCode = copy(argv, conf);
		 }
		 else if (""-rm"".equals(cmd)) {
			 doall(cmd, argv, conf, i);
		 }
		 else if (""-rmr"".equals(cmd)) {
			 doall(cmd, argv, conf, i);
		 }
		 else if (""-du"".equals(cmd)) {
			 if (i < argv.length) {
				 doall(cmd, argv, conf, i);
			 }
			 else {
				 du("""");
			 }
		 }
		 else if (""-mkdir"".equals(cmd)) {
			 doall(cmd, argv, conf, i);
		 }
		 else if (""-report"".equals(cmd)) {
			 report();
		 }
		 else if (""-safemode"".equals(cmd)) {
			 setSafeMode(argv,i);
		 }
		 else {
			 exitCode = -1;
			 System.err.println(cmd.substring(1) + "": Unknown command"");
			 printUsage("""");
		 }
	 }
	 catch (RemoteException e) {
		 exitCode = -1;
		 try {
			 String[] content;
			 content = e.getLocalizedMessage().split(""\n"");
			 System.err.println(cmd.substring(1) + "": "" + content[0]);
		 }
		 catch (Exception ex) {
			 System.err.println(cmd.substring(1) + "": "" + ex.getLocalizedMessage());
		 }
	 }
	 catch (IOException e ) {
		 exitCode = -1;
		 System.err.println(cmd.substring(1) + "": "" + e.getLocalizedMessage());
	 }
	 finally {
		 fs.close();
	 }
	 return exitCode;
 }",0,0,1,0
"public XDMTableCellRenderer() {
	titleLbl = new JLabel(""This is sample title text"");
	titleLbl.setForeground(Color.BLACK);
	iconLbl = new JLabel();
	iconLbl.setForeground(Color.BLACK);
	statLbl = new JLabel(""This is sample status text"");
	statLbl.setForeground(Color.BLACK);
	dateLbl = new JLabel(""Yesterday"");
	dateLbl.setForeground(Color.BLACK);
	lineLbl = new JLabel();
	iconLbl.setOpaque(false);
	iconLbl.setPreferredSize(new Dimension(56, 56));
	iconLbl.setIcon(ImageResource.get(""doc.png""));
	titleLbl.setBackground(Color.WHITE);
	titleLbl.setFont(FontResource.getItemFont());
	titleLbl.setOpaque(false);
	statLbl.setBackground(Color.WHITE);
	statLbl.setFont(FontResource.getNormalFont());
	statLbl.setOpaque(false);
	dateLbl.setBackground(Color.WHITE);
	dateLbl.setOpaque(false);
	dateLbl.setFont(FontResource.getNormalFont());
	lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getWhite());
	lineLbl.setOpaque(true);
	lineLbl.setMinimumSize(new Dimension(10, 1));
	lineLbl.setMaximumSize(new Dimension(lineLbl.getMaximumSize().width, 1));
	lineLbl.setPreferredSize(new Dimension(lineLbl.getPreferredSize().width, 1));
	pcell = new JPanel(new BorderLayout());
	pcell.setBackground(Color.WHITE);
	pcell.add(iconLbl, BorderLayout.WEST);
	Box box = Box.createHorizontalBox();
	box.add(statLbl);
	box.add(Box.createHorizontalGlue());
	box.add(dateLbl);
	box.setBorder(new EmptyBorder(0, 0, 10, 0));
	JPanel p = new JPanel(new BorderLayout());
	p.setOpaque(false);
	p.add(titleLbl);
	p.add(box, BorderLayout.SOUTH);
	p.setBorder(new EmptyBorder(5, 0, 5, 5));
	pcell.add(p);
	pcell.add(lineLbl, BorderLayout.SOUTH);
	pcell.setBorder(new EmptyBorder(0, 15, 0, 15));
}",0,0,1,0
"public interface NodeMatcher<E extends Operator, P extends OperatorPlan<E>> {
	 Map<OperatorKey, OperatorKey> match(P plan1, P plan2, StringBuilder messages) ;
}",1,0,0,0
"public class ArtifactTransferRequest extends Artifact implements Serializable{
	 private String targetRepositoryId;
	 public String getTargetRepositoryId() {
		 return targetRepositoryId;
	 }
	 public void setTargetRepositoryId( String targetRepositoryId ) {
		 this.targetRepositoryId = targetRepositoryId;
	 }
}",0,1,0,0
"public class DotEdge {
	 public DotNode fromNode;
	 public DotNode toNode;
	 public Map<String, String> attributes = new HashMap<String, String>();
	 public String toString() {
		 StringBuilder sb = new StringBuilder(fromNode.name + "" -> "" + toNode.name);
		 if (attributes.size() > 0) {
			 int index = 0;
			 sb.append("" ["");
			 for (Map.Entry<String, String> attr : attributes.entrySet()) {
				 sb.append(attr.getKey() + ""="" + attr.getValue());
				 if (index < attributes.size() - 1) sb.append("", "");
				 index++;
			 }
			 sb.append(""]"");
		 }
		 return sb.toString();
	 }
	 public boolean equals(Object other) {
		 if (other instanceof DotEdge) {
			 DotEdge edge = (DotEdge) other;
			 return fromNode.equals(edge.fromNode) && toNode.equals(edge.toNode);
		 }
		 return false;
	 }
	 public int hashCode() {
		 return fromNode.hashCode() * toNode.hashCode();
	 }
}",1,0,0,0
"public class OptionSet implements UaStructure {
	 public static final NodeId TypeId = Identifiers.OptionSet;
	 public static final NodeId BinaryEncodingId = Identifiers.OptionSet_Encoding_DefaultBinary;
	 public static final NodeId XmlEncodingId = Identifiers.OptionSet_Encoding_DefaultXml;
	 protected final ByteString value;
	 protected final ByteString validBits;
	 public OptionSet() {
		 this.value = null;
		 this.validBits = null;
	 }
	 public OptionSet(ByteString value, ByteString validBits) {
		 this.value = value;
		 this.validBits = validBits;
	 }
	 public ByteString getValue() {
		 return value;
	 }
	 public ByteString getValidBits() {
		 return validBits;
	 }
	 public NodeId getTypeId() {
		 return TypeId;
	 }
	 public NodeId getBinaryEncodingId() {
		 return BinaryEncodingId;
	 }
	 public NodeId getXmlEncodingId() {
		 return XmlEncodingId;
	 }
	 public String toString() {
		 return MoreObjects.toStringHelper(this) .add(""Value"", value) .add(""ValidBits"", validBits) .toString();
	 }
	 public static class Codec extends BuiltinDataTypeCodec<OptionSet> {
		 public Class<OptionSet> getType() {
			 return OptionSet.class;
		 }
		 public OptionSet decode(UaDecoder decoder) throws UaSerializationException {
			 ByteString value = decoder.readByteString(""Value"");
			 ByteString validBits = decoder.readByteString(""ValidBits"");
			 return new OptionSet(value, validBits);
		 }
		 public void encode(OptionSet value, UaEncoder encoder) throws UaSerializationException {
			 encoder.writeByteString(""Value"", value.value);
			 encoder.writeByteString(""ValidBits"", value.validBits);
		 }
	 }
}",1,1,0,0
"private void showMoveQPopup(JButton btn) {
	int index = qList.getSelectedIndex();
	if (index < 0) {
		return;
	}
	DownloadQueue q = queueModel.get(index);
	String qid = q.getQueueId();
	if (qid == null)return;
	JPopupMenu popupMenu = new JPopupMenu();
	for (int i = 0;
	 i < QueueManager.getInstance().getQueueList().size();
	 i++) {
		DownloadQueue tq = QueueManager.getInstance().getQueueList().get(i);
		if (qid.equals(tq.getQueueId())) {
			continue;
		}
		JMenuItem item = new JMenuItem(tq.getName());
		item.setName(""Q_MOVE_TO:"" + tq.getQueueId());
		item.addActionListener(this);
		item.setForeground(Color.WHITE);
		item.setFont(FontResource.getNormalFont());
		popupMenu.add(item);
	}
	popupMenu.setInvoker(btn);
	popupMenu.show(btn, 0, btn.getHeight());
}",0,0,0,0
"public interface Region<S, E> {
	UUID getUuid();
	String getId();
	void start();
	void stop();
	boolean sendEvent(Message<E> event);
	boolean sendEvent(E event);
	State<S,E> getState();
	Collection<State<S, E>> getStates();
	Collection<Transition<S,E>> getTransitions();
	boolean isComplete();
	void addStateListener(StateMachineListener<S, E> listener);
	void removeStateListener(StateMachineListener<S, E> listener);
}",0,1,0,0
"public static class LaunchCommand extends BrooklynCommandWithSystemDefines {
	 "") public String localBrooklynProperties;
	 public boolean noGlobalBrooklynProperties = false;
	 public String app;
	 public String script = null;
	 "") public String locations;
	 public String catalogInitial;
	 public boolean catalogReset;
	 public String catalogAdd;
	 "") public boolean catalogForce;
	 public String port;
	 public boolean useHttps = false;
	 public boolean noConsole = false;
	 public String bindAddress = null;
	 public String publicAddress = null;
	 "") public Boolean noConsoleSecurity = false;
	 "") public boolean startupContinueOnWebErrors = false;
	 "") public boolean startupFailOnPersistenceErrors = false;
	 "") public boolean startupFailOnCatalogErrors = false;
	 "") public boolean startupFailOnManagedAppsErrors = false;
	 public boolean startBrooklynNode = false;
	 "") public boolean stopOnKeyPress = false;
	 final static String STOP_WHICH_APPS_ON_SHUTDOWN = ""--stopOnShutdown"";
	 protected final static String STOP_ALL = ""all"";
	 protected final static String STOP_ALL_IF_NOT_PERSISTED = ""allIfNotPersisted"";
	 protected final static String STOP_NONE = ""none"";
	 protected final static String STOP_THESE = ""these"";
	 protected final static String STOP_THESE_IF_NOT_PERSISTED = ""theseIfNotPersisted"";
	 static {
		 Enums.checkAllEnumeratedIgnoreCase(StopWhichAppsOnShutdown.class, STOP_ALL, STOP_ALL_IF_NOT_PERSISTED, STOP_NONE, STOP_THESE, STOP_THESE_IF_NOT_PERSISTED);
	 }
	 public String stopWhichAppsOnShutdown = STOP_THESE_IF_NOT_PERSISTED;
	 is running exit the process, leaving any entities running. "" + ""Can be used in combination with --persist auto --persistenceDir <custom folder location> to attach to the running app at a later time."") public boolean exitAndLeaveAppsRunningAfterStarting = false;
	 final static String PERSIST_OPTION = ""--persist"";
	 protected final static String PERSIST_OPTION_DISABLED = ""disabled"";
	 protected final static String PERSIST_OPTION_AUTO = ""auto"";
	 protected final static String PERSIST_OPTION_REBIND = ""rebind"";
	 protected final static String PERSIST_OPTION_CLEAN = ""clean"";
	 static {
		 Enums.checkAllEnumeratedIgnoreCase(PersistMode.class, PERSIST_OPTION_DISABLED, PERSIST_OPTION_AUTO, PERSIST_OPTION_REBIND, PERSIST_OPTION_CLEAN);
	 }
	 "") public String persist = PERSIST_OPTION_DISABLED;
	 "") public String persistenceDir;
	 public String persistenceLocation;
	 final static String HA_OPTION = ""--highAvailability"";
	 protected final static String HA_OPTION_DISABLED = ""disabled"";
	 protected final static String HA_OPTION_AUTO = ""auto"";
	 protected final static String HA_OPTION_MASTER = ""master"";
	 protected final static String HA_OPTION_STANDBY = ""standby"";
	 protected final static String HA_OPTION_HOT_STANDBY = ""hot_standby"";
	 protected final static String HA_OPTION_HOT_BACKUP = ""hot_backup"";
	 static {
		 Enums.checkAllEnumeratedIgnoreCase(HighAvailabilityMode.class, HA_OPTION_AUTO, HA_OPTION_DISABLED, HA_OPTION_MASTER, HA_OPTION_STANDBY, HA_OPTION_HOT_STANDBY, HA_OPTION_HOT_BACKUP);
	 }
	 public String highAvailability = HA_OPTION_AUTO;
	 protected ManagementContext explicitManagementContext;
	 public Void call() throws Exception {
		 super.call();
		 BrooklynLauncher launcher;
		 AppShutdownHandler shutdownHandler = new AppShutdownHandler();
		 failIfArguments();
		 try {
			 if (log.isDebugEnabled()) log.debug(""Invoked launch command {
			}
			"", this);
			 if (!quiet) stdout.println(banner);
			 if (verbose) {
				 if (app != null) {
					 stdout.println(""Launching brooklyn app: "" + app + "" in "" + locations);
				 }
				 else {
					 stdout.println(""Launching brooklyn server (no app)"");
				 }
			 }
			 PersistMode persistMode = computePersistMode();
			 HighAvailabilityMode highAvailabilityMode = computeHighAvailabilityMode(persistMode);
			 StopWhichAppsOnShutdown stopWhichAppsOnShutdownMode = computeStopWhichAppsOnShutdown();
			 computeLocations();
			 ResourceUtils utils = ResourceUtils.create(this);
			 GroovyClassLoader loader = new GroovyClassLoader(getClass().getClassLoader());
			 if (script != null) {
				 execGroovyScript(utils, loader, script);
			 }
			 launcher = createLauncher();
			 CatalogInitialization catInit = new CatalogInitialization(catalogInitial, catalogReset, catalogAdd, catalogForce);
			 catInit.addPopulationCallback(new Function<CatalogInitialization,Void>() {
				 public Void apply(CatalogInitialization catInit) {
					 try {
						 populateCatalog(catInit.getManagementContext().getCatalog());
					 }
					 catch (Throwable e) {
						 catInit.handleException(e, ""overridden main class populate catalog"");
					 }
					 confirmCatalog(catInit);
					 return null;
				 }
			 }
			);
			 catInit.setFailOnStartupErrors(startupFailOnCatalogErrors);
			 launcher.catalogInitialization(catInit);
			 launcher.persistMode(persistMode);
			 launcher.persistenceDir(persistenceDir);
			 launcher.persistenceLocation(persistenceLocation);
			 launcher.highAvailabilityMode(highAvailabilityMode);
			 launcher.stopWhichAppsOnShutdown(stopWhichAppsOnShutdownMode);
			 launcher.shutdownHandler(shutdownHandler);
			 computeAndSetApp(launcher, utils, loader);
			 customize(launcher);
		 }
		 catch (FatalConfigurationRuntimeException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 throw new FatalConfigurationRuntimeException(""Fatal error configuring Brooklyn launch: ""+e.getMessage(), e);
		 }
		 try {
			 launcher.start();
		 }
		 catch (FatalRuntimeException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 Exceptions.propagateIfFatal(e);
			 log.error(""Error launching brooklyn: ""+Exceptions.collapseText(e), e);
			 try {
				 launcher.terminate();
			 }
			 catch (Exception e2) {
				 log.warn(""Subsequent error during termination: ""+e2);
				 log.debug(""Details of subsequent error during termination: ""+e2, e2);
			 }
			 Exceptions.propagate(e);
		 }
		 BrooklynServerDetails server = launcher.getServerDetails();
		 ManagementContext mgmt = server.getManagementContext();
		 if (verbose) {
			 Entities.dumpInfo(launcher.getApplications());
		 }
		 if (!exitAndLeaveAppsRunningAfterStarting) {
			 waitAfterLaunch(mgmt, shutdownHandler);
		 }
		 return null;
	 }
	 protected void customize(BrooklynLauncher launcher) {
	 }
	 protected void computeLocations() {
		 boolean hasLocations = !Strings.isBlank(locations);
		 if (app != null) {
			 if (hasLocations && isYamlApp()) {
				 log.info(""YAML app combined with command line locations;
				 YAML locations will take precedence;
				 this behaviour may change in subsequent versions"");
			 }
			 else if (!hasLocations && isYamlApp()) {
				 log.info(""No locations supplied;
				 defaulting to locations defined in YAML (if any)"");
			 }
			 else if (!hasLocations) {
				 log.info(""No locations supplied;
				 starting with no locations"");
			 }
		 }
		 else if (hasLocations) {
			 log.error(""Locations specified without any applications;
			 ignoring locations"");
		 }
	 }
	 protected boolean isYamlApp() {
		 return app != null && app.endsWith("".yaml"");
	 }
	 protected PersistMode computePersistMode() {
		 Maybe<PersistMode> persistMode = Enums.valueOfIgnoreCase(PersistMode.class, persist);
		 if (!persistMode.isPresent()) {
			 if (Strings.isBlank(persist)) {
				 throw new FatalConfigurationRuntimeException(""Persist mode must not be blank"");
			 }
			 else {
				 throw new FatalConfigurationRuntimeException(""Illegal persist setting: ""+persist);
			 }
		 }
		 if (persistMode.get() == PersistMode.DISABLED) {
			 if (Strings.isNonBlank(persistenceDir)) throw new FatalConfigurationRuntimeException(""Cannot specify persistenceDir when persist is disabled"");
			 if (Strings.isNonBlank(persistenceLocation)) throw new FatalConfigurationRuntimeException(""Cannot specify persistenceLocation when persist is disabled"");
		 }
		 return persistMode.get();
	 }
	 protected HighAvailabilityMode computeHighAvailabilityMode(PersistMode persistMode) {
		 Maybe<HighAvailabilityMode> highAvailabilityMode = Enums.valueOfIgnoreCase(HighAvailabilityMode.class, highAvailability);
		 if (!highAvailabilityMode.isPresent()) {
			 if (Strings.isBlank(highAvailability)) {
				 throw new FatalConfigurationRuntimeException(""High availability mode must not be blank"");
			 }
			 else {
				 throw new FatalConfigurationRuntimeException(""Illegal highAvailability setting: ""+highAvailability);
			 }
		 }
		 if (highAvailabilityMode.get() != HighAvailabilityMode.DISABLED) {
			 if (persistMode == PersistMode.DISABLED) {
				 if (highAvailabilityMode.get() == HighAvailabilityMode.AUTO) return HighAvailabilityMode.DISABLED;
				 throw new FatalConfigurationRuntimeException(""Cannot specify highAvailability when persistence is disabled"");
			 }
			 else if (persistMode == PersistMode.CLEAN && (highAvailabilityMode.get() == HighAvailabilityMode.STANDBY || highAvailabilityMode.get() == HighAvailabilityMode.HOT_STANDBY || highAvailabilityMode.get() == HighAvailabilityMode.HOT_BACKUP)) {
				 throw new FatalConfigurationRuntimeException(""Cannot specify highAvailability ""+highAvailabilityMode.get()+"" when persistence is CLEAN"");
			 }
		 }
		 return highAvailabilityMode.get();
	 }
	 protected StopWhichAppsOnShutdown computeStopWhichAppsOnShutdown() {
		 boolean isDefault = STOP_THESE_IF_NOT_PERSISTED.equals(stopWhichAppsOnShutdown);
		 if (exitAndLeaveAppsRunningAfterStarting && isDefault) {
			 return StopWhichAppsOnShutdown.NONE;
		 }
		 else {
			 return Enums.valueOfIgnoreCase(StopWhichAppsOnShutdown.class, stopWhichAppsOnShutdown).get();
		 }
	 }
	 public void useManagementContext(ManagementContext mgmt) {
		 explicitManagementContext = mgmt;
	 }
	 protected BrooklynLauncher createLauncher() {
		 BrooklynLauncher launcher;
		 launcher = BrooklynLauncher.newInstance();
		 launcher.localBrooklynPropertiesFile(localBrooklynProperties) .ignorePersistenceErrors(!startupFailOnPersistenceErrors) .ignoreCatalogErrors(!startupFailOnCatalogErrors) .ignoreWebErrors(startupContinueOnWebErrors) .ignoreAppErrors(!startupFailOnManagedAppsErrors) .locations(Strings.isBlank(locations) ? ImmutableList.<String>of() : JavaStringEscapes.unwrapJsonishListIfPossible(locations));
		 launcher.webconsole(!noConsole);
		 if (useHttps) {
			 launcher.webconsoleHttps(useHttps);
		 }
		 launcher.webconsolePort(port);
		 if (noGlobalBrooklynProperties) {
			 log.debug(""Configuring to disable global brooklyn.properties"");
			 launcher.globalBrooklynPropertiesFile(null);
		 }
		 if (noConsoleSecurity) {
			 log.info(""Configuring to disable console security"");
			 launcher.installSecurityFilter(false);
		 }
		 if (startBrooklynNode) {
			 log.info(""Configuring BrooklynNode entity startup"");
			 launcher.startBrooklynNode(true);
		 }
		 if (Strings.isNonEmpty(bindAddress)) {
			 log.debug(""Configuring bind address as ""+bindAddress);
			 launcher.bindAddress(Networking.getInetAddressWithFixedName(bindAddress));
		 }
		 if (Strings.isNonEmpty(publicAddress)) {
			 log.debug(""Configuring public address as ""+publicAddress);
			 launcher.publicAddress(Networking.getInetAddressWithFixedName(publicAddress));
		 }
		 if (explicitManagementContext!=null) {
			 log.debug(""Configuring explicit management context ""+explicitManagementContext);
			 launcher.managementContext(explicitManagementContext);
		 }
		 return launcher;
	 }
	 protected void populateCatalog(BrooklynCatalog catalog) {
	 }
	 protected void confirmCatalog(CatalogInitialization catInit) {
		 Stopwatch time = Stopwatch.createStarted();
		 BrooklynCatalog catalog = catInit.getManagementContext().getCatalog();
		 Iterable<CatalogItem<Object, Object>> items = catalog.getCatalogItems();
		 for (CatalogItem<Object, Object> item: items) {
			 try {
				 if (item.getCatalogItemType()==CatalogItemType.TEMPLATE) {
				 }
				 else {
					 Object spec = catalog.createSpec((CatalogItem)item);
					 if (spec instanceof EntitySpec) {
						 BrooklynTypes.getDefinedEntityType(((EntitySpec<?>)spec).getType());
					 }
					 log.debug(""Catalog loaded spec ""+spec+"" for item ""+item);
				 }
			 }
			 catch (Throwable throwable) {
				 catInit.handleException(throwable, item);
			 }
		 }
		 log.debug(""Catalog (size ""+Iterables.size(items)+"") confirmed in ""+Duration.of(time));
	 }
	 protected void setAppToLaunch(String className) {
		 if (app!=null) {
			 if (app.equals(className)) return;
			 throw new FatalConfigurationRuntimeException(""Cannot specify app '""+className+""' when '""+app+""' is already specified;
			 "" + ""remove one or more conflicting CLI arguments."");
		 }
		 app = className;
	 }
	 protected void computeAndSetApp(BrooklynLauncher launcher, ResourceUtils utils, GroovyClassLoader loader) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
		 if (app != null) {
			 log.debug(""Loading the user's application: {
			}
			"", app);
			 if (isYamlApp()) {
				 log.debug(""Loading application as YAML spec: {
				}
				"", app);
				 String content = utils.getResourceAsString(app);
				 launcher.application(content);
			 }
			 else {
				 Object loadedApp = loadApplicationFromClasspathOrParse(utils, loader, app);
				 if (loadedApp instanceof ApplicationBuilder) {
					 launcher.application((ApplicationBuilder)loadedApp);
				 }
				 else if (loadedApp instanceof Application) {
					 launcher.application((AbstractApplication)loadedApp);
				 }
				 else {
					 throw new FatalConfigurationRuntimeException(""Unexpected application type ""+(loadedApp==null ? null : loadedApp.getClass())+"", for app ""+loadedApp);
				 }
			 }
		 }
	 }
	 protected void waitAfterLaunch(ManagementContext ctx, AppShutdownHandler shutdownHandler) throws IOException {
		 if (stopOnKeyPress) {
			 log.info(""Server started. Press return to stop."");
			 Task<Void> readTask = ctx.getExecutionManager().submit(new Callable<Void>() {
				 public Void call() throws Exception {
					 stdin.read();
					 return null;
				 }
			 }
			);
			 while (!shutdownHandler.isRequested()) {
				 try {
					 readTask.get(Duration.ONE_SECOND);
					 break;
				 }
				 catch (TimeoutException e) {
				 }
				 catch (InterruptedException e) {
					 Thread.currentThread().interrupt();
					 throw Exceptions.propagate(e);
				 }
				 catch (ExecutionException e) {
					 throw Exceptions.propagate(e);
				 }
			 }
			 log.info(""Shutting down applications."");
			 stopAllApps(ctx.getApplications());
		 }
		 else {
			 log.info(""Launched Brooklyn;
			 will now block until shutdown command received via GUI/API (recommended) or process interrupt."");
			 shutdownHandler.waitOnShutdownRequest();
		 }
	 }
	 protected void execGroovyScript(ResourceUtils utils, GroovyClassLoader loader, String script) {
		 log.debug(""Running the user provided script: {
		}
		"", script);
		 String content = utils.getResourceAsString(script);
		 GroovyShell shell = new GroovyShell(loader);
		 shell.evaluate(content);
	 }
	 protected Object loadApplicationFromClasspathOrParse(ResourceUtils utils, GroovyClassLoader loader, String app) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
		 Class<?> tempclazz;
		 log.debug(""Loading application as class on classpath: {
		}
		"", app);
		 try {
			 tempclazz = loader.loadClass(app, true, false);
		 }
		 catch (ClassNotFoundException cnfe) {
			 log.debug(""Loading \""{
			}
			\"" as class on classpath failed, now trying as .groovy source file"", app);
			 String content = utils.getResourceAsString(app);
			 tempclazz = loader.parseClass(content);
		 }
		 final Class<?> clazz = tempclazz;
		 if (ApplicationBuilder.class.isAssignableFrom(clazz)) {
			 Constructor<?> constructor = clazz.getConstructor();
			 return (ApplicationBuilder) constructor.newInstance();
		 }
		 else if (StartableApplication.class.isAssignableFrom(clazz)) {
			 EntitySpec<? extends StartableApplication> appSpec;
			 if (tempclazz.isInterface()) appSpec = EntitySpec.create((Class<? extends StartableApplication>) clazz);
			 else appSpec = EntitySpec.create(StartableApplication.class, (Class<? extends StartableApplication>) clazz);
			 return new ApplicationBuilder(appSpec) {
				 protected void doBuild() {
				 }
			}
			;
		 }
		 else if (AbstractApplication.class.isAssignableFrom(clazz)) {
			 Constructor<?> constructor = clazz.getConstructor();
			 return (AbstractApplication) constructor.newInstance();
		 }
		 else if (AbstractEntity.class.isAssignableFrom(clazz)) {
			 return new ApplicationBuilder() {
				 protected void doBuild() {
					 addChild(EntitySpec.create(Entity.class).impl((Class<? extends AbstractEntity>)clazz).additionalInterfaces(clazz.getInterfaces()));
				 }
			}
			;
		 }
		 else if (Entity.class.isAssignableFrom(clazz)) {
			 return new ApplicationBuilder() {
				 protected void doBuild() {
					 addChild(EntitySpec.create((Class<? extends Entity>)clazz));
				 }
			}
			;
		 }
		 else {
			 throw new FatalConfigurationRuntimeException(""Application class ""+clazz+"" must extend one of ApplicationBuilder or AbstractApplication"");
		 }
	 }
	 protected void stopAllApps(Collection<? extends Application> applications) {
		 for (Application application : applications) {
			 try {
				 if (application instanceof Startable) {
					 ((Startable)application).stop();
				 }
			 }
			 catch (Exception e) {
				 log.error(""Error stopping ""+application+"": ""+e, e);
			 }
		 }
	 }
	 public ToStringHelper string() {
		 return super.string() .add(""app"", app) .add(""script"", script) .add(""location"", locations) .add(""port"", port) .add(""bindAddress"", bindAddress) .add(""noConsole"", noConsole) .add(""noConsoleSecurity"", noConsoleSecurity) .add(""startupFailOnPersistenceErrors"", startupFailOnPersistenceErrors) .add(""startupFailsOnCatalogErrors"", startupFailOnCatalogErrors) .add(""startupContinueOnWebErrors"", startupContinueOnWebErrors) .add(""startupFailOnManagedAppsErrors"", startupFailOnManagedAppsErrors) .add(""catalogInitial"", catalogInitial) .add(""catalogAdd"", catalogAdd) .add(""catalogReset"", catalogReset) .add(""catalogForce"", catalogForce) .add(""stopWhichAppsOnShutdown"", stopWhichAppsOnShutdown) .add(""stopOnKeyPress"", stopOnKeyPress) .add(""localBrooklynProperties"", localBrooklynProperties) .add(""persist"", persist) .add(""persistenceLocation"", persistenceLocation) .add(""persistenceDir"", persistenceDir) .add(""highAvailability"", highAvailability) .add(""exitAndLeaveAppsRunningAfterStarting"", exitAndLeaveAppsRunningAfterStarting);
	 }
 }",1,1,0,0
"public class ProxyDiagnostics {
	 private String destination;
	 private URI destURI;
	 public static final String DEFAULT_DESTINATION = ""http: public ProxyDiagnostics(String destination) {
		 this.destination = destination;
		 try {
			 this.destURI = new URI(destination);
		 }
		 catch (URISyntaxException e) {
			 throw new BuildException(e);
		 }
	 }
	 public ProxyDiagnostics() {
		 this(DEFAULT_DESTINATION);
	 }
	 public String toString() {
		 ProxySelector selector = ProxySelector.getDefault();
		 List list = selector.select(destURI);
		 StringBuffer result = new StringBuffer();
		 Iterator proxies = list.listIterator();
		 while (proxies.hasNext()) {
			 Proxy proxy = (Proxy) proxies.next();
			 SocketAddress address = proxy.address();
			 if (address == null) {
				 result.append(""Direct connection\n"");
			 }
			 else {
				 result.append(proxy.toString());
				 if (address instanceof InetSocketAddress) {
					 InetSocketAddress ina = (InetSocketAddress) address;
					 result.append(' ');
					 result.append(ina.getHostName());
					 result.append(':');
					 result.append(ina.getPort());
					 if (ina.isUnresolved()) {
						 result.append("" [unresolved]"");
					 }
					 else {
						 InetAddress addr = ina.getAddress();
						 result.append("" ["");
						 result.append(addr.getHostAddress());
						 result.append(']');
					 }
				 }
				 result.append('\n');
			 }
		 }
		 return result.toString();
	 }
}",0,0,0,0
"public class MailMessage {
	 public static final String DEFAULT_HOST = ""localhost"";
	 public static final int DEFAULT_PORT = 25;
	 private String host;
	 private int port = DEFAULT_PORT;
	 private String from;
	 private Vector replyto;
	 private Vector to;
	 private Vector cc;
	 private Vector headersKeys;
	 private Vector headersValues;
	 private MailPrintStream out;
	 private SmtpResponseReader in;
	 private Socket socket;
	 private static final int OK_READY = 220;
	 private static final int OK_HELO = 250;
	 private static final int OK_FROM = 250;
	 private static final int OK_RCPT_1 = 250;
	 private static final int OK_RCPT_2 = 251;
	 private static final int OK_DATA = 354;
	 private static final int OK_DOT = 250;
	 private static final int OK_QUIT = 221;
	 public MailMessage() throws IOException {
		 this(DEFAULT_HOST, DEFAULT_PORT);
	 }
	 public MailMessage(String host) throws IOException {
		 this(host, DEFAULT_PORT);
	 }
	 public MailMessage(String host, int port) throws IOException {
		 this.port = port;
		 this.host = host;
		 replyto = new Vector();
		 to = new Vector();
		 cc = new Vector();
		 headersKeys = new Vector();
		 headersValues = new Vector();
		 connect();
		 sendHelo();
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public void from(String from) throws IOException {
		 sendFrom(from);
		 this.from = from;
	 }
	 public void replyto(String rto) {
		 this.replyto.addElement(rto);
	 }
	 public void to(String to) throws IOException {
		 sendRcpt(to);
		 this.to.addElement(to);
	 }
	 public void cc(String cc) throws IOException {
		 sendRcpt(cc);
		 this.cc.addElement(cc);
	 }
	 public void bcc(String bcc) throws IOException {
		 sendRcpt(bcc);
	 }
	 public void setSubject(String subj) {
		 setHeader(""Subject"", subj);
	 }
	 public void setHeader(String name, String value) {
		 headersKeys.add(name);
		 headersValues.add(value);
	 }
	 public PrintStream getPrintStream() throws IOException {
		 setFromHeader();
		 setReplyToHeader();
		 setToHeader();
		 setCcHeader();
		 setHeader(""X-Mailer"", ""org.apache.tools.mail.MailMessage (ant.apache.org)"");
		 sendData();
		 flushHeaders();
		 return out;
	 }
	 void setFromHeader() {
		 setHeader(""From"", from);
	 }
	 void setReplyToHeader() {
		 if (!replyto.isEmpty()) {
			 setHeader(""Reply-To"", vectorToList(replyto));
		 }
	 }
	 void setToHeader() {
		 if (!to.isEmpty()) {
			 setHeader(""To"", vectorToList(to));
		 }
	 }
	 void setCcHeader() {
		 if (!cc.isEmpty()) {
			 setHeader(""Cc"", vectorToList(cc));
		 }
	 }
	 String vectorToList(Vector v) {
		 StringBuffer buf = new StringBuffer();
		 Enumeration e = v.elements();
		 while (e.hasMoreElements()) {
			 buf.append(e.nextElement());
			 if (e.hasMoreElements()) {
				 buf.append("", "");
			 }
		 }
		 return buf.toString();
	 }
	 void flushHeaders() throws IOException {
		 final int size = headersKeys.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 String name = (String) headersKeys.elementAt(i);
			 String value = (String) headersValues.elementAt(i);
			 out.println(name + "": "" + value);
		 }
		 out.println();
		 out.flush();
	 }
	 public void sendAndClose() throws IOException {
		 try {
			 sendDot();
			 sendQuit();
		 }
		 finally {
			 disconnect();
		 }
	 }
	 static String sanitizeAddress(String s) {
		 int paramDepth = 0;
		 int start = 0;
		 int end = 0;
		 int len = s.length();
		 for (int i = 0;
		 i < len;
		 i++) {
			 char c = s.charAt(i);
			 if (c == '(') {
				 paramDepth++;
				 if (start == 0) {
					 end = i;
				 }
			 }
			 else if (c == ')') {
				 paramDepth--;
				 if (end == 0) {
					 start = i + 1;
				 }
			 }
			 else if (paramDepth == 0 && c == '<') {
				 start = i + 1;
			 }
			 else if (paramDepth == 0 && c == '>') {
				 end = i;
			 }
		 }
		 if (end == 0) {
			 end = len;
		 }
		 return s.substring(start, end);
	 }
	 void connect() throws IOException {
		 socket = new Socket(host, port);
		 out = new MailPrintStream( new BufferedOutputStream( socket.getOutputStream()));
		 in = new SmtpResponseReader(socket.getInputStream());
		 getReady();
	 }
	 void getReady() throws IOException {
		 String response = in.getResponse();
		 int[] ok = {
		OK_READY}
		;
		 if (!isResponseOK(response, ok)) {
			 throw new IOException( ""Didn't get introduction from server: "" + response);
		 }
	 }
	 void sendHelo() throws IOException {
		 String local = InetAddress.getLocalHost().getHostName();
		 int[] ok = {
		OK_HELO}
		;
		 send(""HELO "" + local, ok);
	 }
	 void sendFrom(String from) throws IOException {
		 int[] ok = {
		OK_FROM}
		;
		 send(""MAIL FROM: "" + ""<"" + sanitizeAddress(from) + "">"", ok);
	 }
	 void sendRcpt(String rcpt) throws IOException {
		 int[] ok = {
		OK_RCPT_1, OK_RCPT_2}
		;
		 send(""RCPT TO: "" + ""<"" + sanitizeAddress(rcpt) + "">"", ok);
	 }
	 void sendData() throws IOException {
		 int[] ok = {
		OK_DATA}
		;
		 send(""DATA"", ok);
	 }
	 void sendDot() throws IOException {
		 int[] ok = {
		OK_DOT}
		;
		 send(""\r\n."", ok);
	 }
	 void sendQuit() throws IOException {
		 int[] ok = {
		OK_QUIT}
		;
		 try {
			 send(""QUIT"", ok);
		 }
		 catch (IOException e) {
			 throw new ErrorInQuitException(e);
		 }
	 }
	 void send(String msg, int[] ok) throws IOException {
		 out.rawPrint(msg + ""\r\n"");
		 String response = in.getResponse();
		 if (!isResponseOK(response, ok)) {
			 throw new IOException(""Unexpected reply to command: "" + msg + "": "" + response);
		 }
	 }
	 boolean isResponseOK(String response, int[] ok) {
		 for (int i = 0;
		 i < ok.length;
		 i++) {
			 if (response.startsWith("""" + ok[i])) {
				 return true;
			 }
		 }
		 return false;
	 }
	 void disconnect() throws IOException {
		 if (out != null) {
			 out.close();
		 }
		 if (in != null) {
			 try {
				 in.close();
			 }
			 catch (IOException e) {
			 }
		 }
		 if (socket != null) {
			 try {
				 socket.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
}
class MailPrintStream extends PrintStream {
	 private int lastChar;
	 public MailPrintStream(OutputStream out) {
		 super(out, true);
	 }
	 public void write(int b) {
		 if (b == '\n' && lastChar != '\r') {
			 rawWrite('\r');
			 rawWrite(b);
		 }
		 else if (b == '.' && lastChar == '\n') {
			 rawWrite('.');
			 rawWrite(b);
		 }
		 else {
			 rawWrite(b);
		 }
		 lastChar = b;
	 }
	 public void write(byte[] buf, int off, int len) {
		 for (int i = 0;
		 i < len;
		 i++) {
			 write(buf[off + i]);
		 }
	 }
	 void rawWrite(int b) {
		 super.write(b);
	 }
	 void rawPrint(String s) {
		 int len = s.length();
		 for (int i = 0;
		 i < len;
		 i++) {
			 rawWrite(s.charAt(i));
		 }
	 }
}",0,0,0,0
"public class UML2JagGenerator {
	 private ConsoleLogger logger;
	 private static SimpleModel model;
	 static Log log = LogFactory.getLog(UML2JagGenerator.class);
	 private static final String DEFAULT_SQL_TYPE = ""VARCHAR(255)"";
	 private static final String CHARACTER_PRIMITIVE = ""char"";
	 private static final String CHARACTER_CLASS = ""java.lang.Character"";
	 private static final String JAVA_LANG_PACKAGE_PREFIX = ""java.lang."";
	 private static final char DOT = '.';
	 private static final String EMPTY_STRING = """";
	 private static final String INTEGER_PRIMITIVE = ""int"";
	 private static final String INTEGER_CLASS = ""java.lang.Integer"";
	 private static final String DEFAULT_JDBC_TYPE = ""VARCHAR"";
	 private static final String NUMBER_SQL_TYPE = ""NUMBER"";
	 private static final String TIMESTAMP_SQL_TYPE = ""DATE"";
	 private static final String BIGINT_JDBC_TYPE = ""BIGINT"";
	 public UML2JagGenerator(ConsoleLogger logger) {
		 this.logger = logger;
		 model = new SimpleModel();
	 }
	 public UML2JagGenerator() {
		 model = new SimpleModel();
	 }
	 public synchronized File generateXML(String xmiFileName, String outputDir) {
		 URL url = null;
		 try {
			 url = new URL(""FILE"", EMPTY_STRING, xmiFileName);
		 }
		 catch (MalformedURLException e) {
			 e.printStackTrace();
		 }
		 model.readModel(url);
		 try {
			 checkInterruptStatus();
			 return generateXML(model, outputDir);
		 }
		 catch (InterruptedException e) {
			 e.printStackTrace();
		 }
		 return null;
	 }
	 private File generateXML(SimpleModel model, String outputDir) throws InterruptedException {
		 File file = null;
		 Root root = generateConfig(model);
		 checkInterruptStatus();
		 try {
			 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			 DocumentBuilder builder = dbf.newDocumentBuilder();
			 Document doc = builder.newDocument();
			 org.w3c.dom.Element skelet = doc.createElement(""skelet"");
			 doc.appendChild(skelet);
			 root.getXML(skelet);
			 String XMLDoc = com.finalist.jaggenerator.JagGenerator.outXML(doc);
			 log.debug(""The generated xml project file is: "");
			 log.debug(XMLDoc);
			 file = new File(outputDir, model.getName() + "".xml"");
			 checkInterruptStatus();
			 OutputStream outputStream = new FileOutputStream(file);
			 outputStream.write(XMLDoc.getBytes());
			 outputStream.flush();
			 outputStream.close();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 log(""Error writing the file."");
		 }
		 return file;
	 }
	 private Root generateConfig(SimpleModel model) throws InterruptedException {
		 Root root = new Root();
		 createDataSource(model, root.datasource);
		 createConfig(model, root.config, root.app, root.paths);
		 checkInterruptStatus();
		 HashMap sessionEJBMap = createSessionEJBs(model);
		 if (sessionEJBMap != null && sessionEJBMap.size() > 0) {
			 root.setSessionEjbs(new ArrayList(sessionEJBMap.values()));
		 }
		 checkInterruptStatus();
		 HashMap entityEJBMap = createEntityEJBs(model);
		 if (entityEJBMap != null && entityEJBMap.size() > 0) {
			 root.setEntityEjbs(new ArrayList(entityEJBMap.values()));
		 }
		 checkInterruptStatus();
		 createContainerManagedRelations(entityEJBMap, model);
		 return root;
	 }
	 private void checkInterruptStatus() throws InterruptedException {
		 if (Thread.interrupted()) {
			 throw new InterruptedException();
		 }
	 }
	 private HashMap createEntityEJBs(SimpleModel model) {
		 HashMap map = new HashMap();
		 Collection pkList = model.getAllSimpleUmlPackages(model);
		 for (Iterator pkIterator = pkList.iterator();
		 pkIterator.hasNext();
		) {
			 SimpleUmlPackage simpleUmlPackage = (SimpleUmlPackage) pkIterator.next();
			 Collection list;
			 list = simpleUmlPackage.getSimpleClassifiers();
			 for (Iterator pkit = list.iterator();
			 pkit.hasNext();
			) {
				 SimpleModelElement el = (SimpleModelElement) pkit.next();
				 if ((el instanceof SimpleUmlClass) && model.getStereoType(el) != null && model.getStereoType(el).equalsIgnoreCase(JagUMLProfile.STEREOTYPE_CLASS_ENTITY)) {
					 SimpleUmlClass suc = (SimpleUmlClass) el;
					 String rootPackage = simpleUmlPackage.getFullPackageName();
					 String tableName = getTaggedValue(model, JagUMLProfile.TAGGED_VALUE_CLASS_TABLE_NAME, suc, Utils.unformat(Utils.firstToLowerCase(suc.getName())));
					 Entity entity = new Entity(EMPTY_STRING, tableName, EMPTY_STRING);
					 entity.setRootPackage(rootPackage);
					 entity.setName(suc.getName());
					 entity.setDescription(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, suc));
					 if (model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DISPLAY_NAME, suc) != null) {
						 entity.setDisplayName(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DISPLAY_NAME, suc));
					 }
					 if (model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_IS_ASSOCIATION, suc) != null) {
						 entity.isAssociationEntity.setSelectedItem(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_IS_ASSOCIATION, suc));
					 }
					 entity.setRefName(entity.getName().toString());
					 int pkCount = 0;
					 Collection attributes = suc.getSimpleAttributes();
					 Field primaryKeyField = null;
					 for (Iterator iterator = attributes.iterator();
					 iterator.hasNext();
					) {
						 SimpleAttribute att = (SimpleAttribute) iterator.next();
						 boolean isPK = equal(model.getStereoType(att), JagUMLProfile.STEREOTYPE_ATTRIBUTE_PRIMARY_KEY);
						 boolean required = false;
						 if (isPK) {
							 required = true;
						 }
						 else {
							 required = equal(model.getStereoType(att), JagUMLProfile.STEREOTYPE_ATTRIBUTE_REQUIRED);
						 }
						 Column col = new Column();
						 String colName = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_COLUMN_NAME, att);
						 if (colName == null) {
							 colName = Utils.unformat(att.getName());
						 }
						 col.setName(colName);
						 String sqlType = getTaggedValue(model, JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_SQL_TYPE, att, null);
						 String jdbcType = getTaggedValue(model, JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_JDBC_TYPE, att, null);
						 col.setPrimaryKey(isPK);
						 col.setNullable(!required);
						 SimpleClassifier theClassifier = att.getType();
						 String fieldType = theClassifier.getOwner().getFullPackageName();
						 if (fieldType != null && !Character.isLowerCase(theClassifier.getName().charAt(0))) {
							 fieldType = fieldType + DOT + theClassifier.getName();
						 }
						 else {
							 String primitiveType = theClassifier.getName();
							 if (CHARACTER_PRIMITIVE.equals(primitiveType)) {
								 fieldType = CHARACTER_CLASS;
							 }
							 else if (INTEGER_PRIMITIVE.equals(primitiveType)) {
								 fieldType = INTEGER_CLASS;
							 }
							 else {
								 fieldType = JAVA_LANG_PACKAGE_PREFIX + Character.toUpperCase(primitiveType.charAt(0)) + primitiveType.substring(1);
							 }
						 }
						 if (sqlType == null) {
							 String[] mappedTypes = getDatabaseColumnTypesForClass(fieldType);
							 sqlType = mappedTypes[0];
							 jdbcType = mappedTypes[1];
						 }
						 col.setSqlType(sqlType);
						 String autoGeneratedPrimaryKey = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_AUTO_PRIMARY_KEY, att);
						 boolean generate = false;
						 if (""true"".equalsIgnoreCase(autoGeneratedPrimaryKey)) {
							 generate = true;
						 }
						 Field field = new Field(entity, col);
						 field.setName(att.getName());
						 field.setType(fieldType);
						 if (isPK) {
							 field.setPrimaryKey(isPK);
						 }
						 field.setSqlType(sqlType);
						 field.setJdbcType(jdbcType);
						 field.setHasAutoGenPrimaryKey(generate);
						 if (isPK) {
							 pkCount++;
							 primaryKeyField = field;
						 }
						 entity.add(field);
					 }
					 if (pkCount > 1) {
						 entity.setIsComposite(""true"");
						 String compositePK = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_COMPOSITE_PRIMARY_KEY, suc);
						 entity.setPKeyType(compositePK);
					 }
					 else {
						 if (primaryKeyField != null) {
							 entity.setPrimaryKey(primaryKeyField);
						 }
					 }
					 if (pkCount == 0) {
						 log(""UML Error! Entity '"" + entity.getName() + ""' has no primary key! At least one attribute "" + ""in an entity bean must have the stereotype \""PrimaryKey\""."");
						 JOptionPane.showMessageDialog(null, ""Entity '"" + entity.getName() + ""' has no primary key! At least one attribute "" + ""in an entity bean must have the stereotype \""PrimaryKey\""."", ""UML Error!"", JOptionPane.ERROR_MESSAGE);
					 }
					 else {
						 map.put(entity.getRefName(), entity);
					 }
				 }
			 }
		 }
		 return map;
	 }
	 private String[] getDatabaseColumnTypesForClass(String javaClass) {
		 if (Byte.class.getName().equals(javaClass) || Short.class.getName().equals(javaClass) || Integer.class.getName().equals(javaClass) || Long.class.getName().equals(javaClass) || Double.class.getName().equals(javaClass)) {
			 return new String[] {
			NUMBER_SQL_TYPE, BIGINT_JDBC_TYPE}
			;
		 }
		 if (java.sql.Timestamp.class.getName().equals(javaClass) || java.sql.Date.class.getName().equals(javaClass) || java.util.Date.class.getName().equals(javaClass)) {
			 return new String[] {
			TIMESTAMP_SQL_TYPE, TIMESTAMP_SQL_TYPE}
			;
		 }
		 return new String[] {
		DEFAULT_SQL_TYPE, DEFAULT_JDBC_TYPE}
		;
	 }
	 private String getTaggedValue(SimpleModel model, String taggedValueAttributeSqlType, SimpleModelElement att, String defaultValue) {
		 String value = model.getTaggedValue(taggedValueAttributeSqlType, att);
		 return value == null ? defaultValue : value;
	 }
	 private HashMap createSessionEJBs(SimpleModel model) {
		 HashMap map = new HashMap();
		 Collection pkList = model.getAllSimpleUmlPackages(model);
		 for (Iterator pkIterator = pkList.iterator();
		 pkIterator.hasNext();
		) {
			 SimpleUmlPackage simpleUmlPackage = (SimpleUmlPackage) pkIterator.next();
			 Collection list = simpleUmlPackage.getSimpleClassifiers();
			 for (Iterator it = list.iterator();
			 it.hasNext();
			) {
				 SimpleModelElement el = (SimpleModelElement) it.next();
				 if ((el instanceof SimpleUmlClass) && model.getStereoType(el) != null && model.getStereoType(el).equals(JagUMLProfile.STEREOTYPE_CLASS_SERVICE)) {
					 ArrayList businessMethods = new ArrayList();
					 SimpleUmlClass suc = (SimpleUmlClass) el;
					 Collection operations = suc.getSimpleOperations();
					 for (Iterator oit = operations.iterator();
					 oit.hasNext();
					) {
						 BusinessMethod bm = new BusinessMethod();
						 SimpleOperation operation = (SimpleOperation) oit.next();
						 log.info(""The operation name is: "" + operation.getName());
						 bm.setMethodName(operation.getName());
						 String desc = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, operation);
						 if (desc == null) {
							 bm.setDescription("""");
						 }
						 else {
							 bm.setDescription(desc);
						 }
						 ArrayList argList = new ArrayList();
						 log.info(""The number of parameters: "" + operation.getSimpleParameters().size());
						 for (Iterator pit = operation.getSimpleParameters().iterator();
						 pit.hasNext();
						) {
							 SimpleParameter param = (SimpleParameter) pit.next();
							 BusinessArgument arg = new BusinessArgument();
							 String type;
							 log.debug(""Param kind: "" + param.getKind());
							 if (param.getType() != null) {
								 if (param.getType().getName() != null && param.getType().getName().equalsIgnoreCase(""void"")) {
									 type = ""void"";
								 }
								 else {
									 String packageName = param.getType().getOwner().getFullPackageName();
									 if (packageName == null) {
										 packageName = """";
									 }
									 else {
										 packageName = param.getType().getOwner().getFullPackageName() + ""."";
									 }
									 String typeName = param.getType().getName();
									 if (typeName != null) {
										 if (typeName.startsWith(""java::lang::"")) {
											 typeName = typeName.substring(12);
										 }
									 }
									 type = """" + packageName + typeName;
								 }
							 }
							 else {
								 type = ""void"";
							 }
							 if (param.getKind().equalsIgnoreCase(SimpleParameter.RETURN)) {
								 log.info(""Found a return type"");
								 bm.setReturnType(type);
							 }
							 else {
								 log.info(""The param name is: "" + param.getName());
								 arg.setName(param.getName());
								 log.info(""The param type is: "" + type);
								 arg.setType(type);
								 argList.add(arg);
							 }
						 }
						 bm.setArgumentList(argList);
						 businessMethods.add(bm);
					 }
					 String rootPackage = simpleUmlPackage.getFullPackageName();
					 Session session = new Session(rootPackage);
					 session.setName(suc.getName());
					 session.setRootPackage(rootPackage);
					 session.setRefName(suc.getName());
					 session.setDescription(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, suc));
					 session.setBusinessMethods(businessMethods);
					 Collection deps = model.getSimpleDependencies();
					 for (Iterator iterator = deps.iterator();
					 iterator.hasNext();
					) {
						 SimpleDependency sd = (SimpleDependency) iterator.next();
						 if (sd.getClient().getName().equals(session.getName().toString())) {
							 String entityRef = sd.getSupplier().getName();
							 session.addRef(entityRef);
						 }
					 }
					 map.put(session.getRefName(), session);
				 }
			 }
		 }
		 return map;
	 }
	 private void createContainerManagedRelations(HashMap entityEJBMap, SimpleModel simpleModel) {
		 Iterator assocs = simpleModel.getSimpleAssociations().iterator();
		 while (assocs.hasNext()) {
			 SimpleAssociation assoc = (SimpleAssociation) assocs.next();
			 String sourceEntityName = assoc.getSource().getSimpleClassifier().getName();
			 String destinationEntityName = assoc.getDestination().getSimpleClassifier().getName();
			 Entity sourceEntity = (Entity) entityEJBMap.get(sourceEntityName);
			 Entity destinationEntity = (Entity) entityEJBMap.get(destinationEntityName);
			 boolean multiplicity;
			 boolean bidirectional;
			 if (JagUMLProfile.TAGGED_VALUE_ASSOCIATION_MULTIPLICITY_ONE_TO_ONE.equals(simpleModel.getTaggedValue(JagUMLProfile.TAGGED_VALUE_ASSOCIATION_MULTIPLICITY, assoc))) {
				 multiplicity = false;
			 }
			 else {
				 multiplicity = true;
			 }
			 if (""true"".equals(simpleModel.getTaggedValue(JagUMLProfile.TAGGED_VALUE_ASSOCIATION_BIDIRECTIONAL, assoc))) {
				 bidirectional = true;
			 }
			 else {
				 bidirectional = false;
			 }
			 if (sourceEntity == null || destinationEntity == null) {
				 log(""The relation named '"" + assoc.getName() + ""' has 1 or more 'association ends' "" + ""whose names do not correspond to entity bean class names"");
				 continue;
			 }
			 ForeignKey info = new ForeignKey();
			 String fkFieldName = assoc.getName();
			 String fkColumnName = null;
			 Iterator i = sourceEntity.getFields().iterator();
			 while (i.hasNext()) {
				 Field field = (Field) i.next();
				 if (field.getName().equals(fkFieldName)) {
					 fkColumnName = field.getColumnName();
				 }
			 }
			 info.setPkTableName(destinationEntity.getLocalTableName().toString());
			 info.setPkColumnName(destinationEntity.getPrimaryKey().getColumnName());
			 info.setFkColumnName(fkColumnName);
			 info.setFkName(fkFieldName);
			 Relation relation = new Relation(sourceEntity, info, false);
			 relation.setBidirectional(bidirectional);
			 relation.setTargetMultiple(multiplicity);
			 sourceEntity.addRelation(relation);
			 log(""Added relation: "" + relation);
		 }
	 }
	 private void log(String message) {
		 log.info(message);
		 if (logger != null) {
			 logger.log(message);
		 }
	 }
	 private void createDataSource(SimpleModel model, Datasource ds) {
		 boolean datasourceFound = false;
		 Collection pkList = model.getAllSimpleUmlPackages(model);
		 for (Iterator pkIterator = pkList.iterator();
		 pkIterator.hasNext();
		) {
			 SimpleUmlPackage simpleUmlPackage = (SimpleUmlPackage) pkIterator.next();
			 Collection list = simpleUmlPackage.getSimpleClassifiers();
			 for (Iterator it = list.iterator();
			 it.hasNext();
			) {
				 SimpleModelElement el = (SimpleModelElement) it.next();
				 if ((el instanceof SimpleUmlClass) && model.getStereoType(el) != null && model.getStereoType(el).equals(JagUMLProfile.STEREOTYPE_CLASS_DATA_SOURCE)) {
					 datasourceFound = true;
					 ds.setJndi(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_JNDI_NAME, el));
					 ds.setMapping(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_MAPPING, el));
					 ds.setJdbcUrl(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_JDBC_URL, el));
					 ds.setUserName(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_USER_NAME, el));
					 ds.setPassword(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DATA_SOURCE_PASSWORD, el));
				 }
			 }
		 }
		 if (!datasourceFound) {
			 ds.setJndi(""jdbc/"" + model.getName());
		 }
	 }
	 private void createConfig(SimpleModel model, Config config, App app, Paths paths) {
		 Collection pkList = model.getAllSimpleUmlPackages(model);
		 for (Iterator pkIterator = pkList.iterator();
		 pkIterator.hasNext();
		) {
			 SimpleUmlPackage simpleUmlPackage = (SimpleUmlPackage) pkIterator.next();
			 Collection list = simpleUmlPackage.getSimpleClassifiers();
			 for (Iterator it = list.iterator();
			 it.hasNext();
			) {
				 SimpleModelElement el = (SimpleModelElement) it.next();
				 if ((el instanceof SimpleUmlClass) && model.getStereoType(el) != null && model.getStereoType(el).equals(JagUMLProfile.STEREOTYPE_CLASS_JAG_CONFIG)) {
					 config.setAuthor(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_AUTHOR, el));
					 config.setVersion(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_VERSION, el));
					 config.setCompany(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_COMPANY, el));
					 String templateDir = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_TEMPLATE, el);
					 if (templateDir != null) {
						 File dir = new File(templateDir);
						 config.getTemplate().setTemplateDir(dir);
					 }
					 HashMap map = new HashMap();
					 map.put(JagGenerator.TEMPLATE_APPLICATION_SERVER, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_APPSERVER, el));
					 map.put(JagGenerator.TEMPLATE_USE_RELATIONS, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_USE_RELATIONS, el));
					 map.put(JagGenerator.TEMPLATE_USE_JAVA5, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_USE_JAVA5, el));
					 map.put(JagGenerator.TEMPLATE_USE_MOCK, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_USE_MOCK, el));
					 map.put(JagGenerator.TEMPLATE_WEB_TIER, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_WEB_TIER, el));
					 map.put(JagGenerator.TEMPLATE_BUSINESS_TIER, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_BUSINESS_TIER, el));
					 map.put(JagGenerator.TEMPLATE_SERVICE_TIER, model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CONFIG_SERVICE_TIER, el));
					 config.setTemplateSettings(map);
					 app.setName(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_APPLICATION_NAME, el));
					 app.setDescription(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_DESCRIPTION, el));
					 app.setVersion(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_APPLICATION_VERSION, el));
					 app.setRootPackage(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_ROOT_PACKAGE, el));
					 app.setLogFramework(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_LOGGING, el));
					 app.setDateFormat(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_DATE_FORMAT, el));
					 app.setTimestampFormat(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_TIMESTAMP_FORMAT, el));
					 paths.setServiceOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_SERVICE_PATH, el));
					 paths.setEjbOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_EJB_PATH, el));
					 paths.setWebOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_WEB_PATH, el));
					 paths.setJspOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_JSP_PATH, el));
					 paths.setTestOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_TEST_PATH, el));
					 paths.setConfigOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_CONFIG_PATH, el));
					 paths.setSwingOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_SWING_PATH, el));
					 paths.setMockOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_MOCK_PATH, el));
					 paths.setHibernateOutput(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_MODEL_HIBERNATE_PATH, el));
				 }
			 }
		 }
	 }
	 private boolean equal(String a, String b) {
		 if (a != null && b != null && a.equals(b)) {
			 return true;
		 }
		 else return false;
	 }
	 public static void main(String[] args) {
		 if (args.length == 1) {
			 new UML2JagGenerator().generateXML(args[0], ""."");
		 }
		 else {
			 System.out.println(""Pass an xmi file as argument!"");
		 }
	 }
}",1,0,0,0
"public void addBundleListener(BundleListener l) {
	 checkValidity();
	 Object sm = System.getSecurityManager();
	 if (sm != null) {
		 if (l instanceof SynchronousBundleListener) {
			 ((SecurityManager) sm).checkPermission(new AdminPermission(m_bundle, AdminPermission.LISTENER));
		 }
	 }
	 m_felix.addBundleListener(m_bundle, l);
 }",0,0,0,0
"HttpURLConnection getResponse(final HttpURLConnection conn) throws IOException {
	 return conn;
 }",0,0,0,0
"public String toString() {
	 return ""Double Constant Pool Entry: "" + getValue();
 }",0,0,0,0
"private void writeJSON( final Writer pw, final ServiceReference service, final boolean fullDetails, final Locale locale, final String filter ) throws IOException {
	 final ServiceReference[] allServices = this.getServices(filter);
	 final String statusLine = getStatusLine( allServices );
	 final ServiceReference[] services = ( service != null ) ? new ServiceReference[] {
	 service }
	 : allServices;
	 final JSONWriter jw = new JSONWriter( pw );
	 jw.object();
	 jw.key( ""status"" );
	 jw.value( statusLine );
	 jw.key( ""serviceCount"" );
	 jw.value( allServices.length );
	 jw.key( ""data"" );
	 jw.array();
	 for ( int i = 0;
	 i < services.length;
	 i++ ) {
		 serviceInfo( jw, services[i], fullDetails || service != null, locale );
	 }
	 jw.endArray();
	 jw.endObject();
 }",0,0,1,0
"public class MetaDataFactoryImpl extends EFactoryImpl implements MetaDataFactory{
	 public static MetaDataFactory init() {
		 try {
			 MetaDataFactory theMetaDataFactory = (MetaDataFactory)EPackage.Registry.INSTANCE.getEFactory(MetaDataPackage.eNS_URI);
			 if (theMetaDataFactory != null) {
				 return theMetaDataFactory;
			 }
		 }
		 catch (Exception exception) {
			 EcorePlugin.INSTANCE.log(exception);
		 }
		 return new MetaDataFactoryImpl();
	 }
	 public MetaDataFactoryImpl() {
		 super();
	 }
	 public EObject create(EClass eClass) {
		 switch (eClass.getClassifierID()) {
			 case MetaDataPackage.MD_MODEL: return createMdModel();
			 case MetaDataPackage.MD_BUNDLE: return createMdBundle();
			 case MetaDataPackage.MD_BUNDLE_MEMBER: return createMdBundleMember();
			 case MetaDataPackage.MD_GROUP_OR_OPTION: return createMdGroupOrOption();
			 case MetaDataPackage.MD_GROUP: return createMdGroup();
			 case MetaDataPackage.MD_OPTION: return createMdOption();
			 case MetaDataPackage.MD_OPTION_DEPENDENCY: return createMdOptionDependency();
			 case MetaDataPackage.MD_ALGORITHM: return createMdAlgorithm();
			 case MetaDataPackage.MD_CATEGORY: return createMdCategory();
			 case MetaDataPackage.MD_OPTION_SUPPORT: return createMdOptionSupport();
			 default: throw new IllegalArgumentException(""The class '"" + eClass.getName() + ""' is not a valid classifier"");
		 }
	 }
	 public Object createFromString(EDataType eDataType, String initialValue) {
		 switch (eDataType.getClassifierID()) {
			 case MetaDataPackage.MD_OPTION_TARGET_TYPE: return createMdOptionTargetTypeFromString(eDataType, initialValue);
			 case MetaDataPackage.MD_GRAPH_FEATURE: return createMdGraphFeatureFromString(eDataType, initialValue);
			 default: throw new IllegalArgumentException(""The datatype '"" + eDataType.getName() + ""' is not a valid classifier"");
		 }
	 }
	 public String convertToString(EDataType eDataType, Object instanceValue) {
		 switch (eDataType.getClassifierID()) {
			 case MetaDataPackage.MD_OPTION_TARGET_TYPE: return convertMdOptionTargetTypeToString(eDataType, instanceValue);
			 case MetaDataPackage.MD_GRAPH_FEATURE: return convertMdGraphFeatureToString(eDataType, instanceValue);
			 default: throw new IllegalArgumentException(""The datatype '"" + eDataType.getName() + ""' is not a valid classifier"");
		 }
	 }
	 public MdModel createMdModel() {
		 MdModelImpl mdModel = new MdModelImpl();
		 return mdModel;
	 }
	 public MdBundle createMdBundle() {
		 MdBundleImpl mdBundle = new MdBundleImpl();
		 return mdBundle;
	 }
	 public MdBundleMember createMdBundleMember() {
		 MdBundleMemberImpl mdBundleMember = new MdBundleMemberImpl();
		 return mdBundleMember;
	 }
	 public MdGroupOrOption createMdGroupOrOption() {
		 MdGroupOrOptionImpl mdGroupOrOption = new MdGroupOrOptionImpl();
		 return mdGroupOrOption;
	 }
	 public MdGroup createMdGroup() {
		 MdGroupImpl mdGroup = new MdGroupImpl();
		 return mdGroup;
	 }
	 public MdOption createMdOption() {
		 MdOptionImpl mdOption = new MdOptionImpl();
		 return mdOption;
	 }
	 public MdOptionDependency createMdOptionDependency() {
		 MdOptionDependencyImpl mdOptionDependency = new MdOptionDependencyImpl();
		 return mdOptionDependency;
	 }
	 public MdAlgorithm createMdAlgorithm() {
		 MdAlgorithmImpl mdAlgorithm = new MdAlgorithmImpl();
		 return mdAlgorithm;
	 }
	 public MdCategory createMdCategory() {
		 MdCategoryImpl mdCategory = new MdCategoryImpl();
		 return mdCategory;
	 }
	 public MdOptionSupport createMdOptionSupport() {
		 MdOptionSupportImpl mdOptionSupport = new MdOptionSupportImpl();
		 return mdOptionSupport;
	 }
	 public MdOptionTargetType createMdOptionTargetTypeFromString(EDataType eDataType, String initialValue) {
		 MdOptionTargetType result = MdOptionTargetType.get(initialValue);
		 if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		 return result;
	 }
	 public String convertMdOptionTargetTypeToString(EDataType eDataType, Object instanceValue) {
		 return instanceValue == null ? null : instanceValue.toString();
	 }
	 public MdGraphFeature createMdGraphFeatureFromString(EDataType eDataType, String initialValue) {
		 MdGraphFeature result = MdGraphFeature.get(initialValue);
		 if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		 return result;
	 }
	 public String convertMdGraphFeatureToString(EDataType eDataType, Object instanceValue) {
		 return instanceValue == null ? null : instanceValue.toString();
	 }
	 public MetaDataPackage getMetaDataPackage() {
		 return (MetaDataPackage)getEPackage();
	 }
	 public static MetaDataPackage getPackage() {
		 return MetaDataPackage.eINSTANCE;
	 }
}",1,0,0,0
"public class ProviderCreditReversalDetails {
	 protected String amazonProviderCreditReversalId;
	 protected String sellerId;
	 protected String providerSellerId;
	 protected String creditReversalReferenceId;
	 protected Price creditReversalAmount;
	 protected XMLGregorianCalendar creationTimestamp;
	 protected Status creditReversalStatus;
	 protected String creditReversalNote;
	 public ProviderCreditReversalDetails() {
		 super();
	 }
	 public String getAmazonProviderCreditReversalId() {
		 return amazonProviderCreditReversalId;
	 }
	 public String getSellerId() {
		 return sellerId;
	 }
	 public String getProviderSellerId() {
		 return providerSellerId;
	 }
	 public String getCreditReversalReferenceId() {
		 return creditReversalReferenceId;
	 }
	 public Price getCreditReversalAmount() {
		 return creditReversalAmount;
	 }
	 public XMLGregorianCalendar getCreationTimestamp() {
		 return creationTimestamp;
	 }
	 public Status getCreditReversalStatus() {
		 return creditReversalStatus;
	 }
	 public String getCreditReversalNote() {
		 return creditReversalNote;
	 }
	 public String toString() {
		 return ""ProviderCreditReversalDetails{
		"" + ""amazonProviderCreditReversalId="" + amazonProviderCreditReversalId + "", sellerId="" + sellerId + "", providerId="" + providerSellerId + "", creditReversalReferenceId="" + creditReversalReferenceId + "", creditReversalAmount="" + creditReversalAmount + "", creationTimestamp="" + creationTimestamp + "", creditReversalStatus="" + creditReversalStatus + "", creditReversalNote="" + creditReversalNote + '}
		';
	 }
}",0,1,0,0
